[
    {
        "title": "Non-decreasing Subsequences",
        "question_content": "Given an integer array nums, return all the different possible non-decreasing subsequences of the given array with at least two elements. You may return the answer in any order.\n&nbsp;\nExample 1:\n\nInput: nums = [4,6,7,7]\nOutput: [[4,6],[4,6,7],[4,6,7,7],[4,7],[4,7,7],[6,7],[6,7,7],[7,7]]\n\nExample 2:\n\nInput: nums = [4,4,3,2,1]\nOutput: [[4,4]]\n\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 15\n\t-100 <= nums[i] <= 100",
        "solutions": [
            {
                "id": 3075096,
                "title": "c-easy-solution-backtracking-approach-heavily-commented",
                "content": "## **\\u2705\\u2705C++ || Easy Solution || \\uD83D\\uDCAF\\uD83D\\uDCAFBackTracking Approach || Heavily Commented**\\n# **Please Upvote as it really motivates me**\\n<iframe src=\"https://leetcode.com/playground/hkB62Xcn/shared\" frameBorder=\"0\" width=\"700\" height=\"730\"></iframe>\\n\\n***Time Complexity : `O(2^N*N^2)`\\nSpace Complexity : `O(2^N*N)`***\\n![image](https://assets.leetcode.com/users/images/7a02f26e-85ff-49b8-a932-503cce48097c_1674184823.1043508.png)\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "## **\\u2705\\u2705C++ || Easy Solution || \\uD83D\\uDCAF\\uD83D\\uDCAFBackTracking Approach || Heavily Commented**\\n# **Please Upvote as it really motivates me**\\n<iframe src=\"https://leetcode.com/playground/hkB62Xcn/shared\" frameBorder=\"0\" width=\"700\" height=\"730\"></iframe>\\n\\n***Time Complexity : `O(2^N*N^2)`\\nSpace Complexity : `O(2^N*N)`***\\n![image](https://assets.leetcode.com/users/images/7a02f26e-85ff-49b8-a932-503cce48097c_1674184823.1043508.png)\\n\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 97147,
                "title": "java-solution-beats-100",
                "content": "```\\npublic class Solution {\\n    public List<List<Integer>> findSubsequences(int[] nums) {\\n        List<List<Integer>> res = new LinkedList<>();\\n        helper(new LinkedList<Integer>(), 0, nums, res);\\n        return res; \\n    }\\n    private void helper(LinkedList<Integer> list, int index, int[] nums, List<List<Integer>> res){\\n        if(list.size()>1) res.add(new LinkedList<Integer>(list));\\n        Set<Integer> used = new HashSet<>();\\n        for(int i = index; i<nums.length; i++){\\n            if(used.contains(nums[i])) continue;\\n            if(list.size()==0 || nums[i]>=list.peekLast()){\\n                used.add(nums[i]);\\n                list.add(nums[i]); \\n                helper(list, i+1, nums, res);\\n                list.remove(list.size()-1);\\n            }\\n        }\\n    }\\n}\\n```\\n\\nPretty straightforward. Maybe one thing is: while nums is not necessarily sorted but we have to skip duplicates in each recursion, so we use a hash set to record what we have used in this particular recursion.",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public List<List<Integer>> findSubsequences(int[] nums) {\\n        List<List<Integer>> res = new LinkedList<>();\\n        helper(new LinkedList<Integer>(), 0, nums, res);\\n        return res; \\n    }\\n    private void helper(LinkedList<Integer> list, int index, int[] nums, List<List<Integer>> res){\\n        if(list.size()>1) res.add(new LinkedList<Integer>(list));\\n        Set<Integer> used = new HashSet<>();\\n        for(int i = index; i<nums.length; i++){\\n            if(used.contains(nums[i])) continue;\\n            if(list.size()==0 || nums[i]>=list.peekLast()){\\n                used.add(nums[i]);\\n                list.add(nums[i]); \\n                helper(list, i+1, nums, res);\\n                list.remove(list.size()-1);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 97124,
                "title": "c-dfs-solution-using-unordered-set",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\\n        vector<vector<int>> res;\\n        vector<int> seq;\\n        dfs(res, seq, nums, 0);\\n        return res;\\n    }\\n    \\n    void dfs(vector<vector<int>>& res, vector<int>& seq, vector<int>& nums, int pos) {\\n        if(seq.size() > 1) res.push_back(seq);\\n        unordered_set<int> hash;\\n        for(int i = pos; i < nums.size(); ++i) {\\n            if((seq.empty() || nums[i] >= seq.back()) && hash.find(nums[i]) == hash.end()) {\\n                seq.push_back(nums[i]);\\n                dfs(res, seq, nums, i + 1);\\n                seq.pop_back();\\n                hash.insert(nums[i]);\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\\n        vector<vector<int>> res;\\n        vector<int> seq;\\n        dfs(res, seq, nums, 0);\\n        return res;\\n    }\\n    \\n    void dfs(vector<vector<int>>& res, vector<int>& seq, vector<int>& nums, int pos) {\\n        if(seq.size() > 1) res.push_back(seq);\\n        unordered_set<int> hash;\\n        for(int i = pos; i < nums.size(); ++i) {\\n            if((seq.empty() || nums[i] >= seq.back()) && hash.find(nums[i]) == hash.end()) {\\n                seq.push_back(nums[i]);\\n                dfs(res, seq, nums, i + 1);\\n                seq.pop_back();\\n                hash.insert(nums[i]);\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3074895,
                "title": "easy-explanation-for-beginners-with-video-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n![Screenshot 2023-01-20 at 6.56.12 AM.png](https://assets.leetcode.com/users/images/893491f9-a6b5-4304-b9eb-91f6616fc9d3_1674178010.9559069.png)\\n\\nRecursion might be a difficult concept to understand, but let me try to explain very easily.\\n\\nThink there is a magical function to which you can pass an arraylist and it fills elements from this index that are greater than the last elemnt of the arraylist. say you have <4,6> -- magical function will add 7 to it.\\n\\nSo at first we will pass an empty array list to this function, it will add single elements i.e 4     6     7\\nwe pass them again, in case of 6 it will give only 6,7 because we are asking it to add elemnts next/further to the index 2.\\n\\nWe will be passing arraylist again recursively to obtain all the arraylist that are possible.\\n\\nSince we want unique arraylists we are adding to hashSet.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nKeep the hashSet and the given array outside the function, it will make things easier.\\n\\nRecursionFunction: (arrayList, index)\\nex (<4>,1) it will add from index 1 to end all > 4 i.e 4,6 and 4,7\\n\\nNow call the same function with\\n<4,6>, 2    and <4,7>, 3\\n\\n\\n![Screenshot 2023-01-20 at 7.08.00 AM.png](https://assets.leetcode.com/users/images/294b4630-5da8-43e6-bfaf-e560b108f61f_1674178700.2894423.png)\\n\\nhttps://youtu.be/b3z5g_ORbpI\\n\\n![sfw-please-upvote-me-v0-u5cacra0rnca1.webp](https://assets.leetcode.com/users/images/d973d879-97c5-4da5-83d8-33d9acceb67e_1674179740.874123.webp)\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int[] arr;\\n    HashSet<List<Integer>> hashSet = new HashSet<>();\\n    public List<List<Integer>> findSubsequences(int[] nums) {\\n        arr = nums;\\n        List<Integer> arrayList = new ArrayList<>();\\n        recursion(arrayList,0);\\n        List<List<Integer>> result = new ArrayList<>(hashSet);\\n        return result;\\n    }\\n\\n    public void recursion(List<Integer> arrayList, int index){\\n        if(arrayList.size()>=2) hashSet.add(new ArrayList(arrayList));\\n\\n        for(int i = index;i<arr.length;i++){\\n            if(arrayList.size() == 0 || arr[i]>= arrayList.get(arrayList.size()-1)){\\n                arrayList.add(arr[i]);\\n                recursion(arrayList,i+1);\\n                arrayList.remove(arrayList.size()-1);\\n            }\\n        }\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int[] arr;\\n    HashSet<List<Integer>> hashSet = new HashSet<>();\\n    public List<List<Integer>> findSubsequences(int[] nums) {\\n        arr = nums;\\n        List<Integer> arrayList = new ArrayList<>();\\n        recursion(arrayList,0);\\n        List<List<Integer>> result = new ArrayList<>(hashSet);\\n        return result;\\n    }\\n\\n    public void recursion(List<Integer> arrayList, int index){\\n        if(arrayList.size()>=2) hashSet.add(new ArrayList(arrayList));\\n\\n        for(int i = index;i<arr.length;i++){\\n            if(arrayList.size() == 0 || arr[i]>= arrayList.get(arrayList.size()-1)){\\n                arrayList.add(arr[i]);\\n                recursion(arrayList,i+1);\\n                arrayList.remove(arrayList.size()-1);\\n            }\\n        }\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 97127,
                "title": "simple-python",
                "content": "First build all increasing subsequences regardless of length, then filter out the too short ones.\\n\\n    def findSubsequences(self, nums):\\n        subs = {()}\\n        for num in nums:\\n            subs |= {sub + (num,)\\n                     for sub in subs\\n                     if not sub or sub[-1] <= num}\\n        return [sub for sub in subs if len(sub) >= 2]",
                "solutionTags": [],
                "code": "First build all increasing subsequences regardless of length, then filter out the too short ones.\\n\\n    def findSubsequences(self, nums):\\n        subs = {()}\\n        for num in nums:\\n            subs |= {sub + (num,)\\n                     for sub in subs\\n                     if not sub or sub[-1] <= num}\\n        return [sub for sub in subs if len(sub) >= 2]",
                "codeTag": "Python3"
            },
            {
                "id": 3074787,
                "title": "python3-backtracking-for-beginners",
                "content": "**Code with no comments at the end, in case you don\\'t want to read the story but just want to compare mine with yours**\\n\\nWhen we see constraints ```1 <= nums.length <= 15``` and the question is asking for **all** the different **possible** non-decreasing **subsequences**, it is backtracking!\\n\\n**Backtracking** is basically **Brute Force**, where we check **all possibilities** using a **Recursive Function**.\\nThe most important parts of backtracking using recursive function are:\\n(1) **return** when we reach to the end and no more states can be generated.\\n(2) **restore the state** after calling the recursive function.\\ni.e.,\\n```\\ndef backtrack(state):\\n(1) if there are no more states that can be generated from the current state, return.\\n(2) change the current state to its neighboring state\\n(3) backtrack(state)\\n(4) restore the state (backtrack)\\n```\\n\\n**For this problem**, we want to build all non-decreasing subsequences one by one (Brute Force). So we do a recursive call on each state. \\n - State is defined as the position ```i``` in nums we are currently visiting and the subsequence we have previously build.\\n - Now, at each position ```i```, we have at most two choices:\\n    (1) Do not include nums[i] for the current subsequence we are building.\\n    (2) Include it in the current subsequence ONLY if it is the first element in the subsequence we are building, or it is greater than or equal to the last element in the subsequence we have already build (obey the non-decreasing property).\\n - We will use set to store the subsequences we built so that we don\\'t have duplicates.\\n - We can translate the result from a set of tuples to a list of lists as the examples showed in the question, or just return it as set which is also acceptable by leetcode.\\n\\n**TC: O(2^n * n)**, where 2^n because we are exploring all possible state, and **n** comes from changing the subsequence from list to tuple (or say make a copy of it).\\n\\n**Code with comments**\\n\\n```python\\nclass Solution:\\n    def findSubsequences(self, nums: List[int]) -> List[List[int]]:\\n        # Use set to store different subsequences to avoid duplicates\\n        res = set()\\n        \\n        def BT(i,subsequence):\\n            nonlocal res\\n            \\n            # As long as there are at least two elements, we add it to our result.\\n            # Note that the subsequence is non-decreasing since we checked it while building.\\n            if len(subsequence)>1:\\n                res.add(tuple(subsequence))\\n            \\n            # There are no more elements left to pick (no more state to generate), just return.\\n            if i==len(nums):\\n                return\\n            \\n            # Check to make sure the subsequence is non-decreasing if we want to pick the current element. \\n            if not subsequence or nums[i] >= subsequence[-1]:\\n                                                    # Note that this line is the same as:\\n                                                    # subsequence.append(nums[i])   #change the current state to its neighboring state\\n                BT(i+1, subsequence+[nums[i]])      # BT(i+1, subsequence)          #backtrack(state)\\n                                                    # subsequence.pop()             #restore the state (backtrack)\\n            # Do not pick the current element.\\n            BT(i+1, subsequence)\\n        \\n        BT(0,[])\\n        return res\\n```\\n\\n**Code with no comments**\\n```python\\nclass Solution:\\n    def findSubsequences(self, nums: List[int]) -> List[List[int]]:\\n        res = set()\\n\\n        def BT(i,subsequence):\\n            nonlocal res\\n            if len(subsequence)>1:\\n                res.add(tuple(subsequence))\\n            if i==len(nums):\\n                return\\n            \\n            if not subsequence or nums[i] >= subsequence[-1]:\\n                BT(i+1, subsequence+[nums[i]]) \\n            BT(i+1, subsequence)\\n        \\n        BT(0,[])\\n        return res\\n```\\n\\n**Upvote** if you like this post.\\n\\n**Connect with me on [LinkedIn](https://www.linkedin.com/in/meida-chen-938a265b/)** if you\\'d like to discuss other related topics\\n\\nJust in case if you are working on **ML/DL 3D data-related projects** or are interested in the topic, please check out our project **[HERE](https://github.com/meidachen/STPLS3D)**",
                "solutionTags": [],
                "code": "```1 <= nums.length <= 15```\n```\\ndef backtrack(state):\\n(1) if there are no more states that can be generated from the current state, return.\\n(2) change the current state to its neighboring state\\n(3) backtrack(state)\\n(4) restore the state (backtrack)\\n```\n```i```\n```i```\n```python\\nclass Solution:\\n    def findSubsequences(self, nums: List[int]) -> List[List[int]]:\\n        # Use set to store different subsequences to avoid duplicates\\n        res = set()\\n        \\n        def BT(i,subsequence):\\n            nonlocal res\\n            \\n            # As long as there are at least two elements, we add it to our result.\\n            # Note that the subsequence is non-decreasing since we checked it while building.\\n            if len(subsequence)>1:\\n                res.add(tuple(subsequence))\\n            \\n            # There are no more elements left to pick (no more state to generate), just return.\\n            if i==len(nums):\\n                return\\n            \\n            # Check to make sure the subsequence is non-decreasing if we want to pick the current element. \\n            if not subsequence or nums[i] >= subsequence[-1]:\\n                                                    # Note that this line is the same as:\\n                                                    # subsequence.append(nums[i])   #change the current state to its neighboring state\\n                BT(i+1, subsequence+[nums[i]])      # BT(i+1, subsequence)          #backtrack(state)\\n                                                    # subsequence.pop()             #restore the state (backtrack)\\n            # Do not pick the current element.\\n            BT(i+1, subsequence)\\n        \\n        BT(0,[])\\n        return res\\n```\n```python\\nclass Solution:\\n    def findSubsequences(self, nums: List[int]) -> List[List[int]]:\\n        res = set()\\n\\n        def BT(i,subsequence):\\n            nonlocal res\\n            if len(subsequence)>1:\\n                res.add(tuple(subsequence))\\n            if i==len(nums):\\n                return\\n            \\n            if not subsequence or nums[i] >= subsequence[-1]:\\n                BT(i+1, subsequence+[nums[i]]) \\n            BT(i+1, subsequence)\\n        \\n        BT(0,[])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 97130,
                "title": "java-20-lines-backtracking-solution-using-set-beats-100",
                "content": "\\n    public class Solution {\\n\\n         public List<List<Integer>> findSubsequences(int[] nums) {\\n             Set<List<Integer>> res= new HashSet<List<Integer>>();\\n             List<Integer> holder = new ArrayList<Integer>();\\n             findSequence(res, holder, 0, nums);\\n             List result = new ArrayList(res);\\n             return result;\\n         }\\n    \\n        public void findSequence(Set<List<Integer>> res, List<Integer> holder, int index, int[] nums) {\\n            if (holder.size() >= 2) {\\n                res.add(new ArrayList(holder));\\n            }\\n            for (int i = index; i < nums.length; i++) {\\n                if(holder.size() == 0 || holder.get(holder.size() - 1) <= nums[i]) {\\n                    holder.add(nums[i]);\\n                    findSequence(res, holder, i + 1, nums);\\n                    holder.remove(holder.size() - 1);\\n                }\\n            }\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n\\n         public List<List<Integer>> findSubsequences(int[] nums) {\\n             Set<List<Integer>> res= new HashSet<List<Integer>>();\\n             List<Integer> holder = new ArrayList<Integer>();\\n             findSequence(res, holder, 0, nums);\\n             List result = new ArrayList(res);\\n             return result;\\n         }",
                "codeTag": "Java"
            },
            {
                "id": 97134,
                "title": "evolve-from-intuitive-solution-to-optimal",
                "content": "This is similar to Subsets II. \\n\\n1.  O(n2^n) For each number, we can either take it or drop it. Duplicates are removed by set.\\n```\\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\\n        set<vector<int>> res;\\n        vector<int> one;\\n        find(0,nums, one, res);\\n        return vector<vector<int>>(res.begin(),res.end());\\n    }\\n    void find(int p, vector<int>& nums, vector<int>& one, set<vector<int>>& res) {\\n        if(p==nums.size()) {\\n            if(one.size()>1) res.insert(one);\\n            return;\\n        }\\n        if(one.empty()||nums[p]>=one.back()) {\\n            one.push_back(nums[p]);\\n            find(p+1,nums,one,res);\\n            one.pop_back();\\n        }\\n        find(p+1,nums,one,res);\\n    }\\n```\\n2. We can also generate all increasing subsequences by adding each number to the current sequencies iteratively and use set to remove duplicates.\\n```\\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\\n        vector<vector<int>> seq(1);\\n        set<vector<int>> bst;\\n        for(int i=0;i<nums.size();i++) {\\n            int n = seq.size();\\n            for(int j=0;j<n;j++)\\n                if(seq[j].empty() || seq[j].back()<=nums[i]) {\\n                    seq.push_back(seq[j]);\\n                    seq.back().push_back(nums[i]);\\n                    if(seq.back().size()>1) bst.insert(seq.back());\\n                }  \\n        }\\n        return vector<vector<int>>(bst.begin(),bst.end());\\n    }\\n```\\n3. We can do better by not generating duplicates. When adding a duplicate number to existing sequences, we don't need to add to all sequences because that will create duplicate sequence. We only need to add to the sequences created since adding this number last time.\\n```\\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\\n        vector<vector<int>> res(1);\\n        unordered_map<int,int> ht;\\n        for(int i=0;i<nums.size();i++) {\\n            int n = res.size();\\n            int start = ht[nums[i]];\\n            ht[nums[i]] = n;\\n            for(int j=start;j<n;j++)\\n                if(res[j].empty() || res[j].back()<=nums[i]) {\\n                    res.push_back(res[j]);\\n                    res.back().push_back(nums[i]);\\n                }  \\n        }\\n        for(int i=res.size()-1;i>=0;i--) \\n            if(res[i].size()<2) {\\n                swap(res[i],res.back());\\n                res.pop_back();\\n            }\\n        return res;\\n    }\\n```\\n4. Duplicates can also be avoided in recursion. Starting from a given number, we pick the next number. We cache the numbers already tried to avoid duplicates.\\n```\\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\\n        vector<vector<int>> res;\\n        vector<int> one;\\n        find(0,nums,one,res);\\n        return res;\\n    }\\n    void find(int p, vector<int>& nums, vector<int>& one, vector<vector<int>>& res) {\\n        int n = nums.size();\\n        if(one.size()>1) res.push_back(one);\\n        unordered_set<int> ht;\\n        for(int i=p;i<n;i++) {\\n            if((!one.empty() && nums[i] < one.back()) || ht.count(nums[i])) continue;\\n            ht.insert(nums[i]);\\n            one.push_back(nums[i]);\\n            find(i+1,nums,one,res);\\n            one.pop_back();\\n        }\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\\n        set<vector<int>> res;\\n        vector<int> one;\\n        find(0,nums, one, res);\\n        return vector<vector<int>>(res.begin(),res.end());\\n    }\\n    void find(int p, vector<int>& nums, vector<int>& one, set<vector<int>>& res) {\\n        if(p==nums.size()) {\\n            if(one.size()>1) res.insert(one);\\n            return;\\n        }\\n        if(one.empty()||nums[p]>=one.back()) {\\n            one.push_back(nums[p]);\\n            find(p+1,nums,one,res);\\n            one.pop_back();\\n        }\\n        find(p+1,nums,one,res);\\n    }\\n```\n```\\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\\n        vector<vector<int>> seq(1);\\n        set<vector<int>> bst;\\n        for(int i=0;i<nums.size();i++) {\\n            int n = seq.size();\\n            for(int j=0;j<n;j++)\\n                if(seq[j].empty() || seq[j].back()<=nums[i]) {\\n                    seq.push_back(seq[j]);\\n                    seq.back().push_back(nums[i]);\\n                    if(seq.back().size()>1) bst.insert(seq.back());\\n                }  \\n        }\\n        return vector<vector<int>>(bst.begin(),bst.end());\\n    }\\n```\n```\\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\\n        vector<vector<int>> res(1);\\n        unordered_map<int,int> ht;\\n        for(int i=0;i<nums.size();i++) {\\n            int n = res.size();\\n            int start = ht[nums[i]];\\n            ht[nums[i]] = n;\\n            for(int j=start;j<n;j++)\\n                if(res[j].empty() || res[j].back()<=nums[i]) {\\n                    res.push_back(res[j]);\\n                    res.back().push_back(nums[i]);\\n                }  \\n        }\\n        for(int i=res.size()-1;i>=0;i--) \\n            if(res[i].size()<2) {\\n                swap(res[i],res.back());\\n                res.pop_back();\\n            }\\n        return res;\\n    }\\n```\n```\\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\\n        vector<vector<int>> res;\\n        vector<int> one;\\n        find(0,nums,one,res);\\n        return res;\\n    }\\n    void find(int p, vector<int>& nums, vector<int>& one, vector<vector<int>>& res) {\\n        int n = nums.size();\\n        if(one.size()>1) res.push_back(one);\\n        unordered_set<int> ht;\\n        for(int i=p;i<n;i++) {\\n            if((!one.empty() && nums[i] < one.back()) || ht.count(nums[i])) continue;\\n            ht.insert(nums[i]);\\n            one.push_back(nums[i]);\\n            find(i+1,nums,one,res);\\n            one.pop_back();\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3075034,
                "title": "easy-solution-fully-explained-c-python3-java",
                "content": "# Consider\\uD83D\\uDC4D\\n```\\n                    Please Upvote If You Find It Helpful.\\n```\\n# Intuition\\n    We iterate through each element of array and perform following opration:\\n    1. We pick the element at that index.\\n    2. Or we do not pick that element and increase the index.\\n    3. when we iterate all elements i.e index==n, we check if size of the answer is greater than one (>1). If true then we add it otherwise ignore it.\\n\\n                        {index, {output}}\\n                        {initial, {}}\\n                            /    \\\\\\n                           /      \\\\\\n                       {0, {}}  {0, {4}}\\n                        /  \\\\        /   \\\\\\n                       /    \\\\      /     \\\\\\n                {1, {}}  {1,{6}} {1,{4}} {1,{4,6}}\\n                    |       |       |        |\\n                    |       |       |        |\\n                    \\n# Approach : Backtracking\\n<!-- Describe your approach to solving the problem. -->\\n# Time Complexity : O(N.2^N)\\n# Space Complexity : O(N*N)\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    // Recursive function to find all increasing subsequences\\n    void solve(vector<int> nums, int index, vector<int> output, set<vector<int>>& ans){\\n        // Base case: if we have reached the end of the input array\\n        if(index>=nums.size()){\\n            // Only insert into ans if output has more than one element\\n            if(output.size()>1)\\n                ans.insert(output);\\n            return ;\\n        }\\n        // If output is empty or current element is greater than or equal to the last element in output\\n        if(output.size()==0 || nums[index] >= output.back()){\\n            output.push_back(nums[index]);\\n            solve(nums, index+1, output, ans);\\n            output.pop_back();\\n        }\\n        solve(nums, index+1, output, ans);\\n    }\\n\\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\\n        // Initialize output and set to store all increasing subsequences\\n        vector<int> output;\\n        set<vector<int>> ans;\\n        // Call recursive function to find all increasing subsequences\\n        solve(nums, 0, output, ans);\\n        // Return ans as a vector\\n        return vector(ans.begin(), ans.end());\\n    }\\n};\\n```\\n```python []\\nclass Solution:\\n    def solve(self, nums, index, output, ans):\\n        # base case: if we have reached the end of the input array\\n        if index >= len(nums):\\n            # only add the output if it has more than one element\\n            if len(output) > 1:\\n                ans.add(tuple(output))\\n            return\\n        \\n        # if the output is empty or the current element is greater than or equal to the last element in the output\\n        if not output or nums[index] >= output[-1]:\\n            # add the current element to the output and recursively call solve\\n            output.append(nums[index])\\n            self.solve(nums, index+1, output, ans)\\n            # remove the last element from the output before returning\\n            output.pop()\\n        \\n        # recursively call solve without adding the current element to the output\\n        self.solve(nums, index+1, output, ans)\\n\\n    def findSubsequences(self, nums: List[int]) -> List[List[int]]:\\n        # use a set to store the unique sub sequences\\n        ans = set()\\n        self.solve(nums, 0, [], ans)\\n        return [list(x) for x in ans]\\n\\n```\\n```Java []\\nclass Solution {\\n    public void solve(int[] nums, int index, List<Integer> output, Set<List<Integer>> ans) {\\n        // base case: if we have reached the end of the input array\\n        if (index >= nums.length) {\\n            // only add the output if it has more than one element\\n            if (output.size() > 1) {\\n                ans.add(new ArrayList<>(output));\\n            }\\n            return;\\n        }\\n        \\n        // if the output is empty or the current element is greater than or equal to the last element in the output\\n        if (output.isEmpty() || nums[index] >= output.get(output.size() - 1)) {\\n            // add the current element to the output and recursively call solve\\n            output.add(nums[index]);\\n            solve(nums, index+1, output, ans);\\n            // remove the last element from the output before returning\\n            output.remove(output.size() - 1);\\n        }\\n        \\n        // recursively call solve without adding the current element to the output\\n        solve(nums, index+1, output, ans);\\n    }\\n    \\n    public List<List<Integer>> findSubsequences(int[] nums) {\\n        // use a set to store the unique sub sequences\\n        Set<List<Integer>> ans = new HashSet<>();\\n        solve(nums, 0, new ArrayList<>(), ans);\\n        return new ArrayList<>(ans);\\n    }\\n}\\n```\\n\\n```\\n                                        Give a \\uD83D\\uDC4D. It motivates me alot.\\n```\\n**Let\\'s Connect On [Linkedin](https://www.linkedin.com/in/naman-agarwal-0551aa1aa/)**\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Array",
                    "Backtracking"
                ],
                "code": "```\\n                    Please Upvote If You Find It Helpful.\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    // Recursive function to find all increasing subsequences\\n    void solve(vector<int> nums, int index, vector<int> output, set<vector<int>>& ans){\\n        // Base case: if we have reached the end of the input array\\n        if(index>=nums.size()){\\n            // Only insert into ans if output has more than one element\\n            if(output.size()>1)\\n                ans.insert(output);\\n            return ;\\n        }\\n        // If output is empty or current element is greater than or equal to the last element in output\\n        if(output.size()==0 || nums[index] >= output.back()){\\n            output.push_back(nums[index]);\\n            solve(nums, index+1, output, ans);\\n            output.pop_back();\\n        }\\n        solve(nums, index+1, output, ans);\\n    }\\n\\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\\n        // Initialize output and set to store all increasing subsequences\\n        vector<int> output;\\n        set<vector<int>> ans;\\n        // Call recursive function to find all increasing subsequences\\n        solve(nums, 0, output, ans);\\n        // Return ans as a vector\\n        return vector(ans.begin(), ans.end());\\n    }\\n};\\n```\n```python []\\nclass Solution:\\n    def solve(self, nums, index, output, ans):\\n        # base case: if we have reached the end of the input array\\n        if index >= len(nums):\\n            # only add the output if it has more than one element\\n            if len(output) > 1:\\n                ans.add(tuple(output))\\n            return\\n        \\n        # if the output is empty or the current element is greater than or equal to the last element in the output\\n        if not output or nums[index] >= output[-1]:\\n            # add the current element to the output and recursively call solve\\n            output.append(nums[index])\\n            self.solve(nums, index+1, output, ans)\\n            # remove the last element from the output before returning\\n            output.pop()\\n        \\n        # recursively call solve without adding the current element to the output\\n        self.solve(nums, index+1, output, ans)\\n\\n    def findSubsequences(self, nums: List[int]) -> List[List[int]]:\\n        # use a set to store the unique sub sequences\\n        ans = set()\\n        self.solve(nums, 0, [], ans)\\n        return [list(x) for x in ans]\\n\\n```\n```Java []\\nclass Solution {\\n    public void solve(int[] nums, int index, List<Integer> output, Set<List<Integer>> ans) {\\n        // base case: if we have reached the end of the input array\\n        if (index >= nums.length) {\\n            // only add the output if it has more than one element\\n            if (output.size() > 1) {\\n                ans.add(new ArrayList<>(output));\\n            }\\n            return;\\n        }\\n        \\n        // if the output is empty or the current element is greater than or equal to the last element in the output\\n        if (output.isEmpty() || nums[index] >= output.get(output.size() - 1)) {\\n            // add the current element to the output and recursively call solve\\n            output.add(nums[index]);\\n            solve(nums, index+1, output, ans);\\n            // remove the last element from the output before returning\\n            output.remove(output.size() - 1);\\n        }\\n        \\n        // recursively call solve without adding the current element to the output\\n        solve(nums, index+1, output, ans);\\n    }\\n    \\n    public List<List<Integer>> findSubsequences(int[] nums) {\\n        // use a set to store the unique sub sequences\\n        Set<List<Integer>> ans = new HashSet<>();\\n        solve(nums, 0, new ArrayList<>(), ans);\\n        return new ArrayList<>(ans);\\n    }\\n}\\n```\n```\\n                                        Give a \\uD83D\\uDC4D. It motivates me alot.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 97122,
                "title": "python-solution-using-backtracker",
                "content": "This is a back tracking solution, similar to find the subset. The tricky part is to use a dictionary to check whether the number has been used or not.\\n```\\nclass Solution(object):\\n    def findSubsequences(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        res = []\\n        self.subsets(nums, 0, [], res)\\n        return res\\n        \\n    def subsets(self, nums, index, temp, res):\\n        if len(nums) >= index and len(temp) >= 2:\\n            res.append(temp[:])\\n        used = {}\\n        for i in range(index, len(nums)):\\n            if len(temp) > 0 and temp[-1] > nums[i]: continue\\n            if nums[i] in used: continue\\n            used[nums[i]] = True\\n            temp.append(nums[i])\\n            self.subsets(nums, i+1, temp, res)\\n            temp.pop()\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def findSubsequences(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        res = []\\n        self.subsets(nums, 0, [], res)\\n        return res\\n        \\n    def subsets(self, nums, index, temp, res):\\n        if len(nums) >= index and len(temp) >= 2:\\n            res.append(temp[:])\\n        used = {}\\n        for i in range(index, len(nums)):\\n            if len(temp) > 0 and temp[-1] > nums[i]: continue\\n            if nums[i] in used: continue\\n            used[nums[i]] = True\\n            temp.append(nums[i])\\n            self.subsets(nums, i+1, temp, res)\\n            temp.pop()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1319745,
                "title": "java-easy-backtracking-solution",
                "content": "```\\nclass Solution {\\n    Set<List<Integer>> lists;\\n    public List<List<Integer>> findSubsequences(int[] nums) {\\n        lists = new HashSet<>();\\n        recursion(nums,0,new ArrayList());\\n        \\n        return new ArrayList(lists);\\n    }\\n    void recursion(int[] nums,int curr,List<Integer> temp)\\n    {\\n        if(temp.size() >= 2)\\n            lists.add(new ArrayList(temp));\\n            \\n        for(int i=curr;i<nums.length;i++)\\n        {\\n            if(temp.size()==0 || temp.get(temp.size()-1) <= nums[i])\\n            {\\n                temp.add(nums[i]);\\n                recursion(nums,i+1,temp);\\n                temp.remove(temp.size()-1);\\n            }\\n        }\\n    }\\n}\\n```\\nPlease upvote if u find my code easy to understand",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    Set<List<Integer>> lists;\\n    public List<List<Integer>> findSubsequences(int[] nums) {\\n        lists = new HashSet<>();\\n        recursion(nums,0,new ArrayList());\\n        \\n        return new ArrayList(lists);\\n    }\\n    void recursion(int[] nums,int curr,List<Integer> temp)\\n    {\\n        if(temp.size() >= 2)\\n            lists.add(new ArrayList(temp));\\n            \\n        for(int i=curr;i<nums.length;i++)\\n        {\\n            if(temp.size()==0 || temp.get(temp.size()-1) <= nums[i])\\n            {\\n                temp.add(nums[i]);\\n                recursion(nums,i+1,temp);\\n                temp.remove(temp.size()-1);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 97148,
                "title": "clean-20ms-solution",
                "content": "```\\npublic List<List<Integer>> findSubsequences(int[] nums) {\\n\\tList<List<Integer>> res = new ArrayList<>();\\n\\thelper(res, new ArrayList<Integer>(), nums, 0);\\n\\treturn res;\\n}\\n\\t\\nprivate void helper(List<List<Integer>> res, List<Integer> list, int[] nums, int id) {\\n\\tif (list.size() > 1) res.add(new ArrayList<Integer>(list));\\n\\tList<Integer> unique = new ArrayList<Integer>();\\n\\tfor (int i = id; i < nums.length; i++) {\\n\\t\\tif (id > 0 && nums[i] < nums[id-1]) continue; // skip non-increase\\n\\t\\tif (unique.contains(nums[i])) continue; // skip duplicate\\n\\t\\tunique.add(nums[i]);\\n\\t\\tlist.add(nums[i]);\\n\\t\\thelper(res, list, nums, i+1);\\n\\t\\tlist.remove(list.size()-1);\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic List<List<Integer>> findSubsequences(int[] nums) {\\n\\tList<List<Integer>> res = new ArrayList<>();\\n\\thelper(res, new ArrayList<Integer>(), nums, 0);\\n\\treturn res;\\n}\\n\\t\\nprivate void helper(List<List<Integer>> res, List<Integer> list, int[] nums, int id) {\\n\\tif (list.size() > 1) res.add(new ArrayList<Integer>(list));\\n\\tList<Integer> unique = new ArrayList<Integer>();\\n\\tfor (int i = id; i < nums.length; i++) {\\n\\t\\tif (id > 0 && nums[i] < nums[id-1]) continue; // skip non-increase\\n\\t\\tif (unique.contains(nums[i])) continue; // skip duplicate\\n\\t\\tunique.add(nums[i]);\\n\\t\\tlist.add(nums[i]);\\n\\t\\thelper(res, list, nums, i+1);\\n\\t\\tlist.remove(list.size()-1);\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3075805,
                "title": "simple-c-recursive-backtracking-with-clear-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimply the intuition is recursively generate all the subsequences and backtrack .If u have solved the problem generate all the subsequneces it will be easy . So there is a concept `Take or Not Take` i.e either u take an element  from the array or u don\\'t take it e.g \\nfor **arr[] = {1, 2}.  as shown**\\n     \\n![image.png](https://assets.leetcode.com/users/images/575c1933-79b6-436f-a09f-feb15013f576_1674196231.5734484.png)\\n So this is how we generate all the subsequences from a set .\\n SO keeping this in mind only thing we have to do here is check if the previous element is smaller than next elemnt inorder to keep in ascending order . So if this condition holds we should take it and if not we simply backtrack from there. Beacuse that branch will not lead to increasing subsequence so we simply backtrack from there.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSo do a recusrion and use the concept take or not take .\\nAnd check the condition : `if curr>=prev `\\n**Some Coding Checks:**\\n**Note**: if temp is empty check the minimum  element since our least constarint here is $$-100$$ I have taken -$$105$$ \\nFor duplicates store the subsequences in a  set .\\nAlso check if temp.size()>1 then push vector in set .\\n# Complexity\\n- Time complexity:$$O(2^n*n^2$$)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(2^n*n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n  set<vector<int>>st;\\n    void generate(vector<int>&arr,int start,vector<int>&temp){\\n         if(arr.size()==start){\\n            if(temp.size()>1)st.insert(temp);\\n            return;  \\n         }\\n         int curr=arr[start];\\n         int prev=temp.size()==0?-105:temp[temp.size()-1];\\n\\n         if(curr>=prev){\\n             // take \\n            temp.push_back(curr);\\n            generate(arr,start+1,temp);\\n            // not take\\n            temp.pop_back();\\n            generate(arr,start+1,temp);\\n         }\\n         else{ \\n            // backtrack from here\\n             generate(arr,start+1,temp);\\n         }\\n    }\\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\\n         vector<int>temp;\\n         generate(nums,0,temp);\\n         return vector(st.begin(),st.end());\\n    }\\n};\\n```\\n**If(helpfull)\\uD83D\\uDD3C\\uD83D\\uDD3C;**",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  set<vector<int>>st;\\n    void generate(vector<int>&arr,int start,vector<int>&temp){\\n         if(arr.size()==start){\\n            if(temp.size()>1)st.insert(temp);\\n            return;  \\n         }\\n         int curr=arr[start];\\n         int prev=temp.size()==0?-105:temp[temp.size()-1];\\n\\n         if(curr>=prev){\\n             // take \\n            temp.push_back(curr);\\n            generate(arr,start+1,temp);\\n            // not take\\n            temp.pop_back();\\n            generate(arr,start+1,temp);\\n         }\\n         else{ \\n            // backtrack from here\\n             generate(arr,start+1,temp);\\n         }\\n    }\\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\\n         vector<int>temp;\\n         generate(nums,0,temp);\\n         return vector(st.begin(),st.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3074894,
                "title": "leetcode-the-hard-way-explained-line-by-line",
                "content": "\\uD83D\\uDD34 Check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\n\\uD83D\\uDFE0 Check out our [Discord](https://discord.gg/Nqm4jJcyBf) for live discussion.\\n\\uD83D\\uDFE2 Give a star on [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post if you like it.\\n\\uD83D\\uDD35 Check out [Screencast](https://www.youtube.com/watch?v=VDMvNhHjohw&list=PLBu4Bche1aEWMj1TdpymXbD8Tn8xKVYwj&index=20) if you are interested.\\n\\n---\\n\\n```cpp\\n// ideas:\\n// 1. use set to store the subsequences\\n// 2. iterate each number to compare with the existing subsequences\\n// 3. if the last element is less than the current element, we can add this number to the subsequence\\n// 4. we can also do the same if the subsequence is empty\\n// 5. filter the subsequences to build the final answer\\nclass Solution {\\npublic:\\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        // use set to store the subsequences\\n        set<vector<int>> s;\\n        // init the first subsequence\\n        // alternatively you can do it with `set<vector<int>> s = {{}};`\\n        s.insert(vector<int>({}));\\n        // iterate each number\\n        for (auto x : nums) {\\n            // use `tmp_s` for storing the new subsequences\\n            // because we wants to iterate each subsequence in `s`\\n            set<vector<int>> tmp_s;\\n            for (auto cur_s : s) {\\n                // we can add the current element `x` if\\n                // 1. the subsequence is empty\\n                // e.g. x = 4, [] => [4]\\n                // 2. the last element is less than the current element\\n                // e.g. x = 6, [4] => [4, 6]\\n                if (cur_s.empty() || cur_s.back() <= x) {\\n                    // copy cur_s to new_s\\n                    // because we want to add the number to the new set `new_s`\\n                    // while keeping the old one `cur_s` unchanged\\n                    // e.g. x = 7, cur_s = [4, 6], new_s = [4, 6, 7] \\n                    vector<int> new_s = cur_s;\\n                    // add the number to the new set `new_s`\\n                    new_s.push_back(x);\\n                    // add `new_s` to `tmp_s` instead of `s`\\n                    // because we are iterating `s`\\n                    tmp_s.insert(new_s);\\n                    \\n                }\\n            }\\n            // add the result back to `s`\\n            s.insert(tmp_s.begin(), tmp_s.end());\\n        }\\n        // iterate the set to build the final answer\\n        for (auto x : s) {\\n            // non-decreasing subsequences at least two elements\\n            if (x.size() >= 2) {\\n                ans.push_back(x);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Set"
                ],
                "code": "```cpp\\n// ideas:\\n// 1. use set to store the subsequences\\n// 2. iterate each number to compare with the existing subsequences\\n// 3. if the last element is less than the current element, we can add this number to the subsequence\\n// 4. we can also do the same if the subsequence is empty\\n// 5. filter the subsequences to build the final answer\\nclass Solution {\\npublic:\\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        // use set to store the subsequences\\n        set<vector<int>> s;\\n        // init the first subsequence\\n        // alternatively you can do it with `set<vector<int>> s = {{}};`\\n        s.insert(vector<int>({}));\\n        // iterate each number\\n        for (auto x : nums) {\\n            // use `tmp_s` for storing the new subsequences\\n            // because we wants to iterate each subsequence in `s`\\n            set<vector<int>> tmp_s;\\n            for (auto cur_s : s) {\\n                // we can add the current element `x` if\\n                // 1. the subsequence is empty\\n                // e.g. x = 4, [] => [4]\\n                // 2. the last element is less than the current element\\n                // e.g. x = 6, [4] => [4, 6]\\n                if (cur_s.empty() || cur_s.back() <= x) {\\n                    // copy cur_s to new_s\\n                    // because we want to add the number to the new set `new_s`\\n                    // while keeping the old one `cur_s` unchanged\\n                    // e.g. x = 7, cur_s = [4, 6], new_s = [4, 6, 7] \\n                    vector<int> new_s = cur_s;\\n                    // add the number to the new set `new_s`\\n                    new_s.push_back(x);\\n                    // add `new_s` to `tmp_s` instead of `s`\\n                    // because we are iterating `s`\\n                    tmp_s.insert(new_s);\\n                    \\n                }\\n            }\\n            // add the result back to `s`\\n            s.insert(tmp_s.begin(), tmp_s.end());\\n        }\\n        // iterate the set to build the final answer\\n        for (auto x : s) {\\n            // non-decreasing subsequences at least two elements\\n            if (x.size() >= 2) {\\n                ans.push_back(x);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 97171,
                "title": "c-backtracking-solution-using-set-of-vectors",
                "content": "    class Solution {\\n    private:\\n        void findSubsequences(vector<int> &nums, vector<int> &subsequence,\\n                            set<vector<int> > &result, int size, int index) {\\n        if (size >= 2)\\n            result.insert(subsequence);\\n\\n\\n        for (int i = index; i < nums.size(); ++i) {\\n            if (subsequence.size() == 0 || nums[i] >= subsequence[subsequence.size() - 1]) {\\n                subsequence.push_back(nums[i]);\\n                findSubsequences(nums, subsequence, result, size + 1, i + 1);\\n                subsequence.pop_back();\\n            }\\n        }\\n    }\\n\\n    public:\\n        vector<vector<int>> findSubsequences(vector<int>& nums) {\\n            set<vector<int>> resultSet;\\n            vector<int> subsequence;\\n            findSubsequences(nums, subsequence, resultSet, 0, 0);\\n\\n            vector<vector<int>> result(resultSet.begin(), resultSet.end());\\n            return result;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    private:\\n        void findSubsequences(vector<int> &nums, vector<int> &subsequence,\\n                            set<vector<int> > &result, int size, int index) {\\n        if (size >= 2)\\n            result.insert(subsequence);\\n\\n\\n        for (int i = index; i < nums.size(); ++i) {\\n            if (subsequence.size() == 0 || nums[i] >= subsequence[subsequence.size() - 1]) {\\n                subsequence.push_back(nums[i]);\\n                findSubsequences(nums, subsequence, result, size + 1, i + 1);\\n                subsequence.pop_back();\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3075050,
                "title": "javascript-very-very-easy-to-understand-solution-with-video-explanation",
                "content": "Here is video for explain if it is helpful please subscribe! :\\n\\nhttps://youtu.be/UFQcPycGqgM\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number[][]}\\n */\\nvar findSubsequences = function(nums) {\\n    let res = []\\n    let map = {}\\n    let iterate = (index,temp) =>{\\n        if(map[temp]) return;\\n        if(temp.length>=2){\\n            res.push(temp)\\n        }\\n        for(let i =index;i<nums.length;i++){\\n            if(temp[temp.length-1]>nums[i]) continue;\\n            map[temp] = true;\\n            iterate(i+1,[...temp,nums[i]])\\n        }\\n    }\\n    iterate(0,[])\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[][]}\\n */\\nvar findSubsequences = function(nums) {\\n    let res = []\\n    let map = {}\\n    let iterate = (index,temp) =>{\\n        if(map[temp]) return;\\n        if(temp.length>=2){\\n            res.push(temp)\\n        }\\n        for(let i =index;i<nums.length;i++){\\n            if(temp[temp.length-1]>nums[i]) continue;\\n            map[temp] = true;\\n            iterate(i+1,[...temp,nums[i]])\\n        }\\n    }\\n    iterate(0,[])\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 702479,
                "title": "python-very-simple-solution",
                "content": "```\\nclass Solution:\\n    def findSubsequences(self, nums: List[int]) -> List[List[int]]:\\n        ## RC ##\\n\\t\\t## APPROACH : BACKTRACKING ##\\n        \\n\\t\\t## TIME COMPLEXITY : O(N^2) ##\\n\\t\\t## SPACE COMPLEXITY : O(N^2) ##\\n        \\n        def backtrack(curr, nums):\\n            if( len(curr) >= 2 and curr[-1] < curr[-2] ): return\\n            if( len(curr) >= 2 and curr[:] not in result):\\n                result.add(curr[:])\\n            for i in range(len(nums)):\\n                backtrack( curr + (nums[i],), nums[i+1:] )  # using tuples for curr instead of list\\n        result = set()\\n        backtrack( (), nums)\\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findSubsequences(self, nums: List[int]) -> List[List[int]]:\\n        ## RC ##\\n\\t\\t## APPROACH : BACKTRACKING ##\\n        \\n\\t\\t## TIME COMPLEXITY : O(N^2) ##\\n\\t\\t## SPACE COMPLEXITY : O(N^2) ##\\n        \\n        def backtrack(curr, nums):\\n            if( len(curr) >= 2 and curr[-1] < curr[-2] ): return\\n            if( len(curr) >= 2 and curr[:] not in result):\\n                result.add(curr[:])\\n            for i in range(len(nums)):\\n                backtrack( curr + (nums[i],), nums[i+1:] )  # using tuples for curr instead of list\\n        result = set()\\n        backtrack( (), nums)\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1849730,
                "title": "best-solution-in-c-100-fast-in-time-space-complexity",
                "content": "```\\nCode :-\\n```void solving(vector<int>& nums, vector<vector<int>>& output, vector<int>& temp, int index){\\n        if(index >= nums.size()){\\n            if(temp.size() > 1)\\n                output.push_back(temp);\\n            return;\\n        }\\n        if(index==0 || temp.size()==0 || nums[index] >= temp[temp.size()-1]){\\n            temp.push_back(nums[index]);\\n            solving(nums, output, temp, index+1);\\n            temp.pop_back();\\n        }\\n        if(temp.size()==0 || temp[temp.size()-1]!=nums[index]){\\n            solving(nums, output, temp, index+1);\\n        }\\n}\\n\\t\\nvector<vector<int>> findSubsequences(vector<int>& nums) {\\n        vector<vector<int>> output;\\n        vector<int> temp;\\n        solving(nums, output, temp, 0);\\n        return output;\\n}",
                "solutionTags": [
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nCode :-\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 755694,
                "title": "short-and-easy-to-understand-python-solution",
                "content": "```\\nclass Solution:\\n    def findSubsequences(self, nums):\\n        if not nums:\\n            return []\\n        res = []\\n        def dfs(start, path):\\n            if len(path) >= 2:\\n                res.append(path)\\n            used = set()\\n            for i in range(start, len(nums)):\\n                if not path or path[-1] <= nums[i]:\\n                    if nums[i] not in used:\\n                        used.add(nums[i])\\n                        dfs(i + 1, path+[nums[i]])\\n        dfs(0, [])\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def findSubsequences(self, nums):\\n        if not nums:\\n            return []\\n        res = []\\n        def dfs(start, path):\\n            if len(path) >= 2:\\n                res.append(path)\\n            used = set()\\n            for i in range(start, len(nums)):\\n                if not path or path[-1] <= nums[i]:\\n                    if nums[i] not in used:\\n                        used.add(nums[i])\\n                        dfs(i + 1, path+[nums[i]])\\n        dfs(0, [])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3075912,
                "title": "c-iterative-bitset-bit-manipulation-easy-peasy",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\\n        int n = nums.size();\\n        set<vector<int>> st;\\n        for (int i = 0; i < (1 << n); i++)\\n        {\\n            string s = bitset<32>(i).to_string();\\n            s = s.substr(32 - n);\\n            vector<int> v;\\n            for (int j = 0; j < n; j++)\\n                if (s[j] == \\'1\\')\\n                    v.push_back(nums[j]);\\n\\n            if (v.size() >= 2 and is_sorted(v.begin(), v.end()))\\n                st.insert(v);\\n        }\\n        return vector<vector<int>>(st.begin(), st.end());\\n    }\\n};\\n```\\n\\n# Faster than previous\\n```\\nclass Solution\\n{\\npublic:\\n    vector<vector<int>> findSubsequences(vector<int> &nums)\\n    {\\n        int n = nums.size();\\n        set<vector<int>> st;\\n        for (int i = 0; i < (1 << n); i++)\\n        {\\n            vector<int> v;\\n            bool flag = true;\\n            for (int j = 0; j < n; j++)\\n            {\\n                int bit = n - 1 - j;\\n                if ((i >> bit) & 1)\\n                {\\n                    if (v.empty())\\n                        v.push_back(nums[j]);\\n                    else if (nums[j] >= v.back())\\n                        v.push_back(nums[j]);\\n                    else\\n                        flag = false;\\n                }\\n            }\\n            if (v.size() >= 2 and flag)\\n                st.insert(v);\\n        }\\n        return vector<vector<int>>(st.begin(), st.end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\\n        int n = nums.size();\\n        set<vector<int>> st;\\n        for (int i = 0; i < (1 << n); i++)\\n        {\\n            string s = bitset<32>(i).to_string();\\n            s = s.substr(32 - n);\\n            vector<int> v;\\n            for (int j = 0; j < n; j++)\\n                if (s[j] == \\'1\\')\\n                    v.push_back(nums[j]);\\n\\n            if (v.size() >= 2 and is_sorted(v.begin(), v.end()))\\n                st.insert(v);\\n        }\\n        return vector<vector<int>>(st.begin(), st.end());\\n    }\\n};\\n```\n```\\nclass Solution\\n{\\npublic:\\n    vector<vector<int>> findSubsequences(vector<int> &nums)\\n    {\\n        int n = nums.size();\\n        set<vector<int>> st;\\n        for (int i = 0; i < (1 << n); i++)\\n        {\\n            vector<int> v;\\n            bool flag = true;\\n            for (int j = 0; j < n; j++)\\n            {\\n                int bit = n - 1 - j;\\n                if ((i >> bit) & 1)\\n                {\\n                    if (v.empty())\\n                        v.push_back(nums[j]);\\n                    else if (nums[j] >= v.back())\\n                        v.push_back(nums[j]);\\n                    else\\n                        flag = false;\\n                }\\n            }\\n            if (v.size() >= 2 and flag)\\n                st.insert(v);\\n        }\\n        return vector<vector<int>>(st.begin(), st.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3075362,
                "title": "python3-217-ms-faster-than-93-12-of-python3-clean-and-easy-to-understand",
                "content": "```\\ndef findSubsequences(self, nums: List[int]) -> List[List[int]]:\\n        curr = [[nums[0]]]\\n        for x in nums[1:]:\\n            curr += [y+[x] for y in curr if x>=y[-1]]\\n            curr += [[x]]\\n        curr = [tuple(x) for x in curr if len(x)>=2]\\n        return list(set(curr))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Ordered Set"
                ],
                "code": "```\\ndef findSubsequences(self, nums: List[int]) -> List[List[int]]:\\n        curr = [[nums[0]]]\\n        for x in nums[1:]:\\n            curr += [y+[x] for y in curr if x>=y[-1]]\\n            curr += [[x]]\\n        curr = [tuple(x) for x in curr if len(x)>=2]\\n        return list(set(curr))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3074835,
                "title": "c-easy-solution-beginner-friendly",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    map<vector<int>,int>mp;\\n    void solve(vector<vector<int>>&res,vector<int>&nums,int x,vector<int>&temp){\\n    if(temp.size()>=2)\\n        {   \\n         mp[temp]++;\\n         if(mp[temp]>1)\\n             return;\\n         res.push_back(temp);\\n     \\n        }\\n        if(x>nums.size())\\n        {\\n              return ;\\n        }\\n        \\n\\n        for(int i=x;i<nums.size();i++){\\n            if(temp.size()>=1)\\n            {if(nums[i]<temp[temp.size()-1])\\n                continue;}\\n            \\n            temp.push_back(nums[i]);\\n            solve(res,nums,i+1,temp);\\n            temp.pop_back();//backtracking the changes we made\\n           \\n        }\\n        return;\\n    }\\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\\n        vector<vector<int>>result;\\n        vector<int>temp;\\n        solve(result,nums,0,temp);\\n            \\n        return result;\\n    }\\n};\\n```\\n![begging.jpg](https://assets.leetcode.com/users/images/7afb98ae-049c-47e2-b8b2-61163056536e_1674467008.0091243.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    map<vector<int>,int>mp;\\n    void solve(vector<vector<int>>&res,vector<int>&nums,int x,vector<int>&temp){\\n    if(temp.size()>=2)\\n        {   \\n         mp[temp]++;\\n         if(mp[temp]>1)\\n             return;\\n         res.push_back(temp);\\n     \\n        }\\n        if(x>nums.size())\\n        {\\n              return ;\\n        }\\n        \\n\\n        for(int i=x;i<nums.size();i++){\\n            if(temp.size()>=1)\\n            {if(nums[i]<temp[temp.size()-1])\\n                continue;}\\n            \\n            temp.push_back(nums[i]);\\n            solve(res,nums,i+1,temp);\\n            temp.pop_back();//backtracking the changes we made\\n           \\n        }\\n        return;\\n    }\\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\\n        vector<vector<int>>result;\\n        vector<int>temp;\\n        solve(result,nums,0,temp);\\n            \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3074796,
                "title": "novice-intermediate-video-easy-step-by-step-explanation",
                "content": "#### What kind of insights can you gain from this video?\\nWe will delve into the problem by breaking it down into five key elements:\\n- The problem definition,\\n- Approach: Our method for solving it,\\n- An example for better understanding of the code,\\n- Intuition: The reasoning behind the code,\\n- An analysis of the complexity\\n\\nhttps://youtu.be/IAiW0w2hW8k\\n\\n***If you found value in this video, please consider supporting the effort that went into creating it. Your support is greatly appreciated\\uD83D\\uDC3F\\uFE0F.\\nYour thoughts and suggestions are appreciated.\\uD83D\\uDC40***\\n\\n\\n#### Approach\\n- Backtracking: Which generates all the possible non-decreasing subsequences of the given array.\\n- Hash Set: To avoid the duplicate sequences\\n\\n#### Complexity\\n- Time complexity: O(2^n * n) \\n- Space complexity: O(n) \\n\\n#### Code\\n**CPP:**\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findSubsequences(vector<int> &nums) {\\n    vector<vector<int>> result; // vector to store the final result\\n    vector<int> temp; // vector to store the current subsequence\\n    unordered_set<size_t> hashValues; // set to store unique hash values of the subsequences\\n    //lambda function to generate all possible non-decreasing subsequences\\n    function<void(int, int)> backtrack = [&](int start, size_t hashVal) {\\n        if (temp.size() >= 2) {\\n            if (hashValues.count(hashVal) == 0) { // check if the hash value is already present in the set\\n                result.push_back(temp);\\n                hashValues.insert(hashVal);\\n            }\\n        }\\n\\n        for (int i = start; i < nums.size(); ++i) {\\n            bool take = temp.empty() || nums[i] >= temp.back(); // check if the current element is greater than or equal to the last element in the current subsequence\\n            if (take) {\\n                temp.push_back(nums[i]); // add the current element to the current subsequence\\n                backtrack(i + 1, hashVal ^ (hash<int>()(nums[i]) + 0x9e3779b9 + (hashVal << 6) + (hashVal >> 2)));\\n                temp.pop_back(); // remove the last element of the current subsequence\\n                while (i < nums.size() - 1 && nums[i] == nums[i + 1]) { //skip duplicates\\n                    i++;\\n                }\\n            }\\n        }\\n    };\\n    backtrack(0, 0);\\n    return result;\\n}\\n};\\n```\\n![upvotee.jpg](https://assets.leetcode.com/users/images/eb42267b-c212-457f-accf-301e412355e4_1674180731.9034004.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findSubsequences(vector<int> &nums) {\\n    vector<vector<int>> result; // vector to store the final result\\n    vector<int> temp; // vector to store the current subsequence\\n    unordered_set<size_t> hashValues; // set to store unique hash values of the subsequences\\n    //lambda function to generate all possible non-decreasing subsequences\\n    function<void(int, int)> backtrack = [&](int start, size_t hashVal) {\\n        if (temp.size() >= 2) {\\n            if (hashValues.count(hashVal) == 0) { // check if the hash value is already present in the set\\n                result.push_back(temp);\\n                hashValues.insert(hashVal);\\n            }\\n        }\\n\\n        for (int i = start; i < nums.size(); ++i) {\\n            bool take = temp.empty() || nums[i] >= temp.back(); // check if the current element is greater than or equal to the last element in the current subsequence\\n            if (take) {\\n                temp.push_back(nums[i]); // add the current element to the current subsequence\\n                backtrack(i + 1, hashVal ^ (hash<int>()(nums[i]) + 0x9e3779b9 + (hashVal << 6) + (hashVal >> 2)));\\n                temp.pop_back(); // remove the last element of the current subsequence\\n                while (i < nums.size() - 1 && nums[i] == nums[i + 1]) { //skip duplicates\\n                    i++;\\n                }\\n            }\\n        }\\n    };\\n    backtrack(0, 0);\\n    return result;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 97141,
                "title": "c-clean-code-iterative",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findSubsequences(vector<int>& a) {\\n        set<vector<int>> seqs = {vector<int>(0)};\\n        for (int i = 0; i < a.size(); i++) {\\n            vector<vector<int>> built(seqs.size());\\n            std::copy(seqs.begin(), seqs.end(), built.begin());\\n            for (auto seq : built) {\\n                if (seq.empty() || a[i] >= seq.back()) {\\n                    seq.push_back(a[i]);\\n                    seqs.insert(seq);\\n                }\\n            }\\n        }\\n        \\n        vector<vector<int>> res;\\n        for (auto seq : seqs)\\n            if (seq.size() > 1) res.push_back(seq);\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findSubsequences(vector<int>& a) {\\n        set<vector<int>> seqs = {vector<int>(0)};\\n        for (int i = 0; i < a.size(); i++) {\\n            vector<vector<int>> built(seqs.size());\\n            std::copy(seqs.begin(), seqs.end(), built.begin());\\n            for (auto seq : built) {\\n                if (seq.empty() || a[i] >= seq.back()) {\\n                    seq.push_back(a[i]);\\n                    seqs.insert(seq);\\n                }\\n            }\\n        }\\n        \\n        vector<vector<int>> res;\\n        for (auto seq : seqs)\\n            if (seq.size() > 1) res.push_back(seq);\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3076009,
                "title": "very-short-c-solution-using-bitmask",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimplest and Shortest code for u . Enjoy!! \\'\\uD83D\\uDD3C\\uD83D\\uDD3C\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsing bimask and checking if ith bit is set if yes push the elemnt in vector simple.It will give u all possible combinations because we are looping for $$2^n$$ subsequences and checking if ith bit is set then take ith element in this way all the subsequences are generated and finally check if length of subseq is >1 and increasing .\\nNot sure how this works here is a video [Click](https://www.youtube.com/watch?v=GLm0aLsoRtY)\\n# Complexity\\n- Time complexity:$$O(2^n*n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(2^n*n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\\n        set<vector<int>>ans;\\n        int n=nums.size();\\n         for(int bitmask=0;bitmask<(1<<n);bitmask++){\\n             vector<int>temp;\\n             for(int i=0;i<n;i++){\\n                 if(bitmask&(1<<i))temp.push_back(nums[i]);\\n             }\\n             if(temp.size()>1){\\n                 if(is_sorted(temp.begin(),temp.end()))ans.insert(temp);\\n             }\\n         }\\n         return vector(ans.begin(),ans.end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\\n        set<vector<int>>ans;\\n        int n=nums.size();\\n         for(int bitmask=0;bitmask<(1<<n);bitmask++){\\n             vector<int>temp;\\n             for(int i=0;i<n;i++){\\n                 if(bitmask&(1<<i))temp.push_back(nums[i]);\\n             }\\n             if(temp.size()>1){\\n                 if(is_sorted(temp.begin(),temp.end()))ans.insert(temp);\\n             }\\n         }\\n         return vector(ans.begin(),ans.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3075001,
                "title": "backtracking-detailed",
                "content": "# Intuition & Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\uD835\\uDDD7\\uD835\\uDDF2\\uD835\\uDE01\\uD835\\uDDEE\\uD835\\uDDF6\\uD835\\uDDF9\\uD835\\uDDF2\\uD835\\uDDF1 \\uD835\\uDDD4\\uD835\\uDDFD\\uD835\\uDDFD\\uD835\\uDDFF\\uD835\\uDDFC\\uD835\\uDDEE\\uD835\\uDDF0\\uD835\\uDDF5 \\uD835\\uDDD8\\uD835\\uDE05\\uD835\\uDDFD\\uD835\\uDDF9\\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDEE\\uD835\\uDE01\\uD835\\uDDF6\\uD835\\uDDFC\\uD835\\uDDFB\\n\\uD835\\uDDD6\\uD835\\uDDFC\\uD835\\uDDFA\\uD835\\uDDFA\\uD835\\uDDF2\\uD835\\uDDFB\\uD835\\uDE01\\uD835\\uDE00 \\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDF1 \\uD835\\uDDF3\\uD835\\uDDF2\\uD835\\uDDF2\\uD835\\uDDF1\\uD835\\uDDEF\\uD835\\uDDEE\\uD835\\uDDF0\\uD835\\uDDF8 \\uD835\\uDDEE\\uD835\\uDDFF\\uD835\\uDDF2 \\uD835\\uDDEE\\uD835\\uDDFD\\uD835\\uDDFD\\uD835\\uDDFF\\uD835\\uDDF2\\uD835\\uDDF0\\uD835\\uDDF6\\uD835\\uDDEE\\uD835\\uDE01\\uD835\\uDDF2\\uD835\\uDDF1\\nhttps://youtu.be/_tntAQUX1ps\\n# Complexity\\n- Time complexity: $$O(n*2^n) $$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n+2^n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n$$n$$: Size of each subsequence\\n$$2^n$$: Total number of subsequence\\n\\n# Code\\n```\\nvar findSubsequences = function(nums) {\\n    let n = nums.length\\n    let res = []\\n\\n    let helper = function (i, sub) {\\n        let unique = new Set()\\n        for (let j = i; j < n; j++) {\\n            if (unique.has(nums[j]) || sub.length > 0 && sub[sub.length - 1] > nums[j]) continue\\n            unique.add(nums[j])\\n            sub.push(nums[j])\\n            if (sub.length >= 2) res.push([...sub])\\n            helper(j+1, sub)\\n            sub.pop()\\n        }\\n    }\\n\\n    helper(0, [])\\n    return res\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking"
                ],
                "code": "```\\nvar findSubsequences = function(nums) {\\n    let n = nums.length\\n    let res = []\\n\\n    let helper = function (i, sub) {\\n        let unique = new Set()\\n        for (let j = i; j < n; j++) {\\n            if (unique.has(nums[j]) || sub.length > 0 && sub[sub.length - 1] > nums[j]) continue\\n            unique.add(nums[j])\\n            sub.push(nums[j])\\n            if (sub.length >= 2) res.push([...sub])\\n            helper(j+1, sub)\\n            sub.pop()\\n        }\\n    }\\n\\n    helper(0, [])\\n    return res\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 225830,
                "title": "python-backtracking",
                "content": "\\tdef findSubsequences(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        if not nums:\\n            return []\\n\\n        res = []        \\n        self.dfs(nums, 0, [], res)\\n        \\n        return res\\n        \\n    def dfs(self, nums, start, path, res):\\n        if len(path) >= 2 and path not in res:\\n            res.append(path[:])\\n    \\n        for i in range(start, len(nums)):\\n            if not path or path[-1] <= nums[i]:\\n                path.append(nums[i])\\n                self.dfs(nums, i + 1, path, res)\\n                path.remove(path[-1])",
                "solutionTags": [],
                "code": "\\tdef findSubsequences(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        if not nums:\\n            return []\\n\\n        res = []        \\n        self.dfs(nums, 0, [], res)\\n        \\n        return res\\n        \\n    def dfs(self, nums, start, path, res):\\n        if len(path) >= 2 and path not in res:\\n            res.append(path[:])\\n    \\n        for i in range(start, len(nums)):\\n            if not path or path[-1] <= nums[i]:\\n                path.append(nums[i])\\n                self.dfs(nums, i + 1, path, res)\\n                path.remove(path[-1])",
                "codeTag": "Python3"
            },
            {
                "id": 97198,
                "title": "short-java-iterative-solution-15-line",
                "content": "```\\npublic List<List<Integer>> findSubsequences(int[] nums) {\\n    Set<List<Integer>> results = new HashSet<List<Integer>>();\\n    Set<List<Integer>> subResults = new HashSet<List<Integer>>();\\n    for (int num : nums) {\\n        for (List<Integer> l : subResults) {\\n            if (l.get(l.size() - 1) > num) continue;\\n            List<Integer> copy = new ArrayList<Integer>(l);\\n            copy.add(num);\\n            results.add(copy);\\n        }\\n        subResults.add(Arrays.asList(num));\\n        subResults.addAll(results);\\n    }\\n    return new LinkedList(results);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic List<List<Integer>> findSubsequences(int[] nums) {\\n    Set<List<Integer>> results = new HashSet<List<Integer>>();\\n    Set<List<Integer>> subResults = new HashSet<List<Integer>>();\\n    for (int num : nums) {\\n        for (List<Integer> l : subResults) {\\n            if (l.get(l.size() - 1) > num) continue;\\n            List<Integer> copy = new ArrayList<Integer>(l);\\n            copy.add(num);\\n            results.add(copy);\\n        }\\n        subResults.add(Arrays.asList(num));\\n        subResults.addAll(results);\\n    }\\n    return new LinkedList(results);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1857460,
                "title": "java-backtracking-91-speed-explained",
                "content": "Usually when it comes to generating subsets, there is always a way to avoid using a HashSet, and this question is of no exception. \\n\\nFor any element in the array, we can either <ins>pick or not pick</ins> and we only pick when the current element is no less than the last element in the tmp list, but that along is not enough because we will come across duplicates. Let me elaborate:\\n\\nConsider something like 3 -> 5 -> 7 -> 1 -> 7 -> .... Here, we have two 7 in the array, picking the first 7 and skip the second 7 is the exactly same thing as skipping the first 7 and picking the second 7! \\n\\nThis means that we have to check the last element in the tmp list and if they are identical, we <ins>disallow not-pick</ins> as an option for the current layer of recursion. It works because if the last element in the list is the identical as the current element, not-pick option will be covered by the previous recursion layer that added that element to the tmp list (i.e. Choose not-pick there, not here), so we don\\'t have to do it again.\\n\\n**SOLUTION (91% Speed)**\\n\\n```Java\\nclass Solution {\\n    public List<List<Integer>> findSubsequences(int[] nums) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        gen(0, nums, ans, new ArrayList<>());\\n        return ans;\\n    }\\n\\n    private void gen(int cur, int[] nums, List<List<Integer>> ans, List<Integer> tmp){\\n        if (cur == nums.length){\\n            if (tmp.size() > 1){\\n                ans.add(new ArrayList<>(tmp));\\n            }\\n            return;\\n        }\\n\\n        if (cur == 0 || tmp.isEmpty() || tmp.get(tmp.size() - 1) != nums[cur]){\\n            gen(cur + 1, nums, ans, tmp); // not-pick option\\n        }\\n        if (tmp.isEmpty() || tmp.get(tmp.size() - 1) <= nums[cur]){\\n            tmp.add(nums[cur]);\\n            gen(cur + 1, nums, ans, tmp); // pick option\\n            tmp.remove(tmp.size() - 1);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```Java\\nclass Solution {\\n    public List<List<Integer>> findSubsequences(int[] nums) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        gen(0, nums, ans, new ArrayList<>());\\n        return ans;\\n    }\\n\\n    private void gen(int cur, int[] nums, List<List<Integer>> ans, List<Integer> tmp){\\n        if (cur == nums.length){\\n            if (tmp.size() > 1){\\n                ans.add(new ArrayList<>(tmp));\\n            }\\n            return;\\n        }\\n\\n        if (cur == 0 || tmp.isEmpty() || tmp.get(tmp.size() - 1) != nums[cur]){\\n            gen(cur + 1, nums, ans, tmp); // not-pick option\\n        }\\n        if (tmp.isEmpty() || tmp.get(tmp.size() - 1) <= nums[cur]){\\n            tmp.add(nums[cur]);\\n            gen(cur + 1, nums, ans, tmp); // pick option\\n            tmp.remove(tmp.size() - 1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1277349,
                "title": "8-steps-dfs-backtrack-solution-explained-c",
                "content": "* **THIS PROBLEM IS SIMILAR TO THESE (BackTracking Family) ::**\\n**1. `SUBSETS` :**  [https://leetcode.com/problems/subsets/](http://)\\n**2. `SUBSETS II` :** [https://leetcode.com/problems/subsets-ii/](http://)\\n**3. `Permutations II :`** [https://leetcode.com/problems/permutations-ii/](http://)\\n**4. `Combination Sum II :`** https://leetcode.com/problems/combination-sum-ii/\\n\\n- C++ Code `(Runtime : 45ms)`\\n```\\nclass Solution {\\nprivate:  vector<vector<int>> ans;                   // result 2D vector stores all possible unique answer(s)\\nprivate:\\n    void dfs(vector<int> &nums, int idx, vector<int> &subRes){\\n        if(size(subRes) > 1) ans.push_back(subRes);  // if our subRes has 2 or more elements, add it in our solution space!\\n        unordered_set<int> Set;                      // making hashset to store all duplicates element\\n        \\n        for(int i = idx; i < size(nums); ++i){\\n            // checking if our current picked element is greater than last pushed element in our sub result & our Hashset has no occurence of that element \\n            if((empty(subRes) || nums[i] >= subRes.back()) && Set.count(nums[i])){                                                       \\n                Set.insert(nums[i]);              // insert the element into hashset for the first time\\n                subRes.push_back(nums[i]);\\n                dfs(nums, i + 1, subRes);         // recurr for next elements and add it our subRes, if it\\'s satisfying the condition\\n                subRes.pop_back();                // BACKTRACK\\n            }\\n        }\\n    }\\npublic:\\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\\n        vector<int> subRes;              // to store sub answer(s) of all unique subsequences .. \\n        dfs(nums, 0, subRes);\\n        return ans;\\n    }\\n};\\n```\\n**TIME COMPLEXITY :` O(2 ^ N)`, where N: len of nums**\\n**SPACE COMPLEXITY :` O(N)`, [used for HashSet, not considering recursion stack & solution spaces vectors]**\\n\\nif you find any mistakes pls, drop a comment\\nif it makes any sense don\\'t forget to **Upvote**",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\nprivate:  vector<vector<int>> ans;                   // result 2D vector stores all possible unique answer(s)\\nprivate:\\n    void dfs(vector<int> &nums, int idx, vector<int> &subRes){\\n        if(size(subRes) > 1) ans.push_back(subRes);  // if our subRes has 2 or more elements, add it in our solution space!\\n        unordered_set<int> Set;                      // making hashset to store all duplicates element\\n        \\n        for(int i = idx; i < size(nums); ++i){\\n            // checking if our current picked element is greater than last pushed element in our sub result & our Hashset has no occurence of that element \\n            if((empty(subRes) || nums[i] >= subRes.back()) && Set.count(nums[i])){                                                       \\n                Set.insert(nums[i]);              // insert the element into hashset for the first time\\n                subRes.push_back(nums[i]);\\n                dfs(nums, i + 1, subRes);         // recurr for next elements and add it our subRes, if it\\'s satisfying the condition\\n                subRes.pop_back();                // BACKTRACK\\n            }\\n        }\\n    }\\npublic:\\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\\n        vector<int> subRes;              // to store sub answer(s) of all unique subsequences .. \\n        dfs(nums, 0, subRes);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 635151,
                "title": "c-solution-recursive-backtracking",
                "content": "```\\nclass Solution {\\n    vector<vector<int> > ans;\\npublic:\\n    void dfs(vector<int> &num,int id,int v,vector<int> tem,set<vector<int> > &mp){\\n        if(id==num.size()) return;\\n        if(tem.size()>=2){\\n            mp.insert(tem);\\n        }\\n        for(int i=id+1;i<num.size();i++){\\n            if(num[i]>=v){\\n              //  cout<<num[i]<<\" \"<<v<<endl;\\n                tem.push_back(num[i]);\\n                dfs(num,i,num[i],tem,mp);\\n                tem.pop_back();\\n            }\\n        }\\n    }\\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\\n       set<vector<int> > st;\\n        for(int i=0;i<nums.size();i++){\\n            vector<int> te;\\n            te.push_back(nums[i]);\\n            dfs(nums,i,nums[i],te,st);\\n        }\\n        for(auto m:st){\\n            ans.push_back(m);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    vector<vector<int> > ans;\\npublic:\\n    void dfs(vector<int> &num,int id,int v,vector<int> tem,set<vector<int> > &mp){\\n        if(id==num.size()) return;\\n        if(tem.size()>=2){\\n            mp.insert(tem);\\n        }\\n        for(int i=id+1;i<num.size();i++){\\n            if(num[i]>=v){\\n              //  cout<<num[i]<<\" \"<<v<<endl;\\n                tem.push_back(num[i]);\\n                dfs(num,i,num[i],tem,mp);\\n                tem.pop_back();\\n            }\\n        }\\n    }\\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\\n       set<vector<int> > st;\\n        for(int i=0;i<nums.size();i++){\\n            vector<int> te;\\n            te.push_back(nums[i]);\\n            dfs(nums,i,nums[i],te,st);\\n        }\\n        for(auto m:st){\\n            ans.push_back(m);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 97157,
                "title": "dp-solution-not-as-clean-as-other-python-solutions-but-beats-99-in-speed",
                "content": "The basic idea is to iterate backwards through `nums` and keep track of all subsequences starting at each element.  We do this by adding all the subsequences that we already found for elements after the current one that are greater than or equal to the current element.  The only twist is that we keep a `seen` set to skip over repeated elements.  After iterating through `nums`, just collect all the none empty lists.\\n\\n    def findSubsequences(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        N = len(nums)\\n        dp = [[] for _ in xrange(N)]\\n        ans = []\\n        \\n        for i in xrange(N-2,-1,-1):\\n            ni = nums[i]\\n            seen = set()\\n            for j in xrange(i+1, N):\\n                nj = nums[j]\\n                if ni <= nj and nj not in seen:\\n                    seen.add(nj)\\n                    dp[i].extend([\\n                        [ni] + x for x in [[nj]] + dp[j] \\n                        ])\\n                    \\n        seen = set()\\n        for i in xrange(N):\\n            if nums[i] not in seen:\\n                seen.add(nums[i])\\n                ans += dp[i]\\n        return ans",
                "solutionTags": [],
                "code": "The basic idea is to iterate backwards through `nums` and keep track of all subsequences starting at each element.  We do this by adding all the subsequences that we already found for elements after the current one that are greater than or equal to the current element.  The only twist is that we keep a `seen` set to skip over repeated elements.  After iterating through `nums`, just collect all the none empty lists.\\n\\n    def findSubsequences(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        N = len(nums)\\n        dp = [[] for _ in xrange(N)]\\n        ans = []\\n        \\n        for i in xrange(N-2,-1,-1):\\n            ni = nums[i]\\n            seen = set()\\n            for j in xrange(i+1, N):\\n                nj = nums[j]\\n                if ni <= nj and nj not in seen:\\n                    seen.add(nj)\\n                    dp[i].extend([\\n                        [ni] + x for x in [[nj]] + dp[j] \\n                        ])\\n                    \\n        seen = set()\\n        for i in xrange(N):\\n            if nums[i] not in seen:\\n                seen.add(nums[i])\\n                ans += dp[i]\\n        return ans",
                "codeTag": "Python3"
            },
            {
                "id": 3076238,
                "title": "c-recursion-backtrack-comments-added-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    void find(int idx,int n,vector<int>& nums,vector<int>& ds,set<vector<int>>& ans)\\n    {\\n        // out of bound\\n        if(idx>=n)\\n        {\\n            // check i am having my subsequence length more than 1 or not\\n            if(ds.size()>=2) ans.insert(ds);\\n            return;\\n        }\\n        \\n        // if i am having somehitng in my ds so check my curr idx val is greater or equal to prev or not\\n        // if my ds is empty then also put curr idx val into it\\n        if(!ds.size() || ds.back()<=nums[idx])\\n        {\\n            ds.push_back(nums[idx]);\\n            find(idx+1,n,nums,ds,ans);\\n            ds.pop_back();\\n        }\\n        \\n        // above conditions are not satisfied, skip curr value\\n        find(idx+1,n,nums,ds,ans);\\n    }\\n    vector<vector<int>> findSubsequences(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n        vector<int> ds;\\n        set<vector<int>> ans;                                  // using set because we need unique subsequences\\n        \\n        find(0,n,nums,ds,ans);\\n        return vector(ans.begin(),ans.end());                  // typcasting from set to vector\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void find(int idx,int n,vector<int>& nums,vector<int>& ds,set<vector<int>>& ans)\\n    {\\n        // out of bound\\n        if(idx>=n)\\n        {\\n            // check i am having my subsequence length more than 1 or not\\n            if(ds.size()>=2) ans.insert(ds);\\n            return;\\n        }\\n        \\n        // if i am having somehitng in my ds so check my curr idx val is greater or equal to prev or not\\n        // if my ds is empty then also put curr idx val into it\\n        if(!ds.size() || ds.back()<=nums[idx])\\n        {\\n            ds.push_back(nums[idx]);\\n            find(idx+1,n,nums,ds,ans);\\n            ds.pop_back();\\n        }\\n        \\n        // above conditions are not satisfied, skip curr value\\n        find(idx+1,n,nums,ds,ans);\\n    }\\n    vector<vector<int>> findSubsequences(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n        vector<int> ds;\\n        set<vector<int>> ans;                                  // using set because we need unique subsequences\\n        \\n        find(0,n,nums,ds,ans);\\n        return vector(ans.begin(),ans.end());                  // typcasting from set to vector\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3075598,
                "title": "java-using-recursion-easy-understanding",
                "content": "- giving #TLE\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> findSubsequences(int[] nums) {\\n        List<List<Integer>>al=new ArrayList<>();\\n        List<Integer>ds=new ArrayList<>();\\n        check(al,nums,0,ds,Integer.MIN_VALUE);\\n        return al;\\n    }\\n    public static void check(List<List<Integer>>al,int nums[],int ind,List<Integer>ds,int prev){\\n        if(ds.size()>1){\\n            if(!al.contains(ds))\\n                al.add(new ArrayList<>(ds));\\n        }\\n        for(int i=ind;i<nums.length;i++){\\n            if(nums[i]>=prev){\\n                ds.add(nums[i]);\\n                check(al,nums,i+1,ds,nums[i]);\\n                ds.remove(ds.size()-1);\\n            }\\n        }\\n    }\\n}\\n```\\n- Accepted Solution\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> findSubsequences(int[] nums) {\\n        Set<List<Integer>>al=new HashSet<List<Integer>>();\\n        List<Integer>ds=new ArrayList<>();\\n        check(al,nums,0,ds,Integer.MIN_VALUE);\\n        List res=new ArrayList(al);\\n        return res;\\n    }\\n    public static void check(Set<List<Integer>>al,int nums[],int ind,List<Integer>ds,int prev){\\n        if(ds.size()>1){\\n                al.add(new ArrayList<>(ds));\\n        }\\n        for(int i=ind;i<nums.length;i++){\\n            if(nums[i]>=prev){\\n                ds.add(nums[i]);\\n                check(al,nums,i+1,ds,nums[i]);\\n                ds.remove(ds.size()-1);\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> findSubsequences(int[] nums) {\\n        List<List<Integer>>al=new ArrayList<>();\\n        List<Integer>ds=new ArrayList<>();\\n        check(al,nums,0,ds,Integer.MIN_VALUE);\\n        return al;\\n    }\\n    public static void check(List<List<Integer>>al,int nums[],int ind,List<Integer>ds,int prev){\\n        if(ds.size()>1){\\n            if(!al.contains(ds))\\n                al.add(new ArrayList<>(ds));\\n        }\\n        for(int i=ind;i<nums.length;i++){\\n            if(nums[i]>=prev){\\n                ds.add(nums[i]);\\n                check(al,nums,i+1,ds,nums[i]);\\n                ds.remove(ds.size()-1);\\n            }\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public List<List<Integer>> findSubsequences(int[] nums) {\\n        Set<List<Integer>>al=new HashSet<List<Integer>>();\\n        List<Integer>ds=new ArrayList<>();\\n        check(al,nums,0,ds,Integer.MIN_VALUE);\\n        List res=new ArrayList(al);\\n        return res;\\n    }\\n    public static void check(Set<List<Integer>>al,int nums[],int ind,List<Integer>ds,int prev){\\n        if(ds.size()>1){\\n                al.add(new ArrayList<>(ds));\\n        }\\n        for(int i=ind;i<nums.length;i++){\\n            if(nums[i]>=prev){\\n                ds.add(nums[i]);\\n                check(al,nums,i+1,ds,nums[i]);\\n                ds.remove(ds.size()-1);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3075385,
                "title": "pick-or-not-to-pick-easy-approach-c-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis problem has a famous approach to pick and non pick intution, we choose to whether to pick a number or not, a quick visualization may help.\\n\\n![Screenshot from 2023-01-20 10-04-45.png](https://assets.leetcode.com/users/images/db2e0a5a-2628-4af2-bc14-10cae5ab9236_1674189315.3228383.png)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nas you can see in the picture(sorry for my extra good mousewriting) we have taken an input array [4, 6, 7, 7] now our target is to build all the possible sub sequencces with increasing order of number so we will take 2 cases whether to pick or not an element from the array,\\n\\nso we will take an approach of recursion, so what should be the base case? when we reach the end of the array that should be the base case, and also we dont want any duplicate array so we will take a set as our final storage structure so that no duplicate is stored.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(2^n) as we are taking 2 cases each time pick and non-pick\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(2n) creating an extra vector and set\\n\\n# Code C++\\n```\\nclass Solution {\\npublic:\\n    void helper(int idx, vector<int>&nums, vector<int>&temp, set<vector<int>>&ans){\\n        if(idx >= nums.size()){\\n            if(temp.size() >= 2){\\n                ans.insert(temp);\\n            }\\n            return;\\n        }\\n        if(temp.size() == 0 ||nums[idx]>=temp.back()){\\n            temp.push_back(nums[idx]);\\n            helper(idx+1, nums, temp, ans);\\n            temp.pop_back();\\n        }\\n        helper(idx+1, nums, temp, ans);\\n    }\\n\\n\\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\\n        vector<int> temp;\\n        set<vector<int>> ans;\\n        helper(0, nums, temp, ans);\\n        return vector(ans.begin(), ans.end());\\n    }\\n};\\n```\\n# Code Python\\n```\\nclass Solution:\\n    def findSubsequences(self, nums: List[int]) -> List[List[int]]:\\n        def helper(i, nums, temp, ans):\\n            if(i >= len(nums)):\\n                if(len(temp)>=2):\\n                    ans.add(tuple(temp))\\n                return\\n            if(len(temp)==0 or nums[i] >= temp[-1]):\\n                temp.append(nums[i])\\n                helper(i+1, nums, temp, ans)\\n                temp.pop()\\n            helper(i+1, nums, temp, ans)\\n        temp = []\\n        ans = set()\\n        helper(0, nums, temp, ans)\\n        return list(ans)\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void helper(int idx, vector<int>&nums, vector<int>&temp, set<vector<int>>&ans){\\n        if(idx >= nums.size()){\\n            if(temp.size() >= 2){\\n                ans.insert(temp);\\n            }\\n            return;\\n        }\\n        if(temp.size() == 0 ||nums[idx]>=temp.back()){\\n            temp.push_back(nums[idx]);\\n            helper(idx+1, nums, temp, ans);\\n            temp.pop_back();\\n        }\\n        helper(idx+1, nums, temp, ans);\\n    }\\n\\n\\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\\n        vector<int> temp;\\n        set<vector<int>> ans;\\n        helper(0, nums, temp, ans);\\n        return vector(ans.begin(), ans.end());\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def findSubsequences(self, nums: List[int]) -> List[List[int]]:\\n        def helper(i, nums, temp, ans):\\n            if(i >= len(nums)):\\n                if(len(temp)>=2):\\n                    ans.add(tuple(temp))\\n                return\\n            if(len(temp)==0 or nums[i] >= temp[-1]):\\n                temp.append(nums[i])\\n                helper(i+1, nums, temp, ans)\\n                temp.pop()\\n            helper(i+1, nums, temp, ans)\\n        temp = []\\n        ans = set()\\n        helper(0, nums, temp, ans)\\n        return list(ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3075312,
                "title": "easy-explanation-backtracking-using-hashset-c-java-python3",
                "content": "# Approach :\\n- Backtracking using HashSet\\n# Complexity :\\n- Time complexity : O(n.2^n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : O(n^2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Request \\uD83D\\uDE0A :\\n- If you find this solution easy to understand and helpful, then Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n         \\n![ezgif-3-22a360561c.gif](https://assets.leetcode.com/users/images/104b8c16-7ae5-426e-ae0a-24eaa09ec3ea_1674189781.7935233.gif)\\n\\n# Code [C++| Java| Python3] - [With Comments]\\u2B07\\uFE0F\\u2B07\\uFE0F\\u2B07\\uFE0F\\n```C++ []\\nclass Solution {\\npublic:\\n    // function to find all unique sub sequences\\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\\n        vector<vector<int>> ans; // use a vector to store the unique sub sequences\\n        vector<int> path;\\n        dfs(nums, 0, path, ans);\\n        return ans;\\n    }\\n\\nprivate:\\n    // function to find sub sequences recursively\\n    void dfs(vector<int>& nums, int s, vector<int>& path, vector<vector<int>>& ans) {\\n        if (path.size() > 1)\\n            ans.push_back(path);\\n        unordered_set<int> used;\\n        for (int i = s; i < nums.size(); ++i) {\\n            // check if the current element has been used before\\n            if (used.count(nums[i]) > 0)\\n                continue;\\n            // check if the path is empty or the current element is greater than or equal to the last element in the path\\n            if (path.empty() || nums[i] >= path.back()) {\\n                used.insert(nums[i]); // add the current element to the used\\n                path.push_back(nums[i]);\\n                dfs(nums, i + 1, path, ans); // recursively call dfs without adding the current element to the path\\n                path.pop_back(); // remove the last element from the path before returning\\n            }\\n        }\\n    }\\n};\\n\\n```\\n```Java []\\nclass Solution {\\n  public List<List<Integer>> findSubsequences(int[] nums) {\\n    List<List<Integer>> ans = new LinkedList<>();\\n    // use a List to store the unique sub sequences\\n    dfs(nums, 0, new LinkedList<>(), ans);\\n    return ans;\\n  }\\n\\n  private void dfs(int[] nums, int s, LinkedList<Integer> path, List<List<Integer>> ans) {\\n    if (path.size() > 1)\\n      ans.add(new LinkedList<>(path));\\n\\n    Set<Integer> used = new HashSet<>();\\n\\n    for (int i = s; i < nums.length; ++i) {\\n      if (used.contains(nums[i]))\\n        continue;\\n      if (path.isEmpty() || nums[i] >= path.getLast()) // if the path is empty or the current element is greater than or equal to the last element in the path\\n      {\\n        used.add(nums[i]);// add the current element to the used and recursively call dfs\\n        path.addLast(nums[i]);\\n        dfs(nums, i + 1, path, ans);// recursively call dfs without adding the current element to the path\\n        path.removeLast();// remove the last element from the path before returning\\n      }\\n    }\\n  }\\n}\\n```\\n```Python3 []\\nclass Solution:\\n    def findSubsequences(self, nums: List[int]) -> List[List[int]]:\\n        ans = [] # use a list to store the unique sub sequences\\n        path = []\\n        self.dfs(nums, 0, path, ans)\\n        return ans\\n    \\n    def dfs(self, nums, s, path, ans):\\n        if len(path) > 1:\\n            ans.append(path[:])\\n        used = set()\\n        for i in range(s, len(nums)):\\n            if nums[i] in used:\\n                continue\\n            # check if the path is empty or the current element is greater than or equal to the last element in the path\\n            if not path or nums[i] >= path[-1]:\\n                used.add(nums[i]) # add the current element to the used\\n                path.append(nums[i])\\n                self.dfs(nums, i+1, path, ans) # recursively call dfs without adding the current element to the path\\n                path.pop() # remove the last element from the path before returning\\n\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Array",
                    "Hash Table"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    // function to find all unique sub sequences\\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\\n        vector<vector<int>> ans; // use a vector to store the unique sub sequences\\n        vector<int> path;\\n        dfs(nums, 0, path, ans);\\n        return ans;\\n    }\\n\\nprivate:\\n    // function to find sub sequences recursively\\n    void dfs(vector<int>& nums, int s, vector<int>& path, vector<vector<int>>& ans) {\\n        if (path.size() > 1)\\n            ans.push_back(path);\\n        unordered_set<int> used;\\n        for (int i = s; i < nums.size(); ++i) {\\n            // check if the current element has been used before\\n            if (used.count(nums[i]) > 0)\\n                continue;\\n            // check if the path is empty or the current element is greater than or equal to the last element in the path\\n            if (path.empty() || nums[i] >= path.back()) {\\n                used.insert(nums[i]); // add the current element to the used\\n                path.push_back(nums[i]);\\n                dfs(nums, i + 1, path, ans); // recursively call dfs without adding the current element to the path\\n                path.pop_back(); // remove the last element from the path before returning\\n            }\\n        }\\n    }\\n};\\n\\n```\n```Java []\\nclass Solution {\\n  public List<List<Integer>> findSubsequences(int[] nums) {\\n    List<List<Integer>> ans = new LinkedList<>();\\n    // use a List to store the unique sub sequences\\n    dfs(nums, 0, new LinkedList<>(), ans);\\n    return ans;\\n  }\\n\\n  private void dfs(int[] nums, int s, LinkedList<Integer> path, List<List<Integer>> ans) {\\n    if (path.size() > 1)\\n      ans.add(new LinkedList<>(path));\\n\\n    Set<Integer> used = new HashSet<>();\\n\\n    for (int i = s; i < nums.length; ++i) {\\n      if (used.contains(nums[i]))\\n        continue;\\n      if (path.isEmpty() || nums[i] >= path.getLast()) // if the path is empty or the current element is greater than or equal to the last element in the path\\n      {\\n        used.add(nums[i]);// add the current element to the used and recursively call dfs\\n        path.addLast(nums[i]);\\n        dfs(nums, i + 1, path, ans);// recursively call dfs without adding the current element to the path\\n        path.removeLast();// remove the last element from the path before returning\\n      }\\n    }\\n  }\\n}\\n```\n```Python3 []\\nclass Solution:\\n    def findSubsequences(self, nums: List[int]) -> List[List[int]]:\\n        ans = [] # use a list to store the unique sub sequences\\n        path = []\\n        self.dfs(nums, 0, path, ans)\\n        return ans\\n    \\n    def dfs(self, nums, s, path, ans):\\n        if len(path) > 1:\\n            ans.append(path[:])\\n        used = set()\\n        for i in range(s, len(nums)):\\n            if nums[i] in used:\\n                continue\\n            # check if the path is empty or the current element is greater than or equal to the last element in the path\\n            if not path or nums[i] >= path[-1]:\\n                used.add(nums[i]) # add the current element to the used\\n                path.append(nums[i])\\n                self.dfs(nums, i+1, path, ans) # recursively call dfs without adding the current element to the path\\n                path.pop() # remove the last element from the path before returning\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3077505,
                "title": "easy-to-understand-well-documented-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n***Idea is to use Backtracking .***\\n**Why Backtracking**? *-> At each point we have 2 choices\\n                i) Either to include the element at current index in our current subsequence\\nii) Or, Exclude the current element at current index from adding it to the current subsequence*\\n\\n---\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(2^n * n)$$\\n\\n*The time complexity of this algorithm is O(2^n * n) where n is the length of the input array nums.\\nThis is because for each element in the array, the algorithm has two choices: to include it in the current subsequence or not.\\nThis results in an exponential number of possible subsequences, and for each subsequence, the algorithm must add it to the set, which takes O(n) time.*\\n\\n---\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(2^n * n)$$\\n\\n*The space complexity of this algorithm is O(2^n * n) as well.\\nThis is because the algorithm stores all possible subsequences in a set,\\nwhich takes up O(2^n * n) space, where 2^n is the number of possible subsequences, and n is the length of each subsequence.\\nAdditionally, the algorithm uses a temporary list to store the current subsequence being constructed, which takes up O(n) space.*\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> findSubsequences(int[] nums) {\\n        Set<List<Integer>> res=new HashSet<List<Integer>>();\\n        List<Integer> sequence=new ArrayList<>();\\n        helperBacktrack(nums,0,sequence,res);\\n        return new ArrayList<>(res);\\n    }\\n    private void helperBacktrack(int[] nums,int index,List<Integer> sequence,Set<List<Integer>> res){\\n            if(sequence.size()>=2){ // if the length of the current subsequence is at-least 2 then add it to res\\n                res.add(new ArrayList<>(sequence));\\n            }\\n\\n        for (int i = index; i < nums.length; i++) {//start from index\\n            //if the sequence remains increasing after appending nums[i]\\n            if (sequence.isEmpty() || sequence.get(sequence.size() - 1) <= nums[i]) {\\n                //append nums[i] to the sequence\\n                sequence.add(nums[i]);\\n                //call recursively for i+1\\n                helperBacktrack(nums, i + 1, sequence, res);\\n                //delete nums[i] from the end of the sequence\\n                sequence.remove(sequence.size() - 1);\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> findSubsequences(int[] nums) {\\n        Set<List<Integer>> res=new HashSet<List<Integer>>();\\n        List<Integer> sequence=new ArrayList<>();\\n        helperBacktrack(nums,0,sequence,res);\\n        return new ArrayList<>(res);\\n    }\\n    private void helperBacktrack(int[] nums,int index,List<Integer> sequence,Set<List<Integer>> res){\\n            if(sequence.size()>=2){ // if the length of the current subsequence is at-least 2 then add it to res\\n                res.add(new ArrayList<>(sequence));\\n            }\\n\\n        for (int i = index; i < nums.length; i++) {//start from index\\n            //if the sequence remains increasing after appending nums[i]\\n            if (sequence.isEmpty() || sequence.get(sequence.size() - 1) <= nums[i]) {\\n                //append nums[i] to the sequence\\n                sequence.add(nums[i]);\\n                //call recursively for i+1\\n                helperBacktrack(nums, i + 1, sequence, res);\\n                //delete nums[i] from the end of the sequence\\n                sequence.remove(sequence.size() - 1);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3075682,
                "title": "python-backtracking-video-solution",
                "content": "I have explained the entire solution [here](https://youtu.be/GAEXeExzMWQ).\\n\\n```\\nclass Solution:\\n    def findSubsequences(self, nums: List[int]) -> List[List[int]]:\\n        \\n        res = set()\\n        perm = []\\n        \\n        def dfs(i, prev):\\n            if i==len(nums):\\n                if len(perm)>=2:\\n                    res.add(tuple(perm))\\n                return\\n                \\n            dfs(i+1, prev)\\n            \\n            if nums[i]>=prev:\\n                perm.append(nums[i])\\n                dfs(i+1, nums[i])\\n                perm.pop()\\n        \\n        dfs(0, -inf)\\n        return list(res)\\n```",
                "solutionTags": [
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def findSubsequences(self, nums: List[int]) -> List[List[int]]:\\n        \\n        res = set()\\n        perm = []\\n        \\n        def dfs(i, prev):\\n            if i==len(nums):\\n                if len(perm)>=2:\\n                    res.add(tuple(perm))\\n                return\\n                \\n            dfs(i+1, prev)\\n            \\n            if nums[i]>=prev:\\n                perm.append(nums[i])\\n                dfs(i+1, nums[i])\\n                perm.pop()\\n        \\n        dfs(0, -inf)\\n        return list(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3075365,
                "title": "python-generator-better-than-100-memory",
                "content": "```\\nclass Solution:\\n    def findSubsequences(self, nums: List[int]) -> List[List[int]]:\\n        def rec(ind, path=[]):\\n            if len(path) > 1:\\n                yield path\\n            for i in range(ind, len(nums)):\\n                if not path or nums[i] >= path[-1]:\\n                    yield from rec(i+1, path+[nums[i]])\\n        return list(set(tuple(i) for i in rec(0)))\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findSubsequences(self, nums: List[int]) -> List[List[int]]:\\n        def rec(ind, path=[]):\\n            if len(path) > 1:\\n                yield path\\n            for i in range(ind, len(nums)):\\n                if not path or nums[i] >= path[-1]:\\n                    yield from rec(i+1, path+[nums[i]])\\n        return list(set(tuple(i) for i in rec(0)))\\n",
                "codeTag": "Java"
            },
            {
                "id": 3075037,
                "title": "c-easy-fast-solution",
                "content": "# C++ Code\\n``` C++ []\\nclass Solution {\\npublic:\\n    map<vector<int>,int>mp;\\n    void solve(vector<vector<int>>&res,vector<int>&nums,int x,vector<int>&temp){\\n    if(temp.size()>=2)\\n        {   \\n         mp[temp]++;\\n         if(mp[temp]>1)\\n             return;\\n         res.push_back(temp);\\n     \\n        }\\n        if(x>nums.size())\\n        {\\n              return ;\\n        }\\n        \\n\\n        for(int i=x;i<nums.size();i++){\\n            if(temp.size()>=1)\\n            {if(nums[i]<temp[temp.size()-1])\\n                continue;}\\n            \\n            temp.push_back(nums[i]);\\n            solve(res,nums,i+1,temp);\\n            temp.pop_back();//backtracking the changes we made\\n           \\n        }\\n        return;\\n    }\\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\\n        vector<vector<int>>result;\\n        vector<int>temp;\\n        solve(result,nums,0,temp);\\n            \\n        return result;\\n    }\\n};\\n```\\n\\n*Upvote if helped* :)",
                "solutionTags": [
                    "C++"
                ],
                "code": "``` C++ []\\nclass Solution {\\npublic:\\n    map<vector<int>,int>mp;\\n    void solve(vector<vector<int>>&res,vector<int>&nums,int x,vector<int>&temp){\\n    if(temp.size()>=2)\\n        {   \\n         mp[temp]++;\\n         if(mp[temp]>1)\\n             return;\\n         res.push_back(temp);\\n     \\n        }\\n        if(x>nums.size())\\n        {\\n              return ;\\n        }\\n        \\n\\n        for(int i=x;i<nums.size();i++){\\n            if(temp.size()>=1)\\n            {if(nums[i]<temp[temp.size()-1])\\n                continue;}\\n            \\n            temp.push_back(nums[i]);\\n            solve(res,nums,i+1,temp);\\n            temp.pop_back();//backtracking the changes we made\\n           \\n        }\\n        return;\\n    }\\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\\n        vector<vector<int>>result;\\n        vector<int>temp;\\n        solve(result,nums,0,temp);\\n            \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3074993,
                "title": "c-code-using-dfs-and-recursion-with-explanation",
                "content": "\\n# Approach\\nThis is a depth-first search (DFS) algorithm that is used to find all increasing subsequences of a given array of integers. The basic idea is to start with an empty subsequence, and then add elements to it one by one, while ensuring that the resulting subsequence is always increasing. The algorithm uses a helper function, dfs, that takes four parameters: the array of integers, the current index in the array, the current subsequence, and a reference to a vector that will hold all the resulting subsequences.\\n\\nThe dfs function first checks if the current subsequence has at least two elements, and if so, adds it to the vector of resulting subsequences. Then, it uses an unordered_set to keep track of elements that have already been used, and iterates through the remaining elements in the array, starting from the current index. For each element, it checks if it is greater than or equal to the last element in the current subsequence (if the current subsequence is not empty), and if so, adds it to the current subsequence and calls dfs again with the updated subsequence and the next index. Once the dfs function returns, the current element is removed from the current subsequence, and the algorithm continues with the next element in the array.\\n\\n# Complexity\\n- Time complexity:\\n $$O(2^n * n)$$ \\nThe time complexity of this algorithm is $$O(2^n * n)$$ , where n is the size of the input array. This is because for each element in the array, we have two options: either to include it in the current subsequence or to exclude it. As we recursively call the dfs function for each element, the number of possible subsequences grows exponentially. Additionally, for each of these subsequences, we are adding the elements to a new vector, which takes $$O(n)$$ time.\\n\\n- Space complexity:\\n $$O(n)$$ \\nThe space complexity is $$O(n)$$  as we are only storing the current subsequence and the set of used elements at each level of recursion.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nvector<vector<int>> findSubsequences(vector<int>& nums) {\\n    vector<vector<int>> res;\\n    vector<int> curr;\\n    dfs(nums, 0, curr, res);\\n    return res;\\n}\\n\\nvoid dfs(vector<int>& nums, int start, vector<int>& curr, vector<vector<int>>& res) {\\n    if (curr.size() >= 2) res.push_back(curr);\\n    unordered_set<int> used;\\n    for (int i = start; i < nums.size(); i++) {\\n        if (used.count(nums[i])) continue;\\n        if (curr.empty() || nums[i] >= curr.back()) {\\n            used.insert(nums[i]);\\n            curr.push_back(nums[i]);\\n            dfs(nums, i + 1, curr, res);\\n            curr.pop_back();\\n        }\\n    }\\n}\\n\\n};\\n```\\n# Code\\n```\\nclass Solution {\\npublic:\\nvector<vector<int>> findSubsequences(vector<int>& nums) {\\n    vector<vector<int>> res;\\n    vector<int> cur;\\n    dfs(nums, 0, cur, res);\\n    return res;\\n}\\n\\nvoid dfs(vector<int>& nums, int start, vector<int>& cur, vector<vector<int>>& res) {\\n    if (cur.size() >= 2) res.push_back(cur);\\n    unordered_set<int> used;\\n    for (int i = start; i < nums.size(); i++) {\\n        if ((cur.empty() || nums[i] >= cur.back()) && used.find(nums[i]) == used.end()) {\\n            cur.push_back(nums[i]);\\n            dfs(nums, i + 1, cur, res);\\n            cur.pop_back();\\n            used.insert(nums[i]);\\n        }\\n    }\\n}\\n\\n};\\n```\\n# Please Upvote\\n",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Recursion",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvector<vector<int>> findSubsequences(vector<int>& nums) {\\n    vector<vector<int>> res;\\n    vector<int> curr;\\n    dfs(nums, 0, curr, res);\\n    return res;\\n}\\n\\nvoid dfs(vector<int>& nums, int start, vector<int>& curr, vector<vector<int>>& res) {\\n    if (curr.size() >= 2) res.push_back(curr);\\n    unordered_set<int> used;\\n    for (int i = start; i < nums.size(); i++) {\\n        if (used.count(nums[i])) continue;\\n        if (curr.empty() || nums[i] >= curr.back()) {\\n            used.insert(nums[i]);\\n            curr.push_back(nums[i]);\\n            dfs(nums, i + 1, curr, res);\\n            curr.pop_back();\\n        }\\n    }\\n}\\n\\n};\\n```\n```\\nclass Solution {\\npublic:\\nvector<vector<int>> findSubsequences(vector<int>& nums) {\\n    vector<vector<int>> res;\\n    vector<int> cur;\\n    dfs(nums, 0, cur, res);\\n    return res;\\n}\\n\\nvoid dfs(vector<int>& nums, int start, vector<int>& cur, vector<vector<int>>& res) {\\n    if (cur.size() >= 2) res.push_back(cur);\\n    unordered_set<int> used;\\n    for (int i = start; i < nums.size(); i++) {\\n        if ((cur.empty() || nums[i] >= cur.back()) && used.find(nums[i]) == used.end()) {\\n            cur.push_back(nums[i]);\\n            dfs(nums, i + 1, cur, res);\\n            cur.pop_back();\\n            used.insert(nums[i]);\\n        }\\n    }\\n}\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3074832,
                "title": "javascript-explained-solution-beginner-friendly-backtracking-js",
                "content": "\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number[][]}\\n */\\nvar findSubsequences = function (nums) {\\n    let result = new Set();\\n    let sequence = [];\\n    function backtrack(index) {\\n        if (index === nums.length) {\\n            if (sequence.length >= 2) {\\n                result.add(JSON.stringify(sequence));\\n            }\\n            return;\\n        }\\n\\n        if (!sequence.length ||\\n            sequence[sequence.length - 1]\\n            <= nums[index]) {\\n            sequence.push(nums[index]);\\n            backtrack(index + 1);\\n            sequence.pop();\\n        }\\n        backtrack(index + 1);\\n    }\\n    backtrack(0);\\n    return Array.from(result).map(JSON.parse);\\n};\\n```\\n\\n# Explanation\\n\\n- It creates a new Set called \"result\" to store the resulting subsequences.\\n- It also creates an empty array called \"sequence\" to store the current subsequence being built.\\n- It then defines a function called \"backtrack\" which takes an input \"index\" and is called recursively.\\n- In the \"backtrack\" function:\\n     - If the \"index\" is equal to the length of the input array \"nums\", it checks if the current \"sequence\" has at least two elements.\\n    - If it does, it adds a stringified version of the \"sequence\" to the \"result\" set.\\n    - If the \"index\" is not equal to the length of the input array \"nums\", it checks if the \"sequence\" is empty or if the last element in the \"sequence\" is less than or equal to the element at the current \"index\" in the \"nums\" array.\\n    - If either of these conditions is true, it adds the element at the current \"index\" in the \"nums\" array to the \"sequence\", and then calls the \"backtrack\" function recursively with the next index.\\n    - Then it removes the last element from the \"sequence\" and calls the \"backtrack\" function recursively with the same index again.\\n    \\n- It then calls the \"backtrack\" function with an initial \"index\" of 0.\\n- Finally, it converts the \"result\" set to an array, maps over each element in the array and parse it to convert back to array and returns the final result.\\n\\n# Time Complexity\\n\\nThe function uses a backtracking approach that generates all possible combinations of elements in the input array \"nums\", so the time complexity is O(2^n), where \"n\" is the size of the input array \"nums\".\\nThe backtracking procedure calls the function recursively with each index of the input array \"nums\" at most twice and in each call it pushes and pops an element from the sequence array, and also checks the condition for adding a stringified version of the sequence to the set.\\nTherefore, the overall time complexity of the function is O(n * 2^n)\\n# Space Complexity:\\n\\nThe function uses a Set and an array to store the resulting subsequences, and an array to store the current subsequence being built.\\nThe size of the Set is dependent on the number of distinct non-decreasing subsequences that can be formed from the input array \"nums\". \\nIn the worst case, it could be of size O(2^n)\\nThe size of the array used to store the current subsequence being built is dependent on the size of the input array \"nums\" and is O(n)\\nTherefore, the overall space complexity of the function is O(n + 2^n).",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[][]}\\n */\\nvar findSubsequences = function (nums) {\\n    let result = new Set();\\n    let sequence = [];\\n    function backtrack(index) {\\n        if (index === nums.length) {\\n            if (sequence.length >= 2) {\\n                result.add(JSON.stringify(sequence));\\n            }\\n            return;\\n        }\\n\\n        if (!sequence.length ||\\n            sequence[sequence.length - 1]\\n            <= nums[index]) {\\n            sequence.push(nums[index]);\\n            backtrack(index + 1);\\n            sequence.pop();\\n        }\\n        backtrack(index + 1);\\n    }\\n    backtrack(0);\\n    return Array.from(result).map(JSON.parse);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3074781,
                "title": "c-backtracking-simple-subset-problem",
                "content": "# Intuition\\nSimilar problem as (Subset) https://leetcode.com/problems/subsets/\\nSimply check the condition for all the subsets to see if they are sorted or not.\\n\\n# Approach\\nHash Table + Backtracking\\n\\n## Don\\'t forget to upvote and give a like \\uD83D\\uDE43\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    map<vector<int>,int> mp;\\n    void solve(int index,vector<int>& nums,vector<int>& subset,vector<vector<int>>& ans){\\n        vector<int> check = subset;\\n        sort(check.begin(),check.end());\\n        if(check == subset and subset.size()>=2 and mp.find(subset)==mp.end()){\\n        ans.push_back(subset);\\n        mp[subset] = 1;\\n        }\\n        for(int i = index;i<nums.size();i++){\\n            subset.push_back(nums[i]);\\n            solve(i+1,nums,subset,ans);\\n            subset.pop_back();\\n\\n        }\\n    }\\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\\n        vector<int> subset;\\n        vector<vector<int>> ans;\\n        solve(0,nums,subset,ans);\\n        return ans;\\n    }\\n};\\n```\\n### I hope the solution is clear; use the comment section regarding any doubt.",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    map<vector<int>,int> mp;\\n    void solve(int index,vector<int>& nums,vector<int>& subset,vector<vector<int>>& ans){\\n        vector<int> check = subset;\\n        sort(check.begin(),check.end());\\n        if(check == subset and subset.size()>=2 and mp.find(subset)==mp.end()){\\n        ans.push_back(subset);\\n        mp[subset] = 1;\\n        }\\n        for(int i = index;i<nums.size();i++){\\n            subset.push_back(nums[i]);\\n            solve(i+1,nums,subset,ans);\\n            subset.pop_back();\\n\\n        }\\n    }\\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\\n        vector<int> subset;\\n        vector<vector<int>> ans;\\n        solve(0,nums,subset,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3074732,
                "title": "daily-leetcoding-challenge-january-day-20",
                "content": "This problem is the Daily LeetCoding Challenge for January, Day 20.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/non-decreasing-subsequences/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 0 approach in the official solution</summary>\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/non-decreasing-subsequences/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 1577928,
                "title": "python-dfs",
                "content": "```\\nclass Solution:\\n    def findSubsequences(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(i, num, curr):\\n            if len(curr)>=2:\\n                ans.add(curr[:])\\n            if i>=len(nums):\\n                return\\n            for j in range(i, len(nums)):\\n                if nums[j]>=num:\\n                    dfs(j+1, nums[j], curr+(nums[j],))\\n                        \\n        ans = set()\\n        dfs(0, -float(\"inf\"), ())\\n        return ans",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findSubsequences(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(i, num, curr):\\n            if len(curr)>=2:\\n                ans.add(curr[:])\\n            if i>=len(nums):\\n                return\\n            for j in range(i, len(nums)):\\n                if nums[j]>=num:\\n                    dfs(j+1, nums[j], curr+(nums[j],))\\n                        \\n        ans = set()\\n        dfs(0, -float(\"inf\"), ())\\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 1166008,
                "title": "c-explained-dfs-backtracking",
                "content": "Code has been commented below:\\n```\\nclass Solution {\\n   set<vector<int>> st;  //st will contain all unique inc. subsequence (no duplicate)\\npublic:\\n    void dfs(int idx, int cur, vector<int>&nums,vector<int>&temp){\\n        if(idx == nums.size())return; // if we have reached the end i.e , processed all element from a index\\n        \\n        if(temp.size()>=2)st.insert(temp); //anyinc. subsequence of size >=2 is acceptable\\n     \\n       \\n//now we check for elements to the right of idx ans if they are increasing then push it and\\n// recur for remainning elements , finally we pop_back to backtrack and find new subsequqnce\\n           for(int i= idx+1;i<nums.size();i++){\\n            if(nums[i]>=cur){//check if element at i is greater then cur so that it can form inc. subquence\\n                temp.push_back(nums[i]); //if inc. push it in temp\\n                dfs(i, nums[i], nums,temp); //recur for remainning\\n            temp.pop_back();  //backtrack\\n            }\\n        }\\n    }\\n\\npublic:\\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\\n        \\n//We run the dfs from all indices \\n        for(int i=0;i<nums.size();i++){\\n           vector<int> temp; //for each run we create a new vector temp to stroe the inc. \\n                              //subsequences from this index i\\n            temp.push_back(nums[i]); //push the first element and then run dfs to find all other\\n            \\n            dfs(i, nums[i], nums, temp);\\n           \\n            \\n        }\\n         vector<vector<int>> ans(st.begin(), st.end());\\n     \\n        return ans;\\n    }\\n};\\n```\\n**Do upvote if explanation was useful & you liked the code:)**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n   set<vector<int>> st;  //st will contain all unique inc. subsequence (no duplicate)\\npublic:\\n    void dfs(int idx, int cur, vector<int>&nums,vector<int>&temp){\\n        if(idx == nums.size())return; // if we have reached the end i.e , processed all element from a index\\n        \\n        if(temp.size()>=2)st.insert(temp); //anyinc. subsequence of size >=2 is acceptable\\n     \\n       \\n//now we check for elements to the right of idx ans if they are increasing then push it and\\n// recur for remainning elements , finally we pop_back to backtrack and find new subsequqnce\\n           for(int i= idx+1;i<nums.size();i++){\\n            if(nums[i]>=cur){//check if element at i is greater then cur so that it can form inc. subquence\\n                temp.push_back(nums[i]); //if inc. push it in temp\\n                dfs(i, nums[i], nums,temp); //recur for remainning\\n            temp.pop_back();  //backtrack\\n            }\\n        }\\n    }\\n\\npublic:\\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\\n        \\n//We run the dfs from all indices \\n        for(int i=0;i<nums.size();i++){\\n           vector<int> temp; //for each run we create a new vector temp to stroe the inc. \\n                              //subsequences from this index i\\n            temp.push_back(nums[i]); //push the first element and then run dfs to find all other\\n            \\n            dfs(i, nums[i], nums, temp);\\n           \\n            \\n        }\\n         vector<vector<int>> ans(st.begin(), st.end());\\n     \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 617161,
                "title": "python-short-iterative-solution",
                "content": "```\\nclass Solution(object):\\n    def findSubsequences(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        if not nums: return nums\\n        curr = [[nums[0]]]\\n        for x in nums[1:]:\\n            curr += [y+[x] for y in curr if x>=y[-1]]\\n            curr += [[x]]\\n        curr = [tuple(x) for x in curr if len(x)>=2]\\n        return list(set(curr))\\n\\t",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def findSubsequences(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        if not nums: return nums\\n        curr = [[nums[0]]]\\n        for x in nums[1:]:\\n            curr += [y+[x] for y in curr if x>=y[-1]]\\n            curr += [[x]]\\n        curr = [tuple(x) for x in curr if len(x)>=2]\\n        return list(set(curr))\\n\\t",
                "codeTag": "Java"
            },
            {
                "id": 415715,
                "title": "simple-5ms-java-solution-for-slow-learners-like-myself",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> findSubsequences(int[] nums) {\\n        if (nums == null || nums.length == 0)\\n            return new ArrayList<>();\\n        \\n        List<List<Integer>> lists = new ArrayList<>();\\n        backtrack(lists, new ArrayList<>(), nums, 0);\\n        return lists;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> lists, List<Integer> list, int[] nums, int pos) {\\n        if (list.size() >= 2)\\n            lists.add(new ArrayList<>(list));\\n        \\n        Set<Integer> used = new HashSet<>();\\n        for (int i = pos; i < nums.length; i++) {\\n            int num = nums[i];\\n            if (!used.add(num)) //duplicate number skip\\n                continue;\\n            if (!list.isEmpty() && list.get(list.size() - 1) > num) //strictly increasing sequence only\\n                continue;\\n            list.add(num);\\n            backtrack(lists, list, nums, i + 1);\\n            list.remove(list.size() - 1);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> findSubsequences(int[] nums) {\\n        if (nums == null || nums.length == 0)\\n            return new ArrayList<>();\\n        \\n        List<List<Integer>> lists = new ArrayList<>();\\n        backtrack(lists, new ArrayList<>(), nums, 0);\\n        return lists;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> lists, List<Integer> list, int[] nums, int pos) {\\n        if (list.size() >= 2)\\n            lists.add(new ArrayList<>(list));\\n        \\n        Set<Integer> used = new HashSet<>();\\n        for (int i = pos; i < nums.length; i++) {\\n            int num = nums[i];\\n            if (!used.add(num)) //duplicate number skip\\n                continue;\\n            if (!list.isEmpty() && list.get(list.size() - 1) > num) //strictly increasing sequence only\\n                continue;\\n            list.add(num);\\n            backtrack(lists, list, nums, i + 1);\\n            list.remove(list.size() - 1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 404517,
                "title": "backtracking-solution-without-using-set",
                "content": "```\\nclass Solution {\\n    \\n    private List<List<Integer>> result = new ArrayList<>();\\n    \\n    public List<List<Integer>> findSubsequences(int[] nums) {\\n        helper(nums, 0, new ArrayList<>());\\n        return result;\\n    }\\n    \\n    private void helper(int[] nums, int index, List<Integer> ans) {\\n        if (index > nums.length - 1) {\\n            if (ans.size() > 1) result.add(new ArrayList<>(ans));\\n            return;\\n        } \\n        \\n        if (ans.isEmpty() || nums[index] >= ans.get(ans.size() - 1)) {\\n            ans.add(nums[index]);\\n            helper(nums, index + 1, ans);\\n            ans.remove(ans.size() - 1);\\n        }\\n        \\n        // repeated value, so don\\'t need to drill down.\\n        if (index > 0 \\n            && ans.size() > 0 \\n            && nums[index] == ans.get(ans.size() - 1)) {\\n            return;\\n        }\\n        helper(nums, index + 1, ans);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    private List<List<Integer>> result = new ArrayList<>();\\n    \\n    public List<List<Integer>> findSubsequences(int[] nums) {\\n        helper(nums, 0, new ArrayList<>());\\n        return result;\\n    }\\n    \\n    private void helper(int[] nums, int index, List<Integer> ans) {\\n        if (index > nums.length - 1) {\\n            if (ans.size() > 1) result.add(new ArrayList<>(ans));\\n            return;\\n        } \\n        \\n        if (ans.isEmpty() || nums[index] >= ans.get(ans.size() - 1)) {\\n            ans.add(nums[index]);\\n            helper(nums, index + 1, ans);\\n            ans.remove(ans.size() - 1);\\n        }\\n        \\n        // repeated value, so don\\'t need to drill down.\\n        if (index > 0 \\n            && ans.size() > 0 \\n            && nums[index] == ans.get(ans.size() - 1)) {\\n            return;\\n        }\\n        helper(nums, index + 1, ans);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 379175,
                "title": "c-20-lines-backtracking-faster-than-99-different-thinking",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\\n        vector<vector<int>> ret;\\n        vector<vector<vector<int>>> dp(nums.size());\\n        for (int i = 0; i < nums.size(); ++i) {\\n            bool stop = false;\\n            for (int j = i-1; !stop && j >= 0; --j) {  // look back\\n                if (nums[j] == nums[i]) stop = true;  // duplicate found, stop look back\\n                if (nums[j] > nums[i]) continue;  // non-increasing num found, pass\\n                auto prv_res = dp[j];  // copy previous result\\n                for (auto& v : prv_res) {  \\n                    v.push_back(nums[i]);  // add cur num\\n                    ret.push_back(v);  // push to ret (must more than 2)\\n                }\\n                dp[i].insert(dp[i].end(), \\n                             make_move_iterator(prv_res.begin()), \\n                             make_move_iterator(prv_res.end()));  // move\\n            }\\n            if (!stop) dp[i].push_back({nums[i]});  // not found duplicate, add single cur num\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\\n        vector<vector<int>> ret;\\n        vector<vector<vector<int>>> dp(nums.size());\\n        for (int i = 0; i < nums.size(); ++i) {\\n            bool stop = false;\\n            for (int j = i-1; !stop && j >= 0; --j) {  // look back\\n                if (nums[j] == nums[i]) stop = true;  // duplicate found, stop look back\\n                if (nums[j] > nums[i]) continue;  // non-increasing num found, pass\\n                auto prv_res = dp[j];  // copy previous result\\n                for (auto& v : prv_res) {  \\n                    v.push_back(nums[i]);  // add cur num\\n                    ret.push_back(v);  // push to ret (must more than 2)\\n                }\\n                dp[i].insert(dp[i].end(), \\n                             make_move_iterator(prv_res.begin()), \\n                             make_move_iterator(prv_res.end()));  // move\\n            }\\n            if (!stop) dp[i].push_back({nums[i]});  // not found duplicate, add single cur num\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 337605,
                "title": "c-dfs-176ms-99-solution-w-exaplanation",
                "content": "The idea is to basically explore all permutations, with the following constraints:\\n\\nOnly add elements to permutation vector (```cur``` in my case) if:\\n1. The element is greater than the last element in ```cur```.\\n2. The element has not been previously added (say I have ```nums = [1, 3, 5, 7, 7]```, if I have permutation vector ```cur = [1, 3, 5]```, I will only add the first 7 and permute, but not the second 7).\\n3. ```cur``` is empty.\\n\\nThe second condition is required so we do not include duplicates. Picking the first occurance of a number eliminates duplicates but does not reduce possible permutations because any permutation that is possible with later occurances must also be possible with earlier occurances (any number greater than this number and appears after a later occurance of this number must also appear after the first occurance of this number).\\n\\nTo keep track of what numbers occured already, we use a bitfield (```visited``` in my case). Because the numbers are between [-100, 100], we can use a bitfield of size 201 and index each element by adding 100 to its actual value. This allows us to quickly check if a number has already been visited, at relatively light memory cost. (Memory usage from submission was 17.6 MB, beats 97%).\\n\\nThe run-time of this algorithm  is O(2^n), space complexity is O(n) due to implicit stack space from recursion.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\\n        if(nums.empty()) return {};\\n        vector<vector<int>> sol;\\n        vector<int> cur;\\n        permute(sol, nums, cur, 0);\\n        return sol;\\n    }\\n    static void permute(vector<vector<int>> &sol, const vector<int> &nums, vector<int> &cur, const int i) {\\n        const int size = nums.size();\\n        bitset<201> visited;\\n        for(int j = i; j < size; ++j) {\\n            int a = nums[j] + 100;\\n            if(!visited[a] && (cur.empty() || nums[j] >= cur.back())) {\\n                cur.emplace_back(nums[j]);\\n                if(cur.size() > 1) sol.emplace_back(cur);\\n                permute(sol, nums, cur, j+1);\\n                cur.pop_back();\\n                visited.set(a);\\n            }\\n        }\\n    } \\n};\\n\\nauto gucciGang = []() {std::ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);return 0;}();\\n```",
                "solutionTags": [],
                "code": "```cur```\n```cur```\n```nums = [1, 3, 5, 7, 7]```\n```cur = [1, 3, 5]```\n```cur```\n```visited```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\\n        if(nums.empty()) return {};\\n        vector<vector<int>> sol;\\n        vector<int> cur;\\n        permute(sol, nums, cur, 0);\\n        return sol;\\n    }\\n    static void permute(vector<vector<int>> &sol, const vector<int> &nums, vector<int> &cur, const int i) {\\n        const int size = nums.size();\\n        bitset<201> visited;\\n        for(int j = i; j < size; ++j) {\\n            int a = nums[j] + 100;\\n            if(!visited[a] && (cur.empty() || nums[j] >= cur.back())) {\\n                cur.emplace_back(nums[j]);\\n                if(cur.size() > 1) sol.emplace_back(cur);\\n                permute(sol, nums, cur, j+1);\\n                cur.pop_back();\\n                visited.set(a);\\n            }\\n        }\\n    } \\n};\\n\\nauto gucciGang = []() {std::ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);return 0;}();\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3926168,
                "title": "take-not-take-concept-and-use-set-for-unique-seq",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    set<vector<int>>ans;\\n    void backtrack(vector<int>&nums,int i,int prev,vector<int>path)\\n    {\\n        if(i>=nums.size())\\n        {\\n            if(path.size()>=2)ans.insert(path);\\n            return ;\\n        }\\n        //no take\\n        backtrack(nums,i+1,prev,path);\\n        //take\\n        if(nums[i]>=prev)\\n        {\\n            path.push_back(nums[i]);\\n            backtrack(nums,i+1,nums[i],path);\\n            path.pop_back();\\n        }\\n    }\\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\\n      vector<int>path;\\n        backtrack(nums,0,-101,path);\\n        vector<vector<int>>an;\\n        for(auto it:ans)an.push_back(it);\\n        return an;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    set<vector<int>>ans;\\n    void backtrack(vector<int>&nums,int i,int prev,vector<int>path)\\n    {\\n        if(i>=nums.size())\\n        {\\n            if(path.size()>=2)ans.insert(path);\\n            return ;\\n        }\\n        //no take\\n        backtrack(nums,i+1,prev,path);\\n        //take\\n        if(nums[i]>=prev)\\n        {\\n            path.push_back(nums[i]);\\n            backtrack(nums,i+1,nums[i],path);\\n            path.pop_back();\\n        }\\n    }\\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\\n      vector<int>path;\\n        backtrack(nums,0,-101,path);\\n        vector<vector<int>>an;\\n        for(auto it:ans)an.push_back(it);\\n        return an;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3282957,
                "title": "491-space-90-58-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Create an empty list to store the answer.\\n\\n2. Define a recursive function dfs that takes a starting index start and a list path as arguments.\\n\\n3. If the length of path is greater than 1, append a copy of path to the answer list.\\n\\n4. Create a set used to keep track of the numbers that have already been used in the current recursion path.\\n\\n5. Loop through the range start to the end of the nums list.\\n\\n6. If the current number has already been used, continue to the next iteration.\\n\\n7. If the path list is empty or the current number is greater than or equal to the last number in path, add the current number to the path list and mark it as used.\\n\\n8. Recursively call dfs with the current index plus 1 and the updated path list.\\n\\n9. Return the answer list after calling dfs with an initial start value of 0 and an empty path list.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n  def findSubsequences(self, nums: List[int]) -> List[List[int]]:\\n    ans = []\\n    \\n    def dfs(start: int, path: List[int]) -> None:\\n      if len(path) > 1:\\n        ans.append(path[:])\\n      \\n      used = set()\\n      for i in range(start, len(nums)):\\n        if nums[i] in used:\\n          continue\\n        if not path or nums[i] >= path[-1]:\\n          used.add(nums[i])\\n          dfs(i + 1, path + [nums[i]])\\n    \\n    dfs(0, [])\\n    return ans\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "Backtracking",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n  def findSubsequences(self, nums: List[int]) -> List[List[int]]:\\n    ans = []\\n    \\n    def dfs(start: int, path: List[int]) -> None:\\n      if len(path) > 1:\\n        ans.append(path[:])\\n      \\n      used = set()\\n      for i in range(start, len(nums)):\\n        if nums[i] in used:\\n          continue\\n        if not path or nums[i] >= path[-1]:\\n          used.add(nums[i])\\n          dfs(i + 1, path + [nums[i]])\\n    \\n    dfs(0, [])\\n    return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3079814,
                "title": "accepted-easy-solution-short-simple-best-method",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    set<vector<int>> s;\\n    void solve(vector<int> &nums, vector<int> v, int i)\\n    {\\n        if(i>=nums.size())\\n        {\\n            if(v.size()>=2)\\n            s.insert(v);\\n            return;\\n        }\\n        if(v.size()==0 || v.back()<=nums[i])\\n        {\\n            v.push_back(nums[i]);\\n            solve(nums, v, i+1);\\n            v.pop_back();\\n        }\\n        solve(nums, v, i+1);\\n    }\\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\\n        vector<int> v;\\n        solve(nums, v, 0);\\n        for(auto it:s)\\n        ans.push_back(it);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    set<vector<int>> s;\\n    void solve(vector<int> &nums, vector<int> v, int i)\\n    {\\n        if(i>=nums.size())\\n        {\\n            if(v.size()>=2)\\n            s.insert(v);\\n            return;\\n        }\\n        if(v.size()==0 || v.back()<=nums[i])\\n        {\\n            v.push_back(nums[i]);\\n            solve(nums, v, i+1);\\n            v.pop_back();\\n        }\\n        solve(nums, v, i+1);\\n    }\\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\\n        vector<int> v;\\n        solve(nums, v, 0);\\n        for(auto it:s)\\n        ans.push_back(it);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3078073,
                "title": "c-without-set",
                "content": "# Complexity\\n- Time complexity: O(2^N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N) \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n public:\\n  using Vec = std::vector<int>;\\n  using Vecs = std::vector<Vec>;\\n\\n  Vecs findSubsequences(const Vec& nums) {\\n    Vecs result;\\n    Vec path;\\n    backtracking(nums, 0, path, result);\\n    return result;\\n  }\\n\\n private:\\n  void backtracking(\\n      const Vec& nums, int index, Vec& path, Vecs& result) const {\\n    if (index == nums.size()) {\\n      if (path.size() > 1) {\\n        result.push_back(path);\\n      }\\n      return;\\n    }\\n    if (path.empty() || path.back() != nums[index]) {\\n      backtracking(nums, index + 1, path, result);\\n    }\\n    if (path.empty() || path.back() <= nums[index]) {\\n      path.push_back(nums[index]);\\n      backtracking(nums, index + 1, path, result);\\n      path.pop_back();\\n    }\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n public:\\n  using Vec = std::vector<int>;\\n  using Vecs = std::vector<Vec>;\\n\\n  Vecs findSubsequences(const Vec& nums) {\\n    Vecs result;\\n    Vec path;\\n    backtracking(nums, 0, path, result);\\n    return result;\\n  }\\n\\n private:\\n  void backtracking(\\n      const Vec& nums, int index, Vec& path, Vecs& result) const {\\n    if (index == nums.size()) {\\n      if (path.size() > 1) {\\n        result.push_back(path);\\n      }\\n      return;\\n    }\\n    if (path.empty() || path.back() != nums[index]) {\\n      backtracking(nums, index + 1, path, result);\\n    }\\n    if (path.empty() || path.back() <= nums[index]) {\\n      path.push_back(nums[index]);\\n      backtracking(nums, index + 1, path, result);\\n      path.pop_back();\\n    }\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3076229,
                "title": "easy-c-implementation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    set<vector<int>>ans;\\n    void f(vector<int>&nums,int i,int maxi,vector<int>temp){\\n        int n=nums.size();\\n       if(i==n){\\n           if(temp.size()>=2)\\n           ans.insert(temp);\\n           return;\\n       }\\n       if(nums[i]>=maxi){\\n           temp.push_back(nums[i]);\\n           f(nums,i+1,nums[i],temp);\\n       }\\n       if(nums[i]<maxi)\\n       f(nums,i+1,maxi,temp);\\n       else {\\n           temp.pop_back();\\n           f(nums,i+1,maxi,temp);\\n       }\\n    }\\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\\n      int n=nums.size();\\n      vector<int>temp;\\n      f(nums,0,INT_MIN,temp);\\n      vector<vector<int>>fans;\\n      for(auto it:ans){\\n          fans.push_back(it);\\n      }\\n      return fans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    set<vector<int>>ans;\\n    void f(vector<int>&nums,int i,int maxi,vector<int>temp){\\n        int n=nums.size();\\n       if(i==n){\\n           if(temp.size()>=2)\\n           ans.insert(temp);\\n           return;\\n       }\\n       if(nums[i]>=maxi){\\n           temp.push_back(nums[i]);\\n           f(nums,i+1,nums[i],temp);\\n       }\\n       if(nums[i]<maxi)\\n       f(nums,i+1,maxi,temp);\\n       else {\\n           temp.pop_back();\\n           f(nums,i+1,maxi,temp);\\n       }\\n    }\\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\\n      int n=nums.size();\\n      vector<int>temp;\\n      f(nums,0,INT_MIN,temp);\\n      vector<vector<int>>fans;\\n      for(auto it:ans){\\n          fans.push_back(it);\\n      }\\n      return fans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3075983,
                "title": "avoid-duplicates-without-using-set",
                "content": "*Nice Idea to avoid duplicates in this post -https://leetcode.com/problems/non-decreasing-subsequences/discussion/comments/1765599*\\n*Here is the implementation of it.*\\n<iframe src=\"https://leetcode.com/playground/VVqRsjb2/shared\" frameBorder=\"0\" width=\"800\" height=\"450\"></iframe>\\n\\n```\\nTo understand better let\\'t take the example of duplicates.\\nLet\\'s try to draw the recursion tree for [1,1]\\n\\n                               []\\n                            /      \\\\\\n                         [1]         []   -> take first index or not take\\n                        /   \\\\       /  \\\\\\n                     [1,1]  *[1]*  [1]  [] -> take second index or not take\\n\\nHere we can see if we remove the not take operation of marked branch\\nby checking if the current value is same as previous one or not,\\nwe can avoid duplicates.\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nTo understand better let\\'t take the example of duplicates.\\nLet\\'s try to draw the recursion tree for [1,1]\\n\\n                               []\\n                            /      \\\\\\n                         [1]         []   -> take first index or not take\\n                        /   \\\\       /  \\\\\\n                     [1,1]  *[1]*  [1]  [] -> take second index or not take\\n\\nHere we can see if we remove the not take operation of marked branch\\nby checking if the current value is same as previous one or not,\\nwe can avoid duplicates.\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3075654,
                "title": "easy-to-understand-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nI found all subsequnces first and inserted subsequences of size greater than equal to 2 in vector of vectors ans. then sorted it and removed duplicates from it. then i inserted only increasing subsequnces in new vector of vectors ans1 and returned ans1 at last.  \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\\n        vector <vector <int>> ans,ans1;\\n        vector <int> v;\\n        solution(0,nums,ans,v);\\n        sort(ans.begin(),ans.end());\\n        ans.erase(unique(ans.begin(),ans.end()),ans.end());\\n        int flag=0;\\n        for(int i=0;i<ans.size();i++){\\n            for(int j=1;j<ans[i].size();j++){\\n                if(ans[i][j]<ans[i][j-1]){\\n                    flag=1;\\n                    break;\\n                }\\n            }\\n            if(flag==0) ans1.push_back(ans[i]);\\n            flag=0;\\n        }\\n        return ans1;\\n    }\\n    void solution(int i,vector<int>& nums,vector <vector <int>> &ans,vector <int> &v){\\n        if(i>=nums.size() ){\\n            if(v.size()>=2)\\n                ans.push_back(v);\\n            return;\\n        }\\n       v.push_back(nums[i]);\\n        solution(i+1,nums,ans,v);\\n        v.pop_back();\\n        solution(i+1,nums,ans,v);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Sort",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\\n        vector <vector <int>> ans,ans1;\\n        vector <int> v;\\n        solution(0,nums,ans,v);\\n        sort(ans.begin(),ans.end());\\n        ans.erase(unique(ans.begin(),ans.end()),ans.end());\\n        int flag=0;\\n        for(int i=0;i<ans.size();i++){\\n            for(int j=1;j<ans[i].size();j++){\\n                if(ans[i][j]<ans[i][j-1]){\\n                    flag=1;\\n                    break;\\n                }\\n            }\\n            if(flag==0) ans1.push_back(ans[i]);\\n            flag=0;\\n        }\\n        return ans1;\\n    }\\n    void solution(int i,vector<int>& nums,vector <vector <int>> &ans,vector <int> &v){\\n        if(i>=nums.size() ){\\n            if(v.size()>=2)\\n                ans.push_back(v);\\n            return;\\n        }\\n       v.push_back(nums[i]);\\n        solution(i+1,nums,ans,v);\\n        v.pop_back();\\n        solution(i+1,nums,ans,v);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3075615,
                "title": "simple-c-js-java-beats-100-easy-solution-backtracking-approach-heavily-commented",
                "content": "\\n\\n# Intuition\\nSimply the intuition is recursively generate all the subsequences and backtrack .If u have solved the problem generate all the subsequneces it will be easy . So there is a concept Take or Not Take i.e either u take an element from the array or u don\\'t take it e.g\\nfor arr[] = {1, 2}. as shown\\n\\n![image.png](https://assets.leetcode.com/users/images/c82f9857-1107-48f9-a9d9-af9d48289e8f_1674251873.9484346.png)\\n\\nSo this is how we generate all the subsequences from a set .\\nSO keeping this in mind only thing we have to do here is check if the previous element is smaller than next elemnt inorder to keep in ascending order . So if this condition holds we should take it and if not we simply backtrack from there. Beacuse that branch will not lead to increasing subsequence so we simply backtrack from there.\\n\\n# Approach\\nSo do a recusrion and use the concept take or not take .\\nAnd check the condition : if curr>=prev\\nSome Coding Checks:\\nNote: if temp is empty check the minimum element since our least constarint here is \\u2212100-100\\u2212100 I have taken -105105105\\nFor duplicates store the subsequences in a set .\\nAlso check if temp.size()>1 then push vector in set .\\n\\n# Complexity\\n- Time complexity:$$O(2^n*n^2)$$\\n \\n- Space complexity:$$O(2^n*n)$$\\n\\n![image.png](https://assets.leetcode.com/users/images/ecb2d061-3673-4761-8267-4a96a53dce01_1674252508.7306173.png)\\n\\n```javascript []\\n\\nconst findSubsequences = function(nums) {\\n  return helper([], [], nums, 0)\\n};\\n\\nconst helper = (res, list, nums, index) => {\\n  if(list.length > 1) res.push([...list])\\n  const unique = new Set()\\n  \\n  for (let i = index; i < nums.length; i++) {\\n    if(nums[i] < nums[index - 1]) continue\\n\\n    if(unique.has(nums[i])) continue\\n    unique.add(nums[i])\\n    \\n    list.push(nums[i])\\n    helper(res, list, nums, i+1)\\n    list.pop()\\n  }\\n  \\n  return res\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    void func(int idx,vector<int>&nums,vector<int>&a,set<vector<int>>&ans){\\n        int n=nums.size();\\n        //If we have our index greater than or equal to sizeof nums then we cant go further \\n        //so we will check if there is a subarray with size greater than equal to 2\\n        if(idx>=n){\\n            if(a.size()>=2){\\n                //if we have such subarray we will insert it to the set\\n                ans.insert(a);\\n            }\\n            return ;\\n        }\\n        //now for [0,n-1] index we will check either condition for inserting into a vector\\n            //1. if a vector is empty so we can push the element easily\\n            //2. if a last element is less than equal to cur element\\n        if(!a.size()||nums[idx]>=a.back()){\\n            //we will push back into a vector and then call the func for idx+1;\\n            a.push_back(nums[idx]);\\n            func(idx+1,nums,a,ans);\\n            //we are removing element because a vector is being passed by reference\\n            a.pop_back();\\n        }\\n        //calling the function without that value\\n        func(idx+1,nums,a,ans); \\n    }\\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\\n        //we have made a temp vector for storing the values till an index\\n        vector<int>temp;\\n        //we have made a set of vector because there can be repeated elements which cause \\n        //repetion of subarray so set doesnt allow repetion of values\\n        set<vector<int>>ans;\\n        //we are calling our recursive function giving starting index to 0\\n        func(0,nums,temp,ans);\\n        //typecasting the set into vector and returning it we can do it manually also\\n        return vector(ans.begin(),ans.end());\\n        \\n    }\\n};\\n```\\n```java []\\nclass Solution {\\n    List<List<Integer>>vec=new ArrayList<>();\\n    HashSet<List<Integer>>set=new HashSet<>();\\n    void solve(int []nums, int prev, List<Integer>op, int idx){\\n        if(idx==nums.length){\\n            if(op.size()>1){\\n                set.add(op);\\n            }\\n            return;\\n        }\\n        if(prev==-1 || nums[idx]>=nums[prev]){\\n            List<Integer>op1=new ArrayList<>(op);\\n            op1.add(nums[idx]);\\n            solve(nums,idx,op1,idx+1);\\n        }\\n        solve(nums,prev,op,idx+1);\\n        \\n    }\\n    public List<List<Integer>> findSubsequences(int[] nums) {\\n        List<Integer>op=new ArrayList<>();\\n        solve(nums,-1,op, 0);\\n        Iterator<List<Integer>> it = set.iterator();\\n        while(it.hasNext())vec.add(it.next());\\n        return vec;\\n    }\\n}\\n```\\n\\nIf you really found my solution helpful please upvote it, as it motivates me to post such kind of codes.\\nLet me know in comment if i can do better.\\nLets connect on [Linkedin](https://www.linkedin.com/in/kailas-rathod/) \\n",
                "solutionTags": [
                    "JavaScript",
                    "Hash Table",
                    "Backtracking",
                    "Bit Manipulation"
                ],
                "code": "```javascript []\\n\\nconst findSubsequences = function(nums) {\\n  return helper([], [], nums, 0)\\n};\\n\\nconst helper = (res, list, nums, index) => {\\n  if(list.length > 1) res.push([...list])\\n  const unique = new Set()\\n  \\n  for (let i = index; i < nums.length; i++) {\\n    if(nums[i] < nums[index - 1]) continue\\n\\n    if(unique.has(nums[i])) continue\\n    unique.add(nums[i])\\n    \\n    list.push(nums[i])\\n    helper(res, list, nums, i+1)\\n    list.pop()\\n  }\\n  \\n  return res\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    void func(int idx,vector<int>&nums,vector<int>&a,set<vector<int>>&ans){\\n        int n=nums.size();\\n        //If we have our index greater than or equal to sizeof nums then we cant go further \\n        //so we will check if there is a subarray with size greater than equal to 2\\n        if(idx>=n){\\n            if(a.size()>=2){\\n                //if we have such subarray we will insert it to the set\\n                ans.insert(a);\\n            }\\n            return ;\\n        }\\n        //now for [0,n-1] index we will check either condition for inserting into a vector\\n            //1. if a vector is empty so we can push the element easily\\n            //2. if a last element is less than equal to cur element\\n        if(!a.size()||nums[idx]>=a.back()){\\n            //we will push back into a vector and then call the func for idx+1;\\n            a.push_back(nums[idx]);\\n            func(idx+1,nums,a,ans);\\n            //we are removing element because a vector is being passed by reference\\n            a.pop_back();\\n        }\\n        //calling the function without that value\\n        func(idx+1,nums,a,ans); \\n    }\\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\\n        //we have made a temp vector for storing the values till an index\\n        vector<int>temp;\\n        //we have made a set of vector because there can be repeated elements which cause \\n        //repetion of subarray so set doesnt allow repetion of values\\n        set<vector<int>>ans;\\n        //we are calling our recursive function giving starting index to 0\\n        func(0,nums,temp,ans);\\n        //typecasting the set into vector and returning it we can do it manually also\\n        return vector(ans.begin(),ans.end());\\n        \\n    }\\n};\\n```\n```java []\\nclass Solution {\\n    List<List<Integer>>vec=new ArrayList<>();\\n    HashSet<List<Integer>>set=new HashSet<>();\\n    void solve(int []nums, int prev, List<Integer>op, int idx){\\n        if(idx==nums.length){\\n            if(op.size()>1){\\n                set.add(op);\\n            }\\n            return;\\n        }\\n        if(prev==-1 || nums[idx]>=nums[prev]){\\n            List<Integer>op1=new ArrayList<>(op);\\n            op1.add(nums[idx]);\\n            solve(nums,idx,op1,idx+1);\\n        }\\n        solve(nums,prev,op,idx+1);\\n        \\n    }\\n    public List<List<Integer>> findSubsequences(int[] nums) {\\n        List<Integer>op=new ArrayList<>();\\n        solve(nums,-1,op, 0);\\n        Iterator<List<Integer>> it = set.iterator();\\n        while(it.hasNext())vec.add(it.next());\\n        return vec;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3075509,
                "title": "java-c-100-solution-using-backtracking-and-hashset-backtracking",
                "content": "# Complexity\\n- Time complexity: $$O(2^n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(2^n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```Java []\\nclass Solution {\\n    Set<List<Integer>> ans = new HashSet<>();\\n    List<Integer> subset = new ArrayList<>();\\n    public void genrateSubsequences(int[] nums,int idx)\\n    {\\n        if(nums.length==idx)\\n        {\\n            if(subset.size()>1)\\n                ans.add(new ArrayList<>(subset));\\n            return;\\n        }\\n        if(subset.size()==0 || subset.get(subset.size()-1)<=nums[idx])\\n        {\\n            subset.add(nums[idx]);\\n            genrateSubsequences(nums,idx+1);\\n            subset.remove(subset.size()-1);\\n        }\\n        genrateSubsequences(nums,idx+1);\\n    }\\n    public List<List<Integer>> findSubsequences(int[] nums) {\\n        genrateSubsequences(nums,0);\\n        return new ArrayList(ans);\\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    set<vector<int>> ans;\\n    vector<int> subset;\\n    void genrateSubsequences(vector<int>& nums,int idx)\\n    {\\n        if(nums.size()==idx)\\n        {\\n            if(subset.size()>1)\\n                ans.insert(subset);\\n            return;\\n        }\\n        if(subset.size()==0 || subset[subset.size()-1]<=nums[idx])\\n        {\\n            subset.push_back(nums[idx]);\\n            genrateSubsequences(nums,idx+1);\\n            subset.pop_back();\\n        }\\n        genrateSubsequences(nums,idx+1);\\n    }\\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\\n        genrateSubsequences(nums,0);\\n        vector<vector<int>> res(ans.begin(),ans.end());\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Hash Table",
                    "Backtracking"
                ],
                "code": "```Java []\\nclass Solution {\\n    Set<List<Integer>> ans = new HashSet<>();\\n    List<Integer> subset = new ArrayList<>();\\n    public void genrateSubsequences(int[] nums,int idx)\\n    {\\n        if(nums.length==idx)\\n        {\\n            if(subset.size()>1)\\n                ans.add(new ArrayList<>(subset));\\n            return;\\n        }\\n        if(subset.size()==0 || subset.get(subset.size()-1)<=nums[idx])\\n        {\\n            subset.add(nums[idx]);\\n            genrateSubsequences(nums,idx+1);\\n            subset.remove(subset.size()-1);\\n        }\\n        genrateSubsequences(nums,idx+1);\\n    }\\n    public List<List<Integer>> findSubsequences(int[] nums) {\\n        genrateSubsequences(nums,0);\\n        return new ArrayList(ans);\\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    set<vector<int>> ans;\\n    vector<int> subset;\\n    void genrateSubsequences(vector<int>& nums,int idx)\\n    {\\n        if(nums.size()==idx)\\n        {\\n            if(subset.size()>1)\\n                ans.insert(subset);\\n            return;\\n        }\\n        if(subset.size()==0 || subset[subset.size()-1]<=nums[idx])\\n        {\\n            subset.push_back(nums[idx]);\\n            genrateSubsequences(nums,idx+1);\\n            subset.pop_back();\\n        }\\n        genrateSubsequences(nums,idx+1);\\n    }\\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\\n        genrateSubsequences(nums,0);\\n        vector<vector<int>> res(ans.begin(),ans.end());\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3075423,
                "title": "backtracking-concise-c-solution",
                "content": "# Code\\n```\\nclass Solution {\\nprivate:\\n    // Helper function to recursively find all subsequences of increasing integers\\n    void findSubsequences(vector<int> &nums, vector<int> &subsequence,\\n                        set<vector<int> > &result, int size, int index) {\\n        // If the current subsequence size is greater than or equal to 2, add it to the set of results\\n        if (size >= 2)\\n            result.insert(subsequence);\\n        \\n        // Iterate through the remaining integers in the input vector\\n        for (int i = index; i < nums.size(); ++i) {\\n            // Check if the current integer is greater than or equal to the last element of the current subsequence\\n            // or if the current subsequence is empty\\n            if (subsequence.size() == 0 || nums[i] >= subsequence[subsequence.size() - 1]) {\\n                // Add the current integer to the current subsequence\\n                subsequence.push_back(nums[i]);\\n                // Recursively call the helper function with the updated subsequence, incremented index, and size\\n                findSubsequences(nums, subsequence, result, size + 1, i + 1);\\n                // Remove the last element of the current subsequence to backtrack and try other integers\\n                subsequence.pop_back();\\n            }\\n        }\\n    }\\n\\npublic:\\n    // Main function to find all subsequences of increasing integers in the input vector\\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\\n        // Set to store the results\\n        set<vector<int>> resultSet;\\n        // Vector to store the current subsequence\\n        vector<int> subsequence;\\n        // Call the helper function to find all subsequences\\n        findSubsequences(nums, subsequence, resultSet, 0, 0);\\n\\n        // Convert the set of results to a vector\\n        vector<vector<int>> result(resultSet.begin(), resultSet.end());\\n        // Return the vector of results\\n        return result;\\n    }\\n};\\n\\n```\\n\\n# Code without comment\\n```\\nclass Solution {\\nprivate:\\n    void findSubsequences(vector<int> &nums, vector<int> &subsequence,\\n                        set<vector<int> > &result, int size, int index) {\\n    if (size >= 2)\\n        result.insert(subsequence);\\n\\n\\n    for (int i = index; i < nums.size(); ++i) {\\n        if (subsequence.size() == 0 || nums[i] >= subsequence[subsequence.size() - 1]) {\\n            subsequence.push_back(nums[i]);\\n            findSubsequences(nums, subsequence, result, size + 1, i + 1);\\n            subsequence.pop_back();\\n        }\\n    }\\n}\\n\\npublic:\\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\\n        set<vector<int>> resultSet;\\n        vector<int> subsequence;\\n        findSubsequences(nums, subsequence, resultSet, 0, 0);\\n\\n        vector<vector<int>> result(resultSet.begin(), resultSet.end());\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    // Helper function to recursively find all subsequences of increasing integers\\n    void findSubsequences(vector<int> &nums, vector<int> &subsequence,\\n                        set<vector<int> > &result, int size, int index) {\\n        // If the current subsequence size is greater than or equal to 2, add it to the set of results\\n        if (size >= 2)\\n            result.insert(subsequence);\\n        \\n        // Iterate through the remaining integers in the input vector\\n        for (int i = index; i < nums.size(); ++i) {\\n            // Check if the current integer is greater than or equal to the last element of the current subsequence\\n            // or if the current subsequence is empty\\n            if (subsequence.size() == 0 || nums[i] >= subsequence[subsequence.size() - 1]) {\\n                // Add the current integer to the current subsequence\\n                subsequence.push_back(nums[i]);\\n                // Recursively call the helper function with the updated subsequence, incremented index, and size\\n                findSubsequences(nums, subsequence, result, size + 1, i + 1);\\n                // Remove the last element of the current subsequence to backtrack and try other integers\\n                subsequence.pop_back();\\n            }\\n        }\\n    }\\n\\npublic:\\n    // Main function to find all subsequences of increasing integers in the input vector\\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\\n        // Set to store the results\\n        set<vector<int>> resultSet;\\n        // Vector to store the current subsequence\\n        vector<int> subsequence;\\n        // Call the helper function to find all subsequences\\n        findSubsequences(nums, subsequence, resultSet, 0, 0);\\n\\n        // Convert the set of results to a vector\\n        vector<vector<int>> result(resultSet.begin(), resultSet.end());\\n        // Return the vector of results\\n        return result;\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\nprivate:\\n    void findSubsequences(vector<int> &nums, vector<int> &subsequence,\\n                        set<vector<int> > &result, int size, int index) {\\n    if (size >= 2)\\n        result.insert(subsequence);\\n\\n\\n    for (int i = index; i < nums.size(); ++i) {\\n        if (subsequence.size() == 0 || nums[i] >= subsequence[subsequence.size() - 1]) {\\n            subsequence.push_back(nums[i]);\\n            findSubsequences(nums, subsequence, result, size + 1, i + 1);\\n            subsequence.pop_back();\\n        }\\n    }\\n}\\n\\npublic:\\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\\n        set<vector<int>> resultSet;\\n        vector<int> subsequence;\\n        findSubsequences(nums, subsequence, resultSet, 0, 0);\\n\\n        vector<vector<int>> result(resultSet.begin(), resultSet.end());\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3075220,
                "title": "java-recursive-solution",
                "content": "\\n\\n\\n```\\nclass Solution {\\n    List<List<Integer>>vec=new ArrayList<>();\\n    HashSet<List<Integer>>set=new HashSet<>();\\n    void solve(int []nums, int prev, List<Integer>op, int idx){\\n        if(idx==nums.length){\\n            if(op.size()>1){\\n                set.add(op);\\n            }\\n            return;\\n        }\\n        if(prev==-1 || nums[idx]>=nums[prev]){\\n            List<Integer>op1=new ArrayList<>(op);\\n            op1.add(nums[idx]);\\n            solve(nums,idx,op1,idx+1);\\n        }\\n        solve(nums,prev,op,idx+1);\\n        \\n    }\\n    public List<List<Integer>> findSubsequences(int[] nums) {\\n        List<Integer>op=new ArrayList<>();\\n        solve(nums,-1,op, 0);\\n        Iterator<List<Integer>> it = set.iterator();\\n        while(it.hasNext())vec.add(it.next());\\n        return vec;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    List<List<Integer>>vec=new ArrayList<>();\\n    HashSet<List<Integer>>set=new HashSet<>();\\n    void solve(int []nums, int prev, List<Integer>op, int idx){\\n        if(idx==nums.length){\\n            if(op.size()>1){\\n                set.add(op);\\n            }\\n            return;\\n        }\\n        if(prev==-1 || nums[idx]>=nums[prev]){\\n            List<Integer>op1=new ArrayList<>(op);\\n            op1.add(nums[idx]);\\n            solve(nums,idx,op1,idx+1);\\n        }\\n        solve(nums,prev,op,idx+1);\\n        \\n    }\\n    public List<List<Integer>> findSubsequences(int[] nums) {\\n        List<Integer>op=new ArrayList<>();\\n        solve(nums,-1,op, 0);\\n        Iterator<List<Integer>> it = set.iterator();\\n        while(it.hasNext())vec.add(it.next());\\n        return vec;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3075216,
                "title": "backtracking-easy-to-understand-well-commented",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\nset<vector<int>>s;\\nvoid find_subset(int start_index,vector<int>&individual_subset,vector<int>&nums){\\n         //base case     \\n          if(start_index == nums.size()){\\n            return;\\n          }\\n           \\n  // RECURSION CALL --> (1) INCLUDE , (2)NOT-INCLUDE      \\n        //pick case --> i.e include case\\n        // keep adding value from nums to individual_subset\\n        individual_subset.push_back(nums[start_index]);\\n\\n //check if current individual_subset is sorted or not and it should not be duplicated and size>1 \\n       if(is_sorted(individual_subset.begin(),individual_subset.end()) and individual_subset.size()>1){\\n           s.insert(individual_subset);//stored in set\\n        }\\n\\n        // than go to next index and call find_subset again.\\n        find_subset(start_index+1,individual_subset,nums); \\n        \\n        //backtracking step\\n        // when we return at that time remove the last added value so that we can go for right recursion call pending   \\n        individual_subset.pop_back();\\n        \\n        //not pick --> i.e not-include case\\n        // go to next index and call find_subset again.\\n      find_subset(start_index+1,individual_subset,nums);     \\n}\\n\\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\\n        //backtracking \\n        //keep a set to avoid duplicates\\n         vector<vector<int>> ans; // stores all subset\\n         vector<int>individual_subset; // consist of all subset one by one\\n        // initially start_index is 0\\n        find_subset(0,individual_subset,nums); // function call  \\n         for(auto it : s) {\\n             ans.push_back(it);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\\n```\\nIf you find this solutions to be helpful do upvote..It keeps me motivated :)\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nset<vector<int>>s;\\nvoid find_subset(int start_index,vector<int>&individual_subset,vector<int>&nums){\\n         //base case     \\n          if(start_index == nums.size()){\\n            return;\\n          }\\n           \\n  // RECURSION CALL --> (1) INCLUDE , (2)NOT-INCLUDE      \\n        //pick case --> i.e include case\\n        // keep adding value from nums to individual_subset\\n        individual_subset.push_back(nums[start_index]);\\n\\n //check if current individual_subset is sorted or not and it should not be duplicated and size>1 \\n       if(is_sorted(individual_subset.begin(),individual_subset.end()) and individual_subset.size()>1){\\n           s.insert(individual_subset);//stored in set\\n        }\\n\\n        // than go to next index and call find_subset again.\\n        find_subset(start_index+1,individual_subset,nums); \\n        \\n        //backtracking step\\n        // when we return at that time remove the last added value so that we can go for right recursion call pending   \\n        individual_subset.pop_back();\\n        \\n        //not pick --> i.e not-include case\\n        // go to next index and call find_subset again.\\n      find_subset(start_index+1,individual_subset,nums);     \\n}\\n\\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\\n        //backtracking \\n        //keep a set to avoid duplicates\\n         vector<vector<int>> ans; // stores all subset\\n         vector<int>individual_subset; // consist of all subset one by one\\n        // initially start_index is 0\\n        find_subset(0,individual_subset,nums); // function call  \\n         for(auto it : s) {\\n             ans.push_back(it);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\n```\\nIf you find this solutions to be helpful do upvote..It keeps me motivated :)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3074905,
                "title": "c-easy-recursive-solution-using-set",
                "content": "# Intuition\\nAs the question says, we need to find all the combination of increasing subsequences, so recursive method is to be used.\\n\\n# Approach\\nWe use the typical pick/noPick approach using recursion. For every element of the array, we have two choices - either to pick it or ignore it. If we pick it, it becomes a part of the result, so we can only pick an element if the previously picked element is smaller than or equal to the current element.\\n\\n# Complexity\\n- Time complexity:\\nO(2^n) (recursion) + O(n) (set traversal) = O(2^n)\\n\\n- Space complexity:\\nO(n) (recursive stack space) + O(n) (set) = O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void f(int i, vector<int> nums, int prev, vector<int> & carry, set<vector<int>> &res) {\\n        if(i == nums.size()) {\\n            if(carry.size() >= 2) {\\n                res.insert(carry);\\n            }\\n            return;\\n        }\\n        f(i + 1, nums, prev, carry, res);\\n        if(prev == -1 || nums[prev] <= nums[i]) {\\n            carry.push_back(nums[i]);\\n            f(i + 1, nums, i, carry, res);\\n            carry.pop_back();\\n        }\\n    }\\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\\n        set<vector<int>> res;\\n        vector<int> carry;\\n        f(0, nums, -1, carry, res);\\n        vector<vector<int>> ans;\\n        for(vector<int> x : res) ans.push_back(x);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Backtracking",
                    "Recursion",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void f(int i, vector<int> nums, int prev, vector<int> & carry, set<vector<int>> &res) {\\n        if(i == nums.size()) {\\n            if(carry.size() >= 2) {\\n                res.insert(carry);\\n            }\\n            return;\\n        }\\n        f(i + 1, nums, prev, carry, res);\\n        if(prev == -1 || nums[prev] <= nums[i]) {\\n            carry.push_back(nums[i]);\\n            f(i + 1, nums, i, carry, res);\\n            carry.pop_back();\\n        }\\n    }\\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\\n        set<vector<int>> res;\\n        vector<int> carry;\\n        f(0, nums, -1, carry, res);\\n        vector<vector<int>> ans;\\n        for(vector<int> x : res) ans.push_back(x);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3074854,
                "title": "python3-backtracking-and-recursion",
                "content": "**Recursion** \\n\\n```\\nclass Solution:\\n    def findSubsequences(self, nums: List[int]) -> List[List[int]]:\\n        N = len(nums)\\n        ans = {}\\n        \\n        def rec(idx, arr):\\n            if len(arr) > 1: ans[tuple(arr)]= 1\\n                \\n            for i in range(idx, N):\\n                if nums[i] >= arr[-1]:\\n                    rec(i+1, arr+[nums[i]])\\n        \\n        for i in range(N): \\n            rec(i+1, [nums[i]])\\n            \\n        return ans.keys()\\n```\\n\\t\\t\\n**Backtracking**\\n```\\nclass Solution:\\n    def findSubsequences(self, nums: List[int]) -> List[List[int]]:\\n        N = len(nums)\\n        seq = []\\n        ans = {}\\n        \\n        def bt(idx):\\n            if len(seq) > 1:ans[tuple(seq)] = 1\\n                \\n            for i in range(idx, N):                    \\n                if not seq or (nums[i] >= seq[-1]):\\n                    seq.append(nums[i])\\n                    bt(i+1)\\n                    seq.pop()\\n                    \\n        bt(0)\\n        return ans.keys()",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def findSubsequences(self, nums: List[int]) -> List[List[int]]:\\n        N = len(nums)\\n        ans = {}\\n        \\n        def rec(idx, arr):\\n            if len(arr) > 1: ans[tuple(arr)]= 1\\n                \\n            for i in range(idx, N):\\n                if nums[i] >= arr[-1]:\\n                    rec(i+1, arr+[nums[i]])\\n        \\n        for i in range(N): \\n            rec(i+1, [nums[i]])\\n            \\n        return ans.keys()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3074852,
                "title": "most-space-friendly-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(2^N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N^2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def __init__(self):\\n        self.lst=[]\\n\\n    def fn(self,i,j,nums,lst,n):\\n        if i==n:\\n            return\\n        if j==-1 or nums[j]<=nums[i]:\\n            self.fn(i+1,i,nums,lst+[nums[i]],n)\\n            if len(lst)>=1 and lst+[nums[i]] not in self.lst:\\n                self.lst.append(lst+[nums[i]])\\n        self.fn(i+1,j,nums,lst,n)\\n        return\\n\\n    def findSubsequences(self, nums: List[int]) -> List[List[int]]:\\n        n=len(nums)\\n        self.fn(0,-1,nums,[],n)\\n        return self.lst\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def __init__(self):\\n        self.lst=[]\\n\\n    def fn(self,i,j,nums,lst,n):\\n        if i==n:\\n            return\\n        if j==-1 or nums[j]<=nums[i]:\\n            self.fn(i+1,i,nums,lst+[nums[i]],n)\\n            if len(lst)>=1 and lst+[nums[i]] not in self.lst:\\n                self.lst.append(lst+[nums[i]])\\n        self.fn(i+1,j,nums,lst,n)\\n        return\\n\\n    def findSubsequences(self, nums: List[int]) -> List[List[int]]:\\n        n=len(nums)\\n        self.fn(0,-1,nums,[],n)\\n        return self.lst\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3074834,
                "title": "swift-one-liner",
                "content": "**See Also:** Faster implementations for this problem [Two Approaches: DFS, Bitmask](https://leetcode.com/problems/non-decreasing-subsequences/discuss/3074884/Swift-or-Two-Approaches%3A-DFS-and-Bitmasks)\\n\\n---\\n\\n**One-Liner, terse (accepted answer)**\\n```\\nclass Solution {\\n    func findSubsequences(_ n: [Int]) -> [[Int]] {\\n        Set((2..<1<<n.count).map{b in n.indices.filter{b&1<<$0>0}.reduce(into: [Int]()) {p,i in if n[i] >= p.last ?? -100 {p+=[n[i]]}}}).filter{$0.count>1}\\n    }\\n}\\n```\\n\\n---\\n**One-Liner, expanded and annotated (accepted answer)**\\n```\\nclass Solution {\\n    func findSubsequences(_ nums: [Int]) -> [[Int]] {\\n        Set(\\n            (2 ..< (1 << nums.count)).map{ bits in // generate every bit mask for two or more elements in `nums`\\n                nums.indices // index is used to both index elements in `nums` and index bits in the bit mask \\n                .filter { index in bits & (1<<index) > 0 } // filter out indices that are not in the bit mask\\n                .reduce(into: [Int]()) { partialResult, index in \\n                    // if bitmasked array element is non-decreasing, add it\\n                    if partialResult.isEmpty || nums[index] >= partialResult.last! { \\n                        partialResult.append(nums[index])\\n                    }\\n                }\\n            }\\n        )\\n\\t\\t// finally, filter out elements that are too small \\n        .filter { partialResult in partialResult.count > 1 } \\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func findSubsequences(_ n: [Int]) -> [[Int]] {\\n        Set((2..<1<<n.count).map{b in n.indices.filter{b&1<<$0>0}.reduce(into: [Int]()) {p,i in if n[i] >= p.last ?? -100 {p+=[n[i]]}}}).filter{$0.count>1}\\n    }\\n}\\n```\n```\\nclass Solution {\\n    func findSubsequences(_ nums: [Int]) -> [[Int]] {\\n        Set(\\n            (2 ..< (1 << nums.count)).map{ bits in // generate every bit mask for two or more elements in `nums`\\n                nums.indices // index is used to both index elements in `nums` and index bits in the bit mask \\n                .filter { index in bits & (1<<index) > 0 } // filter out indices that are not in the bit mask\\n                .reduce(into: [Int]()) { partialResult, index in \\n                    // if bitmasked array element is non-decreasing, add it\\n                    if partialResult.isEmpty || nums[index] >= partialResult.last! { \\n                        partialResult.append(nums[index])\\n                    }\\n                }\\n            }\\n        )\\n\\t\\t// finally, filter out elements that are too small \\n        .filter { partialResult in partialResult.count > 1 } \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2576587,
                "title": "java-backtracking-heavily-commented",
                "content": "# Please Upvote :D\\n``` java []\\nclass Solution {\\n    // we use a hashset to avoid duplicacies\\n    private Set<List<Integer>> set;     \\n    public List<List<Integer>> findSubsequences(int[] nums) {\\n        set = new HashSet<>();\\n        // we pass in index 0 because that\\'s where we are starting from in nums\\n        // we pass an empty linked list, why lnkedlist?\\n        // because in java, linkedlist are easier to play with using inbuilt methods\\n        findSubsequences(nums, 0, new LinkedList<>());\\n        return new ArrayList<>(set);    // we return the set as an arraylist\\n    }\\n    \\n    private void findSubsequences(int[] nums, int index, LinkedList<Integer> currList) {\\n        // if the size of our current subsequence under consideration \\n        // has a size >= 2, its a candidate subsequence\\n        if (currList.size() >= 2) {\\n            // add it to the answer by making a copy of it\\n            // because currList is getting altered every now and then\\n            set.add(new ArrayList(currList));   \\n        }\\n        // we start iteration from the given index\\n        for (int i = index; i < nums.length; i++) {\\n            // if currList is empty, we have to add an element\\n            // otherwise, we add an element only if its greater than\\n            // the last element in the list (or subsequece) under consideration\\n            if (currList.isEmpty() || nums[i] >= currList.getLast()) {\\n                currList.add(nums[i]);      // we add the element\\n                // we call the function by passing in the next index\\n                // the function call will explore all possible subsequences \\n                // that can be made using elements right after nums[i]\\n                // say we have [4, 6], we will explore all subsequent elements \\n                // that can be added in the currrent list [4, 6]\\n                findSubsequences(nums, i + 1, currList);    \\n                // Here is the twist, when we are at an index, we can either add the element or ignore it\\n                // because we need subsequences (not subarrays), so we can skip an element and move to the next\\n                // EXAMPLE: We were at 4, and we added 6 after it\\n                // we can either add 6 to get [4, 6] or ignore 6 and move forward to 7 and make [4, 7]\\n                // because both are subsequences\\n                // so after we added 6 we called our function and we will now try without 6, so we remove 6 from [4, 6]\\n                // and before we remove 6, we will already have all the candidate subsequences\\n                // added to our answer by our function call which was given the task of exploring\\n                // and after exploration / addition of candidate subsequences to our ans list\\n                // it has come back to us by backtracking\\n                currList.removeLast();      // removes the last element in the list\\n                // we have done the removal, now the for loop will take us to the next element i.e. 7, \\n                // and we will call the function passing [4, 7]\\n            }\\n        }\\n    }\\n}\\n\\n// TC: O(n * 2^n)\\n// SC: O(n) -> Only hashset considered\\n```\\n---\\n#### Clean solution:\\n``` java\\nclass Solution {\\n    private Set<List<Integer>> set;     \\n    public List<List<Integer>> findSubsequences(int[] nums) {\\n        set = new HashSet<>();\\n        findSubsequences(nums, 0, new LinkedList<>());\\n        return new ArrayList<>(set);    \\n    }\\n    \\n    private void findSubsequences(int[] nums, int index, LinkedList<Integer> currList) {\\n        if (currList.size() >= 2) {\\n            set.add(new ArrayList(currList));   \\n        }\\n        for (int i = index; i < nums.length; i++) {\\n            if (currList.isEmpty() || nums[i] >= currList.getLast()) {\\n                currList.add(nums[i]);     \\n                findSubsequences(nums, i + 1, currList);    \\n                currList.removeLast();      \\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "``` java []\\nclass Solution {\\n    // we use a hashset to avoid duplicacies\\n    private Set<List<Integer>> set;     \\n    public List<List<Integer>> findSubsequences(int[] nums) {\\n        set = new HashSet<>();\\n        // we pass in index 0 because that\\'s where we are starting from in nums\\n        // we pass an empty linked list, why lnkedlist?\\n        // because in java, linkedlist are easier to play with using inbuilt methods\\n        findSubsequences(nums, 0, new LinkedList<>());\\n        return new ArrayList<>(set);    // we return the set as an arraylist\\n    }\\n    \\n    private void findSubsequences(int[] nums, int index, LinkedList<Integer> currList) {\\n        // if the size of our current subsequence under consideration \\n        // has a size >= 2, its a candidate subsequence\\n        if (currList.size() >= 2) {\\n            // add it to the answer by making a copy of it\\n            // because currList is getting altered every now and then\\n            set.add(new ArrayList(currList));   \\n        }\\n        // we start iteration from the given index\\n        for (int i = index; i < nums.length; i++) {\\n            // if currList is empty, we have to add an element\\n            // otherwise, we add an element only if its greater than\\n            // the last element in the list (or subsequece) under consideration\\n            if (currList.isEmpty() || nums[i] >= currList.getLast()) {\\n                currList.add(nums[i]);      // we add the element\\n                // we call the function by passing in the next index\\n                // the function call will explore all possible subsequences \\n                // that can be made using elements right after nums[i]\\n                // say we have [4, 6], we will explore all subsequent elements \\n                // that can be added in the currrent list [4, 6]\\n                findSubsequences(nums, i + 1, currList);    \\n                // Here is the twist, when we are at an index, we can either add the element or ignore it\\n                // because we need subsequences (not subarrays), so we can skip an element and move to the next\\n                // EXAMPLE: We were at 4, and we added 6 after it\\n                // we can either add 6 to get [4, 6] or ignore 6 and move forward to 7 and make [4, 7]\\n                // because both are subsequences\\n                // so after we added 6 we called our function and we will now try without 6, so we remove 6 from [4, 6]\\n                // and before we remove 6, we will already have all the candidate subsequences\\n                // added to our answer by our function call which was given the task of exploring\\n                // and after exploration / addition of candidate subsequences to our ans list\\n                // it has come back to us by backtracking\\n                currList.removeLast();      // removes the last element in the list\\n                // we have done the removal, now the for loop will take us to the next element i.e. 7, \\n                // and we will call the function passing [4, 7]\\n            }\\n        }\\n    }\\n}\\n\\n// TC: O(n * 2^n)\\n// SC: O(n) -> Only hashset considered\\n```\n``` java\\nclass Solution {\\n    private Set<List<Integer>> set;     \\n    public List<List<Integer>> findSubsequences(int[] nums) {\\n        set = new HashSet<>();\\n        findSubsequences(nums, 0, new LinkedList<>());\\n        return new ArrayList<>(set);    \\n    }\\n    \\n    private void findSubsequences(int[] nums, int index, LinkedList<Integer> currList) {\\n        if (currList.size() >= 2) {\\n            set.add(new ArrayList(currList));   \\n        }\\n        for (int i = index; i < nums.length; i++) {\\n            if (currList.isEmpty() || nums[i] >= currList.getLast()) {\\n                currList.add(nums[i]);     \\n                findSubsequences(nums, i + 1, currList);    \\n                currList.removeLast();      \\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2314980,
                "title": "c-set-of-vector-backtracking-easy-to-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> res;\\n    set<vector<int>> s;\\n    void backtrack(vector<int> &nums,int idx,vector<int>&v,int prev)\\n    {\\n        if(idx>=nums.size())\\n        {\\n            if(v.size()>1&&s.count(v)==0)\\n            {\\n                res.push_back(v);\\n                s.insert(v);\\n            }\\n            return;\\n        }\\n        if(nums[idx]>=prev)\\n        {\\n            v.push_back(nums[idx]);\\n            backtrack(nums,idx+1,v,nums[idx]);\\n            v.pop_back();\\n        }\\n        backtrack(nums,idx+1,v,prev);\\n    }\\n    vector<vector<int>> findSubsequences(vector<int>& nums)\\n    {\\n        vector<int> v;\\n        backtrack(nums,0,v,INT_MIN);\\n        return res;\\n        \\n    }\\n};\\n//if you like the solution plz upvote.",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Ordered Set"
                ],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> res;\\n    set<vector<int>> s;\\n    void backtrack(vector<int> &nums,int idx,vector<int>&v,int prev)\\n    {\\n        if(idx>=nums.size())\\n        {\\n            if(v.size()>1&&s.count(v)==0)\\n            {\\n                res.push_back(v);\\n                s.insert(v);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2101960,
                "title": "recursion-tree-backtracking-approach-c",
                "content": "**Conditions -**\\n* minimum size must be >=2 \\n* unique sequence so use set to remove duplicate sequence\\n\\nFrom every element we find increasing subsequence and as our seqeunce size hits >=2 we insert in set and iterate further in array\\n\\n![image](https://assets.leetcode.com/users/images/13cf2065-aa06-446d-8ec9-9fda2a57595e_1654164960.9084275.jpeg)\\n\\n```\\n    void solve(int ind,vector<int>& nums,vector<int> &ds,set<vector<int>> &st){\\n        if(ds.size()>=2){\\n            st.insert(ds);\\n        }\\n        \\n        for(int i=ind;i<nums.size();i++){\\n            if(ds.size()==0 || ds[ds.size()-1]<=nums[i]){\\n                ds.push_back(nums[i]);\\n                solve(i+1,nums,ds,st);\\n                ds.pop_back();\\n            }\\n        }\\n    }\\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\\n        vector<int> ds;\\n        set<vector<int>> st;\\n        solve(0,nums,ds,st);\\n        vector<vector<int>> ans(st.begin(),st.end());\\n        return ans;\\n    }\\n```\\n\\nI am newbie so if you find any error pls let me know.\\n",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\n    void solve(int ind,vector<int>& nums,vector<int> &ds,set<vector<int>> &st){\\n        if(ds.size()>=2){\\n            st.insert(ds);\\n        }\\n        \\n        for(int i=ind;i<nums.size();i++){\\n            if(ds.size()==0 || ds[ds.size()-1]<=nums[i]){\\n                ds.push_back(nums[i]);\\n                solve(i+1,nums,ds,st);\\n                ds.pop_back();\\n            }\\n        }\\n    }\\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\\n        vector<int> ds;\\n        set<vector<int>> st;\\n        solve(0,nums,ds,st);\\n        vector<vector<int>> ans(st.begin(),st.end());\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1641430,
                "title": "java-simple-solution-using-backtracking",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> findSubsequences(int[] nums) {\\n        HashSet<List<Integer>> res = new HashSet<>();\\n        \\n        List<Integer> curr = new ArrayList<>();\\n        \\n        backtrack(nums, res, curr, 0);\\n        \\n        List<List<Integer>> ans = new ArrayList<>(res);\\n         \\n        return ans;\\n    }\\n    \\n    public void backtrack(int[] nums, HashSet<List<Integer>> res, List<Integer> curr, int index){\\n        if(curr.size() > 1 && isIncreasing(curr))\\n            res.add(new ArrayList<>(curr));\\n        \\n        for(int i=index; i<nums.length; i++){\\n            curr.add(nums[i]);\\n            backtrack(nums, res, curr, i+1);\\n            curr.remove(curr.size()-1);\\n        }\\n    }\\n    \\n    public boolean isIncreasing(List<Integer> l){\\n        for(int i=1; i<l.size(); i++){\\n            if(l.get(i) < l.get(i-1))\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> findSubsequences(int[] nums) {\\n        HashSet<List<Integer>> res = new HashSet<>();\\n        \\n        List<Integer> curr = new ArrayList<>();\\n        \\n        backtrack(nums, res, curr, 0);\\n        \\n        List<List<Integer>> ans = new ArrayList<>(res);\\n         \\n        return ans;\\n    }\\n    \\n    public void backtrack(int[] nums, HashSet<List<Integer>> res, List<Integer> curr, int index){\\n        if(curr.size() > 1 && isIncreasing(curr))\\n            res.add(new ArrayList<>(curr));\\n        \\n        for(int i=index; i<nums.length; i++){\\n            curr.add(nums[i]);\\n            backtrack(nums, res, curr, i+1);\\n            curr.remove(curr.size()-1);\\n        }\\n    }\\n    \\n    public boolean isIncreasing(List<Integer> l){\\n        for(int i=1; i<l.size(); i++){\\n            if(l.get(i) < l.get(i-1))\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1502764,
                "title": "40ms-golang-recursion-backtracking",
                "content": "```\\nfunc findSubsequences(nums []int) [][]int {\\n\\tres := [][]int{}\\n\\tvar find func(int, []int)\\n\\tfind = func(i int, list []int) {\\n\\t\\tif len(list) > 1 {\\n\\t\\t\\tcp := make([]int, len(list))\\n\\t\\t\\tcopy(cp, list)\\n\\t\\t\\tres = append(res, cp)\\n\\t\\t}\\n\\t\\tvis := map[int]bool{}\\n\\t\\tfor j := i; j < len(nums); j++ {\\n\\t\\t\\tif (i > 0 && nums[j] < nums[i-1]) || vis[nums[j]] {\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\t\\t\\tvis[nums[j]] = true\\n\\t\\t\\tfind(j+1, append(list, nums[j]))\\n\\t\\t}\\n\\t}\\n\\tfind(0, []int{})\\n\\treturn res\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nfunc findSubsequences(nums []int) [][]int {\\n\\tres := [][]int{}\\n\\tvar find func(int, []int)\\n\\tfind = func(i int, list []int) {\\n\\t\\tif len(list) > 1 {\\n\\t\\t\\tcp := make([]int, len(list))\\n\\t\\t\\tcopy(cp, list)\\n\\t\\t\\tres = append(res, cp)\\n\\t\\t}\\n\\t\\tvis := map[int]bool{}\\n\\t\\tfor j := i; j < len(nums); j++ {\\n\\t\\t\\tif (i > 0 && nums[j] < nums[i-1]) || vis[nums[j]] {\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\t\\t\\tvis[nums[j]] = true\\n\\t\\t\\tfind(j+1, append(list, nums[j]))\\n\\t\\t}\\n\\t}\\n\\tfind(0, []int{})\\n\\treturn res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1271745,
                "title": "c-solution-using-dfs-and-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\\n        vector<int> v;\\n        set<vector<int>> st;\\n        dfs(st,v,nums,0);\\n        return vector<vector<int>>(st.begin(),st.end());\\n    }\\n    void dfs(set<vector<int>> &st,vector<int> &v,vector<int> nums,int start)\\n    {\\n        int n = nums.size();\\n        if(v.size() >= 2)\\n            st.insert(v);\\n        else if(start == n)\\n            return;\\n        \\n        for(int i=start;i<n;++i)\\n        {\\n            if(v.size() == 0 || v.back() <= nums[i])\\n            {\\n                v.push_back(nums[i]);\\n                dfs(st,v,nums,i+1);\\n                v.pop_back();\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\\n        vector<int> v;\\n        set<vector<int>> st;\\n        dfs(st,v,nums,0);\\n        return vector<vector<int>>(st.begin(),st.end());\\n    }\\n    void dfs(set<vector<int>> &st,vector<int> &v,vector<int> nums,int start)\\n    {\\n        int n = nums.size();\\n        if(v.size() >= 2)\\n            st.insert(v);\\n        else if(start == n)\\n            return;\\n        \\n        for(int i=start;i<n;++i)\\n        {\\n            if(v.size() == 0 || v.back() <= nums[i])\\n            {\\n                v.push_back(nums[i]);\\n                dfs(st,v,nums,i+1);\\n                v.pop_back();\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1174082,
                "title": "c-dfs-backtracking-easily-understandable",
                "content": "```\\nclass Solution {\\npublic:\\n    set<vector<int>> result;\\n    vector<int> temp;\\n    void solve(vector<int> nums,int src,int last){\\n        if(temp.size()>1)\\n            result.insert(temp);\\n        for(int i=src;i<nums.size();i++){\\n            if(nums[i]>=last){\\n                temp.push_back(nums[i]);\\n                solve(nums,i+1,nums[i]);\\n                temp.pop_back();\\n            }else{\\n                solve(nums,i+1,last);\\n            }\\n        }\\n    }\\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\\n        solve(nums,0,INT_MIN);\\n        vector<vector<int>> res(result.begin(),result.end());\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    set<vector<int>> result;\\n    vector<int> temp;\\n    void solve(vector<int> nums,int src,int last){\\n        if(temp.size()>1)\\n            result.insert(temp);\\n        for(int i=src;i<nums.size();i++){\\n            if(nums[i]>=last){\\n                temp.push_back(nums[i]);\\n                solve(nums,i+1,nums[i]);\\n                temp.pop_back();\\n            }else{\\n                solve(nums,i+1,last);\\n            }\\n        }\\n    }\\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\\n        solve(nums,0,INT_MIN);\\n        vector<vector<int>> res(result.begin(),result.end());\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1071523,
                "title": "simple-js-beats-100",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[][]}\\n */\\nconst findSubsequences = function(nums) {\\n  return helper([], [], nums, 0)\\n};\\n\\nconst helper = (res, list, nums, index) => {\\n  if(list.length > 1) res.push([...list])\\n  const unique = new Set()\\n  \\n  for (let i = index; i < nums.length; i++) {\\n    if(nums[i] < nums[index - 1]) continue\\n\\n    if(unique.has(nums[i])) continue\\n    unique.add(nums[i])\\n    \\n    list.push(nums[i])\\n    helper(res, list, nums, i+1)\\n    list.pop()\\n  }\\n  \\n  return res\\n}\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[][]}\\n */\\nconst findSubsequences = function(nums) {\\n  return helper([], [], nums, 0)\\n};\\n\\nconst helper = (res, list, nums, index) => {\\n  if(list.length > 1) res.push([...list])\\n  const unique = new Set()\\n  \\n  for (let i = index; i < nums.length; i++) {\\n    if(nums[i] < nums[index - 1]) continue\\n\\n    if(unique.has(nums[i])) continue\\n    unique.add(nums[i])\\n    \\n    list.push(nums[i])\\n    helper(res, list, nums, i+1)\\n    list.pop()\\n  }\\n  \\n  return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 896252,
                "title": "java-c-set-and-recursion-solution-easy-to-understand",
                "content": "if you like it pls upvote\\n\\nJava\\n```\\nclass Solution {\\n    public List<List<Integer>> findSubsequences(int[] nums) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        Set<List<Integer>> set = new HashSet<>();\\n        adder(nums,res,0,new ArrayList<>(),set);\\n        \\n        return res;\\n    }\\n    void adder(int[] nums , List<List<Integer>> res , int index, List<Integer> temp,Set<List<Integer>> set){\\n        if(temp.size() >=2){\\n            List<Integer> gg = new ArrayList<>(temp);\\n            if(!set.contains(gg))\\n                res.add(gg);\\n            set.add(gg);\\n        }\\n        if(index >=nums.length) return;\\n        if(temp.size() ==0 || temp.get(temp.size()-1)<=nums[index]){\\n            temp.add(nums[index]);\\n            adder(nums,res,index+1,temp,set);\\n            temp.remove(temp.size()-1);\\n        }\\n        adder(nums,res,index+1,temp,set);\\n    }\\n}\\n```\\n\\nC++\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> res;\\n    map<vector<int>,int> map;\\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\\n        \\n        vector<int> temp;\\n        adder(nums,0,temp);\\n        \\n        return res;\\n    }\\n    void adder(vector<int>& nums , int index, vector<int> temp){\\n        if(temp.size() >=2){\\n            vector<int> gg = temp;\\n            if(!map.count(gg))\\n                res.push_back(gg);\\n            map[gg] = 1;\\n        }\\n        if(index >=nums.size()) return;\\n        if(temp.size() ==0 || temp[temp.size()-1]<=nums[index]){\\n            temp.push_back(nums[index]);\\n            adder(nums,index+1,temp);\\n            temp.erase(temp.end()-1,temp.end());\\n        }\\n        adder(nums,index+1,temp);\\n    }\\n\\n};\\n\\n\\n```",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> findSubsequences(int[] nums) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        Set<List<Integer>> set = new HashSet<>();\\n        adder(nums,res,0,new ArrayList<>(),set);\\n        \\n        return res;\\n    }\\n    void adder(int[] nums , List<List<Integer>> res , int index, List<Integer> temp,Set<List<Integer>> set){\\n        if(temp.size() >=2){\\n            List<Integer> gg = new ArrayList<>(temp);\\n            if(!set.contains(gg))\\n                res.add(gg);\\n            set.add(gg);\\n        }\\n        if(index >=nums.length) return;\\n        if(temp.size() ==0 || temp.get(temp.size()-1)<=nums[index]){\\n            temp.add(nums[index]);\\n            adder(nums,res,index+1,temp,set);\\n            temp.remove(temp.size()-1);\\n        }\\n        adder(nums,res,index+1,temp,set);\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> res;\\n    map<vector<int>,int> map;\\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\\n        \\n        vector<int> temp;\\n        adder(nums,0,temp);\\n        \\n        return res;\\n    }\\n    void adder(vector<int>& nums , int index, vector<int> temp){\\n        if(temp.size() >=2){\\n            vector<int> gg = temp;\\n            if(!map.count(gg))\\n                res.push_back(gg);\\n            map[gg] = 1;\\n        }\\n        if(index >=nums.size()) return;\\n        if(temp.size() ==0 || temp[temp.size()-1]<=nums[index]){\\n            temp.push_back(nums[index]);\\n            adder(nums,index+1,temp);\\n            temp.erase(temp.end()-1,temp.end());\\n        }\\n        adder(nums,index+1,temp);\\n    }\\n\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 774060,
                "title": "java-recursive-back-tracking-with-set",
                "content": "The idea here is to use backtracking to generate all increasing subsequences, when the current subsequence is of length greater than 1, we attempt to add it to our set. If set doesn\\'t contain such list, it can go in the result list.\\n\\nI recommend going over question #78 Subsets (https://leetcode.com/problems/subsets/) before attempting this question using the backtracking approach.\\n\\n```\\nclass Solution {\\n    private Set<List<Integer>> set = new HashSet();\\n    \\n    public List<List<Integer>> findSubsequences(int[] nums) {\\n        List<List<Integer>> list = new ArrayList();     \\n        backTrack(nums, 0, new ArrayList(), list, set);\\n        return list;\\n    }\\n    \\n    \\n    public void backTrack(int[] nums, int index, List<Integer> currList, List<List<Integer>> list, Set<List<Integer>> set) {\\n        if (currList.size() > 1 && set.add(new ArrayList(currList))) {\\n            list.add(new ArrayList(currList));            \\n        }\\n        \\n        for (int i = index; i < nums.length; i++) {\\n            if (currList.size() == 0 || currList.get(currList.size()-1) <= nums[i]) {\\n                currList.add(nums[i]);\\n                backTrack(nums, i+1, currList, list, set);\\n                currList.remove(currList.size()-1);  \\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    private Set<List<Integer>> set = new HashSet();\\n    \\n    public List<List<Integer>> findSubsequences(int[] nums) {\\n        List<List<Integer>> list = new ArrayList();     \\n        backTrack(nums, 0, new ArrayList(), list, set);\\n        return list;\\n    }\\n    \\n    \\n    public void backTrack(int[] nums, int index, List<Integer> currList, List<List<Integer>> list, Set<List<Integer>> set) {\\n        if (currList.size() > 1 && set.add(new ArrayList(currList))) {\\n            list.add(new ArrayList(currList));            \\n        }\\n        \\n        for (int i = index; i < nums.length; i++) {\\n            if (currList.size() == 0 || currList.get(currList.size()-1) <= nums[i]) {\\n                currList.add(nums[i]);\\n                backTrack(nums, i+1, currList, list, set);\\n                currList.remove(currList.size()-1);  \\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 459434,
                "title": "readable-python-dfs",
                "content": "```py\\nfrom collections import defaultdict\\nclass Solution:\\n    def findSubsequences(self, nums: List[int]) -> List[List[int]]:\\n        # graph \\n        # nodes are index\\n        # edges are if greater than or eq\\n        \\n        # construct\\n        graph = defaultdict(list)\\n        for i, v in enumerate(nums):\\n            for j in range(i+1, len(nums)):\\n                if nums[j] >= v:\\n                    graph[i].append(j)\\n        \\n        # print(graph)\\n        res = set()\\n        stack = []\\n        def dfs(node):\\n            stack.append(nums[node])\\n            # print(node)\\n            \\n            if (len(stack) >= 2):\\n                com = tuple(stack)\\n                # print(com)\\n                res.add(com)\\n            \\n            if node in graph:  # prevent defaultdict adding key on access\\n                for nei in graph[node]:\\n                    dfs(nei)\\n            \\n            stack.pop()\\n        \\n        # dfs each root \\n        for root in graph:\\n            dfs(root)\\n            \\n        return [list(tu) for tu in res]\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```py\\nfrom collections import defaultdict\\nclass Solution:\\n    def findSubsequences(self, nums: List[int]) -> List[List[int]]:\\n        # graph \\n        # nodes are index\\n        # edges are if greater than or eq\\n        \\n        # construct\\n        graph = defaultdict(list)\\n        for i, v in enumerate(nums):\\n            for j in range(i+1, len(nums)):\\n                if nums[j] >= v:\\n                    graph[i].append(j)\\n        \\n        # print(graph)\\n        res = set()\\n        stack = []\\n        def dfs(node):\\n            stack.append(nums[node])\\n            # print(node)\\n            \\n            if (len(stack) >= 2):\\n                com = tuple(stack)\\n                # print(com)\\n                res.add(com)\\n            \\n            if node in graph:  # prevent defaultdict adding key on access\\n                for nei in graph[node]:\\n                    dfs(nei)\\n            \\n            stack.pop()\\n        \\n        # dfs each root \\n        for root in graph:\\n            dfs(root)\\n            \\n        return [list(tu) for tu in res]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 97167,
                "title": "python-basic-dfs",
                "content": "    class Solution(object):\\n        def findSubsequences(self, nums):\\n            ans = []\\n            self.helper(ans, nums, [], 0)\\n            return ans\\n        \\n        def helper(self, ans, nums, temp, pos):\\n            if len(temp) >= 2:\\n                ans.append(temp)\\n            visited = set()\\n            for i in range(pos, len(nums)):\\n                if not temp or temp[-1] <= nums[i]:\\n                    if nums[i] not in visited:\\n                        self.helper(ans, nums, temp+[nums[i]], i+1)\\n                        visited.add(nums[i])",
                "solutionTags": [],
                "code": "    class Solution(object):\\n        def findSubsequences(self, nums):\\n            ans = []\\n            self.helper(ans, nums, [], 0)\\n            return ans\\n        \\n        def helper(self, ans, nums, temp, pos):\\n            if len(temp) >= 2:\\n                ans.append(temp)\\n            visited = set()\\n            for i in range(pos, len(nums)):\\n                if not temp or temp[-1] <= nums[i]:\\n                    if nums[i] not in visited:\\n                        self.helper(ans, nums, temp+[nums[i]], i+1)\\n                        visited.add(nums[i])",
                "codeTag": "Java"
            },
            {
                "id": 97192,
                "title": "9-liner-beat-98-8-no-set-vector-hasher-or-helper-function-detailed-explanation",
                "content": "This is a rewritten version from @Mxxx's great solution which does not use set, DFS or vector hasher. (I give my applause to the latter especially)\\n\\nIn my opinion, the challenge of this problem is actually ***how to detect and avoid duplicated subsequences in the result***. Many fellow coders used set of arrays to automatically avoid duplicates. However, I do not quite prefer this strategy because \\n* not every programming language provides default hasher for vectors and\\n* hash to compare vectors might not be cheap. \\n\\nIn other words, *because `vector` is not a sigular data structure which contains `O(N)` amount of data, any sort of hash/comparison of `vector`'s to check duplicates will not be cheap, and we should avoid to do so.*\\n\\n**Simple Case:** If given array `a[]` has **distinct** numbers, the algorithm will be trivial to employ DP directly without worry for duplicates. Consider how many new increasing subsequences from `a[0:i]` compared with `a[0:i-1]`:\\n1. for any `a[j] < a[i]`, construct size `2` array `{a[j], a[i]}`;\\n2. for any increasing subsequence `seq` in `a[0:i-1]`, if `seq.back() < a[i]`, construct a new sequence by appending `a[i]` to `seq`. \\n\\n**General Case:** When `a[]` has duplicates, simply appending last entry to the results of previous arrays will certainly cause duplicates. Well, the duplicates are caused by the identical values which already appear in previous increasing subsequences. So we can decompose previous result into segments with each segments containing the new subsequences. \\n\\nUse `d[i] = 0` or `1` to denote if value `a[i]` already appeared in the array previously. Use index interval `[s[i], s[i+1])` to denote the index range of new sebsequences contributed by `a[i]`.\\n\\nConsider array `a[] = {1, 2, 1, 2}` with initial result `res = {}`, scan from left and we have,\\n* `{[1], 2, 1, 2}`: `s[0] = 0, d[0] = 0, res = {}`;\\n* `{1, [2], 1, 2}`: `s[1] = 0, d[1] = 0, res = {[1,2]}`;\\n* `{1, 2, [1], 2}`: `s[2] = 1, d[2] = 1, res = {[1,2], [1,1]}`;\\n* `{1, 2, 1, [2]}`: `s[3] = 2, d[3] = 1, res = {[1,2], [1,1], [1,1,2], [2,2], [1,2,2]}`.\\n\\nNote that when last `2` is scanned, we go backward to check each previous entry:\\n* `a[2] = 1` is a duplicate, so do not construct `[1,2]`. Only append `2` to the result contributed by `a[2]`, i.e., `[1,1]+2`;\\n* `a[1] = 2` is not a duplicate, so construct `[2,2]`.  append `2` to the result contributed by `a[1]`, i.e., `[1,2]+2`. Then we found that `a[1]` is duplicated with the currently scanned `a[3]` and there will be no more new sequences because any sequences constructed before `a[1]` are already appended by`a[1]` which is same as `a[3]`.\\n\\nTherefore, `[1,1,2], [2,2], [1,2,2]` are the new additions when last `2` is scanned.\\n```\\n    vector<vector<int>> findSubsequences(vector<int>& a) {\\n        if(a.size() < 2) return {};\\n        vector<vector<int>> res; int s[a.size()], d[a.size()], j;\\n        for(int i=0; i<a.size(); ++i)\\n            for(j=i-1, s[i]=res.size(), d[i]=0; j>=0; --j)\\n                if(a[j] <= a[i]) {\\n                    if(!d[j]) res.push_back({a[j], a[i]});\\n                    for(int k=s[j];k<s[j+1];++k) res.push_back(res[k]), res.back().push_back(a[i]);\\n                    if(d[i] = a[j]==a[i]) break;\\n                }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\n    vector<vector<int>> findSubsequences(vector<int>& a) {\\n        if(a.size() < 2) return {};\\n        vector<vector<int>> res; int s[a.size()], d[a.size()], j;\\n        for(int i=0; i<a.size(); ++i)\\n            for(j=i-1, s[i]=res.size(), d[i]=0; j>=0; --j)\\n                if(a[j] <= a[i]) {\\n                    if(!d[j]) res.push_back({a[j], a[i]});\\n                    for(int k=s[j];k<s[j+1];++k) res.push_back(res[k]), res.back().push_back(a[i]);\\n                    if(d[i] = a[j]==a[i]) break;\\n                }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 97186,
                "title": "java-solution-beats-100-so-far-just-so-far",
                "content": "My thinking process is pretty straightforward. When we iterate the array, if we could know all the existing subsequences whose last elements are equal or smaller than current number, we could generate all subsequences ending with current number by simply appending current number to those found subsequences. \\nTo achieve this, we could directly come up with a data structure to store previously generated subsequences, and to make it more efficient, we could choose a map, specifically TreeMap will be a good choice.\\nThen the most tricky part is how to avoid the duplicate subsequences in our result. For example, [1,2,2,3], with this approach, the workflow will be:\\n\\n```\\n1. [1(cur), 2, 2, 3] \\n    Storage: \\n    {\\n      1:[1]\\n    }\\n2. [1, 2(cur), 2, 3]\\n    Storage: \\n    {\\n       1: [[1]],\\n       2: [[1,2],[2]]\\n   }\\n3. [1, 2, 2(cur), 3] \\n   Storage:\\n   {\\n      1: [[1]],\\n      2: [[1,2],[2]]\\n      2: [[1,2], [1,2,2],[2,2]] // is this correct?\\n   }\\n```\\nWe know both 1 and 2 are smaller or equal than 2 in third step above, but should we append 2 to the tails of both of subsequences ending with 1 and 2. We should not, In this case, the trick is that we don't create new subsequences for those whose last elements is equal to current number, we just append the 2 in current subsequence to override previous ones. So in third step, it will be:\\n```\\n3. [1, 2, 2(cur), 3] \\n   Storage:\\n   {\\n      1: [[1]],\\n      2: [[1,2,2],[2,2],[1,2],[2]] // remember to add [2] in the list\\n   }\\n```\\n\\nThe code is below. As we know that the final result would have 2^n subsequences, the worst runtime for this algorithm will still be O(2^n). \\n\\n```\\n public class Solution {\\n    public List<List<Integer>> findSubsequences(int[] nums) {\\n        int n = nums.length;\\n        \\n        TreeMap<Integer, List<List<Integer>>> map = new TreeMap<>();\\n        for (int i = 0; i < n; i ++) {\\n            \\n            List<List<Integer>> cur = map.get(nums[i]); // the list of sequences ending with current number\\n            if (cur == null) {\\n                cur = new ArrayList<>();\\n                map.put(nums[i], cur);\\n            }\\n            int size = cur.size();\\n            // retrieve all subsequences ending with the number smaller or equal than current number\\n            Map<Integer, List<List<Integer>>> submap = map.headMap(nums[i], true); \\n            final int id = i;\\n            final List<List<Integer>> curList = cur;\\n            submap.forEach((k, v) -> {\\n                if (k == nums[id]) {\\n                    for (int j = 0; j < size; j ++) {\\n                        curList.get(j).add(nums[id]); // directly append the number in current subsequence\\n                    }\\n                } else {\\n                    for (List<Integer> list : v) {\\n                        List<Integer> nl = new ArrayList<>(list);\\n                        nl.add(nums[id]);\\n                        curList.add(nl);\\n                    }\\n                }\\n            });\\n            // Add current number as a list with single element for later use\\n            List<Integer> single = new ArrayList<>();\\n            single.add(nums[i]);\\n            cur.add(single);\\n        }\\n        \\n        List<List<Integer>> res = new ArrayList<>();\\n        for (List<List<Integer>> list : map.values()) {\\n            list.remove(list.size() - 1); // remove the list with single element\\n            res.addAll(list);\\n        }\\n        return res;\\n    }\\n}\\n\\n```\\n\\nComments are welcome. If the description are hard to understand, please let me know.",
                "solutionTags": [],
                "code": "```\\n1. [1(cur), 2, 2, 3] \\n    Storage: \\n    {\\n      1:[1]\\n    }\\n2. [1, 2(cur), 2, 3]\\n    Storage: \\n    {\\n       1: [[1]],\\n       2: [[1,2],[2]]\\n   }\\n3. [1, 2, 2(cur), 3] \\n   Storage:\\n   {\\n      1: [[1]],\\n      2: [[1,2],[2]]\\n      2: [[1,2], [1,2,2],[2,2]] // is this correct?\\n   }\\n```\n```\\n3. [1, 2, 2(cur), 3] \\n   Storage:\\n   {\\n      1: [[1]],\\n      2: [[1,2,2],[2,2],[1,2],[2]] // remember to add [2] in the list\\n   }\\n```\n```\\n public class Solution {\\n    public List<List<Integer>> findSubsequences(int[] nums) {\\n        int n = nums.length;\\n        \\n        TreeMap<Integer, List<List<Integer>>> map = new TreeMap<>();\\n        for (int i = 0; i < n; i ++) {\\n            \\n            List<List<Integer>> cur = map.get(nums[i]); // the list of sequences ending with current number\\n            if (cur == null) {\\n                cur = new ArrayList<>();\\n                map.put(nums[i], cur);\\n            }\\n            int size = cur.size();\\n            // retrieve all subsequences ending with the number smaller or equal than current number\\n            Map<Integer, List<List<Integer>>> submap = map.headMap(nums[i], true); \\n            final int id = i;\\n            final List<List<Integer>> curList = cur;\\n            submap.forEach((k, v) -> {\\n                if (k == nums[id]) {\\n                    for (int j = 0; j < size; j ++) {\\n                        curList.get(j).add(nums[id]); // directly append the number in current subsequence\\n                    }\\n                } else {\\n                    for (List<Integer> list : v) {\\n                        List<Integer> nl = new ArrayList<>(list);\\n                        nl.add(nums[id]);\\n                        curList.add(nl);\\n                    }\\n                }\\n            });\\n            // Add current number as a list with single element for later use\\n            List<Integer> single = new ArrayList<>();\\n            single.add(nums[i]);\\n            cur.add(single);\\n        }\\n        \\n        List<List<Integer>> res = new ArrayList<>();\\n        for (List<List<Integer>> list : map.values()) {\\n            list.remove(list.size() - 1); // remove the list with single element\\n            res.addAll(list);\\n        }\\n        return res;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367751,
                "title": "python3-very-easy-solution-backtracking",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n    please upvote if its useful\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def __init__(self):\\n        self.ans = set()\\n    def findSubsequences(self, nums: List[int]) -> List[List[int]]:\\n        self.sol(0 , [] , nums)\\n        return sorted(self.ans)\\n    def sol(self ,idx ,  path , nums):\\n        if len(path)>1:\\n            if sorted(path) == path:\\n                self.ans.add(tuple(path[:]))\\n        for i in range(idx , len(nums)):\\n            self.sol(i+1, path + [nums[i]] , nums)\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Hash Table",
                    "Backtracking",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def __init__(self):\\n        self.ans = set()\\n    def findSubsequences(self, nums: List[int]) -> List[List[int]]:\\n        self.sol(0 , [] , nums)\\n        return sorted(self.ans)\\n    def sol(self ,idx ,  path , nums):\\n        if len(path)>1:\\n            if sorted(path) == path:\\n                self.ans.add(tuple(path[:]))\\n        for i in range(idx , len(nums)):\\n            self.sol(i+1, path + [nums[i]] , nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3092118,
                "title": "python-dynamic-programming-using-a-set-4-lines-226-ms-faster-than-83-61",
                "content": "https://leetcode.com/submissions/detail/884030014/  \\nRuntime: **226 ms**, faster than 83.61% of Python3 online submissions for Non-decreasing Subsequences.\\nMemory Usage: 20.6 MB, less than 99.88% of Python3 online submissions for Non-decreasing Subsequences.\\n```\\nclass Solution:\\n    def findSubsequences(self, nums: List[int]) -> List[List[int]]:\\n        subs = {(nums[0],)} ## here is the trick\\n        for n in nums[1:]:\\n            subs.update([tuple(list(s)+[n]) for s in subs if n>=list(s)[-1]] + [(n,)])\\n        return [s for s in subs if len(s)>1]\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def findSubsequences(self, nums: List[int]) -> List[List[int]]:\\n        subs = {(nums[0],)} ## here is the trick\\n        for n in nums[1:]:\\n            subs.update([tuple(list(s)+[n]) for s in subs if n>=list(s)[-1]] + [(n,)])\\n        return [s for s in subs if len(s)>1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3088731,
                "title": "c-easy-to-understand-for-beginners",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> result;\\n    \\n    void dfs(vector<int> &nums, int idx, vector<int> &path, set<vector<int>> &s){\\n        if(idx>nums.size()){\\n            return;\\n        }\\n        if(path.size()>=2){\\n            if(s.find(path)==s.end()){\\n                result.push_back(path);\\n                s.insert(path);\\n            }\\n        }\\n        \\n        for(int i=idx; i<nums.size(); i++){\\n            if(path.size()==0 || path.back()<=nums[i]){\\n               path.push_back(nums[i]);\\n                dfs(nums, i+1, path, s);\\n                path.pop_back();\\n            }\\n            \\n        }\\n        \\n    }\\n    \\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\\n        vector<int> path;\\n        set<vector<int>> s;\\n        dfs(nums, 0, path, s);\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> result;\\n    \\n    void dfs(vector<int> &nums, int idx, vector<int> &path, set<vector<int>> &s){\\n        if(idx>nums.size()){\\n            return;\\n        }\\n        if(path.size()>=2){\\n            if(s.find(path)==s.end()){\\n                result.push_back(path);\\n                s.insert(path);\\n            }\\n        }\\n        \\n        for(int i=idx; i<nums.size(); i++){\\n            if(path.size()==0 || path.back()<=nums[i]){\\n               path.push_back(nums[i]);\\n                dfs(nums, i+1, path, s);\\n                path.pop_back();\\n            }\\n            \\n        }\\n        \\n    }\\n    \\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\\n        vector<int> path;\\n        set<vector<int>> s;\\n        dfs(nums, 0, path, s);\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3085690,
                "title": "same-code-with-tweaking-solved-2-problems-easy-to-understand",
                "content": "**SIMILAR QUESTION LINK WITH SOLUTION **\\nhttps://leetcode.com/problems/subsets-ii/description/\\n\\nhttps://leetcode.com/problems/subsets-ii/solutions/3085695/same-code-with-tweaking-solved-2-problems-easy-to-understand/\\n\\n\\n# Approach\\nfind all subsequence it can can make ,along with the check that\\nI) *Subset should not be repeated* .\\ni.e. if(ds.size()==0 || arr[ind]!=ds[ds.size()-1])\\n\\nII) *Subset should be non decreasing* .\\nif(index==0 || ds.size()==0 || nums[index] >= ds[ds.size()-1]){\\n        ds.push_back(nums[index]);\\n        solve(nums, n, ds, index+1);\\n        ds.pop_back();\\n}\\n\\n\\n# Code\\n```\\n#include<vector>\\nclass Solution {\\n    public :\\nvector<vector<int>>vec;\\nvoid solve(vector<int>& nums,int n, vector<int>&ds, int index){\\n        if(index >=n){\\n            if(ds.size() > 1)\\n                vec.push_back(ds);\\n            return;\\n        }\\n        if(index==0 || ds.size()==0 || nums[index] >= ds[ds.size()-1]){\\n            ds.push_back(nums[index]);\\n            solve(nums, n, ds, index+1);\\n            ds.pop_back();\\n        }\\n        if(ds.size()==0 || ds[ds.size()-1]!=nums[index]){\\n            solve(nums, n,ds, index+1);\\n        }\\n}\\npublic:\\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\\n        vector<int>ds;\\n        solve(nums,nums.size(),ds,0);\\n        return vec;\\n    }\\n};\\n```\\n\\n#UPVOTE IF YOU LIKED THE EFFORT\\nTHANK YOU \\nCODE BY :) AMAN MAURYA",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include<vector>\\nclass Solution {\\n    public :\\nvector<vector<int>>vec;\\nvoid solve(vector<int>& nums,int n, vector<int>&ds, int index){\\n        if(index >=n){\\n            if(ds.size() > 1)\\n                vec.push_back(ds);\\n            return;\\n        }\\n        if(index==0 || ds.size()==0 || nums[index] >= ds[ds.size()-1]){\\n            ds.push_back(nums[index]);\\n            solve(nums, n, ds, index+1);\\n            ds.pop_back();\\n        }\\n        if(ds.size()==0 || ds[ds.size()-1]!=nums[index]){\\n            solve(nums, n,ds, index+1);\\n        }\\n}\\npublic:\\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\\n        vector<int>ds;\\n        solve(nums,nums.size(),ds,0);\\n        return vec;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3078026,
                "title": "idk",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nGenerate all permutations ~~With two or more elements~~ that follow a non-decreasing order and store them in a array without duplicates.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUtilize bitmasking to iterate over the array for all permutations.\\nhttps://youtu.be/xXKL9YBWgCY\\nHashSet to remove duplicates :)\\n# Code\\n```\\nimpl Solution {\\n    pub fn find_subsequences(nums: Vec<i32>) -> Vec<Vec<i32>> {\\n        let mut result: std::collections::HashSet<Vec<i32>> = std::collections::HashSet::new();\\n\\n        for bit in 0..(1 << nums.len()) {\\n            let mut permutation: Vec<i32> = vec![];\\n\\n            for index in 0..nums.len(){\\n                if (bit & (1 << index)) <= 0 { continue;}\\n                if permutation.len() != 0 && nums[index] < *permutation.last().unwrap() { continue; }\\n                permutation.push(nums[index]);\\n            }\\n\\n            if permutation.len() < 2 { continue; }\\n            result.insert(permutation);\\n        }\\n        result.into_iter().collect()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn find_subsequences(nums: Vec<i32>) -> Vec<Vec<i32>> {\\n        let mut result: std::collections::HashSet<Vec<i32>> = std::collections::HashSet::new();\\n\\n        for bit in 0..(1 << nums.len()) {\\n            let mut permutation: Vec<i32> = vec![];\\n\\n            for index in 0..nums.len(){\\n                if (bit & (1 << index)) <= 0 { continue;}\\n                if permutation.len() != 0 && nums[index] < *permutation.last().unwrap() { continue; }\\n                permutation.push(nums[index]);\\n            }\\n\\n            if permutation.len() < 2 { continue; }\\n            result.insert(permutation);\\n        }\\n        result.into_iter().collect()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3078012,
                "title": "java-backtracking-beats-99",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n * 2^n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n * 2^n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  int[] nums;\\n  int n;\\n  List<List<Integer>> ans = new ArrayList<>();\\n\\n  private void enumerate(int i, List<Integer> list) {\\n    int l = list.size();\\n\\n    if (i == n) {\\n      if (l >= 2) ans.add(new ArrayList<>(list));\\n      return;\\n    }\\n    // Case: Skip the current number.\\n    // We skip this case if the the previous number was the same as the current one.\\n    // This ensures that we don\\'t end up with duplicates.\\n    if (l == 0 || list.get(l-1) != nums[i])\\n      enumerate(i+1, list);\\n\\n    // Return early if the current number is less than the previous one.\\n    if (l > 0 && list.get(l-1) > nums[i])\\n      return;\\n\\n    // Case: Do not skip the current number.\\n    list.add(nums[i]);\\n    enumerate(i+1, list);\\n    list.remove(list.size() - 1);\\n  }\\n\\n  public List<List<Integer>> findSubsequences(int[] nums) {\\n    this.nums = nums;\\n    n = nums.length;\\n\\n    enumerate(0, new ArrayList<>());\\n    return ans;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n  int[] nums;\\n  int n;\\n  List<List<Integer>> ans = new ArrayList<>();\\n\\n  private void enumerate(int i, List<Integer> list) {\\n    int l = list.size();\\n\\n    if (i == n) {\\n      if (l >= 2) ans.add(new ArrayList<>(list));\\n      return;\\n    }\\n    // Case: Skip the current number.\\n    // We skip this case if the the previous number was the same as the current one.\\n    // This ensures that we don\\'t end up with duplicates.\\n    if (l == 0 || list.get(l-1) != nums[i])\\n      enumerate(i+1, list);\\n\\n    // Return early if the current number is less than the previous one.\\n    if (l > 0 && list.get(l-1) > nums[i])\\n      return;\\n\\n    // Case: Do not skip the current number.\\n    list.add(nums[i]);\\n    enumerate(i+1, list);\\n    list.remove(list.size() - 1);\\n  }\\n\\n  public List<List<Integer>> findSubsequences(int[] nums) {\\n    this.nums = nums;\\n    n = nums.length;\\n\\n    enumerate(0, new ArrayList<>());\\n    return ans;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3077835,
                "title": "simple-c-solution-using-backtracking-with-comments",
                "content": "//author: Dilli Babu\\n//approach: backtracking\\nclass Solution {\\npublic:\\n    void solve(int in,vector<int> &nums,set<vector<int>> &ans,vector<int> &ds){\\n        if(in==nums.size())\\n        {\\n            //checking whether the vector size is greater than 1\\n            if(ds.size()>1)\\n             ans.insert(ds);\\n            return;\\n        }\\n        //checking whether the vector is empty and the last inserted element in the vector is lesser than the current element\\n        if(!ds.size()||ds.back()<=nums[in])\\n        {\\n        ds.push_back(nums[in]);\\n        solve(in+1,nums,ans,ds);\\n        ds.pop_back();\\n        }\\n        solve(in+1,nums,ans,ds);\\n    }\\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\\n      set<vector<int>> ans;\\n      vector<int> ds;\\n      solve(0,nums,ans,ds); \\n      return vector(ans.begin(),ans.end()); \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    void solve(int in,vector<int> &nums,set<vector<int>> &ans,vector<int> &ds){\\n        if(in==nums.size())\\n        {\\n            //checking whether the vector size is greater than 1\\n            if(ds.size()>1)\\n             ans.insert(ds);\\n            return;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3077400,
                "title": "javascript-backtracking-easy-solution",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[][]}\\n */\\nvar findSubsequences = function(nums) {\\n    \\n    const ans = [];\\n    const els = [];\\n    \\n    const check = (i) => {\\n        if(i >= nums.length) {\\n            if(els.length >= 2) {\\n                ans.push(els.slice());\\n            }\\n            return;\\n        }\\n        \\n        const last = els.at(-1) === undefined ?\\xA0-101 : els.at(-1);\\n        const curr = nums[i];\\n\\n        if(curr >= last) {\\n            els.push(curr);\\n            check(i + 1);\\n            els.pop();\\n        }\\n        check(i + 1);\\n        \\n    }\\n    check(0);\\n    // remove duplicates and return result\\n    return Array.from(new Set(ans.map(el => el.join(\"_\")))).map(el => el.split(\"_\"));\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[][]}\\n */\\nvar findSubsequences = function(nums) {\\n    \\n    const ans = [];\\n    const els = [];\\n    \\n    const check = (i) => {\\n        if(i >= nums.length) {\\n            if(els.length >= 2) {\\n                ans.push(els.slice());\\n            }\\n            return;\\n        }\\n        \\n        const last = els.at(-1) === undefined ?\\xA0-101 : els.at(-1);\\n        const curr = nums[i];\\n\\n        if(curr >= last) {\\n            els.push(curr);\\n            check(i + 1);\\n            els.pop();\\n        }\\n        check(i + 1);\\n        \\n    }\\n    check(0);\\n    // remove duplicates and return result\\n    return Array.from(new Set(ans.map(el => el.join(\"_\")))).map(el => el.split(\"_\"));\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3077042,
                "title": "intuitive-explained-recursive-backtracking-solution-using-map",
                "content": "# Upvote if helpful.\\n# Intuition\\n```\\nWe can say for every element that we have only two options: \\n    1) if it is valid choice for adding to the current vector then:\\n        i) add it.\\n        ii)don\\'t add it.\\n    2) if it is not valid choice:\\n        i) then don\\'t add it.\\n```\\n\\n# Approach\\n```\\n    for every element we will check if we could add it to the \\n    current answer:\\n        choice 1(we could add):\\n            further we have 2 options add it or don\\'t add it.\\n        choice 2(we could\\'nt add):\\n            we have only one option that to skip the element.\\n\\n        for choice 1: \\n                if we don\\'t add it i.e. skip it\\n                then recursive call would be idx+1, prev element \\n                that we added will remain same.\\n\\n                if we add it:\\n                then before recursive call we will add to the current\\n                list and in the call the prev element will be nums[idx]\\n                after the call we will remove the element.\\n\\n        for choice 2:\\n                here, we have just one option i.e. to skip it.\\n                prev will remain same here.\\n\\nfor every call we will store the array in map to avoid redundancy.\\n    after we found potential answers then we will loop through the\\n    map and add to the 2d array.\\n\\n```\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    map<vector<int>, int>mp;\\n\\n    void util(vector<int>& nums, int idx, vector<int> curr, int prev){\\n        if(idx==nums.size()){\\n            if(curr.size()>=2){\\n                mp[curr]++;\\n                \\n            }\\n            return;\\n        }\\n\\n        if(nums[idx]>=prev){\\n            util(nums, idx+1, curr, prev);\\n            curr.push_back(nums[idx]);\\n            util(nums, idx+1, curr, nums[idx]);\\n            curr.pop_back();\\n        }\\n        else{\\n            util(nums, idx+1, curr, prev);\\n        }\\n\\n    }\\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\\n        vector<vector<int>>ans;\\n        util(nums, 0, {}, -101);\\n        for(auto pr: mp){\\n            ans.push_back(pr.first);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion",
                    "Ordered Map"
                ],
                "code": "```\\nWe can say for every element that we have only two options: \\n    1) if it is valid choice for adding to the current vector then:\\n        i) add it.\\n        ii)don\\'t add it.\\n    2) if it is not valid choice:\\n        i) then don\\'t add it.\\n```\n```\\n    for every element we will check if we could add it to the \\n    current answer:\\n        choice 1(we could add):\\n            further we have 2 options add it or don\\'t add it.\\n        choice 2(we could\\'nt add):\\n            we have only one option that to skip the element.\\n\\n        for choice 1: \\n                if we don\\'t add it i.e. skip it\\n                then recursive call would be idx+1, prev element \\n                that we added will remain same.\\n\\n                if we add it:\\n                then before recursive call we will add to the current\\n                list and in the call the prev element will be nums[idx]\\n                after the call we will remove the element.\\n\\n        for choice 2:\\n                here, we have just one option i.e. to skip it.\\n                prev will remain same here.\\n\\nfor every call we will store the array in map to avoid redundancy.\\n    after we found potential answers then we will loop through the\\n    map and add to the 2d array.\\n\\n```\n```\\nclass Solution {\\npublic:\\n    map<vector<int>, int>mp;\\n\\n    void util(vector<int>& nums, int idx, vector<int> curr, int prev){\\n        if(idx==nums.size()){\\n            if(curr.size()>=2){\\n                mp[curr]++;\\n                \\n            }\\n            return;\\n        }\\n\\n        if(nums[idx]>=prev){\\n            util(nums, idx+1, curr, prev);\\n            curr.push_back(nums[idx]);\\n            util(nums, idx+1, curr, nums[idx]);\\n            curr.pop_back();\\n        }\\n        else{\\n            util(nums, idx+1, curr, prev);\\n        }\\n\\n    }\\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\\n        vector<vector<int>>ans;\\n        util(nums, 0, {}, -101);\\n        for(auto pr: mp){\\n            ans.push_back(pr.first);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3076679,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def findSubsequences(self, nums: List[int]) -> List[List[int]]:\\n        ans=[]\\n        def backTrack(start,cur):\\n            if len(cur)>1:\\n                ans.append(cur[:])\\n                \\n            last=cur[-1] if cur else -200\\n            seen=set()\\n            for i in range(start,n):\\n                if nums[i] in seen:\\n                    continue\\n                    \\n                if nums[i]>=last:\\n                    cur.append(nums[i])\\n                    backTrack(i+1,cur)\\n                    cur.pop()\\n                    \\n                seen.add(nums[i])\\n                \\n        n=len(nums)\\n        backTrack(0,[])\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findSubsequences(self, nums: List[int]) -> List[List[int]]:\\n        ans=[]\\n        def backTrack(start,cur):\\n            if len(cur)>1:\\n                ans.append(cur[:])\\n                \\n            last=cur[-1] if cur else -200\\n            seen=set()\\n            for i in range(start,n):\\n                if nums[i] in seen:\\n                    continue\\n                    \\n                if nums[i]>=last:\\n                    cur.append(nums[i])\\n                    backTrack(i+1,cur)\\n                    cur.pop()\\n                    \\n                seen.add(nums[i])\\n                \\n        n=len(nums)\\n        backTrack(0,[])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3076623,
                "title": "simple-and-easy-to-understand-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nset<vector<int>>s;\\n    \\n    void f(int ind,vector<int>& nums,vector<int>&v,vector<vector<int>>&ans){\\n        \\n        if(ind == nums.size()){\\n            if(v.size() >= 2){\\n                    s.insert(v);\\n            }\\n            return;\\n        }\\n\\n        if(v.empty() == 1 || v.back() <= nums[ind]){\\n            v.push_back(nums[ind]);\\n        \\n            f(ind+1,nums,v,ans);\\n            v.pop_back();\\n            \\n        }\\n        f(ind+1,nums,v,ans); \\n    }\\n\\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\\n         vector<int>v;\\n         vector<vector<int>>ans;\\n         f(0,nums,v,ans);\\n         for(auto &i : s){\\n             ans.push_back(i);\\n         }\\n         return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nset<vector<int>>s;\\n    \\n    void f(int ind,vector<int>& nums,vector<int>&v,vector<vector<int>>&ans){\\n        \\n        if(ind == nums.size()){\\n            if(v.size() >= 2){\\n                    s.insert(v);\\n            }\\n            return;\\n        }\\n\\n        if(v.empty() == 1 || v.back() <= nums[ind]){\\n            v.push_back(nums[ind]);\\n        \\n            f(ind+1,nums,v,ans);\\n            v.pop_back();\\n            \\n        }\\n        f(ind+1,nums,v,ans); \\n    }\\n\\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\\n         vector<int>v;\\n         vector<vector<int>>ans;\\n         f(0,nums,v,ans);\\n         for(auto &i : s){\\n             ans.push_back(i);\\n         }\\n         return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3076300,
                "title": "c-easy-simple-solution",
                "content": "# UPVOTE IF YOU LIKE THE SOLUTION..\\n```\\nclass Solution {\\npublic:\\nset<vector<int>>s;\\nvoid subsequnce(vector<int>& nums, vector<int>&ds , int i , int n)\\n{\\n    if( i == n )\\n    {\\n        if( ds.size()>1)\\n        {\\n            s.insert( ds);\\n        }\\n        return ;\\n\\n    }\\n    ds.push_back(nums[i]);\\n    subsequnce(nums,ds, i+1, n);\\n    ds.pop_back();\\n    subsequnce( nums , ds, i+1, n);\\n\\n}\\n\\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\\n        \\n         vector<vector<int>> ans;\\n\\n        //  priting all subswquence \\n        int n = nums.size();\\n        vector<int> ds;\\n        subsequnce(nums, ds, 0 , n);\\n\\n        for( auto x : s)\\n        {\\n            vector<int> temp = x; \\n            sort( temp.begin(), temp.end());\\n            if( temp ==x )ans.push_back(x);\\n          \\n        }\\n\\n        return ans;\\n    }\\n\\n};\\n```\\n\\n![you-upvote-me.jpg](https://assets.leetcode.com/users/images/a8f5819b-264b-43f5-b81b-0aea7732097b_1674206125.9909244.jpeg)\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nset<vector<int>>s;\\nvoid subsequnce(vector<int>& nums, vector<int>&ds , int i , int n)\\n{\\n    if( i == n )\\n    {\\n        if( ds.size()>1)\\n        {\\n            s.insert( ds);\\n        }\\n        return ;\\n\\n    }\\n    ds.push_back(nums[i]);\\n    subsequnce(nums,ds, i+1, n);\\n    ds.pop_back();\\n    subsequnce( nums , ds, i+1, n);\\n\\n}\\n\\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\\n        \\n         vector<vector<int>> ans;\\n\\n        //  priting all subswquence \\n        int n = nums.size();\\n        vector<int> ds;\\n        subsequnce(nums, ds, 0 , n);\\n\\n        for( auto x : s)\\n        {\\n            vector<int> temp = x; \\n            sort( temp.begin(), temp.end());\\n            if( temp ==x )ans.push_back(x);\\n          \\n        }\\n\\n        return ans;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3076296,
                "title": "easy-pick-not-pick-approach-c-backtracking-approach",
                "content": "# Complexity\\n- Time complexity:\\nT(2^N) where N is the size of the array \\n\\n![7a02f26e-85ff-49b8-a932-503cce48097c_1674184823.1043508.png](https://assets.leetcode.com/users/images/8887ea82-8b8b-4e9e-8271-0fe5c412cf0f_1674206071.394755.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nvoid func(int idx,vector<int> &nums,vector<int> &temp,vector<vector<int>> &ans)\\n{\\n    if(idx>=nums.size())\\n    {\\n        if(temp.size()>1)\\n            ans.push_back(temp);\\n        return;\\n    }\\n    // Pick\\n    int p=temp.size();\\n    if((p-1>=0 && nums[idx]>=temp[p-1]) || temp.size()==0)\\n    {\\n        temp.push_back(nums[idx]);\\n        func(idx+1,nums,temp,ans);\\n        // BackTracking\\n        if(temp.size()>0)\\n            temp.pop_back();\\n    }\\n    // Not Pick\\n    func(idx+1,nums,temp,ans);\\n}\\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        vector<int> temp;\\n        func(0,nums,temp,ans);\\n        sort(ans.begin(),ans.end());\\n        set<vector<int>> st;\\n        for(auto it:ans)\\n        {\\n            st.insert(it);\\n        }\\n        ans.clear();\\n        for(auto it:st)\\n        {\\n            ans.push_back(it);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvoid func(int idx,vector<int> &nums,vector<int> &temp,vector<vector<int>> &ans)\\n{\\n    if(idx>=nums.size())\\n    {\\n        if(temp.size()>1)\\n            ans.push_back(temp);\\n        return;\\n    }\\n    // Pick\\n    int p=temp.size();\\n    if((p-1>=0 && nums[idx]>=temp[p-1]) || temp.size()==0)\\n    {\\n        temp.push_back(nums[idx]);\\n        func(idx+1,nums,temp,ans);\\n        // BackTracking\\n        if(temp.size()>0)\\n            temp.pop_back();\\n    }\\n    // Not Pick\\n    func(idx+1,nums,temp,ans);\\n}\\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        vector<int> temp;\\n        func(0,nums,temp,ans);\\n        sort(ans.begin(),ans.end());\\n        set<vector<int>> st;\\n        for(auto it:ans)\\n        {\\n            st.insert(it);\\n        }\\n        ans.clear();\\n        for(auto it:st)\\n        {\\n            ans.push_back(it);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3076286,
                "title": "pick-not-pick-trick-striver-s-trick-cpp-recusrion-backtracking",
                "content": "**Hindi Explaination** \\nDekho isme mne sare subsequence find kr liye or bs jo given condition h use lagya h ki non decreasing + subsequence ka size 2 ya us se bda hona chahiye . Ab bat aati h ki mne subsquence kse nikala to uske liye mne striver bhai ka pick and not pick vala tarika apanaya with back tracking link:-(https://www.youtube.com/watch?v=AxNNVECce8c)  u guyz can check it here . or mne set kyu liya agr tum vector<vector<int>> direct loge na to isme same element aa jayenge to apn ko us chij ko avoid krna hai that\\'s why i took it or set kya hota h na basically it stores the value in sorted order and unique values as well . to bs usme store kra kr fr last me set ko vector<vector<int>> res me dal diya ! \\n```\\nclass Solution {\\npublic:\\n    bool check(vector<int>&nums) {\\n        for(int i=0;i<nums.size()-1; i++) {\\n            if(nums[i]>nums[i+1]) return false;\\n        }\\n        return true;\\n    }\\n    void helper(set<vector<int>>&ans,int ind, vector<int>&nums, vector<int>ds) {\\n        if(ind>=nums.size()) {\\n            if(ds.size()>=2 && check(ds)) {\\n                ans.insert(ds);\\n            }\\n            return ;\\n        }\\n        \\n        ds.push_back(nums[ind]);\\n        helper(ans, ind+1, nums, ds);\\n        ds.pop_back();\\n        helper(ans, ind+1, nums, ds);\\n       \\n    } \\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\\n        set<vector<int>> ans;\\n        vector<int>ds;\\n         helper(ans, 0, nums, ds);\\n        vector<vector<int>>res;\\n        for(auto it:ans) {\\n            res.push_back(it);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(vector<int>&nums) {\\n        for(int i=0;i<nums.size()-1; i++) {\\n            if(nums[i]>nums[i+1]) return false;\\n        }\\n        return true;\\n    }\\n    void helper(set<vector<int>>&ans,int ind, vector<int>&nums, vector<int>ds) {\\n        if(ind>=nums.size()) {\\n            if(ds.size()>=2 && check(ds)) {\\n                ans.insert(ds);\\n            }\\n            return ;\\n        }\\n        \\n        ds.push_back(nums[ind]);\\n        helper(ans, ind+1, nums, ds);\\n        ds.pop_back();\\n        helper(ans, ind+1, nums, ds);\\n       \\n    } \\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\\n        set<vector<int>> ans;\\n        vector<int>ds;\\n         helper(ans, 0, nums, ds);\\n        vector<vector<int>>res;\\n        for(auto it:ans) {\\n            res.push_back(it);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3076243,
                "title": "java-without-using-hashset-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nUsually when having to deal with generating all subsequences that [...] you need backtracking. Explanation of that is skipped here.\\n\\nFor dealing with duplicates: \\nWhen backtracking, we backtrack including the element and excluding it. \\n\\nIf the current element is a duplicate of the last, we do not backtrack excluding it, since that would be a duplication of prev excluding and this included. \\n\\nIn other words, you are including in the final result only the last duplicate of a solution. \\n\\nExample:\\n```\\n4 4 5 4 5\\n\\nBacktrack trace:\\n4 4[from index 1 in original list] 5 5. result++\\n4 4[1] 5[2], do not backtrack, does not reach the end\\n4 4[1] 4[3] 5. result++\\n4 4[1] 4[3]. result++\\n4 4[3] 5[4]. result++\\n...\\n```\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTried marking with boolean if visited, tried marked by counts, tried marked by index. All that needs to be done is to take the last duplicate of a solution. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(2^n) - Combinatorics\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(2^n)\\n\\n# Code\\n```\\n\\nclass Solution {\\n\\n    public Solution() {}\\n\\n    int[] nums;\\n    List<List<Integer>> globalResult;\\n    int[] currentList;\\n    int currentListLength;\\n\\n    public List<List<Integer>> findSubsequences(int[] nums) {\\n        this.nums = nums;\\n        this.currentList = new int[nums.length+1];\\n        globalResult = new ArrayList<>();\\n        backtrack(0, -1);\\n\\n        return globalResult;\\n    }\\n\\n    public void backtrack(int i, int l ) {\\n        if (i >= nums.length) {\\n            if (currentListLength >= 2) {\\n                var result = new ArrayList<Integer>(currentListLength);\\n                for(int j = 0; j < currentListLength; j++)\\n                    result.add(currentList[j]);\\n                globalResult.add(result);\\n            }\\n            return;\\n        }\\n        if (l == -1 || nums[i] >= nums[l]) {\\n            currentList[currentListLength++] = nums[i];\\n            backtrack(i+1, i);\\n            currentListLength--;\\n        }\\n        if ((l == -1) || (nums[i] != nums[l]))\\n            backtrack(i+1, l); // backtrack excluding current number\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n4 4 5 4 5\\n\\nBacktrack trace:\\n4 4[from index 1 in original list] 5 5. result++\\n4 4[1] 5[2], do not backtrack, does not reach the end\\n4 4[1] 4[3] 5. result++\\n4 4[1] 4[3]. result++\\n4 4[3] 5[4]. result++\\n...\\n```\n```\\n\\nclass Solution {\\n\\n    public Solution() {}\\n\\n    int[] nums;\\n    List<List<Integer>> globalResult;\\n    int[] currentList;\\n    int currentListLength;\\n\\n    public List<List<Integer>> findSubsequences(int[] nums) {\\n        this.nums = nums;\\n        this.currentList = new int[nums.length+1];\\n        globalResult = new ArrayList<>();\\n        backtrack(0, -1);\\n\\n        return globalResult;\\n    }\\n\\n    public void backtrack(int i, int l ) {\\n        if (i >= nums.length) {\\n            if (currentListLength >= 2) {\\n                var result = new ArrayList<Integer>(currentListLength);\\n                for(int j = 0; j < currentListLength; j++)\\n                    result.add(currentList[j]);\\n                globalResult.add(result);\\n            }\\n            return;\\n        }\\n        if (l == -1 || nums[i] >= nums[l]) {\\n            currentList[currentListLength++] = nums[i];\\n            backtrack(i+1, i);\\n            currentListLength--;\\n        }\\n        if ((l == -1) || (nums[i] != nums[l]))\\n            backtrack(i+1, l); // backtrack excluding current number\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3076200,
                "title": "c-begineer-friendly-easy-understanding-backtrack-video-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n **C++ Clear Explaination ,Please support if you find it usefull. Can give me feedback in comment for improvement.,will be very thankfull.**https://www.youtube.com/watch?v=8S4upxSksDk/\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n  O(2^n.n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n  O(2^n.n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n vector<vector<int>>ans;\\n    void dfs(vector<int>&nums,vector<int>& temp,int index){\\n        // base condition\\n        if(temp.size()>1) ans.push_back(temp);\\n\\n        // for each dfs declare unordered_set\\n        unordered_set<int>set;\\n        for(int i=index;i<nums.size();i++){\\n            // condition\\n            if((temp.size() == 0 || temp.back()<=nums[i])&&(set.find(nums[i]) == set.end())){\\n                temp.push_back(nums[i]);\\n                dfs(nums,temp,i+1);\\n                temp.pop_back();\\n                set.insert(nums[i]);\\n            }\\n        }\\n    }\\n\\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\\n        vector<int>temp;\\n        dfs(nums,temp,0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Backtracking",
                    "Depth-First Search",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n vector<vector<int>>ans;\\n    void dfs(vector<int>&nums,vector<int>& temp,int index){\\n        // base condition\\n        if(temp.size()>1) ans.push_back(temp);\\n\\n        // for each dfs declare unordered_set\\n        unordered_set<int>set;\\n        for(int i=index;i<nums.size();i++){\\n            // condition\\n            if((temp.size() == 0 || temp.back()<=nums[i])&&(set.find(nums[i]) == set.end())){\\n                temp.push_back(nums[i]);\\n                dfs(nums,temp,i+1);\\n                temp.pop_back();\\n                set.insert(nums[i]);\\n            }\\n        }\\n    }\\n\\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\\n        vector<int>temp;\\n        dfs(nums,temp,0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3075996,
                "title": "simple-java-o-n-beginners-helpful",
                "content": "# Intuition\\nGeekster Platform\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> findSubsequences(int[] nums) {\\n       List<List<Integer>> res = new LinkedList<>();\\n        calculate(new LinkedList<Integer>(), 0, nums, res);\\n        return res;   \\n    }\\n    private void calculate(LinkedList<Integer> list, int index, int[] nums, List<List<Integer>> res){\\n     if(list.size()>1){\\n         res.add(new LinkedList<Integer>(list));\\n     }\\n        Set<Integer> used = new HashSet<>();\\n        for(int i = index; i<nums.length; i++){\\n            if(used.contains(nums[i])) continue;\\n            if(list.size()==0 || nums[i]>=list.peekLast()){\\n                used.add(nums[i]);\\n                list.add(nums[i]); \\n                calculate(list, i+1, nums, res);\\n                list.remove(list.size()-1);\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> findSubsequences(int[] nums) {\\n       List<List<Integer>> res = new LinkedList<>();\\n        calculate(new LinkedList<Integer>(), 0, nums, res);\\n        return res;   \\n    }\\n    private void calculate(LinkedList<Integer> list, int index, int[] nums, List<List<Integer>> res){\\n     if(list.size()>1){\\n         res.add(new LinkedList<Integer>(list));\\n     }\\n        Set<Integer> used = new HashSet<>();\\n        for(int i = index; i<nums.length; i++){\\n            if(used.contains(nums[i])) continue;\\n            if(list.size()==0 || nums[i]>=list.peekLast()){\\n                used.add(nums[i]);\\n                list.add(nums[i]); \\n                calculate(list, i+1, nums, res);\\n                list.remove(list.size()-1);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3075832,
                "title": "non-decreasing-subsequences-easy-pick-and-non-pick-approach",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\nbool isNon(vector<int>&ds)\\n{\\n    for(int i=1;i<ds.size();i++)\\n    {\\n        if(ds[i-1]>ds[i])\\n          return false;\\n    }\\n    return true;\\n}\\nvoid picknpick(int ind,vector<int>&nums,vector<int>&ds,set<vector<int>>&res)\\n{\\n    if(ind ==nums.size())\\n    {\\n        if(isNon(ds)==true && ds.size()>1)\\n        {\\n            res.insert(ds);\\n        }\\n        return ;\\n    }\\n    ds.push_back(nums[ind]);\\n    picknpick(ind+1,nums,ds,res);\\n    ds.pop_back();\\n    picknpick(ind+1,nums,ds,res);\\n}\\n    vector<vector<int>> findSubsequences(vector<int>& nums) \\n    {\\n       vector<int>ds;\\n       vector<vector<int>>ans;\\n       set<vector<int>>res;\\n       picknpick(0,nums,ds,res);\\n    \\n       for(auto it:res)\\n       {\\n           ans.push_back(it);\\n       }\\n       return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nbool isNon(vector<int>&ds)\\n{\\n    for(int i=1;i<ds.size();i++)\\n    {\\n        if(ds[i-1]>ds[i])\\n          return false;\\n    }\\n    return true;\\n}\\nvoid picknpick(int ind,vector<int>&nums,vector<int>&ds,set<vector<int>>&res)\\n{\\n    if(ind ==nums.size())\\n    {\\n        if(isNon(ds)==true && ds.size()>1)\\n        {\\n            res.insert(ds);\\n        }\\n        return ;\\n    }\\n    ds.push_back(nums[ind]);\\n    picknpick(ind+1,nums,ds,res);\\n    ds.pop_back();\\n    picknpick(ind+1,nums,ds,res);\\n}\\n    vector<vector<int>> findSubsequences(vector<int>& nums) \\n    {\\n       vector<int>ds;\\n       vector<vector<int>>ans;\\n       set<vector<int>>res;\\n       picknpick(0,nums,ds,res);\\n    \\n       for(auto it:res)\\n       {\\n           ans.push_back(it);\\n       }\\n       return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3075746,
                "title": "go-backtracking-hash-table-20ms-92-5-o-2-n-time-unit-test",
                "content": "# Intuition\\n\\nThe problem is asking us to return &ldquo;all non-decreasing subsequences&rdquo;, basically asking to scan with expanding and contracting (when the end is reached) window, a given input `nums` and return all sequences, where each element is *equal* or *greater* than the previous one.\\n\\n# Approach: [Backtracking](https://leetcode.com/tag/backtracking/), [Hash Table](https://leetcode.com/tag/hash-table/)\\n\\n-   *recursively* (`dfs`) iterate over `nums` and\\n    -   each time when a non-decreasing sequence is longer than a single element, attach it to the result\\n    -   allocate a hash-map to track visited elements, when starting a new sub-sequence\\n    -   scan the given `nums` with expanding&contracting sliding window from left to right\\n        -   if the element is within the current boundaries, and\\n        -   not present in visited map\\n            -   append it to the current sequence, and\\n            -   recursively call the `dfs` function with the next element and the sub-sequence with the current element appended to it\\n        -   otherwise, skip the step.\\n-   return the result\\n\\n## Code\\n\\n```go\\nfunc findSubsequences(nums []int) (res [][]int) {\\n\\tvar dfs func(int, []int)\\n\\tdfs = func(l int, sl []int) {\\n\\t\\tif len(sl) > 1 {\\n\\t\\t\\tcp := make([]int, len(sl))\\n\\t\\t\\tcopy(cp, sl)\\n\\t\\t\\tres = append(res, cp)\\n\\t\\t}\\n\\t\\tseen := make(map[int]bool, len(nums)-l)\\n\\t\\tfor r := l; r < len(nums); r++ {\\n\\t\\t\\tif (l > 0 && nums[r] < nums[l-1]) || seen[nums[r]] {\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\t\\t\\tseen[nums[r]] = true\\n\\t\\t\\tdfs(r+1, append(sl, nums[r]))\\n\\t\\t}\\n\\t}\\n\\n\\tdfs(0, []int{})\\n\\n\\treturn res\\n}\\n```\\n\\n## Complexity\\n\\n- Time: $$O(2^n)$$\\n- Space: $$O(2^n)$$\\n\\nLuckily for us, a given `nums` is short (up to 15 elemens, tops).\\n\\n# Unit Test\\n\\nThe code above, covered by unit test is availabe at the [Go Playground](https://go.dev/play/p/QQLVaclyvQz).\\n\\nIf you like solutions and explanation, please **Upvote**!",
                "solutionTags": [
                    "Go",
                    "Hash Table",
                    "Backtracking"
                ],
                "code": "```go\\nfunc findSubsequences(nums []int) (res [][]int) {\\n\\tvar dfs func(int, []int)\\n\\tdfs = func(l int, sl []int) {\\n\\t\\tif len(sl) > 1 {\\n\\t\\t\\tcp := make([]int, len(sl))\\n\\t\\t\\tcopy(cp, sl)\\n\\t\\t\\tres = append(res, cp)\\n\\t\\t}\\n\\t\\tseen := make(map[int]bool, len(nums)-l)\\n\\t\\tfor r := l; r < len(nums); r++ {\\n\\t\\t\\tif (l > 0 && nums[r] < nums[l-1]) || seen[nums[r]] {\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\t\\t\\tseen[nums[r]] = true\\n\\t\\t\\tdfs(r+1, append(sl, nums[r]))\\n\\t\\t}\\n\\t}\\n\\n\\tdfs(0, []int{})\\n\\n\\treturn res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3075601,
                "title": "c-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    Backtracking\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> num, v;\\n    set<vector<int>> ans;\\n\\n    void solve(int id) {\\n        if(id >= num.size()) {\\n            if(v.size() > 1) ans.insert(v);\\n            return;\\n        }\\n        if(v.size() == 0 or num[id] >= v.back()) {\\n            v.push_back(num[id]);\\n            solve(id + 1);\\n            v.pop_back();\\n        }\\n        solve(id + 1);\\n    }\\n\\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\\n        num = nums;\\n        solve(0);\\n        return vector(ans.begin(), ans.end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> num, v;\\n    set<vector<int>> ans;\\n\\n    void solve(int id) {\\n        if(id >= num.size()) {\\n            if(v.size() > 1) ans.insert(v);\\n            return;\\n        }\\n        if(v.size() == 0 or num[id] >= v.back()) {\\n            v.push_back(num[id]);\\n            solve(id + 1);\\n            v.pop_back();\\n        }\\n        solve(id + 1);\\n    }\\n\\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\\n        num = nums;\\n        solve(0);\\n        return vector(ans.begin(), ans.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3075471,
                "title": "c-backtracking-easy-to-understand-pick-not-pick-approach",
                "content": "# Intuition\\n\\n- Generating all possible subsequences will work as constraints are very small\\n- Using a set to make sure we do not have duplicate subsequences\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse recursion (pick,not-pick approach) to get all subsequences\\n# Complexity\\n- Time complexity : $$O(2^N*log(N))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : $$O(2^N*N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void solve(int index,vector<int>& curr,set<vector<int>>& ans,vector<int>& nums)\\n    {\\n        if(index==nums.size()) \\n        {\\n            if(curr.size()>=2) ans.insert(curr);\\n            return;\\n        }\\n\\n        if(curr.size()==0 || (curr.back()<=nums[index] ))\\n        {\\n            curr.push_back(nums[index]);\\n            solve(index+1,curr,ans,nums);\\n            curr.pop_back();\\n        }\\n        solve(index+1,curr,ans,nums);\\n    }\\n    vector<vector<int>> findSubsequences(vector<int>& nums) \\n    {\\n        set<vector<int>>ans;\\n        vector<vector<int>>ret;\\n        vector<int>curr;\\n        solve(0,curr,ans,nums);  \\n\\n        for(auto it:ans) ret.push_back(it);\\n        return ret;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(int index,vector<int>& curr,set<vector<int>>& ans,vector<int>& nums)\\n    {\\n        if(index==nums.size()) \\n        {\\n            if(curr.size()>=2) ans.insert(curr);\\n            return;\\n        }\\n\\n        if(curr.size()==0 || (curr.back()<=nums[index] ))\\n        {\\n            curr.push_back(nums[index]);\\n            solve(index+1,curr,ans,nums);\\n            curr.pop_back();\\n        }\\n        solve(index+1,curr,ans,nums);\\n    }\\n    vector<vector<int>> findSubsequences(vector<int>& nums) \\n    {\\n        set<vector<int>>ans;\\n        vector<vector<int>>ret;\\n        vector<int>curr;\\n        solve(0,curr,ans,nums);  \\n\\n        for(auto it:ans) ret.push_back(it);\\n        return ret;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3075323,
                "title": "python-python3-solution-11-lines",
                "content": "# Code\\n```\\nclass Solution:\\n    def findSubsequences(self, nums: List[int]) -> List[List[int]]:\\n        subsequences = set()\\n\\n        for num in nums:\\n            new_subsequences = set()\\n            new_subsequences.add((num,))\\n            for s in subsequences:\\n                if num >= s[-1]:\\n                    new_subsequences.add(s + (num,)) # a tuple but not a list, hence can store values in set\\n            subsequences |= new_subsequences\\n        return [s for s in subsequences if len(s) > 1] #conversion to list so as to filter out if too short\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findSubsequences(self, nums: List[int]) -> List[List[int]]:\\n        subsequences = set()\\n\\n        for num in nums:\\n            new_subsequences = set()\\n            new_subsequences.add((num,))\\n            for s in subsequences:\\n                if num >= s[-1]:\\n                    new_subsequences.add(s + (num,)) # a tuple but not a list, hence can store values in set\\n            subsequences |= new_subsequences\\n        return [s for s in subsequences if len(s) > 1] #conversion to list so as to filter out if too short\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3075263,
                "title": "let-s-learn-kotlin-backtracking-into-a-mutableset",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis is a brute force backtracking problem, with duplicity handled by a `MutableSet<List<Int>>` where we will collect valid nondecreasing subsequences.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBy setting up a `backtrack` helper function, we can iterate through `nums`, recursively passing over every element and also choosing to append it if appropriate. To accomplish this, `backtrack` will need two parameters: an index value for `nums` and the current subsequence up to that point. At the end of `nums`, we\\'ll add the subsequence to the set if its length is 2 or more.\\n\\n# Complexity\\nFor both time and space, we\\'re looking at $$2^n$$ subsequences, each handled linearly.\\n- Time complexity: $$O(N * 2^N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N * 2^N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Kotlin specific notes\\n\\n#### Use of `Unit`\\nWhile in some backtracking scenarios we would construct a solution out of return values, here `backtrack` will add subsequences as a side effect. Its useless return value is signified with `Unit` in Kotlin. In most other languages this term is either `null` or `void`. \\n\\n#### Mutability\\nKotlin is notable for its strict and specific typing system. A few observations to learn from this problem are:\\n- Arrays have fixed length, whereas Lists have a mutable size (and no `length` property). This is why the return value is a List. Note that the elements of both are immutable, which is why `MutableArray` and `MutableList` exist.\\n- Likewise, a standard set is immutable, and so in order to add elements, a `MutableSet` must be used.\\n\\n# Code\\n```\\nclass Solution {\\n    fun findSubsequences(nums: IntArray): List<List<Int>> {\\n        var subs = mutableSetOf<List<Int>>()\\n        val n = nums.size\\n        fun backtrack(index: Int, seq: List<Int>): Unit {\\n            if (index == n) {\\n                if (seq.size >= 2) {\\n                subs.add(seq)\\n                }\\n                return Unit\\n            } else {\\n                if (seq.isEmpty() || nums[index] >= seq[seq.size - 1]) {\\n                    backtrack(index + 1, seq + listOf(nums[index]))\\n                }\\n                backtrack(index + 1, seq)\\n                return Unit\\n            }\\n        }\\n        backtrack(0, listOf<Int>())\\n        return subs.toList()\\n    }\\n}\\n```\\nSee you tomorrow!",
                "solutionTags": [
                    "Kotlin",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    fun findSubsequences(nums: IntArray): List<List<Int>> {\\n        var subs = mutableSetOf<List<Int>>()\\n        val n = nums.size\\n        fun backtrack(index: Int, seq: List<Int>): Unit {\\n            if (index == n) {\\n                if (seq.size >= 2) {\\n                subs.add(seq)\\n                }\\n                return Unit\\n            } else {\\n                if (seq.isEmpty() || nums[index] >= seq[seq.size - 1]) {\\n                    backtrack(index + 1, seq + listOf(nums[index]))\\n                }\\n                backtrack(index + 1, seq)\\n                return Unit\\n            }\\n        }\\n        backtrack(0, listOf<Int>())\\n        return subs.toList()\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3075207,
                "title": "java-solution-in-2-methods",
                "content": "\\n\\n# Method 1: Bit Manipulation\\n```\\nclass Solution {\\n    public List<List<Integer>> findSubsequences(int[] nums) {\\n        List<List<Integer>> ll=new ArrayList<>();\\n        int n=nums.length;\\n        int s=0;\\n        HashSet<List<Integer>> h=new HashSet<>();\\n        for(int i=0;i<(1<<n);i++){\\n            List<Integer> l=new ArrayList<>();\\n            int a=i;\\n            for(int j=0;j<n;j++){\\n                s=l.size();\\n                if((a&1)==1)\\n                { \\n                    if(s>=1 && nums[j]<l.get(s-1))\\n                    {\\n                        break;\\n                    }\\n                    l.add(nums[j]);\\n                }\\n                a=a>>1;\\n                if(a==0)\\n                    break;\\n            }\\n            if(l.size()>=2){\\n                if(!h.contains(l)){\\n                    ll.add(new ArrayList<>(l));\\n                    h.add(new ArrayList<>(l));\\n                }\\n            }\\n        }\\n        return ll;\\n    }\\n}\\n```\\n\\n\\n\\n# Method 2: Backtracking\\n```\\nclass Solution {\\n    public List<List<Integer>> findSubsequences(int[] nums) {\\n        List<List<Integer>> ll=new ArrayList<>();\\n        int n=nums.length;\\n        HashSet<List<Integer>> h=new HashSet<>();\\n        check(0,nums,ll,new ArrayList<>(),h);\\n        return ll;\\n    }\\n\\n    public void check(int i,int[] nums,List<List<Integer>> ll,List<Integer> l,HashSet<List<Integer>> h){\\n        if(i>=nums.length)\\n            return;\\n        check(i+1,nums,ll,new ArrayList<>(l),h);\\n        if(l.size()==0){\\n            l.add(nums[i]);\\n            check(i+1,nums,ll,new ArrayList<>(l),h);\\n        }\\n        else if(l.size()!=0 && nums[i]>=l.get(l.size()-1)){\\n            l.add(nums[i]);\\n            check(i+1,nums,ll,new ArrayList<>(l),h);\\n        }\\n        if(l.size()>1 && !h.contains(l)){\\n            ll.add(new ArrayList<>(l));\\n            h.add(new ArrayList<>(l));\\n        }\\n            \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> findSubsequences(int[] nums) {\\n        List<List<Integer>> ll=new ArrayList<>();\\n        int n=nums.length;\\n        int s=0;\\n        HashSet<List<Integer>> h=new HashSet<>();\\n        for(int i=0;i<(1<<n);i++){\\n            List<Integer> l=new ArrayList<>();\\n            int a=i;\\n            for(int j=0;j<n;j++){\\n                s=l.size();\\n                if((a&1)==1)\\n                { \\n                    if(s>=1 && nums[j]<l.get(s-1))\\n                    {\\n                        break;\\n                    }\\n                    l.add(nums[j]);\\n                }\\n                a=a>>1;\\n                if(a==0)\\n                    break;\\n            }\\n            if(l.size()>=2){\\n                if(!h.contains(l)){\\n                    ll.add(new ArrayList<>(l));\\n                    h.add(new ArrayList<>(l));\\n                }\\n            }\\n        }\\n        return ll;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public List<List<Integer>> findSubsequences(int[] nums) {\\n        List<List<Integer>> ll=new ArrayList<>();\\n        int n=nums.length;\\n        HashSet<List<Integer>> h=new HashSet<>();\\n        check(0,nums,ll,new ArrayList<>(),h);\\n        return ll;\\n    }\\n\\n    public void check(int i,int[] nums,List<List<Integer>> ll,List<Integer> l,HashSet<List<Integer>> h){\\n        if(i>=nums.length)\\n            return;\\n        check(i+1,nums,ll,new ArrayList<>(l),h);\\n        if(l.size()==0){\\n            l.add(nums[i]);\\n            check(i+1,nums,ll,new ArrayList<>(l),h);\\n        }\\n        else if(l.size()!=0 && nums[i]>=l.get(l.size()-1)){\\n            l.add(nums[i]);\\n            check(i+1,nums,ll,new ArrayList<>(l),h);\\n        }\\n        if(l.size()>1 && !h.contains(l)){\\n            ll.add(new ArrayList<>(l));\\n            h.add(new ArrayList<>(l));\\n        }\\n            \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3075177,
                "title": "c-easy-backtracking-solution",
                "content": "# Intuition\\nMain Intution behind this Question is we need to find all subarray and those all subarray is also non decreasing so for all subarray we try all possible combination because here size of array is varry between 1 to 15 so we can reccursion and for finding non decreasing subarray we just take one variable pre and when we include new element in array so we compare with pre element if new element is greater or equal so we include otherwise we are not consider that element and proceed to next element and for terminate the reccursion we use base condition which is when we go out of array so just return and also store our ans if our ans size is greater than 2. \\n\\n# Approach\\nJust Apply above logic to code.\\n\\n# Complexity\\n- Time complexity:\\nO(2^N) where N is size of array\\n\\n- Space complexity:\\nO(N^2) for store a ans in set because repetition is no allow.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nvoid findallnondecsubarray(int n,int pre,int cur,vector<int> &temp,set<vector<int>> &temp_ans,vector<int> &nums)\\n{\\n    //base condition exit condition for reccursion\\n    if(cur>=n)\\n    {\\n        if(temp.size()>=2)\\n        {\\n            temp_ans.insert(temp);\\n            return;\\n        }\\n        else return;\\n    }\\n\\n\\n    if(pre==-1||nums[pre]<=nums[cur])\\n//check if cur element is greater or not and proceed accordingly\\n    {\\n        temp.push_back(nums[cur]);\\n        findallnondecsubarray(n,cur,cur+1,temp,temp_ans,nums);\\n        temp.pop_back();\\n    }\\n    findallnondecsubarray(n,pre,cur+1,temp,temp_ans,nums);\\n\\n\\n}\\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\\n        int n=nums.size();\\n        int pre=-1;\\n        int cur=0;\\n        vector<int> temp;\\n        set<vector<int>> temp_ans;\\n        findallnondecsubarray(n,pre,cur,temp,temp_ans,nums);\\n        vector<vector<int>> ans;\\n        for(auto it:temp_ans)ans.push_back(it);\\n        return ans;\\n\\n        \\n    }\\n};\\n```\\n\\n# ![image.png](https://assets.leetcode.com/users/images/a6be7d5c-ddcc-48e8-9ca0-620824e80a7d_1674186869.19883.png)\\n",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvoid findallnondecsubarray(int n,int pre,int cur,vector<int> &temp,set<vector<int>> &temp_ans,vector<int> &nums)\\n{\\n    //base condition exit condition for reccursion\\n    if(cur>=n)\\n    {\\n        if(temp.size()>=2)\\n        {\\n            temp_ans.insert(temp);\\n            return;\\n        }\\n        else return;\\n    }\\n\\n\\n    if(pre==-1||nums[pre]<=nums[cur])\\n//check if cur element is greater or not and proceed accordingly\\n    {\\n        temp.push_back(nums[cur]);\\n        findallnondecsubarray(n,cur,cur+1,temp,temp_ans,nums);\\n        temp.pop_back();\\n    }\\n    findallnondecsubarray(n,pre,cur+1,temp,temp_ans,nums);\\n\\n\\n}\\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\\n        int n=nums.size();\\n        int pre=-1;\\n        int cur=0;\\n        vector<int> temp;\\n        set<vector<int>> temp_ans;\\n        findallnondecsubarray(n,pre,cur,temp,temp_ans,nums);\\n        vector<vector<int>> ans;\\n        for(auto it:temp_ans)ans.push_back(it);\\n        return ans;\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3075016,
                "title": "easy-concise-solution-backtracking",
                "content": "https://github.com/Freeze777/SDE-Interviewer-Notes/blob/main/LeetCodeKotlin/src/main/kotlin/leetcode/medium/backtracking/NonDecreasingSubsequence.kt",
                "solutionTags": [
                    "Kotlin",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 3074885,
                "title": "java-backtracking-thought-on-avoid-repeated-lists",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n01/19/2023\\nI have done this question on last September, but I forget it at all.\\nLuckily, I wrote this solution smoothly, except for one step, as I stated in the header.\\nThere is one step that I can not come up with at once, for example, 4-7-7, we want to avoid (4-7) and (4-7).  \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI remember that I have encounter the same problem on 90.Subset||. \\nSince for this question, we don\\'t care the original order in nums, so we could do Arrays.sort(nums) first. \\n```\\nif(i>start&&nums[i]==nums[i-1]){\\n    continue;}\\n```\\nThis if statement is just below the for loop. Actually, in each for loop, **all the numbers that with index < i, is not in current list**.\\nThen, if nums[i]==nums[i-1]=a, then a must have been added to some lists in previous iteration. \\nAnd, the lists that contain both nums[i-1] and nums[i] had already been added to the result when Iterate to index=i-1.\\n\\nSimilar to this if statement, we need to figure out a solution without sorting the original array.\\nThat is to use a HashSet.\\nSuppose i=c. Then nums[start] to nums[c-1] are all in the set, they are not in the given list. so if set.contains(nums[i]=b), it means that there is no b in the current list. Then we could not add nums[i]=b here.\\n```\\nif(set.contains(nums[i])){\\n    continue;\\n}\\n```\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    List<List<Integer>> res;\\n    public List<List<Integer>> findSubsequences(int[] nums) {\\n        res=new ArrayList<>();\\n        helper(new ArrayList<>(),nums,0);\\n        return res;\\n    }\\n    public void helper(List<Integer> list, int[] nums, int start){\\n        Set<Integer> set=new HashSet<>();\\n        if(start==nums.length){\\n            return;\\n        }\\n        for(int i=start;i<nums.length;i++){\\n            if(set.contains(nums[i])){\\n                    continue;\\n                }\\n            set.add(nums[i]);\\n            if(list.size()==0||nums[i]>=list.get(list.size()-1)){\\n                list.add(nums[i]);\\n                if(list.size()>1){\\n                    res.add(new ArrayList<>(list));\\n                }\\n                helper(list, nums, i+1);\\n                list.remove(list.size()-1);\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nif(i>start&&nums[i]==nums[i-1]){\\n    continue;}\\n```\n```\\nif(set.contains(nums[i])){\\n    continue;\\n}\\n```\n```\\nclass Solution {\\n    List<List<Integer>> res;\\n    public List<List<Integer>> findSubsequences(int[] nums) {\\n        res=new ArrayList<>();\\n        helper(new ArrayList<>(),nums,0);\\n        return res;\\n    }\\n    public void helper(List<Integer> list, int[] nums, int start){\\n        Set<Integer> set=new HashSet<>();\\n        if(start==nums.length){\\n            return;\\n        }\\n        for(int i=start;i<nums.length;i++){\\n            if(set.contains(nums[i])){\\n                    continue;\\n                }\\n            set.add(nums[i]);\\n            if(list.size()==0||nums[i]>=list.get(list.size()-1)){\\n                list.add(nums[i]);\\n                if(list.size()>1){\\n                    res.add(new ArrayList<>(list));\\n                }\\n                helper(list, nums, i+1);\\n                list.remove(list.size()-1);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3074877,
                "title": "commented-simple-python-solution-with-explanation",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def findSubsequences(self, nums: List[int]) -> List[List[int]]:\\n        res = set() # used to check if the number has been used or not\\n        n = len(nums)\\n\\n        def solve(start, cur):\\n            # if we get the length > 1 we already got our answer since we need atleast 2 elements\\n            if len(cur) > 1:\\n                res.add(tuple(cur)) # adding tuple to set since we cannot add list\\n            \\n            fin = cur[-1] if cur else -100 # range of nums.length() given is -100 to 100 \\n            \\n            # standard backtracking\\n            for i in range(start, n):\\n                if nums[i] >= fin:\\n                    cur.append(nums[i])\\n                    solve(i+1, cur)\\n                    cur.pop()\\n            \\n        solve(0, []) # we start from 0 and the current list will be empty\\n        return res\\n        \\n```\\n\\n`Time Complexity = O(2^n)`",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findSubsequences(self, nums: List[int]) -> List[List[int]]:\\n        res = set() # used to check if the number has been used or not\\n        n = len(nums)\\n\\n        def solve(start, cur):\\n            # if we get the length > 1 we already got our answer since we need atleast 2 elements\\n            if len(cur) > 1:\\n                res.add(tuple(cur)) # adding tuple to set since we cannot add list\\n            \\n            fin = cur[-1] if cur else -100 # range of nums.length() given is -100 to 100 \\n            \\n            # standard backtracking\\n            for i in range(start, n):\\n                if nums[i] >= fin:\\n                    cur.append(nums[i])\\n                    solve(i+1, cur)\\n                    cur.pop()\\n            \\n        solve(0, []) # we start from 0 and the current list will be empty\\n        return res\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3074859,
                "title": "no-set-backtracking-simple",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> res;\\n    void subsequence(int idx, vector<int>&nums, vector<int>&temp){\\n        \\n        if(idx == nums.size()){\\n            if(temp.size() >= 2)res.push_back(temp);\\n            return;\\n        };\\n        if(!temp.size() || temp.back() != nums[idx])\\n            subsequence(idx + 1, nums, temp);\\n\\n        if(!temp.size() || nums[idx] >= temp.back()){\\n            temp.push_back(nums[idx]);\\n            subsequence(idx + 1, nums, temp);\\n            temp.pop_back();\\n        }\\n    }\\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\\n        vector<int> temp;\\n        subsequence(0, nums, temp);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> res;\\n    void subsequence(int idx, vector<int>&nums, vector<int>&temp){\\n        \\n        if(idx == nums.size()){\\n            if(temp.size() >= 2)res.push_back(temp);\\n            return;\\n        };\\n        if(!temp.size() || temp.back() != nums[idx])\\n            subsequence(idx + 1, nums, temp);\\n\\n        if(!temp.size() || nums[idx] >= temp.back()){\\n            temp.push_back(nums[idx]);\\n            subsequence(idx + 1, nums, temp);\\n            temp.pop_back();\\n        }\\n    }\\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\\n        vector<int> temp;\\n        subsequence(0, nums, temp);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3074825,
                "title": "rust-hashset",
                "content": "```\\nimpl Solution {\\n    pub fn find_subsequences(nums: Vec<i32>) -> Vec<Vec<i32>> {\\n        use std::collections::HashSet;\\n\\n        fn dfs(i: usize, ret: &mut HashSet<Vec<i32>>, t: &mut Vec<i32>, nums: &Vec<i32>) {\\n            if i == nums.len() {\\n                if t.len() > 1 {\\n                    ret.insert(t.to_vec());\\n                }\\n                return;\\n            }\\n\\n            dfs(i + 1, ret, t, nums);\\n            match t.last() {\\n                Some(&a) if a > nums[i] => (),\\n                _ => {\\n                    t.push(nums[i]);\\n                    dfs(i + 1, ret, t, nums);\\n                    t.pop();\\n                }\\n            }\\n        }\\n\\n        let mut ret = HashSet::new();\\n        let mut t = vec![];\\n        dfs(0, &mut ret, &mut t, &nums);\\n        ret.into_iter().collect()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn find_subsequences(nums: Vec<i32>) -> Vec<Vec<i32>> {\\n        use std::collections::HashSet;\\n\\n        fn dfs(i: usize, ret: &mut HashSet<Vec<i32>>, t: &mut Vec<i32>, nums: &Vec<i32>) {\\n            if i == nums.len() {\\n                if t.len() > 1 {\\n                    ret.insert(t.to_vec());\\n                }\\n                return;\\n            }\\n\\n            dfs(i + 1, ret, t, nums);\\n            match t.last() {\\n                Some(&a) if a > nums[i] => (),\\n                _ => {\\n                    t.push(nums[i]);\\n                    dfs(i + 1, ret, t, nums);\\n                    t.pop();\\n                }\\n            }\\n        }\\n\\n        let mut ret = HashSet::new();\\n        let mut t = vec![];\\n        dfs(0, &mut ret, &mut t, &nums);\\n        ret.into_iter().collect()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3074823,
                "title": "c-backtracking-video-solution",
                "content": "# Intuition & Approach\\nhttps://youtu.be/FDm61BVNTJE\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    int n;\\n    vector<int> cur;\\n    set<vector<int>> subsequences;\\npublic:\\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\\n        n = nums.size();\\n        solve(0, nums);\\n        return vector(subsequences.begin(), subsequences.end());\\n    }\\n\\n    void solve(int idx, vector<int> &nums) {\\n        if (idx == n) {\\n            if (cur.size() > 1)\\n                subsequences.insert(cur);\\n            \\n            return;\\n        }\\n\\n        if (cur.empty() || cur.back() <= nums[idx]) {\\n            cur.push_back(nums[idx]);\\n            solve(idx + 1, nums);\\n            cur.pop_back();\\n        }\\n\\n        solve(idx + 1, nums);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int n;\\n    vector<int> cur;\\n    set<vector<int>> subsequences;\\npublic:\\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\\n        n = nums.size();\\n        solve(0, nums);\\n        return vector(subsequences.begin(), subsequences.end());\\n    }\\n\\n    void solve(int idx, vector<int> &nums) {\\n        if (idx == n) {\\n            if (cur.size() > 1)\\n                subsequences.insert(cur);\\n            \\n            return;\\n        }\\n\\n        if (cur.empty() || cur.back() <= nums[idx]) {\\n            cur.push_back(nums[idx]);\\n            solve(idx + 1, nums);\\n            cur.pop_back();\\n        }\\n\\n        solve(idx + 1, nums);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3074806,
                "title": "python-bfs",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def findSubsequences(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        memo = defaultdict(int)\\n        n = len(nums)\\n        stack = [([nums[i]], i) for i in range(n - 1)]\\n        while stack:\\n            candidate, idx = stack.pop(0)\\n            if len(candidate) >= 2:\\n                res.append(candidate)\\n            for i in range(idx + 1, n):\\n                if nums[i] >= nums[idx]:\\n                    next_candidate = candidate + [nums[i]]\\n                    next_candidate_hashed = f\\'{next_candidate}\\'\\n                    if memo[next_candidate_hashed] == 0:\\n                        memo[next_candidate_hashed] = 1\\n                        stack.append((next_candidate, i))\\n        return res\\n\\n\\n\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findSubsequences(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        memo = defaultdict(int)\\n        n = len(nums)\\n        stack = [([nums[i]], i) for i in range(n - 1)]\\n        while stack:\\n            candidate, idx = stack.pop(0)\\n            if len(candidate) >= 2:\\n                res.append(candidate)\\n            for i in range(idx + 1, n):\\n                if nums[i] >= nums[idx]:\\n                    next_candidate = candidate + [nums[i]]\\n                    next_candidate_hashed = f\\'{next_candidate}\\'\\n                    if memo[next_candidate_hashed] == 0:\\n                        memo[next_candidate_hashed] = 1\\n                        stack.append((next_candidate, i))\\n        return res\\n\\n\\n\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3074756,
                "title": "daily-leetcode-solution-easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    set<vector<int>> ans;\\n    void solve(int idx,int n,vector<int>& ds,vector<int>& nums){\\n        if(idx==n){\\n            if(ds.size()<=1) return;\\n            for(int i=1;i<ds.size();i++){\\n                if(ds[i]<ds[i-1]){\\n                    return;\\n                }\\n            }\\n            ans.insert(ds);\\n            return;\\n        }\\n        ds.push_back(nums[idx]);\\n        solve(idx+1,n,ds,nums);\\n        ds.pop_back();\\n        solve(idx+1,n,ds,nums);\\n    }\\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\\n        vector<int> ds;\\n        solve(0,nums.size(),ds,nums);\\n        vector<vector<int>> res;\\n        for(auto &i:ans){\\n            res.push_back(i);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    set<vector<int>> ans;\\n    void solve(int idx,int n,vector<int>& ds,vector<int>& nums){\\n        if(idx==n){\\n            if(ds.size()<=1) return;\\n            for(int i=1;i<ds.size();i++){\\n                if(ds[i]<ds[i-1]){\\n                    return;\\n                }\\n            }\\n            ans.insert(ds);\\n            return;\\n        }\\n        ds.push_back(nums[idx]);\\n        solve(idx+1,n,ds,nums);\\n        ds.pop_back();\\n        solve(idx+1,n,ds,nums);\\n    }\\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\\n        vector<int> ds;\\n        solve(0,nums.size(),ds,nums);\\n        vector<vector<int>> res;\\n        for(auto &i:ans){\\n            res.push_back(i);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2564123,
                "title": "python-backtracking",
                "content": "\\tclass Solution:\\n\\t\\tdef findSubsequences(self, nums: List[int]) -> List[List[int]]:\\n\\n\\t\\t\\tdef combinations(idx, curArr, nums, res):\\n\\t\\t\\t\\tif len(curArr) >= 2:\\n\\t\\t\\t\\t\\tres.add(curArr)\\n\\n\\t\\t\\t\\tfor i in range(idx, len(nums)):\\n\\t\\t\\t\\t\\tif not curArr or nums[i] >= curArr[-1]:\\n\\t\\t\\t\\t\\t\\tcombinations(i+1, curArr+(nums[i],), nums, res)\\n\\n\\t\\t\\tres = set()\\n\\t\\t\\tcombinations(0, (), nums, res)\\n\\t\\t\\treturn res",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking",
                    "Ordered Set"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef findSubsequences(self, nums: List[int]) -> List[List[int]]:\\n\\n\\t\\t\\tdef combinations(idx, curArr, nums, res):\\n\\t\\t\\t\\tif len(curArr) >= 2:\\n\\t\\t\\t\\t\\tres.add(curArr)\\n\\n\\t\\t\\t\\tfor i in range(idx, len(nums)):\\n\\t\\t\\t\\t\\tif not curArr or nums[i] >= curArr[-1]:\\n\\t\\t\\t\\t\\t\\tcombinations(i+1, curArr+(nums[i],), nums, res)\\n\\n\\t\\t\\tres = set()\\n\\t\\t\\tcombinations(0, (), nums, res)\\n\\t\\t\\treturn res",
                "codeTag": "Java"
            },
            {
                "id": 1968524,
                "title": "java-solution-without-hash-table-9ms",
                "content": "Since the problem wants you to output all the possible patterns, backtracing is required. However, removing duplicate subsequences is a little tricky in this problem. The simplest way, which I also recommend if you encounter this in an interview, is to use a `HashSet` to remove duplicated subsequences.\\n\\nAnother way is to use suffix tree to remove possible duplicated subsequences. The reason why suffix tree works here is **it helps us remove the case that a subsequence is the prefix of another subsequence.** \\n\\nFor example, `[1,1,1]` has a subsequence `[1,1]` which is its prefix. If you try to find all the subsequences of `[1,1,1]`, the result should be `[1,1],[1,1,1]` and the suffix tree will contain only one path `root->1->1->1`. Please notice it doesn\\'t limit to subsequences with the same number, sequence `[1,2,3,1,2,3]` has completely duplicated subsequences `[1,2,3]` and you don\\'t want to generate subsequences from them twice.\\n\\nOn the other hand, sequence `[1,2,3]` has a subsequence `[2,3]` but it is not a prefix of the sequence. The result should be `[1,2],[1,2,3],[2,3]` and the suffix tree will contain two paths `root->1->2->3`, `root->2->3`.\\n\\nIf you have built the suffix tree with all the increasing subsequences, you could visit the tree to collect the path from root. You don\\'t need to find subsequences of that path because all the subsequences are already in the suffix tree.\\n\\n```java\\n// suffix tree node\\nstatic class Node {\\n    int value;\\n    Map<Integer, Node> children = new HashMap<>();\\n    \\n    Node(int value) {\\n        this.value = value;\\n    }\\n    \\n    Node add(int value) {\\n        return children.computeIfAbsent(value, Node::new);\\n    }\\n    \\n    void visit(LinkedList<Integer> seq, List<List<Integer>> result) {\\n        if(seq.size() > 1) {\\n            result.add(new ArrayList<>(seq));\\n        }\\n        for(Node child : children.values()) {\\n            seq.addLast(child.value);\\n            child.visit(seq, result);\\n            seq.removeLast();\\n        }\\n    }\\n}\\n\\npublic List<List<Integer>> findSubsequences(int[] nums) {\\n    Node root = new Node(Integer.MIN_VALUE);\\n    buildTree(nums, 0, root);\\n\\t\\n    List<List<Integer>> result = new ArrayList<>();\\n    root.visit(new LinkedList<>(), result);\\n    return result;\\n}\\n\\nvoid buildTree(int[] nums, int from, Node prev) {\\n    for(int i = from; i < nums.length; i++) {\\n        if(prev.value > nums[i]) continue;\\n        Node curr = prev.add(nums[i]);\\n        buildTree(nums, i + 1, curr);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\n// suffix tree node\\nstatic class Node {\\n    int value;\\n    Map<Integer, Node> children = new HashMap<>();\\n    \\n    Node(int value) {\\n        this.value = value;\\n    }\\n    \\n    Node add(int value) {\\n        return children.computeIfAbsent(value, Node::new);\\n    }\\n    \\n    void visit(LinkedList<Integer> seq, List<List<Integer>> result) {\\n        if(seq.size() > 1) {\\n            result.add(new ArrayList<>(seq));\\n        }\\n        for(Node child : children.values()) {\\n            seq.addLast(child.value);\\n            child.visit(seq, result);\\n            seq.removeLast();\\n        }\\n    }\\n}\\n\\npublic List<List<Integer>> findSubsequences(int[] nums) {\\n    Node root = new Node(Integer.MIN_VALUE);\\n    buildTree(nums, 0, root);\\n\\t\\n    List<List<Integer>> result = new ArrayList<>();\\n    root.visit(new LinkedList<>(), result);\\n    return result;\\n}\\n\\nvoid buildTree(int[] nums, int from, Node prev) {\\n    for(int i = from; i < nums.length; i++) {\\n        if(prev.value > nums[i]) continue;\\n        Node curr = prev.add(nums[i]);\\n        buildTree(nums, i + 1, curr);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1930098,
                "title": "backtracking-with-important-optimization",
                "content": "```\\nclass Solution:\\n    def DFS(self, nums, beg, ans, res):\\n        if len(ans) > 1:\\n            res.append(ans.copy())\\n        isVisited = {}\\n\\n        for i in range(beg, len(nums)):\\n\\n            if len(ans) > 0 and ans[-1] > nums[i]:continue\\n#this line of code added so that our code do not backtrack again & again for same element \\n\\t\\t#e,g [1, 1, 1, 22] for this array, element \\'1\\' will produce all the required combination. No need to backtrack for seccond \\'1\\'\\n\\t\\t#also [1, 2, 4, 1, 0, 2] for this kind of array we do not need to backtrack for \\'1\\' or \\'2\\' again\\n            if nums[i] in isVisited: continue\\n            isVisited[nums[i]] = True\\n            ans.append(nums[i])\\n            self.DFS(nums, i+1, ans, res)\\n            ans.pop(-1)\\n    \\n    def findSubsequences(self, nums: List[int]) -> List[List[int]]:\\n        ans = []\\n        res = []\\n        self.DFS(nums, 0, ans, res)\\n        return res\\n                    \\n                \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def DFS(self, nums, beg, ans, res):\\n        if len(ans) > 1:\\n            res.append(ans.copy())\\n        isVisited = {}\\n\\n        for i in range(beg, len(nums)):\\n\\n            if len(ans) > 0 and ans[-1] > nums[i]:continue\\n#this line of code added so that our code do not backtrack again & again for same element \\n\\t\\t#e,g [1, 1, 1, 22] for this array, element \\'1\\' will produce all the required combination. No need to backtrack for seccond \\'1\\'\\n\\t\\t#also [1, 2, 4, 1, 0, 2] for this kind of array we do not need to backtrack for \\'1\\' or \\'2\\' again\\n            if nums[i] in isVisited: continue\\n            isVisited[nums[i]] = True\\n            ans.append(nums[i])\\n            self.DFS(nums, i+1, ans, res)\\n            ans.pop(-1)\\n    \\n    def findSubsequences(self, nums: List[int]) -> List[List[int]]:\\n        ans = []\\n        res = []\\n        self.DFS(nums, 0, ans, res)\\n        return res\\n                    \\n                \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1910674,
                "title": "c-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    map<vector<int>,int> mp;\\n    void Traverse(vector<int> path,vector<int> nums,int idx,int n)\\n    {\\n        if(path.size()>=2)\\n        {\\n            mp[path]++;\\n            if(mp[path]==1)\\n            {\\n                ans.push_back(path);  \\n            }            \\n        }\\n        if(idx==n)\\n        {\\n            return;\\n        }\\n        for(int i=idx;i<n;i++)\\n        {\\n            if(path.size()==0)\\n            {\\n                path.push_back(nums[i]);\\n            }\\n            else\\n            {\\n                if(nums[i]>=path[path.size()-1])\\n                    path.push_back(nums[i]);\\n            }\\n            Traverse(path,nums,i+1,n);\\n            path.pop_back();\\n        }\\n    }\\n    vector<vector<int>> findSubsequences(vector<int>& nums) \\n    {\\n        vector<int> path;\\n        int n=nums.size();\\n        Traverse(path,nums,0,n);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    map<vector<int>,int> mp;\\n    void Traverse(vector<int> path,vector<int> nums,int idx,int n)\\n    {\\n        if(path.size()>=2)\\n        {\\n            mp[path]++;\\n            if(mp[path]==1)\\n            {\\n                ans.push_back(path);  \\n            }            \\n        }\\n        if(idx==n)\\n        {\\n            return;\\n        }\\n        for(int i=idx;i<n;i++)\\n        {\\n            if(path.size()==0)\\n            {\\n                path.push_back(nums[i]);\\n            }\\n            else\\n            {\\n                if(nums[i]>=path[path.size()-1])\\n                    path.push_back(nums[i]);\\n            }\\n            Traverse(path,nums,i+1,n);\\n            path.pop_back();\\n        }\\n    }\\n    vector<vector<int>> findSubsequences(vector<int>& nums) \\n    {\\n        vector<int> path;\\n        int n=nums.size();\\n        Traverse(path,nums,0,n);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1831002,
                "title": "c-backtracking-using-set",
                "content": "```cpp\\nclass Solution {\\nprivate:\\n    void getSubsequence(int idx,vector<int>&nums,vector<int>&temp,set<vector<int>>&se){\\n        //Base case : \\n        if(temp.size()>=2){\\n            se.insert(temp);\\n            // return;\\n        }\\n        \\n        for(int i=idx;i<size(nums);i++){\\n            if(temp.size()==0 || temp[temp.size()-1]<=nums[i]){\\n                temp.push_back(nums[i]);\\n                getSubsequence(i+1,nums,temp,se);\\n                temp.pop_back();    \\n            }\\n        }\\n    }\\npublic:\\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\\n        set<vector<int>>se;\\n        vector<int>temp;\\n        getSubsequence(0,nums,temp,se);\\n        // for(auto it:se){\\n        //     for(auto v:it){\\n        //         cout<<v<<\",\";\\n        //     }\\n        //     cout<<endl;\\n        // }\\n        vector<vector<int>>ans(se.begin(),se.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "```cpp\\nclass Solution {\\nprivate:\\n    void getSubsequence(int idx,vector<int>&nums,vector<int>&temp,set<vector<int>>&se){\\n        //Base case : \\n        if(temp.size()>=2){\\n            se.insert(temp);\\n            // return;\\n        }\\n        \\n        for(int i=idx;i<size(nums);i++){\\n            if(temp.size()==0 || temp[temp.size()-1]<=nums[i]){\\n                temp.push_back(nums[i]);\\n                getSubsequence(i+1,nums,temp,se);\\n                temp.pop_back();    \\n            }\\n        }\\n    }\\npublic:\\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\\n        set<vector<int>>se;\\n        vector<int>temp;\\n        getSubsequence(0,nums,temp,se);\\n        // for(auto it:se){\\n        //     for(auto v:it){\\n        //         cout<<v<<\",\";\\n        //     }\\n        //     cout<<endl;\\n        // }\\n        vector<vector<int>>ans(se.begin(),se.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1769037,
                "title": "c-concise-solution-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<int>& path, vector<int>& nums, vector<vector<int>>& res, int index){\\n        if(path.size()>1) res.push_back(path);\\n        set<int> used;\\n        for(int i = index; i<nums.size(); i++){\\n            if(used.find(nums[i])!=used.end()) continue;\\n            if(path.size()==0 || nums[i]>=*(path.end()-1)){\\n                used.insert(nums[i]);\\n                path.push_back(nums[i]); \\n                dfs(path, nums, res, i+1);\\n                path.erase(path.end()-1);\\n            }\\n        }\\n    }\\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        vector<int> path;\\n        dfs(path, nums,ans, 0 );\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<int>& path, vector<int>& nums, vector<vector<int>>& res, int index){\\n        if(path.size()>1) res.push_back(path);\\n        set<int> used;\\n        for(int i = index; i<nums.size(); i++){\\n            if(used.find(nums[i])!=used.end()) continue;\\n            if(path.size()==0 || nums[i]>=*(path.end()-1)){\\n                used.insert(nums[i]);\\n                path.push_back(nums[i]); \\n                dfs(path, nums, res, i+1);\\n                path.erase(path.end()-1);\\n            }\\n        }\\n    }\\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        vector<int> path;\\n        dfs(path, nums,ans, 0 );\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1401037,
                "title": "c-backtracking-approach-hashing-of-vector-to-avoid-duplicates",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    unordered_set<string>S;\\n    \\n    void solve(vector<int>& nums, vector<int>&V, int pos)\\n    {\\n        if(pos == nums.size())\\n        {\\n            string key = {V.begin(), V.end()};\\n            if(V.size() >= 2 and S.count(key) == 0)\\n            {\\n                S.insert(key);\\n                ans.push_back(V);\\n            }\\n            return; \\n        }\\n        \\n        if((V.size() and V.back() <= nums[pos]) or (V.size()==0))\\n        {\\n            V.push_back(nums[pos]);\\n            solve(nums, V, pos+1);\\n            V.pop_back();\\n        }\\n        solve(nums, V, pos+1);   \\n    }\\n    \\n    vector<vector<int>> findSubsequences(vector<int>& nums) \\n    {\\n        vector<int> V;\\n        solve(nums, V, 0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    unordered_set<string>S;\\n    \\n    void solve(vector<int>& nums, vector<int>&V, int pos)\\n    {\\n        if(pos == nums.size())\\n        {\\n            string key = {V.begin(), V.end()};\\n            if(V.size() >= 2 and S.count(key) == 0)\\n            {\\n                S.insert(key);\\n                ans.push_back(V);\\n            }\\n            return; \\n        }\\n        \\n        if((V.size() and V.back() <= nums[pos]) or (V.size()==0))\\n        {\\n            V.push_back(nums[pos]);\\n            solve(nums, V, pos+1);\\n            V.pop_back();\\n        }\\n        solve(nums, V, pos+1);   \\n    }\\n    \\n    vector<vector<int>> findSubsequences(vector<int>& nums) \\n    {\\n        vector<int> V;\\n        solve(nums, V, 0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1333960,
                "title": "rust-cheapest-best",
                "content": "```\\nuse std::collections::HashSet;\\n\\nimpl Solution {\\n    pub fn find_subsequences(nums: Vec<i32>) -> Vec<Vec<i32>> {\\n        nums.into_iter()\\n            .fold(\\n                vec![vec![]].into_iter().collect::<HashSet<Vec<i32>>>(),\\n                |seqs, n| {\\n                    seqs.into_iter()\\n                        .flat_map(|seq| {\\n                            if seq.last().unwrap_or(&-100) <= &n {\\n                                vec![seq.iter().cloned().chain(vec![n]).collect(), seq]\\n                            } else {\\n                                vec![seq]\\n                            }\\n                        })\\n                        .collect()\\n                },\\n            )\\n            .into_iter()\\n            .filter(|seq| seq.len() >= 2)\\n            .collect()\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nuse std::collections::HashSet;\\n\\nimpl Solution {\\n    pub fn find_subsequences(nums: Vec<i32>) -> Vec<Vec<i32>> {\\n        nums.into_iter()\\n            .fold(\\n                vec![vec![]].into_iter().collect::<HashSet<Vec<i32>>>(),\\n                |seqs, n| {\\n                    seqs.into_iter()\\n                        .flat_map(|seq| {\\n                            if seq.last().unwrap_or(&-100) <= &n {\\n                                vec![seq.iter().cloned().chain(vec![n]).collect(), seq]\\n                            } else {\\n                                vec![seq]\\n                            }\\n                        })\\n                        .collect()\\n                },\\n            )\\n            .into_iter()\\n            .filter(|seq| seq.len() >= 2)\\n            .collect()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1275892,
                "title": "c-backtracking-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n     set<vector<int>>ans;\\n    \\n    void recurs(vector<int>& nums,int i,vector<int>&res,int prev)\\n    {\\n        if(i>=nums.size())\\n        {\\n            if(res.size()>1)\\n            {\\n                ans.insert(res);\\n            }\\n             return ;\\n        }\\n        \\n          if(res.size()>1)\\n            {\\n                ans.insert(res);\\n            }\\n        \\n        if(nums[i]>=nums[prev])\\n        {\\n            res.push_back(nums[i]);\\n            recurs(nums,i+1,res,i);\\n            res.pop_back();\\n            recurs(nums,i+1,res,prev);\\n        }\\n        else\\n        {\\n            recurs(nums,i+1,res,prev);\\n        }\\n    }\\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\\n        \\n        vector<int>v;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n             v.push_back(nums[i]);\\n             recurs(nums,i+1,v,i);\\n             v.pop_back();\\n        }\\n       \\n   vector<vector<int>>an(ans.begin(),ans.end());\\n        return an;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n     set<vector<int>>ans;\\n    \\n    void recurs(vector<int>& nums,int i,vector<int>&res,int prev)\\n    {\\n        if(i>=nums.size())\\n        {\\n            if(res.size()>1)\\n            {\\n                ans.insert(res);\\n            }\\n             return ;\\n        }\\n        \\n          if(res.size()>1)\\n            {\\n                ans.insert(res);\\n            }\\n        \\n        if(nums[i]>=nums[prev])\\n        {\\n            res.push_back(nums[i]);\\n            recurs(nums,i+1,res,i);\\n            res.pop_back();\\n            recurs(nums,i+1,res,prev);\\n        }\\n        else\\n        {\\n            recurs(nums,i+1,res,prev);\\n        }\\n    }\\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\\n        \\n        vector<int>v;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n             v.push_back(nums[i]);\\n             recurs(nums,i+1,v,i);\\n             v.pop_back();\\n        }\\n       \\n   vector<vector<int>>an(ans.begin(),ans.end());\\n        return an;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1190103,
                "title": "javascript-backtrack",
                "content": "```\\nvar findSubsequences = function(nums) {\\n    if(nums.length < 2) return [];\\n    var result = [];\\n    var path = [];\\n    var backtrack = function(startIndex) {\\n        if(path.length >= 2) {\\n            result.push([...path]);\\n        }\\n        var used = new Set(); // Important, we need to check whether the num has been used on this level to avoid duplicate\\n        for(var i = startIndex; i < nums.length; i++) {\\n            if(path.length > 0 && nums[i] < path[path.length - 1] || used.has(nums[i])) continue;\\n            used.add(nums[i]);\\n            path.push(nums[i]);\\n            backtrack(i + 1);\\n            path.pop();\\n        }\\n        return;\\n    }\\n    backtrack(0);\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar findSubsequences = function(nums) {\\n    if(nums.length < 2) return [];\\n    var result = [];\\n    var path = [];\\n    var backtrack = function(startIndex) {\\n        if(path.length >= 2) {\\n            result.push([...path]);\\n        }\\n        var used = new Set(); // Important, we need to check whether the num has been used on this level to avoid duplicate\\n        for(var i = startIndex; i < nums.length; i++) {\\n            if(path.length > 0 && nums[i] < path[path.length - 1] || used.has(nums[i])) continue;\\n            used.add(nums[i]);\\n            path.push(nums[i]);\\n            backtrack(i + 1);\\n            path.pop();\\n        }\\n        return;\\n    }\\n    backtrack(0);\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1022994,
                "title": "java-dfs",
                "content": "```\\nclass Solution {\\n    public void helper(Set<List<Integer>> ans, List<Integer> path, int start, int cur, int[] nums){\\n        if(start >= nums.length) return;\\n        for(int i=start; i<nums.length;i++){\\n             if(nums[i] >= cur){\\n                 path.add(nums[i]);\\n                 if(path.size()>=2) ans.add(new ArrayList<>(path));\\n                 helper(ans, path, i+1, nums[i], nums);\\n             }\\n            else if(nums[i]<cur) continue;\\n            path.remove(path.size()-1);\\n        }\\n    }\\n    public List<List<Integer>> findSubsequences(int[] nums) {\\n        Set<List<Integer>> ans= new HashSet<>();\\n        if(nums==null || nums.length==0) return new ArrayList<>();\\n        helper(ans, new ArrayList<>(), 0, -101, nums);\\n        return new ArrayList<>(ans);\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public void helper(Set<List<Integer>> ans, List<Integer> path, int start, int cur, int[] nums){\\n        if(start >= nums.length) return;\\n        for(int i=start; i<nums.length;i++){\\n             if(nums[i] >= cur){\\n                 path.add(nums[i]);\\n                 if(path.size()>=2) ans.add(new ArrayList<>(path));\\n                 helper(ans, path, i+1, nums[i], nums);\\n             }",
                "codeTag": "Java"
            },
            {
                "id": 1002157,
                "title": "java-dfs-should-be-easy-to-understand",
                "content": "```\\nclass Solution {\\n    List<List<Integer>> res;\\n    // helper function\\n    public void dfs(int[] nums, int idx, ArrayList<Integer> curr){\\n        // Use a set to make sure we are not adding the same value \\n\\t\\t// ex: Given [4,6,7,7], one of the valid answer is [4,6,7] with the first 7,\\n\\t\\t// but there is no need to add the second 7 again to make another [4,6,7]\\n\\t\\t// Hence, use a set to make sure we skip the same values\\n        Set<Integer> used = new HashSet<>();\\n        // Whenever we have a list passing through, add it into the final result if size >= 2\\n        if(curr.size() >= 2){\\n            res.add(new ArrayList<Integer>(curr));\\n        }\\n        \\n        for(int i = idx; i < nums.length; i++){\\n            if(used.contains(nums[i])) continue;\\n            if(curr.size() == 0 || curr.get(curr.size() - 1) <= nums[i]){\\n                curr.add(nums[i]);\\n                used.add(nums[i]);\\n                dfs(nums, i+1, curr);\\n                curr.remove(curr.size() - 1);   \\n            }\\n        }\\n    }\\n    \\n    public List<List<Integer>> findSubsequences(int[] nums) {\\n        res = new ArrayList<>();\\n        dfs(nums, 0, new ArrayList<Integer>());        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    List<List<Integer>> res;\\n    // helper function\\n    public void dfs(int[] nums, int idx, ArrayList<Integer> curr){\\n        // Use a set to make sure we are not adding the same value \\n\\t\\t// ex: Given [4,6,7,7], one of the valid answer is [4,6,7] with the first 7,\\n\\t\\t// but there is no need to add the second 7 again to make another [4,6,7]\\n\\t\\t// Hence, use a set to make sure we skip the same values\\n        Set<Integer> used = new HashSet<>();\\n        // Whenever we have a list passing through, add it into the final result if size >= 2\\n        if(curr.size() >= 2){\\n            res.add(new ArrayList<Integer>(curr));\\n        }\\n        \\n        for(int i = idx; i < nums.length; i++){\\n            if(used.contains(nums[i])) continue;\\n            if(curr.size() == 0 || curr.get(curr.size() - 1) <= nums[i]){\\n                curr.add(nums[i]);\\n                used.add(nums[i]);\\n                dfs(nums, i+1, curr);\\n                curr.remove(curr.size() - 1);   \\n            }\\n        }\\n    }\\n    \\n    public List<List<Integer>> findSubsequences(int[] nums) {\\n        res = new ArrayList<>();\\n        dfs(nums, 0, new ArrayList<Integer>());        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 818863,
                "title": "python3-dp-solution-increasing-subsequences",
                "content": "```\\nclass Solution:\\n    def findSubsequences(self, nums: List[int]) -> List[List[int]]:\\n        dp = [[(nums[i],)] for i in range(len(nums))]\\n        for i in range(1, len(nums)):\\n            for j in range(i):\\n                if nums[j] <= nums[i]:\\n                    for seq in dp[j]:\\n                        dp[i].append(seq + (nums[i],))\\n        return list(set((t for ta in dp for t in ta if len(t) > 1)))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def findSubsequences(self, nums: List[int]) -> List[List[int]]:\\n        dp = [[(nums[i],)] for i in range(len(nums))]\\n        for i in range(1, len(nums)):\\n            for j in range(i):\\n                if nums[j] <= nums[i]:\\n                    for seq in dp[j]:\\n                        dp[i].append(seq + (nums[i],))\\n        return list(set((t for ta in dp for t in ta if len(t) > 1)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 813743,
                "title": "c-dfs",
                "content": "```C++\\nclass Solution {\\npublic:\\n    vector<vector<int>> findSubsequences(vector<int>& nums) \\n\\t{\\n        int N = nums.size();\\n        \\n        set<vector<int>> record;\\n        vector<int> curRecord;\\n        \\n        dfs(nums, record, curRecord, 0);\\n        \\n        vector<vector<int>> ans (record.begin(), record.end());\\n        \\n        return ans;\\n    }\\n    \\n    void dfs(vector<int>& nums, set<vector<int>>& record, vector<int>& curRecord, int start)\\n    {\\n        int N = nums.size();\\n        \\n        if (N < start) return;\\n        \\n        if (2 <= curRecord.size()) \\n        {\\n            record.insert(curRecord);\\n        }\\n        \\n        for (int i = start; i < N; i++)\\n        {\\n            if (!curRecord.empty() && nums[i] < curRecord.back() )\\n            {\\n                continue;\\n            }\\n            \\n            curRecord.push_back(nums[i]);\\n\\n            dfs(nums, record, curRecord, i + 1);\\n            \\n            curRecord.pop_back();\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```C++\\nclass Solution {\\npublic:\\n    vector<vector<int>> findSubsequences(vector<int>& nums) \\n\\t{\\n        int N = nums.size();\\n        \\n        set<vector<int>> record;\\n        vector<int> curRecord;\\n        \\n        dfs(nums, record, curRecord, 0);\\n        \\n        vector<vector<int>> ans (record.begin(), record.end());\\n        \\n        return ans;\\n    }\\n    \\n    void dfs(vector<int>& nums, set<vector<int>>& record, vector<int>& curRecord, int start)\\n    {\\n        int N = nums.size();\\n        \\n        if (N < start) return;\\n        \\n        if (2 <= curRecord.size()) \\n        {\\n            record.insert(curRecord);\\n        }\\n        \\n        for (int i = start; i < N; i++)\\n        {\\n            if (!curRecord.empty() && nums[i] < curRecord.back() )\\n            {\\n                continue;\\n            }\\n            \\n            curRecord.push_back(nums[i]);\\n\\n            dfs(nums, record, curRecord, i + 1);\\n            \\n            curRecord.pop_back();\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 745690,
                "title": "must-read-cpp-solution-how-to-approach-it-backtracking",
                "content": "**INTUITION:**\\n\\nThe first thing that strikes anyone\\'s mind is : \\nif num= [ 4,6,7,7].\\nif I am able to print all the subsequences of this given array, Then I can later on worry about how to find the increasing ones later on.\\n\\nI tried with this and wrote code: \\nAttaching the code and the output as a code: \\n\\n![image](https://assets.leetcode.com/users/images/903eb91b-ab3b-41cb-afee-45f79e7fdde9_1595244809.1398041.png)\\n\\n\\n\\nNow, Only thing left was to just find the increasing subsequences and remove all the duplicate ones:\\n\\nFor avoiding duplicates, I just used a SET and for increasing subsequences, I first checked if the number coming is more than the previous number if yes push it and update the prev with this number also continue the search. \\n\\n\\n```\\nclass Solution {\\npublic:\\n    set<vector<int>>s;\\n    vector<vector<int>>v;\\n    \\n    void dfs(vector<int>nums,vector<int>temp,int i,int prev){\\n        if(temp.size()>=2&& s.find(temp)==s.end()){\\n            v.push_back(temp);\\n            s.insert(temp);\\n        }\\n        if(i==nums.size())\\n          return;  \\n        \\n        if(nums[i]>=prev){\\n            \\n            temp.push_back(nums[i]);\\n            \\n            dfs(nums,temp,i+1,nums[i]);\\n            \\n            temp.pop_back();\\n            \\n        }\\n        dfs(nums,temp,i+1,prev);\\n        \\n        return;\\n        \\n        }\\n    \\n    \\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\\n        \\n        \\n        vector<int>temp;\\n        \\n        dfs(nums,temp,0,INT_MIN);        \\n        \\n        return v;\\n        \\n        \\n    }\\n};\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    set<vector<int>>s;\\n    vector<vector<int>>v;\\n    \\n    void dfs(vector<int>nums,vector<int>temp,int i,int prev){\\n        if(temp.size()>=2&& s.find(temp)==s.end()){\\n            v.push_back(temp);\\n            s.insert(temp);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 711141,
                "title": "implemented-using-power-set",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\\n        int n = nums.size();\\n        int power_set = (1 << n);\\n        set<vector<int>> res;\\n        for (int j = 0; j < power_set; j++)\\n        {\\n            vector<int> step;\\n            for (int i = 0; i < n; i++)\\n            {\\n                if (j >> i & 1)\\n                {\\n                    if (step.size() == 0)\\n                    {\\n                        step.push_back(nums[i]);\\n                    }\\n                    else\\n                    {\\n                        if (step.back() <= nums[i])\\n                        {\\n                            step.push_back(nums[i]);\\n                        }\\n                        else\\n                        {\\n                            step.pop_back();\\n                        }\\n                    }\\n                }\\n            }\\n            if (step.size() >= 2)\\n                res.insert(step);\\n        }\\n        vector<vector<int>> result(res.begin(), res.end());\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\\n        int n = nums.size();\\n        int power_set = (1 << n);\\n        set<vector<int>> res;\\n        for (int j = 0; j < power_set; j++)\\n        {\\n            vector<int> step;\\n            for (int i = 0; i < n; i++)\\n            {\\n                if (j >> i & 1)\\n                {\\n                    if (step.size() == 0)\\n                    {\\n                        step.push_back(nums[i]);\\n                    }\\n                    else\\n                    {\\n                        if (step.back() <= nums[i])\\n                        {\\n                            step.push_back(nums[i]);\\n                        }\\n                        else\\n                        {\\n                            step.pop_back();\\n                        }\\n                    }\\n                }\\n            }\\n            if (step.size() >= 2)\\n                res.insert(step);\\n        }\\n        vector<vector<int>> result(res.begin(), res.end());\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 352909,
                "title": "c-dfs",
                "content": "```\\npublic class Solution {\\n    public IList<IList<int>> FindSubsequences(int[] nums) {\\n        var result = new List<IList<int>>();\\n        DFS(nums, 0, new List<int>(), result);\\n        return result;\\n    }\\n\\n    private void DFS(int[] nums, int startIndex, IList<int> oneResult, IList<IList<int>> result) {\\n        if (oneResult.Count > 1) {\\n            result.Add(new List<int>(oneResult));\\n        }\\n        \\n        // not able to sort, so we add isVisited to remove the duplicate \\n        var isVisited = new HashSet<int>();\\n\\n        var n = nums.Length;\\n        for (int i = startIndex; i < n; i++) {\\n            var cur = nums[i];\\n            if (isVisited.Contains(cur)) continue;\\n            if (!oneResult.Any() || oneResult.Last() <= cur) {\\n                isVisited.Add(cur);\\n                oneResult.Add(cur);\\n                DFS(nums, i + 1, oneResult, result);\\n                oneResult.RemoveAt(oneResult.Count - 1);\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public IList<IList<int>> FindSubsequences(int[] nums) {\\n        var result = new List<IList<int>>();\\n        DFS(nums, 0, new List<int>(), result);\\n        return result;\\n    }\\n\\n    private void DFS(int[] nums, int startIndex, IList<int> oneResult, IList<IList<int>> result) {\\n        if (oneResult.Count > 1) {\\n            result.Add(new List<int>(oneResult));\\n        }\\n        \\n        // not able to sort, so we add isVisited to remove the duplicate \\n        var isVisited = new HashSet<int>();\\n\\n        var n = nums.Length;\\n        for (int i = startIndex; i < n; i++) {\\n            var cur = nums[i];\\n            if (isVisited.Contains(cur)) continue;\\n            if (!oneResult.Any() || oneResult.Last() <= cur) {\\n                isVisited.Add(cur);\\n                oneResult.Add(cur);\\n                DFS(nums, i + 1, oneResult, result);\\n                oneResult.RemoveAt(oneResult.Count - 1);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 265936,
                "title": "java-backtracking-faster-than-99-explanation-on-how-to-handle-duplicate",
                "content": "At each step, you don\\'t let the same element be used. Check the wasNotAlreadyUsed method, note that it goes from start to less than i.\\n```\\nclass Solution {\\n    public List<List<Integer>> findSubsequences(int[] nums) {\\n        List<List<Integer>> res = new ArrayList<List<Integer>>();\\n        if(nums.length == 0) return res;\\n        boolean[] used = new boolean[nums.length];\\n        dfs(nums,used,res,0,new ArrayList<Integer>());\\n        return res;\\n    }\\n    private void dfs(int[] nums, boolean[] used, List<List<Integer>> res, int start, List<Integer> path) {\\n        if (path.size() >= 2){\\n            res.add(new ArrayList<Integer>(path));\\n        } \\n        for(int i = start; i < nums.length; i++) {\\n            if (!used[i] && \\n                (wasNotAlreadyUsed(nums[i],nums,i,start)) && \\n                (path.size()==0 || nums[i]>=path.get(path.size()-1))\\n               ){\\n                used[i]=true;\\n                path.add(nums[i]);\\n                dfs(nums,used,res,i+1,path);\\n                used[i]=false;\\n                path.remove(path.size()-1);\\n            }\\n        }\\n    }\\n    private boolean wasNotAlreadyUsed(int ele, int[] nums, int pos, int start) {\\n        for(int i = start; i < pos; i++) {\\n            if(nums[i]==ele)\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> findSubsequences(int[] nums) {\\n        List<List<Integer>> res = new ArrayList<List<Integer>>();\\n        if(nums.length == 0) return res;\\n        boolean[] used = new boolean[nums.length];\\n        dfs(nums,used,res,0,new ArrayList<Integer>());\\n        return res;\\n    }\\n    private void dfs(int[] nums, boolean[] used, List<List<Integer>> res, int start, List<Integer> path) {\\n        if (path.size() >= 2){\\n            res.add(new ArrayList<Integer>(path));\\n        } \\n        for(int i = start; i < nums.length; i++) {\\n            if (!used[i] && \\n                (wasNotAlreadyUsed(nums[i],nums,i,start)) && \\n                (path.size()==0 || nums[i]>=path.get(path.size()-1))\\n               ){\\n                used[i]=true;\\n                path.add(nums[i]);\\n                dfs(nums,used,res,i+1,path);\\n                used[i]=false;\\n                path.remove(path.size()-1);\\n            }\\n        }\\n    }\\n    private boolean wasNotAlreadyUsed(int ele, int[] nums, int pos, int start) {\\n        for(int i = start; i < pos; i++) {\\n            if(nums[i]==ele)\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 238086,
                "title": "java-7ms-solution-which-beats-99-8",
                "content": "```\\nclass Solution {\\n    private boolean isUsed(int[] nums, int start, int index){\\n        for(int i = start; i < index; i++)\\n            if( nums[i] == nums[index] )\\n                return true;\\n        return false;\\n    }\\n    \\n    public void traverse(List<List<Integer>> result, List<Integer> current, int[] nums, int index){\\n        if( current.size() > 1 )\\n            result.add(new ArrayList<Integer>(current));\\n        if( index == nums.length )\\n            return;\\n        for(int i = index; i < nums.length; i++){ \\n            if( current.size() > 0 && nums[i] < current.get(current.size() - 1) )\\n                continue;\\n            if( i > index && isUsed(nums, index, i) ) // remove duplicate\\n                continue;\\n            current.add(nums[i]);\\n            traverse(result, current, nums, i + 1);\\n            current.remove(current.size() - 1);\\n        }\\n    }\\n    \\n    public List<List<Integer>> findSubsequences(int[] nums) {\\n        List<List<Integer>> result = new ArrayList<List<Integer>>();\\n        traverse(result, new ArrayList<Integer>(), nums, 0);\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private boolean isUsed(int[] nums, int start, int index){\\n        for(int i = start; i < index; i++)\\n            if( nums[i] == nums[index] )\\n                return true;\\n        return false;\\n    }\\n    \\n    public void traverse(List<List<Integer>> result, List<Integer> current, int[] nums, int index){\\n        if( current.size() > 1 )\\n            result.add(new ArrayList<Integer>(current));\\n        if( index == nums.length )\\n            return;\\n        for(int i = index; i < nums.length; i++){ \\n            if( current.size() > 0 && nums[i] < current.get(current.size() - 1) )\\n                continue;\\n            if( i > index && isUsed(nums, index, i) ) // remove duplicate\\n                continue;\\n            current.add(nums[i]);\\n            traverse(result, current, nums, i + 1);\\n            current.remove(current.size() - 1);\\n        }\\n    }\\n    \\n    public List<List<Integer>> findSubsequences(int[] nums) {\\n        List<List<Integer>> result = new ArrayList<List<Integer>>();\\n        traverse(result, new ArrayList<Integer>(), nums, 0);\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 201129,
                "title": "python-solution",
                "content": "We use the backtracking algorithm. We iterate over `nums`, and at each iteration, find all increasing subsequences ending with the current element. The tricky part is to make sure that we do not include duplicate subsequences when there are duplicate elements in `nums`. There are two solutions that address this issue. For both solutions, the time complexity is O(2^n), and the space complexity is O(2^n), where `n = len(nums)`.\\n\\nA conceptually easier solution is use tuple to represent each sequence (so that it\\'s hashable), and use a set to hold all sequences, which automatically takes care of duplicates.\\n```\\nclass Solution(object):\\n    def findSubsequences(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        res = {()}\\n        for n in nums:\\n            res |= {tup+(n,) for tup in res if not tup or tup[-1] <= n}\\n        return [list(x) for x in res if len(x) >= 2]\\n```\\nAnother solution, which is less automatic, but has faster runtime, is to work with list directly. We use an extra dictionary `num2idx` which at each iteration `i` maps every element before the current element `curr` to its index of last appearance before `curr`. Then to find all unique subsequences that end with `curr`, we only need to append `curr` to all subsequences ending with elements in `nums[num2idx[curr]:i]` which are smaller than or equal to `curr` (if it\\'s the first appearance of `curr`, we replace `nums[num2idx[curr]:i]` by `nums[:i]`).\\n```\\nclass Solution(object):\\n    def findSubsequences(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        res = []\\n        num2idx = {}\\n        idx2res = {}\\n        for i in range(len(nums)):\\n            if nums[i] not in num2idx:\\n                start = 0\\n                idx2res[i] = [[nums[i]]]\\n            else:\\n                start = num2idx[nums[i]]\\n                idx2res[i] = []\\n            for j in range(start, i):\\n                if nums[j] <= nums[i]:\\n                    for seq in idx2res[j]:\\n                        tmp = list(seq)\\n                        tmp.append(nums[i])\\n                        idx2res[i].append(tmp)\\n                        res.append(tmp)\\n            num2idx[nums[i]] = i\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def findSubsequences(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        res = {()}\\n        for n in nums:\\n            res |= {tup+(n,) for tup in res if not tup or tup[-1] <= n}\\n        return [list(x) for x in res if len(x) >= 2]\\n```\n```\\nclass Solution(object):\\n    def findSubsequences(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        res = []\\n        num2idx = {}\\n        idx2res = {}\\n        for i in range(len(nums)):\\n            if nums[i] not in num2idx:\\n                start = 0\\n                idx2res[i] = [[nums[i]]]\\n            else:\\n                start = num2idx[nums[i]]\\n                idx2res[i] = []\\n            for j in range(start, i):\\n                if nums[j] <= nums[i]:\\n                    for seq in idx2res[j]:\\n                        tmp = list(seq)\\n                        tmp.append(nums[i])\\n                        idx2res[i].append(tmp)\\n                        res.append(tmp)\\n            num2idx[nums[i]] = i\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 170270,
                "title": "python-dfs-and-dp-solution",
                "content": "The question is asking to output all subseqs, so have to use DFS. If the question is only asking for total number of outputs, DP will solve.\\n\\nDFS code to output all answers:\\n```\\nclass Solution(object):\\n    def findSubsequences(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        if not nums or len(nums) < 2:\\n            return []\\n        \\n        n = len(nums)\\n        \\n        prev = [-1] * n # index of previous duplicate element\\n        last_index = {}\\n        for i in range(n):\\n            if nums[i] in last_index:\\n                prev[i] = last_index[nums[i]]\\n            last_index[nums[i]] = i      \\n\\n        res = []\\n        self.dfs(nums, 0, [False] * n, prev, [float(\"-inf\")], res)\\n        return res\\n    \\n    \\n    def dfs(self, nums, i, used, prev, subset, res):\\n        # key point: if i > 0, nums[i - 1] is the last selected element, i.e. nums[i - 1] == subset[-1]\\n        if len(subset) > 2:\\n            res.append(subset[1:])\\n        \\n        for j in range(i, len(nums)):\\n            if nums[j] < subset[-1]:\\n                continue\\n            if prev[j] != -1 and not used[prev[j]] and (i - 1) < prev[j]:\\n                continue\\n            subset.append(nums[j])\\n            used[j] = True\\n            self.dfs(nums, j + 1, used, prev, subset, res)\\n            used[j] = False\\n            subset.pop()\\n```\\n\\nDP code to calculate number of answers only:\\n```\\nclass Solution(object):\\n    def findSubsequences(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        if not nums or len(nums) < 2:\\n            return 0\\n        \\n        n = len(nums)\\n        \\n        first_index = {}\\n        for i in range(n):\\n            if nums[i] not in first_index:\\n                first_index[nums[i]] = i\\n        \\n        f = [0] * n\\n        ans = 0\\n        for i in range(n):\\n            for k in range(i - 1, -1, -1):\\n                if nums[k] > nums[i]:\\n                    continue               \\n                f[i] += f[k]\\n                if first_index[nums[k]] == k:\\n                    f[i] += 1\\n                if nums[k] == nums[i]:\\n                    break               \\n            ans += f[i]\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def findSubsequences(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        if not nums or len(nums) < 2:\\n            return []\\n        \\n        n = len(nums)\\n        \\n        prev = [-1] * n # index of previous duplicate element\\n        last_index = {}\\n        for i in range(n):\\n            if nums[i] in last_index:\\n                prev[i] = last_index[nums[i]]\\n            last_index[nums[i]] = i      \\n\\n        res = []\\n        self.dfs(nums, 0, [False] * n, prev, [float(\"-inf\")], res)\\n        return res\\n    \\n    \\n    def dfs(self, nums, i, used, prev, subset, res):\\n        # key point: if i > 0, nums[i - 1] is the last selected element, i.e. nums[i - 1] == subset[-1]\\n        if len(subset) > 2:\\n            res.append(subset[1:])\\n        \\n        for j in range(i, len(nums)):\\n            if nums[j] < subset[-1]:\\n                continue\\n            if prev[j] != -1 and not used[prev[j]] and (i - 1) < prev[j]:\\n                continue\\n            subset.append(nums[j])\\n            used[j] = True\\n            self.dfs(nums, j + 1, used, prev, subset, res)\\n            used[j] = False\\n            subset.pop()\\n```\n```\\nclass Solution(object):\\n    def findSubsequences(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        if not nums or len(nums) < 2:\\n            return 0\\n        \\n        n = len(nums)\\n        \\n        first_index = {}\\n        for i in range(n):\\n            if nums[i] not in first_index:\\n                first_index[nums[i]] = i\\n        \\n        f = [0] * n\\n        ans = 0\\n        for i in range(n):\\n            for k in range(i - 1, -1, -1):\\n                if nums[k] > nums[i]:\\n                    continue               \\n                f[i] += f[k]\\n                if first_index[nums[k]] == k:\\n                    f[i] += 1\\n                if nums[k] == nums[i]:\\n                    break               \\n            ans += f[i]\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 97139,
                "title": "iterative-simple-python-beats-97",
                "content": "```\\nclass Solution(object):\\n    def findSubsequences(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        stack = []\\n        Set = set()\\n        for i in range(len(nums)):\\n            stack.append([])\\n            for j in range(i-1, -1, -1):\\n                if nums[j] <= nums[i]:\\n                    stack[i].append([nums[j], nums[i]])\\n                    Set.add((nums[j], nums[i]))\\n                    for sequence in stack[j]:\\n                        stack[i].append(sequence + [nums[i]])\\n                        Set.add(tuple(stack[i][-1]))\\n                if nums[j] == nums[i]:\\n                    break\\n        return list(Set)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def findSubsequences(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        stack = []\\n        Set = set()\\n        for i in range(len(nums)):\\n            stack.append([])\\n            for j in range(i-1, -1, -1):\\n                if nums[j] <= nums[i]:\\n                    stack[i].append([nums[j], nums[i]])\\n                    Set.add((nums[j], nums[i]))\\n                    for sequence in stack[j]:\\n                        stack[i].append(sequence + [nums[i]])\\n                        Set.add(tuple(stack[i][-1]))\\n                if nums[j] == nums[i]:\\n                    break\\n        return list(Set)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 97132,
                "title": "java-20ms-iterative-solution",
                "content": "The tricky part of this puzzle is how to remove duplicates. Consider\\xa0an input [1, 1, 1, 2],\\xa0for\\xa0the 1 at index 1, its sequence are [[1, 1]], for the 1 at index 2, its sequence is [[1, 1], [1, 1, 1]].\\xa0So when at 2, it will get duplicated sequence [1, 1, 2]. But it's not hard to notice\\xa0sequences for the second 1 contains the sequences of the first 1. So we only need to consider the second 1.\\n```\\npublic class Solution {\\n    public List<List<Integer>> findSubsequences(int[] nums) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        if (nums.length == 0) return res;\\n\\n        // Record the index of last appreance\\n        Map<Integer, Integer> index = new HashMap<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            index.put(nums[i], i);\\n        }\\n\\n        List<List<Integer>>[] memo = new ArrayList[nums.length];\\n\\n        for (int i = 1; i < nums.length; i++) {\\n            memo[i] = new ArrayList<>();\\n            Set<Integer> met = new HashSet<>();\\n            for (int j = i - 1; j >= 0; j--) {\\n                // Use hashset to remove duplicates\\n                if (met.contains(nums[j])) continue;\\n                if (nums[j] <= nums[i]) {\\n                    List<Integer> two = new ArrayList<>();\\n                    two.add(nums[j]);\\n                    two.add(nums[i]);\\n                    memo[i].add(two);\\n\\n                    if (memo[j] != null) {\\n                        for (List<Integer> prev : memo[j]) {\\n                            List<Integer> curr = new ArrayList<>(prev);\\n                            curr.add(nums[i]);\\n                            memo[i].add(curr);\\n                        }\\n                    }\\n                }\\n                met.add(nums[j]);\\n            }\\n\\n            // Only add the sequence to the final result if this is the last appreance\\n            if (i == index.get(nums[i])) {\\n                res.addAll(memo[i]);\\n            }\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public List<List<Integer>> findSubsequences(int[] nums) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        if (nums.length == 0) return res;\\n\\n        // Record the index of last appreance\\n        Map<Integer, Integer> index = new HashMap<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            index.put(nums[i], i);\\n        }\\n\\n        List<List<Integer>>[] memo = new ArrayList[nums.length];\\n\\n        for (int i = 1; i < nums.length; i++) {\\n            memo[i] = new ArrayList<>();\\n            Set<Integer> met = new HashSet<>();\\n            for (int j = i - 1; j >= 0; j--) {\\n                // Use hashset to remove duplicates\\n                if (met.contains(nums[j])) continue;\\n                if (nums[j] <= nums[i]) {\\n                    List<Integer> two = new ArrayList<>();\\n                    two.add(nums[j]);\\n                    two.add(nums[i]);\\n                    memo[i].add(two);\\n\\n                    if (memo[j] != null) {\\n                        for (List<Integer> prev : memo[j]) {\\n                            List<Integer> curr = new ArrayList<>(prev);\\n                            curr.add(nums[i]);\\n                            memo[i].add(curr);\\n                        }\\n                    }\\n                }\\n                met.add(nums[j]);\\n            }\\n\\n            // Only add the sequence to the final result if this is the last appreance\\n            if (i == index.get(nums[i])) {\\n                res.addAll(memo[i]);\\n            }\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 97193,
                "title": "c-222ms-30lines-solution-without-recurse-beats-100",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\\n        vector<vector<int>> ans(0);\\n        if(nums.size()<2) return ans;\\n        int fst[nums.size()];       //first\\n        bool rep[nums.size()];      //repeat\\n        for(int i=0;i<nums.size();++i){\\n            fst[i]=ans.size();\\n            rep[i]=false;\\n            for(int j=i-1;j>=0;--j){\\n                if(nums[j]<=nums[i]){\\n                    if(!rep[j]){\\n                        ans.emplace_back(vector<int>(2,nums[i]));\\n                        ans.back()[0]=nums[j];\\n                    }\\n                    for(int k=fst[j];k<fst[j+1];++k){\\n                        ans.push_back(ans[k]);\\n                        ans.back().emplace_back(nums[i]);\\n                    }\\n                    if(nums[j]==nums[i]){\\n                        rep[i]=true;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\\n        vector<vector<int>> ans(0);\\n        if(nums.size()<2) return ans;\\n        int fst[nums.size()];       //first\\n        bool rep[nums.size()];      //repeat\\n        for(int i=0;i<nums.size();++i){\\n            fst[i]=ans.size();\\n            rep[i]=false;\\n            for(int j=i-1;j>=0;--j){\\n                if(nums[j]<=nums[i]){\\n                    if(!rep[j]){\\n                        ans.emplace_back(vector<int>(2,nums[i]));\\n                        ans.back()[0]=nums[j];\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 4067267,
                "title": "simple-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\\n        set<vector<int>> res;\\n        vector<int> holder;\\n        findSequence(res, holder, 0, nums);\\n        vector<vector<int>> result (res.begin(), res.end());\\n        return result;\\n    }\\n    \\n    void findSequence(set<vector<int>>& res, vector<int>& holder, int index, vector<int>& nums) {\\n        if (holder.size() >= 2) {\\n            res.insert(holder);\\n        }\\n        for (int i = index; i < nums.size(); i++) {\\n            if (holder.size() == 0 || holder.back() <= nums[i]) {\\n                holder.push_back(nums[i]);\\n                findSequence(res, holder, i + 1, nums);\\n                holder.pop_back();\\n            }\\n        }\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\\n        set<vector<int>> res;\\n        vector<int> holder;\\n        findSequence(res, holder, 0, nums);\\n        vector<vector<int>> result (res.begin(), res.end());\\n        return result;\\n    }\\n    \\n    void findSequence(set<vector<int>>& res, vector<int>& holder, int index, vector<int>& nums) {\\n        if (holder.size() >= 2) {\\n            res.insert(holder);\\n        }\\n        for (int i = index; i < nums.size(); i++) {\\n            if (holder.size() == 0 || holder.back() <= nums[i]) {\\n                holder.push_back(nums[i]);\\n                findSequence(res, holder, i + 1, nums);\\n                holder.pop_back();\\n            }\\n        }\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3766489,
                "title": "backtracking-easy-c",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHere i Implement the **Backtracking** Approach to find out all the **Non-decreasing Subsequences**(length>=2) and store them into a **set to handle duplicate**.\\n\\n# Complexity\\n- Time complexity:O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N*N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    set<vector<int>> st;\\n    void solve(vector<int> arr,vector<int> v,int n,int i)\\n    {\\n        if(v.size()>=2) st.insert(v);\\n        if(i>=n) return ;   \\n        if(v.size()==0 || arr[i] >= v.back())\\n        {\\n          v.push_back(arr[i]);\\n          solve(arr,v,n,i+1);\\n          v.pop_back();\\n          solve(arr,v,n,i+1);\\n        }\\n        else solve(arr,v,n,i+1);\\n    }\\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\\n        int n  =  nums.size();\\n        solve(nums,{},n,0);\\n        for(auto v : st) ans.push_back(v);\\n        return ans;  \\n    }\\n};\\n```\\n![upvote.jpg](https://assets.leetcode.com/users/images/32e4c40c-8840-4383-a0d6-0768f9ddb851_1689387458.6137347.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    set<vector<int>> st;\\n    void solve(vector<int> arr,vector<int> v,int n,int i)\\n    {\\n        if(v.size()>=2) st.insert(v);\\n        if(i>=n) return ;   \\n        if(v.size()==0 || arr[i] >= v.back())\\n        {\\n          v.push_back(arr[i]);\\n          solve(arr,v,n,i+1);\\n          v.pop_back();\\n          solve(arr,v,n,i+1);\\n        }\\n        else solve(arr,v,n,i+1);\\n    }\\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\\n        int n  =  nums.size();\\n        solve(nums,{},n,0);\\n        for(auto v : st) ans.push_back(v);\\n        return ans;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3384161,
                "title": "solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def findSubsequences(self, nums: List[int]) -> List[List[int]] :\\n        start_idxes = dict.fromkeys( nums )\\n        subseq_data = [ ]\\n        for idx , num in enumerate( nums ) :\\n            start_idx = start_idxes[ num ]\\n            num_sub = [ num ]\\n            if start_idx is None :\\n                sub_short = [ num_sub ]\\n                start_idx = 0\\n            else :\\n                sub_short = [ ]\\n            subs_long = [ \\\\\\n                sub + num_sub \\\\\\n                for p_num , subs_short_long in subseq_data[ start_idx : ] if num >= p_num \\\\\\n                for subs in subs_short_long \\\\\\n                for sub in subs \\\\\\n            ]\\n            subseq_data.append( [ num , ( sub_short , subs_long ) ] )\\n            start_idxes[ num ] = idx\\n        subseqs = [ \\\\\\n            sub \\\\\\n            for num , subs_short_long in subseq_data \\\\\\n            for sub in subs_short_long[ -1 ] \\\\\\n        ]\\n        return subseqs\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findSubsequences(self, nums: List[int]) -> List[List[int]] :\\n        start_idxes = dict.fromkeys( nums )\\n        subseq_data = [ ]\\n        for idx , num in enumerate( nums ) :\\n            start_idx = start_idxes[ num ]\\n            num_sub = [ num ]\\n            if start_idx is None :\\n                sub_short = [ num_sub ]\\n                start_idx = 0\\n            else :\\n                sub_short = [ ]\\n            subs_long = [ \\\\\\n                sub + num_sub \\\\\\n                for p_num , subs_short_long in subseq_data[ start_idx : ] if num >= p_num \\\\\\n                for subs in subs_short_long \\\\\\n                for sub in subs \\\\\\n            ]\\n            subseq_data.append( [ num , ( sub_short , subs_long ) ] )\\n            start_idxes[ num ] = idx\\n        subseqs = [ \\\\\\n            sub \\\\\\n            for num , subs_short_long in subseq_data \\\\\\n            for sub in subs_short_long[ -1 ] \\\\\\n        ]\\n        return subseqs\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3377467,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    void dfs(vector<int>& nums, vector<vector<int>>& ans, vector<int>& sub, int idx) {\\n      if (sub.size() >= 2) ans.push_back(sub);\\n      if (idx == nums.size()) return;\\n\\n      bool chk[205] = {};\\n      for (int i = idx; i < nums.size(); i++) {\\n        if (!sub.size() || sub.back() <= nums[i]) {\\n          if (chk[nums[i] + 100]) continue;\\n          chk[nums[i]+100] = true;\\n          sub.push_back(nums[i]);\\n          dfs(nums,ans,sub,i+1);\\n          sub.pop_back();\\n        }\\n      }\\n    }\\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\\n      vector<vector<int>> ans;\\n      vector<int> sub;\\n      dfs(nums, ans, sub, 0);\\n      return ans;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def findSubsequences(self, nums: List[int]) -> List[List[int]] :\\n        start_idxes = dict.fromkeys( nums )\\n        subseq_data = [ ]\\n        for idx , num in enumerate( nums ) :\\n            start_idx = start_idxes[ num ]\\n            num_sub = [ num ]\\n            if start_idx is None :\\n                sub_short = [ num_sub ]\\n                start_idx = 0\\n            else :\\n                sub_short = [ ]\\n            subs_long = [ \\\\\\n                sub + num_sub \\\\\\n                for p_num , subs_short_long in subseq_data[ start_idx : ] if num >= p_num \\\\\\n                for subs in subs_short_long \\\\\\n                for sub in subs \\\\\\n            ]\\n            subseq_data.append( [ num , ( sub_short , subs_long ) ] )\\n            start_idxes[ num ] = idx\\n        subseqs = [ \\\\\\n            sub \\\\\\n            for num , subs_short_long in subseq_data \\\\\\n            for sub in subs_short_long[ -1 ] \\\\\\n        ]\\n        return subseqs\\n```\\n\\n```Java []\\nclass Solution extends java.util.AbstractList<List<Integer>>{\\n    List<List<Integer>> lists;\\n    int[] nums;\\n    public List<List<Integer>> findSubsequences(int[] nums) {\\n        this.nums = nums;\\n        return this;\\n    }\\n    public void backtrack(Set<List<Integer>> res, List<Integer> curr, int i) {\\n        if(curr.size() >= 2) {\\n            res.add(new ArrayList<>(curr));\\n        }\\n        for(int j = i; j < nums.length; j++) {\\n            if(curr.size() == 0 || nums[j] >= curr.get(curr.size() - 1)) {\\n                curr.add(nums[j]);\\n                backtrack(res, curr, j + 1);\\n                curr.remove(curr.size() - 1);\\n            }\\n        }\\n    }\\n    @Override\\n    public List<Integer> get(int index) {\\n        if(lists == null) {\\n            this.size();\\n        }\\n        return lists.get(index);\\n    }\\n    @Override\\n    public int size() {\\n        if(lists == null) {\\n            HashSet<List<Integer>> set = new HashSet<>();\\n            backtrack(set, new ArrayList<>(), 0);\\n            lists = new ArrayList<>(set);\\n        }\\n        return lists.size();\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    void dfs(vector<int>& nums, vector<vector<int>>& ans, vector<int>& sub, int idx) {\\n      if (sub.size() >= 2) ans.push_back(sub);\\n      if (idx == nums.size()) return;\\n\\n      bool chk[205] = {};\\n      for (int i = idx; i < nums.size(); i++) {\\n        if (!sub.size() || sub.back() <= nums[i]) {\\n          if (chk[nums[i] + 100]) continue;\\n          chk[nums[i]+100] = true;\\n          sub.push_back(nums[i]);\\n          dfs(nums,ans,sub,i+1);\\n          sub.pop_back();\\n        }\\n      }\\n    }\\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\\n      vector<vector<int>> ans;\\n      vector<int> sub;\\n      dfs(nums, ans, sub, 0);\\n      return ans;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def findSubsequences(self, nums: List[int]) -> List[List[int]] :\\n        start_idxes = dict.fromkeys( nums )\\n        subseq_data = [ ]\\n        for idx , num in enumerate( nums ) :\\n            start_idx = start_idxes[ num ]\\n            num_sub = [ num ]\\n            if start_idx is None :\\n                sub_short = [ num_sub ]\\n                start_idx = 0\\n            else :\\n                sub_short = [ ]\\n            subs_long = [ \\\\\\n                sub + num_sub \\\\\\n                for p_num , subs_short_long in subseq_data[ start_idx : ] if num >= p_num \\\\\\n                for subs in subs_short_long \\\\\\n                for sub in subs \\\\\\n            ]\\n            subseq_data.append( [ num , ( sub_short , subs_long ) ] )\\n            start_idxes[ num ] = idx\\n        subseqs = [ \\\\\\n            sub \\\\\\n            for num , subs_short_long in subseq_data \\\\\\n            for sub in subs_short_long[ -1 ] \\\\\\n        ]\\n        return subseqs\\n```\n```Java []\\nclass Solution extends java.util.AbstractList<List<Integer>>{\\n    List<List<Integer>> lists;\\n    int[] nums;\\n    public List<List<Integer>> findSubsequences(int[] nums) {\\n        this.nums = nums;\\n        return this;\\n    }\\n    public void backtrack(Set<List<Integer>> res, List<Integer> curr, int i) {\\n        if(curr.size() >= 2) {\\n            res.add(new ArrayList<>(curr));\\n        }\\n        for(int j = i; j < nums.length; j++) {\\n            if(curr.size() == 0 || nums[j] >= curr.get(curr.size() - 1)) {\\n                curr.add(nums[j]);\\n                backtrack(res, curr, j + 1);\\n                curr.remove(curr.size() - 1);\\n            }\\n        }\\n    }\\n    @Override\\n    public List<Integer> get(int index) {\\n        if(lists == null) {\\n            this.size();\\n        }\\n        return lists.get(index);\\n    }\\n    @Override\\n    public int size() {\\n        if(lists == null) {\\n            HashSet<List<Integer>> set = new HashSet<>();\\n            backtrack(set, new ArrayList<>(), 0);\\n            lists = new ArrayList<>(set);\\n        }\\n        return lists.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3287681,
                "title": "a-very-basic-way-easy-to-understand-not-very-optimized",
                "content": "\\n\\n# Code\\n```\\nclass Solution\\n{\\n  public:\\n    void subSeq(vector<int> &arr, vector<int> output, int i,\\n      set<vector < int>> &ans)\\n    {\\n      if (i >= arr.size())\\n      {\\n        bool isInc = true;\\n      //  cout << \"size \" << output.size() << endl;\\n        if (output.size() > 1)\\n        {\\n          for (int k = 0; k < output.size() - 1; k++)\\n          {\\n            //cout<<output[k+1]<<\" \"<<output[k]<<endl;\\n            if (output[k + 1] >= output[k]) {}\\n            else\\n            {\\n              isInc = false;\\n              break;\\n            }\\n          }\\n        //  cout<<endl;\\n          \\n        if (isInc)\\n        {\\n          ans.insert(output);\\n        }\\n        }\\n\\n\\n        //cout << endl;\\n        return;\\n      }\\n\\n     \\t// exclude\\n      subSeq(arr, output, i + 1, ans);\\n     \\t// include\\n      output.push_back(arr[i]);\\n      subSeq(arr, output, i + 1, ans);\\n    }\\n\\n  vector<vector < int>> findSubsequences(vector<int> &nums)\\n  {\\n    set<vector < int>> ans;\\n    vector<vector < int>> an1;\\n    vector<int> output;\\n    subSeq(nums, output, 0, ans);\\n    \\n    for(auto cc:ans){\\n      vector<int> temp;\\n      for(auto cc1:cc){\\n        temp.push_back(cc1);\\n      }\\n      an1.push_back(temp);\\n     // cout<<endl;\\n    }\\n\\n    return an1;\\n  }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution\\n{\\n  public:\\n    void subSeq(vector<int> &arr, vector<int> output, int i,\\n      set<vector < int>> &ans)\\n    {\\n      if (i >= arr.size())\\n      {\\n        bool isInc = true;\\n      //  cout << \"size \" << output.size() << endl;\\n        if (output.size() > 1)\\n        {\\n          for (int k = 0; k < output.size() - 1; k++)\\n          {\\n            //cout<<output[k+1]<<\" \"<<output[k]<<endl;\\n            if (output[k + 1] >= output[k]) {}\\n            else\\n            {\\n              isInc = false;\\n              break;\\n            }\\n          }\\n        //  cout<<endl;\\n          \\n        if (isInc)\\n        {\\n          ans.insert(output);\\n        }\\n        }\\n\\n\\n        //cout << endl;\\n        return;\\n      }\\n\\n     \\t// exclude\\n      subSeq(arr, output, i + 1, ans);\\n     \\t// include\\n      output.push_back(arr[i]);\\n      subSeq(arr, output, i + 1, ans);\\n    }\\n\\n  vector<vector < int>> findSubsequences(vector<int> &nums)\\n  {\\n    set<vector < int>> ans;\\n    vector<vector < int>> an1;\\n    vector<int> output;\\n    subSeq(nums, output, 0, ans);\\n    \\n    for(auto cc:ans){\\n      vector<int> temp;\\n      for(auto cc1:cc){\\n        temp.push_back(cc1);\\n      }\\n      an1.push_back(temp);\\n     // cout<<endl;\\n    }\\n\\n    return an1;\\n  }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3084577,
                "title": "c-simple-and-clean-code-with-explanation",
                "content": "The function starts by initializing a set of vectors of integers called ans, which will be used to store unique subsequences. Then, it uses two nested loops to generate all possible subsequences in non-decreasing order. It uses a 2D vector, temp, to store intermediate subsequences and ans to store the final unique subsequences. It checks if the current element is greater than or equal to the previous element. If the condition is satisfied, it adds the current element to the previous subsequences and stores it in temp and ans. Finally, it copies the unique subsequences from ans to a vector output and returns it.\\n\\n# Complexity\\n- Time complexity:$$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n^3)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution\\n{\\npublic:\\n\\tvector<vector<int>> findSubsequences(vector<int> &nums)\\n\\t{\\n\\t\\tset<vector<int>> ans; // set to store unique subsequences\\n\\t\\tint n = nums.size();\\n\\t\\tvector<vector<vector<int>>> temp(n); // 2D vector to store intermediate subsequences\\n\\t\\tfor (int i = 0; i < n; i++)\\n\\t\\t{\\n\\t\\t\\ttemp[i].push_back({nums[i]});\\n\\t\\t\\tfor (int j = i - 1; j >= 0; j--)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (nums[i] >= nums[j])\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tfor (auto sub : temp[j])\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tsub.push_back(nums[i]);\\n\\t\\t\\t\\t\\t\\tans.insert(sub);\\n\\t\\t\\t\\t\\t\\ttemp[i].push_back(sub);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tvector<vector<int>> output;\\n\\t\\tfor (auto &sub : ans)\\n\\t\\t\\toutput.push_back(sub);\\n\\t\\treturn output;\\n\\t}\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sort"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n\\tvector<vector<int>> findSubsequences(vector<int> &nums)\\n\\t{\\n\\t\\tset<vector<int>> ans; // set to store unique subsequences\\n\\t\\tint n = nums.size();\\n\\t\\tvector<vector<vector<int>>> temp(n); // 2D vector to store intermediate subsequences\\n\\t\\tfor (int i = 0; i < n; i++)\\n\\t\\t{\\n\\t\\t\\ttemp[i].push_back({nums[i]});\\n\\t\\t\\tfor (int j = i - 1; j >= 0; j--)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (nums[i] >= nums[j])\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tfor (auto sub : temp[j])\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tsub.push_back(nums[i]);\\n\\t\\t\\t\\t\\t\\tans.insert(sub);\\n\\t\\t\\t\\t\\t\\ttemp[i].push_back(sub);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tvector<vector<int>> output;\\n\\t\\tfor (auto &sub : ans)\\n\\t\\t\\toutput.push_back(sub);\\n\\t\\treturn output;\\n\\t}\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3080378,
                "title": "c-intuitive-recursion-solution-with-set-vector-int",
                "content": "\\n# Code\\n```\\nclass Solution \\n{\\npublic:\\n\\n    set<vector<int>> res;\\n\\n    bool I(vector<int> &a)\\n    {\\n        int n = a.size();\\n        for (int i = 1; i < n; ++i) if (a[i - 1] > a[i]) return false;\\n        return n > 1;\\n    }\\n\\n    vector<int> R(vector<int> curr, int idx, vector<int> &a)\\n    {\\n        if (idx >= a.size()) return curr;\\n\\n        vector<int> temp = curr;\\n        curr.emplace_back(a[idx]);\\n        vector<int> one = R(curr, idx + 1, a), zero = R(temp, idx + 1, a);\\n\\n        if (I(one)) res.emplace(one);\\n        if (I(zero)) res.emplace(zero);\\n\\n        return curr;\\n    }\\n\\n    vector<vector<int>> findSubsequences(vector<int>& nums) \\n    {\\n        res.clear();\\n        R({}, 0, nums);\\n\\n        return vector<vector<int>>(res.begin(), res.end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n\\n    set<vector<int>> res;\\n\\n    bool I(vector<int> &a)\\n    {\\n        int n = a.size();\\n        for (int i = 1; i < n; ++i) if (a[i - 1] > a[i]) return false;\\n        return n > 1;\\n    }\\n\\n    vector<int> R(vector<int> curr, int idx, vector<int> &a)\\n    {\\n        if (idx >= a.size()) return curr;\\n\\n        vector<int> temp = curr;\\n        curr.emplace_back(a[idx]);\\n        vector<int> one = R(curr, idx + 1, a), zero = R(temp, idx + 1, a);\\n\\n        if (I(one)) res.emplace(one);\\n        if (I(zero)) res.emplace(zero);\\n\\n        return curr;\\n    }\\n\\n    vector<vector<int>> findSubsequences(vector<int>& nums) \\n    {\\n        res.clear();\\n        R({}, 0, nums);\\n\\n        return vector<vector<int>>(res.begin(), res.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3079091,
                "title": "when-you-want-to-plagiarize-stefans-solution-but-your-programming-language-slightly-s-cks",
                "content": "C# tuples are too rigid compared to Python, and [immutable collections](https://learn.microsoft.com/en-us/dotnet/api/system.collections.immutable) aren\\'t even hashable, wtf... \\uD83E\\uDD2C How can we translate @StefanPochmann\\'s [beautiful solution](https://leetcode.com/problems/non-decreasing-subsequences/solutions/97127/simple-python/)?\\n\\n\\uD83D\\uDCA1Right! Implement a [cons list](https://en.wikipedia.org/wiki/Cons) with C#9 records!\\uD83D\\uDCA1\\n```\\npublic class Solution {\\n    public IList<IList<int>> FindSubsequences(int[] nums) {\\n        HashSet<ConsList> seq = new() { new() };\\n        foreach (int n in nums)\\n            seq.UnionWith(seq.Where(s => s.Head <= n).Select(s => s.Add(n)).ToList());\\n        return seq.Select(s => s.Flatten().ToArray()).Where(s => s.Length > 1).ToArray();\\n    }\\n\\n    record ConsList {\\n        public virtual int Head => -100;\\n        public virtual ConsList Add(int h) => new ConsList<ConsList>(h, this);\\n        public virtual IEnumerable<int> Flatten() => Enumerable.Empty<int>();\\n    }\\n\\n    record ConsList<T>(int Head, T Tail) : ConsList where T : ConsList {\\n        public override int Head { get; } = Head;\\n        public override ConsList Add(int h) => new ConsList<ConsList<T>>(h, this);\\n        public override IEnumerable<int> Flatten() => Tail.Flatten().Append(Head);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public IList<IList<int>> FindSubsequences(int[] nums) {\\n        HashSet<ConsList> seq = new() { new() };\\n        foreach (int n in nums)\\n            seq.UnionWith(seq.Where(s => s.Head <= n).Select(s => s.Add(n)).ToList());\\n        return seq.Select(s => s.Flatten().ToArray()).Where(s => s.Length > 1).ToArray();\\n    }\\n\\n    record ConsList {\\n        public virtual int Head => -100;\\n        public virtual ConsList Add(int h) => new ConsList<ConsList>(h, this);\\n        public virtual IEnumerable<int> Flatten() => Enumerable.Empty<int>();\\n    }\\n\\n    record ConsList<T>(int Head, T Tail) : ConsList where T : ConsList {\\n        public override int Head { get; } = Head;\\n        public override ConsList Add(int h) => new ConsList<ConsList<T>>(h, this);\\n        public override IEnumerable<int> Flatten() => Tail.Flatten().Append(Head);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3078878,
                "title": "c-backtracking",
                "content": "~~~\\nclass Solution {\\npublic:\\n   void helper(vector<int>& nums,set<vector<int>>& ans,vector<int>& temp,int i)\\n   {\\n       if(i==nums.size())\\n       {\\n        if(temp.size()>1)\\n        {\\n            ans.insert(temp);\\n            \\n        }\\n           return;\\n       }\\n       if(temp.empty()|| nums[i]>=temp.back())\\n       {\\n           temp.push_back(nums[i]);\\n           helper(nums,ans,temp,i+1);\\n           temp.pop_back();\\n       }\\n        helper(nums,ans,temp,i+1);\\n\\n  }\\n    \\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\\n     set<vector<int>> ans;\\n       vector<int> temp;\\n        helper(nums,ans,temp,0);\\n       vector<vector<int>>  r(ans.begin(),ans.end());\\n        return r;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "class Solution {\\npublic:\\n   void helper(vector<int>& nums,set<vector<int>>& ans,vector<int>& temp,int i)\\n   {\\n       if(i==nums.size())\\n       {\\n        if(temp.size()>1)\\n        {\\n            ans.insert(temp);\\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3078574,
                "title": "c-faster-than-90-tc-o-2-n-n-easy-to-understand-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(2^n * n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // Checking an array, that it\\'s increasing or not.\\n    bool isinc(vector<int>nums)\\n    {\\n        for(int i=1;i<nums.size();i++) if(nums[i] < nums[i-1])return false;\\n        return true;\\n    }\\n\\n    // Generating all subsequence and storing desired sequence.\\n    void generateSubseq(vector<int>nums, int i, vector<int>temp, set<vector<int>>& set)\\n    {\\n            if(i==nums.size())\\n            {\\n                if(isinc(temp) && temp.size()>1)set.insert(temp);\\n                return;\\n            }\\n\\n            temp.push_back(nums[i]);\\n            generateSubseq(nums, i+1, temp, set);\\n            temp.pop_back();\\n            generateSubseq(nums, i+1, temp, set);\\n    }\\n\\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\\n        \\n        vector<int>temp;\\n        set<vector<int>>set;\\n\\n        generateSubseq(nums, 0, temp, set);\\n\\n        return vector(set.begin(), set.end());\\n    }\\n};\\n\\n```\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // Checking an array, that it\\'s increasing or not.\\n    bool isinc(vector<int>nums)\\n    {\\n        for(int i=1;i<nums.size();i++) if(nums[i] < nums[i-1])return false;\\n        return true;\\n    }\\n\\n    // Generating all subsequence and storing desired sequence.\\n    void generateSubseq(vector<int>nums, int i, vector<int>temp, set<vector<int>>& set)\\n    {\\n            if(i==nums.size())\\n            {\\n                if(isinc(temp) && temp.size()>1)set.insert(temp);\\n                return;\\n            }\\n\\n            temp.push_back(nums[i]);\\n            generateSubseq(nums, i+1, temp, set);\\n            temp.pop_back();\\n            generateSubseq(nums, i+1, temp, set);\\n    }\\n\\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\\n        \\n        vector<int>temp;\\n        set<vector<int>>set;\\n\\n        generateSubseq(nums, 0, temp, set);\\n\\n        return vector(set.begin(), set.end());\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3078564,
                "title": "491-non-decreasing-subsequences-backtracking",
                "content": "\\n# Complexity\\n- Time complexity:\\nO(N*2^N)\\n\\n- Space complexity:\\nO(N)\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> findSubsequences(int[] A) {\\n        HashSet<List<Integer>>  hs=new HashSet<>();\\n        List<Integer> ds=new ArrayList<>();\\n        recursion(0,hs,A,Integer.MIN_VALUE,ds);\\n         List al=new ArrayList<>(hs);\\n        return al;\\n    }\\n    public void recursion(int indx,HashSet<List<Integer>>  hs,int [] A,int pre,List<Integer> ds){\\n        \\n      if(ds.size() > 1){\\n         hs.add(new ArrayList<>(ds));\\n      }\\n      for(int i=indx;i<A.length;i++){\\n          if(A[i]>=pre){\\n          ds.add(A[i]);\\n          recursion(i+1,hs,A,A[i],ds);\\n          ds.remove(ds.size()-1);\\n          }\\n        }\\n    }\\n}\\n\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> findSubsequences(int[] A) {\\n        HashSet<List<Integer>>  hs=new HashSet<>();\\n        List<Integer> ds=new ArrayList<>();\\n        recursion(0,hs,A,Integer.MIN_VALUE,ds);\\n         List al=new ArrayList<>(hs);\\n        return al;\\n    }\\n    public void recursion(int indx,HashSet<List<Integer>>  hs,int [] A,int pre,List<Integer> ds){\\n        \\n      if(ds.size() > 1){\\n         hs.add(new ArrayList<>(ds));\\n      }\\n      for(int i=indx;i<A.length;i++){\\n          if(A[i]>=pre){\\n          ds.add(A[i]);\\n          recursion(i+1,hs,A,A[i],ds);\\n          ds.remove(ds.size()-1);\\n          }\\n        }\\n    }\\n}\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3078236,
                "title": "python-short-and-clean-bit-mask-functional-programming",
                "content": "# Approach\\n1. Generate all possible sub sequences (`all_sub_seqns`) using bit `mask` method.\\n\\n2. Select sub sequences having non-decreasing order (`is_non_decr`) and length greater than or equal to 2 (`is_len_ge_2`).\\n\\n3. Remove duplicates using a `set` and `return`.\\n\\n# Complexity\\n- Time complexity: $$O(2^n * n)$$\\n\\n- Space complexity: $$O(2^n * n)$$\\n\\nwhere, `n is the length of nums`.\\n\\n# Code\\n```python\\nclass Solution:\\n    def findSubsequences(self, nums: list[int]) -> list[list[int]]:\\n        masks = (map(int, reversed(bin(m)[2:])) for m in range(2 ** len(nums)))\\n        all_sub_seqns = (tuple(compress(nums, m)) for m in masks)\\n\\n        is_non_decr = lambda xs: all(starmap(le, pairwise(xs)))\\n        is_len_ge_2 = lambda xs: len(xs) >= 2\\n\\n        return set(s for s in all_sub_seqns if is_non_decr(s) and is_len_ge_2(s))\\n\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "Backtracking",
                    "Bit Manipulation"
                ],
                "code": "```python\\nclass Solution:\\n    def findSubsequences(self, nums: list[int]) -> list[list[int]]:\\n        masks = (map(int, reversed(bin(m)[2:])) for m in range(2 ** len(nums)))\\n        all_sub_seqns = (tuple(compress(nums, m)) for m in masks)\\n\\n        is_non_decr = lambda xs: all(starmap(le, pairwise(xs)))\\n        is_len_ge_2 = lambda xs: len(xs) >= 2\\n\\n        return set(s for s in all_sub_seqns if is_non_decr(s) and is_len_ge_2(s))\\n\\n        \\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1765599,
                "content": [
                    {
                        "username": "zarif98sjs",
                        "content": "The problem can be solved just by thinking it as a \"take - don't take recursion\". Furthermore, **we can avoid using `set`** to track duplicates by checking just one case. \nFirst, we take the element and do backtrack. Before going to the \"don't take\" case, we can make a simple ***check if the current number is equal to the last number of our temporary answer array***. If that is the case, we will get repeated answers if we go down this path. So, we don't recurse down if that is the case. \n\n***Time Complexity***: Each element will have two options. Either it's chosen, or it's not. So, the time complexity will be $O(2^n)$ in the worst case for sorted arrays where all the elements are considered. Most of the time it will be less than that as we get to prune early"
                    },
                    {
                        "username": "djslim",
                        "content": "Most people including top competitors solved with set , so I guess it' ok to use it"
                    },
                    {
                        "username": "uday000",
                        "content": "[@harsh_singgh](/harsh_singgh) really thankyou for the code brother"
                    },
                    {
                        "username": "uday000",
                        "content": "really thankyou [@Md Zarif Ul Alam](/zarif98sjs) for your thinking and it helped me a lot"
                    },
                    {
                        "username": "safinghoghabori65",
                        "content": "[@lotus18](/lotus18) Thank you so much for this solution. I was stuck in the loop of how to implement. "
                    },
                    {
                        "username": "lotus18",
                        "content": "Code For The Above Approach\n\n```\nclass Solution \n{\npublic:\n    vector<vector<int>> ans;\n    void f(vector<int>& nums, int x, vector<int> &v)\n    {\n        if(x==nums.size()) \n        {\n            if(v.size()>=2) ans.push_back(v);\n            return;\n        }\n        if(v.size()==0 || v.back()<=nums[x])\n        {\n            v.push_back(nums[x]);\n            f(nums,x+1,v);\n            v.pop_back();\n        }\n        if(v.size()!=0 && v.back()!=nums[x]) f(nums,x+1,v);\n        else if(v.size()==0) f(nums,x+1,v);\n        \n    }\n    vector<vector<int>> findSubsequences(vector<int>& nums) \n    {\n        vector<int> v;\n        f(nums,0,v);\n        return ans;\n    }\n};\n\n```"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "[@sanyamjain036](/sanyamjain036) \\n\\nThe idea is to create `New` HashMap in every new idx (recursive call)\\n\\nHope this code give you better insight, me myself just figure it out also when I tried switching language using golang , and sadly golang dont have generic type for set :( \\n\\nhttps://leetcode.com/problems/non-decreasing-subsequences/solutions/3077388/go-backtrack-trace-last-value/?orderBy=most_relevant"
                    },
                    {
                        "username": "hsnooob",
                        "content": "[@kerkathy](/kerkathy) Ooh Sorry about that. Check now."
                    },
                    {
                        "username": "Triquetra",
                        "content": "Various optimizations are pointless for exponential-time problems, in my opinion."
                    },
                    {
                        "username": "kerkathy",
                        "content": "[@harsh_singgh](/harsh_singgh) hi, this seems to be private, would you kindly open the code to public? :)"
                    },
                    {
                        "username": "hsnooob",
                        "content": "Nice idea, here is the implementation of it. https://leetcode.com/problems/non-decreasing-subsequences/solutions/3075983/avoid-duplicates-without-using-set/"
                    },
                    {
                        "username": "sanyamjain036",
                        "content": "Can you explain more in depth , how we can do it without using set?"
                    },
                    {
                        "username": "yadav0288",
                        "content": "[@shadab-malik](/shadab-malik)  For avoiding duplicates , we can use set because set ( set<vector<int>>ans; ) does not consider duplicates ans at the for returning ans convert set into vector example -> vector(ans.begin() , ans.end()) ;"
                    },
                    {
                        "username": "medmoe",
                        "content": "Thank you for the \" take and not take \" phrase that\\'s all what i needed"
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "Nice one"
                    },
                    {
                        "username": "shadab-malik",
                        "content": "[@hydra324](/hydra324) I\\'m still not getting how to avoid duplicates ? Can you explain it pls....\\n"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Does it work with test cases like this?\\n[1,2,5,3,5,4,5]\\nSeems that the last temporary answer array may be [1,3] or [1,4] when we want to avoid duplicates of [1, 5]?"
                    },
                    {
                        "username": "hydra324",
                        "content": "Nice observation! was sracthing my head on how to avoid duplicates without using hashsets."
                    },
                    {
                        "username": "danila_egorenko",
                        "content": "Array week is much better than graph week\\uD83D\\uDC40"
                    },
                    {
                        "username": "challengeHunter",
                        "content": "Easier one does\\'t mean better one........"
                    },
                    {
                        "username": "lineshmalkam",
                        "content": "arrayy weekk goesss brrrrrrrr............."
                    },
                    {
                        "username": "vivek271",
                        "content": "WA on testcase [1,2,3,4,5,6,7,8,9,10,1,1,1,1,1]\\n\\nOutput: https://pastebin.com/RpDxzRe4\\n\\nExpected: https://pastebin.com/wT6z01jw\\n"
                    },
                    {
                        "username": "1337beef",
                        "content": "I saw some answers which produce strictly increasing subsequences while the question now allows non-decreasing subsequences.\\n\\n"
                    },
                    {
                        "username": "RichardChe",
                        "content": "When I run my code(accepted) using [1,2,3,8,9,10,1,1,1,1,1] as test case, it doesn't match the given expected answer, but it's still accepted. Is anybody had the  same situation?"
                    },
                    {
                        "username": "scorpioneer",
                        "content": "[@gauraVSomani](/gauraVSomani) I was facing the same issue . Try to shift the pop statement inside the pick (take it ) if block because if the pop statement is present outside the if block then it will introduce the duplicates which eventually gives wrong answer . I hope it will work for you too :)  "
                    },
                    {
                        "username": "gauraVSomani",
                        "content": "My solution is not being accepted for the same. I can\\'t figure out what I am doing wrong."
                    },
                    {
                        "username": "harshpratap1601",
                        "content": "same issue"
                    },
                    {
                        "username": "abrahem",
                        "content": "read the question carefully \"You may return the answer in any order\""
                    },
                    {
                        "username": "cenjian",
                        "content": " the expect output of the case [1,2,3,4,5,6,7,8,9,10,1,1,1,1,1] doesn\\'t include [1, 1, 1], [1,1] and so on. While according to the description, they are valid subsequences. Please fix this, my dear Leetcode. "
                    },
                    {
                        "username": "the_leetcode_guy",
                        "content": "Explanatory video: https://youtu.be/UX7cY8RvDWw"
                    },
                    {
                        "username": "maltarouti",
                        "content": "This is a discussion tab: \"Please don\\'t post any solutions in this discussion tab.\""
                    },
                    {
                        "username": "rajan_jasani9",
                        "content": "Great Explanation!"
                    },
                    {
                        "username": "sudhakargoutam",
                        "content": "DP Week is coming guys.get ready :( "
                    },
                    {
                        "username": "Sidd26",
                        "content": "Is the runtime of this is at best exponential using backtracking?"
                    },
                    {
                        "username": "devvartkumarkumar",
                        "content": "++?"
                    }
                ]
            },
            {
                "id": 1765583,
                "content": [
                    {
                        "username": "zarif98sjs",
                        "content": "The problem can be solved just by thinking it as a \"take - don't take recursion\". Furthermore, **we can avoid using `set`** to track duplicates by checking just one case. \nFirst, we take the element and do backtrack. Before going to the \"don't take\" case, we can make a simple ***check if the current number is equal to the last number of our temporary answer array***. If that is the case, we will get repeated answers if we go down this path. So, we don't recurse down if that is the case. \n\n***Time Complexity***: Each element will have two options. Either it's chosen, or it's not. So, the time complexity will be $O(2^n)$ in the worst case for sorted arrays where all the elements are considered. Most of the time it will be less than that as we get to prune early"
                    },
                    {
                        "username": "djslim",
                        "content": "Most people including top competitors solved with set , so I guess it' ok to use it"
                    },
                    {
                        "username": "uday000",
                        "content": "[@harsh_singgh](/harsh_singgh) really thankyou for the code brother"
                    },
                    {
                        "username": "uday000",
                        "content": "really thankyou [@Md Zarif Ul Alam](/zarif98sjs) for your thinking and it helped me a lot"
                    },
                    {
                        "username": "safinghoghabori65",
                        "content": "[@lotus18](/lotus18) Thank you so much for this solution. I was stuck in the loop of how to implement. "
                    },
                    {
                        "username": "lotus18",
                        "content": "Code For The Above Approach\n\n```\nclass Solution \n{\npublic:\n    vector<vector<int>> ans;\n    void f(vector<int>& nums, int x, vector<int> &v)\n    {\n        if(x==nums.size()) \n        {\n            if(v.size()>=2) ans.push_back(v);\n            return;\n        }\n        if(v.size()==0 || v.back()<=nums[x])\n        {\n            v.push_back(nums[x]);\n            f(nums,x+1,v);\n            v.pop_back();\n        }\n        if(v.size()!=0 && v.back()!=nums[x]) f(nums,x+1,v);\n        else if(v.size()==0) f(nums,x+1,v);\n        \n    }\n    vector<vector<int>> findSubsequences(vector<int>& nums) \n    {\n        vector<int> v;\n        f(nums,0,v);\n        return ans;\n    }\n};\n\n```"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "[@sanyamjain036](/sanyamjain036) \\n\\nThe idea is to create `New` HashMap in every new idx (recursive call)\\n\\nHope this code give you better insight, me myself just figure it out also when I tried switching language using golang , and sadly golang dont have generic type for set :( \\n\\nhttps://leetcode.com/problems/non-decreasing-subsequences/solutions/3077388/go-backtrack-trace-last-value/?orderBy=most_relevant"
                    },
                    {
                        "username": "hsnooob",
                        "content": "[@kerkathy](/kerkathy) Ooh Sorry about that. Check now."
                    },
                    {
                        "username": "Triquetra",
                        "content": "Various optimizations are pointless for exponential-time problems, in my opinion."
                    },
                    {
                        "username": "kerkathy",
                        "content": "[@harsh_singgh](/harsh_singgh) hi, this seems to be private, would you kindly open the code to public? :)"
                    },
                    {
                        "username": "hsnooob",
                        "content": "Nice idea, here is the implementation of it. https://leetcode.com/problems/non-decreasing-subsequences/solutions/3075983/avoid-duplicates-without-using-set/"
                    },
                    {
                        "username": "sanyamjain036",
                        "content": "Can you explain more in depth , how we can do it without using set?"
                    },
                    {
                        "username": "yadav0288",
                        "content": "[@shadab-malik](/shadab-malik)  For avoiding duplicates , we can use set because set ( set<vector<int>>ans; ) does not consider duplicates ans at the for returning ans convert set into vector example -> vector(ans.begin() , ans.end()) ;"
                    },
                    {
                        "username": "medmoe",
                        "content": "Thank you for the \" take and not take \" phrase that\\'s all what i needed"
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "Nice one"
                    },
                    {
                        "username": "shadab-malik",
                        "content": "[@hydra324](/hydra324) I\\'m still not getting how to avoid duplicates ? Can you explain it pls....\\n"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Does it work with test cases like this?\\n[1,2,5,3,5,4,5]\\nSeems that the last temporary answer array may be [1,3] or [1,4] when we want to avoid duplicates of [1, 5]?"
                    },
                    {
                        "username": "hydra324",
                        "content": "Nice observation! was sracthing my head on how to avoid duplicates without using hashsets."
                    },
                    {
                        "username": "danila_egorenko",
                        "content": "Array week is much better than graph week\\uD83D\\uDC40"
                    },
                    {
                        "username": "challengeHunter",
                        "content": "Easier one does\\'t mean better one........"
                    },
                    {
                        "username": "lineshmalkam",
                        "content": "arrayy weekk goesss brrrrrrrr............."
                    },
                    {
                        "username": "vivek271",
                        "content": "WA on testcase [1,2,3,4,5,6,7,8,9,10,1,1,1,1,1]\\n\\nOutput: https://pastebin.com/RpDxzRe4\\n\\nExpected: https://pastebin.com/wT6z01jw\\n"
                    },
                    {
                        "username": "1337beef",
                        "content": "I saw some answers which produce strictly increasing subsequences while the question now allows non-decreasing subsequences.\\n\\n"
                    },
                    {
                        "username": "RichardChe",
                        "content": "When I run my code(accepted) using [1,2,3,8,9,10,1,1,1,1,1] as test case, it doesn't match the given expected answer, but it's still accepted. Is anybody had the  same situation?"
                    },
                    {
                        "username": "scorpioneer",
                        "content": "[@gauraVSomani](/gauraVSomani) I was facing the same issue . Try to shift the pop statement inside the pick (take it ) if block because if the pop statement is present outside the if block then it will introduce the duplicates which eventually gives wrong answer . I hope it will work for you too :)  "
                    },
                    {
                        "username": "gauraVSomani",
                        "content": "My solution is not being accepted for the same. I can\\'t figure out what I am doing wrong."
                    },
                    {
                        "username": "harshpratap1601",
                        "content": "same issue"
                    },
                    {
                        "username": "abrahem",
                        "content": "read the question carefully \"You may return the answer in any order\""
                    },
                    {
                        "username": "cenjian",
                        "content": " the expect output of the case [1,2,3,4,5,6,7,8,9,10,1,1,1,1,1] doesn\\'t include [1, 1, 1], [1,1] and so on. While according to the description, they are valid subsequences. Please fix this, my dear Leetcode. "
                    },
                    {
                        "username": "the_leetcode_guy",
                        "content": "Explanatory video: https://youtu.be/UX7cY8RvDWw"
                    },
                    {
                        "username": "maltarouti",
                        "content": "This is a discussion tab: \"Please don\\'t post any solutions in this discussion tab.\""
                    },
                    {
                        "username": "rajan_jasani9",
                        "content": "Great Explanation!"
                    },
                    {
                        "username": "sudhakargoutam",
                        "content": "DP Week is coming guys.get ready :( "
                    },
                    {
                        "username": "Sidd26",
                        "content": "Is the runtime of this is at best exponential using backtracking?"
                    },
                    {
                        "username": "devvartkumarkumar",
                        "content": "++?"
                    }
                ]
            },
            {
                "id": 1765858,
                "content": [
                    {
                        "username": "zarif98sjs",
                        "content": "The problem can be solved just by thinking it as a \"take - don't take recursion\". Furthermore, **we can avoid using `set`** to track duplicates by checking just one case. \nFirst, we take the element and do backtrack. Before going to the \"don't take\" case, we can make a simple ***check if the current number is equal to the last number of our temporary answer array***. If that is the case, we will get repeated answers if we go down this path. So, we don't recurse down if that is the case. \n\n***Time Complexity***: Each element will have two options. Either it's chosen, or it's not. So, the time complexity will be $O(2^n)$ in the worst case for sorted arrays where all the elements are considered. Most of the time it will be less than that as we get to prune early"
                    },
                    {
                        "username": "djslim",
                        "content": "Most people including top competitors solved with set , so I guess it' ok to use it"
                    },
                    {
                        "username": "uday000",
                        "content": "[@harsh_singgh](/harsh_singgh) really thankyou for the code brother"
                    },
                    {
                        "username": "uday000",
                        "content": "really thankyou [@Md Zarif Ul Alam](/zarif98sjs) for your thinking and it helped me a lot"
                    },
                    {
                        "username": "safinghoghabori65",
                        "content": "[@lotus18](/lotus18) Thank you so much for this solution. I was stuck in the loop of how to implement. "
                    },
                    {
                        "username": "lotus18",
                        "content": "Code For The Above Approach\n\n```\nclass Solution \n{\npublic:\n    vector<vector<int>> ans;\n    void f(vector<int>& nums, int x, vector<int> &v)\n    {\n        if(x==nums.size()) \n        {\n            if(v.size()>=2) ans.push_back(v);\n            return;\n        }\n        if(v.size()==0 || v.back()<=nums[x])\n        {\n            v.push_back(nums[x]);\n            f(nums,x+1,v);\n            v.pop_back();\n        }\n        if(v.size()!=0 && v.back()!=nums[x]) f(nums,x+1,v);\n        else if(v.size()==0) f(nums,x+1,v);\n        \n    }\n    vector<vector<int>> findSubsequences(vector<int>& nums) \n    {\n        vector<int> v;\n        f(nums,0,v);\n        return ans;\n    }\n};\n\n```"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "[@sanyamjain036](/sanyamjain036) \\n\\nThe idea is to create `New` HashMap in every new idx (recursive call)\\n\\nHope this code give you better insight, me myself just figure it out also when I tried switching language using golang , and sadly golang dont have generic type for set :( \\n\\nhttps://leetcode.com/problems/non-decreasing-subsequences/solutions/3077388/go-backtrack-trace-last-value/?orderBy=most_relevant"
                    },
                    {
                        "username": "hsnooob",
                        "content": "[@kerkathy](/kerkathy) Ooh Sorry about that. Check now."
                    },
                    {
                        "username": "Triquetra",
                        "content": "Various optimizations are pointless for exponential-time problems, in my opinion."
                    },
                    {
                        "username": "kerkathy",
                        "content": "[@harsh_singgh](/harsh_singgh) hi, this seems to be private, would you kindly open the code to public? :)"
                    },
                    {
                        "username": "hsnooob",
                        "content": "Nice idea, here is the implementation of it. https://leetcode.com/problems/non-decreasing-subsequences/solutions/3075983/avoid-duplicates-without-using-set/"
                    },
                    {
                        "username": "sanyamjain036",
                        "content": "Can you explain more in depth , how we can do it without using set?"
                    },
                    {
                        "username": "yadav0288",
                        "content": "[@shadab-malik](/shadab-malik)  For avoiding duplicates , we can use set because set ( set<vector<int>>ans; ) does not consider duplicates ans at the for returning ans convert set into vector example -> vector(ans.begin() , ans.end()) ;"
                    },
                    {
                        "username": "medmoe",
                        "content": "Thank you for the \" take and not take \" phrase that\\'s all what i needed"
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "Nice one"
                    },
                    {
                        "username": "shadab-malik",
                        "content": "[@hydra324](/hydra324) I\\'m still not getting how to avoid duplicates ? Can you explain it pls....\\n"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Does it work with test cases like this?\\n[1,2,5,3,5,4,5]\\nSeems that the last temporary answer array may be [1,3] or [1,4] when we want to avoid duplicates of [1, 5]?"
                    },
                    {
                        "username": "hydra324",
                        "content": "Nice observation! was sracthing my head on how to avoid duplicates without using hashsets."
                    },
                    {
                        "username": "danila_egorenko",
                        "content": "Array week is much better than graph week\\uD83D\\uDC40"
                    },
                    {
                        "username": "challengeHunter",
                        "content": "Easier one does\\'t mean better one........"
                    },
                    {
                        "username": "lineshmalkam",
                        "content": "arrayy weekk goesss brrrrrrrr............."
                    },
                    {
                        "username": "vivek271",
                        "content": "WA on testcase [1,2,3,4,5,6,7,8,9,10,1,1,1,1,1]\\n\\nOutput: https://pastebin.com/RpDxzRe4\\n\\nExpected: https://pastebin.com/wT6z01jw\\n"
                    },
                    {
                        "username": "1337beef",
                        "content": "I saw some answers which produce strictly increasing subsequences while the question now allows non-decreasing subsequences.\\n\\n"
                    },
                    {
                        "username": "RichardChe",
                        "content": "When I run my code(accepted) using [1,2,3,8,9,10,1,1,1,1,1] as test case, it doesn't match the given expected answer, but it's still accepted. Is anybody had the  same situation?"
                    },
                    {
                        "username": "scorpioneer",
                        "content": "[@gauraVSomani](/gauraVSomani) I was facing the same issue . Try to shift the pop statement inside the pick (take it ) if block because if the pop statement is present outside the if block then it will introduce the duplicates which eventually gives wrong answer . I hope it will work for you too :)  "
                    },
                    {
                        "username": "gauraVSomani",
                        "content": "My solution is not being accepted for the same. I can\\'t figure out what I am doing wrong."
                    },
                    {
                        "username": "harshpratap1601",
                        "content": "same issue"
                    },
                    {
                        "username": "abrahem",
                        "content": "read the question carefully \"You may return the answer in any order\""
                    },
                    {
                        "username": "cenjian",
                        "content": " the expect output of the case [1,2,3,4,5,6,7,8,9,10,1,1,1,1,1] doesn\\'t include [1, 1, 1], [1,1] and so on. While according to the description, they are valid subsequences. Please fix this, my dear Leetcode. "
                    },
                    {
                        "username": "the_leetcode_guy",
                        "content": "Explanatory video: https://youtu.be/UX7cY8RvDWw"
                    },
                    {
                        "username": "maltarouti",
                        "content": "This is a discussion tab: \"Please don\\'t post any solutions in this discussion tab.\""
                    },
                    {
                        "username": "rajan_jasani9",
                        "content": "Great Explanation!"
                    },
                    {
                        "username": "sudhakargoutam",
                        "content": "DP Week is coming guys.get ready :( "
                    },
                    {
                        "username": "Sidd26",
                        "content": "Is the runtime of this is at best exponential using backtracking?"
                    },
                    {
                        "username": "devvartkumarkumar",
                        "content": "++?"
                    }
                ]
            },
            {
                "id": 1766899,
                "content": [
                    {
                        "username": "zarif98sjs",
                        "content": "The problem can be solved just by thinking it as a \"take - don't take recursion\". Furthermore, **we can avoid using `set`** to track duplicates by checking just one case. \nFirst, we take the element and do backtrack. Before going to the \"don't take\" case, we can make a simple ***check if the current number is equal to the last number of our temporary answer array***. If that is the case, we will get repeated answers if we go down this path. So, we don't recurse down if that is the case. \n\n***Time Complexity***: Each element will have two options. Either it's chosen, or it's not. So, the time complexity will be $O(2^n)$ in the worst case for sorted arrays where all the elements are considered. Most of the time it will be less than that as we get to prune early"
                    },
                    {
                        "username": "djslim",
                        "content": "Most people including top competitors solved with set , so I guess it' ok to use it"
                    },
                    {
                        "username": "uday000",
                        "content": "[@harsh_singgh](/harsh_singgh) really thankyou for the code brother"
                    },
                    {
                        "username": "uday000",
                        "content": "really thankyou [@Md Zarif Ul Alam](/zarif98sjs) for your thinking and it helped me a lot"
                    },
                    {
                        "username": "safinghoghabori65",
                        "content": "[@lotus18](/lotus18) Thank you so much for this solution. I was stuck in the loop of how to implement. "
                    },
                    {
                        "username": "lotus18",
                        "content": "Code For The Above Approach\n\n```\nclass Solution \n{\npublic:\n    vector<vector<int>> ans;\n    void f(vector<int>& nums, int x, vector<int> &v)\n    {\n        if(x==nums.size()) \n        {\n            if(v.size()>=2) ans.push_back(v);\n            return;\n        }\n        if(v.size()==0 || v.back()<=nums[x])\n        {\n            v.push_back(nums[x]);\n            f(nums,x+1,v);\n            v.pop_back();\n        }\n        if(v.size()!=0 && v.back()!=nums[x]) f(nums,x+1,v);\n        else if(v.size()==0) f(nums,x+1,v);\n        \n    }\n    vector<vector<int>> findSubsequences(vector<int>& nums) \n    {\n        vector<int> v;\n        f(nums,0,v);\n        return ans;\n    }\n};\n\n```"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "[@sanyamjain036](/sanyamjain036) \\n\\nThe idea is to create `New` HashMap in every new idx (recursive call)\\n\\nHope this code give you better insight, me myself just figure it out also when I tried switching language using golang , and sadly golang dont have generic type for set :( \\n\\nhttps://leetcode.com/problems/non-decreasing-subsequences/solutions/3077388/go-backtrack-trace-last-value/?orderBy=most_relevant"
                    },
                    {
                        "username": "hsnooob",
                        "content": "[@kerkathy](/kerkathy) Ooh Sorry about that. Check now."
                    },
                    {
                        "username": "Triquetra",
                        "content": "Various optimizations are pointless for exponential-time problems, in my opinion."
                    },
                    {
                        "username": "kerkathy",
                        "content": "[@harsh_singgh](/harsh_singgh) hi, this seems to be private, would you kindly open the code to public? :)"
                    },
                    {
                        "username": "hsnooob",
                        "content": "Nice idea, here is the implementation of it. https://leetcode.com/problems/non-decreasing-subsequences/solutions/3075983/avoid-duplicates-without-using-set/"
                    },
                    {
                        "username": "sanyamjain036",
                        "content": "Can you explain more in depth , how we can do it without using set?"
                    },
                    {
                        "username": "yadav0288",
                        "content": "[@shadab-malik](/shadab-malik)  For avoiding duplicates , we can use set because set ( set<vector<int>>ans; ) does not consider duplicates ans at the for returning ans convert set into vector example -> vector(ans.begin() , ans.end()) ;"
                    },
                    {
                        "username": "medmoe",
                        "content": "Thank you for the \" take and not take \" phrase that\\'s all what i needed"
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "Nice one"
                    },
                    {
                        "username": "shadab-malik",
                        "content": "[@hydra324](/hydra324) I\\'m still not getting how to avoid duplicates ? Can you explain it pls....\\n"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Does it work with test cases like this?\\n[1,2,5,3,5,4,5]\\nSeems that the last temporary answer array may be [1,3] or [1,4] when we want to avoid duplicates of [1, 5]?"
                    },
                    {
                        "username": "hydra324",
                        "content": "Nice observation! was sracthing my head on how to avoid duplicates without using hashsets."
                    },
                    {
                        "username": "danila_egorenko",
                        "content": "Array week is much better than graph week\\uD83D\\uDC40"
                    },
                    {
                        "username": "challengeHunter",
                        "content": "Easier one does\\'t mean better one........"
                    },
                    {
                        "username": "lineshmalkam",
                        "content": "arrayy weekk goesss brrrrrrrr............."
                    },
                    {
                        "username": "vivek271",
                        "content": "WA on testcase [1,2,3,4,5,6,7,8,9,10,1,1,1,1,1]\\n\\nOutput: https://pastebin.com/RpDxzRe4\\n\\nExpected: https://pastebin.com/wT6z01jw\\n"
                    },
                    {
                        "username": "1337beef",
                        "content": "I saw some answers which produce strictly increasing subsequences while the question now allows non-decreasing subsequences.\\n\\n"
                    },
                    {
                        "username": "RichardChe",
                        "content": "When I run my code(accepted) using [1,2,3,8,9,10,1,1,1,1,1] as test case, it doesn't match the given expected answer, but it's still accepted. Is anybody had the  same situation?"
                    },
                    {
                        "username": "scorpioneer",
                        "content": "[@gauraVSomani](/gauraVSomani) I was facing the same issue . Try to shift the pop statement inside the pick (take it ) if block because if the pop statement is present outside the if block then it will introduce the duplicates which eventually gives wrong answer . I hope it will work for you too :)  "
                    },
                    {
                        "username": "gauraVSomani",
                        "content": "My solution is not being accepted for the same. I can\\'t figure out what I am doing wrong."
                    },
                    {
                        "username": "harshpratap1601",
                        "content": "same issue"
                    },
                    {
                        "username": "abrahem",
                        "content": "read the question carefully \"You may return the answer in any order\""
                    },
                    {
                        "username": "cenjian",
                        "content": " the expect output of the case [1,2,3,4,5,6,7,8,9,10,1,1,1,1,1] doesn\\'t include [1, 1, 1], [1,1] and so on. While according to the description, they are valid subsequences. Please fix this, my dear Leetcode. "
                    },
                    {
                        "username": "the_leetcode_guy",
                        "content": "Explanatory video: https://youtu.be/UX7cY8RvDWw"
                    },
                    {
                        "username": "maltarouti",
                        "content": "This is a discussion tab: \"Please don\\'t post any solutions in this discussion tab.\""
                    },
                    {
                        "username": "rajan_jasani9",
                        "content": "Great Explanation!"
                    },
                    {
                        "username": "sudhakargoutam",
                        "content": "DP Week is coming guys.get ready :( "
                    },
                    {
                        "username": "Sidd26",
                        "content": "Is the runtime of this is at best exponential using backtracking?"
                    },
                    {
                        "username": "devvartkumarkumar",
                        "content": "++?"
                    }
                ]
            },
            {
                "id": 1573441,
                "content": [
                    {
                        "username": "zarif98sjs",
                        "content": "The problem can be solved just by thinking it as a \"take - don't take recursion\". Furthermore, **we can avoid using `set`** to track duplicates by checking just one case. \nFirst, we take the element and do backtrack. Before going to the \"don't take\" case, we can make a simple ***check if the current number is equal to the last number of our temporary answer array***. If that is the case, we will get repeated answers if we go down this path. So, we don't recurse down if that is the case. \n\n***Time Complexity***: Each element will have two options. Either it's chosen, or it's not. So, the time complexity will be $O(2^n)$ in the worst case for sorted arrays where all the elements are considered. Most of the time it will be less than that as we get to prune early"
                    },
                    {
                        "username": "djslim",
                        "content": "Most people including top competitors solved with set , so I guess it' ok to use it"
                    },
                    {
                        "username": "uday000",
                        "content": "[@harsh_singgh](/harsh_singgh) really thankyou for the code brother"
                    },
                    {
                        "username": "uday000",
                        "content": "really thankyou [@Md Zarif Ul Alam](/zarif98sjs) for your thinking and it helped me a lot"
                    },
                    {
                        "username": "safinghoghabori65",
                        "content": "[@lotus18](/lotus18) Thank you so much for this solution. I was stuck in the loop of how to implement. "
                    },
                    {
                        "username": "lotus18",
                        "content": "Code For The Above Approach\n\n```\nclass Solution \n{\npublic:\n    vector<vector<int>> ans;\n    void f(vector<int>& nums, int x, vector<int> &v)\n    {\n        if(x==nums.size()) \n        {\n            if(v.size()>=2) ans.push_back(v);\n            return;\n        }\n        if(v.size()==0 || v.back()<=nums[x])\n        {\n            v.push_back(nums[x]);\n            f(nums,x+1,v);\n            v.pop_back();\n        }\n        if(v.size()!=0 && v.back()!=nums[x]) f(nums,x+1,v);\n        else if(v.size()==0) f(nums,x+1,v);\n        \n    }\n    vector<vector<int>> findSubsequences(vector<int>& nums) \n    {\n        vector<int> v;\n        f(nums,0,v);\n        return ans;\n    }\n};\n\n```"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "[@sanyamjain036](/sanyamjain036) \\n\\nThe idea is to create `New` HashMap in every new idx (recursive call)\\n\\nHope this code give you better insight, me myself just figure it out also when I tried switching language using golang , and sadly golang dont have generic type for set :( \\n\\nhttps://leetcode.com/problems/non-decreasing-subsequences/solutions/3077388/go-backtrack-trace-last-value/?orderBy=most_relevant"
                    },
                    {
                        "username": "hsnooob",
                        "content": "[@kerkathy](/kerkathy) Ooh Sorry about that. Check now."
                    },
                    {
                        "username": "Triquetra",
                        "content": "Various optimizations are pointless for exponential-time problems, in my opinion."
                    },
                    {
                        "username": "kerkathy",
                        "content": "[@harsh_singgh](/harsh_singgh) hi, this seems to be private, would you kindly open the code to public? :)"
                    },
                    {
                        "username": "hsnooob",
                        "content": "Nice idea, here is the implementation of it. https://leetcode.com/problems/non-decreasing-subsequences/solutions/3075983/avoid-duplicates-without-using-set/"
                    },
                    {
                        "username": "sanyamjain036",
                        "content": "Can you explain more in depth , how we can do it without using set?"
                    },
                    {
                        "username": "yadav0288",
                        "content": "[@shadab-malik](/shadab-malik)  For avoiding duplicates , we can use set because set ( set<vector<int>>ans; ) does not consider duplicates ans at the for returning ans convert set into vector example -> vector(ans.begin() , ans.end()) ;"
                    },
                    {
                        "username": "medmoe",
                        "content": "Thank you for the \" take and not take \" phrase that\\'s all what i needed"
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "Nice one"
                    },
                    {
                        "username": "shadab-malik",
                        "content": "[@hydra324](/hydra324) I\\'m still not getting how to avoid duplicates ? Can you explain it pls....\\n"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Does it work with test cases like this?\\n[1,2,5,3,5,4,5]\\nSeems that the last temporary answer array may be [1,3] or [1,4] when we want to avoid duplicates of [1, 5]?"
                    },
                    {
                        "username": "hydra324",
                        "content": "Nice observation! was sracthing my head on how to avoid duplicates without using hashsets."
                    },
                    {
                        "username": "danila_egorenko",
                        "content": "Array week is much better than graph week\\uD83D\\uDC40"
                    },
                    {
                        "username": "challengeHunter",
                        "content": "Easier one does\\'t mean better one........"
                    },
                    {
                        "username": "lineshmalkam",
                        "content": "arrayy weekk goesss brrrrrrrr............."
                    },
                    {
                        "username": "vivek271",
                        "content": "WA on testcase [1,2,3,4,5,6,7,8,9,10,1,1,1,1,1]\\n\\nOutput: https://pastebin.com/RpDxzRe4\\n\\nExpected: https://pastebin.com/wT6z01jw\\n"
                    },
                    {
                        "username": "1337beef",
                        "content": "I saw some answers which produce strictly increasing subsequences while the question now allows non-decreasing subsequences.\\n\\n"
                    },
                    {
                        "username": "RichardChe",
                        "content": "When I run my code(accepted) using [1,2,3,8,9,10,1,1,1,1,1] as test case, it doesn't match the given expected answer, but it's still accepted. Is anybody had the  same situation?"
                    },
                    {
                        "username": "scorpioneer",
                        "content": "[@gauraVSomani](/gauraVSomani) I was facing the same issue . Try to shift the pop statement inside the pick (take it ) if block because if the pop statement is present outside the if block then it will introduce the duplicates which eventually gives wrong answer . I hope it will work for you too :)  "
                    },
                    {
                        "username": "gauraVSomani",
                        "content": "My solution is not being accepted for the same. I can\\'t figure out what I am doing wrong."
                    },
                    {
                        "username": "harshpratap1601",
                        "content": "same issue"
                    },
                    {
                        "username": "abrahem",
                        "content": "read the question carefully \"You may return the answer in any order\""
                    },
                    {
                        "username": "cenjian",
                        "content": " the expect output of the case [1,2,3,4,5,6,7,8,9,10,1,1,1,1,1] doesn\\'t include [1, 1, 1], [1,1] and so on. While according to the description, they are valid subsequences. Please fix this, my dear Leetcode. "
                    },
                    {
                        "username": "the_leetcode_guy",
                        "content": "Explanatory video: https://youtu.be/UX7cY8RvDWw"
                    },
                    {
                        "username": "maltarouti",
                        "content": "This is a discussion tab: \"Please don\\'t post any solutions in this discussion tab.\""
                    },
                    {
                        "username": "rajan_jasani9",
                        "content": "Great Explanation!"
                    },
                    {
                        "username": "sudhakargoutam",
                        "content": "DP Week is coming guys.get ready :( "
                    },
                    {
                        "username": "Sidd26",
                        "content": "Is the runtime of this is at best exponential using backtracking?"
                    },
                    {
                        "username": "devvartkumarkumar",
                        "content": "++?"
                    }
                ]
            },
            {
                "id": 1571748,
                "content": [
                    {
                        "username": "zarif98sjs",
                        "content": "The problem can be solved just by thinking it as a \"take - don't take recursion\". Furthermore, **we can avoid using `set`** to track duplicates by checking just one case. \nFirst, we take the element and do backtrack. Before going to the \"don't take\" case, we can make a simple ***check if the current number is equal to the last number of our temporary answer array***. If that is the case, we will get repeated answers if we go down this path. So, we don't recurse down if that is the case. \n\n***Time Complexity***: Each element will have two options. Either it's chosen, or it's not. So, the time complexity will be $O(2^n)$ in the worst case for sorted arrays where all the elements are considered. Most of the time it will be less than that as we get to prune early"
                    },
                    {
                        "username": "djslim",
                        "content": "Most people including top competitors solved with set , so I guess it' ok to use it"
                    },
                    {
                        "username": "uday000",
                        "content": "[@harsh_singgh](/harsh_singgh) really thankyou for the code brother"
                    },
                    {
                        "username": "uday000",
                        "content": "really thankyou [@Md Zarif Ul Alam](/zarif98sjs) for your thinking and it helped me a lot"
                    },
                    {
                        "username": "safinghoghabori65",
                        "content": "[@lotus18](/lotus18) Thank you so much for this solution. I was stuck in the loop of how to implement. "
                    },
                    {
                        "username": "lotus18",
                        "content": "Code For The Above Approach\n\n```\nclass Solution \n{\npublic:\n    vector<vector<int>> ans;\n    void f(vector<int>& nums, int x, vector<int> &v)\n    {\n        if(x==nums.size()) \n        {\n            if(v.size()>=2) ans.push_back(v);\n            return;\n        }\n        if(v.size()==0 || v.back()<=nums[x])\n        {\n            v.push_back(nums[x]);\n            f(nums,x+1,v);\n            v.pop_back();\n        }\n        if(v.size()!=0 && v.back()!=nums[x]) f(nums,x+1,v);\n        else if(v.size()==0) f(nums,x+1,v);\n        \n    }\n    vector<vector<int>> findSubsequences(vector<int>& nums) \n    {\n        vector<int> v;\n        f(nums,0,v);\n        return ans;\n    }\n};\n\n```"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "[@sanyamjain036](/sanyamjain036) \\n\\nThe idea is to create `New` HashMap in every new idx (recursive call)\\n\\nHope this code give you better insight, me myself just figure it out also when I tried switching language using golang , and sadly golang dont have generic type for set :( \\n\\nhttps://leetcode.com/problems/non-decreasing-subsequences/solutions/3077388/go-backtrack-trace-last-value/?orderBy=most_relevant"
                    },
                    {
                        "username": "hsnooob",
                        "content": "[@kerkathy](/kerkathy) Ooh Sorry about that. Check now."
                    },
                    {
                        "username": "Triquetra",
                        "content": "Various optimizations are pointless for exponential-time problems, in my opinion."
                    },
                    {
                        "username": "kerkathy",
                        "content": "[@harsh_singgh](/harsh_singgh) hi, this seems to be private, would you kindly open the code to public? :)"
                    },
                    {
                        "username": "hsnooob",
                        "content": "Nice idea, here is the implementation of it. https://leetcode.com/problems/non-decreasing-subsequences/solutions/3075983/avoid-duplicates-without-using-set/"
                    },
                    {
                        "username": "sanyamjain036",
                        "content": "Can you explain more in depth , how we can do it without using set?"
                    },
                    {
                        "username": "yadav0288",
                        "content": "[@shadab-malik](/shadab-malik)  For avoiding duplicates , we can use set because set ( set<vector<int>>ans; ) does not consider duplicates ans at the for returning ans convert set into vector example -> vector(ans.begin() , ans.end()) ;"
                    },
                    {
                        "username": "medmoe",
                        "content": "Thank you for the \" take and not take \" phrase that\\'s all what i needed"
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "Nice one"
                    },
                    {
                        "username": "shadab-malik",
                        "content": "[@hydra324](/hydra324) I\\'m still not getting how to avoid duplicates ? Can you explain it pls....\\n"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Does it work with test cases like this?\\n[1,2,5,3,5,4,5]\\nSeems that the last temporary answer array may be [1,3] or [1,4] when we want to avoid duplicates of [1, 5]?"
                    },
                    {
                        "username": "hydra324",
                        "content": "Nice observation! was sracthing my head on how to avoid duplicates without using hashsets."
                    },
                    {
                        "username": "danila_egorenko",
                        "content": "Array week is much better than graph week\\uD83D\\uDC40"
                    },
                    {
                        "username": "challengeHunter",
                        "content": "Easier one does\\'t mean better one........"
                    },
                    {
                        "username": "lineshmalkam",
                        "content": "arrayy weekk goesss brrrrrrrr............."
                    },
                    {
                        "username": "vivek271",
                        "content": "WA on testcase [1,2,3,4,5,6,7,8,9,10,1,1,1,1,1]\\n\\nOutput: https://pastebin.com/RpDxzRe4\\n\\nExpected: https://pastebin.com/wT6z01jw\\n"
                    },
                    {
                        "username": "1337beef",
                        "content": "I saw some answers which produce strictly increasing subsequences while the question now allows non-decreasing subsequences.\\n\\n"
                    },
                    {
                        "username": "RichardChe",
                        "content": "When I run my code(accepted) using [1,2,3,8,9,10,1,1,1,1,1] as test case, it doesn't match the given expected answer, but it's still accepted. Is anybody had the  same situation?"
                    },
                    {
                        "username": "scorpioneer",
                        "content": "[@gauraVSomani](/gauraVSomani) I was facing the same issue . Try to shift the pop statement inside the pick (take it ) if block because if the pop statement is present outside the if block then it will introduce the duplicates which eventually gives wrong answer . I hope it will work for you too :)  "
                    },
                    {
                        "username": "gauraVSomani",
                        "content": "My solution is not being accepted for the same. I can\\'t figure out what I am doing wrong."
                    },
                    {
                        "username": "harshpratap1601",
                        "content": "same issue"
                    },
                    {
                        "username": "abrahem",
                        "content": "read the question carefully \"You may return the answer in any order\""
                    },
                    {
                        "username": "cenjian",
                        "content": " the expect output of the case [1,2,3,4,5,6,7,8,9,10,1,1,1,1,1] doesn\\'t include [1, 1, 1], [1,1] and so on. While according to the description, they are valid subsequences. Please fix this, my dear Leetcode. "
                    },
                    {
                        "username": "the_leetcode_guy",
                        "content": "Explanatory video: https://youtu.be/UX7cY8RvDWw"
                    },
                    {
                        "username": "maltarouti",
                        "content": "This is a discussion tab: \"Please don\\'t post any solutions in this discussion tab.\""
                    },
                    {
                        "username": "rajan_jasani9",
                        "content": "Great Explanation!"
                    },
                    {
                        "username": "sudhakargoutam",
                        "content": "DP Week is coming guys.get ready :( "
                    },
                    {
                        "username": "Sidd26",
                        "content": "Is the runtime of this is at best exponential using backtracking?"
                    },
                    {
                        "username": "devvartkumarkumar",
                        "content": "++?"
                    }
                ]
            },
            {
                "id": 1855577,
                "content": [
                    {
                        "username": "zarif98sjs",
                        "content": "The problem can be solved just by thinking it as a \"take - don't take recursion\". Furthermore, **we can avoid using `set`** to track duplicates by checking just one case. \nFirst, we take the element and do backtrack. Before going to the \"don't take\" case, we can make a simple ***check if the current number is equal to the last number of our temporary answer array***. If that is the case, we will get repeated answers if we go down this path. So, we don't recurse down if that is the case. \n\n***Time Complexity***: Each element will have two options. Either it's chosen, or it's not. So, the time complexity will be $O(2^n)$ in the worst case for sorted arrays where all the elements are considered. Most of the time it will be less than that as we get to prune early"
                    },
                    {
                        "username": "djslim",
                        "content": "Most people including top competitors solved with set , so I guess it' ok to use it"
                    },
                    {
                        "username": "uday000",
                        "content": "[@harsh_singgh](/harsh_singgh) really thankyou for the code brother"
                    },
                    {
                        "username": "uday000",
                        "content": "really thankyou [@Md Zarif Ul Alam](/zarif98sjs) for your thinking and it helped me a lot"
                    },
                    {
                        "username": "safinghoghabori65",
                        "content": "[@lotus18](/lotus18) Thank you so much for this solution. I was stuck in the loop of how to implement. "
                    },
                    {
                        "username": "lotus18",
                        "content": "Code For The Above Approach\n\n```\nclass Solution \n{\npublic:\n    vector<vector<int>> ans;\n    void f(vector<int>& nums, int x, vector<int> &v)\n    {\n        if(x==nums.size()) \n        {\n            if(v.size()>=2) ans.push_back(v);\n            return;\n        }\n        if(v.size()==0 || v.back()<=nums[x])\n        {\n            v.push_back(nums[x]);\n            f(nums,x+1,v);\n            v.pop_back();\n        }\n        if(v.size()!=0 && v.back()!=nums[x]) f(nums,x+1,v);\n        else if(v.size()==0) f(nums,x+1,v);\n        \n    }\n    vector<vector<int>> findSubsequences(vector<int>& nums) \n    {\n        vector<int> v;\n        f(nums,0,v);\n        return ans;\n    }\n};\n\n```"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "[@sanyamjain036](/sanyamjain036) \\n\\nThe idea is to create `New` HashMap in every new idx (recursive call)\\n\\nHope this code give you better insight, me myself just figure it out also when I tried switching language using golang , and sadly golang dont have generic type for set :( \\n\\nhttps://leetcode.com/problems/non-decreasing-subsequences/solutions/3077388/go-backtrack-trace-last-value/?orderBy=most_relevant"
                    },
                    {
                        "username": "hsnooob",
                        "content": "[@kerkathy](/kerkathy) Ooh Sorry about that. Check now."
                    },
                    {
                        "username": "Triquetra",
                        "content": "Various optimizations are pointless for exponential-time problems, in my opinion."
                    },
                    {
                        "username": "kerkathy",
                        "content": "[@harsh_singgh](/harsh_singgh) hi, this seems to be private, would you kindly open the code to public? :)"
                    },
                    {
                        "username": "hsnooob",
                        "content": "Nice idea, here is the implementation of it. https://leetcode.com/problems/non-decreasing-subsequences/solutions/3075983/avoid-duplicates-without-using-set/"
                    },
                    {
                        "username": "sanyamjain036",
                        "content": "Can you explain more in depth , how we can do it without using set?"
                    },
                    {
                        "username": "yadav0288",
                        "content": "[@shadab-malik](/shadab-malik)  For avoiding duplicates , we can use set because set ( set<vector<int>>ans; ) does not consider duplicates ans at the for returning ans convert set into vector example -> vector(ans.begin() , ans.end()) ;"
                    },
                    {
                        "username": "medmoe",
                        "content": "Thank you for the \" take and not take \" phrase that\\'s all what i needed"
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "Nice one"
                    },
                    {
                        "username": "shadab-malik",
                        "content": "[@hydra324](/hydra324) I\\'m still not getting how to avoid duplicates ? Can you explain it pls....\\n"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Does it work with test cases like this?\\n[1,2,5,3,5,4,5]\\nSeems that the last temporary answer array may be [1,3] or [1,4] when we want to avoid duplicates of [1, 5]?"
                    },
                    {
                        "username": "hydra324",
                        "content": "Nice observation! was sracthing my head on how to avoid duplicates without using hashsets."
                    },
                    {
                        "username": "danila_egorenko",
                        "content": "Array week is much better than graph week\\uD83D\\uDC40"
                    },
                    {
                        "username": "challengeHunter",
                        "content": "Easier one does\\'t mean better one........"
                    },
                    {
                        "username": "lineshmalkam",
                        "content": "arrayy weekk goesss brrrrrrrr............."
                    },
                    {
                        "username": "vivek271",
                        "content": "WA on testcase [1,2,3,4,5,6,7,8,9,10,1,1,1,1,1]\\n\\nOutput: https://pastebin.com/RpDxzRe4\\n\\nExpected: https://pastebin.com/wT6z01jw\\n"
                    },
                    {
                        "username": "1337beef",
                        "content": "I saw some answers which produce strictly increasing subsequences while the question now allows non-decreasing subsequences.\\n\\n"
                    },
                    {
                        "username": "RichardChe",
                        "content": "When I run my code(accepted) using [1,2,3,8,9,10,1,1,1,1,1] as test case, it doesn't match the given expected answer, but it's still accepted. Is anybody had the  same situation?"
                    },
                    {
                        "username": "scorpioneer",
                        "content": "[@gauraVSomani](/gauraVSomani) I was facing the same issue . Try to shift the pop statement inside the pick (take it ) if block because if the pop statement is present outside the if block then it will introduce the duplicates which eventually gives wrong answer . I hope it will work for you too :)  "
                    },
                    {
                        "username": "gauraVSomani",
                        "content": "My solution is not being accepted for the same. I can\\'t figure out what I am doing wrong."
                    },
                    {
                        "username": "harshpratap1601",
                        "content": "same issue"
                    },
                    {
                        "username": "abrahem",
                        "content": "read the question carefully \"You may return the answer in any order\""
                    },
                    {
                        "username": "cenjian",
                        "content": " the expect output of the case [1,2,3,4,5,6,7,8,9,10,1,1,1,1,1] doesn\\'t include [1, 1, 1], [1,1] and so on. While according to the description, they are valid subsequences. Please fix this, my dear Leetcode. "
                    },
                    {
                        "username": "the_leetcode_guy",
                        "content": "Explanatory video: https://youtu.be/UX7cY8RvDWw"
                    },
                    {
                        "username": "maltarouti",
                        "content": "This is a discussion tab: \"Please don\\'t post any solutions in this discussion tab.\""
                    },
                    {
                        "username": "rajan_jasani9",
                        "content": "Great Explanation!"
                    },
                    {
                        "username": "sudhakargoutam",
                        "content": "DP Week is coming guys.get ready :( "
                    },
                    {
                        "username": "Sidd26",
                        "content": "Is the runtime of this is at best exponential using backtracking?"
                    },
                    {
                        "username": "devvartkumarkumar",
                        "content": "++?"
                    }
                ]
            },
            {
                "id": 1765903,
                "content": [
                    {
                        "username": "zarif98sjs",
                        "content": "The problem can be solved just by thinking it as a \"take - don't take recursion\". Furthermore, **we can avoid using `set`** to track duplicates by checking just one case. \nFirst, we take the element and do backtrack. Before going to the \"don't take\" case, we can make a simple ***check if the current number is equal to the last number of our temporary answer array***. If that is the case, we will get repeated answers if we go down this path. So, we don't recurse down if that is the case. \n\n***Time Complexity***: Each element will have two options. Either it's chosen, or it's not. So, the time complexity will be $O(2^n)$ in the worst case for sorted arrays where all the elements are considered. Most of the time it will be less than that as we get to prune early"
                    },
                    {
                        "username": "djslim",
                        "content": "Most people including top competitors solved with set , so I guess it' ok to use it"
                    },
                    {
                        "username": "uday000",
                        "content": "[@harsh_singgh](/harsh_singgh) really thankyou for the code brother"
                    },
                    {
                        "username": "uday000",
                        "content": "really thankyou [@Md Zarif Ul Alam](/zarif98sjs) for your thinking and it helped me a lot"
                    },
                    {
                        "username": "safinghoghabori65",
                        "content": "[@lotus18](/lotus18) Thank you so much for this solution. I was stuck in the loop of how to implement. "
                    },
                    {
                        "username": "lotus18",
                        "content": "Code For The Above Approach\n\n```\nclass Solution \n{\npublic:\n    vector<vector<int>> ans;\n    void f(vector<int>& nums, int x, vector<int> &v)\n    {\n        if(x==nums.size()) \n        {\n            if(v.size()>=2) ans.push_back(v);\n            return;\n        }\n        if(v.size()==0 || v.back()<=nums[x])\n        {\n            v.push_back(nums[x]);\n            f(nums,x+1,v);\n            v.pop_back();\n        }\n        if(v.size()!=0 && v.back()!=nums[x]) f(nums,x+1,v);\n        else if(v.size()==0) f(nums,x+1,v);\n        \n    }\n    vector<vector<int>> findSubsequences(vector<int>& nums) \n    {\n        vector<int> v;\n        f(nums,0,v);\n        return ans;\n    }\n};\n\n```"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "[@sanyamjain036](/sanyamjain036) \\n\\nThe idea is to create `New` HashMap in every new idx (recursive call)\\n\\nHope this code give you better insight, me myself just figure it out also when I tried switching language using golang , and sadly golang dont have generic type for set :( \\n\\nhttps://leetcode.com/problems/non-decreasing-subsequences/solutions/3077388/go-backtrack-trace-last-value/?orderBy=most_relevant"
                    },
                    {
                        "username": "hsnooob",
                        "content": "[@kerkathy](/kerkathy) Ooh Sorry about that. Check now."
                    },
                    {
                        "username": "Triquetra",
                        "content": "Various optimizations are pointless for exponential-time problems, in my opinion."
                    },
                    {
                        "username": "kerkathy",
                        "content": "[@harsh_singgh](/harsh_singgh) hi, this seems to be private, would you kindly open the code to public? :)"
                    },
                    {
                        "username": "hsnooob",
                        "content": "Nice idea, here is the implementation of it. https://leetcode.com/problems/non-decreasing-subsequences/solutions/3075983/avoid-duplicates-without-using-set/"
                    },
                    {
                        "username": "sanyamjain036",
                        "content": "Can you explain more in depth , how we can do it without using set?"
                    },
                    {
                        "username": "yadav0288",
                        "content": "[@shadab-malik](/shadab-malik)  For avoiding duplicates , we can use set because set ( set<vector<int>>ans; ) does not consider duplicates ans at the for returning ans convert set into vector example -> vector(ans.begin() , ans.end()) ;"
                    },
                    {
                        "username": "medmoe",
                        "content": "Thank you for the \" take and not take \" phrase that\\'s all what i needed"
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "Nice one"
                    },
                    {
                        "username": "shadab-malik",
                        "content": "[@hydra324](/hydra324) I\\'m still not getting how to avoid duplicates ? Can you explain it pls....\\n"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Does it work with test cases like this?\\n[1,2,5,3,5,4,5]\\nSeems that the last temporary answer array may be [1,3] or [1,4] when we want to avoid duplicates of [1, 5]?"
                    },
                    {
                        "username": "hydra324",
                        "content": "Nice observation! was sracthing my head on how to avoid duplicates without using hashsets."
                    },
                    {
                        "username": "danila_egorenko",
                        "content": "Array week is much better than graph week\\uD83D\\uDC40"
                    },
                    {
                        "username": "challengeHunter",
                        "content": "Easier one does\\'t mean better one........"
                    },
                    {
                        "username": "lineshmalkam",
                        "content": "arrayy weekk goesss brrrrrrrr............."
                    },
                    {
                        "username": "vivek271",
                        "content": "WA on testcase [1,2,3,4,5,6,7,8,9,10,1,1,1,1,1]\\n\\nOutput: https://pastebin.com/RpDxzRe4\\n\\nExpected: https://pastebin.com/wT6z01jw\\n"
                    },
                    {
                        "username": "1337beef",
                        "content": "I saw some answers which produce strictly increasing subsequences while the question now allows non-decreasing subsequences.\\n\\n"
                    },
                    {
                        "username": "RichardChe",
                        "content": "When I run my code(accepted) using [1,2,3,8,9,10,1,1,1,1,1] as test case, it doesn't match the given expected answer, but it's still accepted. Is anybody had the  same situation?"
                    },
                    {
                        "username": "scorpioneer",
                        "content": "[@gauraVSomani](/gauraVSomani) I was facing the same issue . Try to shift the pop statement inside the pick (take it ) if block because if the pop statement is present outside the if block then it will introduce the duplicates which eventually gives wrong answer . I hope it will work for you too :)  "
                    },
                    {
                        "username": "gauraVSomani",
                        "content": "My solution is not being accepted for the same. I can\\'t figure out what I am doing wrong."
                    },
                    {
                        "username": "harshpratap1601",
                        "content": "same issue"
                    },
                    {
                        "username": "abrahem",
                        "content": "read the question carefully \"You may return the answer in any order\""
                    },
                    {
                        "username": "cenjian",
                        "content": " the expect output of the case [1,2,3,4,5,6,7,8,9,10,1,1,1,1,1] doesn\\'t include [1, 1, 1], [1,1] and so on. While according to the description, they are valid subsequences. Please fix this, my dear Leetcode. "
                    },
                    {
                        "username": "the_leetcode_guy",
                        "content": "Explanatory video: https://youtu.be/UX7cY8RvDWw"
                    },
                    {
                        "username": "maltarouti",
                        "content": "This is a discussion tab: \"Please don\\'t post any solutions in this discussion tab.\""
                    },
                    {
                        "username": "rajan_jasani9",
                        "content": "Great Explanation!"
                    },
                    {
                        "username": "sudhakargoutam",
                        "content": "DP Week is coming guys.get ready :( "
                    },
                    {
                        "username": "Sidd26",
                        "content": "Is the runtime of this is at best exponential using backtracking?"
                    },
                    {
                        "username": "devvartkumarkumar",
                        "content": "++?"
                    }
                ]
            },
            {
                "id": 1765678,
                "content": [
                    {
                        "username": "zarif98sjs",
                        "content": "The problem can be solved just by thinking it as a \"take - don't take recursion\". Furthermore, **we can avoid using `set`** to track duplicates by checking just one case. \nFirst, we take the element and do backtrack. Before going to the \"don't take\" case, we can make a simple ***check if the current number is equal to the last number of our temporary answer array***. If that is the case, we will get repeated answers if we go down this path. So, we don't recurse down if that is the case. \n\n***Time Complexity***: Each element will have two options. Either it's chosen, or it's not. So, the time complexity will be $O(2^n)$ in the worst case for sorted arrays where all the elements are considered. Most of the time it will be less than that as we get to prune early"
                    },
                    {
                        "username": "djslim",
                        "content": "Most people including top competitors solved with set , so I guess it' ok to use it"
                    },
                    {
                        "username": "uday000",
                        "content": "[@harsh_singgh](/harsh_singgh) really thankyou for the code brother"
                    },
                    {
                        "username": "uday000",
                        "content": "really thankyou [@Md Zarif Ul Alam](/zarif98sjs) for your thinking and it helped me a lot"
                    },
                    {
                        "username": "safinghoghabori65",
                        "content": "[@lotus18](/lotus18) Thank you so much for this solution. I was stuck in the loop of how to implement. "
                    },
                    {
                        "username": "lotus18",
                        "content": "Code For The Above Approach\n\n```\nclass Solution \n{\npublic:\n    vector<vector<int>> ans;\n    void f(vector<int>& nums, int x, vector<int> &v)\n    {\n        if(x==nums.size()) \n        {\n            if(v.size()>=2) ans.push_back(v);\n            return;\n        }\n        if(v.size()==0 || v.back()<=nums[x])\n        {\n            v.push_back(nums[x]);\n            f(nums,x+1,v);\n            v.pop_back();\n        }\n        if(v.size()!=0 && v.back()!=nums[x]) f(nums,x+1,v);\n        else if(v.size()==0) f(nums,x+1,v);\n        \n    }\n    vector<vector<int>> findSubsequences(vector<int>& nums) \n    {\n        vector<int> v;\n        f(nums,0,v);\n        return ans;\n    }\n};\n\n```"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "[@sanyamjain036](/sanyamjain036) \\n\\nThe idea is to create `New` HashMap in every new idx (recursive call)\\n\\nHope this code give you better insight, me myself just figure it out also when I tried switching language using golang , and sadly golang dont have generic type for set :( \\n\\nhttps://leetcode.com/problems/non-decreasing-subsequences/solutions/3077388/go-backtrack-trace-last-value/?orderBy=most_relevant"
                    },
                    {
                        "username": "hsnooob",
                        "content": "[@kerkathy](/kerkathy) Ooh Sorry about that. Check now."
                    },
                    {
                        "username": "Triquetra",
                        "content": "Various optimizations are pointless for exponential-time problems, in my opinion."
                    },
                    {
                        "username": "kerkathy",
                        "content": "[@harsh_singgh](/harsh_singgh) hi, this seems to be private, would you kindly open the code to public? :)"
                    },
                    {
                        "username": "hsnooob",
                        "content": "Nice idea, here is the implementation of it. https://leetcode.com/problems/non-decreasing-subsequences/solutions/3075983/avoid-duplicates-without-using-set/"
                    },
                    {
                        "username": "sanyamjain036",
                        "content": "Can you explain more in depth , how we can do it without using set?"
                    },
                    {
                        "username": "yadav0288",
                        "content": "[@shadab-malik](/shadab-malik)  For avoiding duplicates , we can use set because set ( set<vector<int>>ans; ) does not consider duplicates ans at the for returning ans convert set into vector example -> vector(ans.begin() , ans.end()) ;"
                    },
                    {
                        "username": "medmoe",
                        "content": "Thank you for the \" take and not take \" phrase that\\'s all what i needed"
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "Nice one"
                    },
                    {
                        "username": "shadab-malik",
                        "content": "[@hydra324](/hydra324) I\\'m still not getting how to avoid duplicates ? Can you explain it pls....\\n"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Does it work with test cases like this?\\n[1,2,5,3,5,4,5]\\nSeems that the last temporary answer array may be [1,3] or [1,4] when we want to avoid duplicates of [1, 5]?"
                    },
                    {
                        "username": "hydra324",
                        "content": "Nice observation! was sracthing my head on how to avoid duplicates without using hashsets."
                    },
                    {
                        "username": "danila_egorenko",
                        "content": "Array week is much better than graph week\\uD83D\\uDC40"
                    },
                    {
                        "username": "challengeHunter",
                        "content": "Easier one does\\'t mean better one........"
                    },
                    {
                        "username": "lineshmalkam",
                        "content": "arrayy weekk goesss brrrrrrrr............."
                    },
                    {
                        "username": "vivek271",
                        "content": "WA on testcase [1,2,3,4,5,6,7,8,9,10,1,1,1,1,1]\\n\\nOutput: https://pastebin.com/RpDxzRe4\\n\\nExpected: https://pastebin.com/wT6z01jw\\n"
                    },
                    {
                        "username": "1337beef",
                        "content": "I saw some answers which produce strictly increasing subsequences while the question now allows non-decreasing subsequences.\\n\\n"
                    },
                    {
                        "username": "RichardChe",
                        "content": "When I run my code(accepted) using [1,2,3,8,9,10,1,1,1,1,1] as test case, it doesn't match the given expected answer, but it's still accepted. Is anybody had the  same situation?"
                    },
                    {
                        "username": "scorpioneer",
                        "content": "[@gauraVSomani](/gauraVSomani) I was facing the same issue . Try to shift the pop statement inside the pick (take it ) if block because if the pop statement is present outside the if block then it will introduce the duplicates which eventually gives wrong answer . I hope it will work for you too :)  "
                    },
                    {
                        "username": "gauraVSomani",
                        "content": "My solution is not being accepted for the same. I can\\'t figure out what I am doing wrong."
                    },
                    {
                        "username": "harshpratap1601",
                        "content": "same issue"
                    },
                    {
                        "username": "abrahem",
                        "content": "read the question carefully \"You may return the answer in any order\""
                    },
                    {
                        "username": "cenjian",
                        "content": " the expect output of the case [1,2,3,4,5,6,7,8,9,10,1,1,1,1,1] doesn\\'t include [1, 1, 1], [1,1] and so on. While according to the description, they are valid subsequences. Please fix this, my dear Leetcode. "
                    },
                    {
                        "username": "the_leetcode_guy",
                        "content": "Explanatory video: https://youtu.be/UX7cY8RvDWw"
                    },
                    {
                        "username": "maltarouti",
                        "content": "This is a discussion tab: \"Please don\\'t post any solutions in this discussion tab.\""
                    },
                    {
                        "username": "rajan_jasani9",
                        "content": "Great Explanation!"
                    },
                    {
                        "username": "sudhakargoutam",
                        "content": "DP Week is coming guys.get ready :( "
                    },
                    {
                        "username": "Sidd26",
                        "content": "Is the runtime of this is at best exponential using backtracking?"
                    },
                    {
                        "username": "devvartkumarkumar",
                        "content": "++?"
                    }
                ]
            },
            {
                "id": 1571749,
                "content": [
                    {
                        "username": "zarif98sjs",
                        "content": "The problem can be solved just by thinking it as a \"take - don't take recursion\". Furthermore, **we can avoid using `set`** to track duplicates by checking just one case. \nFirst, we take the element and do backtrack. Before going to the \"don't take\" case, we can make a simple ***check if the current number is equal to the last number of our temporary answer array***. If that is the case, we will get repeated answers if we go down this path. So, we don't recurse down if that is the case. \n\n***Time Complexity***: Each element will have two options. Either it's chosen, or it's not. So, the time complexity will be $O(2^n)$ in the worst case for sorted arrays where all the elements are considered. Most of the time it will be less than that as we get to prune early"
                    },
                    {
                        "username": "djslim",
                        "content": "Most people including top competitors solved with set , so I guess it' ok to use it"
                    },
                    {
                        "username": "uday000",
                        "content": "[@harsh_singgh](/harsh_singgh) really thankyou for the code brother"
                    },
                    {
                        "username": "uday000",
                        "content": "really thankyou [@Md Zarif Ul Alam](/zarif98sjs) for your thinking and it helped me a lot"
                    },
                    {
                        "username": "safinghoghabori65",
                        "content": "[@lotus18](/lotus18) Thank you so much for this solution. I was stuck in the loop of how to implement. "
                    },
                    {
                        "username": "lotus18",
                        "content": "Code For The Above Approach\n\n```\nclass Solution \n{\npublic:\n    vector<vector<int>> ans;\n    void f(vector<int>& nums, int x, vector<int> &v)\n    {\n        if(x==nums.size()) \n        {\n            if(v.size()>=2) ans.push_back(v);\n            return;\n        }\n        if(v.size()==0 || v.back()<=nums[x])\n        {\n            v.push_back(nums[x]);\n            f(nums,x+1,v);\n            v.pop_back();\n        }\n        if(v.size()!=0 && v.back()!=nums[x]) f(nums,x+1,v);\n        else if(v.size()==0) f(nums,x+1,v);\n        \n    }\n    vector<vector<int>> findSubsequences(vector<int>& nums) \n    {\n        vector<int> v;\n        f(nums,0,v);\n        return ans;\n    }\n};\n\n```"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "[@sanyamjain036](/sanyamjain036) \\n\\nThe idea is to create `New` HashMap in every new idx (recursive call)\\n\\nHope this code give you better insight, me myself just figure it out also when I tried switching language using golang , and sadly golang dont have generic type for set :( \\n\\nhttps://leetcode.com/problems/non-decreasing-subsequences/solutions/3077388/go-backtrack-trace-last-value/?orderBy=most_relevant"
                    },
                    {
                        "username": "hsnooob",
                        "content": "[@kerkathy](/kerkathy) Ooh Sorry about that. Check now."
                    },
                    {
                        "username": "Triquetra",
                        "content": "Various optimizations are pointless for exponential-time problems, in my opinion."
                    },
                    {
                        "username": "kerkathy",
                        "content": "[@harsh_singgh](/harsh_singgh) hi, this seems to be private, would you kindly open the code to public? :)"
                    },
                    {
                        "username": "hsnooob",
                        "content": "Nice idea, here is the implementation of it. https://leetcode.com/problems/non-decreasing-subsequences/solutions/3075983/avoid-duplicates-without-using-set/"
                    },
                    {
                        "username": "sanyamjain036",
                        "content": "Can you explain more in depth , how we can do it without using set?"
                    },
                    {
                        "username": "yadav0288",
                        "content": "[@shadab-malik](/shadab-malik)  For avoiding duplicates , we can use set because set ( set<vector<int>>ans; ) does not consider duplicates ans at the for returning ans convert set into vector example -> vector(ans.begin() , ans.end()) ;"
                    },
                    {
                        "username": "medmoe",
                        "content": "Thank you for the \" take and not take \" phrase that\\'s all what i needed"
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "Nice one"
                    },
                    {
                        "username": "shadab-malik",
                        "content": "[@hydra324](/hydra324) I\\'m still not getting how to avoid duplicates ? Can you explain it pls....\\n"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Does it work with test cases like this?\\n[1,2,5,3,5,4,5]\\nSeems that the last temporary answer array may be [1,3] or [1,4] when we want to avoid duplicates of [1, 5]?"
                    },
                    {
                        "username": "hydra324",
                        "content": "Nice observation! was sracthing my head on how to avoid duplicates without using hashsets."
                    },
                    {
                        "username": "danila_egorenko",
                        "content": "Array week is much better than graph week\\uD83D\\uDC40"
                    },
                    {
                        "username": "challengeHunter",
                        "content": "Easier one does\\'t mean better one........"
                    },
                    {
                        "username": "lineshmalkam",
                        "content": "arrayy weekk goesss brrrrrrrr............."
                    },
                    {
                        "username": "vivek271",
                        "content": "WA on testcase [1,2,3,4,5,6,7,8,9,10,1,1,1,1,1]\\n\\nOutput: https://pastebin.com/RpDxzRe4\\n\\nExpected: https://pastebin.com/wT6z01jw\\n"
                    },
                    {
                        "username": "1337beef",
                        "content": "I saw some answers which produce strictly increasing subsequences while the question now allows non-decreasing subsequences.\\n\\n"
                    },
                    {
                        "username": "RichardChe",
                        "content": "When I run my code(accepted) using [1,2,3,8,9,10,1,1,1,1,1] as test case, it doesn't match the given expected answer, but it's still accepted. Is anybody had the  same situation?"
                    },
                    {
                        "username": "scorpioneer",
                        "content": "[@gauraVSomani](/gauraVSomani) I was facing the same issue . Try to shift the pop statement inside the pick (take it ) if block because if the pop statement is present outside the if block then it will introduce the duplicates which eventually gives wrong answer . I hope it will work for you too :)  "
                    },
                    {
                        "username": "gauraVSomani",
                        "content": "My solution is not being accepted for the same. I can\\'t figure out what I am doing wrong."
                    },
                    {
                        "username": "harshpratap1601",
                        "content": "same issue"
                    },
                    {
                        "username": "abrahem",
                        "content": "read the question carefully \"You may return the answer in any order\""
                    },
                    {
                        "username": "cenjian",
                        "content": " the expect output of the case [1,2,3,4,5,6,7,8,9,10,1,1,1,1,1] doesn\\'t include [1, 1, 1], [1,1] and so on. While according to the description, they are valid subsequences. Please fix this, my dear Leetcode. "
                    },
                    {
                        "username": "the_leetcode_guy",
                        "content": "Explanatory video: https://youtu.be/UX7cY8RvDWw"
                    },
                    {
                        "username": "maltarouti",
                        "content": "This is a discussion tab: \"Please don\\'t post any solutions in this discussion tab.\""
                    },
                    {
                        "username": "rajan_jasani9",
                        "content": "Great Explanation!"
                    },
                    {
                        "username": "sudhakargoutam",
                        "content": "DP Week is coming guys.get ready :( "
                    },
                    {
                        "username": "Sidd26",
                        "content": "Is the runtime of this is at best exponential using backtracking?"
                    },
                    {
                        "username": "devvartkumarkumar",
                        "content": "++?"
                    }
                ]
            },
            {
                "id": 1765599,
                "content": [
                    {
                        "username": "zarif98sjs",
                        "content": "The problem can be solved just by thinking it as a \"take - don't take recursion\". Furthermore, **we can avoid using `set`** to track duplicates by checking just one case. \nFirst, we take the element and do backtrack. Before going to the \"don't take\" case, we can make a simple ***check if the current number is equal to the last number of our temporary answer array***. If that is the case, we will get repeated answers if we go down this path. So, we don't recurse down if that is the case. \n\n***Time Complexity***: Each element will have two options. Either it's chosen, or it's not. So, the time complexity will be $O(2^n)$ in the worst case for sorted arrays where all the elements are considered. Most of the time it will be less than that as we get to prune early"
                    },
                    {
                        "username": "djslim",
                        "content": "Most people including top competitors solved with set , so I guess it' ok to use it"
                    },
                    {
                        "username": "uday000",
                        "content": "[@harsh_singgh](/harsh_singgh) really thankyou for the code brother"
                    },
                    {
                        "username": "uday000",
                        "content": "really thankyou [@Md Zarif Ul Alam](/zarif98sjs) for your thinking and it helped me a lot"
                    },
                    {
                        "username": "safinghoghabori65",
                        "content": "[@lotus18](/lotus18) Thank you so much for this solution. I was stuck in the loop of how to implement. "
                    },
                    {
                        "username": "lotus18",
                        "content": "Code For The Above Approach\n\n```\nclass Solution \n{\npublic:\n    vector<vector<int>> ans;\n    void f(vector<int>& nums, int x, vector<int> &v)\n    {\n        if(x==nums.size()) \n        {\n            if(v.size()>=2) ans.push_back(v);\n            return;\n        }\n        if(v.size()==0 || v.back()<=nums[x])\n        {\n            v.push_back(nums[x]);\n            f(nums,x+1,v);\n            v.pop_back();\n        }\n        if(v.size()!=0 && v.back()!=nums[x]) f(nums,x+1,v);\n        else if(v.size()==0) f(nums,x+1,v);\n        \n    }\n    vector<vector<int>> findSubsequences(vector<int>& nums) \n    {\n        vector<int> v;\n        f(nums,0,v);\n        return ans;\n    }\n};\n\n```"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "[@sanyamjain036](/sanyamjain036) \\n\\nThe idea is to create `New` HashMap in every new idx (recursive call)\\n\\nHope this code give you better insight, me myself just figure it out also when I tried switching language using golang , and sadly golang dont have generic type for set :( \\n\\nhttps://leetcode.com/problems/non-decreasing-subsequences/solutions/3077388/go-backtrack-trace-last-value/?orderBy=most_relevant"
                    },
                    {
                        "username": "hsnooob",
                        "content": "[@kerkathy](/kerkathy) Ooh Sorry about that. Check now."
                    },
                    {
                        "username": "Triquetra",
                        "content": "Various optimizations are pointless for exponential-time problems, in my opinion."
                    },
                    {
                        "username": "kerkathy",
                        "content": "[@harsh_singgh](/harsh_singgh) hi, this seems to be private, would you kindly open the code to public? :)"
                    },
                    {
                        "username": "hsnooob",
                        "content": "Nice idea, here is the implementation of it. https://leetcode.com/problems/non-decreasing-subsequences/solutions/3075983/avoid-duplicates-without-using-set/"
                    },
                    {
                        "username": "sanyamjain036",
                        "content": "Can you explain more in depth , how we can do it without using set?"
                    },
                    {
                        "username": "yadav0288",
                        "content": "[@shadab-malik](/shadab-malik)  For avoiding duplicates , we can use set because set ( set<vector<int>>ans; ) does not consider duplicates ans at the for returning ans convert set into vector example -> vector(ans.begin() , ans.end()) ;"
                    },
                    {
                        "username": "medmoe",
                        "content": "Thank you for the \" take and not take \" phrase that\\'s all what i needed"
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "Nice one"
                    },
                    {
                        "username": "shadab-malik",
                        "content": "[@hydra324](/hydra324) I\\'m still not getting how to avoid duplicates ? Can you explain it pls....\\n"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Does it work with test cases like this?\\n[1,2,5,3,5,4,5]\\nSeems that the last temporary answer array may be [1,3] or [1,4] when we want to avoid duplicates of [1, 5]?"
                    },
                    {
                        "username": "hydra324",
                        "content": "Nice observation! was sracthing my head on how to avoid duplicates without using hashsets."
                    },
                    {
                        "username": "danila_egorenko",
                        "content": "Array week is much better than graph week\\uD83D\\uDC40"
                    },
                    {
                        "username": "challengeHunter",
                        "content": "Easier one does\\'t mean better one........"
                    },
                    {
                        "username": "lineshmalkam",
                        "content": "arrayy weekk goesss brrrrrrrr............."
                    },
                    {
                        "username": "vivek271",
                        "content": "WA on testcase [1,2,3,4,5,6,7,8,9,10,1,1,1,1,1]\\n\\nOutput: https://pastebin.com/RpDxzRe4\\n\\nExpected: https://pastebin.com/wT6z01jw\\n"
                    },
                    {
                        "username": "1337beef",
                        "content": "I saw some answers which produce strictly increasing subsequences while the question now allows non-decreasing subsequences.\\n\\n"
                    },
                    {
                        "username": "RichardChe",
                        "content": "When I run my code(accepted) using [1,2,3,8,9,10,1,1,1,1,1] as test case, it doesn't match the given expected answer, but it's still accepted. Is anybody had the  same situation?"
                    },
                    {
                        "username": "scorpioneer",
                        "content": "[@gauraVSomani](/gauraVSomani) I was facing the same issue . Try to shift the pop statement inside the pick (take it ) if block because if the pop statement is present outside the if block then it will introduce the duplicates which eventually gives wrong answer . I hope it will work for you too :)  "
                    },
                    {
                        "username": "gauraVSomani",
                        "content": "My solution is not being accepted for the same. I can\\'t figure out what I am doing wrong."
                    },
                    {
                        "username": "harshpratap1601",
                        "content": "same issue"
                    },
                    {
                        "username": "abrahem",
                        "content": "read the question carefully \"You may return the answer in any order\""
                    },
                    {
                        "username": "cenjian",
                        "content": " the expect output of the case [1,2,3,4,5,6,7,8,9,10,1,1,1,1,1] doesn\\'t include [1, 1, 1], [1,1] and so on. While according to the description, they are valid subsequences. Please fix this, my dear Leetcode. "
                    },
                    {
                        "username": "the_leetcode_guy",
                        "content": "Explanatory video: https://youtu.be/UX7cY8RvDWw"
                    },
                    {
                        "username": "maltarouti",
                        "content": "This is a discussion tab: \"Please don\\'t post any solutions in this discussion tab.\""
                    },
                    {
                        "username": "rajan_jasani9",
                        "content": "Great Explanation!"
                    },
                    {
                        "username": "sudhakargoutam",
                        "content": "DP Week is coming guys.get ready :( "
                    },
                    {
                        "username": "Sidd26",
                        "content": "Is the runtime of this is at best exponential using backtracking?"
                    },
                    {
                        "username": "devvartkumarkumar",
                        "content": "++?"
                    }
                ]
            },
            {
                "id": 1765583,
                "content": [
                    {
                        "username": "zarif98sjs",
                        "content": "The problem can be solved just by thinking it as a \"take - don't take recursion\". Furthermore, **we can avoid using `set`** to track duplicates by checking just one case. \nFirst, we take the element and do backtrack. Before going to the \"don't take\" case, we can make a simple ***check if the current number is equal to the last number of our temporary answer array***. If that is the case, we will get repeated answers if we go down this path. So, we don't recurse down if that is the case. \n\n***Time Complexity***: Each element will have two options. Either it's chosen, or it's not. So, the time complexity will be $O(2^n)$ in the worst case for sorted arrays where all the elements are considered. Most of the time it will be less than that as we get to prune early"
                    },
                    {
                        "username": "djslim",
                        "content": "Most people including top competitors solved with set , so I guess it' ok to use it"
                    },
                    {
                        "username": "uday000",
                        "content": "[@harsh_singgh](/harsh_singgh) really thankyou for the code brother"
                    },
                    {
                        "username": "uday000",
                        "content": "really thankyou [@Md Zarif Ul Alam](/zarif98sjs) for your thinking and it helped me a lot"
                    },
                    {
                        "username": "safinghoghabori65",
                        "content": "[@lotus18](/lotus18) Thank you so much for this solution. I was stuck in the loop of how to implement. "
                    },
                    {
                        "username": "lotus18",
                        "content": "Code For The Above Approach\n\n```\nclass Solution \n{\npublic:\n    vector<vector<int>> ans;\n    void f(vector<int>& nums, int x, vector<int> &v)\n    {\n        if(x==nums.size()) \n        {\n            if(v.size()>=2) ans.push_back(v);\n            return;\n        }\n        if(v.size()==0 || v.back()<=nums[x])\n        {\n            v.push_back(nums[x]);\n            f(nums,x+1,v);\n            v.pop_back();\n        }\n        if(v.size()!=0 && v.back()!=nums[x]) f(nums,x+1,v);\n        else if(v.size()==0) f(nums,x+1,v);\n        \n    }\n    vector<vector<int>> findSubsequences(vector<int>& nums) \n    {\n        vector<int> v;\n        f(nums,0,v);\n        return ans;\n    }\n};\n\n```"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "[@sanyamjain036](/sanyamjain036) \\n\\nThe idea is to create `New` HashMap in every new idx (recursive call)\\n\\nHope this code give you better insight, me myself just figure it out also when I tried switching language using golang , and sadly golang dont have generic type for set :( \\n\\nhttps://leetcode.com/problems/non-decreasing-subsequences/solutions/3077388/go-backtrack-trace-last-value/?orderBy=most_relevant"
                    },
                    {
                        "username": "hsnooob",
                        "content": "[@kerkathy](/kerkathy) Ooh Sorry about that. Check now."
                    },
                    {
                        "username": "Triquetra",
                        "content": "Various optimizations are pointless for exponential-time problems, in my opinion."
                    },
                    {
                        "username": "kerkathy",
                        "content": "[@harsh_singgh](/harsh_singgh) hi, this seems to be private, would you kindly open the code to public? :)"
                    },
                    {
                        "username": "hsnooob",
                        "content": "Nice idea, here is the implementation of it. https://leetcode.com/problems/non-decreasing-subsequences/solutions/3075983/avoid-duplicates-without-using-set/"
                    },
                    {
                        "username": "sanyamjain036",
                        "content": "Can you explain more in depth , how we can do it without using set?"
                    },
                    {
                        "username": "yadav0288",
                        "content": "[@shadab-malik](/shadab-malik)  For avoiding duplicates , we can use set because set ( set<vector<int>>ans; ) does not consider duplicates ans at the for returning ans convert set into vector example -> vector(ans.begin() , ans.end()) ;"
                    },
                    {
                        "username": "medmoe",
                        "content": "Thank you for the \" take and not take \" phrase that\\'s all what i needed"
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "Nice one"
                    },
                    {
                        "username": "shadab-malik",
                        "content": "[@hydra324](/hydra324) I\\'m still not getting how to avoid duplicates ? Can you explain it pls....\\n"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Does it work with test cases like this?\\n[1,2,5,3,5,4,5]\\nSeems that the last temporary answer array may be [1,3] or [1,4] when we want to avoid duplicates of [1, 5]?"
                    },
                    {
                        "username": "hydra324",
                        "content": "Nice observation! was sracthing my head on how to avoid duplicates without using hashsets."
                    },
                    {
                        "username": "danila_egorenko",
                        "content": "Array week is much better than graph week\\uD83D\\uDC40"
                    },
                    {
                        "username": "challengeHunter",
                        "content": "Easier one does\\'t mean better one........"
                    },
                    {
                        "username": "lineshmalkam",
                        "content": "arrayy weekk goesss brrrrrrrr............."
                    },
                    {
                        "username": "vivek271",
                        "content": "WA on testcase [1,2,3,4,5,6,7,8,9,10,1,1,1,1,1]\\n\\nOutput: https://pastebin.com/RpDxzRe4\\n\\nExpected: https://pastebin.com/wT6z01jw\\n"
                    },
                    {
                        "username": "1337beef",
                        "content": "I saw some answers which produce strictly increasing subsequences while the question now allows non-decreasing subsequences.\\n\\n"
                    },
                    {
                        "username": "RichardChe",
                        "content": "When I run my code(accepted) using [1,2,3,8,9,10,1,1,1,1,1] as test case, it doesn't match the given expected answer, but it's still accepted. Is anybody had the  same situation?"
                    },
                    {
                        "username": "scorpioneer",
                        "content": "[@gauraVSomani](/gauraVSomani) I was facing the same issue . Try to shift the pop statement inside the pick (take it ) if block because if the pop statement is present outside the if block then it will introduce the duplicates which eventually gives wrong answer . I hope it will work for you too :)  "
                    },
                    {
                        "username": "gauraVSomani",
                        "content": "My solution is not being accepted for the same. I can\\'t figure out what I am doing wrong."
                    },
                    {
                        "username": "harshpratap1601",
                        "content": "same issue"
                    },
                    {
                        "username": "abrahem",
                        "content": "read the question carefully \"You may return the answer in any order\""
                    },
                    {
                        "username": "cenjian",
                        "content": " the expect output of the case [1,2,3,4,5,6,7,8,9,10,1,1,1,1,1] doesn\\'t include [1, 1, 1], [1,1] and so on. While according to the description, they are valid subsequences. Please fix this, my dear Leetcode. "
                    },
                    {
                        "username": "the_leetcode_guy",
                        "content": "Explanatory video: https://youtu.be/UX7cY8RvDWw"
                    },
                    {
                        "username": "maltarouti",
                        "content": "This is a discussion tab: \"Please don\\'t post any solutions in this discussion tab.\""
                    },
                    {
                        "username": "rajan_jasani9",
                        "content": "Great Explanation!"
                    },
                    {
                        "username": "sudhakargoutam",
                        "content": "DP Week is coming guys.get ready :( "
                    },
                    {
                        "username": "Sidd26",
                        "content": "Is the runtime of this is at best exponential using backtracking?"
                    },
                    {
                        "username": "devvartkumarkumar",
                        "content": "++?"
                    }
                ]
            },
            {
                "id": 1765858,
                "content": [
                    {
                        "username": "zarif98sjs",
                        "content": "The problem can be solved just by thinking it as a \"take - don't take recursion\". Furthermore, **we can avoid using `set`** to track duplicates by checking just one case. \nFirst, we take the element and do backtrack. Before going to the \"don't take\" case, we can make a simple ***check if the current number is equal to the last number of our temporary answer array***. If that is the case, we will get repeated answers if we go down this path. So, we don't recurse down if that is the case. \n\n***Time Complexity***: Each element will have two options. Either it's chosen, or it's not. So, the time complexity will be $O(2^n)$ in the worst case for sorted arrays where all the elements are considered. Most of the time it will be less than that as we get to prune early"
                    },
                    {
                        "username": "djslim",
                        "content": "Most people including top competitors solved with set , so I guess it' ok to use it"
                    },
                    {
                        "username": "uday000",
                        "content": "[@harsh_singgh](/harsh_singgh) really thankyou for the code brother"
                    },
                    {
                        "username": "uday000",
                        "content": "really thankyou [@Md Zarif Ul Alam](/zarif98sjs) for your thinking and it helped me a lot"
                    },
                    {
                        "username": "safinghoghabori65",
                        "content": "[@lotus18](/lotus18) Thank you so much for this solution. I was stuck in the loop of how to implement. "
                    },
                    {
                        "username": "lotus18",
                        "content": "Code For The Above Approach\n\n```\nclass Solution \n{\npublic:\n    vector<vector<int>> ans;\n    void f(vector<int>& nums, int x, vector<int> &v)\n    {\n        if(x==nums.size()) \n        {\n            if(v.size()>=2) ans.push_back(v);\n            return;\n        }\n        if(v.size()==0 || v.back()<=nums[x])\n        {\n            v.push_back(nums[x]);\n            f(nums,x+1,v);\n            v.pop_back();\n        }\n        if(v.size()!=0 && v.back()!=nums[x]) f(nums,x+1,v);\n        else if(v.size()==0) f(nums,x+1,v);\n        \n    }\n    vector<vector<int>> findSubsequences(vector<int>& nums) \n    {\n        vector<int> v;\n        f(nums,0,v);\n        return ans;\n    }\n};\n\n```"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "[@sanyamjain036](/sanyamjain036) \\n\\nThe idea is to create `New` HashMap in every new idx (recursive call)\\n\\nHope this code give you better insight, me myself just figure it out also when I tried switching language using golang , and sadly golang dont have generic type for set :( \\n\\nhttps://leetcode.com/problems/non-decreasing-subsequences/solutions/3077388/go-backtrack-trace-last-value/?orderBy=most_relevant"
                    },
                    {
                        "username": "hsnooob",
                        "content": "[@kerkathy](/kerkathy) Ooh Sorry about that. Check now."
                    },
                    {
                        "username": "Triquetra",
                        "content": "Various optimizations are pointless for exponential-time problems, in my opinion."
                    },
                    {
                        "username": "kerkathy",
                        "content": "[@harsh_singgh](/harsh_singgh) hi, this seems to be private, would you kindly open the code to public? :)"
                    },
                    {
                        "username": "hsnooob",
                        "content": "Nice idea, here is the implementation of it. https://leetcode.com/problems/non-decreasing-subsequences/solutions/3075983/avoid-duplicates-without-using-set/"
                    },
                    {
                        "username": "sanyamjain036",
                        "content": "Can you explain more in depth , how we can do it without using set?"
                    },
                    {
                        "username": "yadav0288",
                        "content": "[@shadab-malik](/shadab-malik)  For avoiding duplicates , we can use set because set ( set<vector<int>>ans; ) does not consider duplicates ans at the for returning ans convert set into vector example -> vector(ans.begin() , ans.end()) ;"
                    },
                    {
                        "username": "medmoe",
                        "content": "Thank you for the \" take and not take \" phrase that\\'s all what i needed"
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "Nice one"
                    },
                    {
                        "username": "shadab-malik",
                        "content": "[@hydra324](/hydra324) I\\'m still not getting how to avoid duplicates ? Can you explain it pls....\\n"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Does it work with test cases like this?\\n[1,2,5,3,5,4,5]\\nSeems that the last temporary answer array may be [1,3] or [1,4] when we want to avoid duplicates of [1, 5]?"
                    },
                    {
                        "username": "hydra324",
                        "content": "Nice observation! was sracthing my head on how to avoid duplicates without using hashsets."
                    },
                    {
                        "username": "danila_egorenko",
                        "content": "Array week is much better than graph week\\uD83D\\uDC40"
                    },
                    {
                        "username": "challengeHunter",
                        "content": "Easier one does\\'t mean better one........"
                    },
                    {
                        "username": "lineshmalkam",
                        "content": "arrayy weekk goesss brrrrrrrr............."
                    },
                    {
                        "username": "vivek271",
                        "content": "WA on testcase [1,2,3,4,5,6,7,8,9,10,1,1,1,1,1]\\n\\nOutput: https://pastebin.com/RpDxzRe4\\n\\nExpected: https://pastebin.com/wT6z01jw\\n"
                    },
                    {
                        "username": "1337beef",
                        "content": "I saw some answers which produce strictly increasing subsequences while the question now allows non-decreasing subsequences.\\n\\n"
                    },
                    {
                        "username": "RichardChe",
                        "content": "When I run my code(accepted) using [1,2,3,8,9,10,1,1,1,1,1] as test case, it doesn't match the given expected answer, but it's still accepted. Is anybody had the  same situation?"
                    },
                    {
                        "username": "scorpioneer",
                        "content": "[@gauraVSomani](/gauraVSomani) I was facing the same issue . Try to shift the pop statement inside the pick (take it ) if block because if the pop statement is present outside the if block then it will introduce the duplicates which eventually gives wrong answer . I hope it will work for you too :)  "
                    },
                    {
                        "username": "gauraVSomani",
                        "content": "My solution is not being accepted for the same. I can\\'t figure out what I am doing wrong."
                    },
                    {
                        "username": "harshpratap1601",
                        "content": "same issue"
                    },
                    {
                        "username": "abrahem",
                        "content": "read the question carefully \"You may return the answer in any order\""
                    },
                    {
                        "username": "cenjian",
                        "content": " the expect output of the case [1,2,3,4,5,6,7,8,9,10,1,1,1,1,1] doesn\\'t include [1, 1, 1], [1,1] and so on. While according to the description, they are valid subsequences. Please fix this, my dear Leetcode. "
                    },
                    {
                        "username": "the_leetcode_guy",
                        "content": "Explanatory video: https://youtu.be/UX7cY8RvDWw"
                    },
                    {
                        "username": "maltarouti",
                        "content": "This is a discussion tab: \"Please don\\'t post any solutions in this discussion tab.\""
                    },
                    {
                        "username": "rajan_jasani9",
                        "content": "Great Explanation!"
                    },
                    {
                        "username": "sudhakargoutam",
                        "content": "DP Week is coming guys.get ready :( "
                    },
                    {
                        "username": "Sidd26",
                        "content": "Is the runtime of this is at best exponential using backtracking?"
                    },
                    {
                        "username": "devvartkumarkumar",
                        "content": "++?"
                    }
                ]
            },
            {
                "id": 1766899,
                "content": [
                    {
                        "username": "zarif98sjs",
                        "content": "The problem can be solved just by thinking it as a \"take - don't take recursion\". Furthermore, **we can avoid using `set`** to track duplicates by checking just one case. \nFirst, we take the element and do backtrack. Before going to the \"don't take\" case, we can make a simple ***check if the current number is equal to the last number of our temporary answer array***. If that is the case, we will get repeated answers if we go down this path. So, we don't recurse down if that is the case. \n\n***Time Complexity***: Each element will have two options. Either it's chosen, or it's not. So, the time complexity will be $O(2^n)$ in the worst case for sorted arrays where all the elements are considered. Most of the time it will be less than that as we get to prune early"
                    },
                    {
                        "username": "djslim",
                        "content": "Most people including top competitors solved with set , so I guess it' ok to use it"
                    },
                    {
                        "username": "uday000",
                        "content": "[@harsh_singgh](/harsh_singgh) really thankyou for the code brother"
                    },
                    {
                        "username": "uday000",
                        "content": "really thankyou [@Md Zarif Ul Alam](/zarif98sjs) for your thinking and it helped me a lot"
                    },
                    {
                        "username": "safinghoghabori65",
                        "content": "[@lotus18](/lotus18) Thank you so much for this solution. I was stuck in the loop of how to implement. "
                    },
                    {
                        "username": "lotus18",
                        "content": "Code For The Above Approach\n\n```\nclass Solution \n{\npublic:\n    vector<vector<int>> ans;\n    void f(vector<int>& nums, int x, vector<int> &v)\n    {\n        if(x==nums.size()) \n        {\n            if(v.size()>=2) ans.push_back(v);\n            return;\n        }\n        if(v.size()==0 || v.back()<=nums[x])\n        {\n            v.push_back(nums[x]);\n            f(nums,x+1,v);\n            v.pop_back();\n        }\n        if(v.size()!=0 && v.back()!=nums[x]) f(nums,x+1,v);\n        else if(v.size()==0) f(nums,x+1,v);\n        \n    }\n    vector<vector<int>> findSubsequences(vector<int>& nums) \n    {\n        vector<int> v;\n        f(nums,0,v);\n        return ans;\n    }\n};\n\n```"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "[@sanyamjain036](/sanyamjain036) \\n\\nThe idea is to create `New` HashMap in every new idx (recursive call)\\n\\nHope this code give you better insight, me myself just figure it out also when I tried switching language using golang , and sadly golang dont have generic type for set :( \\n\\nhttps://leetcode.com/problems/non-decreasing-subsequences/solutions/3077388/go-backtrack-trace-last-value/?orderBy=most_relevant"
                    },
                    {
                        "username": "hsnooob",
                        "content": "[@kerkathy](/kerkathy) Ooh Sorry about that. Check now."
                    },
                    {
                        "username": "Triquetra",
                        "content": "Various optimizations are pointless for exponential-time problems, in my opinion."
                    },
                    {
                        "username": "kerkathy",
                        "content": "[@harsh_singgh](/harsh_singgh) hi, this seems to be private, would you kindly open the code to public? :)"
                    },
                    {
                        "username": "hsnooob",
                        "content": "Nice idea, here is the implementation of it. https://leetcode.com/problems/non-decreasing-subsequences/solutions/3075983/avoid-duplicates-without-using-set/"
                    },
                    {
                        "username": "sanyamjain036",
                        "content": "Can you explain more in depth , how we can do it without using set?"
                    },
                    {
                        "username": "yadav0288",
                        "content": "[@shadab-malik](/shadab-malik)  For avoiding duplicates , we can use set because set ( set<vector<int>>ans; ) does not consider duplicates ans at the for returning ans convert set into vector example -> vector(ans.begin() , ans.end()) ;"
                    },
                    {
                        "username": "medmoe",
                        "content": "Thank you for the \" take and not take \" phrase that\\'s all what i needed"
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "Nice one"
                    },
                    {
                        "username": "shadab-malik",
                        "content": "[@hydra324](/hydra324) I\\'m still not getting how to avoid duplicates ? Can you explain it pls....\\n"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Does it work with test cases like this?\\n[1,2,5,3,5,4,5]\\nSeems that the last temporary answer array may be [1,3] or [1,4] when we want to avoid duplicates of [1, 5]?"
                    },
                    {
                        "username": "hydra324",
                        "content": "Nice observation! was sracthing my head on how to avoid duplicates without using hashsets."
                    },
                    {
                        "username": "danila_egorenko",
                        "content": "Array week is much better than graph week\\uD83D\\uDC40"
                    },
                    {
                        "username": "challengeHunter",
                        "content": "Easier one does\\'t mean better one........"
                    },
                    {
                        "username": "lineshmalkam",
                        "content": "arrayy weekk goesss brrrrrrrr............."
                    },
                    {
                        "username": "vivek271",
                        "content": "WA on testcase [1,2,3,4,5,6,7,8,9,10,1,1,1,1,1]\\n\\nOutput: https://pastebin.com/RpDxzRe4\\n\\nExpected: https://pastebin.com/wT6z01jw\\n"
                    },
                    {
                        "username": "1337beef",
                        "content": "I saw some answers which produce strictly increasing subsequences while the question now allows non-decreasing subsequences.\\n\\n"
                    },
                    {
                        "username": "RichardChe",
                        "content": "When I run my code(accepted) using [1,2,3,8,9,10,1,1,1,1,1] as test case, it doesn't match the given expected answer, but it's still accepted. Is anybody had the  same situation?"
                    },
                    {
                        "username": "scorpioneer",
                        "content": "[@gauraVSomani](/gauraVSomani) I was facing the same issue . Try to shift the pop statement inside the pick (take it ) if block because if the pop statement is present outside the if block then it will introduce the duplicates which eventually gives wrong answer . I hope it will work for you too :)  "
                    },
                    {
                        "username": "gauraVSomani",
                        "content": "My solution is not being accepted for the same. I can\\'t figure out what I am doing wrong."
                    },
                    {
                        "username": "harshpratap1601",
                        "content": "same issue"
                    },
                    {
                        "username": "abrahem",
                        "content": "read the question carefully \"You may return the answer in any order\""
                    },
                    {
                        "username": "cenjian",
                        "content": " the expect output of the case [1,2,3,4,5,6,7,8,9,10,1,1,1,1,1] doesn\\'t include [1, 1, 1], [1,1] and so on. While according to the description, they are valid subsequences. Please fix this, my dear Leetcode. "
                    },
                    {
                        "username": "the_leetcode_guy",
                        "content": "Explanatory video: https://youtu.be/UX7cY8RvDWw"
                    },
                    {
                        "username": "maltarouti",
                        "content": "This is a discussion tab: \"Please don\\'t post any solutions in this discussion tab.\""
                    },
                    {
                        "username": "rajan_jasani9",
                        "content": "Great Explanation!"
                    },
                    {
                        "username": "sudhakargoutam",
                        "content": "DP Week is coming guys.get ready :( "
                    },
                    {
                        "username": "Sidd26",
                        "content": "Is the runtime of this is at best exponential using backtracking?"
                    },
                    {
                        "username": "devvartkumarkumar",
                        "content": "++?"
                    }
                ]
            },
            {
                "id": 1573441,
                "content": [
                    {
                        "username": "zarif98sjs",
                        "content": "The problem can be solved just by thinking it as a \"take - don't take recursion\". Furthermore, **we can avoid using `set`** to track duplicates by checking just one case. \nFirst, we take the element and do backtrack. Before going to the \"don't take\" case, we can make a simple ***check if the current number is equal to the last number of our temporary answer array***. If that is the case, we will get repeated answers if we go down this path. So, we don't recurse down if that is the case. \n\n***Time Complexity***: Each element will have two options. Either it's chosen, or it's not. So, the time complexity will be $O(2^n)$ in the worst case for sorted arrays where all the elements are considered. Most of the time it will be less than that as we get to prune early"
                    },
                    {
                        "username": "djslim",
                        "content": "Most people including top competitors solved with set , so I guess it' ok to use it"
                    },
                    {
                        "username": "uday000",
                        "content": "[@harsh_singgh](/harsh_singgh) really thankyou for the code brother"
                    },
                    {
                        "username": "uday000",
                        "content": "really thankyou [@Md Zarif Ul Alam](/zarif98sjs) for your thinking and it helped me a lot"
                    },
                    {
                        "username": "safinghoghabori65",
                        "content": "[@lotus18](/lotus18) Thank you so much for this solution. I was stuck in the loop of how to implement. "
                    },
                    {
                        "username": "lotus18",
                        "content": "Code For The Above Approach\n\n```\nclass Solution \n{\npublic:\n    vector<vector<int>> ans;\n    void f(vector<int>& nums, int x, vector<int> &v)\n    {\n        if(x==nums.size()) \n        {\n            if(v.size()>=2) ans.push_back(v);\n            return;\n        }\n        if(v.size()==0 || v.back()<=nums[x])\n        {\n            v.push_back(nums[x]);\n            f(nums,x+1,v);\n            v.pop_back();\n        }\n        if(v.size()!=0 && v.back()!=nums[x]) f(nums,x+1,v);\n        else if(v.size()==0) f(nums,x+1,v);\n        \n    }\n    vector<vector<int>> findSubsequences(vector<int>& nums) \n    {\n        vector<int> v;\n        f(nums,0,v);\n        return ans;\n    }\n};\n\n```"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "[@sanyamjain036](/sanyamjain036) \\n\\nThe idea is to create `New` HashMap in every new idx (recursive call)\\n\\nHope this code give you better insight, me myself just figure it out also when I tried switching language using golang , and sadly golang dont have generic type for set :( \\n\\nhttps://leetcode.com/problems/non-decreasing-subsequences/solutions/3077388/go-backtrack-trace-last-value/?orderBy=most_relevant"
                    },
                    {
                        "username": "hsnooob",
                        "content": "[@kerkathy](/kerkathy) Ooh Sorry about that. Check now."
                    },
                    {
                        "username": "Triquetra",
                        "content": "Various optimizations are pointless for exponential-time problems, in my opinion."
                    },
                    {
                        "username": "kerkathy",
                        "content": "[@harsh_singgh](/harsh_singgh) hi, this seems to be private, would you kindly open the code to public? :)"
                    },
                    {
                        "username": "hsnooob",
                        "content": "Nice idea, here is the implementation of it. https://leetcode.com/problems/non-decreasing-subsequences/solutions/3075983/avoid-duplicates-without-using-set/"
                    },
                    {
                        "username": "sanyamjain036",
                        "content": "Can you explain more in depth , how we can do it without using set?"
                    },
                    {
                        "username": "yadav0288",
                        "content": "[@shadab-malik](/shadab-malik)  For avoiding duplicates , we can use set because set ( set<vector<int>>ans; ) does not consider duplicates ans at the for returning ans convert set into vector example -> vector(ans.begin() , ans.end()) ;"
                    },
                    {
                        "username": "medmoe",
                        "content": "Thank you for the \" take and not take \" phrase that\\'s all what i needed"
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "Nice one"
                    },
                    {
                        "username": "shadab-malik",
                        "content": "[@hydra324](/hydra324) I\\'m still not getting how to avoid duplicates ? Can you explain it pls....\\n"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Does it work with test cases like this?\\n[1,2,5,3,5,4,5]\\nSeems that the last temporary answer array may be [1,3] or [1,4] when we want to avoid duplicates of [1, 5]?"
                    },
                    {
                        "username": "hydra324",
                        "content": "Nice observation! was sracthing my head on how to avoid duplicates without using hashsets."
                    },
                    {
                        "username": "danila_egorenko",
                        "content": "Array week is much better than graph week\\uD83D\\uDC40"
                    },
                    {
                        "username": "challengeHunter",
                        "content": "Easier one does\\'t mean better one........"
                    },
                    {
                        "username": "lineshmalkam",
                        "content": "arrayy weekk goesss brrrrrrrr............."
                    },
                    {
                        "username": "vivek271",
                        "content": "WA on testcase [1,2,3,4,5,6,7,8,9,10,1,1,1,1,1]\\n\\nOutput: https://pastebin.com/RpDxzRe4\\n\\nExpected: https://pastebin.com/wT6z01jw\\n"
                    },
                    {
                        "username": "1337beef",
                        "content": "I saw some answers which produce strictly increasing subsequences while the question now allows non-decreasing subsequences.\\n\\n"
                    },
                    {
                        "username": "RichardChe",
                        "content": "When I run my code(accepted) using [1,2,3,8,9,10,1,1,1,1,1] as test case, it doesn't match the given expected answer, but it's still accepted. Is anybody had the  same situation?"
                    },
                    {
                        "username": "scorpioneer",
                        "content": "[@gauraVSomani](/gauraVSomani) I was facing the same issue . Try to shift the pop statement inside the pick (take it ) if block because if the pop statement is present outside the if block then it will introduce the duplicates which eventually gives wrong answer . I hope it will work for you too :)  "
                    },
                    {
                        "username": "gauraVSomani",
                        "content": "My solution is not being accepted for the same. I can\\'t figure out what I am doing wrong."
                    },
                    {
                        "username": "harshpratap1601",
                        "content": "same issue"
                    },
                    {
                        "username": "abrahem",
                        "content": "read the question carefully \"You may return the answer in any order\""
                    },
                    {
                        "username": "cenjian",
                        "content": " the expect output of the case [1,2,3,4,5,6,7,8,9,10,1,1,1,1,1] doesn\\'t include [1, 1, 1], [1,1] and so on. While according to the description, they are valid subsequences. Please fix this, my dear Leetcode. "
                    },
                    {
                        "username": "the_leetcode_guy",
                        "content": "Explanatory video: https://youtu.be/UX7cY8RvDWw"
                    },
                    {
                        "username": "maltarouti",
                        "content": "This is a discussion tab: \"Please don\\'t post any solutions in this discussion tab.\""
                    },
                    {
                        "username": "rajan_jasani9",
                        "content": "Great Explanation!"
                    },
                    {
                        "username": "sudhakargoutam",
                        "content": "DP Week is coming guys.get ready :( "
                    },
                    {
                        "username": "Sidd26",
                        "content": "Is the runtime of this is at best exponential using backtracking?"
                    },
                    {
                        "username": "devvartkumarkumar",
                        "content": "++?"
                    }
                ]
            },
            {
                "id": 1571748,
                "content": [
                    {
                        "username": "zarif98sjs",
                        "content": "The problem can be solved just by thinking it as a \"take - don't take recursion\". Furthermore, **we can avoid using `set`** to track duplicates by checking just one case. \nFirst, we take the element and do backtrack. Before going to the \"don't take\" case, we can make a simple ***check if the current number is equal to the last number of our temporary answer array***. If that is the case, we will get repeated answers if we go down this path. So, we don't recurse down if that is the case. \n\n***Time Complexity***: Each element will have two options. Either it's chosen, or it's not. So, the time complexity will be $O(2^n)$ in the worst case for sorted arrays where all the elements are considered. Most of the time it will be less than that as we get to prune early"
                    },
                    {
                        "username": "djslim",
                        "content": "Most people including top competitors solved with set , so I guess it' ok to use it"
                    },
                    {
                        "username": "uday000",
                        "content": "[@harsh_singgh](/harsh_singgh) really thankyou for the code brother"
                    },
                    {
                        "username": "uday000",
                        "content": "really thankyou [@Md Zarif Ul Alam](/zarif98sjs) for your thinking and it helped me a lot"
                    },
                    {
                        "username": "safinghoghabori65",
                        "content": "[@lotus18](/lotus18) Thank you so much for this solution. I was stuck in the loop of how to implement. "
                    },
                    {
                        "username": "lotus18",
                        "content": "Code For The Above Approach\n\n```\nclass Solution \n{\npublic:\n    vector<vector<int>> ans;\n    void f(vector<int>& nums, int x, vector<int> &v)\n    {\n        if(x==nums.size()) \n        {\n            if(v.size()>=2) ans.push_back(v);\n            return;\n        }\n        if(v.size()==0 || v.back()<=nums[x])\n        {\n            v.push_back(nums[x]);\n            f(nums,x+1,v);\n            v.pop_back();\n        }\n        if(v.size()!=0 && v.back()!=nums[x]) f(nums,x+1,v);\n        else if(v.size()==0) f(nums,x+1,v);\n        \n    }\n    vector<vector<int>> findSubsequences(vector<int>& nums) \n    {\n        vector<int> v;\n        f(nums,0,v);\n        return ans;\n    }\n};\n\n```"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "[@sanyamjain036](/sanyamjain036) \\n\\nThe idea is to create `New` HashMap in every new idx (recursive call)\\n\\nHope this code give you better insight, me myself just figure it out also when I tried switching language using golang , and sadly golang dont have generic type for set :( \\n\\nhttps://leetcode.com/problems/non-decreasing-subsequences/solutions/3077388/go-backtrack-trace-last-value/?orderBy=most_relevant"
                    },
                    {
                        "username": "hsnooob",
                        "content": "[@kerkathy](/kerkathy) Ooh Sorry about that. Check now."
                    },
                    {
                        "username": "Triquetra",
                        "content": "Various optimizations are pointless for exponential-time problems, in my opinion."
                    },
                    {
                        "username": "kerkathy",
                        "content": "[@harsh_singgh](/harsh_singgh) hi, this seems to be private, would you kindly open the code to public? :)"
                    },
                    {
                        "username": "hsnooob",
                        "content": "Nice idea, here is the implementation of it. https://leetcode.com/problems/non-decreasing-subsequences/solutions/3075983/avoid-duplicates-without-using-set/"
                    },
                    {
                        "username": "sanyamjain036",
                        "content": "Can you explain more in depth , how we can do it without using set?"
                    },
                    {
                        "username": "yadav0288",
                        "content": "[@shadab-malik](/shadab-malik)  For avoiding duplicates , we can use set because set ( set<vector<int>>ans; ) does not consider duplicates ans at the for returning ans convert set into vector example -> vector(ans.begin() , ans.end()) ;"
                    },
                    {
                        "username": "medmoe",
                        "content": "Thank you for the \" take and not take \" phrase that\\'s all what i needed"
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "Nice one"
                    },
                    {
                        "username": "shadab-malik",
                        "content": "[@hydra324](/hydra324) I\\'m still not getting how to avoid duplicates ? Can you explain it pls....\\n"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Does it work with test cases like this?\\n[1,2,5,3,5,4,5]\\nSeems that the last temporary answer array may be [1,3] or [1,4] when we want to avoid duplicates of [1, 5]?"
                    },
                    {
                        "username": "hydra324",
                        "content": "Nice observation! was sracthing my head on how to avoid duplicates without using hashsets."
                    },
                    {
                        "username": "danila_egorenko",
                        "content": "Array week is much better than graph week\\uD83D\\uDC40"
                    },
                    {
                        "username": "challengeHunter",
                        "content": "Easier one does\\'t mean better one........"
                    },
                    {
                        "username": "lineshmalkam",
                        "content": "arrayy weekk goesss brrrrrrrr............."
                    },
                    {
                        "username": "vivek271",
                        "content": "WA on testcase [1,2,3,4,5,6,7,8,9,10,1,1,1,1,1]\\n\\nOutput: https://pastebin.com/RpDxzRe4\\n\\nExpected: https://pastebin.com/wT6z01jw\\n"
                    },
                    {
                        "username": "1337beef",
                        "content": "I saw some answers which produce strictly increasing subsequences while the question now allows non-decreasing subsequences.\\n\\n"
                    },
                    {
                        "username": "RichardChe",
                        "content": "When I run my code(accepted) using [1,2,3,8,9,10,1,1,1,1,1] as test case, it doesn't match the given expected answer, but it's still accepted. Is anybody had the  same situation?"
                    },
                    {
                        "username": "scorpioneer",
                        "content": "[@gauraVSomani](/gauraVSomani) I was facing the same issue . Try to shift the pop statement inside the pick (take it ) if block because if the pop statement is present outside the if block then it will introduce the duplicates which eventually gives wrong answer . I hope it will work for you too :)  "
                    },
                    {
                        "username": "gauraVSomani",
                        "content": "My solution is not being accepted for the same. I can\\'t figure out what I am doing wrong."
                    },
                    {
                        "username": "harshpratap1601",
                        "content": "same issue"
                    },
                    {
                        "username": "abrahem",
                        "content": "read the question carefully \"You may return the answer in any order\""
                    },
                    {
                        "username": "cenjian",
                        "content": " the expect output of the case [1,2,3,4,5,6,7,8,9,10,1,1,1,1,1] doesn\\'t include [1, 1, 1], [1,1] and so on. While according to the description, they are valid subsequences. Please fix this, my dear Leetcode. "
                    },
                    {
                        "username": "the_leetcode_guy",
                        "content": "Explanatory video: https://youtu.be/UX7cY8RvDWw"
                    },
                    {
                        "username": "maltarouti",
                        "content": "This is a discussion tab: \"Please don\\'t post any solutions in this discussion tab.\""
                    },
                    {
                        "username": "rajan_jasani9",
                        "content": "Great Explanation!"
                    },
                    {
                        "username": "sudhakargoutam",
                        "content": "DP Week is coming guys.get ready :( "
                    },
                    {
                        "username": "Sidd26",
                        "content": "Is the runtime of this is at best exponential using backtracking?"
                    },
                    {
                        "username": "devvartkumarkumar",
                        "content": "++?"
                    }
                ]
            },
            {
                "id": 1855577,
                "content": [
                    {
                        "username": "zarif98sjs",
                        "content": "The problem can be solved just by thinking it as a \"take - don't take recursion\". Furthermore, **we can avoid using `set`** to track duplicates by checking just one case. \nFirst, we take the element and do backtrack. Before going to the \"don't take\" case, we can make a simple ***check if the current number is equal to the last number of our temporary answer array***. If that is the case, we will get repeated answers if we go down this path. So, we don't recurse down if that is the case. \n\n***Time Complexity***: Each element will have two options. Either it's chosen, or it's not. So, the time complexity will be $O(2^n)$ in the worst case for sorted arrays where all the elements are considered. Most of the time it will be less than that as we get to prune early"
                    },
                    {
                        "username": "djslim",
                        "content": "Most people including top competitors solved with set , so I guess it' ok to use it"
                    },
                    {
                        "username": "uday000",
                        "content": "[@harsh_singgh](/harsh_singgh) really thankyou for the code brother"
                    },
                    {
                        "username": "uday000",
                        "content": "really thankyou [@Md Zarif Ul Alam](/zarif98sjs) for your thinking and it helped me a lot"
                    },
                    {
                        "username": "safinghoghabori65",
                        "content": "[@lotus18](/lotus18) Thank you so much for this solution. I was stuck in the loop of how to implement. "
                    },
                    {
                        "username": "lotus18",
                        "content": "Code For The Above Approach\n\n```\nclass Solution \n{\npublic:\n    vector<vector<int>> ans;\n    void f(vector<int>& nums, int x, vector<int> &v)\n    {\n        if(x==nums.size()) \n        {\n            if(v.size()>=2) ans.push_back(v);\n            return;\n        }\n        if(v.size()==0 || v.back()<=nums[x])\n        {\n            v.push_back(nums[x]);\n            f(nums,x+1,v);\n            v.pop_back();\n        }\n        if(v.size()!=0 && v.back()!=nums[x]) f(nums,x+1,v);\n        else if(v.size()==0) f(nums,x+1,v);\n        \n    }\n    vector<vector<int>> findSubsequences(vector<int>& nums) \n    {\n        vector<int> v;\n        f(nums,0,v);\n        return ans;\n    }\n};\n\n```"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "[@sanyamjain036](/sanyamjain036) \\n\\nThe idea is to create `New` HashMap in every new idx (recursive call)\\n\\nHope this code give you better insight, me myself just figure it out also when I tried switching language using golang , and sadly golang dont have generic type for set :( \\n\\nhttps://leetcode.com/problems/non-decreasing-subsequences/solutions/3077388/go-backtrack-trace-last-value/?orderBy=most_relevant"
                    },
                    {
                        "username": "hsnooob",
                        "content": "[@kerkathy](/kerkathy) Ooh Sorry about that. Check now."
                    },
                    {
                        "username": "Triquetra",
                        "content": "Various optimizations are pointless for exponential-time problems, in my opinion."
                    },
                    {
                        "username": "kerkathy",
                        "content": "[@harsh_singgh](/harsh_singgh) hi, this seems to be private, would you kindly open the code to public? :)"
                    },
                    {
                        "username": "hsnooob",
                        "content": "Nice idea, here is the implementation of it. https://leetcode.com/problems/non-decreasing-subsequences/solutions/3075983/avoid-duplicates-without-using-set/"
                    },
                    {
                        "username": "sanyamjain036",
                        "content": "Can you explain more in depth , how we can do it without using set?"
                    },
                    {
                        "username": "yadav0288",
                        "content": "[@shadab-malik](/shadab-malik)  For avoiding duplicates , we can use set because set ( set<vector<int>>ans; ) does not consider duplicates ans at the for returning ans convert set into vector example -> vector(ans.begin() , ans.end()) ;"
                    },
                    {
                        "username": "medmoe",
                        "content": "Thank you for the \" take and not take \" phrase that\\'s all what i needed"
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "Nice one"
                    },
                    {
                        "username": "shadab-malik",
                        "content": "[@hydra324](/hydra324) I\\'m still not getting how to avoid duplicates ? Can you explain it pls....\\n"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Does it work with test cases like this?\\n[1,2,5,3,5,4,5]\\nSeems that the last temporary answer array may be [1,3] or [1,4] when we want to avoid duplicates of [1, 5]?"
                    },
                    {
                        "username": "hydra324",
                        "content": "Nice observation! was sracthing my head on how to avoid duplicates without using hashsets."
                    },
                    {
                        "username": "danila_egorenko",
                        "content": "Array week is much better than graph week\\uD83D\\uDC40"
                    },
                    {
                        "username": "challengeHunter",
                        "content": "Easier one does\\'t mean better one........"
                    },
                    {
                        "username": "lineshmalkam",
                        "content": "arrayy weekk goesss brrrrrrrr............."
                    },
                    {
                        "username": "vivek271",
                        "content": "WA on testcase [1,2,3,4,5,6,7,8,9,10,1,1,1,1,1]\\n\\nOutput: https://pastebin.com/RpDxzRe4\\n\\nExpected: https://pastebin.com/wT6z01jw\\n"
                    },
                    {
                        "username": "1337beef",
                        "content": "I saw some answers which produce strictly increasing subsequences while the question now allows non-decreasing subsequences.\\n\\n"
                    },
                    {
                        "username": "RichardChe",
                        "content": "When I run my code(accepted) using [1,2,3,8,9,10,1,1,1,1,1] as test case, it doesn't match the given expected answer, but it's still accepted. Is anybody had the  same situation?"
                    },
                    {
                        "username": "scorpioneer",
                        "content": "[@gauraVSomani](/gauraVSomani) I was facing the same issue . Try to shift the pop statement inside the pick (take it ) if block because if the pop statement is present outside the if block then it will introduce the duplicates which eventually gives wrong answer . I hope it will work for you too :)  "
                    },
                    {
                        "username": "gauraVSomani",
                        "content": "My solution is not being accepted for the same. I can\\'t figure out what I am doing wrong."
                    },
                    {
                        "username": "harshpratap1601",
                        "content": "same issue"
                    },
                    {
                        "username": "abrahem",
                        "content": "read the question carefully \"You may return the answer in any order\""
                    },
                    {
                        "username": "cenjian",
                        "content": " the expect output of the case [1,2,3,4,5,6,7,8,9,10,1,1,1,1,1] doesn\\'t include [1, 1, 1], [1,1] and so on. While according to the description, they are valid subsequences. Please fix this, my dear Leetcode. "
                    },
                    {
                        "username": "the_leetcode_guy",
                        "content": "Explanatory video: https://youtu.be/UX7cY8RvDWw"
                    },
                    {
                        "username": "maltarouti",
                        "content": "This is a discussion tab: \"Please don\\'t post any solutions in this discussion tab.\""
                    },
                    {
                        "username": "rajan_jasani9",
                        "content": "Great Explanation!"
                    },
                    {
                        "username": "sudhakargoutam",
                        "content": "DP Week is coming guys.get ready :( "
                    },
                    {
                        "username": "Sidd26",
                        "content": "Is the runtime of this is at best exponential using backtracking?"
                    },
                    {
                        "username": "devvartkumarkumar",
                        "content": "++?"
                    }
                ]
            },
            {
                "id": 1765903,
                "content": [
                    {
                        "username": "zarif98sjs",
                        "content": "The problem can be solved just by thinking it as a \"take - don't take recursion\". Furthermore, **we can avoid using `set`** to track duplicates by checking just one case. \nFirst, we take the element and do backtrack. Before going to the \"don't take\" case, we can make a simple ***check if the current number is equal to the last number of our temporary answer array***. If that is the case, we will get repeated answers if we go down this path. So, we don't recurse down if that is the case. \n\n***Time Complexity***: Each element will have two options. Either it's chosen, or it's not. So, the time complexity will be $O(2^n)$ in the worst case for sorted arrays where all the elements are considered. Most of the time it will be less than that as we get to prune early"
                    },
                    {
                        "username": "djslim",
                        "content": "Most people including top competitors solved with set , so I guess it' ok to use it"
                    },
                    {
                        "username": "uday000",
                        "content": "[@harsh_singgh](/harsh_singgh) really thankyou for the code brother"
                    },
                    {
                        "username": "uday000",
                        "content": "really thankyou [@Md Zarif Ul Alam](/zarif98sjs) for your thinking and it helped me a lot"
                    },
                    {
                        "username": "safinghoghabori65",
                        "content": "[@lotus18](/lotus18) Thank you so much for this solution. I was stuck in the loop of how to implement. "
                    },
                    {
                        "username": "lotus18",
                        "content": "Code For The Above Approach\n\n```\nclass Solution \n{\npublic:\n    vector<vector<int>> ans;\n    void f(vector<int>& nums, int x, vector<int> &v)\n    {\n        if(x==nums.size()) \n        {\n            if(v.size()>=2) ans.push_back(v);\n            return;\n        }\n        if(v.size()==0 || v.back()<=nums[x])\n        {\n            v.push_back(nums[x]);\n            f(nums,x+1,v);\n            v.pop_back();\n        }\n        if(v.size()!=0 && v.back()!=nums[x]) f(nums,x+1,v);\n        else if(v.size()==0) f(nums,x+1,v);\n        \n    }\n    vector<vector<int>> findSubsequences(vector<int>& nums) \n    {\n        vector<int> v;\n        f(nums,0,v);\n        return ans;\n    }\n};\n\n```"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "[@sanyamjain036](/sanyamjain036) \\n\\nThe idea is to create `New` HashMap in every new idx (recursive call)\\n\\nHope this code give you better insight, me myself just figure it out also when I tried switching language using golang , and sadly golang dont have generic type for set :( \\n\\nhttps://leetcode.com/problems/non-decreasing-subsequences/solutions/3077388/go-backtrack-trace-last-value/?orderBy=most_relevant"
                    },
                    {
                        "username": "hsnooob",
                        "content": "[@kerkathy](/kerkathy) Ooh Sorry about that. Check now."
                    },
                    {
                        "username": "Triquetra",
                        "content": "Various optimizations are pointless for exponential-time problems, in my opinion."
                    },
                    {
                        "username": "kerkathy",
                        "content": "[@harsh_singgh](/harsh_singgh) hi, this seems to be private, would you kindly open the code to public? :)"
                    },
                    {
                        "username": "hsnooob",
                        "content": "Nice idea, here is the implementation of it. https://leetcode.com/problems/non-decreasing-subsequences/solutions/3075983/avoid-duplicates-without-using-set/"
                    },
                    {
                        "username": "sanyamjain036",
                        "content": "Can you explain more in depth , how we can do it without using set?"
                    },
                    {
                        "username": "yadav0288",
                        "content": "[@shadab-malik](/shadab-malik)  For avoiding duplicates , we can use set because set ( set<vector<int>>ans; ) does not consider duplicates ans at the for returning ans convert set into vector example -> vector(ans.begin() , ans.end()) ;"
                    },
                    {
                        "username": "medmoe",
                        "content": "Thank you for the \" take and not take \" phrase that\\'s all what i needed"
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "Nice one"
                    },
                    {
                        "username": "shadab-malik",
                        "content": "[@hydra324](/hydra324) I\\'m still not getting how to avoid duplicates ? Can you explain it pls....\\n"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Does it work with test cases like this?\\n[1,2,5,3,5,4,5]\\nSeems that the last temporary answer array may be [1,3] or [1,4] when we want to avoid duplicates of [1, 5]?"
                    },
                    {
                        "username": "hydra324",
                        "content": "Nice observation! was sracthing my head on how to avoid duplicates without using hashsets."
                    },
                    {
                        "username": "danila_egorenko",
                        "content": "Array week is much better than graph week\\uD83D\\uDC40"
                    },
                    {
                        "username": "challengeHunter",
                        "content": "Easier one does\\'t mean better one........"
                    },
                    {
                        "username": "lineshmalkam",
                        "content": "arrayy weekk goesss brrrrrrrr............."
                    },
                    {
                        "username": "vivek271",
                        "content": "WA on testcase [1,2,3,4,5,6,7,8,9,10,1,1,1,1,1]\\n\\nOutput: https://pastebin.com/RpDxzRe4\\n\\nExpected: https://pastebin.com/wT6z01jw\\n"
                    },
                    {
                        "username": "1337beef",
                        "content": "I saw some answers which produce strictly increasing subsequences while the question now allows non-decreasing subsequences.\\n\\n"
                    },
                    {
                        "username": "RichardChe",
                        "content": "When I run my code(accepted) using [1,2,3,8,9,10,1,1,1,1,1] as test case, it doesn't match the given expected answer, but it's still accepted. Is anybody had the  same situation?"
                    },
                    {
                        "username": "scorpioneer",
                        "content": "[@gauraVSomani](/gauraVSomani) I was facing the same issue . Try to shift the pop statement inside the pick (take it ) if block because if the pop statement is present outside the if block then it will introduce the duplicates which eventually gives wrong answer . I hope it will work for you too :)  "
                    },
                    {
                        "username": "gauraVSomani",
                        "content": "My solution is not being accepted for the same. I can\\'t figure out what I am doing wrong."
                    },
                    {
                        "username": "harshpratap1601",
                        "content": "same issue"
                    },
                    {
                        "username": "abrahem",
                        "content": "read the question carefully \"You may return the answer in any order\""
                    },
                    {
                        "username": "cenjian",
                        "content": " the expect output of the case [1,2,3,4,5,6,7,8,9,10,1,1,1,1,1] doesn\\'t include [1, 1, 1], [1,1] and so on. While according to the description, they are valid subsequences. Please fix this, my dear Leetcode. "
                    },
                    {
                        "username": "the_leetcode_guy",
                        "content": "Explanatory video: https://youtu.be/UX7cY8RvDWw"
                    },
                    {
                        "username": "maltarouti",
                        "content": "This is a discussion tab: \"Please don\\'t post any solutions in this discussion tab.\""
                    },
                    {
                        "username": "rajan_jasani9",
                        "content": "Great Explanation!"
                    },
                    {
                        "username": "sudhakargoutam",
                        "content": "DP Week is coming guys.get ready :( "
                    },
                    {
                        "username": "Sidd26",
                        "content": "Is the runtime of this is at best exponential using backtracking?"
                    },
                    {
                        "username": "devvartkumarkumar",
                        "content": "++?"
                    }
                ]
            },
            {
                "id": 1765678,
                "content": [
                    {
                        "username": "zarif98sjs",
                        "content": "The problem can be solved just by thinking it as a \"take - don't take recursion\". Furthermore, **we can avoid using `set`** to track duplicates by checking just one case. \nFirst, we take the element and do backtrack. Before going to the \"don't take\" case, we can make a simple ***check if the current number is equal to the last number of our temporary answer array***. If that is the case, we will get repeated answers if we go down this path. So, we don't recurse down if that is the case. \n\n***Time Complexity***: Each element will have two options. Either it's chosen, or it's not. So, the time complexity will be $O(2^n)$ in the worst case for sorted arrays where all the elements are considered. Most of the time it will be less than that as we get to prune early"
                    },
                    {
                        "username": "djslim",
                        "content": "Most people including top competitors solved with set , so I guess it' ok to use it"
                    },
                    {
                        "username": "uday000",
                        "content": "[@harsh_singgh](/harsh_singgh) really thankyou for the code brother"
                    },
                    {
                        "username": "uday000",
                        "content": "really thankyou [@Md Zarif Ul Alam](/zarif98sjs) for your thinking and it helped me a lot"
                    },
                    {
                        "username": "safinghoghabori65",
                        "content": "[@lotus18](/lotus18) Thank you so much for this solution. I was stuck in the loop of how to implement. "
                    },
                    {
                        "username": "lotus18",
                        "content": "Code For The Above Approach\n\n```\nclass Solution \n{\npublic:\n    vector<vector<int>> ans;\n    void f(vector<int>& nums, int x, vector<int> &v)\n    {\n        if(x==nums.size()) \n        {\n            if(v.size()>=2) ans.push_back(v);\n            return;\n        }\n        if(v.size()==0 || v.back()<=nums[x])\n        {\n            v.push_back(nums[x]);\n            f(nums,x+1,v);\n            v.pop_back();\n        }\n        if(v.size()!=0 && v.back()!=nums[x]) f(nums,x+1,v);\n        else if(v.size()==0) f(nums,x+1,v);\n        \n    }\n    vector<vector<int>> findSubsequences(vector<int>& nums) \n    {\n        vector<int> v;\n        f(nums,0,v);\n        return ans;\n    }\n};\n\n```"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "[@sanyamjain036](/sanyamjain036) \\n\\nThe idea is to create `New` HashMap in every new idx (recursive call)\\n\\nHope this code give you better insight, me myself just figure it out also when I tried switching language using golang , and sadly golang dont have generic type for set :( \\n\\nhttps://leetcode.com/problems/non-decreasing-subsequences/solutions/3077388/go-backtrack-trace-last-value/?orderBy=most_relevant"
                    },
                    {
                        "username": "hsnooob",
                        "content": "[@kerkathy](/kerkathy) Ooh Sorry about that. Check now."
                    },
                    {
                        "username": "Triquetra",
                        "content": "Various optimizations are pointless for exponential-time problems, in my opinion."
                    },
                    {
                        "username": "kerkathy",
                        "content": "[@harsh_singgh](/harsh_singgh) hi, this seems to be private, would you kindly open the code to public? :)"
                    },
                    {
                        "username": "hsnooob",
                        "content": "Nice idea, here is the implementation of it. https://leetcode.com/problems/non-decreasing-subsequences/solutions/3075983/avoid-duplicates-without-using-set/"
                    },
                    {
                        "username": "sanyamjain036",
                        "content": "Can you explain more in depth , how we can do it without using set?"
                    },
                    {
                        "username": "yadav0288",
                        "content": "[@shadab-malik](/shadab-malik)  For avoiding duplicates , we can use set because set ( set<vector<int>>ans; ) does not consider duplicates ans at the for returning ans convert set into vector example -> vector(ans.begin() , ans.end()) ;"
                    },
                    {
                        "username": "medmoe",
                        "content": "Thank you for the \" take and not take \" phrase that\\'s all what i needed"
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "Nice one"
                    },
                    {
                        "username": "shadab-malik",
                        "content": "[@hydra324](/hydra324) I\\'m still not getting how to avoid duplicates ? Can you explain it pls....\\n"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Does it work with test cases like this?\\n[1,2,5,3,5,4,5]\\nSeems that the last temporary answer array may be [1,3] or [1,4] when we want to avoid duplicates of [1, 5]?"
                    },
                    {
                        "username": "hydra324",
                        "content": "Nice observation! was sracthing my head on how to avoid duplicates without using hashsets."
                    },
                    {
                        "username": "danila_egorenko",
                        "content": "Array week is much better than graph week\\uD83D\\uDC40"
                    },
                    {
                        "username": "challengeHunter",
                        "content": "Easier one does\\'t mean better one........"
                    },
                    {
                        "username": "lineshmalkam",
                        "content": "arrayy weekk goesss brrrrrrrr............."
                    },
                    {
                        "username": "vivek271",
                        "content": "WA on testcase [1,2,3,4,5,6,7,8,9,10,1,1,1,1,1]\\n\\nOutput: https://pastebin.com/RpDxzRe4\\n\\nExpected: https://pastebin.com/wT6z01jw\\n"
                    },
                    {
                        "username": "1337beef",
                        "content": "I saw some answers which produce strictly increasing subsequences while the question now allows non-decreasing subsequences.\\n\\n"
                    },
                    {
                        "username": "RichardChe",
                        "content": "When I run my code(accepted) using [1,2,3,8,9,10,1,1,1,1,1] as test case, it doesn't match the given expected answer, but it's still accepted. Is anybody had the  same situation?"
                    },
                    {
                        "username": "scorpioneer",
                        "content": "[@gauraVSomani](/gauraVSomani) I was facing the same issue . Try to shift the pop statement inside the pick (take it ) if block because if the pop statement is present outside the if block then it will introduce the duplicates which eventually gives wrong answer . I hope it will work for you too :)  "
                    },
                    {
                        "username": "gauraVSomani",
                        "content": "My solution is not being accepted for the same. I can\\'t figure out what I am doing wrong."
                    },
                    {
                        "username": "harshpratap1601",
                        "content": "same issue"
                    },
                    {
                        "username": "abrahem",
                        "content": "read the question carefully \"You may return the answer in any order\""
                    },
                    {
                        "username": "cenjian",
                        "content": " the expect output of the case [1,2,3,4,5,6,7,8,9,10,1,1,1,1,1] doesn\\'t include [1, 1, 1], [1,1] and so on. While according to the description, they are valid subsequences. Please fix this, my dear Leetcode. "
                    },
                    {
                        "username": "the_leetcode_guy",
                        "content": "Explanatory video: https://youtu.be/UX7cY8RvDWw"
                    },
                    {
                        "username": "maltarouti",
                        "content": "This is a discussion tab: \"Please don\\'t post any solutions in this discussion tab.\""
                    },
                    {
                        "username": "rajan_jasani9",
                        "content": "Great Explanation!"
                    },
                    {
                        "username": "sudhakargoutam",
                        "content": "DP Week is coming guys.get ready :( "
                    },
                    {
                        "username": "Sidd26",
                        "content": "Is the runtime of this is at best exponential using backtracking?"
                    },
                    {
                        "username": "devvartkumarkumar",
                        "content": "++?"
                    }
                ]
            },
            {
                "id": 1571749,
                "content": [
                    {
                        "username": "zarif98sjs",
                        "content": "The problem can be solved just by thinking it as a \"take - don't take recursion\". Furthermore, **we can avoid using `set`** to track duplicates by checking just one case. \nFirst, we take the element and do backtrack. Before going to the \"don't take\" case, we can make a simple ***check if the current number is equal to the last number of our temporary answer array***. If that is the case, we will get repeated answers if we go down this path. So, we don't recurse down if that is the case. \n\n***Time Complexity***: Each element will have two options. Either it's chosen, or it's not. So, the time complexity will be $O(2^n)$ in the worst case for sorted arrays where all the elements are considered. Most of the time it will be less than that as we get to prune early"
                    },
                    {
                        "username": "djslim",
                        "content": "Most people including top competitors solved with set , so I guess it' ok to use it"
                    },
                    {
                        "username": "uday000",
                        "content": "[@harsh_singgh](/harsh_singgh) really thankyou for the code brother"
                    },
                    {
                        "username": "uday000",
                        "content": "really thankyou [@Md Zarif Ul Alam](/zarif98sjs) for your thinking and it helped me a lot"
                    },
                    {
                        "username": "safinghoghabori65",
                        "content": "[@lotus18](/lotus18) Thank you so much for this solution. I was stuck in the loop of how to implement. "
                    },
                    {
                        "username": "lotus18",
                        "content": "Code For The Above Approach\n\n```\nclass Solution \n{\npublic:\n    vector<vector<int>> ans;\n    void f(vector<int>& nums, int x, vector<int> &v)\n    {\n        if(x==nums.size()) \n        {\n            if(v.size()>=2) ans.push_back(v);\n            return;\n        }\n        if(v.size()==0 || v.back()<=nums[x])\n        {\n            v.push_back(nums[x]);\n            f(nums,x+1,v);\n            v.pop_back();\n        }\n        if(v.size()!=0 && v.back()!=nums[x]) f(nums,x+1,v);\n        else if(v.size()==0) f(nums,x+1,v);\n        \n    }\n    vector<vector<int>> findSubsequences(vector<int>& nums) \n    {\n        vector<int> v;\n        f(nums,0,v);\n        return ans;\n    }\n};\n\n```"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "[@sanyamjain036](/sanyamjain036) \\n\\nThe idea is to create `New` HashMap in every new idx (recursive call)\\n\\nHope this code give you better insight, me myself just figure it out also when I tried switching language using golang , and sadly golang dont have generic type for set :( \\n\\nhttps://leetcode.com/problems/non-decreasing-subsequences/solutions/3077388/go-backtrack-trace-last-value/?orderBy=most_relevant"
                    },
                    {
                        "username": "hsnooob",
                        "content": "[@kerkathy](/kerkathy) Ooh Sorry about that. Check now."
                    },
                    {
                        "username": "Triquetra",
                        "content": "Various optimizations are pointless for exponential-time problems, in my opinion."
                    },
                    {
                        "username": "kerkathy",
                        "content": "[@harsh_singgh](/harsh_singgh) hi, this seems to be private, would you kindly open the code to public? :)"
                    },
                    {
                        "username": "hsnooob",
                        "content": "Nice idea, here is the implementation of it. https://leetcode.com/problems/non-decreasing-subsequences/solutions/3075983/avoid-duplicates-without-using-set/"
                    },
                    {
                        "username": "sanyamjain036",
                        "content": "Can you explain more in depth , how we can do it without using set?"
                    },
                    {
                        "username": "yadav0288",
                        "content": "[@shadab-malik](/shadab-malik)  For avoiding duplicates , we can use set because set ( set<vector<int>>ans; ) does not consider duplicates ans at the for returning ans convert set into vector example -> vector(ans.begin() , ans.end()) ;"
                    },
                    {
                        "username": "medmoe",
                        "content": "Thank you for the \" take and not take \" phrase that\\'s all what i needed"
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "Nice one"
                    },
                    {
                        "username": "shadab-malik",
                        "content": "[@hydra324](/hydra324) I\\'m still not getting how to avoid duplicates ? Can you explain it pls....\\n"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Does it work with test cases like this?\\n[1,2,5,3,5,4,5]\\nSeems that the last temporary answer array may be [1,3] or [1,4] when we want to avoid duplicates of [1, 5]?"
                    },
                    {
                        "username": "hydra324",
                        "content": "Nice observation! was sracthing my head on how to avoid duplicates without using hashsets."
                    },
                    {
                        "username": "danila_egorenko",
                        "content": "Array week is much better than graph week\\uD83D\\uDC40"
                    },
                    {
                        "username": "challengeHunter",
                        "content": "Easier one does\\'t mean better one........"
                    },
                    {
                        "username": "lineshmalkam",
                        "content": "arrayy weekk goesss brrrrrrrr............."
                    },
                    {
                        "username": "vivek271",
                        "content": "WA on testcase [1,2,3,4,5,6,7,8,9,10,1,1,1,1,1]\\n\\nOutput: https://pastebin.com/RpDxzRe4\\n\\nExpected: https://pastebin.com/wT6z01jw\\n"
                    },
                    {
                        "username": "1337beef",
                        "content": "I saw some answers which produce strictly increasing subsequences while the question now allows non-decreasing subsequences.\\n\\n"
                    },
                    {
                        "username": "RichardChe",
                        "content": "When I run my code(accepted) using [1,2,3,8,9,10,1,1,1,1,1] as test case, it doesn't match the given expected answer, but it's still accepted. Is anybody had the  same situation?"
                    },
                    {
                        "username": "scorpioneer",
                        "content": "[@gauraVSomani](/gauraVSomani) I was facing the same issue . Try to shift the pop statement inside the pick (take it ) if block because if the pop statement is present outside the if block then it will introduce the duplicates which eventually gives wrong answer . I hope it will work for you too :)  "
                    },
                    {
                        "username": "gauraVSomani",
                        "content": "My solution is not being accepted for the same. I can\\'t figure out what I am doing wrong."
                    },
                    {
                        "username": "harshpratap1601",
                        "content": "same issue"
                    },
                    {
                        "username": "abrahem",
                        "content": "read the question carefully \"You may return the answer in any order\""
                    },
                    {
                        "username": "cenjian",
                        "content": " the expect output of the case [1,2,3,4,5,6,7,8,9,10,1,1,1,1,1] doesn\\'t include [1, 1, 1], [1,1] and so on. While according to the description, they are valid subsequences. Please fix this, my dear Leetcode. "
                    },
                    {
                        "username": "the_leetcode_guy",
                        "content": "Explanatory video: https://youtu.be/UX7cY8RvDWw"
                    },
                    {
                        "username": "maltarouti",
                        "content": "This is a discussion tab: \"Please don\\'t post any solutions in this discussion tab.\""
                    },
                    {
                        "username": "rajan_jasani9",
                        "content": "Great Explanation!"
                    },
                    {
                        "username": "sudhakargoutam",
                        "content": "DP Week is coming guys.get ready :( "
                    },
                    {
                        "username": "Sidd26",
                        "content": "Is the runtime of this is at best exponential using backtracking?"
                    },
                    {
                        "username": "devvartkumarkumar",
                        "content": "++?"
                    }
                ]
            },
            {
                "id": 1768720,
                "content": [
                    {
                        "username": "ProProg",
                        "content": "Why the following code is not working for the [1,2,3,4,5,6,7,8,9,10,1,1,1,1,1]?\n\n```\n class Solution {\nprivate:\n    vector<vector<int>> result;\n    int n = 0;\npublic:\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\n        this->n = nums.size();\n        if(n <= 1) {\n            return result;\n        }\n\n        vector<int> sub;\n        recurse(nums, 0, sub);\n        return result;\n    }\n\nprivate:\n   void recurse(vector<int>& nums, int start, vector<int>& sub) {\n       if(sub.size() >= 2) {\n           result.push_back(sub);\n       }\n\n       if(start >= n) {\n           return;\n       }\n\n       for(int index = start; index < n; index++) {\n           // If the current element is smaller than last element of current subsequence.\n           if(sub.size() > 0 && sub.back() > nums[index]) {\n               continue;\n           }\n\n           // Check if the same element has been taken for the same position\n           if(index > start && nums[index] == nums[index -1]) {\n               continue;\n           }\n           \n           sub.push_back(nums[index]);\n           recurse(nums, index + 1, sub);\n           sub.pop_back();\n       }\n   }\n};\n```"
                    },
                    {
                        "username": "JonahYe",
                        "content": "This kind of problem isn't suitable for Goer, since it's very hard to avoid duplicating subsequence in Go. What do you think?"
                    },
                    {
                        "username": "aumo",
                        "content": "Look for pruning methods to traverse the solution space without introducing duplicates"
                    },
                    {
                        "username": "Shchukinvov",
                        "content": "Can somebody explain, why do we have [4,7] and [4,7,7] in output example 1?"
                    },
                    {
                        "username": "voolcanooo",
                        "content": "subsequence can be discontinuous, and non decreasing means one should be bigger or same as the previous one"
                    },
                    {
                        "username": "vinaygottipamula",
                        "content": "\\'return all the different possible non-decreasing subsequences\\' as it is also the non-decreasing subsequence(not necessarily contiguos array), we have to consider it. We are not asked to find Strictly increasing subsequence .\\n"
                    },
                    {
                        "username": "harshcodes04",
                        "content": "It might be wrong but I think we need to find Subsequences with atleast two elements where second element should be greater and equal to the first one. Contiguous array is not necessary here. "
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "recursion - include ,exclude\\nset for duplicate "
                    },
                    {
                        "username": "apalvinski",
                        "content": "I am getting [System.ArgumentException: array too small. numBytes/offset wrong.] error on \\nthe test case: [1,1,1,1,1,1,1].  But if i execute the test case explicitly it works fine. Does anybody know what may be an issue. Thank you in advance."
                    },
                    {
                        "username": "bupt_wc",
                        "content": "https://buptwc.github.io/2018/07/03/Leetcode-491-Increasing-Subsequences/\\n\\nhelp you understand LIS and this problem\\nHope helpful!"
                    },
                    {
                        "username": "rohit_rm",
                        "content": "why my code is giving empty list ? can anyone pls explain ?\\n\\n `class Solution {\\n   \\n    public List<List<Integer>> findSubsequences(int[] nums) {\\n         List<List<Integer>> ans = new LinkedList<>();\\n         List<Integer> list = new LinkedList<>();\\n        helper(nums, nums.length,list , 0, ans);\\n        return ans;\\n    }\\n\\n    private void helper(int nums[], int n , List<Integer> list , int index , List<List<Integer>> ans){\\n\\n        if(index == n){\\n            System.out.println(list.size());\\n            ans.add(list);\\n            return;\\n        }\\n\\n        list.add(nums[index]);\\n        helper(nums, n, list, index+1,ans);\\n        list.remove(list.size() - 1);\\n        helper(nums, n, list, index+1,ans);\\n        \\n    }\\n}`"
                    },
                    {
                        "username": "khushiii07",
                        "content": "``` \\nclass Solution {\\npublic:\\n    void solve(vector<int>& nums,int idx,vector<int>& tem,vector<vector<int>>& ans){\\n        if(idx==nums.size()){\\n            if(tem.size()>=2){\\n                ans.push_back(tem); \\n            }\\n            return;\\n        }\\n        if(tem.empty()) tem.push_back(nums[idx]);\\n        else if(nums[idx] >= tem.back()){\\n            tem.push_back(nums[idx]);\\n            solve(nums,idx+1,tem,ans);   \\n            tem.pop_back();\\n        }\\n        solve(nums,idx+1,tem,ans);\\n    }\\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        vector<int> tem;\\n\\n        solve(nums,0,tem,ans);\\n\\n        return ans;\\n    }\\n};\\n```\\n\\ncan anyone figure out what else im missing.. for testcase 1,\\n im getting \" [[4,6,7,7],[4,6,7],[4,6,7],[4,6],[4,7,7],[4,7],[4,7]] \""
                    },
                    {
                        "username": "sumantaraj",
                        "content": "create unordered set \\n unordered_set<int> st; to store values not needed"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/491.%20Non-decreasing%20Subsequences.cpp\\nALL LEETCODE SOLUTION IN C++\\nPLEASE LEAVE A STAR"
                    }
                ]
            },
            {
                "id": 1766495,
                "content": [
                    {
                        "username": "ProProg",
                        "content": "Why the following code is not working for the [1,2,3,4,5,6,7,8,9,10,1,1,1,1,1]?\n\n```\n class Solution {\nprivate:\n    vector<vector<int>> result;\n    int n = 0;\npublic:\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\n        this->n = nums.size();\n        if(n <= 1) {\n            return result;\n        }\n\n        vector<int> sub;\n        recurse(nums, 0, sub);\n        return result;\n    }\n\nprivate:\n   void recurse(vector<int>& nums, int start, vector<int>& sub) {\n       if(sub.size() >= 2) {\n           result.push_back(sub);\n       }\n\n       if(start >= n) {\n           return;\n       }\n\n       for(int index = start; index < n; index++) {\n           // If the current element is smaller than last element of current subsequence.\n           if(sub.size() > 0 && sub.back() > nums[index]) {\n               continue;\n           }\n\n           // Check if the same element has been taken for the same position\n           if(index > start && nums[index] == nums[index -1]) {\n               continue;\n           }\n           \n           sub.push_back(nums[index]);\n           recurse(nums, index + 1, sub);\n           sub.pop_back();\n       }\n   }\n};\n```"
                    },
                    {
                        "username": "JonahYe",
                        "content": "This kind of problem isn't suitable for Goer, since it's very hard to avoid duplicating subsequence in Go. What do you think?"
                    },
                    {
                        "username": "aumo",
                        "content": "Look for pruning methods to traverse the solution space without introducing duplicates"
                    },
                    {
                        "username": "Shchukinvov",
                        "content": "Can somebody explain, why do we have [4,7] and [4,7,7] in output example 1?"
                    },
                    {
                        "username": "voolcanooo",
                        "content": "subsequence can be discontinuous, and non decreasing means one should be bigger or same as the previous one"
                    },
                    {
                        "username": "vinaygottipamula",
                        "content": "\\'return all the different possible non-decreasing subsequences\\' as it is also the non-decreasing subsequence(not necessarily contiguos array), we have to consider it. We are not asked to find Strictly increasing subsequence .\\n"
                    },
                    {
                        "username": "harshcodes04",
                        "content": "It might be wrong but I think we need to find Subsequences with atleast two elements where second element should be greater and equal to the first one. Contiguous array is not necessary here. "
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "recursion - include ,exclude\\nset for duplicate "
                    },
                    {
                        "username": "apalvinski",
                        "content": "I am getting [System.ArgumentException: array too small. numBytes/offset wrong.] error on \\nthe test case: [1,1,1,1,1,1,1].  But if i execute the test case explicitly it works fine. Does anybody know what may be an issue. Thank you in advance."
                    },
                    {
                        "username": "bupt_wc",
                        "content": "https://buptwc.github.io/2018/07/03/Leetcode-491-Increasing-Subsequences/\\n\\nhelp you understand LIS and this problem\\nHope helpful!"
                    },
                    {
                        "username": "rohit_rm",
                        "content": "why my code is giving empty list ? can anyone pls explain ?\\n\\n `class Solution {\\n   \\n    public List<List<Integer>> findSubsequences(int[] nums) {\\n         List<List<Integer>> ans = new LinkedList<>();\\n         List<Integer> list = new LinkedList<>();\\n        helper(nums, nums.length,list , 0, ans);\\n        return ans;\\n    }\\n\\n    private void helper(int nums[], int n , List<Integer> list , int index , List<List<Integer>> ans){\\n\\n        if(index == n){\\n            System.out.println(list.size());\\n            ans.add(list);\\n            return;\\n        }\\n\\n        list.add(nums[index]);\\n        helper(nums, n, list, index+1,ans);\\n        list.remove(list.size() - 1);\\n        helper(nums, n, list, index+1,ans);\\n        \\n    }\\n}`"
                    },
                    {
                        "username": "khushiii07",
                        "content": "``` \\nclass Solution {\\npublic:\\n    void solve(vector<int>& nums,int idx,vector<int>& tem,vector<vector<int>>& ans){\\n        if(idx==nums.size()){\\n            if(tem.size()>=2){\\n                ans.push_back(tem); \\n            }\\n            return;\\n        }\\n        if(tem.empty()) tem.push_back(nums[idx]);\\n        else if(nums[idx] >= tem.back()){\\n            tem.push_back(nums[idx]);\\n            solve(nums,idx+1,tem,ans);   \\n            tem.pop_back();\\n        }\\n        solve(nums,idx+1,tem,ans);\\n    }\\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        vector<int> tem;\\n\\n        solve(nums,0,tem,ans);\\n\\n        return ans;\\n    }\\n};\\n```\\n\\ncan anyone figure out what else im missing.. for testcase 1,\\n im getting \" [[4,6,7,7],[4,6,7],[4,6,7],[4,6],[4,7,7],[4,7],[4,7]] \""
                    },
                    {
                        "username": "sumantaraj",
                        "content": "create unordered set \\n unordered_set<int> st; to store values not needed"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/491.%20Non-decreasing%20Subsequences.cpp\\nALL LEETCODE SOLUTION IN C++\\nPLEASE LEAVE A STAR"
                    }
                ]
            },
            {
                "id": 1766068,
                "content": [
                    {
                        "username": "ProProg",
                        "content": "Why the following code is not working for the [1,2,3,4,5,6,7,8,9,10,1,1,1,1,1]?\n\n```\n class Solution {\nprivate:\n    vector<vector<int>> result;\n    int n = 0;\npublic:\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\n        this->n = nums.size();\n        if(n <= 1) {\n            return result;\n        }\n\n        vector<int> sub;\n        recurse(nums, 0, sub);\n        return result;\n    }\n\nprivate:\n   void recurse(vector<int>& nums, int start, vector<int>& sub) {\n       if(sub.size() >= 2) {\n           result.push_back(sub);\n       }\n\n       if(start >= n) {\n           return;\n       }\n\n       for(int index = start; index < n; index++) {\n           // If the current element is smaller than last element of current subsequence.\n           if(sub.size() > 0 && sub.back() > nums[index]) {\n               continue;\n           }\n\n           // Check if the same element has been taken for the same position\n           if(index > start && nums[index] == nums[index -1]) {\n               continue;\n           }\n           \n           sub.push_back(nums[index]);\n           recurse(nums, index + 1, sub);\n           sub.pop_back();\n       }\n   }\n};\n```"
                    },
                    {
                        "username": "JonahYe",
                        "content": "This kind of problem isn't suitable for Goer, since it's very hard to avoid duplicating subsequence in Go. What do you think?"
                    },
                    {
                        "username": "aumo",
                        "content": "Look for pruning methods to traverse the solution space without introducing duplicates"
                    },
                    {
                        "username": "Shchukinvov",
                        "content": "Can somebody explain, why do we have [4,7] and [4,7,7] in output example 1?"
                    },
                    {
                        "username": "voolcanooo",
                        "content": "subsequence can be discontinuous, and non decreasing means one should be bigger or same as the previous one"
                    },
                    {
                        "username": "vinaygottipamula",
                        "content": "\\'return all the different possible non-decreasing subsequences\\' as it is also the non-decreasing subsequence(not necessarily contiguos array), we have to consider it. We are not asked to find Strictly increasing subsequence .\\n"
                    },
                    {
                        "username": "harshcodes04",
                        "content": "It might be wrong but I think we need to find Subsequences with atleast two elements where second element should be greater and equal to the first one. Contiguous array is not necessary here. "
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "recursion - include ,exclude\\nset for duplicate "
                    },
                    {
                        "username": "apalvinski",
                        "content": "I am getting [System.ArgumentException: array too small. numBytes/offset wrong.] error on \\nthe test case: [1,1,1,1,1,1,1].  But if i execute the test case explicitly it works fine. Does anybody know what may be an issue. Thank you in advance."
                    },
                    {
                        "username": "bupt_wc",
                        "content": "https://buptwc.github.io/2018/07/03/Leetcode-491-Increasing-Subsequences/\\n\\nhelp you understand LIS and this problem\\nHope helpful!"
                    },
                    {
                        "username": "rohit_rm",
                        "content": "why my code is giving empty list ? can anyone pls explain ?\\n\\n `class Solution {\\n   \\n    public List<List<Integer>> findSubsequences(int[] nums) {\\n         List<List<Integer>> ans = new LinkedList<>();\\n         List<Integer> list = new LinkedList<>();\\n        helper(nums, nums.length,list , 0, ans);\\n        return ans;\\n    }\\n\\n    private void helper(int nums[], int n , List<Integer> list , int index , List<List<Integer>> ans){\\n\\n        if(index == n){\\n            System.out.println(list.size());\\n            ans.add(list);\\n            return;\\n        }\\n\\n        list.add(nums[index]);\\n        helper(nums, n, list, index+1,ans);\\n        list.remove(list.size() - 1);\\n        helper(nums, n, list, index+1,ans);\\n        \\n    }\\n}`"
                    },
                    {
                        "username": "khushiii07",
                        "content": "``` \\nclass Solution {\\npublic:\\n    void solve(vector<int>& nums,int idx,vector<int>& tem,vector<vector<int>>& ans){\\n        if(idx==nums.size()){\\n            if(tem.size()>=2){\\n                ans.push_back(tem); \\n            }\\n            return;\\n        }\\n        if(tem.empty()) tem.push_back(nums[idx]);\\n        else if(nums[idx] >= tem.back()){\\n            tem.push_back(nums[idx]);\\n            solve(nums,idx+1,tem,ans);   \\n            tem.pop_back();\\n        }\\n        solve(nums,idx+1,tem,ans);\\n    }\\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        vector<int> tem;\\n\\n        solve(nums,0,tem,ans);\\n\\n        return ans;\\n    }\\n};\\n```\\n\\ncan anyone figure out what else im missing.. for testcase 1,\\n im getting \" [[4,6,7,7],[4,6,7],[4,6,7],[4,6],[4,7,7],[4,7],[4,7]] \""
                    },
                    {
                        "username": "sumantaraj",
                        "content": "create unordered set \\n unordered_set<int> st; to store values not needed"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/491.%20Non-decreasing%20Subsequences.cpp\\nALL LEETCODE SOLUTION IN C++\\nPLEASE LEAVE A STAR"
                    }
                ]
            },
            {
                "id": 1766047,
                "content": [
                    {
                        "username": "ProProg",
                        "content": "Why the following code is not working for the [1,2,3,4,5,6,7,8,9,10,1,1,1,1,1]?\n\n```\n class Solution {\nprivate:\n    vector<vector<int>> result;\n    int n = 0;\npublic:\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\n        this->n = nums.size();\n        if(n <= 1) {\n            return result;\n        }\n\n        vector<int> sub;\n        recurse(nums, 0, sub);\n        return result;\n    }\n\nprivate:\n   void recurse(vector<int>& nums, int start, vector<int>& sub) {\n       if(sub.size() >= 2) {\n           result.push_back(sub);\n       }\n\n       if(start >= n) {\n           return;\n       }\n\n       for(int index = start; index < n; index++) {\n           // If the current element is smaller than last element of current subsequence.\n           if(sub.size() > 0 && sub.back() > nums[index]) {\n               continue;\n           }\n\n           // Check if the same element has been taken for the same position\n           if(index > start && nums[index] == nums[index -1]) {\n               continue;\n           }\n           \n           sub.push_back(nums[index]);\n           recurse(nums, index + 1, sub);\n           sub.pop_back();\n       }\n   }\n};\n```"
                    },
                    {
                        "username": "JonahYe",
                        "content": "This kind of problem isn't suitable for Goer, since it's very hard to avoid duplicating subsequence in Go. What do you think?"
                    },
                    {
                        "username": "aumo",
                        "content": "Look for pruning methods to traverse the solution space without introducing duplicates"
                    },
                    {
                        "username": "Shchukinvov",
                        "content": "Can somebody explain, why do we have [4,7] and [4,7,7] in output example 1?"
                    },
                    {
                        "username": "voolcanooo",
                        "content": "subsequence can be discontinuous, and non decreasing means one should be bigger or same as the previous one"
                    },
                    {
                        "username": "vinaygottipamula",
                        "content": "\\'return all the different possible non-decreasing subsequences\\' as it is also the non-decreasing subsequence(not necessarily contiguos array), we have to consider it. We are not asked to find Strictly increasing subsequence .\\n"
                    },
                    {
                        "username": "harshcodes04",
                        "content": "It might be wrong but I think we need to find Subsequences with atleast two elements where second element should be greater and equal to the first one. Contiguous array is not necessary here. "
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "recursion - include ,exclude\\nset for duplicate "
                    },
                    {
                        "username": "apalvinski",
                        "content": "I am getting [System.ArgumentException: array too small. numBytes/offset wrong.] error on \\nthe test case: [1,1,1,1,1,1,1].  But if i execute the test case explicitly it works fine. Does anybody know what may be an issue. Thank you in advance."
                    },
                    {
                        "username": "bupt_wc",
                        "content": "https://buptwc.github.io/2018/07/03/Leetcode-491-Increasing-Subsequences/\\n\\nhelp you understand LIS and this problem\\nHope helpful!"
                    },
                    {
                        "username": "rohit_rm",
                        "content": "why my code is giving empty list ? can anyone pls explain ?\\n\\n `class Solution {\\n   \\n    public List<List<Integer>> findSubsequences(int[] nums) {\\n         List<List<Integer>> ans = new LinkedList<>();\\n         List<Integer> list = new LinkedList<>();\\n        helper(nums, nums.length,list , 0, ans);\\n        return ans;\\n    }\\n\\n    private void helper(int nums[], int n , List<Integer> list , int index , List<List<Integer>> ans){\\n\\n        if(index == n){\\n            System.out.println(list.size());\\n            ans.add(list);\\n            return;\\n        }\\n\\n        list.add(nums[index]);\\n        helper(nums, n, list, index+1,ans);\\n        list.remove(list.size() - 1);\\n        helper(nums, n, list, index+1,ans);\\n        \\n    }\\n}`"
                    },
                    {
                        "username": "khushiii07",
                        "content": "``` \\nclass Solution {\\npublic:\\n    void solve(vector<int>& nums,int idx,vector<int>& tem,vector<vector<int>>& ans){\\n        if(idx==nums.size()){\\n            if(tem.size()>=2){\\n                ans.push_back(tem); \\n            }\\n            return;\\n        }\\n        if(tem.empty()) tem.push_back(nums[idx]);\\n        else if(nums[idx] >= tem.back()){\\n            tem.push_back(nums[idx]);\\n            solve(nums,idx+1,tem,ans);   \\n            tem.pop_back();\\n        }\\n        solve(nums,idx+1,tem,ans);\\n    }\\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        vector<int> tem;\\n\\n        solve(nums,0,tem,ans);\\n\\n        return ans;\\n    }\\n};\\n```\\n\\ncan anyone figure out what else im missing.. for testcase 1,\\n im getting \" [[4,6,7,7],[4,6,7],[4,6,7],[4,6],[4,7,7],[4,7],[4,7]] \""
                    },
                    {
                        "username": "sumantaraj",
                        "content": "create unordered set \\n unordered_set<int> st; to store values not needed"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/491.%20Non-decreasing%20Subsequences.cpp\\nALL LEETCODE SOLUTION IN C++\\nPLEASE LEAVE A STAR"
                    }
                ]
            },
            {
                "id": 1572397,
                "content": [
                    {
                        "username": "ProProg",
                        "content": "Why the following code is not working for the [1,2,3,4,5,6,7,8,9,10,1,1,1,1,1]?\n\n```\n class Solution {\nprivate:\n    vector<vector<int>> result;\n    int n = 0;\npublic:\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\n        this->n = nums.size();\n        if(n <= 1) {\n            return result;\n        }\n\n        vector<int> sub;\n        recurse(nums, 0, sub);\n        return result;\n    }\n\nprivate:\n   void recurse(vector<int>& nums, int start, vector<int>& sub) {\n       if(sub.size() >= 2) {\n           result.push_back(sub);\n       }\n\n       if(start >= n) {\n           return;\n       }\n\n       for(int index = start; index < n; index++) {\n           // If the current element is smaller than last element of current subsequence.\n           if(sub.size() > 0 && sub.back() > nums[index]) {\n               continue;\n           }\n\n           // Check if the same element has been taken for the same position\n           if(index > start && nums[index] == nums[index -1]) {\n               continue;\n           }\n           \n           sub.push_back(nums[index]);\n           recurse(nums, index + 1, sub);\n           sub.pop_back();\n       }\n   }\n};\n```"
                    },
                    {
                        "username": "JonahYe",
                        "content": "This kind of problem isn't suitable for Goer, since it's very hard to avoid duplicating subsequence in Go. What do you think?"
                    },
                    {
                        "username": "aumo",
                        "content": "Look for pruning methods to traverse the solution space without introducing duplicates"
                    },
                    {
                        "username": "Shchukinvov",
                        "content": "Can somebody explain, why do we have [4,7] and [4,7,7] in output example 1?"
                    },
                    {
                        "username": "voolcanooo",
                        "content": "subsequence can be discontinuous, and non decreasing means one should be bigger or same as the previous one"
                    },
                    {
                        "username": "vinaygottipamula",
                        "content": "\\'return all the different possible non-decreasing subsequences\\' as it is also the non-decreasing subsequence(not necessarily contiguos array), we have to consider it. We are not asked to find Strictly increasing subsequence .\\n"
                    },
                    {
                        "username": "harshcodes04",
                        "content": "It might be wrong but I think we need to find Subsequences with atleast two elements where second element should be greater and equal to the first one. Contiguous array is not necessary here. "
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "recursion - include ,exclude\\nset for duplicate "
                    },
                    {
                        "username": "apalvinski",
                        "content": "I am getting [System.ArgumentException: array too small. numBytes/offset wrong.] error on \\nthe test case: [1,1,1,1,1,1,1].  But if i execute the test case explicitly it works fine. Does anybody know what may be an issue. Thank you in advance."
                    },
                    {
                        "username": "bupt_wc",
                        "content": "https://buptwc.github.io/2018/07/03/Leetcode-491-Increasing-Subsequences/\\n\\nhelp you understand LIS and this problem\\nHope helpful!"
                    },
                    {
                        "username": "rohit_rm",
                        "content": "why my code is giving empty list ? can anyone pls explain ?\\n\\n `class Solution {\\n   \\n    public List<List<Integer>> findSubsequences(int[] nums) {\\n         List<List<Integer>> ans = new LinkedList<>();\\n         List<Integer> list = new LinkedList<>();\\n        helper(nums, nums.length,list , 0, ans);\\n        return ans;\\n    }\\n\\n    private void helper(int nums[], int n , List<Integer> list , int index , List<List<Integer>> ans){\\n\\n        if(index == n){\\n            System.out.println(list.size());\\n            ans.add(list);\\n            return;\\n        }\\n\\n        list.add(nums[index]);\\n        helper(nums, n, list, index+1,ans);\\n        list.remove(list.size() - 1);\\n        helper(nums, n, list, index+1,ans);\\n        \\n    }\\n}`"
                    },
                    {
                        "username": "khushiii07",
                        "content": "``` \\nclass Solution {\\npublic:\\n    void solve(vector<int>& nums,int idx,vector<int>& tem,vector<vector<int>>& ans){\\n        if(idx==nums.size()){\\n            if(tem.size()>=2){\\n                ans.push_back(tem); \\n            }\\n            return;\\n        }\\n        if(tem.empty()) tem.push_back(nums[idx]);\\n        else if(nums[idx] >= tem.back()){\\n            tem.push_back(nums[idx]);\\n            solve(nums,idx+1,tem,ans);   \\n            tem.pop_back();\\n        }\\n        solve(nums,idx+1,tem,ans);\\n    }\\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        vector<int> tem;\\n\\n        solve(nums,0,tem,ans);\\n\\n        return ans;\\n    }\\n};\\n```\\n\\ncan anyone figure out what else im missing.. for testcase 1,\\n im getting \" [[4,6,7,7],[4,6,7],[4,6,7],[4,6],[4,7,7],[4,7],[4,7]] \""
                    },
                    {
                        "username": "sumantaraj",
                        "content": "create unordered set \\n unordered_set<int> st; to store values not needed"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/491.%20Non-decreasing%20Subsequences.cpp\\nALL LEETCODE SOLUTION IN C++\\nPLEASE LEAVE A STAR"
                    }
                ]
            },
            {
                "id": 1569247,
                "content": [
                    {
                        "username": "ProProg",
                        "content": "Why the following code is not working for the [1,2,3,4,5,6,7,8,9,10,1,1,1,1,1]?\n\n```\n class Solution {\nprivate:\n    vector<vector<int>> result;\n    int n = 0;\npublic:\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\n        this->n = nums.size();\n        if(n <= 1) {\n            return result;\n        }\n\n        vector<int> sub;\n        recurse(nums, 0, sub);\n        return result;\n    }\n\nprivate:\n   void recurse(vector<int>& nums, int start, vector<int>& sub) {\n       if(sub.size() >= 2) {\n           result.push_back(sub);\n       }\n\n       if(start >= n) {\n           return;\n       }\n\n       for(int index = start; index < n; index++) {\n           // If the current element is smaller than last element of current subsequence.\n           if(sub.size() > 0 && sub.back() > nums[index]) {\n               continue;\n           }\n\n           // Check if the same element has been taken for the same position\n           if(index > start && nums[index] == nums[index -1]) {\n               continue;\n           }\n           \n           sub.push_back(nums[index]);\n           recurse(nums, index + 1, sub);\n           sub.pop_back();\n       }\n   }\n};\n```"
                    },
                    {
                        "username": "JonahYe",
                        "content": "This kind of problem isn't suitable for Goer, since it's very hard to avoid duplicating subsequence in Go. What do you think?"
                    },
                    {
                        "username": "aumo",
                        "content": "Look for pruning methods to traverse the solution space without introducing duplicates"
                    },
                    {
                        "username": "Shchukinvov",
                        "content": "Can somebody explain, why do we have [4,7] and [4,7,7] in output example 1?"
                    },
                    {
                        "username": "voolcanooo",
                        "content": "subsequence can be discontinuous, and non decreasing means one should be bigger or same as the previous one"
                    },
                    {
                        "username": "vinaygottipamula",
                        "content": "\\'return all the different possible non-decreasing subsequences\\' as it is also the non-decreasing subsequence(not necessarily contiguos array), we have to consider it. We are not asked to find Strictly increasing subsequence .\\n"
                    },
                    {
                        "username": "harshcodes04",
                        "content": "It might be wrong but I think we need to find Subsequences with atleast two elements where second element should be greater and equal to the first one. Contiguous array is not necessary here. "
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "recursion - include ,exclude\\nset for duplicate "
                    },
                    {
                        "username": "apalvinski",
                        "content": "I am getting [System.ArgumentException: array too small. numBytes/offset wrong.] error on \\nthe test case: [1,1,1,1,1,1,1].  But if i execute the test case explicitly it works fine. Does anybody know what may be an issue. Thank you in advance."
                    },
                    {
                        "username": "bupt_wc",
                        "content": "https://buptwc.github.io/2018/07/03/Leetcode-491-Increasing-Subsequences/\\n\\nhelp you understand LIS and this problem\\nHope helpful!"
                    },
                    {
                        "username": "rohit_rm",
                        "content": "why my code is giving empty list ? can anyone pls explain ?\\n\\n `class Solution {\\n   \\n    public List<List<Integer>> findSubsequences(int[] nums) {\\n         List<List<Integer>> ans = new LinkedList<>();\\n         List<Integer> list = new LinkedList<>();\\n        helper(nums, nums.length,list , 0, ans);\\n        return ans;\\n    }\\n\\n    private void helper(int nums[], int n , List<Integer> list , int index , List<List<Integer>> ans){\\n\\n        if(index == n){\\n            System.out.println(list.size());\\n            ans.add(list);\\n            return;\\n        }\\n\\n        list.add(nums[index]);\\n        helper(nums, n, list, index+1,ans);\\n        list.remove(list.size() - 1);\\n        helper(nums, n, list, index+1,ans);\\n        \\n    }\\n}`"
                    },
                    {
                        "username": "khushiii07",
                        "content": "``` \\nclass Solution {\\npublic:\\n    void solve(vector<int>& nums,int idx,vector<int>& tem,vector<vector<int>>& ans){\\n        if(idx==nums.size()){\\n            if(tem.size()>=2){\\n                ans.push_back(tem); \\n            }\\n            return;\\n        }\\n        if(tem.empty()) tem.push_back(nums[idx]);\\n        else if(nums[idx] >= tem.back()){\\n            tem.push_back(nums[idx]);\\n            solve(nums,idx+1,tem,ans);   \\n            tem.pop_back();\\n        }\\n        solve(nums,idx+1,tem,ans);\\n    }\\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        vector<int> tem;\\n\\n        solve(nums,0,tem,ans);\\n\\n        return ans;\\n    }\\n};\\n```\\n\\ncan anyone figure out what else im missing.. for testcase 1,\\n im getting \" [[4,6,7,7],[4,6,7],[4,6,7],[4,6],[4,7,7],[4,7],[4,7]] \""
                    },
                    {
                        "username": "sumantaraj",
                        "content": "create unordered set \\n unordered_set<int> st; to store values not needed"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/491.%20Non-decreasing%20Subsequences.cpp\\nALL LEETCODE SOLUTION IN C++\\nPLEASE LEAVE A STAR"
                    }
                ]
            },
            {
                "id": 1981575,
                "content": [
                    {
                        "username": "ProProg",
                        "content": "Why the following code is not working for the [1,2,3,4,5,6,7,8,9,10,1,1,1,1,1]?\n\n```\n class Solution {\nprivate:\n    vector<vector<int>> result;\n    int n = 0;\npublic:\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\n        this->n = nums.size();\n        if(n <= 1) {\n            return result;\n        }\n\n        vector<int> sub;\n        recurse(nums, 0, sub);\n        return result;\n    }\n\nprivate:\n   void recurse(vector<int>& nums, int start, vector<int>& sub) {\n       if(sub.size() >= 2) {\n           result.push_back(sub);\n       }\n\n       if(start >= n) {\n           return;\n       }\n\n       for(int index = start; index < n; index++) {\n           // If the current element is smaller than last element of current subsequence.\n           if(sub.size() > 0 && sub.back() > nums[index]) {\n               continue;\n           }\n\n           // Check if the same element has been taken for the same position\n           if(index > start && nums[index] == nums[index -1]) {\n               continue;\n           }\n           \n           sub.push_back(nums[index]);\n           recurse(nums, index + 1, sub);\n           sub.pop_back();\n       }\n   }\n};\n```"
                    },
                    {
                        "username": "JonahYe",
                        "content": "This kind of problem isn't suitable for Goer, since it's very hard to avoid duplicating subsequence in Go. What do you think?"
                    },
                    {
                        "username": "aumo",
                        "content": "Look for pruning methods to traverse the solution space without introducing duplicates"
                    },
                    {
                        "username": "Shchukinvov",
                        "content": "Can somebody explain, why do we have [4,7] and [4,7,7] in output example 1?"
                    },
                    {
                        "username": "voolcanooo",
                        "content": "subsequence can be discontinuous, and non decreasing means one should be bigger or same as the previous one"
                    },
                    {
                        "username": "vinaygottipamula",
                        "content": "\\'return all the different possible non-decreasing subsequences\\' as it is also the non-decreasing subsequence(not necessarily contiguos array), we have to consider it. We are not asked to find Strictly increasing subsequence .\\n"
                    },
                    {
                        "username": "harshcodes04",
                        "content": "It might be wrong but I think we need to find Subsequences with atleast two elements where second element should be greater and equal to the first one. Contiguous array is not necessary here. "
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "recursion - include ,exclude\\nset for duplicate "
                    },
                    {
                        "username": "apalvinski",
                        "content": "I am getting [System.ArgumentException: array too small. numBytes/offset wrong.] error on \\nthe test case: [1,1,1,1,1,1,1].  But if i execute the test case explicitly it works fine. Does anybody know what may be an issue. Thank you in advance."
                    },
                    {
                        "username": "bupt_wc",
                        "content": "https://buptwc.github.io/2018/07/03/Leetcode-491-Increasing-Subsequences/\\n\\nhelp you understand LIS and this problem\\nHope helpful!"
                    },
                    {
                        "username": "rohit_rm",
                        "content": "why my code is giving empty list ? can anyone pls explain ?\\n\\n `class Solution {\\n   \\n    public List<List<Integer>> findSubsequences(int[] nums) {\\n         List<List<Integer>> ans = new LinkedList<>();\\n         List<Integer> list = new LinkedList<>();\\n        helper(nums, nums.length,list , 0, ans);\\n        return ans;\\n    }\\n\\n    private void helper(int nums[], int n , List<Integer> list , int index , List<List<Integer>> ans){\\n\\n        if(index == n){\\n            System.out.println(list.size());\\n            ans.add(list);\\n            return;\\n        }\\n\\n        list.add(nums[index]);\\n        helper(nums, n, list, index+1,ans);\\n        list.remove(list.size() - 1);\\n        helper(nums, n, list, index+1,ans);\\n        \\n    }\\n}`"
                    },
                    {
                        "username": "khushiii07",
                        "content": "``` \\nclass Solution {\\npublic:\\n    void solve(vector<int>& nums,int idx,vector<int>& tem,vector<vector<int>>& ans){\\n        if(idx==nums.size()){\\n            if(tem.size()>=2){\\n                ans.push_back(tem); \\n            }\\n            return;\\n        }\\n        if(tem.empty()) tem.push_back(nums[idx]);\\n        else if(nums[idx] >= tem.back()){\\n            tem.push_back(nums[idx]);\\n            solve(nums,idx+1,tem,ans);   \\n            tem.pop_back();\\n        }\\n        solve(nums,idx+1,tem,ans);\\n    }\\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        vector<int> tem;\\n\\n        solve(nums,0,tem,ans);\\n\\n        return ans;\\n    }\\n};\\n```\\n\\ncan anyone figure out what else im missing.. for testcase 1,\\n im getting \" [[4,6,7,7],[4,6,7],[4,6,7],[4,6],[4,7,7],[4,7],[4,7]] \""
                    },
                    {
                        "username": "sumantaraj",
                        "content": "create unordered set \\n unordered_set<int> st; to store values not needed"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/491.%20Non-decreasing%20Subsequences.cpp\\nALL LEETCODE SOLUTION IN C++\\nPLEASE LEAVE A STAR"
                    }
                ]
            },
            {
                "id": 1979703,
                "content": [
                    {
                        "username": "ProProg",
                        "content": "Why the following code is not working for the [1,2,3,4,5,6,7,8,9,10,1,1,1,1,1]?\n\n```\n class Solution {\nprivate:\n    vector<vector<int>> result;\n    int n = 0;\npublic:\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\n        this->n = nums.size();\n        if(n <= 1) {\n            return result;\n        }\n\n        vector<int> sub;\n        recurse(nums, 0, sub);\n        return result;\n    }\n\nprivate:\n   void recurse(vector<int>& nums, int start, vector<int>& sub) {\n       if(sub.size() >= 2) {\n           result.push_back(sub);\n       }\n\n       if(start >= n) {\n           return;\n       }\n\n       for(int index = start; index < n; index++) {\n           // If the current element is smaller than last element of current subsequence.\n           if(sub.size() > 0 && sub.back() > nums[index]) {\n               continue;\n           }\n\n           // Check if the same element has been taken for the same position\n           if(index > start && nums[index] == nums[index -1]) {\n               continue;\n           }\n           \n           sub.push_back(nums[index]);\n           recurse(nums, index + 1, sub);\n           sub.pop_back();\n       }\n   }\n};\n```"
                    },
                    {
                        "username": "JonahYe",
                        "content": "This kind of problem isn't suitable for Goer, since it's very hard to avoid duplicating subsequence in Go. What do you think?"
                    },
                    {
                        "username": "aumo",
                        "content": "Look for pruning methods to traverse the solution space without introducing duplicates"
                    },
                    {
                        "username": "Shchukinvov",
                        "content": "Can somebody explain, why do we have [4,7] and [4,7,7] in output example 1?"
                    },
                    {
                        "username": "voolcanooo",
                        "content": "subsequence can be discontinuous, and non decreasing means one should be bigger or same as the previous one"
                    },
                    {
                        "username": "vinaygottipamula",
                        "content": "\\'return all the different possible non-decreasing subsequences\\' as it is also the non-decreasing subsequence(not necessarily contiguos array), we have to consider it. We are not asked to find Strictly increasing subsequence .\\n"
                    },
                    {
                        "username": "harshcodes04",
                        "content": "It might be wrong but I think we need to find Subsequences with atleast two elements where second element should be greater and equal to the first one. Contiguous array is not necessary here. "
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "recursion - include ,exclude\\nset for duplicate "
                    },
                    {
                        "username": "apalvinski",
                        "content": "I am getting [System.ArgumentException: array too small. numBytes/offset wrong.] error on \\nthe test case: [1,1,1,1,1,1,1].  But if i execute the test case explicitly it works fine. Does anybody know what may be an issue. Thank you in advance."
                    },
                    {
                        "username": "bupt_wc",
                        "content": "https://buptwc.github.io/2018/07/03/Leetcode-491-Increasing-Subsequences/\\n\\nhelp you understand LIS and this problem\\nHope helpful!"
                    },
                    {
                        "username": "rohit_rm",
                        "content": "why my code is giving empty list ? can anyone pls explain ?\\n\\n `class Solution {\\n   \\n    public List<List<Integer>> findSubsequences(int[] nums) {\\n         List<List<Integer>> ans = new LinkedList<>();\\n         List<Integer> list = new LinkedList<>();\\n        helper(nums, nums.length,list , 0, ans);\\n        return ans;\\n    }\\n\\n    private void helper(int nums[], int n , List<Integer> list , int index , List<List<Integer>> ans){\\n\\n        if(index == n){\\n            System.out.println(list.size());\\n            ans.add(list);\\n            return;\\n        }\\n\\n        list.add(nums[index]);\\n        helper(nums, n, list, index+1,ans);\\n        list.remove(list.size() - 1);\\n        helper(nums, n, list, index+1,ans);\\n        \\n    }\\n}`"
                    },
                    {
                        "username": "khushiii07",
                        "content": "``` \\nclass Solution {\\npublic:\\n    void solve(vector<int>& nums,int idx,vector<int>& tem,vector<vector<int>>& ans){\\n        if(idx==nums.size()){\\n            if(tem.size()>=2){\\n                ans.push_back(tem); \\n            }\\n            return;\\n        }\\n        if(tem.empty()) tem.push_back(nums[idx]);\\n        else if(nums[idx] >= tem.back()){\\n            tem.push_back(nums[idx]);\\n            solve(nums,idx+1,tem,ans);   \\n            tem.pop_back();\\n        }\\n        solve(nums,idx+1,tem,ans);\\n    }\\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        vector<int> tem;\\n\\n        solve(nums,0,tem,ans);\\n\\n        return ans;\\n    }\\n};\\n```\\n\\ncan anyone figure out what else im missing.. for testcase 1,\\n im getting \" [[4,6,7,7],[4,6,7],[4,6,7],[4,6],[4,7,7],[4,7],[4,7]] \""
                    },
                    {
                        "username": "sumantaraj",
                        "content": "create unordered set \\n unordered_set<int> st; to store values not needed"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/491.%20Non-decreasing%20Subsequences.cpp\\nALL LEETCODE SOLUTION IN C++\\nPLEASE LEAVE A STAR"
                    }
                ]
            },
            {
                "id": 1936779,
                "content": [
                    {
                        "username": "ProProg",
                        "content": "Why the following code is not working for the [1,2,3,4,5,6,7,8,9,10,1,1,1,1,1]?\n\n```\n class Solution {\nprivate:\n    vector<vector<int>> result;\n    int n = 0;\npublic:\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\n        this->n = nums.size();\n        if(n <= 1) {\n            return result;\n        }\n\n        vector<int> sub;\n        recurse(nums, 0, sub);\n        return result;\n    }\n\nprivate:\n   void recurse(vector<int>& nums, int start, vector<int>& sub) {\n       if(sub.size() >= 2) {\n           result.push_back(sub);\n       }\n\n       if(start >= n) {\n           return;\n       }\n\n       for(int index = start; index < n; index++) {\n           // If the current element is smaller than last element of current subsequence.\n           if(sub.size() > 0 && sub.back() > nums[index]) {\n               continue;\n           }\n\n           // Check if the same element has been taken for the same position\n           if(index > start && nums[index] == nums[index -1]) {\n               continue;\n           }\n           \n           sub.push_back(nums[index]);\n           recurse(nums, index + 1, sub);\n           sub.pop_back();\n       }\n   }\n};\n```"
                    },
                    {
                        "username": "JonahYe",
                        "content": "This kind of problem isn't suitable for Goer, since it's very hard to avoid duplicating subsequence in Go. What do you think?"
                    },
                    {
                        "username": "aumo",
                        "content": "Look for pruning methods to traverse the solution space without introducing duplicates"
                    },
                    {
                        "username": "Shchukinvov",
                        "content": "Can somebody explain, why do we have [4,7] and [4,7,7] in output example 1?"
                    },
                    {
                        "username": "voolcanooo",
                        "content": "subsequence can be discontinuous, and non decreasing means one should be bigger or same as the previous one"
                    },
                    {
                        "username": "vinaygottipamula",
                        "content": "\\'return all the different possible non-decreasing subsequences\\' as it is also the non-decreasing subsequence(not necessarily contiguos array), we have to consider it. We are not asked to find Strictly increasing subsequence .\\n"
                    },
                    {
                        "username": "harshcodes04",
                        "content": "It might be wrong but I think we need to find Subsequences with atleast two elements where second element should be greater and equal to the first one. Contiguous array is not necessary here. "
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "recursion - include ,exclude\\nset for duplicate "
                    },
                    {
                        "username": "apalvinski",
                        "content": "I am getting [System.ArgumentException: array too small. numBytes/offset wrong.] error on \\nthe test case: [1,1,1,1,1,1,1].  But if i execute the test case explicitly it works fine. Does anybody know what may be an issue. Thank you in advance."
                    },
                    {
                        "username": "bupt_wc",
                        "content": "https://buptwc.github.io/2018/07/03/Leetcode-491-Increasing-Subsequences/\\n\\nhelp you understand LIS and this problem\\nHope helpful!"
                    },
                    {
                        "username": "rohit_rm",
                        "content": "why my code is giving empty list ? can anyone pls explain ?\\n\\n `class Solution {\\n   \\n    public List<List<Integer>> findSubsequences(int[] nums) {\\n         List<List<Integer>> ans = new LinkedList<>();\\n         List<Integer> list = new LinkedList<>();\\n        helper(nums, nums.length,list , 0, ans);\\n        return ans;\\n    }\\n\\n    private void helper(int nums[], int n , List<Integer> list , int index , List<List<Integer>> ans){\\n\\n        if(index == n){\\n            System.out.println(list.size());\\n            ans.add(list);\\n            return;\\n        }\\n\\n        list.add(nums[index]);\\n        helper(nums, n, list, index+1,ans);\\n        list.remove(list.size() - 1);\\n        helper(nums, n, list, index+1,ans);\\n        \\n    }\\n}`"
                    },
                    {
                        "username": "khushiii07",
                        "content": "``` \\nclass Solution {\\npublic:\\n    void solve(vector<int>& nums,int idx,vector<int>& tem,vector<vector<int>>& ans){\\n        if(idx==nums.size()){\\n            if(tem.size()>=2){\\n                ans.push_back(tem); \\n            }\\n            return;\\n        }\\n        if(tem.empty()) tem.push_back(nums[idx]);\\n        else if(nums[idx] >= tem.back()){\\n            tem.push_back(nums[idx]);\\n            solve(nums,idx+1,tem,ans);   \\n            tem.pop_back();\\n        }\\n        solve(nums,idx+1,tem,ans);\\n    }\\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        vector<int> tem;\\n\\n        solve(nums,0,tem,ans);\\n\\n        return ans;\\n    }\\n};\\n```\\n\\ncan anyone figure out what else im missing.. for testcase 1,\\n im getting \" [[4,6,7,7],[4,6,7],[4,6,7],[4,6],[4,7,7],[4,7],[4,7]] \""
                    },
                    {
                        "username": "sumantaraj",
                        "content": "create unordered set \\n unordered_set<int> st; to store values not needed"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/491.%20Non-decreasing%20Subsequences.cpp\\nALL LEETCODE SOLUTION IN C++\\nPLEASE LEAVE A STAR"
                    }
                ]
            },
            {
                "id": 1806684,
                "content": [
                    {
                        "username": "ProProg",
                        "content": "Why the following code is not working for the [1,2,3,4,5,6,7,8,9,10,1,1,1,1,1]?\n\n```\n class Solution {\nprivate:\n    vector<vector<int>> result;\n    int n = 0;\npublic:\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\n        this->n = nums.size();\n        if(n <= 1) {\n            return result;\n        }\n\n        vector<int> sub;\n        recurse(nums, 0, sub);\n        return result;\n    }\n\nprivate:\n   void recurse(vector<int>& nums, int start, vector<int>& sub) {\n       if(sub.size() >= 2) {\n           result.push_back(sub);\n       }\n\n       if(start >= n) {\n           return;\n       }\n\n       for(int index = start; index < n; index++) {\n           // If the current element is smaller than last element of current subsequence.\n           if(sub.size() > 0 && sub.back() > nums[index]) {\n               continue;\n           }\n\n           // Check if the same element has been taken for the same position\n           if(index > start && nums[index] == nums[index -1]) {\n               continue;\n           }\n           \n           sub.push_back(nums[index]);\n           recurse(nums, index + 1, sub);\n           sub.pop_back();\n       }\n   }\n};\n```"
                    },
                    {
                        "username": "JonahYe",
                        "content": "This kind of problem isn't suitable for Goer, since it's very hard to avoid duplicating subsequence in Go. What do you think?"
                    },
                    {
                        "username": "aumo",
                        "content": "Look for pruning methods to traverse the solution space without introducing duplicates"
                    },
                    {
                        "username": "Shchukinvov",
                        "content": "Can somebody explain, why do we have [4,7] and [4,7,7] in output example 1?"
                    },
                    {
                        "username": "voolcanooo",
                        "content": "subsequence can be discontinuous, and non decreasing means one should be bigger or same as the previous one"
                    },
                    {
                        "username": "vinaygottipamula",
                        "content": "\\'return all the different possible non-decreasing subsequences\\' as it is also the non-decreasing subsequence(not necessarily contiguos array), we have to consider it. We are not asked to find Strictly increasing subsequence .\\n"
                    },
                    {
                        "username": "harshcodes04",
                        "content": "It might be wrong but I think we need to find Subsequences with atleast two elements where second element should be greater and equal to the first one. Contiguous array is not necessary here. "
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "recursion - include ,exclude\\nset for duplicate "
                    },
                    {
                        "username": "apalvinski",
                        "content": "I am getting [System.ArgumentException: array too small. numBytes/offset wrong.] error on \\nthe test case: [1,1,1,1,1,1,1].  But if i execute the test case explicitly it works fine. Does anybody know what may be an issue. Thank you in advance."
                    },
                    {
                        "username": "bupt_wc",
                        "content": "https://buptwc.github.io/2018/07/03/Leetcode-491-Increasing-Subsequences/\\n\\nhelp you understand LIS and this problem\\nHope helpful!"
                    },
                    {
                        "username": "rohit_rm",
                        "content": "why my code is giving empty list ? can anyone pls explain ?\\n\\n `class Solution {\\n   \\n    public List<List<Integer>> findSubsequences(int[] nums) {\\n         List<List<Integer>> ans = new LinkedList<>();\\n         List<Integer> list = new LinkedList<>();\\n        helper(nums, nums.length,list , 0, ans);\\n        return ans;\\n    }\\n\\n    private void helper(int nums[], int n , List<Integer> list , int index , List<List<Integer>> ans){\\n\\n        if(index == n){\\n            System.out.println(list.size());\\n            ans.add(list);\\n            return;\\n        }\\n\\n        list.add(nums[index]);\\n        helper(nums, n, list, index+1,ans);\\n        list.remove(list.size() - 1);\\n        helper(nums, n, list, index+1,ans);\\n        \\n    }\\n}`"
                    },
                    {
                        "username": "khushiii07",
                        "content": "``` \\nclass Solution {\\npublic:\\n    void solve(vector<int>& nums,int idx,vector<int>& tem,vector<vector<int>>& ans){\\n        if(idx==nums.size()){\\n            if(tem.size()>=2){\\n                ans.push_back(tem); \\n            }\\n            return;\\n        }\\n        if(tem.empty()) tem.push_back(nums[idx]);\\n        else if(nums[idx] >= tem.back()){\\n            tem.push_back(nums[idx]);\\n            solve(nums,idx+1,tem,ans);   \\n            tem.pop_back();\\n        }\\n        solve(nums,idx+1,tem,ans);\\n    }\\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        vector<int> tem;\\n\\n        solve(nums,0,tem,ans);\\n\\n        return ans;\\n    }\\n};\\n```\\n\\ncan anyone figure out what else im missing.. for testcase 1,\\n im getting \" [[4,6,7,7],[4,6,7],[4,6,7],[4,6],[4,7,7],[4,7],[4,7]] \""
                    },
                    {
                        "username": "sumantaraj",
                        "content": "create unordered set \\n unordered_set<int> st; to store values not needed"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/491.%20Non-decreasing%20Subsequences.cpp\\nALL LEETCODE SOLUTION IN C++\\nPLEASE LEAVE A STAR"
                    }
                ]
            },
            {
                "id": 1774993,
                "content": [
                    {
                        "username": "Soham_Panchal",
                        "content": "Just keeping my Hash set and `nums` array identifier outside the functions increased my percentile to 74% from 19%. \\uD83D\\uDE2F"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nClick this link to Subscribe to my YouTube Channel https://tinyurl.com/4e2nj4vr\\n\\nhttps://youtu.be/S03sqmz2zX8"
                    },
                    {
                        "username": "shivam2612002",
                        "content": "can this be done using dp ? as we use dp in pick non-pick questions "
                    },
                    {
                        "username": "EricCLutts",
                        "content": "Whenever I ran into duplicates, I created a vector of vectors containing each possible value of them (so [..., 1, 1, 1, ...] became {{1}, {1, 1}, {1, 1, 1}} then appended each where valid onto previous vectors.\\nTime constraints not nearly as tight as some problems, had enough time at the end to run a sort + erase duplicates."
                    },
                    {
                        "username": "hiranmay1000",
                        "content": "Can it be solvable below O(n^2)?"
                    },
                    {
                        "username": "sudhakargoutam",
                        "content": "nope\\n"
                    },
                    {
                        "username": "vermani",
                        "content": "1. Find all subsequences of array using power set approach\\n2. store those subsequences in set so duplicates are discarded\\n3. iterate over the set and check if subsequence size is greater than 1 and if it is already sorted store it in return array (vector<vector<int>>) variable\\n4. return final array"
                    },
                    {
                        "username": "vikasanwla07",
                        "content": "class Solution {\\npublic:\\n    \\n    void fun(vector<int>&nums,int s,vector<int>&path,vector<vector<int>>&ans){\\n        if(path.size()>1)ans.push_back(path);\\n        set<int>used;\\n        for(int i = s;i<nums.size();i++){\\n            if(used.find(nums[i])!=used.end())continue;\\n            if(path.empty() or nums[i]>=path.back()){\\n                used.insert(nums[i]);\\n                path.push_back(nums[i]);\\n                fun(nums,i+1,path,ans);\\n                path.pop_back();\\n            }\\n        }\\n    }\\n    \\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        vector<int>v;\\n        fun(nums, 0,v, ans);\\n        return ans;\\n    }\\n\\n  \\n};"
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "This medium level problems become an easy level problem, if it is understood well.\\nBacktracking solves this problem in the simplest manner.\\nUnderstand the approach here: https://youtu.be/WUsYiuuZICc"
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "At Each index, try both possibilities, take or not take the current element.\\n- Note: The subseq should maintain non-dec order."
                    }
                ]
            },
            {
                "id": 1771451,
                "content": [
                    {
                        "username": "Soham_Panchal",
                        "content": "Just keeping my Hash set and `nums` array identifier outside the functions increased my percentile to 74% from 19%. \\uD83D\\uDE2F"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nClick this link to Subscribe to my YouTube Channel https://tinyurl.com/4e2nj4vr\\n\\nhttps://youtu.be/S03sqmz2zX8"
                    },
                    {
                        "username": "shivam2612002",
                        "content": "can this be done using dp ? as we use dp in pick non-pick questions "
                    },
                    {
                        "username": "EricCLutts",
                        "content": "Whenever I ran into duplicates, I created a vector of vectors containing each possible value of them (so [..., 1, 1, 1, ...] became {{1}, {1, 1}, {1, 1, 1}} then appended each where valid onto previous vectors.\\nTime constraints not nearly as tight as some problems, had enough time at the end to run a sort + erase duplicates."
                    },
                    {
                        "username": "hiranmay1000",
                        "content": "Can it be solvable below O(n^2)?"
                    },
                    {
                        "username": "sudhakargoutam",
                        "content": "nope\\n"
                    },
                    {
                        "username": "vermani",
                        "content": "1. Find all subsequences of array using power set approach\\n2. store those subsequences in set so duplicates are discarded\\n3. iterate over the set and check if subsequence size is greater than 1 and if it is already sorted store it in return array (vector<vector<int>>) variable\\n4. return final array"
                    },
                    {
                        "username": "vikasanwla07",
                        "content": "class Solution {\\npublic:\\n    \\n    void fun(vector<int>&nums,int s,vector<int>&path,vector<vector<int>>&ans){\\n        if(path.size()>1)ans.push_back(path);\\n        set<int>used;\\n        for(int i = s;i<nums.size();i++){\\n            if(used.find(nums[i])!=used.end())continue;\\n            if(path.empty() or nums[i]>=path.back()){\\n                used.insert(nums[i]);\\n                path.push_back(nums[i]);\\n                fun(nums,i+1,path,ans);\\n                path.pop_back();\\n            }\\n        }\\n    }\\n    \\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        vector<int>v;\\n        fun(nums, 0,v, ans);\\n        return ans;\\n    }\\n\\n  \\n};"
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "This medium level problems become an easy level problem, if it is understood well.\\nBacktracking solves this problem in the simplest manner.\\nUnderstand the approach here: https://youtu.be/WUsYiuuZICc"
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "At Each index, try both possibilities, take or not take the current element.\\n- Note: The subseq should maintain non-dec order."
                    }
                ]
            },
            {
                "id": 1766961,
                "content": [
                    {
                        "username": "Soham_Panchal",
                        "content": "Just keeping my Hash set and `nums` array identifier outside the functions increased my percentile to 74% from 19%. \\uD83D\\uDE2F"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nClick this link to Subscribe to my YouTube Channel https://tinyurl.com/4e2nj4vr\\n\\nhttps://youtu.be/S03sqmz2zX8"
                    },
                    {
                        "username": "shivam2612002",
                        "content": "can this be done using dp ? as we use dp in pick non-pick questions "
                    },
                    {
                        "username": "EricCLutts",
                        "content": "Whenever I ran into duplicates, I created a vector of vectors containing each possible value of them (so [..., 1, 1, 1, ...] became {{1}, {1, 1}, {1, 1, 1}} then appended each where valid onto previous vectors.\\nTime constraints not nearly as tight as some problems, had enough time at the end to run a sort + erase duplicates."
                    },
                    {
                        "username": "hiranmay1000",
                        "content": "Can it be solvable below O(n^2)?"
                    },
                    {
                        "username": "sudhakargoutam",
                        "content": "nope\\n"
                    },
                    {
                        "username": "vermani",
                        "content": "1. Find all subsequences of array using power set approach\\n2. store those subsequences in set so duplicates are discarded\\n3. iterate over the set and check if subsequence size is greater than 1 and if it is already sorted store it in return array (vector<vector<int>>) variable\\n4. return final array"
                    },
                    {
                        "username": "vikasanwla07",
                        "content": "class Solution {\\npublic:\\n    \\n    void fun(vector<int>&nums,int s,vector<int>&path,vector<vector<int>>&ans){\\n        if(path.size()>1)ans.push_back(path);\\n        set<int>used;\\n        for(int i = s;i<nums.size();i++){\\n            if(used.find(nums[i])!=used.end())continue;\\n            if(path.empty() or nums[i]>=path.back()){\\n                used.insert(nums[i]);\\n                path.push_back(nums[i]);\\n                fun(nums,i+1,path,ans);\\n                path.pop_back();\\n            }\\n        }\\n    }\\n    \\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        vector<int>v;\\n        fun(nums, 0,v, ans);\\n        return ans;\\n    }\\n\\n  \\n};"
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "This medium level problems become an easy level problem, if it is understood well.\\nBacktracking solves this problem in the simplest manner.\\nUnderstand the approach here: https://youtu.be/WUsYiuuZICc"
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "At Each index, try both possibilities, take or not take the current element.\\n- Note: The subseq should maintain non-dec order."
                    }
                ]
            },
            {
                "id": 1766858,
                "content": [
                    {
                        "username": "Soham_Panchal",
                        "content": "Just keeping my Hash set and `nums` array identifier outside the functions increased my percentile to 74% from 19%. \\uD83D\\uDE2F"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nClick this link to Subscribe to my YouTube Channel https://tinyurl.com/4e2nj4vr\\n\\nhttps://youtu.be/S03sqmz2zX8"
                    },
                    {
                        "username": "shivam2612002",
                        "content": "can this be done using dp ? as we use dp in pick non-pick questions "
                    },
                    {
                        "username": "EricCLutts",
                        "content": "Whenever I ran into duplicates, I created a vector of vectors containing each possible value of them (so [..., 1, 1, 1, ...] became {{1}, {1, 1}, {1, 1, 1}} then appended each where valid onto previous vectors.\\nTime constraints not nearly as tight as some problems, had enough time at the end to run a sort + erase duplicates."
                    },
                    {
                        "username": "hiranmay1000",
                        "content": "Can it be solvable below O(n^2)?"
                    },
                    {
                        "username": "sudhakargoutam",
                        "content": "nope\\n"
                    },
                    {
                        "username": "vermani",
                        "content": "1. Find all subsequences of array using power set approach\\n2. store those subsequences in set so duplicates are discarded\\n3. iterate over the set and check if subsequence size is greater than 1 and if it is already sorted store it in return array (vector<vector<int>>) variable\\n4. return final array"
                    },
                    {
                        "username": "vikasanwla07",
                        "content": "class Solution {\\npublic:\\n    \\n    void fun(vector<int>&nums,int s,vector<int>&path,vector<vector<int>>&ans){\\n        if(path.size()>1)ans.push_back(path);\\n        set<int>used;\\n        for(int i = s;i<nums.size();i++){\\n            if(used.find(nums[i])!=used.end())continue;\\n            if(path.empty() or nums[i]>=path.back()){\\n                used.insert(nums[i]);\\n                path.push_back(nums[i]);\\n                fun(nums,i+1,path,ans);\\n                path.pop_back();\\n            }\\n        }\\n    }\\n    \\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        vector<int>v;\\n        fun(nums, 0,v, ans);\\n        return ans;\\n    }\\n\\n  \\n};"
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "This medium level problems become an easy level problem, if it is understood well.\\nBacktracking solves this problem in the simplest manner.\\nUnderstand the approach here: https://youtu.be/WUsYiuuZICc"
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "At Each index, try both possibilities, take or not take the current element.\\n- Note: The subseq should maintain non-dec order."
                    }
                ]
            },
            {
                "id": 1766601,
                "content": [
                    {
                        "username": "Soham_Panchal",
                        "content": "Just keeping my Hash set and `nums` array identifier outside the functions increased my percentile to 74% from 19%. \\uD83D\\uDE2F"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nClick this link to Subscribe to my YouTube Channel https://tinyurl.com/4e2nj4vr\\n\\nhttps://youtu.be/S03sqmz2zX8"
                    },
                    {
                        "username": "shivam2612002",
                        "content": "can this be done using dp ? as we use dp in pick non-pick questions "
                    },
                    {
                        "username": "EricCLutts",
                        "content": "Whenever I ran into duplicates, I created a vector of vectors containing each possible value of them (so [..., 1, 1, 1, ...] became {{1}, {1, 1}, {1, 1, 1}} then appended each where valid onto previous vectors.\\nTime constraints not nearly as tight as some problems, had enough time at the end to run a sort + erase duplicates."
                    },
                    {
                        "username": "hiranmay1000",
                        "content": "Can it be solvable below O(n^2)?"
                    },
                    {
                        "username": "sudhakargoutam",
                        "content": "nope\\n"
                    },
                    {
                        "username": "vermani",
                        "content": "1. Find all subsequences of array using power set approach\\n2. store those subsequences in set so duplicates are discarded\\n3. iterate over the set and check if subsequence size is greater than 1 and if it is already sorted store it in return array (vector<vector<int>>) variable\\n4. return final array"
                    },
                    {
                        "username": "vikasanwla07",
                        "content": "class Solution {\\npublic:\\n    \\n    void fun(vector<int>&nums,int s,vector<int>&path,vector<vector<int>>&ans){\\n        if(path.size()>1)ans.push_back(path);\\n        set<int>used;\\n        for(int i = s;i<nums.size();i++){\\n            if(used.find(nums[i])!=used.end())continue;\\n            if(path.empty() or nums[i]>=path.back()){\\n                used.insert(nums[i]);\\n                path.push_back(nums[i]);\\n                fun(nums,i+1,path,ans);\\n                path.pop_back();\\n            }\\n        }\\n    }\\n    \\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        vector<int>v;\\n        fun(nums, 0,v, ans);\\n        return ans;\\n    }\\n\\n  \\n};"
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "This medium level problems become an easy level problem, if it is understood well.\\nBacktracking solves this problem in the simplest manner.\\nUnderstand the approach here: https://youtu.be/WUsYiuuZICc"
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "At Each index, try both possibilities, take or not take the current element.\\n- Note: The subseq should maintain non-dec order."
                    }
                ]
            },
            {
                "id": 1766435,
                "content": [
                    {
                        "username": "Soham_Panchal",
                        "content": "Just keeping my Hash set and `nums` array identifier outside the functions increased my percentile to 74% from 19%. \\uD83D\\uDE2F"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nClick this link to Subscribe to my YouTube Channel https://tinyurl.com/4e2nj4vr\\n\\nhttps://youtu.be/S03sqmz2zX8"
                    },
                    {
                        "username": "shivam2612002",
                        "content": "can this be done using dp ? as we use dp in pick non-pick questions "
                    },
                    {
                        "username": "EricCLutts",
                        "content": "Whenever I ran into duplicates, I created a vector of vectors containing each possible value of them (so [..., 1, 1, 1, ...] became {{1}, {1, 1}, {1, 1, 1}} then appended each where valid onto previous vectors.\\nTime constraints not nearly as tight as some problems, had enough time at the end to run a sort + erase duplicates."
                    },
                    {
                        "username": "hiranmay1000",
                        "content": "Can it be solvable below O(n^2)?"
                    },
                    {
                        "username": "sudhakargoutam",
                        "content": "nope\\n"
                    },
                    {
                        "username": "vermani",
                        "content": "1. Find all subsequences of array using power set approach\\n2. store those subsequences in set so duplicates are discarded\\n3. iterate over the set and check if subsequence size is greater than 1 and if it is already sorted store it in return array (vector<vector<int>>) variable\\n4. return final array"
                    },
                    {
                        "username": "vikasanwla07",
                        "content": "class Solution {\\npublic:\\n    \\n    void fun(vector<int>&nums,int s,vector<int>&path,vector<vector<int>>&ans){\\n        if(path.size()>1)ans.push_back(path);\\n        set<int>used;\\n        for(int i = s;i<nums.size();i++){\\n            if(used.find(nums[i])!=used.end())continue;\\n            if(path.empty() or nums[i]>=path.back()){\\n                used.insert(nums[i]);\\n                path.push_back(nums[i]);\\n                fun(nums,i+1,path,ans);\\n                path.pop_back();\\n            }\\n        }\\n    }\\n    \\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        vector<int>v;\\n        fun(nums, 0,v, ans);\\n        return ans;\\n    }\\n\\n  \\n};"
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "This medium level problems become an easy level problem, if it is understood well.\\nBacktracking solves this problem in the simplest manner.\\nUnderstand the approach here: https://youtu.be/WUsYiuuZICc"
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "At Each index, try both possibilities, take or not take the current element.\\n- Note: The subseq should maintain non-dec order."
                    }
                ]
            },
            {
                "id": 1766348,
                "content": [
                    {
                        "username": "Soham_Panchal",
                        "content": "Just keeping my Hash set and `nums` array identifier outside the functions increased my percentile to 74% from 19%. \\uD83D\\uDE2F"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nClick this link to Subscribe to my YouTube Channel https://tinyurl.com/4e2nj4vr\\n\\nhttps://youtu.be/S03sqmz2zX8"
                    },
                    {
                        "username": "shivam2612002",
                        "content": "can this be done using dp ? as we use dp in pick non-pick questions "
                    },
                    {
                        "username": "EricCLutts",
                        "content": "Whenever I ran into duplicates, I created a vector of vectors containing each possible value of them (so [..., 1, 1, 1, ...] became {{1}, {1, 1}, {1, 1, 1}} then appended each where valid onto previous vectors.\\nTime constraints not nearly as tight as some problems, had enough time at the end to run a sort + erase duplicates."
                    },
                    {
                        "username": "hiranmay1000",
                        "content": "Can it be solvable below O(n^2)?"
                    },
                    {
                        "username": "sudhakargoutam",
                        "content": "nope\\n"
                    },
                    {
                        "username": "vermani",
                        "content": "1. Find all subsequences of array using power set approach\\n2. store those subsequences in set so duplicates are discarded\\n3. iterate over the set and check if subsequence size is greater than 1 and if it is already sorted store it in return array (vector<vector<int>>) variable\\n4. return final array"
                    },
                    {
                        "username": "vikasanwla07",
                        "content": "class Solution {\\npublic:\\n    \\n    void fun(vector<int>&nums,int s,vector<int>&path,vector<vector<int>>&ans){\\n        if(path.size()>1)ans.push_back(path);\\n        set<int>used;\\n        for(int i = s;i<nums.size();i++){\\n            if(used.find(nums[i])!=used.end())continue;\\n            if(path.empty() or nums[i]>=path.back()){\\n                used.insert(nums[i]);\\n                path.push_back(nums[i]);\\n                fun(nums,i+1,path,ans);\\n                path.pop_back();\\n            }\\n        }\\n    }\\n    \\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        vector<int>v;\\n        fun(nums, 0,v, ans);\\n        return ans;\\n    }\\n\\n  \\n};"
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "This medium level problems become an easy level problem, if it is understood well.\\nBacktracking solves this problem in the simplest manner.\\nUnderstand the approach here: https://youtu.be/WUsYiuuZICc"
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "At Each index, try both possibilities, take or not take the current element.\\n- Note: The subseq should maintain non-dec order."
                    }
                ]
            },
            {
                "id": 1766212,
                "content": [
                    {
                        "username": "Soham_Panchal",
                        "content": "Just keeping my Hash set and `nums` array identifier outside the functions increased my percentile to 74% from 19%. \\uD83D\\uDE2F"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nClick this link to Subscribe to my YouTube Channel https://tinyurl.com/4e2nj4vr\\n\\nhttps://youtu.be/S03sqmz2zX8"
                    },
                    {
                        "username": "shivam2612002",
                        "content": "can this be done using dp ? as we use dp in pick non-pick questions "
                    },
                    {
                        "username": "EricCLutts",
                        "content": "Whenever I ran into duplicates, I created a vector of vectors containing each possible value of them (so [..., 1, 1, 1, ...] became {{1}, {1, 1}, {1, 1, 1}} then appended each where valid onto previous vectors.\\nTime constraints not nearly as tight as some problems, had enough time at the end to run a sort + erase duplicates."
                    },
                    {
                        "username": "hiranmay1000",
                        "content": "Can it be solvable below O(n^2)?"
                    },
                    {
                        "username": "sudhakargoutam",
                        "content": "nope\\n"
                    },
                    {
                        "username": "vermani",
                        "content": "1. Find all subsequences of array using power set approach\\n2. store those subsequences in set so duplicates are discarded\\n3. iterate over the set and check if subsequence size is greater than 1 and if it is already sorted store it in return array (vector<vector<int>>) variable\\n4. return final array"
                    },
                    {
                        "username": "vikasanwla07",
                        "content": "class Solution {\\npublic:\\n    \\n    void fun(vector<int>&nums,int s,vector<int>&path,vector<vector<int>>&ans){\\n        if(path.size()>1)ans.push_back(path);\\n        set<int>used;\\n        for(int i = s;i<nums.size();i++){\\n            if(used.find(nums[i])!=used.end())continue;\\n            if(path.empty() or nums[i]>=path.back()){\\n                used.insert(nums[i]);\\n                path.push_back(nums[i]);\\n                fun(nums,i+1,path,ans);\\n                path.pop_back();\\n            }\\n        }\\n    }\\n    \\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        vector<int>v;\\n        fun(nums, 0,v, ans);\\n        return ans;\\n    }\\n\\n  \\n};"
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "This medium level problems become an easy level problem, if it is understood well.\\nBacktracking solves this problem in the simplest manner.\\nUnderstand the approach here: https://youtu.be/WUsYiuuZICc"
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "At Each index, try both possibilities, take or not take the current element.\\n- Note: The subseq should maintain non-dec order."
                    }
                ]
            },
            {
                "id": 1766177,
                "content": [
                    {
                        "username": "Soham_Panchal",
                        "content": "Just keeping my Hash set and `nums` array identifier outside the functions increased my percentile to 74% from 19%. \\uD83D\\uDE2F"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nClick this link to Subscribe to my YouTube Channel https://tinyurl.com/4e2nj4vr\\n\\nhttps://youtu.be/S03sqmz2zX8"
                    },
                    {
                        "username": "shivam2612002",
                        "content": "can this be done using dp ? as we use dp in pick non-pick questions "
                    },
                    {
                        "username": "EricCLutts",
                        "content": "Whenever I ran into duplicates, I created a vector of vectors containing each possible value of them (so [..., 1, 1, 1, ...] became {{1}, {1, 1}, {1, 1, 1}} then appended each where valid onto previous vectors.\\nTime constraints not nearly as tight as some problems, had enough time at the end to run a sort + erase duplicates."
                    },
                    {
                        "username": "hiranmay1000",
                        "content": "Can it be solvable below O(n^2)?"
                    },
                    {
                        "username": "sudhakargoutam",
                        "content": "nope\\n"
                    },
                    {
                        "username": "vermani",
                        "content": "1. Find all subsequences of array using power set approach\\n2. store those subsequences in set so duplicates are discarded\\n3. iterate over the set and check if subsequence size is greater than 1 and if it is already sorted store it in return array (vector<vector<int>>) variable\\n4. return final array"
                    },
                    {
                        "username": "vikasanwla07",
                        "content": "class Solution {\\npublic:\\n    \\n    void fun(vector<int>&nums,int s,vector<int>&path,vector<vector<int>>&ans){\\n        if(path.size()>1)ans.push_back(path);\\n        set<int>used;\\n        for(int i = s;i<nums.size();i++){\\n            if(used.find(nums[i])!=used.end())continue;\\n            if(path.empty() or nums[i]>=path.back()){\\n                used.insert(nums[i]);\\n                path.push_back(nums[i]);\\n                fun(nums,i+1,path,ans);\\n                path.pop_back();\\n            }\\n        }\\n    }\\n    \\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        vector<int>v;\\n        fun(nums, 0,v, ans);\\n        return ans;\\n    }\\n\\n  \\n};"
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "This medium level problems become an easy level problem, if it is understood well.\\nBacktracking solves this problem in the simplest manner.\\nUnderstand the approach here: https://youtu.be/WUsYiuuZICc"
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "At Each index, try both possibilities, take or not take the current element.\\n- Note: The subseq should maintain non-dec order."
                    }
                ]
            },
            {
                "id": 1766120,
                "content": [
                    {
                        "username": "Soham_Panchal",
                        "content": "Just keeping my Hash set and `nums` array identifier outside the functions increased my percentile to 74% from 19%. \\uD83D\\uDE2F"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nClick this link to Subscribe to my YouTube Channel https://tinyurl.com/4e2nj4vr\\n\\nhttps://youtu.be/S03sqmz2zX8"
                    },
                    {
                        "username": "shivam2612002",
                        "content": "can this be done using dp ? as we use dp in pick non-pick questions "
                    },
                    {
                        "username": "EricCLutts",
                        "content": "Whenever I ran into duplicates, I created a vector of vectors containing each possible value of them (so [..., 1, 1, 1, ...] became {{1}, {1, 1}, {1, 1, 1}} then appended each where valid onto previous vectors.\\nTime constraints not nearly as tight as some problems, had enough time at the end to run a sort + erase duplicates."
                    },
                    {
                        "username": "hiranmay1000",
                        "content": "Can it be solvable below O(n^2)?"
                    },
                    {
                        "username": "sudhakargoutam",
                        "content": "nope\\n"
                    },
                    {
                        "username": "vermani",
                        "content": "1. Find all subsequences of array using power set approach\\n2. store those subsequences in set so duplicates are discarded\\n3. iterate over the set and check if subsequence size is greater than 1 and if it is already sorted store it in return array (vector<vector<int>>) variable\\n4. return final array"
                    },
                    {
                        "username": "vikasanwla07",
                        "content": "class Solution {\\npublic:\\n    \\n    void fun(vector<int>&nums,int s,vector<int>&path,vector<vector<int>>&ans){\\n        if(path.size()>1)ans.push_back(path);\\n        set<int>used;\\n        for(int i = s;i<nums.size();i++){\\n            if(used.find(nums[i])!=used.end())continue;\\n            if(path.empty() or nums[i]>=path.back()){\\n                used.insert(nums[i]);\\n                path.push_back(nums[i]);\\n                fun(nums,i+1,path,ans);\\n                path.pop_back();\\n            }\\n        }\\n    }\\n    \\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        vector<int>v;\\n        fun(nums, 0,v, ans);\\n        return ans;\\n    }\\n\\n  \\n};"
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "This medium level problems become an easy level problem, if it is understood well.\\nBacktracking solves this problem in the simplest manner.\\nUnderstand the approach here: https://youtu.be/WUsYiuuZICc"
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "At Each index, try both possibilities, take or not take the current element.\\n- Note: The subseq should maintain non-dec order."
                    }
                ]
            },
            {
                "id": 1765994,
                "content": [
                    {
                        "username": "piyush_chhawachharia",
                        "content": "Why is it showing TLE. I checked in some solutions and its working fine using recursion with other people?\n\n```\nclass Solution {\n    public List<List<Integer>> findSubsequences(int[] nums) {\n        List<Integer> li=new ArrayList<>();\n        List<List<Integer>> ans=new ArrayList<>();\n   \n        func(0,-1,nums,li,ans);\n        return ans;\n    }\n    public int func(int idx,int prev,int[] nums,List<Integer> li,List<List<Integer>> ans){\n        if(idx==nums.length){\n            if(!ans.contains(li) && li.size()>=2)\n            ans.add(new ArrayList<>(li));\n            return 0;\n        }\n        int op2=0;\n      \n        if(prev==-1 || nums[idx]>=nums[prev]){\n            li.add(nums[idx]);\n             op2=1+func(idx+1,idx,nums,li,ans);\n            li.remove(li.size()-1);\n        }\n         int op1=func(idx+1,prev,nums,li,ans);\n        return Math.max(op1,op2);\n    }\n}\n```"
                    },
                    {
                        "username": "piyush_chhawachharia",
                        "content": "[@imprayas12](/imprayas12) Thanks for Helping"
                    },
                    {
                        "username": "imprayas12",
                        "content": "the contains() method of java arraylist takes O(n) while in set it takes O(logn) at worst and average case -> O(1)"
                    },
                    {
                        "username": "bhaveshgarg2000",
                        "content": "Array Week I Like It \\uD83D\\uDE0D"
                    },
                    {
                        "username": "safal19",
                        "content": "Solution easy with explaination: [leetcode](https://leetcode.com/problems/non-decreasing-subsequences/solutions/3075488/easy-explaination-easiest-java-solution-using-recursion/)"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Is the backtracking solution taking O(2^n * n^2) time.\\nIn what conditions will the TC be O(2^n * n) ?"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "4 steps:\n1. get all subsequences\n2. only take the subsequences of size >=2\n4. find a way to sort them in increasing order\n4. eliminate duplicates\n\nsolution: https://leetcode.com/problems/non-decreasing-subsequences/solutions/3075203/java-simple-backtracking-solution/"
                    },
                    {
                        "username": "dollysingh",
                        "content": "Hint:\\n\\n1. Pick the current element\\n2. Not Pick the current element and simply move to next index.\\n\\nSince the constraint\\'s are small O(2^n) solution will pass.\\n\\nHave a great Day, see you tomorrow!!"
                    },
                    {
                        "username": "harshcodes04",
                        "content": "[@shadab-malik](/shadab-malik) Use a set to to prevent adding duplicate elements while traverse i.e. ( used = set() ; if nums[i] in used: continue )"
                    },
                    {
                        "username": "shadab-malik",
                        "content": "I\\'m getting duplicates in my answer why so??"
                    },
                    {
                        "username": "user8228j",
                        "content": "I thought for sure I would\\'ve gotten TLE but guess not. Nearly-Brute force DP works."
                    },
                    {
                        "username": "Panda_2397",
                        "content": "similar to \\'find combination\\'"
                    },
                    {
                        "username": "jeevankumar159",
                        "content": "A different approach to keep the array and hashSet out of the recursive function. https://youtu.be/b3z5g_ORbpI what do you guys think?"
                    },
                    {
                        "username": "Shreyash_Yadav",
                        "content": "Here we go again to master the Arrays"
                    }
                ]
            },
            {
                "id": 1765981,
                "content": [
                    {
                        "username": "piyush_chhawachharia",
                        "content": "Why is it showing TLE. I checked in some solutions and its working fine using recursion with other people?\n\n```\nclass Solution {\n    public List<List<Integer>> findSubsequences(int[] nums) {\n        List<Integer> li=new ArrayList<>();\n        List<List<Integer>> ans=new ArrayList<>();\n   \n        func(0,-1,nums,li,ans);\n        return ans;\n    }\n    public int func(int idx,int prev,int[] nums,List<Integer> li,List<List<Integer>> ans){\n        if(idx==nums.length){\n            if(!ans.contains(li) && li.size()>=2)\n            ans.add(new ArrayList<>(li));\n            return 0;\n        }\n        int op2=0;\n      \n        if(prev==-1 || nums[idx]>=nums[prev]){\n            li.add(nums[idx]);\n             op2=1+func(idx+1,idx,nums,li,ans);\n            li.remove(li.size()-1);\n        }\n         int op1=func(idx+1,prev,nums,li,ans);\n        return Math.max(op1,op2);\n    }\n}\n```"
                    },
                    {
                        "username": "piyush_chhawachharia",
                        "content": "[@imprayas12](/imprayas12) Thanks for Helping"
                    },
                    {
                        "username": "imprayas12",
                        "content": "the contains() method of java arraylist takes O(n) while in set it takes O(logn) at worst and average case -> O(1)"
                    },
                    {
                        "username": "bhaveshgarg2000",
                        "content": "Array Week I Like It \\uD83D\\uDE0D"
                    },
                    {
                        "username": "safal19",
                        "content": "Solution easy with explaination: [leetcode](https://leetcode.com/problems/non-decreasing-subsequences/solutions/3075488/easy-explaination-easiest-java-solution-using-recursion/)"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Is the backtracking solution taking O(2^n * n^2) time.\\nIn what conditions will the TC be O(2^n * n) ?"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "4 steps:\n1. get all subsequences\n2. only take the subsequences of size >=2\n4. find a way to sort them in increasing order\n4. eliminate duplicates\n\nsolution: https://leetcode.com/problems/non-decreasing-subsequences/solutions/3075203/java-simple-backtracking-solution/"
                    },
                    {
                        "username": "dollysingh",
                        "content": "Hint:\\n\\n1. Pick the current element\\n2. Not Pick the current element and simply move to next index.\\n\\nSince the constraint\\'s are small O(2^n) solution will pass.\\n\\nHave a great Day, see you tomorrow!!"
                    },
                    {
                        "username": "harshcodes04",
                        "content": "[@shadab-malik](/shadab-malik) Use a set to to prevent adding duplicate elements while traverse i.e. ( used = set() ; if nums[i] in used: continue )"
                    },
                    {
                        "username": "shadab-malik",
                        "content": "I\\'m getting duplicates in my answer why so??"
                    },
                    {
                        "username": "user8228j",
                        "content": "I thought for sure I would\\'ve gotten TLE but guess not. Nearly-Brute force DP works."
                    },
                    {
                        "username": "Panda_2397",
                        "content": "similar to \\'find combination\\'"
                    },
                    {
                        "username": "jeevankumar159",
                        "content": "A different approach to keep the array and hashSet out of the recursive function. https://youtu.be/b3z5g_ORbpI what do you guys think?"
                    },
                    {
                        "username": "Shreyash_Yadav",
                        "content": "Here we go again to master the Arrays"
                    }
                ]
            },
            {
                "id": 1765918,
                "content": [
                    {
                        "username": "piyush_chhawachharia",
                        "content": "Why is it showing TLE. I checked in some solutions and its working fine using recursion with other people?\n\n```\nclass Solution {\n    public List<List<Integer>> findSubsequences(int[] nums) {\n        List<Integer> li=new ArrayList<>();\n        List<List<Integer>> ans=new ArrayList<>();\n   \n        func(0,-1,nums,li,ans);\n        return ans;\n    }\n    public int func(int idx,int prev,int[] nums,List<Integer> li,List<List<Integer>> ans){\n        if(idx==nums.length){\n            if(!ans.contains(li) && li.size()>=2)\n            ans.add(new ArrayList<>(li));\n            return 0;\n        }\n        int op2=0;\n      \n        if(prev==-1 || nums[idx]>=nums[prev]){\n            li.add(nums[idx]);\n             op2=1+func(idx+1,idx,nums,li,ans);\n            li.remove(li.size()-1);\n        }\n         int op1=func(idx+1,prev,nums,li,ans);\n        return Math.max(op1,op2);\n    }\n}\n```"
                    },
                    {
                        "username": "piyush_chhawachharia",
                        "content": "[@imprayas12](/imprayas12) Thanks for Helping"
                    },
                    {
                        "username": "imprayas12",
                        "content": "the contains() method of java arraylist takes O(n) while in set it takes O(logn) at worst and average case -> O(1)"
                    },
                    {
                        "username": "bhaveshgarg2000",
                        "content": "Array Week I Like It \\uD83D\\uDE0D"
                    },
                    {
                        "username": "safal19",
                        "content": "Solution easy with explaination: [leetcode](https://leetcode.com/problems/non-decreasing-subsequences/solutions/3075488/easy-explaination-easiest-java-solution-using-recursion/)"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Is the backtracking solution taking O(2^n * n^2) time.\\nIn what conditions will the TC be O(2^n * n) ?"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "4 steps:\n1. get all subsequences\n2. only take the subsequences of size >=2\n4. find a way to sort them in increasing order\n4. eliminate duplicates\n\nsolution: https://leetcode.com/problems/non-decreasing-subsequences/solutions/3075203/java-simple-backtracking-solution/"
                    },
                    {
                        "username": "dollysingh",
                        "content": "Hint:\\n\\n1. Pick the current element\\n2. Not Pick the current element and simply move to next index.\\n\\nSince the constraint\\'s are small O(2^n) solution will pass.\\n\\nHave a great Day, see you tomorrow!!"
                    },
                    {
                        "username": "harshcodes04",
                        "content": "[@shadab-malik](/shadab-malik) Use a set to to prevent adding duplicate elements while traverse i.e. ( used = set() ; if nums[i] in used: continue )"
                    },
                    {
                        "username": "shadab-malik",
                        "content": "I\\'m getting duplicates in my answer why so??"
                    },
                    {
                        "username": "user8228j",
                        "content": "I thought for sure I would\\'ve gotten TLE but guess not. Nearly-Brute force DP works."
                    },
                    {
                        "username": "Panda_2397",
                        "content": "similar to \\'find combination\\'"
                    },
                    {
                        "username": "jeevankumar159",
                        "content": "A different approach to keep the array and hashSet out of the recursive function. https://youtu.be/b3z5g_ORbpI what do you guys think?"
                    },
                    {
                        "username": "Shreyash_Yadav",
                        "content": "Here we go again to master the Arrays"
                    }
                ]
            },
            {
                "id": 1765796,
                "content": [
                    {
                        "username": "piyush_chhawachharia",
                        "content": "Why is it showing TLE. I checked in some solutions and its working fine using recursion with other people?\n\n```\nclass Solution {\n    public List<List<Integer>> findSubsequences(int[] nums) {\n        List<Integer> li=new ArrayList<>();\n        List<List<Integer>> ans=new ArrayList<>();\n   \n        func(0,-1,nums,li,ans);\n        return ans;\n    }\n    public int func(int idx,int prev,int[] nums,List<Integer> li,List<List<Integer>> ans){\n        if(idx==nums.length){\n            if(!ans.contains(li) && li.size()>=2)\n            ans.add(new ArrayList<>(li));\n            return 0;\n        }\n        int op2=0;\n      \n        if(prev==-1 || nums[idx]>=nums[prev]){\n            li.add(nums[idx]);\n             op2=1+func(idx+1,idx,nums,li,ans);\n            li.remove(li.size()-1);\n        }\n         int op1=func(idx+1,prev,nums,li,ans);\n        return Math.max(op1,op2);\n    }\n}\n```"
                    },
                    {
                        "username": "piyush_chhawachharia",
                        "content": "[@imprayas12](/imprayas12) Thanks for Helping"
                    },
                    {
                        "username": "imprayas12",
                        "content": "the contains() method of java arraylist takes O(n) while in set it takes O(logn) at worst and average case -> O(1)"
                    },
                    {
                        "username": "bhaveshgarg2000",
                        "content": "Array Week I Like It \\uD83D\\uDE0D"
                    },
                    {
                        "username": "safal19",
                        "content": "Solution easy with explaination: [leetcode](https://leetcode.com/problems/non-decreasing-subsequences/solutions/3075488/easy-explaination-easiest-java-solution-using-recursion/)"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Is the backtracking solution taking O(2^n * n^2) time.\\nIn what conditions will the TC be O(2^n * n) ?"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "4 steps:\n1. get all subsequences\n2. only take the subsequences of size >=2\n4. find a way to sort them in increasing order\n4. eliminate duplicates\n\nsolution: https://leetcode.com/problems/non-decreasing-subsequences/solutions/3075203/java-simple-backtracking-solution/"
                    },
                    {
                        "username": "dollysingh",
                        "content": "Hint:\\n\\n1. Pick the current element\\n2. Not Pick the current element and simply move to next index.\\n\\nSince the constraint\\'s are small O(2^n) solution will pass.\\n\\nHave a great Day, see you tomorrow!!"
                    },
                    {
                        "username": "harshcodes04",
                        "content": "[@shadab-malik](/shadab-malik) Use a set to to prevent adding duplicate elements while traverse i.e. ( used = set() ; if nums[i] in used: continue )"
                    },
                    {
                        "username": "shadab-malik",
                        "content": "I\\'m getting duplicates in my answer why so??"
                    },
                    {
                        "username": "user8228j",
                        "content": "I thought for sure I would\\'ve gotten TLE but guess not. Nearly-Brute force DP works."
                    },
                    {
                        "username": "Panda_2397",
                        "content": "similar to \\'find combination\\'"
                    },
                    {
                        "username": "jeevankumar159",
                        "content": "A different approach to keep the array and hashSet out of the recursive function. https://youtu.be/b3z5g_ORbpI what do you guys think?"
                    },
                    {
                        "username": "Shreyash_Yadav",
                        "content": "Here we go again to master the Arrays"
                    }
                ]
            },
            {
                "id": 1765788,
                "content": [
                    {
                        "username": "piyush_chhawachharia",
                        "content": "Why is it showing TLE. I checked in some solutions and its working fine using recursion with other people?\n\n```\nclass Solution {\n    public List<List<Integer>> findSubsequences(int[] nums) {\n        List<Integer> li=new ArrayList<>();\n        List<List<Integer>> ans=new ArrayList<>();\n   \n        func(0,-1,nums,li,ans);\n        return ans;\n    }\n    public int func(int idx,int prev,int[] nums,List<Integer> li,List<List<Integer>> ans){\n        if(idx==nums.length){\n            if(!ans.contains(li) && li.size()>=2)\n            ans.add(new ArrayList<>(li));\n            return 0;\n        }\n        int op2=0;\n      \n        if(prev==-1 || nums[idx]>=nums[prev]){\n            li.add(nums[idx]);\n             op2=1+func(idx+1,idx,nums,li,ans);\n            li.remove(li.size()-1);\n        }\n         int op1=func(idx+1,prev,nums,li,ans);\n        return Math.max(op1,op2);\n    }\n}\n```"
                    },
                    {
                        "username": "piyush_chhawachharia",
                        "content": "[@imprayas12](/imprayas12) Thanks for Helping"
                    },
                    {
                        "username": "imprayas12",
                        "content": "the contains() method of java arraylist takes O(n) while in set it takes O(logn) at worst and average case -> O(1)"
                    },
                    {
                        "username": "bhaveshgarg2000",
                        "content": "Array Week I Like It \\uD83D\\uDE0D"
                    },
                    {
                        "username": "safal19",
                        "content": "Solution easy with explaination: [leetcode](https://leetcode.com/problems/non-decreasing-subsequences/solutions/3075488/easy-explaination-easiest-java-solution-using-recursion/)"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Is the backtracking solution taking O(2^n * n^2) time.\\nIn what conditions will the TC be O(2^n * n) ?"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "4 steps:\n1. get all subsequences\n2. only take the subsequences of size >=2\n4. find a way to sort them in increasing order\n4. eliminate duplicates\n\nsolution: https://leetcode.com/problems/non-decreasing-subsequences/solutions/3075203/java-simple-backtracking-solution/"
                    },
                    {
                        "username": "dollysingh",
                        "content": "Hint:\\n\\n1. Pick the current element\\n2. Not Pick the current element and simply move to next index.\\n\\nSince the constraint\\'s are small O(2^n) solution will pass.\\n\\nHave a great Day, see you tomorrow!!"
                    },
                    {
                        "username": "harshcodes04",
                        "content": "[@shadab-malik](/shadab-malik) Use a set to to prevent adding duplicate elements while traverse i.e. ( used = set() ; if nums[i] in used: continue )"
                    },
                    {
                        "username": "shadab-malik",
                        "content": "I\\'m getting duplicates in my answer why so??"
                    },
                    {
                        "username": "user8228j",
                        "content": "I thought for sure I would\\'ve gotten TLE but guess not. Nearly-Brute force DP works."
                    },
                    {
                        "username": "Panda_2397",
                        "content": "similar to \\'find combination\\'"
                    },
                    {
                        "username": "jeevankumar159",
                        "content": "A different approach to keep the array and hashSet out of the recursive function. https://youtu.be/b3z5g_ORbpI what do you guys think?"
                    },
                    {
                        "username": "Shreyash_Yadav",
                        "content": "Here we go again to master the Arrays"
                    }
                ]
            },
            {
                "id": 1765755,
                "content": [
                    {
                        "username": "piyush_chhawachharia",
                        "content": "Why is it showing TLE. I checked in some solutions and its working fine using recursion with other people?\n\n```\nclass Solution {\n    public List<List<Integer>> findSubsequences(int[] nums) {\n        List<Integer> li=new ArrayList<>();\n        List<List<Integer>> ans=new ArrayList<>();\n   \n        func(0,-1,nums,li,ans);\n        return ans;\n    }\n    public int func(int idx,int prev,int[] nums,List<Integer> li,List<List<Integer>> ans){\n        if(idx==nums.length){\n            if(!ans.contains(li) && li.size()>=2)\n            ans.add(new ArrayList<>(li));\n            return 0;\n        }\n        int op2=0;\n      \n        if(prev==-1 || nums[idx]>=nums[prev]){\n            li.add(nums[idx]);\n             op2=1+func(idx+1,idx,nums,li,ans);\n            li.remove(li.size()-1);\n        }\n         int op1=func(idx+1,prev,nums,li,ans);\n        return Math.max(op1,op2);\n    }\n}\n```"
                    },
                    {
                        "username": "piyush_chhawachharia",
                        "content": "[@imprayas12](/imprayas12) Thanks for Helping"
                    },
                    {
                        "username": "imprayas12",
                        "content": "the contains() method of java arraylist takes O(n) while in set it takes O(logn) at worst and average case -> O(1)"
                    },
                    {
                        "username": "bhaveshgarg2000",
                        "content": "Array Week I Like It \\uD83D\\uDE0D"
                    },
                    {
                        "username": "safal19",
                        "content": "Solution easy with explaination: [leetcode](https://leetcode.com/problems/non-decreasing-subsequences/solutions/3075488/easy-explaination-easiest-java-solution-using-recursion/)"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Is the backtracking solution taking O(2^n * n^2) time.\\nIn what conditions will the TC be O(2^n * n) ?"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "4 steps:\n1. get all subsequences\n2. only take the subsequences of size >=2\n4. find a way to sort them in increasing order\n4. eliminate duplicates\n\nsolution: https://leetcode.com/problems/non-decreasing-subsequences/solutions/3075203/java-simple-backtracking-solution/"
                    },
                    {
                        "username": "dollysingh",
                        "content": "Hint:\\n\\n1. Pick the current element\\n2. Not Pick the current element and simply move to next index.\\n\\nSince the constraint\\'s are small O(2^n) solution will pass.\\n\\nHave a great Day, see you tomorrow!!"
                    },
                    {
                        "username": "harshcodes04",
                        "content": "[@shadab-malik](/shadab-malik) Use a set to to prevent adding duplicate elements while traverse i.e. ( used = set() ; if nums[i] in used: continue )"
                    },
                    {
                        "username": "shadab-malik",
                        "content": "I\\'m getting duplicates in my answer why so??"
                    },
                    {
                        "username": "user8228j",
                        "content": "I thought for sure I would\\'ve gotten TLE but guess not. Nearly-Brute force DP works."
                    },
                    {
                        "username": "Panda_2397",
                        "content": "similar to \\'find combination\\'"
                    },
                    {
                        "username": "jeevankumar159",
                        "content": "A different approach to keep the array and hashSet out of the recursive function. https://youtu.be/b3z5g_ORbpI what do you guys think?"
                    },
                    {
                        "username": "Shreyash_Yadav",
                        "content": "Here we go again to master the Arrays"
                    }
                ]
            },
            {
                "id": 1765743,
                "content": [
                    {
                        "username": "piyush_chhawachharia",
                        "content": "Why is it showing TLE. I checked in some solutions and its working fine using recursion with other people?\n\n```\nclass Solution {\n    public List<List<Integer>> findSubsequences(int[] nums) {\n        List<Integer> li=new ArrayList<>();\n        List<List<Integer>> ans=new ArrayList<>();\n   \n        func(0,-1,nums,li,ans);\n        return ans;\n    }\n    public int func(int idx,int prev,int[] nums,List<Integer> li,List<List<Integer>> ans){\n        if(idx==nums.length){\n            if(!ans.contains(li) && li.size()>=2)\n            ans.add(new ArrayList<>(li));\n            return 0;\n        }\n        int op2=0;\n      \n        if(prev==-1 || nums[idx]>=nums[prev]){\n            li.add(nums[idx]);\n             op2=1+func(idx+1,idx,nums,li,ans);\n            li.remove(li.size()-1);\n        }\n         int op1=func(idx+1,prev,nums,li,ans);\n        return Math.max(op1,op2);\n    }\n}\n```"
                    },
                    {
                        "username": "piyush_chhawachharia",
                        "content": "[@imprayas12](/imprayas12) Thanks for Helping"
                    },
                    {
                        "username": "imprayas12",
                        "content": "the contains() method of java arraylist takes O(n) while in set it takes O(logn) at worst and average case -> O(1)"
                    },
                    {
                        "username": "bhaveshgarg2000",
                        "content": "Array Week I Like It \\uD83D\\uDE0D"
                    },
                    {
                        "username": "safal19",
                        "content": "Solution easy with explaination: [leetcode](https://leetcode.com/problems/non-decreasing-subsequences/solutions/3075488/easy-explaination-easiest-java-solution-using-recursion/)"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Is the backtracking solution taking O(2^n * n^2) time.\\nIn what conditions will the TC be O(2^n * n) ?"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "4 steps:\n1. get all subsequences\n2. only take the subsequences of size >=2\n4. find a way to sort them in increasing order\n4. eliminate duplicates\n\nsolution: https://leetcode.com/problems/non-decreasing-subsequences/solutions/3075203/java-simple-backtracking-solution/"
                    },
                    {
                        "username": "dollysingh",
                        "content": "Hint:\\n\\n1. Pick the current element\\n2. Not Pick the current element and simply move to next index.\\n\\nSince the constraint\\'s are small O(2^n) solution will pass.\\n\\nHave a great Day, see you tomorrow!!"
                    },
                    {
                        "username": "harshcodes04",
                        "content": "[@shadab-malik](/shadab-malik) Use a set to to prevent adding duplicate elements while traverse i.e. ( used = set() ; if nums[i] in used: continue )"
                    },
                    {
                        "username": "shadab-malik",
                        "content": "I\\'m getting duplicates in my answer why so??"
                    },
                    {
                        "username": "user8228j",
                        "content": "I thought for sure I would\\'ve gotten TLE but guess not. Nearly-Brute force DP works."
                    },
                    {
                        "username": "Panda_2397",
                        "content": "similar to \\'find combination\\'"
                    },
                    {
                        "username": "jeevankumar159",
                        "content": "A different approach to keep the array and hashSet out of the recursive function. https://youtu.be/b3z5g_ORbpI what do you guys think?"
                    },
                    {
                        "username": "Shreyash_Yadav",
                        "content": "Here we go again to master the Arrays"
                    }
                ]
            },
            {
                "id": 1765725,
                "content": [
                    {
                        "username": "piyush_chhawachharia",
                        "content": "Why is it showing TLE. I checked in some solutions and its working fine using recursion with other people?\n\n```\nclass Solution {\n    public List<List<Integer>> findSubsequences(int[] nums) {\n        List<Integer> li=new ArrayList<>();\n        List<List<Integer>> ans=new ArrayList<>();\n   \n        func(0,-1,nums,li,ans);\n        return ans;\n    }\n    public int func(int idx,int prev,int[] nums,List<Integer> li,List<List<Integer>> ans){\n        if(idx==nums.length){\n            if(!ans.contains(li) && li.size()>=2)\n            ans.add(new ArrayList<>(li));\n            return 0;\n        }\n        int op2=0;\n      \n        if(prev==-1 || nums[idx]>=nums[prev]){\n            li.add(nums[idx]);\n             op2=1+func(idx+1,idx,nums,li,ans);\n            li.remove(li.size()-1);\n        }\n         int op1=func(idx+1,prev,nums,li,ans);\n        return Math.max(op1,op2);\n    }\n}\n```"
                    },
                    {
                        "username": "piyush_chhawachharia",
                        "content": "[@imprayas12](/imprayas12) Thanks for Helping"
                    },
                    {
                        "username": "imprayas12",
                        "content": "the contains() method of java arraylist takes O(n) while in set it takes O(logn) at worst and average case -> O(1)"
                    },
                    {
                        "username": "bhaveshgarg2000",
                        "content": "Array Week I Like It \\uD83D\\uDE0D"
                    },
                    {
                        "username": "safal19",
                        "content": "Solution easy with explaination: [leetcode](https://leetcode.com/problems/non-decreasing-subsequences/solutions/3075488/easy-explaination-easiest-java-solution-using-recursion/)"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Is the backtracking solution taking O(2^n * n^2) time.\\nIn what conditions will the TC be O(2^n * n) ?"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "4 steps:\n1. get all subsequences\n2. only take the subsequences of size >=2\n4. find a way to sort them in increasing order\n4. eliminate duplicates\n\nsolution: https://leetcode.com/problems/non-decreasing-subsequences/solutions/3075203/java-simple-backtracking-solution/"
                    },
                    {
                        "username": "dollysingh",
                        "content": "Hint:\\n\\n1. Pick the current element\\n2. Not Pick the current element and simply move to next index.\\n\\nSince the constraint\\'s are small O(2^n) solution will pass.\\n\\nHave a great Day, see you tomorrow!!"
                    },
                    {
                        "username": "harshcodes04",
                        "content": "[@shadab-malik](/shadab-malik) Use a set to to prevent adding duplicate elements while traverse i.e. ( used = set() ; if nums[i] in used: continue )"
                    },
                    {
                        "username": "shadab-malik",
                        "content": "I\\'m getting duplicates in my answer why so??"
                    },
                    {
                        "username": "user8228j",
                        "content": "I thought for sure I would\\'ve gotten TLE but guess not. Nearly-Brute force DP works."
                    },
                    {
                        "username": "Panda_2397",
                        "content": "similar to \\'find combination\\'"
                    },
                    {
                        "username": "jeevankumar159",
                        "content": "A different approach to keep the array and hashSet out of the recursive function. https://youtu.be/b3z5g_ORbpI what do you guys think?"
                    },
                    {
                        "username": "Shreyash_Yadav",
                        "content": "Here we go again to master the Arrays"
                    }
                ]
            },
            {
                "id": 1765642,
                "content": [
                    {
                        "username": "piyush_chhawachharia",
                        "content": "Why is it showing TLE. I checked in some solutions and its working fine using recursion with other people?\n\n```\nclass Solution {\n    public List<List<Integer>> findSubsequences(int[] nums) {\n        List<Integer> li=new ArrayList<>();\n        List<List<Integer>> ans=new ArrayList<>();\n   \n        func(0,-1,nums,li,ans);\n        return ans;\n    }\n    public int func(int idx,int prev,int[] nums,List<Integer> li,List<List<Integer>> ans){\n        if(idx==nums.length){\n            if(!ans.contains(li) && li.size()>=2)\n            ans.add(new ArrayList<>(li));\n            return 0;\n        }\n        int op2=0;\n      \n        if(prev==-1 || nums[idx]>=nums[prev]){\n            li.add(nums[idx]);\n             op2=1+func(idx+1,idx,nums,li,ans);\n            li.remove(li.size()-1);\n        }\n         int op1=func(idx+1,prev,nums,li,ans);\n        return Math.max(op1,op2);\n    }\n}\n```"
                    },
                    {
                        "username": "piyush_chhawachharia",
                        "content": "[@imprayas12](/imprayas12) Thanks for Helping"
                    },
                    {
                        "username": "imprayas12",
                        "content": "the contains() method of java arraylist takes O(n) while in set it takes O(logn) at worst and average case -> O(1)"
                    },
                    {
                        "username": "bhaveshgarg2000",
                        "content": "Array Week I Like It \\uD83D\\uDE0D"
                    },
                    {
                        "username": "safal19",
                        "content": "Solution easy with explaination: [leetcode](https://leetcode.com/problems/non-decreasing-subsequences/solutions/3075488/easy-explaination-easiest-java-solution-using-recursion/)"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Is the backtracking solution taking O(2^n * n^2) time.\\nIn what conditions will the TC be O(2^n * n) ?"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "4 steps:\n1. get all subsequences\n2. only take the subsequences of size >=2\n4. find a way to sort them in increasing order\n4. eliminate duplicates\n\nsolution: https://leetcode.com/problems/non-decreasing-subsequences/solutions/3075203/java-simple-backtracking-solution/"
                    },
                    {
                        "username": "dollysingh",
                        "content": "Hint:\\n\\n1. Pick the current element\\n2. Not Pick the current element and simply move to next index.\\n\\nSince the constraint\\'s are small O(2^n) solution will pass.\\n\\nHave a great Day, see you tomorrow!!"
                    },
                    {
                        "username": "harshcodes04",
                        "content": "[@shadab-malik](/shadab-malik) Use a set to to prevent adding duplicate elements while traverse i.e. ( used = set() ; if nums[i] in used: continue )"
                    },
                    {
                        "username": "shadab-malik",
                        "content": "I\\'m getting duplicates in my answer why so??"
                    },
                    {
                        "username": "user8228j",
                        "content": "I thought for sure I would\\'ve gotten TLE but guess not. Nearly-Brute force DP works."
                    },
                    {
                        "username": "Panda_2397",
                        "content": "similar to \\'find combination\\'"
                    },
                    {
                        "username": "jeevankumar159",
                        "content": "A different approach to keep the array and hashSet out of the recursive function. https://youtu.be/b3z5g_ORbpI what do you guys think?"
                    },
                    {
                        "username": "Shreyash_Yadav",
                        "content": "Here we go again to master the Arrays"
                    }
                ]
            },
            {
                "id": 1765632,
                "content": [
                    {
                        "username": "piyush_chhawachharia",
                        "content": "Why is it showing TLE. I checked in some solutions and its working fine using recursion with other people?\n\n```\nclass Solution {\n    public List<List<Integer>> findSubsequences(int[] nums) {\n        List<Integer> li=new ArrayList<>();\n        List<List<Integer>> ans=new ArrayList<>();\n   \n        func(0,-1,nums,li,ans);\n        return ans;\n    }\n    public int func(int idx,int prev,int[] nums,List<Integer> li,List<List<Integer>> ans){\n        if(idx==nums.length){\n            if(!ans.contains(li) && li.size()>=2)\n            ans.add(new ArrayList<>(li));\n            return 0;\n        }\n        int op2=0;\n      \n        if(prev==-1 || nums[idx]>=nums[prev]){\n            li.add(nums[idx]);\n             op2=1+func(idx+1,idx,nums,li,ans);\n            li.remove(li.size()-1);\n        }\n         int op1=func(idx+1,prev,nums,li,ans);\n        return Math.max(op1,op2);\n    }\n}\n```"
                    },
                    {
                        "username": "piyush_chhawachharia",
                        "content": "[@imprayas12](/imprayas12) Thanks for Helping"
                    },
                    {
                        "username": "imprayas12",
                        "content": "the contains() method of java arraylist takes O(n) while in set it takes O(logn) at worst and average case -> O(1)"
                    },
                    {
                        "username": "bhaveshgarg2000",
                        "content": "Array Week I Like It \\uD83D\\uDE0D"
                    },
                    {
                        "username": "safal19",
                        "content": "Solution easy with explaination: [leetcode](https://leetcode.com/problems/non-decreasing-subsequences/solutions/3075488/easy-explaination-easiest-java-solution-using-recursion/)"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Is the backtracking solution taking O(2^n * n^2) time.\\nIn what conditions will the TC be O(2^n * n) ?"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "4 steps:\n1. get all subsequences\n2. only take the subsequences of size >=2\n4. find a way to sort them in increasing order\n4. eliminate duplicates\n\nsolution: https://leetcode.com/problems/non-decreasing-subsequences/solutions/3075203/java-simple-backtracking-solution/"
                    },
                    {
                        "username": "dollysingh",
                        "content": "Hint:\\n\\n1. Pick the current element\\n2. Not Pick the current element and simply move to next index.\\n\\nSince the constraint\\'s are small O(2^n) solution will pass.\\n\\nHave a great Day, see you tomorrow!!"
                    },
                    {
                        "username": "harshcodes04",
                        "content": "[@shadab-malik](/shadab-malik) Use a set to to prevent adding duplicate elements while traverse i.e. ( used = set() ; if nums[i] in used: continue )"
                    },
                    {
                        "username": "shadab-malik",
                        "content": "I\\'m getting duplicates in my answer why so??"
                    },
                    {
                        "username": "user8228j",
                        "content": "I thought for sure I would\\'ve gotten TLE but guess not. Nearly-Brute force DP works."
                    },
                    {
                        "username": "Panda_2397",
                        "content": "similar to \\'find combination\\'"
                    },
                    {
                        "username": "jeevankumar159",
                        "content": "A different approach to keep the array and hashSet out of the recursive function. https://youtu.be/b3z5g_ORbpI what do you guys think?"
                    },
                    {
                        "username": "Shreyash_Yadav",
                        "content": "Here we go again to master the Arrays"
                    }
                ]
            }
        ]
    }
]