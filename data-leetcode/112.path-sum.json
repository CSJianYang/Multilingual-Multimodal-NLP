[
    {
        "title": "Integer to Roman",
        "question_content": "Roman numerals are represented by seven different symbols:&nbsp;I, V, X, L, C, D and M.\n\nSymbol       Value\nI             1\nV             5\nX             10\nL             50\nC             100\nD             500\nM             1000\nFor example,&nbsp;2 is written as II&nbsp;in Roman numeral, just two one's added together. 12 is written as&nbsp;XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.\nRoman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:\n\n\tI can be placed before V (5) and X (10) to make 4 and 9.&nbsp;\n\tX can be placed before L (50) and C (100) to make 40 and 90.&nbsp;\n\tC can be placed before D (500) and M (1000) to make 400 and 900.\n\nGiven an integer, convert it to a roman numeral.\n&nbsp;\nExample 1:\n\nInput: num = 3\nOutput: \"III\"\nExplanation: 3 is represented as 3 ones.\n\nExample 2:\n\nInput: num = 58\nOutput: \"LVIII\"\nExplanation: L = 50, V = 5, III = 3.\n\nExample 3:\n\nInput: num = 1994\nOutput: \"MCMXCIV\"\nExplanation: M = 1000, CM = 900, XC = 90 and IV = 4.\n\n&nbsp;\nConstraints:\n\n\t1 <= num <= 3999",
        "solutions": [
            {
                "id": 6274,
                "title": "simple-solution",
                "content": "```\\npublic static String intToRoman(int num) {\\n    String M[] = {\"\", \"M\", \"MM\", \"MMM\"};\\n    String C[] = {\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"};\\n    String X[] = {\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"};\\n    String I[] = {\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"};\\n    return M[num/1000] + C[(num%1000)/100] + X[(num%100)/10] + I[num%10];\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic static String intToRoman(int num) {\\n    String M[] = {\"\", \"M\", \"MM\", \"MMM\"};\\n    String C[] = {\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"};\\n    String X[] = {\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"};\\n    String I[] = {\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"};\\n    return M[num/1000] + C[(num%1000)/100] + X[(num%100)/10] + I[num%10];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 6310,
                "title": "my-java-solution-easy-to-understand",
                "content": "Reference:\\nhttp://blog.csdn.net/beiyeqingteng/article/details/8547565\\n\\npublic class Solution {\\n    public String intToRoman(int num) {\\n        \\n        int[] values = {1000,900,500,400,100,90,50,40,10,9,5,4,1};\\n        String[] strs = {\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\\n        \\n        StringBuilder sb = new StringBuilder();\\n        \\n        for(int i=0;i<values.length;i++) {\\n            while(num >= values[i]) {\\n                num -= values[i];\\n                sb.append(strs[i]);\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public String intToRoman(int num) {\\n        \\n        int[] values = {1000,900,500,400,100,90,50,40,10,9,5,4,1}",
                "codeTag": "Java"
            },
            {
                "id": 1293176,
                "title": "c-easy-solution-o-1",
                "content": "```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string ones[] = {\"\",\"I\",\"II\",\"III\",\"IV\",\"V\",\"VI\",\"VII\",\"VIII\",\"IX\"};\\n        string tens[] = {\"\",\"X\",\"XX\",\"XXX\",\"XL\",\"L\",\"LX\",\"LXX\",\"LXXX\",\"XC\"};\\n        string hrns[] = {\"\",\"C\",\"CC\",\"CCC\",\"CD\",\"D\",\"DC\",\"DCC\",\"DCCC\",\"CM\"};\\n        string ths[]={\"\",\"M\",\"MM\",\"MMM\"};\\n        \\n        return ths[num/1000] + hrns[(num%1000)/100] + tens[(num%100)/10] + ones[num%10];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string ones[] = {\"\",\"I\",\"II\",\"III\",\"IV\",\"V\",\"VI\",\"VII\",\"VIII\",\"IX\"};\\n        string tens[] = {\"\",\"X\",\"XX\",\"XXX\",\"XL\",\"L\",\"LX\",\"LXX\",\"LXXX\",\"XC\"};\\n        string hrns[] = {\"\",\"C\",\"CC\",\"CCC\",\"CD\",\"D\",\"DC\",\"DCC\",\"DCCC\",\"CM\"};\\n        string ths[]={\"\",\"M\",\"MM\",\"MMM\"};\\n        \\n        return ths[num/1000] + hrns[(num%1000)/100] + tens[(num%100)/10] + ones[num%10];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2962674,
                "title": "easiest-o-1-faang-method-ever",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string ones[] = {\"\",\"I\",\"II\",\"III\",\"IV\",\"V\",\"VI\",\"VII\",\"VIII\",\"IX\"};\\n        string tens[] = {\"\",\"X\",\"XX\",\"XXX\",\"XL\",\"L\",\"LX\",\"LXX\",\"LXXX\",\"XC\"};\\n        string hrns[] = {\"\",\"C\",\"CC\",\"CCC\",\"CD\",\"D\",\"DC\",\"DCC\",\"DCCC\",\"CM\"};\\n        string ths[]={\"\",\"M\",\"MM\",\"MMM\"};\\n        \\n        return ths[num/1000] + hrns[(num%1000)/100] + tens[(num%100)/10] + ones[num%10];\\n    }\\n};\\n```\\n\\n# ***Please Upvote if it helps \\u2764\\uFE0F***",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Hash Table",
                    "Math",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string ones[] = {\"\",\"I\",\"II\",\"III\",\"IV\",\"V\",\"VI\",\"VII\",\"VIII\",\"IX\"};\\n        string tens[] = {\"\",\"X\",\"XX\",\"XXX\",\"XL\",\"L\",\"LX\",\"LXX\",\"LXXX\",\"XC\"};\\n        string hrns[] = {\"\",\"C\",\"CC\",\"CCC\",\"CD\",\"D\",\"DC\",\"DCC\",\"DCCC\",\"CM\"};\\n        string ths[]={\"\",\"M\",\"MM\",\"MMM\"};\\n        \\n        return ths[num/1000] + hrns[(num%1000)/100] + tens[(num%100)/10] + ones[num%10];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 6382,
                "title": "my-simple-cpp-solution",
                "content": "    class Solution {\\n    public:\\n        string intToRoman(int num) \\n        {\\n            string res;\\n            string sym[] = {\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"};\\n            int val[] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\\n            \\n            for(int i=0; num != 0; i++)\\n            {\\n                while(num >= val[i])\\n                {\\n                    num -= val[i];\\n                    res += sym[i];\\n                }\\n            }\\n            \\n            return res;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        string intToRoman(int num) \\n        {\\n            string res;\\n            string sym[] = {\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"}",
                "codeTag": "Java"
            },
            {
                "id": 6304,
                "title": "python-simple-solution",
                "content": "        \\n    def intToRoman1(self, num):\\n        values = [ 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 ]\\n        numerals = [ \"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\" ]\\n        res, i = \"\", 0\\n        while num:\\n            res += (num//values[i]) * numerals[i]\\n            num %= values[i]\\n            i += 1\\n        return res\\n        \\n    def intToRoman(self, num):\\n        values = [ 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 ]\\n        numerals = [ \"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\" ]\\n        res = \"\"\\n        for i, v in enumerate(values):\\n            res += (num//v) * numerals[i]\\n            num %= v\\n        return res",
                "solutionTags": [
                    "Python"
                ],
                "code": "        \\n    def intToRoman1(self, num):\\n        values = [ 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 ]\\n        numerals = [ \"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\" ]\\n        res, i = \"\", 0\\n        while num:\\n            res += (num//values[i]) * numerals[i]\\n            num %= values[i]\\n            i += 1\\n        return res\\n        \\n    def intToRoman(self, num):\\n        values = [ 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 ]\\n        numerals = [ \"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\" ]\\n        res = \"\"\\n        for i, v in enumerate(values):\\n            res += (num//v) * numerals[i]\\n            num %= v\\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 3216797,
                "title": "easiest-beginner-friendly-sol-c-java-python",
                "content": "# Intuition of this Problem:\\nThis code takes a non-negative integer as input and converts it into its corresponding Roman numeral representation. The approach used here is to store the Roman numeral values and their corresponding symbols in a vector of pairs. The algorithm then iterates through the vector and repeatedly adds the corresponding symbols to the result string while subtracting the corresponding value from the input integer until the input integer becomes zero.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**NOTE - PLEASE READ APPROACH FIRST THEN SEE THE CODE. YOU WILL DEFINITELY UNDERSTAND THE CODE LINE BY LINE AFTER SEEING THE APPROACH.**\\n\\n# Approach for this Problem:\\n1. Initialize an empty string called Roman to store the resulting Roman numeral.\\n2. Create a vector of pairs called storeIntRoman, to store the Roman numeral values and their corresponding symbols.\\n3. Iterate through the storeIntRoman vector using a for loop.\\n4. For each pair, check if the input integer is greater than or equal to the Roman numeral value.\\n5. If it is, add the corresponding symbol to the Roman string and subtract the corresponding value from the input integer.\\n6. Repeat steps 4-5 until the input integer becomes zero.\\n7. Return the Roman string.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Humble Request:\\n- If my solution is helpful to you then please **UPVOTE** my solution, your **UPVOTE** motivates me to post such kind of solution.\\n- Please let me know in comments if there is need to do any improvement in my approach, code....anything.\\n- **Let\\'s connect on** https://www.linkedin.com/in/abhinash-singh-1b851b188\\n\\n![57jfh9.jpg](https://assets.leetcode.com/users/images/c2826b72-fb1c-464c-9f95-d9e578abcaf3_1674104075.4732099.jpeg)\\n\\n# Code:\\n```C++ []\\n//Approach 1 : \\n//time complexity - O(1) since the algorithm always iterates through a constant number of values (13 in this case).\\n//O(1) since the amount of extra space used is constant (the size of the storeIntRoman vector, which is also 13 in this case\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string Roman = \"\";\\n        // Creating vector of pairs to store the Roman numeral values and their corresponding symbols\\n        vector<pair<int, string>> storeIntRoman = {{1000, \"M\"}, {900, \"CM\"}, {500, \"D\"}, {400, \"CD\"}, {100, \"C\"}, {90, \"XC\"}, {50, \"L\"}, {40, \"XL\"}, {10, \"X\"}, {9, \"IX\"}, {5, \"V\"}, {4, \"IV\"}, {1, \"I\"}};\\n        // Iterating through the vector and repeatedly adds the corresponding symbols to the result string while subtracting the corresponding value from the input integer until the input integer becomes zero.\\n        for (int i = 0; i < storeIntRoman.size(); i++) {\\n            while (num >= storeIntRoman[i].first) {\\n                Roman += storeIntRoman[i].second;\\n                num -= storeIntRoman[i].first;\\n            }\\n        }\\n        return Roman;\\n    }\\n};\\n```\\n```C++ []\\n//Approach 2\\n//time complexity - O(1) since the algorithm always iterates through a constant number of values (13 in this case).\\n//O(1) since the amount of extra space used is constant (the size of the storeIntRoman vector, which is also 13 in this case\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string ones[] = {\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"};\\n        string tens[] = {\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"};\\n        string hundreds[] = {\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"};\\n        string thousands[]= {\"\", \"M\", \"MM\", \"MMM\"};\\n        \\n        string Roman =  thousands[num / 1000] + hundreds[(num % 1000) / 100] + tens[(num % 100) / 10] + ones[num % 10];\\n        return Roman;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public String intToRoman(int num) {\\n        String Roman = \"\";\\n        int[][] storeIntRoman = {{1000, \"M\"}, {900, \"CM\"}, {500, \"D\"}, {400, \"CD\"}, {100, \"C\"}, {90, \"XC\"}, {50, \"L\"}, {40, \"XL\"}, {10, \"X\"}, {9, \"IX\"}, {5, \"V\"}, {4, \"IV\"}, {1, \"I\"}};\\n        for (int i = 0; i < storeIntRoman.length; i++) {\\n            while (num >= storeIntRoman[i][0]) {\\n                Roman += storeIntRoman[i][1];\\n                num -= storeIntRoman[i][0];\\n            }\\n        }\\n        return Roman;\\n    }\\n}\\n\\n```\\n```Python []\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        Roman = \"\"\\n        storeIntRoman = [[1000, \"M\"], [900, \"CM\"], [500, \"D\"], [400, \"CD\"], [100, \"C\"], [90, \"XC\"], [50, \"L\"], [40, \"XL\"], [10, \"X\"], [9, \"IX\"], [5, \"V\"], [4, \"IV\"], [1, \"I\"]]\\n        for i in range(len(storeIntRoman)):\\n            while num >= storeIntRoman[i][0]:\\n                Roman += storeIntRoman[i][1]\\n                num -= storeIntRoman[i][0]\\n        return Roman\\n\\n```\\n\\n# Time Complexity and Space Complexity:\\n- Time complexity: **O(13) = O(1)** - Approach 1\\n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(13) = O(1)** - Approach 1\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Hash Table",
                    "Math"
                ],
                "code": "```C++ []\\n//Approach 1 : \\n//time complexity - O(1) since the algorithm always iterates through a constant number of values (13 in this case).\\n//O(1) since the amount of extra space used is constant (the size of the storeIntRoman vector, which is also 13 in this case\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string Roman = \"\";\\n        // Creating vector of pairs to store the Roman numeral values and their corresponding symbols\\n        vector<pair<int, string>> storeIntRoman = {{1000, \"M\"}, {900, \"CM\"}, {500, \"D\"}, {400, \"CD\"}, {100, \"C\"}, {90, \"XC\"}, {50, \"L\"}, {40, \"XL\"}, {10, \"X\"}, {9, \"IX\"}, {5, \"V\"}, {4, \"IV\"}, {1, \"I\"}};\\n        // Iterating through the vector and repeatedly adds the corresponding symbols to the result string while subtracting the corresponding value from the input integer until the input integer becomes zero.\\n        for (int i = 0; i < storeIntRoman.size(); i++) {\\n            while (num >= storeIntRoman[i].first) {\\n                Roman += storeIntRoman[i].second;\\n                num -= storeIntRoman[i].first;\\n            }\\n        }\\n        return Roman;\\n    }\\n};\\n```\n```C++ []\\n//Approach 2\\n//time complexity - O(1) since the algorithm always iterates through a constant number of values (13 in this case).\\n//O(1) since the amount of extra space used is constant (the size of the storeIntRoman vector, which is also 13 in this case\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string ones[] = {\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"};\\n        string tens[] = {\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"};\\n        string hundreds[] = {\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"};\\n        string thousands[]= {\"\", \"M\", \"MM\", \"MMM\"};\\n        \\n        string Roman =  thousands[num / 1000] + hundreds[(num % 1000) / 100] + tens[(num % 100) / 10] + ones[num % 10];\\n        return Roman;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public String intToRoman(int num) {\\n        String Roman = \"\";\\n        int[][] storeIntRoman = {{1000, \"M\"}, {900, \"CM\"}, {500, \"D\"}, {400, \"CD\"}, {100, \"C\"}, {90, \"XC\"}, {50, \"L\"}, {40, \"XL\"}, {10, \"X\"}, {9, \"IX\"}, {5, \"V\"}, {4, \"IV\"}, {1, \"I\"}};\\n        for (int i = 0; i < storeIntRoman.length; i++) {\\n            while (num >= storeIntRoman[i][0]) {\\n                Roman += storeIntRoman[i][1];\\n                num -= storeIntRoman[i][0];\\n            }\\n        }\\n        return Roman;\\n    }\\n}\\n\\n```\n```Python []\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        Roman = \"\"\\n        storeIntRoman = [[1000, \"M\"], [900, \"CM\"], [500, \"D\"], [400, \"CD\"], [100, \"C\"], [90, \"XC\"], [50, \"L\"], [40, \"XL\"], [10, \"X\"], [9, \"IX\"], [5, \"V\"], [4, \"IV\"], [1, \"I\"]]\\n        for i in range(len(storeIntRoman)):\\n            while num >= storeIntRoman[i][0]:\\n                Roman += storeIntRoman[i][1]\\n                num -= storeIntRoman[i][0]\\n        return Roman\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1102775,
                "title": "js-python-java-c-simple-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nJust like Roman to Integer, this problem is most easily solved using a **lookup table** for the conversion between digit and numeral. In this case, we can easily deal with the values in descending order and insert the appropriate numeral (or numerals) as many times as we can while reducing the our target number (**N**) by the same amount.\\n\\nOnce **N** runs out, we can **return ans**.\\n\\n---\\n\\n#### ***Implementation:***\\n\\nJava\\'s **StringBuilder** can take care of repeated string concatenations without some of the overhead of making string copies.\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **124ms / 43.5MB** (beats 100% / 100%).\\n```javascript\\nconst val = [1000,900,500,400,100,90,50,40,10,9,5,4,1]\\nconst rom = [\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"]\\n\\nvar intToRoman = function(N) {\\n    let ans = \"\"\\n    for (let i = 0; N; i++)\\n        while (N >= val[i]) ans += rom[i], N -= val[i]\\n    return ans\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **40ms / 14.1MB** (beats 95% / 86%).\\n```python\\nval = [1000,900,500,400,100,90,50,40,10,9,5,4,1]\\nrom = [\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"]\\n\\nclass Solution:\\n    def intToRoman(self, N: int) -> str:\\n        ans = \"\"\\n        for i in range(13):\\n            while N >= val[i]:\\n                ans += rom[i]\\n                N -= val[i]\\n        return ans\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **3ms / 38.1MB** (beats 100% / 95%).\\n```java\\nclass Solution {\\n    final static int[] val = {1000,900,500,400,100,90,50,40,10,9,5,4,1};\\n    final static String[] rom = {\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\\n\\n    public String intToRoman(int N) {\\n        StringBuilder ans = new StringBuilder();\\n        for (int i = 0; N > 0; i++)\\n            while (N >= val[i]) {\\n                ans.append(rom[i]);\\n                N -= val[i];\\n            }\\n        return ans.toString();\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **0ms / 5.8MB** (beats 100% / 98%).\\n```c++\\nclass Solution {\\npublic:\\n    const int val[13] = {1000,900,500,400,100,90,50,40,10,9,5,4,1};\\n    const string rom[13] = {\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\\n\\n    string intToRoman(int N) {\\n        string ans = \"\";\\n        for (int i = 0; N; i++)\\n            while (N >= val[i]) ans += rom[i], N -= val[i];\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```javascript\\nconst val = [1000,900,500,400,100,90,50,40,10,9,5,4,1]\\nconst rom = [\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"]\\n\\nvar intToRoman = function(N) {\\n    let ans = \"\"\\n    for (let i = 0; N; i++)\\n        while (N >= val[i]) ans += rom[i], N -= val[i]\\n    return ans\\n};\\n```\n```python\\nval = [1000,900,500,400,100,90,50,40,10,9,5,4,1]\\nrom = [\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"]\\n\\nclass Solution:\\n    def intToRoman(self, N: int) -> str:\\n        ans = \"\"\\n        for i in range(13):\\n            while N >= val[i]:\\n                ans += rom[i]\\n                N -= val[i]\\n        return ans\\n```\n```java\\nclass Solution {\\n    final static int[] val = {1000,900,500,400,100,90,50,40,10,9,5,4,1};\\n    final static String[] rom = {\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\\n\\n    public String intToRoman(int N) {\\n        StringBuilder ans = new StringBuilder();\\n        for (int i = 0; N > 0; i++)\\n            while (N >= val[i]) {\\n                ans.append(rom[i]);\\n                N -= val[i];\\n            }\\n        return ans.toString();\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    const int val[13] = {1000,900,500,400,100,90,50,40,10,9,5,4,1};\\n    const string rom[13] = {\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\\n\\n    string intToRoman(int N) {\\n        string ans = \"\";\\n        for (int i = 0; N; i++)\\n            while (N >= val[i]) ans += rom[i], N -= val[i];\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2724200,
                "title": "python-s-simple-and-easy-to-understand-solution-99-faster",
                "content": "**\\uD83D\\uDD3C IF YOU FIND THIS POST HELPFUL PLEASE UPVOTE \\uD83D\\uDC4D**\\n\\nVisit this blog to learn Python tips and techniques and to find a Leetcode solution with an explanation:  https://www.python-techs.com/\\n\\n**Solution:**\\n```\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        # Creating Dictionary for Lookup\\n        num_map = {\\n            1: \"I\",\\n            5: \"V\",    4: \"IV\",\\n            10: \"X\",   9: \"IX\",\\n            50: \"L\",   40: \"XL\",\\n            100: \"C\",  90: \"XC\",\\n            500: \"D\",  400: \"CD\",\\n            1000: \"M\", 900: \"CM\",\\n        }\\n        \\n        # Result Variable\\n        r = \\'\\'\\n        \\n        \\n        for n in [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]:\\n            # If n in list then add the roman value to result variable\\n            while n <= num:\\n                r += num_map[n]\\n                num-=n\\n        return r\\n```\\n**Thank you for reading! \\uD83D\\uDE04 Comment if you have any questions or feedback.**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        # Creating Dictionary for Lookup\\n        num_map = {\\n            1: \"I\",\\n            5: \"V\",    4: \"IV\",\\n            10: \"X\",   9: \"IX\",\\n            50: \"L\",   40: \"XL\",\\n            100: \"C\",  90: \"XC\",\\n            500: \"D\",  400: \"CD\",\\n            1000: \"M\", 900: \"CM\",\\n        }\\n        \\n        # Result Variable\\n        r = \\'\\'\\n        \\n        \\n        for n in [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]:\\n            # If n in list then add the roman value to result variable\\n            while n <= num:\\n                r += num_map[n]\\n                num-=n\\n        return r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2723774,
                "title": "c-simple-and-easy-solution",
                "content": "**Please connect with me if u like my solution**\\n**Please Upvote**\\nhttps://www.linkedin.com/in/shubham-roy-0b71a0220/\\n\\n```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        int normal[]={1000,900,500,400,100,90,50,40,10,9,5,4,1};\\n        string roman[]={\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\\n        string res;\\n        for(int i=0;i<13;i++){\\n            while(num>=normal[i]){\\n                res.append(roman[i]);\\n                num-=normal[i];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        int normal[]={1000,900,500,400,100,90,50,40,10,9,5,4,1};\\n        string roman[]={\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\\n        string res;\\n        for(int i=0;i<13;i++){\\n            while(num>=normal[i]){\\n                res.append(roman[i]);\\n                num-=normal[i];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 6273,
                "title": "share-my-python-solution-96ms",
                "content": "    M = [\"\", \"M\", \"MM\", \"MMM\"];\\n    C = [\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"];\\n    X = [\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"];\\n    I = [\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"];\\n    return M[num/1000] + C[(num%1000)/100] + X[(num%100)/10] + I[num%10];",
                "solutionTags": [
                    "Python"
                ],
                "code": "    M = [\"\", \"M\", \"MM\", \"MMM\"];\\n    C = [\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"];\\n    X = [\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"];\\n    I = [\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"];\\n    return M[num/1000] + C[(num%1000)/100] + X[(num%100)/10] + I[num%10];",
                "codeTag": "Unknown"
            },
            {
                "id": 292605,
                "title": "python-solution-44ms",
                "content": "if this helps, please upvote! Thanks!\\n\\n```class Solution:\\n    def intToRoman(self, num: int) -> str:\\n        d = {1000: \\'M\\', 900: \\'CM\\', 500: \\'D\\', 400: \\'CD\\', 100: \\'C\\', 90: \\'XC\\', 50: \\'L\\', 40: \\'XL\\', 10: \\'X\\', 9: \\'IX\\', 5: \\'V\\', 4: \\'IV\\', 1: \\'I\\'}\\n        res = \\'\\'\\n        for k in d:\\n            while num >= k:\\n                res += d[k]\\n                num -= k\\n        return res\\n\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n    def intToRoman(self, num: int) -> str:\\n        d = {1000: \\'M\\', 900: \\'CM\\', 500: \\'D\\', 400: \\'CD\\', 100: \\'C\\', 90: \\'XC\\', 50: \\'L\\', 40: \\'XL\\', 10: \\'X\\', 9: \\'IX\\', 5: \\'V\\', 4: \\'IV\\', 1: \\'I\\'}",
                "codeTag": "Java"
            },
            {
                "id": 6361,
                "title": "a-simple-python-code-easy-to-understand",
                "content": "```python\\nclass Solution(object):\\n    def intToRoman(self, num):\\n        dict = [\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"]\\n        nums = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\\n        result = \"\"\\n        for letter, n in zip(dict, nums):\\n            result += letter * int(num / n)\\n            num %= n\\n        return result\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution(object):\\n    def intToRoman(self, num):\\n        dict = [\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"]\\n        nums = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\\n        result = \"\"\\n        for letter, n in zip(dict, nums):\\n            result += letter * int(num / n)\\n            num %= n\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 462641,
                "title": "python-pythonic-simple-solution-88-9-100-0",
                "content": "If you like, please upvote!\\n```\\ndef intToRoman(num: int):\\n    roman = {\\n        1000: \\'M\\',\\n        900: \\'CM\\',\\n        500: \\'D\\',\\n        400: \\'CD\\',\\n        100: \\'C\\',\\n        90: \\'XC\\',\\n        50: \\'L\\',\\n        40: \\'XL\\',\\n        10: \\'X\\',\\n        9: \\'IX\\',\\n        5: \\'V\\',\\n        4: \\'IV\\',\\n        1: \\'I\\'\\n        }\\n    romanized = \\'\\'\\n\\n    for base, symb in roman.items():\\n        romanized += symb * (num // base)\\n        num %= base\\n    else:\\n        return romanized\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef intToRoman(num: int):\\n    roman = {\\n        1000: \\'M\\',\\n        900: \\'CM\\',\\n        500: \\'D\\',\\n        400: \\'CD\\',\\n        100: \\'C\\',\\n        90: \\'XC\\',\\n        50: \\'L\\',\\n        40: \\'XL\\',\\n        10: \\'X\\',\\n        9: \\'IX\\',\\n        5: \\'V\\',\\n        4: \\'IV\\',\\n        1: \\'I\\'\\n        }\\n    romanized = \\'\\'\\n\\n    for base, symb in roman.items():\\n        romanized += symb * (num // base)\\n        num %= base\\n    else:\\n        return romanized\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 6376,
                "title": "simple-java-solution",
                "content": "    public String intToRoman(int num) {\\n        String M[] = {\"\", \"M\", \"MM\", \"MMM\"};\\n        String C[] = {\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"};\\n        String X[] = {\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"};\\n        String I[] = {\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"};\\n        return M[num/1000] + C[(num%1000)/100]+ X[(num%100)/10] + I[num%10];\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public String intToRoman(int num) {\\n        String M[] = {\"\", \"M\", \"MM\", \"MMM\"};\\n        String C[] = {\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"};\\n        String X[] = {\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"};\\n        String I[] = {\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"};\\n        return M[num/1000] + C[(num%1000)/100]+ X[(num%100)/10] + I[num%10];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 6489,
                "title": "sharing-my-really-simple-solution-with-explanation",
                "content": "    string intToRoman(int num) {\\n        string table[4][10] = {{\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"},\\n                               {\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"},\\n                               {\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"},\\n                               {\"\", \"M\", \"MM\", \"MMM\"}\\n                              };\\n        string result;\\n        int count = 0;\\n        while(num > 0){\\n            int temp = num % 10;\\n            result = table[count][temp] + result;\\n            num /= 10;\\n            count++;\\n        }\\n        return result;\\n    }\\n\\nThe basic idea is really simple: replace every digit in num by roman numerals.\\n\\nFor example, we have a num: 2438.\\n\\n2 --> \"MM\"\\n\\n4 --> \"CD\"\\n\\n3 --> \"XXX\"\\n\\n8 --> \"VIII\"\\n\\nThen the result is \"MMCDXXXVIII\".",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "    string intToRoman(int num) {\\n        string table[4][10] = {{\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"},\\n                               {\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"},\\n                               {\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"},\\n                               {\"\", \"M\", \"MM\", \"MMM\"}\\n                              };\\n        string result;\\n        int count = 0;\\n        while(num > 0){\\n            int temp = num % 10;\\n            result = table[count][temp] + result;\\n            num /= 10;\\n            count++;\\n        }\\n        return result;\\n    }\\n\\nThe basic idea is really simple: replace every digit in num by roman numerals.\\n\\nFor example, we have a num: 2438.\\n\\n2 --> \"MM\"\\n\\n4 --> \"CD\"\\n\\n3 --> \"XXX\"\\n\\n8 --> \"VIII\"\\n\\nThen the result is \"MMCDXXXVIII\".",
                "codeTag": "Unknown"
            },
            {
                "id": 1144148,
                "title": "accepted-solution-for-swift",
                "content": "<blockquote>\\n<b>Disclaimer:</b> By using any content from this post or thread, you release the author(s) from all liability and warranty of any kind. You are free to use the content freely and as you see fit. Any suggestions for improvement are welcome and greatly appreciated! Happy coding!\\n</blockquote>\\n\\n```swift\\nclass Solution {\\n    \\n    private let values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\\n    private let symbols = [\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"]\\n    \\n    func intToRoman(_ num: Int) -> String {\\n        \\n        var int = num\\n        var sym = \"\"\\n        \\n        while int > 0 {\\n            for (i, d) in values.enumerated() where int - d >= 0 {\\n                int -= d\\n                sym += symbols[i]\\n                break\\n            }\\n        }\\n        return sym\\n    }\\n}\\n```\\n\\n---\\n\\n<p>\\n<details>\\n<summary>\\n<img src=\"https://git.io/JDblm\" height=\"24\">\\n<b>TEST CASES</b>\\n</summary>\\n\\n<p><pre>\\n<b>Result:</b> Executed 3 tests, with 0 failures (0 unexpected) in 0.013 (0.015) seconds\\n</pre></p>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    // 3 is represented as 3 ones.\\n    func test0() {\\n        let value = solution.intToRoman(3)\\n        XCTAssertEqual(value, \"III\")\\n    }\\n    \\n    // L = 50, V = 5, III = 3.\\n    func test1() {\\n        let value = solution.intToRoman(58)\\n        XCTAssertEqual(value, \"LVIII\")\\n    }\\n    \\n    // M = 1000, CM = 900, XC = 90 and IV = 4.\\n    func test2() {\\n        let value = solution.intToRoman(1994)\\n        XCTAssertEqual(value, \"MCMXCIV\")\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n</details>\\n</p>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    \\n    private let values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\\n    private let symbols = [\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"]\\n    \\n    func intToRoman(_ num: Int) -> String {\\n        \\n        var int = num\\n        var sym = \"\"\\n        \\n        while int > 0 {\\n            for (i, d) in values.enumerated() where int - d >= 0 {\\n                int -= d\\n                sym += symbols[i]\\n                break\\n            }\\n        }\\n        return sym\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    // 3 is represented as 3 ones.\\n    func test0() {\\n        let value = solution.intToRoman(3)\\n        XCTAssertEqual(value, \"III\")\\n    }\\n    \\n    // L = 50, V = 5, III = 3.\\n    func test1() {\\n        let value = solution.intToRoman(58)\\n        XCTAssertEqual(value, \"LVIII\")\\n    }\\n    \\n    // M = 1000, CM = 900, XC = 90 and IV = 4.\\n    func test2() {\\n        let value = solution.intToRoman(1994)\\n        XCTAssertEqual(value, \"MCMXCIV\")\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 401764,
                "title": "clean-javascript-solution-using-map",
                "content": "Here\\'s clean javascript solution:\\n\\nFirst version using ```forEach```:\\n```\\nfunction intToRoman(num) {\\n    const map = { M: 1000, CM: 900, D: 500, CD: 400, C: 100, XC: 90, L: 50, XL: 40, X: 10, IX: 9, V: 5, IV: 4, I: 1 };\\n    let result = \\'\\';\\n    Object.entries(map).forEach(([letter, n]) => {\\n        result += letter.repeat(Math.floor(num / n));\\n        num %= n;\\n    });\\n    return result;\\n}\\n```\\n\\nSecond version with ```reduce```:\\n\\n```\\nfunction intToRoman(num) {\\n    const map = { M: 1000, CM: 900, D: 500, CD: 400, C: 100, XC: 90, L: 50, XL: 40, X: 10, IX: 9, V: 5, IV: 4, I: 1 };\\n    return Object.entries(map).reduce((result, [letter, n]) => {\\n        result += letter.repeat(Math.floor(num / n));\\n        num %= n;\\n        return result;\\n    }, \\'\\');\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```forEach```\n```\\nfunction intToRoman(num) {\\n    const map = { M: 1000, CM: 900, D: 500, CD: 400, C: 100, XC: 90, L: 50, XL: 40, X: 10, IX: 9, V: 5, IV: 4, I: 1 };\\n    let result = \\'\\';\\n    Object.entries(map).forEach(([letter, n]) => {\\n        result += letter.repeat(Math.floor(num / n));\\n        num %= n;\\n    });\\n    return result;\\n}\\n```\n```reduce```\n```\\nfunction intToRoman(num) {\\n    const map = { M: 1000, CM: 900, D: 500, CD: 400, C: 100, XC: 90, L: 50, XL: 40, X: 10, IX: 9, V: 5, IV: 4, I: 1 };\\n    return Object.entries(map).reduce((result, [letter, n]) => {\\n        result += letter.repeat(Math.floor(num / n));\\n        num %= n;\\n        return result;\\n    }, \\'\\');\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 6309,
                "title": "more-generalizable-solution-can-be-extended-to-any-roman-to-integer-conversion",
                "content": "This solution includes generalizability. Even if the number to be converted is > 3999, it works without making extra effort for finding cases.\\n```\\nbool isMul(int n) {\\n        return (n + 1) % 5 == 0;\\n    }\\n    int getMult(const int & n) {\\n        if(n / 1000 > 0) return 1000;\\n        if(n / 100 > 0) return 100;\\n        if(n / 10 > 0) return 10;\\n        return 1;\\n    }\\n    string subProb(int &num) {\\n        map<int,string> val;\\n        val[1] = \"I\";\\n        val[5] = \"V\";\\n        val[10] = \"X\";\\n        val[50] = \"L\";\\n        val[100] = \"C\";\\n        val[500] = \"D\";\\n        val[1000] = \"M\";\\n        int multiple = getMult(num);\\n        string ans = \"\";\\n        int value = num / multiple;\\n        if(value == 4) ans += (val[multiple] + val[5 * multiple]), value -=4;\\n        else if(value == 9) ans += (val[multiple] + val[10 * multiple]), value -=9;\\n        else if(value >= 5) {\\n            ans += val[5 * multiple];\\n            value -= 5;\\n        }\\n        for(int i = 0; i < value; i ++) ans += val[multiple];\\n        num %= multiple;\\n        return ans;\\n    }\\n    string intToRoman(int num) {\\n        string ans = \"\";\\n        while(num > 0) ans += subProb(num);\\n        return ans;\\n        \\n    }\\n```\\n\\nHope you like the solution",
                "solutionTags": [],
                "code": "```\\nbool isMul(int n) {\\n        return (n + 1) % 5 == 0;\\n    }\\n    int getMult(const int & n) {\\n        if(n / 1000 > 0) return 1000;\\n        if(n / 100 > 0) return 100;\\n        if(n / 10 > 0) return 10;\\n        return 1;\\n    }\\n    string subProb(int &num) {\\n        map<int,string> val;\\n        val[1] = \"I\";\\n        val[5] = \"V\";\\n        val[10] = \"X\";\\n        val[50] = \"L\";\\n        val[100] = \"C\";\\n        val[500] = \"D\";\\n        val[1000] = \"M\";\\n        int multiple = getMult(num);\\n        string ans = \"\";\\n        int value = num / multiple;\\n        if(value == 4) ans += (val[multiple] + val[5 * multiple]), value -=4;\\n        else if(value == 9) ans += (val[multiple] + val[10 * multiple]), value -=9;\\n        else if(value >= 5) {\\n            ans += val[5 * multiple];\\n            value -= 5;\\n        }\\n        for(int i = 0; i < value; i ++) ans += val[multiple];\\n        num %= multiple;\\n        return ans;\\n    }\\n    string intToRoman(int num) {\\n        string ans = \"\";\\n        while(num > 0) ans += subProb(num);\\n        return ans;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 6281,
                "title": "two-lines-can-do-the-job",
                "content": "String[] romanPieces={\"\",\"I\",\"II\",\"III\",\"IV\",\"V\",\"VI\",\"VII\",\"VIII\",\"IX\",\\n\\t\\t\\t\\t\\t\\t\"\",\"X\",\"XX\",\"XXX\",\"XL\",\"L\",\"LX\",\"LXX\",\"LXXX\",\"XC\",\\n\\t\\t\\t\\t\\t\\t\"\",\"C\",\"CC\",\"CCC\",\"CD\",\"D\",\"DC\",\"DCC\",\"DCCC\",\"CM\",\\n\\t\\t\\t\\t\\t\\t\"\",\"M\",\"MM\",\"MMM\",\"MMMM\"};\\nreturn romanPieces[num/1000+30]+romanPieces[(num/100)%10+20]\\n\\t\\t\\t\\t\\t+romanPieces[(num/10)%10+10]+romanPieces[num%10];",
                "solutionTags": [],
                "code": "String[] romanPieces={\"\",\"I\",\"II\",\"III\",\"IV\",\"V\",\"VI\",\"VII\",\"VIII\",\"IX\",\\n\\t\\t\\t\\t\\t\\t\"\",\"X\",\"XX\",\"XXX\",\"XL\",\"L\",\"LX\",\"LXX\",\"LXXX\",\"XC\",\\n\\t\\t\\t\\t\\t\\t\"\",\"C\",\"CC\",\"CCC\",\"CD\",\"D\",\"DC\",\"DCC\",\"DCCC\",\"CM\",\\n\\t\\t\\t\\t\\t\\t\"\",\"M\",\"MM\",\"MMM\",\"MMMM\"};\\nreturn romanPieces[num/1000+30]+romanPieces[(num/100)%10+20]\\n\\t\\t\\t\\t\\t+romanPieces[(num/10)%10+10]+romanPieces[num%10];",
                "codeTag": "Unknown"
            },
            {
                "id": 6432,
                "title": "easy-to-understand-java-solution",
                "content": "public class Solution {\\n\\n    public enum Type{\\n        M(1000),CM(900),D(500),CD(400),C(100),XC(90),L(50),XL(40),X(10),IX(9),V(5),IV(4),I(1);\\n        private final int value;\\n        Type(int value) {\\n            this.value = value;\\n        }\\n    };\\n    public String intToRoman(int num) {\\n        StringBuilder output = new StringBuilder();\\n        for (Type t:Type.values()) {\\n            while (num>=t.value) {\\n                output.append(t);\\n                num -= t.value;\\n            }\\n        }\\n        return output.toString();\\n    }\\n\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n    public enum Type{\\n        M(1000),CM(900),D(500),CD(400),C(100),XC(90),L(50),XL(40),X(10),IX(9),V(5),IV(4),I(1);\\n        private final int value;\\n        Type(int value) {\\n            this.value = value;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3512574,
                "title": "c-java-python-javascript-5-lines-of-code-100-simple-solution",
                "content": "# Intuition:\\nThe given problem is about converting an integer into a Roman numeral. To do this, we can create arrays that represent the Roman numeral symbols for each place value (ones, tens, hundreds, thousands). Then, we can divide the given number into its respective place values and concatenate the corresponding Roman numeral symbols.\\n\\n# Approach:\\n1. Create four arrays: `ones`, `tens`, `hrns`, and `ths`, representing the Roman numeral symbols for ones, tens, hundreds, and thousands respectively. Each array contains the symbols for the numbers from 0 to 9 in their respective place value.\\n2. Divide the given number `num` into its respective place values:\\n   - `thousands = num / 1000`\\n   - `hundreds = (num % 1000) / 100`\\n   - `tens = (num % 100) / 10`\\n   - `ones = num % 10`\\n3. Concatenate the Roman numeral symbols based on the place values:\\n   - `ths[num/1000]` represents the Roman numeral for thousands place.\\n   - `hrns[(num%1000)/100]` represents the Roman numeral for hundreds place.\\n   - `tens[(num%100)/10]` represents the Roman numeral for tens place.\\n   - `ones[num%10]` represents the Roman numeral for ones place.\\n4. Return the concatenation of the Roman numeral symbols obtained from step 3.\\n\\n# Complexity:\\n- Time complexity: O(1) because the number of digits in the given number is constant (up to 4 digits for the given range).\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1) because the arrays storing the Roman numeral values have fixed sizes.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n---\\n\\n\\n# C++\\n```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string ones[] = {\"\",\"I\",\"II\",\"III\",\"IV\",\"V\",\"VI\",\"VII\",\"VIII\",\"IX\"};\\n        string tens[] = {\"\",\"X\",\"XX\",\"XXX\",\"XL\",\"L\",\"LX\",\"LXX\",\"LXXX\",\"XC\"};\\n        string hrns[] = {\"\",\"C\",\"CC\",\"CCC\",\"CD\",\"D\",\"DC\",\"DCC\",\"DCCC\",\"CM\"};\\n        string ths[]={\"\",\"M\",\"MM\",\"MMM\"};\\n        \\n        return ths[num/1000] + hrns[(num%1000)/100] + tens[(num%100)/10] + ones[num%10];\\n    }\\n};\\n```\\n\\n---\\n# JAVA\\n```\\nclass Solution {\\n    public String intToRoman(int num) {\\n        String[] ones = {\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"};\\n        String[] tens = {\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"};\\n        String[] hrns = {\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"};\\n        String[] ths = {\"\", \"M\", \"MM\", \"MMM\"};\\n\\n        return ths[num / 1000] + hrns[(num % 1000) / 100] + tens[(num % 100) / 10] + ones[num % 10];\\n    }\\n}\\n\\n```\\n\\n---\\n# JavaScript\\n```\\nvar intToRoman = function(num) {\\n    const ones = [\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"];\\n    const tens = [\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"];\\n    const hrns = [\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"];\\n    const ths = [\"\", \"M\", \"MM\", \"MMM\"];\\n    return ths[Math.floor(num / 1000)] + hrns[Math.floor((num % 1000) / 100)] + tens[Math.floor((num % 100) / 10)] + ones[num % 10];\\n};\\n```\\n---\\n# Python\\n```\\nclass Solution:\\n    def intToRoman(self, num):\\n        ones = [\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"]\\n        tens = [\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"]\\n        hrns = [\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"]\\n        ths = [\"\", \"M\", \"MM\", \"MMM\"]\\n\\n        return ths[num / 1000] + hrns[(num % 1000) / 100] + tens[(num % 100) / 10] + ones[num % 10]\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string ones[] = {\"\",\"I\",\"II\",\"III\",\"IV\",\"V\",\"VI\",\"VII\",\"VIII\",\"IX\"};\\n        string tens[] = {\"\",\"X\",\"XX\",\"XXX\",\"XL\",\"L\",\"LX\",\"LXX\",\"LXXX\",\"XC\"};\\n        string hrns[] = {\"\",\"C\",\"CC\",\"CCC\",\"CD\",\"D\",\"DC\",\"DCC\",\"DCCC\",\"CM\"};\\n        string ths[]={\"\",\"M\",\"MM\",\"MMM\"};\\n        \\n        return ths[num/1000] + hrns[(num%1000)/100] + tens[(num%100)/10] + ones[num%10];\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public String intToRoman(int num) {\\n        String[] ones = {\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"};\\n        String[] tens = {\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"};\\n        String[] hrns = {\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"};\\n        String[] ths = {\"\", \"M\", \"MM\", \"MMM\"};\\n\\n        return ths[num / 1000] + hrns[(num % 1000) / 100] + tens[(num % 100) / 10] + ones[num % 10];\\n    }\\n}\\n\\n```\n```\\nvar intToRoman = function(num) {\\n    const ones = [\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"];\\n    const tens = [\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"];\\n    const hrns = [\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"];\\n    const ths = [\"\", \"M\", \"MM\", \"MMM\"];\\n    return ths[Math.floor(num / 1000)] + hrns[Math.floor((num % 1000) / 100)] + tens[Math.floor((num % 100) / 10)] + ones[num % 10];\\n};\\n```\n```\\nclass Solution:\\n    def intToRoman(self, num):\\n        ones = [\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"]\\n        tens = [\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"]\\n        hrns = [\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"]\\n        ths = [\"\", \"M\", \"MM\", \"MMM\"]\\n\\n        return ths[num / 1000] + hrns[(num % 1000) / 100] + tens[(num % 100) / 10] + ones[num % 10]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1422472,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        int intCode[]={1000,900,500,400,100,90,50,40,10,9,5,4,1};\\n        string code[]={\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\\n        \\n        string s;\\n        for(int i=0; i<13; ++i){\\n            while(num>=intCode[i]){\\n                s.append(code[i]);\\n                num-=intCode[i];\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```\\nPlease **UPVOTE**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        int intCode[]={1000,900,500,400,100,90,50,40,10,9,5,4,1};\\n        string code[]={\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\\n        \\n        string s;\\n        for(int i=0; i<13; ++i){\\n            while(num>=intCode[i]){\\n                s.append(code[i]);\\n                num-=intCode[i];\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2723782,
                "title": "java-explained-in-detail-simple-fast-solution-dictionary",
                "content": "I do my best everyday to give a clear explanation, so to help everyone improve their skills.\\n\\nIf you find this **helpful**, please \\uD83D\\uDC4D **upvote** this post and watch my [Github Repository](https://github.com/cheehwatang/leetcode-java).\\n\\nThank you for reading! \\uD83D\\uDE04 Comment if you have any questions or feedback.\\n\\n---\\n\\n#### Java - Using Dictionary - Approach 1\\n\\n```\\npublic String intToRoman(int num) {\\n\\n        // Approach:\\n        // This method uses two arrays with the corresponding integer-roman map, in descending order.\\n\\n        int[] value = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\\n        String[] roman = {\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"};\\n\\n        StringBuilder romanNumeral = new StringBuilder();\\n\\n        for (int i = 0; i < value.length && num > 0; i++) {\\n            // Check from the highest value, 1000 to the smallest.\\n            // If it is possible to subtract, for example 400, we know the roman numeral next is \"CD\".\\n            while (num >= value[i]) {\\n                romanNumeral.append(roman[i]);\\n                num -= value[i];\\n            }\\n        }\\n        return romanNumeral.toString();\\n    }\\n```\\n---\\n\\n#### Java - Without Dictionary - Approach 2\\n```\\nclass Solution {\\n    public String intToRoman(int num) {\\n        String romanNumeral = \"\";\\n        while (num >= 1000) {\\n            romanNumeral += \"M\";\\n            num -= 1000;\\n        }\\n        while (num >= 900) {\\n            romanNumeral += \"CM\";\\n            num -= 900;\\n        }\\n        while (num >= 500) {\\n            romanNumeral += \"D\";\\n            num -= 500;\\n        }\\n        while (num >= 400) {\\n            romanNumeral += \"CD\";\\n            num -= 400;\\n        }\\n        while (num >= 100) {\\n            romanNumeral += \"C\";\\n            num -= 100;\\n        }\\n        while (num >= 90) {\\n            romanNumeral += \"XC\";\\n            num -= 90;\\n        }\\n        while (num >= 50) {\\n            romanNumeral += \"L\";\\n            num -= 50;\\n        }\\n        while (num >= 40) {\\n            romanNumeral += \"XL\";\\n            num -= 40;\\n        }\\n        while (num >= 10) {\\n            romanNumeral += \"X\";\\n            num -= 10;\\n        }\\n        while (num >= 9) {\\n            romanNumeral += \"IX\";\\n            num -= 9;\\n        }\\n        while (num >= 5) {\\n            romanNumeral += \"V\";\\n            num -= 5;\\n        }\\n        while (num >= 4) {\\n            romanNumeral += \"IV\";\\n            num -= 4;\\n        }\\n        while (num >= 1) {\\n            romanNumeral += \"I\";\\n            num -= 1;\\n        }\\n\\n        return romanNumeral;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic String intToRoman(int num) {\\n\\n        // Approach:\\n        // This method uses two arrays with the corresponding integer-roman map, in descending order.\\n\\n        int[] value = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\\n        String[] roman = {\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"};\\n\\n        StringBuilder romanNumeral = new StringBuilder();\\n\\n        for (int i = 0; i < value.length && num > 0; i++) {\\n            // Check from the highest value, 1000 to the smallest.\\n            // If it is possible to subtract, for example 400, we know the roman numeral next is \"CD\".\\n            while (num >= value[i]) {\\n                romanNumeral.append(roman[i]);\\n                num -= value[i];\\n            }\\n        }\\n        return romanNumeral.toString();\\n    }\\n```\n```\\nclass Solution {\\n    public String intToRoman(int num) {\\n        String romanNumeral = \"\";\\n        while (num >= 1000) {\\n            romanNumeral += \"M\";\\n            num -= 1000;\\n        }\\n        while (num >= 900) {\\n            romanNumeral += \"CM\";\\n            num -= 900;\\n        }\\n        while (num >= 500) {\\n            romanNumeral += \"D\";\\n            num -= 500;\\n        }\\n        while (num >= 400) {\\n            romanNumeral += \"CD\";\\n            num -= 400;\\n        }\\n        while (num >= 100) {\\n            romanNumeral += \"C\";\\n            num -= 100;\\n        }\\n        while (num >= 90) {\\n            romanNumeral += \"XC\";\\n            num -= 90;\\n        }\\n        while (num >= 50) {\\n            romanNumeral += \"L\";\\n            num -= 50;\\n        }\\n        while (num >= 40) {\\n            romanNumeral += \"XL\";\\n            num -= 40;\\n        }\\n        while (num >= 10) {\\n            romanNumeral += \"X\";\\n            num -= 10;\\n        }\\n        while (num >= 9) {\\n            romanNumeral += \"IX\";\\n            num -= 9;\\n        }\\n        while (num >= 5) {\\n            romanNumeral += \"V\";\\n            num -= 5;\\n        }\\n        while (num >= 4) {\\n            romanNumeral += \"IV\";\\n            num -= 4;\\n        }\\n        while (num >= 1) {\\n            romanNumeral += \"I\";\\n            num -= 1;\\n        }\\n\\n        return romanNumeral;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3975240,
                "title": "java-runtime-3ms-beats-98-91-o-1",
                "content": "# Intuition\\nMy initial approach to solving this problem involves converting an integer to its Roman numeral representation using a predefined set of values and corresponding Roman numeral symbols.\\n\\n# Approach\\nTo achieve this, I utilize a greedy approach where I repeatedly subtract the largest possible value from the given number while appending the corresponding Roman numeral symbol to the result string. I maintain two arrays: `values`, which contains the integer values corresponding to Roman numerals, and `romanNumerals`, which contains the corresponding Roman numeral symbols.\\n\\nStarting with the largest value, I iterate through the `values` array and at each step, I check if the current value can be subtracted from the given number. If it can be, I append the corresponding Roman numeral symbol to the result string and subtract the value from the number. If not, I move on to the next smaller value.\\n\\nI continue this process until the given number becomes zero, and the result string represents the Roman numeral equivalent of the original number.\\n\\n# Complexity\\n- Time complexity: O(1)\\n  The algorithm performs a constant number of operations regardless of the magnitude of the input number. The iteration through the `values` array and the subsequent calculations are independent of the value of the input.\\n\\n- Space complexity: O(1)\\n  The algorithm uses a fixed amount of additional memory space for variables and arrays, leading to a constant space complexity.\\n\\n# Code\\n```java\\nclass Solution {\\n    public String intToRoman(int num) {\\n     \\n        int[] values = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\\n        String[] romanNumerals = {\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"};\\n\\n        StringBuilder sb = new StringBuilder();\\n\\n        int i = 0;\\n    \\n        while (num > 0) {\\n            if (num >= values[i]) {\\n                \\n                sb.append(romanNumerals[i]);\\n                num -= values[i];\\n            } else {\\n                i++;\\n            }\\n        }\\n\\n        return sb.toString();\\n    }\\n}\\n\\n```\\n![c0504eaf-5fb8-4a1d-a769-833262d1b86e_1674433591.3836212.webp](https://assets.leetcode.com/users/images/8a3b41d1-f0ca-472f-a9f7-8346b34a824e_1693297402.2918687.webp)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public String intToRoman(int num) {\\n     \\n        int[] values = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\\n        String[] romanNumerals = {\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"};\\n\\n        StringBuilder sb = new StringBuilder();\\n\\n        int i = 0;\\n    \\n        while (num > 0) {\\n            if (num >= values[i]) {\\n                \\n                sb.append(romanNumerals[i]);\\n                num -= values[i];\\n            } else {\\n                i++;\\n            }\\n        }\\n\\n        return sb.toString();\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421938,
                "title": "awesome-python-solution",
                "content": "\\n\\n# Python Solution\\n```\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        M=[\"\",\"M\",\"MM\",\"MMM\"]\\n        C=[\"\",\"C\",\"CC\",\"CCC\",\"CD\",\"D\",\"DC\",\"DCC\",\"DCCC\",\"CM\"]\\n        X=[\"\",\"X\",\"XX\",\"XXX\",\"XL\",\"L\",\"LX\",\"LXX\",\"LXXX\",\"XC\"]\\n        I=[\"\",\"I\",\"II\",\"III\",\"IV\",\"V\",\"VI\",\"VII\",\"VIII\",\"IX\"]\\n        return M[num//1000]+C[num%1000//100]+X[num%1000%100//10]+I[num%1000%100%10]\\n```\\n# please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        M=[\"\",\"M\",\"MM\",\"MMM\"]\\n        C=[\"\",\"C\",\"CC\",\"CCC\",\"CD\",\"D\",\"DC\",\"DCC\",\"DCCC\",\"CM\"]\\n        X=[\"\",\"X\",\"XX\",\"XXX\",\"XL\",\"L\",\"LX\",\"LXX\",\"LXXX\",\"XC\"]\\n        I=[\"\",\"I\",\"II\",\"III\",\"IV\",\"V\",\"VI\",\"VII\",\"VIII\",\"IX\"]\\n        return M[num//1000]+C[num%1000//100]+X[num%1000%100//10]+I[num%1000%100%10]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 531193,
                "title": "python-solution-without-big-table",
                "content": "I think my solution is good in terms of scalability -- No need to create big table :)\\n\\n``` python\\ndef intToRoman(self, num: int) -> str:\\n\\tones = [\\'I\\', \\'X\\', \\'C\\', \\'M\\']\\n\\tfives = [\\'V\\', \\'L\\', \\'D\\']\\n\\ti = 0\\n\\tans = []\\n\\n\\twhile num > 0:\\n\\t\\tn = num % 10\\n\\t\\tif 1 <= n <= 3:\\n\\t\\t\\tans.append(ones[i] * n) \\n\\t\\telif n == 4:\\n\\t\\t\\tans.append(ones[i] + fives[i])\\n\\t\\telif 5 <= n <= 8:\\n\\t\\t\\tans.append(fives[i] + ones[i] * (n - 5))\\n\\t\\telif n == 9:\\n\\t\\t\\tans.append(ones[i] + ones[i+1])\\n\\n\\t\\ti += 1\\n\\t\\tnum //= 10\\n\\n\\treturn \"\".join(ans[::-1])",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "I think my solution is good in terms of scalability -- No need to create big table :)\\n\\n``` python\\ndef intToRoman(self, num: int) -> str:\\n\\tones = [\\'I\\', \\'X\\', \\'C\\', \\'M\\']\\n\\tfives = [\\'V\\', \\'L\\', \\'D\\']\\n\\ti = 0\\n\\tans = []\\n\\n\\twhile num > 0:\\n\\t\\tn = num % 10\\n\\t\\tif 1 <= n <= 3:\\n\\t\\t\\tans.append(ones[i] * n) \\n\\t\\telif n == 4:\\n\\t\\t\\tans.append(ones[i] + fives[i])\\n\\t\\telif 5 <= n <= 8:\\n\\t\\t\\tans.append(fives[i] + ones[i] * (n - 5))\\n\\t\\telif n == 9:\\n\\t\\t\\tans.append(ones[i] + ones[i+1])\\n\\n\\t\\ti += 1\\n\\t\\tnum //= 10\\n\\n\\treturn \"\".join(ans[::-1])",
                "codeTag": "Python3"
            },
            {
                "id": 1102673,
                "title": "python-short-solution-explained",
                "content": "Let us look at Roman representation digit by digit and see how it works.\\nFor last digit we can have \\n`\" \", I, II, III, IV, V, VI, VII, VIII, IX`\\nFor next digit we can have \\n`\" \", X, XX, XXX, XL, L, LX, LXX, LXXX, XC`\\nand so on.\\n\\nNotice, that we have exactly the same pattern here, but instead of `I, V, X`, we have `X, L, C` symbols. Let us use this idea and function `digit` to construct our number. We find last digit of integer representation of our number, create corresponding roman part and add it to the beginning of our answer.\\n\\n**Complexity**: time complexity is just `O(1)`, because length is restricted by `15`. Space complexity is `O(1)` as well.\\n\\n```\\nclass Solution:\\n    def intToRoman(self, num):\\n        def digit(a,b,c,dig):\\n            return [\"\",a,2*a,3*a,a+b,b,b+a,b+2*a,b+3*a,a+c][dig]\\n        \\n        l = [\"I\",\"V\",\"X\",\"L\",\"C\",\"D\",\"M\",\"!\",\"!\"]\\n        out, i = \"\", 0\\n\\n        while num != 0:\\n            num, last = divmod(num, 10)\\n            out = digit(l[i], l[i+1], l[i+2], last) + out\\n            i += 2\\n        return out\\n```\\n\\nIf you have any question, feel free to ask. If you like the explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def intToRoman(self, num):\\n        def digit(a,b,c,dig):\\n            return [\"\",a,2*a,3*a,a+b,b,b+a,b+2*a,b+3*a,a+c][dig]\\n        \\n        l = [\"I\",\"V\",\"X\",\"L\",\"C\",\"D\",\"M\",\"!\",\"!\"]\\n        out, i = \"\", 0\\n\\n        while num != 0:\\n            num, last = divmod(num, 10)\\n            out = digit(l[i], l[i+1], l[i+2], last) + out\\n            i += 2\\n        return out\\n```",
                "codeTag": "Java"
            },
            {
                "id": 341297,
                "title": "easiest-and-fastest-0-ms-c-solution-a-little-bit-more-memory-for-simplicity",
                "content": "```\\nclass Solution {\\nprivate:\\n    const vector<pair<int, char*>> conv = {{1000, \"M\"},\\n                                            {900, \"CM\"},\\n                                            {500, \"D\"},\\n                                            {400, \"CD\"},\\n                                            {100, \"C\"},\\n                                            {90, \"XC\"},\\n                                            {50, \"L\"},\\n                                            {40, \"XL\"},\\n                                            {10, \"X\"},\\n                                            {9, \"IX\"},\\n                                            {5, \"V\"},\\n                                            {4, \"IV\"},\\n                                            {1, \"I\"}};\\npublic:\\n    string intToRoman(int num) {\\n        string res;\\n        auto it = conv.begin();\\n        while (num > 0 && it != conv.end()) {\\n            if (num >= it->first) {\\n                num -= it->first;\\n                res += it->second;\\n            } else {\\n                ++it;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    const vector<pair<int, char*>> conv = {{1000, \"M\"},\\n                                            {900, \"CM\"},\\n                                            {500, \"D\"},\\n                                            {400, \"CD\"},\\n                                            {100, \"C\"},\\n                                            {90, \"XC\"},\\n                                            {50, \"L\"},\\n                                            {40, \"XL\"},\\n                                            {10, \"X\"},\\n                                            {9, \"IX\"},\\n                                            {5, \"V\"},\\n                                            {4, \"IV\"},\\n                                            {1, \"I\"}};\\npublic:\\n    string intToRoman(int num) {\\n        string res;\\n        auto it = conv.begin();\\n        while (num > 0 && it != conv.end()) {\\n            if (num >= it->first) {\\n                num -= it->first;\\n                res += it->second;\\n            } else {\\n                ++it;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2057323,
                "title": "0ms-1liner-100-fastest-solution-explained-o-n-time-complexity-o-n-space-complexity",
                "content": "**As a professional with a passion for problem-solving and collaboration, I am always looking to expand my network of like-minded individuals on LinkedIn. By connecting with me, we can work together to tackle complex challenges, share ideas, and grow both professionally and personally.**\\n\\n**Whether you\\'re an expert in your field or just starting out, I welcome connections from all backgrounds and experiences. By building a diverse and collaborative network, we can leverage our unique perspectives and skill sets to push the boundaries of what\\'s possible.**\\n\\n**So, if you\\'re interested in connecting and exploring the potential for future collaborations, please don\\'t hesitate to reach out. Let\\'s start a conversation and see where it takes us!**\\n\\n---\\n\\nhttps://www.linkedin.com/in/cucerdariancatalin/\\nhttps://www.linkedin.com/in/cucerdariancatalin/\\nhttps://www.linkedin.com/in/cucerdariancatalin/\\n\\n---\\n(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful, ***please upvote*** this post.)\\n***Take care brother, peace, love!***\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 38.2MB*** (beats 92.04% / 24.00%).\\n* *** Java ***\\n\\n```\\n\\nclass Solution {\\n    final static int[] val = {1000,900,500,400,100,90,50,40,10,9,5,4,1};\\n    final static String[] rom = {\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\\n\\n    public String intToRoman(int N) {\\n        StringBuilder ans = new StringBuilder();\\n        for (int i = 0; N > 0; i++)\\n            while (N >= val[i]) {\\n                ans.append(rom[i]);\\n                N -= val[i];\\n            }\\n        return ans.toString();\\n    }\\n}\\n\\n```\\n\\n```\\n```\\n\\n```\\n```\\n***\"We are Anonymous. We are legion. We do not forgive. We do not forget. Expect us. Open your eyes..\" - \\uD835\\uDCD0\\uD835\\uDCF7\\uD835\\uDCF8\\uD835\\uDCF7\\uD835\\uDD02\\uD835\\uDCF6\\uD835\\uDCF8\\uD835\\uDCFE\\uD835\\uDCFC***",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "JavaScript",
                    "Swift",
                    "Kotlin",
                    "PHP"
                ],
                "code": "```\\n```\n```\\n\\nclass Solution {\\n    final static int[] val = {1000,900,500,400,100,90,50,40,10,9,5,4,1};\\n    final static String[] rom = {\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\\n\\n    public String intToRoman(int N) {\\n        StringBuilder ans = new StringBuilder();\\n        for (int i = 0; N > 0; i++)\\n            while (N >= val[i]) {\\n                ans.append(rom[i]);\\n                N -= val[i];\\n            }\\n        return ans.toString();\\n    }\\n}\\n\\n```\n```\\n```\n```\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2725325,
                "title": "short-c-explained-solution-beginner-friendly-by-mr-coder",
                "content": "[Watch](https://www.youtube.com/watch?v=RckYHjMJLNI)\\nhttps://www.youtube.com/watch?v=RckYHjMJLNI\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        vector<pair<int, string>> vm = {{1000, \"M\"},{900, \"CM\"} , {500, \"D\"},{400, \"CD\"} , {100, \"C\"} , {90, \"XC\"}, {50, \"L\"}, {40, \"XL\"},{10, \"X\"}, {9, \"IX\"},{5, \"V\"} , {4, \"IV\"},{1, \"I\"} };\\n        string s_ans = \"\";\\n        while(num > 0){\\n            for(auto x : vm){\\n                if(num >= x.first){\\n                    s_ans += x.second;\\n                    num = num - x.first;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return s_ans;\\n    }\\n};\\n```\\n**If you find my solution helpful please upvote it.**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        vector<pair<int, string>> vm = {{1000, \"M\"},{900, \"CM\"} , {500, \"D\"},{400, \"CD\"} , {100, \"C\"} , {90, \"XC\"}, {50, \"L\"}, {40, \"XL\"},{10, \"X\"}, {9, \"IX\"},{5, \"V\"} , {4, \"IV\"},{1, \"I\"} };\\n        string s_ans = \"\";\\n        while(num > 0){\\n            for(auto x : vm){\\n                if(num >= x.first){\\n                    s_ans += x.second;\\n                    num = num - x.first;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return s_ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 704000,
                "title": "javascript",
                "content": "```\\nvar intToRoman = function(num) {\\n    let res = \"\";\\n    if (num < 1 || num > 3999) return res;\\n    let weight = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1];\\n   let token = [\\'M\\', \\'CM\\', \\'D\\', \\'CD\\', \\'C\\', \\'XC\\', \\'L\\', \\'XL\\', \\'X\\', \\'IX\\', \\'V\\', \\'IV\\', \\'I\\'];\\n    let i = 0;\\n    while (num > 0){\\n        if (num - weight[i] >= 0){\\n            res += token[i];\\n            num -= weight[i];\\n        }\\n        else{\\n            i++;\\n        }\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar intToRoman = function(num) {\\n    let res = \"\";\\n    if (num < 1 || num > 3999) return res;\\n    let weight = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1];\\n   let token = [\\'M\\', \\'CM\\', \\'D\\', \\'CD\\', \\'C\\', \\'XC\\', \\'L\\', \\'XL\\', \\'X\\', \\'IX\\', \\'V\\', \\'IV\\', \\'I\\'];\\n    let i = 0;\\n    while (num > 0){\\n        if (num - weight[i] >= 0){\\n            res += token[i];\\n            num -= weight[i];\\n        }\\n        else{\\n            i++;\\n        }\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 6473,
                "title": "esay-c-solution-43ms",
                "content": "    class Solution {\\n    public:\\n    \\tconst static string THOUS[];\\n    \\tconst static string HUNDS[];\\n    \\tconst static string TENS[];\\n    \\tconst static string ONES[];\\n        string intToRoman(int num) {\\n    \\t\\tstring result;\\n    \\t\\tresult += THOUS[(int)(num/1000)%10];\\n    \\t\\tresult += HUNDS[(int)(num/100)%10];\\n    \\t\\tresult += TENS[(int)(num/10)%10];\\n    \\t\\tresult += ONES[num%10];\\n    \\t\\treturn result;\\n        }\\n    };\\n    \\n    const string Solution::THOUS[]\\t= {\"\",\"M\",\"MM\",\"MMM\"};\\n    const string Solution::HUNDS[]\\t= {\"\",\"C\",\"CC\",\"CCC\",\"CD\",\"D\",\"DC\",\"DCC\",\"DCCC\",\"CM\"};\\n    const string Solution::TENS[]\\t= {\"\",\"X\",\"XX\",\"XXX\",\"XL\",\"L\",\"LX\",\"LXX\",\"LXXX\",\"XC\"};\\n    const string Solution::ONES[]\\t= {\"\",\"I\",\"II\",\"III\",\"IV\",\"V\",\"VI\",\"VII\",\"VIII\",\"IX\"};",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    \\tconst static string THOUS[];\\n    \\tconst static string HUNDS[];\\n    \\tconst static string TENS[];\\n    \\tconst static string ONES[];\\n        string intToRoman(int num) {\\n    \\t\\tstring result;\\n    \\t\\tresult += THOUS[(int)(num/1000)%10];\\n    \\t\\tresult += HUNDS[(int)(num/100)%10];\\n    \\t\\tresult += TENS[(int)(num/10)%10];\\n    \\t\\tresult += ONES[num%10];\\n    \\t\\treturn result;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2724006,
                "title": "c-integer-to-roman-just-8-lines-of-code",
                "content": "```\\nstring intToRoman(int num) {\\n    string str[13] = {\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"};\\n    int val[13] = {1000, 900, 500, 400, 100,  90,  50,  40, 10,   9,   5,   4,  1};\\n    string ans;\\n    for (int i=0; i<13; i++) {\\n        for (int j=0; j<(num/val[i]); j++) {\\n            ans += str[i];\\n        }\\n        num %= val[i];\\n    }\\n    return ans;\\n}\\n```\\nHelpful?",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nstring intToRoman(int num) {\\n    string str[13] = {\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"};\\n    int val[13] = {1000, 900, 500, 400, 100,  90,  50,  40, 10,   9,   5,   4,  1};\\n    string ans;\\n    for (int i=0; i<13; i++) {\\n        for (int j=0; j<(num/val[i]); j++) {\\n            ans += str[i];\\n        }\\n        num %= val[i];\\n    }\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2521374,
                "title": "no-loop-no-conditions-used",
                "content": "String[] Thousands={\"\",\"M\",\"MM\",\"MMM\"};\\n        String[] Hundreds={\"\",\"C\",\"CC\",\"CCC\",\"CD\",\"D\",\"DC\",\"DCC\",\"DCCC\",\"CM\"};\\n        String[] Tens={\"\",\"X\",\"XX\",\"XXX\",\"XL\",\"L\",\"LX\",\"LXX\",\"LXXX\",\"XC\"};\\n        String[] Units={\"\",\"I\",\"II\",\"III\",\"IV\",\"V\",\"VI\",\"VII\",\"VIII\",\"IX\"};\\n        return Thousands[num/1000]+Hundreds[(num%1000)/100]+Tens[(num%100)/10]+Units[(num%10)];",
                "solutionTags": [],
                "code": "String[] Thousands={\"\",\"M\",\"MM\",\"MMM\"};\\n        String[] Hundreds={\"\",\"C\",\"CC\",\"CCC\",\"CD\",\"D\",\"DC\",\"DCC\",\"DCCC\",\"CM\"};\\n        String[] Tens={\"\",\"X\",\"XX\",\"XXX\",\"XL\",\"L\",\"LX\",\"LXX\",\"LXXX\",\"XC\"};\\n        String[] Units={\"\",\"I\",\"II\",\"III\",\"IV\",\"V\",\"VI\",\"VII\",\"VIII\",\"IX\"};\\n        return Thousands[num/1000]+Hundreds[(num%1000)/100]+Tens[(num%100)/10]+Units[(num%10)];",
                "codeTag": "Unknown"
            },
            {
                "id": 255369,
                "title": "c-100",
                "content": "```\\npublic class Solution {\\n    public string IntToRoman(int num) {\\n        if (num >= 1000) return \"M\" + IntToRoman(num - 1000);\\n\\n        if (num >= 500) return num >= 900 ? (\"CM\" + IntToRoman(num - 900)) : (\"D\" + IntToRoman(num - 500));\\n\\n        if (num >= 100) return num >= 400 ? (\"CD\" + IntToRoman(num - 400)) : (\"C\" + IntToRoman(num - 100));\\n\\n        if (num >= 50) return num >= 90 ? (\"XC\" + IntToRoman(num - 90)) : (\"L\" + IntToRoman(num - 50));\\n\\n        if (num >= 10) return num >= 40 ? (\"XL\" + IntToRoman(num - 40)): (\"X\" + IntToRoman(num - 10));\\n\\n        if (num >= 5) return num == 9 ? \"IX\" : \"V\" + IntToRoman(num - 5);\\n\\n        if (num > 0) return num == 4 ? \"IV\" : \"I\" + IntToRoman(num - 1);\\n\\n        return \"\";\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public string IntToRoman(int num) {\\n        if (num >= 1000) return \"M\" + IntToRoman(num - 1000);\\n\\n        if (num >= 500) return num >= 900 ? (\"CM\" + IntToRoman(num - 900)) : (\"D\" + IntToRoman(num - 500));\\n\\n        if (num >= 100) return num >= 400 ? (\"CD\" + IntToRoman(num - 400)) : (\"C\" + IntToRoman(num - 100));\\n\\n        if (num >= 50) return num >= 90 ? (\"XC\" + IntToRoman(num - 90)) : (\"L\" + IntToRoman(num - 50));\\n\\n        if (num >= 10) return num >= 40 ? (\"XL\" + IntToRoman(num - 40)): (\"X\" + IntToRoman(num - 10));\\n\\n        if (num >= 5) return num == 9 ? \"IX\" : \"V\" + IntToRoman(num - 5);\\n\\n        if (num > 0) return num == 4 ? \"IV\" : \"I\" + IntToRoman(num - 1);\\n\\n        return \"\";\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3425736,
                "title": "best-and-easy-beginners-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n                Easiest Approaah using arrays \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n                  store the info and use it\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n                  O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n                  O(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public String intToRoman(int num) {\\n        String[] s={\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\\n        int[] values={1000,900,500,400,100,90,50,40,10,9,5,4,1};\\n        String t=\"\";\\n       int i=0;\\n       while(num>0){\\n           if(num>=values[i]){\\n               t+=s[i];\\n               num-=values[i];\\n           }\\n            else\\n           i++;\\n       }\\n        return t;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String intToRoman(int num) {\\n        String[] s={\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\\n        int[] values={1000,900,500,400,100,90,50,40,10,9,5,4,1};\\n        String t=\"\";\\n       int i=0;\\n       while(num>0){\\n           if(num>=values[i]){\\n               t+=s[i];\\n               num-=values[i];\\n           }\\n            else\\n           i++;\\n       }\\n        return t;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1536553,
                "title": "java-easy-solution-using-a-linkedhashmap",
                "content": "I noticed most of the solutions to this problem are using multiple arrays, instead I used a single LinkedHashMap to solve it.\\n\\n**Q. Why use LinkedHashMap instead of HashMap?\\nA. LinkedHashMap is ordered, HashMap is unordered.**\\n\\nsource: https://docs.oracle.com/javase/6/docs/api/java/util/LinkedHashMap.html\\n\\n```\\nclass Solution {\\n    public String intToRoman(int num) {\\n        LinkedHashMap<Integer, String> map = new LinkedHashMap<>();\\n        map.put(1000, \"M\");\\n        map.put(900, \"CM\");\\n        map.put(500, \"D\");\\n        map.put(400, \"CD\");\\n        map.put(100, \"C\");\\n        map.put(90, \"XC\");\\n        map.put(50, \"L\");\\n        map.put(40, \"XL\");\\n        map.put(10, \"X\");\\n        map.put(9, \"IX\");\\n        map.put(5, \"V\");\\n        map.put(4, \"IV\");\\n        map.put(1, \"I\");\\n        StringBuilder sb = new StringBuilder();\\n        for (Map.Entry<Integer, String> entry : map.entrySet()) {\\n            while (num >= entry.getKey()) {\\n                num -= entry.getKey();\\n                sb.append(entry.getValue());\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String intToRoman(int num) {\\n        LinkedHashMap<Integer, String> map = new LinkedHashMap<>();\\n        map.put(1000, \"M\");\\n        map.put(900, \"CM\");\\n        map.put(500, \"D\");\\n        map.put(400, \"CD\");\\n        map.put(100, \"C\");\\n        map.put(90, \"XC\");\\n        map.put(50, \"L\");\\n        map.put(40, \"XL\");\\n        map.put(10, \"X\");\\n        map.put(9, \"IX\");\\n        map.put(5, \"V\");\\n        map.put(4, \"IV\");\\n        map.put(1, \"I\");\\n        StringBuilder sb = new StringBuilder();\\n        for (Map.Entry<Integer, String> entry : map.entrySet()) {\\n            while (num >= entry.getKey()) {\\n                num -= entry.getKey();\\n                sb.append(entry.getValue());\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2723880,
                "title": "fastest-python-solution-using-mapping",
                "content": "```\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        i=1\\n        dic={1:\\'I\\',5:\\'V\\',10:\\'X\\',50:\\'L\\',100:\\'C\\',500:\\'D\\',1000:\\'M\\'}\\n        s=\"\"\\n        while num!=0:\\n            y=num%pow(10,i)//pow(10,i-1)\\n            if y==5:\\n                s=dic[y*pow(10,i-1)]+s\\n            elif y==1:\\n                s=dic[y*pow(10,i-1)]+s\\n            elif y==4:\\n                s=dic[1*pow(10,i-1)]+dic[5*pow(10,i-1)]+s\\n            elif y==9:\\n                s=dic[1*pow(10,i-1)]+dic[1*pow(10,i)]+s\\n            elif y<4:\\n                s=dic[pow(10,i-1)]*y+s\\n            elif y>5 and y<9:\\n                y-=5\\n                s=dic[5*pow(10,i-1)]+dic[pow(10,i-1)]*y+s\\n            num=num//pow(10,i)\\n            num*=pow(10,i)\\n            i+=1\\n        return s\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        i=1\\n        dic={1:\\'I\\',5:\\'V\\',10:\\'X\\',50:\\'L\\',100:\\'C\\',500:\\'D\\',1000:\\'M\\'}\\n        s=\"\"\\n        while num!=0:\\n            y=num%pow(10,i)//pow(10,i-1)\\n            if y==5:\\n                s=dic[y*pow(10,i-1)]+s\\n            elif y==1:\\n                s=dic[y*pow(10,i-1)]+s\\n            elif y==4:\\n                s=dic[1*pow(10,i-1)]+dic[5*pow(10,i-1)]+s\\n            elif y==9:\\n                s=dic[1*pow(10,i-1)]+dic[1*pow(10,i)]+s\\n            elif y<4:\\n                s=dic[pow(10,i-1)]*y+s\\n            elif y>5 and y<9:\\n                y-=5\\n                s=dic[5*pow(10,i-1)]+dic[pow(10,i-1)]*y+s\\n            num=num//pow(10,i)\\n            num*=pow(10,i)\\n            i+=1\\n        return s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 971772,
                "title": "c-0ms-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string romans[] = {\"I\",\"IV\",\"V\",\"IX\",\"X\",\"XL\",\"L\",\"XC\",\"C\",\"CD\",\"D\",\"CM\",\"M\"};\\n        int numerals[]={1,4,5,9,10,40,50,90,100,400,500,900,1000};\\n        string res;\\n        while(num)\\n        {\\n            for(int i=12;i>=0;i--)\\n            {\\n                int x = num/numerals[i];\\n                if(x)\\n                {\\n                    while(x--)\\n                    {\\n                        res += romans[i];\\n                    }\\n                    num %= numerals[i];\\n                    break;\\n                }\\n            }\\n        }   \\n        return res;\\n    }\\n};\\n```\\n\\n\\n**Runtime: 0 ms, faster than 100.00% of C++ online submissions for Integer to Roman.\\nMemory Usage: 6 MB, less than 99.00% of C++ online submissions for Integer to Roman.**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string romans[] = {\"I\",\"IV\",\"V\",\"IX\",\"X\",\"XL\",\"L\",\"XC\",\"C\",\"CD\",\"D\",\"CM\",\"M\"};\\n        int numerals[]={1,4,5,9,10,40,50,90,100,400,500,900,1000};\\n        string res;\\n        while(num)\\n        {\\n            for(int i=12;i>=0;i--)\\n            {\\n                int x = num/numerals[i];\\n                if(x)\\n                {\\n                    while(x--)\\n                    {\\n                        res += romans[i];\\n                    }\\n                    num %= numerals[i];\\n                    break;\\n                }\\n            }\\n        }   \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3202670,
                "title": "best-c-2-solution-hash-table-math-string-one-stop-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can solve this problem using String + Hash Table + Math.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can easily understand the all the approaches by seeing the code which is easy to understand with comments.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime complexity is given in code comment.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace complexity is given in code comment.\\n\\n# Code\\n```\\n/*\\n\\n    Time Complexity : O(1), We are scanning Array(val) of the number one by one therefore, the maximum time can\\n    be used to iterate over Array(val) is O(1) which is constant because we can maximum do around 18 iteration\\n    which is constant.\\n\\n    Space Complexity : O(1), We are using integer arrays and one string array whose sizes don\\u2019t depend on the\\n    input size hence the space complexity will be O(1).\\n\\n    Solved using String + Hash Table + Math.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 *****************************************/\\n\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string res;\\n        string sym[] = {\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"};\\n        int val[] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\\n\\n        for(int i=0; num != 0; i++){\\n            while(num >= val[i]){\\n                num -= val[i];\\n                res += sym[i];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(1), We are scanning each digit of the number one by one therefore, the time complexity\\n    will be O(log10N). But N cannot be grater than 3999, therefore, the maximum time can be O(loh103999) ~= \\n    O(3.60) which is constant hence the overall time complexity will be O(1).\\n\\n    Space Complexity : O(1), We are using four arrays whose sizes don\\u2019t depend on the input size hence the space\\n    complexity will be O(1).\\n\\n    Solved using String + Hash Table + Math.\\n\\n*/\\n\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        vector<string> ones = {\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"};\\n        vector<string> tens = {\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"};\\n        vector<string> hundred = {\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"};\\n        vector<string> thousand = {\"\", \"M\", \"MM\", \"MMM\"};\\n        \\n        string ans = \"\";\\n        \\n        ans += thousand[num/1000] + hundred[(num%1000)/100] + tens[(num%100)/10] + ones[num%10];\\n        return ans;\\n    }\\n};\\n\\n\\n\\n```\\n\\n***IF YOU LIKE THE SOLUTION THEN PLEASE UPVOTE MY SOLUTION BECAUSE IT GIVES ME MOTIVATION TO REGULARLY POST THE SOLUTION.***\\n\\n![WhatsApp Image 2023-02-10 at 19.01.02.jpeg](https://assets.leetcode.com/users/images/0a95fea4-64f4-4502-82aa-41db6d77c05c_1676054939.8270252.jpeg)",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Math",
                    "String"
                ],
                "code": "```\\n/*\\n\\n    Time Complexity : O(1), We are scanning Array(val) of the number one by one therefore, the maximum time can\\n    be used to iterate over Array(val) is O(1) which is constant because we can maximum do around 18 iteration\\n    which is constant.\\n\\n    Space Complexity : O(1), We are using integer arrays and one string array whose sizes don\\u2019t depend on the\\n    input size hence the space complexity will be O(1).\\n\\n    Solved using String + Hash Table + Math.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 *****************************************/\\n\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string res;\\n        string sym[] = {\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"};\\n        int val[] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\\n\\n        for(int i=0; num != 0; i++){\\n            while(num >= val[i]){\\n                num -= val[i];\\n                res += sym[i];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(1), We are scanning each digit of the number one by one therefore, the time complexity\\n    will be O(log10N). But N cannot be grater than 3999, therefore, the maximum time can be O(loh103999) ~= \\n    O(3.60) which is constant hence the overall time complexity will be O(1).\\n\\n    Space Complexity : O(1), We are using four arrays whose sizes don\\u2019t depend on the input size hence the space\\n    complexity will be O(1).\\n\\n    Solved using String + Hash Table + Math.\\n\\n*/\\n\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        vector<string> ones = {\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"};\\n        vector<string> tens = {\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"};\\n        vector<string> hundred = {\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"};\\n        vector<string> thousand = {\"\", \"M\", \"MM\", \"MMM\"};\\n        \\n        string ans = \"\";\\n        \\n        ans += thousand[num/1000] + hundred[(num%1000)/100] + tens[(num%100)/10] + ones[num%10];\\n        return ans;\\n    }\\n};\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2724009,
                "title": "java-easy-solution-100-faster-code",
                "content": "\\tPLEASE UPVOTE IF YOU LIKE.\\n```\\nclass Solution {\\n    private static final StringBuilder sb = new StringBuilder(15);\\n    \\n    private static final String[] thou = {\"\", \"M\", \"MM\", \"MMM\"};\\n    private static final String[] hund = {\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\",\"DCCC\",\"CM\"};\\n    private static final String[] tens = {\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\",\"LXX\",\"LXXX\",\"XC\"};\\n    private static final String[] ones = {\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\",\"VII\",\"VIII\",\"IX\"};\\n    \\n    public String intToRoman(int num) {\\n        sb.setLength(0);\\n        \\n        sb.append(thou[num/1000]);\\n        sb.append(hund[(num%1000)/100]);\\n        sb.append(tens[(num%100)/10]);\\n        sb.append(ones[num%10]);\\n        \\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private static final StringBuilder sb = new StringBuilder(15);\\n    \\n    private static final String[] thou = {\"\", \"M\", \"MM\", \"MMM\"};\\n    private static final String[] hund = {\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\",\"DCCC\",\"CM\"};\\n    private static final String[] tens = {\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\",\"LXX\",\"LXXX\",\"XC\"};\\n    private static final String[] ones = {\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\",\"VII\",\"VIII\",\"IX\"};\\n    \\n    public String intToRoman(int num) {\\n        sb.setLength(0);\\n        \\n        sb.append(thou[num/1000]);\\n        sb.append(hund[(num%1000)/100]);\\n        sb.append(tens[(num%100)/10]);\\n        sb.append(ones[num%10]);\\n        \\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 245498,
                "title": "c-greedy",
                "content": "Decrement large to small ```val``` from value vector by the largest possible amount each time  from ```num```\\n\\n```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string res = \"\";\\n        vector<int> val{1000,900,500,400,100,90,50,40,10,9,5,4,1};\\n        vector<string> str{\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\\n        for (int i = 0; i < val.size(); ++i) {\\n            while (num >= val[i]) {\\n                num -= val[i];\\n                res += str[i];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```val```\n```num```\n```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string res = \"\";\\n        vector<int> val{1000,900,500,400,100,90,50,40,10,9,5,4,1};\\n        vector<string> str{\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\\n        for (int i = 0; i < val.size(); ++i) {\\n            while (num >= val[i]) {\\n                num -= val[i];\\n                res += str[i];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 444278,
                "title": "java-runtime-3s-and-greater-than-100-100",
                "content": "```\\nclass Solution {\\n    public String intToRoman(int num) {\\n        StringBuilder result = new StringBuilder();\\n        int[] div = {1000, 900, 500, 400, 100, 90, \\n                     50, 40, 10, 9, 5, 4, 1};\\n        String[] roman = {\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \\n                          \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"};\\n        for (int i = 0; i < div.length;) {\\n            if (num >= div[i]) {\\n                result.append(roman[i]);\\n                num -= div[i];\\n            } else {\\n                i++;\\n            }\\n        }\\n        \\n        return result.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String intToRoman(int num) {\\n        StringBuilder result = new StringBuilder();\\n        int[] div = {1000, 900, 500, 400, 100, 90, \\n                     50, 40, 10, 9, 5, 4, 1};\\n        String[] roman = {\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \\n                          \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"};\\n        for (int i = 0; i < div.length;) {\\n            if (num >= div[i]) {\\n                result.append(roman[i]);\\n                num -= div[i];\\n            } else {\\n                i++;\\n            }\\n        }\\n        \\n        return result.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 6469,
                "title": "share-my-iterative-solution",
                "content": "    public String intToRoman(int num) {\\n        int[] weights={1000,900,500,400,100,90,50,40,10,9,5,4,1};\\n        String[] tokens={\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\\n        StringBuilder rs=new StringBuilder(\"\");\\n        int start=0;\\n        while(num>0){\\n            for(int i=start;i<13;i++){\\n                if(num>=weights[i]){\\n                    num-=weights[i];\\n                    rs.append(tokens[i]);\\n                    break;\\n                }\\n                start=i+1; // skip those impossible check, make it faster\\n            }\\n        }\\n        return rs.toString();\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public String intToRoman(int num) {\\n        int[] weights={1000,900,500,400,100,90,50,40,10,9,5,4,1};\\n        String[] tokens={\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\\n        StringBuilder rs=new StringBuilder(\"\");\\n        int start=0;\\n        while(num>0){\\n            for(int i=start;i<13;i++){\\n                if(num>=weights[i]){\\n                    num-=weights[i];\\n                    rs.append(tokens[i]);\\n                    break;\\n                }\\n                start=i+1; // skip those impossible check, make it faster\\n            }\\n        }\\n        return rs.toString();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1102756,
                "title": "python-stack-solution",
                "content": "My code:\\n\\n```\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        dct = {1: \\'I\\', 4: \\'IV\\', 5: \\'V\\', 9: \\'IX\\', 10: \\'X\\', 40: \\'XL\\', 50: \\'L\\', 90: \\'XC\\', 100: \\'C\\', 400: \\'CD\\', 500: \\'D\\', 900: \\'CM\\', 1000: \\'M\\'}\\n        stack = [1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000]\\n        ans = []\\n        while num > 0:\\n            if stack[-1] > num:\\n                stack.pop()\\n            else:\\n                num -= stack[-1]\\n                ans.append(dct[stack[-1]])\\n        return \"\".join(map(str, ans))\\n                \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        dct = {1: \\'I\\', 4: \\'IV\\', 5: \\'V\\', 9: \\'IX\\', 10: \\'X\\', 40: \\'XL\\', 50: \\'L\\', 90: \\'XC\\', 100: \\'C\\', 400: \\'CD\\', 500: \\'D\\', 900: \\'CM\\', 1000: \\'M\\'}\\n        stack = [1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000]\\n        ans = []\\n        while num > 0:\\n            if stack[-1] > num:\\n                stack.pop()\\n            else:\\n                num -= stack[-1]\\n                ans.append(dct[stack[-1]])\\n        return \"\".join(map(str, ans))\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 6405,
                "title": "my-solutions-in-java",
                "content": "\\n    public String intToRoman(int num) {\\n        String data[] = {\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\\n        int value[] = {1000,900,500,400,100,90,50,40,10,9,5,4,1}, base = -1;\\n        StringBuilder result = new StringBuilder();\\n\\n        for(int i = 0;i < data.length;i++){\\n            if((base=num/value[i])!=0){\\n                while(base--!=0)result.append(data[i]);\\n                num=num%value[i];\\n            }\\n        }\\n        return result.toString();\\n    }",
                "solutionTags": [],
                "code": "\\n    public String intToRoman(int num) {\\n        String data[] = {\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\\n        int value[] = {1000,900,500,400,100,90,50,40,10,9,5,4,1}, base = -1;\\n        StringBuilder result = new StringBuilder();\\n\\n        for(int i = 0;i < data.length;i++){\\n            if((base=num/value[i])!=0){\\n                while(base--!=0)result.append(data[i]);\\n                num=num%value[i];\\n            }\\n        }\\n        return result.toString();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1102727,
                "title": "python-java-clean-concise",
                "content": "**Python**\\n```python\\nclass Solution(object):\\n    def intToRoman(self, num):\\n        digits = [(1000, \"M\"), (900, \"CM\"), (500, \"D\"), (400, \"CD\"), (100, \"C\"), (90, \"XC\"), (50, \"L\"), (40, \"XL\"),\\n               (10, \"X\"), (9, \"IX\"), (5, \"V\"), (4, \"IV\"), (1, \"I\")]\\n\\n        ans = \"\"\\n        for n, s in digits:  # Maximum 13 operations\\n            while num >= n:  # Each while loop, maximum 3 operations, imagine case num=3\\n                ans += s\\n                num -= n\\n        return ans\\n```\\n\\n**Java**\\n```java\\nclass Solution {\\n    public String intToRoman(int num) {\\n        int[] values = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\\n        String[] symbols = {\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"};\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < values.length; i++) {\\n            while (num >= values[i]) {\\n                num -= values[i];\\n                sb.append(symbols[i]);\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```\\n\\n**Complexity:**\\n- Time & Space: `O(1)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution(object):\\n    def intToRoman(self, num):\\n        digits = [(1000, \"M\"), (900, \"CM\"), (500, \"D\"), (400, \"CD\"), (100, \"C\"), (90, \"XC\"), (50, \"L\"), (40, \"XL\"),\\n               (10, \"X\"), (9, \"IX\"), (5, \"V\"), (4, \"IV\"), (1, \"I\")]\\n\\n        ans = \"\"\\n        for n, s in digits:  # Maximum 13 operations\\n            while num >= n:  # Each while loop, maximum 3 operations, imagine case num=3\\n                ans += s\\n                num -= n\\n        return ans\\n```\n```java\\nclass Solution {\\n    public String intToRoman(int num) {\\n        int[] values = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\\n        String[] symbols = {\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"};\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < values.length; i++) {\\n            while (num >= values[i]) {\\n                num -= values[i];\\n                sb.append(symbols[i]);\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 689156,
                "title": "python3-smart-work-soln-4-line",
                "content": "```\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        M=[\"\",\"M\",\"MM\",\"MMM\"]\\n        C=[\"\",\"C\",\"CC\",\"CCC\",\"CD\",\"D\",\"DC\",\"DCC\",\"DCCC\",\"CM\"]\\n        X=[\"\",\"X\",\"XX\",\"XXX\",\"XL\",\"L\",\"LX\",\"LXX\",\"LXXX\",\"XC\"]\\n        I=[\"\",\"I\",\"II\",\"III\",\"IV\",\"V\",\"VI\",\"VII\",\"VIII\",\"IX\"]\\n        \\n        return M[num//1000]+C[(num//100)%10]+X[(num//10)%10]+I[num%10]\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Brainteaser"
                ],
                "code": "```\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        M=[\"\",\"M\",\"MM\",\"MMM\"]\\n        C=[\"\",\"C\",\"CC\",\"CCC\",\"CD\",\"D\",\"DC\",\"DCC\",\"DCCC\",\"CM\"]\\n        X=[\"\",\"X\",\"XX\",\"XXX\",\"XL\",\"L\",\"LX\",\"LXX\",\"LXXX\",\"XC\"]\\n        I=[\"\",\"I\",\"II\",\"III\",\"IV\",\"V\",\"VI\",\"VII\",\"VIII\",\"IX\"]\\n        \\n        return M[num//1000]+C[(num//100)%10]+X[(num//10)%10]+I[num%10]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 492037,
                "title": "java-easiest-solution-must-read",
                "content": "```\\npublic String intToRoman(int num) {\\n\\n\\tString[] thousands = {\"\",\"M\",\"MM\",\"MMM\"};\\n\\tString[] hundreds = {\"\",\"C\",\"CC\",\"CCC\",\"CD\",\"D\",\"DC\",\"DCC\",\"DCCC\",\"CM\"};\\n\\tString[] tens = {\"\",\"X\",\"XX\",\"XXX\",\"XL\",\"L\",\"LX\",\"LXX\",\"LXXX\",\"XC\"};\\n\\tString[] ones = {\"\",\"I\",\"II\",\"III\",\"IV\",\"V\",\"VI\",\"VII\",\"VIII\",\"IX\"};\\n\\n\\tStringBuilder sol = new StringBuilder();\\n\\tsol.append(thousands[num/1000])\\n\\t\\t.append(hundreds[(num%1000)/100])\\n\\t\\t.append(tens[(num%100)/10])\\n\\t\\t.append(ones[num%10]);\\n\\t\\t\\n\\treturn  sol.toString();\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic String intToRoman(int num) {\\n\\n\\tString[] thousands = {\"\",\"M\",\"MM\",\"MMM\"};\\n\\tString[] hundreds = {\"\",\"C\",\"CC\",\"CCC\",\"CD\",\"D\",\"DC\",\"DCC\",\"DCCC\",\"CM\"};\\n\\tString[] tens = {\"\",\"X\",\"XX\",\"XXX\",\"XL\",\"L\",\"LX\",\"LXX\",\"LXXX\",\"XC\"};\\n\\tString[] ones = {\"\",\"I\",\"II\",\"III\",\"IV\",\"V\",\"VI\",\"VII\",\"VIII\",\"IX\"};\\n\\n\\tStringBuilder sol = new StringBuilder();\\n\\tsol.append(thousands[num/1000])\\n\\t\\t.append(hundreds[(num%1000)/100])\\n\\t\\t.append(tens[(num%100)/10])\\n\\t\\t.append(ones[num%10]);\\n\\t\\t\\n\\treturn  sol.toString();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2289110,
                "title": "very-easy-100-c-java-javascript-fully-explained-line-by-line",
                "content": "# **C++ Solution:**\\n```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        //first we create a table of roman word and their values..\\n        vector<string> romanWord = {\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\", \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"};\\n        vector<int> value = {1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000};\\n        //initialize and set the index i...\\n        int i = romanWord.size() - 1;\\n        //create the solution which will be in string format...\\n        string sol = \"\";\\n        //a loop will be made to begin the procedure...\\n        while(num>0){\\n            //this loop is working untill the the vslue of integer is less or equal to num...\\n            while(value[i]<=num){\\n                //Append the roman numeral into an solution string...\\n                sol += romanWord[i];\\n                //subtract the integral value from the given integer...\\n                //Subtract the current number until the given integer is greater than the current number.\\n                num -= value[i];\\n            }\\n            i--;\\n        }\\n        //Once we are done with all the roman numerals, we return the solution.\\n        return sol;\\n    }\\n};\\n```\\n\\n# **Java Solution:**\\n```\\nclass Solution {\\n    public String intToRoman(int num) {\\n        //first we create a table of roman word and their values..\\n        String romanWord[] = {\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\", \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"};\\n        int value[] = {1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000};\\n        //initialize and set the index i...\\n        int i = romanWord.length - 1;\\n        //create the solution which will be in string format...\\n        String sol = \"\";\\n        //a loop will be made to begin the procedure...\\n        while(num>0){\\n            //this loop is working untill the the vslue of integer is less or equal to num...\\n            while(value[i]<=num){\\n                //Append the roman numeral into an solution string...\\n                sol += romanWord[i];\\n                //subtract the integral value from the given integer...\\n                //Subtract the current number until the given integer is greater than the current number.\\n                num -= value[i];\\n            }\\n            i--;\\n        }\\n        //Once we are done with all the roman numerals, we return the solution.\\n        return sol;\\n    }\\n}\\n```\\n\\n# **Javascript Solution:**\\n```\\n//Another approach is here..\\nvar intToRoman = function(num) {\\n    //create the list..\\n    const M = [\"\", \"M\", \"MM\", \"MMM\"];\\n    const C = [\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"];\\n    const X = [\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"];\\n    const I = [\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"];\\n    //return solution with this procedure...\\n    return M[Math.floor(num / 1000)] + C[Math.floor((num % 1000) / 100)] + X[Math.floor((num % 100) / 10)] + I[num % 10];\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "C",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        //first we create a table of roman word and their values..\\n        vector<string> romanWord = {\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\", \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"};\\n        vector<int> value = {1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000};\\n        //initialize and set the index i...\\n        int i = romanWord.size() - 1;\\n        //create the solution which will be in string format...\\n        string sol = \"\";\\n        //a loop will be made to begin the procedure...\\n        while(num>0){\\n            //this loop is working untill the the vslue of integer is less or equal to num...\\n            while(value[i]<=num){\\n                //Append the roman numeral into an solution string...\\n                sol += romanWord[i];\\n                //subtract the integral value from the given integer...\\n                //Subtract the current number until the given integer is greater than the current number.\\n                num -= value[i];\\n            }\\n            i--;\\n        }\\n        //Once we are done with all the roman numerals, we return the solution.\\n        return sol;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public String intToRoman(int num) {\\n        //first we create a table of roman word and their values..\\n        String romanWord[] = {\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\", \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"};\\n        int value[] = {1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000};\\n        //initialize and set the index i...\\n        int i = romanWord.length - 1;\\n        //create the solution which will be in string format...\\n        String sol = \"\";\\n        //a loop will be made to begin the procedure...\\n        while(num>0){\\n            //this loop is working untill the the vslue of integer is less or equal to num...\\n            while(value[i]<=num){\\n                //Append the roman numeral into an solution string...\\n                sol += romanWord[i];\\n                //subtract the integral value from the given integer...\\n                //Subtract the current number until the given integer is greater than the current number.\\n                num -= value[i];\\n            }\\n            i--;\\n        }\\n        //Once we are done with all the roman numerals, we return the solution.\\n        return sol;\\n    }\\n}\\n```\n```\\n//Another approach is here..\\nvar intToRoman = function(num) {\\n    //create the list..\\n    const M = [\"\", \"M\", \"MM\", \"MMM\"];\\n    const C = [\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"];\\n    const X = [\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"];\\n    const I = [\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"];\\n    //return solution with this procedure...\\n    return M[Math.floor(num / 1000)] + C[Math.floor((num % 1000) / 100)] + X[Math.floor((num % 100) / 10)] + I[num % 10];\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 928027,
                "title": "don-t-spend-too-much-time-on-this-problem-if-you-don-t-understand-the-logic-behind-roman-numerals",
                "content": "class Solution {\\n    public String intToRoman(int num) {\\n        \\n        // 42\\n        int[] values = {1000,900,500,400,100,90,50,40,10,9,5,4,1};\\n        String[] romanNumerals ={\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\\n        \\n        StringBuilder sb = new StringBuilder();\\n        \\n        for (int i = 0; i < values.length; i++) {\\n            \\n            while(num >= values[i]) {\\n                \\n                num -= values[i];\\n                sb.append(romanNumerals[i]);\\n            }\\n        }\\n        \\n        return sb.toString();\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public String intToRoman(int num) {\\n        \\n        // 42\\n        int[] values = {1000,900,500,400,100,90,50,40,10,9,5,4,1}",
                "codeTag": "Java"
            },
            {
                "id": 323502,
                "title": "a-simple-javascript-solution",
                "content": "```js\\n// build a roman set\\n// build a number set correspond roman set\\n// traverse set ,Decrease num\\nvar intToRoman = function(num) {\\n    var list = [\\'M\\', \\'CM\\', \\'D\\', \\'CD\\',\\'C\\',\\'XC\\',\\'L\\', \\'XL\\',\\'X\\',\\'IX\\',\\'V\\',\\'IV\\',\\'I\\']\\n    var valueList = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\\n    var result = \\'\\'\\n    while(num !== 0) {\\n        for(var i = 0 ; i < valueList.length ; i++) {\\n            if(num >= valueList[i]){\\n                result += list[i]\\n                num -= valueList[i]\\n                break\\n            }\\n        }\\n    }\\n    return result\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\n// build a roman set\\n// build a number set correspond roman set\\n// traverse set ,Decrease num\\nvar intToRoman = function(num) {\\n    var list = [\\'M\\', \\'CM\\', \\'D\\', \\'CD\\',\\'C\\',\\'XC\\',\\'L\\', \\'XL\\',\\'X\\',\\'IX\\',\\'V\\',\\'IV\\',\\'I\\']\\n    var valueList = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\\n    var result = \\'\\'\\n    while(num !== 0) {\\n        for(var i = 0 ; i < valueList.length ; i++) {\\n            if(num >= valueList[i]){\\n                result += list[i]\\n                num -= valueList[i]\\n                break\\n            }\\n        }\\n    }\\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 6438,
                "title": "straight-forward-java-recursive-solution",
                "content": "    public class Solution {\\n        public String intToRoman(int num) {\\n            if (num>=1000) {\\n                return (\"M\"+intToRoman(num-1000));\\n            } else if (num>=900) {\\n                return (\"CM\"+intToRoman(num-900));\\n            } else if (num>=500) {\\n                return (\"D\"+intToRoman(num-500));\\n            } else if (num>=400) {\\n                return (\"CD\"+intToRoman(num-400));\\n            } else if (num>=100) {\\n                return (\"C\"+intToRoman(num-100));\\n            } else if (num>=90) {\\n                return (\"XC\"+intToRoman(num-90));\\n            } else if (num>=50) {\\n                return (\"L\"+intToRoman(num-50));\\n            } else if (num>=40) {\\n                return (\"XL\"+intToRoman(num-40));\\n            } else if (num>=10) {\\n                return (\"X\"+intToRoman(num-10));\\n            } else if (num>=9) {\\n                return (\"IX\"+intToRoman(num-9));\\n            } else if (num>=5) {\\n                return (\"V\"+intToRoman(num-5));\\n            } else if (num>=4) {\\n                return (\"IV\"+intToRoman(num-4));\\n            } else if (num>=1) {\\n                return (\"I\"+intToRoman(num-1));\\n            }\\n            return (\"\");\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public String intToRoman(int num) {\\n            if (num>=1000) {\\n                return (\"M\"+intToRoman(num-1000));\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3968557,
                "title": "java-simple-solution-runtime-9ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport java.util.Enumeration;\\nimport java.util.Hashtable;\\n\\nclass Solution {\\n     public static String intToRoman(int num)\\n    {\\n        StringBuilder s = new StringBuilder();\\n\\n        Hashtable<Integer , String > list = new Hashtable<>();\\n        list.put(1 , \"I\");\\n        list.put(4 , \"IV\");\\n        list.put(5 , \"V\");\\n        list.put(9 , \"IX\");\\n        list.put(10 , \"X\");\\n        list.put(40 , \"XL\");\\n        list.put(50 , \"L\");\\n        list.put(90 , \"XC\");\\n        list.put(100 , \"C\");\\n        list.put(400 , \"CD\");\\n        list.put(500 , \"D\");\\n        list.put(900 , \"CM\");\\n        list.put(1000 , \"M\");\\n        \\n        while (num > 0)\\n        {\\n            int maxkey = getMaxKey(list , num);\\n            s.append(list.get(maxkey));\\n            num -= maxkey;\\n        }\\n        return s.toString();\\n    }\\n\\n    public static int getMaxKey(Hashtable list , int target)\\n    {\\n        int maxKey = -1;\\n\\n        Enumeration<Integer> keys = list.keys();\\n        while (keys.hasMoreElements()) {\\n            int key = keys.nextElement();\\n            if (key <= target && key > maxKey) {\\n                maxKey = key;\\n            }\\n        }\\n        return maxKey;\\n    }\\n}\\n```\\n\\n\\n![e78315ef-8a9d-492b-9908-e3917f23eb31_1674946036.087042.jpeg](https://assets.leetcode.com/users/images/8e0d7970-b648-4a25-9abb-98529499d16b_1693157592.6218796.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.Enumeration;\\nimport java.util.Hashtable;\\n\\nclass Solution {\\n     public static String intToRoman(int num)\\n    {\\n        StringBuilder s = new StringBuilder();\\n\\n        Hashtable<Integer , String > list = new Hashtable<>();\\n        list.put(1 , \"I\");\\n        list.put(4 , \"IV\");\\n        list.put(5 , \"V\");\\n        list.put(9 , \"IX\");\\n        list.put(10 , \"X\");\\n        list.put(40 , \"XL\");\\n        list.put(50 , \"L\");\\n        list.put(90 , \"XC\");\\n        list.put(100 , \"C\");\\n        list.put(400 , \"CD\");\\n        list.put(500 , \"D\");\\n        list.put(900 , \"CM\");\\n        list.put(1000 , \"M\");\\n        \\n        while (num > 0)\\n        {\\n            int maxkey = getMaxKey(list , num);\\n            s.append(list.get(maxkey));\\n            num -= maxkey;\\n        }\\n        return s.toString();\\n    }\\n\\n    public static int getMaxKey(Hashtable list , int target)\\n    {\\n        int maxKey = -1;\\n\\n        Enumeration<Integer> keys = list.keys();\\n        while (keys.hasMoreElements()) {\\n            int key = keys.nextElement();\\n            if (key <= target && key > maxKey) {\\n                maxKey = key;\\n            }\\n        }\\n        return maxKey;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3311278,
                "title": "c-java-c-python3-simple-easy-to-understand-efficient-clean-code",
                "content": "# Frequently encountered in technical interviews\\n```\\nstd::vector<std::pair<std::string, int>> interview_frequency= {\\n    {\"Amazon\", 27},\\n    {\"Microsoft\", 5},\\n    {\"Bloomberg\", 5},\\n    {\"Apple\", 3},\\n    {\"Capital One\", 3},\\n    {\"Adobe\", 2},\\n    {\"Google\", 2},\\n    {\"tiktok\", 2}\\n};\\n```\\n\\n# Solution\\n\\n\\n```C++ []\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        return convertRoman(num/1000, 4) + convertRoman((num%1000)/100, 3) + convertRoman((num%100)/10, 2) + convertRoman(num%10, 1);      \\n    }\\n\\nprivate:\\n    int values[7] { 1000, 500, 100, 50, 10, 5, 1 };\\n    string strs[7] { \"M\", \"D\", \"C\", \"L\", \"X\", \"V\", \"I\" };\\n    unordered_map<int, int> myDict {{4, 0}, {3, 2}, {2, 4}, {1, 6}};\\n\\n    string convertRoman(int digit, int value) {\\n        string res = \"\";\\n        int temp = myDict[value];\\n        if (temp == 0) \\n            res = repeat(strs[temp], digit);\\n        else {\\n            if (digit >= 1 && digit < 4) \\n                res += repeat(strs[temp], digit);\\n            else if (digit == 4) \\n                res += strs[temp] + strs[temp - 1];\\n            else if (digit >= 5 && digit < 9) \\n                res += strs[temp - 1] + repeat(strs[temp], (digit - 5));\\n            else if (digit == 9) \\n                res += strs[temp] + strs[temp - 2];\\n        }\\n        return res;\\n    }\\n\\n    string repeat(string repeatVal, int num) {\\n        string ret = \"\";\\n        while (num--) \\n            ret += repeatVal;\\n        return ret;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    private int[] values = {1000, 500, 100, 50, 10, 5, 1};\\n    private String[] strs = {\"M\", \"D\", \"C\", \"L\", \"X\", \"V\", \"I\"};\\n    private Map<Integer, Integer> myDict = new HashMap<Integer, Integer>() {{\\n        put(4, 0);\\n        put(3, 2);\\n        put(2, 4);\\n        put(1, 6);\\n    }};\\n\\n    public String intToRoman(int num) {\\n        return convertRoman(num/1000, 4) + convertRoman((num%1000)/100, 3) + convertRoman((num%100)/10, 2) + convertRoman(num%10, 1);      \\n    }\\n\\n    private String convertRoman(int digit, int value) {\\n        String res = \"\";\\n        int temp = myDict.get(value);\\n        if (temp == 0) \\n            res = repeat(strs[temp], digit);\\n        else {\\n            if (digit >= 1 && digit < 4) \\n                res += repeat(strs[temp], digit);\\n            else if (digit == 4) \\n                res += strs[temp] + strs[temp - 1];\\n            else if (digit >= 5 && digit < 9) \\n                res += strs[temp - 1] + repeat(strs[temp], (digit - 5));\\n            else if (digit == 9) \\n                res += strs[temp] + strs[temp - 2];\\n        }\\n        return res;\\n    }\\n\\n    private String repeat(String repeatVal, int num) {\\n        String ret = \"\";\\n        while (num-- > 0) \\n            ret += repeatVal;\\n        return ret;\\n    }\\n}\\n```\\n```csharp []\\npublic class Solution {\\n    private int[] values = {1000, 500, 100, 50, 10, 5, 1};\\n    private string[] strs = {\"M\", \"D\", \"C\", \"L\", \"X\", \"V\", \"I\"};\\n    private Dictionary<int, int> myDict = new Dictionary<int, int> {\\n        {4, 0},\\n        {3, 2},\\n        {2, 4},\\n        {1, 6}\\n    };\\n\\n    public string IntToRoman(int num) {\\n        return convertRoman(num/1000, 4) + convertRoman((num%1000)/100, 3) + convertRoman((num%100)/10, 2) + convertRoman(num%10, 1);      \\n    }\\n\\n    private string convertRoman(int digit, int value) {\\n        string res = \"\";\\n        int temp = myDict[value];\\n        if (temp == 0) \\n            res = repeat(strs[temp], digit);\\n        else {\\n            if (digit >= 1 && digit < 4) \\n                res += repeat(strs[temp], digit);\\n            else if (digit == 4) \\n                res += strs[temp] + strs[temp - 1];\\n            else if (digit >= 5 && digit < 9) \\n                res += strs[temp - 1] + repeat(strs[temp], (digit - 5));\\n            else if (digit == 9) \\n                res += strs[temp] + strs[temp - 2];\\n        }\\n        return res;\\n    }\\n\\n    private string repeat(string repeatVal, int num) {\\n        string ret = \"\";\\n        while (num-- > 0) \\n            ret += repeatVal;\\n        return ret;\\n    }\\n}\\n```\\n```python3 []\\nclass Solution:\\n    def __init__(self):\\n        self.values = [1000, 500, 100, 50, 10, 5, 1]\\n        self.strs = [\"M\", \"D\", \"C\", \"L\", \"X\", \"V\", \"I\"]\\n        self.myDict = {4: 0, 3: 2, 2: 4, 1: 6}\\n\\n    def intToRoman(self, num: int) -> str:\\n        return self.convertRoman(num//1000, 4) + self.convertRoman((num%1000)//100, 3) + self.convertRoman((num%100)//10, 2) + self.convertRoman(num%10, 1)\\n\\n    def convertRoman(self, digit: int, value: int) -> str:\\n        res = \"\"\\n        temp = self.myDict[value]\\n        if temp == 0:\\n            res = self.repeat(self.strs[temp], digit)\\n        else:\\n            if digit >= 1 and digit < 4:\\n                res += self.repeat(self.strs[temp], digit)\\n            elif digit == 4:\\n                res += self.strs[temp] + self.strs[temp - 1]\\n            elif digit >= 5 and digit < 9:\\n                res += self.strs[temp - 1] + self.repeat(self.strs[temp], (digit - 5))\\n            elif digit == 9:\\n                res += self.strs[temp] + self.strs[temp - 2]\\n        return res\\n\\n    def repeat(self, repeatVal: str, num: int) -> str:\\n        ret = \"\"\\n        while num > 0:\\n            ret += repeatVal\\n            num -= 1\\n        return ret\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Hash Table",
                    "Math"
                ],
                "code": "```\\nstd::vector<std::pair<std::string, int>> interview_frequency= {\\n    {\"Amazon\", 27},\\n    {\"Microsoft\", 5},\\n    {\"Bloomberg\", 5},\\n    {\"Apple\", 3},\\n    {\"Capital One\", 3},\\n    {\"Adobe\", 2},\\n    {\"Google\", 2},\\n    {\"tiktok\", 2}\\n};\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        return convertRoman(num/1000, 4) + convertRoman((num%1000)/100, 3) + convertRoman((num%100)/10, 2) + convertRoman(num%10, 1);      \\n    }\\n\\nprivate:\\n    int values[7] { 1000, 500, 100, 50, 10, 5, 1 };\\n    string strs[7] { \"M\", \"D\", \"C\", \"L\", \"X\", \"V\", \"I\" };\\n    unordered_map<int, int> myDict {{4, 0}, {3, 2}, {2, 4}, {1, 6}};\\n\\n    string convertRoman(int digit, int value) {\\n        string res = \"\";\\n        int temp = myDict[value];\\n        if (temp == 0) \\n            res = repeat(strs[temp], digit);\\n        else {\\n            if (digit >= 1 && digit < 4) \\n                res += repeat(strs[temp], digit);\\n            else if (digit == 4) \\n                res += strs[temp] + strs[temp - 1];\\n            else if (digit >= 5 && digit < 9) \\n                res += strs[temp - 1] + repeat(strs[temp], (digit - 5));\\n            else if (digit == 9) \\n                res += strs[temp] + strs[temp - 2];\\n        }\\n        return res;\\n    }\\n\\n    string repeat(string repeatVal, int num) {\\n        string ret = \"\";\\n        while (num--) \\n            ret += repeatVal;\\n        return ret;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    private int[] values = {1000, 500, 100, 50, 10, 5, 1};\\n    private String[] strs = {\"M\", \"D\", \"C\", \"L\", \"X\", \"V\", \"I\"};\\n    private Map<Integer, Integer> myDict = new HashMap<Integer, Integer>() {{\\n        put(4, 0);\\n        put(3, 2);\\n        put(2, 4);\\n        put(1, 6);\\n    }};\\n\\n    public String intToRoman(int num) {\\n        return convertRoman(num/1000, 4) + convertRoman((num%1000)/100, 3) + convertRoman((num%100)/10, 2) + convertRoman(num%10, 1);      \\n    }\\n\\n    private String convertRoman(int digit, int value) {\\n        String res = \"\";\\n        int temp = myDict.get(value);\\n        if (temp == 0) \\n            res = repeat(strs[temp], digit);\\n        else {\\n            if (digit >= 1 && digit < 4) \\n                res += repeat(strs[temp], digit);\\n            else if (digit == 4) \\n                res += strs[temp] + strs[temp - 1];\\n            else if (digit >= 5 && digit < 9) \\n                res += strs[temp - 1] + repeat(strs[temp], (digit - 5));\\n            else if (digit == 9) \\n                res += strs[temp] + strs[temp - 2];\\n        }\\n        return res;\\n    }\\n\\n    private String repeat(String repeatVal, int num) {\\n        String ret = \"\";\\n        while (num-- > 0) \\n            ret += repeatVal;\\n        return ret;\\n    }\\n}\\n```\n```csharp []\\npublic class Solution {\\n    private int[] values = {1000, 500, 100, 50, 10, 5, 1};\\n    private string[] strs = {\"M\", \"D\", \"C\", \"L\", \"X\", \"V\", \"I\"};\\n    private Dictionary<int, int> myDict = new Dictionary<int, int> {\\n        {4, 0},\\n        {3, 2},\\n        {2, 4},\\n        {1, 6}\\n    };\\n\\n    public string IntToRoman(int num) {\\n        return convertRoman(num/1000, 4) + convertRoman((num%1000)/100, 3) + convertRoman((num%100)/10, 2) + convertRoman(num%10, 1);      \\n    }\\n\\n    private string convertRoman(int digit, int value) {\\n        string res = \"\";\\n        int temp = myDict[value];\\n        if (temp == 0) \\n            res = repeat(strs[temp], digit);\\n        else {\\n            if (digit >= 1 && digit < 4) \\n                res += repeat(strs[temp], digit);\\n            else if (digit == 4) \\n                res += strs[temp] + strs[temp - 1];\\n            else if (digit >= 5 && digit < 9) \\n                res += strs[temp - 1] + repeat(strs[temp], (digit - 5));\\n            else if (digit == 9) \\n                res += strs[temp] + strs[temp - 2];\\n        }\\n        return res;\\n    }\\n\\n    private string repeat(string repeatVal, int num) {\\n        string ret = \"\";\\n        while (num-- > 0) \\n            ret += repeatVal;\\n        return ret;\\n    }\\n}\\n```\n```python3 []\\nclass Solution:\\n    def __init__(self):\\n        self.values = [1000, 500, 100, 50, 10, 5, 1]\\n        self.strs = [\"M\", \"D\", \"C\", \"L\", \"X\", \"V\", \"I\"]\\n        self.myDict = {4: 0, 3: 2, 2: 4, 1: 6}\\n\\n    def intToRoman(self, num: int) -> str:\\n        return self.convertRoman(num//1000, 4) + self.convertRoman((num%1000)//100, 3) + self.convertRoman((num%100)//10, 2) + self.convertRoman(num%10, 1)\\n\\n    def convertRoman(self, digit: int, value: int) -> str:\\n        res = \"\"\\n        temp = self.myDict[value]\\n        if temp == 0:\\n            res = self.repeat(self.strs[temp], digit)\\n        else:\\n            if digit >= 1 and digit < 4:\\n                res += self.repeat(self.strs[temp], digit)\\n            elif digit == 4:\\n                res += self.strs[temp] + self.strs[temp - 1]\\n            elif digit >= 5 and digit < 9:\\n                res += self.strs[temp - 1] + self.repeat(self.strs[temp], (digit - 5))\\n            elif digit == 9:\\n                res += self.strs[temp] + self.strs[temp - 2]\\n        return res\\n\\n    def repeat(self, repeatVal: str, num: int) -> str:\\n        ret = \"\"\\n        while num > 0:\\n            ret += repeatVal\\n            num -= 1\\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2725198,
                "title": "python-rust-c-three-easy-concise-solutions-with-detailed-comments",
                "content": "**IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n**** \\n**Python.** This [**solution**](https://leetcode.com/submissions/detail/826490173/) employs a repetition of Roman digits. It demonstrated **47 ms runtime (96.77%)** and used **13.9 MB memory (35.57%)**. Time complexity is contstant: **O(1)**. Space complexity is constant: **O(1)**.\\n```\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        \\n\\t\\t# Starting from Python 3.7, dictionary order is guaranteed \\n\\t\\t# to be insertion order\\n        num_to_roman = { 1000 : \"M\", 900 : \"CM\", 500 : \"D\", 400 : \"CD\",\\n                          100 : \"C\",  90 : \"XC\",  50 : \"L\",  40 : \"XL\",\\n                           10 : \"X\",   9 : \"IX\",   5 : \"V\",   4 : \"IV\",\\n                            1 : \"I\" }\\n        roman: str = \"\"\\n\\n        # The idea is to repeat each of Roman digits as many times\\n        # as needed to cover the decimal representation.\\n        for i, r in num_to_roman.items():\\n            roman += r * (num // i)\\n            num   %= i\\n        else:\\n            return roman\\n```\\n**** \\n**Rust.** This [**solution**](https://leetcode.com/submissions/detail/826504889/) employs a brute force digit substitution. It demonstrated **0 ms runtime (100.00%)** and used **2.0 MB memory (94.20%)**. Time complexity is constant: **O(1)**. Space complexity is constant: **O(1)**.\\n```\\nconst ONES : [&str;10] = [\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"];\\nconst TENS : [&str;10] = [\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"];\\nconst CENT : [&str;10] = [\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"];\\nconst MILS : [&str;4]  = [\"\", \"M\", \"MM\", \"MMM\"];\\n\\nimpl Solution \\n{\\n    pub fn int_to_roman(num: i32) -> String \\n    {\\n        // Given that the number of outcomes is small, a brute force\\n\\t\\t// substituion for each power of ten is a viable solution...\\n\\t\\tformat!(\"{}{}{}{}\", MILS[(num / 1000 % 10) as usize],\\n                            CENT[(num / 100  % 10) as usize],\\n                            TENS[(num / 10   % 10) as usize],\\n                            ONES[(num        % 10) as usize])\\n    }\\n}\\n```\\n**** \\n**\\u0421++.** This [**solution**](https://leetcode.com/submissions/detail/826509511/) employs an iterative build-up of a Roman number. It demonstrated **0 ms runtime (100.0%)** and used **6.1 MB memory (47.60%)**. Time complexity is constant: **O(1)**. Space complexity is constant: **O(1)**.\\n```\\nclass Solution \\n{\\n    const int    intgr[13] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\\n    const string roman[13] = {\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\\n\\npublic:\\n    string intToRoman(int num)\\n    {\\n        string rom = \"\";\\n\\t\\t\\n        for (int i = 0; num > 0; i++)\\n\\t\\t    // each digit is repeated as many times as needed to \\n\\t\\t\\t// completely cover the decimal representation \\n            while (num >= intgr[i]) rom += roman[i], num -= intgr[i];\\n        return rom;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "Python",
                    "C",
                    "Rust"
                ],
                "code": "```\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        \\n\\t\\t# Starting from Python 3.7, dictionary order is guaranteed \\n\\t\\t# to be insertion order\\n        num_to_roman = { 1000 : \"M\", 900 : \"CM\", 500 : \"D\", 400 : \"CD\",\\n                          100 : \"C\",  90 : \"XC\",  50 : \"L\",  40 : \"XL\",\\n                           10 : \"X\",   9 : \"IX\",   5 : \"V\",   4 : \"IV\",\\n                            1 : \"I\" }\\n        roman: str = \"\"\\n\\n        # The idea is to repeat each of Roman digits as many times\\n        # as needed to cover the decimal representation.\\n        for i, r in num_to_roman.items():\\n            roman += r * (num // i)\\n            num   %= i\\n        else:\\n            return roman\\n```\n```\\nconst ONES : [&str;10] = [\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"];\\nconst TENS : [&str;10] = [\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"];\\nconst CENT : [&str;10] = [\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"];\\nconst MILS : [&str;4]  = [\"\", \"M\", \"MM\", \"MMM\"];\\n\\nimpl Solution \\n{\\n    pub fn int_to_roman(num: i32) -> String \\n    {\\n        // Given that the number of outcomes is small, a brute force\\n\\t\\t// substituion for each power of ten is a viable solution...\\n\\t\\tformat!(\"{}{}{}{}\", MILS[(num / 1000 % 10) as usize],\\n                            CENT[(num / 100  % 10) as usize],\\n                            TENS[(num / 10   % 10) as usize],\\n                            ONES[(num        % 10) as usize])\\n    }\\n}\\n```\n```\\nclass Solution \\n{\\n    const int    intgr[13] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\\n    const string roman[13] = {\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\\n\\npublic:\\n    string intToRoman(int num)\\n    {\\n        string rom = \"\";\\n\\t\\t\\n        for (int i = 0; num > 0; i++)\\n\\t\\t    // each digit is repeated as many times as needed to \\n\\t\\t\\t// completely cover the decimal representation \\n            while (num >= intgr[i]) rom += roman[i], num -= intgr[i];\\n        return rom;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2724059,
                "title": "python-3-8-lines-w-example-t-m-99-5-46",
                "content": "```\\nclass Solution:\\n    def intToRoman(self, num: int) -> str: \\n\\n        mils = [\"\", \"M\", \"MM\", \"MMM\"]\\n\\n        cens = [ \"\",  \"C\",  \"CC\",  \"CCC\", \"CD\",\\n                \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"]\\n\\n        decs = [ \"\",  \"X\",  \"XX\",  \"XXX\", \"XL\",\\n                \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"]\\n\\n        unes = [ \"\",  \"I\",  \"II\",  \"III\", \"IV\",\\n                \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"]    #    EX:  num = 2579\\n\\n        m, num = divmod(num,1000)                  #  m = 2  num =  579\\n        c, num = divmod(num,100 )                  #  m = 5  num =   79\\n        d, u   = divmod(num,10  )                  #  m = 7  u   =    9\\n\\n        return mils[m]+cens[c]+decs[d]+unes[u]     #  mils[2]+cens[5]+decs[7]+unes[9] = MM + D + LXX + IX = MMDLXXIX \\n```\\n[https://leetcode.com/submissions/detail/826328411/](http://)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def intToRoman(self, num: int) -> str: \\n\\n        mils = [\"\", \"M\", \"MM\", \"MMM\"]\\n\\n        cens = [ \"\",  \"C\",  \"CC\",  \"CCC\", \"CD\",\\n                \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"]\\n\\n        decs = [ \"\",  \"X\",  \"XX\",  \"XXX\", \"XL\",\\n                \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"]\\n\\n        unes = [ \"\",  \"I\",  \"II\",  \"III\", \"IV\",\\n                \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"]    #    EX:  num = 2579\\n\\n        m, num = divmod(num,1000)                  #  m = 2  num =  579\\n        c, num = divmod(num,100 )                  #  m = 5  num =   79\\n        d, u   = divmod(num,10  )                  #  m = 7  u   =    9\\n\\n        return mils[m]+cens[c]+decs[d]+unes[u]     #  mils[2]+cens[5]+decs[7]+unes[9] = MM + D + LXX + IX = MMDLXXIX \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1744490,
                "title": "easy-c-solution-with-full-explanation",
                "content": "\\n> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistake please let me know. Thank you!\\u2764\\uFE0F**\\n> \\n\\n\\n---\\n\\n## Explanation:\\n\\n### Solution 01\\n\\n- Basic approach, taking all possible cases that can happen and making a while loop for every case.\\n- We\\u2019ll calculate from a large value and will continue until it\\u2019s reduced to any other cases.\\n- Add the character to the last of the ans string.\\n- **Time complexity:** O(n^2).\\n\\n### Solution 02\\n\\n- Here we store the values of all cases in a string and int variable.\\n- Here 13 possible cases can happen, so we run a loop for 13 indexes.\\n- Similar to the previous approach runs a while loop until num is greater or equal to current number of our array & add this to our ans array.\\n- **Time complexity:** O(n^2).\\n\\n---\\n\\n## Code:\\n\\n```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string ans=\"\";\\n        while(num >= 1000){\\n            ans += \"M\";\\n            num -= 1000;\\n        }\\n        if(num >= 900){\\n            ans += \"CM\";\\n            num -= 900;\\n        }\\n        while(num >= 500){\\n            ans += \"D\";\\n            num -= 500;\\n        }\\n        if(num >= 400){\\n            ans += \"CD\";\\n            num -= 400;\\n        }\\n        while(num >= 100){\\n            ans += \"C\";\\n            num -= 100;\\n        }\\n        if(num >= 90){\\n            ans += \"XC\";\\n            num -= 90;\\n        }\\n        while(num >= 50){\\n            ans += \"L\";\\n            num -= 50;\\n        }\\n        if(num >= 40){\\n            ans += \"XL\";\\n            num -= 40;\\n        }\\n        while(num >= 10){\\n            ans += \"X\";\\n            num -= 10;\\n        }\\n        if(num >= 9){\\n            ans += \"IX\";\\n            num -= 9;\\n        }\\n        while(num >= 5){\\n            ans += \"V\";\\n            num -= 5;\\n        }\\n        if(num >= 4){\\n            ans += \"IV\";\\n            num -= 4;\\n        }\\n        while(num >= 1){\\n            ans += \"I\";\\n            num -= 1;\\n        }\\n        return ans;\\n    }\\n};\\n\\n//Solution 02:\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string valr[]={\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\\n        int vali[]={1000,900,500,400,100,90,50,40,10,9,5,4,1};\\n        \\n        string ans;\\n        \\n        for(int i=0; i<13; i++){\\n            while(num >= vali[i]){\\n                ans.append(valr[i]);\\n                num -= vali[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n---\\n\\n> **Please upvote this solution**\\n>",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string ans=\"\";\\n        while(num >= 1000){\\n            ans += \"M\";\\n            num -= 1000;\\n        }\\n        if(num >= 900){\\n            ans += \"CM\";\\n            num -= 900;\\n        }\\n        while(num >= 500){\\n            ans += \"D\";\\n            num -= 500;\\n        }\\n        if(num >= 400){\\n            ans += \"CD\";\\n            num -= 400;\\n        }\\n        while(num >= 100){\\n            ans += \"C\";\\n            num -= 100;\\n        }\\n        if(num >= 90){\\n            ans += \"XC\";\\n            num -= 90;\\n        }\\n        while(num >= 50){\\n            ans += \"L\";\\n            num -= 50;\\n        }\\n        if(num >= 40){\\n            ans += \"XL\";\\n            num -= 40;\\n        }\\n        while(num >= 10){\\n            ans += \"X\";\\n            num -= 10;\\n        }\\n        if(num >= 9){\\n            ans += \"IX\";\\n            num -= 9;\\n        }\\n        while(num >= 5){\\n            ans += \"V\";\\n            num -= 5;\\n        }\\n        if(num >= 4){\\n            ans += \"IV\";\\n            num -= 4;\\n        }\\n        while(num >= 1){\\n            ans += \"I\";\\n            num -= 1;\\n        }\\n        return ans;\\n    }\\n};\\n\\n//Solution 02:\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string valr[]={\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\\n        int vali[]={1000,900,500,400,100,90,50,40,10,9,5,4,1};\\n        \\n        string ans;\\n        \\n        for(int i=0; i<13; i++){\\n            while(num >= vali[i]){\\n                ans.append(valr[i]);\\n                num -= vali[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1119875,
                "title": "solution-in-java-100-faster",
                "content": "```\\nclass Solution {\\n    public String intToRoman(int num) {\\n        int[] v = {1000,900,500,400,100,90,50,40,10,9,5,4,1};\\n        String[] s = {\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\\n        StringBuilder sb=new StringBuilder();\\n        \\n        for(int i=0;i<v.length;i++){\\n            while(num>=v[i]){\\n                sb.append(s[i]);\\n                num-=v[i];\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```\\nPlease **upvote**, if you like the solution:)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String intToRoman(int num) {\\n        int[] v = {1000,900,500,400,100,90,50,40,10,9,5,4,1};\\n        String[] s = {\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\\n        StringBuilder sb=new StringBuilder();\\n        \\n        for(int i=0;i<v.length;i++){\\n            while(num>=v[i]){\\n                sb.append(s[i]);\\n                num-=v[i];\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1102909,
                "title": "c-simplest-straight-forward-solution-0-ms-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        vector<string> roman = {\"M\", \"D\", \"C\", \"L\", \"X\", \"V\", \"I\"};\\n        vector<int> integers = {1000, 500, 100, 50, 10, 5, 1};\\n        vector<int> carry = {100, 100, 10, 10, 1, 1, 0};\\n        \\n        string res = \"\";\\n        int next;\\n        \\n        for (int i = 0; num; i++) {\\n            \\n            int temp = num / integers[i];\\n            while (temp--) res += roman[i];\\n            num %= integers[i];\\n            \\n            if (i == 6) return res;\\n            \\n            next = carry[i];\\n            if ((num - num % next) == (integers[i] - next)) {\\n                res += i % 2 ? roman[i+1] + roman[i] : roman[i+2] + roman[i];\\n                num -= integers[i] - next;\\n            }\\n            \\n        }\\n        return res;\\n    }\\n};\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        vector<string> roman = {\"M\", \"D\", \"C\", \"L\", \"X\", \"V\", \"I\"};\\n        vector<int> integers = {1000, 500, 100, 50, 10, 5, 1};\\n        vector<int> carry = {100, 100, 10, 10, 1, 1, 0};\\n        \\n        string res = \"\";\\n        int next;\\n        \\n        for (int i = 0; num; i++) {\\n            \\n            int temp = num / integers[i];\\n            while (temp--) res += roman[i];\\n            num %= integers[i];\\n            \\n            if (i == 6) return res;\\n            \\n            next = carry[i];\\n            if ((num - num % next) == (integers[i] - next)) {\\n                res += i % 2 ? roman[i+1] + roman[i] : roman[i+2] + roman[i];\\n                num -= integers[i] - next;\\n            }\\n            \\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 204750,
                "title": "easy-with-javascript",
                "content": "```\\nfunction intToRoman(num) {\\n    var hash = [\\n        [\\'\\', \\'I\\', \\'II\\', \\'III\\', \\'IV\\', \\'V\\', \\'VI\\', \\'VII\\', \\'VIII\\', \\'IX\\'],\\n        [\\'\\', \\'X\\', \\'XX\\', \\'XXX\\', \\'XL\\', \\'L\\', \\'LX\\', \\'LXX\\', \\'LXXX\\', \\'XC\\'],\\n        [\\'\\', \\'C\\', \\'CC\\', \\'CCC\\', \\'CD\\', \\'D\\', \\'DC\\', \\'DCC\\', \\'DCCC\\', \\'CM\\'],\\n        [\\'\\', \\'M\\', \\'MM\\', \\'MMM\\']\\n    ];\\n    \\n    var result = \\'\\';\\n    var counter = 0;\\n    while (num > 0) {\\n        result = hash[counter++][num % 10] + result;\\n        num = Math.floor(num / 10);\\n    }\\n    \\n    return result;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nfunction intToRoman(num) {\\n    var hash = [\\n        [\\'\\', \\'I\\', \\'II\\', \\'III\\', \\'IV\\', \\'V\\', \\'VI\\', \\'VII\\', \\'VIII\\', \\'IX\\'],\\n        [\\'\\', \\'X\\', \\'XX\\', \\'XXX\\', \\'XL\\', \\'L\\', \\'LX\\', \\'LXX\\', \\'LXXX\\', \\'XC\\'],\\n        [\\'\\', \\'C\\', \\'CC\\', \\'CCC\\', \\'CD\\', \\'D\\', \\'DC\\', \\'DCC\\', \\'DCCC\\', \\'CM\\'],\\n        [\\'\\', \\'M\\', \\'MM\\', \\'MMM\\']\\n    ];\\n    \\n    var result = \\'\\';\\n    var counter = 0;\\n    while (num > 0) {\\n        result = hash[counter++][num % 10] + result;\\n        num = Math.floor(num / 10);\\n    }\\n    \\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 169178,
                "title": "simple-java-solution-with-treemap",
                "content": "```\\nimport java.util.HashMap;\\nimport java.util.Map;\\nimport java.util.TreeMap;\\n\\nclass Solution {\\n\\n    public static TreeMap<Integer, String> map = new TreeMap<>();\\n\\n    static {\\n\\n        map.put(1,\"I\");\\n        map.put(5, \"V\");\\n        map.put(10, \"X\");\\n        map.put(50, \"L\");\\n        map.put(100, \"C\");\\n        map.put(500, \"D\");\\n        map.put(1000, \"M\");\\n        map.put(4, \"IV\");\\n        map.put(9, \"IX\");\\n        map.put(40, \"XL\");\\n        map.put(90, \"XC\");\\n        map.put(400, \"CD\");\\n        map.put(900, \"CM\");\\n    }\\n    public static String intToRoman(int num) {\\n        StringBuilder ans = new StringBuilder();\\n        while (num != 0) {\\n            Map.Entry<Integer, String> entry = map.floorEntry(num);\\n            ans.append(entry.getValue());\\n            num -= entry.getKey();\\n        }\\n        return ans.toString();\\n\\n    }\\n\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport java.util.HashMap;\\nimport java.util.Map;\\nimport java.util.TreeMap;\\n\\nclass Solution {\\n\\n    public static TreeMap<Integer, String> map = new TreeMap<>();\\n\\n    static {\\n\\n        map.put(1,\"I\");\\n        map.put(5, \"V\");\\n        map.put(10, \"X\");\\n        map.put(50, \"L\");\\n        map.put(100, \"C\");\\n        map.put(500, \"D\");\\n        map.put(1000, \"M\");\\n        map.put(4, \"IV\");\\n        map.put(9, \"IX\");\\n        map.put(40, \"XL\");\\n        map.put(90, \"XC\");\\n        map.put(400, \"CD\");\\n        map.put(900, \"CM\");\\n    }\\n    public static String intToRoman(int num) {\\n        StringBuilder ans = new StringBuilder();\\n        while (num != 0) {\\n            Map.Entry<Integer, String> entry = map.floorEntry(num);\\n            ans.append(entry.getValue());\\n            num -= entry.getKey();\\n        }\\n        return ans.toString();\\n\\n    }\\n\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3114050,
                "title": "js-ts-clean-and-easy-solution-beats-98-5",
                "content": "```\\nfunction intToRoman(num: number): string {\\n    const rNums: Record<string,number> = {\\n      M:1000,\\n      CM:900,\\n      D:500,\\n      CD:400,\\n      C:100,\\n      XC:90,\\n      L:50,\\n      XL:40,\\n      X:10,\\n      IX:9,\\n      V:5,\\n      IV:4,\\n      I:1\\n    };\\n    let result = \\'\\';\\n    for(let rN in rNums){\\n        let count = num / rNums[rN];\\n        if(count>0) {\\n            result+= rN.repeat(count);\\n            num = num % rNums[rN];\\n        }\\n    }\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction intToRoman(num: number): string {\\n    const rNums: Record<string,number> = {\\n      M:1000,\\n      CM:900,\\n      D:500,\\n      CD:400,\\n      C:100,\\n      XC:90,\\n      L:50,\\n      XL:40,\\n      X:10,\\n      IX:9,\\n      V:5,\\n      IV:4,\\n      I:1\\n    };\\n    let result = \\'\\';\\n    for(let rN in rNums){\\n        let count = num / rNums[rN];\\n        if(count>0) {\\n            result+= rN.repeat(count);\\n            num = num % rNums[rN];\\n        }\\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2613942,
                "title": "python-solution",
                "content": "```\\ndef intToRoman(self, num: int) -> str:\\n\\tdic = {\"M\": 1000, \"CM\": 900, \"D\": 500, \"CD\": 400,\\n\\t   \"C\": 100, \"XC\": 90, \"L\": 50, \"XL\": 40, \"X\": 10,\\n\\t   \"IX\": 9, \"V\": 5, \"IV\": 4, \"I\": 1}\\n\\n\\toutput = \"\"\\n\\tfor key, value in dic.items():\\n\\t\\toutput += key * (num // value)\\n\\t\\tif num // value != 0:\\n\\t\\t\\tnum -= (value * (num // value))\\n\\n\\treturn output\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef intToRoman(self, num: int) -> str:\\n\\tdic = {\"M\": 1000, \"CM\": 900, \"D\": 500, \"CD\": 400,\\n\\t   \"C\": 100, \"XC\": 90, \"L\": 50, \"XL\": 40, \"X\": 10,\\n\\t   \"IX\": 9, \"V\": 5, \"IV\": 4, \"I\": 1}\\n\\n\\toutput = \"\"\\n\\tfor key, value in dic.items():\\n\\t\\toutput += key * (num // value)\\n\\t\\tif num // value != 0:\\n\\t\\t\\tnum -= (value * (num // value))\\n\\n\\treturn output\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2568037,
                "title": "javascript-simple-solution",
                "content": "```\\nvar intToRoman = function(num) {\\n    let roman = {\\n        \\'M\\':  1000, \\'CM\\': 900, \\'D\\':  500, \\'CD\\': 400,\\n        \\'C\\':  100,  \\'XC\\': 90,  \\'L\\':  50,  \\'XL\\': 40,\\n        \\'X\\':  10,   \\'IX\\': 9,   \\'V\\':  5,   \\'IV\\': 4, \\'I\\':  1\\n    },  \\n\\tromanNum = \\'\\';\\n\\t\\n    for(let i in roman){\\n        while(num >= roman[i]){\\n            romanNum += i;\\n            num -= roman[i];\\n        }\\n    }\\n    return romanNum; \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar intToRoman = function(num) {\\n    let roman = {\\n        \\'M\\':  1000, \\'CM\\': 900, \\'D\\':  500, \\'CD\\': 400,\\n        \\'C\\':  100,  \\'XC\\': 90,  \\'L\\':  50,  \\'XL\\': 40,\\n        \\'X\\':  10,   \\'IX\\': 9,   \\'V\\':  5,   \\'IV\\': 4, \\'I\\':  1\\n    },  \\n\\tromanNum = \\'\\';\\n\\t\\n    for(let i in roman){\\n        while(num >= roman[i]){\\n            romanNum += i;\\n            num -= roman[i];\\n        }\\n    }\\n    return romanNum; \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2240419,
                "title": "c-2methods-easy-and-fast",
                "content": "**METHOD 1: Short and easy**\\n\\nEach quotient will tell how much is the value / what should be the Roman Symbol\\n\\n//KHELO DIMAAG SE XD\\n```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string ones[] = {\"\",\"I\",\"II\",\"III\",\"IV\",\"V\",\"VI\",\"VII\",\"VIII\",\"IX\"};\\n        string tens[] = {\"\",\"X\",\"XX\",\"XXX\",\"XL\",\"L\",\"LX\",\"LXX\",\"LXXX\",\"XC\"};\\n        string hrns[] = {\"\",\"C\",\"CC\",\"CCC\",\"CD\",\"D\",\"DC\",\"DCC\",\"DCCC\",\"CM\"};\\n        string ths[]={\"\",\"M\",\"MM\",\"MMM\"};\\n        \\n        return ths[num/1000] + hrns[(num%1000)/100] + tens[(num%100)/10] + ones[num%10];\\n    }\\n};\\n\\n```\\n\\n**Guy\\'s if you find this solution helpful \\uD83D\\uDE0A, PLEASE do UPVOTE. By doing that it motivate\\'s me to create more better post like this \\u270D\\uFE0F\\nIf you have some \\uD83E\\uDD14 doubts feel free to bug me (^~^)***\\n```\\n\\n```\\n\\n**METHOD 2: correct but quite bulky ;)**\\n\\nSuppose num = 1984\\nwe split it as : 1000 + 900 + 80 + 4 \\nand at each iteration compare it\\'s value.\\n\\nSpecial cases are dealt separately. (4,9,40,90,400,90)\\n\\n80 is internally split as : 50 + 10 +10 +10\\nSEE RANGES of num in the if-else ladder \\n\\nand atlast we do num = num - val;\\n\\n```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string ans=\"\";\\n        int val=1;\\n        while(num>0){\\n            string ch=\"\";\\n            if(num>=1000)\\n                val=1000;\\n            else if(num>=900)\\n                val=900;\\n            else if(num>=500)\\n                val=500;\\n            else if(num>=400)\\n                val=400;\\n            else if(num>=100)\\n                val=100;\\n            else if(num>=90)\\n                val=90;\\n            else if(num>=50)\\n                val=50;\\n            else if(num>=40)\\n                val=40;\\n            else if(num>=10)\\n                val=10;\\n            else if(num==9)\\n                val=9;\\n            else if(num>=5)\\n                val=5;\\n            else if(num==4)\\n                val=4;\\n            else if(num>=1)\\n                val=1;\\n            \\n            switch(val){\\n                case 1: ch=\"I\";break;\\n                case 5: ch=\"V\";break;\\n                case 10: ch=\"X\";break;\\n                case 50: ch=\"L\";break;\\n                case 100: ch=\"C\";break;\\n                case 500: ch=\"D\";break;\\n                case 1000: ch=\"M\";break;\\n                case 4: ch=\"IV\";break;\\n                case 9: ch=\"IX\";break;\\n                case 40: ch=\"XL\";break;\\n                case 90: ch=\"XC\";break;\\n                case 400: ch=\"CD\";break;\\n                case 900: ch=\"CM\";break;\\n            }\\n            ans+=ch;\\n            num=num-val;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string ones[] = {\"\",\"I\",\"II\",\"III\",\"IV\",\"V\",\"VI\",\"VII\",\"VIII\",\"IX\"};\\n        string tens[] = {\"\",\"X\",\"XX\",\"XXX\",\"XL\",\"L\",\"LX\",\"LXX\",\"LXXX\",\"XC\"};\\n        string hrns[] = {\"\",\"C\",\"CC\",\"CCC\",\"CD\",\"D\",\"DC\",\"DCC\",\"DCCC\",\"CM\"};\\n        string ths[]={\"\",\"M\",\"MM\",\"MMM\"};\\n        \\n        return ths[num/1000] + hrns[(num%1000)/100] + tens[(num%100)/10] + ones[num%10];\\n    }\\n};\\n\\n```\n```\\n\\n```\n```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string ans=\"\";\\n        int val=1;\\n        while(num>0){\\n            string ch=\"\";\\n            if(num>=1000)\\n                val=1000;\\n            else if(num>=900)\\n                val=900;\\n            else if(num>=500)\\n                val=500;\\n            else if(num>=400)\\n                val=400;\\n            else if(num>=100)\\n                val=100;\\n            else if(num>=90)\\n                val=90;\\n            else if(num>=50)\\n                val=50;\\n            else if(num>=40)\\n                val=40;\\n            else if(num>=10)\\n                val=10;\\n            else if(num==9)\\n                val=9;\\n            else if(num>=5)\\n                val=5;\\n            else if(num==4)\\n                val=4;\\n            else if(num>=1)\\n                val=1;\\n            \\n            switch(val){\\n                case 1: ch=\"I\";break;\\n                case 5: ch=\"V\";break;\\n                case 10: ch=\"X\";break;\\n                case 50: ch=\"L\";break;\\n                case 100: ch=\"C\";break;\\n                case 500: ch=\"D\";break;\\n                case 1000: ch=\"M\";break;\\n                case 4: ch=\"IV\";break;\\n                case 9: ch=\"IX\";break;\\n                case 40: ch=\"XL\";break;\\n                case 90: ch=\"XC\";break;\\n                case 400: ch=\"CD\";break;\\n                case 900: ch=\"CM\";break;\\n            }\\n            ans+=ch;\\n            num=num-val;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1311405,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public String intToRoman(int num) {\\n        int[] no={1000,900,500,400,100,90,50,40,10,9,5,4,1};\\n        String[] code={\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\\n        \\n        StringBuilder sb=new StringBuilder();\\n        for(int i=0;i<no.length;i++)\\n        {\\n            while(num >= no[i])\\n            {\\n                sb.append(code[i]);\\n                num-=no[i];\\n            }\\n        }\\n        \\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String intToRoman(int num) {\\n        int[] no={1000,900,500,400,100,90,50,40,10,9,5,4,1};\\n        String[] code={\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\\n        \\n        StringBuilder sb=new StringBuilder();\\n        for(int i=0;i<no.length;i++)\\n        {\\n            while(num >= no[i])\\n            {\\n                sb.append(code[i]);\\n                num-=no[i];\\n            }\\n        }\\n        \\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1168743,
                "title": "go-4ms-3-3mb-solution-with-0-b-op-and-0-aloc-op",
                "content": "```go\\nvar (\\n\\tr0 = []string{\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"}\\n\\tr1 = []string{\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"}\\n\\tr2 = []string{\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"}\\n\\tr3 = []string{\"\", \"M\", \"MM\", \"MMM\"}\\n)\\n\\nfunc intToRoman(num int) string {\\n\\t// This is efficient in Go. The 4 operands are evaluated,\\n\\t// then a single allocation is made of the exact size needed for the result.\\n\\treturn r3[num%1e4/1e3] + r2[num%1e3/1e2] + r1[num%100/10] + r0[num%10]\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nvar (\\n\\tr0 = []string{\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"}\\n\\tr1 = []string{\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"}\\n\\tr2 = []string{\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"}\\n\\tr3 = []string{\"\", \"M\", \"MM\", \"MMM\"}\\n)\\n\\nfunc intToRoman(num int) string {\\n\\t// This is efficient in Go. The 4 operands are evaluated,\\n\\t// then a single allocation is made of the exact size needed for the result.\\n\\treturn r3[num%1e4/1e3] + r2[num%1e3/1e2] + r1[num%100/10] + r0[num%10]\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1103708,
                "title": "java-simple-and-easy-to-understand-solution-3-ms-faster-than-100-00-with-efficient-memory-usage",
                "content": "# PLEASE UPVOTE IF YOU LIKE THIS SOLUTION\\n\\n```\\nclass Solution {\\n    static String[] symbol = new String[]{\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\", \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"};\\n    static int[] value = new int[]{1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000};\\n    \\n    public String intToRoman(int num) {\\n\\n        \\n        StringBuilder sb = new StringBuilder();\\n        int i = value.length - 1;\\n        \\n        //Logic\\n        //Subtract num with value[i] till num is greater than Zero, \\n        // if num is greater/equal to value[i], and append Corresponding symbol\\n        // else just move lower value\\n         \\n        while(num > 0 && i >= 0){\\n            \\n            if(num < value[i]){\\n                //just move to lower value\\n                i--;\\n            } else {\\n                //decreament num with Current value\\n                num -= value[i];\\n                \\n                //now append the corresponding symbol\\n                sb.append(symbol[i]);\\n            }\\n        }\\n        \\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    static String[] symbol = new String[]{\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\", \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"};\\n    static int[] value = new int[]{1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000};\\n    \\n    public String intToRoman(int num) {\\n\\n        \\n        StringBuilder sb = new StringBuilder();\\n        int i = value.length - 1;\\n        \\n        //Logic\\n        //Subtract num with value[i] till num is greater than Zero, \\n        // if num is greater/equal to value[i], and append Corresponding symbol\\n        // else just move lower value\\n         \\n        while(num > 0 && i >= 0){\\n            \\n            if(num < value[i]){\\n                //just move to lower value\\n                i--;\\n            } else {\\n                //decreament num with Current value\\n                num -= value[i];\\n                \\n                //now append the corresponding symbol\\n                sb.append(symbol[i]);\\n            }\\n        }\\n        \\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 491557,
                "title": "python-o-log-n-o-1-100-100-simple-intuitive",
                "content": "```\\nclass Solution:\\n\\tdef intToRoman(self, num: int) -> str:\\n\\t\\tres = \"\"\\n\\t\\ts=1000\\n\\n\\t\\td = {1:\"I\", 5:\"V\", 10:\"X\", 50:\"L\", 100:\"C\", 500:\"D\", 1000:\"M\"}\\n\\n\\t\\twhile num!=0:\\n\\t\\t\\tr, temp = divmod(num, s)\\n\\n\\t\\t\\tif r==9:\\n\\t\\t\\t\\tres+=d[s]+d[s*10]\\n\\t\\t\\telif r==4:\\n\\t\\t\\t\\tres+=d[s]+d[s*5]\\n\\t\\t\\telif r>=5:\\n\\t\\t\\t\\tres+=d[s*5] + d[s]*(r-5) \\n\\t\\t\\telse:\\n\\t\\t\\t\\tres += d[s]*r\\n\\n\\t\\t\\ts=s//10\\n\\t\\t\\tnum=temp\\n\\n\\t\\treturn res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n\\tdef intToRoman(self, num: int) -> str:\\n\\t\\tres = \"\"\\n\\t\\ts=1000\\n\\n\\t\\td = {1:\"I\", 5:\"V\", 10:\"X\", 50:\"L\", 100:\"C\", 500:\"D\", 1000:\"M\"}\\n\\n\\t\\twhile num!=0:\\n\\t\\t\\tr, temp = divmod(num, s)\\n\\n\\t\\t\\tif r==9:\\n\\t\\t\\t\\tres+=d[s]+d[s*10]\\n\\t\\t\\telif r==4:\\n\\t\\t\\t\\tres+=d[s]+d[s*5]\\n\\t\\t\\telif r>=5:\\n\\t\\t\\t\\tres+=d[s*5] + d[s]*(r-5) \\n\\t\\t\\telse:\\n\\t\\t\\t\\tres += d[s]*r\\n\\n\\t\\t\\ts=s//10\\n\\t\\t\\tnum=temp\\n\\n\\t\\treturn res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 389377,
                "title": "easy-to-understand-python3",
                "content": "We are basically creating a dict for mapping the numerals, and then substracting the values from the `num` variable, starting with the highest, and on every substraction we add the corresponding roman numeral.\\n\\nYou can use an `OrderedDict` instead of having the extra list `arr` that i\\'m using, but I don\\'t think theres much of a performance difference.\\n```\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        mapping = {\\n            1: \"I\",\\n            4: \"IV\",\\n            5: \"V\",\\n            9: \"IX\",\\n            10: \"X\",\\n            40: \"XL\",\\n            50: \"L\",\\n            90: \"XC\",\\n            100: \"C\",\\n            400: \"CD\",\\n            500: \"D\",\\n            900: \"CM\",\\n            1000: \"M\",\\n        }\\n        arr = [1000,900,500,400,100,90,50,40,10,9,5,4,1]\\n        result = \"\"\\n        for a in arr:\\n            while num >= a:\\n                num = num - a\\n                result = result + mapping[a]\\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        mapping = {\\n            1: \"I\",\\n            4: \"IV\",\\n            5: \"V\",\\n            9: \"IX\",\\n            10: \"X\",\\n            40: \"XL\",\\n            50: \"L\",\\n            90: \"XC\",\\n            100: \"C\",\\n            400: \"CD\",\\n            500: \"D\",\\n            900: \"CM\",\\n            1000: \"M\",\\n        }\\n        arr = [1000,900,500,400,100,90,50,40,10,9,5,4,1]\\n        result = \"\"\\n        for a in arr:\\n            while num >= a:\\n                num = num - a\\n                result = result + mapping[a]\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 241683,
                "title": "simple-python-beats-99",
                "content": "```\\nclass Solution(object):\\n    def intToRoman(self, num):\\n        \"\"\"\\n        :type num: int\\n        :rtype: str\\n        \"\"\"\\n        if not num: return\\n        \\n        out = \\'\\'\\n        \\n        values = [ 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 ]\\n        Roman = [ \"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\" ]\\n        \\n        for i in range (len(values)):\\n            while num >= values[i]:\\n                num -= values[i]\\n                out += Roman[i]\\n        return out\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def intToRoman(self, num):\\n        \"\"\"\\n        :type num: int\\n        :rtype: str\\n        \"\"\"\\n        if not num: return\\n        \\n        out = \\'\\'\\n        \\n        values = [ 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 ]\\n        Roman = [ \"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\" ]\\n        \\n        for i in range (len(values)):\\n            while num >= values[i]:\\n                num -= values[i]\\n                out += Roman[i]\\n        return out\\n```",
                "codeTag": "Java"
            },
            {
                "id": 233083,
                "title": "95-python-solution-that-s-easy-to-grok",
                "content": "While looking through the Python solutions trying to figure out how to get mine faster I was surprised that none were similar to mine, so...\\n\\n```python\\nret = \"\" \\nroman_to_int = [ \\n    (\"M\", 1000),\\n    (\"CM\", 900),\\n    (\"D\", 500),\\n    (\"CD\", 400),\\n    (\"C\", 100),\\n    (\"XC\", 90),\\n    (\"L\", 50),\\n    (\"XL\", 40),\\n    (\"X\", 10),\\n    (\"IX\", 9),\\n    (\"V\", 5),\\n    (\"IV\", 4),\\n    (\"I\", 1),\\n]\\n\\nfor roman, value in roman_to_int:\\n    while num >= value:\\n        ret += roman \\n        num -= value\\n    \\nreturn ret\\n```\\n",
                "solutionTags": [],
                "code": "```python\\nret = \"\" \\nroman_to_int = [ \\n    (\"M\", 1000),\\n    (\"CM\", 900),\\n    (\"D\", 500),\\n    (\"CD\", 400),\\n    (\"C\", 100),\\n    (\"XC\", 90),\\n    (\"L\", 50),\\n    (\"XL\", 40),\\n    (\"X\", 10),\\n    (\"IX\", 9),\\n    (\"V\", 5),\\n    (\"IV\", 4),\\n    (\"I\", 1),\\n]\\n\\nfor roman, value in roman_to_int:\\n    while num >= value:\\n        ret += roman \\n        num -= value\\n    \\nreturn ret\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3752772,
                "title": "beats-99-55-brute-force-easy-to-understand-beginner-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n![image.png](https://assets.leetcode.com/users/images/207d1a5c-ba36-4766-bf5d-574a7adbc53e_1690968849.1358607.png)\\n\\n# Code\\n```\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        x = \\'\\'\\n        while num!=0:\\n            if num>= 1000:\\n                x+=\\'M\\'\\n                num-=1000\\n            elif num>= 900:\\n                x+=\\'CM\\'\\n                num-=900\\n            elif num>= 500:\\n                x+=\\'D\\'\\n                num-= 500\\n            elif num>= 400: \\n                x+=\\'CD\\' \\n                num-= 400\\n            elif num>= 100:\\n                x+=\\'C\\'\\n                num-=100\\n            elif num>= 90:\\n                x+=\\'XC\\' \\n                num-=90\\n            elif num>= 50:\\n                x+=\\'L\\' \\n                num-=50\\n            elif num>= 40:\\n                x+=\\'XL\\' \\n                num-=40\\n            elif num>= 10:\\n                x+=\\'X\\' \\n                num-=10\\n            elif num>= 9:\\n                x+=\\'IX\\' \\n                num-=9\\n            elif num>= 5:\\n                x+=\\'V\\' \\n                num-=5\\n            elif num>= 4:\\n                x+=\\'IV\\' \\n                num-=4\\n            else:\\n                x+=\\'I\\'\\n                num-=1\\n        return x\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        x = \\'\\'\\n        while num!=0:\\n            if num>= 1000:\\n                x+=\\'M\\'\\n                num-=1000\\n            elif num>= 900:\\n                x+=\\'CM\\'\\n                num-=900\\n            elif num>= 500:\\n                x+=\\'D\\'\\n                num-= 500\\n            elif num>= 400: \\n                x+=\\'CD\\' \\n                num-= 400\\n            elif num>= 100:\\n                x+=\\'C\\'\\n                num-=100\\n            elif num>= 90:\\n                x+=\\'XC\\' \\n                num-=90\\n            elif num>= 50:\\n                x+=\\'L\\' \\n                num-=50\\n            elif num>= 40:\\n                x+=\\'XL\\' \\n                num-=40\\n            elif num>= 10:\\n                x+=\\'X\\' \\n                num-=10\\n            elif num>= 9:\\n                x+=\\'IX\\' \\n                num-=9\\n            elif num>= 5:\\n                x+=\\'V\\' \\n                num-=5\\n            elif num>= 4:\\n                x+=\\'IV\\' \\n                num-=4\\n            else:\\n                x+=\\'I\\'\\n                num-=1\\n        return x\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2724066,
                "title": "c-solution-easy-5-line-function",
                "content": "# Looking for Contribution in Hacktoberfest\\n## You are welcomed to contribute in my Repos:-\\n# GITHUB LINK --> [Yaduttam95](https://github.com/Yaduttam95)\\n\\n# If you liked the solution please UPVOTE \\uD83D\\uDC4D\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    \\n    string intToRoman(int A) {\\n\\n    string ones[] = {\"\",\"I\",\"II\",\"III\",\"IV\",\"V\",\"VI\",\"VII\",\"VIII\",\"IX\"};\\n\\n    string tens[] = {\"\",\"X\",\"XX\",\"XXX\",\"XL\",\"L\",\"LX\",\"LXX\",\"LXXX\",\"XC\"};\\n\\n    string hrns[] = {\"\",\"C\",\"CC\",\"CCC\",\"CD\",\"D\",\"DC\",\"DCC\",\"DCCC\",\"CM\"};\\n\\n    string thns[] = {\"\",\"M\",\"MM\",\"MMM\"};\\n\\n    \\n\\n    return thns[A/1000] + hrns[(A%1000)/100] + tens[(A%100)/10] + ones[A%10];\\n\\n}\\n};\\n```\\n\\n\\n## if you reached till here and solution worked for you kindly upvote the solution",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    \\n    string intToRoman(int A) {\\n\\n    string ones[] = {\"\",\"I\",\"II\",\"III\",\"IV\",\"V\",\"VI\",\"VII\",\"VIII\",\"IX\"};\\n\\n    string tens[] = {\"\",\"X\",\"XX\",\"XXX\",\"XL\",\"L\",\"LX\",\"LXX\",\"LXXX\",\"XC\"};\\n\\n    string hrns[] = {\"\",\"C\",\"CC\",\"CCC\",\"CD\",\"D\",\"DC\",\"DCC\",\"DCCC\",\"CM\"};\\n\\n    string thns[] = {\"\",\"M\",\"MM\",\"MMM\"};\\n\\n    \\n\\n    return thns[A/1000] + hrns[(A%1000)/100] + tens[(A%100)/10] + ones[A%10];\\n\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2723812,
                "title": "daily-leetcode-solution-easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string ans=\"\";\\n        int Value[]={1000,900,500,400,100,90,50,40,10,9,5,4,1};\\n        string Symbol[]={\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\\n        for(int i=0;num!=0;i++)\\n        {\\n            while(num>=Value[i])\\n            {\\n                ans+=Symbol[i];\\n                num-=Value[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string ans=\"\";\\n        int Value[]={1000,900,500,400,100,90,50,40,10,9,5,4,1};\\n        string Symbol[]={\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\\n        for(int i=0;num!=0;i++)\\n        {\\n            while(num>=Value[i])\\n            {\\n                ans+=Symbol[i];\\n                num-=Value[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2489093,
                "title": "simple-solution-no-loop",
                "content": "```\\nclass Solution {\\n    public String intToRoman(int n) {\\n     \\n    String units[]={\"\",\"I\",\"II\",\"III\",\"IV\",\"V\",\"VI\",\"VII\",\"VIII\",\"IX\"};\\n        \\n String tens[]={\"\",\"X\",\"XX\",\"XXX\",\"XL\",\"L\",\"LX\",\"LXX\",\"LXXX\",\"XC\"};\\n        \\nString hundreds[]=  {\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"};\\n        \\nString thousands[]={\"\",\"M\",\"MM\",\"MMM\"};\\n\\n        \\n        return (thousands[n/1000]+\\n               hundreds[(n % 1000)/100]+\\n                tens[(n%100)/10]+\\n               units[n%10]);\\n        \\n        \\n    }\\n}  \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String intToRoman(int n) {\\n     \\n    String units[]={\"\",\"I\",\"II\",\"III\",\"IV\",\"V\",\"VI\",\"VII\",\"VIII\",\"IX\"};\\n        \\n String tens[]={\"\",\"X\",\"XX\",\"XXX\",\"XL\",\"L\",\"LX\",\"LXX\",\"LXXX\",\"XC\"};\\n        \\nString hundreds[]=  {\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"};\\n        \\nString thousands[]={\"\",\"M\",\"MM\",\"MMM\"};\\n\\n        \\n        return (thousands[n/1000]+\\n               hundreds[(n % 1000)/100]+\\n                tens[(n%100)/10]+\\n               units[n%10]);\\n        \\n        \\n    }\\n}  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2427934,
                "title": "java-solution-using-treemap",
                "content": "```\\n\\tpublic String intToRoman(int num) {\\n        TreeMap<Integer, String> tm = new TreeMap<Integer, String>();\\n        tm.put(1,\"I\");\\n        tm.put(5,\"V\");\\n        tm.put(10,\"X\");\\n        tm.put(50,\"L\");\\n        tm.put(100,\"C\");\\n        tm.put(500,\"D\");\\n        tm.put(1000,\"M\");\\n        tm.put(4,\"IV\");\\n        tm.put(9,\"IX\");\\n        tm.put(40,\"XL\");\\n        tm.put(90,\"XC\");\\n        tm.put(400,\"CD\");\\n        tm.put(900,\"CM\");\\n        \\n        StringBuilder romanNumeral = new StringBuilder(\"\");\\n        while(num > 0){\\n            int nearestNum = tm.floorKey(num);\\n            romanNumeral.append(tm.get(nearestNum));\\n            num = num - nearestNum;\\n        }\\n        \\n        return romanNumeral.toString();\\n        \\n    }\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\n\\tpublic String intToRoman(int num) {\\n        TreeMap<Integer, String> tm = new TreeMap<Integer, String>();\\n        tm.put(1,\"I\");\\n        tm.put(5,\"V\");\\n        tm.put(10,\"X\");\\n        tm.put(50,\"L\");\\n        tm.put(100,\"C\");\\n        tm.put(500,\"D\");\\n        tm.put(1000,\"M\");\\n        tm.put(4,\"IV\");\\n        tm.put(9,\"IX\");\\n        tm.put(40,\"XL\");\\n        tm.put(90,\"XC\");\\n        tm.put(400,\"CD\");\\n        tm.put(900,\"CM\");\\n        \\n        StringBuilder romanNumeral = new StringBuilder(\"\");\\n        while(num > 0){\\n            int nearestNum = tm.floorKey(num);\\n            romanNumeral.append(tm.get(nearestNum));\\n            num = num - nearestNum;\\n        }\\n        \\n        return romanNumeral.toString();\\n        \\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2140059,
                "title": "rust-o-1-super-efficient-simple-with-thorough-explanation-0ms",
                "content": "Conversion to Roman numerals is O(1) time-complexity and space complexity is also constant.\\n\\nExplanation: The array of Roman numerals from 0 to 3999 is indexed by the input value, `num`.\\n\\n\\u2728\\uD83D\\uDE01 \\u2728\\n\\n```rust\\n\\nimpl Solution {\\n    pub fn int_to_roman(num: i32) -> String {\\n        NUMERALS[num as usize].to_string()\\n    }\\n}\\n\\nconst NUMERALS: [&str; 4000] = [\\n    \"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\",\"VIII\", \"IX\", \"X\", \"XI\", \\n    \"XII\", \"XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"XVIII\", \"XIX\", \"XX\", \"XXI\",\\n    \"XXII\", \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\", \"XXVIII\", \"XXIX\", \\n    \"XXX\", \"XXXI\", \"XXXII\", \"XXXIII\", \"XXXIV\", \"XXXV\", \"XXXVI\", \"XXXVII\", \\n    \"XXXVIII\", \"XXXIX\", \"XL\", \"XLI\", \"XLII\", \"XLIII\", \"XLIV\", \"XLV\", \"XLVI\",\\n    \"XLVII\", \"XLVIII\", \"XLIX\", \"L\", \"LI\", \"LII\", \"LIII\", \"LIV\", \"LV\", \"LVI\",\\n    \"LVII\", \"LVIII\", \"LIX\", \"LX\", \"LXI\", \"LXII\", \"LXIII\", \"LXIV\", \"LXV\", \\n    \"LXVI\", \"LXVII\", \"LXVIII\", \"LXIX\", \"LXX\", \"LXXI\", \"LXXII\", \"LXXIII\", \\n    \"LXXIV\", \"LXXV\", \"LXXVI\", \"LXXVII\", \"LXXVIII\", \"LXXIX\", \"LXXX\", \"LXXXI\",\\n    \"LXXXII\", \"LXXXIII\", \"LXXXIV\", \"LXXXV\", \"LXXXVI\", \"LXXXVII\", \"LXXXVIII\",\\n    \"LXXXIX\", \"XC\", \"XCI\", \"XCII\", \"XCIII\", \"XCIV\", \"XCV\", \"XCVI\", \"XCVII\", \\n    \"XCVIII\", \"XCIX\", \"C\", \"CI\", \"CII\", \"CIII\", \"CIV\", \"CV\", \"CVI\", \"CVII\", \\n    \"CVIII\", \"CIX\", \"CX\", \"CXI\", \"CXII\", \"CXIII\", \"CXIV\", \"CXV\", \"CXVI\", \\n    \"CXVII\", \"CXVIII\", \"CXIX\", \"CXX\", \"CXXI\", \"CXXII\", \"CXXIII\", \"CXXIV\", \\n    \"CXXV\", \"CXXVI\", \"CXXVII\", \"CXXVIII\", \"CXXIX\", \"CXXX\", \"CXXXI\", \\n    \"CXXXII\", \"CXXXIII\", \"CXXXIV\", \"CXXXV\", \"CXXXVI\", \"CXXXVII\", \"CXXXVIII\",\\n    \"CXXXIX\", \"CXL\", \"CXLI\", \"CXLII\", \"CXLIII\", \"CXLIV\", \"CXLV\", \"CXLVI\", \\n    \"CXLVII\", \"CXLVIII\", \"CXLIX\", \"CL\", \"CLI\", \"CLII\", \"CLIII\", \"CLIV\", \\n    \"CLV\", \"CLVI\", \"CLVII\", \"CLVIII\", \"CLIX\", \"CLX\", \"CLXI\", \"CLXII\", \\n    \"CLXIII\", \"CLXIV\", \"CLXV\", \"CLXVI\", \"CLXVII\", \"CLXVIII\", \"CLXIX\", \\n    \"CLXX\", \"CLXXI\", \"CLXXII\", \"CLXXIII\", \"CLXXIV\", \"CLXXV\", \"CLXXVI\", \\n    \"CLXXVII\", \"CLXXVIII\", \"CLXXIX\", \"CLXXX\", \"CLXXXI\", \"CLXXXII\", \\n    \"CLXXXIII\", \"CLXXXIV\", \"CLXXXV\", \"CLXXXVI\", \"CLXXXVII\", \"CLXXXVIII\", \\n    \"CLXXXIX\", \"CXC\", \"CXCI\", \"CXCII\", \"CXCIII\", \"CXCIV\", \"CXCV\", \"CXCVI\", \\n    \"CXCVII\", \"CXCVIII\", \"CXCIX\", \"CC\", \"CCI\", \"CCII\", \"CCIII\", \"CCIV\", \\n    \"CCV\", \"CCVI\", \"CCVII\", \"CCVIII\", \"CCIX\", \"CCX\", \"CCXI\", \"CCXII\", \\n    \"CCXIII\", \"CCXIV\", \"CCXV\", \"CCXVI\", \"CCXVII\", \"CCXVIII\", \"CCXIX\", \\n    \"CCXX\", \"CCXXI\", \"CCXXII\", \"CCXXIII\", \"CCXXIV\", \"CCXXV\", \"CCXXVI\", \\n    \"CCXXVII\", \"CCXXVIII\", \"CCXXIX\", \"CCXXX\", \"CCXXXI\", \"CCXXXII\", \\n    \"CCXXXIII\", \"CCXXXIV\", \"CCXXXV\", \"CCXXXVI\", \"CCXXXVII\", \"CCXXXVIII\", \\n    \"CCXXXIX\", \"CCXL\", \"CCXLI\", \"CCXLII\", \"CCXLIII\", \"CCXLIV\", \"CCXLV\", \\n    \"CCXLVI\", \"CCXLVII\", \"CCXLVIII\", \"CCXLIX\", \"CCL\", \"CCLI\", \"CCLII\", \\n    \"CCLIII\", \"CCLIV\", \"CCLV\", \"CCLVI\", \"CCLVII\", \"CCLVIII\", \"CCLIX\", \\n    \"CCLX\", \"CCLXI\", \"CCLXII\", \"CCLXIII\", \"CCLXIV\", \"CCLXV\", \"CCLXVI\", \\n    \"CCLXVII\", \"CCLXVIII\", \"CCLXIX\", \"CCLXX\", \"CCLXXI\", \"CCLXXII\", \\n    \"CCLXXIII\", \"CCLXXIV\", \"CCLXXV\", \"CCLXXVI\", \"CCLXXVII\", \"CCLXXVIII\", \\n    \"CCLXXIX\", \"CCLXXX\", \"CCLXXXI\", \"CCLXXXII\", \"CCLXXXIII\", \"CCLXXXIV\", \\n    \"CCLXXXV\", \"CCLXXXVI\", \"CCLXXXVII\", \"CCLXXXVIII\", \"CCLXXXIX\", \"CCXC\", \\n    \"CCXCI\", \"CCXCII\", \"CCXCIII\", \"CCXCIV\", \"CCXCV\", \"CCXCVI\", \"CCXCVII\", \\n    \"CCXCVIII\", \"CCXCIX\", \"CCC\", \"CCCI\", \"CCCII\", \"CCCIII\", \"CCCIV\", \"CCCV\",\\n    \"CCCVI\", \"CCCVII\", \"CCCVIII\", \"CCCIX\", \"CCCX\", \"CCCXI\", \"CCCXII\", \\n    \"CCCXIII\", \"CCCXIV\", \"CCCXV\", \"CCCXVI\", \"CCCXVII\", \"CCCXVIII\", \"CCCXIX\", \\n    \"CCCXX\", \"CCCXXI\", \"CCCXXII\", \"CCCXXIII\", \"CCCXXIV\", \"CCCXXV\", \\n    \"CCCXXVI\", \"CCCXXVII\", \"CCCXXVIII\", \"CCCXXIX\", \"CCCXXX\", \"CCCXXXI\", \\n    \"CCCXXXII\", \"CCCXXXIII\", \"CCCXXXIV\", \"CCCXXXV\", \"CCCXXXVI\", \"CCCXXXVII\", \\n    \"CCCXXXVIII\", \"CCCXXXIX\", \"CCCXL\", \"CCCXLI\", \"CCCXLII\", \"CCCXLIII\", \\n    \"CCCXLIV\", \"CCCXLV\", \"CCCXLVI\", \"CCCXLVII\", \"CCCXLVIII\", \"CCCXLIX\", \\n    \"CCCL\", \"CCCLI\", \"CCCLII\", \"CCCLIII\", \"CCCLIV\", \"CCCLV\", \"CCCLVI\", \\n    \"CCCLVII\", \"CCCLVIII\", \"CCCLIX\", \"CCCLX\", \"CCCLXI\", \"CCCLXII\", \\n    \"CCCLXIII\", \"CCCLXIV\", \"CCCLXV\", \"CCCLXVI\", \"CCCLXVII\", \"CCCLXVIII\", \\n    \"CCCLXIX\", \"CCCLXX\", \"CCCLXXI\", \"CCCLXXII\", \"CCCLXXIII\", \"CCCLXXIV\", \\n    \"CCCLXXV\", \"CCCLXXVI\", \"CCCLXXVII\", \"CCCLXXVIII\", \"CCCLXXIX\", \"CCCLXXX\", \\n    \"CCCLXXXI\", \"CCCLXXXII\", \"CCCLXXXIII\", \"CCCLXXXIV\", \"CCCLXXXV\", \\n    \"CCCLXXXVI\", \"CCCLXXXVII\", \"CCCLXXXVIII\", \"CCCLXXXIX\", \"CCCXC\", \\n    \"CCCXCI\", \"CCCXCII\", \"CCCXCIII\", \"CCCXCIV\", \"CCCXCV\", \"CCCXCVI\", \\n    \"CCCXCVII\", \"CCCXCVIII\", \"CCCXCIX\", \"CD\", \"CDI\", \"CDII\", \"CDIII\", \\n    \"CDIV\", \"CDV\", \"CDVI\", \"CDVII\", \"CDVIII\", \"CDIX\", \"CDX\", \"CDXI\", \\n    \"CDXII\", \"CDXIII\", \"CDXIV\", \"CDXV\", \"CDXVI\", \"CDXVII\", \"CDXVIII\", \\n    \"CDXIX\", \"CDXX\", \"CDXXI\", \"CDXXII\", \"CDXXIII\", \"CDXXIV\", \"CDXXV\", \\n    \"CDXXVI\", \"CDXXVII\", \"CDXXVIII\", \"CDXXIX\", \"CDXXX\", \"CDXXXI\", \"CDXXXII\",\\n    \"CDXXXIII\", \"CDXXXIV\", \"CDXXXV\", \"CDXXXVI\", \"CDXXXVII\", \"CDXXXVIII\", \\n    \"CDXXXIX\", \"CDXL\", \"CDXLI\", \"CDXLII\", \"CDXLIII\", \"CDXLIV\", \"CDXLV\", \\n    \"CDXLVI\", \"CDXLVII\", \"CDXLVIII\", \"CDXLIX\", \"CDL\", \"CDLI\", \"CDLII\", \\n    \"CDLIII\", \"CDLIV\", \"CDLV\", \"CDLVI\", \"CDLVII\", \"CDLVIII\", \"CDLIX\", \\n    \"CDLX\", \"CDLXI\", \"CDLXII\", \"CDLXIII\", \"CDLXIV\", \"CDLXV\", \"CDLXVI\", \\n    \"CDLXVII\", \"CDLXVIII\", \"CDLXIX\", \"CDLXX\", \"CDLXXI\", \"CDLXXII\", \\n    \"CDLXXIII\", \"CDLXXIV\", \"CDLXXV\", \"CDLXXVI\", \"CDLXXVII\", \"CDLXXVIII\", \\n    \"CDLXXIX\", \"CDLXXX\", \"CDLXXXI\", \"CDLXXXII\", \"CDLXXXIII\", \"CDLXXXIV\", \\n    \"CDLXXXV\", \"CDLXXXVI\", \"CDLXXXVII\", \"CDLXXXVIII\", \"CDLXXXIX\", \"CDXC\", \\n    \"CDXCI\", \"CDXCII\", \"CDXCIII\", \"CDXCIV\", \"CDXCV\", \"CDXCVI\", \"CDXCVII\", \\n    \"CDXCVIII\", \"CDXCIX\", \"D\", \"DI\", \"DII\", \"DIII\", \"DIV\", \"DV\", \"DVI\", \\n    \"DVII\", \"DVIII\", \"DIX\", \"DX\", \"DXI\", \"DXII\", \"DXIII\", \"DXIV\", \"DXV\", \\n    \"DXVI\", \"DXVII\", \"DXVIII\", \"DXIX\", \"DXX\", \"DXXI\", \"DXXII\", \"DXXIII\", \\n    \"DXXIV\", \"DXXV\", \"DXXVI\", \"DXXVII\", \"DXXVIII\", \"DXXIX\", \"DXXX\", \"DXXXI\", \\n    \"DXXXII\", \"DXXXIII\", \"DXXXIV\", \"DXXXV\", \"DXXXVI\", \"DXXXVII\", \"DXXXVIII\", \\n    \"DXXXIX\", \"DXL\", \"DXLI\", \"DXLII\", \"DXLIII\", \"DXLIV\", \"DXLV\", \"DXLVI\", \\n    \"DXLVII\", \"DXLVIII\", \"DXLIX\", \"DL\", \"DLI\", \"DLII\", \"DLIII\", \"DLIV\", \\n    \"DLV\", \"DLVI\", \"DLVII\", \"DLVIII\", \"DLIX\", \"DLX\", \"DLXI\", \"DLXII\", \\n    \"DLXIII\", \"DLXIV\", \"DLXV\", \"DLXVI\", \"DLXVII\", \"DLXVIII\", \"DLXIX\", \\n    \"DLXX\", \"DLXXI\", \"DLXXII\", \"DLXXIII\", \"DLXXIV\", \"DLXXV\", \"DLXXVI\", \\n    \"DLXXVII\", \"DLXXVIII\", \"DLXXIX\", \"DLXXX\", \"DLXXXI\", \"DLXXXII\", \\n    \"DLXXXIII\", \"DLXXXIV\", \"DLXXXV\", \"DLXXXVI\", \"DLXXXVII\", \"DLXXXVIII\", \\n    \"DLXXXIX\", \"DXC\", \"DXCI\", \"DXCII\", \"DXCIII\", \"DXCIV\", \"DXCV\", \"DXCVI\", \\n    \"DXCVII\", \"DXCVIII\", \"DXCIX\", \"DC\", \"DCI\", \"DCII\", \"DCIII\", \"DCIV\", \\n    \"DCV\", \"DCVI\", \"DCVII\", \"DCVIII\", \"DCIX\", \"DCX\", \"DCXI\", \"DCXII\", \\n    \"DCXIII\", \"DCXIV\", \"DCXV\", \"DCXVI\", \"DCXVII\", \"DCXVIII\", \"DCXIX\", \\n    \"DCXX\", \"DCXXI\", \"DCXXII\", \"DCXXIII\", \"DCXXIV\", \"DCXXV\", \"DCXXVI\", \\n    \"DCXXVII\", \"DCXXVIII\", \"DCXXIX\", \"DCXXX\", \"DCXXXI\", \"DCXXXII\", \\n    \"DCXXXIII\", \"DCXXXIV\", \"DCXXXV\", \"DCXXXVI\", \"DCXXXVII\", \"DCXXXVIII\", \\n    \"DCXXXIX\", \"DCXL\", \"DCXLI\", \"DCXLII\", \"DCXLIII\", \"DCXLIV\", \"DCXLV\", \\n    \"DCXLVI\", \"DCXLVII\", \"DCXLVIII\", \"DCXLIX\", \"DCL\", \"DCLI\", \"DCLII\", \\n    \"DCLIII\", \"DCLIV\", \"DCLV\", \"DCLVI\", \"DCLVII\", \"DCLVIII\", \"DCLIX\", \\n    \"DCLX\", \"DCLXI\", \"DCLXII\", \"DCLXIII\", \"DCLXIV\", \"DCLXV\", \"DCLXVI\", \\n    \"DCLXVII\", \"DCLXVIII\", \"DCLXIX\", \"DCLXX\", \"DCLXXI\", \"DCLXXII\", \\n    \"DCLXXIII\", \"DCLXXIV\", \"DCLXXV\", \"DCLXXVI\", \"DCLXXVII\", \"DCLXXVIII\", \\n    \"DCLXXIX\", \"DCLXXX\", \"DCLXXXI\", \"DCLXXXII\", \"DCLXXXIII\", \"DCLXXXIV\", \\n    \"DCLXXXV\", \"DCLXXXVI\", \"DCLXXXVII\", \"DCLXXXVIII\", \"DCLXXXIX\", \"DCXC\", \\n    \"DCXCI\", \"DCXCII\", \"DCXCIII\", \"DCXCIV\", \"DCXCV\", \"DCXCVI\", \"DCXCVII\", \\n    \"DCXCVIII\", \"DCXCIX\", \"DCC\", \"DCCI\", \"DCCII\", \"DCCIII\", \"DCCIV\", \\n    \"DCCV\", \"DCCVI\", \"DCCVII\", \"DCCVIII\", \"DCCIX\", \"DCCX\", \"DCCXI\", \\n    \"DCCXII\", \"DCCXIII\", \"DCCXIV\", \"DCCXV\", \"DCCXVI\", \"DCCXVII\", \"DCCXVIII\",\\n    \"DCCXIX\", \"DCCXX\", \"DCCXXI\", \"DCCXXII\", \"DCCXXIII\", \"DCCXXIV\", \"DCCXXV\", \\n    \"DCCXXVI\", \"DCCXXVII\", \"DCCXXVIII\", \"DCCXXIX\", \"DCCXXX\", \"DCCXXXI\", \\n    \"DCCXXXII\", \"DCCXXXIII\", \"DCCXXXIV\", \"DCCXXXV\", \"DCCXXXVI\", \"DCCXXXVII\", \\n                        :\\n\\t\\t\\t            :   // Edited to reduce size of post, but you get the idea...\\n\\t\\t\\t\\t\\t\\t:\\n    \"MMMCMXCII\", \"MMMCMXCIII\", \"MMMCMXCIV\", \"MMMCMXCV\", \"MMMCMXCVI\",\\n    \"MMMCMXCVII\", \"MMMCMXCVIII\", \"MMMCMXCIX\"];\\n ```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\n\\nimpl Solution {\\n    pub fn int_to_roman(num: i32) -> String {\\n        NUMERALS[num as usize].to_string()\\n    }\\n}\\n\\nconst NUMERALS: [&str; 4000] = [\\n    \"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\",\"VIII\", \"IX\", \"X\", \"XI\", \\n    \"XII\", \"XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"XVIII\", \"XIX\", \"XX\", \"XXI\",\\n    \"XXII\", \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\", \"XXVIII\", \"XXIX\", \\n    \"XXX\", \"XXXI\", \"XXXII\", \"XXXIII\", \"XXXIV\", \"XXXV\", \"XXXVI\", \"XXXVII\", \\n    \"XXXVIII\", \"XXXIX\", \"XL\", \"XLI\", \"XLII\", \"XLIII\", \"XLIV\", \"XLV\", \"XLVI\",\\n    \"XLVII\", \"XLVIII\", \"XLIX\", \"L\", \"LI\", \"LII\", \"LIII\", \"LIV\", \"LV\", \"LVI\",\\n    \"LVII\", \"LVIII\", \"LIX\", \"LX\", \"LXI\", \"LXII\", \"LXIII\", \"LXIV\", \"LXV\", \\n    \"LXVI\", \"LXVII\", \"LXVIII\", \"LXIX\", \"LXX\", \"LXXI\", \"LXXII\", \"LXXIII\", \\n    \"LXXIV\", \"LXXV\", \"LXXVI\", \"LXXVII\", \"LXXVIII\", \"LXXIX\", \"LXXX\", \"LXXXI\",\\n    \"LXXXII\", \"LXXXIII\", \"LXXXIV\", \"LXXXV\", \"LXXXVI\", \"LXXXVII\", \"LXXXVIII\",\\n    \"LXXXIX\", \"XC\", \"XCI\", \"XCII\", \"XCIII\", \"XCIV\", \"XCV\", \"XCVI\", \"XCVII\", \\n    \"XCVIII\", \"XCIX\", \"C\", \"CI\", \"CII\", \"CIII\", \"CIV\", \"CV\", \"CVI\", \"CVII\", \\n    \"CVIII\", \"CIX\", \"CX\", \"CXI\", \"CXII\", \"CXIII\", \"CXIV\", \"CXV\", \"CXVI\", \\n    \"CXVII\", \"CXVIII\", \"CXIX\", \"CXX\", \"CXXI\", \"CXXII\", \"CXXIII\", \"CXXIV\", \\n    \"CXXV\", \"CXXVI\", \"CXXVII\", \"CXXVIII\", \"CXXIX\", \"CXXX\", \"CXXXI\", \\n    \"CXXXII\", \"CXXXIII\", \"CXXXIV\", \"CXXXV\", \"CXXXVI\", \"CXXXVII\", \"CXXXVIII\",\\n    \"CXXXIX\", \"CXL\", \"CXLI\", \"CXLII\", \"CXLIII\", \"CXLIV\", \"CXLV\", \"CXLVI\", \\n    \"CXLVII\", \"CXLVIII\", \"CXLIX\", \"CL\", \"CLI\", \"CLII\", \"CLIII\", \"CLIV\", \\n    \"CLV\", \"CLVI\", \"CLVII\", \"CLVIII\", \"CLIX\", \"CLX\", \"CLXI\", \"CLXII\", \\n    \"CLXIII\", \"CLXIV\", \"CLXV\", \"CLXVI\", \"CLXVII\", \"CLXVIII\", \"CLXIX\", \\n    \"CLXX\", \"CLXXI\", \"CLXXII\", \"CLXXIII\", \"CLXXIV\", \"CLXXV\", \"CLXXVI\", \\n    \"CLXXVII\", \"CLXXVIII\", \"CLXXIX\", \"CLXXX\", \"CLXXXI\", \"CLXXXII\", \\n    \"CLXXXIII\", \"CLXXXIV\", \"CLXXXV\", \"CLXXXVI\", \"CLXXXVII\", \"CLXXXVIII\", \\n    \"CLXXXIX\", \"CXC\", \"CXCI\", \"CXCII\", \"CXCIII\", \"CXCIV\", \"CXCV\", \"CXCVI\", \\n    \"CXCVII\", \"CXCVIII\", \"CXCIX\", \"CC\", \"CCI\", \"CCII\", \"CCIII\", \"CCIV\", \\n    \"CCV\", \"CCVI\", \"CCVII\", \"CCVIII\", \"CCIX\", \"CCX\", \"CCXI\", \"CCXII\", \\n    \"CCXIII\", \"CCXIV\", \"CCXV\", \"CCXVI\", \"CCXVII\", \"CCXVIII\", \"CCXIX\", \\n    \"CCXX\", \"CCXXI\", \"CCXXII\", \"CCXXIII\", \"CCXXIV\", \"CCXXV\", \"CCXXVI\", \\n    \"CCXXVII\", \"CCXXVIII\", \"CCXXIX\", \"CCXXX\", \"CCXXXI\", \"CCXXXII\", \\n    \"CCXXXIII\", \"CCXXXIV\", \"CCXXXV\", \"CCXXXVI\", \"CCXXXVII\", \"CCXXXVIII\", \\n    \"CCXXXIX\", \"CCXL\", \"CCXLI\", \"CCXLII\", \"CCXLIII\", \"CCXLIV\", \"CCXLV\", \\n    \"CCXLVI\", \"CCXLVII\", \"CCXLVIII\", \"CCXLIX\", \"CCL\", \"CCLI\", \"CCLII\", \\n    \"CCLIII\", \"CCLIV\", \"CCLV\", \"CCLVI\", \"CCLVII\", \"CCLVIII\", \"CCLIX\", \\n    \"CCLX\", \"CCLXI\", \"CCLXII\", \"CCLXIII\", \"CCLXIV\", \"CCLXV\", \"CCLXVI\", \\n    \"CCLXVII\", \"CCLXVIII\", \"CCLXIX\", \"CCLXX\", \"CCLXXI\", \"CCLXXII\", \\n    \"CCLXXIII\", \"CCLXXIV\", \"CCLXXV\", \"CCLXXVI\", \"CCLXXVII\", \"CCLXXVIII\", \\n    \"CCLXXIX\", \"CCLXXX\", \"CCLXXXI\", \"CCLXXXII\", \"CCLXXXIII\", \"CCLXXXIV\", \\n    \"CCLXXXV\", \"CCLXXXVI\", \"CCLXXXVII\", \"CCLXXXVIII\", \"CCLXXXIX\", \"CCXC\", \\n    \"CCXCI\", \"CCXCII\", \"CCXCIII\", \"CCXCIV\", \"CCXCV\", \"CCXCVI\", \"CCXCVII\", \\n    \"CCXCVIII\", \"CCXCIX\", \"CCC\", \"CCCI\", \"CCCII\", \"CCCIII\", \"CCCIV\", \"CCCV\",\\n    \"CCCVI\", \"CCCVII\", \"CCCVIII\", \"CCCIX\", \"CCCX\", \"CCCXI\", \"CCCXII\", \\n    \"CCCXIII\", \"CCCXIV\", \"CCCXV\", \"CCCXVI\", \"CCCXVII\", \"CCCXVIII\", \"CCCXIX\", \\n    \"CCCXX\", \"CCCXXI\", \"CCCXXII\", \"CCCXXIII\", \"CCCXXIV\", \"CCCXXV\", \\n    \"CCCXXVI\", \"CCCXXVII\", \"CCCXXVIII\", \"CCCXXIX\", \"CCCXXX\", \"CCCXXXI\", \\n    \"CCCXXXII\", \"CCCXXXIII\", \"CCCXXXIV\", \"CCCXXXV\", \"CCCXXXVI\", \"CCCXXXVII\", \\n    \"CCCXXXVIII\", \"CCCXXXIX\", \"CCCXL\", \"CCCXLI\", \"CCCXLII\", \"CCCXLIII\", \\n    \"CCCXLIV\", \"CCCXLV\", \"CCCXLVI\", \"CCCXLVII\", \"CCCXLVIII\", \"CCCXLIX\", \\n    \"CCCL\", \"CCCLI\", \"CCCLII\", \"CCCLIII\", \"CCCLIV\", \"CCCLV\", \"CCCLVI\", \\n    \"CCCLVII\", \"CCCLVIII\", \"CCCLIX\", \"CCCLX\", \"CCCLXI\", \"CCCLXII\", \\n    \"CCCLXIII\", \"CCCLXIV\", \"CCCLXV\", \"CCCLXVI\", \"CCCLXVII\", \"CCCLXVIII\", \\n    \"CCCLXIX\", \"CCCLXX\", \"CCCLXXI\", \"CCCLXXII\", \"CCCLXXIII\", \"CCCLXXIV\", \\n    \"CCCLXXV\", \"CCCLXXVI\", \"CCCLXXVII\", \"CCCLXXVIII\", \"CCCLXXIX\", \"CCCLXXX\", \\n    \"CCCLXXXI\", \"CCCLXXXII\", \"CCCLXXXIII\", \"CCCLXXXIV\", \"CCCLXXXV\", \\n    \"CCCLXXXVI\", \"CCCLXXXVII\", \"CCCLXXXVIII\", \"CCCLXXXIX\", \"CCCXC\", \\n    \"CCCXCI\", \"CCCXCII\", \"CCCXCIII\", \"CCCXCIV\", \"CCCXCV\", \"CCCXCVI\", \\n    \"CCCXCVII\", \"CCCXCVIII\", \"CCCXCIX\", \"CD\", \"CDI\", \"CDII\", \"CDIII\", \\n    \"CDIV\", \"CDV\", \"CDVI\", \"CDVII\", \"CDVIII\", \"CDIX\", \"CDX\", \"CDXI\", \\n    \"CDXII\", \"CDXIII\", \"CDXIV\", \"CDXV\", \"CDXVI\", \"CDXVII\", \"CDXVIII\", \\n    \"CDXIX\", \"CDXX\", \"CDXXI\", \"CDXXII\", \"CDXXIII\", \"CDXXIV\", \"CDXXV\", \\n    \"CDXXVI\", \"CDXXVII\", \"CDXXVIII\", \"CDXXIX\", \"CDXXX\", \"CDXXXI\", \"CDXXXII\",\\n    \"CDXXXIII\", \"CDXXXIV\", \"CDXXXV\", \"CDXXXVI\", \"CDXXXVII\", \"CDXXXVIII\", \\n    \"CDXXXIX\", \"CDXL\", \"CDXLI\", \"CDXLII\", \"CDXLIII\", \"CDXLIV\", \"CDXLV\", \\n    \"CDXLVI\", \"CDXLVII\", \"CDXLVIII\", \"CDXLIX\", \"CDL\", \"CDLI\", \"CDLII\", \\n    \"CDLIII\", \"CDLIV\", \"CDLV\", \"CDLVI\", \"CDLVII\", \"CDLVIII\", \"CDLIX\", \\n    \"CDLX\", \"CDLXI\", \"CDLXII\", \"CDLXIII\", \"CDLXIV\", \"CDLXV\", \"CDLXVI\", \\n    \"CDLXVII\", \"CDLXVIII\", \"CDLXIX\", \"CDLXX\", \"CDLXXI\", \"CDLXXII\", \\n    \"CDLXXIII\", \"CDLXXIV\", \"CDLXXV\", \"CDLXXVI\", \"CDLXXVII\", \"CDLXXVIII\", \\n    \"CDLXXIX\", \"CDLXXX\", \"CDLXXXI\", \"CDLXXXII\", \"CDLXXXIII\", \"CDLXXXIV\", \\n    \"CDLXXXV\", \"CDLXXXVI\", \"CDLXXXVII\", \"CDLXXXVIII\", \"CDLXXXIX\", \"CDXC\", \\n    \"CDXCI\", \"CDXCII\", \"CDXCIII\", \"CDXCIV\", \"CDXCV\", \"CDXCVI\", \"CDXCVII\", \\n    \"CDXCVIII\", \"CDXCIX\", \"D\", \"DI\", \"DII\", \"DIII\", \"DIV\", \"DV\", \"DVI\", \\n    \"DVII\", \"DVIII\", \"DIX\", \"DX\", \"DXI\", \"DXII\", \"DXIII\", \"DXIV\", \"DXV\", \\n    \"DXVI\", \"DXVII\", \"DXVIII\", \"DXIX\", \"DXX\", \"DXXI\", \"DXXII\", \"DXXIII\", \\n    \"DXXIV\", \"DXXV\", \"DXXVI\", \"DXXVII\", \"DXXVIII\", \"DXXIX\", \"DXXX\", \"DXXXI\", \\n    \"DXXXII\", \"DXXXIII\", \"DXXXIV\", \"DXXXV\", \"DXXXVI\", \"DXXXVII\", \"DXXXVIII\", \\n    \"DXXXIX\", \"DXL\", \"DXLI\", \"DXLII\", \"DXLIII\", \"DXLIV\", \"DXLV\", \"DXLVI\", \\n    \"DXLVII\", \"DXLVIII\", \"DXLIX\", \"DL\", \"DLI\", \"DLII\", \"DLIII\", \"DLIV\", \\n    \"DLV\", \"DLVI\", \"DLVII\", \"DLVIII\", \"DLIX\", \"DLX\", \"DLXI\", \"DLXII\", \\n    \"DLXIII\", \"DLXIV\", \"DLXV\", \"DLXVI\", \"DLXVII\", \"DLXVIII\", \"DLXIX\", \\n    \"DLXX\", \"DLXXI\", \"DLXXII\", \"DLXXIII\", \"DLXXIV\", \"DLXXV\", \"DLXXVI\", \\n    \"DLXXVII\", \"DLXXVIII\", \"DLXXIX\", \"DLXXX\", \"DLXXXI\", \"DLXXXII\", \\n    \"DLXXXIII\", \"DLXXXIV\", \"DLXXXV\", \"DLXXXVI\", \"DLXXXVII\", \"DLXXXVIII\", \\n    \"DLXXXIX\", \"DXC\", \"DXCI\", \"DXCII\", \"DXCIII\", \"DXCIV\", \"DXCV\", \"DXCVI\", \\n    \"DXCVII\", \"DXCVIII\", \"DXCIX\", \"DC\", \"DCI\", \"DCII\", \"DCIII\", \"DCIV\", \\n    \"DCV\", \"DCVI\", \"DCVII\", \"DCVIII\", \"DCIX\", \"DCX\", \"DCXI\", \"DCXII\", \\n    \"DCXIII\", \"DCXIV\", \"DCXV\", \"DCXVI\", \"DCXVII\", \"DCXVIII\", \"DCXIX\", \\n    \"DCXX\", \"DCXXI\", \"DCXXII\", \"DCXXIII\", \"DCXXIV\", \"DCXXV\", \"DCXXVI\", \\n    \"DCXXVII\", \"DCXXVIII\", \"DCXXIX\", \"DCXXX\", \"DCXXXI\", \"DCXXXII\", \\n    \"DCXXXIII\", \"DCXXXIV\", \"DCXXXV\", \"DCXXXVI\", \"DCXXXVII\", \"DCXXXVIII\", \\n    \"DCXXXIX\", \"DCXL\", \"DCXLI\", \"DCXLII\", \"DCXLIII\", \"DCXLIV\", \"DCXLV\", \\n    \"DCXLVI\", \"DCXLVII\", \"DCXLVIII\", \"DCXLIX\", \"DCL\", \"DCLI\", \"DCLII\", \\n    \"DCLIII\", \"DCLIV\", \"DCLV\", \"DCLVI\", \"DCLVII\", \"DCLVIII\", \"DCLIX\", \\n    \"DCLX\", \"DCLXI\", \"DCLXII\", \"DCLXIII\", \"DCLXIV\", \"DCLXV\", \"DCLXVI\", \\n    \"DCLXVII\", \"DCLXVIII\", \"DCLXIX\", \"DCLXX\", \"DCLXXI\", \"DCLXXII\", \\n    \"DCLXXIII\", \"DCLXXIV\", \"DCLXXV\", \"DCLXXVI\", \"DCLXXVII\", \"DCLXXVIII\", \\n    \"DCLXXIX\", \"DCLXXX\", \"DCLXXXI\", \"DCLXXXII\", \"DCLXXXIII\", \"DCLXXXIV\", \\n    \"DCLXXXV\", \"DCLXXXVI\", \"DCLXXXVII\", \"DCLXXXVIII\", \"DCLXXXIX\", \"DCXC\", \\n    \"DCXCI\", \"DCXCII\", \"DCXCIII\", \"DCXCIV\", \"DCXCV\", \"DCXCVI\", \"DCXCVII\", \\n    \"DCXCVIII\", \"DCXCIX\", \"DCC\", \"DCCI\", \"DCCII\", \"DCCIII\", \"DCCIV\", \\n    \"DCCV\", \"DCCVI\", \"DCCVII\", \"DCCVIII\", \"DCCIX\", \"DCCX\", \"DCCXI\", \\n    \"DCCXII\", \"DCCXIII\", \"DCCXIV\", \"DCCXV\", \"DCCXVI\", \"DCCXVII\", \"DCCXVIII\",\\n    \"DCCXIX\", \"DCCXX\", \"DCCXXI\", \"DCCXXII\", \"DCCXXIII\", \"DCCXXIV\", \"DCCXXV\", \\n    \"DCCXXVI\", \"DCCXXVII\", \"DCCXXVIII\", \"DCCXXIX\", \"DCCXXX\", \"DCCXXXI\", \\n    \"DCCXXXII\", \"DCCXXXIII\", \"DCCXXXIV\", \"DCCXXXV\", \"DCCXXXVI\", \"DCCXXXVII\", \\n                        :\\n\\t\\t\\t            :   // Edited to reduce size of post, but you get the idea...\\n\\t\\t\\t\\t\\t\\t:\\n    \"MMMCMXCII\", \"MMMCMXCIII\", \"MMMCMXCIV\", \"MMMCMXCV\", \"MMMCMXCVI\",\\n    \"MMMCMXCVII\", \"MMMCMXCVIII\", \"MMMCMXCIX\"];\\n ```",
                "codeTag": "Unknown"
            },
            {
                "id": 2018967,
                "title": "very-easy-c-solution-please-upvote",
                "content": "```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        vector<int> in={1000,900,500,400,100,90,50,40,10,9,5,4,1};\\n        vector<string> roman={\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\\n        string res=\"\";\\n        for(int i=0;i<(int)in.size();i++)\\n        {\\n            int count=num/in[i];\\n            while(count--)\\n            {\\n                res+=roman[i];\\n            }\\n            num=num%in[i];\\n        }\\n        return res;\\n    }\\n};\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    string intToRoman(int num) {\\n        vector<int> in={1000,900,500,400,100,90,50,40,10,9,5,4,1}",
                "codeTag": "Java"
            },
            {
                "id": 1980870,
                "title": "java-c-python-javascript-kotlin-o-n-time-beats-99-97-memory-speed-0ms-april-2022",
                "content": "***Hello it would be my pleasure to introduce myself Darian.***\\n\\n<iframe src=\"https://leetcode.com/playground/6KqgMr3S/shared\" frameBorder=\"0\" width=\"1000\" height=\"1000\"></iframe>\\n\\n***Consider upvote if useful! Hopefully it can be used in your advantage!***\\n***Take care brother, peace, love!***",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "JavaScript",
                    "Kotlin"
                ],
                "code": "***Hello it would be my pleasure to introduce myself Darian.***\\n\\n<iframe src=\"https://leetcode.com/playground/6KqgMr3S/shared\" frameBorder=\"0\" width=\"1000\" height=\"1000\"></iframe>\\n\\n***Consider upvote if useful! Hopefully it can be used in your advantage!***\\n***Take care brother, peace, love!***",
                "codeTag": "Unknown"
            },
            {
                "id": 1847281,
                "title": "python-solution",
                "content": "Please Upvote\\n\\n```\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        \\n        d = {1000: \\'M\\', 900: \\'CM\\', 500: \\'D\\', 400: \\'CD\\', 100: \\'C\\', 90: \\'XC\\', 50: \\'L\\', 40: \\'XL\\', 10: \\'X\\', 9: \\'IX\\', 5: \\'V\\', 4: \\'IV\\', 1: \\'I\\'}\\n        result = \\'\\'\\n        \\n        for k in d.keys():\\n            result += (num // k) * d[k]\\n            num %= k\\n                \\n        return result\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        \\n        d = {1000: \\'M\\', 900: \\'CM\\', 500: \\'D\\', 400: \\'CD\\', 100: \\'C\\', 90: \\'XC\\', 50: \\'L\\', 40: \\'XL\\', 10: \\'X\\', 9: \\'IX\\', 5: \\'V\\', 4: \\'IV\\', 1: \\'I\\'}\\n        result = \\'\\'\\n        \\n        for k in d.keys():\\n            result += (num // k) * d[k]\\n            num %= k\\n                \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1759934,
                "title": "python3-solution-100-faster",
                "content": "**Solution - 1**\\n```\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        M = [\"\", \"M\", \"MM\", \"MMM\"]\\n        C = [\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"]\\n        X = [\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"]\\n        I = [\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"]\\n        return M[num//1000] + C[(num%1000)//100] + X[(num%100)//10] + I[num%10]\\n```\\n\\n**Solution - 2**\\n```\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        values = [\\'I\\',\\'V\\',\\'X\\',\\'L\\',\\'C\\',\\'D\\',\\'M\\',\\'\\']\\n        ans,i = \\'\\',0\\n        while num:\\n            digit = num%10\\n            if digit%5 == 4: ans = values[i] + values[i + 1 + int(digit==9)] + ans\\n            else: ans = values[i+1]*int(digit>=5) + values[i]*(digit%5) + ans\\n            num //= 10\\n            i += 2\\n        return ans\\n```\\n\\n**Solution - 3**\\n```\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        values = [\\'I\\',\\'V\\',\\'X\\',\\'L\\',\\'C\\',\\'D\\',\\'M\\']\\n        ans,i = \\'\\',0\\n        while num:\\n            digit = num%10\\n            if digit == 4: ans = values[i] + values[i + 1] + ans\\n            elif digit == 9: ans = values[i] + values[i + 2] + ans\\n            elif digit >= 5: ans = values[i+1] + values[i]*(digit-5) + ans\\n            else: ans = values[i]*digit + ans\\n            num //= 10\\n            i += 2\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        M = [\"\", \"M\", \"MM\", \"MMM\"]\\n        C = [\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"]\\n        X = [\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"]\\n        I = [\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"]\\n        return M[num//1000] + C[(num%1000)//100] + X[(num%100)//10] + I[num%10]\\n```\n```\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        values = [\\'I\\',\\'V\\',\\'X\\',\\'L\\',\\'C\\',\\'D\\',\\'M\\',\\'\\']\\n        ans,i = \\'\\',0\\n        while num:\\n            digit = num%10\\n            if digit%5 == 4: ans = values[i] + values[i + 1 + int(digit==9)] + ans\\n            else: ans = values[i+1]*int(digit>=5) + values[i]*(digit%5) + ans\\n            num //= 10\\n            i += 2\\n        return ans\\n```\n```\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        values = [\\'I\\',\\'V\\',\\'X\\',\\'L\\',\\'C\\',\\'D\\',\\'M\\']\\n        ans,i = \\'\\',0\\n        while num:\\n            digit = num%10\\n            if digit == 4: ans = values[i] + values[i + 1] + ans\\n            elif digit == 9: ans = values[i] + values[i + 2] + ans\\n            elif digit >= 5: ans = values[i+1] + values[i]*(digit-5) + ans\\n            else: ans = values[i]*digit + ans\\n            num //= 10\\n            i += 2\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1410013,
                "title": "0-ms-faster-than-100-00-of-c-online-submissions-for-integer-to-roman",
                "content": "# Simple and elegant solution\\n```\\nstring intToRoman(int number) {\\n        int num[] = {1,4,5,9,10,40,50,90,100,400,500,900,1000};\\n    string sym[] = {\"I\",\"IV\",\"V\",\"IX\",\"X\",\"XL\",\"L\",\"XC\",\"C\",\"CD\",\"D\",\"CM\",\"M\"};\\n    int i=12;  \\n    int d;\\n    string ans=\"\";\\n    while(number>0)\\n    {\\n        d = number/num[i];\\n      number = number%num[i];\\n      while(d--)\\n      {\\n        ans+=sym[i];\\n      }\\n      i--;\\n    }\\n     return ans;   \\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```\\nstring intToRoman(int number) {\\n        int num[] = {1,4,5,9,10,40,50,90,100,400,500,900,1000};\\n    string sym[] = {\"I\",\"IV\",\"V\",\"IX\",\"X\",\"XL\",\"L\",\"XC\",\"C\",\"CD\",\"D\",\"CM\",\"M\"};\\n    int i=12;  \\n    int d;\\n    string ans=\"\";\\n    while(number>0)\\n    {\\n        d = number/num[i];\\n      number = number%num[i];\\n      while(d--)\\n      {\\n        ans+=sym[i];\\n      }\\n      i--;\\n    }\\n     return ans;   \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1354615,
                "title": "simple-java-solution-100-faster",
                "content": "``` class Solution {\\n    private static int[] keys = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};      \\n    private static String[] values = {\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"};\\n    \\n    public String intToRoman(int num) {\\n        StringBuilder s = new StringBuilder();\\n        int counter = 0;\\n        \\n        \\n        while(num > 0){\\n            if(num >= keys[counter]){\\n                s.append(values[counter]);\\n                num -= keys[counter];\\n            }\\n            else\\n                counter++;\\n        }\\n        \\n        return s.toString();\\n        \\n    }\\n}```",
                "solutionTags": [],
                "code": "``` class Solution {\\n    private static int[] keys = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};      \\n    private static String[] values = {\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"};\\n    \\n    public String intToRoman(int num) {\\n        StringBuilder s = new StringBuilder();\\n        int counter = 0;\\n        \\n        \\n        while(num > 0){\\n            if(num >= keys[counter]){\\n                s.append(values[counter]);\\n                num -= keys[counter];\\n            }\\n            else\\n                counter++;\\n        }\\n        \\n        return s.toString();\\n        \\n    }\\n}```",
                "codeTag": "Java"
            },
            {
                "id": 1202412,
                "title": "easy-c-solution",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        \\n        int numbers[] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\\n        string romans[] = {\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"};\\n        \\n        string res;\\n        \\n        for(int i=0; i<13; i++)\\n        {\\n            while(num >= numbers[i])\\n            {\\n                num -= numbers[i];\\n                res += romans[i];\\n            }\\n        }\\n        \\n        return res;\\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        \\n        int numbers[] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\\n        string romans[] = {\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"};\\n        \\n        string res;\\n        \\n        for(int i=0; i<13; i++)\\n        {\\n            while(num >= numbers[i])\\n            {\\n                num -= numbers[i];\\n                res += romans[i];\\n            }\\n        }\\n        \\n        return res;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 216081,
                "title": "swift-solution",
                "content": "class Solution {\\n    func intToRoman(_ num: Int) -> String {\\n        if num == 0 {\\n            return \"\"\\n        } else if num >= 1000 {\\n            return \"M\" + intToRoman(num - 1000)\\n        } else if num >= 900 {\\n            return \"CM\" + intToRoman(num - 900)\\n        } else if num >= 500 {\\n            return \"D\" + intToRoman(num - 500)\\n        } else if num >= 400 {\\n            return \"CD\" + intToRoman(num - 400)\\n        } else if num >= 100 {\\n            return \"C\" + intToRoman(num - 100)\\n        } else if num >= 90 {\\n            return \"XC\" + intToRoman(num - 90)\\n        } else if num >= 50 {\\n            return \"L\" + intToRoman(num - 50)\\n        } else if num >= 40 {\\n            return \"XL\" + intToRoman(num - 40)\\n        } else if num >= 10 {\\n            return \"X\" + intToRoman(num - 10)\\n        } else if num >= 9 {\\n            return \"IX\" + intToRoman(num - 9)\\n        } else if num >= 5 {\\n            return \"V\" + intToRoman(num - 5)\\n        } else if num >= 4 {\\n            return \"IV\" + intToRoman(num - 4)\\n        } else if num > 0 {\\n            return \"I\" + intToRoman(num - 1)\\n        }\\n        \\n        return \"\"\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    func intToRoman(_ num: Int) -> String {\\n        if num == 0 {\\n            return \"\"\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 188598,
                "title": "easy-to-understand-java-solution",
                "content": "```\\n  public String intToRoman(int num) {\\n        \\n        return convert(num,new String());\\n        \\n    }\\n    \\n   public String convert(int num, String res){\\n        \\n        if(num == 0) return res;\\n        else if(num >= 1000) return convert(num - 1000, res +\"M\");\\n        else if(num >= 900) return convert(num - 900, res +\"CM\");\\n        else if(num >= 500) return convert(num - 500, res +\"D\");\\n        else if(num >= 400) return convert(num - 400, res +\"CD\");\\n        else if(num >= 100) return convert(num - 100, res +\"C\");\\n        else if(num >= 90) return convert(num - 90, res +\"XC\");\\n        else if(num >= 50) return convert(num - 50, res +\"L\");\\n        else if(num >= 40) return convert(num - 40, res +\"XL\");\\n        else if(num >= 10) return convert(num - 10, res +\"X\");\\n        else if(num >= 9) return convert(num - 9, res +\"IX\");\\n        else if(num >= 5) return convert(num - 5, res +\"V\");\\n        else if(num >= 4) return convert(num - 4, res +\"IV\");\\n        else if(num == 3) return convert(num - 3, res +\"III\");\\n        else if(num == 2) return convert(num - 2, res +\"II\");\\n        else if(num == 1) return convert(num - 1, res +\"I\");\\n        \\n        return null;\\n        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n  public String intToRoman(int num) {\\n        \\n        return convert(num,new String());\\n        \\n    }\\n    \\n   public String convert(int num, String res){\\n        \\n        if(num == 0) return res;\\n        else if(num >= 1000) return convert(num - 1000, res +\"M\");\\n        else if(num >= 900) return convert(num - 900, res +\"CM\");\\n        else if(num >= 500) return convert(num - 500, res +\"D\");\\n        else if(num >= 400) return convert(num - 400, res +\"CD\");\\n        else if(num >= 100) return convert(num - 100, res +\"C\");\\n        else if(num >= 90) return convert(num - 90, res +\"XC\");\\n        else if(num >= 50) return convert(num - 50, res +\"L\");\\n        else if(num >= 40) return convert(num - 40, res +\"XL\");\\n        else if(num >= 10) return convert(num - 10, res +\"X\");\\n        else if(num >= 9) return convert(num - 9, res +\"IX\");\\n        else if(num >= 5) return convert(num - 5, res +\"V\");\\n        else if(num >= 4) return convert(num - 4, res +\"IV\");\\n        else if(num == 3) return convert(num - 3, res +\"III\");\\n        else if(num == 2) return convert(num - 2, res +\"II\");\\n        else if(num == 1) return convert(num - 1, res +\"I\");\\n        \\n        return null;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 6388,
                "title": "my-java-solution",
                "content": "\\n\\n\\n        String res = \"\";\\n        String[] c = new String[]{\"I\",\"IV\",\"V\",\"IX\",\"X\",\"XL\",\"L\",\"XC\",\"C\",\"CD\",\"D\",\"CM\",\"M\"};\\n        int[] n = new int[]{1,4,5,9,10,40,50,90,100,400,500,900,1000};\\n        int i = 12;\\n        while(num > 0 && i>=0){\\n            if(num >= n[i]){\\n                res += c[i];\\n                num -= n[i];\\n            }else{\\n                i--;\\n            }\\n        }\\n        return res;",
                "solutionTags": [],
                "code": "\\n\\n\\n        String res = \"\";\\n        String[] c = new String[]{\"I\",\"IV\",\"V\",\"IX\",\"X\",\"XL\",\"L\",\"XC\",\"C\",\"CD\",\"D\",\"CM\",\"M\"};\\n        int[] n = new int[]{1,4,5,9,10,40,50,90,100,400,500,900,1000};\\n        int i = 12;\\n        while(num > 0 && i>=0){\\n            if(num >= n[i]){\\n                res += c[i];\\n                num -= n[i];\\n            }else{\\n                i--;\\n            }\\n        }\\n        return res;",
                "codeTag": "Unknown"
            },
            {
                "id": 6451,
                "title": "my-easy-understanding-solution",
                "content": "\\n    string intToRoman(int num) \\n    {   \\n        string s;  \\n    \\n        while (num > 0)\\n        {   \\n            if (num >= 1000) {s += \"M\"; num-=1000; continue;}\\n            if (num >= 900)  {s += \"CM\"; num-=900; continue;}\\n            if (num >= 500)  {s += \"D\"; num-=500; continue;}\\n            if (num >= 400)  {s += \"CD\"; num-=400; continue;}\\n            if (num >= 100)  {s += \"C\"; num-=100; continue;}\\n            if (num >= 90)   {s += \"XC\"; num-=90; continue;}\\n            if (num >= 50)   {s += \"L\"; num-=50; continue;}\\n            if (num >= 40)   {s += \"XL\"; num-=40; continue;}\\n            if (num >= 10)   {s += \"X\"; num-=10; continue;}\\n            if (num >= 9)    {s += \"IX\"; num-=9; continue;}\\n            if (num >= 5)    {s += \"V\"; num-=5; continue;}\\n            if (num >= 4)    {s += \"IV\"; num-=4; continue;}\\n            if (num == 3)    {s += \"III\"; num-=3; continue;}\\n            if (num == 2)    {s += \"II\"; num-=2; continue;}\\n            if (num == 1)    {s += \"I\"; num-=1; continue;}\\n        }   \\n    \\n        return s;\\n    }",
                "solutionTags": [],
                "code": "\\n    string intToRoman(int num) \\n    {   \\n        string s;  \\n    \\n        while (num > 0)\\n        {   \\n            if (num >= 1000) {s += \"M\"; num-=1000; continue;}\\n            if (num >= 900)  {s += \"CM\"; num-=900; continue;}\\n            if (num >= 500)  {s += \"D\"; num-=500; continue;}\\n            if (num >= 400)  {s += \"CD\"; num-=400; continue;}\\n            if (num >= 100)  {s += \"C\"; num-=100; continue;}\\n            if (num >= 90)   {s += \"XC\"; num-=90; continue;}\\n            if (num >= 50)   {s += \"L\"; num-=50; continue;}\\n            if (num >= 40)   {s += \"XL\"; num-=40; continue;}\\n            if (num >= 10)   {s += \"X\"; num-=10; continue;}\\n            if (num >= 9)    {s += \"IX\"; num-=9; continue;}\\n            if (num >= 5)    {s += \"V\"; num-=5; continue;}\\n            if (num >= 4)    {s += \"IV\"; num-=4; continue;}\\n            if (num == 3)    {s += \"III\"; num-=3; continue;}\\n            if (num == 2)    {s += \"II\"; num-=2; continue;}\\n            if (num == 1)    {s += \"I\"; num-=1; continue;}\\n        }   \\n    \\n        return s;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3618408,
                "title": "beats-100-by-using-subtraction-method",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        vector<string> v1={\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\\n                           \"X\",\"IX\",\"V\",\"IV\",\"I\"};\\n        vector<int> v2={1000,900,500,400,100,90,50,40,10,9,5,4,1};\\n        string res=\"\";\\n        for(int i=0; num>0; i++){\\n            while(num>=v2[i]){\\n                res=res+v1[i];\\n                num=num-v2[i];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        vector<string> v1={\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\\n                           \"X\",\"IX\",\"V\",\"IV\",\"I\"};\\n        vector<int> v2={1000,900,500,400,100,90,50,40,10,9,5,4,1};\\n        string res=\"\";\\n        for(int i=0; num>0; i++){\\n            while(num>=v2[i]){\\n                res=res+v1[i];\\n                num=num-v2[i];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2724994,
                "title": "java-without-extended-dictionary",
                "content": "```\\npublic String intToRoman(int number) {\\n        Map<Integer, Character> map = Map.of(1, \\'I\\', 5, \\'V\\', 10, \\'X\\', 50, \\'L\\', 100, \\'C\\', 500, \\'D\\', 1000, \\'M\\');\\n        StringBuilder roman = new StringBuilder();\\n\\n        int multiplier = 1;\\n        while (number > 0) {\\n            int digit = number % 10;\\n\\n            if (digit == 4 || digit == 9)\\n                roman.insert(0, \"\" + map.get(multiplier) + map.get((digit + 1) * multiplier));\\n            else\\n                roman.insert(0,  (digit >= 5 ? map.get(5 * multiplier) : \"\") + (map.get(multiplier).toString().repeat(digit >= 5 ? digit - 5 : digit)));\\n\\n            number = number / 10; multiplier *= 10;\\n        }\\n\\n        return roman.toString();\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic String intToRoman(int number) {\\n        Map<Integer, Character> map = Map.of(1, \\'I\\', 5, \\'V\\', 10, \\'X\\', 50, \\'L\\', 100, \\'C\\', 500, \\'D\\', 1000, \\'M\\');\\n        StringBuilder roman = new StringBuilder();\\n\\n        int multiplier = 1;\\n        while (number > 0) {\\n            int digit = number % 10;\\n\\n            if (digit == 4 || digit == 9)\\n                roman.insert(0, \"\" + map.get(multiplier) + map.get((digit + 1) * multiplier));\\n            else\\n                roman.insert(0,  (digit >= 5 ? map.get(5 * multiplier) : \"\") + (map.get(multiplier).toString().repeat(digit >= 5 ? digit - 5 : digit)));\\n\\n            number = number / 10; multiplier *= 10;\\n        }\\n\\n        return roman.toString();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2724574,
                "title": "go-simple-recursion",
                "content": "Please Upvote if you like the solution \\n\\n```\\nfunc intToRoman(num int) string {\\n    return getRoman(num, \"\")\\n}\\n\\nfunc getRoman(num int, roman string) string {\\n    if num == 0 {\\n        return roman\\n    }\\n    \\n    if num - 1000 >= 0 {\\n        return getRoman(num-1000, roman + \"M\")\\n    }\\n    \\n    if num - 900 >= 0 {\\n        return getRoman(num-900, roman + \"CM\")\\n    }\\n    \\n    if num - 500 >= 0 {\\n        return getRoman(num-500, roman + \"D\")\\n    }\\n    \\n    if num - 400 >= 0 {\\n        return getRoman(num-400, roman + \"CD\")\\n    }\\n    \\n    if num - 100 >= 0 {\\n        return getRoman(num-100, roman + \"C\")\\n    }\\n    \\n    if num - 90 >= 0 {\\n        return getRoman(num-90, roman + \"XC\")\\n    }\\n    \\n    if num - 50 >= 0 {\\n        return getRoman(num-50, roman + \"L\")\\n    }\\n    \\n    if num - 40 >= 0 {\\n        return getRoman(num-40, roman + \"XL\")\\n    }\\n    \\n    if num - 10 >= 0 {\\n        return getRoman(num-10, roman + \"X\")\\n    }\\n    \\n    if num - 9 >= 0 {\\n        return getRoman(num-9, roman + \"IX\")\\n    }\\n    \\n    if num - 5 >= 0 {\\n        return getRoman(num-5, roman + \"V\")\\n    }\\n    \\n    if num - 4 >= 0 {\\n        return getRoman(num-4, roman + \"IV\")\\n    }\\n    \\n    if num - 1 >= 0 {\\n        return getRoman(num-1, roman + \"I\")\\n    }\\n     \\n    return roman\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Recursion"
                ],
                "code": "```\\nfunc intToRoman(num int) string {\\n    return getRoman(num, \"\")\\n}\\n\\nfunc getRoman(num int, roman string) string {\\n    if num == 0 {\\n        return roman\\n    }\\n    \\n    if num - 1000 >= 0 {\\n        return getRoman(num-1000, roman + \"M\")\\n    }\\n    \\n    if num - 900 >= 0 {\\n        return getRoman(num-900, roman + \"CM\")\\n    }\\n    \\n    if num - 500 >= 0 {\\n        return getRoman(num-500, roman + \"D\")\\n    }\\n    \\n    if num - 400 >= 0 {\\n        return getRoman(num-400, roman + \"CD\")\\n    }\\n    \\n    if num - 100 >= 0 {\\n        return getRoman(num-100, roman + \"C\")\\n    }\\n    \\n    if num - 90 >= 0 {\\n        return getRoman(num-90, roman + \"XC\")\\n    }\\n    \\n    if num - 50 >= 0 {\\n        return getRoman(num-50, roman + \"L\")\\n    }\\n    \\n    if num - 40 >= 0 {\\n        return getRoman(num-40, roman + \"XL\")\\n    }\\n    \\n    if num - 10 >= 0 {\\n        return getRoman(num-10, roman + \"X\")\\n    }\\n    \\n    if num - 9 >= 0 {\\n        return getRoman(num-9, roman + \"IX\")\\n    }\\n    \\n    if num - 5 >= 0 {\\n        return getRoman(num-5, roman + \"V\")\\n    }\\n    \\n    if num - 4 >= 0 {\\n        return getRoman(num-4, roman + \"IV\")\\n    }\\n    \\n    if num - 1 >= 0 {\\n        return getRoman(num-1, roman + \"I\")\\n    }\\n     \\n    return roman\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2336437,
                "title": "easy-explanation-commented-c",
                "content": "Initially we need to store all the integer values which have specific roman values.\\nThen we will extract the key in sorted order (biggest to smallest) and check again and again if number is greater than the key then subtract the key from number and also add the roman in the answer.\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        // map is decreasing sorted by key\\n        map<int, string, greater<int>> m;\\n        m[1000] = \"M\";\\n        m[900] = \"CM\";\\n        m[500] = \"D\";\\n        m[400] = \"CD\";\\n        m[100] = \"C\";\\n        m[90] = \"XC\";\\n        m[50] = \"L\";\\n        m[40] = \"XL\";\\n        m[10] = \"X\";\\n        m[9] = \"IX\";\\n        m[5] = \"V\";\\n        m[4] = \"IV\";\\n        m[1] = \"I\";\\n        \\n        string ans = \"\";\\n\\t\\t// take pair from map\\n        for(auto p: m)\\n        {\\n            // if number is lesser or equal to key then add\\n            while(num >= p.first)\\n            {\\n                ans += p.second;\\n                num -= p.first;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    string intToRoman(int num) {\\n        // map is decreasing sorted by key\\n        map<int, string, greater<int>> m;\\n        m[1000] = \"M\";\\n        m[900] = \"CM\";\\n        m[500] = \"D\";\\n        m[400] = \"CD\";\\n        m[100] = \"C\";\\n        m[90] = \"XC\";\\n        m[50] = \"L\";\\n        m[40] = \"XL\";\\n        m[10] = \"X\";\\n        m[9] = \"IX\";\\n        m[5] = \"V\";\\n        m[4] = \"IV\";\\n        m[1] = \"I\";\\n        \\n        string ans = \"\";\\n\\t\\t// take pair from map\\n        for(auto p: m)\\n        {\\n            // if number is lesser or equal to key then add\\n            while(num >= p.first)\\n            {\\n                ans += p.second;\\n                num -= p.first;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2162067,
                "title": "easy-cpp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string ans;\\n        int val[] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\\n        string sym[] = {\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"};\\n        \\n        int i=0;\\n        while(num){\\n            \\n            while(val[i]<=num){\\n                num-=val[i];\\n                ans+=sym[i];\\n            }\\n            \\n            i++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n**Please Upvote and thank you**\\n\\n**Feel Free to ask questions**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string ans;\\n        int val[] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\\n        string sym[] = {\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"};\\n        \\n        int i=0;\\n        while(num){\\n            \\n            while(val[i]<=num){\\n                num-=val[i];\\n                ans+=sym[i];\\n            }\\n            \\n            i++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1371192,
                "title": "c-no-recursion",
                "content": "```\\nstring intToRoman(int num) {\\n     vector<string> ones ={\"\",\"I\",\"II\",\"III\",\"IV\",\"V\",\"VI\",\"VII\",\"VIII\",\"IX\"};\\n        vector<string>tens = {\"\",\"X\",\"XX\",\"XXX\",\"XL\",\"L\",\"LX\",\"LXX\",\"LXXX\",\"XC\"};\\n        vector<string>hundreds = {\"\",\"C\",\"CC\",\"CCC\",\"CD\",\"D\",\"DC\",\"DCC\",\"DCCC\",\"CM\"};\\n        vector<string>thousand = {\"\",\"M\",\"MM\",\"MMM\"};\\n        return thousand[num/1000]+hundreds[num%1000/100]+tens[num%100/10]+ones[num%10];\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nstring intToRoman(int num) {\\n     vector<string> ones ={\"\",\"I\",\"II\",\"III\",\"IV\",\"V\",\"VI\",\"VII\",\"VIII\",\"IX\"};\\n        vector<string>tens = {\"\",\"X\",\"XX\",\"XXX\",\"XL\",\"L\",\"LX\",\"LXX\",\"LXXX\",\"XC\"};\\n        vector<string>hundreds = {\"\",\"C\",\"CC\",\"CCC\",\"CD\",\"D\",\"DC\",\"DCC\",\"DCCC\",\"CM\"};\\n        vector<string>thousand = {\"\",\"M\",\"MM\",\"MMM\"};\\n        return thousand[num/1000]+hundreds[num%1000/100]+tens[num%100/10]+ones[num%10];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1316412,
                "title": "simple-javascript-solution-beats-99-5",
                "content": "```\\n// 124ms 99.5%, 44MB 97.8%\\nconst symbolToValue = {\\n    \"M\" : 1000,\\n    \"CM\": 900,\\n    \"D\" : 500,\\n    \"CD\": 400,\\n    \"C\" : 100,\\n    \"XC\": 90,\\n    \"L\" : 50,\\n    \"XL\": 40,\\n    \"X\" : 10,\\n    \"IX\": 9,\\n    \"V\" : 5,\\n    \"IV\": 4,\\n    \"I\" : 1,\\n}\\n\\nvar intToRoman = function(num) {\\n    let finalStr = \"\";\\n    for (s in symbolToValue){\\n        const v = symbolToValue[s];\\n        while (num >= v){\\n            num -= v;\\n            finalStr += s;\\n        }    \\n    }\\n    return finalStr;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// 124ms 99.5%, 44MB 97.8%\\nconst symbolToValue = {\\n    \"M\" : 1000,\\n    \"CM\": 900,\\n    \"D\" : 500,\\n    \"CD\": 400,\\n    \"C\" : 100,\\n    \"XC\": 90,\\n    \"L\" : 50,\\n    \"XL\": 40,\\n    \"X\" : 10,\\n    \"IX\": 9,\\n    \"V\" : 5,\\n    \"IV\": 4,\\n    \"I\" : 1,\\n}\\n\\nvar intToRoman = function(num) {\\n    let finalStr = \"\";\\n    for (s in symbolToValue){\\n        const v = symbolToValue[s];\\n        while (num >= v){\\n            num -= v;\\n            finalStr += s;\\n        }    \\n    }\\n    return finalStr;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 812398,
                "title": "java-easy-to-understand-solution",
                "content": "```\\nclass Solution {\\n    public String intToRoman(int num) {\\n        String units[]={\"\",\"I\",\"II\",\"III\",\"IV\",\"V\",\"VI\",\"VII\",\"VIII\",\"IX\"};\\n        String tens[]={\"\",\"X\",\"XX\",\"XXX\",\"XL\",\"L\",\"LX\",\"LXX\",\"LXXX\",\"XC\"};\\n        String hundreds[]={\"\",\"C\",\"CC\",\"CCC\",\"CD\",\"D\",\"DC\",\"DCC\",\"DCCC\",\"CM\"};\\n        String thousands[]={\"\",\"M\",\"MM\",\"MMM\"};\\n        \\n        return thousands[num/1000]+\\n                hundreds[(num%1000)/100]+\\n                tens[(num%100)/10]+\\n                units[num%10];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String intToRoman(int num) {\\n        String units[]={\"\",\"I\",\"II\",\"III\",\"IV\",\"V\",\"VI\",\"VII\",\"VIII\",\"IX\"};\\n        String tens[]={\"\",\"X\",\"XX\",\"XXX\",\"XL\",\"L\",\"LX\",\"LXX\",\"LXXX\",\"XC\"};\\n        String hundreds[]={\"\",\"C\",\"CC\",\"CCC\",\"CD\",\"D\",\"DC\",\"DCC\",\"DCCC\",\"CM\"};\\n        String thousands[]={\"\",\"M\",\"MM\",\"MMM\"};\\n        \\n        return thousands[num/1000]+\\n                hundreds[(num%1000)/100]+\\n                tens[(num%100)/10]+\\n                units[num%10];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 757248,
                "title": "c-solution",
                "content": "```\\nstring intToRoman(int num) {\\n\\tvector<string> roman {\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"};\\n\\tvector<int> no {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\\n\\tstring ans = \"\";\\n\\tfor(int i=0; num != 0; i++){\\n\\t\\twhile(num >= no[i]){\\n\\t\\t\\tnum -= no[i];\\n\\t\\t\\tans += roman[i];\\n\\t\\t}\\n\\t}\\n\\treturn ans;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nstring intToRoman(int num) {\\n\\tvector<string> roman {\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"};\\n\\tvector<int> no {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\\n\\tstring ans = \"\";\\n\\tfor(int i=0; num != 0; i++){\\n\\t\\twhile(num >= no[i]){\\n\\t\\t\\tnum -= no[i];\\n\\t\\t\\tans += roman[i];\\n\\t\\t}\\n\\t}\\n\\treturn ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 657354,
                "title": "java-beatiful-solution",
                "content": "```\\n    public String intToRoman(int num) {\\n        StringBuilder sb = new StringBuilder();\\n        String[] romanNums = {\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"};\\n        int[] arabNums = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\\n        int index = 0;\\n        \\n        while (num > 0) {\\n            int mult = num / arabNums[index];\\n            \\n            if (mult > 0) {\\n                num %= arabNums[index];\\n                sb.append(romanNums[index].repeat(mult));\\n                // sb.append(String.join(\"\", Collections.nCopies(mult, romanNums[index])));\\n            }\\n            \\n            index++;\\n        }\\n        \\n        return sb.toString();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public String intToRoman(int num) {\\n        StringBuilder sb = new StringBuilder();\\n        String[] romanNums = {\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"};\\n        int[] arabNums = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\\n        int index = 0;\\n        \\n        while (num > 0) {\\n            int mult = num / arabNums[index];\\n            \\n            if (mult > 0) {\\n                num %= arabNums[index];\\n                sb.append(romanNums[index].repeat(mult));\\n                // sb.append(String.join(\"\", Collections.nCopies(mult, romanNums[index])));\\n            }\\n            \\n            index++;\\n        }\\n        \\n        return sb.toString();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 657129,
                "title": "my-c-solution-without-hardcoding-all-the-numerals",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    string intToRoman(int num)\\n    {       \\n        string res = \"\";\\n        string s[] = {\"I\", \"X\", \"C\", \"M\", \"V\", \"L\", \"D\", \"\"};\\n        int i = 0;\\n        while (num)\\n        {\\n            switch(num % 10)\\n            {\\n                case 1: res.insert(0, s[i]); break;\\n                case 2: res.insert(0, s[i] + s[i]); break;\\n                case 3: res.insert(0, s[i] + s[i] + s[i]); break;\\n                case 4: res.insert(0, s[i] + s[i + 4]); break;\\n                case 5: res.insert(0, s[i + 4]); break;\\n                case 6: res.insert(0, s[i + 4] + s[i]); break;\\n                case 7: res.insert(0, s[i + 4] + s[i] + s[i]); break;\\n                case 8: res.insert(0, s[i + 4] + s[i] + s[i] + s[i]); break;\\n                case 9: res.insert(0, s[i] + s[i + 1]); break;  \\n            }\\n            num /= 10;\\n            i++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    string intToRoman(int num)\\n    {       \\n        string res = \"\";\\n        string s[] = {\"I\", \"X\", \"C\", \"M\", \"V\", \"L\", \"D\", \"\"};\\n        int i = 0;\\n        while (num)\\n        {\\n            switch(num % 10)\\n            {\\n                case 1: res.insert(0, s[i]); break;\\n                case 2: res.insert(0, s[i] + s[i]); break;\\n                case 3: res.insert(0, s[i] + s[i] + s[i]); break;\\n                case 4: res.insert(0, s[i] + s[i + 4]); break;\\n                case 5: res.insert(0, s[i + 4]); break;\\n                case 6: res.insert(0, s[i + 4] + s[i]); break;\\n                case 7: res.insert(0, s[i + 4] + s[i] + s[i]); break;\\n                case 8: res.insert(0, s[i + 4] + s[i] + s[i] + s[i]); break;\\n                case 9: res.insert(0, s[i] + s[i + 1]); break;  \\n            }\\n            num /= 10;\\n            i++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 389923,
                "title": "faster-than-98-6-javascript",
                "content": "```\\nvar intToRoman = function(num) {\\n    var digit, r = \\'\\';\\n    var convert = (digit, tens, fives, ones) => {\\n        if(digit === 9) { r = r.concat(ones + tens); }\\n        else if(digit > 5) { r = r.concat(fives + ones.repeat(digit % 5)); }\\n        else if(digit === 5) { r = r.concat(fives); }\\n        else if(digit === 4) { r = r.concat(ones + fives); }\\n        else if(digit > 0) { r = r.concat(ones.repeat(digit)) }\\n    };\\n    \\n    if(num > 999) { convert(Math.floor(num/1000), \\'\\', \\'\\', \\'M\\');\\n        num = Math.floor(num%1000);\\n    }\\n    if(num > 99) { convert(Math.floor(num/100), \\'M\\', \\'D\\', \\'C\\');\\n        num = Math.floor(num%100);\\n    }\\n    if(num > 9) { convert(Math.floor(num/10), \\'C\\', \\'L\\', \\'X\\');\\n        num = Math.floor(num%10);\\n    }\\n    convert(num, \\'X\\', \\'V\\', \\'I\\');\\n    return r;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar intToRoman = function(num) {\\n    var digit, r = \\'\\';\\n    var convert = (digit, tens, fives, ones) => {\\n        if(digit === 9) { r = r.concat(ones + tens); }\\n        else if(digit > 5) { r = r.concat(fives + ones.repeat(digit % 5)); }\\n        else if(digit === 5) { r = r.concat(fives); }\\n        else if(digit === 4) { r = r.concat(ones + fives); }\\n        else if(digit > 0) { r = r.concat(ones.repeat(digit)) }\\n    };\\n    \\n    if(num > 999) { convert(Math.floor(num/1000), \\'\\', \\'\\', \\'M\\');\\n        num = Math.floor(num%1000);\\n    }\\n    if(num > 99) { convert(Math.floor(num/100), \\'M\\', \\'D\\', \\'C\\');\\n        num = Math.floor(num%100);\\n    }\\n    if(num > 9) { convert(Math.floor(num/10), \\'C\\', \\'L\\', \\'X\\');\\n        num = Math.floor(num%10);\\n    }\\n    convert(num, \\'X\\', \\'V\\', \\'I\\');\\n    return r;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 342992,
                "title": "java-solution-beats-100-100",
                "content": "```\\npublic String intToRoman(int num) {        \\n\\tString[] romans = new String[]{\"M\", \"CM\", \"D\", \"CD\", \\n\\t\\t\\t\\t\\t\\t\\t\\t   \"C\", \"XC\", \"L\", \"XL\",\\n\\t\\t\\t\\t\\t\\t\\t\\t  \"X\", \"IX\", \"V\", \"IV\", \"I\"};\\n\\tint[] numbers = new int[]{1000, 900, 500, 400,\\n\\t\\t\\t\\t\\t\\t\\t 100, 90, 50, 40,\\n\\t\\t\\t\\t\\t\\t\\t 10, 9, 5, 4, 1};\\n\\tStringBuilder romanRes = new StringBuilder();\\n\\tfor (int i = 0; i < romans.length; i++) {\\n\\t\\tif (num == 0) break;\\n\\t\\tint count = num/numbers[i];\\n\\t\\twhile (count > 0) {\\n\\t\\t\\tromanRes.append(romans[i]);\\n\\t\\t\\tcount--;\\n\\t\\t}\\n\\t\\tnum = num % numbers[i];\\n\\t}\\n\\n\\treturn romanRes.toString();\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic String intToRoman(int num) {        \\n\\tString[] romans = new String[]{\"M\", \"CM\", \"D\", \"CD\", \\n\\t\\t\\t\\t\\t\\t\\t\\t   \"C\", \"XC\", \"L\", \"XL\",\\n\\t\\t\\t\\t\\t\\t\\t\\t  \"X\", \"IX\", \"V\", \"IV\", \"I\"};\\n\\tint[] numbers = new int[]{1000, 900, 500, 400,\\n\\t\\t\\t\\t\\t\\t\\t 100, 90, 50, 40,\\n\\t\\t\\t\\t\\t\\t\\t 10, 9, 5, 4, 1};\\n\\tStringBuilder romanRes = new StringBuilder();\\n\\tfor (int i = 0; i < romans.length; i++) {\\n\\t\\tif (num == 0) break;\\n\\t\\tint count = num/numbers[i];\\n\\t\\twhile (count > 0) {\\n\\t\\t\\tromanRes.append(romans[i]);\\n\\t\\t\\tcount--;\\n\\t\\t}\\n\\t\\tnum = num % numbers[i];\\n\\t}\\n\\n\\treturn romanRes.toString();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 279026,
                "title": "c-solution-12ms-and-7-4mb-beats-100",
                "content": "```\\n#define ROMAN_SUM_TYPE_COUNT 13\\n\\nstruct RomanItem\\n{\\n\\tint interSum;\\n    char *romanStr;\\n};\\n\\nchar* intToRoman(int num) {\\n    char *answer = (char *)malloc(sizeof(char) * 50);\\n    answer[0] = \\'\\\\0\\';\\n    int quotient = 0;\\n    struct RomanItem romanArray[ROMAN_SUM_TYPE_COUNT] = {{1, \"I\"}, {4, \"IV\"}, {5, \"V\"}, {9, \"IX\"}, {10, \"X\"}, {40, \"XL\"}, {50, \"L\"}, {90, \"XC\"}, {100, \"C\"}, {400, \"CD\"}, {500, \"D\"},\\n        {900, \"CM\"}, {1000, \"M\"}};\\n    \\n    for (int i = ROMAN_SUM_TYPE_COUNT - 1; i >= 0; i--)\\n    {\\n        quotient = num/romanArray[i].interSum;\\n        while(quotient > 0)\\n        {\\n            strcat(answer, romanArray[i].romanStr);\\n            quotient--;\\n        }\\n        num = num % romanArray[i].interSum;\\n    }\\n    return answer;\\n}\\n```\\n\\ni had tried to solve this solution without enumeration but it\\'s more clearer and eaiser by enumeration...",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n#define ROMAN_SUM_TYPE_COUNT 13\\n\\nstruct RomanItem\\n{\\n\\tint interSum;\\n    char *romanStr;\\n};\\n\\nchar* intToRoman(int num) {\\n    char *answer = (char *)malloc(sizeof(char) * 50);\\n    answer[0] = \\'\\\\0\\';\\n    int quotient = 0;\\n    struct RomanItem romanArray[ROMAN_SUM_TYPE_COUNT] = {{1, \"I\"}, {4, \"IV\"}, {5, \"V\"}, {9, \"IX\"}, {10, \"X\"}, {40, \"XL\"}, {50, \"L\"}, {90, \"XC\"}, {100, \"C\"}, {400, \"CD\"}, {500, \"D\"},\\n        {900, \"CM\"}, {1000, \"M\"}};\\n    \\n    for (int i = ROMAN_SUM_TYPE_COUNT - 1; i >= 0; i--)\\n    {\\n        quotient = num/romanArray[i].interSum;\\n        while(quotient > 0)\\n        {\\n            strcat(answer, romanArray[i].romanStr);\\n            quotient--;\\n        }\\n        num = num % romanArray[i].interSum;\\n    }\\n    return answer;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 256455,
                "title": "a-top-1-10-concise-c-solution",
                "content": "The speed of this solution varies depending on run, but it\\'s always in top 10%.\\nNote: order by key in descending order in \\'foreach\\' is not required by this runtime \\u2014 it follows declaration order.\\n\\n```\\npublic class Solution \\n{\\n    public string IntToRoman(int num) \\n    {\\n        var result = new StringBuilder();\\n        var map = new Dictionary<int, string>\\n        {\\n            { 1000, \"M\" },\\n            { 900, \"CM\" },\\n            { 500, \"D\" },\\n            { 400, \"CD\" },\\n            { 100, \"C\" },\\n            { 90, \"XC\" },\\n            { 50, \"L\" },\\n            { 40, \"XL\" },\\n            { 10, \"X\" },\\n            { 9, \"IX\" },\\n            { 5, \"V\" },\\n            { 4, \"IV\" },\\n            { 1, \"I\" },\\n        };\\n        \\n        foreach (var kv in map)  \\n        {\\n            while (num >= kv.Key)\\n            {\\n                num -= kv.Key;\\n                result.Append(kv.Value);\\n            }\\n        }\\n        \\n        return result.ToString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution \\n{\\n    public string IntToRoman(int num) \\n    {\\n        var result = new StringBuilder();\\n        var map = new Dictionary<int, string>\\n        {\\n            { 1000, \"M\" },\\n            { 900, \"CM\" },\\n            { 500, \"D\" },\\n            { 400, \"CD\" },\\n            { 100, \"C\" },\\n            { 90, \"XC\" },\\n            { 50, \"L\" },\\n            { 40, \"XL\" },\\n            { 10, \"X\" },\\n            { 9, \"IX\" },\\n            { 5, \"V\" },\\n            { 4, \"IV\" },\\n            { 1, \"I\" },\\n        };\\n        \\n        foreach (var kv in map)  \\n        {\\n            while (num >= kv.Key)\\n            {\\n                num -= kv.Key;\\n                result.Append(kv.Value);\\n            }\\n        }\\n        \\n        return result.ToString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 196579,
                "title": "javascript-98",
                "content": "```\\n/**\\n * @param {number} num\\n * @return {string}\\n */\\n\\n /* value, str mapping */\\n const mapping = [\\n    [1000, \\'M\\'], [900, \\'CM\\'], [500, \\'D\\'], [400, \\'CD\\'], [100, \\'C\\'], [90, \\'XC\\'], [50, \\'L\\'], [40, \\'XL\\'], [10, \\'X\\'], [9, \\'IX\\'], [5, \\'V\\'], [4, \\'IV\\'], [1, \\'I\\']\\n];\\n\\nvar intToRoman = function(num) {\\n    let str = \\'\\';\\n\\n    for (let i = 0; i < mapping.length; i++) {\\n        const [val, char] = mapping[i];\\n\\n        if (num >= val) {\\n            while (num >= val) {\\n                num -= val;\\n                str += char;\\n            }\\n        }\\n    }\\n\\n    return str;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number} num\\n * @return {string}\\n */\\n\\n /* value, str mapping */\\n const mapping = [\\n    [1000, \\'M\\'], [900, \\'CM\\'], [500, \\'D\\'], [400, \\'CD\\'], [100, \\'C\\'], [90, \\'XC\\'], [50, \\'L\\'], [40, \\'XL\\'], [10, \\'X\\'], [9, \\'IX\\'], [5, \\'V\\'], [4, \\'IV\\'], [1, \\'I\\']\\n];\\n\\nvar intToRoman = function(num) {\\n    let str = \\'\\';\\n\\n    for (let i = 0; i < mapping.length; i++) {\\n        const [val, char] = mapping[i];\\n\\n        if (num >= val) {\\n            while (num >= val) {\\n                num -= val;\\n                str += char;\\n            }\\n        }\\n    }\\n\\n    return str;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4059438,
                "title": "best-o-1-solution",
                "content": "# Approach 1\\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(1)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        vector <string> s = {\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\", \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"};\\n        vector <int> value = {1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000};\\n        string ans = \"\";\\n        int i = value.size() - 1; \\n        while (i >= 0 ) {\\n            if (num < value[i]) {\\n                i--;\\n            } else {\\n                ans += s[i];\\n                num -= value[i];\\n            }    \\n        }\\n        return ans;\\n};\\n```\\n\\n# Approach 2\\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(1)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        vector <string> ones = {\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"};\\n        vector <string> tens = {\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"};\\n        vector <string> hrns = {\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"};\\n        vector <string> ths = {\"\", \"M\", \"MM\", \"MMM\"};\\n        \\n        return ths[num/1000] + hrns[(num%1000)/100] + tens[(num%100)/10] + ones[num%10];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        vector <string> s = {\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\", \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"};\\n        vector <int> value = {1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000};\\n        string ans = \"\";\\n        int i = value.size() - 1; \\n        while (i >= 0 ) {\\n            if (num < value[i]) {\\n                i--;\\n            } else {\\n                ans += s[i];\\n                num -= value[i];\\n            }    \\n        }\\n        return ans;\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        vector <string> ones = {\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"};\\n        vector <string> tens = {\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"};\\n        vector <string> hrns = {\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"};\\n        vector <string> ths = {\"\", \"M\", \"MM\", \"MMM\"};\\n        \\n        return ths[num/1000] + hrns[(num%1000)/100] + tens[(num%100)/10] + ones[num%10];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3722581,
                "title": "take-this-simple-sol-with-python",
                "content": "# Code\\n```\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        roman_mapping = {\\n            1000: \\'M\\',\\n            900: \\'CM\\',\\n            500: \\'D\\',\\n            400: \\'CD\\',\\n            100: \\'C\\',\\n            90: \\'XC\\',\\n            50: \\'L\\',\\n            40: \\'XL\\',\\n            10: \\'X\\',\\n            9: \\'IX\\',\\n            5: \\'V\\',\\n            4: \\'IV\\',\\n            1: \\'I\\'\\n        }\\n        result = \"\"\\n        for value, symbol in roman_mapping.items():\\n            while num >= value:\\n                result += symbol\\n                num -= value\\n        return result\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        roman_mapping = {\\n            1000: \\'M\\',\\n            900: \\'CM\\',\\n            500: \\'D\\',\\n            400: \\'CD\\',\\n            100: \\'C\\',\\n            90: \\'XC\\',\\n            50: \\'L\\',\\n            40: \\'XL\\',\\n            10: \\'X\\',\\n            9: \\'IX\\',\\n            5: \\'V\\',\\n            4: \\'IV\\',\\n            1: \\'I\\'\\n        }\\n        result = \"\"\\n        for value, symbol in roman_mapping.items():\\n            while num >= value:\\n                result += symbol\\n                num -= value\\n        return result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2423552,
                "title": "simple-c-solution-comments-added",
                "content": "```\\nclass Solution {\\npublic:\\n    // creating int to roman map.\\n    unordered_map<int,char>itor={\\n        {1,\\'I\\'},{5,\\'V\\'},{10,\\'X\\'},{50,\\'L\\'},{100,\\'C\\'},{500,\\'D\\'},{1000,\\'M\\'}\\n    };\\n    // reverse the string.\\n    void reverse(string &s)\\n    {\\n        int i=0,j=s.length()-1;\\n        while(i<j)\\n        {\\n            swap(s[i],s[j]);\\n            i++;j--;\\n        }\\n    }\\n    // main function.\\n    string intToRoman(int num) {\\n        \\n        string res=\"\";\\n        //Multiplier to determine once,tens... places\\n        int mul=1;\\n        while(num)\\n        {\\n            int x=num%10; //last digit\\n            num/=10; //removing last digit from num.\\n            if(x==0) //if zero then move to next digit (with increasing multiplier).\\n            {\\n                mul*=10;\\n                continue;\\n            }\\n            // we have two cases 4 and 9 then make b=5 || 10.\\n            int b=-1;\\n            if(x==4)\\n                b=5;\\n            else if(x==9)\\n                b=10;\\n            \\n            if(b==-1) //if last digit is not 4||9 then simply add I. for 3= III\\n            {\\n                while(x)\\n                {\\n                    if(x==5)\\n                    {\\n                        res+=itor[5*mul];\\n                        x-=5;\\n                    }\\n                    else\\n                    {\\n                        res+=itor[1*mul];\\n                        x-=1;\\n                    }\\n                }\\n            }\\n            else // if(last digit is 4||9) then add IV or IX to res.\\n            {\\n                res+=itor[b*mul];\\n                res+=itor[1*mul];\\n            }\\n            mul*=10;\\n        }\\n        //we traversed from lsb to msb so reverse the string.\\n        reverse(res);\\n        return res;\\n        // remember if 4 comes then we add VI to res so that reverse will be IV.\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // creating int to roman map.\\n    unordered_map<int,char>itor={\\n        {1,\\'I\\'},{5,\\'V\\'},{10,\\'X\\'},{50,\\'L\\'},{100,\\'C\\'},{500,\\'D\\'},{1000,\\'M\\'}\\n    };\\n    // reverse the string.\\n    void reverse(string &s)\\n    {\\n        int i=0,j=s.length()-1;\\n        while(i<j)\\n        {\\n            swap(s[i],s[j]);\\n            i++;j--;\\n        }\\n    }\\n    // main function.\\n    string intToRoman(int num) {\\n        \\n        string res=\"\";\\n        //Multiplier to determine once,tens... places\\n        int mul=1;\\n        while(num)\\n        {\\n            int x=num%10; //last digit\\n            num/=10; //removing last digit from num.\\n            if(x==0) //if zero then move to next digit (with increasing multiplier).\\n            {\\n                mul*=10;\\n                continue;\\n            }\\n            // we have two cases 4 and 9 then make b=5 || 10.\\n            int b=-1;\\n            if(x==4)\\n                b=5;\\n            else if(x==9)\\n                b=10;\\n            \\n            if(b==-1) //if last digit is not 4||9 then simply add I. for 3= III\\n            {\\n                while(x)\\n                {\\n                    if(x==5)\\n                    {\\n                        res+=itor[5*mul];\\n                        x-=5;\\n                    }\\n                    else\\n                    {\\n                        res+=itor[1*mul];\\n                        x-=1;\\n                    }\\n                }\\n            }\\n            else // if(last digit is 4||9) then add IV or IX to res.\\n            {\\n                res+=itor[b*mul];\\n                res+=itor[1*mul];\\n            }\\n            mul*=10;\\n        }\\n        //we traversed from lsb to msb so reverse the string.\\n        reverse(res);\\n        return res;\\n        // remember if 4 comes then we add VI to res so that reverse will be IV.\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2366255,
                "title": "c-simple-and-clean-solution",
                "content": "Please Upvote if it helped you !!!\\nHappy Coding :)\\n```\\nstring intToRoman(int num) \\n    {\\n        string answer=\"\";\\n        string ones[]={\"\",\"I\",\"II\",\"III\",\"IV\",\"V\",\"VI\",\"VII\",\"VIII\",\"IX\"};\\n        string tens[]={\"\",\"X\",\"XX\",\"XXX\",\"XL\",\"L\",\"LX\",\"LXX\",\"LXXX\",\"XC\"};\\n        string hundreds[] ={\"\",\"C\",\"CC\",\"CCC\",\"CD\",\"D\",\"DC\",\"DCC\",\"DCCC\",\"CM\"};\\n        string thousands[]={\"\",\"M\",\"MM\",\"MMM\"};\\n        answer=thousands[num/1000]+hundreds[(num%1000)/100]+tens[(num%100)/10]+ones[num%10];\\n        return answer;\\n    }\\n```\\t",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nstring intToRoman(int num) \\n    {\\n        string answer=\"\";\\n        string ones[]={\"\",\"I\",\"II\",\"III\",\"IV\",\"V\",\"VI\",\"VII\",\"VIII\",\"IX\"};\\n        string tens[]={\"\",\"X\",\"XX\",\"XXX\",\"XL\",\"L\",\"LX\",\"LXX\",\"LXXX\",\"XC\"};\\n        string hundreds[] ={\"\",\"C\",\"CC\",\"CCC\",\"CD\",\"D\",\"DC\",\"DCC\",\"DCCC\",\"CM\"};\\n        string thousands[]={\"\",\"M\",\"MM\",\"MMM\"};\\n        answer=thousands[num/1000]+hundreds[(num%1000)/100]+tens[(num%100)/10]+ones[num%10];\\n        return answer;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1924307,
                "title": "java-intuitive-easy-to-understand-and-remember-solution-100-faster-fully-extensible-too",
                "content": "There are two solutions in this post. The second approach is based on the first approach. \\nThe second approach supports adding new symbols or loading them in runtime without changing the code, one important aspect in code design. (e.g. S.O.L.I.D)\\n\\nThe main idea is to get each digit from left to right of the input `num`, convert each digit to Roman numeral(s) according to the Substraction rules and Mappings at the bottom of the post, and combine them as the final result.\\n\\nFor example: the mappings below are examples for [1,10).\\n\\n```\\n1  -> I\\n2  -> II\\n3  -> III\\n4  -> IV (not IIII)\\n5  -> V\\n6  -> VI\\n7  -> VII\\n8  -> VIII\\n9  -> IX (not VIIII)\\n```\\nThe mappings above are coded in the method `intToRoman` below, with \"I\", \"V\", \"X\" passed as arguments for the case of [1,10).\\n\\t`intToRoman(rs, num % 10, \"I\", \"V\", \"X\"); //get 4 in 1234`\\n\\nThe same principle applies to tens, hundreds, and thousands when a single digit is considered and mapped to its respective Roman symbols. \\n\\nSee the mappings at the bottom of the post for tens, hundreds, and thousands.\\n\\nThe solution below is intuitive and easy to understand and remember, which is what matters during interviews.\\n\\n\\n```\\nclass Solution {\\n\\tpublic String intToRoman(int num) {\\n\\t\\tStringBuilder rs = new StringBuilder();\\n\\t\\tintToRoman(rs, num / 1000, \"M\", \"\", \"\"); //get 1 in 1234\\n\\t\\tintToRoman(rs, num / 100 % 10, \"C\", \"D\", \"M\"); //get 2 in 1234\\n\\t\\tintToRoman(rs, num / 10 % 10, \"X\", \"L\", \"C\");  //get 3 in 1234\\n\\t\\tintToRoman(rs, num % 10, \"I\", \"V\", \"X\"); //get 4 in 1234\\n\\t\\treturn rs.toString();\\n\\t}\\n\\n //Comments are an example of [1,10)\\n  private void intToRoman(StringBuilder sb, int num, String one, String five, String ten) {\\n\\t\\tif (1 <= num) {\\n\\t\\t\\tif (num < 4) {\\n\\t\\t\\t\\tsb.append(one.repeat(num)); //this is I, or II, or III, one could be I, X C, M depending on whether it is under tens, tens, hundreds, or thousands\\n\\t\\t\\t} else if (num < 5) { // num >= 4 && num < 5)\\n\\t\\t\\t\\tsb.append(one).append(five); //this is IV\\n\\t\\t\\t} else if (num == 5) {\\n\\t\\t\\t\\tsb.append(five); //this V\\n\\t\\t\\t} else if (num < 9) { // num > 5 && num < 9\\n\\t\\t\\t\\tsb.append(five).append(one.repeat(num - 5)); //this is VI, or VII, or VIII\\n\\t\\t\\t} else { // num >= 9 && num < 10\\n\\t\\t\\t\\tsb.append(one).append(ten); //this is IX\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n```\\n\\nHope it helps.\\n\\nPlease upvote if it does.\\n\\nFor completeness, below are the references\\n**The Substraction Rules:**\\n```\\n There are six instances where subtraction is used:\\nI can be placed before V (5) and X (10) to make 4 and 9. \\nX can be placed before L (50) and C (100) to make 40 and 90. \\nC can be placed before D (500) and M (1000) to make 400 and 900.\\n```\\n**The Mappings:**\\n```\\n(\\'I\\', 1)\\n(\\'V\\', 5)\\n(\\'X\\', 10)\\n(\\'L\\', 50)\\n(\\'C\\', 100)\\n(\\'D\\', 500)\\n(\\'M\\', 1000)\\n```\\n\\nExamples\\n```\\n3 -> III\\n58- > LVIII\\n1994 -> MCMXCIV\\n```\\nScore (the score is not constant for some reason)\\n![image](https://assets.leetcode.com/users/images/bef342b3-9f4d-4769-8315-5cc924e5c8ff_1649363126.5775585.jpeg)\\n\\n**Follow Up**\\nThe benefit of this method is fully extensible. If it has to support larger number over the current limit, new mappings can be added in `map` variable, even during runtime, the rest of the code remains unchanged.\\n\\nFor example, adding new symbols or loading them in runtime is like below:\\n   \\n   `itr.map.add(new String[] { \"M\", \"\", \"\" });`\\n   \\nThis is the important and bonus point if asked during an interview.\\n\\n```\\nclass Solution {\\n\\n\\tpublic static List<String[]> map = new ArrayList<String[]>();//public for runtime call\\n\\tstatic {\\n\\t\\tmap.add(new String[] { \"I\", \"V\", \"X\" });\\n\\t\\tmap.add(new String[] { \"X\", \"L\", \"C\" });\\n\\t\\tmap.add(new String[] { \"C\", \"D\", \"M\" });\\n\\t\\tmap.add(new String[] { \"M\", \"\", \"\" });\\n\\t}\\n\\n\\tpublic String intToRoman(int num) {\\n\\t\\tStringBuilder rs = new StringBuilder();\\n\\t\\tint n = map.size();\\n\\t\\tfor (int i = n - 1; i >= 0; i--) {\\n\\t\\t\\tintToRoman(rs, num / ((int) Math.pow(10, i)) % 10, map.get(i)[0], map.get(i)[1], map.get(i)[2]);\\n\\t\\t}\\n\\t\\treturn rs.toString();\\n\\t}\\n\\n\\tprivate void intToRoman(StringBuilder sb, int num, String one, String five, String ten) {\\n\\t\\tif (1 <= num) {\\n\\t\\t\\tif (num < 4) {\\n\\t\\t\\t\\tsb.append(one.repeat(num));\\n\\t\\t\\t} else if (num < 5) { // num >= 4 && num < 5)\\n\\t\\t\\t\\tsb.append(one).append(five);\\n\\t\\t\\t} else if (num == 5) {\\n\\t\\t\\t\\tsb.append(five);\\n\\t\\t\\t} else if (num < 9) { // num > 5 && num < 9\\n\\t\\t\\t\\tsb.append(five).append(one.repeat(num - 5));\\n\\t\\t\\t} else { // num >= 9 && num < 10\\n\\t\\t\\t\\tsb.append(one).append(ten);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n```\\nPlease upvote if it helps.\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n1  -> I\\n2  -> II\\n3  -> III\\n4  -> IV (not IIII)\\n5  -> V\\n6  -> VI\\n7  -> VII\\n8  -> VIII\\n9  -> IX (not VIIII)\\n```\n```\\nclass Solution {\\n\\tpublic String intToRoman(int num) {\\n\\t\\tStringBuilder rs = new StringBuilder();\\n\\t\\tintToRoman(rs, num / 1000, \"M\", \"\", \"\"); //get 1 in 1234\\n\\t\\tintToRoman(rs, num / 100 % 10, \"C\", \"D\", \"M\"); //get 2 in 1234\\n\\t\\tintToRoman(rs, num / 10 % 10, \"X\", \"L\", \"C\");  //get 3 in 1234\\n\\t\\tintToRoman(rs, num % 10, \"I\", \"V\", \"X\"); //get 4 in 1234\\n\\t\\treturn rs.toString();\\n\\t}\\n\\n //Comments are an example of [1,10)\\n  private void intToRoman(StringBuilder sb, int num, String one, String five, String ten) {\\n\\t\\tif (1 <= num) {\\n\\t\\t\\tif (num < 4) {\\n\\t\\t\\t\\tsb.append(one.repeat(num)); //this is I, or II, or III, one could be I, X C, M depending on whether it is under tens, tens, hundreds, or thousands\\n\\t\\t\\t} else if (num < 5) { // num >= 4 && num < 5)\\n\\t\\t\\t\\tsb.append(one).append(five); //this is IV\\n\\t\\t\\t} else if (num == 5) {\\n\\t\\t\\t\\tsb.append(five); //this V\\n\\t\\t\\t} else if (num < 9) { // num > 5 && num < 9\\n\\t\\t\\t\\tsb.append(five).append(one.repeat(num - 5)); //this is VI, or VII, or VIII\\n\\t\\t\\t} else { // num >= 9 && num < 10\\n\\t\\t\\t\\tsb.append(one).append(ten); //this is IX\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n```\n```\\n There are six instances where subtraction is used:\\nI can be placed before V (5) and X (10) to make 4 and 9. \\nX can be placed before L (50) and C (100) to make 40 and 90. \\nC can be placed before D (500) and M (1000) to make 400 and 900.\\n```\n```\\n(\\'I\\', 1)\\n(\\'V\\', 5)\\n(\\'X\\', 10)\\n(\\'L\\', 50)\\n(\\'C\\', 100)\\n(\\'D\\', 500)\\n(\\'M\\', 1000)\\n```\n```\\n3 -> III\\n58- > LVIII\\n1994 -> MCMXCIV\\n```\n```\\nclass Solution {\\n\\n\\tpublic static List<String[]> map = new ArrayList<String[]>();//public for runtime call\\n\\tstatic {\\n\\t\\tmap.add(new String[] { \"I\", \"V\", \"X\" });\\n\\t\\tmap.add(new String[] { \"X\", \"L\", \"C\" });\\n\\t\\tmap.add(new String[] { \"C\", \"D\", \"M\" });\\n\\t\\tmap.add(new String[] { \"M\", \"\", \"\" });\\n\\t}\\n\\n\\tpublic String intToRoman(int num) {\\n\\t\\tStringBuilder rs = new StringBuilder();\\n\\t\\tint n = map.size();\\n\\t\\tfor (int i = n - 1; i >= 0; i--) {\\n\\t\\t\\tintToRoman(rs, num / ((int) Math.pow(10, i)) % 10, map.get(i)[0], map.get(i)[1], map.get(i)[2]);\\n\\t\\t}\\n\\t\\treturn rs.toString();\\n\\t}\\n\\n\\tprivate void intToRoman(StringBuilder sb, int num, String one, String five, String ten) {\\n\\t\\tif (1 <= num) {\\n\\t\\t\\tif (num < 4) {\\n\\t\\t\\t\\tsb.append(one.repeat(num));\\n\\t\\t\\t} else if (num < 5) { // num >= 4 && num < 5)\\n\\t\\t\\t\\tsb.append(one).append(five);\\n\\t\\t\\t} else if (num == 5) {\\n\\t\\t\\t\\tsb.append(five);\\n\\t\\t\\t} else if (num < 9) { // num > 5 && num < 9\\n\\t\\t\\t\\tsb.append(five).append(one.repeat(num - 5));\\n\\t\\t\\t} else { // num >= 9 && num < 10\\n\\t\\t\\t\\tsb.append(one).append(ten);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1872499,
                "title": "c-java-solution-greedy",
                "content": "**Intuition**\\nGreedily always subtract the maximal roman number equivalent value from ```num```.\\n\\n**Complexity**\\n- Time: O(1)\\n- Space: O(1)\\n\\n**Implementation**\\n- C#\\n```\\npublic class Solution {\\n    public string IntToRoman(int num) {\\n        \\n        if(num < 1)\\n            throw new ArgumentException(\"Invaid Input.\");\\n        \\n        string[] roman = new string[]{\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\\n        int[] nums = new int[]{1000,900,500,400,100,90,50,40,10,9,5,4,1};\\n        \\n        string res = \"\";\\n        int i = 0;\\n        \\n        while(num > 0)\\n        {\\n            while(num >= nums[i])\\n            {\\n                res += roman[i];\\n                num -= nums[i];\\n            }            \\n            i++;  \\n        }\\n\\n        return res;\\n    }\\n}\\n```\\n\\n- Java\\n```\\nclass Solution {\\n    public String intToRoman(int num) {\\n        \\n        String[] roman = new String[]{\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"};\\n        int[] nums = new int[]{1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\\n        \\n        String res = \"\";\\n        int i = 0;\\n        while(num > 0)\\n        {\\n            while(num >= nums[i])\\n            {\\n                res += roman[i];\\n                num -= nums[i];\\n            }\\n            i++;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```num```\n```\\npublic class Solution {\\n    public string IntToRoman(int num) {\\n        \\n        if(num < 1)\\n            throw new ArgumentException(\"Invaid Input.\");\\n        \\n        string[] roman = new string[]{\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\\n        int[] nums = new int[]{1000,900,500,400,100,90,50,40,10,9,5,4,1};\\n        \\n        string res = \"\";\\n        int i = 0;\\n        \\n        while(num > 0)\\n        {\\n            while(num >= nums[i])\\n            {\\n                res += roman[i];\\n                num -= nums[i];\\n            }            \\n            i++;  \\n        }\\n\\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public String intToRoman(int num) {\\n        \\n        String[] roman = new String[]{\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"};\\n        int[] nums = new int[]{1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\\n        \\n        String res = \"\";\\n        int i = 0;\\n        while(num > 0)\\n        {\\n            while(num >= nums[i])\\n            {\\n                res += roman[i];\\n                num -= nums[i];\\n            }\\n            i++;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1799449,
                "title": "clear-c-solution-6-lines",
                "content": "```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        int integer[13]={1000,900,500,400,100,90,50,40,10,9,5,4,1};\\n        string roman[13]={\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\\n        string res=\"\";\\n        for(int i=0;i<13;i++){\\n            while(num>=integer[i]){\\n                res+=roman[i];\\n                num-=integer[i];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        int integer[13]={1000,900,500,400,100,90,50,40,10,9,5,4,1};\\n        string roman[13]={\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\\n        string res=\"\";\\n        for(int i=0;i<13;i++){\\n            while(num>=integer[i]){\\n                res+=roman[i];\\n                num-=integer[i];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1776923,
                "title": "go-simple-solution",
                "content": "```   \\nfunc intToRoman(num int) string {\\n    symbol := []string{\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"}\\n    value := []int{1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1}\\n    \\n    result := \"\"\\n    \\n    for num > 0{\\n        for i := range value{\\n            if num >= value[i]{\\n                result += symbol[i] \\n                num -= value[i]\\n                break\\n            }\\n        }\\n    }\\n    return result\\n    \\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```   \\nfunc intToRoman(num int) string {\\n    symbol := []string{\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"}\\n    value := []int{1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1}\\n    \\n    result := \"\"\\n    \\n    for num > 0{\\n        for i := range value{\\n            if num >= value[i]{\\n                result += symbol[i] \\n                num -= value[i]\\n                break\\n            }\\n        }\\n    }\\n    return result\\n    \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1644959,
                "title": "optimised-solution-3ms-38-3mb",
                "content": "class Solution {\\n\\n    public String intToRoman(int num) {\\n       StringBuilder result = new StringBuilder();\\n        int[] div = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\\n        String[] roman = {\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"};\\n        for (int i = 0; i < div.length;) {\\n            if (num >= div[i]) {\\n                result.append(roman[i]);\\n                num -= div[i];\\n            } \\n            else i++;\\n        }\\n        \\n        return result.toString();  \\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "class Solution {\\n\\n    public String intToRoman(int num) {\\n       StringBuilder result = new StringBuilder();\\n        int[] div = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1}",
                "codeTag": "Java"
            },
            {
                "id": 1511574,
                "title": "cpp-solution-easy-to-understand",
                "content": "**Please upvote if you like the solution** \\n\\nCode ->\\n```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) \\n    {\\n        string ans;\\nstring symbol[] = {\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"};\\n        int val[] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\\n        \\n        for(int i=0; num != 0; i++)\\n        {\\n            while(num >= val[i])\\n            {\\n                num -= val[i];\\n                ans += symbol[i];\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) \\n    {\\n        string ans;\\nstring symbol[] = {\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"};\\n        int val[] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\\n        \\n        for(int i=0; num != 0; i++)\\n        {\\n            while(num >= val[i])\\n            {\\n                num -= val[i];\\n                ans += symbol[i];\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1448993,
                "title": "python-easiest-dictionary-solution",
                "content": "```\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        translation = {\\n            \\'M\\': 1000,\\n            \\'CM\\': 900,\\n            \\'D\\': 500,\\n            \\'CD\\': 400,\\n            \\'C\\': 100,\\n            \\'XC\\': 90,\\n            \\'L\\': 50,\\n            \\'XL\\': 40,\\n            \\'X\\': 10,\\n            \\'IX\\': 9,\\n            \\'V\\': 5,\\n            \\'IV\\': 4,\\n            \\'I\\': 1,\\n        }\\n        out = \\'\\'\\n        for s,n in translation.items():\\n            out += num // n * s\\n            num %= n\\n        \\n        return out\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        translation = {\\n            \\'M\\': 1000,\\n            \\'CM\\': 900,\\n            \\'D\\': 500,\\n            \\'CD\\': 400,\\n            \\'C\\': 100,\\n            \\'XC\\': 90,\\n            \\'L\\': 50,\\n            \\'XL\\': 40,\\n            \\'X\\': 10,\\n            \\'IX\\': 9,\\n            \\'V\\': 5,\\n            \\'IV\\': 4,\\n            \\'I\\': 1,\\n        }\\n        out = \\'\\'\\n        for s,n in translation.items():\\n            out += num // n * s\\n            num %= n\\n        \\n        return out\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1396382,
                "title": "python-95-faster-easy-solution",
                "content": "```\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        roman_dict = {\"M\": 1000, \"CM\": 900, \"D\": 500, \"CD\": 400, \"C\": 100,\\n                     \"XC\": 90, \"L\": 50, \"XL\": 40, \"X\": 10, \"IX\": 9, \"V\": 5,\\n                     \"IV\": 4, \"I\": 1}\\n        output = \"\"\\n        while num >= 1:\\n            for key in roman_dict.keys():\\n                if num - roman_dict[key] >= 0:\\n                    output += key\\n                    num -= roman_dict[key]\\n                    break\\n        return output\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        roman_dict = {\"M\": 1000, \"CM\": 900, \"D\": 500, \"CD\": 400, \"C\": 100,\\n                     \"XC\": 90, \"L\": 50, \"XL\": 40, \"X\": 10, \"IX\": 9, \"V\": 5,\\n                     \"IV\": 4, \"I\": 1}\\n        output = \"\"\\n        while num >= 1:\\n            for key in roman_dict.keys():\\n                if num - roman_dict[key] >= 0:\\n                    output += key\\n                    num -= roman_dict[key]\\n                    break\\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1343815,
                "title": "c-solution-simple-short-and-clear",
                "content": "```\\nstring intToRoman(int num)\\n    {\\n        string symbol[13] = {\"I\",\"IV\",\"V\",\"IX\",\"X\",\"XL\",\"L\",\"XC\",\"C\",\"CD\",\"D\",\"CM\",\"M\"};\\n        int number[13] = {1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000}; \\n        int i = 12;\\n        string ans = \"\";\\n        \\n        while(num > 0)\\n        {\\n            int count = num / number[i];\\n            num = num % number[i];\\n            \\n            while(count--)\\n            {\\n                ans = ans + symbol[i];\\n            }\\n            \\n            i--;\\n        }\\n        \\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "```\\nstring intToRoman(int num)\\n    {\\n        string symbol[13] = {\"I\",\"IV\",\"V\",\"IX\",\"X\",\"XL\",\"L\",\"XC\",\"C\",\"CD\",\"D\",\"CM\",\"M\"};\\n        int number[13] = {1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000}; \\n        int i = 12;\\n        string ans = \"\";\\n        \\n        while(num > 0)\\n        {\\n            int count = num / number[i];\\n            num = num % number[i];\\n            \\n            while(count--)\\n            {\\n                ans = ans + symbol[i];\\n            }\\n            \\n            i--;\\n        }\\n        \\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1250878,
                "title": "easy-python-logic",
                "content": "Instead of the dictionary you can also use two lists.\\n```\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        d={\\n            1000:\\'M\\',\\n            900:\\'CM\\',\\n            500:\\'D\\',\\n            400:\\'CD\\',\\n            100:\\'C\\',\\n            90:\\'XC\\',\\n            50:\\'L\\',\\n            40:\\'XL\\',\\n            10:\\'X\\',\\n            9:\\'IX\\',\\n            5:\\'V\\',\\n            4:\\'IV\\',\\n            1:\\'I\\'\\n        }\\n        s=\"\"\\n        while num!=0:\\n            for i in d.keys():\\n                if num>=i:\\n                    s+=d[i]\\n                    num-=i\\n                    break\\n        return s",
                "solutionTags": [],
                "code": "class Solution:\\n    def intToRoman(self, num: int) -> str:\\n        d={\\n            1000:\\'M\\',\\n            900:\\'CM\\',\\n            500:\\'D\\',\\n            400:\\'CD\\',\\n            100:\\'C\\',\\n            90:\\'XC\\',\\n            50:\\'L\\',\\n            40:\\'XL\\',\\n            10:\\'X\\',\\n            9:\\'IX\\',\\n            5:\\'V\\',\\n            4:\\'IV\\',\\n            1:\\'I\\'\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1210718,
                "title": "c-upper-bound-clean-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        \\n        map<int, string> mp = {{1,\"I\"}, \\n                               {5,\"V\"}, \\n                               {10,\"X\"}, \\n                               {50,\"L\"}, \\n                               {100,\"C\"}, \\n                               {500,\"D\"}, \\n                               {1000,\"M\"}, \\n                               {4,\"IV\"}, \\n                               {9,\"IX\"}, \\n                               {40,\"XL\"},\\n                               {90,\"XC\"},\\n                               {400,\"CD\"},\\n                               {900,\"CM\"}};   \\n        string ans;\\n        while(num > 0){\\n            auto it = --mp.upper_bound(num);\\n            num -= (it->first);\\n            ans += (it->second);\\n        }\\n        return ans;      \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        \\n        map<int, string> mp = {{1,\"I\"}, \\n                               {5,\"V\"}, \\n                               {10,\"X\"}, \\n                               {50,\"L\"}, \\n                               {100,\"C\"}, \\n                               {500,\"D\"}, \\n                               {1000,\"M\"}, \\n                               {4,\"IV\"}, \\n                               {9,\"IX\"}, \\n                               {40,\"XL\"},\\n                               {90,\"XC\"},\\n                               {400,\"CD\"},\\n                               {900,\"CM\"}};   \\n        string ans;\\n        while(num > 0){\\n            auto it = --mp.upper_bound(num);\\n            num -= (it->first);\\n            ans += (it->second);\\n        }\\n        return ans;      \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1184992,
                "title": "python3-simple-and-easy-to-understand-solution-using-dictionary",
                "content": "```\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        d = {1000: \\'M\\', 900: \\'CM\\', 500: \\'D\\', 400: \\'CD\\', 100: \\'C\\', 90: \\'XC\\', 50: \\'L\\', 40: \\'XL\\', 10: \\'X\\', 9: \\'IX\\', 5: \\'V\\', 4: \\'IV\\', 1: \\'I\\'}\\n        s = \\'\\'\\n        for i in d.keys():\\n            s += (num//i)*d[i]\\n            num %= i\\n        return s\\n```\\n**If you like this solution, please upvote for this**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        d = {1000: \\'M\\', 900: \\'CM\\', 500: \\'D\\', 400: \\'CD\\', 100: \\'C\\', 90: \\'XC\\', 50: \\'L\\', 40: \\'XL\\', 10: \\'X\\', 9: \\'IX\\', 5: \\'V\\', 4: \\'IV\\', 1: \\'I\\'}\\n        s = \\'\\'\\n        for i in d.keys():\\n            s += (num//i)*d[i]\\n            num %= i\\n        return s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1103918,
                "title": "c-simple-and-easy-to-understand-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        vector<int> values{1,4,5,9,10,40,50,90,100,400,500,900,1000};\\n        vector<string> roman{\"I\",\"IV\",\"V\",\"IX\",\"X\",\"XL\",\"L\",\"XC\",\"C\",\"CD\",\"D\",\"CM\",\"M\"};\\n        int idx=roman.size()-1;\\n        \\n        string ans;\\n        while(num>0){\\n            while(num<values[idx])\\n                idx--;\\n            int count=num/values[idx];\\n            num=num-count*values[idx];\\n            while(count--){\\n                ans+=roman[idx];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Time Complexity:** \\nO(1) as num is limited to 3999 only. \\nO(n) if num is very very large and we need add \"M\" to string multiple times (Not given in constraints).\\n\\nWhy O(1) ? \\nReason - In worst case it will take constant(3) calls for some values[i] and value size is also constant to 13. \\nSo runtime will be < 13 * 3 only => *O(39) ~ O(1)*\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        vector<int> values{1,4,5,9,10,40,50,90,100,400,500,900,1000};\\n        vector<string> roman{\"I\",\"IV\",\"V\",\"IX\",\"X\",\"XL\",\"L\",\"XC\",\"C\",\"CD\",\"D\",\"CM\",\"M\"};\\n        int idx=roman.size()-1;\\n        \\n        string ans;\\n        while(num>0){\\n            while(num<values[idx])\\n                idx--;\\n            int count=num/values[idx];\\n            num=num-count*values[idx];\\n            while(count--){\\n                ans+=roman[idx];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1103010,
                "title": "clean-correct-python-solution",
                "content": "```\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        \\n        vals = [ 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 ]\\n        romans = [ \"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\" ]\\n        \\n        res=\\'\\'\\n        \\n        for i,v in enumerate(vals):\\n            \\n            res += (num//v) * romans[i];\\n            num %= v\\n            \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        \\n        vals = [ 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 ]\\n        romans = [ \"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\" ]\\n        \\n        res=\\'\\'\\n        \\n        for i,v in enumerate(vals):\\n            \\n            res += (num//v) * romans[i];\\n            num %= v\\n            \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 625791,
                "title": "golang-8ms",
                "content": "```go\\nimport \"strings\"\\n\\ntype node struct {\\n    val int\\n    s string\\n}\\n\\nvar romanNodes = []node{\\n    {1000, \"M\"},\\n    {900, \"CM\"},\\n    {500, \"D\"},\\n    {400, \"CD\"},\\n    {100, \"C\"},\\n    {90, \"XC\"},\\n    {50, \"L\"},\\n    {40, \"XL\"},\\n    {10, \"X\"},\\n    {9, \"IX\"},\\n    {5, \"V\"},\\n    {4, \"IV\"},\\n    {1, \"I\"},\\n}\\n\\nfunc intToRoman(num int) string {\\n    sb := strings.Builder{}\\n    \\n    for _, n := range romanNodes {\\n        for num >= n.val {\\n            sb.WriteString(n.s)\\n            num -= n.val\\n        }   \\n    }\\n    \\n    return sb.String()\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nimport \"strings\"\\n\\ntype node struct {\\n    val int\\n    s string\\n}\\n\\nvar romanNodes = []node{\\n    {1000, \"M\"},\\n    {900, \"CM\"},\\n    {500, \"D\"},\\n    {400, \"CD\"},\\n    {100, \"C\"},\\n    {90, \"XC\"},\\n    {50, \"L\"},\\n    {40, \"XL\"},\\n    {10, \"X\"},\\n    {9, \"IX\"},\\n    {5, \"V\"},\\n    {4, \"IV\"},\\n    {1, \"I\"},\\n}\\n\\nfunc intToRoman(num int) string {\\n    sb := strings.Builder{}\\n    \\n    for _, n := range romanNodes {\\n        for num >= n.val {\\n            sb.WriteString(n.s)\\n            num -= n.val\\n        }   \\n    }\\n    \\n    return sb.String()\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 544197,
                "title": "easy-java-solution-self-explanatory",
                "content": "class Solution {\\n    public String intToRoman(int num) {\\n    int[] values = {1000,900,500,400,100,90,50,40,10,9,5,4,1};\\n     String[] romanLiterals = {\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\\n    StringBuilder roman = new StringBuilder();\\n        for(int i=0;i<values.length;i++){\\n            while(num>=values[i]){\\n                roman.append(romanLiterals[i]);\\n                    num-=values[i];\\n            }\\n            \\n        }\\n        return roman.toString();\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public String intToRoman(int num) {\\n    int[] values = {1000,900,500,400,100,90,50,40,10,9,5,4,1}",
                "codeTag": "Java"
            },
            {
                "id": 318386,
                "title": "java-4-ms-faster-than-69-85-36-1-mb-less-than-99-98",
                "content": "```\\nclass Solution {\\n    public String intToRoman(int n) {\\n       String M[] = {\"\", \"M\", \"MM\", \"MMM\"};\\n        String C[] = {\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"};\\n        String X[] = {\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"};\\n        String I[] = {\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"};\\n        return M[n / 1000] + C[(n / 100) % 10] + X[(n / 10) % 10] + I[n % 10];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String intToRoman(int n) {\\n       String M[] = {\"\", \"M\", \"MM\", \"MMM\"};\\n        String C[] = {\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"};\\n        String X[] = {\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"};\\n        String I[] = {\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"};\\n        return M[n / 1000] + C[(n / 100) % 10] + X[(n / 10) % 10] + I[n % 10];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 262432,
                "title": "faster-than-100-00-of-java",
                "content": "Runtime: 4 ms, faster than 100.00% of Java online submissions for Integer to Roman.\\nMemory Usage: 37.6 MB, less than 100.00% of Java online submissions for Integer to Roman.\\n```java \\nclass Solution {\\n    public String intToRoman(int num) {\\n        StringBuilder  result = new StringBuilder();\\n        int[] nums = {1000,900,500,400,100,90,50,40,10,9,5,4,1};\\n        String[] chars= {\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\\n        while(num!=0){\\n            for(int i =0; i<nums.length;i++){\\n                if(num>=nums[i]){\\n                    result.append(chars[i]);\\n                    num-=nums[i];\\n                    break;\\n                }\\n            }\\n        }\\n        return result.toString();\\n    }\\n}\\n```\\n\\u8FD9\\u9898\\u6CA1\\u5565\\u610F\\u4E49\\u554A",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java \\nclass Solution {\\n    public String intToRoman(int num) {\\n        StringBuilder  result = new StringBuilder();\\n        int[] nums = {1000,900,500,400,100,90,50,40,10,9,5,4,1};\\n        String[] chars= {\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\\n        while(num!=0){\\n            for(int i =0; i<nums.length;i++){\\n                if(num>=nums[i]){\\n                    result.append(chars[i]);\\n                    num-=nums[i];\\n                    break;\\n                }\\n            }\\n        }\\n        return result.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 222715,
                "title": "java-57-ms-beats-95-5-no-map-used-easy-understand",
                "content": "```\\nclass Solution {\\n    int[] nums = new int[] {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\\n    String[] symbols = new String[] {\\n        \"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"\\n    };\\n    public String intToRoman(int num) {\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < nums.length && num > 0; i++) {\\n            int cnt = num / nums[i];\\n            while (cnt-- > 0) {\\n                sb.append(symbols[i]);\\n            }\\n            num %= nums[i];\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int[] nums = new int[] {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\\n    String[] symbols = new String[] {\\n        \"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"\\n    };\\n    public String intToRoman(int num) {\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < nums.length && num > 0; i++) {\\n            int cnt = num / nums[i];\\n            while (cnt-- > 0) {\\n                sb.append(symbols[i]);\\n            }\\n            num %= nums[i];\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 6343,
                "title": "my-c-solution-beat-95",
                "content": "```\\nstring intToRoman(int num) {\\n        int i=0;\\n        string a = \"IVXLCDM\", res = \"\";\\n        while(num)\\n        {\\n            int temp = num%10;\\n            if(temp<=3) res = string(temp,a[i])+res;\\n            else if(temp==4) res = string(1,a[i])+string(1,a[i+1])+res;\\n            else if(temp==5) res = string(1,a[i+1])+res;\\n            else if(temp<=8) res = string(1,a[i+1])+string(temp-5,a[i])+res;\\n            else if(temp==9) res = string(1,a[i])+string(1,a[i+2])+res;\\n            num = num/10;\\n            i += 2;\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nstring intToRoman(int num) {\\n        int i=0;\\n        string a = \"IVXLCDM\", res = \"\";\\n        while(num)\\n        {\\n            int temp = num%10;\\n            if(temp<=3) res = string(temp,a[i])+res;\\n            else if(temp==4) res = string(1,a[i])+string(1,a[i+1])+res;\\n            else if(temp==5) res = string(1,a[i+1])+res;\\n            else if(temp<=8) res = string(1,a[i+1])+string(temp-5,a[i])+res;\\n            else if(temp==9) res = string(1,a[i])+string(1,a[i+2])+res;\\n            num = num/10;\\n            i += 2;\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 6315,
                "title": "please-laugh-at-me",
                "content": "\\n```\\npublic class Solution {\\n    public String intToRoman(int num) {\\n        StringBuffer res = new StringBuffer();\\n        while(num >= 1000){\\n            res.append(\"M\");\\n            num -= 1000;\\n        }\\n        int temp = num / 100;\\n        switch(temp){\\n            case 9: res.append(\"CM\"); break;\\n            case 8: res.append(\"DCCC\"); break;\\n            case 7: res.append(\"DCC\"); break;\\n            case 6: res.append(\"DC\"); break;\\n            case 5: res.append(\"D\"); break;\\n            case 4: res.append(\"CD\"); break;\\n            case 3: res.append(\"CCC\"); break;\\n            case 2: res.append(\"CC\"); break;\\n            case 1: res.append(\"C\"); break;\\n            case 0: break;\\n        }\\n        num -= temp*100;\\n        temp = num / 10;\\n        switch(temp){\\n            case 9: res.append(\"XC\"); break;\\n            case 8: res.append(\"LXXX\"); break;\\n            case 7: res.append(\"LXX\"); break;\\n            case 6: res.append(\"LX\"); break;\\n            case 5: res.append(\"L\"); break;\\n            case 4: res.append(\"XL\"); break;\\n            case 3: res.append(\"XXX\"); break;\\n            case 2: res.append(\"XX\"); break;\\n            case 1: res.append(\"X\"); break;\\n            case 0: break;\\n        }\\n        num -= temp*10;\\n        switch(num){\\n            case 9: res.append(\"IX\"); break;\\n            case 8: res.append(\"VIII\"); break;\\n            case 7: res.append(\"VII\"); break;\\n            case 6: res.append(\"VI\"); break;\\n            case 5: res.append(\"V\"); break;\\n            case 4: res.append(\"IV\"); break;\\n            case 3: res.append(\"III\"); break;\\n            case 2: res.append(\"II\"); break;\\n            case 1: res.append(\"I\"); break;\\n            case 0: break;\\n        }\\n        \\n        return res.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public String intToRoman(int num) {\\n        StringBuffer res = new StringBuffer();\\n        while(num >= 1000){\\n            res.append(\"M\");\\n            num -= 1000;\\n        }\\n        int temp = num / 100;\\n        switch(temp){\\n            case 9: res.append(\"CM\"); break;\\n            case 8: res.append(\"DCCC\"); break;\\n            case 7: res.append(\"DCC\"); break;\\n            case 6: res.append(\"DC\"); break;\\n            case 5: res.append(\"D\"); break;\\n            case 4: res.append(\"CD\"); break;\\n            case 3: res.append(\"CCC\"); break;\\n            case 2: res.append(\"CC\"); break;\\n            case 1: res.append(\"C\"); break;\\n            case 0: break;\\n        }\\n        num -= temp*100;\\n        temp = num / 10;\\n        switch(temp){\\n            case 9: res.append(\"XC\"); break;\\n            case 8: res.append(\"LXXX\"); break;\\n            case 7: res.append(\"LXX\"); break;\\n            case 6: res.append(\"LX\"); break;\\n            case 5: res.append(\"L\"); break;\\n            case 4: res.append(\"XL\"); break;\\n            case 3: res.append(\"XXX\"); break;\\n            case 2: res.append(\"XX\"); break;\\n            case 1: res.append(\"X\"); break;\\n            case 0: break;\\n        }\\n        num -= temp*10;\\n        switch(num){\\n            case 9: res.append(\"IX\"); break;\\n            case 8: res.append(\"VIII\"); break;\\n            case 7: res.append(\"VII\"); break;\\n            case 6: res.append(\"VI\"); break;\\n            case 5: res.append(\"V\"); break;\\n            case 4: res.append(\"IV\"); break;\\n            case 3: res.append(\"III\"); break;\\n            case 2: res.append(\"II\"); break;\\n            case 1: res.append(\"I\"); break;\\n            case 0: break;\\n        }\\n        \\n        return res.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 6411,
                "title": "share-my-c-solution-easy-to-understand",
                "content": "    class Solution {\\n    public:\\n        string intToRoman(int num) {\\n            string ret = \"\";\\n            if (num <= 0) return ret;\\n            //{ {1, 2, 3, 4, 5, 6, 7, 8, 9},\\n            //  {10, 20, 30, 40, 50, 60, 70, 80, 90},\\n            //  {100, 200, 300, 400, 500, 600, 700, 800, 900},\\n            //  {1000, 2000, 3000} }\\n            string roman[4][10] = {{\"0\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"},\\n                                   {\"0\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"},\\n                                   {\"0\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"},\\n                                   {\"0\", \"M\", \"MM\", \"MMM\"}};\\n            int i = 0, k = 1000;\\n            \\n            for (i = 3; i >= 0; --i)\\n            {\\n                if (num / k != 0)\\n                    ret += roman[i][num/k];\\n                num %= k;\\n                k /= 10;\\n            }\\n            \\n            return ret;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        string intToRoman(int num) {\\n            string ret = \"\";\\n            if (num <= 0) return ret;\\n            //{ {1, 2, 3, 4, 5, 6, 7, 8, 9}",
                "codeTag": "Java"
            },
            {
                "id": 6455,
                "title": "my-short-java-code",
                "content": "    public class Solution {\\n        \\n        String[][] base = new String[][]{{\"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"},\\n                                    {\"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"},\\n                                    {\"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"},\\n                                    {\"M\", \"MM\", \"MMM\", \"\", \"\", \"\", \"\", \"\", \"\"}};\\n        \\n        public String intToRoman(int num) {\\n            String r = \"\";\\n            for (int i = 0; num != 0; num /= 10, i++) {\\n                if (num % 10 == 0)\\n                    continue;\\n                r = base[i][num % 10-1] + r;\\n            }\\n            return r;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        \\n        String[][] base = new String[][]{{\"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"}",
                "codeTag": "Java"
            },
            {
                "id": 6482,
                "title": "a-solution-applies-to-numbers-in-any-range",
                "content": "    public class Solution {\\n        public String intToRoman(int num) {\\n            return (romanDigit((num / 1000) % 10, \"M\", \"XX\", \"XX\")) + \\n                   (romanDigit((num / 100) % 10, \"C\", \"D\", \"M\")) +\\n                   (romanDigit((num / 10) % 10, \"X\", \"L\", \"C\")) +\\n                   (romanDigit(num % 10, \"I\", \"V\", \"X\"));\\n        }\\n        \\n        public String romanDigit(int n, String onechar, String fivechar, String tenchar) {\\n            if (n == 0) return \"\";\\n            if (n == 1) return onechar;\\n            if (n == 2) return onechar + onechar;\\n            if (n == 3) return onechar + onechar + onechar;\\n            if (n == 4) return onechar + fivechar;\\n            if (n == 5) return fivechar;\\n            if (n == 6) return fivechar + onechar;\\n            if (n == 7) return fivechar + onechar + onechar;\\n            if (n == 8) return fivechar + onechar + onechar + onechar;\\n            if (n == 9) return onechar + tenchar;\\n            \\n            return null;\\n        }\\n    }\\n\\n\\nI know the listing way is not so good, but just realized that the patterns are the same and can be summarized as \"onechar\", \"fivechar\" and \"tenchar\", which will simplify the solution a little bit.",
                "solutionTags": [],
                "code": "class Solution {\\n        public String intToRoman(int num) {\\n            return (romanDigit((num / 1000) % 10, \"M\", \"XX\", \"XX\")) + \\n                   (romanDigit((num / 100) % 10, \"C\", \"D\", \"M\")) +\\n                   (romanDigit((num / 10) % 10, \"X\", \"L\", \"C\")) +\\n                   (romanDigit(num % 10, \"I\", \"V\", \"X\"));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 6486,
                "title": "an-accepted-answer-in-python-using-s-replace",
                "content": "runtime:168 ms\\n\\n    class Solution:\\n   \\n        # @return a string\\n        def intToRoman(self, num):\\n            result = num//1000 *'M' + num%1000//100*'C' + \\\\\\n                         num%1000%100//10*'X' + num%1000%100%10*'I'\\n\\n            result = result.replace('IIIIIIIII', 'IX')\\n            result = result.replace('IIIII','V')\\n            result = result.replace('IIII' , 'IV')\\n            result = result.replace('XXXXXXXXX', 'XC')\\n            result = result.replace('XXXXX' , 'L')\\n            result = result.replace('XXXX' , 'XL')\\n            result = result.replace('CCCCCCCCC', 'CM')\\n            result = result.replace('CCCCC', 'D')\\n            result = result.replace('CCCC', 'CD')\\n            return (result)",
                "solutionTags": [],
                "code": "runtime:168 ms\\n\\n    class Solution:\\n   \\n        # @return a string\\n        def intToRoman(self, num):\\n            result = num//1000 *'M' + num%1000//100*'C' + \\\\\\n                         num%1000%100//10*'X' + num%1000%100%10*'I'\\n\\n            result = result.replace('IIIIIIIII', 'IX')\\n            result = result.replace('IIIII','V')\\n            result = result.replace('IIII' , 'IV')\\n            result = result.replace('XXXXXXXXX', 'XC')\\n            result = result.replace('XXXXX' , 'L')\\n            result = result.replace('XXXX' , 'XL')\\n            result = result.replace('CCCCCCCCC', 'CM')\\n            result = result.replace('CCCCC', 'D')\\n            result = result.replace('CCCC', 'CD')\\n            return (result)",
                "codeTag": "Java"
            },
            {
                "id": 6495,
                "title": "my-accepted-solution-in-java-using-array",
                "content": "The key of my solution is count the num of every digits,and using array to append it.\\n\\n    public class Solution {\\n        public String intToRoman(int num) {\\n            StringBuffer res=new StringBuffer();\\n            String[] aryC={\"\",\"C\",\"CC\",\"CCC\",\"CD\",\"D\",\"DC\",\"DCC\",\"DCCC\",\"CM\"};\\n            String[] aryX={\"\",\"X\",\"XX\",\"XXX\",\"XL\",\"L\",\"LX\",\"LXX\",\"LXXX\",\"XC\"};\\n            String[] aryI={\"\",\"I\",\"II\",\"III\",\"IV\",\"V\",\"VI\",\"VII\",\"VIII\",\"IX\"};\\n            int Mnums=num/1000;        //1000\\n            int Cnums=(num%1000)/100;  //100\\n            int Xnums=(num%100)/10;    //10\\n            int Inums=num%10;          //1\\n            for(int i=Mnums;i>0;i--)\\n            {\\n                res.append(\"M\");\\n            }\\n            res.append(aryC[Cnums]);\\n            res.append(aryX[Xnums]);\\n            res.append(aryI[Inums]);\\n            return res.toString();\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public String intToRoman(int num) {\\n            StringBuffer res=new StringBuffer();\\n            String[] aryC={\"\",\"C\",\"CC\",\"CCC\",\"CD\",\"D\",\"DC\",\"DCC\",\"DCCC\",\"CM\"}",
                "codeTag": "Java"
            },
            {
                "id": 3985674,
                "title": "beats-98-very-easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thougStringhts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Create two arrays, one to store the Roman numerals and the other to store their corresponding values.\\n2. Initialize a StringBuilder to store the Roman numeral representation of the integer.\\n3. Iterate over the arrays in parallel.\\n4. While the integer is greater than or equal to the value at the current index of the values array, append the Roman numeral at the corresponding index of the notations array to the StringBuilder.\\n5. Decrement the integer by the value at the current index of the values array.\\n6. Repeat steps 4 and 5 until the integer is less than the value at the first index of the values array.\\n7. Return the String representation of the StringBuilder\\n\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public String intToRoman(int num) {\\n        int []values={1000,900,500,400,100,90,50,40,10,9,5,4,1};\\n        String []notations={\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\\n        StringBuilder sb=new StringBuilder();\\n\\n        for(int i=0;i<values.length;i++){\\n            while(num>=values[i])\\n            {\\n                num-=values[i];\\n                sb.append(notations[i]);\\n            }\\n        }\\n\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String intToRoman(int num) {\\n        int []values={1000,900,500,400,100,90,50,40,10,9,5,4,1};\\n        String []notations={\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\\n        StringBuilder sb=new StringBuilder();\\n\\n        for(int i=0;i<values.length;i++){\\n            while(num>=values[i])\\n            {\\n                num-=values[i];\\n                sb.append(notations[i]);\\n            }\\n        }\\n\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3113157,
                "title": "most-optimised-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) \\n    {\\n        int normal[]={1000,900,500,400,100,90,50,40,10,9,5,4,1};\\n        string roman[]={\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\\n        string rom;\\n        for(int i=0;i<13;i++){\\n            while(num>=normal[i]){\\n                rom.append(roman[i]);\\n                num-=normal[i];\\n            }\\n        }\\n        return rom;\\n        }};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) \\n    {\\n        int normal[]={1000,900,500,400,100,90,50,40,10,9,5,4,1};\\n        string roman[]={\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\\n        string rom;\\n        for(int i=0;i<13;i++){\\n            while(num>=normal[i]){\\n                rom.append(roman[i]);\\n                num-=normal[i];\\n            }\\n        }\\n        return rom;\\n        }};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2991683,
                "title": "c",
                "content": "# Code\\n```\\npublic class Solution {\\n    public string IntToRoman(int num) {\\n        if (num >= 1000) return \"M\" + IntToRoman(num - 1000);\\n\\n        if (num >= 500) return num >= 900 ? (\"CM\" + IntToRoman(num - 900)) : (\"D\" + IntToRoman(num - 500));\\n\\n        if (num >= 100) return num >= 400 ? (\"CD\" + IntToRoman(num - 400)) : (\"C\" + IntToRoman(num - 100));\\n\\n        if (num >= 50) return num >= 90 ? (\"XC\" + IntToRoman(num - 90)) : (\"L\" + IntToRoman(num - 50));\\n\\n        if (num >= 10) return num >= 40 ? (\"XL\" + IntToRoman(num - 40)): (\"X\" + IntToRoman(num - 10));\\n\\n        if (num >= 5) return num == 9 ? \"IX\" : \"V\" + IntToRoman(num - 5);\\n\\n        if (num > 0) return num == 4 ? \"IV\" : \"I\" + IntToRoman(num - 1);\\n\\n        return \"\";   \\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public string IntToRoman(int num) {\\n        if (num >= 1000) return \"M\" + IntToRoman(num - 1000);\\n\\n        if (num >= 500) return num >= 900 ? (\"CM\" + IntToRoman(num - 900)) : (\"D\" + IntToRoman(num - 500));\\n\\n        if (num >= 100) return num >= 400 ? (\"CD\" + IntToRoman(num - 400)) : (\"C\" + IntToRoman(num - 100));\\n\\n        if (num >= 50) return num >= 90 ? (\"XC\" + IntToRoman(num - 90)) : (\"L\" + IntToRoman(num - 50));\\n\\n        if (num >= 10) return num >= 40 ? (\"XL\" + IntToRoman(num - 40)): (\"X\" + IntToRoman(num - 10));\\n\\n        if (num >= 5) return num == 9 ? \"IX\" : \"V\" + IntToRoman(num - 5);\\n\\n        if (num > 0) return num == 4 ? \"IV\" : \"I\" + IntToRoman(num - 1);\\n\\n        return \"\";   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2724944,
                "title": "c-use-hashmap-easy-approach",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    string intToRoman(int num) \\n    {\\n        vector<pair<int, string>> roman = {{1000, \"M\"}, {900, \"CM\"}, {500, \"D\"}, {400, \"CD\"}, {100, \"C\"},\\n                                         {90, \"XC\"}, {50, \"L\"}, {40, \"XL\"}, {10, \"X\"}, {9, \"IX\"},\\n                                         {5, \"V\"}, {4, \"IV\"}, {1, \"I\"}};\\n        \\n        string res=\"\";\\n        \\n        for(auto it:roman)\\n        {\\n            while(num >= it.first)\\n            {\\n                res += it.second;\\n                num -= it.first;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    string intToRoman(int num) \\n    {\\n        vector<pair<int, string>> roman = {{1000, \"M\"}, {900, \"CM\"}, {500, \"D\"}, {400, \"CD\"}, {100, \"C\"},\\n                                         {90, \"XC\"}, {50, \"L\"}, {40, \"XL\"}, {10, \"X\"}, {9, \"IX\"},\\n                                         {5, \"V\"}, {4, \"IV\"}, {1, \"I\"}};\\n        \\n        string res=\"\";\\n        \\n        for(auto it:roman)\\n        {\\n            while(num >= it.first)\\n            {\\n                res += it.second;\\n                num -= it.first;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2724475,
                "title": "java-and-c-simple-and-concise-solution-with-detailed-explanation",
                "content": "# Explanation:\\nInitialize two arrays with all possible roman string and number combinations in descending order. Following are the legitamate possible roman symbols and number combinations.  (*I\\'ve used a vector of pairs in C++ implementation*)\\n```\\n String [] romans = {\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"};\\n Integer [] nums = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\\n```\\n\\nThe goal here is to check how many times each number is divisible by the roman symbols and convert the number to roman symbol greedily.  \\n\\n` Example :3888`\\n            \\nWe start with 1000 and check if the given number is greater than 1000. In this case, it is greater than 1000. We need to know exactly how many times the number is divisible by 1000 because we need to replace 1000 with M that many number of times.   So we know 3000 can be represented with 3 Ms (`MMM`) as floor(3888 / 1000) is 3. Now since we have converted 3000 to roman number, we need to convert the reminder ie 888.\\n\\nWe know for sure the reminder from the previous operation is less than the previous divisor, so we don\\'t have to loop through the numbers array from the start every time. We can start traversing nums array with the index after the previous divisor, as it is sorted in descending order.  888 < 900, so we continue traversing the nums array. the next element in the array is 500. 888 > 500, so we break out of the first for loop below. Now 888 / 500 = 1. so we append the roman notation for 1 500 i.e D to our result.  Now the result so far is `MMMD` and reminder is 388. After solving for the reminder in the similar manner, we get the answer `MMMMDCCCLXXXVIII`.\\n\\n**Complexity**\\n\\n```\\n Time Complexity: O(1)\\n Space Complexity: O(1)\\n```\\n            \\nThis is because we use two arrays of fixed size 13 to store the roman and binary numbers. And no matter what the number is we know the below operations are in the worst case constant space as array size is constant and we are just iterating a constant sized array and we can guarantee in the worst case iterates through every element at the most once. The divisorcan at the most be O(8) which is constant. And all the operations in the below loop are constant operations.  \\n\\n```\\n \\n        while(num > 0) {\\n            for(;num < nums[i]; i++);\\n            int count = (num / nums[i]);\\n            for(int j = 0; j < count; j++)\\n                result.append(romans[i]);\\n            num = num - count * nums[i];\\n        }\\n```\\n\\n# Java Solution\\n```\\nclass Solution {\\n    public String intToRoman(int num) {\\n        String [] romans = {\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"};\\n        Integer [] nums = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\\n        int i = 0;\\n        StringBuilder result = new StringBuilder();\\n        \\n        while(num > 0) {\\n            for(;num < nums[i]; i++);\\n            int count = (num / nums[i]);\\n            for(int j = 0; j < count; j++)\\n                result.append(romans[i]);\\n            num = num - count * nums[i];\\n        }\\n        \\n        return result.toString();\\n    }\\n}\\n```\\n\\n# C++ Solution\\n```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        vector<pair<int,string>> romanPairs = {\\n            {1000, \"M\"}, {900, \"CM\"}, {500, \"D\"}, {400, \"CD\"}, {100, \"C\"}, {90, \"XC\"}, \\n            {50, \"L\"}, {40, \"XL\"}, {10, \"X\"}, {9, \"IX\"}, {5, \"V\"}, {4, \"IV\"}, {1, \"I\"}\\n        };\\n        \\n        int i = 0;\\n        string result = \"\";\\n        \\n        while(num > 0) {\\n            for(;num < romanPairs[i].first; i++);\\n            string roman = romanPairs[i].second;\\n            int number = romanPairs[i].first; \\n            int count = (num / number);\\n            \\n            for(int j = 0; j < count; j++)\\n                result += roman;\\n            num = num - count * number;\\n        }\\n        \\n        return result;\\n    }\\n};\\n```\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\n String [] romans = {\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"};\\n Integer [] nums = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\\n```\n```\\n Time Complexity: O(1)\\n Space Complexity: O(1)\\n```\n```\\n \\n        while(num > 0) {\\n            for(;num < nums[i]; i++);\\n            int count = (num / nums[i]);\\n            for(int j = 0; j < count; j++)\\n                result.append(romans[i]);\\n            num = num - count * nums[i];\\n        }\\n```\n```\\nclass Solution {\\n    public String intToRoman(int num) {\\n        String [] romans = {\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"};\\n        Integer [] nums = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\\n        int i = 0;\\n        StringBuilder result = new StringBuilder();\\n        \\n        while(num > 0) {\\n            for(;num < nums[i]; i++);\\n            int count = (num / nums[i]);\\n            for(int j = 0; j < count; j++)\\n                result.append(romans[i]);\\n            num = num - count * nums[i];\\n        }\\n        \\n        return result.toString();\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        vector<pair<int,string>> romanPairs = {\\n            {1000, \"M\"}, {900, \"CM\"}, {500, \"D\"}, {400, \"CD\"}, {100, \"C\"}, {90, \"XC\"}, \\n            {50, \"L\"}, {40, \"XL\"}, {10, \"X\"}, {9, \"IX\"}, {5, \"V\"}, {4, \"IV\"}, {1, \"I\"}\\n        };\\n        \\n        int i = 0;\\n        string result = \"\";\\n        \\n        while(num > 0) {\\n            for(;num < romanPairs[i].first; i++);\\n            string roman = romanPairs[i].second;\\n            int number = romanPairs[i].first; \\n            int count = (num / number);\\n            \\n            for(int j = 0; j < count; j++)\\n                result += roman;\\n            num = num - count * number;\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2724333,
                "title": "easy-python-solution",
                "content": "```\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        symbolMap = {\\n            1 : \"I\", \\n            5 : \\'V\\', \\n            10 : \"X\", \\n            50 : \"L\", \\n            100 : \"C\", \\n            500 : \"D\", \\n            1000 : \"M\"\\n        }\\n        \\n        res = [] \\n        while num >= 1000: \\n            res.append(symbolMap[1000])\\n            num -= 1000 \\n        \\n        while num >= 900: \\n            res.append(symbolMap[100])\\n            res.append(symbolMap[1000])\\n            num -= 900        \\n            \\n        while num >= 500: \\n            res.append(symbolMap[500])\\n            num -= 500\\n        \\n        while num >= 400: \\n            res.append(symbolMap[100])\\n            res.append(symbolMap[500])\\n            num -= 400  \\n        \\n        while num >= 100: \\n            res.append(symbolMap[100])\\n            num -= 100 \\n        \\n        while num >= 90: \\n            res.append(symbolMap[10])\\n            res.append(symbolMap[100])\\n            num -= 90  \\n            \\n        while num >= 50: \\n            res.append(symbolMap[50])\\n            num -= 50 \\n            \\n        while num >= 40: \\n            res.append(symbolMap[10])\\n            res.append(symbolMap[50])\\n            num -= 40 \\n        \\n        while num >= 10: \\n            res.append(symbolMap[10])\\n            num -= 10\\n            \\n        while num >= 9: \\n            res.append(symbolMap[1])\\n            res.append(symbolMap[10])\\n            num -= 400  \\n        \\n        while num >= 5:\\n            res.append(symbolMap[5])\\n            num -= 5 \\n            \\n        while num >= 4: \\n            res.append(symbolMap[1])\\n            res.append(symbolMap[5])\\n            num -= 400  \\n        \\n        while num >= 1: \\n            res.append(symbolMap[1])\\n            num -= 1 \\n            \\n        return \"\".join(res)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        symbolMap = {\\n            1 : \"I\", \\n            5 : \\'V\\', \\n            10 : \"X\", \\n            50 : \"L\", \\n            100 : \"C\", \\n            500 : \"D\", \\n            1000 : \"M\"\\n        }\\n        \\n        res = [] \\n        while num >= 1000: \\n            res.append(symbolMap[1000])\\n            num -= 1000 \\n        \\n        while num >= 900: \\n            res.append(symbolMap[100])\\n            res.append(symbolMap[1000])\\n            num -= 900        \\n            \\n        while num >= 500: \\n            res.append(symbolMap[500])\\n            num -= 500\\n        \\n        while num >= 400: \\n            res.append(symbolMap[100])\\n            res.append(symbolMap[500])\\n            num -= 400  \\n        \\n        while num >= 100: \\n            res.append(symbolMap[100])\\n            num -= 100 \\n        \\n        while num >= 90: \\n            res.append(symbolMap[10])\\n            res.append(symbolMap[100])\\n            num -= 90  \\n            \\n        while num >= 50: \\n            res.append(symbolMap[50])\\n            num -= 50 \\n            \\n        while num >= 40: \\n            res.append(symbolMap[10])\\n            res.append(symbolMap[50])\\n            num -= 40 \\n        \\n        while num >= 10: \\n            res.append(symbolMap[10])\\n            num -= 10\\n            \\n        while num >= 9: \\n            res.append(symbolMap[1])\\n            res.append(symbolMap[10])\\n            num -= 400  \\n        \\n        while num >= 5:\\n            res.append(symbolMap[5])\\n            num -= 5 \\n            \\n        while num >= 4: \\n            res.append(symbolMap[1])\\n            res.append(symbolMap[5])\\n            num -= 400  \\n        \\n        while num >= 1: \\n            res.append(symbolMap[1])\\n            num -= 1 \\n            \\n        return \"\".join(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2723932,
                "title": "c-no-hard-code-simple-way",
                "content": "```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        vector<pair<int, string>> map{{1, \"I\"}, {4, \"IV\"}, {5, \"V\"}, {9, \"IX\"}, {10, \"X\"}, {40, \"XL\"}, {50, \"L\"}, \\n\\t\\t{90, \"XC\"}, {100, \"C\"}, {400, \"CD\"}, {500, \"D\"}, {900, \"CM\"}, {1000, \"M\"}};\\n        int l = map.size()-1;\\n        string s=\"\";\\n        \\n        while(num!=0){\\n            while(map[l].first>num){\\n                l--;\\n            }\\n            s += map[l].second;\\n            num -= map[l].first;\\n        }\\n        return s;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        vector<pair<int, string>> map{{1, \"I\"}, {4, \"IV\"}, {5, \"V\"}, {9, \"IX\"}, {10, \"X\"}, {40, \"XL\"}, {50, \"L\"}, \\n\\t\\t{90, \"XC\"}, {100, \"C\"}, {400, \"CD\"}, {500, \"D\"}, {900, \"CM\"}, {1000, \"M\"}};\\n        int l = map.size()-1;\\n        string s=\"\";\\n        \\n        while(num!=0){\\n            while(map[l].first>num){\\n                l--;\\n            }\\n            s += map[l].second;\\n            num -= map[l].first;\\n        }\\n        return s;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2723735,
                "title": "daily-leetcoding-challenge-october-day-20",
                "content": "This problem is the Daily LeetCoding Challenge for October, Day 20.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/integer-to-roman/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Greedy\n\n  \n**Approach 2:** Hardcode Digits\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/integer-to-roman/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 2501930,
                "title": "moms-spaghetti",
                "content": "```\\n\\n   let m = Math.floor(num/1000)\\n  num%=1000\\n  let cm = Math.floor(num / 900)\\n  num%=900\\n  let d = Math.floor(num/500)\\n  num%=500\\nlet cd = Math.floor(num/400)\\nnum%=400\\nlet c = Math.floor(num/100)\\nnum%=100\\nlet xc = Math.floor(num/90)\\nnum%=90\\nlet l = Math.floor(num/50)\\n  num%=50\\nlet xl = Math.floor(num/40)\\nnum%=40\\nlet x = Math.floor(num/10)\\nnum%=10\\nlet ix = Math.floor(num/9)\\nnum%=9\\nlet v = Math.floor(num/5)\\nnum%=5\\nlet iv = Math.floor(num/4)\\nnum%=4\\nlet i = Math.floor(num/1)\\n\\n\\nreturn \"M\".repeat(m)+\"CM\".repeat(cm)+\"D\".repeat(d)+\"CD\".repeat(cd)+\"C\".repeat(c)+\"XC\".repeat(xc)+\"L\".repeat(l)+\"XL\".repeat(xl)+\"X\".repeat(x)+\"IX\".repeat(ix)+\"V\".repeat(v)+\"IV\".repeat(iv)+\"I\".repeat(i)\\n```\\n",
                "solutionTags": [
                    "JavaScript",
                    "Math"
                ],
                "code": "```\\n\\n   let m = Math.floor(num/1000)\\n  num%=1000\\n  let cm = Math.floor(num / 900)\\n  num%=900\\n  let d = Math.floor(num/500)\\n  num%=500\\nlet cd = Math.floor(num/400)\\nnum%=400\\nlet c = Math.floor(num/100)\\nnum%=100\\nlet xc = Math.floor(num/90)\\nnum%=90\\nlet l = Math.floor(num/50)\\n  num%=50\\nlet xl = Math.floor(num/40)\\nnum%=40\\nlet x = Math.floor(num/10)\\nnum%=10\\nlet ix = Math.floor(num/9)\\nnum%=9\\nlet v = Math.floor(num/5)\\nnum%=5\\nlet iv = Math.floor(num/4)\\nnum%=4\\nlet i = Math.floor(num/1)\\n\\n\\nreturn \"M\".repeat(m)+\"CM\".repeat(cm)+\"D\".repeat(d)+\"CD\".repeat(cd)+\"C\".repeat(c)+\"XC\".repeat(xc)+\"L\".repeat(l)+\"XL\".repeat(xl)+\"X\".repeat(x)+\"IX\".repeat(ix)+\"V\".repeat(v)+\"IV\".repeat(iv)+\"I\".repeat(i)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2497457,
                "title": "thous-hunds-tens-ones-by-mdeakyne",
                "content": "**Please upvote if it was helpful!**\\n\\nThe old elegant solution without a loop.\\n```\\nclass Solution {\\n  String intToRoman(int num) {\\n    final ones = [\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"];\\n    final tens = [\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"];\\n    final hunds = [\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"];\\n    final thous = [\"\", \"M\", \"MM\", \"MMM\", \"MMMM\"];\\n\\n    final t = thous[num  ~/ 1000];\\n    final h = hunds[num ~/ 100 % 10];\\n    final te = tens[num ~/ 10 % 10];\\n    final o = ones[num % 10];\\n\\n    return t + h + te + o;\\n  }\\n}\\n```\\n[Submission Detail](https://leetcode.com/submissions/detail/785763057/)",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  String intToRoman(int num) {\\n    final ones = [\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"];\\n    final tens = [\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"];\\n    final hunds = [\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"];\\n    final thous = [\"\", \"M\", \"MM\", \"MMM\", \"MMMM\"];\\n\\n    final t = thous[num  ~/ 1000];\\n    final h = hunds[num ~/ 100 % 10];\\n    final te = tens[num ~/ 10 % 10];\\n    final o = ones[num % 10];\\n\\n    return t + h + te + o;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2294406,
                "title": "c-complete-dry-run-digit-by-digit-solution-right-to-left-single-hashmap",
                "content": "After Reading this post definetely you will be crystal clear with the Approach and as well as with Code.\\n***\\nBefore copying the code please once understand completely then you can copy !!\\n```\\nclass Solution {\\npublic:\\n    \\n    //  Dry run some exmaples \\n    /*\\n        3999 = 3000 + 900 + 90 + 9 = MMM + CM + XC + IX\\n        // Go backward only one positions\\n        2835 = 2000 + 800 + 30 + 5 = MM + DCC + XXX + V  (WRONG WAY : MM + CCM + XXX + V)\\n        4000 = MMMM\\n\\n    */\\n    \\n    // DRY RUN of num = 249 for the below code\\n    // 249 = 200 + 40 + 9 = \\n    /* \\n        Ist Pass :\\n        --------\\n        last digit = 9 , place value = x = 1\\n        1. multiply by place value = 9*1 = 9 \\n        2  9 is not found in map\\n        3. Its nearest by place value x=1, 9+1 = 10, 10 is present in map\\n        4. write mp[1]+mp[10] = \"IX\" for \\'9\\'\\n        5. ans = \"IX\"\\n        \\n        IInd Pass :\\n        ---------\\n        last digit = 4 , place value = x = 10\\n        1. multiply by place value = 4*10 = 40\\n        2  40 is not found in map\\n        3. Its nearest by place value x=10, 40+10 = 50, 50 is present in map\\n        4. write mp[10]+mp[50] = \"XL\" for \\'40\\'\\n        5. ans = \"XLIX\"\\n        \\n        IIIrd Pass :\\n        ---------\\n        last digit = 2 , place value = x = 100\\n        1. multiply by place value = 2*100 = 200\\n        2  200 is not found in map\\n        3. Its nearest by place value x=100, 200+100 = 300, 300 is not present in map\\n        4. So perform subtraction by place value x=100, 200-100 = 100, 100 is present in map\\n        5. write mp[100]+mp[100] = \"CC\" for \\'200\\'\\n        6. ans = \"CCXLIX\"\\n        \\n        DONE !\\n    */\\n    string intToRoman(int num) \\n    {\\n        unordered_map<int,string>mp = {{1,\"I\"},{5,\"V\"},{10,\"X\"},{50,\"L\"},{100,\"C\"},{500,\"D\"},{1000,\"M\"}};\\n        \\n        int x=1;\\n        string ans=\"\";\\n        while(num>0)\\n        {\\n            int d=num%10;                           // Last digit of a number\\n            d*=x;                                   // Multiply by its place value (like 1, 10, 100, 1000)\\n            while(d>0)\\n            {\\n                if(mp.find(d)!=mp.end()){           // find the digit in the map - direct \\n                    ans = mp[d] + ans;\\n                    d = 0;\\n                } \\n                else if(mp.find(d+x)!=mp.end())      // or find the approx nearest in the map. // like 40 nearest to 50\\n                {\\n                    ans = mp[x] + mp[d+x] + ans;\\n                    d = 0;\\n                }\\n                else                            // iterate the place value mapped value until it matches the map value\\n                {\\n                    ans = mp[x] + ans;\\n                    d -= x;\\n                } \\n            }\\n            num/=10; // remove the last digit from the number\\n            x*=10; // increment the place value.\\n        }\\n        return ans;\\n    }\\n};\\n```\\n***Thanks for Upvoting !***\\n\\uD83D\\uDE42",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    //  Dry run some exmaples \\n    /*\\n        3999 = 3000 + 900 + 90 + 9 = MMM + CM + XC + IX\\n        // Go backward only one positions\\n        2835 = 2000 + 800 + 30 + 5 = MM + DCC + XXX + V  (WRONG WAY : MM + CCM + XXX + V)\\n        4000 = MMMM\\n\\n    */\\n    \\n    // DRY RUN of num = 249 for the below code\\n    // 249 = 200 + 40 + 9 = \\n    /* \\n        Ist Pass :\\n        --------\\n        last digit = 9 , place value = x = 1\\n        1. multiply by place value = 9*1 = 9 \\n        2  9 is not found in map\\n        3. Its nearest by place value x=1, 9+1 = 10, 10 is present in map\\n        4. write mp[1]+mp[10] = \"IX\" for \\'9\\'\\n        5. ans = \"IX\"\\n        \\n        IInd Pass :\\n        ---------\\n        last digit = 4 , place value = x = 10\\n        1. multiply by place value = 4*10 = 40\\n        2  40 is not found in map\\n        3. Its nearest by place value x=10, 40+10 = 50, 50 is present in map\\n        4. write mp[10]+mp[50] = \"XL\" for \\'40\\'\\n        5. ans = \"XLIX\"\\n        \\n        IIIrd Pass :\\n        ---------\\n        last digit = 2 , place value = x = 100\\n        1. multiply by place value = 2*100 = 200\\n        2  200 is not found in map\\n        3. Its nearest by place value x=100, 200+100 = 300, 300 is not present in map\\n        4. So perform subtraction by place value x=100, 200-100 = 100, 100 is present in map\\n        5. write mp[100]+mp[100] = \"CC\" for \\'200\\'\\n        6. ans = \"CCXLIX\"\\n        \\n        DONE !\\n    */\\n    string intToRoman(int num) \\n    {\\n        unordered_map<int,string>mp = {{1,\"I\"},{5,\"V\"},{10,\"X\"},{50,\"L\"},{100,\"C\"},{500,\"D\"},{1000,\"M\"}};\\n        \\n        int x=1;\\n        string ans=\"\";\\n        while(num>0)\\n        {\\n            int d=num%10;                           // Last digit of a number\\n            d*=x;                                   // Multiply by its place value (like 1, 10, 100, 1000)\\n            while(d>0)\\n            {\\n                if(mp.find(d)!=mp.end()){           // find the digit in the map - direct \\n                    ans = mp[d] + ans;\\n                    d = 0;\\n                } \\n                else if(mp.find(d+x)!=mp.end())      // or find the approx nearest in the map. // like 40 nearest to 50\\n                {\\n                    ans = mp[x] + mp[d+x] + ans;\\n                    d = 0;\\n                }\\n                else                            // iterate the place value mapped value until it matches the map value\\n                {\\n                    ans = mp[x] + ans;\\n                    d -= x;\\n                } \\n            }\\n            num/=10; // remove the last digit from the number\\n            x*=10; // increment the place value.\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2247286,
                "title": "c-integer-to-roman-fast-solution",
                "content": "class Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string roman[] = {\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\", \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"};\\n        int val[] = {1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000};\\n        int i = 12;\\n        string str = \"\";\\n        while(num > 0) {\\n            int div = num / val[i];\\n            num %= val[i];\\n            while(div--) {\\n                str += roman[i];\\n            }\\n            i--;\\n        }\\n        return str;\\n    }\\n};\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string roman[] = {\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\", \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"}",
                "codeTag": "Java"
            },
            {
                "id": 2237969,
                "title": "simple-java-recursive-solution-17ms",
                "content": "```\\n\\t\\tpublic String intToRoman(int num) {\\n\\t\\t\\tif(num == 0) return \"\";\\n\\t\\t\\tif(num >= 1000) return \"M\" + intToRoman( num - 1000);\\n\\t\\t\\tif(num >= 900) return \"CM\" + intToRoman(num - 900);\\n\\t\\t\\tif(num >= 500) return \"D\" + intToRoman( num - 500);\\n\\t\\t\\tif(num >= 400) return \"CD\" + intToRoman(num - 400);\\n\\t\\t\\tif(num >= 100) return \"C\" + intToRoman( num - 100);\\n\\t\\t\\tif(num >= 90) return \"XC\" + intToRoman( num - 90);\\n\\t\\t\\tif(num >= 50) return \"L\" + intToRoman( num - 50);\\n\\t\\t\\tif(num >= 40) return \"XL\" + intToRoman( num - 40);\\n\\t\\t\\tif(num >= 10) return \"X\" + intToRoman( num - 10);\\n\\t\\t\\tif(num >= 9) return \"IX\" + intToRoman( num - 9);\\n\\t\\t\\tif(num >= 5) return \"V\" + intToRoman( num - 5);\\n\\t\\t\\tif(num >= 4) return \"IV\" + intToRoman( num - 4);\\n\\t\\t\\tif(num >= 1) return \"I\" + intToRoman( num - 1);\\n\\t\\t\\treturn intToRoman(num);\\n    }\\n```",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\n\\t\\tpublic String intToRoman(int num) {\\n\\t\\t\\tif(num == 0) return \"\";\\n\\t\\t\\tif(num >= 1000) return \"M\" + intToRoman( num - 1000);\\n\\t\\t\\tif(num >= 900) return \"CM\" + intToRoman(num - 900);\\n\\t\\t\\tif(num >= 500) return \"D\" + intToRoman( num - 500);\\n\\t\\t\\tif(num >= 400) return \"CD\" + intToRoman(num - 400);\\n\\t\\t\\tif(num >= 100) return \"C\" + intToRoman( num - 100);\\n\\t\\t\\tif(num >= 90) return \"XC\" + intToRoman( num - 90);\\n\\t\\t\\tif(num >= 50) return \"L\" + intToRoman( num - 50);\\n\\t\\t\\tif(num >= 40) return \"XL\" + intToRoman( num - 40);\\n\\t\\t\\tif(num >= 10) return \"X\" + intToRoman( num - 10);\\n\\t\\t\\tif(num >= 9) return \"IX\" + intToRoman( num - 9);\\n\\t\\t\\tif(num >= 5) return \"V\" + intToRoman( num - 5);\\n\\t\\t\\tif(num >= 4) return \"IV\" + intToRoman( num - 4);\\n\\t\\t\\tif(num >= 1) return \"I\" + intToRoman( num - 1);\\n\\t\\t\\treturn intToRoman(num);\\n    }\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1898146,
                "content": [
                    {
                        "username": "sulicn",
                        "content": "Can I report those idiots that are still posting solutions here?"
                    },
                    {
                        "username": "Wolfoo",
                        "content": "I think it\\'s easy not medium"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "alalalaa",
                        "content": "double it and give it to the next person\\n"
                    },
                    {
                        "username": "Luojihencha",
                        "content": "I paied a lot of money for leetcode......and still there is no answer. Leetcode please, all questions are hard for me."
                    },
                    {
                        "username": "jy0819",
                        "content": "bro it\\'s been 3 years hope your luoji becomes better now lol"
                    },
                    {
                        "username": "alalalaa",
                        "content": "ask someone who knows how to code to make you connect the dots"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "IHxRK28",
                        "content": "I dont know whether this is a troll statement or not but heres your motivation and tips/advice \\n\\nYou could just follow famous playlists on youtube - \\nSo theres this Indian Guy called striver (Channel Name - TakeuForward) more than half of his videos are in english, You should follow that and I can definitely say You will get better at it. From what I know and understand, You get better at coding with practice which might take different time for different people, so if you are interested in coding keep at it.  "
                    },
                    {
                        "username": "umnik",
                        "content": "I know the easy way of solving this problem is using **23 case** statements (10 for numbers [1-10], 10 for [10-100], 10 for [1000-3000]). But the code does not look good and it's getting bit long. I'm thinking even applying the rules for converting may also make the code complex. Any suggestions?"
                    },
                    {
                        "username": "androidcarson",
                        "content": "[@AdityaBhate](/AdityaBhate) downvoted for using emojis"
                    },
                    {
                        "username": "tolem",
                        "content": "yeah it can  even be solved in 10 to 11 case checks "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you might wanna take a look into this [solution](https://leetcode.com/problems/integer-to-roman/solutions/2726838/c-solution/?orderBy=most_votes)"
                    },
                    {
                        "username": "selvablaze",
                        "content": "[@lucayan0506](/lucayan0506) class Solution {\\n    public String getValue(int val, int pos, HashMap<Integer, String> map){\\n        int value = val * (int) Math.pow(10, pos-1);\\n        String answer = \"\";\\n        if(map.containsKey(value))\\n            return map.get(value);\\n        int upperBound = (int) Math.pow(10,pos);\\n        int midBound = (int) Math.pow(10,pos)/2;\\n        int lowerBound = (int) Math.pow(10, pos-1);\\n        if(val == 4)\\n            answer = map.get(lowerBound) + map.get(midBound);\\n        else if(val == 9 )\\n            answer = map.get(lowerBound) + map.get(upperBound);   \\n        else if(val < 4)\\n            answer = map.get(lowerBound).repeat(val);\\n        else if(val > 5)\\n            answer =  map.get(midBound) + map.get(lowerBound).repeat(val-5);   \\n        map.put(value, answer);\\n        return answer;              \\n    }\\n    public String intToRoman(int num) {\\n        String answer = \"\";\\n        int i = 1;\\n        HashMap<Integer,String> map = new HashMap<>();\\n        map.put(1, \"I\" );\\n        map.put(5, \"V\" );\\n        map.put(10, \"X\" );\\n        map.put(50, \"L\" );\\n        map.put(100, \"C\" );\\n        map.put(500, \"D\" );\\n        map.put(1000, \"M\");\\n        while(num>0){\\n            answer = getValue(num%10, i, map) + answer;\\n            num = num/10;\\n            i++;\\n        }\\n        return answer;\\n    }\\n}"
                    },
                    {
                        "username": "lucayan0506",
                        "content": "I would suggest use map (where you save the value in decimal and the value in roman) `m[1000] = \"M\"    m[900] = \"CM\"`.\nOr you can you use 2 array (one for decimal number, one for roman number) `decimal_number[0] = 1000 roman_number[0] = \"M\"`\nThen use a for loop, instead of 23 case statement"
                    },
                    {
                        "username": "Amax",
                        "content": "For example: how do you spell 1999 in roman?\\nMIM or MCMXCIX?"
                    },
                    {
                        "username": "RittikChaudhary",
                        "content": "[@VinayPatidar](/VinayPatidar) bhai 1001 ho skta hai \"MI\""
                    },
                    {
                        "username": "Kei_Chen",
                        "content": "[@VinayPatidar](/VinayPatidar) Actually I after M is allowed, for example: to write 1001, we can use MI"
                    },
                    {
                        "username": "arthur326",
                        "content": "Yeah, just from the information given in the question, 10 could be written as IX or VIV, right? (This does not violate the subtraction cases they give.) Are we allowed to return either representation? The question should be clearer..."
                    },
                    {
                        "username": "lolo101",
                        "content": "MCMXCIX\\nYou cannot write \"IM\" because you may only remove the previous power of ten to a power of ten.\\nFor instance \"IX\", \"XC\", \"CM\" are allowed. But \"IC\", \"IM\", \"XM\" are not."
                    },
                    {
                        "username": "VinayPatidar",
                        "content": "second one\\nyou cannot have I before or after M"
                    },
                    {
                        "username": "ozkansafak",
                        "content": "[@Kram_](/Kram_) Why? What\\'s the rule we\\'re trying to capture in the code?"
                    },
                    {
                        "username": "abdallahg2120",
                        "content": "According to roman rule which I see in problem description.\\nI think the right answer is MCMXCIX.\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "10 years later, we still have the same doubt!"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Oh man it\\'s been 10 years for this comment."
                    },
                    {
                        "username": "snoyes",
                        "content": "In modern standard use, the only subtractive forms are IV, IX, XL, XC, CD, and CM, so MIM wouldn\\'t be allowed. In medieval and earlier times, usage was all over the place, so there\\'s no telling "
                    },
                    {
                        "username": "Kram_",
                        "content": "The second one"
                    },
                    {
                        "username": "YuriiHryniv",
                        "content": "I bought leetcode subscription but this problem seems very hard to me :((. Unsubscribe, I thought I would get into FAANG"
                    },
                    {
                        "username": "AseCantCode",
                        "content": "[@Artsapollo](/Artsapollo) dude he is just joking"
                    },
                    {
                        "username": "Artsapollo",
                        "content": "Dude, try before pay"
                    },
                    {
                        "username": "ztia0004",
                        "content": "I just don\\'t know the point of this question, it\\'s like wasting my time to understand something I do not want to know, rather than coding practice"
                    },
                    {
                        "username": "mayankK135",
                        "content": "Like all DSA problem you solve, it\\'s also to teach how problem solving skill, off course you won\\'t need it in real world"
                    },
                    {
                        "username": "AseCantCode",
                        "content": "[@georgezakharov](/georgezakharov) lmao\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Tell it on an interview :)"
                    },
                    {
                        "username": "ranjeetmadhaviitd",
                        "content": "[Watch](https://www.youtube.com/watch?v=wvpe4ldKTW0) this video for the better explanation of the solution.\\nhttps://www.youtube.com/watch?v=wvpe4ldKTW0\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution."
                    },
                    {
                        "username": "suren-yeager",
                        "content": "this isnt the correct question !!"
                    },
                    {
                        "username": "heshan16",
                        "content": "Er,for example,actually, the roman integer of 49 should be IL?But in this problem,the input of 49 should be output LXIX.So there result would not  the true roman numbers"
                    },
                    {
                        "username": "ivstarkov",
                        "content": "[@xcelr8](/xcelr8) 49 is XLIX. LXIX isnt possible."
                    },
                    {
                        "username": "dtwiers",
                        "content": "In the most loosely-defined version of Roman numerals, yes, IL would be correct. But in the more rigorously defined version, you can only use the next-highest order of 10 unit lower than a number to subtract from a large number - so IM isn\\'t a thing for 999, but CM will get you 900 because C is the next highest power of 10 below 1000. You then get XC (100 - 10), and IX (10 - 1), so 999 is CMXCIX"
                    },
                    {
                        "username": "dtwiers",
                        "content": "[@xcelr8](/xcelr8) that is 69. 49 is XLIX."
                    },
                    {
                        "username": "xcelr8",
                        "content": "49 is LXIX in roman"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "class Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string ans=\"\";\\n        while(num>=1000){\\n            ans+=\"M\";\\n            num-=1000;\\n        }\\n        while(num>=900){\\n            ans+=\"CM\";\\n            num-=900;\\n        }\\n        while(num>=500){\\n            ans+=\"D\";\\n            num-=500;\\n        }\\n        while(num>=400){\\n            ans+=\"CD\";\\n            num-=400;\\n        }\\n        while(num>=100){\\n            ans+=\"C\";\\n            num-=100;\\n        }\\n        while(num>=90){\\n            ans+=\"XC\";\\n            num-=90;\\n        }\\n        while(num>=50){\\n            ans+=\"L\";\\n            num-=50;\\n        }\\n        while(num>=40){\\n            ans+=\"XL\";\\n            num-=40;\\n        }\\n        while(num>=10){\\n            ans+=\"X\";\\n            num-=10;\\n        }\\n        while(num>=9){\\n            ans+=\"IX\";\\n            num-=9;\\n        }\\n        while(num>=5){\\n            ans+=\"V\";\\n            num-=5;\\n        }\\n        while(num>=4){\\n            ans+=\"IV\";\\n            num-=4;\\n        }\\n        while(num>=1){\\n            ans+=\"I\";\\n            num-=1;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sulicn",
                        "content": "[@user9666yo](/user9666yo) Is it allowed to post answers here in discussion?@Deepak_8811"
                    },
                    {
                        "username": "user9666yo",
                        "content": "//criado objeto com a correspondencia dos valores\\nconst symbols = {\\n  \\'I\\': 1,\\n  \\'V\\': 5,\\n  \\'X\\': 10,\\n  \\'L\\': 50,\\n  \\'C\\': 100,\\n  \\'D\\': 500,\\n  \\'M\\': 1000,\\n};\\n\\n//fun\\xE7ao contador total\\nfunction romanToInt(s) {\\n  let total = 0;\\n\\n//percorrer cada algarismo\\n  for (let i = 0; i < s.length; ++i) {\\n    const num1 = symbols[s[i]];\\n    const num2 = symbols[s[i + 1]];\\n\\n    if (num1 < num2) {\\n      total -= num1;\\n    } else {\\n      total += num1;\\n    }\\n  }\\n//retorna o total\\n  return total;\\n}\\n"
                    }
                ]
            },
            {
                "id": 1576240,
                "content": [
                    {
                        "username": "sulicn",
                        "content": "Can I report those idiots that are still posting solutions here?"
                    },
                    {
                        "username": "Wolfoo",
                        "content": "I think it\\'s easy not medium"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "alalalaa",
                        "content": "double it and give it to the next person\\n"
                    },
                    {
                        "username": "Luojihencha",
                        "content": "I paied a lot of money for leetcode......and still there is no answer. Leetcode please, all questions are hard for me."
                    },
                    {
                        "username": "jy0819",
                        "content": "bro it\\'s been 3 years hope your luoji becomes better now lol"
                    },
                    {
                        "username": "alalalaa",
                        "content": "ask someone who knows how to code to make you connect the dots"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "IHxRK28",
                        "content": "I dont know whether this is a troll statement or not but heres your motivation and tips/advice \\n\\nYou could just follow famous playlists on youtube - \\nSo theres this Indian Guy called striver (Channel Name - TakeuForward) more than half of his videos are in english, You should follow that and I can definitely say You will get better at it. From what I know and understand, You get better at coding with practice which might take different time for different people, so if you are interested in coding keep at it.  "
                    },
                    {
                        "username": "umnik",
                        "content": "I know the easy way of solving this problem is using **23 case** statements (10 for numbers [1-10], 10 for [10-100], 10 for [1000-3000]). But the code does not look good and it's getting bit long. I'm thinking even applying the rules for converting may also make the code complex. Any suggestions?"
                    },
                    {
                        "username": "androidcarson",
                        "content": "[@AdityaBhate](/AdityaBhate) downvoted for using emojis"
                    },
                    {
                        "username": "tolem",
                        "content": "yeah it can  even be solved in 10 to 11 case checks "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you might wanna take a look into this [solution](https://leetcode.com/problems/integer-to-roman/solutions/2726838/c-solution/?orderBy=most_votes)"
                    },
                    {
                        "username": "selvablaze",
                        "content": "[@lucayan0506](/lucayan0506) class Solution {\\n    public String getValue(int val, int pos, HashMap<Integer, String> map){\\n        int value = val * (int) Math.pow(10, pos-1);\\n        String answer = \"\";\\n        if(map.containsKey(value))\\n            return map.get(value);\\n        int upperBound = (int) Math.pow(10,pos);\\n        int midBound = (int) Math.pow(10,pos)/2;\\n        int lowerBound = (int) Math.pow(10, pos-1);\\n        if(val == 4)\\n            answer = map.get(lowerBound) + map.get(midBound);\\n        else if(val == 9 )\\n            answer = map.get(lowerBound) + map.get(upperBound);   \\n        else if(val < 4)\\n            answer = map.get(lowerBound).repeat(val);\\n        else if(val > 5)\\n            answer =  map.get(midBound) + map.get(lowerBound).repeat(val-5);   \\n        map.put(value, answer);\\n        return answer;              \\n    }\\n    public String intToRoman(int num) {\\n        String answer = \"\";\\n        int i = 1;\\n        HashMap<Integer,String> map = new HashMap<>();\\n        map.put(1, \"I\" );\\n        map.put(5, \"V\" );\\n        map.put(10, \"X\" );\\n        map.put(50, \"L\" );\\n        map.put(100, \"C\" );\\n        map.put(500, \"D\" );\\n        map.put(1000, \"M\");\\n        while(num>0){\\n            answer = getValue(num%10, i, map) + answer;\\n            num = num/10;\\n            i++;\\n        }\\n        return answer;\\n    }\\n}"
                    },
                    {
                        "username": "lucayan0506",
                        "content": "I would suggest use map (where you save the value in decimal and the value in roman) `m[1000] = \"M\"    m[900] = \"CM\"`.\nOr you can you use 2 array (one for decimal number, one for roman number) `decimal_number[0] = 1000 roman_number[0] = \"M\"`\nThen use a for loop, instead of 23 case statement"
                    },
                    {
                        "username": "Amax",
                        "content": "For example: how do you spell 1999 in roman?\\nMIM or MCMXCIX?"
                    },
                    {
                        "username": "RittikChaudhary",
                        "content": "[@VinayPatidar](/VinayPatidar) bhai 1001 ho skta hai \"MI\""
                    },
                    {
                        "username": "Kei_Chen",
                        "content": "[@VinayPatidar](/VinayPatidar) Actually I after M is allowed, for example: to write 1001, we can use MI"
                    },
                    {
                        "username": "arthur326",
                        "content": "Yeah, just from the information given in the question, 10 could be written as IX or VIV, right? (This does not violate the subtraction cases they give.) Are we allowed to return either representation? The question should be clearer..."
                    },
                    {
                        "username": "lolo101",
                        "content": "MCMXCIX\\nYou cannot write \"IM\" because you may only remove the previous power of ten to a power of ten.\\nFor instance \"IX\", \"XC\", \"CM\" are allowed. But \"IC\", \"IM\", \"XM\" are not."
                    },
                    {
                        "username": "VinayPatidar",
                        "content": "second one\\nyou cannot have I before or after M"
                    },
                    {
                        "username": "ozkansafak",
                        "content": "[@Kram_](/Kram_) Why? What\\'s the rule we\\'re trying to capture in the code?"
                    },
                    {
                        "username": "abdallahg2120",
                        "content": "According to roman rule which I see in problem description.\\nI think the right answer is MCMXCIX.\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "10 years later, we still have the same doubt!"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Oh man it\\'s been 10 years for this comment."
                    },
                    {
                        "username": "snoyes",
                        "content": "In modern standard use, the only subtractive forms are IV, IX, XL, XC, CD, and CM, so MIM wouldn\\'t be allowed. In medieval and earlier times, usage was all over the place, so there\\'s no telling "
                    },
                    {
                        "username": "Kram_",
                        "content": "The second one"
                    },
                    {
                        "username": "YuriiHryniv",
                        "content": "I bought leetcode subscription but this problem seems very hard to me :((. Unsubscribe, I thought I would get into FAANG"
                    },
                    {
                        "username": "AseCantCode",
                        "content": "[@Artsapollo](/Artsapollo) dude he is just joking"
                    },
                    {
                        "username": "Artsapollo",
                        "content": "Dude, try before pay"
                    },
                    {
                        "username": "ztia0004",
                        "content": "I just don\\'t know the point of this question, it\\'s like wasting my time to understand something I do not want to know, rather than coding practice"
                    },
                    {
                        "username": "mayankK135",
                        "content": "Like all DSA problem you solve, it\\'s also to teach how problem solving skill, off course you won\\'t need it in real world"
                    },
                    {
                        "username": "AseCantCode",
                        "content": "[@georgezakharov](/georgezakharov) lmao\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Tell it on an interview :)"
                    },
                    {
                        "username": "ranjeetmadhaviitd",
                        "content": "[Watch](https://www.youtube.com/watch?v=wvpe4ldKTW0) this video for the better explanation of the solution.\\nhttps://www.youtube.com/watch?v=wvpe4ldKTW0\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution."
                    },
                    {
                        "username": "suren-yeager",
                        "content": "this isnt the correct question !!"
                    },
                    {
                        "username": "heshan16",
                        "content": "Er,for example,actually, the roman integer of 49 should be IL?But in this problem,the input of 49 should be output LXIX.So there result would not  the true roman numbers"
                    },
                    {
                        "username": "ivstarkov",
                        "content": "[@xcelr8](/xcelr8) 49 is XLIX. LXIX isnt possible."
                    },
                    {
                        "username": "dtwiers",
                        "content": "In the most loosely-defined version of Roman numerals, yes, IL would be correct. But in the more rigorously defined version, you can only use the next-highest order of 10 unit lower than a number to subtract from a large number - so IM isn\\'t a thing for 999, but CM will get you 900 because C is the next highest power of 10 below 1000. You then get XC (100 - 10), and IX (10 - 1), so 999 is CMXCIX"
                    },
                    {
                        "username": "dtwiers",
                        "content": "[@xcelr8](/xcelr8) that is 69. 49 is XLIX."
                    },
                    {
                        "username": "xcelr8",
                        "content": "49 is LXIX in roman"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "class Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string ans=\"\";\\n        while(num>=1000){\\n            ans+=\"M\";\\n            num-=1000;\\n        }\\n        while(num>=900){\\n            ans+=\"CM\";\\n            num-=900;\\n        }\\n        while(num>=500){\\n            ans+=\"D\";\\n            num-=500;\\n        }\\n        while(num>=400){\\n            ans+=\"CD\";\\n            num-=400;\\n        }\\n        while(num>=100){\\n            ans+=\"C\";\\n            num-=100;\\n        }\\n        while(num>=90){\\n            ans+=\"XC\";\\n            num-=90;\\n        }\\n        while(num>=50){\\n            ans+=\"L\";\\n            num-=50;\\n        }\\n        while(num>=40){\\n            ans+=\"XL\";\\n            num-=40;\\n        }\\n        while(num>=10){\\n            ans+=\"X\";\\n            num-=10;\\n        }\\n        while(num>=9){\\n            ans+=\"IX\";\\n            num-=9;\\n        }\\n        while(num>=5){\\n            ans+=\"V\";\\n            num-=5;\\n        }\\n        while(num>=4){\\n            ans+=\"IV\";\\n            num-=4;\\n        }\\n        while(num>=1){\\n            ans+=\"I\";\\n            num-=1;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sulicn",
                        "content": "[@user9666yo](/user9666yo) Is it allowed to post answers here in discussion?@Deepak_8811"
                    },
                    {
                        "username": "user9666yo",
                        "content": "//criado objeto com a correspondencia dos valores\\nconst symbols = {\\n  \\'I\\': 1,\\n  \\'V\\': 5,\\n  \\'X\\': 10,\\n  \\'L\\': 50,\\n  \\'C\\': 100,\\n  \\'D\\': 500,\\n  \\'M\\': 1000,\\n};\\n\\n//fun\\xE7ao contador total\\nfunction romanToInt(s) {\\n  let total = 0;\\n\\n//percorrer cada algarismo\\n  for (let i = 0; i < s.length; ++i) {\\n    const num1 = symbols[s[i]];\\n    const num2 = symbols[s[i + 1]];\\n\\n    if (num1 < num2) {\\n      total -= num1;\\n    } else {\\n      total += num1;\\n    }\\n  }\\n//retorna o total\\n  return total;\\n}\\n"
                    }
                ]
            },
            {
                "id": 1568266,
                "content": [
                    {
                        "username": "sulicn",
                        "content": "Can I report those idiots that are still posting solutions here?"
                    },
                    {
                        "username": "Wolfoo",
                        "content": "I think it\\'s easy not medium"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "alalalaa",
                        "content": "double it and give it to the next person\\n"
                    },
                    {
                        "username": "Luojihencha",
                        "content": "I paied a lot of money for leetcode......and still there is no answer. Leetcode please, all questions are hard for me."
                    },
                    {
                        "username": "jy0819",
                        "content": "bro it\\'s been 3 years hope your luoji becomes better now lol"
                    },
                    {
                        "username": "alalalaa",
                        "content": "ask someone who knows how to code to make you connect the dots"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "IHxRK28",
                        "content": "I dont know whether this is a troll statement or not but heres your motivation and tips/advice \\n\\nYou could just follow famous playlists on youtube - \\nSo theres this Indian Guy called striver (Channel Name - TakeuForward) more than half of his videos are in english, You should follow that and I can definitely say You will get better at it. From what I know and understand, You get better at coding with practice which might take different time for different people, so if you are interested in coding keep at it.  "
                    },
                    {
                        "username": "umnik",
                        "content": "I know the easy way of solving this problem is using **23 case** statements (10 for numbers [1-10], 10 for [10-100], 10 for [1000-3000]). But the code does not look good and it's getting bit long. I'm thinking even applying the rules for converting may also make the code complex. Any suggestions?"
                    },
                    {
                        "username": "androidcarson",
                        "content": "[@AdityaBhate](/AdityaBhate) downvoted for using emojis"
                    },
                    {
                        "username": "tolem",
                        "content": "yeah it can  even be solved in 10 to 11 case checks "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you might wanna take a look into this [solution](https://leetcode.com/problems/integer-to-roman/solutions/2726838/c-solution/?orderBy=most_votes)"
                    },
                    {
                        "username": "selvablaze",
                        "content": "[@lucayan0506](/lucayan0506) class Solution {\\n    public String getValue(int val, int pos, HashMap<Integer, String> map){\\n        int value = val * (int) Math.pow(10, pos-1);\\n        String answer = \"\";\\n        if(map.containsKey(value))\\n            return map.get(value);\\n        int upperBound = (int) Math.pow(10,pos);\\n        int midBound = (int) Math.pow(10,pos)/2;\\n        int lowerBound = (int) Math.pow(10, pos-1);\\n        if(val == 4)\\n            answer = map.get(lowerBound) + map.get(midBound);\\n        else if(val == 9 )\\n            answer = map.get(lowerBound) + map.get(upperBound);   \\n        else if(val < 4)\\n            answer = map.get(lowerBound).repeat(val);\\n        else if(val > 5)\\n            answer =  map.get(midBound) + map.get(lowerBound).repeat(val-5);   \\n        map.put(value, answer);\\n        return answer;              \\n    }\\n    public String intToRoman(int num) {\\n        String answer = \"\";\\n        int i = 1;\\n        HashMap<Integer,String> map = new HashMap<>();\\n        map.put(1, \"I\" );\\n        map.put(5, \"V\" );\\n        map.put(10, \"X\" );\\n        map.put(50, \"L\" );\\n        map.put(100, \"C\" );\\n        map.put(500, \"D\" );\\n        map.put(1000, \"M\");\\n        while(num>0){\\n            answer = getValue(num%10, i, map) + answer;\\n            num = num/10;\\n            i++;\\n        }\\n        return answer;\\n    }\\n}"
                    },
                    {
                        "username": "lucayan0506",
                        "content": "I would suggest use map (where you save the value in decimal and the value in roman) `m[1000] = \"M\"    m[900] = \"CM\"`.\nOr you can you use 2 array (one for decimal number, one for roman number) `decimal_number[0] = 1000 roman_number[0] = \"M\"`\nThen use a for loop, instead of 23 case statement"
                    },
                    {
                        "username": "Amax",
                        "content": "For example: how do you spell 1999 in roman?\\nMIM or MCMXCIX?"
                    },
                    {
                        "username": "RittikChaudhary",
                        "content": "[@VinayPatidar](/VinayPatidar) bhai 1001 ho skta hai \"MI\""
                    },
                    {
                        "username": "Kei_Chen",
                        "content": "[@VinayPatidar](/VinayPatidar) Actually I after M is allowed, for example: to write 1001, we can use MI"
                    },
                    {
                        "username": "arthur326",
                        "content": "Yeah, just from the information given in the question, 10 could be written as IX or VIV, right? (This does not violate the subtraction cases they give.) Are we allowed to return either representation? The question should be clearer..."
                    },
                    {
                        "username": "lolo101",
                        "content": "MCMXCIX\\nYou cannot write \"IM\" because you may only remove the previous power of ten to a power of ten.\\nFor instance \"IX\", \"XC\", \"CM\" are allowed. But \"IC\", \"IM\", \"XM\" are not."
                    },
                    {
                        "username": "VinayPatidar",
                        "content": "second one\\nyou cannot have I before or after M"
                    },
                    {
                        "username": "ozkansafak",
                        "content": "[@Kram_](/Kram_) Why? What\\'s the rule we\\'re trying to capture in the code?"
                    },
                    {
                        "username": "abdallahg2120",
                        "content": "According to roman rule which I see in problem description.\\nI think the right answer is MCMXCIX.\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "10 years later, we still have the same doubt!"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Oh man it\\'s been 10 years for this comment."
                    },
                    {
                        "username": "snoyes",
                        "content": "In modern standard use, the only subtractive forms are IV, IX, XL, XC, CD, and CM, so MIM wouldn\\'t be allowed. In medieval and earlier times, usage was all over the place, so there\\'s no telling "
                    },
                    {
                        "username": "Kram_",
                        "content": "The second one"
                    },
                    {
                        "username": "YuriiHryniv",
                        "content": "I bought leetcode subscription but this problem seems very hard to me :((. Unsubscribe, I thought I would get into FAANG"
                    },
                    {
                        "username": "AseCantCode",
                        "content": "[@Artsapollo](/Artsapollo) dude he is just joking"
                    },
                    {
                        "username": "Artsapollo",
                        "content": "Dude, try before pay"
                    },
                    {
                        "username": "ztia0004",
                        "content": "I just don\\'t know the point of this question, it\\'s like wasting my time to understand something I do not want to know, rather than coding practice"
                    },
                    {
                        "username": "mayankK135",
                        "content": "Like all DSA problem you solve, it\\'s also to teach how problem solving skill, off course you won\\'t need it in real world"
                    },
                    {
                        "username": "AseCantCode",
                        "content": "[@georgezakharov](/georgezakharov) lmao\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Tell it on an interview :)"
                    },
                    {
                        "username": "ranjeetmadhaviitd",
                        "content": "[Watch](https://www.youtube.com/watch?v=wvpe4ldKTW0) this video for the better explanation of the solution.\\nhttps://www.youtube.com/watch?v=wvpe4ldKTW0\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution."
                    },
                    {
                        "username": "suren-yeager",
                        "content": "this isnt the correct question !!"
                    },
                    {
                        "username": "heshan16",
                        "content": "Er,for example,actually, the roman integer of 49 should be IL?But in this problem,the input of 49 should be output LXIX.So there result would not  the true roman numbers"
                    },
                    {
                        "username": "ivstarkov",
                        "content": "[@xcelr8](/xcelr8) 49 is XLIX. LXIX isnt possible."
                    },
                    {
                        "username": "dtwiers",
                        "content": "In the most loosely-defined version of Roman numerals, yes, IL would be correct. But in the more rigorously defined version, you can only use the next-highest order of 10 unit lower than a number to subtract from a large number - so IM isn\\'t a thing for 999, but CM will get you 900 because C is the next highest power of 10 below 1000. You then get XC (100 - 10), and IX (10 - 1), so 999 is CMXCIX"
                    },
                    {
                        "username": "dtwiers",
                        "content": "[@xcelr8](/xcelr8) that is 69. 49 is XLIX."
                    },
                    {
                        "username": "xcelr8",
                        "content": "49 is LXIX in roman"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "class Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string ans=\"\";\\n        while(num>=1000){\\n            ans+=\"M\";\\n            num-=1000;\\n        }\\n        while(num>=900){\\n            ans+=\"CM\";\\n            num-=900;\\n        }\\n        while(num>=500){\\n            ans+=\"D\";\\n            num-=500;\\n        }\\n        while(num>=400){\\n            ans+=\"CD\";\\n            num-=400;\\n        }\\n        while(num>=100){\\n            ans+=\"C\";\\n            num-=100;\\n        }\\n        while(num>=90){\\n            ans+=\"XC\";\\n            num-=90;\\n        }\\n        while(num>=50){\\n            ans+=\"L\";\\n            num-=50;\\n        }\\n        while(num>=40){\\n            ans+=\"XL\";\\n            num-=40;\\n        }\\n        while(num>=10){\\n            ans+=\"X\";\\n            num-=10;\\n        }\\n        while(num>=9){\\n            ans+=\"IX\";\\n            num-=9;\\n        }\\n        while(num>=5){\\n            ans+=\"V\";\\n            num-=5;\\n        }\\n        while(num>=4){\\n            ans+=\"IV\";\\n            num-=4;\\n        }\\n        while(num>=1){\\n            ans+=\"I\";\\n            num-=1;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sulicn",
                        "content": "[@user9666yo](/user9666yo) Is it allowed to post answers here in discussion?@Deepak_8811"
                    },
                    {
                        "username": "user9666yo",
                        "content": "//criado objeto com a correspondencia dos valores\\nconst symbols = {\\n  \\'I\\': 1,\\n  \\'V\\': 5,\\n  \\'X\\': 10,\\n  \\'L\\': 50,\\n  \\'C\\': 100,\\n  \\'D\\': 500,\\n  \\'M\\': 1000,\\n};\\n\\n//fun\\xE7ao contador total\\nfunction romanToInt(s) {\\n  let total = 0;\\n\\n//percorrer cada algarismo\\n  for (let i = 0; i < s.length; ++i) {\\n    const num1 = symbols[s[i]];\\n    const num2 = symbols[s[i + 1]];\\n\\n    if (num1 < num2) {\\n      total -= num1;\\n    } else {\\n      total += num1;\\n    }\\n  }\\n//retorna o total\\n  return total;\\n}\\n"
                    }
                ]
            },
            {
                "id": 1565655,
                "content": [
                    {
                        "username": "sulicn",
                        "content": "Can I report those idiots that are still posting solutions here?"
                    },
                    {
                        "username": "Wolfoo",
                        "content": "I think it\\'s easy not medium"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "alalalaa",
                        "content": "double it and give it to the next person\\n"
                    },
                    {
                        "username": "Luojihencha",
                        "content": "I paied a lot of money for leetcode......and still there is no answer. Leetcode please, all questions are hard for me."
                    },
                    {
                        "username": "jy0819",
                        "content": "bro it\\'s been 3 years hope your luoji becomes better now lol"
                    },
                    {
                        "username": "alalalaa",
                        "content": "ask someone who knows how to code to make you connect the dots"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "IHxRK28",
                        "content": "I dont know whether this is a troll statement or not but heres your motivation and tips/advice \\n\\nYou could just follow famous playlists on youtube - \\nSo theres this Indian Guy called striver (Channel Name - TakeuForward) more than half of his videos are in english, You should follow that and I can definitely say You will get better at it. From what I know and understand, You get better at coding with practice which might take different time for different people, so if you are interested in coding keep at it.  "
                    },
                    {
                        "username": "umnik",
                        "content": "I know the easy way of solving this problem is using **23 case** statements (10 for numbers [1-10], 10 for [10-100], 10 for [1000-3000]). But the code does not look good and it's getting bit long. I'm thinking even applying the rules for converting may also make the code complex. Any suggestions?"
                    },
                    {
                        "username": "androidcarson",
                        "content": "[@AdityaBhate](/AdityaBhate) downvoted for using emojis"
                    },
                    {
                        "username": "tolem",
                        "content": "yeah it can  even be solved in 10 to 11 case checks "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you might wanna take a look into this [solution](https://leetcode.com/problems/integer-to-roman/solutions/2726838/c-solution/?orderBy=most_votes)"
                    },
                    {
                        "username": "selvablaze",
                        "content": "[@lucayan0506](/lucayan0506) class Solution {\\n    public String getValue(int val, int pos, HashMap<Integer, String> map){\\n        int value = val * (int) Math.pow(10, pos-1);\\n        String answer = \"\";\\n        if(map.containsKey(value))\\n            return map.get(value);\\n        int upperBound = (int) Math.pow(10,pos);\\n        int midBound = (int) Math.pow(10,pos)/2;\\n        int lowerBound = (int) Math.pow(10, pos-1);\\n        if(val == 4)\\n            answer = map.get(lowerBound) + map.get(midBound);\\n        else if(val == 9 )\\n            answer = map.get(lowerBound) + map.get(upperBound);   \\n        else if(val < 4)\\n            answer = map.get(lowerBound).repeat(val);\\n        else if(val > 5)\\n            answer =  map.get(midBound) + map.get(lowerBound).repeat(val-5);   \\n        map.put(value, answer);\\n        return answer;              \\n    }\\n    public String intToRoman(int num) {\\n        String answer = \"\";\\n        int i = 1;\\n        HashMap<Integer,String> map = new HashMap<>();\\n        map.put(1, \"I\" );\\n        map.put(5, \"V\" );\\n        map.put(10, \"X\" );\\n        map.put(50, \"L\" );\\n        map.put(100, \"C\" );\\n        map.put(500, \"D\" );\\n        map.put(1000, \"M\");\\n        while(num>0){\\n            answer = getValue(num%10, i, map) + answer;\\n            num = num/10;\\n            i++;\\n        }\\n        return answer;\\n    }\\n}"
                    },
                    {
                        "username": "lucayan0506",
                        "content": "I would suggest use map (where you save the value in decimal and the value in roman) `m[1000] = \"M\"    m[900] = \"CM\"`.\nOr you can you use 2 array (one for decimal number, one for roman number) `decimal_number[0] = 1000 roman_number[0] = \"M\"`\nThen use a for loop, instead of 23 case statement"
                    },
                    {
                        "username": "Amax",
                        "content": "For example: how do you spell 1999 in roman?\\nMIM or MCMXCIX?"
                    },
                    {
                        "username": "RittikChaudhary",
                        "content": "[@VinayPatidar](/VinayPatidar) bhai 1001 ho skta hai \"MI\""
                    },
                    {
                        "username": "Kei_Chen",
                        "content": "[@VinayPatidar](/VinayPatidar) Actually I after M is allowed, for example: to write 1001, we can use MI"
                    },
                    {
                        "username": "arthur326",
                        "content": "Yeah, just from the information given in the question, 10 could be written as IX or VIV, right? (This does not violate the subtraction cases they give.) Are we allowed to return either representation? The question should be clearer..."
                    },
                    {
                        "username": "lolo101",
                        "content": "MCMXCIX\\nYou cannot write \"IM\" because you may only remove the previous power of ten to a power of ten.\\nFor instance \"IX\", \"XC\", \"CM\" are allowed. But \"IC\", \"IM\", \"XM\" are not."
                    },
                    {
                        "username": "VinayPatidar",
                        "content": "second one\\nyou cannot have I before or after M"
                    },
                    {
                        "username": "ozkansafak",
                        "content": "[@Kram_](/Kram_) Why? What\\'s the rule we\\'re trying to capture in the code?"
                    },
                    {
                        "username": "abdallahg2120",
                        "content": "According to roman rule which I see in problem description.\\nI think the right answer is MCMXCIX.\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "10 years later, we still have the same doubt!"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Oh man it\\'s been 10 years for this comment."
                    },
                    {
                        "username": "snoyes",
                        "content": "In modern standard use, the only subtractive forms are IV, IX, XL, XC, CD, and CM, so MIM wouldn\\'t be allowed. In medieval and earlier times, usage was all over the place, so there\\'s no telling "
                    },
                    {
                        "username": "Kram_",
                        "content": "The second one"
                    },
                    {
                        "username": "YuriiHryniv",
                        "content": "I bought leetcode subscription but this problem seems very hard to me :((. Unsubscribe, I thought I would get into FAANG"
                    },
                    {
                        "username": "AseCantCode",
                        "content": "[@Artsapollo](/Artsapollo) dude he is just joking"
                    },
                    {
                        "username": "Artsapollo",
                        "content": "Dude, try before pay"
                    },
                    {
                        "username": "ztia0004",
                        "content": "I just don\\'t know the point of this question, it\\'s like wasting my time to understand something I do not want to know, rather than coding practice"
                    },
                    {
                        "username": "mayankK135",
                        "content": "Like all DSA problem you solve, it\\'s also to teach how problem solving skill, off course you won\\'t need it in real world"
                    },
                    {
                        "username": "AseCantCode",
                        "content": "[@georgezakharov](/georgezakharov) lmao\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Tell it on an interview :)"
                    },
                    {
                        "username": "ranjeetmadhaviitd",
                        "content": "[Watch](https://www.youtube.com/watch?v=wvpe4ldKTW0) this video for the better explanation of the solution.\\nhttps://www.youtube.com/watch?v=wvpe4ldKTW0\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution."
                    },
                    {
                        "username": "suren-yeager",
                        "content": "this isnt the correct question !!"
                    },
                    {
                        "username": "heshan16",
                        "content": "Er,for example,actually, the roman integer of 49 should be IL?But in this problem,the input of 49 should be output LXIX.So there result would not  the true roman numbers"
                    },
                    {
                        "username": "ivstarkov",
                        "content": "[@xcelr8](/xcelr8) 49 is XLIX. LXIX isnt possible."
                    },
                    {
                        "username": "dtwiers",
                        "content": "In the most loosely-defined version of Roman numerals, yes, IL would be correct. But in the more rigorously defined version, you can only use the next-highest order of 10 unit lower than a number to subtract from a large number - so IM isn\\'t a thing for 999, but CM will get you 900 because C is the next highest power of 10 below 1000. You then get XC (100 - 10), and IX (10 - 1), so 999 is CMXCIX"
                    },
                    {
                        "username": "dtwiers",
                        "content": "[@xcelr8](/xcelr8) that is 69. 49 is XLIX."
                    },
                    {
                        "username": "xcelr8",
                        "content": "49 is LXIX in roman"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "class Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string ans=\"\";\\n        while(num>=1000){\\n            ans+=\"M\";\\n            num-=1000;\\n        }\\n        while(num>=900){\\n            ans+=\"CM\";\\n            num-=900;\\n        }\\n        while(num>=500){\\n            ans+=\"D\";\\n            num-=500;\\n        }\\n        while(num>=400){\\n            ans+=\"CD\";\\n            num-=400;\\n        }\\n        while(num>=100){\\n            ans+=\"C\";\\n            num-=100;\\n        }\\n        while(num>=90){\\n            ans+=\"XC\";\\n            num-=90;\\n        }\\n        while(num>=50){\\n            ans+=\"L\";\\n            num-=50;\\n        }\\n        while(num>=40){\\n            ans+=\"XL\";\\n            num-=40;\\n        }\\n        while(num>=10){\\n            ans+=\"X\";\\n            num-=10;\\n        }\\n        while(num>=9){\\n            ans+=\"IX\";\\n            num-=9;\\n        }\\n        while(num>=5){\\n            ans+=\"V\";\\n            num-=5;\\n        }\\n        while(num>=4){\\n            ans+=\"IV\";\\n            num-=4;\\n        }\\n        while(num>=1){\\n            ans+=\"I\";\\n            num-=1;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sulicn",
                        "content": "[@user9666yo](/user9666yo) Is it allowed to post answers here in discussion?@Deepak_8811"
                    },
                    {
                        "username": "user9666yo",
                        "content": "//criado objeto com a correspondencia dos valores\\nconst symbols = {\\n  \\'I\\': 1,\\n  \\'V\\': 5,\\n  \\'X\\': 10,\\n  \\'L\\': 50,\\n  \\'C\\': 100,\\n  \\'D\\': 500,\\n  \\'M\\': 1000,\\n};\\n\\n//fun\\xE7ao contador total\\nfunction romanToInt(s) {\\n  let total = 0;\\n\\n//percorrer cada algarismo\\n  for (let i = 0; i < s.length; ++i) {\\n    const num1 = symbols[s[i]];\\n    const num2 = symbols[s[i + 1]];\\n\\n    if (num1 < num2) {\\n      total -= num1;\\n    } else {\\n      total += num1;\\n    }\\n  }\\n//retorna o total\\n  return total;\\n}\\n"
                    }
                ]
            },
            {
                "id": 1565656,
                "content": [
                    {
                        "username": "sulicn",
                        "content": "Can I report those idiots that are still posting solutions here?"
                    },
                    {
                        "username": "Wolfoo",
                        "content": "I think it\\'s easy not medium"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "alalalaa",
                        "content": "double it and give it to the next person\\n"
                    },
                    {
                        "username": "Luojihencha",
                        "content": "I paied a lot of money for leetcode......and still there is no answer. Leetcode please, all questions are hard for me."
                    },
                    {
                        "username": "jy0819",
                        "content": "bro it\\'s been 3 years hope your luoji becomes better now lol"
                    },
                    {
                        "username": "alalalaa",
                        "content": "ask someone who knows how to code to make you connect the dots"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "IHxRK28",
                        "content": "I dont know whether this is a troll statement or not but heres your motivation and tips/advice \\n\\nYou could just follow famous playlists on youtube - \\nSo theres this Indian Guy called striver (Channel Name - TakeuForward) more than half of his videos are in english, You should follow that and I can definitely say You will get better at it. From what I know and understand, You get better at coding with practice which might take different time for different people, so if you are interested in coding keep at it.  "
                    },
                    {
                        "username": "umnik",
                        "content": "I know the easy way of solving this problem is using **23 case** statements (10 for numbers [1-10], 10 for [10-100], 10 for [1000-3000]). But the code does not look good and it's getting bit long. I'm thinking even applying the rules for converting may also make the code complex. Any suggestions?"
                    },
                    {
                        "username": "androidcarson",
                        "content": "[@AdityaBhate](/AdityaBhate) downvoted for using emojis"
                    },
                    {
                        "username": "tolem",
                        "content": "yeah it can  even be solved in 10 to 11 case checks "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you might wanna take a look into this [solution](https://leetcode.com/problems/integer-to-roman/solutions/2726838/c-solution/?orderBy=most_votes)"
                    },
                    {
                        "username": "selvablaze",
                        "content": "[@lucayan0506](/lucayan0506) class Solution {\\n    public String getValue(int val, int pos, HashMap<Integer, String> map){\\n        int value = val * (int) Math.pow(10, pos-1);\\n        String answer = \"\";\\n        if(map.containsKey(value))\\n            return map.get(value);\\n        int upperBound = (int) Math.pow(10,pos);\\n        int midBound = (int) Math.pow(10,pos)/2;\\n        int lowerBound = (int) Math.pow(10, pos-1);\\n        if(val == 4)\\n            answer = map.get(lowerBound) + map.get(midBound);\\n        else if(val == 9 )\\n            answer = map.get(lowerBound) + map.get(upperBound);   \\n        else if(val < 4)\\n            answer = map.get(lowerBound).repeat(val);\\n        else if(val > 5)\\n            answer =  map.get(midBound) + map.get(lowerBound).repeat(val-5);   \\n        map.put(value, answer);\\n        return answer;              \\n    }\\n    public String intToRoman(int num) {\\n        String answer = \"\";\\n        int i = 1;\\n        HashMap<Integer,String> map = new HashMap<>();\\n        map.put(1, \"I\" );\\n        map.put(5, \"V\" );\\n        map.put(10, \"X\" );\\n        map.put(50, \"L\" );\\n        map.put(100, \"C\" );\\n        map.put(500, \"D\" );\\n        map.put(1000, \"M\");\\n        while(num>0){\\n            answer = getValue(num%10, i, map) + answer;\\n            num = num/10;\\n            i++;\\n        }\\n        return answer;\\n    }\\n}"
                    },
                    {
                        "username": "lucayan0506",
                        "content": "I would suggest use map (where you save the value in decimal and the value in roman) `m[1000] = \"M\"    m[900] = \"CM\"`.\nOr you can you use 2 array (one for decimal number, one for roman number) `decimal_number[0] = 1000 roman_number[0] = \"M\"`\nThen use a for loop, instead of 23 case statement"
                    },
                    {
                        "username": "Amax",
                        "content": "For example: how do you spell 1999 in roman?\\nMIM or MCMXCIX?"
                    },
                    {
                        "username": "RittikChaudhary",
                        "content": "[@VinayPatidar](/VinayPatidar) bhai 1001 ho skta hai \"MI\""
                    },
                    {
                        "username": "Kei_Chen",
                        "content": "[@VinayPatidar](/VinayPatidar) Actually I after M is allowed, for example: to write 1001, we can use MI"
                    },
                    {
                        "username": "arthur326",
                        "content": "Yeah, just from the information given in the question, 10 could be written as IX or VIV, right? (This does not violate the subtraction cases they give.) Are we allowed to return either representation? The question should be clearer..."
                    },
                    {
                        "username": "lolo101",
                        "content": "MCMXCIX\\nYou cannot write \"IM\" because you may only remove the previous power of ten to a power of ten.\\nFor instance \"IX\", \"XC\", \"CM\" are allowed. But \"IC\", \"IM\", \"XM\" are not."
                    },
                    {
                        "username": "VinayPatidar",
                        "content": "second one\\nyou cannot have I before or after M"
                    },
                    {
                        "username": "ozkansafak",
                        "content": "[@Kram_](/Kram_) Why? What\\'s the rule we\\'re trying to capture in the code?"
                    },
                    {
                        "username": "abdallahg2120",
                        "content": "According to roman rule which I see in problem description.\\nI think the right answer is MCMXCIX.\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "10 years later, we still have the same doubt!"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Oh man it\\'s been 10 years for this comment."
                    },
                    {
                        "username": "snoyes",
                        "content": "In modern standard use, the only subtractive forms are IV, IX, XL, XC, CD, and CM, so MIM wouldn\\'t be allowed. In medieval and earlier times, usage was all over the place, so there\\'s no telling "
                    },
                    {
                        "username": "Kram_",
                        "content": "The second one"
                    },
                    {
                        "username": "YuriiHryniv",
                        "content": "I bought leetcode subscription but this problem seems very hard to me :((. Unsubscribe, I thought I would get into FAANG"
                    },
                    {
                        "username": "AseCantCode",
                        "content": "[@Artsapollo](/Artsapollo) dude he is just joking"
                    },
                    {
                        "username": "Artsapollo",
                        "content": "Dude, try before pay"
                    },
                    {
                        "username": "ztia0004",
                        "content": "I just don\\'t know the point of this question, it\\'s like wasting my time to understand something I do not want to know, rather than coding practice"
                    },
                    {
                        "username": "mayankK135",
                        "content": "Like all DSA problem you solve, it\\'s also to teach how problem solving skill, off course you won\\'t need it in real world"
                    },
                    {
                        "username": "AseCantCode",
                        "content": "[@georgezakharov](/georgezakharov) lmao\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Tell it on an interview :)"
                    },
                    {
                        "username": "ranjeetmadhaviitd",
                        "content": "[Watch](https://www.youtube.com/watch?v=wvpe4ldKTW0) this video for the better explanation of the solution.\\nhttps://www.youtube.com/watch?v=wvpe4ldKTW0\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution."
                    },
                    {
                        "username": "suren-yeager",
                        "content": "this isnt the correct question !!"
                    },
                    {
                        "username": "heshan16",
                        "content": "Er,for example,actually, the roman integer of 49 should be IL?But in this problem,the input of 49 should be output LXIX.So there result would not  the true roman numbers"
                    },
                    {
                        "username": "ivstarkov",
                        "content": "[@xcelr8](/xcelr8) 49 is XLIX. LXIX isnt possible."
                    },
                    {
                        "username": "dtwiers",
                        "content": "In the most loosely-defined version of Roman numerals, yes, IL would be correct. But in the more rigorously defined version, you can only use the next-highest order of 10 unit lower than a number to subtract from a large number - so IM isn\\'t a thing for 999, but CM will get you 900 because C is the next highest power of 10 below 1000. You then get XC (100 - 10), and IX (10 - 1), so 999 is CMXCIX"
                    },
                    {
                        "username": "dtwiers",
                        "content": "[@xcelr8](/xcelr8) that is 69. 49 is XLIX."
                    },
                    {
                        "username": "xcelr8",
                        "content": "49 is LXIX in roman"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "class Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string ans=\"\";\\n        while(num>=1000){\\n            ans+=\"M\";\\n            num-=1000;\\n        }\\n        while(num>=900){\\n            ans+=\"CM\";\\n            num-=900;\\n        }\\n        while(num>=500){\\n            ans+=\"D\";\\n            num-=500;\\n        }\\n        while(num>=400){\\n            ans+=\"CD\";\\n            num-=400;\\n        }\\n        while(num>=100){\\n            ans+=\"C\";\\n            num-=100;\\n        }\\n        while(num>=90){\\n            ans+=\"XC\";\\n            num-=90;\\n        }\\n        while(num>=50){\\n            ans+=\"L\";\\n            num-=50;\\n        }\\n        while(num>=40){\\n            ans+=\"XL\";\\n            num-=40;\\n        }\\n        while(num>=10){\\n            ans+=\"X\";\\n            num-=10;\\n        }\\n        while(num>=9){\\n            ans+=\"IX\";\\n            num-=9;\\n        }\\n        while(num>=5){\\n            ans+=\"V\";\\n            num-=5;\\n        }\\n        while(num>=4){\\n            ans+=\"IV\";\\n            num-=4;\\n        }\\n        while(num>=1){\\n            ans+=\"I\";\\n            num-=1;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sulicn",
                        "content": "[@user9666yo](/user9666yo) Is it allowed to post answers here in discussion?@Deepak_8811"
                    },
                    {
                        "username": "user9666yo",
                        "content": "//criado objeto com a correspondencia dos valores\\nconst symbols = {\\n  \\'I\\': 1,\\n  \\'V\\': 5,\\n  \\'X\\': 10,\\n  \\'L\\': 50,\\n  \\'C\\': 100,\\n  \\'D\\': 500,\\n  \\'M\\': 1000,\\n};\\n\\n//fun\\xE7ao contador total\\nfunction romanToInt(s) {\\n  let total = 0;\\n\\n//percorrer cada algarismo\\n  for (let i = 0; i < s.length; ++i) {\\n    const num1 = symbols[s[i]];\\n    const num2 = symbols[s[i + 1]];\\n\\n    if (num1 < num2) {\\n      total -= num1;\\n    } else {\\n      total += num1;\\n    }\\n  }\\n//retorna o total\\n  return total;\\n}\\n"
                    }
                ]
            },
            {
                "id": 1732820,
                "content": [
                    {
                        "username": "sulicn",
                        "content": "Can I report those idiots that are still posting solutions here?"
                    },
                    {
                        "username": "Wolfoo",
                        "content": "I think it\\'s easy not medium"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "alalalaa",
                        "content": "double it and give it to the next person\\n"
                    },
                    {
                        "username": "Luojihencha",
                        "content": "I paied a lot of money for leetcode......and still there is no answer. Leetcode please, all questions are hard for me."
                    },
                    {
                        "username": "jy0819",
                        "content": "bro it\\'s been 3 years hope your luoji becomes better now lol"
                    },
                    {
                        "username": "alalalaa",
                        "content": "ask someone who knows how to code to make you connect the dots"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "IHxRK28",
                        "content": "I dont know whether this is a troll statement or not but heres your motivation and tips/advice \\n\\nYou could just follow famous playlists on youtube - \\nSo theres this Indian Guy called striver (Channel Name - TakeuForward) more than half of his videos are in english, You should follow that and I can definitely say You will get better at it. From what I know and understand, You get better at coding with practice which might take different time for different people, so if you are interested in coding keep at it.  "
                    },
                    {
                        "username": "umnik",
                        "content": "I know the easy way of solving this problem is using **23 case** statements (10 for numbers [1-10], 10 for [10-100], 10 for [1000-3000]). But the code does not look good and it's getting bit long. I'm thinking even applying the rules for converting may also make the code complex. Any suggestions?"
                    },
                    {
                        "username": "androidcarson",
                        "content": "[@AdityaBhate](/AdityaBhate) downvoted for using emojis"
                    },
                    {
                        "username": "tolem",
                        "content": "yeah it can  even be solved in 10 to 11 case checks "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you might wanna take a look into this [solution](https://leetcode.com/problems/integer-to-roman/solutions/2726838/c-solution/?orderBy=most_votes)"
                    },
                    {
                        "username": "selvablaze",
                        "content": "[@lucayan0506](/lucayan0506) class Solution {\\n    public String getValue(int val, int pos, HashMap<Integer, String> map){\\n        int value = val * (int) Math.pow(10, pos-1);\\n        String answer = \"\";\\n        if(map.containsKey(value))\\n            return map.get(value);\\n        int upperBound = (int) Math.pow(10,pos);\\n        int midBound = (int) Math.pow(10,pos)/2;\\n        int lowerBound = (int) Math.pow(10, pos-1);\\n        if(val == 4)\\n            answer = map.get(lowerBound) + map.get(midBound);\\n        else if(val == 9 )\\n            answer = map.get(lowerBound) + map.get(upperBound);   \\n        else if(val < 4)\\n            answer = map.get(lowerBound).repeat(val);\\n        else if(val > 5)\\n            answer =  map.get(midBound) + map.get(lowerBound).repeat(val-5);   \\n        map.put(value, answer);\\n        return answer;              \\n    }\\n    public String intToRoman(int num) {\\n        String answer = \"\";\\n        int i = 1;\\n        HashMap<Integer,String> map = new HashMap<>();\\n        map.put(1, \"I\" );\\n        map.put(5, \"V\" );\\n        map.put(10, \"X\" );\\n        map.put(50, \"L\" );\\n        map.put(100, \"C\" );\\n        map.put(500, \"D\" );\\n        map.put(1000, \"M\");\\n        while(num>0){\\n            answer = getValue(num%10, i, map) + answer;\\n            num = num/10;\\n            i++;\\n        }\\n        return answer;\\n    }\\n}"
                    },
                    {
                        "username": "lucayan0506",
                        "content": "I would suggest use map (where you save the value in decimal and the value in roman) `m[1000] = \"M\"    m[900] = \"CM\"`.\nOr you can you use 2 array (one for decimal number, one for roman number) `decimal_number[0] = 1000 roman_number[0] = \"M\"`\nThen use a for loop, instead of 23 case statement"
                    },
                    {
                        "username": "Amax",
                        "content": "For example: how do you spell 1999 in roman?\\nMIM or MCMXCIX?"
                    },
                    {
                        "username": "RittikChaudhary",
                        "content": "[@VinayPatidar](/VinayPatidar) bhai 1001 ho skta hai \"MI\""
                    },
                    {
                        "username": "Kei_Chen",
                        "content": "[@VinayPatidar](/VinayPatidar) Actually I after M is allowed, for example: to write 1001, we can use MI"
                    },
                    {
                        "username": "arthur326",
                        "content": "Yeah, just from the information given in the question, 10 could be written as IX or VIV, right? (This does not violate the subtraction cases they give.) Are we allowed to return either representation? The question should be clearer..."
                    },
                    {
                        "username": "lolo101",
                        "content": "MCMXCIX\\nYou cannot write \"IM\" because you may only remove the previous power of ten to a power of ten.\\nFor instance \"IX\", \"XC\", \"CM\" are allowed. But \"IC\", \"IM\", \"XM\" are not."
                    },
                    {
                        "username": "VinayPatidar",
                        "content": "second one\\nyou cannot have I before or after M"
                    },
                    {
                        "username": "ozkansafak",
                        "content": "[@Kram_](/Kram_) Why? What\\'s the rule we\\'re trying to capture in the code?"
                    },
                    {
                        "username": "abdallahg2120",
                        "content": "According to roman rule which I see in problem description.\\nI think the right answer is MCMXCIX.\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "10 years later, we still have the same doubt!"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Oh man it\\'s been 10 years for this comment."
                    },
                    {
                        "username": "snoyes",
                        "content": "In modern standard use, the only subtractive forms are IV, IX, XL, XC, CD, and CM, so MIM wouldn\\'t be allowed. In medieval and earlier times, usage was all over the place, so there\\'s no telling "
                    },
                    {
                        "username": "Kram_",
                        "content": "The second one"
                    },
                    {
                        "username": "YuriiHryniv",
                        "content": "I bought leetcode subscription but this problem seems very hard to me :((. Unsubscribe, I thought I would get into FAANG"
                    },
                    {
                        "username": "AseCantCode",
                        "content": "[@Artsapollo](/Artsapollo) dude he is just joking"
                    },
                    {
                        "username": "Artsapollo",
                        "content": "Dude, try before pay"
                    },
                    {
                        "username": "ztia0004",
                        "content": "I just don\\'t know the point of this question, it\\'s like wasting my time to understand something I do not want to know, rather than coding practice"
                    },
                    {
                        "username": "mayankK135",
                        "content": "Like all DSA problem you solve, it\\'s also to teach how problem solving skill, off course you won\\'t need it in real world"
                    },
                    {
                        "username": "AseCantCode",
                        "content": "[@georgezakharov](/georgezakharov) lmao\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Tell it on an interview :)"
                    },
                    {
                        "username": "ranjeetmadhaviitd",
                        "content": "[Watch](https://www.youtube.com/watch?v=wvpe4ldKTW0) this video for the better explanation of the solution.\\nhttps://www.youtube.com/watch?v=wvpe4ldKTW0\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution."
                    },
                    {
                        "username": "suren-yeager",
                        "content": "this isnt the correct question !!"
                    },
                    {
                        "username": "heshan16",
                        "content": "Er,for example,actually, the roman integer of 49 should be IL?But in this problem,the input of 49 should be output LXIX.So there result would not  the true roman numbers"
                    },
                    {
                        "username": "ivstarkov",
                        "content": "[@xcelr8](/xcelr8) 49 is XLIX. LXIX isnt possible."
                    },
                    {
                        "username": "dtwiers",
                        "content": "In the most loosely-defined version of Roman numerals, yes, IL would be correct. But in the more rigorously defined version, you can only use the next-highest order of 10 unit lower than a number to subtract from a large number - so IM isn\\'t a thing for 999, but CM will get you 900 because C is the next highest power of 10 below 1000. You then get XC (100 - 10), and IX (10 - 1), so 999 is CMXCIX"
                    },
                    {
                        "username": "dtwiers",
                        "content": "[@xcelr8](/xcelr8) that is 69. 49 is XLIX."
                    },
                    {
                        "username": "xcelr8",
                        "content": "49 is LXIX in roman"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "class Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string ans=\"\";\\n        while(num>=1000){\\n            ans+=\"M\";\\n            num-=1000;\\n        }\\n        while(num>=900){\\n            ans+=\"CM\";\\n            num-=900;\\n        }\\n        while(num>=500){\\n            ans+=\"D\";\\n            num-=500;\\n        }\\n        while(num>=400){\\n            ans+=\"CD\";\\n            num-=400;\\n        }\\n        while(num>=100){\\n            ans+=\"C\";\\n            num-=100;\\n        }\\n        while(num>=90){\\n            ans+=\"XC\";\\n            num-=90;\\n        }\\n        while(num>=50){\\n            ans+=\"L\";\\n            num-=50;\\n        }\\n        while(num>=40){\\n            ans+=\"XL\";\\n            num-=40;\\n        }\\n        while(num>=10){\\n            ans+=\"X\";\\n            num-=10;\\n        }\\n        while(num>=9){\\n            ans+=\"IX\";\\n            num-=9;\\n        }\\n        while(num>=5){\\n            ans+=\"V\";\\n            num-=5;\\n        }\\n        while(num>=4){\\n            ans+=\"IV\";\\n            num-=4;\\n        }\\n        while(num>=1){\\n            ans+=\"I\";\\n            num-=1;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sulicn",
                        "content": "[@user9666yo](/user9666yo) Is it allowed to post answers here in discussion?@Deepak_8811"
                    },
                    {
                        "username": "user9666yo",
                        "content": "//criado objeto com a correspondencia dos valores\\nconst symbols = {\\n  \\'I\\': 1,\\n  \\'V\\': 5,\\n  \\'X\\': 10,\\n  \\'L\\': 50,\\n  \\'C\\': 100,\\n  \\'D\\': 500,\\n  \\'M\\': 1000,\\n};\\n\\n//fun\\xE7ao contador total\\nfunction romanToInt(s) {\\n  let total = 0;\\n\\n//percorrer cada algarismo\\n  for (let i = 0; i < s.length; ++i) {\\n    const num1 = symbols[s[i]];\\n    const num2 = symbols[s[i + 1]];\\n\\n    if (num1 < num2) {\\n      total -= num1;\\n    } else {\\n      total += num1;\\n    }\\n  }\\n//retorna o total\\n  return total;\\n}\\n"
                    }
                ]
            },
            {
                "id": 1914145,
                "content": [
                    {
                        "username": "sulicn",
                        "content": "Can I report those idiots that are still posting solutions here?"
                    },
                    {
                        "username": "Wolfoo",
                        "content": "I think it\\'s easy not medium"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "alalalaa",
                        "content": "double it and give it to the next person\\n"
                    },
                    {
                        "username": "Luojihencha",
                        "content": "I paied a lot of money for leetcode......and still there is no answer. Leetcode please, all questions are hard for me."
                    },
                    {
                        "username": "jy0819",
                        "content": "bro it\\'s been 3 years hope your luoji becomes better now lol"
                    },
                    {
                        "username": "alalalaa",
                        "content": "ask someone who knows how to code to make you connect the dots"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "IHxRK28",
                        "content": "I dont know whether this is a troll statement or not but heres your motivation and tips/advice \\n\\nYou could just follow famous playlists on youtube - \\nSo theres this Indian Guy called striver (Channel Name - TakeuForward) more than half of his videos are in english, You should follow that and I can definitely say You will get better at it. From what I know and understand, You get better at coding with practice which might take different time for different people, so if you are interested in coding keep at it.  "
                    },
                    {
                        "username": "umnik",
                        "content": "I know the easy way of solving this problem is using **23 case** statements (10 for numbers [1-10], 10 for [10-100], 10 for [1000-3000]). But the code does not look good and it's getting bit long. I'm thinking even applying the rules for converting may also make the code complex. Any suggestions?"
                    },
                    {
                        "username": "androidcarson",
                        "content": "[@AdityaBhate](/AdityaBhate) downvoted for using emojis"
                    },
                    {
                        "username": "tolem",
                        "content": "yeah it can  even be solved in 10 to 11 case checks "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you might wanna take a look into this [solution](https://leetcode.com/problems/integer-to-roman/solutions/2726838/c-solution/?orderBy=most_votes)"
                    },
                    {
                        "username": "selvablaze",
                        "content": "[@lucayan0506](/lucayan0506) class Solution {\\n    public String getValue(int val, int pos, HashMap<Integer, String> map){\\n        int value = val * (int) Math.pow(10, pos-1);\\n        String answer = \"\";\\n        if(map.containsKey(value))\\n            return map.get(value);\\n        int upperBound = (int) Math.pow(10,pos);\\n        int midBound = (int) Math.pow(10,pos)/2;\\n        int lowerBound = (int) Math.pow(10, pos-1);\\n        if(val == 4)\\n            answer = map.get(lowerBound) + map.get(midBound);\\n        else if(val == 9 )\\n            answer = map.get(lowerBound) + map.get(upperBound);   \\n        else if(val < 4)\\n            answer = map.get(lowerBound).repeat(val);\\n        else if(val > 5)\\n            answer =  map.get(midBound) + map.get(lowerBound).repeat(val-5);   \\n        map.put(value, answer);\\n        return answer;              \\n    }\\n    public String intToRoman(int num) {\\n        String answer = \"\";\\n        int i = 1;\\n        HashMap<Integer,String> map = new HashMap<>();\\n        map.put(1, \"I\" );\\n        map.put(5, \"V\" );\\n        map.put(10, \"X\" );\\n        map.put(50, \"L\" );\\n        map.put(100, \"C\" );\\n        map.put(500, \"D\" );\\n        map.put(1000, \"M\");\\n        while(num>0){\\n            answer = getValue(num%10, i, map) + answer;\\n            num = num/10;\\n            i++;\\n        }\\n        return answer;\\n    }\\n}"
                    },
                    {
                        "username": "lucayan0506",
                        "content": "I would suggest use map (where you save the value in decimal and the value in roman) `m[1000] = \"M\"    m[900] = \"CM\"`.\nOr you can you use 2 array (one for decimal number, one for roman number) `decimal_number[0] = 1000 roman_number[0] = \"M\"`\nThen use a for loop, instead of 23 case statement"
                    },
                    {
                        "username": "Amax",
                        "content": "For example: how do you spell 1999 in roman?\\nMIM or MCMXCIX?"
                    },
                    {
                        "username": "RittikChaudhary",
                        "content": "[@VinayPatidar](/VinayPatidar) bhai 1001 ho skta hai \"MI\""
                    },
                    {
                        "username": "Kei_Chen",
                        "content": "[@VinayPatidar](/VinayPatidar) Actually I after M is allowed, for example: to write 1001, we can use MI"
                    },
                    {
                        "username": "arthur326",
                        "content": "Yeah, just from the information given in the question, 10 could be written as IX or VIV, right? (This does not violate the subtraction cases they give.) Are we allowed to return either representation? The question should be clearer..."
                    },
                    {
                        "username": "lolo101",
                        "content": "MCMXCIX\\nYou cannot write \"IM\" because you may only remove the previous power of ten to a power of ten.\\nFor instance \"IX\", \"XC\", \"CM\" are allowed. But \"IC\", \"IM\", \"XM\" are not."
                    },
                    {
                        "username": "VinayPatidar",
                        "content": "second one\\nyou cannot have I before or after M"
                    },
                    {
                        "username": "ozkansafak",
                        "content": "[@Kram_](/Kram_) Why? What\\'s the rule we\\'re trying to capture in the code?"
                    },
                    {
                        "username": "abdallahg2120",
                        "content": "According to roman rule which I see in problem description.\\nI think the right answer is MCMXCIX.\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "10 years later, we still have the same doubt!"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Oh man it\\'s been 10 years for this comment."
                    },
                    {
                        "username": "snoyes",
                        "content": "In modern standard use, the only subtractive forms are IV, IX, XL, XC, CD, and CM, so MIM wouldn\\'t be allowed. In medieval and earlier times, usage was all over the place, so there\\'s no telling "
                    },
                    {
                        "username": "Kram_",
                        "content": "The second one"
                    },
                    {
                        "username": "YuriiHryniv",
                        "content": "I bought leetcode subscription but this problem seems very hard to me :((. Unsubscribe, I thought I would get into FAANG"
                    },
                    {
                        "username": "AseCantCode",
                        "content": "[@Artsapollo](/Artsapollo) dude he is just joking"
                    },
                    {
                        "username": "Artsapollo",
                        "content": "Dude, try before pay"
                    },
                    {
                        "username": "ztia0004",
                        "content": "I just don\\'t know the point of this question, it\\'s like wasting my time to understand something I do not want to know, rather than coding practice"
                    },
                    {
                        "username": "mayankK135",
                        "content": "Like all DSA problem you solve, it\\'s also to teach how problem solving skill, off course you won\\'t need it in real world"
                    },
                    {
                        "username": "AseCantCode",
                        "content": "[@georgezakharov](/georgezakharov) lmao\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Tell it on an interview :)"
                    },
                    {
                        "username": "ranjeetmadhaviitd",
                        "content": "[Watch](https://www.youtube.com/watch?v=wvpe4ldKTW0) this video for the better explanation of the solution.\\nhttps://www.youtube.com/watch?v=wvpe4ldKTW0\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution."
                    },
                    {
                        "username": "suren-yeager",
                        "content": "this isnt the correct question !!"
                    },
                    {
                        "username": "heshan16",
                        "content": "Er,for example,actually, the roman integer of 49 should be IL?But in this problem,the input of 49 should be output LXIX.So there result would not  the true roman numbers"
                    },
                    {
                        "username": "ivstarkov",
                        "content": "[@xcelr8](/xcelr8) 49 is XLIX. LXIX isnt possible."
                    },
                    {
                        "username": "dtwiers",
                        "content": "In the most loosely-defined version of Roman numerals, yes, IL would be correct. But in the more rigorously defined version, you can only use the next-highest order of 10 unit lower than a number to subtract from a large number - so IM isn\\'t a thing for 999, but CM will get you 900 because C is the next highest power of 10 below 1000. You then get XC (100 - 10), and IX (10 - 1), so 999 is CMXCIX"
                    },
                    {
                        "username": "dtwiers",
                        "content": "[@xcelr8](/xcelr8) that is 69. 49 is XLIX."
                    },
                    {
                        "username": "xcelr8",
                        "content": "49 is LXIX in roman"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "class Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string ans=\"\";\\n        while(num>=1000){\\n            ans+=\"M\";\\n            num-=1000;\\n        }\\n        while(num>=900){\\n            ans+=\"CM\";\\n            num-=900;\\n        }\\n        while(num>=500){\\n            ans+=\"D\";\\n            num-=500;\\n        }\\n        while(num>=400){\\n            ans+=\"CD\";\\n            num-=400;\\n        }\\n        while(num>=100){\\n            ans+=\"C\";\\n            num-=100;\\n        }\\n        while(num>=90){\\n            ans+=\"XC\";\\n            num-=90;\\n        }\\n        while(num>=50){\\n            ans+=\"L\";\\n            num-=50;\\n        }\\n        while(num>=40){\\n            ans+=\"XL\";\\n            num-=40;\\n        }\\n        while(num>=10){\\n            ans+=\"X\";\\n            num-=10;\\n        }\\n        while(num>=9){\\n            ans+=\"IX\";\\n            num-=9;\\n        }\\n        while(num>=5){\\n            ans+=\"V\";\\n            num-=5;\\n        }\\n        while(num>=4){\\n            ans+=\"IV\";\\n            num-=4;\\n        }\\n        while(num>=1){\\n            ans+=\"I\";\\n            num-=1;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sulicn",
                        "content": "[@user9666yo](/user9666yo) Is it allowed to post answers here in discussion?@Deepak_8811"
                    },
                    {
                        "username": "user9666yo",
                        "content": "//criado objeto com a correspondencia dos valores\\nconst symbols = {\\n  \\'I\\': 1,\\n  \\'V\\': 5,\\n  \\'X\\': 10,\\n  \\'L\\': 50,\\n  \\'C\\': 100,\\n  \\'D\\': 500,\\n  \\'M\\': 1000,\\n};\\n\\n//fun\\xE7ao contador total\\nfunction romanToInt(s) {\\n  let total = 0;\\n\\n//percorrer cada algarismo\\n  for (let i = 0; i < s.length; ++i) {\\n    const num1 = symbols[s[i]];\\n    const num2 = symbols[s[i + 1]];\\n\\n    if (num1 < num2) {\\n      total -= num1;\\n    } else {\\n      total += num1;\\n    }\\n  }\\n//retorna o total\\n  return total;\\n}\\n"
                    }
                ]
            },
            {
                "id": 1652407,
                "content": [
                    {
                        "username": "sulicn",
                        "content": "Can I report those idiots that are still posting solutions here?"
                    },
                    {
                        "username": "Wolfoo",
                        "content": "I think it\\'s easy not medium"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "alalalaa",
                        "content": "double it and give it to the next person\\n"
                    },
                    {
                        "username": "Luojihencha",
                        "content": "I paied a lot of money for leetcode......and still there is no answer. Leetcode please, all questions are hard for me."
                    },
                    {
                        "username": "jy0819",
                        "content": "bro it\\'s been 3 years hope your luoji becomes better now lol"
                    },
                    {
                        "username": "alalalaa",
                        "content": "ask someone who knows how to code to make you connect the dots"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "IHxRK28",
                        "content": "I dont know whether this is a troll statement or not but heres your motivation and tips/advice \\n\\nYou could just follow famous playlists on youtube - \\nSo theres this Indian Guy called striver (Channel Name - TakeuForward) more than half of his videos are in english, You should follow that and I can definitely say You will get better at it. From what I know and understand, You get better at coding with practice which might take different time for different people, so if you are interested in coding keep at it.  "
                    },
                    {
                        "username": "umnik",
                        "content": "I know the easy way of solving this problem is using **23 case** statements (10 for numbers [1-10], 10 for [10-100], 10 for [1000-3000]). But the code does not look good and it's getting bit long. I'm thinking even applying the rules for converting may also make the code complex. Any suggestions?"
                    },
                    {
                        "username": "androidcarson",
                        "content": "[@AdityaBhate](/AdityaBhate) downvoted for using emojis"
                    },
                    {
                        "username": "tolem",
                        "content": "yeah it can  even be solved in 10 to 11 case checks "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you might wanna take a look into this [solution](https://leetcode.com/problems/integer-to-roman/solutions/2726838/c-solution/?orderBy=most_votes)"
                    },
                    {
                        "username": "selvablaze",
                        "content": "[@lucayan0506](/lucayan0506) class Solution {\\n    public String getValue(int val, int pos, HashMap<Integer, String> map){\\n        int value = val * (int) Math.pow(10, pos-1);\\n        String answer = \"\";\\n        if(map.containsKey(value))\\n            return map.get(value);\\n        int upperBound = (int) Math.pow(10,pos);\\n        int midBound = (int) Math.pow(10,pos)/2;\\n        int lowerBound = (int) Math.pow(10, pos-1);\\n        if(val == 4)\\n            answer = map.get(lowerBound) + map.get(midBound);\\n        else if(val == 9 )\\n            answer = map.get(lowerBound) + map.get(upperBound);   \\n        else if(val < 4)\\n            answer = map.get(lowerBound).repeat(val);\\n        else if(val > 5)\\n            answer =  map.get(midBound) + map.get(lowerBound).repeat(val-5);   \\n        map.put(value, answer);\\n        return answer;              \\n    }\\n    public String intToRoman(int num) {\\n        String answer = \"\";\\n        int i = 1;\\n        HashMap<Integer,String> map = new HashMap<>();\\n        map.put(1, \"I\" );\\n        map.put(5, \"V\" );\\n        map.put(10, \"X\" );\\n        map.put(50, \"L\" );\\n        map.put(100, \"C\" );\\n        map.put(500, \"D\" );\\n        map.put(1000, \"M\");\\n        while(num>0){\\n            answer = getValue(num%10, i, map) + answer;\\n            num = num/10;\\n            i++;\\n        }\\n        return answer;\\n    }\\n}"
                    },
                    {
                        "username": "lucayan0506",
                        "content": "I would suggest use map (where you save the value in decimal and the value in roman) `m[1000] = \"M\"    m[900] = \"CM\"`.\nOr you can you use 2 array (one for decimal number, one for roman number) `decimal_number[0] = 1000 roman_number[0] = \"M\"`\nThen use a for loop, instead of 23 case statement"
                    },
                    {
                        "username": "Amax",
                        "content": "For example: how do you spell 1999 in roman?\\nMIM or MCMXCIX?"
                    },
                    {
                        "username": "RittikChaudhary",
                        "content": "[@VinayPatidar](/VinayPatidar) bhai 1001 ho skta hai \"MI\""
                    },
                    {
                        "username": "Kei_Chen",
                        "content": "[@VinayPatidar](/VinayPatidar) Actually I after M is allowed, for example: to write 1001, we can use MI"
                    },
                    {
                        "username": "arthur326",
                        "content": "Yeah, just from the information given in the question, 10 could be written as IX or VIV, right? (This does not violate the subtraction cases they give.) Are we allowed to return either representation? The question should be clearer..."
                    },
                    {
                        "username": "lolo101",
                        "content": "MCMXCIX\\nYou cannot write \"IM\" because you may only remove the previous power of ten to a power of ten.\\nFor instance \"IX\", \"XC\", \"CM\" are allowed. But \"IC\", \"IM\", \"XM\" are not."
                    },
                    {
                        "username": "VinayPatidar",
                        "content": "second one\\nyou cannot have I before or after M"
                    },
                    {
                        "username": "ozkansafak",
                        "content": "[@Kram_](/Kram_) Why? What\\'s the rule we\\'re trying to capture in the code?"
                    },
                    {
                        "username": "abdallahg2120",
                        "content": "According to roman rule which I see in problem description.\\nI think the right answer is MCMXCIX.\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "10 years later, we still have the same doubt!"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Oh man it\\'s been 10 years for this comment."
                    },
                    {
                        "username": "snoyes",
                        "content": "In modern standard use, the only subtractive forms are IV, IX, XL, XC, CD, and CM, so MIM wouldn\\'t be allowed. In medieval and earlier times, usage was all over the place, so there\\'s no telling "
                    },
                    {
                        "username": "Kram_",
                        "content": "The second one"
                    },
                    {
                        "username": "YuriiHryniv",
                        "content": "I bought leetcode subscription but this problem seems very hard to me :((. Unsubscribe, I thought I would get into FAANG"
                    },
                    {
                        "username": "AseCantCode",
                        "content": "[@Artsapollo](/Artsapollo) dude he is just joking"
                    },
                    {
                        "username": "Artsapollo",
                        "content": "Dude, try before pay"
                    },
                    {
                        "username": "ztia0004",
                        "content": "I just don\\'t know the point of this question, it\\'s like wasting my time to understand something I do not want to know, rather than coding practice"
                    },
                    {
                        "username": "mayankK135",
                        "content": "Like all DSA problem you solve, it\\'s also to teach how problem solving skill, off course you won\\'t need it in real world"
                    },
                    {
                        "username": "AseCantCode",
                        "content": "[@georgezakharov](/georgezakharov) lmao\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Tell it on an interview :)"
                    },
                    {
                        "username": "ranjeetmadhaviitd",
                        "content": "[Watch](https://www.youtube.com/watch?v=wvpe4ldKTW0) this video for the better explanation of the solution.\\nhttps://www.youtube.com/watch?v=wvpe4ldKTW0\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution."
                    },
                    {
                        "username": "suren-yeager",
                        "content": "this isnt the correct question !!"
                    },
                    {
                        "username": "heshan16",
                        "content": "Er,for example,actually, the roman integer of 49 should be IL?But in this problem,the input of 49 should be output LXIX.So there result would not  the true roman numbers"
                    },
                    {
                        "username": "ivstarkov",
                        "content": "[@xcelr8](/xcelr8) 49 is XLIX. LXIX isnt possible."
                    },
                    {
                        "username": "dtwiers",
                        "content": "In the most loosely-defined version of Roman numerals, yes, IL would be correct. But in the more rigorously defined version, you can only use the next-highest order of 10 unit lower than a number to subtract from a large number - so IM isn\\'t a thing for 999, but CM will get you 900 because C is the next highest power of 10 below 1000. You then get XC (100 - 10), and IX (10 - 1), so 999 is CMXCIX"
                    },
                    {
                        "username": "dtwiers",
                        "content": "[@xcelr8](/xcelr8) that is 69. 49 is XLIX."
                    },
                    {
                        "username": "xcelr8",
                        "content": "49 is LXIX in roman"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "class Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string ans=\"\";\\n        while(num>=1000){\\n            ans+=\"M\";\\n            num-=1000;\\n        }\\n        while(num>=900){\\n            ans+=\"CM\";\\n            num-=900;\\n        }\\n        while(num>=500){\\n            ans+=\"D\";\\n            num-=500;\\n        }\\n        while(num>=400){\\n            ans+=\"CD\";\\n            num-=400;\\n        }\\n        while(num>=100){\\n            ans+=\"C\";\\n            num-=100;\\n        }\\n        while(num>=90){\\n            ans+=\"XC\";\\n            num-=90;\\n        }\\n        while(num>=50){\\n            ans+=\"L\";\\n            num-=50;\\n        }\\n        while(num>=40){\\n            ans+=\"XL\";\\n            num-=40;\\n        }\\n        while(num>=10){\\n            ans+=\"X\";\\n            num-=10;\\n        }\\n        while(num>=9){\\n            ans+=\"IX\";\\n            num-=9;\\n        }\\n        while(num>=5){\\n            ans+=\"V\";\\n            num-=5;\\n        }\\n        while(num>=4){\\n            ans+=\"IV\";\\n            num-=4;\\n        }\\n        while(num>=1){\\n            ans+=\"I\";\\n            num-=1;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sulicn",
                        "content": "[@user9666yo](/user9666yo) Is it allowed to post answers here in discussion?@Deepak_8811"
                    },
                    {
                        "username": "user9666yo",
                        "content": "//criado objeto com a correspondencia dos valores\\nconst symbols = {\\n  \\'I\\': 1,\\n  \\'V\\': 5,\\n  \\'X\\': 10,\\n  \\'L\\': 50,\\n  \\'C\\': 100,\\n  \\'D\\': 500,\\n  \\'M\\': 1000,\\n};\\n\\n//fun\\xE7ao contador total\\nfunction romanToInt(s) {\\n  let total = 0;\\n\\n//percorrer cada algarismo\\n  for (let i = 0; i < s.length; ++i) {\\n    const num1 = symbols[s[i]];\\n    const num2 = symbols[s[i + 1]];\\n\\n    if (num1 < num2) {\\n      total -= num1;\\n    } else {\\n      total += num1;\\n    }\\n  }\\n//retorna o total\\n  return total;\\n}\\n"
                    }
                ]
            },
            {
                "id": 1571035,
                "content": [
                    {
                        "username": "sulicn",
                        "content": "Can I report those idiots that are still posting solutions here?"
                    },
                    {
                        "username": "Wolfoo",
                        "content": "I think it\\'s easy not medium"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "alalalaa",
                        "content": "double it and give it to the next person\\n"
                    },
                    {
                        "username": "Luojihencha",
                        "content": "I paied a lot of money for leetcode......and still there is no answer. Leetcode please, all questions are hard for me."
                    },
                    {
                        "username": "jy0819",
                        "content": "bro it\\'s been 3 years hope your luoji becomes better now lol"
                    },
                    {
                        "username": "alalalaa",
                        "content": "ask someone who knows how to code to make you connect the dots"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "IHxRK28",
                        "content": "I dont know whether this is a troll statement or not but heres your motivation and tips/advice \\n\\nYou could just follow famous playlists on youtube - \\nSo theres this Indian Guy called striver (Channel Name - TakeuForward) more than half of his videos are in english, You should follow that and I can definitely say You will get better at it. From what I know and understand, You get better at coding with practice which might take different time for different people, so if you are interested in coding keep at it.  "
                    },
                    {
                        "username": "umnik",
                        "content": "I know the easy way of solving this problem is using **23 case** statements (10 for numbers [1-10], 10 for [10-100], 10 for [1000-3000]). But the code does not look good and it's getting bit long. I'm thinking even applying the rules for converting may also make the code complex. Any suggestions?"
                    },
                    {
                        "username": "androidcarson",
                        "content": "[@AdityaBhate](/AdityaBhate) downvoted for using emojis"
                    },
                    {
                        "username": "tolem",
                        "content": "yeah it can  even be solved in 10 to 11 case checks "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you might wanna take a look into this [solution](https://leetcode.com/problems/integer-to-roman/solutions/2726838/c-solution/?orderBy=most_votes)"
                    },
                    {
                        "username": "selvablaze",
                        "content": "[@lucayan0506](/lucayan0506) class Solution {\\n    public String getValue(int val, int pos, HashMap<Integer, String> map){\\n        int value = val * (int) Math.pow(10, pos-1);\\n        String answer = \"\";\\n        if(map.containsKey(value))\\n            return map.get(value);\\n        int upperBound = (int) Math.pow(10,pos);\\n        int midBound = (int) Math.pow(10,pos)/2;\\n        int lowerBound = (int) Math.pow(10, pos-1);\\n        if(val == 4)\\n            answer = map.get(lowerBound) + map.get(midBound);\\n        else if(val == 9 )\\n            answer = map.get(lowerBound) + map.get(upperBound);   \\n        else if(val < 4)\\n            answer = map.get(lowerBound).repeat(val);\\n        else if(val > 5)\\n            answer =  map.get(midBound) + map.get(lowerBound).repeat(val-5);   \\n        map.put(value, answer);\\n        return answer;              \\n    }\\n    public String intToRoman(int num) {\\n        String answer = \"\";\\n        int i = 1;\\n        HashMap<Integer,String> map = new HashMap<>();\\n        map.put(1, \"I\" );\\n        map.put(5, \"V\" );\\n        map.put(10, \"X\" );\\n        map.put(50, \"L\" );\\n        map.put(100, \"C\" );\\n        map.put(500, \"D\" );\\n        map.put(1000, \"M\");\\n        while(num>0){\\n            answer = getValue(num%10, i, map) + answer;\\n            num = num/10;\\n            i++;\\n        }\\n        return answer;\\n    }\\n}"
                    },
                    {
                        "username": "lucayan0506",
                        "content": "I would suggest use map (where you save the value in decimal and the value in roman) `m[1000] = \"M\"    m[900] = \"CM\"`.\nOr you can you use 2 array (one for decimal number, one for roman number) `decimal_number[0] = 1000 roman_number[0] = \"M\"`\nThen use a for loop, instead of 23 case statement"
                    },
                    {
                        "username": "Amax",
                        "content": "For example: how do you spell 1999 in roman?\\nMIM or MCMXCIX?"
                    },
                    {
                        "username": "RittikChaudhary",
                        "content": "[@VinayPatidar](/VinayPatidar) bhai 1001 ho skta hai \"MI\""
                    },
                    {
                        "username": "Kei_Chen",
                        "content": "[@VinayPatidar](/VinayPatidar) Actually I after M is allowed, for example: to write 1001, we can use MI"
                    },
                    {
                        "username": "arthur326",
                        "content": "Yeah, just from the information given in the question, 10 could be written as IX or VIV, right? (This does not violate the subtraction cases they give.) Are we allowed to return either representation? The question should be clearer..."
                    },
                    {
                        "username": "lolo101",
                        "content": "MCMXCIX\\nYou cannot write \"IM\" because you may only remove the previous power of ten to a power of ten.\\nFor instance \"IX\", \"XC\", \"CM\" are allowed. But \"IC\", \"IM\", \"XM\" are not."
                    },
                    {
                        "username": "VinayPatidar",
                        "content": "second one\\nyou cannot have I before or after M"
                    },
                    {
                        "username": "ozkansafak",
                        "content": "[@Kram_](/Kram_) Why? What\\'s the rule we\\'re trying to capture in the code?"
                    },
                    {
                        "username": "abdallahg2120",
                        "content": "According to roman rule which I see in problem description.\\nI think the right answer is MCMXCIX.\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "10 years later, we still have the same doubt!"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Oh man it\\'s been 10 years for this comment."
                    },
                    {
                        "username": "snoyes",
                        "content": "In modern standard use, the only subtractive forms are IV, IX, XL, XC, CD, and CM, so MIM wouldn\\'t be allowed. In medieval and earlier times, usage was all over the place, so there\\'s no telling "
                    },
                    {
                        "username": "Kram_",
                        "content": "The second one"
                    },
                    {
                        "username": "YuriiHryniv",
                        "content": "I bought leetcode subscription but this problem seems very hard to me :((. Unsubscribe, I thought I would get into FAANG"
                    },
                    {
                        "username": "AseCantCode",
                        "content": "[@Artsapollo](/Artsapollo) dude he is just joking"
                    },
                    {
                        "username": "Artsapollo",
                        "content": "Dude, try before pay"
                    },
                    {
                        "username": "ztia0004",
                        "content": "I just don\\'t know the point of this question, it\\'s like wasting my time to understand something I do not want to know, rather than coding practice"
                    },
                    {
                        "username": "mayankK135",
                        "content": "Like all DSA problem you solve, it\\'s also to teach how problem solving skill, off course you won\\'t need it in real world"
                    },
                    {
                        "username": "AseCantCode",
                        "content": "[@georgezakharov](/georgezakharov) lmao\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Tell it on an interview :)"
                    },
                    {
                        "username": "ranjeetmadhaviitd",
                        "content": "[Watch](https://www.youtube.com/watch?v=wvpe4ldKTW0) this video for the better explanation of the solution.\\nhttps://www.youtube.com/watch?v=wvpe4ldKTW0\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution."
                    },
                    {
                        "username": "suren-yeager",
                        "content": "this isnt the correct question !!"
                    },
                    {
                        "username": "heshan16",
                        "content": "Er,for example,actually, the roman integer of 49 should be IL?But in this problem,the input of 49 should be output LXIX.So there result would not  the true roman numbers"
                    },
                    {
                        "username": "ivstarkov",
                        "content": "[@xcelr8](/xcelr8) 49 is XLIX. LXIX isnt possible."
                    },
                    {
                        "username": "dtwiers",
                        "content": "In the most loosely-defined version of Roman numerals, yes, IL would be correct. But in the more rigorously defined version, you can only use the next-highest order of 10 unit lower than a number to subtract from a large number - so IM isn\\'t a thing for 999, but CM will get you 900 because C is the next highest power of 10 below 1000. You then get XC (100 - 10), and IX (10 - 1), so 999 is CMXCIX"
                    },
                    {
                        "username": "dtwiers",
                        "content": "[@xcelr8](/xcelr8) that is 69. 49 is XLIX."
                    },
                    {
                        "username": "xcelr8",
                        "content": "49 is LXIX in roman"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "class Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string ans=\"\";\\n        while(num>=1000){\\n            ans+=\"M\";\\n            num-=1000;\\n        }\\n        while(num>=900){\\n            ans+=\"CM\";\\n            num-=900;\\n        }\\n        while(num>=500){\\n            ans+=\"D\";\\n            num-=500;\\n        }\\n        while(num>=400){\\n            ans+=\"CD\";\\n            num-=400;\\n        }\\n        while(num>=100){\\n            ans+=\"C\";\\n            num-=100;\\n        }\\n        while(num>=90){\\n            ans+=\"XC\";\\n            num-=90;\\n        }\\n        while(num>=50){\\n            ans+=\"L\";\\n            num-=50;\\n        }\\n        while(num>=40){\\n            ans+=\"XL\";\\n            num-=40;\\n        }\\n        while(num>=10){\\n            ans+=\"X\";\\n            num-=10;\\n        }\\n        while(num>=9){\\n            ans+=\"IX\";\\n            num-=9;\\n        }\\n        while(num>=5){\\n            ans+=\"V\";\\n            num-=5;\\n        }\\n        while(num>=4){\\n            ans+=\"IV\";\\n            num-=4;\\n        }\\n        while(num>=1){\\n            ans+=\"I\";\\n            num-=1;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sulicn",
                        "content": "[@user9666yo](/user9666yo) Is it allowed to post answers here in discussion?@Deepak_8811"
                    },
                    {
                        "username": "user9666yo",
                        "content": "//criado objeto com a correspondencia dos valores\\nconst symbols = {\\n  \\'I\\': 1,\\n  \\'V\\': 5,\\n  \\'X\\': 10,\\n  \\'L\\': 50,\\n  \\'C\\': 100,\\n  \\'D\\': 500,\\n  \\'M\\': 1000,\\n};\\n\\n//fun\\xE7ao contador total\\nfunction romanToInt(s) {\\n  let total = 0;\\n\\n//percorrer cada algarismo\\n  for (let i = 0; i < s.length; ++i) {\\n    const num1 = symbols[s[i]];\\n    const num2 = symbols[s[i + 1]];\\n\\n    if (num1 < num2) {\\n      total -= num1;\\n    } else {\\n      total += num1;\\n    }\\n  }\\n//retorna o total\\n  return total;\\n}\\n"
                    }
                ]
            },
            {
                "id": 1778211,
                "content": [
                    {
                        "username": "sulicn",
                        "content": "Can I report those idiots that are still posting solutions here?"
                    },
                    {
                        "username": "Wolfoo",
                        "content": "I think it\\'s easy not medium"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "alalalaa",
                        "content": "double it and give it to the next person\\n"
                    },
                    {
                        "username": "Luojihencha",
                        "content": "I paied a lot of money for leetcode......and still there is no answer. Leetcode please, all questions are hard for me."
                    },
                    {
                        "username": "jy0819",
                        "content": "bro it\\'s been 3 years hope your luoji becomes better now lol"
                    },
                    {
                        "username": "alalalaa",
                        "content": "ask someone who knows how to code to make you connect the dots"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "IHxRK28",
                        "content": "I dont know whether this is a troll statement or not but heres your motivation and tips/advice \\n\\nYou could just follow famous playlists on youtube - \\nSo theres this Indian Guy called striver (Channel Name - TakeuForward) more than half of his videos are in english, You should follow that and I can definitely say You will get better at it. From what I know and understand, You get better at coding with practice which might take different time for different people, so if you are interested in coding keep at it.  "
                    },
                    {
                        "username": "umnik",
                        "content": "I know the easy way of solving this problem is using **23 case** statements (10 for numbers [1-10], 10 for [10-100], 10 for [1000-3000]). But the code does not look good and it's getting bit long. I'm thinking even applying the rules for converting may also make the code complex. Any suggestions?"
                    },
                    {
                        "username": "androidcarson",
                        "content": "[@AdityaBhate](/AdityaBhate) downvoted for using emojis"
                    },
                    {
                        "username": "tolem",
                        "content": "yeah it can  even be solved in 10 to 11 case checks "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you might wanna take a look into this [solution](https://leetcode.com/problems/integer-to-roman/solutions/2726838/c-solution/?orderBy=most_votes)"
                    },
                    {
                        "username": "selvablaze",
                        "content": "[@lucayan0506](/lucayan0506) class Solution {\\n    public String getValue(int val, int pos, HashMap<Integer, String> map){\\n        int value = val * (int) Math.pow(10, pos-1);\\n        String answer = \"\";\\n        if(map.containsKey(value))\\n            return map.get(value);\\n        int upperBound = (int) Math.pow(10,pos);\\n        int midBound = (int) Math.pow(10,pos)/2;\\n        int lowerBound = (int) Math.pow(10, pos-1);\\n        if(val == 4)\\n            answer = map.get(lowerBound) + map.get(midBound);\\n        else if(val == 9 )\\n            answer = map.get(lowerBound) + map.get(upperBound);   \\n        else if(val < 4)\\n            answer = map.get(lowerBound).repeat(val);\\n        else if(val > 5)\\n            answer =  map.get(midBound) + map.get(lowerBound).repeat(val-5);   \\n        map.put(value, answer);\\n        return answer;              \\n    }\\n    public String intToRoman(int num) {\\n        String answer = \"\";\\n        int i = 1;\\n        HashMap<Integer,String> map = new HashMap<>();\\n        map.put(1, \"I\" );\\n        map.put(5, \"V\" );\\n        map.put(10, \"X\" );\\n        map.put(50, \"L\" );\\n        map.put(100, \"C\" );\\n        map.put(500, \"D\" );\\n        map.put(1000, \"M\");\\n        while(num>0){\\n            answer = getValue(num%10, i, map) + answer;\\n            num = num/10;\\n            i++;\\n        }\\n        return answer;\\n    }\\n}"
                    },
                    {
                        "username": "lucayan0506",
                        "content": "I would suggest use map (where you save the value in decimal and the value in roman) `m[1000] = \"M\"    m[900] = \"CM\"`.\nOr you can you use 2 array (one for decimal number, one for roman number) `decimal_number[0] = 1000 roman_number[0] = \"M\"`\nThen use a for loop, instead of 23 case statement"
                    },
                    {
                        "username": "Amax",
                        "content": "For example: how do you spell 1999 in roman?\\nMIM or MCMXCIX?"
                    },
                    {
                        "username": "RittikChaudhary",
                        "content": "[@VinayPatidar](/VinayPatidar) bhai 1001 ho skta hai \"MI\""
                    },
                    {
                        "username": "Kei_Chen",
                        "content": "[@VinayPatidar](/VinayPatidar) Actually I after M is allowed, for example: to write 1001, we can use MI"
                    },
                    {
                        "username": "arthur326",
                        "content": "Yeah, just from the information given in the question, 10 could be written as IX or VIV, right? (This does not violate the subtraction cases they give.) Are we allowed to return either representation? The question should be clearer..."
                    },
                    {
                        "username": "lolo101",
                        "content": "MCMXCIX\\nYou cannot write \"IM\" because you may only remove the previous power of ten to a power of ten.\\nFor instance \"IX\", \"XC\", \"CM\" are allowed. But \"IC\", \"IM\", \"XM\" are not."
                    },
                    {
                        "username": "VinayPatidar",
                        "content": "second one\\nyou cannot have I before or after M"
                    },
                    {
                        "username": "ozkansafak",
                        "content": "[@Kram_](/Kram_) Why? What\\'s the rule we\\'re trying to capture in the code?"
                    },
                    {
                        "username": "abdallahg2120",
                        "content": "According to roman rule which I see in problem description.\\nI think the right answer is MCMXCIX.\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "10 years later, we still have the same doubt!"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Oh man it\\'s been 10 years for this comment."
                    },
                    {
                        "username": "snoyes",
                        "content": "In modern standard use, the only subtractive forms are IV, IX, XL, XC, CD, and CM, so MIM wouldn\\'t be allowed. In medieval and earlier times, usage was all over the place, so there\\'s no telling "
                    },
                    {
                        "username": "Kram_",
                        "content": "The second one"
                    },
                    {
                        "username": "YuriiHryniv",
                        "content": "I bought leetcode subscription but this problem seems very hard to me :((. Unsubscribe, I thought I would get into FAANG"
                    },
                    {
                        "username": "AseCantCode",
                        "content": "[@Artsapollo](/Artsapollo) dude he is just joking"
                    },
                    {
                        "username": "Artsapollo",
                        "content": "Dude, try before pay"
                    },
                    {
                        "username": "ztia0004",
                        "content": "I just don\\'t know the point of this question, it\\'s like wasting my time to understand something I do not want to know, rather than coding practice"
                    },
                    {
                        "username": "mayankK135",
                        "content": "Like all DSA problem you solve, it\\'s also to teach how problem solving skill, off course you won\\'t need it in real world"
                    },
                    {
                        "username": "AseCantCode",
                        "content": "[@georgezakharov](/georgezakharov) lmao\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Tell it on an interview :)"
                    },
                    {
                        "username": "ranjeetmadhaviitd",
                        "content": "[Watch](https://www.youtube.com/watch?v=wvpe4ldKTW0) this video for the better explanation of the solution.\\nhttps://www.youtube.com/watch?v=wvpe4ldKTW0\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution."
                    },
                    {
                        "username": "suren-yeager",
                        "content": "this isnt the correct question !!"
                    },
                    {
                        "username": "heshan16",
                        "content": "Er,for example,actually, the roman integer of 49 should be IL?But in this problem,the input of 49 should be output LXIX.So there result would not  the true roman numbers"
                    },
                    {
                        "username": "ivstarkov",
                        "content": "[@xcelr8](/xcelr8) 49 is XLIX. LXIX isnt possible."
                    },
                    {
                        "username": "dtwiers",
                        "content": "In the most loosely-defined version of Roman numerals, yes, IL would be correct. But in the more rigorously defined version, you can only use the next-highest order of 10 unit lower than a number to subtract from a large number - so IM isn\\'t a thing for 999, but CM will get you 900 because C is the next highest power of 10 below 1000. You then get XC (100 - 10), and IX (10 - 1), so 999 is CMXCIX"
                    },
                    {
                        "username": "dtwiers",
                        "content": "[@xcelr8](/xcelr8) that is 69. 49 is XLIX."
                    },
                    {
                        "username": "xcelr8",
                        "content": "49 is LXIX in roman"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "class Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string ans=\"\";\\n        while(num>=1000){\\n            ans+=\"M\";\\n            num-=1000;\\n        }\\n        while(num>=900){\\n            ans+=\"CM\";\\n            num-=900;\\n        }\\n        while(num>=500){\\n            ans+=\"D\";\\n            num-=500;\\n        }\\n        while(num>=400){\\n            ans+=\"CD\";\\n            num-=400;\\n        }\\n        while(num>=100){\\n            ans+=\"C\";\\n            num-=100;\\n        }\\n        while(num>=90){\\n            ans+=\"XC\";\\n            num-=90;\\n        }\\n        while(num>=50){\\n            ans+=\"L\";\\n            num-=50;\\n        }\\n        while(num>=40){\\n            ans+=\"XL\";\\n            num-=40;\\n        }\\n        while(num>=10){\\n            ans+=\"X\";\\n            num-=10;\\n        }\\n        while(num>=9){\\n            ans+=\"IX\";\\n            num-=9;\\n        }\\n        while(num>=5){\\n            ans+=\"V\";\\n            num-=5;\\n        }\\n        while(num>=4){\\n            ans+=\"IV\";\\n            num-=4;\\n        }\\n        while(num>=1){\\n            ans+=\"I\";\\n            num-=1;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sulicn",
                        "content": "[@user9666yo](/user9666yo) Is it allowed to post answers here in discussion?@Deepak_8811"
                    },
                    {
                        "username": "user9666yo",
                        "content": "//criado objeto com a correspondencia dos valores\\nconst symbols = {\\n  \\'I\\': 1,\\n  \\'V\\': 5,\\n  \\'X\\': 10,\\n  \\'L\\': 50,\\n  \\'C\\': 100,\\n  \\'D\\': 500,\\n  \\'M\\': 1000,\\n};\\n\\n//fun\\xE7ao contador total\\nfunction romanToInt(s) {\\n  let total = 0;\\n\\n//percorrer cada algarismo\\n  for (let i = 0; i < s.length; ++i) {\\n    const num1 = symbols[s[i]];\\n    const num2 = symbols[s[i + 1]];\\n\\n    if (num1 < num2) {\\n      total -= num1;\\n    } else {\\n      total += num1;\\n    }\\n  }\\n//retorna o total\\n  return total;\\n}\\n"
                    }
                ]
            },
            {
                "id": 1898146,
                "content": [
                    {
                        "username": "sulicn",
                        "content": "Can I report those idiots that are still posting solutions here?"
                    },
                    {
                        "username": "Wolfoo",
                        "content": "I think it\\'s easy not medium"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "alalalaa",
                        "content": "double it and give it to the next person\\n"
                    },
                    {
                        "username": "Luojihencha",
                        "content": "I paied a lot of money for leetcode......and still there is no answer. Leetcode please, all questions are hard for me."
                    },
                    {
                        "username": "jy0819",
                        "content": "bro it\\'s been 3 years hope your luoji becomes better now lol"
                    },
                    {
                        "username": "alalalaa",
                        "content": "ask someone who knows how to code to make you connect the dots"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "IHxRK28",
                        "content": "I dont know whether this is a troll statement or not but heres your motivation and tips/advice \\n\\nYou could just follow famous playlists on youtube - \\nSo theres this Indian Guy called striver (Channel Name - TakeuForward) more than half of his videos are in english, You should follow that and I can definitely say You will get better at it. From what I know and understand, You get better at coding with practice which might take different time for different people, so if you are interested in coding keep at it.  "
                    },
                    {
                        "username": "umnik",
                        "content": "I know the easy way of solving this problem is using **23 case** statements (10 for numbers [1-10], 10 for [10-100], 10 for [1000-3000]). But the code does not look good and it's getting bit long. I'm thinking even applying the rules for converting may also make the code complex. Any suggestions?"
                    },
                    {
                        "username": "androidcarson",
                        "content": "[@AdityaBhate](/AdityaBhate) downvoted for using emojis"
                    },
                    {
                        "username": "tolem",
                        "content": "yeah it can  even be solved in 10 to 11 case checks "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you might wanna take a look into this [solution](https://leetcode.com/problems/integer-to-roman/solutions/2726838/c-solution/?orderBy=most_votes)"
                    },
                    {
                        "username": "selvablaze",
                        "content": "[@lucayan0506](/lucayan0506) class Solution {\\n    public String getValue(int val, int pos, HashMap<Integer, String> map){\\n        int value = val * (int) Math.pow(10, pos-1);\\n        String answer = \"\";\\n        if(map.containsKey(value))\\n            return map.get(value);\\n        int upperBound = (int) Math.pow(10,pos);\\n        int midBound = (int) Math.pow(10,pos)/2;\\n        int lowerBound = (int) Math.pow(10, pos-1);\\n        if(val == 4)\\n            answer = map.get(lowerBound) + map.get(midBound);\\n        else if(val == 9 )\\n            answer = map.get(lowerBound) + map.get(upperBound);   \\n        else if(val < 4)\\n            answer = map.get(lowerBound).repeat(val);\\n        else if(val > 5)\\n            answer =  map.get(midBound) + map.get(lowerBound).repeat(val-5);   \\n        map.put(value, answer);\\n        return answer;              \\n    }\\n    public String intToRoman(int num) {\\n        String answer = \"\";\\n        int i = 1;\\n        HashMap<Integer,String> map = new HashMap<>();\\n        map.put(1, \"I\" );\\n        map.put(5, \"V\" );\\n        map.put(10, \"X\" );\\n        map.put(50, \"L\" );\\n        map.put(100, \"C\" );\\n        map.put(500, \"D\" );\\n        map.put(1000, \"M\");\\n        while(num>0){\\n            answer = getValue(num%10, i, map) + answer;\\n            num = num/10;\\n            i++;\\n        }\\n        return answer;\\n    }\\n}"
                    },
                    {
                        "username": "lucayan0506",
                        "content": "I would suggest use map (where you save the value in decimal and the value in roman) `m[1000] = \"M\"    m[900] = \"CM\"`.\nOr you can you use 2 array (one for decimal number, one for roman number) `decimal_number[0] = 1000 roman_number[0] = \"M\"`\nThen use a for loop, instead of 23 case statement"
                    },
                    {
                        "username": "Amax",
                        "content": "For example: how do you spell 1999 in roman?\\nMIM or MCMXCIX?"
                    },
                    {
                        "username": "RittikChaudhary",
                        "content": "[@VinayPatidar](/VinayPatidar) bhai 1001 ho skta hai \"MI\""
                    },
                    {
                        "username": "Kei_Chen",
                        "content": "[@VinayPatidar](/VinayPatidar) Actually I after M is allowed, for example: to write 1001, we can use MI"
                    },
                    {
                        "username": "arthur326",
                        "content": "Yeah, just from the information given in the question, 10 could be written as IX or VIV, right? (This does not violate the subtraction cases they give.) Are we allowed to return either representation? The question should be clearer..."
                    },
                    {
                        "username": "lolo101",
                        "content": "MCMXCIX\\nYou cannot write \"IM\" because you may only remove the previous power of ten to a power of ten.\\nFor instance \"IX\", \"XC\", \"CM\" are allowed. But \"IC\", \"IM\", \"XM\" are not."
                    },
                    {
                        "username": "VinayPatidar",
                        "content": "second one\\nyou cannot have I before or after M"
                    },
                    {
                        "username": "ozkansafak",
                        "content": "[@Kram_](/Kram_) Why? What\\'s the rule we\\'re trying to capture in the code?"
                    },
                    {
                        "username": "abdallahg2120",
                        "content": "According to roman rule which I see in problem description.\\nI think the right answer is MCMXCIX.\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "10 years later, we still have the same doubt!"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Oh man it\\'s been 10 years for this comment."
                    },
                    {
                        "username": "snoyes",
                        "content": "In modern standard use, the only subtractive forms are IV, IX, XL, XC, CD, and CM, so MIM wouldn\\'t be allowed. In medieval and earlier times, usage was all over the place, so there\\'s no telling "
                    },
                    {
                        "username": "Kram_",
                        "content": "The second one"
                    },
                    {
                        "username": "YuriiHryniv",
                        "content": "I bought leetcode subscription but this problem seems very hard to me :((. Unsubscribe, I thought I would get into FAANG"
                    },
                    {
                        "username": "AseCantCode",
                        "content": "[@Artsapollo](/Artsapollo) dude he is just joking"
                    },
                    {
                        "username": "Artsapollo",
                        "content": "Dude, try before pay"
                    },
                    {
                        "username": "ztia0004",
                        "content": "I just don\\'t know the point of this question, it\\'s like wasting my time to understand something I do not want to know, rather than coding practice"
                    },
                    {
                        "username": "mayankK135",
                        "content": "Like all DSA problem you solve, it\\'s also to teach how problem solving skill, off course you won\\'t need it in real world"
                    },
                    {
                        "username": "AseCantCode",
                        "content": "[@georgezakharov](/georgezakharov) lmao\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Tell it on an interview :)"
                    },
                    {
                        "username": "ranjeetmadhaviitd",
                        "content": "[Watch](https://www.youtube.com/watch?v=wvpe4ldKTW0) this video for the better explanation of the solution.\\nhttps://www.youtube.com/watch?v=wvpe4ldKTW0\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution."
                    },
                    {
                        "username": "suren-yeager",
                        "content": "this isnt the correct question !!"
                    },
                    {
                        "username": "heshan16",
                        "content": "Er,for example,actually, the roman integer of 49 should be IL?But in this problem,the input of 49 should be output LXIX.So there result would not  the true roman numbers"
                    },
                    {
                        "username": "ivstarkov",
                        "content": "[@xcelr8](/xcelr8) 49 is XLIX. LXIX isnt possible."
                    },
                    {
                        "username": "dtwiers",
                        "content": "In the most loosely-defined version of Roman numerals, yes, IL would be correct. But in the more rigorously defined version, you can only use the next-highest order of 10 unit lower than a number to subtract from a large number - so IM isn\\'t a thing for 999, but CM will get you 900 because C is the next highest power of 10 below 1000. You then get XC (100 - 10), and IX (10 - 1), so 999 is CMXCIX"
                    },
                    {
                        "username": "dtwiers",
                        "content": "[@xcelr8](/xcelr8) that is 69. 49 is XLIX."
                    },
                    {
                        "username": "xcelr8",
                        "content": "49 is LXIX in roman"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "class Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string ans=\"\";\\n        while(num>=1000){\\n            ans+=\"M\";\\n            num-=1000;\\n        }\\n        while(num>=900){\\n            ans+=\"CM\";\\n            num-=900;\\n        }\\n        while(num>=500){\\n            ans+=\"D\";\\n            num-=500;\\n        }\\n        while(num>=400){\\n            ans+=\"CD\";\\n            num-=400;\\n        }\\n        while(num>=100){\\n            ans+=\"C\";\\n            num-=100;\\n        }\\n        while(num>=90){\\n            ans+=\"XC\";\\n            num-=90;\\n        }\\n        while(num>=50){\\n            ans+=\"L\";\\n            num-=50;\\n        }\\n        while(num>=40){\\n            ans+=\"XL\";\\n            num-=40;\\n        }\\n        while(num>=10){\\n            ans+=\"X\";\\n            num-=10;\\n        }\\n        while(num>=9){\\n            ans+=\"IX\";\\n            num-=9;\\n        }\\n        while(num>=5){\\n            ans+=\"V\";\\n            num-=5;\\n        }\\n        while(num>=4){\\n            ans+=\"IV\";\\n            num-=4;\\n        }\\n        while(num>=1){\\n            ans+=\"I\";\\n            num-=1;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sulicn",
                        "content": "[@user9666yo](/user9666yo) Is it allowed to post answers here in discussion?@Deepak_8811"
                    },
                    {
                        "username": "user9666yo",
                        "content": "//criado objeto com a correspondencia dos valores\\nconst symbols = {\\n  \\'I\\': 1,\\n  \\'V\\': 5,\\n  \\'X\\': 10,\\n  \\'L\\': 50,\\n  \\'C\\': 100,\\n  \\'D\\': 500,\\n  \\'M\\': 1000,\\n};\\n\\n//fun\\xE7ao contador total\\nfunction romanToInt(s) {\\n  let total = 0;\\n\\n//percorrer cada algarismo\\n  for (let i = 0; i < s.length; ++i) {\\n    const num1 = symbols[s[i]];\\n    const num2 = symbols[s[i + 1]];\\n\\n    if (num1 < num2) {\\n      total -= num1;\\n    } else {\\n      total += num1;\\n    }\\n  }\\n//retorna o total\\n  return total;\\n}\\n"
                    }
                ]
            },
            {
                "id": 1576240,
                "content": [
                    {
                        "username": "sulicn",
                        "content": "Can I report those idiots that are still posting solutions here?"
                    },
                    {
                        "username": "Wolfoo",
                        "content": "I think it\\'s easy not medium"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "alalalaa",
                        "content": "double it and give it to the next person\\n"
                    },
                    {
                        "username": "Luojihencha",
                        "content": "I paied a lot of money for leetcode......and still there is no answer. Leetcode please, all questions are hard for me."
                    },
                    {
                        "username": "jy0819",
                        "content": "bro it\\'s been 3 years hope your luoji becomes better now lol"
                    },
                    {
                        "username": "alalalaa",
                        "content": "ask someone who knows how to code to make you connect the dots"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "IHxRK28",
                        "content": "I dont know whether this is a troll statement or not but heres your motivation and tips/advice \\n\\nYou could just follow famous playlists on youtube - \\nSo theres this Indian Guy called striver (Channel Name - TakeuForward) more than half of his videos are in english, You should follow that and I can definitely say You will get better at it. From what I know and understand, You get better at coding with practice which might take different time for different people, so if you are interested in coding keep at it.  "
                    },
                    {
                        "username": "umnik",
                        "content": "I know the easy way of solving this problem is using **23 case** statements (10 for numbers [1-10], 10 for [10-100], 10 for [1000-3000]). But the code does not look good and it's getting bit long. I'm thinking even applying the rules for converting may also make the code complex. Any suggestions?"
                    },
                    {
                        "username": "androidcarson",
                        "content": "[@AdityaBhate](/AdityaBhate) downvoted for using emojis"
                    },
                    {
                        "username": "tolem",
                        "content": "yeah it can  even be solved in 10 to 11 case checks "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you might wanna take a look into this [solution](https://leetcode.com/problems/integer-to-roman/solutions/2726838/c-solution/?orderBy=most_votes)"
                    },
                    {
                        "username": "selvablaze",
                        "content": "[@lucayan0506](/lucayan0506) class Solution {\\n    public String getValue(int val, int pos, HashMap<Integer, String> map){\\n        int value = val * (int) Math.pow(10, pos-1);\\n        String answer = \"\";\\n        if(map.containsKey(value))\\n            return map.get(value);\\n        int upperBound = (int) Math.pow(10,pos);\\n        int midBound = (int) Math.pow(10,pos)/2;\\n        int lowerBound = (int) Math.pow(10, pos-1);\\n        if(val == 4)\\n            answer = map.get(lowerBound) + map.get(midBound);\\n        else if(val == 9 )\\n            answer = map.get(lowerBound) + map.get(upperBound);   \\n        else if(val < 4)\\n            answer = map.get(lowerBound).repeat(val);\\n        else if(val > 5)\\n            answer =  map.get(midBound) + map.get(lowerBound).repeat(val-5);   \\n        map.put(value, answer);\\n        return answer;              \\n    }\\n    public String intToRoman(int num) {\\n        String answer = \"\";\\n        int i = 1;\\n        HashMap<Integer,String> map = new HashMap<>();\\n        map.put(1, \"I\" );\\n        map.put(5, \"V\" );\\n        map.put(10, \"X\" );\\n        map.put(50, \"L\" );\\n        map.put(100, \"C\" );\\n        map.put(500, \"D\" );\\n        map.put(1000, \"M\");\\n        while(num>0){\\n            answer = getValue(num%10, i, map) + answer;\\n            num = num/10;\\n            i++;\\n        }\\n        return answer;\\n    }\\n}"
                    },
                    {
                        "username": "lucayan0506",
                        "content": "I would suggest use map (where you save the value in decimal and the value in roman) `m[1000] = \"M\"    m[900] = \"CM\"`.\nOr you can you use 2 array (one for decimal number, one for roman number) `decimal_number[0] = 1000 roman_number[0] = \"M\"`\nThen use a for loop, instead of 23 case statement"
                    },
                    {
                        "username": "Amax",
                        "content": "For example: how do you spell 1999 in roman?\\nMIM or MCMXCIX?"
                    },
                    {
                        "username": "RittikChaudhary",
                        "content": "[@VinayPatidar](/VinayPatidar) bhai 1001 ho skta hai \"MI\""
                    },
                    {
                        "username": "Kei_Chen",
                        "content": "[@VinayPatidar](/VinayPatidar) Actually I after M is allowed, for example: to write 1001, we can use MI"
                    },
                    {
                        "username": "arthur326",
                        "content": "Yeah, just from the information given in the question, 10 could be written as IX or VIV, right? (This does not violate the subtraction cases they give.) Are we allowed to return either representation? The question should be clearer..."
                    },
                    {
                        "username": "lolo101",
                        "content": "MCMXCIX\\nYou cannot write \"IM\" because you may only remove the previous power of ten to a power of ten.\\nFor instance \"IX\", \"XC\", \"CM\" are allowed. But \"IC\", \"IM\", \"XM\" are not."
                    },
                    {
                        "username": "VinayPatidar",
                        "content": "second one\\nyou cannot have I before or after M"
                    },
                    {
                        "username": "ozkansafak",
                        "content": "[@Kram_](/Kram_) Why? What\\'s the rule we\\'re trying to capture in the code?"
                    },
                    {
                        "username": "abdallahg2120",
                        "content": "According to roman rule which I see in problem description.\\nI think the right answer is MCMXCIX.\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "10 years later, we still have the same doubt!"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Oh man it\\'s been 10 years for this comment."
                    },
                    {
                        "username": "snoyes",
                        "content": "In modern standard use, the only subtractive forms are IV, IX, XL, XC, CD, and CM, so MIM wouldn\\'t be allowed. In medieval and earlier times, usage was all over the place, so there\\'s no telling "
                    },
                    {
                        "username": "Kram_",
                        "content": "The second one"
                    },
                    {
                        "username": "YuriiHryniv",
                        "content": "I bought leetcode subscription but this problem seems very hard to me :((. Unsubscribe, I thought I would get into FAANG"
                    },
                    {
                        "username": "AseCantCode",
                        "content": "[@Artsapollo](/Artsapollo) dude he is just joking"
                    },
                    {
                        "username": "Artsapollo",
                        "content": "Dude, try before pay"
                    },
                    {
                        "username": "ztia0004",
                        "content": "I just don\\'t know the point of this question, it\\'s like wasting my time to understand something I do not want to know, rather than coding practice"
                    },
                    {
                        "username": "mayankK135",
                        "content": "Like all DSA problem you solve, it\\'s also to teach how problem solving skill, off course you won\\'t need it in real world"
                    },
                    {
                        "username": "AseCantCode",
                        "content": "[@georgezakharov](/georgezakharov) lmao\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Tell it on an interview :)"
                    },
                    {
                        "username": "ranjeetmadhaviitd",
                        "content": "[Watch](https://www.youtube.com/watch?v=wvpe4ldKTW0) this video for the better explanation of the solution.\\nhttps://www.youtube.com/watch?v=wvpe4ldKTW0\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution."
                    },
                    {
                        "username": "suren-yeager",
                        "content": "this isnt the correct question !!"
                    },
                    {
                        "username": "heshan16",
                        "content": "Er,for example,actually, the roman integer of 49 should be IL?But in this problem,the input of 49 should be output LXIX.So there result would not  the true roman numbers"
                    },
                    {
                        "username": "ivstarkov",
                        "content": "[@xcelr8](/xcelr8) 49 is XLIX. LXIX isnt possible."
                    },
                    {
                        "username": "dtwiers",
                        "content": "In the most loosely-defined version of Roman numerals, yes, IL would be correct. But in the more rigorously defined version, you can only use the next-highest order of 10 unit lower than a number to subtract from a large number - so IM isn\\'t a thing for 999, but CM will get you 900 because C is the next highest power of 10 below 1000. You then get XC (100 - 10), and IX (10 - 1), so 999 is CMXCIX"
                    },
                    {
                        "username": "dtwiers",
                        "content": "[@xcelr8](/xcelr8) that is 69. 49 is XLIX."
                    },
                    {
                        "username": "xcelr8",
                        "content": "49 is LXIX in roman"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "class Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string ans=\"\";\\n        while(num>=1000){\\n            ans+=\"M\";\\n            num-=1000;\\n        }\\n        while(num>=900){\\n            ans+=\"CM\";\\n            num-=900;\\n        }\\n        while(num>=500){\\n            ans+=\"D\";\\n            num-=500;\\n        }\\n        while(num>=400){\\n            ans+=\"CD\";\\n            num-=400;\\n        }\\n        while(num>=100){\\n            ans+=\"C\";\\n            num-=100;\\n        }\\n        while(num>=90){\\n            ans+=\"XC\";\\n            num-=90;\\n        }\\n        while(num>=50){\\n            ans+=\"L\";\\n            num-=50;\\n        }\\n        while(num>=40){\\n            ans+=\"XL\";\\n            num-=40;\\n        }\\n        while(num>=10){\\n            ans+=\"X\";\\n            num-=10;\\n        }\\n        while(num>=9){\\n            ans+=\"IX\";\\n            num-=9;\\n        }\\n        while(num>=5){\\n            ans+=\"V\";\\n            num-=5;\\n        }\\n        while(num>=4){\\n            ans+=\"IV\";\\n            num-=4;\\n        }\\n        while(num>=1){\\n            ans+=\"I\";\\n            num-=1;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sulicn",
                        "content": "[@user9666yo](/user9666yo) Is it allowed to post answers here in discussion?@Deepak_8811"
                    },
                    {
                        "username": "user9666yo",
                        "content": "//criado objeto com a correspondencia dos valores\\nconst symbols = {\\n  \\'I\\': 1,\\n  \\'V\\': 5,\\n  \\'X\\': 10,\\n  \\'L\\': 50,\\n  \\'C\\': 100,\\n  \\'D\\': 500,\\n  \\'M\\': 1000,\\n};\\n\\n//fun\\xE7ao contador total\\nfunction romanToInt(s) {\\n  let total = 0;\\n\\n//percorrer cada algarismo\\n  for (let i = 0; i < s.length; ++i) {\\n    const num1 = symbols[s[i]];\\n    const num2 = symbols[s[i + 1]];\\n\\n    if (num1 < num2) {\\n      total -= num1;\\n    } else {\\n      total += num1;\\n    }\\n  }\\n//retorna o total\\n  return total;\\n}\\n"
                    }
                ]
            },
            {
                "id": 1568266,
                "content": [
                    {
                        "username": "sulicn",
                        "content": "Can I report those idiots that are still posting solutions here?"
                    },
                    {
                        "username": "Wolfoo",
                        "content": "I think it\\'s easy not medium"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "alalalaa",
                        "content": "double it and give it to the next person\\n"
                    },
                    {
                        "username": "Luojihencha",
                        "content": "I paied a lot of money for leetcode......and still there is no answer. Leetcode please, all questions are hard for me."
                    },
                    {
                        "username": "jy0819",
                        "content": "bro it\\'s been 3 years hope your luoji becomes better now lol"
                    },
                    {
                        "username": "alalalaa",
                        "content": "ask someone who knows how to code to make you connect the dots"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "IHxRK28",
                        "content": "I dont know whether this is a troll statement or not but heres your motivation and tips/advice \\n\\nYou could just follow famous playlists on youtube - \\nSo theres this Indian Guy called striver (Channel Name - TakeuForward) more than half of his videos are in english, You should follow that and I can definitely say You will get better at it. From what I know and understand, You get better at coding with practice which might take different time for different people, so if you are interested in coding keep at it.  "
                    },
                    {
                        "username": "umnik",
                        "content": "I know the easy way of solving this problem is using **23 case** statements (10 for numbers [1-10], 10 for [10-100], 10 for [1000-3000]). But the code does not look good and it's getting bit long. I'm thinking even applying the rules for converting may also make the code complex. Any suggestions?"
                    },
                    {
                        "username": "androidcarson",
                        "content": "[@AdityaBhate](/AdityaBhate) downvoted for using emojis"
                    },
                    {
                        "username": "tolem",
                        "content": "yeah it can  even be solved in 10 to 11 case checks "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you might wanna take a look into this [solution](https://leetcode.com/problems/integer-to-roman/solutions/2726838/c-solution/?orderBy=most_votes)"
                    },
                    {
                        "username": "selvablaze",
                        "content": "[@lucayan0506](/lucayan0506) class Solution {\\n    public String getValue(int val, int pos, HashMap<Integer, String> map){\\n        int value = val * (int) Math.pow(10, pos-1);\\n        String answer = \"\";\\n        if(map.containsKey(value))\\n            return map.get(value);\\n        int upperBound = (int) Math.pow(10,pos);\\n        int midBound = (int) Math.pow(10,pos)/2;\\n        int lowerBound = (int) Math.pow(10, pos-1);\\n        if(val == 4)\\n            answer = map.get(lowerBound) + map.get(midBound);\\n        else if(val == 9 )\\n            answer = map.get(lowerBound) + map.get(upperBound);   \\n        else if(val < 4)\\n            answer = map.get(lowerBound).repeat(val);\\n        else if(val > 5)\\n            answer =  map.get(midBound) + map.get(lowerBound).repeat(val-5);   \\n        map.put(value, answer);\\n        return answer;              \\n    }\\n    public String intToRoman(int num) {\\n        String answer = \"\";\\n        int i = 1;\\n        HashMap<Integer,String> map = new HashMap<>();\\n        map.put(1, \"I\" );\\n        map.put(5, \"V\" );\\n        map.put(10, \"X\" );\\n        map.put(50, \"L\" );\\n        map.put(100, \"C\" );\\n        map.put(500, \"D\" );\\n        map.put(1000, \"M\");\\n        while(num>0){\\n            answer = getValue(num%10, i, map) + answer;\\n            num = num/10;\\n            i++;\\n        }\\n        return answer;\\n    }\\n}"
                    },
                    {
                        "username": "lucayan0506",
                        "content": "I would suggest use map (where you save the value in decimal and the value in roman) `m[1000] = \"M\"    m[900] = \"CM\"`.\nOr you can you use 2 array (one for decimal number, one for roman number) `decimal_number[0] = 1000 roman_number[0] = \"M\"`\nThen use a for loop, instead of 23 case statement"
                    },
                    {
                        "username": "Amax",
                        "content": "For example: how do you spell 1999 in roman?\\nMIM or MCMXCIX?"
                    },
                    {
                        "username": "RittikChaudhary",
                        "content": "[@VinayPatidar](/VinayPatidar) bhai 1001 ho skta hai \"MI\""
                    },
                    {
                        "username": "Kei_Chen",
                        "content": "[@VinayPatidar](/VinayPatidar) Actually I after M is allowed, for example: to write 1001, we can use MI"
                    },
                    {
                        "username": "arthur326",
                        "content": "Yeah, just from the information given in the question, 10 could be written as IX or VIV, right? (This does not violate the subtraction cases they give.) Are we allowed to return either representation? The question should be clearer..."
                    },
                    {
                        "username": "lolo101",
                        "content": "MCMXCIX\\nYou cannot write \"IM\" because you may only remove the previous power of ten to a power of ten.\\nFor instance \"IX\", \"XC\", \"CM\" are allowed. But \"IC\", \"IM\", \"XM\" are not."
                    },
                    {
                        "username": "VinayPatidar",
                        "content": "second one\\nyou cannot have I before or after M"
                    },
                    {
                        "username": "ozkansafak",
                        "content": "[@Kram_](/Kram_) Why? What\\'s the rule we\\'re trying to capture in the code?"
                    },
                    {
                        "username": "abdallahg2120",
                        "content": "According to roman rule which I see in problem description.\\nI think the right answer is MCMXCIX.\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "10 years later, we still have the same doubt!"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Oh man it\\'s been 10 years for this comment."
                    },
                    {
                        "username": "snoyes",
                        "content": "In modern standard use, the only subtractive forms are IV, IX, XL, XC, CD, and CM, so MIM wouldn\\'t be allowed. In medieval and earlier times, usage was all over the place, so there\\'s no telling "
                    },
                    {
                        "username": "Kram_",
                        "content": "The second one"
                    },
                    {
                        "username": "YuriiHryniv",
                        "content": "I bought leetcode subscription but this problem seems very hard to me :((. Unsubscribe, I thought I would get into FAANG"
                    },
                    {
                        "username": "AseCantCode",
                        "content": "[@Artsapollo](/Artsapollo) dude he is just joking"
                    },
                    {
                        "username": "Artsapollo",
                        "content": "Dude, try before pay"
                    },
                    {
                        "username": "ztia0004",
                        "content": "I just don\\'t know the point of this question, it\\'s like wasting my time to understand something I do not want to know, rather than coding practice"
                    },
                    {
                        "username": "mayankK135",
                        "content": "Like all DSA problem you solve, it\\'s also to teach how problem solving skill, off course you won\\'t need it in real world"
                    },
                    {
                        "username": "AseCantCode",
                        "content": "[@georgezakharov](/georgezakharov) lmao\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Tell it on an interview :)"
                    },
                    {
                        "username": "ranjeetmadhaviitd",
                        "content": "[Watch](https://www.youtube.com/watch?v=wvpe4ldKTW0) this video for the better explanation of the solution.\\nhttps://www.youtube.com/watch?v=wvpe4ldKTW0\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution."
                    },
                    {
                        "username": "suren-yeager",
                        "content": "this isnt the correct question !!"
                    },
                    {
                        "username": "heshan16",
                        "content": "Er,for example,actually, the roman integer of 49 should be IL?But in this problem,the input of 49 should be output LXIX.So there result would not  the true roman numbers"
                    },
                    {
                        "username": "ivstarkov",
                        "content": "[@xcelr8](/xcelr8) 49 is XLIX. LXIX isnt possible."
                    },
                    {
                        "username": "dtwiers",
                        "content": "In the most loosely-defined version of Roman numerals, yes, IL would be correct. But in the more rigorously defined version, you can only use the next-highest order of 10 unit lower than a number to subtract from a large number - so IM isn\\'t a thing for 999, but CM will get you 900 because C is the next highest power of 10 below 1000. You then get XC (100 - 10), and IX (10 - 1), so 999 is CMXCIX"
                    },
                    {
                        "username": "dtwiers",
                        "content": "[@xcelr8](/xcelr8) that is 69. 49 is XLIX."
                    },
                    {
                        "username": "xcelr8",
                        "content": "49 is LXIX in roman"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "class Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string ans=\"\";\\n        while(num>=1000){\\n            ans+=\"M\";\\n            num-=1000;\\n        }\\n        while(num>=900){\\n            ans+=\"CM\";\\n            num-=900;\\n        }\\n        while(num>=500){\\n            ans+=\"D\";\\n            num-=500;\\n        }\\n        while(num>=400){\\n            ans+=\"CD\";\\n            num-=400;\\n        }\\n        while(num>=100){\\n            ans+=\"C\";\\n            num-=100;\\n        }\\n        while(num>=90){\\n            ans+=\"XC\";\\n            num-=90;\\n        }\\n        while(num>=50){\\n            ans+=\"L\";\\n            num-=50;\\n        }\\n        while(num>=40){\\n            ans+=\"XL\";\\n            num-=40;\\n        }\\n        while(num>=10){\\n            ans+=\"X\";\\n            num-=10;\\n        }\\n        while(num>=9){\\n            ans+=\"IX\";\\n            num-=9;\\n        }\\n        while(num>=5){\\n            ans+=\"V\";\\n            num-=5;\\n        }\\n        while(num>=4){\\n            ans+=\"IV\";\\n            num-=4;\\n        }\\n        while(num>=1){\\n            ans+=\"I\";\\n            num-=1;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sulicn",
                        "content": "[@user9666yo](/user9666yo) Is it allowed to post answers here in discussion?@Deepak_8811"
                    },
                    {
                        "username": "user9666yo",
                        "content": "//criado objeto com a correspondencia dos valores\\nconst symbols = {\\n  \\'I\\': 1,\\n  \\'V\\': 5,\\n  \\'X\\': 10,\\n  \\'L\\': 50,\\n  \\'C\\': 100,\\n  \\'D\\': 500,\\n  \\'M\\': 1000,\\n};\\n\\n//fun\\xE7ao contador total\\nfunction romanToInt(s) {\\n  let total = 0;\\n\\n//percorrer cada algarismo\\n  for (let i = 0; i < s.length; ++i) {\\n    const num1 = symbols[s[i]];\\n    const num2 = symbols[s[i + 1]];\\n\\n    if (num1 < num2) {\\n      total -= num1;\\n    } else {\\n      total += num1;\\n    }\\n  }\\n//retorna o total\\n  return total;\\n}\\n"
                    }
                ]
            },
            {
                "id": 1565655,
                "content": [
                    {
                        "username": "sulicn",
                        "content": "Can I report those idiots that are still posting solutions here?"
                    },
                    {
                        "username": "Wolfoo",
                        "content": "I think it\\'s easy not medium"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "alalalaa",
                        "content": "double it and give it to the next person\\n"
                    },
                    {
                        "username": "Luojihencha",
                        "content": "I paied a lot of money for leetcode......and still there is no answer. Leetcode please, all questions are hard for me."
                    },
                    {
                        "username": "jy0819",
                        "content": "bro it\\'s been 3 years hope your luoji becomes better now lol"
                    },
                    {
                        "username": "alalalaa",
                        "content": "ask someone who knows how to code to make you connect the dots"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "IHxRK28",
                        "content": "I dont know whether this is a troll statement or not but heres your motivation and tips/advice \\n\\nYou could just follow famous playlists on youtube - \\nSo theres this Indian Guy called striver (Channel Name - TakeuForward) more than half of his videos are in english, You should follow that and I can definitely say You will get better at it. From what I know and understand, You get better at coding with practice which might take different time for different people, so if you are interested in coding keep at it.  "
                    },
                    {
                        "username": "umnik",
                        "content": "I know the easy way of solving this problem is using **23 case** statements (10 for numbers [1-10], 10 for [10-100], 10 for [1000-3000]). But the code does not look good and it's getting bit long. I'm thinking even applying the rules for converting may also make the code complex. Any suggestions?"
                    },
                    {
                        "username": "androidcarson",
                        "content": "[@AdityaBhate](/AdityaBhate) downvoted for using emojis"
                    },
                    {
                        "username": "tolem",
                        "content": "yeah it can  even be solved in 10 to 11 case checks "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you might wanna take a look into this [solution](https://leetcode.com/problems/integer-to-roman/solutions/2726838/c-solution/?orderBy=most_votes)"
                    },
                    {
                        "username": "selvablaze",
                        "content": "[@lucayan0506](/lucayan0506) class Solution {\\n    public String getValue(int val, int pos, HashMap<Integer, String> map){\\n        int value = val * (int) Math.pow(10, pos-1);\\n        String answer = \"\";\\n        if(map.containsKey(value))\\n            return map.get(value);\\n        int upperBound = (int) Math.pow(10,pos);\\n        int midBound = (int) Math.pow(10,pos)/2;\\n        int lowerBound = (int) Math.pow(10, pos-1);\\n        if(val == 4)\\n            answer = map.get(lowerBound) + map.get(midBound);\\n        else if(val == 9 )\\n            answer = map.get(lowerBound) + map.get(upperBound);   \\n        else if(val < 4)\\n            answer = map.get(lowerBound).repeat(val);\\n        else if(val > 5)\\n            answer =  map.get(midBound) + map.get(lowerBound).repeat(val-5);   \\n        map.put(value, answer);\\n        return answer;              \\n    }\\n    public String intToRoman(int num) {\\n        String answer = \"\";\\n        int i = 1;\\n        HashMap<Integer,String> map = new HashMap<>();\\n        map.put(1, \"I\" );\\n        map.put(5, \"V\" );\\n        map.put(10, \"X\" );\\n        map.put(50, \"L\" );\\n        map.put(100, \"C\" );\\n        map.put(500, \"D\" );\\n        map.put(1000, \"M\");\\n        while(num>0){\\n            answer = getValue(num%10, i, map) + answer;\\n            num = num/10;\\n            i++;\\n        }\\n        return answer;\\n    }\\n}"
                    },
                    {
                        "username": "lucayan0506",
                        "content": "I would suggest use map (where you save the value in decimal and the value in roman) `m[1000] = \"M\"    m[900] = \"CM\"`.\nOr you can you use 2 array (one for decimal number, one for roman number) `decimal_number[0] = 1000 roman_number[0] = \"M\"`\nThen use a for loop, instead of 23 case statement"
                    },
                    {
                        "username": "Amax",
                        "content": "For example: how do you spell 1999 in roman?\\nMIM or MCMXCIX?"
                    },
                    {
                        "username": "RittikChaudhary",
                        "content": "[@VinayPatidar](/VinayPatidar) bhai 1001 ho skta hai \"MI\""
                    },
                    {
                        "username": "Kei_Chen",
                        "content": "[@VinayPatidar](/VinayPatidar) Actually I after M is allowed, for example: to write 1001, we can use MI"
                    },
                    {
                        "username": "arthur326",
                        "content": "Yeah, just from the information given in the question, 10 could be written as IX or VIV, right? (This does not violate the subtraction cases they give.) Are we allowed to return either representation? The question should be clearer..."
                    },
                    {
                        "username": "lolo101",
                        "content": "MCMXCIX\\nYou cannot write \"IM\" because you may only remove the previous power of ten to a power of ten.\\nFor instance \"IX\", \"XC\", \"CM\" are allowed. But \"IC\", \"IM\", \"XM\" are not."
                    },
                    {
                        "username": "VinayPatidar",
                        "content": "second one\\nyou cannot have I before or after M"
                    },
                    {
                        "username": "ozkansafak",
                        "content": "[@Kram_](/Kram_) Why? What\\'s the rule we\\'re trying to capture in the code?"
                    },
                    {
                        "username": "abdallahg2120",
                        "content": "According to roman rule which I see in problem description.\\nI think the right answer is MCMXCIX.\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "10 years later, we still have the same doubt!"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Oh man it\\'s been 10 years for this comment."
                    },
                    {
                        "username": "snoyes",
                        "content": "In modern standard use, the only subtractive forms are IV, IX, XL, XC, CD, and CM, so MIM wouldn\\'t be allowed. In medieval and earlier times, usage was all over the place, so there\\'s no telling "
                    },
                    {
                        "username": "Kram_",
                        "content": "The second one"
                    },
                    {
                        "username": "YuriiHryniv",
                        "content": "I bought leetcode subscription but this problem seems very hard to me :((. Unsubscribe, I thought I would get into FAANG"
                    },
                    {
                        "username": "AseCantCode",
                        "content": "[@Artsapollo](/Artsapollo) dude he is just joking"
                    },
                    {
                        "username": "Artsapollo",
                        "content": "Dude, try before pay"
                    },
                    {
                        "username": "ztia0004",
                        "content": "I just don\\'t know the point of this question, it\\'s like wasting my time to understand something I do not want to know, rather than coding practice"
                    },
                    {
                        "username": "mayankK135",
                        "content": "Like all DSA problem you solve, it\\'s also to teach how problem solving skill, off course you won\\'t need it in real world"
                    },
                    {
                        "username": "AseCantCode",
                        "content": "[@georgezakharov](/georgezakharov) lmao\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Tell it on an interview :)"
                    },
                    {
                        "username": "ranjeetmadhaviitd",
                        "content": "[Watch](https://www.youtube.com/watch?v=wvpe4ldKTW0) this video for the better explanation of the solution.\\nhttps://www.youtube.com/watch?v=wvpe4ldKTW0\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution."
                    },
                    {
                        "username": "suren-yeager",
                        "content": "this isnt the correct question !!"
                    },
                    {
                        "username": "heshan16",
                        "content": "Er,for example,actually, the roman integer of 49 should be IL?But in this problem,the input of 49 should be output LXIX.So there result would not  the true roman numbers"
                    },
                    {
                        "username": "ivstarkov",
                        "content": "[@xcelr8](/xcelr8) 49 is XLIX. LXIX isnt possible."
                    },
                    {
                        "username": "dtwiers",
                        "content": "In the most loosely-defined version of Roman numerals, yes, IL would be correct. But in the more rigorously defined version, you can only use the next-highest order of 10 unit lower than a number to subtract from a large number - so IM isn\\'t a thing for 999, but CM will get you 900 because C is the next highest power of 10 below 1000. You then get XC (100 - 10), and IX (10 - 1), so 999 is CMXCIX"
                    },
                    {
                        "username": "dtwiers",
                        "content": "[@xcelr8](/xcelr8) that is 69. 49 is XLIX."
                    },
                    {
                        "username": "xcelr8",
                        "content": "49 is LXIX in roman"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "class Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string ans=\"\";\\n        while(num>=1000){\\n            ans+=\"M\";\\n            num-=1000;\\n        }\\n        while(num>=900){\\n            ans+=\"CM\";\\n            num-=900;\\n        }\\n        while(num>=500){\\n            ans+=\"D\";\\n            num-=500;\\n        }\\n        while(num>=400){\\n            ans+=\"CD\";\\n            num-=400;\\n        }\\n        while(num>=100){\\n            ans+=\"C\";\\n            num-=100;\\n        }\\n        while(num>=90){\\n            ans+=\"XC\";\\n            num-=90;\\n        }\\n        while(num>=50){\\n            ans+=\"L\";\\n            num-=50;\\n        }\\n        while(num>=40){\\n            ans+=\"XL\";\\n            num-=40;\\n        }\\n        while(num>=10){\\n            ans+=\"X\";\\n            num-=10;\\n        }\\n        while(num>=9){\\n            ans+=\"IX\";\\n            num-=9;\\n        }\\n        while(num>=5){\\n            ans+=\"V\";\\n            num-=5;\\n        }\\n        while(num>=4){\\n            ans+=\"IV\";\\n            num-=4;\\n        }\\n        while(num>=1){\\n            ans+=\"I\";\\n            num-=1;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sulicn",
                        "content": "[@user9666yo](/user9666yo) Is it allowed to post answers here in discussion?@Deepak_8811"
                    },
                    {
                        "username": "user9666yo",
                        "content": "//criado objeto com a correspondencia dos valores\\nconst symbols = {\\n  \\'I\\': 1,\\n  \\'V\\': 5,\\n  \\'X\\': 10,\\n  \\'L\\': 50,\\n  \\'C\\': 100,\\n  \\'D\\': 500,\\n  \\'M\\': 1000,\\n};\\n\\n//fun\\xE7ao contador total\\nfunction romanToInt(s) {\\n  let total = 0;\\n\\n//percorrer cada algarismo\\n  for (let i = 0; i < s.length; ++i) {\\n    const num1 = symbols[s[i]];\\n    const num2 = symbols[s[i + 1]];\\n\\n    if (num1 < num2) {\\n      total -= num1;\\n    } else {\\n      total += num1;\\n    }\\n  }\\n//retorna o total\\n  return total;\\n}\\n"
                    }
                ]
            },
            {
                "id": 1565656,
                "content": [
                    {
                        "username": "sulicn",
                        "content": "Can I report those idiots that are still posting solutions here?"
                    },
                    {
                        "username": "Wolfoo",
                        "content": "I think it\\'s easy not medium"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "alalalaa",
                        "content": "double it and give it to the next person\\n"
                    },
                    {
                        "username": "Luojihencha",
                        "content": "I paied a lot of money for leetcode......and still there is no answer. Leetcode please, all questions are hard for me."
                    },
                    {
                        "username": "jy0819",
                        "content": "bro it\\'s been 3 years hope your luoji becomes better now lol"
                    },
                    {
                        "username": "alalalaa",
                        "content": "ask someone who knows how to code to make you connect the dots"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "IHxRK28",
                        "content": "I dont know whether this is a troll statement or not but heres your motivation and tips/advice \\n\\nYou could just follow famous playlists on youtube - \\nSo theres this Indian Guy called striver (Channel Name - TakeuForward) more than half of his videos are in english, You should follow that and I can definitely say You will get better at it. From what I know and understand, You get better at coding with practice which might take different time for different people, so if you are interested in coding keep at it.  "
                    },
                    {
                        "username": "umnik",
                        "content": "I know the easy way of solving this problem is using **23 case** statements (10 for numbers [1-10], 10 for [10-100], 10 for [1000-3000]). But the code does not look good and it's getting bit long. I'm thinking even applying the rules for converting may also make the code complex. Any suggestions?"
                    },
                    {
                        "username": "androidcarson",
                        "content": "[@AdityaBhate](/AdityaBhate) downvoted for using emojis"
                    },
                    {
                        "username": "tolem",
                        "content": "yeah it can  even be solved in 10 to 11 case checks "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you might wanna take a look into this [solution](https://leetcode.com/problems/integer-to-roman/solutions/2726838/c-solution/?orderBy=most_votes)"
                    },
                    {
                        "username": "selvablaze",
                        "content": "[@lucayan0506](/lucayan0506) class Solution {\\n    public String getValue(int val, int pos, HashMap<Integer, String> map){\\n        int value = val * (int) Math.pow(10, pos-1);\\n        String answer = \"\";\\n        if(map.containsKey(value))\\n            return map.get(value);\\n        int upperBound = (int) Math.pow(10,pos);\\n        int midBound = (int) Math.pow(10,pos)/2;\\n        int lowerBound = (int) Math.pow(10, pos-1);\\n        if(val == 4)\\n            answer = map.get(lowerBound) + map.get(midBound);\\n        else if(val == 9 )\\n            answer = map.get(lowerBound) + map.get(upperBound);   \\n        else if(val < 4)\\n            answer = map.get(lowerBound).repeat(val);\\n        else if(val > 5)\\n            answer =  map.get(midBound) + map.get(lowerBound).repeat(val-5);   \\n        map.put(value, answer);\\n        return answer;              \\n    }\\n    public String intToRoman(int num) {\\n        String answer = \"\";\\n        int i = 1;\\n        HashMap<Integer,String> map = new HashMap<>();\\n        map.put(1, \"I\" );\\n        map.put(5, \"V\" );\\n        map.put(10, \"X\" );\\n        map.put(50, \"L\" );\\n        map.put(100, \"C\" );\\n        map.put(500, \"D\" );\\n        map.put(1000, \"M\");\\n        while(num>0){\\n            answer = getValue(num%10, i, map) + answer;\\n            num = num/10;\\n            i++;\\n        }\\n        return answer;\\n    }\\n}"
                    },
                    {
                        "username": "lucayan0506",
                        "content": "I would suggest use map (where you save the value in decimal and the value in roman) `m[1000] = \"M\"    m[900] = \"CM\"`.\nOr you can you use 2 array (one for decimal number, one for roman number) `decimal_number[0] = 1000 roman_number[0] = \"M\"`\nThen use a for loop, instead of 23 case statement"
                    },
                    {
                        "username": "Amax",
                        "content": "For example: how do you spell 1999 in roman?\\nMIM or MCMXCIX?"
                    },
                    {
                        "username": "RittikChaudhary",
                        "content": "[@VinayPatidar](/VinayPatidar) bhai 1001 ho skta hai \"MI\""
                    },
                    {
                        "username": "Kei_Chen",
                        "content": "[@VinayPatidar](/VinayPatidar) Actually I after M is allowed, for example: to write 1001, we can use MI"
                    },
                    {
                        "username": "arthur326",
                        "content": "Yeah, just from the information given in the question, 10 could be written as IX or VIV, right? (This does not violate the subtraction cases they give.) Are we allowed to return either representation? The question should be clearer..."
                    },
                    {
                        "username": "lolo101",
                        "content": "MCMXCIX\\nYou cannot write \"IM\" because you may only remove the previous power of ten to a power of ten.\\nFor instance \"IX\", \"XC\", \"CM\" are allowed. But \"IC\", \"IM\", \"XM\" are not."
                    },
                    {
                        "username": "VinayPatidar",
                        "content": "second one\\nyou cannot have I before or after M"
                    },
                    {
                        "username": "ozkansafak",
                        "content": "[@Kram_](/Kram_) Why? What\\'s the rule we\\'re trying to capture in the code?"
                    },
                    {
                        "username": "abdallahg2120",
                        "content": "According to roman rule which I see in problem description.\\nI think the right answer is MCMXCIX.\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "10 years later, we still have the same doubt!"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Oh man it\\'s been 10 years for this comment."
                    },
                    {
                        "username": "snoyes",
                        "content": "In modern standard use, the only subtractive forms are IV, IX, XL, XC, CD, and CM, so MIM wouldn\\'t be allowed. In medieval and earlier times, usage was all over the place, so there\\'s no telling "
                    },
                    {
                        "username": "Kram_",
                        "content": "The second one"
                    },
                    {
                        "username": "YuriiHryniv",
                        "content": "I bought leetcode subscription but this problem seems very hard to me :((. Unsubscribe, I thought I would get into FAANG"
                    },
                    {
                        "username": "AseCantCode",
                        "content": "[@Artsapollo](/Artsapollo) dude he is just joking"
                    },
                    {
                        "username": "Artsapollo",
                        "content": "Dude, try before pay"
                    },
                    {
                        "username": "ztia0004",
                        "content": "I just don\\'t know the point of this question, it\\'s like wasting my time to understand something I do not want to know, rather than coding practice"
                    },
                    {
                        "username": "mayankK135",
                        "content": "Like all DSA problem you solve, it\\'s also to teach how problem solving skill, off course you won\\'t need it in real world"
                    },
                    {
                        "username": "AseCantCode",
                        "content": "[@georgezakharov](/georgezakharov) lmao\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Tell it on an interview :)"
                    },
                    {
                        "username": "ranjeetmadhaviitd",
                        "content": "[Watch](https://www.youtube.com/watch?v=wvpe4ldKTW0) this video for the better explanation of the solution.\\nhttps://www.youtube.com/watch?v=wvpe4ldKTW0\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution."
                    },
                    {
                        "username": "suren-yeager",
                        "content": "this isnt the correct question !!"
                    },
                    {
                        "username": "heshan16",
                        "content": "Er,for example,actually, the roman integer of 49 should be IL?But in this problem,the input of 49 should be output LXIX.So there result would not  the true roman numbers"
                    },
                    {
                        "username": "ivstarkov",
                        "content": "[@xcelr8](/xcelr8) 49 is XLIX. LXIX isnt possible."
                    },
                    {
                        "username": "dtwiers",
                        "content": "In the most loosely-defined version of Roman numerals, yes, IL would be correct. But in the more rigorously defined version, you can only use the next-highest order of 10 unit lower than a number to subtract from a large number - so IM isn\\'t a thing for 999, but CM will get you 900 because C is the next highest power of 10 below 1000. You then get XC (100 - 10), and IX (10 - 1), so 999 is CMXCIX"
                    },
                    {
                        "username": "dtwiers",
                        "content": "[@xcelr8](/xcelr8) that is 69. 49 is XLIX."
                    },
                    {
                        "username": "xcelr8",
                        "content": "49 is LXIX in roman"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "class Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string ans=\"\";\\n        while(num>=1000){\\n            ans+=\"M\";\\n            num-=1000;\\n        }\\n        while(num>=900){\\n            ans+=\"CM\";\\n            num-=900;\\n        }\\n        while(num>=500){\\n            ans+=\"D\";\\n            num-=500;\\n        }\\n        while(num>=400){\\n            ans+=\"CD\";\\n            num-=400;\\n        }\\n        while(num>=100){\\n            ans+=\"C\";\\n            num-=100;\\n        }\\n        while(num>=90){\\n            ans+=\"XC\";\\n            num-=90;\\n        }\\n        while(num>=50){\\n            ans+=\"L\";\\n            num-=50;\\n        }\\n        while(num>=40){\\n            ans+=\"XL\";\\n            num-=40;\\n        }\\n        while(num>=10){\\n            ans+=\"X\";\\n            num-=10;\\n        }\\n        while(num>=9){\\n            ans+=\"IX\";\\n            num-=9;\\n        }\\n        while(num>=5){\\n            ans+=\"V\";\\n            num-=5;\\n        }\\n        while(num>=4){\\n            ans+=\"IV\";\\n            num-=4;\\n        }\\n        while(num>=1){\\n            ans+=\"I\";\\n            num-=1;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sulicn",
                        "content": "[@user9666yo](/user9666yo) Is it allowed to post answers here in discussion?@Deepak_8811"
                    },
                    {
                        "username": "user9666yo",
                        "content": "//criado objeto com a correspondencia dos valores\\nconst symbols = {\\n  \\'I\\': 1,\\n  \\'V\\': 5,\\n  \\'X\\': 10,\\n  \\'L\\': 50,\\n  \\'C\\': 100,\\n  \\'D\\': 500,\\n  \\'M\\': 1000,\\n};\\n\\n//fun\\xE7ao contador total\\nfunction romanToInt(s) {\\n  let total = 0;\\n\\n//percorrer cada algarismo\\n  for (let i = 0; i < s.length; ++i) {\\n    const num1 = symbols[s[i]];\\n    const num2 = symbols[s[i + 1]];\\n\\n    if (num1 < num2) {\\n      total -= num1;\\n    } else {\\n      total += num1;\\n    }\\n  }\\n//retorna o total\\n  return total;\\n}\\n"
                    }
                ]
            },
            {
                "id": 1732820,
                "content": [
                    {
                        "username": "sulicn",
                        "content": "Can I report those idiots that are still posting solutions here?"
                    },
                    {
                        "username": "Wolfoo",
                        "content": "I think it\\'s easy not medium"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "alalalaa",
                        "content": "double it and give it to the next person\\n"
                    },
                    {
                        "username": "Luojihencha",
                        "content": "I paied a lot of money for leetcode......and still there is no answer. Leetcode please, all questions are hard for me."
                    },
                    {
                        "username": "jy0819",
                        "content": "bro it\\'s been 3 years hope your luoji becomes better now lol"
                    },
                    {
                        "username": "alalalaa",
                        "content": "ask someone who knows how to code to make you connect the dots"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "IHxRK28",
                        "content": "I dont know whether this is a troll statement or not but heres your motivation and tips/advice \\n\\nYou could just follow famous playlists on youtube - \\nSo theres this Indian Guy called striver (Channel Name - TakeuForward) more than half of his videos are in english, You should follow that and I can definitely say You will get better at it. From what I know and understand, You get better at coding with practice which might take different time for different people, so if you are interested in coding keep at it.  "
                    },
                    {
                        "username": "umnik",
                        "content": "I know the easy way of solving this problem is using **23 case** statements (10 for numbers [1-10], 10 for [10-100], 10 for [1000-3000]). But the code does not look good and it's getting bit long. I'm thinking even applying the rules for converting may also make the code complex. Any suggestions?"
                    },
                    {
                        "username": "androidcarson",
                        "content": "[@AdityaBhate](/AdityaBhate) downvoted for using emojis"
                    },
                    {
                        "username": "tolem",
                        "content": "yeah it can  even be solved in 10 to 11 case checks "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you might wanna take a look into this [solution](https://leetcode.com/problems/integer-to-roman/solutions/2726838/c-solution/?orderBy=most_votes)"
                    },
                    {
                        "username": "selvablaze",
                        "content": "[@lucayan0506](/lucayan0506) class Solution {\\n    public String getValue(int val, int pos, HashMap<Integer, String> map){\\n        int value = val * (int) Math.pow(10, pos-1);\\n        String answer = \"\";\\n        if(map.containsKey(value))\\n            return map.get(value);\\n        int upperBound = (int) Math.pow(10,pos);\\n        int midBound = (int) Math.pow(10,pos)/2;\\n        int lowerBound = (int) Math.pow(10, pos-1);\\n        if(val == 4)\\n            answer = map.get(lowerBound) + map.get(midBound);\\n        else if(val == 9 )\\n            answer = map.get(lowerBound) + map.get(upperBound);   \\n        else if(val < 4)\\n            answer = map.get(lowerBound).repeat(val);\\n        else if(val > 5)\\n            answer =  map.get(midBound) + map.get(lowerBound).repeat(val-5);   \\n        map.put(value, answer);\\n        return answer;              \\n    }\\n    public String intToRoman(int num) {\\n        String answer = \"\";\\n        int i = 1;\\n        HashMap<Integer,String> map = new HashMap<>();\\n        map.put(1, \"I\" );\\n        map.put(5, \"V\" );\\n        map.put(10, \"X\" );\\n        map.put(50, \"L\" );\\n        map.put(100, \"C\" );\\n        map.put(500, \"D\" );\\n        map.put(1000, \"M\");\\n        while(num>0){\\n            answer = getValue(num%10, i, map) + answer;\\n            num = num/10;\\n            i++;\\n        }\\n        return answer;\\n    }\\n}"
                    },
                    {
                        "username": "lucayan0506",
                        "content": "I would suggest use map (where you save the value in decimal and the value in roman) `m[1000] = \"M\"    m[900] = \"CM\"`.\nOr you can you use 2 array (one for decimal number, one for roman number) `decimal_number[0] = 1000 roman_number[0] = \"M\"`\nThen use a for loop, instead of 23 case statement"
                    },
                    {
                        "username": "Amax",
                        "content": "For example: how do you spell 1999 in roman?\\nMIM or MCMXCIX?"
                    },
                    {
                        "username": "RittikChaudhary",
                        "content": "[@VinayPatidar](/VinayPatidar) bhai 1001 ho skta hai \"MI\""
                    },
                    {
                        "username": "Kei_Chen",
                        "content": "[@VinayPatidar](/VinayPatidar) Actually I after M is allowed, for example: to write 1001, we can use MI"
                    },
                    {
                        "username": "arthur326",
                        "content": "Yeah, just from the information given in the question, 10 could be written as IX or VIV, right? (This does not violate the subtraction cases they give.) Are we allowed to return either representation? The question should be clearer..."
                    },
                    {
                        "username": "lolo101",
                        "content": "MCMXCIX\\nYou cannot write \"IM\" because you may only remove the previous power of ten to a power of ten.\\nFor instance \"IX\", \"XC\", \"CM\" are allowed. But \"IC\", \"IM\", \"XM\" are not."
                    },
                    {
                        "username": "VinayPatidar",
                        "content": "second one\\nyou cannot have I before or after M"
                    },
                    {
                        "username": "ozkansafak",
                        "content": "[@Kram_](/Kram_) Why? What\\'s the rule we\\'re trying to capture in the code?"
                    },
                    {
                        "username": "abdallahg2120",
                        "content": "According to roman rule which I see in problem description.\\nI think the right answer is MCMXCIX.\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "10 years later, we still have the same doubt!"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Oh man it\\'s been 10 years for this comment."
                    },
                    {
                        "username": "snoyes",
                        "content": "In modern standard use, the only subtractive forms are IV, IX, XL, XC, CD, and CM, so MIM wouldn\\'t be allowed. In medieval and earlier times, usage was all over the place, so there\\'s no telling "
                    },
                    {
                        "username": "Kram_",
                        "content": "The second one"
                    },
                    {
                        "username": "YuriiHryniv",
                        "content": "I bought leetcode subscription but this problem seems very hard to me :((. Unsubscribe, I thought I would get into FAANG"
                    },
                    {
                        "username": "AseCantCode",
                        "content": "[@Artsapollo](/Artsapollo) dude he is just joking"
                    },
                    {
                        "username": "Artsapollo",
                        "content": "Dude, try before pay"
                    },
                    {
                        "username": "ztia0004",
                        "content": "I just don\\'t know the point of this question, it\\'s like wasting my time to understand something I do not want to know, rather than coding practice"
                    },
                    {
                        "username": "mayankK135",
                        "content": "Like all DSA problem you solve, it\\'s also to teach how problem solving skill, off course you won\\'t need it in real world"
                    },
                    {
                        "username": "AseCantCode",
                        "content": "[@georgezakharov](/georgezakharov) lmao\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Tell it on an interview :)"
                    },
                    {
                        "username": "ranjeetmadhaviitd",
                        "content": "[Watch](https://www.youtube.com/watch?v=wvpe4ldKTW0) this video for the better explanation of the solution.\\nhttps://www.youtube.com/watch?v=wvpe4ldKTW0\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution."
                    },
                    {
                        "username": "suren-yeager",
                        "content": "this isnt the correct question !!"
                    },
                    {
                        "username": "heshan16",
                        "content": "Er,for example,actually, the roman integer of 49 should be IL?But in this problem,the input of 49 should be output LXIX.So there result would not  the true roman numbers"
                    },
                    {
                        "username": "ivstarkov",
                        "content": "[@xcelr8](/xcelr8) 49 is XLIX. LXIX isnt possible."
                    },
                    {
                        "username": "dtwiers",
                        "content": "In the most loosely-defined version of Roman numerals, yes, IL would be correct. But in the more rigorously defined version, you can only use the next-highest order of 10 unit lower than a number to subtract from a large number - so IM isn\\'t a thing for 999, but CM will get you 900 because C is the next highest power of 10 below 1000. You then get XC (100 - 10), and IX (10 - 1), so 999 is CMXCIX"
                    },
                    {
                        "username": "dtwiers",
                        "content": "[@xcelr8](/xcelr8) that is 69. 49 is XLIX."
                    },
                    {
                        "username": "xcelr8",
                        "content": "49 is LXIX in roman"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "class Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string ans=\"\";\\n        while(num>=1000){\\n            ans+=\"M\";\\n            num-=1000;\\n        }\\n        while(num>=900){\\n            ans+=\"CM\";\\n            num-=900;\\n        }\\n        while(num>=500){\\n            ans+=\"D\";\\n            num-=500;\\n        }\\n        while(num>=400){\\n            ans+=\"CD\";\\n            num-=400;\\n        }\\n        while(num>=100){\\n            ans+=\"C\";\\n            num-=100;\\n        }\\n        while(num>=90){\\n            ans+=\"XC\";\\n            num-=90;\\n        }\\n        while(num>=50){\\n            ans+=\"L\";\\n            num-=50;\\n        }\\n        while(num>=40){\\n            ans+=\"XL\";\\n            num-=40;\\n        }\\n        while(num>=10){\\n            ans+=\"X\";\\n            num-=10;\\n        }\\n        while(num>=9){\\n            ans+=\"IX\";\\n            num-=9;\\n        }\\n        while(num>=5){\\n            ans+=\"V\";\\n            num-=5;\\n        }\\n        while(num>=4){\\n            ans+=\"IV\";\\n            num-=4;\\n        }\\n        while(num>=1){\\n            ans+=\"I\";\\n            num-=1;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sulicn",
                        "content": "[@user9666yo](/user9666yo) Is it allowed to post answers here in discussion?@Deepak_8811"
                    },
                    {
                        "username": "user9666yo",
                        "content": "//criado objeto com a correspondencia dos valores\\nconst symbols = {\\n  \\'I\\': 1,\\n  \\'V\\': 5,\\n  \\'X\\': 10,\\n  \\'L\\': 50,\\n  \\'C\\': 100,\\n  \\'D\\': 500,\\n  \\'M\\': 1000,\\n};\\n\\n//fun\\xE7ao contador total\\nfunction romanToInt(s) {\\n  let total = 0;\\n\\n//percorrer cada algarismo\\n  for (let i = 0; i < s.length; ++i) {\\n    const num1 = symbols[s[i]];\\n    const num2 = symbols[s[i + 1]];\\n\\n    if (num1 < num2) {\\n      total -= num1;\\n    } else {\\n      total += num1;\\n    }\\n  }\\n//retorna o total\\n  return total;\\n}\\n"
                    }
                ]
            },
            {
                "id": 1914145,
                "content": [
                    {
                        "username": "sulicn",
                        "content": "Can I report those idiots that are still posting solutions here?"
                    },
                    {
                        "username": "Wolfoo",
                        "content": "I think it\\'s easy not medium"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "alalalaa",
                        "content": "double it and give it to the next person\\n"
                    },
                    {
                        "username": "Luojihencha",
                        "content": "I paied a lot of money for leetcode......and still there is no answer. Leetcode please, all questions are hard for me."
                    },
                    {
                        "username": "jy0819",
                        "content": "bro it\\'s been 3 years hope your luoji becomes better now lol"
                    },
                    {
                        "username": "alalalaa",
                        "content": "ask someone who knows how to code to make you connect the dots"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "IHxRK28",
                        "content": "I dont know whether this is a troll statement or not but heres your motivation and tips/advice \\n\\nYou could just follow famous playlists on youtube - \\nSo theres this Indian Guy called striver (Channel Name - TakeuForward) more than half of his videos are in english, You should follow that and I can definitely say You will get better at it. From what I know and understand, You get better at coding with practice which might take different time for different people, so if you are interested in coding keep at it.  "
                    },
                    {
                        "username": "umnik",
                        "content": "I know the easy way of solving this problem is using **23 case** statements (10 for numbers [1-10], 10 for [10-100], 10 for [1000-3000]). But the code does not look good and it's getting bit long. I'm thinking even applying the rules for converting may also make the code complex. Any suggestions?"
                    },
                    {
                        "username": "androidcarson",
                        "content": "[@AdityaBhate](/AdityaBhate) downvoted for using emojis"
                    },
                    {
                        "username": "tolem",
                        "content": "yeah it can  even be solved in 10 to 11 case checks "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you might wanna take a look into this [solution](https://leetcode.com/problems/integer-to-roman/solutions/2726838/c-solution/?orderBy=most_votes)"
                    },
                    {
                        "username": "selvablaze",
                        "content": "[@lucayan0506](/lucayan0506) class Solution {\\n    public String getValue(int val, int pos, HashMap<Integer, String> map){\\n        int value = val * (int) Math.pow(10, pos-1);\\n        String answer = \"\";\\n        if(map.containsKey(value))\\n            return map.get(value);\\n        int upperBound = (int) Math.pow(10,pos);\\n        int midBound = (int) Math.pow(10,pos)/2;\\n        int lowerBound = (int) Math.pow(10, pos-1);\\n        if(val == 4)\\n            answer = map.get(lowerBound) + map.get(midBound);\\n        else if(val == 9 )\\n            answer = map.get(lowerBound) + map.get(upperBound);   \\n        else if(val < 4)\\n            answer = map.get(lowerBound).repeat(val);\\n        else if(val > 5)\\n            answer =  map.get(midBound) + map.get(lowerBound).repeat(val-5);   \\n        map.put(value, answer);\\n        return answer;              \\n    }\\n    public String intToRoman(int num) {\\n        String answer = \"\";\\n        int i = 1;\\n        HashMap<Integer,String> map = new HashMap<>();\\n        map.put(1, \"I\" );\\n        map.put(5, \"V\" );\\n        map.put(10, \"X\" );\\n        map.put(50, \"L\" );\\n        map.put(100, \"C\" );\\n        map.put(500, \"D\" );\\n        map.put(1000, \"M\");\\n        while(num>0){\\n            answer = getValue(num%10, i, map) + answer;\\n            num = num/10;\\n            i++;\\n        }\\n        return answer;\\n    }\\n}"
                    },
                    {
                        "username": "lucayan0506",
                        "content": "I would suggest use map (where you save the value in decimal and the value in roman) `m[1000] = \"M\"    m[900] = \"CM\"`.\nOr you can you use 2 array (one for decimal number, one for roman number) `decimal_number[0] = 1000 roman_number[0] = \"M\"`\nThen use a for loop, instead of 23 case statement"
                    },
                    {
                        "username": "Amax",
                        "content": "For example: how do you spell 1999 in roman?\\nMIM or MCMXCIX?"
                    },
                    {
                        "username": "RittikChaudhary",
                        "content": "[@VinayPatidar](/VinayPatidar) bhai 1001 ho skta hai \"MI\""
                    },
                    {
                        "username": "Kei_Chen",
                        "content": "[@VinayPatidar](/VinayPatidar) Actually I after M is allowed, for example: to write 1001, we can use MI"
                    },
                    {
                        "username": "arthur326",
                        "content": "Yeah, just from the information given in the question, 10 could be written as IX or VIV, right? (This does not violate the subtraction cases they give.) Are we allowed to return either representation? The question should be clearer..."
                    },
                    {
                        "username": "lolo101",
                        "content": "MCMXCIX\\nYou cannot write \"IM\" because you may only remove the previous power of ten to a power of ten.\\nFor instance \"IX\", \"XC\", \"CM\" are allowed. But \"IC\", \"IM\", \"XM\" are not."
                    },
                    {
                        "username": "VinayPatidar",
                        "content": "second one\\nyou cannot have I before or after M"
                    },
                    {
                        "username": "ozkansafak",
                        "content": "[@Kram_](/Kram_) Why? What\\'s the rule we\\'re trying to capture in the code?"
                    },
                    {
                        "username": "abdallahg2120",
                        "content": "According to roman rule which I see in problem description.\\nI think the right answer is MCMXCIX.\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "10 years later, we still have the same doubt!"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Oh man it\\'s been 10 years for this comment."
                    },
                    {
                        "username": "snoyes",
                        "content": "In modern standard use, the only subtractive forms are IV, IX, XL, XC, CD, and CM, so MIM wouldn\\'t be allowed. In medieval and earlier times, usage was all over the place, so there\\'s no telling "
                    },
                    {
                        "username": "Kram_",
                        "content": "The second one"
                    },
                    {
                        "username": "YuriiHryniv",
                        "content": "I bought leetcode subscription but this problem seems very hard to me :((. Unsubscribe, I thought I would get into FAANG"
                    },
                    {
                        "username": "AseCantCode",
                        "content": "[@Artsapollo](/Artsapollo) dude he is just joking"
                    },
                    {
                        "username": "Artsapollo",
                        "content": "Dude, try before pay"
                    },
                    {
                        "username": "ztia0004",
                        "content": "I just don\\'t know the point of this question, it\\'s like wasting my time to understand something I do not want to know, rather than coding practice"
                    },
                    {
                        "username": "mayankK135",
                        "content": "Like all DSA problem you solve, it\\'s also to teach how problem solving skill, off course you won\\'t need it in real world"
                    },
                    {
                        "username": "AseCantCode",
                        "content": "[@georgezakharov](/georgezakharov) lmao\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Tell it on an interview :)"
                    },
                    {
                        "username": "ranjeetmadhaviitd",
                        "content": "[Watch](https://www.youtube.com/watch?v=wvpe4ldKTW0) this video for the better explanation of the solution.\\nhttps://www.youtube.com/watch?v=wvpe4ldKTW0\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution."
                    },
                    {
                        "username": "suren-yeager",
                        "content": "this isnt the correct question !!"
                    },
                    {
                        "username": "heshan16",
                        "content": "Er,for example,actually, the roman integer of 49 should be IL?But in this problem,the input of 49 should be output LXIX.So there result would not  the true roman numbers"
                    },
                    {
                        "username": "ivstarkov",
                        "content": "[@xcelr8](/xcelr8) 49 is XLIX. LXIX isnt possible."
                    },
                    {
                        "username": "dtwiers",
                        "content": "In the most loosely-defined version of Roman numerals, yes, IL would be correct. But in the more rigorously defined version, you can only use the next-highest order of 10 unit lower than a number to subtract from a large number - so IM isn\\'t a thing for 999, but CM will get you 900 because C is the next highest power of 10 below 1000. You then get XC (100 - 10), and IX (10 - 1), so 999 is CMXCIX"
                    },
                    {
                        "username": "dtwiers",
                        "content": "[@xcelr8](/xcelr8) that is 69. 49 is XLIX."
                    },
                    {
                        "username": "xcelr8",
                        "content": "49 is LXIX in roman"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "class Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string ans=\"\";\\n        while(num>=1000){\\n            ans+=\"M\";\\n            num-=1000;\\n        }\\n        while(num>=900){\\n            ans+=\"CM\";\\n            num-=900;\\n        }\\n        while(num>=500){\\n            ans+=\"D\";\\n            num-=500;\\n        }\\n        while(num>=400){\\n            ans+=\"CD\";\\n            num-=400;\\n        }\\n        while(num>=100){\\n            ans+=\"C\";\\n            num-=100;\\n        }\\n        while(num>=90){\\n            ans+=\"XC\";\\n            num-=90;\\n        }\\n        while(num>=50){\\n            ans+=\"L\";\\n            num-=50;\\n        }\\n        while(num>=40){\\n            ans+=\"XL\";\\n            num-=40;\\n        }\\n        while(num>=10){\\n            ans+=\"X\";\\n            num-=10;\\n        }\\n        while(num>=9){\\n            ans+=\"IX\";\\n            num-=9;\\n        }\\n        while(num>=5){\\n            ans+=\"V\";\\n            num-=5;\\n        }\\n        while(num>=4){\\n            ans+=\"IV\";\\n            num-=4;\\n        }\\n        while(num>=1){\\n            ans+=\"I\";\\n            num-=1;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sulicn",
                        "content": "[@user9666yo](/user9666yo) Is it allowed to post answers here in discussion?@Deepak_8811"
                    },
                    {
                        "username": "user9666yo",
                        "content": "//criado objeto com a correspondencia dos valores\\nconst symbols = {\\n  \\'I\\': 1,\\n  \\'V\\': 5,\\n  \\'X\\': 10,\\n  \\'L\\': 50,\\n  \\'C\\': 100,\\n  \\'D\\': 500,\\n  \\'M\\': 1000,\\n};\\n\\n//fun\\xE7ao contador total\\nfunction romanToInt(s) {\\n  let total = 0;\\n\\n//percorrer cada algarismo\\n  for (let i = 0; i < s.length; ++i) {\\n    const num1 = symbols[s[i]];\\n    const num2 = symbols[s[i + 1]];\\n\\n    if (num1 < num2) {\\n      total -= num1;\\n    } else {\\n      total += num1;\\n    }\\n  }\\n//retorna o total\\n  return total;\\n}\\n"
                    }
                ]
            },
            {
                "id": 1652407,
                "content": [
                    {
                        "username": "sulicn",
                        "content": "Can I report those idiots that are still posting solutions here?"
                    },
                    {
                        "username": "Wolfoo",
                        "content": "I think it\\'s easy not medium"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "alalalaa",
                        "content": "double it and give it to the next person\\n"
                    },
                    {
                        "username": "Luojihencha",
                        "content": "I paied a lot of money for leetcode......and still there is no answer. Leetcode please, all questions are hard for me."
                    },
                    {
                        "username": "jy0819",
                        "content": "bro it\\'s been 3 years hope your luoji becomes better now lol"
                    },
                    {
                        "username": "alalalaa",
                        "content": "ask someone who knows how to code to make you connect the dots"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "IHxRK28",
                        "content": "I dont know whether this is a troll statement or not but heres your motivation and tips/advice \\n\\nYou could just follow famous playlists on youtube - \\nSo theres this Indian Guy called striver (Channel Name - TakeuForward) more than half of his videos are in english, You should follow that and I can definitely say You will get better at it. From what I know and understand, You get better at coding with practice which might take different time for different people, so if you are interested in coding keep at it.  "
                    },
                    {
                        "username": "umnik",
                        "content": "I know the easy way of solving this problem is using **23 case** statements (10 for numbers [1-10], 10 for [10-100], 10 for [1000-3000]). But the code does not look good and it's getting bit long. I'm thinking even applying the rules for converting may also make the code complex. Any suggestions?"
                    },
                    {
                        "username": "androidcarson",
                        "content": "[@AdityaBhate](/AdityaBhate) downvoted for using emojis"
                    },
                    {
                        "username": "tolem",
                        "content": "yeah it can  even be solved in 10 to 11 case checks "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you might wanna take a look into this [solution](https://leetcode.com/problems/integer-to-roman/solutions/2726838/c-solution/?orderBy=most_votes)"
                    },
                    {
                        "username": "selvablaze",
                        "content": "[@lucayan0506](/lucayan0506) class Solution {\\n    public String getValue(int val, int pos, HashMap<Integer, String> map){\\n        int value = val * (int) Math.pow(10, pos-1);\\n        String answer = \"\";\\n        if(map.containsKey(value))\\n            return map.get(value);\\n        int upperBound = (int) Math.pow(10,pos);\\n        int midBound = (int) Math.pow(10,pos)/2;\\n        int lowerBound = (int) Math.pow(10, pos-1);\\n        if(val == 4)\\n            answer = map.get(lowerBound) + map.get(midBound);\\n        else if(val == 9 )\\n            answer = map.get(lowerBound) + map.get(upperBound);   \\n        else if(val < 4)\\n            answer = map.get(lowerBound).repeat(val);\\n        else if(val > 5)\\n            answer =  map.get(midBound) + map.get(lowerBound).repeat(val-5);   \\n        map.put(value, answer);\\n        return answer;              \\n    }\\n    public String intToRoman(int num) {\\n        String answer = \"\";\\n        int i = 1;\\n        HashMap<Integer,String> map = new HashMap<>();\\n        map.put(1, \"I\" );\\n        map.put(5, \"V\" );\\n        map.put(10, \"X\" );\\n        map.put(50, \"L\" );\\n        map.put(100, \"C\" );\\n        map.put(500, \"D\" );\\n        map.put(1000, \"M\");\\n        while(num>0){\\n            answer = getValue(num%10, i, map) + answer;\\n            num = num/10;\\n            i++;\\n        }\\n        return answer;\\n    }\\n}"
                    },
                    {
                        "username": "lucayan0506",
                        "content": "I would suggest use map (where you save the value in decimal and the value in roman) `m[1000] = \"M\"    m[900] = \"CM\"`.\nOr you can you use 2 array (one for decimal number, one for roman number) `decimal_number[0] = 1000 roman_number[0] = \"M\"`\nThen use a for loop, instead of 23 case statement"
                    },
                    {
                        "username": "Amax",
                        "content": "For example: how do you spell 1999 in roman?\\nMIM or MCMXCIX?"
                    },
                    {
                        "username": "RittikChaudhary",
                        "content": "[@VinayPatidar](/VinayPatidar) bhai 1001 ho skta hai \"MI\""
                    },
                    {
                        "username": "Kei_Chen",
                        "content": "[@VinayPatidar](/VinayPatidar) Actually I after M is allowed, for example: to write 1001, we can use MI"
                    },
                    {
                        "username": "arthur326",
                        "content": "Yeah, just from the information given in the question, 10 could be written as IX or VIV, right? (This does not violate the subtraction cases they give.) Are we allowed to return either representation? The question should be clearer..."
                    },
                    {
                        "username": "lolo101",
                        "content": "MCMXCIX\\nYou cannot write \"IM\" because you may only remove the previous power of ten to a power of ten.\\nFor instance \"IX\", \"XC\", \"CM\" are allowed. But \"IC\", \"IM\", \"XM\" are not."
                    },
                    {
                        "username": "VinayPatidar",
                        "content": "second one\\nyou cannot have I before or after M"
                    },
                    {
                        "username": "ozkansafak",
                        "content": "[@Kram_](/Kram_) Why? What\\'s the rule we\\'re trying to capture in the code?"
                    },
                    {
                        "username": "abdallahg2120",
                        "content": "According to roman rule which I see in problem description.\\nI think the right answer is MCMXCIX.\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "10 years later, we still have the same doubt!"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Oh man it\\'s been 10 years for this comment."
                    },
                    {
                        "username": "snoyes",
                        "content": "In modern standard use, the only subtractive forms are IV, IX, XL, XC, CD, and CM, so MIM wouldn\\'t be allowed. In medieval and earlier times, usage was all over the place, so there\\'s no telling "
                    },
                    {
                        "username": "Kram_",
                        "content": "The second one"
                    },
                    {
                        "username": "YuriiHryniv",
                        "content": "I bought leetcode subscription but this problem seems very hard to me :((. Unsubscribe, I thought I would get into FAANG"
                    },
                    {
                        "username": "AseCantCode",
                        "content": "[@Artsapollo](/Artsapollo) dude he is just joking"
                    },
                    {
                        "username": "Artsapollo",
                        "content": "Dude, try before pay"
                    },
                    {
                        "username": "ztia0004",
                        "content": "I just don\\'t know the point of this question, it\\'s like wasting my time to understand something I do not want to know, rather than coding practice"
                    },
                    {
                        "username": "mayankK135",
                        "content": "Like all DSA problem you solve, it\\'s also to teach how problem solving skill, off course you won\\'t need it in real world"
                    },
                    {
                        "username": "AseCantCode",
                        "content": "[@georgezakharov](/georgezakharov) lmao\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Tell it on an interview :)"
                    },
                    {
                        "username": "ranjeetmadhaviitd",
                        "content": "[Watch](https://www.youtube.com/watch?v=wvpe4ldKTW0) this video for the better explanation of the solution.\\nhttps://www.youtube.com/watch?v=wvpe4ldKTW0\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution."
                    },
                    {
                        "username": "suren-yeager",
                        "content": "this isnt the correct question !!"
                    },
                    {
                        "username": "heshan16",
                        "content": "Er,for example,actually, the roman integer of 49 should be IL?But in this problem,the input of 49 should be output LXIX.So there result would not  the true roman numbers"
                    },
                    {
                        "username": "ivstarkov",
                        "content": "[@xcelr8](/xcelr8) 49 is XLIX. LXIX isnt possible."
                    },
                    {
                        "username": "dtwiers",
                        "content": "In the most loosely-defined version of Roman numerals, yes, IL would be correct. But in the more rigorously defined version, you can only use the next-highest order of 10 unit lower than a number to subtract from a large number - so IM isn\\'t a thing for 999, but CM will get you 900 because C is the next highest power of 10 below 1000. You then get XC (100 - 10), and IX (10 - 1), so 999 is CMXCIX"
                    },
                    {
                        "username": "dtwiers",
                        "content": "[@xcelr8](/xcelr8) that is 69. 49 is XLIX."
                    },
                    {
                        "username": "xcelr8",
                        "content": "49 is LXIX in roman"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "class Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string ans=\"\";\\n        while(num>=1000){\\n            ans+=\"M\";\\n            num-=1000;\\n        }\\n        while(num>=900){\\n            ans+=\"CM\";\\n            num-=900;\\n        }\\n        while(num>=500){\\n            ans+=\"D\";\\n            num-=500;\\n        }\\n        while(num>=400){\\n            ans+=\"CD\";\\n            num-=400;\\n        }\\n        while(num>=100){\\n            ans+=\"C\";\\n            num-=100;\\n        }\\n        while(num>=90){\\n            ans+=\"XC\";\\n            num-=90;\\n        }\\n        while(num>=50){\\n            ans+=\"L\";\\n            num-=50;\\n        }\\n        while(num>=40){\\n            ans+=\"XL\";\\n            num-=40;\\n        }\\n        while(num>=10){\\n            ans+=\"X\";\\n            num-=10;\\n        }\\n        while(num>=9){\\n            ans+=\"IX\";\\n            num-=9;\\n        }\\n        while(num>=5){\\n            ans+=\"V\";\\n            num-=5;\\n        }\\n        while(num>=4){\\n            ans+=\"IV\";\\n            num-=4;\\n        }\\n        while(num>=1){\\n            ans+=\"I\";\\n            num-=1;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sulicn",
                        "content": "[@user9666yo](/user9666yo) Is it allowed to post answers here in discussion?@Deepak_8811"
                    },
                    {
                        "username": "user9666yo",
                        "content": "//criado objeto com a correspondencia dos valores\\nconst symbols = {\\n  \\'I\\': 1,\\n  \\'V\\': 5,\\n  \\'X\\': 10,\\n  \\'L\\': 50,\\n  \\'C\\': 100,\\n  \\'D\\': 500,\\n  \\'M\\': 1000,\\n};\\n\\n//fun\\xE7ao contador total\\nfunction romanToInt(s) {\\n  let total = 0;\\n\\n//percorrer cada algarismo\\n  for (let i = 0; i < s.length; ++i) {\\n    const num1 = symbols[s[i]];\\n    const num2 = symbols[s[i + 1]];\\n\\n    if (num1 < num2) {\\n      total -= num1;\\n    } else {\\n      total += num1;\\n    }\\n  }\\n//retorna o total\\n  return total;\\n}\\n"
                    }
                ]
            },
            {
                "id": 1571035,
                "content": [
                    {
                        "username": "sulicn",
                        "content": "Can I report those idiots that are still posting solutions here?"
                    },
                    {
                        "username": "Wolfoo",
                        "content": "I think it\\'s easy not medium"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "alalalaa",
                        "content": "double it and give it to the next person\\n"
                    },
                    {
                        "username": "Luojihencha",
                        "content": "I paied a lot of money for leetcode......and still there is no answer. Leetcode please, all questions are hard for me."
                    },
                    {
                        "username": "jy0819",
                        "content": "bro it\\'s been 3 years hope your luoji becomes better now lol"
                    },
                    {
                        "username": "alalalaa",
                        "content": "ask someone who knows how to code to make you connect the dots"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "IHxRK28",
                        "content": "I dont know whether this is a troll statement or not but heres your motivation and tips/advice \\n\\nYou could just follow famous playlists on youtube - \\nSo theres this Indian Guy called striver (Channel Name - TakeuForward) more than half of his videos are in english, You should follow that and I can definitely say You will get better at it. From what I know and understand, You get better at coding with practice which might take different time for different people, so if you are interested in coding keep at it.  "
                    },
                    {
                        "username": "umnik",
                        "content": "I know the easy way of solving this problem is using **23 case** statements (10 for numbers [1-10], 10 for [10-100], 10 for [1000-3000]). But the code does not look good and it's getting bit long. I'm thinking even applying the rules for converting may also make the code complex. Any suggestions?"
                    },
                    {
                        "username": "androidcarson",
                        "content": "[@AdityaBhate](/AdityaBhate) downvoted for using emojis"
                    },
                    {
                        "username": "tolem",
                        "content": "yeah it can  even be solved in 10 to 11 case checks "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you might wanna take a look into this [solution](https://leetcode.com/problems/integer-to-roman/solutions/2726838/c-solution/?orderBy=most_votes)"
                    },
                    {
                        "username": "selvablaze",
                        "content": "[@lucayan0506](/lucayan0506) class Solution {\\n    public String getValue(int val, int pos, HashMap<Integer, String> map){\\n        int value = val * (int) Math.pow(10, pos-1);\\n        String answer = \"\";\\n        if(map.containsKey(value))\\n            return map.get(value);\\n        int upperBound = (int) Math.pow(10,pos);\\n        int midBound = (int) Math.pow(10,pos)/2;\\n        int lowerBound = (int) Math.pow(10, pos-1);\\n        if(val == 4)\\n            answer = map.get(lowerBound) + map.get(midBound);\\n        else if(val == 9 )\\n            answer = map.get(lowerBound) + map.get(upperBound);   \\n        else if(val < 4)\\n            answer = map.get(lowerBound).repeat(val);\\n        else if(val > 5)\\n            answer =  map.get(midBound) + map.get(lowerBound).repeat(val-5);   \\n        map.put(value, answer);\\n        return answer;              \\n    }\\n    public String intToRoman(int num) {\\n        String answer = \"\";\\n        int i = 1;\\n        HashMap<Integer,String> map = new HashMap<>();\\n        map.put(1, \"I\" );\\n        map.put(5, \"V\" );\\n        map.put(10, \"X\" );\\n        map.put(50, \"L\" );\\n        map.put(100, \"C\" );\\n        map.put(500, \"D\" );\\n        map.put(1000, \"M\");\\n        while(num>0){\\n            answer = getValue(num%10, i, map) + answer;\\n            num = num/10;\\n            i++;\\n        }\\n        return answer;\\n    }\\n}"
                    },
                    {
                        "username": "lucayan0506",
                        "content": "I would suggest use map (where you save the value in decimal and the value in roman) `m[1000] = \"M\"    m[900] = \"CM\"`.\nOr you can you use 2 array (one for decimal number, one for roman number) `decimal_number[0] = 1000 roman_number[0] = \"M\"`\nThen use a for loop, instead of 23 case statement"
                    },
                    {
                        "username": "Amax",
                        "content": "For example: how do you spell 1999 in roman?\\nMIM or MCMXCIX?"
                    },
                    {
                        "username": "RittikChaudhary",
                        "content": "[@VinayPatidar](/VinayPatidar) bhai 1001 ho skta hai \"MI\""
                    },
                    {
                        "username": "Kei_Chen",
                        "content": "[@VinayPatidar](/VinayPatidar) Actually I after M is allowed, for example: to write 1001, we can use MI"
                    },
                    {
                        "username": "arthur326",
                        "content": "Yeah, just from the information given in the question, 10 could be written as IX or VIV, right? (This does not violate the subtraction cases they give.) Are we allowed to return either representation? The question should be clearer..."
                    },
                    {
                        "username": "lolo101",
                        "content": "MCMXCIX\\nYou cannot write \"IM\" because you may only remove the previous power of ten to a power of ten.\\nFor instance \"IX\", \"XC\", \"CM\" are allowed. But \"IC\", \"IM\", \"XM\" are not."
                    },
                    {
                        "username": "VinayPatidar",
                        "content": "second one\\nyou cannot have I before or after M"
                    },
                    {
                        "username": "ozkansafak",
                        "content": "[@Kram_](/Kram_) Why? What\\'s the rule we\\'re trying to capture in the code?"
                    },
                    {
                        "username": "abdallahg2120",
                        "content": "According to roman rule which I see in problem description.\\nI think the right answer is MCMXCIX.\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "10 years later, we still have the same doubt!"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Oh man it\\'s been 10 years for this comment."
                    },
                    {
                        "username": "snoyes",
                        "content": "In modern standard use, the only subtractive forms are IV, IX, XL, XC, CD, and CM, so MIM wouldn\\'t be allowed. In medieval and earlier times, usage was all over the place, so there\\'s no telling "
                    },
                    {
                        "username": "Kram_",
                        "content": "The second one"
                    },
                    {
                        "username": "YuriiHryniv",
                        "content": "I bought leetcode subscription but this problem seems very hard to me :((. Unsubscribe, I thought I would get into FAANG"
                    },
                    {
                        "username": "AseCantCode",
                        "content": "[@Artsapollo](/Artsapollo) dude he is just joking"
                    },
                    {
                        "username": "Artsapollo",
                        "content": "Dude, try before pay"
                    },
                    {
                        "username": "ztia0004",
                        "content": "I just don\\'t know the point of this question, it\\'s like wasting my time to understand something I do not want to know, rather than coding practice"
                    },
                    {
                        "username": "mayankK135",
                        "content": "Like all DSA problem you solve, it\\'s also to teach how problem solving skill, off course you won\\'t need it in real world"
                    },
                    {
                        "username": "AseCantCode",
                        "content": "[@georgezakharov](/georgezakharov) lmao\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Tell it on an interview :)"
                    },
                    {
                        "username": "ranjeetmadhaviitd",
                        "content": "[Watch](https://www.youtube.com/watch?v=wvpe4ldKTW0) this video for the better explanation of the solution.\\nhttps://www.youtube.com/watch?v=wvpe4ldKTW0\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution."
                    },
                    {
                        "username": "suren-yeager",
                        "content": "this isnt the correct question !!"
                    },
                    {
                        "username": "heshan16",
                        "content": "Er,for example,actually, the roman integer of 49 should be IL?But in this problem,the input of 49 should be output LXIX.So there result would not  the true roman numbers"
                    },
                    {
                        "username": "ivstarkov",
                        "content": "[@xcelr8](/xcelr8) 49 is XLIX. LXIX isnt possible."
                    },
                    {
                        "username": "dtwiers",
                        "content": "In the most loosely-defined version of Roman numerals, yes, IL would be correct. But in the more rigorously defined version, you can only use the next-highest order of 10 unit lower than a number to subtract from a large number - so IM isn\\'t a thing for 999, but CM will get you 900 because C is the next highest power of 10 below 1000. You then get XC (100 - 10), and IX (10 - 1), so 999 is CMXCIX"
                    },
                    {
                        "username": "dtwiers",
                        "content": "[@xcelr8](/xcelr8) that is 69. 49 is XLIX."
                    },
                    {
                        "username": "xcelr8",
                        "content": "49 is LXIX in roman"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "class Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string ans=\"\";\\n        while(num>=1000){\\n            ans+=\"M\";\\n            num-=1000;\\n        }\\n        while(num>=900){\\n            ans+=\"CM\";\\n            num-=900;\\n        }\\n        while(num>=500){\\n            ans+=\"D\";\\n            num-=500;\\n        }\\n        while(num>=400){\\n            ans+=\"CD\";\\n            num-=400;\\n        }\\n        while(num>=100){\\n            ans+=\"C\";\\n            num-=100;\\n        }\\n        while(num>=90){\\n            ans+=\"XC\";\\n            num-=90;\\n        }\\n        while(num>=50){\\n            ans+=\"L\";\\n            num-=50;\\n        }\\n        while(num>=40){\\n            ans+=\"XL\";\\n            num-=40;\\n        }\\n        while(num>=10){\\n            ans+=\"X\";\\n            num-=10;\\n        }\\n        while(num>=9){\\n            ans+=\"IX\";\\n            num-=9;\\n        }\\n        while(num>=5){\\n            ans+=\"V\";\\n            num-=5;\\n        }\\n        while(num>=4){\\n            ans+=\"IV\";\\n            num-=4;\\n        }\\n        while(num>=1){\\n            ans+=\"I\";\\n            num-=1;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sulicn",
                        "content": "[@user9666yo](/user9666yo) Is it allowed to post answers here in discussion?@Deepak_8811"
                    },
                    {
                        "username": "user9666yo",
                        "content": "//criado objeto com a correspondencia dos valores\\nconst symbols = {\\n  \\'I\\': 1,\\n  \\'V\\': 5,\\n  \\'X\\': 10,\\n  \\'L\\': 50,\\n  \\'C\\': 100,\\n  \\'D\\': 500,\\n  \\'M\\': 1000,\\n};\\n\\n//fun\\xE7ao contador total\\nfunction romanToInt(s) {\\n  let total = 0;\\n\\n//percorrer cada algarismo\\n  for (let i = 0; i < s.length; ++i) {\\n    const num1 = symbols[s[i]];\\n    const num2 = symbols[s[i + 1]];\\n\\n    if (num1 < num2) {\\n      total -= num1;\\n    } else {\\n      total += num1;\\n    }\\n  }\\n//retorna o total\\n  return total;\\n}\\n"
                    }
                ]
            },
            {
                "id": 1778211,
                "content": [
                    {
                        "username": "sulicn",
                        "content": "Can I report those idiots that are still posting solutions here?"
                    },
                    {
                        "username": "Wolfoo",
                        "content": "I think it\\'s easy not medium"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "alalalaa",
                        "content": "double it and give it to the next person\\n"
                    },
                    {
                        "username": "Luojihencha",
                        "content": "I paied a lot of money for leetcode......and still there is no answer. Leetcode please, all questions are hard for me."
                    },
                    {
                        "username": "jy0819",
                        "content": "bro it\\'s been 3 years hope your luoji becomes better now lol"
                    },
                    {
                        "username": "alalalaa",
                        "content": "ask someone who knows how to code to make you connect the dots"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "IHxRK28",
                        "content": "I dont know whether this is a troll statement or not but heres your motivation and tips/advice \\n\\nYou could just follow famous playlists on youtube - \\nSo theres this Indian Guy called striver (Channel Name - TakeuForward) more than half of his videos are in english, You should follow that and I can definitely say You will get better at it. From what I know and understand, You get better at coding with practice which might take different time for different people, so if you are interested in coding keep at it.  "
                    },
                    {
                        "username": "umnik",
                        "content": "I know the easy way of solving this problem is using **23 case** statements (10 for numbers [1-10], 10 for [10-100], 10 for [1000-3000]). But the code does not look good and it's getting bit long. I'm thinking even applying the rules for converting may also make the code complex. Any suggestions?"
                    },
                    {
                        "username": "androidcarson",
                        "content": "[@AdityaBhate](/AdityaBhate) downvoted for using emojis"
                    },
                    {
                        "username": "tolem",
                        "content": "yeah it can  even be solved in 10 to 11 case checks "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you might wanna take a look into this [solution](https://leetcode.com/problems/integer-to-roman/solutions/2726838/c-solution/?orderBy=most_votes)"
                    },
                    {
                        "username": "selvablaze",
                        "content": "[@lucayan0506](/lucayan0506) class Solution {\\n    public String getValue(int val, int pos, HashMap<Integer, String> map){\\n        int value = val * (int) Math.pow(10, pos-1);\\n        String answer = \"\";\\n        if(map.containsKey(value))\\n            return map.get(value);\\n        int upperBound = (int) Math.pow(10,pos);\\n        int midBound = (int) Math.pow(10,pos)/2;\\n        int lowerBound = (int) Math.pow(10, pos-1);\\n        if(val == 4)\\n            answer = map.get(lowerBound) + map.get(midBound);\\n        else if(val == 9 )\\n            answer = map.get(lowerBound) + map.get(upperBound);   \\n        else if(val < 4)\\n            answer = map.get(lowerBound).repeat(val);\\n        else if(val > 5)\\n            answer =  map.get(midBound) + map.get(lowerBound).repeat(val-5);   \\n        map.put(value, answer);\\n        return answer;              \\n    }\\n    public String intToRoman(int num) {\\n        String answer = \"\";\\n        int i = 1;\\n        HashMap<Integer,String> map = new HashMap<>();\\n        map.put(1, \"I\" );\\n        map.put(5, \"V\" );\\n        map.put(10, \"X\" );\\n        map.put(50, \"L\" );\\n        map.put(100, \"C\" );\\n        map.put(500, \"D\" );\\n        map.put(1000, \"M\");\\n        while(num>0){\\n            answer = getValue(num%10, i, map) + answer;\\n            num = num/10;\\n            i++;\\n        }\\n        return answer;\\n    }\\n}"
                    },
                    {
                        "username": "lucayan0506",
                        "content": "I would suggest use map (where you save the value in decimal and the value in roman) `m[1000] = \"M\"    m[900] = \"CM\"`.\nOr you can you use 2 array (one for decimal number, one for roman number) `decimal_number[0] = 1000 roman_number[0] = \"M\"`\nThen use a for loop, instead of 23 case statement"
                    },
                    {
                        "username": "Amax",
                        "content": "For example: how do you spell 1999 in roman?\\nMIM or MCMXCIX?"
                    },
                    {
                        "username": "RittikChaudhary",
                        "content": "[@VinayPatidar](/VinayPatidar) bhai 1001 ho skta hai \"MI\""
                    },
                    {
                        "username": "Kei_Chen",
                        "content": "[@VinayPatidar](/VinayPatidar) Actually I after M is allowed, for example: to write 1001, we can use MI"
                    },
                    {
                        "username": "arthur326",
                        "content": "Yeah, just from the information given in the question, 10 could be written as IX or VIV, right? (This does not violate the subtraction cases they give.) Are we allowed to return either representation? The question should be clearer..."
                    },
                    {
                        "username": "lolo101",
                        "content": "MCMXCIX\\nYou cannot write \"IM\" because you may only remove the previous power of ten to a power of ten.\\nFor instance \"IX\", \"XC\", \"CM\" are allowed. But \"IC\", \"IM\", \"XM\" are not."
                    },
                    {
                        "username": "VinayPatidar",
                        "content": "second one\\nyou cannot have I before or after M"
                    },
                    {
                        "username": "ozkansafak",
                        "content": "[@Kram_](/Kram_) Why? What\\'s the rule we\\'re trying to capture in the code?"
                    },
                    {
                        "username": "abdallahg2120",
                        "content": "According to roman rule which I see in problem description.\\nI think the right answer is MCMXCIX.\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "10 years later, we still have the same doubt!"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Oh man it\\'s been 10 years for this comment."
                    },
                    {
                        "username": "snoyes",
                        "content": "In modern standard use, the only subtractive forms are IV, IX, XL, XC, CD, and CM, so MIM wouldn\\'t be allowed. In medieval and earlier times, usage was all over the place, so there\\'s no telling "
                    },
                    {
                        "username": "Kram_",
                        "content": "The second one"
                    },
                    {
                        "username": "YuriiHryniv",
                        "content": "I bought leetcode subscription but this problem seems very hard to me :((. Unsubscribe, I thought I would get into FAANG"
                    },
                    {
                        "username": "AseCantCode",
                        "content": "[@Artsapollo](/Artsapollo) dude he is just joking"
                    },
                    {
                        "username": "Artsapollo",
                        "content": "Dude, try before pay"
                    },
                    {
                        "username": "ztia0004",
                        "content": "I just don\\'t know the point of this question, it\\'s like wasting my time to understand something I do not want to know, rather than coding practice"
                    },
                    {
                        "username": "mayankK135",
                        "content": "Like all DSA problem you solve, it\\'s also to teach how problem solving skill, off course you won\\'t need it in real world"
                    },
                    {
                        "username": "AseCantCode",
                        "content": "[@georgezakharov](/georgezakharov) lmao\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Tell it on an interview :)"
                    },
                    {
                        "username": "ranjeetmadhaviitd",
                        "content": "[Watch](https://www.youtube.com/watch?v=wvpe4ldKTW0) this video for the better explanation of the solution.\\nhttps://www.youtube.com/watch?v=wvpe4ldKTW0\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution."
                    },
                    {
                        "username": "suren-yeager",
                        "content": "this isnt the correct question !!"
                    },
                    {
                        "username": "heshan16",
                        "content": "Er,for example,actually, the roman integer of 49 should be IL?But in this problem,the input of 49 should be output LXIX.So there result would not  the true roman numbers"
                    },
                    {
                        "username": "ivstarkov",
                        "content": "[@xcelr8](/xcelr8) 49 is XLIX. LXIX isnt possible."
                    },
                    {
                        "username": "dtwiers",
                        "content": "In the most loosely-defined version of Roman numerals, yes, IL would be correct. But in the more rigorously defined version, you can only use the next-highest order of 10 unit lower than a number to subtract from a large number - so IM isn\\'t a thing for 999, but CM will get you 900 because C is the next highest power of 10 below 1000. You then get XC (100 - 10), and IX (10 - 1), so 999 is CMXCIX"
                    },
                    {
                        "username": "dtwiers",
                        "content": "[@xcelr8](/xcelr8) that is 69. 49 is XLIX."
                    },
                    {
                        "username": "xcelr8",
                        "content": "49 is LXIX in roman"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "class Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string ans=\"\";\\n        while(num>=1000){\\n            ans+=\"M\";\\n            num-=1000;\\n        }\\n        while(num>=900){\\n            ans+=\"CM\";\\n            num-=900;\\n        }\\n        while(num>=500){\\n            ans+=\"D\";\\n            num-=500;\\n        }\\n        while(num>=400){\\n            ans+=\"CD\";\\n            num-=400;\\n        }\\n        while(num>=100){\\n            ans+=\"C\";\\n            num-=100;\\n        }\\n        while(num>=90){\\n            ans+=\"XC\";\\n            num-=90;\\n        }\\n        while(num>=50){\\n            ans+=\"L\";\\n            num-=50;\\n        }\\n        while(num>=40){\\n            ans+=\"XL\";\\n            num-=40;\\n        }\\n        while(num>=10){\\n            ans+=\"X\";\\n            num-=10;\\n        }\\n        while(num>=9){\\n            ans+=\"IX\";\\n            num-=9;\\n        }\\n        while(num>=5){\\n            ans+=\"V\";\\n            num-=5;\\n        }\\n        while(num>=4){\\n            ans+=\"IV\";\\n            num-=4;\\n        }\\n        while(num>=1){\\n            ans+=\"I\";\\n            num-=1;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sulicn",
                        "content": "[@user9666yo](/user9666yo) Is it allowed to post answers here in discussion?@Deepak_8811"
                    },
                    {
                        "username": "user9666yo",
                        "content": "//criado objeto com a correspondencia dos valores\\nconst symbols = {\\n  \\'I\\': 1,\\n  \\'V\\': 5,\\n  \\'X\\': 10,\\n  \\'L\\': 50,\\n  \\'C\\': 100,\\n  \\'D\\': 500,\\n  \\'M\\': 1000,\\n};\\n\\n//fun\\xE7ao contador total\\nfunction romanToInt(s) {\\n  let total = 0;\\n\\n//percorrer cada algarismo\\n  for (let i = 0; i < s.length; ++i) {\\n    const num1 = symbols[s[i]];\\n    const num2 = symbols[s[i + 1]];\\n\\n    if (num1 < num2) {\\n      total -= num1;\\n    } else {\\n      total += num1;\\n    }\\n  }\\n//retorna o total\\n  return total;\\n}\\n"
                    }
                ]
            },
            {
                "id": 2071772,
                "content": [
                    {
                        "username": "mukeshgupta_",
                        "content": "I think its easy question. On GFG this is a Basic Question."
                    },
                    {
                        "username": "Code_Enthusiast232",
                        "content": "The intuition behind it is just to go from highest value to the lowest possible and to add some special cases to the hash table.\n\nThat's it"
                    },
                    {
                        "username": "akotb3",
                        "content": "\\nthis is the code I wrote  I believe it should work but evertime i put into leetcode it is  just out putting a bunch of IIIIIIII an example of this is if the input is 58 it would print : \"IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII\"\\n\\nclass Solution(object):\\n    def intToRoman(self, num):\\n        numdict = {1000:\"M\",\\n            900:\"CM\",\\n            500:\"D\",\\n            400:\"CD\",\\n            100:\"C\",\\n            90:\"XC\",\\n            50:\"L\",\\n            40:\"XL\",\\n            10:\"X\",\\n            9:\"IX\",\\n            5:\"V\",\\n            4:\"IV\",\\n            1:\"I\"\\n          }\\n        roman =\"\"\\n        for i in numdict.keys():\\n            while num >= i:\\n                num -= i\\n                roman += numdict[i]\\n            if num == 0:\\n                break\\n        return roman\\n\\nsolution = Solution()\\n\\n\\nresult = solution.intToRoman(1994)\\nprint(result)\\n\\n"
                    },
                    {
                        "username": "megan891685",
                        "content": "If I want to do this in c and not have memory leaks AND keep the compile time down, how should I return an array of char?\\nFor example.\\n `char *roman = (char*)malloc(sizeof(char)*8)\\n  char *arr =roman;\\n free(roman)\\n return arr; //will cause mem leaks\\n`\\n\\n `char *roman = (char*)malloc(sizeof(char)*8)\\n  char *arr;\\n  for(int i = 0; i < strlen(roman);i++){\\n arr[i] = roman[i];\\n}//going through for loop sounds like a giant waste.\\n free(roman)\\nreturn arr;\\n`"
                    },
                    {
                        "username": "0x6B0",
                        "content": "Have to give this a like, it deserves the upvote, even though it left me with 3 failed attempts "
                    },
                    {
                        "username": "Nwarr_Desirs",
                        "content": "please bros i don\\'t undestand, what is self?? why do i need it? "
                    },
                    {
                        "username": "Kei_Chen",
                        "content": "Self is something that 'represents' a function as a whole allowing you to access any variable inside the class, it doesn't have to be self (i.e. could be wjf), but is normally stated as it. For example, if we have two functions in the class, and we try to call one variable, this could be messy (if you get it). Take this as an example:\n\nclass Person:\n  def __init__(self, name: str, age: int) -> str:\n    self.name = name\n    self.age = age\n\n  def myfunc(abc):\n    return abc.name\n\nAlso you can refer to here: https://www.w3schools.com/python/gloss_python_self.asp#:~:text=The%20self%20parameter%20is%20a,that%20belongs%20to%20the%20class."
                    },
                    {
                        "username": "jetroll2014",
                        "content": "Idk why this is wrong.\n\nIt is clear that my result is same with the expected.... But it's a wrong answer.\n\nIdk why!!! Please someone help me :( \n\nnum=3, Output:\"III\", Expected:\"III\"\nnum=58, Output:\"LVIII\", Expected:\"LVIII\"\n\n\n `class Solution {\npublic:\n    string intToRoman(int num) {\n        int value = 0;\n        int count=0;\n        string result;\n        result+='M'*(num/1000);\n        num%=1000;\n        int idx = num/100;\n        if(idx ==9){\n            result+=\"CM\";\n        }\n        else if(idx==4){\n            result+=\"CD\";\n        }\n        else\n        {result.append(idx/5, 'D');\n        result.append(idx%5, 'C');\n        }\n        num%=100;\n        idx = num/10;\n        if(idx==9){\n            result+=\"XC\";\n        }\n        else if(idx==4){\n            result+=\"XL\";\n        }\n        else\n        {result.append(idx/5, 'L');\n        result.append(idx%5, 'X');\n        }\n        num%=10;\n        if(num==9){\n            result+=\"IX\";\n        }\n        else if(num==4){\n            result+=\"IV\";\n        }\n        else\n        {\n            result.append(num/5, 'V');\n            result.append(num%5, 'I');\n        }\n        return result;\n    }\n};`"
                    },
                    {
                        "username": "EmreArslan",
                        "content": "As I said in this code's comment sections, your code sets 0th index of result string as null. If the value is smaller than 1000. Also, your code doesn't multiplicate the 'M' if the number is bigger than 1000.\n\nHere is the fixed code with comment sections that explains the situation:\n\n```\nclass Solution { \n    public: string intToRoman(int num) \n    { \n        int value = 0; \n        int count=0; \n        string result;\n\n        //In this line, the initial char of 'result' string can be Null\n        // result+='M'*(num/1000); \n\n        //So that, I deactivated this line and wrote this if conditional and while loop\n        if(num/1000){\n            while(num >= 1000){\n                result += 'M';\n                num-=1000;\n            }\n        };\n        \n        // num%=1000; \n        int idx = num/100; \n        if(idx ==9){ result+=\"CM\"; } \n        else if(idx==4){ result+=\"CD\"; } \n        else {\n            result.append(idx/5, 'D'); \n            result.append(idx%5, 'C'); \n        } \n        num%=100; \n        idx = num/10; \n        if(idx==9){ \n            result+=\"XC\"; \n        } \n        else if(idx==4){ \n            result+=\"XL\"; \n        } \n        else {\n            result.append(idx/5, 'L'); \n            result.append(idx%5, 'X'); \n        } \n        num%=10; \n        if(num==9){ \n            result+=\"IX\"; \n        } \n        else if(num==4){ \n            result+=\"IV\"; \n        } \n        else { \n            result.append(num/5, 'V'); \n            result.append(num%5, 'I'); \n        } \n        return result; \n    } \n};\n```\n\nI hope it helps you "
                    },
                    {
                        "username": "arpitagrawal09",
                        "content": "Quite interesting question! "
                    },
                    {
                        "username": "anamrani17",
                        "content": "/**\\n * @param {number} num\\n * @return {string}\\n */\\nvar intToRoman = function(num) {\\n    // step 1: create a lookup table\\n    const lookupTable = {\\n       O: [\\'\\', \\'I\\', \\'II\\', \\'III\\', \\'IV\\', \\'V\\', \\'VI\\', \\'VII\\', \\'VIII\\', \\'IX\\'],\\n        T: [\\'\\', \\'X\\', \\'XX\\', \\'XXX\\', \\'XL\\', \\'L\\', \\'LX\\', \\'LXX\\', \\'LXXX\\', \\'XC\\'],\\n        H : [\\'\\', \\'C\\', \\'CC\\', \\'CCC\\', \\'CD\\', \\'D\\', \\'DC\\', \\'DCC\\', \\'DCCC\\', \\'CM\\'],\\n        Th : [\\'\\', \\'M\\', \\'MM\\', \\'MMM\\']\\n    }\\nreturn lookupTable.Th[Math.floor(num/1000)] + lookupTable.H[Math.floor((num%1000)/100)] + lookupTable.T[Math.floor((num%100)/10)] + lookupTable.O[num%10];\\n    \\n};\\n\\nhere is my solution of JavaScript code.\\nthe main line of code is return statement the expands the number then extract each digit one by one.\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "zbraven",
                        "content": "int bul(char ch,int value)\\n{\\n\\nswitch (ch)\\n{\\n    case \\'I\\':\\n        value += 1;\\n        break;\\n    case \\'V\\':\\n        value += 5;\\n        break;\\n    case \\'X\\':\\n        value += 10;\\n        break;\\n    case \\'L\\':\\n        value += 50;\\n        break;\\n    case \\'C\\':\\n        value += 100;\\n        break;\\n    case \\'D\\':\\n        value += 500;\\n        break;\\n    case \\'M\\':\\n        value += 1000;\\n            break;\\n }\\n    return value;\\n\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user9666yo",
                        "content": "//criado objeto com a correspondencia dos valores\\nconst symbols = {\\n  \\'I\\': 1,\\n  \\'V\\': 5,\\n  \\'X\\': 10,\\n  \\'L\\': 50,\\n  \\'C\\': 100,\\n  \\'D\\': 500,\\n  \\'M\\': 1000,\\n};\\n\\n//fun\\xE7ao contador total\\nfunction romanToInt(s) {\\n  let total = 0;\\n\\n//percorrer cada algarismo\\n  for (let i = 0; i < s.length; ++i) {\\n    const num1 = symbols[s[i]];\\n    const num2 = symbols[s[i + 1]];\\n\\n    if (num1 < num2) {\\n      total -= num1;\\n    } else {\\n      total += num1;\\n    }\\n  }\\n//retorna o total\\n  return total;\\n}\\n\\nconsole.log(romanToInt(\"MCMXCIV\"));"
                    }
                ]
            },
            {
                "id": 2071582,
                "content": [
                    {
                        "username": "mukeshgupta_",
                        "content": "I think its easy question. On GFG this is a Basic Question."
                    },
                    {
                        "username": "Code_Enthusiast232",
                        "content": "The intuition behind it is just to go from highest value to the lowest possible and to add some special cases to the hash table.\n\nThat's it"
                    },
                    {
                        "username": "akotb3",
                        "content": "\\nthis is the code I wrote  I believe it should work but evertime i put into leetcode it is  just out putting a bunch of IIIIIIII an example of this is if the input is 58 it would print : \"IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII\"\\n\\nclass Solution(object):\\n    def intToRoman(self, num):\\n        numdict = {1000:\"M\",\\n            900:\"CM\",\\n            500:\"D\",\\n            400:\"CD\",\\n            100:\"C\",\\n            90:\"XC\",\\n            50:\"L\",\\n            40:\"XL\",\\n            10:\"X\",\\n            9:\"IX\",\\n            5:\"V\",\\n            4:\"IV\",\\n            1:\"I\"\\n          }\\n        roman =\"\"\\n        for i in numdict.keys():\\n            while num >= i:\\n                num -= i\\n                roman += numdict[i]\\n            if num == 0:\\n                break\\n        return roman\\n\\nsolution = Solution()\\n\\n\\nresult = solution.intToRoman(1994)\\nprint(result)\\n\\n"
                    },
                    {
                        "username": "megan891685",
                        "content": "If I want to do this in c and not have memory leaks AND keep the compile time down, how should I return an array of char?\\nFor example.\\n `char *roman = (char*)malloc(sizeof(char)*8)\\n  char *arr =roman;\\n free(roman)\\n return arr; //will cause mem leaks\\n`\\n\\n `char *roman = (char*)malloc(sizeof(char)*8)\\n  char *arr;\\n  for(int i = 0; i < strlen(roman);i++){\\n arr[i] = roman[i];\\n}//going through for loop sounds like a giant waste.\\n free(roman)\\nreturn arr;\\n`"
                    },
                    {
                        "username": "0x6B0",
                        "content": "Have to give this a like, it deserves the upvote, even though it left me with 3 failed attempts "
                    },
                    {
                        "username": "Nwarr_Desirs",
                        "content": "please bros i don\\'t undestand, what is self?? why do i need it? "
                    },
                    {
                        "username": "Kei_Chen",
                        "content": "Self is something that 'represents' a function as a whole allowing you to access any variable inside the class, it doesn't have to be self (i.e. could be wjf), but is normally stated as it. For example, if we have two functions in the class, and we try to call one variable, this could be messy (if you get it). Take this as an example:\n\nclass Person:\n  def __init__(self, name: str, age: int) -> str:\n    self.name = name\n    self.age = age\n\n  def myfunc(abc):\n    return abc.name\n\nAlso you can refer to here: https://www.w3schools.com/python/gloss_python_self.asp#:~:text=The%20self%20parameter%20is%20a,that%20belongs%20to%20the%20class."
                    },
                    {
                        "username": "jetroll2014",
                        "content": "Idk why this is wrong.\n\nIt is clear that my result is same with the expected.... But it's a wrong answer.\n\nIdk why!!! Please someone help me :( \n\nnum=3, Output:\"III\", Expected:\"III\"\nnum=58, Output:\"LVIII\", Expected:\"LVIII\"\n\n\n `class Solution {\npublic:\n    string intToRoman(int num) {\n        int value = 0;\n        int count=0;\n        string result;\n        result+='M'*(num/1000);\n        num%=1000;\n        int idx = num/100;\n        if(idx ==9){\n            result+=\"CM\";\n        }\n        else if(idx==4){\n            result+=\"CD\";\n        }\n        else\n        {result.append(idx/5, 'D');\n        result.append(idx%5, 'C');\n        }\n        num%=100;\n        idx = num/10;\n        if(idx==9){\n            result+=\"XC\";\n        }\n        else if(idx==4){\n            result+=\"XL\";\n        }\n        else\n        {result.append(idx/5, 'L');\n        result.append(idx%5, 'X');\n        }\n        num%=10;\n        if(num==9){\n            result+=\"IX\";\n        }\n        else if(num==4){\n            result+=\"IV\";\n        }\n        else\n        {\n            result.append(num/5, 'V');\n            result.append(num%5, 'I');\n        }\n        return result;\n    }\n};`"
                    },
                    {
                        "username": "EmreArslan",
                        "content": "As I said in this code's comment sections, your code sets 0th index of result string as null. If the value is smaller than 1000. Also, your code doesn't multiplicate the 'M' if the number is bigger than 1000.\n\nHere is the fixed code with comment sections that explains the situation:\n\n```\nclass Solution { \n    public: string intToRoman(int num) \n    { \n        int value = 0; \n        int count=0; \n        string result;\n\n        //In this line, the initial char of 'result' string can be Null\n        // result+='M'*(num/1000); \n\n        //So that, I deactivated this line and wrote this if conditional and while loop\n        if(num/1000){\n            while(num >= 1000){\n                result += 'M';\n                num-=1000;\n            }\n        };\n        \n        // num%=1000; \n        int idx = num/100; \n        if(idx ==9){ result+=\"CM\"; } \n        else if(idx==4){ result+=\"CD\"; } \n        else {\n            result.append(idx/5, 'D'); \n            result.append(idx%5, 'C'); \n        } \n        num%=100; \n        idx = num/10; \n        if(idx==9){ \n            result+=\"XC\"; \n        } \n        else if(idx==4){ \n            result+=\"XL\"; \n        } \n        else {\n            result.append(idx/5, 'L'); \n            result.append(idx%5, 'X'); \n        } \n        num%=10; \n        if(num==9){ \n            result+=\"IX\"; \n        } \n        else if(num==4){ \n            result+=\"IV\"; \n        } \n        else { \n            result.append(num/5, 'V'); \n            result.append(num%5, 'I'); \n        } \n        return result; \n    } \n};\n```\n\nI hope it helps you "
                    },
                    {
                        "username": "arpitagrawal09",
                        "content": "Quite interesting question! "
                    },
                    {
                        "username": "anamrani17",
                        "content": "/**\\n * @param {number} num\\n * @return {string}\\n */\\nvar intToRoman = function(num) {\\n    // step 1: create a lookup table\\n    const lookupTable = {\\n       O: [\\'\\', \\'I\\', \\'II\\', \\'III\\', \\'IV\\', \\'V\\', \\'VI\\', \\'VII\\', \\'VIII\\', \\'IX\\'],\\n        T: [\\'\\', \\'X\\', \\'XX\\', \\'XXX\\', \\'XL\\', \\'L\\', \\'LX\\', \\'LXX\\', \\'LXXX\\', \\'XC\\'],\\n        H : [\\'\\', \\'C\\', \\'CC\\', \\'CCC\\', \\'CD\\', \\'D\\', \\'DC\\', \\'DCC\\', \\'DCCC\\', \\'CM\\'],\\n        Th : [\\'\\', \\'M\\', \\'MM\\', \\'MMM\\']\\n    }\\nreturn lookupTable.Th[Math.floor(num/1000)] + lookupTable.H[Math.floor((num%1000)/100)] + lookupTable.T[Math.floor((num%100)/10)] + lookupTable.O[num%10];\\n    \\n};\\n\\nhere is my solution of JavaScript code.\\nthe main line of code is return statement the expands the number then extract each digit one by one.\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "zbraven",
                        "content": "int bul(char ch,int value)\\n{\\n\\nswitch (ch)\\n{\\n    case \\'I\\':\\n        value += 1;\\n        break;\\n    case \\'V\\':\\n        value += 5;\\n        break;\\n    case \\'X\\':\\n        value += 10;\\n        break;\\n    case \\'L\\':\\n        value += 50;\\n        break;\\n    case \\'C\\':\\n        value += 100;\\n        break;\\n    case \\'D\\':\\n        value += 500;\\n        break;\\n    case \\'M\\':\\n        value += 1000;\\n            break;\\n }\\n    return value;\\n\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user9666yo",
                        "content": "//criado objeto com a correspondencia dos valores\\nconst symbols = {\\n  \\'I\\': 1,\\n  \\'V\\': 5,\\n  \\'X\\': 10,\\n  \\'L\\': 50,\\n  \\'C\\': 100,\\n  \\'D\\': 500,\\n  \\'M\\': 1000,\\n};\\n\\n//fun\\xE7ao contador total\\nfunction romanToInt(s) {\\n  let total = 0;\\n\\n//percorrer cada algarismo\\n  for (let i = 0; i < s.length; ++i) {\\n    const num1 = symbols[s[i]];\\n    const num2 = symbols[s[i + 1]];\\n\\n    if (num1 < num2) {\\n      total -= num1;\\n    } else {\\n      total += num1;\\n    }\\n  }\\n//retorna o total\\n  return total;\\n}\\n\\nconsole.log(romanToInt(\"MCMXCIV\"));"
                    }
                ]
            },
            {
                "id": 2048280,
                "content": [
                    {
                        "username": "mukeshgupta_",
                        "content": "I think its easy question. On GFG this is a Basic Question."
                    },
                    {
                        "username": "Code_Enthusiast232",
                        "content": "The intuition behind it is just to go from highest value to the lowest possible and to add some special cases to the hash table.\n\nThat's it"
                    },
                    {
                        "username": "akotb3",
                        "content": "\\nthis is the code I wrote  I believe it should work but evertime i put into leetcode it is  just out putting a bunch of IIIIIIII an example of this is if the input is 58 it would print : \"IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII\"\\n\\nclass Solution(object):\\n    def intToRoman(self, num):\\n        numdict = {1000:\"M\",\\n            900:\"CM\",\\n            500:\"D\",\\n            400:\"CD\",\\n            100:\"C\",\\n            90:\"XC\",\\n            50:\"L\",\\n            40:\"XL\",\\n            10:\"X\",\\n            9:\"IX\",\\n            5:\"V\",\\n            4:\"IV\",\\n            1:\"I\"\\n          }\\n        roman =\"\"\\n        for i in numdict.keys():\\n            while num >= i:\\n                num -= i\\n                roman += numdict[i]\\n            if num == 0:\\n                break\\n        return roman\\n\\nsolution = Solution()\\n\\n\\nresult = solution.intToRoman(1994)\\nprint(result)\\n\\n"
                    },
                    {
                        "username": "megan891685",
                        "content": "If I want to do this in c and not have memory leaks AND keep the compile time down, how should I return an array of char?\\nFor example.\\n `char *roman = (char*)malloc(sizeof(char)*8)\\n  char *arr =roman;\\n free(roman)\\n return arr; //will cause mem leaks\\n`\\n\\n `char *roman = (char*)malloc(sizeof(char)*8)\\n  char *arr;\\n  for(int i = 0; i < strlen(roman);i++){\\n arr[i] = roman[i];\\n}//going through for loop sounds like a giant waste.\\n free(roman)\\nreturn arr;\\n`"
                    },
                    {
                        "username": "0x6B0",
                        "content": "Have to give this a like, it deserves the upvote, even though it left me with 3 failed attempts "
                    },
                    {
                        "username": "Nwarr_Desirs",
                        "content": "please bros i don\\'t undestand, what is self?? why do i need it? "
                    },
                    {
                        "username": "Kei_Chen",
                        "content": "Self is something that 'represents' a function as a whole allowing you to access any variable inside the class, it doesn't have to be self (i.e. could be wjf), but is normally stated as it. For example, if we have two functions in the class, and we try to call one variable, this could be messy (if you get it). Take this as an example:\n\nclass Person:\n  def __init__(self, name: str, age: int) -> str:\n    self.name = name\n    self.age = age\n\n  def myfunc(abc):\n    return abc.name\n\nAlso you can refer to here: https://www.w3schools.com/python/gloss_python_self.asp#:~:text=The%20self%20parameter%20is%20a,that%20belongs%20to%20the%20class."
                    },
                    {
                        "username": "jetroll2014",
                        "content": "Idk why this is wrong.\n\nIt is clear that my result is same with the expected.... But it's a wrong answer.\n\nIdk why!!! Please someone help me :( \n\nnum=3, Output:\"III\", Expected:\"III\"\nnum=58, Output:\"LVIII\", Expected:\"LVIII\"\n\n\n `class Solution {\npublic:\n    string intToRoman(int num) {\n        int value = 0;\n        int count=0;\n        string result;\n        result+='M'*(num/1000);\n        num%=1000;\n        int idx = num/100;\n        if(idx ==9){\n            result+=\"CM\";\n        }\n        else if(idx==4){\n            result+=\"CD\";\n        }\n        else\n        {result.append(idx/5, 'D');\n        result.append(idx%5, 'C');\n        }\n        num%=100;\n        idx = num/10;\n        if(idx==9){\n            result+=\"XC\";\n        }\n        else if(idx==4){\n            result+=\"XL\";\n        }\n        else\n        {result.append(idx/5, 'L');\n        result.append(idx%5, 'X');\n        }\n        num%=10;\n        if(num==9){\n            result+=\"IX\";\n        }\n        else if(num==4){\n            result+=\"IV\";\n        }\n        else\n        {\n            result.append(num/5, 'V');\n            result.append(num%5, 'I');\n        }\n        return result;\n    }\n};`"
                    },
                    {
                        "username": "EmreArslan",
                        "content": "As I said in this code's comment sections, your code sets 0th index of result string as null. If the value is smaller than 1000. Also, your code doesn't multiplicate the 'M' if the number is bigger than 1000.\n\nHere is the fixed code with comment sections that explains the situation:\n\n```\nclass Solution { \n    public: string intToRoman(int num) \n    { \n        int value = 0; \n        int count=0; \n        string result;\n\n        //In this line, the initial char of 'result' string can be Null\n        // result+='M'*(num/1000); \n\n        //So that, I deactivated this line and wrote this if conditional and while loop\n        if(num/1000){\n            while(num >= 1000){\n                result += 'M';\n                num-=1000;\n            }\n        };\n        \n        // num%=1000; \n        int idx = num/100; \n        if(idx ==9){ result+=\"CM\"; } \n        else if(idx==4){ result+=\"CD\"; } \n        else {\n            result.append(idx/5, 'D'); \n            result.append(idx%5, 'C'); \n        } \n        num%=100; \n        idx = num/10; \n        if(idx==9){ \n            result+=\"XC\"; \n        } \n        else if(idx==4){ \n            result+=\"XL\"; \n        } \n        else {\n            result.append(idx/5, 'L'); \n            result.append(idx%5, 'X'); \n        } \n        num%=10; \n        if(num==9){ \n            result+=\"IX\"; \n        } \n        else if(num==4){ \n            result+=\"IV\"; \n        } \n        else { \n            result.append(num/5, 'V'); \n            result.append(num%5, 'I'); \n        } \n        return result; \n    } \n};\n```\n\nI hope it helps you "
                    },
                    {
                        "username": "arpitagrawal09",
                        "content": "Quite interesting question! "
                    },
                    {
                        "username": "anamrani17",
                        "content": "/**\\n * @param {number} num\\n * @return {string}\\n */\\nvar intToRoman = function(num) {\\n    // step 1: create a lookup table\\n    const lookupTable = {\\n       O: [\\'\\', \\'I\\', \\'II\\', \\'III\\', \\'IV\\', \\'V\\', \\'VI\\', \\'VII\\', \\'VIII\\', \\'IX\\'],\\n        T: [\\'\\', \\'X\\', \\'XX\\', \\'XXX\\', \\'XL\\', \\'L\\', \\'LX\\', \\'LXX\\', \\'LXXX\\', \\'XC\\'],\\n        H : [\\'\\', \\'C\\', \\'CC\\', \\'CCC\\', \\'CD\\', \\'D\\', \\'DC\\', \\'DCC\\', \\'DCCC\\', \\'CM\\'],\\n        Th : [\\'\\', \\'M\\', \\'MM\\', \\'MMM\\']\\n    }\\nreturn lookupTable.Th[Math.floor(num/1000)] + lookupTable.H[Math.floor((num%1000)/100)] + lookupTable.T[Math.floor((num%100)/10)] + lookupTable.O[num%10];\\n    \\n};\\n\\nhere is my solution of JavaScript code.\\nthe main line of code is return statement the expands the number then extract each digit one by one.\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "zbraven",
                        "content": "int bul(char ch,int value)\\n{\\n\\nswitch (ch)\\n{\\n    case \\'I\\':\\n        value += 1;\\n        break;\\n    case \\'V\\':\\n        value += 5;\\n        break;\\n    case \\'X\\':\\n        value += 10;\\n        break;\\n    case \\'L\\':\\n        value += 50;\\n        break;\\n    case \\'C\\':\\n        value += 100;\\n        break;\\n    case \\'D\\':\\n        value += 500;\\n        break;\\n    case \\'M\\':\\n        value += 1000;\\n            break;\\n }\\n    return value;\\n\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user9666yo",
                        "content": "//criado objeto com a correspondencia dos valores\\nconst symbols = {\\n  \\'I\\': 1,\\n  \\'V\\': 5,\\n  \\'X\\': 10,\\n  \\'L\\': 50,\\n  \\'C\\': 100,\\n  \\'D\\': 500,\\n  \\'M\\': 1000,\\n};\\n\\n//fun\\xE7ao contador total\\nfunction romanToInt(s) {\\n  let total = 0;\\n\\n//percorrer cada algarismo\\n  for (let i = 0; i < s.length; ++i) {\\n    const num1 = symbols[s[i]];\\n    const num2 = symbols[s[i + 1]];\\n\\n    if (num1 < num2) {\\n      total -= num1;\\n    } else {\\n      total += num1;\\n    }\\n  }\\n//retorna o total\\n  return total;\\n}\\n\\nconsole.log(romanToInt(\"MCMXCIV\"));"
                    }
                ]
            },
            {
                "id": 2038589,
                "content": [
                    {
                        "username": "mukeshgupta_",
                        "content": "I think its easy question. On GFG this is a Basic Question."
                    },
                    {
                        "username": "Code_Enthusiast232",
                        "content": "The intuition behind it is just to go from highest value to the lowest possible and to add some special cases to the hash table.\n\nThat's it"
                    },
                    {
                        "username": "akotb3",
                        "content": "\\nthis is the code I wrote  I believe it should work but evertime i put into leetcode it is  just out putting a bunch of IIIIIIII an example of this is if the input is 58 it would print : \"IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII\"\\n\\nclass Solution(object):\\n    def intToRoman(self, num):\\n        numdict = {1000:\"M\",\\n            900:\"CM\",\\n            500:\"D\",\\n            400:\"CD\",\\n            100:\"C\",\\n            90:\"XC\",\\n            50:\"L\",\\n            40:\"XL\",\\n            10:\"X\",\\n            9:\"IX\",\\n            5:\"V\",\\n            4:\"IV\",\\n            1:\"I\"\\n          }\\n        roman =\"\"\\n        for i in numdict.keys():\\n            while num >= i:\\n                num -= i\\n                roman += numdict[i]\\n            if num == 0:\\n                break\\n        return roman\\n\\nsolution = Solution()\\n\\n\\nresult = solution.intToRoman(1994)\\nprint(result)\\n\\n"
                    },
                    {
                        "username": "megan891685",
                        "content": "If I want to do this in c and not have memory leaks AND keep the compile time down, how should I return an array of char?\\nFor example.\\n `char *roman = (char*)malloc(sizeof(char)*8)\\n  char *arr =roman;\\n free(roman)\\n return arr; //will cause mem leaks\\n`\\n\\n `char *roman = (char*)malloc(sizeof(char)*8)\\n  char *arr;\\n  for(int i = 0; i < strlen(roman);i++){\\n arr[i] = roman[i];\\n}//going through for loop sounds like a giant waste.\\n free(roman)\\nreturn arr;\\n`"
                    },
                    {
                        "username": "0x6B0",
                        "content": "Have to give this a like, it deserves the upvote, even though it left me with 3 failed attempts "
                    },
                    {
                        "username": "Nwarr_Desirs",
                        "content": "please bros i don\\'t undestand, what is self?? why do i need it? "
                    },
                    {
                        "username": "Kei_Chen",
                        "content": "Self is something that 'represents' a function as a whole allowing you to access any variable inside the class, it doesn't have to be self (i.e. could be wjf), but is normally stated as it. For example, if we have two functions in the class, and we try to call one variable, this could be messy (if you get it). Take this as an example:\n\nclass Person:\n  def __init__(self, name: str, age: int) -> str:\n    self.name = name\n    self.age = age\n\n  def myfunc(abc):\n    return abc.name\n\nAlso you can refer to here: https://www.w3schools.com/python/gloss_python_self.asp#:~:text=The%20self%20parameter%20is%20a,that%20belongs%20to%20the%20class."
                    },
                    {
                        "username": "jetroll2014",
                        "content": "Idk why this is wrong.\n\nIt is clear that my result is same with the expected.... But it's a wrong answer.\n\nIdk why!!! Please someone help me :( \n\nnum=3, Output:\"III\", Expected:\"III\"\nnum=58, Output:\"LVIII\", Expected:\"LVIII\"\n\n\n `class Solution {\npublic:\n    string intToRoman(int num) {\n        int value = 0;\n        int count=0;\n        string result;\n        result+='M'*(num/1000);\n        num%=1000;\n        int idx = num/100;\n        if(idx ==9){\n            result+=\"CM\";\n        }\n        else if(idx==4){\n            result+=\"CD\";\n        }\n        else\n        {result.append(idx/5, 'D');\n        result.append(idx%5, 'C');\n        }\n        num%=100;\n        idx = num/10;\n        if(idx==9){\n            result+=\"XC\";\n        }\n        else if(idx==4){\n            result+=\"XL\";\n        }\n        else\n        {result.append(idx/5, 'L');\n        result.append(idx%5, 'X');\n        }\n        num%=10;\n        if(num==9){\n            result+=\"IX\";\n        }\n        else if(num==4){\n            result+=\"IV\";\n        }\n        else\n        {\n            result.append(num/5, 'V');\n            result.append(num%5, 'I');\n        }\n        return result;\n    }\n};`"
                    },
                    {
                        "username": "EmreArslan",
                        "content": "As I said in this code's comment sections, your code sets 0th index of result string as null. If the value is smaller than 1000. Also, your code doesn't multiplicate the 'M' if the number is bigger than 1000.\n\nHere is the fixed code with comment sections that explains the situation:\n\n```\nclass Solution { \n    public: string intToRoman(int num) \n    { \n        int value = 0; \n        int count=0; \n        string result;\n\n        //In this line, the initial char of 'result' string can be Null\n        // result+='M'*(num/1000); \n\n        //So that, I deactivated this line and wrote this if conditional and while loop\n        if(num/1000){\n            while(num >= 1000){\n                result += 'M';\n                num-=1000;\n            }\n        };\n        \n        // num%=1000; \n        int idx = num/100; \n        if(idx ==9){ result+=\"CM\"; } \n        else if(idx==4){ result+=\"CD\"; } \n        else {\n            result.append(idx/5, 'D'); \n            result.append(idx%5, 'C'); \n        } \n        num%=100; \n        idx = num/10; \n        if(idx==9){ \n            result+=\"XC\"; \n        } \n        else if(idx==4){ \n            result+=\"XL\"; \n        } \n        else {\n            result.append(idx/5, 'L'); \n            result.append(idx%5, 'X'); \n        } \n        num%=10; \n        if(num==9){ \n            result+=\"IX\"; \n        } \n        else if(num==4){ \n            result+=\"IV\"; \n        } \n        else { \n            result.append(num/5, 'V'); \n            result.append(num%5, 'I'); \n        } \n        return result; \n    } \n};\n```\n\nI hope it helps you "
                    },
                    {
                        "username": "arpitagrawal09",
                        "content": "Quite interesting question! "
                    },
                    {
                        "username": "anamrani17",
                        "content": "/**\\n * @param {number} num\\n * @return {string}\\n */\\nvar intToRoman = function(num) {\\n    // step 1: create a lookup table\\n    const lookupTable = {\\n       O: [\\'\\', \\'I\\', \\'II\\', \\'III\\', \\'IV\\', \\'V\\', \\'VI\\', \\'VII\\', \\'VIII\\', \\'IX\\'],\\n        T: [\\'\\', \\'X\\', \\'XX\\', \\'XXX\\', \\'XL\\', \\'L\\', \\'LX\\', \\'LXX\\', \\'LXXX\\', \\'XC\\'],\\n        H : [\\'\\', \\'C\\', \\'CC\\', \\'CCC\\', \\'CD\\', \\'D\\', \\'DC\\', \\'DCC\\', \\'DCCC\\', \\'CM\\'],\\n        Th : [\\'\\', \\'M\\', \\'MM\\', \\'MMM\\']\\n    }\\nreturn lookupTable.Th[Math.floor(num/1000)] + lookupTable.H[Math.floor((num%1000)/100)] + lookupTable.T[Math.floor((num%100)/10)] + lookupTable.O[num%10];\\n    \\n};\\n\\nhere is my solution of JavaScript code.\\nthe main line of code is return statement the expands the number then extract each digit one by one.\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "zbraven",
                        "content": "int bul(char ch,int value)\\n{\\n\\nswitch (ch)\\n{\\n    case \\'I\\':\\n        value += 1;\\n        break;\\n    case \\'V\\':\\n        value += 5;\\n        break;\\n    case \\'X\\':\\n        value += 10;\\n        break;\\n    case \\'L\\':\\n        value += 50;\\n        break;\\n    case \\'C\\':\\n        value += 100;\\n        break;\\n    case \\'D\\':\\n        value += 500;\\n        break;\\n    case \\'M\\':\\n        value += 1000;\\n            break;\\n }\\n    return value;\\n\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user9666yo",
                        "content": "//criado objeto com a correspondencia dos valores\\nconst symbols = {\\n  \\'I\\': 1,\\n  \\'V\\': 5,\\n  \\'X\\': 10,\\n  \\'L\\': 50,\\n  \\'C\\': 100,\\n  \\'D\\': 500,\\n  \\'M\\': 1000,\\n};\\n\\n//fun\\xE7ao contador total\\nfunction romanToInt(s) {\\n  let total = 0;\\n\\n//percorrer cada algarismo\\n  for (let i = 0; i < s.length; ++i) {\\n    const num1 = symbols[s[i]];\\n    const num2 = symbols[s[i + 1]];\\n\\n    if (num1 < num2) {\\n      total -= num1;\\n    } else {\\n      total += num1;\\n    }\\n  }\\n//retorna o total\\n  return total;\\n}\\n\\nconsole.log(romanToInt(\"MCMXCIV\"));"
                    }
                ]
            },
            {
                "id": 1968531,
                "content": [
                    {
                        "username": "mukeshgupta_",
                        "content": "I think its easy question. On GFG this is a Basic Question."
                    },
                    {
                        "username": "Code_Enthusiast232",
                        "content": "The intuition behind it is just to go from highest value to the lowest possible and to add some special cases to the hash table.\n\nThat's it"
                    },
                    {
                        "username": "akotb3",
                        "content": "\\nthis is the code I wrote  I believe it should work but evertime i put into leetcode it is  just out putting a bunch of IIIIIIII an example of this is if the input is 58 it would print : \"IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII\"\\n\\nclass Solution(object):\\n    def intToRoman(self, num):\\n        numdict = {1000:\"M\",\\n            900:\"CM\",\\n            500:\"D\",\\n            400:\"CD\",\\n            100:\"C\",\\n            90:\"XC\",\\n            50:\"L\",\\n            40:\"XL\",\\n            10:\"X\",\\n            9:\"IX\",\\n            5:\"V\",\\n            4:\"IV\",\\n            1:\"I\"\\n          }\\n        roman =\"\"\\n        for i in numdict.keys():\\n            while num >= i:\\n                num -= i\\n                roman += numdict[i]\\n            if num == 0:\\n                break\\n        return roman\\n\\nsolution = Solution()\\n\\n\\nresult = solution.intToRoman(1994)\\nprint(result)\\n\\n"
                    },
                    {
                        "username": "megan891685",
                        "content": "If I want to do this in c and not have memory leaks AND keep the compile time down, how should I return an array of char?\\nFor example.\\n `char *roman = (char*)malloc(sizeof(char)*8)\\n  char *arr =roman;\\n free(roman)\\n return arr; //will cause mem leaks\\n`\\n\\n `char *roman = (char*)malloc(sizeof(char)*8)\\n  char *arr;\\n  for(int i = 0; i < strlen(roman);i++){\\n arr[i] = roman[i];\\n}//going through for loop sounds like a giant waste.\\n free(roman)\\nreturn arr;\\n`"
                    },
                    {
                        "username": "0x6B0",
                        "content": "Have to give this a like, it deserves the upvote, even though it left me with 3 failed attempts "
                    },
                    {
                        "username": "Nwarr_Desirs",
                        "content": "please bros i don\\'t undestand, what is self?? why do i need it? "
                    },
                    {
                        "username": "Kei_Chen",
                        "content": "Self is something that 'represents' a function as a whole allowing you to access any variable inside the class, it doesn't have to be self (i.e. could be wjf), but is normally stated as it. For example, if we have two functions in the class, and we try to call one variable, this could be messy (if you get it). Take this as an example:\n\nclass Person:\n  def __init__(self, name: str, age: int) -> str:\n    self.name = name\n    self.age = age\n\n  def myfunc(abc):\n    return abc.name\n\nAlso you can refer to here: https://www.w3schools.com/python/gloss_python_self.asp#:~:text=The%20self%20parameter%20is%20a,that%20belongs%20to%20the%20class."
                    },
                    {
                        "username": "jetroll2014",
                        "content": "Idk why this is wrong.\n\nIt is clear that my result is same with the expected.... But it's a wrong answer.\n\nIdk why!!! Please someone help me :( \n\nnum=3, Output:\"III\", Expected:\"III\"\nnum=58, Output:\"LVIII\", Expected:\"LVIII\"\n\n\n `class Solution {\npublic:\n    string intToRoman(int num) {\n        int value = 0;\n        int count=0;\n        string result;\n        result+='M'*(num/1000);\n        num%=1000;\n        int idx = num/100;\n        if(idx ==9){\n            result+=\"CM\";\n        }\n        else if(idx==4){\n            result+=\"CD\";\n        }\n        else\n        {result.append(idx/5, 'D');\n        result.append(idx%5, 'C');\n        }\n        num%=100;\n        idx = num/10;\n        if(idx==9){\n            result+=\"XC\";\n        }\n        else if(idx==4){\n            result+=\"XL\";\n        }\n        else\n        {result.append(idx/5, 'L');\n        result.append(idx%5, 'X');\n        }\n        num%=10;\n        if(num==9){\n            result+=\"IX\";\n        }\n        else if(num==4){\n            result+=\"IV\";\n        }\n        else\n        {\n            result.append(num/5, 'V');\n            result.append(num%5, 'I');\n        }\n        return result;\n    }\n};`"
                    },
                    {
                        "username": "EmreArslan",
                        "content": "As I said in this code's comment sections, your code sets 0th index of result string as null. If the value is smaller than 1000. Also, your code doesn't multiplicate the 'M' if the number is bigger than 1000.\n\nHere is the fixed code with comment sections that explains the situation:\n\n```\nclass Solution { \n    public: string intToRoman(int num) \n    { \n        int value = 0; \n        int count=0; \n        string result;\n\n        //In this line, the initial char of 'result' string can be Null\n        // result+='M'*(num/1000); \n\n        //So that, I deactivated this line and wrote this if conditional and while loop\n        if(num/1000){\n            while(num >= 1000){\n                result += 'M';\n                num-=1000;\n            }\n        };\n        \n        // num%=1000; \n        int idx = num/100; \n        if(idx ==9){ result+=\"CM\"; } \n        else if(idx==4){ result+=\"CD\"; } \n        else {\n            result.append(idx/5, 'D'); \n            result.append(idx%5, 'C'); \n        } \n        num%=100; \n        idx = num/10; \n        if(idx==9){ \n            result+=\"XC\"; \n        } \n        else if(idx==4){ \n            result+=\"XL\"; \n        } \n        else {\n            result.append(idx/5, 'L'); \n            result.append(idx%5, 'X'); \n        } \n        num%=10; \n        if(num==9){ \n            result+=\"IX\"; \n        } \n        else if(num==4){ \n            result+=\"IV\"; \n        } \n        else { \n            result.append(num/5, 'V'); \n            result.append(num%5, 'I'); \n        } \n        return result; \n    } \n};\n```\n\nI hope it helps you "
                    },
                    {
                        "username": "arpitagrawal09",
                        "content": "Quite interesting question! "
                    },
                    {
                        "username": "anamrani17",
                        "content": "/**\\n * @param {number} num\\n * @return {string}\\n */\\nvar intToRoman = function(num) {\\n    // step 1: create a lookup table\\n    const lookupTable = {\\n       O: [\\'\\', \\'I\\', \\'II\\', \\'III\\', \\'IV\\', \\'V\\', \\'VI\\', \\'VII\\', \\'VIII\\', \\'IX\\'],\\n        T: [\\'\\', \\'X\\', \\'XX\\', \\'XXX\\', \\'XL\\', \\'L\\', \\'LX\\', \\'LXX\\', \\'LXXX\\', \\'XC\\'],\\n        H : [\\'\\', \\'C\\', \\'CC\\', \\'CCC\\', \\'CD\\', \\'D\\', \\'DC\\', \\'DCC\\', \\'DCCC\\', \\'CM\\'],\\n        Th : [\\'\\', \\'M\\', \\'MM\\', \\'MMM\\']\\n    }\\nreturn lookupTable.Th[Math.floor(num/1000)] + lookupTable.H[Math.floor((num%1000)/100)] + lookupTable.T[Math.floor((num%100)/10)] + lookupTable.O[num%10];\\n    \\n};\\n\\nhere is my solution of JavaScript code.\\nthe main line of code is return statement the expands the number then extract each digit one by one.\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "zbraven",
                        "content": "int bul(char ch,int value)\\n{\\n\\nswitch (ch)\\n{\\n    case \\'I\\':\\n        value += 1;\\n        break;\\n    case \\'V\\':\\n        value += 5;\\n        break;\\n    case \\'X\\':\\n        value += 10;\\n        break;\\n    case \\'L\\':\\n        value += 50;\\n        break;\\n    case \\'C\\':\\n        value += 100;\\n        break;\\n    case \\'D\\':\\n        value += 500;\\n        break;\\n    case \\'M\\':\\n        value += 1000;\\n            break;\\n }\\n    return value;\\n\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user9666yo",
                        "content": "//criado objeto com a correspondencia dos valores\\nconst symbols = {\\n  \\'I\\': 1,\\n  \\'V\\': 5,\\n  \\'X\\': 10,\\n  \\'L\\': 50,\\n  \\'C\\': 100,\\n  \\'D\\': 500,\\n  \\'M\\': 1000,\\n};\\n\\n//fun\\xE7ao contador total\\nfunction romanToInt(s) {\\n  let total = 0;\\n\\n//percorrer cada algarismo\\n  for (let i = 0; i < s.length; ++i) {\\n    const num1 = symbols[s[i]];\\n    const num2 = symbols[s[i + 1]];\\n\\n    if (num1 < num2) {\\n      total -= num1;\\n    } else {\\n      total += num1;\\n    }\\n  }\\n//retorna o total\\n  return total;\\n}\\n\\nconsole.log(romanToInt(\"MCMXCIV\"));"
                    }
                ]
            },
            {
                "id": 1964782,
                "content": [
                    {
                        "username": "mukeshgupta_",
                        "content": "I think its easy question. On GFG this is a Basic Question."
                    },
                    {
                        "username": "Code_Enthusiast232",
                        "content": "The intuition behind it is just to go from highest value to the lowest possible and to add some special cases to the hash table.\n\nThat's it"
                    },
                    {
                        "username": "akotb3",
                        "content": "\\nthis is the code I wrote  I believe it should work but evertime i put into leetcode it is  just out putting a bunch of IIIIIIII an example of this is if the input is 58 it would print : \"IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII\"\\n\\nclass Solution(object):\\n    def intToRoman(self, num):\\n        numdict = {1000:\"M\",\\n            900:\"CM\",\\n            500:\"D\",\\n            400:\"CD\",\\n            100:\"C\",\\n            90:\"XC\",\\n            50:\"L\",\\n            40:\"XL\",\\n            10:\"X\",\\n            9:\"IX\",\\n            5:\"V\",\\n            4:\"IV\",\\n            1:\"I\"\\n          }\\n        roman =\"\"\\n        for i in numdict.keys():\\n            while num >= i:\\n                num -= i\\n                roman += numdict[i]\\n            if num == 0:\\n                break\\n        return roman\\n\\nsolution = Solution()\\n\\n\\nresult = solution.intToRoman(1994)\\nprint(result)\\n\\n"
                    },
                    {
                        "username": "megan891685",
                        "content": "If I want to do this in c and not have memory leaks AND keep the compile time down, how should I return an array of char?\\nFor example.\\n `char *roman = (char*)malloc(sizeof(char)*8)\\n  char *arr =roman;\\n free(roman)\\n return arr; //will cause mem leaks\\n`\\n\\n `char *roman = (char*)malloc(sizeof(char)*8)\\n  char *arr;\\n  for(int i = 0; i < strlen(roman);i++){\\n arr[i] = roman[i];\\n}//going through for loop sounds like a giant waste.\\n free(roman)\\nreturn arr;\\n`"
                    },
                    {
                        "username": "0x6B0",
                        "content": "Have to give this a like, it deserves the upvote, even though it left me with 3 failed attempts "
                    },
                    {
                        "username": "Nwarr_Desirs",
                        "content": "please bros i don\\'t undestand, what is self?? why do i need it? "
                    },
                    {
                        "username": "Kei_Chen",
                        "content": "Self is something that 'represents' a function as a whole allowing you to access any variable inside the class, it doesn't have to be self (i.e. could be wjf), but is normally stated as it. For example, if we have two functions in the class, and we try to call one variable, this could be messy (if you get it). Take this as an example:\n\nclass Person:\n  def __init__(self, name: str, age: int) -> str:\n    self.name = name\n    self.age = age\n\n  def myfunc(abc):\n    return abc.name\n\nAlso you can refer to here: https://www.w3schools.com/python/gloss_python_self.asp#:~:text=The%20self%20parameter%20is%20a,that%20belongs%20to%20the%20class."
                    },
                    {
                        "username": "jetroll2014",
                        "content": "Idk why this is wrong.\n\nIt is clear that my result is same with the expected.... But it's a wrong answer.\n\nIdk why!!! Please someone help me :( \n\nnum=3, Output:\"III\", Expected:\"III\"\nnum=58, Output:\"LVIII\", Expected:\"LVIII\"\n\n\n `class Solution {\npublic:\n    string intToRoman(int num) {\n        int value = 0;\n        int count=0;\n        string result;\n        result+='M'*(num/1000);\n        num%=1000;\n        int idx = num/100;\n        if(idx ==9){\n            result+=\"CM\";\n        }\n        else if(idx==4){\n            result+=\"CD\";\n        }\n        else\n        {result.append(idx/5, 'D');\n        result.append(idx%5, 'C');\n        }\n        num%=100;\n        idx = num/10;\n        if(idx==9){\n            result+=\"XC\";\n        }\n        else if(idx==4){\n            result+=\"XL\";\n        }\n        else\n        {result.append(idx/5, 'L');\n        result.append(idx%5, 'X');\n        }\n        num%=10;\n        if(num==9){\n            result+=\"IX\";\n        }\n        else if(num==4){\n            result+=\"IV\";\n        }\n        else\n        {\n            result.append(num/5, 'V');\n            result.append(num%5, 'I');\n        }\n        return result;\n    }\n};`"
                    },
                    {
                        "username": "EmreArslan",
                        "content": "As I said in this code's comment sections, your code sets 0th index of result string as null. If the value is smaller than 1000. Also, your code doesn't multiplicate the 'M' if the number is bigger than 1000.\n\nHere is the fixed code with comment sections that explains the situation:\n\n```\nclass Solution { \n    public: string intToRoman(int num) \n    { \n        int value = 0; \n        int count=0; \n        string result;\n\n        //In this line, the initial char of 'result' string can be Null\n        // result+='M'*(num/1000); \n\n        //So that, I deactivated this line and wrote this if conditional and while loop\n        if(num/1000){\n            while(num >= 1000){\n                result += 'M';\n                num-=1000;\n            }\n        };\n        \n        // num%=1000; \n        int idx = num/100; \n        if(idx ==9){ result+=\"CM\"; } \n        else if(idx==4){ result+=\"CD\"; } \n        else {\n            result.append(idx/5, 'D'); \n            result.append(idx%5, 'C'); \n        } \n        num%=100; \n        idx = num/10; \n        if(idx==9){ \n            result+=\"XC\"; \n        } \n        else if(idx==4){ \n            result+=\"XL\"; \n        } \n        else {\n            result.append(idx/5, 'L'); \n            result.append(idx%5, 'X'); \n        } \n        num%=10; \n        if(num==9){ \n            result+=\"IX\"; \n        } \n        else if(num==4){ \n            result+=\"IV\"; \n        } \n        else { \n            result.append(num/5, 'V'); \n            result.append(num%5, 'I'); \n        } \n        return result; \n    } \n};\n```\n\nI hope it helps you "
                    },
                    {
                        "username": "arpitagrawal09",
                        "content": "Quite interesting question! "
                    },
                    {
                        "username": "anamrani17",
                        "content": "/**\\n * @param {number} num\\n * @return {string}\\n */\\nvar intToRoman = function(num) {\\n    // step 1: create a lookup table\\n    const lookupTable = {\\n       O: [\\'\\', \\'I\\', \\'II\\', \\'III\\', \\'IV\\', \\'V\\', \\'VI\\', \\'VII\\', \\'VIII\\', \\'IX\\'],\\n        T: [\\'\\', \\'X\\', \\'XX\\', \\'XXX\\', \\'XL\\', \\'L\\', \\'LX\\', \\'LXX\\', \\'LXXX\\', \\'XC\\'],\\n        H : [\\'\\', \\'C\\', \\'CC\\', \\'CCC\\', \\'CD\\', \\'D\\', \\'DC\\', \\'DCC\\', \\'DCCC\\', \\'CM\\'],\\n        Th : [\\'\\', \\'M\\', \\'MM\\', \\'MMM\\']\\n    }\\nreturn lookupTable.Th[Math.floor(num/1000)] + lookupTable.H[Math.floor((num%1000)/100)] + lookupTable.T[Math.floor((num%100)/10)] + lookupTable.O[num%10];\\n    \\n};\\n\\nhere is my solution of JavaScript code.\\nthe main line of code is return statement the expands the number then extract each digit one by one.\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "zbraven",
                        "content": "int bul(char ch,int value)\\n{\\n\\nswitch (ch)\\n{\\n    case \\'I\\':\\n        value += 1;\\n        break;\\n    case \\'V\\':\\n        value += 5;\\n        break;\\n    case \\'X\\':\\n        value += 10;\\n        break;\\n    case \\'L\\':\\n        value += 50;\\n        break;\\n    case \\'C\\':\\n        value += 100;\\n        break;\\n    case \\'D\\':\\n        value += 500;\\n        break;\\n    case \\'M\\':\\n        value += 1000;\\n            break;\\n }\\n    return value;\\n\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user9666yo",
                        "content": "//criado objeto com a correspondencia dos valores\\nconst symbols = {\\n  \\'I\\': 1,\\n  \\'V\\': 5,\\n  \\'X\\': 10,\\n  \\'L\\': 50,\\n  \\'C\\': 100,\\n  \\'D\\': 500,\\n  \\'M\\': 1000,\\n};\\n\\n//fun\\xE7ao contador total\\nfunction romanToInt(s) {\\n  let total = 0;\\n\\n//percorrer cada algarismo\\n  for (let i = 0; i < s.length; ++i) {\\n    const num1 = symbols[s[i]];\\n    const num2 = symbols[s[i + 1]];\\n\\n    if (num1 < num2) {\\n      total -= num1;\\n    } else {\\n      total += num1;\\n    }\\n  }\\n//retorna o total\\n  return total;\\n}\\n\\nconsole.log(romanToInt(\"MCMXCIV\"));"
                    }
                ]
            },
            {
                "id": 1956594,
                "content": [
                    {
                        "username": "mukeshgupta_",
                        "content": "I think its easy question. On GFG this is a Basic Question."
                    },
                    {
                        "username": "Code_Enthusiast232",
                        "content": "The intuition behind it is just to go from highest value to the lowest possible and to add some special cases to the hash table.\n\nThat's it"
                    },
                    {
                        "username": "akotb3",
                        "content": "\\nthis is the code I wrote  I believe it should work but evertime i put into leetcode it is  just out putting a bunch of IIIIIIII an example of this is if the input is 58 it would print : \"IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII\"\\n\\nclass Solution(object):\\n    def intToRoman(self, num):\\n        numdict = {1000:\"M\",\\n            900:\"CM\",\\n            500:\"D\",\\n            400:\"CD\",\\n            100:\"C\",\\n            90:\"XC\",\\n            50:\"L\",\\n            40:\"XL\",\\n            10:\"X\",\\n            9:\"IX\",\\n            5:\"V\",\\n            4:\"IV\",\\n            1:\"I\"\\n          }\\n        roman =\"\"\\n        for i in numdict.keys():\\n            while num >= i:\\n                num -= i\\n                roman += numdict[i]\\n            if num == 0:\\n                break\\n        return roman\\n\\nsolution = Solution()\\n\\n\\nresult = solution.intToRoman(1994)\\nprint(result)\\n\\n"
                    },
                    {
                        "username": "megan891685",
                        "content": "If I want to do this in c and not have memory leaks AND keep the compile time down, how should I return an array of char?\\nFor example.\\n `char *roman = (char*)malloc(sizeof(char)*8)\\n  char *arr =roman;\\n free(roman)\\n return arr; //will cause mem leaks\\n`\\n\\n `char *roman = (char*)malloc(sizeof(char)*8)\\n  char *arr;\\n  for(int i = 0; i < strlen(roman);i++){\\n arr[i] = roman[i];\\n}//going through for loop sounds like a giant waste.\\n free(roman)\\nreturn arr;\\n`"
                    },
                    {
                        "username": "0x6B0",
                        "content": "Have to give this a like, it deserves the upvote, even though it left me with 3 failed attempts "
                    },
                    {
                        "username": "Nwarr_Desirs",
                        "content": "please bros i don\\'t undestand, what is self?? why do i need it? "
                    },
                    {
                        "username": "Kei_Chen",
                        "content": "Self is something that 'represents' a function as a whole allowing you to access any variable inside the class, it doesn't have to be self (i.e. could be wjf), but is normally stated as it. For example, if we have two functions in the class, and we try to call one variable, this could be messy (if you get it). Take this as an example:\n\nclass Person:\n  def __init__(self, name: str, age: int) -> str:\n    self.name = name\n    self.age = age\n\n  def myfunc(abc):\n    return abc.name\n\nAlso you can refer to here: https://www.w3schools.com/python/gloss_python_self.asp#:~:text=The%20self%20parameter%20is%20a,that%20belongs%20to%20the%20class."
                    },
                    {
                        "username": "jetroll2014",
                        "content": "Idk why this is wrong.\n\nIt is clear that my result is same with the expected.... But it's a wrong answer.\n\nIdk why!!! Please someone help me :( \n\nnum=3, Output:\"III\", Expected:\"III\"\nnum=58, Output:\"LVIII\", Expected:\"LVIII\"\n\n\n `class Solution {\npublic:\n    string intToRoman(int num) {\n        int value = 0;\n        int count=0;\n        string result;\n        result+='M'*(num/1000);\n        num%=1000;\n        int idx = num/100;\n        if(idx ==9){\n            result+=\"CM\";\n        }\n        else if(idx==4){\n            result+=\"CD\";\n        }\n        else\n        {result.append(idx/5, 'D');\n        result.append(idx%5, 'C');\n        }\n        num%=100;\n        idx = num/10;\n        if(idx==9){\n            result+=\"XC\";\n        }\n        else if(idx==4){\n            result+=\"XL\";\n        }\n        else\n        {result.append(idx/5, 'L');\n        result.append(idx%5, 'X');\n        }\n        num%=10;\n        if(num==9){\n            result+=\"IX\";\n        }\n        else if(num==4){\n            result+=\"IV\";\n        }\n        else\n        {\n            result.append(num/5, 'V');\n            result.append(num%5, 'I');\n        }\n        return result;\n    }\n};`"
                    },
                    {
                        "username": "EmreArslan",
                        "content": "As I said in this code's comment sections, your code sets 0th index of result string as null. If the value is smaller than 1000. Also, your code doesn't multiplicate the 'M' if the number is bigger than 1000.\n\nHere is the fixed code with comment sections that explains the situation:\n\n```\nclass Solution { \n    public: string intToRoman(int num) \n    { \n        int value = 0; \n        int count=0; \n        string result;\n\n        //In this line, the initial char of 'result' string can be Null\n        // result+='M'*(num/1000); \n\n        //So that, I deactivated this line and wrote this if conditional and while loop\n        if(num/1000){\n            while(num >= 1000){\n                result += 'M';\n                num-=1000;\n            }\n        };\n        \n        // num%=1000; \n        int idx = num/100; \n        if(idx ==9){ result+=\"CM\"; } \n        else if(idx==4){ result+=\"CD\"; } \n        else {\n            result.append(idx/5, 'D'); \n            result.append(idx%5, 'C'); \n        } \n        num%=100; \n        idx = num/10; \n        if(idx==9){ \n            result+=\"XC\"; \n        } \n        else if(idx==4){ \n            result+=\"XL\"; \n        } \n        else {\n            result.append(idx/5, 'L'); \n            result.append(idx%5, 'X'); \n        } \n        num%=10; \n        if(num==9){ \n            result+=\"IX\"; \n        } \n        else if(num==4){ \n            result+=\"IV\"; \n        } \n        else { \n            result.append(num/5, 'V'); \n            result.append(num%5, 'I'); \n        } \n        return result; \n    } \n};\n```\n\nI hope it helps you "
                    },
                    {
                        "username": "arpitagrawal09",
                        "content": "Quite interesting question! "
                    },
                    {
                        "username": "anamrani17",
                        "content": "/**\\n * @param {number} num\\n * @return {string}\\n */\\nvar intToRoman = function(num) {\\n    // step 1: create a lookup table\\n    const lookupTable = {\\n       O: [\\'\\', \\'I\\', \\'II\\', \\'III\\', \\'IV\\', \\'V\\', \\'VI\\', \\'VII\\', \\'VIII\\', \\'IX\\'],\\n        T: [\\'\\', \\'X\\', \\'XX\\', \\'XXX\\', \\'XL\\', \\'L\\', \\'LX\\', \\'LXX\\', \\'LXXX\\', \\'XC\\'],\\n        H : [\\'\\', \\'C\\', \\'CC\\', \\'CCC\\', \\'CD\\', \\'D\\', \\'DC\\', \\'DCC\\', \\'DCCC\\', \\'CM\\'],\\n        Th : [\\'\\', \\'M\\', \\'MM\\', \\'MMM\\']\\n    }\\nreturn lookupTable.Th[Math.floor(num/1000)] + lookupTable.H[Math.floor((num%1000)/100)] + lookupTable.T[Math.floor((num%100)/10)] + lookupTable.O[num%10];\\n    \\n};\\n\\nhere is my solution of JavaScript code.\\nthe main line of code is return statement the expands the number then extract each digit one by one.\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "zbraven",
                        "content": "int bul(char ch,int value)\\n{\\n\\nswitch (ch)\\n{\\n    case \\'I\\':\\n        value += 1;\\n        break;\\n    case \\'V\\':\\n        value += 5;\\n        break;\\n    case \\'X\\':\\n        value += 10;\\n        break;\\n    case \\'L\\':\\n        value += 50;\\n        break;\\n    case \\'C\\':\\n        value += 100;\\n        break;\\n    case \\'D\\':\\n        value += 500;\\n        break;\\n    case \\'M\\':\\n        value += 1000;\\n            break;\\n }\\n    return value;\\n\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user9666yo",
                        "content": "//criado objeto com a correspondencia dos valores\\nconst symbols = {\\n  \\'I\\': 1,\\n  \\'V\\': 5,\\n  \\'X\\': 10,\\n  \\'L\\': 50,\\n  \\'C\\': 100,\\n  \\'D\\': 500,\\n  \\'M\\': 1000,\\n};\\n\\n//fun\\xE7ao contador total\\nfunction romanToInt(s) {\\n  let total = 0;\\n\\n//percorrer cada algarismo\\n  for (let i = 0; i < s.length; ++i) {\\n    const num1 = symbols[s[i]];\\n    const num2 = symbols[s[i + 1]];\\n\\n    if (num1 < num2) {\\n      total -= num1;\\n    } else {\\n      total += num1;\\n    }\\n  }\\n//retorna o total\\n  return total;\\n}\\n\\nconsole.log(romanToInt(\"MCMXCIV\"));"
                    }
                ]
            },
            {
                "id": 1887061,
                "content": [
                    {
                        "username": "mukeshgupta_",
                        "content": "I think its easy question. On GFG this is a Basic Question."
                    },
                    {
                        "username": "Code_Enthusiast232",
                        "content": "The intuition behind it is just to go from highest value to the lowest possible and to add some special cases to the hash table.\n\nThat's it"
                    },
                    {
                        "username": "akotb3",
                        "content": "\\nthis is the code I wrote  I believe it should work but evertime i put into leetcode it is  just out putting a bunch of IIIIIIII an example of this is if the input is 58 it would print : \"IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII\"\\n\\nclass Solution(object):\\n    def intToRoman(self, num):\\n        numdict = {1000:\"M\",\\n            900:\"CM\",\\n            500:\"D\",\\n            400:\"CD\",\\n            100:\"C\",\\n            90:\"XC\",\\n            50:\"L\",\\n            40:\"XL\",\\n            10:\"X\",\\n            9:\"IX\",\\n            5:\"V\",\\n            4:\"IV\",\\n            1:\"I\"\\n          }\\n        roman =\"\"\\n        for i in numdict.keys():\\n            while num >= i:\\n                num -= i\\n                roman += numdict[i]\\n            if num == 0:\\n                break\\n        return roman\\n\\nsolution = Solution()\\n\\n\\nresult = solution.intToRoman(1994)\\nprint(result)\\n\\n"
                    },
                    {
                        "username": "megan891685",
                        "content": "If I want to do this in c and not have memory leaks AND keep the compile time down, how should I return an array of char?\\nFor example.\\n `char *roman = (char*)malloc(sizeof(char)*8)\\n  char *arr =roman;\\n free(roman)\\n return arr; //will cause mem leaks\\n`\\n\\n `char *roman = (char*)malloc(sizeof(char)*8)\\n  char *arr;\\n  for(int i = 0; i < strlen(roman);i++){\\n arr[i] = roman[i];\\n}//going through for loop sounds like a giant waste.\\n free(roman)\\nreturn arr;\\n`"
                    },
                    {
                        "username": "0x6B0",
                        "content": "Have to give this a like, it deserves the upvote, even though it left me with 3 failed attempts "
                    },
                    {
                        "username": "Nwarr_Desirs",
                        "content": "please bros i don\\'t undestand, what is self?? why do i need it? "
                    },
                    {
                        "username": "Kei_Chen",
                        "content": "Self is something that 'represents' a function as a whole allowing you to access any variable inside the class, it doesn't have to be self (i.e. could be wjf), but is normally stated as it. For example, if we have two functions in the class, and we try to call one variable, this could be messy (if you get it). Take this as an example:\n\nclass Person:\n  def __init__(self, name: str, age: int) -> str:\n    self.name = name\n    self.age = age\n\n  def myfunc(abc):\n    return abc.name\n\nAlso you can refer to here: https://www.w3schools.com/python/gloss_python_self.asp#:~:text=The%20self%20parameter%20is%20a,that%20belongs%20to%20the%20class."
                    },
                    {
                        "username": "jetroll2014",
                        "content": "Idk why this is wrong.\n\nIt is clear that my result is same with the expected.... But it's a wrong answer.\n\nIdk why!!! Please someone help me :( \n\nnum=3, Output:\"III\", Expected:\"III\"\nnum=58, Output:\"LVIII\", Expected:\"LVIII\"\n\n\n `class Solution {\npublic:\n    string intToRoman(int num) {\n        int value = 0;\n        int count=0;\n        string result;\n        result+='M'*(num/1000);\n        num%=1000;\n        int idx = num/100;\n        if(idx ==9){\n            result+=\"CM\";\n        }\n        else if(idx==4){\n            result+=\"CD\";\n        }\n        else\n        {result.append(idx/5, 'D');\n        result.append(idx%5, 'C');\n        }\n        num%=100;\n        idx = num/10;\n        if(idx==9){\n            result+=\"XC\";\n        }\n        else if(idx==4){\n            result+=\"XL\";\n        }\n        else\n        {result.append(idx/5, 'L');\n        result.append(idx%5, 'X');\n        }\n        num%=10;\n        if(num==9){\n            result+=\"IX\";\n        }\n        else if(num==4){\n            result+=\"IV\";\n        }\n        else\n        {\n            result.append(num/5, 'V');\n            result.append(num%5, 'I');\n        }\n        return result;\n    }\n};`"
                    },
                    {
                        "username": "EmreArslan",
                        "content": "As I said in this code's comment sections, your code sets 0th index of result string as null. If the value is smaller than 1000. Also, your code doesn't multiplicate the 'M' if the number is bigger than 1000.\n\nHere is the fixed code with comment sections that explains the situation:\n\n```\nclass Solution { \n    public: string intToRoman(int num) \n    { \n        int value = 0; \n        int count=0; \n        string result;\n\n        //In this line, the initial char of 'result' string can be Null\n        // result+='M'*(num/1000); \n\n        //So that, I deactivated this line and wrote this if conditional and while loop\n        if(num/1000){\n            while(num >= 1000){\n                result += 'M';\n                num-=1000;\n            }\n        };\n        \n        // num%=1000; \n        int idx = num/100; \n        if(idx ==9){ result+=\"CM\"; } \n        else if(idx==4){ result+=\"CD\"; } \n        else {\n            result.append(idx/5, 'D'); \n            result.append(idx%5, 'C'); \n        } \n        num%=100; \n        idx = num/10; \n        if(idx==9){ \n            result+=\"XC\"; \n        } \n        else if(idx==4){ \n            result+=\"XL\"; \n        } \n        else {\n            result.append(idx/5, 'L'); \n            result.append(idx%5, 'X'); \n        } \n        num%=10; \n        if(num==9){ \n            result+=\"IX\"; \n        } \n        else if(num==4){ \n            result+=\"IV\"; \n        } \n        else { \n            result.append(num/5, 'V'); \n            result.append(num%5, 'I'); \n        } \n        return result; \n    } \n};\n```\n\nI hope it helps you "
                    },
                    {
                        "username": "arpitagrawal09",
                        "content": "Quite interesting question! "
                    },
                    {
                        "username": "anamrani17",
                        "content": "/**\\n * @param {number} num\\n * @return {string}\\n */\\nvar intToRoman = function(num) {\\n    // step 1: create a lookup table\\n    const lookupTable = {\\n       O: [\\'\\', \\'I\\', \\'II\\', \\'III\\', \\'IV\\', \\'V\\', \\'VI\\', \\'VII\\', \\'VIII\\', \\'IX\\'],\\n        T: [\\'\\', \\'X\\', \\'XX\\', \\'XXX\\', \\'XL\\', \\'L\\', \\'LX\\', \\'LXX\\', \\'LXXX\\', \\'XC\\'],\\n        H : [\\'\\', \\'C\\', \\'CC\\', \\'CCC\\', \\'CD\\', \\'D\\', \\'DC\\', \\'DCC\\', \\'DCCC\\', \\'CM\\'],\\n        Th : [\\'\\', \\'M\\', \\'MM\\', \\'MMM\\']\\n    }\\nreturn lookupTable.Th[Math.floor(num/1000)] + lookupTable.H[Math.floor((num%1000)/100)] + lookupTable.T[Math.floor((num%100)/10)] + lookupTable.O[num%10];\\n    \\n};\\n\\nhere is my solution of JavaScript code.\\nthe main line of code is return statement the expands the number then extract each digit one by one.\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "zbraven",
                        "content": "int bul(char ch,int value)\\n{\\n\\nswitch (ch)\\n{\\n    case \\'I\\':\\n        value += 1;\\n        break;\\n    case \\'V\\':\\n        value += 5;\\n        break;\\n    case \\'X\\':\\n        value += 10;\\n        break;\\n    case \\'L\\':\\n        value += 50;\\n        break;\\n    case \\'C\\':\\n        value += 100;\\n        break;\\n    case \\'D\\':\\n        value += 500;\\n        break;\\n    case \\'M\\':\\n        value += 1000;\\n            break;\\n }\\n    return value;\\n\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user9666yo",
                        "content": "//criado objeto com a correspondencia dos valores\\nconst symbols = {\\n  \\'I\\': 1,\\n  \\'V\\': 5,\\n  \\'X\\': 10,\\n  \\'L\\': 50,\\n  \\'C\\': 100,\\n  \\'D\\': 500,\\n  \\'M\\': 1000,\\n};\\n\\n//fun\\xE7ao contador total\\nfunction romanToInt(s) {\\n  let total = 0;\\n\\n//percorrer cada algarismo\\n  for (let i = 0; i < s.length; ++i) {\\n    const num1 = symbols[s[i]];\\n    const num2 = symbols[s[i + 1]];\\n\\n    if (num1 < num2) {\\n      total -= num1;\\n    } else {\\n      total += num1;\\n    }\\n  }\\n//retorna o total\\n  return total;\\n}\\n\\nconsole.log(romanToInt(\"MCMXCIV\"));"
                    }
                ]
            },
            {
                "id": 1865905,
                "content": [
                    {
                        "username": "mukeshgupta_",
                        "content": "I think its easy question. On GFG this is a Basic Question."
                    },
                    {
                        "username": "Code_Enthusiast232",
                        "content": "The intuition behind it is just to go from highest value to the lowest possible and to add some special cases to the hash table.\n\nThat's it"
                    },
                    {
                        "username": "akotb3",
                        "content": "\\nthis is the code I wrote  I believe it should work but evertime i put into leetcode it is  just out putting a bunch of IIIIIIII an example of this is if the input is 58 it would print : \"IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII\"\\n\\nclass Solution(object):\\n    def intToRoman(self, num):\\n        numdict = {1000:\"M\",\\n            900:\"CM\",\\n            500:\"D\",\\n            400:\"CD\",\\n            100:\"C\",\\n            90:\"XC\",\\n            50:\"L\",\\n            40:\"XL\",\\n            10:\"X\",\\n            9:\"IX\",\\n            5:\"V\",\\n            4:\"IV\",\\n            1:\"I\"\\n          }\\n        roman =\"\"\\n        for i in numdict.keys():\\n            while num >= i:\\n                num -= i\\n                roman += numdict[i]\\n            if num == 0:\\n                break\\n        return roman\\n\\nsolution = Solution()\\n\\n\\nresult = solution.intToRoman(1994)\\nprint(result)\\n\\n"
                    },
                    {
                        "username": "megan891685",
                        "content": "If I want to do this in c and not have memory leaks AND keep the compile time down, how should I return an array of char?\\nFor example.\\n `char *roman = (char*)malloc(sizeof(char)*8)\\n  char *arr =roman;\\n free(roman)\\n return arr; //will cause mem leaks\\n`\\n\\n `char *roman = (char*)malloc(sizeof(char)*8)\\n  char *arr;\\n  for(int i = 0; i < strlen(roman);i++){\\n arr[i] = roman[i];\\n}//going through for loop sounds like a giant waste.\\n free(roman)\\nreturn arr;\\n`"
                    },
                    {
                        "username": "0x6B0",
                        "content": "Have to give this a like, it deserves the upvote, even though it left me with 3 failed attempts "
                    },
                    {
                        "username": "Nwarr_Desirs",
                        "content": "please bros i don\\'t undestand, what is self?? why do i need it? "
                    },
                    {
                        "username": "Kei_Chen",
                        "content": "Self is something that 'represents' a function as a whole allowing you to access any variable inside the class, it doesn't have to be self (i.e. could be wjf), but is normally stated as it. For example, if we have two functions in the class, and we try to call one variable, this could be messy (if you get it). Take this as an example:\n\nclass Person:\n  def __init__(self, name: str, age: int) -> str:\n    self.name = name\n    self.age = age\n\n  def myfunc(abc):\n    return abc.name\n\nAlso you can refer to here: https://www.w3schools.com/python/gloss_python_self.asp#:~:text=The%20self%20parameter%20is%20a,that%20belongs%20to%20the%20class."
                    },
                    {
                        "username": "jetroll2014",
                        "content": "Idk why this is wrong.\n\nIt is clear that my result is same with the expected.... But it's a wrong answer.\n\nIdk why!!! Please someone help me :( \n\nnum=3, Output:\"III\", Expected:\"III\"\nnum=58, Output:\"LVIII\", Expected:\"LVIII\"\n\n\n `class Solution {\npublic:\n    string intToRoman(int num) {\n        int value = 0;\n        int count=0;\n        string result;\n        result+='M'*(num/1000);\n        num%=1000;\n        int idx = num/100;\n        if(idx ==9){\n            result+=\"CM\";\n        }\n        else if(idx==4){\n            result+=\"CD\";\n        }\n        else\n        {result.append(idx/5, 'D');\n        result.append(idx%5, 'C');\n        }\n        num%=100;\n        idx = num/10;\n        if(idx==9){\n            result+=\"XC\";\n        }\n        else if(idx==4){\n            result+=\"XL\";\n        }\n        else\n        {result.append(idx/5, 'L');\n        result.append(idx%5, 'X');\n        }\n        num%=10;\n        if(num==9){\n            result+=\"IX\";\n        }\n        else if(num==4){\n            result+=\"IV\";\n        }\n        else\n        {\n            result.append(num/5, 'V');\n            result.append(num%5, 'I');\n        }\n        return result;\n    }\n};`"
                    },
                    {
                        "username": "EmreArslan",
                        "content": "As I said in this code's comment sections, your code sets 0th index of result string as null. If the value is smaller than 1000. Also, your code doesn't multiplicate the 'M' if the number is bigger than 1000.\n\nHere is the fixed code with comment sections that explains the situation:\n\n```\nclass Solution { \n    public: string intToRoman(int num) \n    { \n        int value = 0; \n        int count=0; \n        string result;\n\n        //In this line, the initial char of 'result' string can be Null\n        // result+='M'*(num/1000); \n\n        //So that, I deactivated this line and wrote this if conditional and while loop\n        if(num/1000){\n            while(num >= 1000){\n                result += 'M';\n                num-=1000;\n            }\n        };\n        \n        // num%=1000; \n        int idx = num/100; \n        if(idx ==9){ result+=\"CM\"; } \n        else if(idx==4){ result+=\"CD\"; } \n        else {\n            result.append(idx/5, 'D'); \n            result.append(idx%5, 'C'); \n        } \n        num%=100; \n        idx = num/10; \n        if(idx==9){ \n            result+=\"XC\"; \n        } \n        else if(idx==4){ \n            result+=\"XL\"; \n        } \n        else {\n            result.append(idx/5, 'L'); \n            result.append(idx%5, 'X'); \n        } \n        num%=10; \n        if(num==9){ \n            result+=\"IX\"; \n        } \n        else if(num==4){ \n            result+=\"IV\"; \n        } \n        else { \n            result.append(num/5, 'V'); \n            result.append(num%5, 'I'); \n        } \n        return result; \n    } \n};\n```\n\nI hope it helps you "
                    },
                    {
                        "username": "arpitagrawal09",
                        "content": "Quite interesting question! "
                    },
                    {
                        "username": "anamrani17",
                        "content": "/**\\n * @param {number} num\\n * @return {string}\\n */\\nvar intToRoman = function(num) {\\n    // step 1: create a lookup table\\n    const lookupTable = {\\n       O: [\\'\\', \\'I\\', \\'II\\', \\'III\\', \\'IV\\', \\'V\\', \\'VI\\', \\'VII\\', \\'VIII\\', \\'IX\\'],\\n        T: [\\'\\', \\'X\\', \\'XX\\', \\'XXX\\', \\'XL\\', \\'L\\', \\'LX\\', \\'LXX\\', \\'LXXX\\', \\'XC\\'],\\n        H : [\\'\\', \\'C\\', \\'CC\\', \\'CCC\\', \\'CD\\', \\'D\\', \\'DC\\', \\'DCC\\', \\'DCCC\\', \\'CM\\'],\\n        Th : [\\'\\', \\'M\\', \\'MM\\', \\'MMM\\']\\n    }\\nreturn lookupTable.Th[Math.floor(num/1000)] + lookupTable.H[Math.floor((num%1000)/100)] + lookupTable.T[Math.floor((num%100)/10)] + lookupTable.O[num%10];\\n    \\n};\\n\\nhere is my solution of JavaScript code.\\nthe main line of code is return statement the expands the number then extract each digit one by one.\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "zbraven",
                        "content": "int bul(char ch,int value)\\n{\\n\\nswitch (ch)\\n{\\n    case \\'I\\':\\n        value += 1;\\n        break;\\n    case \\'V\\':\\n        value += 5;\\n        break;\\n    case \\'X\\':\\n        value += 10;\\n        break;\\n    case \\'L\\':\\n        value += 50;\\n        break;\\n    case \\'C\\':\\n        value += 100;\\n        break;\\n    case \\'D\\':\\n        value += 500;\\n        break;\\n    case \\'M\\':\\n        value += 1000;\\n            break;\\n }\\n    return value;\\n\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user9666yo",
                        "content": "//criado objeto com a correspondencia dos valores\\nconst symbols = {\\n  \\'I\\': 1,\\n  \\'V\\': 5,\\n  \\'X\\': 10,\\n  \\'L\\': 50,\\n  \\'C\\': 100,\\n  \\'D\\': 500,\\n  \\'M\\': 1000,\\n};\\n\\n//fun\\xE7ao contador total\\nfunction romanToInt(s) {\\n  let total = 0;\\n\\n//percorrer cada algarismo\\n  for (let i = 0; i < s.length; ++i) {\\n    const num1 = symbols[s[i]];\\n    const num2 = symbols[s[i + 1]];\\n\\n    if (num1 < num2) {\\n      total -= num1;\\n    } else {\\n      total += num1;\\n    }\\n  }\\n//retorna o total\\n  return total;\\n}\\n\\nconsole.log(romanToInt(\"MCMXCIV\"));"
                    }
                ]
            },
            {
                "id": 1818404,
                "content": [
                    {
                        "username": "mukeshgupta_",
                        "content": "I think its easy question. On GFG this is a Basic Question."
                    },
                    {
                        "username": "Code_Enthusiast232",
                        "content": "The intuition behind it is just to go from highest value to the lowest possible and to add some special cases to the hash table.\n\nThat's it"
                    },
                    {
                        "username": "akotb3",
                        "content": "\\nthis is the code I wrote  I believe it should work but evertime i put into leetcode it is  just out putting a bunch of IIIIIIII an example of this is if the input is 58 it would print : \"IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII\"\\n\\nclass Solution(object):\\n    def intToRoman(self, num):\\n        numdict = {1000:\"M\",\\n            900:\"CM\",\\n            500:\"D\",\\n            400:\"CD\",\\n            100:\"C\",\\n            90:\"XC\",\\n            50:\"L\",\\n            40:\"XL\",\\n            10:\"X\",\\n            9:\"IX\",\\n            5:\"V\",\\n            4:\"IV\",\\n            1:\"I\"\\n          }\\n        roman =\"\"\\n        for i in numdict.keys():\\n            while num >= i:\\n                num -= i\\n                roman += numdict[i]\\n            if num == 0:\\n                break\\n        return roman\\n\\nsolution = Solution()\\n\\n\\nresult = solution.intToRoman(1994)\\nprint(result)\\n\\n"
                    },
                    {
                        "username": "megan891685",
                        "content": "If I want to do this in c and not have memory leaks AND keep the compile time down, how should I return an array of char?\\nFor example.\\n `char *roman = (char*)malloc(sizeof(char)*8)\\n  char *arr =roman;\\n free(roman)\\n return arr; //will cause mem leaks\\n`\\n\\n `char *roman = (char*)malloc(sizeof(char)*8)\\n  char *arr;\\n  for(int i = 0; i < strlen(roman);i++){\\n arr[i] = roman[i];\\n}//going through for loop sounds like a giant waste.\\n free(roman)\\nreturn arr;\\n`"
                    },
                    {
                        "username": "0x6B0",
                        "content": "Have to give this a like, it deserves the upvote, even though it left me with 3 failed attempts "
                    },
                    {
                        "username": "Nwarr_Desirs",
                        "content": "please bros i don\\'t undestand, what is self?? why do i need it? "
                    },
                    {
                        "username": "Kei_Chen",
                        "content": "Self is something that 'represents' a function as a whole allowing you to access any variable inside the class, it doesn't have to be self (i.e. could be wjf), but is normally stated as it. For example, if we have two functions in the class, and we try to call one variable, this could be messy (if you get it). Take this as an example:\n\nclass Person:\n  def __init__(self, name: str, age: int) -> str:\n    self.name = name\n    self.age = age\n\n  def myfunc(abc):\n    return abc.name\n\nAlso you can refer to here: https://www.w3schools.com/python/gloss_python_self.asp#:~:text=The%20self%20parameter%20is%20a,that%20belongs%20to%20the%20class."
                    },
                    {
                        "username": "jetroll2014",
                        "content": "Idk why this is wrong.\n\nIt is clear that my result is same with the expected.... But it's a wrong answer.\n\nIdk why!!! Please someone help me :( \n\nnum=3, Output:\"III\", Expected:\"III\"\nnum=58, Output:\"LVIII\", Expected:\"LVIII\"\n\n\n `class Solution {\npublic:\n    string intToRoman(int num) {\n        int value = 0;\n        int count=0;\n        string result;\n        result+='M'*(num/1000);\n        num%=1000;\n        int idx = num/100;\n        if(idx ==9){\n            result+=\"CM\";\n        }\n        else if(idx==4){\n            result+=\"CD\";\n        }\n        else\n        {result.append(idx/5, 'D');\n        result.append(idx%5, 'C');\n        }\n        num%=100;\n        idx = num/10;\n        if(idx==9){\n            result+=\"XC\";\n        }\n        else if(idx==4){\n            result+=\"XL\";\n        }\n        else\n        {result.append(idx/5, 'L');\n        result.append(idx%5, 'X');\n        }\n        num%=10;\n        if(num==9){\n            result+=\"IX\";\n        }\n        else if(num==4){\n            result+=\"IV\";\n        }\n        else\n        {\n            result.append(num/5, 'V');\n            result.append(num%5, 'I');\n        }\n        return result;\n    }\n};`"
                    },
                    {
                        "username": "EmreArslan",
                        "content": "As I said in this code's comment sections, your code sets 0th index of result string as null. If the value is smaller than 1000. Also, your code doesn't multiplicate the 'M' if the number is bigger than 1000.\n\nHere is the fixed code with comment sections that explains the situation:\n\n```\nclass Solution { \n    public: string intToRoman(int num) \n    { \n        int value = 0; \n        int count=0; \n        string result;\n\n        //In this line, the initial char of 'result' string can be Null\n        // result+='M'*(num/1000); \n\n        //So that, I deactivated this line and wrote this if conditional and while loop\n        if(num/1000){\n            while(num >= 1000){\n                result += 'M';\n                num-=1000;\n            }\n        };\n        \n        // num%=1000; \n        int idx = num/100; \n        if(idx ==9){ result+=\"CM\"; } \n        else if(idx==4){ result+=\"CD\"; } \n        else {\n            result.append(idx/5, 'D'); \n            result.append(idx%5, 'C'); \n        } \n        num%=100; \n        idx = num/10; \n        if(idx==9){ \n            result+=\"XC\"; \n        } \n        else if(idx==4){ \n            result+=\"XL\"; \n        } \n        else {\n            result.append(idx/5, 'L'); \n            result.append(idx%5, 'X'); \n        } \n        num%=10; \n        if(num==9){ \n            result+=\"IX\"; \n        } \n        else if(num==4){ \n            result+=\"IV\"; \n        } \n        else { \n            result.append(num/5, 'V'); \n            result.append(num%5, 'I'); \n        } \n        return result; \n    } \n};\n```\n\nI hope it helps you "
                    },
                    {
                        "username": "arpitagrawal09",
                        "content": "Quite interesting question! "
                    },
                    {
                        "username": "anamrani17",
                        "content": "/**\\n * @param {number} num\\n * @return {string}\\n */\\nvar intToRoman = function(num) {\\n    // step 1: create a lookup table\\n    const lookupTable = {\\n       O: [\\'\\', \\'I\\', \\'II\\', \\'III\\', \\'IV\\', \\'V\\', \\'VI\\', \\'VII\\', \\'VIII\\', \\'IX\\'],\\n        T: [\\'\\', \\'X\\', \\'XX\\', \\'XXX\\', \\'XL\\', \\'L\\', \\'LX\\', \\'LXX\\', \\'LXXX\\', \\'XC\\'],\\n        H : [\\'\\', \\'C\\', \\'CC\\', \\'CCC\\', \\'CD\\', \\'D\\', \\'DC\\', \\'DCC\\', \\'DCCC\\', \\'CM\\'],\\n        Th : [\\'\\', \\'M\\', \\'MM\\', \\'MMM\\']\\n    }\\nreturn lookupTable.Th[Math.floor(num/1000)] + lookupTable.H[Math.floor((num%1000)/100)] + lookupTable.T[Math.floor((num%100)/10)] + lookupTable.O[num%10];\\n    \\n};\\n\\nhere is my solution of JavaScript code.\\nthe main line of code is return statement the expands the number then extract each digit one by one.\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "zbraven",
                        "content": "int bul(char ch,int value)\\n{\\n\\nswitch (ch)\\n{\\n    case \\'I\\':\\n        value += 1;\\n        break;\\n    case \\'V\\':\\n        value += 5;\\n        break;\\n    case \\'X\\':\\n        value += 10;\\n        break;\\n    case \\'L\\':\\n        value += 50;\\n        break;\\n    case \\'C\\':\\n        value += 100;\\n        break;\\n    case \\'D\\':\\n        value += 500;\\n        break;\\n    case \\'M\\':\\n        value += 1000;\\n            break;\\n }\\n    return value;\\n\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user9666yo",
                        "content": "//criado objeto com a correspondencia dos valores\\nconst symbols = {\\n  \\'I\\': 1,\\n  \\'V\\': 5,\\n  \\'X\\': 10,\\n  \\'L\\': 50,\\n  \\'C\\': 100,\\n  \\'D\\': 500,\\n  \\'M\\': 1000,\\n};\\n\\n//fun\\xE7ao contador total\\nfunction romanToInt(s) {\\n  let total = 0;\\n\\n//percorrer cada algarismo\\n  for (let i = 0; i < s.length; ++i) {\\n    const num1 = symbols[s[i]];\\n    const num2 = symbols[s[i + 1]];\\n\\n    if (num1 < num2) {\\n      total -= num1;\\n    } else {\\n      total += num1;\\n    }\\n  }\\n//retorna o total\\n  return total;\\n}\\n\\nconsole.log(romanToInt(\"MCMXCIV\"));"
                    }
                ]
            },
            {
                "id": 1804156,
                "content": [
                    {
                        "username": "haduong825",
                        "content": "Here is my stupid solution \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\n\\n `class Solution {\\n  String intToRoman(int num) {\\n    final oneMap = {1: \"I\", 10: \"X\", 100: \"C\", 1000: \"M\"};\\n    final fiveMap = {5: \"V\", 50: \"L\", 500: \"D\"};\\n    final inputStr =\\n        num.toString().split(\\'\\').reversed.map((e) => int.parse(e)).toList();\\n    var outputArray = List<String>.empty(growable: true);\\n    for (int i = 0; i < inputStr.length; i++) {\\n      if (inputStr[i] * pow(10, i) < (5 * pow(10, i) - pow(10, i))) {\\n        for (int j = 0; j < inputStr[i]; j++) {\\n          outputArray.add(oneMap[pow(10, i)] ?? \"\");\\n        }\\n      } else if (inputStr[i] * pow(10, i) < 9 * pow(10, i) &&\\n          inputStr[i] * pow(10, i) != (4 * pow(10, i))) {\\n        var tmpStr = \"\";\\n        tmpStr += fiveMap[5 * pow(10, i)] ?? \"\";\\n        for (int j = 0; j < inputStr[i] - 5; j++) {\\n          tmpStr += oneMap[pow(10, i)] ?? \"\";\\n        }\\n\\n        outputArray.add(tmpStr);\\n      } else if (inputStr[i] * pow(10, i) == (4 * pow(10, i))) {\\n        outputArray.add(\"${oneMap[pow(10, i)]}${fiveMap[5 * pow(10, i)]}\");\\n      } else if (inputStr[i] * pow(10, i) == (9 * pow(10, i))) {\\n        outputArray.add(\"${oneMap[pow(10, i)]}${oneMap[pow(10, i + 1)]}\");\\n      } else if (inputStr[i] * pow(10, (i + 1)) == (5 * pow(10, (i + 1)))) {\\n        outputArray.add(fiveMap[5 * pow(10, i)] ?? \"\");\\n      }\\n    }\\n\\n    return outputArray.reversed.reduce((value, element) => value + element);\\n  }\\n}`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nAnd here are the rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "maj-oliveira",
                        "content": "what is the complexity of this code?\\n\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        d = {1000:\\'M\\',900:\\'CM\\',500:\\'D\\',400:\\'CD\\',100:\\'C\\',90:\\'XC\\',50:\\'L\\',40:\\'XL\\',10:\\'X\\',9:\\'IX\\',5:\\'V\\',4:\\'IV\\',1:\\'I\\'}\\n        result = \"\"\\n\\n        while num !=0:\\n            for key in d:\\n                if key<=num or key==1:\\n                    div = num // key\\n                    for i in range(div):\\n                        result = result + d[key]\\n                    num = num % key\\n\\n        return result"
                    },
                    {
                        "username": "boy19970722",
                        "content": "can someone exmplain why 200 is LLLL instead of CC where 20 is XX instead of VVVV?"
                    },
                    {
                        "username": "jamesTheCoder",
                        "content": "200 is CC. Largest possible. "
                    },
                    {
                        "username": "adnanitzer",
                        "content": "Here is an easy way in JS, find the first number >= the result, add its symbol and substract it then continue\n `let roman = \"M\".repeat(parseInt(num/1000));\n    num = num%1000;\n    const nums = ['900', '500','400','100', '90','50',  '40',  '10', '9', '5','4', '1']\n    const rom = [\"CM\", 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I']\n    for (let i in nums){\n        while (num>=nums[i]){\n            roman+=rom[i]\n            num-=nums[i]\n        }\n    }\n    return roman;`"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "RASWQQW",
                        "content": "Can we this code but its shown as incorrect in testcase\n\n`\n\n\n        _dict = {1000: \"M\", 500: \"D\", 100: \"C\", 50: \"L\", 10: \"X\", 5: \"V\", 1: \"I\"}\n        # print(dict(reversed(list(_dict.items()))))\n\n        _digitLen = len(str(num))\n        num = str(num)[::-1]\n        dar = 1\n        text = ''\n        for elem in str(num):\n            elem = int(elem) * dar\n            for key, value in _dict.items():\n\n                if int(elem) == key:\n                    text+= value; break\n\n                elif int(elem) % key == 0:\n                    for _ in range(int(elem / dar)):\n                        text+=value\n\n                    break\n\n                elif 3 * dar >= int(elem) % key > 0 and int(elem) % key != elem:\n                    for ss in range(int(int(elem) % key / dar)):\n                        text+=_dict[dar]\n                    text += value\n                    break\n\n                elif int(elem) + dar == key:\n                    text+=value+_dict[dar]; \n                    \n                    break\n\n            dar *= 10\n\n        return text[::-1] `\n\n\n\n\n "
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "hsthanh00",
                        "content": "var roman = \"\";\\nfunction divided(num,romanNum){\\n    roman += romanNum ;\\n    if(num <= 0){\\n        return roman;\\n    }\\n    if( num>=1000){\\n        var romanNumber = \"M\".repeat(num/1000);\\n       return divided(num%1000,romanNumber)\\n    }\\n    if(num >= 900){\\n        var romanNumber = \"CM\".repeat(num/900);\\n       return divided(num%900,romanNumber)\\n    }\\n    if(num>=500){\\n        \\n        var romanNumber = \"D\".repeat(num/500);\\n        return divided(num%500,romanNumber)\\n    }\\n    if(num >= 400){\\n         var romanNumber = \"CD\".repeat(num/400);\\n        return divided(num%400,romanNumber)\\n    }\\n    if(num>=100){\\n        var romanNumber = \"C\".repeat(num/100);\\n        return divided(num%100,romanNumber)\\n    }\\n    if(num>=90){\\n         var romanNumber = \"XC\".repeat(num/90);\\n        return divided(num%90,romanNumber)\\n    }\\n    if(num>=50){\\n        var romanNumber = \"L\".repeat(num/50);\\n        return divided(num%50,romanNumber)\\n    }\\n    if(num>=40){\\n         var romanNumber = \"XL\".repeat(num/40);\\n        return divided(num%40,romanNumber)\\n    }\\n    \\n    if(num>=10){\\n        var romanNumber = \"X\".repeat(num/10);\\n        return divided(num%10,romanNumber)\\n    }\\n    if(num>=9){\\n         var romanNumber = \"IX\".repeat(num/9);\\n        return divided(num%9,romanNumber)\\n    }\\n     if(num>=5){\\n        var romanNumber = \"V\".repeat(num/5);\\n        return  divided(num%5,romanNumber)\\n    }\\n    if(num>=4){\\n         var romanNumber = \"IV\".repeat(num/4);\\n        return divided(num%4,romanNumber)\\n    }\\n     if(num>=1){\\n        var romanNumber = \"I\".repeat(num/1);\\n        return divided(num%1,romanNumber)\\n    }\\n    return roman; \\n}\\n\\nvar intToRoman = function(num) {\\n var roman = divided(num,\"\");\\n return roman \\n};\\n// how does it work when i code it on visual studio code but at \"leetcode\" it\\'s wrong. @@\\n"
                    },
                    {
                        "username": "RohitAgarwal08",
                        "content": "Explanation in Hindi\\n\\nhttps://youtu.be/fh5Q-2TvQwo"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1802501,
                "content": [
                    {
                        "username": "haduong825",
                        "content": "Here is my stupid solution \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\n\\n `class Solution {\\n  String intToRoman(int num) {\\n    final oneMap = {1: \"I\", 10: \"X\", 100: \"C\", 1000: \"M\"};\\n    final fiveMap = {5: \"V\", 50: \"L\", 500: \"D\"};\\n    final inputStr =\\n        num.toString().split(\\'\\').reversed.map((e) => int.parse(e)).toList();\\n    var outputArray = List<String>.empty(growable: true);\\n    for (int i = 0; i < inputStr.length; i++) {\\n      if (inputStr[i] * pow(10, i) < (5 * pow(10, i) - pow(10, i))) {\\n        for (int j = 0; j < inputStr[i]; j++) {\\n          outputArray.add(oneMap[pow(10, i)] ?? \"\");\\n        }\\n      } else if (inputStr[i] * pow(10, i) < 9 * pow(10, i) &&\\n          inputStr[i] * pow(10, i) != (4 * pow(10, i))) {\\n        var tmpStr = \"\";\\n        tmpStr += fiveMap[5 * pow(10, i)] ?? \"\";\\n        for (int j = 0; j < inputStr[i] - 5; j++) {\\n          tmpStr += oneMap[pow(10, i)] ?? \"\";\\n        }\\n\\n        outputArray.add(tmpStr);\\n      } else if (inputStr[i] * pow(10, i) == (4 * pow(10, i))) {\\n        outputArray.add(\"${oneMap[pow(10, i)]}${fiveMap[5 * pow(10, i)]}\");\\n      } else if (inputStr[i] * pow(10, i) == (9 * pow(10, i))) {\\n        outputArray.add(\"${oneMap[pow(10, i)]}${oneMap[pow(10, i + 1)]}\");\\n      } else if (inputStr[i] * pow(10, (i + 1)) == (5 * pow(10, (i + 1)))) {\\n        outputArray.add(fiveMap[5 * pow(10, i)] ?? \"\");\\n      }\\n    }\\n\\n    return outputArray.reversed.reduce((value, element) => value + element);\\n  }\\n}`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nAnd here are the rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "maj-oliveira",
                        "content": "what is the complexity of this code?\\n\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        d = {1000:\\'M\\',900:\\'CM\\',500:\\'D\\',400:\\'CD\\',100:\\'C\\',90:\\'XC\\',50:\\'L\\',40:\\'XL\\',10:\\'X\\',9:\\'IX\\',5:\\'V\\',4:\\'IV\\',1:\\'I\\'}\\n        result = \"\"\\n\\n        while num !=0:\\n            for key in d:\\n                if key<=num or key==1:\\n                    div = num // key\\n                    for i in range(div):\\n                        result = result + d[key]\\n                    num = num % key\\n\\n        return result"
                    },
                    {
                        "username": "boy19970722",
                        "content": "can someone exmplain why 200 is LLLL instead of CC where 20 is XX instead of VVVV?"
                    },
                    {
                        "username": "jamesTheCoder",
                        "content": "200 is CC. Largest possible. "
                    },
                    {
                        "username": "adnanitzer",
                        "content": "Here is an easy way in JS, find the first number >= the result, add its symbol and substract it then continue\n `let roman = \"M\".repeat(parseInt(num/1000));\n    num = num%1000;\n    const nums = ['900', '500','400','100', '90','50',  '40',  '10', '9', '5','4', '1']\n    const rom = [\"CM\", 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I']\n    for (let i in nums){\n        while (num>=nums[i]){\n            roman+=rom[i]\n            num-=nums[i]\n        }\n    }\n    return roman;`"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "RASWQQW",
                        "content": "Can we this code but its shown as incorrect in testcase\n\n`\n\n\n        _dict = {1000: \"M\", 500: \"D\", 100: \"C\", 50: \"L\", 10: \"X\", 5: \"V\", 1: \"I\"}\n        # print(dict(reversed(list(_dict.items()))))\n\n        _digitLen = len(str(num))\n        num = str(num)[::-1]\n        dar = 1\n        text = ''\n        for elem in str(num):\n            elem = int(elem) * dar\n            for key, value in _dict.items():\n\n                if int(elem) == key:\n                    text+= value; break\n\n                elif int(elem) % key == 0:\n                    for _ in range(int(elem / dar)):\n                        text+=value\n\n                    break\n\n                elif 3 * dar >= int(elem) % key > 0 and int(elem) % key != elem:\n                    for ss in range(int(int(elem) % key / dar)):\n                        text+=_dict[dar]\n                    text += value\n                    break\n\n                elif int(elem) + dar == key:\n                    text+=value+_dict[dar]; \n                    \n                    break\n\n            dar *= 10\n\n        return text[::-1] `\n\n\n\n\n "
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "hsthanh00",
                        "content": "var roman = \"\";\\nfunction divided(num,romanNum){\\n    roman += romanNum ;\\n    if(num <= 0){\\n        return roman;\\n    }\\n    if( num>=1000){\\n        var romanNumber = \"M\".repeat(num/1000);\\n       return divided(num%1000,romanNumber)\\n    }\\n    if(num >= 900){\\n        var romanNumber = \"CM\".repeat(num/900);\\n       return divided(num%900,romanNumber)\\n    }\\n    if(num>=500){\\n        \\n        var romanNumber = \"D\".repeat(num/500);\\n        return divided(num%500,romanNumber)\\n    }\\n    if(num >= 400){\\n         var romanNumber = \"CD\".repeat(num/400);\\n        return divided(num%400,romanNumber)\\n    }\\n    if(num>=100){\\n        var romanNumber = \"C\".repeat(num/100);\\n        return divided(num%100,romanNumber)\\n    }\\n    if(num>=90){\\n         var romanNumber = \"XC\".repeat(num/90);\\n        return divided(num%90,romanNumber)\\n    }\\n    if(num>=50){\\n        var romanNumber = \"L\".repeat(num/50);\\n        return divided(num%50,romanNumber)\\n    }\\n    if(num>=40){\\n         var romanNumber = \"XL\".repeat(num/40);\\n        return divided(num%40,romanNumber)\\n    }\\n    \\n    if(num>=10){\\n        var romanNumber = \"X\".repeat(num/10);\\n        return divided(num%10,romanNumber)\\n    }\\n    if(num>=9){\\n         var romanNumber = \"IX\".repeat(num/9);\\n        return divided(num%9,romanNumber)\\n    }\\n     if(num>=5){\\n        var romanNumber = \"V\".repeat(num/5);\\n        return  divided(num%5,romanNumber)\\n    }\\n    if(num>=4){\\n         var romanNumber = \"IV\".repeat(num/4);\\n        return divided(num%4,romanNumber)\\n    }\\n     if(num>=1){\\n        var romanNumber = \"I\".repeat(num/1);\\n        return divided(num%1,romanNumber)\\n    }\\n    return roman; \\n}\\n\\nvar intToRoman = function(num) {\\n var roman = divided(num,\"\");\\n return roman \\n};\\n// how does it work when i code it on visual studio code but at \"leetcode\" it\\'s wrong. @@\\n"
                    },
                    {
                        "username": "RohitAgarwal08",
                        "content": "Explanation in Hindi\\n\\nhttps://youtu.be/fh5Q-2TvQwo"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1799735,
                "content": [
                    {
                        "username": "haduong825",
                        "content": "Here is my stupid solution \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\n\\n `class Solution {\\n  String intToRoman(int num) {\\n    final oneMap = {1: \"I\", 10: \"X\", 100: \"C\", 1000: \"M\"};\\n    final fiveMap = {5: \"V\", 50: \"L\", 500: \"D\"};\\n    final inputStr =\\n        num.toString().split(\\'\\').reversed.map((e) => int.parse(e)).toList();\\n    var outputArray = List<String>.empty(growable: true);\\n    for (int i = 0; i < inputStr.length; i++) {\\n      if (inputStr[i] * pow(10, i) < (5 * pow(10, i) - pow(10, i))) {\\n        for (int j = 0; j < inputStr[i]; j++) {\\n          outputArray.add(oneMap[pow(10, i)] ?? \"\");\\n        }\\n      } else if (inputStr[i] * pow(10, i) < 9 * pow(10, i) &&\\n          inputStr[i] * pow(10, i) != (4 * pow(10, i))) {\\n        var tmpStr = \"\";\\n        tmpStr += fiveMap[5 * pow(10, i)] ?? \"\";\\n        for (int j = 0; j < inputStr[i] - 5; j++) {\\n          tmpStr += oneMap[pow(10, i)] ?? \"\";\\n        }\\n\\n        outputArray.add(tmpStr);\\n      } else if (inputStr[i] * pow(10, i) == (4 * pow(10, i))) {\\n        outputArray.add(\"${oneMap[pow(10, i)]}${fiveMap[5 * pow(10, i)]}\");\\n      } else if (inputStr[i] * pow(10, i) == (9 * pow(10, i))) {\\n        outputArray.add(\"${oneMap[pow(10, i)]}${oneMap[pow(10, i + 1)]}\");\\n      } else if (inputStr[i] * pow(10, (i + 1)) == (5 * pow(10, (i + 1)))) {\\n        outputArray.add(fiveMap[5 * pow(10, i)] ?? \"\");\\n      }\\n    }\\n\\n    return outputArray.reversed.reduce((value, element) => value + element);\\n  }\\n}`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nAnd here are the rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "maj-oliveira",
                        "content": "what is the complexity of this code?\\n\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        d = {1000:\\'M\\',900:\\'CM\\',500:\\'D\\',400:\\'CD\\',100:\\'C\\',90:\\'XC\\',50:\\'L\\',40:\\'XL\\',10:\\'X\\',9:\\'IX\\',5:\\'V\\',4:\\'IV\\',1:\\'I\\'}\\n        result = \"\"\\n\\n        while num !=0:\\n            for key in d:\\n                if key<=num or key==1:\\n                    div = num // key\\n                    for i in range(div):\\n                        result = result + d[key]\\n                    num = num % key\\n\\n        return result"
                    },
                    {
                        "username": "boy19970722",
                        "content": "can someone exmplain why 200 is LLLL instead of CC where 20 is XX instead of VVVV?"
                    },
                    {
                        "username": "jamesTheCoder",
                        "content": "200 is CC. Largest possible. "
                    },
                    {
                        "username": "adnanitzer",
                        "content": "Here is an easy way in JS, find the first number >= the result, add its symbol and substract it then continue\n `let roman = \"M\".repeat(parseInt(num/1000));\n    num = num%1000;\n    const nums = ['900', '500','400','100', '90','50',  '40',  '10', '9', '5','4', '1']\n    const rom = [\"CM\", 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I']\n    for (let i in nums){\n        while (num>=nums[i]){\n            roman+=rom[i]\n            num-=nums[i]\n        }\n    }\n    return roman;`"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "RASWQQW",
                        "content": "Can we this code but its shown as incorrect in testcase\n\n`\n\n\n        _dict = {1000: \"M\", 500: \"D\", 100: \"C\", 50: \"L\", 10: \"X\", 5: \"V\", 1: \"I\"}\n        # print(dict(reversed(list(_dict.items()))))\n\n        _digitLen = len(str(num))\n        num = str(num)[::-1]\n        dar = 1\n        text = ''\n        for elem in str(num):\n            elem = int(elem) * dar\n            for key, value in _dict.items():\n\n                if int(elem) == key:\n                    text+= value; break\n\n                elif int(elem) % key == 0:\n                    for _ in range(int(elem / dar)):\n                        text+=value\n\n                    break\n\n                elif 3 * dar >= int(elem) % key > 0 and int(elem) % key != elem:\n                    for ss in range(int(int(elem) % key / dar)):\n                        text+=_dict[dar]\n                    text += value\n                    break\n\n                elif int(elem) + dar == key:\n                    text+=value+_dict[dar]; \n                    \n                    break\n\n            dar *= 10\n\n        return text[::-1] `\n\n\n\n\n "
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "hsthanh00",
                        "content": "var roman = \"\";\\nfunction divided(num,romanNum){\\n    roman += romanNum ;\\n    if(num <= 0){\\n        return roman;\\n    }\\n    if( num>=1000){\\n        var romanNumber = \"M\".repeat(num/1000);\\n       return divided(num%1000,romanNumber)\\n    }\\n    if(num >= 900){\\n        var romanNumber = \"CM\".repeat(num/900);\\n       return divided(num%900,romanNumber)\\n    }\\n    if(num>=500){\\n        \\n        var romanNumber = \"D\".repeat(num/500);\\n        return divided(num%500,romanNumber)\\n    }\\n    if(num >= 400){\\n         var romanNumber = \"CD\".repeat(num/400);\\n        return divided(num%400,romanNumber)\\n    }\\n    if(num>=100){\\n        var romanNumber = \"C\".repeat(num/100);\\n        return divided(num%100,romanNumber)\\n    }\\n    if(num>=90){\\n         var romanNumber = \"XC\".repeat(num/90);\\n        return divided(num%90,romanNumber)\\n    }\\n    if(num>=50){\\n        var romanNumber = \"L\".repeat(num/50);\\n        return divided(num%50,romanNumber)\\n    }\\n    if(num>=40){\\n         var romanNumber = \"XL\".repeat(num/40);\\n        return divided(num%40,romanNumber)\\n    }\\n    \\n    if(num>=10){\\n        var romanNumber = \"X\".repeat(num/10);\\n        return divided(num%10,romanNumber)\\n    }\\n    if(num>=9){\\n         var romanNumber = \"IX\".repeat(num/9);\\n        return divided(num%9,romanNumber)\\n    }\\n     if(num>=5){\\n        var romanNumber = \"V\".repeat(num/5);\\n        return  divided(num%5,romanNumber)\\n    }\\n    if(num>=4){\\n         var romanNumber = \"IV\".repeat(num/4);\\n        return divided(num%4,romanNumber)\\n    }\\n     if(num>=1){\\n        var romanNumber = \"I\".repeat(num/1);\\n        return divided(num%1,romanNumber)\\n    }\\n    return roman; \\n}\\n\\nvar intToRoman = function(num) {\\n var roman = divided(num,\"\");\\n return roman \\n};\\n// how does it work when i code it on visual studio code but at \"leetcode\" it\\'s wrong. @@\\n"
                    },
                    {
                        "username": "RohitAgarwal08",
                        "content": "Explanation in Hindi\\n\\nhttps://youtu.be/fh5Q-2TvQwo"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1776009,
                "content": [
                    {
                        "username": "haduong825",
                        "content": "Here is my stupid solution \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\n\\n `class Solution {\\n  String intToRoman(int num) {\\n    final oneMap = {1: \"I\", 10: \"X\", 100: \"C\", 1000: \"M\"};\\n    final fiveMap = {5: \"V\", 50: \"L\", 500: \"D\"};\\n    final inputStr =\\n        num.toString().split(\\'\\').reversed.map((e) => int.parse(e)).toList();\\n    var outputArray = List<String>.empty(growable: true);\\n    for (int i = 0; i < inputStr.length; i++) {\\n      if (inputStr[i] * pow(10, i) < (5 * pow(10, i) - pow(10, i))) {\\n        for (int j = 0; j < inputStr[i]; j++) {\\n          outputArray.add(oneMap[pow(10, i)] ?? \"\");\\n        }\\n      } else if (inputStr[i] * pow(10, i) < 9 * pow(10, i) &&\\n          inputStr[i] * pow(10, i) != (4 * pow(10, i))) {\\n        var tmpStr = \"\";\\n        tmpStr += fiveMap[5 * pow(10, i)] ?? \"\";\\n        for (int j = 0; j < inputStr[i] - 5; j++) {\\n          tmpStr += oneMap[pow(10, i)] ?? \"\";\\n        }\\n\\n        outputArray.add(tmpStr);\\n      } else if (inputStr[i] * pow(10, i) == (4 * pow(10, i))) {\\n        outputArray.add(\"${oneMap[pow(10, i)]}${fiveMap[5 * pow(10, i)]}\");\\n      } else if (inputStr[i] * pow(10, i) == (9 * pow(10, i))) {\\n        outputArray.add(\"${oneMap[pow(10, i)]}${oneMap[pow(10, i + 1)]}\");\\n      } else if (inputStr[i] * pow(10, (i + 1)) == (5 * pow(10, (i + 1)))) {\\n        outputArray.add(fiveMap[5 * pow(10, i)] ?? \"\");\\n      }\\n    }\\n\\n    return outputArray.reversed.reduce((value, element) => value + element);\\n  }\\n}`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nAnd here are the rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "maj-oliveira",
                        "content": "what is the complexity of this code?\\n\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        d = {1000:\\'M\\',900:\\'CM\\',500:\\'D\\',400:\\'CD\\',100:\\'C\\',90:\\'XC\\',50:\\'L\\',40:\\'XL\\',10:\\'X\\',9:\\'IX\\',5:\\'V\\',4:\\'IV\\',1:\\'I\\'}\\n        result = \"\"\\n\\n        while num !=0:\\n            for key in d:\\n                if key<=num or key==1:\\n                    div = num // key\\n                    for i in range(div):\\n                        result = result + d[key]\\n                    num = num % key\\n\\n        return result"
                    },
                    {
                        "username": "boy19970722",
                        "content": "can someone exmplain why 200 is LLLL instead of CC where 20 is XX instead of VVVV?"
                    },
                    {
                        "username": "jamesTheCoder",
                        "content": "200 is CC. Largest possible. "
                    },
                    {
                        "username": "adnanitzer",
                        "content": "Here is an easy way in JS, find the first number >= the result, add its symbol and substract it then continue\n `let roman = \"M\".repeat(parseInt(num/1000));\n    num = num%1000;\n    const nums = ['900', '500','400','100', '90','50',  '40',  '10', '9', '5','4', '1']\n    const rom = [\"CM\", 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I']\n    for (let i in nums){\n        while (num>=nums[i]){\n            roman+=rom[i]\n            num-=nums[i]\n        }\n    }\n    return roman;`"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "RASWQQW",
                        "content": "Can we this code but its shown as incorrect in testcase\n\n`\n\n\n        _dict = {1000: \"M\", 500: \"D\", 100: \"C\", 50: \"L\", 10: \"X\", 5: \"V\", 1: \"I\"}\n        # print(dict(reversed(list(_dict.items()))))\n\n        _digitLen = len(str(num))\n        num = str(num)[::-1]\n        dar = 1\n        text = ''\n        for elem in str(num):\n            elem = int(elem) * dar\n            for key, value in _dict.items():\n\n                if int(elem) == key:\n                    text+= value; break\n\n                elif int(elem) % key == 0:\n                    for _ in range(int(elem / dar)):\n                        text+=value\n\n                    break\n\n                elif 3 * dar >= int(elem) % key > 0 and int(elem) % key != elem:\n                    for ss in range(int(int(elem) % key / dar)):\n                        text+=_dict[dar]\n                    text += value\n                    break\n\n                elif int(elem) + dar == key:\n                    text+=value+_dict[dar]; \n                    \n                    break\n\n            dar *= 10\n\n        return text[::-1] `\n\n\n\n\n "
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "hsthanh00",
                        "content": "var roman = \"\";\\nfunction divided(num,romanNum){\\n    roman += romanNum ;\\n    if(num <= 0){\\n        return roman;\\n    }\\n    if( num>=1000){\\n        var romanNumber = \"M\".repeat(num/1000);\\n       return divided(num%1000,romanNumber)\\n    }\\n    if(num >= 900){\\n        var romanNumber = \"CM\".repeat(num/900);\\n       return divided(num%900,romanNumber)\\n    }\\n    if(num>=500){\\n        \\n        var romanNumber = \"D\".repeat(num/500);\\n        return divided(num%500,romanNumber)\\n    }\\n    if(num >= 400){\\n         var romanNumber = \"CD\".repeat(num/400);\\n        return divided(num%400,romanNumber)\\n    }\\n    if(num>=100){\\n        var romanNumber = \"C\".repeat(num/100);\\n        return divided(num%100,romanNumber)\\n    }\\n    if(num>=90){\\n         var romanNumber = \"XC\".repeat(num/90);\\n        return divided(num%90,romanNumber)\\n    }\\n    if(num>=50){\\n        var romanNumber = \"L\".repeat(num/50);\\n        return divided(num%50,romanNumber)\\n    }\\n    if(num>=40){\\n         var romanNumber = \"XL\".repeat(num/40);\\n        return divided(num%40,romanNumber)\\n    }\\n    \\n    if(num>=10){\\n        var romanNumber = \"X\".repeat(num/10);\\n        return divided(num%10,romanNumber)\\n    }\\n    if(num>=9){\\n         var romanNumber = \"IX\".repeat(num/9);\\n        return divided(num%9,romanNumber)\\n    }\\n     if(num>=5){\\n        var romanNumber = \"V\".repeat(num/5);\\n        return  divided(num%5,romanNumber)\\n    }\\n    if(num>=4){\\n         var romanNumber = \"IV\".repeat(num/4);\\n        return divided(num%4,romanNumber)\\n    }\\n     if(num>=1){\\n        var romanNumber = \"I\".repeat(num/1);\\n        return divided(num%1,romanNumber)\\n    }\\n    return roman; \\n}\\n\\nvar intToRoman = function(num) {\\n var roman = divided(num,\"\");\\n return roman \\n};\\n// how does it work when i code it on visual studio code but at \"leetcode\" it\\'s wrong. @@\\n"
                    },
                    {
                        "username": "RohitAgarwal08",
                        "content": "Explanation in Hindi\\n\\nhttps://youtu.be/fh5Q-2TvQwo"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1768434,
                "content": [
                    {
                        "username": "haduong825",
                        "content": "Here is my stupid solution \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\n\\n `class Solution {\\n  String intToRoman(int num) {\\n    final oneMap = {1: \"I\", 10: \"X\", 100: \"C\", 1000: \"M\"};\\n    final fiveMap = {5: \"V\", 50: \"L\", 500: \"D\"};\\n    final inputStr =\\n        num.toString().split(\\'\\').reversed.map((e) => int.parse(e)).toList();\\n    var outputArray = List<String>.empty(growable: true);\\n    for (int i = 0; i < inputStr.length; i++) {\\n      if (inputStr[i] * pow(10, i) < (5 * pow(10, i) - pow(10, i))) {\\n        for (int j = 0; j < inputStr[i]; j++) {\\n          outputArray.add(oneMap[pow(10, i)] ?? \"\");\\n        }\\n      } else if (inputStr[i] * pow(10, i) < 9 * pow(10, i) &&\\n          inputStr[i] * pow(10, i) != (4 * pow(10, i))) {\\n        var tmpStr = \"\";\\n        tmpStr += fiveMap[5 * pow(10, i)] ?? \"\";\\n        for (int j = 0; j < inputStr[i] - 5; j++) {\\n          tmpStr += oneMap[pow(10, i)] ?? \"\";\\n        }\\n\\n        outputArray.add(tmpStr);\\n      } else if (inputStr[i] * pow(10, i) == (4 * pow(10, i))) {\\n        outputArray.add(\"${oneMap[pow(10, i)]}${fiveMap[5 * pow(10, i)]}\");\\n      } else if (inputStr[i] * pow(10, i) == (9 * pow(10, i))) {\\n        outputArray.add(\"${oneMap[pow(10, i)]}${oneMap[pow(10, i + 1)]}\");\\n      } else if (inputStr[i] * pow(10, (i + 1)) == (5 * pow(10, (i + 1)))) {\\n        outputArray.add(fiveMap[5 * pow(10, i)] ?? \"\");\\n      }\\n    }\\n\\n    return outputArray.reversed.reduce((value, element) => value + element);\\n  }\\n}`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nAnd here are the rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "maj-oliveira",
                        "content": "what is the complexity of this code?\\n\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        d = {1000:\\'M\\',900:\\'CM\\',500:\\'D\\',400:\\'CD\\',100:\\'C\\',90:\\'XC\\',50:\\'L\\',40:\\'XL\\',10:\\'X\\',9:\\'IX\\',5:\\'V\\',4:\\'IV\\',1:\\'I\\'}\\n        result = \"\"\\n\\n        while num !=0:\\n            for key in d:\\n                if key<=num or key==1:\\n                    div = num // key\\n                    for i in range(div):\\n                        result = result + d[key]\\n                    num = num % key\\n\\n        return result"
                    },
                    {
                        "username": "boy19970722",
                        "content": "can someone exmplain why 200 is LLLL instead of CC where 20 is XX instead of VVVV?"
                    },
                    {
                        "username": "jamesTheCoder",
                        "content": "200 is CC. Largest possible. "
                    },
                    {
                        "username": "adnanitzer",
                        "content": "Here is an easy way in JS, find the first number >= the result, add its symbol and substract it then continue\n `let roman = \"M\".repeat(parseInt(num/1000));\n    num = num%1000;\n    const nums = ['900', '500','400','100', '90','50',  '40',  '10', '9', '5','4', '1']\n    const rom = [\"CM\", 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I']\n    for (let i in nums){\n        while (num>=nums[i]){\n            roman+=rom[i]\n            num-=nums[i]\n        }\n    }\n    return roman;`"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "RASWQQW",
                        "content": "Can we this code but its shown as incorrect in testcase\n\n`\n\n\n        _dict = {1000: \"M\", 500: \"D\", 100: \"C\", 50: \"L\", 10: \"X\", 5: \"V\", 1: \"I\"}\n        # print(dict(reversed(list(_dict.items()))))\n\n        _digitLen = len(str(num))\n        num = str(num)[::-1]\n        dar = 1\n        text = ''\n        for elem in str(num):\n            elem = int(elem) * dar\n            for key, value in _dict.items():\n\n                if int(elem) == key:\n                    text+= value; break\n\n                elif int(elem) % key == 0:\n                    for _ in range(int(elem / dar)):\n                        text+=value\n\n                    break\n\n                elif 3 * dar >= int(elem) % key > 0 and int(elem) % key != elem:\n                    for ss in range(int(int(elem) % key / dar)):\n                        text+=_dict[dar]\n                    text += value\n                    break\n\n                elif int(elem) + dar == key:\n                    text+=value+_dict[dar]; \n                    \n                    break\n\n            dar *= 10\n\n        return text[::-1] `\n\n\n\n\n "
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "hsthanh00",
                        "content": "var roman = \"\";\\nfunction divided(num,romanNum){\\n    roman += romanNum ;\\n    if(num <= 0){\\n        return roman;\\n    }\\n    if( num>=1000){\\n        var romanNumber = \"M\".repeat(num/1000);\\n       return divided(num%1000,romanNumber)\\n    }\\n    if(num >= 900){\\n        var romanNumber = \"CM\".repeat(num/900);\\n       return divided(num%900,romanNumber)\\n    }\\n    if(num>=500){\\n        \\n        var romanNumber = \"D\".repeat(num/500);\\n        return divided(num%500,romanNumber)\\n    }\\n    if(num >= 400){\\n         var romanNumber = \"CD\".repeat(num/400);\\n        return divided(num%400,romanNumber)\\n    }\\n    if(num>=100){\\n        var romanNumber = \"C\".repeat(num/100);\\n        return divided(num%100,romanNumber)\\n    }\\n    if(num>=90){\\n         var romanNumber = \"XC\".repeat(num/90);\\n        return divided(num%90,romanNumber)\\n    }\\n    if(num>=50){\\n        var romanNumber = \"L\".repeat(num/50);\\n        return divided(num%50,romanNumber)\\n    }\\n    if(num>=40){\\n         var romanNumber = \"XL\".repeat(num/40);\\n        return divided(num%40,romanNumber)\\n    }\\n    \\n    if(num>=10){\\n        var romanNumber = \"X\".repeat(num/10);\\n        return divided(num%10,romanNumber)\\n    }\\n    if(num>=9){\\n         var romanNumber = \"IX\".repeat(num/9);\\n        return divided(num%9,romanNumber)\\n    }\\n     if(num>=5){\\n        var romanNumber = \"V\".repeat(num/5);\\n        return  divided(num%5,romanNumber)\\n    }\\n    if(num>=4){\\n         var romanNumber = \"IV\".repeat(num/4);\\n        return divided(num%4,romanNumber)\\n    }\\n     if(num>=1){\\n        var romanNumber = \"I\".repeat(num/1);\\n        return divided(num%1,romanNumber)\\n    }\\n    return roman; \\n}\\n\\nvar intToRoman = function(num) {\\n var roman = divided(num,\"\");\\n return roman \\n};\\n// how does it work when i code it on visual studio code but at \"leetcode\" it\\'s wrong. @@\\n"
                    },
                    {
                        "username": "RohitAgarwal08",
                        "content": "Explanation in Hindi\\n\\nhttps://youtu.be/fh5Q-2TvQwo"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1766388,
                "content": [
                    {
                        "username": "haduong825",
                        "content": "Here is my stupid solution \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\n\\n `class Solution {\\n  String intToRoman(int num) {\\n    final oneMap = {1: \"I\", 10: \"X\", 100: \"C\", 1000: \"M\"};\\n    final fiveMap = {5: \"V\", 50: \"L\", 500: \"D\"};\\n    final inputStr =\\n        num.toString().split(\\'\\').reversed.map((e) => int.parse(e)).toList();\\n    var outputArray = List<String>.empty(growable: true);\\n    for (int i = 0; i < inputStr.length; i++) {\\n      if (inputStr[i] * pow(10, i) < (5 * pow(10, i) - pow(10, i))) {\\n        for (int j = 0; j < inputStr[i]; j++) {\\n          outputArray.add(oneMap[pow(10, i)] ?? \"\");\\n        }\\n      } else if (inputStr[i] * pow(10, i) < 9 * pow(10, i) &&\\n          inputStr[i] * pow(10, i) != (4 * pow(10, i))) {\\n        var tmpStr = \"\";\\n        tmpStr += fiveMap[5 * pow(10, i)] ?? \"\";\\n        for (int j = 0; j < inputStr[i] - 5; j++) {\\n          tmpStr += oneMap[pow(10, i)] ?? \"\";\\n        }\\n\\n        outputArray.add(tmpStr);\\n      } else if (inputStr[i] * pow(10, i) == (4 * pow(10, i))) {\\n        outputArray.add(\"${oneMap[pow(10, i)]}${fiveMap[5 * pow(10, i)]}\");\\n      } else if (inputStr[i] * pow(10, i) == (9 * pow(10, i))) {\\n        outputArray.add(\"${oneMap[pow(10, i)]}${oneMap[pow(10, i + 1)]}\");\\n      } else if (inputStr[i] * pow(10, (i + 1)) == (5 * pow(10, (i + 1)))) {\\n        outputArray.add(fiveMap[5 * pow(10, i)] ?? \"\");\\n      }\\n    }\\n\\n    return outputArray.reversed.reduce((value, element) => value + element);\\n  }\\n}`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nAnd here are the rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "maj-oliveira",
                        "content": "what is the complexity of this code?\\n\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        d = {1000:\\'M\\',900:\\'CM\\',500:\\'D\\',400:\\'CD\\',100:\\'C\\',90:\\'XC\\',50:\\'L\\',40:\\'XL\\',10:\\'X\\',9:\\'IX\\',5:\\'V\\',4:\\'IV\\',1:\\'I\\'}\\n        result = \"\"\\n\\n        while num !=0:\\n            for key in d:\\n                if key<=num or key==1:\\n                    div = num // key\\n                    for i in range(div):\\n                        result = result + d[key]\\n                    num = num % key\\n\\n        return result"
                    },
                    {
                        "username": "boy19970722",
                        "content": "can someone exmplain why 200 is LLLL instead of CC where 20 is XX instead of VVVV?"
                    },
                    {
                        "username": "jamesTheCoder",
                        "content": "200 is CC. Largest possible. "
                    },
                    {
                        "username": "adnanitzer",
                        "content": "Here is an easy way in JS, find the first number >= the result, add its symbol and substract it then continue\n `let roman = \"M\".repeat(parseInt(num/1000));\n    num = num%1000;\n    const nums = ['900', '500','400','100', '90','50',  '40',  '10', '9', '5','4', '1']\n    const rom = [\"CM\", 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I']\n    for (let i in nums){\n        while (num>=nums[i]){\n            roman+=rom[i]\n            num-=nums[i]\n        }\n    }\n    return roman;`"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "RASWQQW",
                        "content": "Can we this code but its shown as incorrect in testcase\n\n`\n\n\n        _dict = {1000: \"M\", 500: \"D\", 100: \"C\", 50: \"L\", 10: \"X\", 5: \"V\", 1: \"I\"}\n        # print(dict(reversed(list(_dict.items()))))\n\n        _digitLen = len(str(num))\n        num = str(num)[::-1]\n        dar = 1\n        text = ''\n        for elem in str(num):\n            elem = int(elem) * dar\n            for key, value in _dict.items():\n\n                if int(elem) == key:\n                    text+= value; break\n\n                elif int(elem) % key == 0:\n                    for _ in range(int(elem / dar)):\n                        text+=value\n\n                    break\n\n                elif 3 * dar >= int(elem) % key > 0 and int(elem) % key != elem:\n                    for ss in range(int(int(elem) % key / dar)):\n                        text+=_dict[dar]\n                    text += value\n                    break\n\n                elif int(elem) + dar == key:\n                    text+=value+_dict[dar]; \n                    \n                    break\n\n            dar *= 10\n\n        return text[::-1] `\n\n\n\n\n "
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "hsthanh00",
                        "content": "var roman = \"\";\\nfunction divided(num,romanNum){\\n    roman += romanNum ;\\n    if(num <= 0){\\n        return roman;\\n    }\\n    if( num>=1000){\\n        var romanNumber = \"M\".repeat(num/1000);\\n       return divided(num%1000,romanNumber)\\n    }\\n    if(num >= 900){\\n        var romanNumber = \"CM\".repeat(num/900);\\n       return divided(num%900,romanNumber)\\n    }\\n    if(num>=500){\\n        \\n        var romanNumber = \"D\".repeat(num/500);\\n        return divided(num%500,romanNumber)\\n    }\\n    if(num >= 400){\\n         var romanNumber = \"CD\".repeat(num/400);\\n        return divided(num%400,romanNumber)\\n    }\\n    if(num>=100){\\n        var romanNumber = \"C\".repeat(num/100);\\n        return divided(num%100,romanNumber)\\n    }\\n    if(num>=90){\\n         var romanNumber = \"XC\".repeat(num/90);\\n        return divided(num%90,romanNumber)\\n    }\\n    if(num>=50){\\n        var romanNumber = \"L\".repeat(num/50);\\n        return divided(num%50,romanNumber)\\n    }\\n    if(num>=40){\\n         var romanNumber = \"XL\".repeat(num/40);\\n        return divided(num%40,romanNumber)\\n    }\\n    \\n    if(num>=10){\\n        var romanNumber = \"X\".repeat(num/10);\\n        return divided(num%10,romanNumber)\\n    }\\n    if(num>=9){\\n         var romanNumber = \"IX\".repeat(num/9);\\n        return divided(num%9,romanNumber)\\n    }\\n     if(num>=5){\\n        var romanNumber = \"V\".repeat(num/5);\\n        return  divided(num%5,romanNumber)\\n    }\\n    if(num>=4){\\n         var romanNumber = \"IV\".repeat(num/4);\\n        return divided(num%4,romanNumber)\\n    }\\n     if(num>=1){\\n        var romanNumber = \"I\".repeat(num/1);\\n        return divided(num%1,romanNumber)\\n    }\\n    return roman; \\n}\\n\\nvar intToRoman = function(num) {\\n var roman = divided(num,\"\");\\n return roman \\n};\\n// how does it work when i code it on visual studio code but at \"leetcode\" it\\'s wrong. @@\\n"
                    },
                    {
                        "username": "RohitAgarwal08",
                        "content": "Explanation in Hindi\\n\\nhttps://youtu.be/fh5Q-2TvQwo"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1766291,
                "content": [
                    {
                        "username": "haduong825",
                        "content": "Here is my stupid solution \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\n\\n `class Solution {\\n  String intToRoman(int num) {\\n    final oneMap = {1: \"I\", 10: \"X\", 100: \"C\", 1000: \"M\"};\\n    final fiveMap = {5: \"V\", 50: \"L\", 500: \"D\"};\\n    final inputStr =\\n        num.toString().split(\\'\\').reversed.map((e) => int.parse(e)).toList();\\n    var outputArray = List<String>.empty(growable: true);\\n    for (int i = 0; i < inputStr.length; i++) {\\n      if (inputStr[i] * pow(10, i) < (5 * pow(10, i) - pow(10, i))) {\\n        for (int j = 0; j < inputStr[i]; j++) {\\n          outputArray.add(oneMap[pow(10, i)] ?? \"\");\\n        }\\n      } else if (inputStr[i] * pow(10, i) < 9 * pow(10, i) &&\\n          inputStr[i] * pow(10, i) != (4 * pow(10, i))) {\\n        var tmpStr = \"\";\\n        tmpStr += fiveMap[5 * pow(10, i)] ?? \"\";\\n        for (int j = 0; j < inputStr[i] - 5; j++) {\\n          tmpStr += oneMap[pow(10, i)] ?? \"\";\\n        }\\n\\n        outputArray.add(tmpStr);\\n      } else if (inputStr[i] * pow(10, i) == (4 * pow(10, i))) {\\n        outputArray.add(\"${oneMap[pow(10, i)]}${fiveMap[5 * pow(10, i)]}\");\\n      } else if (inputStr[i] * pow(10, i) == (9 * pow(10, i))) {\\n        outputArray.add(\"${oneMap[pow(10, i)]}${oneMap[pow(10, i + 1)]}\");\\n      } else if (inputStr[i] * pow(10, (i + 1)) == (5 * pow(10, (i + 1)))) {\\n        outputArray.add(fiveMap[5 * pow(10, i)] ?? \"\");\\n      }\\n    }\\n\\n    return outputArray.reversed.reduce((value, element) => value + element);\\n  }\\n}`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nAnd here are the rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "maj-oliveira",
                        "content": "what is the complexity of this code?\\n\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        d = {1000:\\'M\\',900:\\'CM\\',500:\\'D\\',400:\\'CD\\',100:\\'C\\',90:\\'XC\\',50:\\'L\\',40:\\'XL\\',10:\\'X\\',9:\\'IX\\',5:\\'V\\',4:\\'IV\\',1:\\'I\\'}\\n        result = \"\"\\n\\n        while num !=0:\\n            for key in d:\\n                if key<=num or key==1:\\n                    div = num // key\\n                    for i in range(div):\\n                        result = result + d[key]\\n                    num = num % key\\n\\n        return result"
                    },
                    {
                        "username": "boy19970722",
                        "content": "can someone exmplain why 200 is LLLL instead of CC where 20 is XX instead of VVVV?"
                    },
                    {
                        "username": "jamesTheCoder",
                        "content": "200 is CC. Largest possible. "
                    },
                    {
                        "username": "adnanitzer",
                        "content": "Here is an easy way in JS, find the first number >= the result, add its symbol and substract it then continue\n `let roman = \"M\".repeat(parseInt(num/1000));\n    num = num%1000;\n    const nums = ['900', '500','400','100', '90','50',  '40',  '10', '9', '5','4', '1']\n    const rom = [\"CM\", 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I']\n    for (let i in nums){\n        while (num>=nums[i]){\n            roman+=rom[i]\n            num-=nums[i]\n        }\n    }\n    return roman;`"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "RASWQQW",
                        "content": "Can we this code but its shown as incorrect in testcase\n\n`\n\n\n        _dict = {1000: \"M\", 500: \"D\", 100: \"C\", 50: \"L\", 10: \"X\", 5: \"V\", 1: \"I\"}\n        # print(dict(reversed(list(_dict.items()))))\n\n        _digitLen = len(str(num))\n        num = str(num)[::-1]\n        dar = 1\n        text = ''\n        for elem in str(num):\n            elem = int(elem) * dar\n            for key, value in _dict.items():\n\n                if int(elem) == key:\n                    text+= value; break\n\n                elif int(elem) % key == 0:\n                    for _ in range(int(elem / dar)):\n                        text+=value\n\n                    break\n\n                elif 3 * dar >= int(elem) % key > 0 and int(elem) % key != elem:\n                    for ss in range(int(int(elem) % key / dar)):\n                        text+=_dict[dar]\n                    text += value\n                    break\n\n                elif int(elem) + dar == key:\n                    text+=value+_dict[dar]; \n                    \n                    break\n\n            dar *= 10\n\n        return text[::-1] `\n\n\n\n\n "
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "hsthanh00",
                        "content": "var roman = \"\";\\nfunction divided(num,romanNum){\\n    roman += romanNum ;\\n    if(num <= 0){\\n        return roman;\\n    }\\n    if( num>=1000){\\n        var romanNumber = \"M\".repeat(num/1000);\\n       return divided(num%1000,romanNumber)\\n    }\\n    if(num >= 900){\\n        var romanNumber = \"CM\".repeat(num/900);\\n       return divided(num%900,romanNumber)\\n    }\\n    if(num>=500){\\n        \\n        var romanNumber = \"D\".repeat(num/500);\\n        return divided(num%500,romanNumber)\\n    }\\n    if(num >= 400){\\n         var romanNumber = \"CD\".repeat(num/400);\\n        return divided(num%400,romanNumber)\\n    }\\n    if(num>=100){\\n        var romanNumber = \"C\".repeat(num/100);\\n        return divided(num%100,romanNumber)\\n    }\\n    if(num>=90){\\n         var romanNumber = \"XC\".repeat(num/90);\\n        return divided(num%90,romanNumber)\\n    }\\n    if(num>=50){\\n        var romanNumber = \"L\".repeat(num/50);\\n        return divided(num%50,romanNumber)\\n    }\\n    if(num>=40){\\n         var romanNumber = \"XL\".repeat(num/40);\\n        return divided(num%40,romanNumber)\\n    }\\n    \\n    if(num>=10){\\n        var romanNumber = \"X\".repeat(num/10);\\n        return divided(num%10,romanNumber)\\n    }\\n    if(num>=9){\\n         var romanNumber = \"IX\".repeat(num/9);\\n        return divided(num%9,romanNumber)\\n    }\\n     if(num>=5){\\n        var romanNumber = \"V\".repeat(num/5);\\n        return  divided(num%5,romanNumber)\\n    }\\n    if(num>=4){\\n         var romanNumber = \"IV\".repeat(num/4);\\n        return divided(num%4,romanNumber)\\n    }\\n     if(num>=1){\\n        var romanNumber = \"I\".repeat(num/1);\\n        return divided(num%1,romanNumber)\\n    }\\n    return roman; \\n}\\n\\nvar intToRoman = function(num) {\\n var roman = divided(num,\"\");\\n return roman \\n};\\n// how does it work when i code it on visual studio code but at \"leetcode\" it\\'s wrong. @@\\n"
                    },
                    {
                        "username": "RohitAgarwal08",
                        "content": "Explanation in Hindi\\n\\nhttps://youtu.be/fh5Q-2TvQwo"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1746519,
                "content": [
                    {
                        "username": "haduong825",
                        "content": "Here is my stupid solution \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\n\\n `class Solution {\\n  String intToRoman(int num) {\\n    final oneMap = {1: \"I\", 10: \"X\", 100: \"C\", 1000: \"M\"};\\n    final fiveMap = {5: \"V\", 50: \"L\", 500: \"D\"};\\n    final inputStr =\\n        num.toString().split(\\'\\').reversed.map((e) => int.parse(e)).toList();\\n    var outputArray = List<String>.empty(growable: true);\\n    for (int i = 0; i < inputStr.length; i++) {\\n      if (inputStr[i] * pow(10, i) < (5 * pow(10, i) - pow(10, i))) {\\n        for (int j = 0; j < inputStr[i]; j++) {\\n          outputArray.add(oneMap[pow(10, i)] ?? \"\");\\n        }\\n      } else if (inputStr[i] * pow(10, i) < 9 * pow(10, i) &&\\n          inputStr[i] * pow(10, i) != (4 * pow(10, i))) {\\n        var tmpStr = \"\";\\n        tmpStr += fiveMap[5 * pow(10, i)] ?? \"\";\\n        for (int j = 0; j < inputStr[i] - 5; j++) {\\n          tmpStr += oneMap[pow(10, i)] ?? \"\";\\n        }\\n\\n        outputArray.add(tmpStr);\\n      } else if (inputStr[i] * pow(10, i) == (4 * pow(10, i))) {\\n        outputArray.add(\"${oneMap[pow(10, i)]}${fiveMap[5 * pow(10, i)]}\");\\n      } else if (inputStr[i] * pow(10, i) == (9 * pow(10, i))) {\\n        outputArray.add(\"${oneMap[pow(10, i)]}${oneMap[pow(10, i + 1)]}\");\\n      } else if (inputStr[i] * pow(10, (i + 1)) == (5 * pow(10, (i + 1)))) {\\n        outputArray.add(fiveMap[5 * pow(10, i)] ?? \"\");\\n      }\\n    }\\n\\n    return outputArray.reversed.reduce((value, element) => value + element);\\n  }\\n}`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nAnd here are the rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "maj-oliveira",
                        "content": "what is the complexity of this code?\\n\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        d = {1000:\\'M\\',900:\\'CM\\',500:\\'D\\',400:\\'CD\\',100:\\'C\\',90:\\'XC\\',50:\\'L\\',40:\\'XL\\',10:\\'X\\',9:\\'IX\\',5:\\'V\\',4:\\'IV\\',1:\\'I\\'}\\n        result = \"\"\\n\\n        while num !=0:\\n            for key in d:\\n                if key<=num or key==1:\\n                    div = num // key\\n                    for i in range(div):\\n                        result = result + d[key]\\n                    num = num % key\\n\\n        return result"
                    },
                    {
                        "username": "boy19970722",
                        "content": "can someone exmplain why 200 is LLLL instead of CC where 20 is XX instead of VVVV?"
                    },
                    {
                        "username": "jamesTheCoder",
                        "content": "200 is CC. Largest possible. "
                    },
                    {
                        "username": "adnanitzer",
                        "content": "Here is an easy way in JS, find the first number >= the result, add its symbol and substract it then continue\n `let roman = \"M\".repeat(parseInt(num/1000));\n    num = num%1000;\n    const nums = ['900', '500','400','100', '90','50',  '40',  '10', '9', '5','4', '1']\n    const rom = [\"CM\", 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I']\n    for (let i in nums){\n        while (num>=nums[i]){\n            roman+=rom[i]\n            num-=nums[i]\n        }\n    }\n    return roman;`"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "RASWQQW",
                        "content": "Can we this code but its shown as incorrect in testcase\n\n`\n\n\n        _dict = {1000: \"M\", 500: \"D\", 100: \"C\", 50: \"L\", 10: \"X\", 5: \"V\", 1: \"I\"}\n        # print(dict(reversed(list(_dict.items()))))\n\n        _digitLen = len(str(num))\n        num = str(num)[::-1]\n        dar = 1\n        text = ''\n        for elem in str(num):\n            elem = int(elem) * dar\n            for key, value in _dict.items():\n\n                if int(elem) == key:\n                    text+= value; break\n\n                elif int(elem) % key == 0:\n                    for _ in range(int(elem / dar)):\n                        text+=value\n\n                    break\n\n                elif 3 * dar >= int(elem) % key > 0 and int(elem) % key != elem:\n                    for ss in range(int(int(elem) % key / dar)):\n                        text+=_dict[dar]\n                    text += value\n                    break\n\n                elif int(elem) + dar == key:\n                    text+=value+_dict[dar]; \n                    \n                    break\n\n            dar *= 10\n\n        return text[::-1] `\n\n\n\n\n "
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "hsthanh00",
                        "content": "var roman = \"\";\\nfunction divided(num,romanNum){\\n    roman += romanNum ;\\n    if(num <= 0){\\n        return roman;\\n    }\\n    if( num>=1000){\\n        var romanNumber = \"M\".repeat(num/1000);\\n       return divided(num%1000,romanNumber)\\n    }\\n    if(num >= 900){\\n        var romanNumber = \"CM\".repeat(num/900);\\n       return divided(num%900,romanNumber)\\n    }\\n    if(num>=500){\\n        \\n        var romanNumber = \"D\".repeat(num/500);\\n        return divided(num%500,romanNumber)\\n    }\\n    if(num >= 400){\\n         var romanNumber = \"CD\".repeat(num/400);\\n        return divided(num%400,romanNumber)\\n    }\\n    if(num>=100){\\n        var romanNumber = \"C\".repeat(num/100);\\n        return divided(num%100,romanNumber)\\n    }\\n    if(num>=90){\\n         var romanNumber = \"XC\".repeat(num/90);\\n        return divided(num%90,romanNumber)\\n    }\\n    if(num>=50){\\n        var romanNumber = \"L\".repeat(num/50);\\n        return divided(num%50,romanNumber)\\n    }\\n    if(num>=40){\\n         var romanNumber = \"XL\".repeat(num/40);\\n        return divided(num%40,romanNumber)\\n    }\\n    \\n    if(num>=10){\\n        var romanNumber = \"X\".repeat(num/10);\\n        return divided(num%10,romanNumber)\\n    }\\n    if(num>=9){\\n         var romanNumber = \"IX\".repeat(num/9);\\n        return divided(num%9,romanNumber)\\n    }\\n     if(num>=5){\\n        var romanNumber = \"V\".repeat(num/5);\\n        return  divided(num%5,romanNumber)\\n    }\\n    if(num>=4){\\n         var romanNumber = \"IV\".repeat(num/4);\\n        return divided(num%4,romanNumber)\\n    }\\n     if(num>=1){\\n        var romanNumber = \"I\".repeat(num/1);\\n        return divided(num%1,romanNumber)\\n    }\\n    return roman; \\n}\\n\\nvar intToRoman = function(num) {\\n var roman = divided(num,\"\");\\n return roman \\n};\\n// how does it work when i code it on visual studio code but at \"leetcode\" it\\'s wrong. @@\\n"
                    },
                    {
                        "username": "RohitAgarwal08",
                        "content": "Explanation in Hindi\\n\\nhttps://youtu.be/fh5Q-2TvQwo"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1744912,
                "content": [
                    {
                        "username": "haduong825",
                        "content": "Here is my stupid solution \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\n\\n `class Solution {\\n  String intToRoman(int num) {\\n    final oneMap = {1: \"I\", 10: \"X\", 100: \"C\", 1000: \"M\"};\\n    final fiveMap = {5: \"V\", 50: \"L\", 500: \"D\"};\\n    final inputStr =\\n        num.toString().split(\\'\\').reversed.map((e) => int.parse(e)).toList();\\n    var outputArray = List<String>.empty(growable: true);\\n    for (int i = 0; i < inputStr.length; i++) {\\n      if (inputStr[i] * pow(10, i) < (5 * pow(10, i) - pow(10, i))) {\\n        for (int j = 0; j < inputStr[i]; j++) {\\n          outputArray.add(oneMap[pow(10, i)] ?? \"\");\\n        }\\n      } else if (inputStr[i] * pow(10, i) < 9 * pow(10, i) &&\\n          inputStr[i] * pow(10, i) != (4 * pow(10, i))) {\\n        var tmpStr = \"\";\\n        tmpStr += fiveMap[5 * pow(10, i)] ?? \"\";\\n        for (int j = 0; j < inputStr[i] - 5; j++) {\\n          tmpStr += oneMap[pow(10, i)] ?? \"\";\\n        }\\n\\n        outputArray.add(tmpStr);\\n      } else if (inputStr[i] * pow(10, i) == (4 * pow(10, i))) {\\n        outputArray.add(\"${oneMap[pow(10, i)]}${fiveMap[5 * pow(10, i)]}\");\\n      } else if (inputStr[i] * pow(10, i) == (9 * pow(10, i))) {\\n        outputArray.add(\"${oneMap[pow(10, i)]}${oneMap[pow(10, i + 1)]}\");\\n      } else if (inputStr[i] * pow(10, (i + 1)) == (5 * pow(10, (i + 1)))) {\\n        outputArray.add(fiveMap[5 * pow(10, i)] ?? \"\");\\n      }\\n    }\\n\\n    return outputArray.reversed.reduce((value, element) => value + element);\\n  }\\n}`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nAnd here are the rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "maj-oliveira",
                        "content": "what is the complexity of this code?\\n\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        d = {1000:\\'M\\',900:\\'CM\\',500:\\'D\\',400:\\'CD\\',100:\\'C\\',90:\\'XC\\',50:\\'L\\',40:\\'XL\\',10:\\'X\\',9:\\'IX\\',5:\\'V\\',4:\\'IV\\',1:\\'I\\'}\\n        result = \"\"\\n\\n        while num !=0:\\n            for key in d:\\n                if key<=num or key==1:\\n                    div = num // key\\n                    for i in range(div):\\n                        result = result + d[key]\\n                    num = num % key\\n\\n        return result"
                    },
                    {
                        "username": "boy19970722",
                        "content": "can someone exmplain why 200 is LLLL instead of CC where 20 is XX instead of VVVV?"
                    },
                    {
                        "username": "jamesTheCoder",
                        "content": "200 is CC. Largest possible. "
                    },
                    {
                        "username": "adnanitzer",
                        "content": "Here is an easy way in JS, find the first number >= the result, add its symbol and substract it then continue\n `let roman = \"M\".repeat(parseInt(num/1000));\n    num = num%1000;\n    const nums = ['900', '500','400','100', '90','50',  '40',  '10', '9', '5','4', '1']\n    const rom = [\"CM\", 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I']\n    for (let i in nums){\n        while (num>=nums[i]){\n            roman+=rom[i]\n            num-=nums[i]\n        }\n    }\n    return roman;`"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "RASWQQW",
                        "content": "Can we this code but its shown as incorrect in testcase\n\n`\n\n\n        _dict = {1000: \"M\", 500: \"D\", 100: \"C\", 50: \"L\", 10: \"X\", 5: \"V\", 1: \"I\"}\n        # print(dict(reversed(list(_dict.items()))))\n\n        _digitLen = len(str(num))\n        num = str(num)[::-1]\n        dar = 1\n        text = ''\n        for elem in str(num):\n            elem = int(elem) * dar\n            for key, value in _dict.items():\n\n                if int(elem) == key:\n                    text+= value; break\n\n                elif int(elem) % key == 0:\n                    for _ in range(int(elem / dar)):\n                        text+=value\n\n                    break\n\n                elif 3 * dar >= int(elem) % key > 0 and int(elem) % key != elem:\n                    for ss in range(int(int(elem) % key / dar)):\n                        text+=_dict[dar]\n                    text += value\n                    break\n\n                elif int(elem) + dar == key:\n                    text+=value+_dict[dar]; \n                    \n                    break\n\n            dar *= 10\n\n        return text[::-1] `\n\n\n\n\n "
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "hsthanh00",
                        "content": "var roman = \"\";\\nfunction divided(num,romanNum){\\n    roman += romanNum ;\\n    if(num <= 0){\\n        return roman;\\n    }\\n    if( num>=1000){\\n        var romanNumber = \"M\".repeat(num/1000);\\n       return divided(num%1000,romanNumber)\\n    }\\n    if(num >= 900){\\n        var romanNumber = \"CM\".repeat(num/900);\\n       return divided(num%900,romanNumber)\\n    }\\n    if(num>=500){\\n        \\n        var romanNumber = \"D\".repeat(num/500);\\n        return divided(num%500,romanNumber)\\n    }\\n    if(num >= 400){\\n         var romanNumber = \"CD\".repeat(num/400);\\n        return divided(num%400,romanNumber)\\n    }\\n    if(num>=100){\\n        var romanNumber = \"C\".repeat(num/100);\\n        return divided(num%100,romanNumber)\\n    }\\n    if(num>=90){\\n         var romanNumber = \"XC\".repeat(num/90);\\n        return divided(num%90,romanNumber)\\n    }\\n    if(num>=50){\\n        var romanNumber = \"L\".repeat(num/50);\\n        return divided(num%50,romanNumber)\\n    }\\n    if(num>=40){\\n         var romanNumber = \"XL\".repeat(num/40);\\n        return divided(num%40,romanNumber)\\n    }\\n    \\n    if(num>=10){\\n        var romanNumber = \"X\".repeat(num/10);\\n        return divided(num%10,romanNumber)\\n    }\\n    if(num>=9){\\n         var romanNumber = \"IX\".repeat(num/9);\\n        return divided(num%9,romanNumber)\\n    }\\n     if(num>=5){\\n        var romanNumber = \"V\".repeat(num/5);\\n        return  divided(num%5,romanNumber)\\n    }\\n    if(num>=4){\\n         var romanNumber = \"IV\".repeat(num/4);\\n        return divided(num%4,romanNumber)\\n    }\\n     if(num>=1){\\n        var romanNumber = \"I\".repeat(num/1);\\n        return divided(num%1,romanNumber)\\n    }\\n    return roman; \\n}\\n\\nvar intToRoman = function(num) {\\n var roman = divided(num,\"\");\\n return roman \\n};\\n// how does it work when i code it on visual studio code but at \"leetcode\" it\\'s wrong. @@\\n"
                    },
                    {
                        "username": "RohitAgarwal08",
                        "content": "Explanation in Hindi\\n\\nhttps://youtu.be/fh5Q-2TvQwo"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1731563,
                "content": [
                    {
                        "username": "haduong825",
                        "content": "Here is my stupid solution \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\n\\n `class Solution {\\n  String intToRoman(int num) {\\n    final oneMap = {1: \"I\", 10: \"X\", 100: \"C\", 1000: \"M\"};\\n    final fiveMap = {5: \"V\", 50: \"L\", 500: \"D\"};\\n    final inputStr =\\n        num.toString().split(\\'\\').reversed.map((e) => int.parse(e)).toList();\\n    var outputArray = List<String>.empty(growable: true);\\n    for (int i = 0; i < inputStr.length; i++) {\\n      if (inputStr[i] * pow(10, i) < (5 * pow(10, i) - pow(10, i))) {\\n        for (int j = 0; j < inputStr[i]; j++) {\\n          outputArray.add(oneMap[pow(10, i)] ?? \"\");\\n        }\\n      } else if (inputStr[i] * pow(10, i) < 9 * pow(10, i) &&\\n          inputStr[i] * pow(10, i) != (4 * pow(10, i))) {\\n        var tmpStr = \"\";\\n        tmpStr += fiveMap[5 * pow(10, i)] ?? \"\";\\n        for (int j = 0; j < inputStr[i] - 5; j++) {\\n          tmpStr += oneMap[pow(10, i)] ?? \"\";\\n        }\\n\\n        outputArray.add(tmpStr);\\n      } else if (inputStr[i] * pow(10, i) == (4 * pow(10, i))) {\\n        outputArray.add(\"${oneMap[pow(10, i)]}${fiveMap[5 * pow(10, i)]}\");\\n      } else if (inputStr[i] * pow(10, i) == (9 * pow(10, i))) {\\n        outputArray.add(\"${oneMap[pow(10, i)]}${oneMap[pow(10, i + 1)]}\");\\n      } else if (inputStr[i] * pow(10, (i + 1)) == (5 * pow(10, (i + 1)))) {\\n        outputArray.add(fiveMap[5 * pow(10, i)] ?? \"\");\\n      }\\n    }\\n\\n    return outputArray.reversed.reduce((value, element) => value + element);\\n  }\\n}`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nAnd here are the rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "maj-oliveira",
                        "content": "what is the complexity of this code?\\n\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        d = {1000:\\'M\\',900:\\'CM\\',500:\\'D\\',400:\\'CD\\',100:\\'C\\',90:\\'XC\\',50:\\'L\\',40:\\'XL\\',10:\\'X\\',9:\\'IX\\',5:\\'V\\',4:\\'IV\\',1:\\'I\\'}\\n        result = \"\"\\n\\n        while num !=0:\\n            for key in d:\\n                if key<=num or key==1:\\n                    div = num // key\\n                    for i in range(div):\\n                        result = result + d[key]\\n                    num = num % key\\n\\n        return result"
                    },
                    {
                        "username": "boy19970722",
                        "content": "can someone exmplain why 200 is LLLL instead of CC where 20 is XX instead of VVVV?"
                    },
                    {
                        "username": "jamesTheCoder",
                        "content": "200 is CC. Largest possible. "
                    },
                    {
                        "username": "adnanitzer",
                        "content": "Here is an easy way in JS, find the first number >= the result, add its symbol and substract it then continue\n `let roman = \"M\".repeat(parseInt(num/1000));\n    num = num%1000;\n    const nums = ['900', '500','400','100', '90','50',  '40',  '10', '9', '5','4', '1']\n    const rom = [\"CM\", 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I']\n    for (let i in nums){\n        while (num>=nums[i]){\n            roman+=rom[i]\n            num-=nums[i]\n        }\n    }\n    return roman;`"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "RASWQQW",
                        "content": "Can we this code but its shown as incorrect in testcase\n\n`\n\n\n        _dict = {1000: \"M\", 500: \"D\", 100: \"C\", 50: \"L\", 10: \"X\", 5: \"V\", 1: \"I\"}\n        # print(dict(reversed(list(_dict.items()))))\n\n        _digitLen = len(str(num))\n        num = str(num)[::-1]\n        dar = 1\n        text = ''\n        for elem in str(num):\n            elem = int(elem) * dar\n            for key, value in _dict.items():\n\n                if int(elem) == key:\n                    text+= value; break\n\n                elif int(elem) % key == 0:\n                    for _ in range(int(elem / dar)):\n                        text+=value\n\n                    break\n\n                elif 3 * dar >= int(elem) % key > 0 and int(elem) % key != elem:\n                    for ss in range(int(int(elem) % key / dar)):\n                        text+=_dict[dar]\n                    text += value\n                    break\n\n                elif int(elem) + dar == key:\n                    text+=value+_dict[dar]; \n                    \n                    break\n\n            dar *= 10\n\n        return text[::-1] `\n\n\n\n\n "
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "hsthanh00",
                        "content": "var roman = \"\";\\nfunction divided(num,romanNum){\\n    roman += romanNum ;\\n    if(num <= 0){\\n        return roman;\\n    }\\n    if( num>=1000){\\n        var romanNumber = \"M\".repeat(num/1000);\\n       return divided(num%1000,romanNumber)\\n    }\\n    if(num >= 900){\\n        var romanNumber = \"CM\".repeat(num/900);\\n       return divided(num%900,romanNumber)\\n    }\\n    if(num>=500){\\n        \\n        var romanNumber = \"D\".repeat(num/500);\\n        return divided(num%500,romanNumber)\\n    }\\n    if(num >= 400){\\n         var romanNumber = \"CD\".repeat(num/400);\\n        return divided(num%400,romanNumber)\\n    }\\n    if(num>=100){\\n        var romanNumber = \"C\".repeat(num/100);\\n        return divided(num%100,romanNumber)\\n    }\\n    if(num>=90){\\n         var romanNumber = \"XC\".repeat(num/90);\\n        return divided(num%90,romanNumber)\\n    }\\n    if(num>=50){\\n        var romanNumber = \"L\".repeat(num/50);\\n        return divided(num%50,romanNumber)\\n    }\\n    if(num>=40){\\n         var romanNumber = \"XL\".repeat(num/40);\\n        return divided(num%40,romanNumber)\\n    }\\n    \\n    if(num>=10){\\n        var romanNumber = \"X\".repeat(num/10);\\n        return divided(num%10,romanNumber)\\n    }\\n    if(num>=9){\\n         var romanNumber = \"IX\".repeat(num/9);\\n        return divided(num%9,romanNumber)\\n    }\\n     if(num>=5){\\n        var romanNumber = \"V\".repeat(num/5);\\n        return  divided(num%5,romanNumber)\\n    }\\n    if(num>=4){\\n         var romanNumber = \"IV\".repeat(num/4);\\n        return divided(num%4,romanNumber)\\n    }\\n     if(num>=1){\\n        var romanNumber = \"I\".repeat(num/1);\\n        return divided(num%1,romanNumber)\\n    }\\n    return roman; \\n}\\n\\nvar intToRoman = function(num) {\\n var roman = divided(num,\"\");\\n return roman \\n};\\n// how does it work when i code it on visual studio code but at \"leetcode\" it\\'s wrong. @@\\n"
                    },
                    {
                        "username": "RohitAgarwal08",
                        "content": "Explanation in Hindi\\n\\nhttps://youtu.be/fh5Q-2TvQwo"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    }
                ]
            }
        ]
    },
    {
        "title": "Path Sum",
        "question_content": "<p>Given the <code>root</code> of a binary tree and an integer <code>targetSum</code>, return <code>true</code> if the tree has a <strong>root-to-leaf</strong> path such that adding up all the values along the path equals <code>targetSum</code>.</p>\n\n<p>A <strong>leaf</strong> is a node with no children.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/18/pathsum1.jpg\" style=\"width: 500px; height: 356px;\" />\n<pre>\n<strong>Input:</strong> root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22\n<strong>Output:</strong> true\n<strong>Explanation:</strong> The root-to-leaf path with the target sum is shown.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/18/pathsum2.jpg\" />\n<pre>\n<strong>Input:</strong> root = [1,2,3], targetSum = 5\n<strong>Output:</strong> false\n<strong>Explanation:</strong> There two root-to-leaf paths in the tree:\n(1 --&gt; 2): The sum is 3.\n(1 --&gt; 3): The sum is 4.\nThere is no root-to-leaf path with sum = 5.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = [], targetSum = 0\n<strong>Output:</strong> false\n<strong>Explanation:</strong> Since the tree is empty, there are no root-to-leaf paths.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[0, 5000]</code>.</li>\n\t<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>\n\t<li><code>-1000 &lt;= targetSum &lt;= 1000</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 36378,
                "title": "accepted-my-recursive-solution-in-java",
                "content": "The basic idea is to subtract the value of current node from sum until it reaches a leaf node and the subtraction equals 0, then we know that we got a hit. Otherwise the subtraction at the end could not be 0.\\n\\n    public class Solution {\\n        public boolean hasPathSum(TreeNode root, int sum) {\\n            if(root == null) return false;\\n        \\n            if(root.left == null && root.right == null && sum - root.val == 0) return true;\\n        \\n            return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public boolean hasPathSum(TreeNode root, int sum) {\\n            if(root == null) return false;\\n        \\n            if(root.left == null && root.right == null && sum - root.val == 0) return true;\\n        \\n            return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 36360,
                "title": "short-python-recursive-solution-o-n",
                "content": "    # Definition for a  binary tree node\\n    # class TreeNode:\\n    #     def __init__(self, x):\\n    #         self.val = x\\n    #         self.left = None\\n    #         self.right = None\\n    \\n    class Solution:\\n        # @param root, a tree node\\n        # @param sum, an integer\\n        # @return a boolean\\n        # 1:27\\n        def hasPathSum(self, root, sum):\\n            if not root:\\n                return False\\n    \\n            if not root.left and not root.right and root.val == sum:\\n                return True\\n            \\n            sum -= root.val\\n    \\n            return self.hasPathSum(root.left, sum) or self.hasPathSum(root.right, sum)",
                "solutionTags": [
                    "Python"
                ],
                "code": "    # Definition for a  binary tree node\\n    # class TreeNode:\\n    #     def __init__(self, x):\\n    #         self.val = x\\n    #         self.left = None\\n    #         self.right = None\\n    \\n    class Solution:\\n        # @param root, a tree node\\n        # @param sum, an integer\\n        # @return a boolean\\n        # 1:27\\n        def hasPathSum(self, root, sum):\\n            if not root:\\n                return False\\n    \\n            if not root.left and not root.right and root.val == sum:\\n                return True\\n            \\n            sum -= root.val\\n    \\n            return self.hasPathSum(root.left, sum) or self.hasPathSum(root.right, sum)",
                "codeTag": "Java"
            },
            {
                "id": 36367,
                "title": "3-lines-of-c-solution",
                "content": "    bool hasPathSum(TreeNode *root, int sum) {\\n            if (root == NULL) return false;\\n            if (root->val == sum && root->left ==  NULL && root->right == NULL) return true;\\n            return hasPathSum(root->left, sum-root->val) || hasPathSum(root->right, sum-root->val);\\n        }",
                "solutionTags": [],
                "code": "    bool hasPathSum(TreeNode *root, int sum) {\\n            if (root == NULL) return false;\\n            if (root->val == sum && root->left ==  NULL && root->right == NULL) return true;\\n            return hasPathSum(root->left, sum-root->val) || hasPathSum(root->right, sum-root->val);\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 36486,
                "title": "python-solutions-dfs-recursively-dfs-stack-bfs-queue",
                "content": "# DFS Recursively \\n    def hasPathSum1(self, root, sum):\\n        res = []\\n        self.dfs(root, sum, res)\\n        return any(res)\\n        \\n    def dfs(self, root, target, res):\\n        if root:\\n            if not root.left and not root.right and root.val == target:\\n                res.append(True)\\n            if root.left:\\n                self.dfs(root.left, target-root.val, res)\\n            if root.right:\\n                self.dfs(root.right, target-root.val, res)\\n    \\n    # DFS with stack\\n    def hasPathSum2(self, root, sum):\\n        if not root:\\n            return False\\n        stack = [(root, root.val)]\\n        while stack:\\n            curr, val = stack.pop()\\n            if not curr.left and not curr.right and val == sum:\\n                return True\\n            if curr.right:\\n                stack.append((curr.right, val+curr.right.val))\\n            if curr.left:\\n                stack.append((curr.left, val+curr.left.val))\\n        return False\\n        \\n    # BFS with queue\\n    def hasPathSum(self, root, sum):\\n        if not root:\\n            return False\\n        queue = [(root, sum-root.val)]\\n        while queue:\\n            curr, val = queue.pop(0)\\n            if not curr.left and not curr.right and val == 0:\\n                return True\\n            if curr.left:\\n                queue.append((curr.left, val-curr.left.val))\\n            if curr.right:\\n                queue.append((curr.right, val-curr.right.val))\\n        return False\\n\\t\\t\\n\\tdef hasPathSum1(self, root, sum):\\n        if not root:\\n            return False\\n        if not root.left and not root.right and root.val == sum:\\n            return True\\n        return self.hasPathSum(root.left, sum-root.val) or self.hasPathSum(root.right, sum-root.val)",
                "solutionTags": [
                    "Python",
                    "Stack",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "# DFS Recursively \\n    def hasPathSum1(self, root, sum):\\n        res = []\\n        self.dfs(root, sum, res)\\n        return any(res)\\n        \\n    def dfs(self, root, target, res):\\n        if root:\\n            if not root.left and not root.right and root.val == target:\\n                res.append(True)\\n            if root.left:\\n                self.dfs(root.left, target-root.val, res)\\n            if root.right:\\n                self.dfs(root.right, target-root.val, res)\\n    \\n    # DFS with stack\\n    def hasPathSum2(self, root, sum):\\n        if not root:\\n            return False\\n        stack = [(root, root.val)]\\n        while stack:\\n            curr, val = stack.pop()\\n            if not curr.left and not curr.right and val == sum:\\n                return True\\n            if curr.right:\\n                stack.append((curr.right, val+curr.right.val))\\n            if curr.left:\\n                stack.append((curr.left, val+curr.left.val))\\n        return False\\n        \\n    # BFS with queue\\n    def hasPathSum(self, root, sum):\\n        if not root:\\n            return False\\n        queue = [(root, sum-root.val)]\\n        while queue:\\n            curr, val = queue.pop(0)\\n            if not curr.left and not curr.right and val == 0:\\n                return True\\n            if curr.left:\\n                queue.append((curr.left, val-curr.left.val))\\n            if curr.right:\\n                queue.append((curr.right, val-curr.right.val))\\n        return False\\n\\t\\t\\n\\tdef hasPathSum1(self, root, sum):\\n        if not root:\\n            return False\\n        if not root.left and not root.right and root.val == sum:\\n            return True\\n        return self.hasPathSum(root.left, sum-root.val) or self.hasPathSum(root.right, sum-root.val)",
                "codeTag": "Python3"
            },
            {
                "id": 670515,
                "title": "c-recursive-solution-4-lines-code",
                "content": "***Pls upvote if you find this helpful  :)***\\n\\nThree things to remember while solving any recursion based questions are:\\n1)Terminating condition/Base Case\\n2)Body (Code to be performed each time)\\n3)Propagation(Calling itself,propagating further)\\n```\\nclass Solution {\\npublic:\\n    bool hasPathSum(TreeNode* root, int sum) {\\n        if(!root)return false;                                         //Terminating Condition\\n        sum=sum-root->val;                                             //Body\\n        if(sum==0&&!root->left&&!root->right)return true;              //body\\n        return hasPathSum(root->left,sum)||hasPathSum(root->right,sum);//Propagation\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool hasPathSum(TreeNode* root, int sum) {\\n        if(!root)return false;                                         //Terminating Condition\\n        sum=sum-root->val;                                             //Body\\n        if(sum==0&&!root->left&&!root->right)return true;              //body\\n        return hasPathSum(root->left,sum)||hasPathSum(root->right,sum);//Propagation\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3096296,
                "title": "easiest-beginner-friendly-sol-recursion-o-n-time-and-o-h-space",
                "content": "# Intuition\\n- We are using **top down recursion** approach to solve this problem.\\n- See below solution to understand how we can use top down and bottom up approach in recursion.\\nhttps://leetcode.com/problems/maximum-depth-of-binary-tree/solutions/3093043/easiest-beginner-friendly-solution-dfs-o-n-time-and-o-h-space/?orderBy=hot\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Create a helper function called \"rootToLeafPathSum\" that takes in three parameters: a binary tree node, a target sum, and a current sum.\\n2. Check if the current node is null, and if so, return false.\\n3. Check if the current node is a leaf node (i.e. has no left or right children), and if so, add the value of the node to the current sum.\\n4. If the current sum equals the target sum, return true.\\n5. Recursively call the \"rootToLeafPathSum\" function on the left and right children of the current node, passing in the updated current sum.\\n6. Return the result of the recursive calls.\\n7. In the \"hasPathSum\" function, initialize the current sum to 0 and call the \"rootToLeafPathSum\" function on the root node, passing in the target sum and current sum as parameters.\\n8. Return the result of the \"rootToLeafPathSum\" function call.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Code\\n```C++ []\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool rootToLeafPathSum(TreeNode* root, int targetSum, int sum){\\n        if(root == nullptr)\\n            return false;\\n        if(root -> left == nullptr && root -> right == nullptr){\\n            sum = sum + root -> val;\\n            if(sum == targetSum)\\n                return true;   \\n        }\\n        return rootToLeafPathSum(root -> left, targetSum, sum + root -> val) || rootToLeafPathSum(root -> right, targetSum, sum + root -> val);\\n    }\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        int sum = 0;\\n        return rootToLeafPathSum(root, targetSum, sum);\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public boolean rootToLeafPathSum(TreeNode root, int targetSum, int sum){\\n        if(root == null)\\n            return false;\\n        if(root.left == null && root.right == null){\\n            sum = sum + root.val;\\n            if(sum == targetSum)\\n                return true;   \\n        }\\n        return rootToLeafPathSum(root.left, targetSum, sum + root.val) || rootToLeafPathSum(root.right, targetSum, sum + root.val);\\n    }\\n    public boolean hasPathSum(TreeNode root, int targetSum) {\\n        int sum = 0;\\n        return rootToLeafPathSum(root, targetSum, sum);\\n    }\\n}\\n\\n```\\n```Python []\\nclass Solution:\\n    def rootToLeafPathSum(self, root: TreeNode, targetSum: int, sum: int) -> bool:\\n        if root is None:\\n            return False\\n        if root.left is None and root.right is None:\\n            sum += root.val\\n            if sum == targetSum:\\n                return True   \\n        return self.rootToLeafPathSum(root.left, targetSum, sum + root.val) or self.rootToLeafPathSum(root.right, targetSum, sum + root.val)\\n\\n    def hasPathSum(self, root: TreeNode, targetSum: int) -> bool:\\n        sum = 0\\n        return self.rootToLeafPathSum(root, targetSum, sum)\\n\\n```\\n- If my solution is helpful to you then please **UPVOTE** my solution, your **UPVOTE** motivates me to post such kind of solution.\\n- Please let me know in comments if there is need to do any improvement in my approach, code....anything.\\n- **Let\\'s connect on** https://www.linkedin.com/in/abhinash-singh-1b851b188\\n![57jfh9.jpg](https://assets.leetcode.com/users/images/c2826b72-fb1c-464c-9f95-d9e578abcaf3_1674104075.4732099.jpeg)\\n\\n# Complexity\\n- Time complexity: **O(n)** // where n is the number of nodes in the tree\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:**O(h)** //where h is the height of the tree\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Binary Tree"
                ],
                "code": "```C++ []\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool rootToLeafPathSum(TreeNode* root, int targetSum, int sum){\\n        if(root == nullptr)\\n            return false;\\n        if(root -> left == nullptr && root -> right == nullptr){\\n            sum = sum + root -> val;\\n            if(sum == targetSum)\\n                return true;   \\n        }\\n        return rootToLeafPathSum(root -> left, targetSum, sum + root -> val) || rootToLeafPathSum(root -> right, targetSum, sum + root -> val);\\n    }\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        int sum = 0;\\n        return rootToLeafPathSum(root, targetSum, sum);\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public boolean rootToLeafPathSum(TreeNode root, int targetSum, int sum){\\n        if(root == null)\\n            return false;\\n        if(root.left == null && root.right == null){\\n            sum = sum + root.val;\\n            if(sum == targetSum)\\n                return true;   \\n        }\\n        return rootToLeafPathSum(root.left, targetSum, sum + root.val) || rootToLeafPathSum(root.right, targetSum, sum + root.val);\\n    }\\n    public boolean hasPathSum(TreeNode root, int targetSum) {\\n        int sum = 0;\\n        return rootToLeafPathSum(root, targetSum, sum);\\n    }\\n}\\n\\n```\n```Python []\\nclass Solution:\\n    def rootToLeafPathSum(self, root: TreeNode, targetSum: int, sum: int) -> bool:\\n        if root is None:\\n            return False\\n        if root.left is None and root.right is None:\\n            sum += root.val\\n            if sum == targetSum:\\n                return True   \\n        return self.rootToLeafPathSum(root.left, targetSum, sum + root.val) or self.rootToLeafPathSum(root.right, targetSum, sum + root.val)\\n\\n    def hasPathSum(self, root: TreeNode, targetSum: int) -> bool:\\n        sum = 0\\n        return self.rootToLeafPathSum(root, targetSum, sum)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 36580,
                "title": "java-solution-both-recursion-and-iteration",
                "content": "  \\n    public boolean hasPathSum(TreeNode root, int sum) {\\n        // iteration method\\n        if (root == null) {return false;}\\n        Stack<TreeNode> path = new Stack<>();\\n        Stack<Integer> sub = new Stack<>();\\n        path.push(root);\\n        sub.push(root.val);\\n        while (!path.isEmpty()) {\\n            TreeNode temp = path.pop();\\n            int tempVal = sub.pop();\\n            if (temp.left == null && temp.right == null) {if (tempVal == sum) return true;}\\n            else {\\n                if (temp.left != null) {\\n                    path.push(temp.left);\\n                    sub.push(temp.left.val + tempVal);\\n                }\\n                if (temp.right != null) {\\n                    path.push(temp.right);\\n                    sub.push(temp.right.val + tempVal);\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n\\n----------\\n\\n    public boolean hasPathSum(TreeNode root, int sum) {\\n        // recursion method\\n        if (root == null) return false;\\n        if (root.left == null && root.right == null && root.val == sum) return true;\\n        return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "  \\n    public boolean hasPathSum(TreeNode root, int sum) {\\n        // iteration method\\n        if (root == null) {return false;}\\n        Stack<TreeNode> path = new Stack<>();\\n        Stack<Integer> sub = new Stack<>();\\n        path.push(root);\\n        sub.push(root.val);\\n        while (!path.isEmpty()) {\\n            TreeNode temp = path.pop();\\n            int tempVal = sub.pop();\\n            if (temp.left == null && temp.right == null) {if (tempVal == sum) return true;}\\n            else {\\n                if (temp.left != null) {\\n                    path.push(temp.left);\\n                    sub.push(temp.left.val + tempVal);\\n                }\\n                if (temp.right != null) {\\n                    path.push(temp.right);\\n                    sub.push(temp.right.val + tempVal);\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n\\n----------\\n\\n    public boolean hasPathSum(TreeNode root, int sum) {\\n        // recursion method\\n        if (root == null) return false;\\n        if (root.left == null && root.right == null && root.val == sum) return true;\\n        return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 36382,
                "title": "accepted-by-using-postorder-traversal",
                "content": "In the postorder traversal, the node will be removed from the stack only when the right sub-tree has been visited.so the path will be stored in the stack. we can keep check the SUM, the length from root to leaf node.\\nat leaf node, if SUM == sum, OK, return true. After postorder traversal, return false.\\n\\nI have compared this solution with recursion solutions. In the leetcode OJ, the run time of two solutions is very near.\\n\\nbelow is my iterator code.\\n\\n\\n    class Solution {\\n    public:\\n        bool hasPathSum(TreeNode *root, int sum) {\\n            stack<TreeNode *> s;\\n            TreeNode *pre = NULL, *cur = root;\\n            int SUM = 0;\\n            while (cur || !s.empty()) {\\n                while (cur) {\\n                    s.push(cur);\\n                    SUM += cur->val;\\n                    cur = cur->left;\\n                }\\n                cur = s.top();\\n                if (cur->left == NULL && cur->right == NULL && SUM == sum) {\\n                    return true;\\n                }\\n                if (cur->right && pre != cur->right) {\\n                    cur = cur->right;\\n                } else {\\n                    pre = cur;\\n                    s.pop();\\n                    SUM -= cur->val;\\n                    cur = NULL;\\n                }\\n            }\\n            return false;\\n        }\\n    };",
                "solutionTags": [
                    "Iterator"
                ],
                "code": "class Solution {\\n    public:\\n        bool hasPathSum(TreeNode *root, int sum) {\\n            stack<TreeNode *> s;\\n            TreeNode *pre = NULL, *cur = root;\\n            int SUM = 0;\\n            while (cur || !s.empty()) {\\n                while (cur) {\\n                    s.push(cur);\\n                    SUM += cur->val;\\n                    cur = cur->left;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2658162,
                "title": "c-beats-95-easy-explained-optimized",
                "content": "**PLEASE UPVOTE IF YOU FIND MY APPROACH HELPFUL, MEANS A LOT \\uD83D\\uDE0A**\\n\\n**Ques)** Why we `return left || right` ???\\n**Ans =>** `return left || right` means we are checking either root->left side gives us our targetSum or root->right side gives us our targetSum\\n\\n```\\nclass Solution {\\npublic:\\n    bool hasPathSum(TreeNode* root, int targetSum)\\n    {\\n        if(root == NULL)\\n        {\\n            return false;\\n        }\\n        if(root->left == NULL && root->right == NULL && root->val - targetSum == 0)\\n        {\\n            return true;\\n        }\\n        \\n        bool left = hasPathSum(root->left,targetSum - root->val);\\n        bool right = hasPathSum(root->right,targetSum - root->val);\\n        \\n        return left || right;\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/dd5b3b44-6321-44eb-8a47-add0158c3dad_1664857526.350247.png)\\n",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool hasPathSum(TreeNode* root, int targetSum)\\n    {\\n        if(root == NULL)\\n        {\\n            return false;\\n        }\\n        if(root->left == NULL && root->right == NULL && root->val - targetSum == 0)\\n        {\\n            return true;\\n        }\\n        \\n        bool left = hasPathSum(root->left,targetSum - root->val);\\n        bool right = hasPathSum(root->right,targetSum - root->val);\\n        \\n        return left || right;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 36534,
                "title": "my-java-no-recursive-method",
                "content": "the idea is preorder traverse , instead of using recursive call, I am using a stack.\\nthe only problem is that I changed TreeNode value\\n\\n    public boolean hasPathSum(TreeNode root, int sum) {\\n    \\t    Stack <TreeNode> stack = new Stack<> ();\\t    \\n    \\t    stack.push(root) ;\\t    \\n    \\t    while (!stack.isEmpty() && root != null){\\n    \\t    \\tTreeNode cur = stack.pop() ;\\t\\n    \\t    \\tif (cur.left == null && cur.right == null){\\t    \\t\\t\\n    \\t    \\t\\tif (cur.val == sum ) return true ;\\n    \\t    \\t}\\n    \\t    \\tif (cur.right != null) {\\n    \\t    \\t\\tcur.right.val = cur.val + cur.right.val ;\\n    \\t    \\t\\tstack.push(cur.right) ;\\n    \\t    \\t}\\n    \\t    \\tif (cur.left != null) {\\n    \\t    \\t\\tcur.left.val = cur.val + cur.left.val;\\n    \\t    \\t\\tstack.push(cur.left);\\n    \\t    \\t}\\n    \\t    }\\t    \\n    \\t    return false ;\\n    \\t }",
                "solutionTags": [],
                "code": "the idea is preorder traverse , instead of using recursive call, I am using a stack.\\nthe only problem is that I changed TreeNode value\\n\\n    public boolean hasPathSum(TreeNode root, int sum) {\\n    \\t    Stack <TreeNode> stack = new Stack<> ();\\t    \\n    \\t    stack.push(root) ;\\t    \\n    \\t    while (!stack.isEmpty() && root != null){\\n    \\t    \\tTreeNode cur = stack.pop() ;\\t\\n    \\t    \\tif (cur.left == null && cur.right == null){\\t    \\t\\t\\n    \\t    \\t\\tif (cur.val == sum ) return true ;\\n    \\t    \\t}\\n    \\t    \\tif (cur.right != null) {\\n    \\t    \\t\\tcur.right.val = cur.val + cur.right.val ;\\n    \\t    \\t\\tstack.push(cur.right) ;\\n    \\t    \\t}\\n    \\t    \\tif (cur.left != null) {\\n    \\t    \\t\\tcur.left.val = cur.val + cur.left.val;\\n    \\t    \\t\\tstack.push(cur.left);\\n    \\t    \\t}\\n    \\t    }\\t    \\n    \\t    return false ;\\n    \\t }",
                "codeTag": "Unknown"
            },
            {
                "id": 1285179,
                "title": "simplest-c-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    bool hasPathSum(TreeNode* root, int targetSum)\\n    {\\n        if(root == NULL)\\n        {\\n            return false;\\n        }\\n        if(root->left == NULL && root->right == NULL && root->val - targetSum == 0)\\n        {\\n            return true;\\n        }\\n        \\n        bool left = hasPathSum(root->left,targetSum - root->val);\\n        bool right = hasPathSum(root->right,targetSum - root->val);\\n        \\n        return left || right;\\n    }\\n};\\n```\\n**Like the solution?\\nPlease upvote \\u30C4**\\n\\nIf you can\\'t understand any step/point, feel free to comment.\\nHappy to help.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool hasPathSum(TreeNode* root, int targetSum)\\n    {\\n        if(root == NULL)\\n        {\\n            return false;\\n        }\\n        if(root->left == NULL && root->right == NULL && root->val - targetSum == 0)\\n        {\\n            return true;\\n        }\\n        \\n        bool left = hasPathSum(root->left,targetSum - root->val);\\n        bool right = hasPathSum(root->right,targetSum - root->val);\\n        \\n        return left || right;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 36596,
                "title": "one-line-solution-sharing-in-javascript",
                "content": "Since this problem is quite straight forward, so I played around a bit and turned it into the shortest solution as below.\\n\\n    /**\\n     * Memo:\\n     * Complex: O(n)\\n     * Runtime: 164ms\\n     * Tests: 114 test cases passed\\n     * Rank: A\\n     */\\n    var hasPathSum = function(root, sum) { return root ? (!root.left && !root.right) ? sum === root.val : (hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val)) : false; };\\n\\nWhile it is equivalent as the following\\n \\n    var hasPathSum = function(root, sum) {\\n        if (!root) return false;\\n\\n        if (!root.left && !root.right) { // check leaf\\n            return sum === root.val;\\n        } else { // continue DFS\\n            return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);\\n        }\\n    };",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "Since this problem is quite straight forward, so I played around a bit and turned it into the shortest solution as below.\\n\\n    /**\\n     * Memo:\\n     * Complex: O(n)\\n     * Runtime: 164ms\\n     * Tests: 114 test cases passed\\n     * Rank: A\\n     */\\n    var hasPathSum = function(root, sum) { return root ? (!root.left && !root.right) ? sum === root.val : (hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val)) : false; };\\n\\nWhile it is equivalent as the following\\n \\n    var hasPathSum = function(root, sum) {\\n        if (!root) return false;\\n\\n        if (!root.left && !root.right) { // check leaf\\n            return sum === root.val;\\n        } else { // continue DFS\\n            return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);\\n        }\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 36372,
                "title": "easy-5-lines-and-clean-java-solution",
                "content": "   You simply check if current node (starting with root) is a leaf node and sum is equal its value. If not, you just check left or right with the decremented sum. If one of them returns true, it has a path.\\n\\n    public boolean hasPathSum(TreeNode root, int sum) {    \\n      if (root == null)\\n         return false;\\n            \\n      if (root.left == null && root.right == null && root.val == sum) // Leaf check\\n         return true;\\n            \\n      return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "   You simply check if current node (starting with root) is a leaf node and sum is equal its value. If not, you just check left or right with the decremented sum. If one of them returns true, it has a path.\\n\\n    public boolean hasPathSum(TreeNode root, int sum) {    \\n      if (root == null)\\n         return false;\\n            \\n      if (root.left == null && root.right == null && root.val == sum) // Leaf check\\n         return true;\\n            \\n      return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 36370,
                "title": "a-java-concise-solution",
                "content": "    public boolean hasPathSum(TreeNode root, int sum) {\\n       if(root == null){\\n\\t     return false;\\n\\t   }\\n       if(root.left == null && root.right == null){\\n\\t      return (root.val == sum);\\n\\t   }\\n\\t   return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);\\n       \\t   \\n    }",
                "solutionTags": [],
                "code": "    public boolean hasPathSum(TreeNode root, int sum) {\\n       if(root == null){\\n\\t     return false;\\n\\t   }\\n       if(root.left == null && root.right == null){\\n\\t      return (root.val == sum);\\n\\t   }\\n\\t   return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);\\n       \\t   \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1749038,
                "title": "c-efficient-recursive-easy-3-lines-solution-with-comments",
                "content": "#### If you understand the approach please please upvote!!!\\n***Thanks :)***\\n```\\nclass Solution {\\npublic:\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        if(root==NULL) return false;\\n        \\n        //we reached here,i.e the root is not NULL, so we took the root value in our sum, and remaining targetSum is targetSum-root value.\\n        targetSum=targetSum-root->val;\\n        \\n        //if the current node is a leaf and its value is equal to the sum, we\\'ve found a path\\n        if(targetSum==0 && root->left==NULL && root->right==NULL) return true;\\n        \\n        // recursively call to traverse the left and right sub-tree\\n        // return true if any of the two recursive call return true\\n        return hasPathSum(root->left,targetSum) || hasPathSum(root->right,targetSum);\\n    }\\n};\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        if(root==NULL) return false;\\n        \\n        //we reached here,i.e the root is not NULL, so we took the root value in our sum, and remaining targetSum is targetSum-root value.\\n        targetSum=targetSum-root->val;\\n        \\n        //if the current node is a leaf and its value is equal to the sum, we\\'ve found a path\\n        if(targetSum==0 && root->left==NULL && root->right==NULL) return true;\\n        \\n        // recursively call to traverse the left and right sub-tree\\n        // return true if any of the two recursive call return true\\n        return hasPathSum(root->left,targetSum) || hasPathSum(root->right,targetSum);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 534122,
                "title": "python-bfs-dfs-recursive-dfs-iterative-solution",
                "content": "#### I. DFS recursive solution\\nAlgorithm:\\n1. Visit a node and check that node is leaf and node.val == sum. If it\\'s true - return True, else continue traverse\\n2. Traverse the left subtree and decrease current sum by value of current node , i.e., call `hasPathSum(node.left, curr_sum - node.val)`\\n3. Traverse the right subtree and decrease current sum by value of current node , i.e., call `hasPathSum(node.right, curr_sum - node.val)`\\n```Python\\ndef hasPathSum(self, root: TreeNode, sum: int) -> bool:\\n\\tif not root:\\n\\t\\treturn False\\n\\tif not root.left and not root.right and root.val == sum:\\n\\t\\treturn True\\n\\treturn self.hasPathSum(root.left, sum - root.val) or self.hasPathSum(root.right, sum - root.val)\\n```\\n\\n#### II. DFS iterative solution\\nAlgorithm:\\n1. Create empty stack and push root node and current sum to stack.\\n2. Do followind steps while stack is not empty:\\n\\t * Pop `(node, curr_sum)` from stack\\n\\t * Cheack that node is leaf and `node.val == sum`. If it\\'s true - return True, else go to the next step\\n\\t * Push left child of popped node and current sum decreased by popped node value `(node.left, curr_sum - node.val)`.\\n\\t * Push right child of popped node and current sum decreased by popped node value `(node.right, curr_sum - node.val)`.\\n3. Return False if sum is not found.\\n```Python\\ndef hasPathSum(self, root: TreeNode, sum: int) -> bool:\\n\\tstack = [(root, sum)]\\n\\twhile stack:\\n\\t\\tnode, curr_sum = stack.pop()\\n\\tif not node:\\n\\t\\tcontinue\\n\\tif not node.left and not node.right and curr_sum == node.val:\\n\\t\\treturn True\\n\\tstack.append((node.left, curr_sum - node.val))\\n\\tstack.append((node.right, curr_sum - node.val))\\n\\treturn False\\n```\\n\\n#### III. BFS Solution\\n\\nAlgorithm:\\n1. Create empty deque (double-ended queue) and push root node and current sum to queue.\\n2. Do followind steps while queue is not empty:\\n\\t * Do popfront/popleft `(node, curr_sum)` from queue\\n\\t * If node is None - continue\\n\\t * Cheack that node is leaf and `node.val == sum`. If it\\'s true - return True, else go to the next step\\n\\t * Push left child of popped node and current sum decreased by popped node value `(node.left, curr_sum - node.val)` to the queue.\\n\\t * Push right child of popped node and current sum decreased by popped node value `(node.right, curr_sum - node.val)` to the queue.\\n3. Return False if sum is not found.\\n\\n```Python\\nfrom collections import deque\\n\\ndef hasPathSum(self, root: TreeNode, sum: int) -> bool:\\n\\tdeq = deque()\\n\\tdeq.append((root, sum))\\n\\t\\twhile deq:\\n\\t\\t\\tnode, curr_sum = deq.popleft()\\n\\t\\t\\tif not node:\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\tif not node.left and not node.right and curr_sum == node.val:\\n\\t\\t\\t\\treturn True\\n\\t\\t\\tdeq.append((node.left, curr_sum - node.val))\\n\\t\\t\\tdeq.append((node.right, curr_sum - node.val))\\n\\treturn False\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```Python\\ndef hasPathSum(self, root: TreeNode, sum: int) -> bool:\\n\\tif not root:\\n\\t\\treturn False\\n\\tif not root.left and not root.right and root.val == sum:\\n\\t\\treturn True\\n\\treturn self.hasPathSum(root.left, sum - root.val) or self.hasPathSum(root.right, sum - root.val)\\n```\n```Python\\ndef hasPathSum(self, root: TreeNode, sum: int) -> bool:\\n\\tstack = [(root, sum)]\\n\\twhile stack:\\n\\t\\tnode, curr_sum = stack.pop()\\n\\tif not node:\\n\\t\\tcontinue\\n\\tif not node.left and not node.right and curr_sum == node.val:\\n\\t\\treturn True\\n\\tstack.append((node.left, curr_sum - node.val))\\n\\tstack.append((node.right, curr_sum - node.val))\\n\\treturn False\\n```\n```Python\\nfrom collections import deque\\n\\ndef hasPathSum(self, root: TreeNode, sum: int) -> bool:\\n\\tdeq = deque()\\n\\tdeq.append((root, sum))\\n\\t\\twhile deq:\\n\\t\\t\\tnode, curr_sum = deq.popleft()\\n\\t\\t\\tif not node:\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\tif not node.left and not node.right and curr_sum == node.val:\\n\\t\\t\\t\\treturn True\\n\\t\\t\\tdeq.append((node.left, curr_sum - node.val))\\n\\t\\t\\tdeq.append((node.right, curr_sum - node.val))\\n\\treturn False\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1329291,
                "title": "java-three-easy-approach-with-explanation-preorder-postorder-0ms",
                "content": "```\\n1 st Approach \\nclass Solution\\n{\\n    public boolean hasPathSum(TreeNode root, int targetSum)//we always try to approach the zero ----0++++ from any half left or right, like taking limit//if zero found at leaf then true else false\\n    {\\n        if(root == null)\\n            return false;//base case when the selected path is not the desired path //we return false and check in next half of the subtree//base case for terminnation of the recursion \\n        else if(root.left == null && root.right == null && targetSum - root.val == 0)//we have faith in tree that it can find the node if present where the value nutralizes each other at 0\\n            return true;//only the case when we are returning true \\n        else\\n            return hasPathSum(root.left,targetSum - root.val)||hasPathSum(root.right,targetSum - root.val);//if present in left is good otherwiswe we are searching in right subtree recursively //all permutation in ways are done by recursion and not our tension \\n    }\\n}//Please do Upvote, It helps a lot\\n```\\n```\\n2 nd Approach \\n\\nclass Solution \\n{\\n    private boolean flag= false;//we are taking the base case as false, if the sum is not found and if the target sum lies in the path from root to leaf, we make the flag true  \\n    \\n    public boolean hasPathSum(TreeNode root, int targetSum) \\n    {\\n        int sum = 0;//calculate the downward sum \\n        \\n        Helper(root, sum, targetSum);//it helps us calculate  the sum of each node for each path from root to leaf and tells us that our desired sum is present or not, by adding the node at that path \\n        \\n        return flag;//returns true if sum is present else false is returned \\n    }\\n    public TreeNode  Helper(TreeNode root, int sum, int targetSum)\\n    {//postorder traversal + semi preorder traversal(accesing root beforehand once), we want to know about child first and then the parent \\n        if(root == null)//base case when we hit the null node, to tell the parent no node is present we return null \\n            return null;\\n        //ROOT\\n        sum= sum + root.val;//adding the node value to sum at each level//accesing root beforehand once\\n        \\n        TreeNode left= Helper(root.left, sum, targetSum);//recursing down the left subtree and knowing about the left child//storring the reference to detect it is leaf or not, if it is leaf then left == null//LEFT\\n        TreeNode right= Helper(root.right, sum, targetSum);//recursing down the right subtree and knowing about the right child//storring the reference to detect it is leaf or not, if it is leaf then right == null//RIGHT\\n        \\n        //ROOT\\n        if(sum == targetSum && left == null && right == null) //if we reached to our desired sum and the parent node is a leaf node, we got our path finally \\n            flag= true;//we make the flag to true as the desired path from root to leaf is achived \\n        \\n        return root;//returning root, to tell the parent that I am present \\n    }\\n}\\n```\\n```\\n3 rd Approach \\nclass Solution {\\n    //0 -- null node, 1 means node, 2 found path node //metadata about the current status of the node \\n     public int PathSum(TreeNode root, int curr, int targetSum){\\n         if ( root == null){\\n            return 0;//we return 0 to tell that i am leaf \\n        }\\n         curr+= root.val;//preorder sum\\n         \\n         int left= PathSum(root.left, curr, targetSum);\\n         \\n         if ( left == 2 )\\n             return 2;//if left path conatins the desired path to leaf node with target sum, we no need to go to right part reccursively\\n         \\n        int right= PathSum(root.right, curr, targetSum);\\n         \\n        if ( right == 2)\\n             return 2;//if right path conatins the desired path to leaf node with target sum, we no need to check further condition we just return 2 in order to indicate desired path has been found\\n         \\n         //Backtracking postorder traversal \\n         \\n        if ( left == 0 && right == 0 && targetSum == curr){//if we reach to leaf node with desired sum we return 2, inorder to indicate we have found the path \\n             return 2;\\n        }\\n        \\n        return 1;//we return 1, to tell that we have not found the desired path till now  \\n     }\\n    public boolean hasPathSum(TreeNode root, int targetSum) {\\n        if ( root == null){\\n            return false;//empty graph, no path tp find we return false \\n        }\\n        \\n        if ( PathSum(root, 0, targetSum) == 2)//found path case \\n            return true;\\n        else\\n            return false;//not path found case \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n1 st Approach \\nclass Solution\\n{\\n    public boolean hasPathSum(TreeNode root, int targetSum)//we always try to approach the zero ----0++++ from any half left or right, like taking limit//if zero found at leaf then true else false\\n    {\\n        if(root == null)\\n            return false;//base case when the selected path is not the desired path //we return false and check in next half of the subtree//base case for terminnation of the recursion \\n        else if(root.left == null && root.right == null && targetSum - root.val == 0)//we have faith in tree that it can find the node if present where the value nutralizes each other at 0\\n            return true;//only the case when we are returning true \\n        else\\n            return hasPathSum(root.left,targetSum - root.val)||hasPathSum(root.right,targetSum - root.val);//if present in left is good otherwiswe we are searching in right subtree recursively //all permutation in ways are done by recursion and not our tension \\n    }\\n}//Please do Upvote, It helps a lot\\n```\n```\\n2 nd Approach \\n\\nclass Solution \\n{\\n    private boolean flag= false;//we are taking the base case as false, if the sum is not found and if the target sum lies in the path from root to leaf, we make the flag true  \\n    \\n    public boolean hasPathSum(TreeNode root, int targetSum) \\n    {\\n        int sum = 0;//calculate the downward sum \\n        \\n        Helper(root, sum, targetSum);//it helps us calculate  the sum of each node for each path from root to leaf and tells us that our desired sum is present or not, by adding the node at that path \\n        \\n        return flag;//returns true if sum is present else false is returned \\n    }\\n    public TreeNode  Helper(TreeNode root, int sum, int targetSum)\\n    {//postorder traversal + semi preorder traversal(accesing root beforehand once), we want to know about child first and then the parent \\n        if(root == null)//base case when we hit the null node, to tell the parent no node is present we return null \\n            return null;\\n        //ROOT\\n        sum= sum + root.val;//adding the node value to sum at each level//accesing root beforehand once\\n        \\n        TreeNode left= Helper(root.left, sum, targetSum);//recursing down the left subtree and knowing about the left child//storring the reference to detect it is leaf or not, if it is leaf then left == null//LEFT\\n        TreeNode right= Helper(root.right, sum, targetSum);//recursing down the right subtree and knowing about the right child//storring the reference to detect it is leaf or not, if it is leaf then right == null//RIGHT\\n        \\n        //ROOT\\n        if(sum == targetSum && left == null && right == null) //if we reached to our desired sum and the parent node is a leaf node, we got our path finally \\n            flag= true;//we make the flag to true as the desired path from root to leaf is achived \\n        \\n        return root;//returning root, to tell the parent that I am present \\n    }\\n}\\n```\n```\\n3 rd Approach \\nclass Solution {\\n    //0 -- null node, 1 means node, 2 found path node //metadata about the current status of the node \\n     public int PathSum(TreeNode root, int curr, int targetSum){\\n         if ( root == null){\\n            return 0;//we return 0 to tell that i am leaf \\n        }\\n         curr+= root.val;//preorder sum\\n         \\n         int left= PathSum(root.left, curr, targetSum);\\n         \\n         if ( left == 2 )\\n             return 2;//if left path conatins the desired path to leaf node with target sum, we no need to go to right part reccursively\\n         \\n        int right= PathSum(root.right, curr, targetSum);\\n         \\n        if ( right == 2)\\n             return 2;//if right path conatins the desired path to leaf node with target sum, we no need to check further condition we just return 2 in order to indicate desired path has been found\\n         \\n         //Backtracking postorder traversal \\n         \\n        if ( left == 0 && right == 0 && targetSum == curr){//if we reach to leaf node with desired sum we return 2, inorder to indicate we have found the path \\n             return 2;\\n        }\\n        \\n        return 1;//we return 1, to tell that we have not found the desired path till now  \\n     }\\n    public boolean hasPathSum(TreeNode root, int targetSum) {\\n        if ( root == null){\\n            return false;//empty graph, no path tp find we return false \\n        }\\n        \\n        if ( PathSum(root, 0, targetSum) == 2)//found path case \\n            return true;\\n        else\\n            return false;//not path found case \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3054429,
                "title": "accepted-easy-solution-short-simple-best-method",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        if(!root)\\n            return false;\\n        if(!root->left && !root->right && root->val==targetSum)\\n            return true;\\n        else\\n            return hasPathSum(root->left, targetSum-root->val) ||\\n            hasPathSum(root->right, targetSum-root->val);\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        if(!root)\\n            return false;\\n        if(!root->left && !root->right && root->val==targetSum)\\n            return true;\\n        else\\n            return hasPathSum(root->left, targetSum-root->val) ||\\n            hasPathSum(root->right, targetSum-root->val);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 36581,
                "title": "my-python-iterative-dfs-solution",
                "content": "    \\n    def hasPathSum(self, root, sum):\\n        if root is None:\\n            return False\\n        stack = [(root, sum)]\\n        while stack:\\n            node, _sum = stack.pop()\\n            if node.left is node.right is None and node.val == _sum:\\n                return True\\n            if node.left:\\n                stack.append((node.left, _sum - node.val))\\n            if node.right:\\n                stack.append((node.right, _sum - node.val))\\n        return False\\n\\n\\nCurrent node and the sum until current node as a tuple is pushed onto the stack to keep track of the sum.",
                "solutionTags": [
                    "Python"
                ],
                "code": "    \\n    def hasPathSum(self, root, sum):\\n        if root is None:\\n            return False\\n        stack = [(root, sum)]\\n        while stack:\\n            node, _sum = stack.pop()\\n            if node.left is node.right is None and node.val == _sum:\\n                return True\\n            if node.left:\\n                stack.append((node.left, _sum - node.val))\\n            if node.right:\\n                stack.append((node.right, _sum - node.val))\\n        return False\\n\\n\\nCurrent node and the sum until current node as a tuple is pushed onto the stack to keep track of the sum.",
                "codeTag": "Python3"
            },
            {
                "id": 518530,
                "title": "c-97-runtime-iterative-and-recursive-solution",
                "content": "Iterative Solution \\n```\\nbool hasPathSum(TreeNode* root, int sum) {\\n        if(root == NULL) return false;\\n        stack<pair<TreeNode*,int>> stack;\\n        stack.push({root, root->val});\\n        while(!stack.empty()) {\\n            TreeNode* current = stack.top().first; \\n            int total_sum = stack.top().second; stack.pop();\\n            if(current->right) stack.push({current->right, total_sum+current->right->val});\\n            if(current->left) stack.push({current->left, total_sum+current->left->val});\\n            if(!current->right && !current->left && total_sum==sum) { //if its a leaf\\n                return true; //and total sum is found\\n            }\\n        }\\n        return false;\\n    }\\n```\\n\\nRecursive Solution\\n```\\nbool hasPathSum(TreeNode* root, int sum) {\\n        if(root == NULL) return false;\\n        int new_sum = sum - root->val;\\n        if(!root->left && !root->right) return new_sum==0;\\n        return hasPathSum(root->left, new_sum) || hasPathSum(root->right, new_sum);\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nbool hasPathSum(TreeNode* root, int sum) {\\n        if(root == NULL) return false;\\n        stack<pair<TreeNode*,int>> stack;\\n        stack.push({root, root->val});\\n        while(!stack.empty()) {\\n            TreeNode* current = stack.top().first; \\n            int total_sum = stack.top().second; stack.pop();\\n            if(current->right) stack.push({current->right, total_sum+current->right->val});\\n            if(current->left) stack.push({current->left, total_sum+current->left->val});\\n            if(!current->right && !current->left && total_sum==sum) { //if its a leaf\\n                return true; //and total sum is found\\n            }\\n        }\\n        return false;\\n    }\\n```\n```\\nbool hasPathSum(TreeNode* root, int sum) {\\n        if(root == NULL) return false;\\n        int new_sum = sum - root->val;\\n        if(!root->left && !root->right) return new_sum==0;\\n        return hasPathSum(root->left, new_sum) || hasPathSum(root->right, new_sum);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 170024,
                "title": "python-solution",
                "content": "Recursion:\\n```\\nclass Solution(object):\\n    def hasPathSum(self, root, sum):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type sum: int\\n        :rtype: bool\\n        \"\"\"\\n        if not root:\\n            return False\\n        elif not root.left and not root.right:\\n            if root.val == sum:\\n                return True\\n            else:\\n                return False\\n        return self.hasPathSum(root.left, sum - root.val) or self.hasPathSum(root.right, sum - root.val)\\n```\\nDFS:\\n```\\nclass Solution(object):\\n    def hasPathSum(self, root, sum):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type sum: int\\n        :rtype: bool\\n        \"\"\"\\n        if not root:\\n            return False\\n        stack = [(root,sum - root.val)]\\n        while stack:\\n            u = stack.pop()\\n            if not u[0].left and not u[0].right:\\n                if u[1] == 0:\\n                    return True\\n            if u[0].left:\\n                stack.append((u[0].left, u[1]-u[0].left.val))\\n            if u[0].right:\\n                stack.append((u[0].right, u[1]-u[0].right.val))\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def hasPathSum(self, root, sum):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type sum: int\\n        :rtype: bool\\n        \"\"\"\\n        if not root:\\n            return False\\n        elif not root.left and not root.right:\\n            if root.val == sum:\\n                return True\\n            else:\\n                return False\\n        return self.hasPathSum(root.left, sum - root.val) or self.hasPathSum(root.right, sum - root.val)\\n```\n```\\nclass Solution(object):\\n    def hasPathSum(self, root, sum):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type sum: int\\n        :rtype: bool\\n        \"\"\"\\n        if not root:\\n            return False\\n        stack = [(root,sum - root.val)]\\n        while stack:\\n            u = stack.pop()\\n            if not u[0].left and not u[0].right:\\n                if u[1] == 0:\\n                    return True\\n            if u[0].left:\\n                stack.append((u[0].left, u[1]-u[0].left.val))\\n            if u[0].right:\\n                stack.append((u[0].right, u[1]-u[0].right.val))\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3977919,
                "title": "easy-solution-python3-c-c-c-java-explain-line-by-line-with-image",
                "content": "# Problem\\nYou\\'re given a binary tree and an integer targetSum. The task is to determine whether there exists a root-to-leaf path in the tree where the sum of the values of the nodes along the path equals the targetSum.\\n\\nIn other words, you need to check if there\\'s a sequence of nodes starting from the root and following edges to reach a leaf node such that the sum of values along this path is equal to the given targetSum.\\n\\n\\n---\\n# Solution\\nThe provided solution is implemented as a method named hasPathSum within a class named Solution. The method takes two parameters: root, which is the root node of the binary tree, and targetSum, the desired sum.\\n\\n\\n**Here\\'s how the solution works:** \\n\\n1. f root is None (i.e., the tree is empty), there can\\'t be any path with the desired sum. So, the function returns False.\\n2. If root is a leaf node (i.e., it has no left or right children), the function checks whether the value of the leaf node is equal to the remaining targetSum. If they are equal, it returns True, indicating that a valid path with the target sum has been found.\\n3. If the above conditions are not met, the function recursively checks for a valid path with the target sum in both the left and right subtrees. It subtracts the value of the current node from the targetSum before passing it to the recursive calls.\\n4. The result of the recursive calls on the left and right subtrees (left_sum and right_sum) are then combined using the logical OR operation. This is because if either the left subtree or the right subtree has a valid path, it means there\\'s a valid path in the entire tree, so the function should return True.\\n5. If none of the above conditions are met, the function returns False.\\n\\nThe base cases (when the tree is empty or when a leaf node with a matching value is found) guarantee that the recursion will eventually terminate. The recursion explores all possible paths from the root to leaf nodes, checking if any of them sum up to the given targetSum. The logical OR operation on the results of the recursive calls ensures that the function correctly returns True if a valid path is found anywhere in the tree.\\n\\nThis solution has a time complexity of O(N), where N is the number of nodes in the binary tree, as it visits each node once in the worst case.\\n\\n![Screenshot 2023-08-20 065922.png](https://assets.leetcode.com/users/images/5bd15a5a-5ff9-4683-82d9-2c25a18bc26a_1693336283.4753764.png)\\n\\n\\n# Code\\n---\\n\\n```Python3 []\\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        if not root:\\n            return False\\n        \\n        if not root.left and not root.right:\\n            return targetSum == root.val\\n        \\n        left_sum = self.hasPathSum(root.left, targetSum - root.val)\\n        right_sum = self.hasPathSum(root.right, targetSum - root.val)\\n        \\n        return left_sum or right_sum\\n```\\n```python []\\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        if not root:\\n            return False\\n        \\n        if not root.left and not root.right:\\n            return targetSum == root.val\\n        \\n        left_sum = self.hasPathSum(root.left, targetSum - root.val)\\n        right_sum = self.hasPathSum(root.right, targetSum - root.val)\\n        \\n        return left_sum or right_sum\\n```\\n```C# []\\npublic class Solution\\n{\\n    public bool HasPathSum(TreeNode root, int targetSum)\\n    {\\n        if (root == null)\\n        {\\n            return false;\\n        }\\n\\n        if (root.left == null && root.right == null)\\n        {\\n            return targetSum == root.val;\\n        }\\n\\n        bool leftSum = HasPathSum(root.left, targetSum - root.val);\\n        bool rightSum = HasPathSum(root.right, targetSum - root.val);\\n\\n        return leftSum || rightSum;\\n    }\\n}\\n```\\n\\n```C++ []\\nclass Solution {\\npublic:\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        if (!root) {\\n            return false;\\n        }\\n        \\n        if (!root->left && !root->right) {\\n            return targetSum == root->val;\\n        }\\n        \\n        bool left_sum = hasPathSum(root->left, targetSum - root->val);\\n        bool right_sum = hasPathSum(root->right, targetSum - root->val);\\n        \\n        return left_sum || right_sum;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public boolean hasPathSum(TreeNode root, int targetSum) {\\n        if (root == null) {\\n            return false;\\n        }\\n        \\n        if (root.left == null && root.right == null) {\\n            return targetSum == root.val;\\n        }\\n        \\n        boolean leftSum = hasPathSum(root.left, targetSum - root.val);\\n        boolean rightSum = hasPathSum(root.right, targetSum - root.val);\\n        \\n        return leftSum || rightSum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "C#"
                ],
                "code": "```Python3 []\\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        if not root:\\n            return False\\n        \\n        if not root.left and not root.right:\\n            return targetSum == root.val\\n        \\n        left_sum = self.hasPathSum(root.left, targetSum - root.val)\\n        right_sum = self.hasPathSum(root.right, targetSum - root.val)\\n        \\n        return left_sum or right_sum\\n```\n```python []\\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        if not root:\\n            return False\\n        \\n        if not root.left and not root.right:\\n            return targetSum == root.val\\n        \\n        left_sum = self.hasPathSum(root.left, targetSum - root.val)\\n        right_sum = self.hasPathSum(root.right, targetSum - root.val)\\n        \\n        return left_sum or right_sum\\n```\n```C# []\\npublic class Solution\\n{\\n    public bool HasPathSum(TreeNode root, int targetSum)\\n    {\\n        if (root == null)\\n        {\\n            return false;\\n        }\\n\\n        if (root.left == null && root.right == null)\\n        {\\n            return targetSum == root.val;\\n        }\\n\\n        bool leftSum = HasPathSum(root.left, targetSum - root.val);\\n        bool rightSum = HasPathSum(root.right, targetSum - root.val);\\n\\n        return leftSum || rightSum;\\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        if (!root) {\\n            return false;\\n        }\\n        \\n        if (!root->left && !root->right) {\\n            return targetSum == root->val;\\n        }\\n        \\n        bool left_sum = hasPathSum(root->left, targetSum - root->val);\\n        bool right_sum = hasPathSum(root->right, targetSum - root->val);\\n        \\n        return left_sum || right_sum;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public boolean hasPathSum(TreeNode root, int targetSum) {\\n        if (root == null) {\\n            return false;\\n        }\\n        \\n        if (root.left == null && root.right == null) {\\n            return targetSum == root.val;\\n        }\\n        \\n        boolean leftSum = hasPathSum(root.left, targetSum - root.val);\\n        boolean rightSum = hasPathSum(root.right, targetSum - root.val);\\n        \\n        return leftSum || rightSum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2658019,
                "title": "leetcode-the-hard-way-explained-line-by-line",
                "content": "Please check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\nI\\'ll explain my solution line by line daily and you can find the full list in my [Discord](https://discord.gg/Nqm4jJcyBf).\\nIf you like it, please give a star, watch my [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post.\\n\\n---\\n\\n<iframe src=\"https://leetcode.com/playground/PNj2PJfY/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\"></iframe>",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "Please check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\nI\\'ll explain my solution line by line daily and you can find the full list in my [Discord](https://discord.gg/Nqm4jJcyBf).\\nIf you like it, please give a star, watch my [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post.\\n\\n---\\n\\n<iframe src=\"https://leetcode.com/playground/PNj2PJfY/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\"></iframe>",
                "codeTag": "Unknown"
            },
            {
                "id": 36489,
                "title": "3-line-java-solution",
                "content": "\\n    public boolean hasPathSum(TreeNode root, int sum) {\\n        if (root == null) return false;\\n        if (root.left == null && root.right == null && root.val == sum) return true;\\n        return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);\\n    }",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "\\n    public boolean hasPathSum(TreeNode root, int sum) {\\n        if (root == null) return false;\\n        if (root.left == null && root.right == null && root.val == sum) return true;\\n        return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2658792,
                "title": "python-elegant-short-dfs",
                "content": "```\\nclass Solution:\\n    \"\"\"\\n    Time:   O(n)\\n    Memory: O(n)\\n    \"\"\"\\n\\n    def hasPathSum(self, root: Optional[TreeNode], target: int) -> bool:\\n        if root is None:\\n            return False\\n        if root.left is None and root.right is None:\\n            return target == root.val\\n        return self.hasPathSum( root.left, target - root.val) or \\\\\\n               self.hasPathSum(root.right, target - root.val)\\n```\\n\\nIf you like this solution remember to **upvote it** to let me know.\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    \"\"\"\\n    Time:   O(n)\\n    Memory: O(n)\\n    \"\"\"\\n\\n    def hasPathSum(self, root: Optional[TreeNode], target: int) -> bool:\\n        if root is None:\\n            return False\\n        if root.left is None and root.right is None:\\n            return target == root.val\\n        return self.hasPathSum( root.left, target - root.val) or \\\\\\n               self.hasPathSum(root.right, target - root.val)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1255933,
                "title": "c-dfs-multiple-solutions",
                "content": "```\\nSolution 1: \\nclass Solution {\\npublic:\\n    \\n    int pathSum = 0; \\n    bool pathFound = false;\\n    \\n    bool hasPathSum(TreeNode* root, int targetSum) \\n    {                \\n        if(root != NULL)\\n        {\\n            pathSum += root->val;\\n            \\n            if(root->left == NULL && root->right == NULL)\\n            {\\n                if(pathSum == targetSum)\\n                    pathFound = true;\\n            }\\n            else\\n            {\\n                hasPathSum(root->left, targetSum);\\n                hasPathSum(root->right, targetSum);\\n            }\\n            \\n            pathSum -= root->val;    \\n        }\\n\\n        return (pathFound == true) ? true : false;\\n     }\\n};\\n\\nSolution 2: \\n\\nclass Solution {\\npublic:\\n    \\n   \\n    bool hasPathSum(TreeNode* root, int targetSum) \\n    {        \\n        if (root == nullptr) \\n        {\\n          return false;\\n        }\\n\\n        // if the current node is a leaf and its value is equal to the sum, we\\'ve found a path\\n        if (root->val == targetSum && root->left == nullptr && root->right == nullptr) \\n        {\\n          return true;\\n        }\\n\\t\\t\\n        // recursively call to traverse the left and right sub-tree\\n        // return true if any of the two recursive call return true\\n        return hasPathSum(root->left, targetSum - root->val) || hasPathSum(root->right, targetSum - root->val);\\n     }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nSolution 1: \\nclass Solution {\\npublic:\\n    \\n    int pathSum = 0; \\n    bool pathFound = false;\\n    \\n    bool hasPathSum(TreeNode* root, int targetSum) \\n    {                \\n        if(root != NULL)\\n        {\\n            pathSum += root->val;\\n            \\n            if(root->left == NULL && root->right == NULL)\\n            {\\n                if(pathSum == targetSum)\\n                    pathFound = true;\\n            }\\n            else\\n            {\\n                hasPathSum(root->left, targetSum);\\n                hasPathSum(root->right, targetSum);\\n            }\\n            \\n            pathSum -= root->val;    \\n        }\\n\\n        return (pathFound == true) ? true : false;\\n     }\\n};\\n\\nSolution 2: \\n\\nclass Solution {\\npublic:\\n    \\n   \\n    bool hasPathSum(TreeNode* root, int targetSum) \\n    {        \\n        if (root == nullptr) \\n        {\\n          return false;\\n        }\\n\\n        // if the current node is a leaf and its value is equal to the sum, we\\'ve found a path\\n        if (root->val == targetSum && root->left == nullptr && root->right == nullptr) \\n        {\\n          return true;\\n        }\\n\\t\\t\\n        // recursively call to traverse the left and right sub-tree\\n        // return true if any of the two recursive call return true\\n        return hasPathSum(root->left, targetSum - root->val) || hasPathSum(root->right, targetSum - root->val);\\n     }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 36470,
                "title": "u3010python-u3011recursive-solution-with-explanation-and-thinking-process",
                "content": "## Base case\\n1. This question wants to find a path from node to the **leaf**, so the node who satisfies must be a **leaf** (`not node.left and not nood.right`)\\n2. I want to recursively subtract the `sum` by current node's value, so the leaf node of correct path must have the same value of its assigned `sum`\\n\\n## Recursive step\\n1. We want to traverse all the nodes, so `node.left` and `node.right` must be called parallelly\\n2. One valid path is enough, so we want to use `or` to connect two \"branches\"\\n3. Considering each node as the root of its children, `sum` should be modified from its parent\\n\\n<br>\\n\\n    def hasPathSum(self, root, sum):\\n        if not root:\\n            return False\\n            \\n        if root.val == sum and not root.left and not root.right:\\n            return True\\n            \\n        return self.hasPathSum(root.left, sum - root.val) or \\\\\\n               self.hasPathSum(root.right, sum - root.val)",
                "solutionTags": [
                    "Python"
                ],
                "code": "## Base case\\n1. This question wants to find a path from node to the **leaf**, so the node who satisfies must be a **leaf** (`not node.left and not nood.right`)\\n2. I want to recursively subtract the `sum` by current node's value, so the leaf node of correct path must have the same value of its assigned `sum`\\n\\n## Recursive step\\n1. We want to traverse all the nodes, so `node.left` and `node.right` must be called parallelly\\n2. One valid path is enough, so we want to use `or` to connect two \"branches\"\\n3. Considering each node as the root of its children, `sum` should be modified from its parent\\n\\n<br>\\n\\n    def hasPathSum(self, root, sum):\\n        if not root:\\n            return False\\n            \\n        if root.val == sum and not root.left and not root.right:\\n            return True\\n            \\n        return self.hasPathSum(root.left, sum - root.val) or \\\\\\n               self.hasPathSum(root.right, sum - root.val)",
                "codeTag": "Python3"
            },
            {
                "id": 2432844,
                "title": "very-easy-100-3-line-explained-java-c-python-js-c-python3",
                "content": "# **Java Solution:**\\nRuntime: 0 ms, faster than 100.00% of Java online submissions for Path Sum.\\n```\\nclass Solution {\\n    public boolean hasPathSum(TreeNode root, int targetSum) {\\n        // If the tree is empty i.e. root is NULL, return false...\\n\\t    if (root == null) return false;\\n        // If there is only a single root node and the value of root node is equal to the targetSum...\\n\\t    if (root.val == targetSum && (root.left == null && root.right == null)) return true;\\n        // Call the same function recursively for left and right subtree...\\n\\t    return hasPathSum(root.left, targetSum - root.val)|| hasPathSum(root.right, targetSum - root.val);\\n    }\\n}\\n```\\n\\n# **C++ Solution:**\\nRuntime: 6 ms, faster than 89.18% of C++ online submissions for Path Sum.\\nMemory Usage: 11.2 MB, less than 92.17% of C++ online submissions for Path Sum.\\n```\\nclass Solution {\\npublic:\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        // If the tree is empty i.e. root is NULL, return false...\\n\\t    if (root == NULL) return false;\\n        // If there is only a single root node and the value of root node is equal to the targetSum...\\n\\t    if (root->val == targetSum && (root->left == NULL && root->right == NULL)) return true;\\n        // Call the same function recursively for left and right subtree...\\n\\t    return hasPathSum(root->left, targetSum - root->val)|| hasPathSum(root->right, targetSum - root->val);\\n    }\\n};\\n```\\n\\n\\n# **Python Solution:**\\n```\\nclass Solution(object):\\n    def hasPathSum(self, root, targetSum):\\n        # If the tree is empty i.e. root is NULL, return false...\\n\\t    if root is None: return 0\\n        # If there is only a single root node and the value of root node is equal to the targetSum...\\n\\t    if root.val == targetSum and (root.left is None and root.right is None):  return 1\\n        # Call the same function recursively for left and right subtree...\\n\\t    return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)\\n```\\n            \\n# **JavaScript Solution:**\\n```\\nvar hasPathSum = function(root, targetSum) {\\n    // If the tree is empty i.e. root is NULL, return false...\\n\\tif (root == null) return false;\\n    // If there is only a single root node and the value of root node is equal to the targetSum...\\n\\tif (root.val == targetSum && (root.left == null && root.right == null)) return true;\\n    // Call the same function recursively for left and right subtree...\\n\\treturn hasPathSum(root.left, targetSum - root.val)|| hasPathSum(root.right, targetSum - root.val);\\n};\\n```\\n\\n# **C Language:**\\n```\\nbool hasPathSum(struct TreeNode* root, int targetSum){\\n    // If the tree is empty i.e. root is NULL, return false...\\n\\tif (root == NULL) return false;\\n    // If there is only a single root node and the value of root node is equal to the targetSum...\\n\\tif (root->val == targetSum && (root->left == NULL && root->right == NULL)) return true;\\n    // Call the same function recursively for left and right subtree...\\n\\treturn hasPathSum(root->left, targetSum - root->val)|| hasPathSum(root->right, targetSum - root->val);\\n}\\n```\\n\\n# **Python3 Solution:**\\n```\\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        # If the tree is empty i.e. root is NULL, return false...\\n\\t    if root is None: return 0\\n        # If there is only a single root node and the value of root node is equal to the targetSum...\\n\\t    if root.val == targetSum and (root.left is None and root.right is None):  return 1\\n        # Call the same function recursively for left and right subtree...\\n\\t    return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)\\n```\\n**I am working hard for you guys...\\nPlease upvote if you found any help with this code...**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public boolean hasPathSum(TreeNode root, int targetSum) {\\n        // If the tree is empty i.e. root is NULL, return false...\\n\\t    if (root == null) return false;\\n        // If there is only a single root node and the value of root node is equal to the targetSum...\\n\\t    if (root.val == targetSum && (root.left == null && root.right == null)) return true;\\n        // Call the same function recursively for left and right subtree...\\n\\t    return hasPathSum(root.left, targetSum - root.val)|| hasPathSum(root.right, targetSum - root.val);\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        // If the tree is empty i.e. root is NULL, return false...\\n\\t    if (root == NULL) return false;\\n        // If there is only a single root node and the value of root node is equal to the targetSum...\\n\\t    if (root->val == targetSum && (root->left == NULL && root->right == NULL)) return true;\\n        // Call the same function recursively for left and right subtree...\\n\\t    return hasPathSum(root->left, targetSum - root->val)|| hasPathSum(root->right, targetSum - root->val);\\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def hasPathSum(self, root, targetSum):\\n        # If the tree is empty i.e. root is NULL, return false...\\n\\t    if root is None: return 0\\n        # If there is only a single root node and the value of root node is equal to the targetSum...\\n\\t    if root.val == targetSum and (root.left is None and root.right is None):  return 1\\n        # Call the same function recursively for left and right subtree...\\n\\t    return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)\\n```\n```\\nvar hasPathSum = function(root, targetSum) {\\n    // If the tree is empty i.e. root is NULL, return false...\\n\\tif (root == null) return false;\\n    // If there is only a single root node and the value of root node is equal to the targetSum...\\n\\tif (root.val == targetSum && (root.left == null && root.right == null)) return true;\\n    // Call the same function recursively for left and right subtree...\\n\\treturn hasPathSum(root.left, targetSum - root.val)|| hasPathSum(root.right, targetSum - root.val);\\n};\\n```\n```\\nbool hasPathSum(struct TreeNode* root, int targetSum){\\n    // If the tree is empty i.e. root is NULL, return false...\\n\\tif (root == NULL) return false;\\n    // If there is only a single root node and the value of root node is equal to the targetSum...\\n\\tif (root->val == targetSum && (root->left == NULL && root->right == NULL)) return true;\\n    // Call the same function recursively for left and right subtree...\\n\\treturn hasPathSum(root->left, targetSum - root->val)|| hasPathSum(root->right, targetSum - root->val);\\n}\\n```\n```\\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        # If the tree is empty i.e. root is NULL, return false...\\n\\t    if root is None: return 0\\n        # If there is only a single root node and the value of root node is equal to the targetSum...\\n\\t    if root.val == targetSum and (root.left is None and root.right is None):  return 1\\n        # Call the same function recursively for left and right subtree...\\n\\t    return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2658225,
                "title": "java-easy-solution-2-liner-code-recursive",
                "content": "\\tPLEASE UPVOTE IF YOU LIKE.\\n```\\npublic class Solution {\\n    public boolean hasPathSum(TreeNode root, int sum) {\\n        if(root==null)return false;\\n        sum = sum - root.val;\\n        if(root.left==null && root.right==null){\\n            if(sum == 0)return true;\\n            else return false;\\n        }\\n        return hasPathSum(root.left,sum) || hasPathSum(root.right,sum);\\n        \\n        \\n    }\\n    \\n   \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\npublic class Solution {\\n    public boolean hasPathSum(TreeNode root, int sum) {\\n        if(root==null)return false;\\n        sum = sum - root.val;\\n        if(root.left==null && root.right==null){\\n            if(sum == 0)return true;\\n            else return false;\\n        }\\n        return hasPathSum(root.left,sum) || hasPathSum(root.right,sum);\\n        \\n        \\n    }\\n    \\n   \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1928074,
                "title": "100-fastest-swift-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public var val: Int\\n *     public var left: TreeNode?\\n *     public var right: TreeNode?\\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n *         self.val = val\\n *         self.left = left\\n *         self.right = right\\n *     }\\n * }\\n */\\nclass Solution {\\n    func hasPathSum(_ root: TreeNode?, _ targetSum: Int) -> Bool {\\n        guard let root = root else { return false }\\n        \\n        if root.val == targetSum && root.left == nil && root.right == nil { return true }\\n        \\n        return hasPathSum(root.left, targetSum - root.val) || hasPathSum(root.right, targetSum - root.val)\\n    }\\n    \\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public var val: Int\\n *     public var left: TreeNode?\\n *     public var right: TreeNode?\\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n *         self.val = val\\n *         self.left = left\\n *         self.right = right\\n *     }\\n * }\\n */\\nclass Solution {\\n    func hasPathSum(_ root: TreeNode?, _ targetSum: Int) -> Bool {\\n        guard let root = root else { return false }\\n        \\n        if root.val == targetSum && root.left == nil && root.right == nil { return true }\\n        \\n        return hasPathSum(root.left, targetSum - root.val) || hasPathSum(root.right, targetSum - root.val)\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 779613,
                "title": "python-simple-dfs",
                "content": "```\\ndef hasPathSum(self, root: TreeNode, sum: int) -> bool:\\n    if not root: # edge case\\n        return False\\n    if not root.left and not root.right: \\n        return sum == root.val\\n    return self.hasPathSum(root.left, sum - root.val) or self.hasPathSum(root.right, sum - root.val)\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\ndef hasPathSum(self, root: TreeNode, sum: int) -> bool:\\n    if not root: # edge case\\n        return False\\n    if not root.left and not root.right: \\n        return sum == root.val\\n    return self.hasPathSum(root.left, sum - root.val) or self.hasPathSum(root.right, sum - root.val)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3193152,
                "title": "path-sum-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThis solution uses an iterative approach with a stack to traverse the binary tree and keep track of the current path value. It checks if the current node is a leaf node and its value matches the target sum. If not, it adds the left and right children to the stack along with their updated path value. It returns False if no such path is found.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        if not root:\\n            return False\\n        \\n        # Use a list to store the path from root to the current node\\n        stack = [(root, root.val)]\\n        \\n        while stack:\\n            node, val = stack.pop()\\n            \\n            # Check if the current node is a leaf node and its value matches the targetSum\\n            if not node.left and not node.right and val == targetSum:\\n                return True\\n            \\n            # Add the left and right children to the stack along with their updated path value\\n            if node.left:\\n                stack.append((node.left, val + node.left.val))\\n            if node.right:\\n                stack.append((node.right, val + node.right.val))\\n        \\n        return False\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Tree",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        if not root:\\n            return False\\n        \\n        # Use a list to store the path from root to the current node\\n        stack = [(root, root.val)]\\n        \\n        while stack:\\n            node, val = stack.pop()\\n            \\n            # Check if the current node is a leaf node and its value matches the targetSum\\n            if not node.left and not node.right and val == targetSum:\\n                return True\\n            \\n            # Add the left and right children to the stack along with their updated path value\\n            if node.left:\\n                stack.append((node.left, val + node.left.val))\\n            if node.right:\\n                stack.append((node.right, val + node.right.val))\\n        \\n        return False\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1207135,
                "title": "easy-js-solution",
                "content": "```\\n/*\\n1. Use DFS to try all possible paths.\\n2. Keep track of the sum of path during traversal. When leaf node is reached, check if\\nthe sum of path equals the target. If so, return true, else continue DFS traversal to\\ntry other paths.\\n*/\\nvar hasPathSum = function(root, targetSum) {\\n    return dfs(root, targetSum);\\n    // T.C: O(N)\\n    // S.C: O(H)\\n};\\n\\nconst dfs = (root, target) => {\\n    if (!root) {\\n        return false;\\n    }\\n    if (!root.left && !root.right) {\\n        return target - root.val === 0;\\n    }\\n    return dfs(root.left, target - root.val) || \\n        dfs(root.right, target - root.val);\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/*\\n1. Use DFS to try all possible paths.\\n2. Keep track of the sum of path during traversal. When leaf node is reached, check if\\nthe sum of path equals the target. If so, return true, else continue DFS traversal to\\ntry other paths.\\n*/\\nvar hasPathSum = function(root, targetSum) {\\n    return dfs(root, targetSum);\\n    // T.C: O(N)\\n    // S.C: O(H)\\n};\\n\\nconst dfs = (root, target) => {\\n    if (!root) {\\n        return false;\\n    }\\n    if (!root.left && !root.right) {\\n        return target - root.val === 0;\\n    }\\n    return dfs(root.left, target - root.val) || \\n        dfs(root.right, target - root.val);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1190588,
                "title": "python-recursive-approach-easy-to-solve",
                "content": "Think about one small tree. Let say we have only one node like\\n```\\n\\t\\t\\t\\t\\t    1\\n\\t\\t\\t\\tNone         None\\n```\\nand targetSum is 1, so our condtion will be \\n```\\nif root.left is None and root.right is None and root.val == targetSum:\\n            return True\\n```\\n  \\n                     1\\n\\t\\t\\t\\t2         3\\nand targetSum is 4\\nFor the above example we have the path sum in right hand side, so whenever we are recursively calling on a node we will check both side of the tree.\\n```\\n\\nclass Solution:\\n    def hasPathSum(self, root: TreeNode, targetSum: int) -> bool:\\n        \\n        if root is None: return False\\n        \\n        if root.left is None and root.right is None and root.val == targetSum:\\n            return True\\n        \\n        return self.hasPathSum(root.left, targetSum-root.val) or self.hasPathSum(root.right, targetSum-root.val)\\n```\\nPlease Upvote if you get it.\\n\\nPlease check out Path sum II solution. (https://leetcode.com/problems/path-sum-ii/discuss/1192146/Python-or-Recursive-approach-or-97-beats)\\n",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\n\\t\\t\\t\\t\\t    1\\n\\t\\t\\t\\tNone         None\\n```\n```\\nif root.left is None and root.right is None and root.val == targetSum:\\n            return True\\n```\n```\\n\\nclass Solution:\\n    def hasPathSum(self, root: TreeNode, targetSum: int) -> bool:\\n        \\n        if root is None: return False\\n        \\n        if root.left is None and root.right is None and root.val == targetSum:\\n            return True\\n        \\n        return self.hasPathSum(root.left, targetSum-root.val) or self.hasPathSum(root.right, targetSum-root.val)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 744383,
                "title": "c-solution-recursion-iterative-dfs-iterative-bfs",
                "content": "```\\nclass Solution {\\n public:\\n  bool hasPathSum(TreeNode* root, int sum) {\\n    if (not root) return false;\\n    sum -= root->val;\\n    if (not root->left and not root->right) {\\n      return sum == 0;\\n    }\\n    return hasPathSum(root->left, sum) || hasPathSum(root->right, sum);\\n  }\\n};\\n```\\n//DFS\\n```\\nclass Solution {\\n public:\\n  bool hasPathSum(TreeNode* root, int sum) {\\n    if (!root) return false;\\n    stack<pair<TreeNode*, int>> stk;\\n    stk.push({root, sum});\\n    while (!stk.empty()) {\\n      auto [node, curr_sum] = stk.top();\\n      stk.pop();\\n      curr_sum -= node->val;\\n      if (!node->left && !node->right && curr_sum == 0) {\\n        return true;\\n      }\\n      if (node->right) stk.push({node->right, curr_sum});\\n      if (node->left) stk.push({node->left, curr_sum});\\n    }\\n    return false;\\n  }\\n};\\n```\\n// BFS\\n```\\nclass Solution {\\n public:\\n  bool hasPathSum(TreeNode *root, int sum) {\\n    if (!root) return false;\\n    queue<pair<TreeNode *, int>> q;\\n    q.push({root, sum});\\n    while (!q.empty()) {\\n      auto [node, curr_sum] = q.front();\\n      q.pop();\\n      curr_sum -= node->val;\\n      if (!node->left && !node->right && curr_sum == 0) return true;\\n      if (node->left) q.push({node->left, curr_sum});\\n      if (node->right) q.push({node->right, curr_sum});\\n    }\\n    return false;\\n  }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n public:\\n  bool hasPathSum(TreeNode* root, int sum) {\\n    if (not root) return false;\\n    sum -= root->val;\\n    if (not root->left and not root->right) {\\n      return sum == 0;\\n    }\\n    return hasPathSum(root->left, sum) || hasPathSum(root->right, sum);\\n  }\\n};\\n```\n```\\nclass Solution {\\n public:\\n  bool hasPathSum(TreeNode* root, int sum) {\\n    if (!root) return false;\\n    stack<pair<TreeNode*, int>> stk;\\n    stk.push({root, sum});\\n    while (!stk.empty()) {\\n      auto [node, curr_sum] = stk.top();\\n      stk.pop();\\n      curr_sum -= node->val;\\n      if (!node->left && !node->right && curr_sum == 0) {\\n        return true;\\n      }\\n      if (node->right) stk.push({node->right, curr_sum});\\n      if (node->left) stk.push({node->left, curr_sum});\\n    }\\n    return false;\\n  }\\n};\\n```\n```\\nclass Solution {\\n public:\\n  bool hasPathSum(TreeNode *root, int sum) {\\n    if (!root) return false;\\n    queue<pair<TreeNode *, int>> q;\\n    q.push({root, sum});\\n    while (!q.empty()) {\\n      auto [node, curr_sum] = q.front();\\n      q.pop();\\n      curr_sum -= node->val;\\n      if (!node->left && !node->right && curr_sum == 0) return true;\\n      if (node->left) q.push({node->left, curr_sum});\\n      if (node->right) q.push({node->right, curr_sum});\\n    }\\n    return false;\\n  }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3768446,
                "title": "java-100-faster-solution-step-by-step-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(H)\\n![Screenshot_20230205_171246.png](https://assets.leetcode.com/users/images/6a3e9288-d254-4302-b55e-0e221543c512_1689421045.2787068.png)\\n\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean hasPathSum(TreeNode root, int targetSum) {\\n        if (root == null) {\\n            return false;\\n        }\\n        \\n        // Check if the current node is a leaf node and its value matches the targetSum\\n        if (root.left == null && root.right == null && root.val == targetSum) {\\n            return true;\\n        }\\n        \\n        // Recursively check the left and right subtrees with updated targetSum\\n        return hasPathSum(root.left, targetSum - root.val) || hasPathSum(root.right, targetSum - root.val);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean hasPathSum(TreeNode root, int targetSum) {\\n        if (root == null) {\\n            return false;\\n        }\\n        \\n        // Check if the current node is a leaf node and its value matches the targetSum\\n        if (root.left == null && root.right == null && root.val == targetSum) {\\n            return true;\\n        }\\n        \\n        // Recursively check the left and right subtrees with updated targetSum\\n        return hasPathSum(root.left, targetSum - root.val) || hasPathSum(root.right, targetSum - root.val);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2799035,
                "title": "c-solutions",
                "content": "```\\nclass Solution {\\npublic:\\n    bool hasPathSum(TreeNode* root, int sum) {\\n        if(!root)return false;                                         //Terminating Condition\\n        sum=sum-root->val;                                             //Body\\n        if(sum==0&&!root->left&&!root->right)return true;              //body\\n        return hasPathSum(root->left,sum)||hasPathSum(root->right,sum);//Propagation\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool hasPathSum(TreeNode* root, int sum) {\\n        if(!root)return false;                                         //Terminating Condition\\n        sum=sum-root->val;                                             //Body\\n        if(sum==0&&!root->left&&!root->right)return true;              //body\\n        return hasPathSum(root->left,sum)||hasPathSum(root->right,sum);//Propagation\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2658451,
                "title": "path-sum-99-22-fastest-execution-c-3-line-easy-solution-simple-and-short",
                "content": "**SHIVAM DAILY LEETCODE SOLUTIONS || CHECK : [https://bit.ly/leetcode-solutions](https://bit.ly/leetcode-solutions)\\nRuntime: 4 ms, faster than 99.22% of C++ online submissions for Path Sum.\\nMemory Usage: 21.4 MB, less than 38.76% of C++ online submissions for Path Sum.** \\n\\n```\\nclass Solution {\\npublic:\\n    bool hasPathSum(TreeNode* root, int sum)\\n    {\\n        if (!root) return false;\\n        if (!root->left && !root->right) return root->val == sum;\\n        return hasPathSum(root->left, sum - root->val) || hasPathSum(root->right, sum - root->val);\\n    }\\n};\\n\\n```\\n![image](https://assets.leetcode.com/users/images/6523b1bc-71a3-4707-b34e-bcd7a708ca8d_1664862675.8947413.png)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool hasPathSum(TreeNode* root, int sum)\\n    {\\n        if (!root) return false;\\n        if (!root->left && !root->right) return root->val == sum;\\n        return hasPathSum(root->left, sum - root->val) || hasPathSum(root->right, sum - root->val);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 518065,
                "title": "javascript-solution-98-32",
                "content": "```\\nvar hasPathSum = function(root, sum) {\\n    return dfs(root, 0, sum);\\n};\\n\\nvar dfs = function(curr, currentSum, targetSum) {\\n    if (!curr) {\\n        return false;\\n    }\\n\\n    currentSum += curr.val;\\n    \\n    if (curr.left === null && curr.right === null) {\\n        return currentSum === targetSum;\\n    }\\n    \\n    return dfs(curr.left, currentSum, targetSum) || dfs(curr.right, currentSum, targetSum);\\n}\\n```\\n\\nRuntime: 56 ms, faster than 98.32% of JavaScript online submissions for Path Sum.\\nMemory Usage: 37.1 MB, less than 100.00% of JavaScript online submissions for Path Sum.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar hasPathSum = function(root, sum) {\\n    return dfs(root, 0, sum);\\n};\\n\\nvar dfs = function(curr, currentSum, targetSum) {\\n    if (!curr) {\\n        return false;\\n    }\\n\\n    currentSum += curr.val;\\n    \\n    if (curr.left === null && curr.right === null) {\\n        return currentSum === targetSum;\\n    }\\n    \\n    return dfs(curr.left, currentSum, targetSum) || dfs(curr.right, currentSum, targetSum);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 36531,
                "title": "share-my-3-lines-c-solution",
                "content": "    /**\\n     * Definition for a binary tree node.\\n     * struct TreeNode {\\n     *     int val;\\n     *     TreeNode *left;\\n     *     TreeNode *right;\\n     *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n     * };\\n     */\\n    class Solution {\\n    public:\\n        bool hasPathSum(TreeNode* root, int sum) {\\n            if(!root) return false;\\n            if((root -> val == sum) && ((!root -> left) && (!root -> right))) return true;\\n            return hasPathSum(root -> left, sum - root -> val) || hasPathSum(root -> right, sum - root -> val);\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        bool hasPathSum(TreeNode* root, int sum) {\\n            if(!root) return false;\\n            if((root -> val == sum) && ((!root -> left) && (!root -> right))) return true;\\n            return hasPathSum(root -> left, sum - root -> val) || hasPathSum(root -> right, sum - root -> val);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 36600,
                "title": "4-ms-c-solution-recursion",
                "content": "    bool hasPathSum(struct TreeNode* root, int sum) {\\n        if (!root) \\n            return false;\\n        if (!root->right && !root->left) \\n            return sum==root->val;\\n        return hasPathSum(root->left, sum-root->val)||hasPathSum(root->right, sum-root->val);\\n    }",
                "solutionTags": [],
                "code": "    bool hasPathSum(struct TreeNode* root, int sum) {\\n        if (!root) \\n            return false;\\n        if (!root->right && !root->left) \\n            return sum==root->val;\\n        return hasPathSum(root->left, sum-root->val)||hasPathSum(root->right, sum-root->val);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3198445,
                "title": "recursive-depth-first-traversal-with-sum-calculation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe need to traverse the tree in a depth-first manner, keeping track of the sum of values along the path from the root to the current node. When we reach a leaf node, we check if the sum is equal to the target sum. If yes, we return true, otherwise, we continue traversing the tree.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe define a function `hasPathSum` that takes the root node of the binary tree and the target sum as input, and returns a boolean value indicating whether there exists a root-to-leaf path with the given sum.\\n\\nThe first base case is when the root is None, which means we have reached the end of a branch without finding the target sum. In this case, we return False.\\n\\nThe second base case is when the root is a leaf node, which means we have reached the end of a root-to-leaf path. In this case, we check if the sum of values along the path is equal to the target sum. If yes, we return True, otherwise, we return False.\\n\\nIn the recursive case, we call the `hasPathSum` function on the left and right subtrees, with the target sum reduced by the value of the current node. If either of these recursive calls returns True, we return True, because there exists a root-to-leaf path with the target sum. Otherwise, we continue traversing the tree.\\n# Complexity\\n- Time complexity:$O(n)$, where n is the number of nodes in the binary tree. We need to visit every node once to check if it is a leaf node and calculate the sum along the path.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$ O(h)$, where h is the height of the binary tree. In the worst case, the recursion stack will have h frames, one for each level of the tree.\\n\\n\\n\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        if not root:\\n            return False\\n        if not root.left and not root.right: # leaf node\\n            return targetSum == root.val\\n        return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)\\n```",
                "solutionTags": [
                    "Python3",
                    "Tree",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        if not root:\\n            return False\\n        if not root.left and not root.right: # leaf node\\n            return targetSum == root.val\\n        return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2661481,
                "title": "c-2-different-approach-recursive-iterative",
                "content": "I came up with 2 different approaches for this problem. Please let me know if you have other ideas or if you have suggestions on how to improve one of the solutions. This problem many good solutions have been posted already, nevertheless I just had fun writing up my thoughts. So here we go. :)\\n\\n\\n### Approach 1: recursive\\n\\nWhen we hear \"binary tree\" the first reaction should almost always be \"recursion\", so here we go:\\n\\n```cpp\\n    static bool hasPathSum(const TreeNode* root, int targetSum) {\\n        if (!root) return false;\\n        \\n        if (!root->left && !root->right) return root->val == targetSum;\\n        \\n        return\\n            hasPathSum(root->left, targetSum - root->val) ||\\n            hasPathSum(root->right, targetSum - root->val);\\n    }\\n```\\n\\nPlease note that the code above is better in case there is actually a path, then the following code without \"short circute evaluation\":\\n\\n```cpp\\n        bool left = hasPathSum(root->left, targetSum - root->val);\\n        bool right = hasPathSum(root->right, targetSum - root->val);\\n        return left || right;\\n```\\n\\nThis could be fixed by adding an extra ```if (left) return true;```, but IMO the code above is just the cleanest and shortest solution here.\\n\\n**Complexity Analysis**\\n\\nLet $$n$$ be the number of nodes in the tree, and $$h$$ be the height of the tree, which can range from $$\\\\log n$$ if the tree is perfectly balanced to $$n$$ in the case the tree is basically a linked list.\\n\\n* Time complexity: $$O(n)$$ worst case we need to visit all the nodes.\\n* Space complexity: $$O(h)$$ we need that for the recursion stack.\\n\\n### Approach 2: iterative\\n\\nThe iterative version is straight forward as well if we use a ```stack<pair<TreeNode, int>>```.\\n\\n```cpp\\n    static bool hasPathSum(const TreeNode* root, int targetSum) {\\n        if (!root) return false;\\n\\n        stack<pair<const TreeNode*, int>> st;\\n        st.push({root, targetSum});\\n\\n        while (!empty(st)) {\\n            const auto [node, target] = st.top(); st.pop();\\n            if (!node->left && !node->right && node->val == target) return true;\\n            \\n            if (node->left) st.push({node->left, target - node->val});\\n            if (node->right) st.push({node->right, target - node->val});\\n        }\\n        \\n        return false;\\n    }\\n```\\n\\nWe could use a ```queue``` instead of a ```stack```, but using a BFS like aproach seems a bit pointless to me for this problem. Please let me know if there are good reasons to consider BFS as well.\\n\\nOne aspect I like about an iterative solution is that it seems easier to handle problematic input. Imagine the tree we get is actually not a tree put has a circle. The solutions above would run out of call stack space or allocate more and more memory and eventually run out of memory. For the iterative version we could easly add something like:\\n\\n\\n```cpp\\n   if (size(stack) > 10000) {\\n      LOG_ERROR(\"Tree too larger or input is not a tree.\");\\n      return false;\\n   }\\n```\\n\\nHow to best handle the error would be another questions. Do we want to use exceptions or do we want to use a different API to be able to pass the error to the caller is intersting questions to explore.\\n\\n\\n**Complexity Analysis**\\nThis is basically the same as for approach 1, but we are using an explict stack instead of the implict call stack, but it would grow at the same speed.\\n\\n\\n_As always: Feedback, questions, and comments are welcome. Leaving an upvote sparks  joy! :)_\\n\\n**p.s. Join us on the [LeetCode The Hard Way Discord Server](https://discord.gg/Nqm4jJcyBf)!**",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```cpp\\n    static bool hasPathSum(const TreeNode* root, int targetSum) {\\n        if (!root) return false;\\n        \\n        if (!root->left && !root->right) return root->val == targetSum;\\n        \\n        return\\n            hasPathSum(root->left, targetSum - root->val) ||\\n            hasPathSum(root->right, targetSum - root->val);\\n    }\\n```\n```cpp\\n        bool left = hasPathSum(root->left, targetSum - root->val);\\n        bool right = hasPathSum(root->right, targetSum - root->val);\\n        return left || right;\\n```\n```if (left) return true;```\n```stack<pair<TreeNode, int>>```\n```cpp\\n    static bool hasPathSum(const TreeNode* root, int targetSum) {\\n        if (!root) return false;\\n\\n        stack<pair<const TreeNode*, int>> st;\\n        st.push({root, targetSum});\\n\\n        while (!empty(st)) {\\n            const auto [node, target] = st.top(); st.pop();\\n            if (!node->left && !node->right && node->val == target) return true;\\n            \\n            if (node->left) st.push({node->left, target - node->val});\\n            if (node->right) st.push({node->right, target - node->val});\\n        }\\n        \\n        return false;\\n    }\\n```\n```queue```\n```stack```\n```cpp\\n   if (size(stack) > 10000) {\\n      LOG_ERROR(\"Tree too larger or input is not a tree.\");\\n      return false;\\n   }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2658315,
                "title": "java-recursive-solution",
                "content": "```\\nclass Solution {\\n    public boolean hasPathSum(TreeNode root, int targetSum) {\\n        if(root==null){\\n            return false;\\n        }\\n        \\n        if(root.left==null && root.right==null && targetSum==root.val){\\n            return true;\\n        }\\n        \\n        return hasPathSum(root.left,targetSum-root.val) || hasPathSum(root.right,targetSum-root.val);\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public boolean hasPathSum(TreeNode root, int targetSum) {\\n        if(root==null){\\n            return false;\\n        }\\n        \\n        if(root.left==null && root.right==null && targetSum==root.val){\\n            return true;\\n        }\\n        \\n        return hasPathSum(root.left,targetSum-root.val) || hasPathSum(root.right,targetSum-root.val);\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1654324,
                "title": "java-100-faster-recursion",
                "content": "## Please upvote if it helps! Thx :D\\n```\\npublic boolean hasPathSum(TreeNode root, int targetSum) {\\n\\tif (root == null) return false;\\n\\tif (root.left == null && root.right==null && root.val == targetSum) return true;\\n\\ttargetSum -= root.val;\\n\\treturn hasPathSum(root.left, targetSum) || hasPathSum(root.right, targetSum);\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\npublic boolean hasPathSum(TreeNode root, int targetSum) {\\n\\tif (root == null) return false;\\n\\tif (root.left == null && root.right==null && root.val == targetSum) return true;\\n\\ttargetSum -= root.val;\\n\\treturn hasPathSum(root.left, targetSum) || hasPathSum(root.right, targetSum);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 350383,
                "title": "python3-recursively-and-iteratively",
                "content": "recursively:\\n```\\nclass Solution:\\n    def hasPathSum(self, root: TreeNode, sum: int) -> bool:\\n        if not root:\\n            return False\\n        sum -= root.val\\n        if not root.left and not root.right:\\n            return sum == 0\\n        return self.hasPathSum(root.left,sum) or self.hasPathSum(root.right,sum)\\n```\\nIteratively:\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def hasPathSum(self, root: TreeNode, sum: int) -> bool:\\n        if not root:\\n            return False\\n        stack = [[root,sum-root.val]]\\n        while stack:\\n            cur,curr_sum = stack.pop()\\n            if not cur.left and not cur.right and curr_sum == 0:\\n                return True\\n            if cur.right:\\n                stack.append((cur.right,curr_sum-cur.right.val))\\n            if cur.left:\\n                stack.append((cur.left, curr_sum-cur.left.val))\\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def hasPathSum(self, root: TreeNode, sum: int) -> bool:\\n        if not root:\\n            return False\\n        sum -= root.val\\n        if not root.left and not root.right:\\n            return sum == 0\\n        return self.hasPathSum(root.left,sum) or self.hasPathSum(root.right,sum)\\n```\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def hasPathSum(self, root: TreeNode, sum: int) -> bool:\\n        if not root:\\n            return False\\n        stack = [[root,sum-root.val]]\\n        while stack:\\n            cur,curr_sum = stack.pop()\\n            if not cur.left and not cur.right and curr_sum == 0:\\n                return True\\n            if cur.right:\\n                stack.append((cur.right,curr_sum-cur.right.val))\\n            if cur.left:\\n                stack.append((cur.left, curr_sum-cur.left.val))\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3486462,
                "title": "solution",
                "content": "The function hasPathSum checks if there is a path from the root to the leaves in the binary tree defined by the root, whose sum of vertex values is equal to the given number targetSum.\\n\\nThe function first checks if the root is empty. If it is empty, the function returns false, since an empty tree has no path from the root to the leaves.\\n\\nThen it subtracts the value of the root from targetSum. It then checks to see if the current node is a leaf, that is, it has no child nodes. If so, the function returns the result of comparing targetSum to zero. If the sum in the current node goes to the right number and the current node is a leaf, then we have found the path from the root to the leaf with the right sum of values.\\n\\nIf the current node is not a leaf, the function calls itself recursively for the left and right subtree, passing targetSum minus the value of the current node as an argument. The function then returns the result of the logical AND of the recursive calls, since both subtrees must have a path from the root to the leaf with the desired sum in order for the whole tree to have that path.\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean hasPathSum(TreeNode root, int targetSum) {\\n        if (root == null) {\\n            return false;\\n        }\\n\\n        targetSum -= root.val;\\n\\n        if (root.left == null && root.right == null) {\\n            return targetSum == 0;\\n        }\\n\\n        return hasPathSum(root.left, targetSum) || hasPathSum(root.right, targetSum);        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "C#",
                    "Go"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean hasPathSum(TreeNode root, int targetSum) {\\n        if (root == null) {\\n            return false;\\n        }\\n\\n        targetSum -= root.val;\\n\\n        if (root.left == null && root.right == null) {\\n            return targetSum == 0;\\n        }\\n\\n        return hasPathSum(root.left, targetSum) || hasPathSum(root.right, targetSum);        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3212802,
                "title": "java-solution-0-ms-beats-100",
                "content": "# Java Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean hasPathSum(TreeNode root, int targetSum) {\\n        if (root == null) {\\n            return false;\\n        }\\n        if (root.val == targetSum && root.left == null && root.right == null) {\\n            return true;\\n        }\\n        return hasPathSum(root.left, targetSum - root.val) || hasPathSum(root.right, targetSum - root.val);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean hasPathSum(TreeNode root, int targetSum) {\\n        if (root == null) {\\n            return false;\\n        }\\n        if (root.val == targetSum && root.left == null && root.right == null) {\\n            return true;\\n        }\\n        return hasPathSum(root.left, targetSum - root.val) || hasPathSum(root.right, targetSum - root.val);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2658457,
                "title": "1-line-python",
                "content": "```\\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        return (root.val == targetSum) if (root and not root.left and not root.right) else (root and (self.hasPathSum(root.right, targetSum - root.val) or self.hasPathSum(root.left, targetSum - root.val)))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        return (root.val == targetSum) if (root and not root.left and not root.right) else (root and (self.hasPathSum(root.right, targetSum - root.val) or self.hasPathSum(root.left, targetSum - root.val)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1856379,
                "title": "simple-js-solution-w-comments",
                "content": "```\\nconst hasPathSum = (root, targetSum) => {\\n\\tif (!root) return false;\\n\\n\\tlet output = false;\\n\\tconst traverse = (root, sum = 0) => {\\n\\t\\t// if targetSum exist at end of path, set output to TRUE\\n\\t\\tif (!root.left && !root.right) {\\n\\t\\t\\tif (targetSum === sum + root.val) output = true;\\n\\t\\t}\\n\\n\\t\\t// traverse left/right and keep adding value of nodes in current path\\n\\t\\tif (root.left) traverse(root.left, sum + root.val);\\n\\t\\tif (root.right) traverse(root.right, sum + root.val);\\n\\t};\\n\\n\\ttraverse(root);\\n\\treturn output;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\nconst hasPathSum = (root, targetSum) => {\\n\\tif (!root) return false;\\n\\n\\tlet output = false;\\n\\tconst traverse = (root, sum = 0) => {\\n\\t\\t// if targetSum exist at end of path, set output to TRUE\\n\\t\\tif (!root.left && !root.right) {\\n\\t\\t\\tif (targetSum === sum + root.val) output = true;\\n\\t\\t}\\n\\n\\t\\t// traverse left/right and keep adding value of nodes in current path\\n\\t\\tif (root.left) traverse(root.left, sum + root.val);\\n\\t\\tif (root.right) traverse(root.right, sum + root.val);\\n\\t};\\n\\n\\ttraverse(root);\\n\\treturn output;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 36391,
                "title": "java-iterative-solution-with-one-stack",
                "content": "```\\npublic boolean hasPathSum(TreeNode root, int sum) {\\n        Stack<TreeNode> visitedNodes = new Stack<>();\\n        TreeNode prev = null;\\n       \\n        while(root!=null || !visitedNodes.isEmpty()){\\n            while(root!=null){\\n                visitedNodes.push(root);\\n                sum -= root.val;\\n                prev = root;\\n                root = root.left;\\n            }\\n            root = visitedNodes.peek();\\n            if(root.left==null && root.right == null && sum==0) return true;\\n            if(root.right != null && root.right != prev){\\n                root = root.right;\\n            }else{\\n                sum += root.val;\\n                prev = visitedNodes.pop();\\n                root = null;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean hasPathSum(TreeNode root, int sum) {\\n        Stack<TreeNode> visitedNodes = new Stack<>();\\n        TreeNode prev = null;\\n       \\n        while(root!=null || !visitedNodes.isEmpty()){\\n            while(root!=null){\\n                visitedNodes.push(root);\\n                sum -= root.val;\\n                prev = root;\\n                root = root.left;\\n            }\\n            root = visitedNodes.peek();\\n            if(root.left==null && root.right == null && sum==0) return true;\\n            if(root.right != null && root.right != prev){\\n                root = root.right;\\n            }else{\\n                sum += root.val;\\n                prev = visitedNodes.pop();\\n                root = null;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 36543,
                "title": "share-my-easy-and-clean-recursion-java-solution-with-explanation",
                "content": "    public class Solution {\\n        public boolean hasPathSum(TreeNode root, int sum) {\\n            \\n            // check if root is null\\n            if(root == null) return false;\\n            \\n            // if the current node is not a leaf node, do recursion.\\n            if(root.left != null || root.right != null) \\n                return hasPathSum(root.left, sum - root.val) || \\n                    hasPathSum(root.right, sum - root.val);\\n            \\n            // now the current node is a leaf node\\n            return sum - root.val == 0;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public boolean hasPathSum(TreeNode root, int sum) {\\n            \\n            // check if root is null\\n            if(root == null) return false;\\n            \\n            // if the current node is not a leaf node, do recursion.\\n            if(root.left != null || root.right != null) \\n                return hasPathSum(root.left, sum - root.val) || \\n                    hasPathSum(root.right, sum - root.val);\\n            \\n            // now the current node is a leaf node\\n            return sum - root.val == 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 36620,
                "title": "java-solution-shortest",
                "content": "    public boolean hasPathSum(TreeNode root, int sum) {\\n        if (root == null) {\\n            return false;\\n        }\\n\\n        if (sum - root.val == 0 && root.left == null && root.right == null) {\\n            return true;\\n        }\\n\\n        return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);\\n    }",
                "solutionTags": [],
                "code": "    public boolean hasPathSum(TreeNode root, int sum) {\\n        if (root == null) {\\n            return false;\\n        }\\n\\n        if (sum - root.val == 0 && root.left == null && root.right == null) {\\n            return true;\\n        }\\n\\n        return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3336702,
                "title": "python3-deque-beat-98-10-34ms",
                "content": "\\n\\n# Complexity\\n- Time complexity:  O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:  O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        if not root:\\n            return False\\n        queue = collections.deque([(root, root.val)])\\n        while queue:\\n            node, val = queue.popleft()\\n            if not node.left and not node.right:\\n                if val == targetSum: return True\\n                else: continue\\n            if node.left:\\n                queue.append((node.left, val + node.left.val))   \\n            if node.right:\\n                queue.append((node.right, val + node.right.val))   \\n        return False\\n```",
                "solutionTags": [
                    "Python3",
                    "Tree",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        if not root:\\n            return False\\n        queue = collections.deque([(root, root.val)])\\n        while queue:\\n            node, val = queue.popleft()\\n            if not node.left and not node.right:\\n                if val == targetSum: return True\\n                else: continue\\n            if node.left:\\n                queue.append((node.left, val + node.left.val))   \\n            if node.right:\\n                queue.append((node.right, val + node.right.val))   \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2902210,
                "title": "javascript-easy-code-thumbs-up-if-you-like",
                "content": "\\n# Code\\n```\\n\\nvar hasPathSum = function (root, targetSum) {\\n    if (!root)\\n        return false\\n    if (root.val === targetSum && (!root.left && !root.right))\\n        return true\\n\\n    return hasPathSum(root.left, targetSum - root.val) || hasPathSum(root.right, targetSum - root.val)\\n\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nvar hasPathSum = function (root, targetSum) {\\n    if (!root)\\n        return false\\n    if (root.val === targetSum && (!root.left && !root.right))\\n        return true\\n\\n    return hasPathSum(root.left, targetSum - root.val) || hasPathSum(root.right, targetSum - root.val)\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2291836,
                "title": "three-solution-to-come-up-on-iterview-easy-to-understand",
                "content": "Hey there! This problem gives us to practice in use of different binary tree traversals. If you look closer to the idea of the problem you will come up with the following: DFS (**preorder**) with recursion, DFS iterative version and BFS (or level traversal). Go ahead and get to know all of them.\\n\\n___\\n***DFS recursion*** [0ms 44.2MB](https://leetcode.com/submissions/detail/748771650/)\\nThe simplies (it\\'s seems to me) solution based on **preorder** binary tree traversal. Here we will visit all paths to leaf (node with no children) till we find desired path or visit all:\\n\\n```\\npublic boolean hasPathSum(TreeNode root, int targetSum) {\\n        if (root == null) return false;\\n        return hasPathSum(root, targetSum, 0);\\n    }\\n    \\n    private boolean hasPathSum(TreeNode root, int targetSum, int currSum) {\\n        if (root == null)\\n            return false;\\n        currSum += root.val;\\n        if (currSum == targetSum && root.left == null && root.right == null)\\n            return true;\\n        if (hasPathSum(root.left, targetSum, currSum) || hasPathSum(root.right, targetSum, currSum))\\n            return true;\\n        return false;\\n    }\\n```\\nTime complexity: O(2^n) - where 2^n is a size of a binary tree\\nSpace complexity: O(n), where n is a depth of this tree\\n\\nSimple, readable and neet. But recursion is sign to find iterative method.\\n___\\n***DFS iterative*** [4ms 44MB](https://leetcode.com/submissions/detail/748798973/)\\nThis is an alternative to the previous method because we want to avoid recursion as much as possible. Here we use the same principles (e.g. Stack) as in dfs traversal of binary tree. Note here we have two stacks - one will indicate root - to - this - node sum. If you know how to make it one stack in Java - please let me know ;]\\n\\n```\\npublic boolean hasPathSum(TreeNode root, int targetSum) {\\n        if (root == null) return false;\\n        Stack<TreeNode> stack = new Stack<>();\\n        Stack<Integer> sum = new Stack<>();\\n        stack.push(root);\\n        sum.push(root.val);\\n        while (!stack.isEmpty()) {\\n            TreeNode node = stack.pop();\\n            int currSum = sum.pop();\\n            if (currSum == targetSum && node.left == null && node.right == null)\\n                return true;\\n            \\n            if (node.right != null) {\\n                stack.push(node.right);\\n                sum.push(node.right.val + currSum);\\n            }\\n            if (node.left != null) {\\n                stack.push(node.left);\\n                sum.push(node.left.val + currSum);\\n            }\\n        }\\n        return false;\\n    }\\n```\\nTime and Space complexity are identical to the first approach.- But it\\'s generally better the previous because recursion may cause stackoverflow\\n\\n____\\n***BFS*** [2ms 44.6MB](https://leetcode.com/submissions/detail/748810508/)\\nThe last approach is so called level traversal - that is, we initially visit one level of the tree, then one that below and so on. We use the standart approach for BFS with queue. Note the same issue with the second queue for sum.\\nIt is so much a like previous in implemention, but the data structure dictates an order - stack makes traversal go in depth, when queue makes us check this level first.\\n\\n```\\npublic boolean hasPathSum(TreeNode root, int targetSum) {\\n        if (root == null) return false;\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        Queue<Integer> sum = new LinkedList<>();\\n        queue.add(root);\\n        sum.add(root.val);\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            for (int i = 0; i < size; i++) {\\n                TreeNode node = queue.remove();\\n                int currSum = sum.remove();\\n                if (currSum == targetSum && node.left == null && node.right == null) {\\n                    return true;\\n                }\\n                \\n                \\n               if (node.left != null) {\\n                    queue.add(node.left);\\n                    sum.add(node.left.val + currSum);\\n                }\\n                if (node.right != null) {\\n                    queue.add(node.right);\\n                    sum.add(node.right.val + currSum);\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n```\\nAgain, time and space complexity stay the same.\\n___\\nIn conclusion, benchmarks shows recursive is the best.and BFS is best among iterative version. Still you need to look in the root of the problem and choose the most preferable ( but here I belive it doesn\\'t matter much )\\n",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\npublic boolean hasPathSum(TreeNode root, int targetSum) {\\n        if (root == null) return false;\\n        return hasPathSum(root, targetSum, 0);\\n    }\\n    \\n    private boolean hasPathSum(TreeNode root, int targetSum, int currSum) {\\n        if (root == null)\\n            return false;\\n        currSum += root.val;\\n        if (currSum == targetSum && root.left == null && root.right == null)\\n            return true;\\n        if (hasPathSum(root.left, targetSum, currSum) || hasPathSum(root.right, targetSum, currSum))\\n            return true;\\n        return false;\\n    }\\n```\n```\\npublic boolean hasPathSum(TreeNode root, int targetSum) {\\n        if (root == null) return false;\\n        Stack<TreeNode> stack = new Stack<>();\\n        Stack<Integer> sum = new Stack<>();\\n        stack.push(root);\\n        sum.push(root.val);\\n        while (!stack.isEmpty()) {\\n            TreeNode node = stack.pop();\\n            int currSum = sum.pop();\\n            if (currSum == targetSum && node.left == null && node.right == null)\\n                return true;\\n            \\n            if (node.right != null) {\\n                stack.push(node.right);\\n                sum.push(node.right.val + currSum);\\n            }\\n            if (node.left != null) {\\n                stack.push(node.left);\\n                sum.push(node.left.val + currSum);\\n            }\\n        }\\n        return false;\\n    }\\n```\n```\\npublic boolean hasPathSum(TreeNode root, int targetSum) {\\n        if (root == null) return false;\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        Queue<Integer> sum = new LinkedList<>();\\n        queue.add(root);\\n        sum.add(root.val);\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            for (int i = 0; i < size; i++) {\\n                TreeNode node = queue.remove();\\n                int currSum = sum.remove();\\n                if (currSum == targetSum && node.left == null && node.right == null) {\\n                    return true;\\n                }\\n                \\n                \\n               if (node.left != null) {\\n                    queue.add(node.left);\\n                    sum.add(node.left.val + currSum);\\n                }\\n                if (node.right != null) {\\n                    queue.add(node.right);\\n                    sum.add(node.right.val + currSum);\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 690667,
                "title": "c-100-time-one-line-recursive-solution",
                "content": "The base case is when the `root->val == sum` and the node is a leaf (ie: both `!root-left` and `!root->right` are true); if not, we keep recursing with decreased values of `sum`:\\n\\nNotice that since the nodes can also have negative values, there is no way to know in advance when you have summed \"too much\" and thus you should stop exploring down.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    bool hasPathSum(TreeNode* root, int sum) {\\n        return root && (!root->left && !root->right && root->val == sum || hasPathSum(root->left, sum - root->val) || hasPathSum(root->right, sum - root->val));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    bool hasPathSum(TreeNode* root, int sum) {\\n        return root && (!root->left && !root->right && root->val == sum || hasPathSum(root->left, sum - root->val) || hasPathSum(root->right, sum - root->val));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 523142,
                "title": "javascript",
                "content": "```\\nvar hasPathSum = function(root, sum) {\\n    if(!root) {\\n        return false;\\n    }\\n    if(!root.left && !root.right) {\\n        return root.val == sum ? true : false;\\n    }\\n    let remain = sum - root.val\\n    return hasPathSum(root.left, remain) || hasPathSum(root.right, remain)\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar hasPathSum = function(root, sum) {\\n    if(!root) {\\n        return false;\\n    }\\n    if(!root.left && !root.right) {\\n        return root.val == sum ? true : false;\\n    }\\n    let remain = sum - root.val\\n    return hasPathSum(root.left, remain) || hasPathSum(root.right, remain)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 519347,
                "title": "go-4ms",
                "content": "```\\nfunc hasPathSum(root *TreeNode, sum int) bool {\\n    if root == nil {\\n        return false\\n    }\\n    if root.Left == nil && root.Right == nil {\\n        return sum == root.Val\\n    }\\n    return hasPathSum(root.Left, sum - root.Val) || hasPathSum(root.Right, sum - root.Val)\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc hasPathSum(root *TreeNode, sum int) bool {\\n    if root == nil {\\n        return false\\n    }\\n    if root.Left == nil && root.Right == nil {\\n        return sum == root.Val\\n    }\\n    return hasPathSum(root.Left, sum - root.Val) || hasPathSum(root.Right, sum - root.Val)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 410446,
                "title": "simple-python-solution-recursive-and-iterative-using-dfs",
                "content": "**Recursive**\\n\\n```\\nclass Solution:\\n    def hasPathSum(self, root: TreeNode, sum: int) -> bool:\\n        if not root:\\n            return False\\n        \\n        sum = sum - root.val\\n        \\n        if not root.left and not root.right: #leaf node\\n            return sum == 0\\n        else:\\n            return self.hasPathSum(root.left, sum) or self.hasPathSum(root.right, sum)\\n```\\n\\t\\t\\t\\n**Iterative**\\n\\n```      \\nclass Solution:\\n    def hasPathSum(self, root: TreeNode, sum: int) -> bool:\\n        \\n        if not root:\\n            return False\\n        \\n        stack = []\\n        \\n        stack.append((root, sum - root.val))\\n        \\n        while stack:\\n            node, sum = stack.pop()\\n            if not node.left and not node.right and sum == 0:\\n                return True\\n            if node.left:\\n                stack.append((node.left, sum - node.left.val))\\n            if node.right:\\n                stack.append((node.right, sum - node.right.val))       \\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Tree",
                    "Depth-First Search",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def hasPathSum(self, root: TreeNode, sum: int) -> bool:\\n        if not root:\\n            return False\\n        \\n        sum = sum - root.val\\n        \\n        if not root.left and not root.right: #leaf node\\n            return sum == 0\\n        else:\\n            return self.hasPathSum(root.left, sum) or self.hasPathSum(root.right, sum)\\n```\n```      \\nclass Solution:\\n    def hasPathSum(self, root: TreeNode, sum: int) -> bool:\\n        \\n        if not root:\\n            return False\\n        \\n        stack = []\\n        \\n        stack.append((root, sum - root.val))\\n        \\n        while stack:\\n            node, sum = stack.pop()\\n            if not node.left and not node.right and sum == 0:\\n                return True\\n            if node.left:\\n                stack.append((node.left, sum - node.left.val))\\n            if node.right:\\n                stack.append((node.right, sum - node.right.val))       \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 388724,
                "title": "javascript-easy-top-bottom-approach",
                "content": "```\\nvar hasPathSum = function(root, sum) {\\n    if (!root) return false;\\n    let queue = [root];\\n    while (queue.length > 0) {\\n        let cur = queue.shift();\\n        if (!cur.left && !cur.right && cur.val == sum) {\\n            return true;\\n        }\\n        if (cur.left) {\\n            cur.left.val += cur.val;\\n            queue.push (cur.left);\\n        }\\n        if (cur.right) {\\n            cur.right.val += cur.val;\\n            queue.push (cur.right);\\n        }\\n    }\\n    return false;\\n};\\n\\nfunction TreeNode (val) {\\n    this.val = val;\\n    this.left = this.right = null;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar hasPathSum = function(root, sum) {\\n    if (!root) return false;\\n    let queue = [root];\\n    while (queue.length > 0) {\\n        let cur = queue.shift();\\n        if (!cur.left && !cur.right && cur.val == sum) {\\n            return true;\\n        }\\n        if (cur.left) {\\n            cur.left.val += cur.val;\\n            queue.push (cur.left);\\n        }\\n        if (cur.right) {\\n            cur.right.val += cur.val;\\n            queue.push (cur.right);\\n        }\\n    }\\n    return false;\\n};\\n\\nfunction TreeNode (val) {\\n    this.val = val;\\n    this.left = this.right = null;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 36484,
                "title": "simple-c-solution",
                "content": "    class Solution {\\n    public:\\n        bool hasPathSum(TreeNode* root, int sum) {\\n            if(root == NULL){\\n                return false;\\n            }\\n            int newsum = sum - root->val;\\n            if(root->left == NULL && root->right == NULL){\\n                return newsum == 0;\\n            }\\n            return hasPathSum(root->left, newsum) || hasPathSum(root->right, newsum);\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        bool hasPathSum(TreeNode* root, int sum) {\\n            if(root == NULL){\\n                return false;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 36536,
                "title": "my-java-solution-using-recursive",
                "content": "    \\n    public boolean hasPathSum(TreeNode root, int sum) {\\n        if (root == null) {\\n            return false;\\n        } else {\\n            if (root.left == null && root.right == null) {\\n                return sum == root.val;\\n            } else {\\n                int subSum = sum - root.val;\\n                return hasPathSum(root.left, subSum) || hasPathSum(root.right, subSum);\\n            }\\n        }\\n    }",
                "solutionTags": [],
                "code": "    \\n    public boolean hasPathSum(TreeNode root, int sum) {\\n        if (root == null) {\\n            return false;\\n        } else {\\n            if (root.left == null && root.right == null) {\\n                return sum == root.val;\\n            } else {\\n                int subSum = sum - root.val;\\n                return hasPathSum(root.left, subSum) || hasPathSum(root.right, subSum);\\n            }\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 36567,
                "title": "12ms-c-solution",
                "content": "    class Solution {\\n    public:\\n        bool hasPathSum(TreeNode* root, int sum) {\\n            if(root == NULL) return false;\\n            sum -= root->val;\\n            return sum == 0 && root->left == NULL && root->right == NULL ? true : hasPathSum(root->left, sum) | hasPathSum(root->right, sum);\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        bool hasPathSum(TreeNode* root, int sum) {\\n            if(root == NULL) return false;\\n            sum -= root->val;\\n            return sum == 0 && root->left == NULL && root->right == NULL ? true : hasPathSum(root->left, sum) | hasPathSum(root->right, sum);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 36642,
                "title": "just-another-java-solution-recursive-simple-but-can-be-simpler",
                "content": "    /**\\n     * Definition for binary tree\\n     * public class TreeNode {\\n     *     int val;\\n     *     TreeNode left;\\n     *     TreeNode right;\\n     *     TreeNode(int x) { val = x; }\\n     * }\\n     */\\n    public class Solution {\\n        public boolean hasPathSum(TreeNode root, int sum) {\\n            //start it off with initial sum of 0, pass in root.\\n            return helper(root,0,sum);\\n        }\\n        \\n      public boolean helper(TreeNode node,int currSum,int wanted){\\n          if(node==null)\\n            return false;\\n            \\n          //node is a leaf\\n          if(node.left==null && node.right==null){\\n              if((node.val+currSum) == wanted) //check if it sumeed up.\\n                  return true;\\n              return false;\\n          }\\n          \\n          //not a leaf, so recursively try again but with child nodes, pass in current sum + val of this node.\\n          return (helper(node.left,currSum+node.val,wanted) || helper(node.right,currSum+node.val,wanted));\\n          \\n      }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public boolean hasPathSum(TreeNode root, int sum) {\\n            //start it off with initial sum of 0, pass in root.\\n            return helper(root,0,sum);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2231004,
                "title": "python-dfs-binary-tree-leaves-find-all-paths",
                "content": "It is intuitive to find all the possible paths from roots to leaves and sum them and check with the target sum.\\n```\\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        res = []\\n        if not root:\\n            return False\\n        def dfs(r,path):\\n            if not r.left and not r.right:\\n                path+=[r.val]\\n                res.append(path)\\n                return\\n            if r.left:\\n                dfs(r.left,path+[r.val])\\n            if r.right:\\n                dfs(r.right,path+[r.val])\\n            return \\n        dfs(root,[])\\n        # print(res)\\n        for arr in res:\\n            if sum(arr)==targetSum:\\n                return True\\n        return False\\n```\\n```\\nUPVOTE IF YOU LIKED IT :)\\n```\\nDo Let me know how we can optimise this further.\\nOne way i know that instead of keeping path, we can keep the sum itself and then return true if found targetSum.\\nBut for me it does not change time complexity much. \\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        res = []\\n        if not root:\\n            return False\\n        def dfs(r,path):\\n            if not r.left and not r.right:\\n                path+=[r.val]\\n                res.append(path)\\n                return\\n            if r.left:\\n                dfs(r.left,path+[r.val])\\n            if r.right:\\n                dfs(r.right,path+[r.val])\\n            return \\n        dfs(root,[])\\n        # print(res)\\n        for arr in res:\\n            if sum(arr)==targetSum:\\n                return True\\n        return False\\n```\n```\\nUPVOTE IF YOU LIKED IT :)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2040038,
                "title": "o-n-time-beats-99-97-memory-speed-0ms-may-2022",
                "content": "```\\n```\\n\\n(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful, ***please upvote*** this post.)\\n***Take care brother, peace, love!***\\n\\n```\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 38.2MB*** (beats 92.04% / 24.00%).\\n* ***Java***\\n```\\npublic boolean hasPathSum(TreeNode root, int sum) {\\n    // iteration method\\n    if (root == null) {return false;}\\n    Stack<TreeNode> path = new Stack<>();\\n    Stack<Integer> sub = new Stack<>();\\n    path.push(root);\\n    sub.push(root.val);\\n    while (!path.isEmpty()) {\\n        TreeNode temp = path.pop();\\n        int tempVal = sub.pop();\\n        if (temp.left == null && temp.right == null) {if (tempVal == sum) return true;}\\n        else {\\n            if (temp.left != null) {\\n                path.push(temp.left);\\n                sub.push(temp.left.val + tempVal);\\n            }\\n            if (temp.right != null) {\\n                path.push(temp.right);\\n                sub.push(temp.right.val + tempVal);\\n            }\\n        }\\n    }\\n    return false;\\n}\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 7.0MB*** (beats 100.00% / 100.00%).\\n* ***C++***\\n```\\nclass Solution {\\npublic:\\n    bool hasPathSum(TreeNode* root, int sum) {\\n        if(!root)return false;                                         //Terminating Condition\\n        sum=sum-root->val;                                             //Body\\n        if(sum==0&&!root->left&&!root->right)return true;              //body\\n        return hasPathSum(root->left,sum)||hasPathSum(root->right,sum);//Propagation\\n    }\\n};\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\n\\nThe best result for the code below is ***26ms / 12.2MB*** (beats 95.42% / 82.32%).\\n* ***Python***\\n```\\ndef hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n\\n        def inorder(root, path_sum):\\n            if not root:\\n                return False\\n            \\n            path_sum+=root.val\\n            \\n            if not root.left and not root.right:\\n                return path_sum==targetSum\\n                \\n            return inorder(root.left, path_sum) or inorder(root.right, path_sum)\\n             \\n        return inorder(root, 0)\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***51ms / 34.2MB*** (beats 100.00% / 84.12%).\\n* ***JavaScript***\\n```\\nvar hasPathSum = function(root, targetSum) {\\n    return dfs(root, targetSum);\\n    // T.C: O(N)\\n    // S.C: O(H)\\n};\\n\\nconst dfs = (root, target) => {\\n    if (!root) {\\n        return false;\\n    }\\n    if (!root.left && !root.right) {\\n        return target - root.val === 0;\\n    }\\n    return dfs(root.left, target - root.val) || \\n        dfs(root.right, target - root.val);\\n}\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***68ms / 44.2MB*** (beats 100.00% / 45.25%).\\n* ***Kotlin***\\n```\\nclass Solution {\\n    fun hasPathSum(root: TreeNode?, sum: Int): Boolean {\\n        if (root==null){\\n            return false\\n        }\\n        else if (root.left==null && root.right==null && root!!.`val`==sum){\\n            return true\\n        }\\n        return hasPathSum(root.left, sum-root!!.`val`) || hasPathSum(root.right, sum-root!!.`val`)\\n    }\\n}\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***12ms / 32.2MB*** (beats 95% / 84%).\\n* ***Swift***\\n```\\nclass Solution {\\n    func hasPathSum(_ root: TreeNode?, _ targetSum: Int) -> Bool {\\n        guard let root = root else {\\n            return false\\n        }\\n        \\n        if root.left == nil && root.right == nil {\\n            return root.val == targetSum\\n        }\\n        \\n        return hasPathSum(root.left, targetSum - root.val) || hasPathSum(root.right, targetSum - root.val)\\n    }\\n}\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\n***\"Open your eyes. Expect us.\" - \\uD835\\uDCD0\\uD835\\uDCF7\\uD835\\uDCF8\\uD835\\uDCF7\\uD835\\uDD02\\uD835\\uDCF6\\uD835\\uDCF8\\uD835\\uDCFE\\uD835\\uDCFC***\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript",
                    "Swift",
                    "Kotlin",
                    "PHP",
                    "Recursion"
                ],
                "code": "```\\n```\n```\\n```\n```\\n```\n```\\n```\n```\\npublic boolean hasPathSum(TreeNode root, int sum) {\\n    // iteration method\\n    if (root == null) {return false;}\\n    Stack<TreeNode> path = new Stack<>();\\n    Stack<Integer> sub = new Stack<>();\\n    path.push(root);\\n    sub.push(root.val);\\n    while (!path.isEmpty()) {\\n        TreeNode temp = path.pop();\\n        int tempVal = sub.pop();\\n        if (temp.left == null && temp.right == null) {if (tempVal == sum) return true;}\\n        else {\\n            if (temp.left != null) {\\n                path.push(temp.left);\\n                sub.push(temp.left.val + tempVal);\\n            }\\n            if (temp.right != null) {\\n                path.push(temp.right);\\n                sub.push(temp.right.val + tempVal);\\n            }\\n        }\\n    }\\n    return false;\\n}\\n```\n```\\n```\n```\\n```\n```\\nclass Solution {\\npublic:\\n    bool hasPathSum(TreeNode* root, int sum) {\\n        if(!root)return false;                                         //Terminating Condition\\n        sum=sum-root->val;                                             //Body\\n        if(sum==0&&!root->left&&!root->right)return true;              //body\\n        return hasPathSum(root->left,sum)||hasPathSum(root->right,sum);//Propagation\\n    }\\n};\\n```\n```\\n```\n```\\n```\n```\\ndef hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n\\n        def inorder(root, path_sum):\\n            if not root:\\n                return False\\n            \\n            path_sum+=root.val\\n            \\n            if not root.left and not root.right:\\n                return path_sum==targetSum\\n                \\n            return inorder(root.left, path_sum) or inorder(root.right, path_sum)\\n             \\n        return inorder(root, 0)\\n```\n```\\n```\n```\\n```\n```\\nvar hasPathSum = function(root, targetSum) {\\n    return dfs(root, targetSum);\\n    // T.C: O(N)\\n    // S.C: O(H)\\n};\\n\\nconst dfs = (root, target) => {\\n    if (!root) {\\n        return false;\\n    }\\n    if (!root.left && !root.right) {\\n        return target - root.val === 0;\\n    }\\n    return dfs(root.left, target - root.val) || \\n        dfs(root.right, target - root.val);\\n}\\n```\n```\\n```\n```\\n```\n```\\nclass Solution {\\n    fun hasPathSum(root: TreeNode?, sum: Int): Boolean {\\n        if (root==null){\\n            return false\\n        }\\n        else if (root.left==null && root.right==null && root!!.`val`==sum){\\n            return true\\n        }\\n        return hasPathSum(root.left, sum-root!!.`val`) || hasPathSum(root.right, sum-root!!.`val`)\\n    }\\n}\\n```\n```\\n```\n```\\n```\n```\\nclass Solution {\\n    func hasPathSum(_ root: TreeNode?, _ targetSum: Int) -> Bool {\\n        guard let root = root else {\\n            return false\\n        }\\n        \\n        if root.left == nil && root.right == nil {\\n            return root.val == targetSum\\n        }\\n        \\n        return hasPathSum(root.left, targetSum - root.val) || hasPathSum(root.right, targetSum - root.val)\\n    }\\n}\\n```\n```\\n```\n```\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1567369,
                "title": "javascript-easy-to-understand-dfs",
                "content": "Since we need to sum the values from root to leaf, it\\'s straightforward to think about DFS. So, the process could be:\\n1. Traverse the tree via DFS\\n2. Check whether current node is leaf\\n\\t- check the target value\\n\\t- continue recursion\\n\\nHere\\'s the code:\\n\\n```js\\nconst hasPathSum = (node, target) => {\\n  if (!node) return false;\\n  if (!node.left && !node.right) return target === node.val;\\n  return (\\n    hasPathSum(node.left, target - node.val) ||\\n    hasPathSum(node.right, target - node.val)\\n  );\\n};\\n```\\n\\nEven, we could make it in 1-line:\\n\\n```js\\nconst hasPathSum = (node, target) => !!node && (!node.left && !node.right ? target === node.val : hasPathSum(node.left, target - node.val) || hasPathSum(node.right, target - node.val));\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nconst hasPathSum = (node, target) => {\\n  if (!node) return false;\\n  if (!node.left && !node.right) return target === node.val;\\n  return (\\n    hasPathSum(node.left, target - node.val) ||\\n    hasPathSum(node.right, target - node.val)\\n  );\\n};\\n```\n```js\\nconst hasPathSum = (node, target) => !!node && (!node.left && !node.right ? target === node.val : hasPathSum(node.left, target - node.val) || hasPathSum(node.right, target - node.val));\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1517970,
                "title": "two-approaches-dfs-very-simple-c",
                "content": "\\nImplementation\\n\\n**1st Approach using helper(findPath) method\\nTime Complexity = O(N), Space Complexity = O(H) where H is the height of the Binary Tree**\\n\\n```\\nclass Solution {\\npublic:\\n    bool findPath(TreeNode* root, int targetSum, int sum){\\n        if(root == NULL) return false;\\n        sum += root->val;\\n        \\n        if(root->left == NULL && root->right == NULL){\\n            return (sum == targetSum) ? true : false;\\n        }\\n        return (findPath(root->left, targetSum, sum) || findPath(root->right, targetSum, sum));        \\n    }\\n    \\n    bool hasPathSum(TreeNode* root, int targetSum) {        \\n        return findPath(root, targetSum, 0);\\n    }\\n};\\n```\\n\\n**2nd Approach without using any helper method\\nTime Complexity = O(N), Space Complexity = O(H) where H is the height of the Binary Tree**\\n\\n```\\nclass Solution {\\npublic:\\n    bool hasPathSum(TreeNode* root, int targetSum) {        \\n        if(root == NULL) return false;\\n        targetSum -= root->val;\\n        \\n        if(root->left == NULL && root->right == NULL){\\n            return (targetSum == 0) ? true : false;\\n        }\\n        return (hasPathSum(root->left, targetSum) || hasPathSum(root->right, targetSum));        \\n    }\\n};\\n```\\n\\nIf you find any issue in understanding the solution then comment below, will try to help you.\\nIf you found my solution useful.\\nSo **please do upvote and encourage me** to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding **:)**",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool findPath(TreeNode* root, int targetSum, int sum){\\n        if(root == NULL) return false;\\n        sum += root->val;\\n        \\n        if(root->left == NULL && root->right == NULL){\\n            return (sum == targetSum) ? true : false;\\n        }\\n        return (findPath(root->left, targetSum, sum) || findPath(root->right, targetSum, sum));        \\n    }\\n    \\n    bool hasPathSum(TreeNode* root, int targetSum) {        \\n        return findPath(root, targetSum, 0);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool hasPathSum(TreeNode* root, int targetSum) {        \\n        if(root == NULL) return false;\\n        targetSum -= root->val;\\n        \\n        if(root->left == NULL && root->right == NULL){\\n            return (targetSum == 0) ? true : false;\\n        }\\n        return (hasPathSum(root->left, targetSum) || hasPathSum(root->right, targetSum));        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 746228,
                "title": "java-dfs-runtime-0-ms-faster-than-100-00-memory-usage-39-2-mb-less-than-73-39",
                "content": "```\\n// Runtime: 0 ms, faster than 100.00% of Java online submissions for Path Sum.\\n// Memory Usage: 39.2 MB, less than 73.39% of Java online submissions for Path Sum.\\nclass Solution {\\n    private boolean answer = false;\\n    public boolean hasPathSum(TreeNode root, int sum) {\\n        if(root==null) return false;\\n        dfs(root,sum,0);\\n        return answer;    \\n    }\\n    \\n    private void dfs(TreeNode node, int sum, int currentSum){\\n        if(answer==true) return;\\n        \\n        if(node.left==null && node.right==null){\\n            currentSum+=node.val;\\n            if(sum==currentSum) answer = true;\\n            return;\\n        }\\n        \\n        currentSum+=node.val;\\n        if(node.left!=null) dfs(node.left, sum, currentSum);\\n        if(node.right!=null) dfs(node.right,sum,currentSum);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\n// Runtime: 0 ms, faster than 100.00% of Java online submissions for Path Sum.\\n// Memory Usage: 39.2 MB, less than 73.39% of Java online submissions for Path Sum.\\nclass Solution {\\n    private boolean answer = false;\\n    public boolean hasPathSum(TreeNode root, int sum) {\\n        if(root==null) return false;\\n        dfs(root,sum,0);\\n        return answer;    \\n    }\\n    \\n    private void dfs(TreeNode node, int sum, int currentSum){\\n        if(answer==true) return;\\n        \\n        if(node.left==null && node.right==null){\\n            currentSum+=node.val;\\n            if(sum==currentSum) answer = true;\\n            return;\\n        }\\n        \\n        currentSum+=node.val;\\n        if(node.left!=null) dfs(node.left, sum, currentSum);\\n        if(node.right!=null) dfs(node.right,sum,currentSum);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 517434,
                "title": "java-0ms-recursive",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public boolean hasPathSum(TreeNode root, int sum) {\\n        if(root == null)\\n            return false;\\n        else\\n            return (root.left == null && root.right == null && root.val == sum)\\n            || hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public boolean hasPathSum(TreeNode root, int sum) {\\n        if(root == null)\\n            return false;\\n        else\\n            return (root.left == null && root.right == null && root.val == sum)\\n            || hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 36618,
                "title": "my-java-solution",
                "content": "    public class Solution {\\n        public boolean hasPathSum(TreeNode root, int sum) {\\n            if (root == null)\\n                return false;\\n            if (root.left == null && root.right == null)\\n                return sum == root.val;\\n            return hasPathSum(root.left,sum-root.val) || hasPathSum(root.right,sum-root.val);\\n        }   \\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public boolean hasPathSum(TreeNode root, int sum) {\\n            if (root == null)\\n                return false;\\n            if (root.left == null && root.right == null)\\n                return sum == root.val;\\n            return hasPathSum(root.left,sum-root.val) || hasPathSum(root.right,sum-root.val);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 36640,
                "title": "my-solution-in-c",
                "content": "    /**\\n     * Definition for binary tree\\n     * struct TreeNode {\\n     *     int val;\\n     *     TreeNode *left;\\n     *     TreeNode *right;\\n     *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n     * };\\n     */\\n    class Solution {\\n    public:\\n        bool hasPathSum(TreeNode *root, int sum) {\\n            if(!root) return false;\\n            if(!root->left && !root->right)\\n                return root->val == sum;\\n            return hasPathSum(root->left,sum-root->val) || hasPathSum(root->right,sum-root->val);\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        bool hasPathSum(TreeNode *root, int sum) {\\n            if(!root) return false;\\n            if(!root->left && !root->right)\\n                return root->val == sum;\\n            return hasPathSum(root->left,sum-root->val) || hasPathSum(root->right,sum-root->val);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3526144,
                "title": "c-easy-in-3-lines",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        if (!root) return false;\\n        if (root->val == targetSum && !root->left && !root->right) return true;\\n        return hasPathSum(root->right, targetSum - root->val) || hasPathSum(root->left, targetSum - root->val);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        if (!root) return false;\\n        if (root->val == targetSum && !root->left && !root->right) return true;\\n        return hasPathSum(root->right, targetSum - root->val) || hasPathSum(root->left, targetSum - root->val);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3418430,
                "title": "easiest-java-solution-beats-100-recursive",
                "content": "# Intuition\\nIteration of Tree and summing up the path till leaf.\\nsearcing the leaf node is equal to target or not.\\n\\n# Approach\\njust like node to leaf sum problem , sum up all path till leaf\\nex- \\n```\\ntree = 1            and target is 11\\n      / \\\\\\n    2     3\\n   /     / \\\\\\n  5     4   7\\n```\\n\\nso after path() function tree will be like\\n```\\n       1\\n      / \\\\\\n    3     4\\n   /     / \\\\\\n  8     8   11  \\n\\n```\\n* now search through the leaf to check is there any targetSum present or not if any return true else false  \\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n\\n    public boolean hasPathSum(TreeNode root, int targetSum){\\n        path(root);\\n        return has(root,targetSum);\\n    }\\n    public boolean has(TreeNode root, int targetSum) {\\n        if(root==null)\\n        return false;\\n\\n        if(root.left==null && root.right==null){\\n            if(root.val==targetSum)\\n            return true;\\n        }\\n\\n        return has(root.left,targetSum) || has(root.right,targetSum);\\n    }\\n\\n    public static void path(TreeNode root){\\n        if(root==null)\\n        return;\\n        int data = root.val;\\n        if(root.left!=null)\\n        root.left.val += data;\\n\\n        if(root.right!=null)\\n        root.right.val += data;\\n\\n        path(root.left);\\n        path(root.right);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\ntree = 1            and target is 11\\n      / \\\\\\n    2     3\\n   /     / \\\\\\n  5     4   7\\n```\n```\\n       1\\n      / \\\\\\n    3     4\\n   /     / \\\\\\n  8     8   11  \\n\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n\\n    public boolean hasPathSum(TreeNode root, int targetSum){\\n        path(root);\\n        return has(root,targetSum);\\n    }\\n    public boolean has(TreeNode root, int targetSum) {\\n        if(root==null)\\n        return false;\\n\\n        if(root.left==null && root.right==null){\\n            if(root.val==targetSum)\\n            return true;\\n        }\\n\\n        return has(root.left,targetSum) || has(root.right,targetSum);\\n    }\\n\\n    public static void path(TreeNode root){\\n        if(root==null)\\n        return;\\n        int data = root.val;\\n        if(root.left!=null)\\n        root.left.val += data;\\n\\n        if(root.right!=null)\\n        root.right.val += data;\\n\\n        path(root.left);\\n        path(root.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3294258,
                "title": "my-shortest-c-solution",
                "content": "\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        if (!root)\\n            return false;\\n        \\n        if (root->val == targetSum and !root->left and !root->right)\\n            return true;\\n        \\n        return hasPathSum(root->left, targetSum - root->val) or hasPathSum(root->right, targetSum - root->val);\\n    }\\n};\\n```\\n\\n# Complexity\\n- Time Complexity : $$O(n)$$ [worst case : Traverse all `n` nodes]\\n- Space Complexity : $$O(1)$$",
                "solutionTags": [
                    "C++"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        if (!root)\\n            return false;\\n        \\n        if (root->val == targetSum and !root->left and !root->right)\\n            return true;\\n        \\n        return hasPathSum(root->left, targetSum - root->val) or hasPathSum(root->right, targetSum - root->val);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3058005,
                "title": "javascript-simple-up-vote-if-u-like",
                "content": "# Code\\n```\\nvar hasPathSum = function(root, targetSum) {\\n    if (!root) return false // not a leaf\\n    if (!root.left && !root.right) return root.val === targetSum; // leaf\\n\\n    return hasPathSum(root.left, targetSum - root.val) || hasPathSum(root.right, targetSum - root.val);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar hasPathSum = function(root, targetSum) {\\n    if (!root) return false // not a leaf\\n    if (!root.left && !root.right) return root.val === targetSum; // leaf\\n\\n    return hasPathSum(root.left, targetSum - root.val) || hasPathSum(root.right, targetSum - root.val);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3039724,
                "title": "0ms-java-solution-another-approach",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean hasPathSum(TreeNode root, int target) \\n    {\\n        if(root==null)\\n            return false;\\n        if(root.left==null && root.right==null)\\n            return (target-root.val)==0;\\n     return hasPathSum(root.left,target-root.val) || hasPathSum(root.right,target-root.val);   \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean hasPathSum(TreeNode root, int target) \\n    {\\n        if(root==null)\\n            return false;\\n        if(root.left==null && root.right==null)\\n            return (target-root.val)==0;\\n     return hasPathSum(root.left,target-root.val) || hasPathSum(root.right,target-root.val);   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2813240,
                "title": "python-recursive",
                "content": "```\\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        def helper(node,tot):\\n            if not node:\\n                return \\n            elif not node.left and not node.right:\\n                if tot+node.val==targetSum:\\n                    return True\\n            else:\\n                return helper(node.left,tot+node.val) or helper(node.right,tot+node.val)\\n        if root:\\n            return helper(root,0)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        def helper(node,tot):\\n            if not node:\\n                return \\n            elif not node.left and not node.right:\\n                if tot+node.val==targetSum:\\n                    return True\\n            else:\\n                return helper(node.left,tot+node.val) or helper(node.right,tot+node.val)\\n        if root:\\n            return helper(root,0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2660894,
                "title": "c-concise-recursion-clean-inorder-traversal",
                "content": "```\\n  bool inorder(TreeNode* root , int sum , int &targetSum)\\n    {\\n        if(!root) return false;\\n        sum+=root->val;\\n        if(root->left==NULL && root->right==NULL) if(sum==targetSum) return true; \\n        return (inorder(root->left , sum , targetSum) || inorder(root->right , sum , targetSum));\\n    }\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        return inorder(root, 0 , targetSum);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n  bool inorder(TreeNode* root , int sum , int &targetSum)\\n    {\\n        if(!root) return false;\\n        sum+=root->val;\\n        if(root->left==NULL && root->right==NULL) if(sum==targetSum) return true; \\n        return (inorder(root->left , sum , targetSum) || inorder(root->right , sum , targetSum));\\n    }\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        return inorder(root, 0 , targetSum);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2231534,
                "title": "java-0ms-simple-explanation-with-tc-sc-easy-to-understand",
                "content": "```\\nclass Solution {\\n    \\n    public boolean hasPathSum(TreeNode root, int targetSum) {\\n        \\n        //return false when root is null or when we reached leaf node but the sum is not equal to target sum\\n        if(root == null) {\\n            return false;\\n        }\\n        \\n        //if the current node is not null then we subract targetSum by it\\'s value and pass the new targetSum ahead in the function\\n        targetSum = targetSum - root.val;\\n        \\n        //if both sides are null then it means that we have reached leaf node and if at the same time targetSum is also equals to 0 then we can return true because we have found the path\\n        if(root.left == null && root.right == null && 0 == targetSum) {\\n            return true;\\n        }\\n        \\n        //we do a recursive call for both the sides and use \\'or(||)\\' function because even if one side is true then we got the ans(path)\\n        return hasPathSum(root.left,  targetSum) || hasPathSum(root.right, targetSum);\\n    }\\n    \\n}\\n\\n//Time Complexity: O(n) n is the total number of nodes in the binary tree\\n//Space Complexity: O(n) n is the total number of nodes in the binary tree\\n//Please upvote the solution if you like it",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "class Solution {\\n    \\n    public boolean hasPathSum(TreeNode root, int targetSum) {\\n        \\n        //return false when root is null or when we reached leaf node but the sum is not equal to target sum\\n        if(root == null) {\\n            return false;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1550790,
                "title": "90-faster-c-solution",
                "content": "```\\n bool hasPathSum(TreeNode* root, int targetSum) {\\n        if(!root){\\n            return false;\\n        }\\n        if(targetSum==root->val && root->left==NULL && root->right==NULL){\\n            return true;\\n        }\\n        return hasPathSum(root->left,targetSum-(root->val)) || hasPathSum(root->right,targetSum-(root->val));\\n    }\\n```\\nFor More LeetCode Problem\\'s Solution(Topic-Wise)Please Check Out;\\nhttps://github.com/Ariyanlaskar/DSA/tree/master/LeetCode",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n bool hasPathSum(TreeNode* root, int targetSum) {\\n        if(!root){\\n            return false;\\n        }\\n        if(targetSum==root->val && root->left==NULL && root->right==NULL){\\n            return true;\\n        }\\n        return hasPathSum(root->left,targetSum-(root->val)) || hasPathSum(root->right,targetSum-(root->val));\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1381668,
                "title": "c-dfs-recursive-dfs-iterative-and-bfs",
                "content": "DFS Recursive:\\n\\n```\\npublic bool HasPathSum(TreeNode root, int targetSum)\\n{\\n    if(root == null)\\n        return false;\\n    \\n    if(root.left == null && root.right == null)\\n        return root.val == targetSum;\\n    \\n    return HasPathSum(root.left, targetSum - root.val) || HasPathSum(root.right, targetSum - root.val);\\n}\\n```\\n\\nDFS Iterative:\\n\\n```\\npublic bool HasPathSum(TreeNode root, int targetSum)\\n{\\n    if(root == null)\\n        return false;\\n        \\n    var stack = new Stack<TreeNode>();\\n    var rest = new Stack<int>();\\n    \\n    stack.Push(root);\\n    rest.Push(targetSum);\\n    \\n    while(stack.Count() > 0)\\n    {\\n        root = stack.Pop();\\n        targetSum = rest.Pop();\\n        \\n        if(root.left == null && root.right == null)\\n        {\\n            if(targetSum == root.val)\\n                return true;\\n        }\\n            \\n        if(root.left != null)\\n        {\\n            stack.Push(root.left);\\n            rest.Push(targetSum - root.val);\\n        }\\n            \\n        if(root.right != null)\\n        {\\n            stack.Push(root.right);\\n            rest.Push(targetSum - root.val);\\n        }\\n    }\\n    return false;\\n}\\n```\\n\\nBFS:\\n\\n```\\npublic bool HasPathSum(TreeNode root, int targetSum)\\n{\\n    if (root == null)\\n        return false;\\n        \\n    var queue = new Queue<TreeNode>();\\n    var rest = new Queue<int>();\\n    \\n    queue.Enqueue(root);\\n    rest.Enqueue(targetSum);\\n\\n    while (queue.Count() > 0)\\n    {\\n        root = queue.Dequeue();\\n        targetSum = rest.Dequeue();\\n        \\n        if (root.left == null && root.right == null)\\n        {\\n            if(targetSum == root.val)\\n                return true;\\n        }\\n        \\n        if(root.left != null)\\n        {\\n            queue.Enqueue(root.left);\\n            rest.Enqueue(targetSum - root.val);\\n        }\\n        \\n        if(root.right != null)\\n        {\\n            queue.Enqueue(root.right);\\n            rest.Enqueue(targetSum - root.val);\\n        }\\n    }\\n\\n    return false;\\n}\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\npublic bool HasPathSum(TreeNode root, int targetSum)\\n{\\n    if(root == null)\\n        return false;\\n    \\n    if(root.left == null && root.right == null)\\n        return root.val == targetSum;\\n    \\n    return HasPathSum(root.left, targetSum - root.val) || HasPathSum(root.right, targetSum - root.val);\\n}\\n```\n```\\npublic bool HasPathSum(TreeNode root, int targetSum)\\n{\\n    if(root == null)\\n        return false;\\n        \\n    var stack = new Stack<TreeNode>();\\n    var rest = new Stack<int>();\\n    \\n    stack.Push(root);\\n    rest.Push(targetSum);\\n    \\n    while(stack.Count() > 0)\\n    {\\n        root = stack.Pop();\\n        targetSum = rest.Pop();\\n        \\n        if(root.left == null && root.right == null)\\n        {\\n            if(targetSum == root.val)\\n                return true;\\n        }\\n            \\n        if(root.left != null)\\n        {\\n            stack.Push(root.left);\\n            rest.Push(targetSum - root.val);\\n        }\\n            \\n        if(root.right != null)\\n        {\\n            stack.Push(root.right);\\n            rest.Push(targetSum - root.val);\\n        }\\n    }\\n    return false;\\n}\\n```\n```\\npublic bool HasPathSum(TreeNode root, int targetSum)\\n{\\n    if (root == null)\\n        return false;\\n        \\n    var queue = new Queue<TreeNode>();\\n    var rest = new Queue<int>();\\n    \\n    queue.Enqueue(root);\\n    rest.Enqueue(targetSum);\\n\\n    while (queue.Count() > 0)\\n    {\\n        root = queue.Dequeue();\\n        targetSum = rest.Dequeue();\\n        \\n        if (root.left == null && root.right == null)\\n        {\\n            if(targetSum == root.val)\\n                return true;\\n        }\\n        \\n        if(root.left != null)\\n        {\\n            queue.Enqueue(root.left);\\n            rest.Enqueue(targetSum - root.val);\\n        }\\n        \\n        if(root.right != null)\\n        {\\n            queue.Enqueue(root.right);\\n            rest.Enqueue(targetSum - root.val);\\n        }\\n    }\\n\\n    return false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 525239,
                "title": "python-js-go-c-o-n-dfs-w-hint",
                "content": "Python O(n) sol by DFS\\n\\n---\\n**Hint**:\\n\\nThink of **DFS** algorithm framework\\n\\nOne node is the so-called **leaf node**, if and only if,\\nit is **not an empty node** and it **doesn\\'t have** both *left child* and *right child*.\\n\\nImagine the path sum as a process treasure hunt **from root to leaf** with specified target value\\n\\nUpdate *target value* as *previous target* - *current node value*, then go down to next level in DFS.\\n\\n\\n---\\n**Implementation_#1**:\\nDFS with recursion\\n\\n```\\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        \\n        ## Base case\\n        if not root:\\n            return False\\n        \\n        ## Base case\\n        if not root.left and not root.right:\\n            \\n            # we have the path with targetSum\\n            return targetSum == root.val\\n        \\n        ## General case:\\n        return self.hasPathSum(root.left, targetSum - root.val) or \\\\\\n                self.hasPathSum(root.right, targetSum - root.val)\\n```\\n\\n---\\n\\nin **Javascript**:\\n\\n<details>\\n\\t<summary> Expand to see source code </summary>\\n\\n```\\nvar hasPathSum = function(root, targetSum) {\\n    \\n    // Base case\\n    if( null == root ){\\n        return false;\\n    }\\n    \\n    \\n    if( null == root.left && null == root.right ){\\n        // Base case\\n        return root.val == targetSum;\\n    }else{\\n        \\n        // General cases\\n        return hasPathSum( root.left, targetSum-root.val ) || hasPathSum( root.right, targetSum-root.val );\\n    }\\n};\\n```\\n\\n</details>\\n\\n---\\n\\nin **Go**:\\n\\n<details>\\n\\t<summary> Expand to see source code </summary>\\n\\t\\n```\\nfunc hasPathSum(root *TreeNode, targetSum int) bool {\\n    \\n    // Base case\\n    if nil == root{\\n        return false\\n    }\\n    \\n    \\n    if nil == root.Left && nil == root.Right{\\n        // Base case\\n        return root.Val == targetSum\\n        \\n    }else{\\n        // General cases\\n        return hasPathSum(root.Left, targetSum - root.Val) || hasPathSum(root.Right, targetSum - root.Val)\\n    }\\n}\\n```\\n\\n</details>\\n\\n---\\n\\nin **C++**\\n\\n<details>\\n\\t<summary> Expand to see source code </summary>\\n\\t\\n```\\nclass Solution {\\npublic:\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        \\n        if ( NULL == root ){\\n            return false;\\n        }\\n        \\n        if ( NULL == root->left && NULL == root->right){\\n            return root->val == targetSum;\\n        }else{\\n            return hasPathSum(root->left, targetSum - root->val) || hasPathSum(root->right, targetSum - root->val);\\n        }\\n    }\\n};\\n```\\n</details>\\n\\n---\\n**Implementation_#2**:\\nDFS with stack\\n\\n```\\nclass Solution:\\n    \\n    def hasPathSum(self, root, sum):\\n        \\n        traversal_stack = [(root, sum)]\\n        \\n        # DFS with stack\\n        while traversal_stack:\\n            \\n            node, value = traversal_stack.pop()\\n            \\n            if node:\\n                if not node.left and not node.right and node.val == value:\\n                    # leaf node\\n                    return True\\n                \\n                else:\\n                    # non-leaf node\\n                    traversal_stack.append((node.right, value-node.val))\\n                    traversal_stack.append((node.left, value-node.val))\\n\\n            else:\\n                # empty node\\n                continue\\n                \\n        return False\\n```\\n\\n---\\n\\n\\n---\\n\\nRelated leetcode challenge:\\n\\n[1] [Leetcode #113 Path Sum II](https://leetcode.com/problems/path-sum-ii/)\\n\\n[2] [Leetcode #437 Path Sum III](https://leetcode.com/problems/path-sum-iii/)\\n\\n[3] [Leetcode #129 Sum Root to Leaf Numbers](https://leetcode.com/problems/sum-root-to-leaf-numbers/)",
                "solutionTags": [
                    "C++",
                    "Python",
                    "C",
                    "JavaScript",
                    "Go",
                    "Stack",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        \\n        ## Base case\\n        if not root:\\n            return False\\n        \\n        ## Base case\\n        if not root.left and not root.right:\\n            \\n            # we have the path with targetSum\\n            return targetSum == root.val\\n        \\n        ## General case:\\n        return self.hasPathSum(root.left, targetSum - root.val) or \\\\\\n                self.hasPathSum(root.right, targetSum - root.val)\\n```\n```\\nvar hasPathSum = function(root, targetSum) {\\n    \\n    // Base case\\n    if( null == root ){\\n        return false;\\n    }\\n    \\n    \\n    if( null == root.left && null == root.right ){\\n        // Base case\\n        return root.val == targetSum;\\n    }else{\\n        \\n        // General cases\\n        return hasPathSum( root.left, targetSum-root.val ) || hasPathSum( root.right, targetSum-root.val );\\n    }\\n};\\n```\n```\\nfunc hasPathSum(root *TreeNode, targetSum int) bool {\\n    \\n    // Base case\\n    if nil == root{\\n        return false\\n    }\\n    \\n    \\n    if nil == root.Left && nil == root.Right{\\n        // Base case\\n        return root.Val == targetSum\\n        \\n    }else{\\n        // General cases\\n        return hasPathSum(root.Left, targetSum - root.Val) || hasPathSum(root.Right, targetSum - root.Val)\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        \\n        if ( NULL == root ){\\n            return false;\\n        }\\n        \\n        if ( NULL == root->left && NULL == root->right){\\n            return root->val == targetSum;\\n        }else{\\n            return hasPathSum(root->left, targetSum - root->val) || hasPathSum(root->right, targetSum - root->val);\\n        }\\n    }\\n};\\n```\n```\\nclass Solution:\\n    \\n    def hasPathSum(self, root, sum):\\n        \\n        traversal_stack = [(root, sum)]\\n        \\n        # DFS with stack\\n        while traversal_stack:\\n            \\n            node, value = traversal_stack.pop()\\n            \\n            if node:\\n                if not node.left and not node.right and node.val == value:\\n                    # leaf node\\n                    return True\\n                \\n                else:\\n                    # non-leaf node\\n                    traversal_stack.append((node.right, value-node.val))\\n                    traversal_stack.append((node.left, value-node.val))\\n\\n            else:\\n                # empty node\\n                continue\\n                \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 328124,
                "title": "simple-python-solution-top-down-dfs",
                "content": "Please see and vote for my solutions for these similar problems.\\n\\n[257. Binary Tree Paths](https://leetcode.com/problems/binary-tree-paths/discuss/309004/Different-DFS-Python-solutions)\\n```\\n    def binaryTreePaths(self, root: TreeNode) -> List[str]:\\n        def dfs(node, path, res):\\n            if node.left == None and node.right == None:\\n                res.append(path + str(node.val))\\n            if node.left:\\n                dfs(node.left, path + str(node.val) + \\'->\\', res)\\n            if node.right:\\n                dfs(node.right, path + str(node.val) + \\'->\\', res)\\n        \\n        if not root:\\n            return []\\n        res = []\\n        dfs(root, \"\", res)\\n        return res\\n```\\n\\n[129. Sum Root to Leaf Numbers](https://leetcode.com/problems/sum-root-to-leaf-numbers/discuss/328123/Simple-Python-Solution%3A-top-down-DFS)\\n```\\n    def sumNumbers(self, root: TreeNode) -> int:\\n        def dfs(node, bits, res):\\n            if node.left == None and node.right == None:\\n                res[0] += int(bits + str(node.val), 10)\\n            if node.left:\\n                dfs(node.left, bits + str(node.val), res)\\n            if node.right:\\n                dfs(node.right, bits + str(node.val), res)\\n        \\n        if root == None:\\n            return 0\\n        bits, res = \\'\\', [0]\\n        dfs(root, bits, res)\\n        return res[0]\\n```\\n\\n[1022. Sum of Root To Leaf Binary Numbers](https://leetcode.com/problems/sum-of-root-to-leaf-binary-numbers/discuss/328033/Top-down-Python-DFS-Solution)\\n```\\n    def sumRootToLeaf(self, root: TreeNode) -> int:\\n        def dfs(node, bits, res):\\n            if node.left == None and node.right == None:\\n                res[0] += int(bits + str(node.val), 2)\\n            if node.left:\\n                dfs(node.left, bits + str(node.val), res)\\n            if node.right:\\n                dfs(node.right, bits + str(node.val), res)\\n        \\n        if root == None:\\n            return 0\\n        bits, res = \\'\\', [0]\\n        dfs(root, bits, res)\\n        return res[0]\\n```\\n\\n[988. Smallest String Starting From Leaf](https://leetcode.com/problems/smallest-string-starting-from-leaf/discuss/328119/Simple-Python-Solution%3A-top-down-DFS)\\n```\\n    def smallestFromLeaf(self, root: TreeNode) -> str:\\n        def dfs(root, s):\\n            s = s + chr(ord(\\'a\\') + root.val)\\n            if not root.left and not root.right:\\n                if res[0] == None:\\n                    res[0] = s[::-1]\\n                else:\\n                    res[0] = min(res[0], s[::-1])\\n            if root.left:\\n                dfs(root.left, s)\\n            if root.right:\\n                dfs(root.right, s)\\n        \\n        if not root:\\n            return \\'\\'\\n        res = [None]\\n        dfs(root, \\'\\')\\n        return res[0]\\n```\\n\\n[112. Path Sum](https://leetcode.com/problems/path-sum/discuss/328124/Simple-Python-Solution%3A-top-down-DFS)\\n\\n```\\n    def hasPathSum(self, root: TreeNode, s: int) -> bool:\\n        def dfs(root, curr_s):\\n            curr_s += root.val\\n            if not root.left and not root.right:\\n                if curr_s == s:\\n                    res[0] = True\\n                    return\\n            if not res[0] and root.left:\\n                dfs(root.left, curr_s)\\n            if not res[0] and root.right:\\n                dfs(root.right, curr_s)\\n        \\n        if not root:\\n            return False\\n        res = [False]\\n        dfs(root, 0)\\n        return res[0]\\n```\\n\\n[113. Path Sum II](https://leetcode.com/problems/path-sum-ii/discuss/328125/Simple-Python-Solution%3A-top-down-DFS)\\n```\\n    def pathSum(self, root: TreeNode, s: int) -> List[List[int]]:\\n        def dfs(root, lst, curr_s):\\n            curr_s += root.val\\n            if not root.left and not root.right:\\n                if curr_s == s:\\n                    res.append(lst + [root.val])\\n                    return\\n            if root.left:\\n                dfs(root.left, lst + [root.val], curr_s)\\n            if root.right:\\n                dfs(root.right, lst + [root.val], curr_s)\\n        \\n        if not root:\\n            return []\\n        res = []\\n        dfs(root, [], 0)\\n        return res\\n```\\n\\n[437. Path Sum III](https://leetcode.com/problems/path-sum-iii/discuss/328128/Simple-Python-Solution%3A-top-down-DFS-%2B-DP) (Similar problem: 560. Subarray Sum Equals K)\\n\\n```\\n    def pathSum(self, root, s):\\n        def dfs(root, curr_s):\\n            curr_s += root.val\\n            res[0] += pre_sums.get(curr_s - s, 0)\\n            pre_sums[curr_s] = pre_sums.get(curr_s, 0) + 1\\n            if root.left:\\n                dfs(root.left, curr_s)\\n            if root.right:\\n                dfs(root.right, curr_s)\\n            pre_sums[curr_s] -= 1\\n            if pre_sums[curr_s] == 0:\\n                del pre_sums[curr_s]\\n        \\n        res = [0]\\n        pre_sums = {0: 1}\\n        if not root:\\n            return res[0]\\n        dfs(root, 0)\\n        return res[0]\\n```",
                "solutionTags": [],
                "code": "```\\n    def binaryTreePaths(self, root: TreeNode) -> List[str]:\\n        def dfs(node, path, res):\\n            if node.left == None and node.right == None:\\n                res.append(path + str(node.val))\\n            if node.left:\\n                dfs(node.left, path + str(node.val) + \\'->\\', res)\\n            if node.right:\\n                dfs(node.right, path + str(node.val) + \\'->\\', res)\\n        \\n        if not root:\\n            return []\\n        res = []\\n        dfs(root, \"\", res)\\n        return res\\n```\n```\\n    def sumNumbers(self, root: TreeNode) -> int:\\n        def dfs(node, bits, res):\\n            if node.left == None and node.right == None:\\n                res[0] += int(bits + str(node.val), 10)\\n            if node.left:\\n                dfs(node.left, bits + str(node.val), res)\\n            if node.right:\\n                dfs(node.right, bits + str(node.val), res)\\n        \\n        if root == None:\\n            return 0\\n        bits, res = \\'\\', [0]\\n        dfs(root, bits, res)\\n        return res[0]\\n```\n```\\n    def sumRootToLeaf(self, root: TreeNode) -> int:\\n        def dfs(node, bits, res):\\n            if node.left == None and node.right == None:\\n                res[0] += int(bits + str(node.val), 2)\\n            if node.left:\\n                dfs(node.left, bits + str(node.val), res)\\n            if node.right:\\n                dfs(node.right, bits + str(node.val), res)\\n        \\n        if root == None:\\n            return 0\\n        bits, res = \\'\\', [0]\\n        dfs(root, bits, res)\\n        return res[0]\\n```\n```\\n    def smallestFromLeaf(self, root: TreeNode) -> str:\\n        def dfs(root, s):\\n            s = s + chr(ord(\\'a\\') + root.val)\\n            if not root.left and not root.right:\\n                if res[0] == None:\\n                    res[0] = s[::-1]\\n                else:\\n                    res[0] = min(res[0], s[::-1])\\n            if root.left:\\n                dfs(root.left, s)\\n            if root.right:\\n                dfs(root.right, s)\\n        \\n        if not root:\\n            return \\'\\'\\n        res = [None]\\n        dfs(root, \\'\\')\\n        return res[0]\\n```\n```\\n    def hasPathSum(self, root: TreeNode, s: int) -> bool:\\n        def dfs(root, curr_s):\\n            curr_s += root.val\\n            if not root.left and not root.right:\\n                if curr_s == s:\\n                    res[0] = True\\n                    return\\n            if not res[0] and root.left:\\n                dfs(root.left, curr_s)\\n            if not res[0] and root.right:\\n                dfs(root.right, curr_s)\\n        \\n        if not root:\\n            return False\\n        res = [False]\\n        dfs(root, 0)\\n        return res[0]\\n```\n```\\n    def pathSum(self, root: TreeNode, s: int) -> List[List[int]]:\\n        def dfs(root, lst, curr_s):\\n            curr_s += root.val\\n            if not root.left and not root.right:\\n                if curr_s == s:\\n                    res.append(lst + [root.val])\\n                    return\\n            if root.left:\\n                dfs(root.left, lst + [root.val], curr_s)\\n            if root.right:\\n                dfs(root.right, lst + [root.val], curr_s)\\n        \\n        if not root:\\n            return []\\n        res = []\\n        dfs(root, [], 0)\\n        return res\\n```\n```\\n    def pathSum(self, root, s):\\n        def dfs(root, curr_s):\\n            curr_s += root.val\\n            res[0] += pre_sums.get(curr_s - s, 0)\\n            pre_sums[curr_s] = pre_sums.get(curr_s, 0) + 1\\n            if root.left:\\n                dfs(root.left, curr_s)\\n            if root.right:\\n                dfs(root.right, curr_s)\\n            pre_sums[curr_s] -= 1\\n            if pre_sums[curr_s] == 0:\\n                del pre_sums[curr_s]\\n        \\n        res = [0]\\n        pre_sums = {0: 1}\\n        if not root:\\n            return res[0]\\n        dfs(root, 0)\\n        return res[0]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 111106,
                "title": "javascript-clean-solution",
                "content": "```\\nvar hasPathSum = function(root, sum) {\\n    let res = false;\\n    function helper(node, cur){\\n        if(!node) return;\\n        cur += node.val;\\n        if(!node.left && !node.right){\\n            if(cur === sum){\\n                res = true;\\n                return;\\n            }\\n        }\\n        else{\\n            helper(node.left, cur);\\n            helper(node.right, cur);\\n        }\\n    }\\n    helper(root, 0);\\n    return res;\\n};",
                "solutionTags": [],
                "code": "```\\nvar hasPathSum = function(root, sum) {\\n    let res = false;\\n    function helper(node, cur){\\n        if(!node) return;\\n        cur += node.val;\\n        if(!node.left && !node.right){\\n            if(cur === sum){\\n                res = true;\\n                return;\\n            }\\n        }\\n        else{\\n            helper(node.left, cur);\\n            helper(node.right, cur);\\n        }\\n    }\\n    helper(root, 0);\\n    return res;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 36387,
                "title": "swift-solution",
                "content": "```\\nclass Solution {\\n    func hasPathSum(_ root: TreeNode?, _ sum: Int) -> Bool {\\n        guard let root = root else {\\n            return false\\n        }\\n        \\n        if root.left == nil && root.right == nil {\\n            return root.val == sum\\n        }\\n        \\n        return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val)\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func hasPathSum(_ root: TreeNode?, _ sum: Int) -> Bool {\\n        guard let root = root else {\\n            return false\\n        }\\n        \\n        if root.left == nil && root.right == nil {\\n            return root.val == sum\\n        }\\n        \\n        return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 36389,
                "title": "c",
                "content": "```\\npublic class Solution {\\n    public bool HasPathSum(TreeNode root, int sum) {\\n        if (root == null)\\n            return false;\\n        \\n        if (root.left == null && root.right == null)\\n            return sum == root.val;\\n        \\n        return HasPathSum(root.left, sum - root.val) || HasPathSum(root.right, sum - root.val);\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public bool HasPathSum(TreeNode root, int sum) {\\n        if (root == null)\\n            return false;\\n        \\n        if (root.left == null && root.right == null)\\n            return sum == root.val;\\n        \\n        return HasPathSum(root.left, sum - root.val) || HasPathSum(root.right, sum - root.val);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 36513,
                "title": "accepted-java-iteration-solution-with-one-stack-without-change-the-value-of-treenode",
                "content": "Enjoy my first post ^ ^\\n\\n    public boolean hasPathSum(TreeNode root, int sum) {\\n\\t\\tStack<TreeNode> stack = new Stack<>();\\n\\t\\twhile (!stack.isEmpty() || root != null) {\\n\\t\\t\\twhile (root != null) {\\n\\t\\t\\t\\tstack.push(root);\\n\\t\\t\\t\\tsum -= root.val;\\n\\t\\t\\t\\troot = root.left;\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\tif (sum == 0 && stack.peek().right == null && stack.peek().left == null) {\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t} \\n\\t\\t\\t\\n\\t\\t\\t//root == null\\n\\t\\t\\t//pop all nodes whose children pathes have been both checked.\\n\\t\\t\\twhile (!stack.isEmpty() && stack.peek().right == root) {\\n\\t\\t\\t    root = stack.pop();\\n\\t\\t\\t    sum += root.val;\\n\\t\\t\\t}\\n\\t\\t\\troot = stack.isEmpty() ? null : stack.peek().right;\\n\\t\\t\\t//root is now the first node in in-order which has never been pushed in the stack.\\n\\t\\t}\\n\\t\\treturn false;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "Enjoy my first post ^ ^\\n\\n    public boolean hasPathSum(TreeNode root, int sum) {\\n\\t\\tStack<TreeNode> stack = new Stack<>();\\n\\t\\twhile (!stack.isEmpty() || root != null) {\\n\\t\\t\\twhile (root != null) {\\n\\t\\t\\t\\tstack.push(root);\\n\\t\\t\\t\\tsum -= root.val;\\n\\t\\t\\t\\troot = root.left;\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\tif (sum == 0 && stack.peek().right == null && stack.peek().left == null) {\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t} \\n\\t\\t\\t\\n\\t\\t\\t//root == null\\n\\t\\t\\t//pop all nodes whose children pathes have been both checked.\\n\\t\\t\\twhile (!stack.isEmpty() && stack.peek().right == root) {\\n\\t\\t\\t    root = stack.pop();\\n\\t\\t\\t    sum += root.val;\\n\\t\\t\\t}\\n\\t\\t\\troot = stack.isEmpty() ? null : stack.peek().right;\\n\\t\\t\\t//root is now the first node in in-order which has never been pushed in the stack.\\n\\t\\t}\\n\\t\\treturn false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 36523,
                "title": "clean-1-ms-recursive-java-solution",
                "content": "    public boolean hasPathSum(TreeNode root, int sum) {\\n        \\n        if((root==null))\\n        {\\n            return false;\\n        }\\n        sum=sum-root.val;\\n        if(sum==0)\\n        {\\n            if((root.left==null)&&(root.right==null))\\n            {\\n                return true;\\n            }\\n        }\\n\\n       if(hasPathSum(root.left,sum)||hasPathSum(root.right,sum))\\n       {\\n           return true;\\n       }\\n\\n        \\n        return false;\\n        \\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public boolean hasPathSum(TreeNode root, int sum) {\\n        \\n        if((root==null))\\n        {\\n            return false;\\n        }\\n        sum=sum-root.val;\\n        if(sum==0)\\n        {\\n            if((root.left==null)&&(root.right==null))\\n            {\\n                return true;\\n            }\\n        }\\n\\n       if(hasPathSum(root.left,sum)||hasPathSum(root.right,sum))\\n       {\\n           return true;\\n       }\\n\\n        \\n        return false;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 36568,
                "title": "a-c-recursive-version",
                "content": "    public bool HasPathSum(TreeNode root, int sum) {\\n        return root == null ? false :\\n               root.val == sum && root.left == null && root.right == null\\n            || HasPathSum(root.left, sum - root.val)\\n            || HasPathSum(root.right, sum - root.val);\\n    }",
                "solutionTags": [],
                "code": "    public bool HasPathSum(TreeNode root, int sum) {\\n        return root == null ? false :\\n               root.val == sum && root.left == null && root.right == null\\n            || HasPathSum(root.left, sum - root.val)\\n            || HasPathSum(root.right, sum - root.val);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3009126,
                "title": "1ms-java-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean hasPathSum(TreeNode root, int targetSum) {\\n        if(root==null){\\n            return false;\\n        }\\n        if(root.left==null && root.right==null && root.val==targetSum){\\n            return true;\\n        }\\n        if(hasPathSum(root.left,targetSum-root.val)||hasPathSum(root.right,targetSum-root.val)){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean hasPathSum(TreeNode root, int targetSum) {\\n        if(root==null){\\n            return false;\\n        }\\n        if(root.left==null && root.right==null && root.val==targetSum){\\n            return true;\\n        }\\n        if(hasPathSum(root.left,targetSum-root.val)||hasPathSum(root.right,targetSum-root.val)){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2660876,
                "title": "java-dfs-and-bfs",
                "content": "# Intuition\\nTraverse the tree and sum up the values you get along the path to a leaf node.\\nWhenever you arrive at a leaf node, check whether it is equal to the `targetSum`\\n\\n# DFS\\n```\\nclass Solution {\\n    public boolean hasPathSum(TreeNode root, int targetSum) {\\n        if (root == null) return false;\\n        return searchPathSum(root, 0, targetSum);\\n    }\\n    \\n    public boolean searchPathSum(TreeNode root, int currentSum, int targetSum) {\\n        if (root == null) {\\n            return false;\\n        }\\n        \\n        currentSum += root.val;\\n        if (root.left == null && root.right == null) {\\n            return currentSum == targetSum;\\n        }\\n        \\n        return searchPathSum(root.left, currentSum, targetSum) || searchPathSum(root.right, currentSum, targetSum);\\n    }\\n}\\n```\\n\\n# BFS\\n```\\nclass TreeElement {\\n    public TreeNode node;\\n    private int sum;\\n    \\n    TreeElement(TreeNode node, int sum) {\\n        this.node = node;\\n        this.sum = sum;\\n    }\\n    \\n    public boolean isLeaf() {\\n        return node != null && node.left == null && node.right == null;\\n    }\\n    \\n    public int getSum() {\\n        return sum;\\n    }\\n}\\n\\nclass Solution {\\n    public boolean hasPathSum(TreeNode root, int targetSum) {\\n        if (root == null) return false;\\n        \\n        Queue<TreeElement> queue = new LinkedList<TreeElement>();\\n        queue.add(new TreeElement(root, 0));\\n        \\n        while(queue.size() != 0) {\\n            TreeElement currentElement = queue.poll();\\n            if(currentElement.node == null) continue;\\n            \\n            int newSum = currentElement.getSum() + currentElement.node.val;\\n            if(currentElement.isLeaf() && newSum == targetSum) {\\n                return true;\\n            }\\n            \\n            if(currentElement.node.right != null) {\\n                queue.add(new TreeElement(currentElement.node.right, newSum));\\n            }\\n            if(currentElement.node.left != null) {\\n                queue.add(new TreeElement(currentElement.node.left, newSum));\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean hasPathSum(TreeNode root, int targetSum) {\\n        if (root == null) return false;\\n        return searchPathSum(root, 0, targetSum);\\n    }\\n    \\n    public boolean searchPathSum(TreeNode root, int currentSum, int targetSum) {\\n        if (root == null) {\\n            return false;\\n        }\\n        \\n        currentSum += root.val;\\n        if (root.left == null && root.right == null) {\\n            return currentSum == targetSum;\\n        }\\n        \\n        return searchPathSum(root.left, currentSum, targetSum) || searchPathSum(root.right, currentSum, targetSum);\\n    }\\n}\\n```\n```\\nclass TreeElement {\\n    public TreeNode node;\\n    private int sum;\\n    \\n    TreeElement(TreeNode node, int sum) {\\n        this.node = node;\\n        this.sum = sum;\\n    }\\n    \\n    public boolean isLeaf() {\\n        return node != null && node.left == null && node.right == null;\\n    }\\n    \\n    public int getSum() {\\n        return sum;\\n    }\\n}\\n\\nclass Solution {\\n    public boolean hasPathSum(TreeNode root, int targetSum) {\\n        if (root == null) return false;\\n        \\n        Queue<TreeElement> queue = new LinkedList<TreeElement>();\\n        queue.add(new TreeElement(root, 0));\\n        \\n        while(queue.size() != 0) {\\n            TreeElement currentElement = queue.poll();\\n            if(currentElement.node == null) continue;\\n            \\n            int newSum = currentElement.getSum() + currentElement.node.val;\\n            if(currentElement.isLeaf() && newSum == targetSum) {\\n                return true;\\n            }\\n            \\n            if(currentElement.node.right != null) {\\n                queue.add(new TreeElement(currentElement.node.right, newSum));\\n            }\\n            if(currentElement.node.left != null) {\\n                queue.add(new TreeElement(currentElement.node.left, newSum));\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2658790,
                "title": "c-recursion-with-explanation-4-lines",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    bool root_to_leaf(TreeNode* root, int Sum){\\n        \\n        // root reaches NULL that means we didn\\'t find any path root-to-leaf that add up to sum because if there is any we return from line number \\'24\\'\\n        if(root==NULL)return false;\\n        \\n        // because we reach some root value so remaining target sum is sum-root_value\\n        Sum=Sum-root->val;\\n        \\n        // base case when we reach leaf node && Sum becomes \\'0\\' specify that we find a path THEREFORE return true\\n        if(root->left==NULL and root->right==NULL and Sum==0)return true;\\n        \\n        // recursive call to LEFT subtree of root && RIGHT subtree of root using or because \\n        // if any one of them return true we found a path so return true  && if both of them return false we didn\\'t found any path so return false\\n        // true or true => true || true or false => true || false or true => true || false or false => false \\n        return root_to_leaf(root->left,Sum) or root_to_leaf(root->right,Sum);\\n    }\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        \\n        // EDGE case when tree is empty because there are no root-to-leaf paths THRERFORE return false\\n        if(root==NULL)return false;\\n        \\n        // function call to check if there exist a path root-to-leaf such that adding up values along the path == targetSum\\n        return root_to_leaf(root,targetSum);\\n    }\\n};\\n```\\n\\n```\\nTIME COMPLEXITY \\nO(N) as we have to visit every node until we find a root-to-leaf path of sum = target sum \\n\\nSPACE COMPLEXITY \\nO(LOGN) recursion stack space as we go as depth as height of tree\\n\\nN=Total Number of Nodes in Tree",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool root_to_leaf(TreeNode* root, int Sum){\\n        \\n        // root reaches NULL that means we didn\\'t find any path root-to-leaf that add up to sum because if there is any we return from line number \\'24\\'\\n        if(root==NULL)return false;\\n        \\n        // because we reach some root value so remaining target sum is sum-root_value\\n        Sum=Sum-root->val;\\n        \\n        // base case when we reach leaf node && Sum becomes \\'0\\' specify that we find a path THEREFORE return true\\n        if(root->left==NULL and root->right==NULL and Sum==0)return true;\\n        \\n        // recursive call to LEFT subtree of root && RIGHT subtree of root using or because \\n        // if any one of them return true we found a path so return true  && if both of them return false we didn\\'t found any path so return false\\n        // true or true => true || true or false => true || false or true => true || false or false => false \\n        return root_to_leaf(root->left,Sum) or root_to_leaf(root->right,Sum);\\n    }\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        \\n        // EDGE case when tree is empty because there are no root-to-leaf paths THRERFORE return false\\n        if(root==NULL)return false;\\n        \\n        // function call to check if there exist a path root-to-leaf such that adding up values along the path == targetSum\\n        return root_to_leaf(root,targetSum);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2657629,
                "title": "python-3-7-lines-recursion-t-m-94-56",
                "content": "```\\nclass Solution:\\n    def hasPathSum(self, root: TreeNode, targetSum: int) -> bool:\\n        \\n        if not root :                                               # if null node\\n            return False                                            # return False\\n    \\n        if (not root.right and not root.left                        # if target hit on leaf, \\n            and root.val == targetSum):                             # return True\\n            return True\\n        \\n        return (self.hasPathSum(root.left ,targetSum-root.val) or   # traverse left  subtree\\n                self.hasPathSum(root.right,targetSum-root.val))     # traverse right subtree  \\n```\\n[https://leetcode.com/submissions/detail/603749417/](http://)",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def hasPathSum(self, root: TreeNode, targetSum: int) -> bool:\\n        \\n        if not root :                                               # if null node\\n            return False                                            # return False\\n    \\n        if (not root.right and not root.left                        # if target hit on leaf, \\n            and root.val == targetSum):                             # return True\\n            return True\\n        \\n        return (self.hasPathSum(root.left ,targetSum-root.val) or   # traverse left  subtree\\n                self.hasPathSum(root.right,targetSum-root.val))     # traverse right subtree  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2580206,
                "title": "accepted-recursive-solution",
                "content": "```\\nclass Solution {\\n    public boolean hasPathSum(TreeNode root, int targetSum) {\\n        if(root == null)\\n            return false;\\n        \\n        if(root.left==null && root.right==null && targetSum -root.val ==0)\\n            return true;\\n        \\n        \\n        return hasPathSum(root.left, targetSum -root.val) || hasPathSum(root.right, targetSum -root.val);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public boolean hasPathSum(TreeNode root, int targetSum) {\\n        if(root == null)\\n            return false;\\n        \\n        if(root.left==null && root.right==null && targetSum -root.val ==0)\\n            return true;\\n        \\n        \\n        return hasPathSum(root.left, targetSum -root.val) || hasPathSum(root.right, targetSum -root.val);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1688756,
                "title": "recursive-iterative-and-morris-traversal-solutions-in-python",
                "content": "## Approach 1. recursive\\n---\\n##### Time complexity: O(n)\\n##### Space complexity: O(n)\\n```python\\nclass Solution:\\n    def hasPathSum(self, root: Optiona[TreeNode], targetSum: int) -> bool:\\n        if root == None:\\n            return False\\n\\n        if root.left == None and root.right == None:\\n            return targetSum == root.val\\n\\n        return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)\\n```\\n## Approach 2. iterative\\n---\\n##### Time complexity: O(n)\\n##### Space complexity: O(n)\\n```python\\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        if root == None:\\n            return False\\n\\n        stack = [(root, targetSum - root.val)]\\n\\n        while len(stack) > 0:\\n            node, remainder = stack.pop()\\n\\n            if node.left == None and node.right == None and remainder == 0:\\n                return True\\n\\n            if node.left != None:\\n                stack.append((node.left, remainder - node.left.val))\\n\\n            if node.right != None:\\n                stack.append((node.right, remainder - node.right.val))\\n\\n        return False\\n```\\n## Approach 3. Morris traversal\\n---\\n##### Time complexity: O(n)\\n##### Space complexity: O(1)\\n\\nThis solution is thanks to [ayuanx](https://leetcode.com/problems/path-sum/discuss/36435/C%2B%2B-Non-recursive-O(1)-space-solution-based-on-Morris-Traversal). The intuition behind it is that we keep track of the path sum so far while we traverse down the tree, where `m` is updated when we move the root pointer down the tree, and `n` is updated when we\\'re setting up successor relationships / [threading the tree](https://en.wikipedia.org/wiki/Threaded_binary_tree). When we\\'re about to explore a different path, we subtract the current path\\'s sum `n` from the total path sum `m`.\\n\\n```python\\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        m = 0\\n\\n        while root != None:\\n            if root.left == None:\\n                m += root.val\\n                root = root.right\\n\\n                if root == None and m == targetSum:\\n                    return True\\n            else:\\n                prev = root.left\\n                n = prev.val\\n\\n                while prev.right != None and prev.right != root:\\n                    prev = prev.right\\n                    n += prev.val\\n\\n                if prev.right == None:\\n                    m += root.val\\n                    prev.right = root\\n\\n                    if prev.left == None and m + n == targetSum:\\n                        return True\\n\\n                    root = root.left\\n                else:\\n                    prev.right = None\\n                    root = root.right\\n                    m -= n\\n\\n        return False\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Stack",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```python\\nclass Solution:\\n    def hasPathSum(self, root: Optiona[TreeNode], targetSum: int) -> bool:\\n        if root == None:\\n            return False\\n\\n        if root.left == None and root.right == None:\\n            return targetSum == root.val\\n\\n        return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)\\n```\n```python\\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        if root == None:\\n            return False\\n\\n        stack = [(root, targetSum - root.val)]\\n\\n        while len(stack) > 0:\\n            node, remainder = stack.pop()\\n\\n            if node.left == None and node.right == None and remainder == 0:\\n                return True\\n\\n            if node.left != None:\\n                stack.append((node.left, remainder - node.left.val))\\n\\n            if node.right != None:\\n                stack.append((node.right, remainder - node.right.val))\\n\\n        return False\\n```\n```python\\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        m = 0\\n\\n        while root != None:\\n            if root.left == None:\\n                m += root.val\\n                root = root.right\\n\\n                if root == None and m == targetSum:\\n                    return True\\n            else:\\n                prev = root.left\\n                n = prev.val\\n\\n                while prev.right != None and prev.right != root:\\n                    prev = prev.right\\n                    n += prev.val\\n\\n                if prev.right == None:\\n                    m += root.val\\n                    prev.right = root\\n\\n                    if prev.left == None and m + n == targetSum:\\n                        return True\\n\\n                    root = root.left\\n                else:\\n                    prev.right = None\\n                    root = root.right\\n                    m -= n\\n\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 896271,
                "title": "simple-recursive-python-3",
                "content": "Algorithm:\\n* decrement the sum as you recurse down the binary tree\\n* if you are at a leaf node, check if `sum == 0`\\n\\n```\\nclass Solution:\\n    def hasPathSum(self, root: TreeNode, sum: int) -> bool:\\n        if not root:\\n            return False\\n\\n        sum -= root.val\\n        \\n        #only check sum if it is a leaf node\\n        if root.left == None and root.right == None:\\n            if sum == 0:\\n                return True\\n            return False\\n\\n        return self.hasPathSum(root.left, sum) or self.hasPathSum(root.right, sum)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def hasPathSum(self, root: TreeNode, sum: int) -> bool:\\n        if not root:\\n            return False\\n\\n        sum -= root.val\\n        \\n        #only check sum if it is a leaf node\\n        if root.left == None and root.right == None:\\n            if sum == 0:\\n                return True\\n            return False\\n\\n        return self.hasPathSum(root.left, sum) or self.hasPathSum(root.right, sum)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 286472,
                "title": "c-dfs",
                "content": "```\\npublic class Solution {\\n    public bool HasPathSum(TreeNode root, int sum) {\\n        if (root == null) return false;\\n        if (root.left == null && root.right == null && sum == root.val) {\\n            return true;\\n        }\\n\\n        return HasPathSum(root.left, sum - root.val) || HasPathSum(root.right, sum - root.val);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public bool HasPathSum(TreeNode root, int sum) {\\n        if (root == null) return false;\\n        if (root.left == null && root.right == null && sum == root.val) {\\n            return true;\\n        }\\n\\n        return HasPathSum(root.left, sum - root.val) || HasPathSum(root.right, sum - root.val);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 144669,
                "title": "my-swift-solution",
                "content": "\\tfunc hasPathSum(_ root: TreeNode?, _ sum: Int) -> Bool {\\n        guard let root = root else {\\n            return false\\n        }\\n        \\n        if root.left == nil && root.right == nil {\\n            return root.val == sum\\n        }\\n        \\n        return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val)\\n    }",
                "solutionTags": [],
                "code": "\\tfunc hasPathSum(_ root: TreeNode?, _ sum: Int) -> Bool {\\n        guard let root = root else {\\n            return false\\n        }\\n        \\n        if root.left == nil && root.right == nil {\\n            return root.val == sum\\n        }\\n        \\n        return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val)\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 36438,
                "title": "simple-python-solution-3-lines",
                "content": "```\\ndef hasPathSum(self, root, sum):\\n        if root == None:return False\\n        if root.val - sum == 0 and root.left == None and root.right == None:return True\\n        return self.hasPathSum(root.left, sum-root.val) or self.hasPathSum(root.right, sum-root.val)",
                "solutionTags": [],
                "code": "```\\ndef hasPathSum(self, root, sum):\\n        if root == None:return False\\n        if root.val - sum == 0 and root.left == None and root.right == None:return True\\n        return self.hasPathSum(root.left, sum-root.val) or self.hasPathSum(root.right, sum-root.val)",
                "codeTag": "Python3"
            },
            {
                "id": 36505,
                "title": "java-recursive-solution-with-comments",
                "content": "    public boolean hasPathSum(TreeNode root, int sum) {\\n     \\n     // empty tree\\n     if (root == null)\\n        return false;\\n    \\n     // leaf node, check sum\\n    if (root.left == null && root.right == null) {\\n      if(sum == root.val)\\n        return true;\\n      else \\n        return false;\\n    } \\n    \\n    // at least one sub tree is not null, check if either one has path sum\\n    return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);\\n     \\n        \\n    }",
                "solutionTags": [],
                "code": "    public boolean hasPathSum(TreeNode root, int sum) {\\n     \\n     // empty tree\\n     if (root == null)\\n        return false;\\n    \\n     // leaf node, check sum\\n    if (root.left == null && root.right == null) {\\n      if(sum == root.val)\\n        return true;\\n      else \\n        return false;\\n    } \\n    \\n    // at least one sub tree is not null, check if either one has path sum\\n    return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);\\n     \\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 36500,
                "title": "recommend-for-beginners-recursive-non-recursive-c-implementation-with-detailed-explaination",
                "content": "    class Solution {\\n    public:\\n        /*** recursive solution  ***/\\n        bool hasPathSum(TreeNode* root, int sum) {\\n            if(root==NULL)  return false;\\n            if(root->left==NULL && root->right==NULL)   return sum==root->val;\\n            return hasPathSum(root->left, sum-root->val) || hasPathSum(root->right, sum-root->val);\\n        }\\n        \\n        /*** level-bfs-iterative solution  ***/\\n        bool hasPathSum(TreeNode* root, int sum){\\n            if(root==NULL)  return false;\\n            \\n            queue<TreeNode*> q;\\n            q.push(root);\\n            while(q.size()>0){\\n                TreeNode* node=q.front();\\n                q.pop();\\n                if(node->left==NULL && node->right==NULL){\\n                    if(node->val==sum)  return true;\\n                }\\n                if(node->left){\\n                    node->left->val+=node->val;\\n                    q.push(node->left);\\n                }\\n                if(node->right){\\n                    node->right->val+=node->val;\\n                    q.push(node->right);\\n                }\\n            }\\n            return false;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        /*** recursive solution  ***/\\n        bool hasPathSum(TreeNode* root, int sum) {\\n            if(root==NULL)  return false;\\n            if(root->left==NULL && root->right==NULL)   return sum==root->val;\\n            return hasPathSum(root->left, sum-root->val) || hasPathSum(root->right, sum-root->val);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 36510,
                "title": "1ms-3-lines-java-recursion-solution",
                "content": "    public class Solution {\\n    public boolean hasPathSum(TreeNode root, int sum) {\\n        if(root == null) return false;\\n        if(root.val == sum && root.left == null && root.right == null) return true;\\n        return hasPathSum(root.left, sum-root.val) || hasPathSum(root.right, sum-root.val);\\n    }\\n    }",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "class Solution {\\n    public boolean hasPathSum(TreeNode root, int sum) {\\n        if(root == null) return false;\\n        if(root.val == sum && root.left == null && root.right == null) return true;\\n        return hasPathSum(root.left, sum-root.val) || hasPathSum(root.right, sum-root.val);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 36554,
                "title": "3-line-java-recursive-solution",
                "content": "    public boolean hasPathSum(TreeNode root, int sum) {\\n            if(root == null) return false;\\n            if(root.right==null && root.left == null && root.val == sum) return true;\\n            return hasPathSum(root.left,sum-root.val) || hasPathSum(root.right,sum-root.val);\\n    }",
                "solutionTags": [],
                "code": "    public boolean hasPathSum(TreeNode root, int sum) {\\n            if(root == null) return false;\\n            if(root.right==null && root.left == null && root.val == sum) return true;\\n            return hasPathSum(root.left,sum-root.val) || hasPathSum(root.right,sum-root.val);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 36638,
                "title": "super-easy-3-lines-java-solution",
                "content": "I believe this is the easiest approach. Let me know if you can improve it.\\n\\n    public class Solution {\\n    public boolean hasPathSum(TreeNode root, int sum) {\\n        if(root == null) return false;\\n        \\n        if(root.left == null && root.right == null && sum - root.val == 0 ) return true;\\n        \\n        return hasPathSum(root.left,sum - root.val)||hasPathSum(root.right,sum - root.val);\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public boolean hasPathSum(TreeNode root, int sum) {\\n        if(root == null) return false;\\n        \\n        if(root.left == null && root.right == null && sum - root.val == 0 ) return true;\\n        \\n        return hasPathSum(root.left,sum - root.val)||hasPathSum(root.right,sum - root.val);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 4087878,
                "title": "best-o-n-solution",
                "content": "# Approach\\nDFS Traversal\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool traversal(TreeNode* root, int curSum, int targetSum) {\\n        if (!root->left && !root->right) {\\n            if (targetSum == (curSum + root->val))\\n                return true;\\n            return false;    \\n        }\\n        if (root->left) {\\n            if (traversal(root->left, curSum + root->val, targetSum))\\n                return true;\\n        }\\n        if (root->right) {\\n            if (traversal(root->right, curSum + root->val, targetSum))\\n                return true;\\n        }\\n        return false;\\n    }\\n\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        int curSum = 0;\\n        if (!root)\\n            return false;\\n        return traversal(root, curSum, targetSum);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool traversal(TreeNode* root, int curSum, int targetSum) {\\n        if (!root->left && !root->right) {\\n            if (targetSum == (curSum + root->val))\\n                return true;\\n            return false;    \\n        }\\n        if (root->left) {\\n            if (traversal(root->left, curSum + root->val, targetSum))\\n                return true;\\n        }\\n        if (root->right) {\\n            if (traversal(root->right, curSum + root->val, targetSum))\\n                return true;\\n        }\\n        return false;\\n    }\\n\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        int curSum = 0;\\n        if (!root)\\n            return false;\\n        return traversal(root, curSum, targetSum);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3609573,
                "title": "path-sum-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe code defines a method called hasPathSum that takes two parameters: a root node of a binary tree and a target sum. The method returns true if there is a path from the root to a leaf node that adds up to the target sum, and false otherwise.\\n\\nThe method uses recursion to check every possible path in the tree. It first checks if the root node is null, which means the tree is empty. In that case, it returns false. Then it checks if the root node is a leaf node, which means it has no children. In that case, it subtracts the root node\\u2019s value from the target sum and compares it to zero. If they are equal, it means the path sum equals the target sum, so it returns true. Otherwise, it returns false.\\n\\nIf the root node is not a leaf node, it recursively calls itself on the left and right subtrees of the root node, with the updated target sum (target sum minus root node\\u2019s value). It returns true if either of the recursive calls returns true, or false if both of them return false. This way, it explores all possible paths in the tree and returns true if any of them matches the target sum.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(h)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean hasPathSum(TreeNode root, int targetSum) {\\n        if(root == null){\\n            return false;\\n        }\\n        if(root.left == null && root.right == null){\\n            if((targetSum - root.val) == 0){\\n                return true;\\n            }else{\\n                return false;\\n            }\\n        }\\n        return hasPathSum(root.left,(targetSum - root.val)) || hasPathSum(root.right,(targetSum - root.val));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean hasPathSum(TreeNode root, int targetSum) {\\n        if(root == null){\\n            return false;\\n        }\\n        if(root.left == null && root.right == null){\\n            if((targetSum - root.val) == 0){\\n                return true;\\n            }else{\\n                return false;\\n            }\\n        }\\n        return hasPathSum(root.left,(targetSum - root.val)) || hasPathSum(root.right,(targetSum - root.val));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445571,
                "title": "simple-c-solution",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        if(root==NULL){\\n            return false;\\n        }\\n        if(root->left==NULL && root->right==NULL){\\n            return targetSum==root->val;\\n        }\\n        return hasPathSum(root->left,targetSum-root->val) || hasPathSum(root->right,targetSum-root->val);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        if(root==NULL){\\n            return false;\\n        }\\n        if(root->left==NULL && root->right==NULL){\\n            return targetSum==root->val;\\n        }\\n        return hasPathSum(root->left,targetSum-root->val) || hasPathSum(root->right,targetSum-root->val);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3294299,
                "title": "python3-100-fast-easiest-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**Usig DFS**\\n![image.png](https://assets.leetcode.com/users/images/58b332db-48fa-497b-8543-4275b77fc517_1678764586.376835.png)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- use dfs to get till leaf node.\\n- while traversing keep track of current sum.\\n- now when encountered leaf node check current sum and target sum, return true if equal else false.\\n- now we will also keep track of left and right returned values, if we find that from left subtree we\\'re getting answer then we will not traverse right sub-tree.\\n- this will help in redusing time by 50%.\\n- return answer found\\n# Complexity\\n- Time complexity: O(N/2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N/2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        def dfs_sum(curr=None, sumTill=0):\\n            if curr:\\n                sumTill += curr.val\\n                left = dfs_sum(curr.left, sumTill)\\n                right = False\\n                if not left:\\n                    right = dfs_sum(curr.right, sumTill)\\n                \\n                if curr.left == None and curr.right == None:\\n                    return sumTill == targetSum\\n                return left or right\\n            return False\\n        return dfs_sum(root)\\n```\\n # Please like and comment below ( \\u0361\\uD83D\\uDC41\\uFE0F\\u202F\\u035C\\u0296 \\u0361\\uD83D\\uDC41\\uFE0F)\\uD83D\\uDC4C",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        def dfs_sum(curr=None, sumTill=0):\\n            if curr:\\n                sumTill += curr.val\\n                left = dfs_sum(curr.left, sumTill)\\n                right = False\\n                if not left:\\n                    right = dfs_sum(curr.right, sumTill)\\n                \\n                if curr.left == None and curr.right == None:\\n                    return sumTill == targetSum\\n                return left or right\\n            return False\\n        return dfs_sum(root)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3193893,
                "title": "python-recursive-code-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        if root is None:\\n            return False\\n        if root.left is None and root.right is None and targetSum - root.val == 0:\\n            return True\\n        return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        if root is None:\\n            return False\\n        if root.left is None and root.right is None and targetSum - root.val == 0:\\n            return True\\n        return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2996017,
                "title": "1ms-java-recursive-solution-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean hasPathSum(TreeNode root, int targetSum) {\\n        if(root==null){\\n            return false;\\n        }\\n        if(root.left==null && root.right==null && targetSum==root.val){\\n            return true;\\n        }\\n\\n        return hasPathSum(root.left,targetSum-root.val) || hasPathSum(root.right,targetSum-root.val);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean hasPathSum(TreeNode root, int targetSum) {\\n        if(root==null){\\n            return false;\\n        }\\n        if(root.left==null && root.right==null && targetSum==root.val){\\n            return true;\\n        }\\n\\n        return hasPathSum(root.left,targetSum-root.val) || hasPathSum(root.right,targetSum-root.val);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2830351,
                "title": "java-dfs",
                "content": "If you like it pls upvote\\n```\\n\\n\\n    public boolean hasPathSum(TreeNode root, int targetSum) {\\n        if(root==null)  return false;\\n\\n        Deque<TreeNode> stack = new ArrayDeque<>();\\n        stack.push(root);\\n\\n        while(!stack.isEmpty()) {\\n            TreeNode curr = stack.pop();\\n\\n            if(curr.val == targetSum && curr.left==null && curr.right==null) {\\n                return true;\\n            }\\n\\n            if(curr.left!=null) {\\n                curr.left.val += curr.val;\\n                stack.push(curr.left);\\n            }\\n\\n            if(curr.right!=null) {\\n                curr.right.val += curr.val;\\n                stack.push(curr.right);\\n            }\\n        }\\n        return false;\\n    }\\n\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\n\\n\\n    public boolean hasPathSum(TreeNode root, int targetSum) {\\n        if(root==null)  return false;\\n\\n        Deque<TreeNode> stack = new ArrayDeque<>();\\n        stack.push(root);\\n\\n        while(!stack.isEmpty()) {\\n            TreeNode curr = stack.pop();\\n\\n            if(curr.val == targetSum && curr.left==null && curr.right==null) {\\n                return true;\\n            }\\n\\n            if(curr.left!=null) {\\n                curr.left.val += curr.val;\\n                stack.push(curr.left);\\n            }\\n\\n            if(curr.right!=null) {\\n                curr.right.val += curr.val;\\n                stack.push(curr.right);\\n            }\\n        }\\n        return false;\\n    }\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2765268,
                "title": "tree-traversal",
                "content": "```\\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        \\n        ans = [False]\\n        \\n        def tree_traversal(root, curr_sum, ans):\\n            curr_sum += root.val\\n    \\n            if root.left is None and root.right is None:\\n                if curr_sum == targetSum:\\n                    ans[0] = True\\n\\n            \\n            if root.left:\\n                tree_traversal(root.left, curr_sum, ans)\\n            \\n            if root.right:\\n                tree_traversal(root.right, curr_sum, ans)\\n        \\n        if root:\\n            tree_traversal(root, 0, ans)\\n        return ans[0]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        \\n        ans = [False]\\n        \\n        def tree_traversal(root, curr_sum, ans):\\n            curr_sum += root.val\\n    \\n            if root.left is None and root.right is None:\\n                if curr_sum == targetSum:\\n                    ans[0] = True\\n\\n            \\n            if root.left:\\n                tree_traversal(root.left, curr_sum, ans)\\n            \\n            if root.right:\\n                tree_traversal(root.right, curr_sum, ans)\\n        \\n        if root:\\n            tree_traversal(root, 0, ans)\\n        return ans[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2765163,
                "title": "one-lineeer",
                "content": "```\\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        return (root.val == targetSum) if (root and not root.left and not root.right) else (root and (self.hasPathSum(root.right, targetSum - root.val) or self.hasPathSum(root.left, targetSum - root.val)))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        return (root.val == targetSum) if (root and not root.left and not root.right) else (root and (self.hasPathSum(root.right, targetSum - root.val) or self.hasPathSum(root.left, targetSum - root.val)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2687829,
                "title": "java-recursive-easy-to-understand-100-faster",
                "content": "```\\nclass Solution {\\n    public boolean hasPathSum(TreeNode root, int targetSum) {\\n        traversal(root,targetSum);\\n        return res;\\n    }\\n    boolean res = false;\\n    public void traversal(TreeNode root, int targetSum) {\\n        if(root != null) {\\n            root.val = targetSum-root.val;\\n            if(root.left == null && root.right == null && root.val == 0) {\\n                res = true;\\n                return;\\n            }\\n            traversal(root.left, root.val);\\n            traversal(root.right, root.val);\\n        }\\n    }\\n}\\n```\\n\\nIf you like the solution please do upvote, Thanks in advance.",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public boolean hasPathSum(TreeNode root, int targetSum) {\\n        traversal(root,targetSum);\\n        return res;\\n    }\\n    boolean res = false;\\n    public void traversal(TreeNode root, int targetSum) {\\n        if(root != null) {\\n            root.val = targetSum-root.val;\\n            if(root.left == null && root.right == null && root.val == 0) {\\n                res = true;\\n                return;\\n            }\\n            traversal(root.left, root.val);\\n            traversal(root.right, root.val);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2658684,
                "title": "root-path-sum",
                "content": "bool hasPathSum(TreeNode* root, int sum) {\\n      if(root == nullptr) return false;\\nif(root->val == sum && root->right == nullptr && root->left == nullptr) return true;\\nif(root->left != nullptr) root->left->val += root->val;\\nif(root->right != nullptr) root->right->val += root->val;\\nreturn hasPathSum(root->left,sum) || hasPathSum(root->right,sum);\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "bool hasPathSum(TreeNode* root, int sum) {\\n      if(root == nullptr) return false;\\nif(root->val == sum && root->right == nullptr && root->left == nullptr) return true;\\nif(root->left != nullptr) root->left->val += root->val;\\nif(root->right != nullptr) root->right->val += root->val;\\nreturn hasPathSum(root->left,sum) || hasPathSum(root->right,sum);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2658505,
                "title": "112-path-sum-python",
                "content": "Python:\\n```\\n    def hasPathSum(self, root, sum):\\n        if not root:\\n            return False\\n        if not root.left and not root.right and root.val == sum:\\n            return True\\n        sum -= root.val\\n        return self.hasPathSum(root.left, sum) or self.hasPathSum(root.right, sum)\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n    def hasPathSum(self, root, sum):\\n        if not root:\\n            return False\\n        if not root.left and not root.right and root.val == sum:\\n            return True\\n        sum -= root.val\\n        return self.hasPathSum(root.left, sum) or self.hasPathSum(root.right, sum)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2657607,
                "title": "daily-leetcode-solution-easy-solution-in-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool preOrderTraversal(TreeNode* root,int targetSum)\\n    {\\n        if(root==NULL) return false;\\n        if(root->right==NULL&&root->left==NULL)\\n        {\\n            if(root->val==targetSum) return true;\\n        }\\n        bool left=preOrderTraversal(root->left,targetSum-(root->val));\\n        bool right=preOrderTraversal(root->right,targetSum-(root->val));\\n        return left|right;\\n    }\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        return preOrderTraversal(root,targetSum);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool preOrderTraversal(TreeNode* root,int targetSum)\\n    {\\n        if(root==NULL) return false;\\n        if(root->right==NULL&&root->left==NULL)\\n        {\\n            if(root->val==targetSum) return true;\\n        }\\n        bool left=preOrderTraversal(root->left,targetSum-(root->val));\\n        bool right=preOrderTraversal(root->right,targetSum-(root->val));\\n        return left|right;\\n    }\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        return preOrderTraversal(root,targetSum);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2657586,
                "title": "daily-leetcoding-challenge-october-day-4",
                "content": "This problem is the Daily LeetCoding Challenge for October, Day 4.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/path-sum/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion\n\n  \n**Approach 2:** Iterations\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/path-sum/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 2537117,
                "title": "javascript-dfs-with-comments",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @param {number} targetSum\\n * @return {boolean}\\n */\\nconst hasPathSum = (root, targetSum) => {\\n    // DFS\\n    // Relatively easy to understand\\n    if(!root) return false; // Base case if we DFS all the way to the end, but dont find an answer\\n    \\n    // Condition if true\\n    // Since we substract the node value from the targetSum as we DFS\\n    // If we get to a node with no left or right AND the node.val === targetSum, we found an answer\\n\\t// Because if node.val === targetSum, that means if we subtract the two, it is 0\\n    if(!root.left && !root.right && targetSum === root.val) return true;\\n    \\n    // We just need to find 1, so if either side returns true, it is true\\n    return hasPathSum(root.left, targetSum - root.val) || hasPathSum(root.right, targetSum - root.val);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @param {number} targetSum\\n * @return {boolean}\\n */\\nconst hasPathSum = (root, targetSum) => {\\n    // DFS\\n    // Relatively easy to understand\\n    if(!root) return false; // Base case if we DFS all the way to the end, but dont find an answer\\n    \\n    // Condition if true\\n    // Since we substract the node value from the targetSum as we DFS\\n    // If we get to a node with no left or right AND the node.val === targetSum, we found an answer\\n\\t// Because if node.val === targetSum, that means if we subtract the two, it is 0\\n    if(!root.left && !root.right && targetSum === root.val) return true;\\n    \\n    // We just need to find 1, so if either side returns true, it is true\\n    return hasPathSum(root.left, targetSum - root.val) || hasPathSum(root.right, targetSum - root.val);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2379258,
                "title": "accepted-dfs-iterative-java",
                "content": "```\\nclass Solution {\\n    public boolean hasPathSum(TreeNode root, int targetSum) {\\n        if(root==null)  return false;\\n        \\n        Deque<TreeNode> stack = new ArrayDeque<TreeNode>();\\n        stack.push(root);\\n        \\n        while(!stack.isEmpty()) {\\n            TreeNode curr = stack.pop();\\n            \\n            if(curr.val == targetSum && curr.left==null && curr.right==null)    return true;\\n            \\n            if(curr.left!=null) {\\n                curr.left.val += curr.val;\\n                stack.push(curr.left);\\n            }\\n            \\n            if(curr.right!=null) {\\n                curr.right.val += curr.val;\\n                stack.push(curr.right);\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Depth-First Search",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    public boolean hasPathSum(TreeNode root, int targetSum) {\\n        if(root==null)  return false;\\n        \\n        Deque<TreeNode> stack = new ArrayDeque<TreeNode>();\\n        stack.push(root);\\n        \\n        while(!stack.isEmpty()) {\\n            TreeNode curr = stack.pop();\\n            \\n            if(curr.val == targetSum && curr.left==null && curr.right==null)    return true;\\n            \\n            if(curr.left!=null) {\\n                curr.left.val += curr.val;\\n                stack.push(curr.left);\\n            }\\n            \\n            if(curr.right!=null) {\\n                curr.right.val += curr.val;\\n                stack.push(curr.right);\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2176648,
                "title": "python3-short-4lines-dfs",
                "content": "```\\nclass Solution:\\n    def hasPathSum(self, root: TreeNode, sum: int) -> bool:\\n        if not root:\\n            return False\\n        if root.val == sum and not  root.left and not root.right:\\n            return True\\n        return self.hasPathSum(root.left, sum-root.val) or self.hasPathSum(root.right, sum-root.val)\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def hasPathSum(self, root: TreeNode, sum: int) -> bool:\\n        if not root:\\n            return False\\n        if root.val == sum and not  root.left and not root.right:\\n            return True\\n        return self.hasPathSum(root.left, sum-root.val) or self.hasPathSum(root.right, sum-root.val)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2013138,
                "title": "c-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        if(root == NULL)\\n            return false;\\n        if(root->left == NULL && root->right == NULL && targetSum  - root->val == 0)\\n            return true;\\n        else\\n            return hasPathSum(root->left, targetSum - root->val) || hasPathSum(root->right, targetSum - root->val) ;\\n       }\\n\\t};\\n\\t\\n\\nTime complexity  --> O(n) \\nspace complexity --> O(log n)",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        if(root == NULL)\\n            return false;\\n        if(root->left == NULL && root->right == NULL && targetSum  - root->val == 0)\\n            return true;\\n        else\\n            return hasPathSum(root->left, targetSum - root->val) || hasPathSum(root->right, targetSum - root->val) ;\\n       }",
                "codeTag": "Java"
            },
            {
                "id": 1746355,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public boolean hasPathSum(TreeNode root, int targetSum) {\\n        if(root==null)return false;\\n        if(root.left==null &&root.right==null){\\n           return root.val==targetSum;\\n        }\\n        return hasPathSum(root.left,targetSum-root.val)||hasPathSum(root.right,targetSum-root.val);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean hasPathSum(TreeNode root, int targetSum) {\\n        if(root==null)return false;\\n        if(root.left==null &&root.right==null){\\n           return root.val==targetSum;\\n        }\\n        return hasPathSum(root.left,targetSum-root.val)||hasPathSum(root.right,targetSum-root.val);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1741659,
                "title": "c-fast-solution-dfs-recursive-approach-easy-to-understand",
                "content": "class Solution {\\npublic:\\n\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        if(root==NULL)\\n            return false;\\n        else  \\n        if(root->left==NULL && root->right==NULL) {\\n             if(targetSum-root->val==0)\\n                return true;\\n            return false;\\n        }\\n            bool l=hasPathSum(root->left,targetSum-root->val);\\n            bool r=hasPathSum(root->right,targetSum-root->val);\\n     return l || r;\\n    }\\n};",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        if(root==NULL)\\n            return false;\\n        else  \\n        if(root->left==NULL && root->right==NULL) {\\n             if(targetSum-root->val==0)\\n                return true;\\n            return false;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1583269,
                "title": "python3-easy-fast-recursive-solution",
                "content": "```\\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        if not root: return False\\n        if root and not root.left and not root.right: return root.val == targetSum\\n        return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        if not root: return False\\n        if root and not root.left and not root.right: return root.val == targetSum\\n        return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1560896,
                "title": "python3-simple-solution-with-explanation",
                "content": "**Idea:**\\nFor every node we visit we add its value to the path_sum, and:\\nIf its a leaf, we check if its `path_sum` is equal to the `targetSum`,\\notherwise, we continue checking with its left and right nodes.\\n\\n**Time complexity:** O(n) where n is the number of nodes in the tree.\\n**Space complexity:** O(h) where h is the height of the tree (in worst case h=n).\\n\\n```\\ndef hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n\\n        def inorder(root, path_sum):\\n            if not root:\\n                return False\\n            \\n            path_sum+=root.val\\n            \\n            if not root.left and not root.right:\\n                return path_sum==targetSum\\n                \\n            return inorder(root.left, path_sum) or inorder(root.right, path_sum)\\n             \\n        return inorder(root, 0)\\n```\\n\\n*Thanx for reading, please **upvote** if it helped you :)*",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n\\n        def inorder(root, path_sum):\\n            if not root:\\n                return False\\n            \\n            path_sum+=root.val\\n            \\n            if not root.left and not root.right:\\n                return path_sum==targetSum\\n                \\n            return inorder(root.left, path_sum) or inorder(root.right, path_sum)\\n             \\n        return inorder(root, 0)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1522254,
                "title": "simple-to-understand-using-recursion-with-comments",
                "content": "**Thumbs up if you find this helpful** \\uD83D\\uDC4D\\n\\n```\\npublic class Solution {\\n    public bool HasPathSum(TreeNode root, int targetSum) {\\n        return Search(root, targetSum);\\n    }\\n    \\n    public bool Search(TreeNode node, int targetSum) {\\n        if (node == null) {\\n            return false;\\n        }\\n        \\n        // Determine the current sum\\n        targetSum = targetSum - node.val;\\n        \\n        // Since this is a root-to-leaf check, evaluate for the \\n        // success condition when both left and right nodes are null        \\n        if (node.left == null && node.right == null) {\\n            return targetSum == 0;\\n        }\\n        \\n        // Keep exploring along branches finding the target sum\\n        return Search(node.left, targetSum)\\n            || Search(node.right, targetSum);      \\n    }    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public bool HasPathSum(TreeNode root, int targetSum) {\\n        return Search(root, targetSum);\\n    }\\n    \\n    public bool Search(TreeNode node, int targetSum) {\\n        if (node == null) {\\n            return false;\\n        }\\n        \\n        // Determine the current sum\\n        targetSum = targetSum - node.val;\\n        \\n        // Since this is a root-to-leaf check, evaluate for the \\n        // success condition when both left and right nodes are null        \\n        if (node.left == null && node.right == null) {\\n            return targetSum == 0;\\n        }\\n        \\n        // Keep exploring along branches finding the target sum\\n        return Search(node.left, targetSum)\\n            || Search(node.right, targetSum);      \\n    }    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1467761,
                "title": "javascript-solution-with-stack",
                "content": "Solving this question with recursion is too simple. Why not implement a stack instead???\\n\\nStrategy: Add node and current total of the path we are traversing into the stack. \\n\\t\\t\\t\\tKeep track of where we are in the tree using a variable called curr\\n\\t\\t\\t\\tWhen we have no left or right children, we check to see if value in the path is equal to target value.\\n```\\nvar hasPathSum = function(root, targetSum) {\\n//check to see if we are given an empty tree\\n    if (!root)return false\\n    const stack =[]\\n\\t\\n\\t//in our current variable, we will keep track of the tree in 0th index, and keep current sum of path at 1st index\\n     let curr=[root,0]\\n\\t \\n\\t /* our stop conditions for while loop are:\\n\\t 1.) when we have no elements in the stack\\n\\t 2.) since our stack is initially empty, we will add in when curr is null as a stop condition */\\n\\n    while (curr || stack.length){\\n\\t/* we want to keep adding to our stack while traversing left. We will stop when we add a null child to our\\n\\tstack, since that means we are at the leftmost child of current subtree*/\\n       while (curr && curr[0]){\\n           let [node,val]=curr\\n           stack.push([node,val+node.val])\\n           curr=[node.left,val+node.val]\\n       }\\n\\t   /*because curr has an empty child, that means we have went 1 level too far in the tree, in order\\n\\t   to get our last node that had a value in the tree, we just pop off the last item in the stack*/\\n          curr=stack.pop()\\n\\n   /* we need to figure out if the node we are currently at-which we know has no left children, is a leaf,\\n   meaning it has no right children as well. So we set a variable rightNode as either the right node, or null */\\n        let rightNode= curr[0]? curr[0].right :null\\n        if (rightNode === null){\\n\\t\\t/*we need to ensure we are at a leaf, and if we are, we will see if current path sum is equal to target */\\n            if(curr[0].left===null && curr[1]===targetSum){\\n                return true\\n            }\\n\\t\\t\\t/*since we are at a leaf node, we cannot traverse any further, we will instead set curr to null so that\\n\\t\\t\\twe bypass the inner while loop and pop off the stack to previous node */\\n\\t\\t\\tcurr=null\\n        } else {\\n\\t\\t//since we do have a right node, we want to traverse down to the bottom of the graph before checking sum\\n            curr=[rightNode, curr[1]]        \\n        }   \\n\\t\\t\\n    } return false \\n}",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search",
                    "Iterator"
                ],
                "code": "Solving this question with recursion is too simple. Why not implement a stack instead???\\n\\nStrategy: Add node and current total of the path we are traversing into the stack. \\n\\t\\t\\t\\tKeep track of where we are in the tree using a variable called curr\\n\\t\\t\\t\\tWhen we have no left or right children, we check to see if value in the path is equal to target value.\\n```\\nvar hasPathSum = function(root, targetSum) {\\n//check to see if we are given an empty tree\\n    if (!root)return false\\n    const stack =[]\\n\\t\\n\\t//in our current variable, we will keep track of the tree in 0th index, and keep current sum of path at 1st index\\n     let curr=[root,0]\\n\\t \\n\\t /* our stop conditions for while loop are:\\n\\t 1.) when we have no elements in the stack\\n\\t 2.) since our stack is initially empty, we will add in when curr is null as a stop condition */\\n\\n    while (curr || stack.length){\\n\\t/* we want to keep adding to our stack while traversing left. We will stop when we add a null child to our\\n\\tstack, since that means we are at the leftmost child of current subtree*/\\n       while (curr && curr[0]){\\n           let [node,val]=curr\\n           stack.push([node,val+node.val])\\n           curr=[node.left,val+node.val]\\n       }\\n\\t   /*because curr has an empty child, that means we have went 1 level too far in the tree, in order\\n\\t   to get our last node that had a value in the tree, we just pop off the last item in the stack*/\\n          curr=stack.pop()\\n\\n   /* we need to figure out if the node we are currently at-which we know has no left children, is a leaf,\\n   meaning it has no right children as well. So we set a variable rightNode as either the right node, or null */\\n        let rightNode= curr[0]? curr[0].right :null\\n        if (rightNode === null){\\n\\t\\t/*we need to ensure we are at a leaf, and if we are, we will see if current path sum is equal to target */\\n            if(curr[0].left===null && curr[1]===targetSum){\\n                return true\\n            }\\n\\t\\t\\t/*since we are at a leaf node, we cannot traverse any further, we will instead set curr to null so that\\n\\t\\t\\twe bypass the inner while loop and pop off the stack to previous node */\\n\\t\\t\\tcurr=null\\n        } else {\\n\\t\\t//since we do have a right node, we want to traverse down to the bottom of the graph before checking sum\\n            curr=[rightNode, curr[1]]        \\n        }   \\n\\t\\t\\n    } return false \\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 1377783,
                "title": "c-short-and-easy-recursion",
                "content": "**If you liked this solution, Please Upvote. Thanks**\\n\\n```\\n\\tbool hasPathSum(TreeNode* root, int sum) {\\n        if(root==nullptr) return false;\\n        if(root->left==nullptr and root->right==nullptr)\\n            if(sum==root->val) return true;\\n        return hasPathSum(root->left,sum-(root->val)) or hasPathSum(root->right,sum-(root->val));\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tbool hasPathSum(TreeNode* root, int sum) {\\n        if(root==nullptr) return false;\\n        if(root->left==nullptr and root->right==nullptr)\\n            if(sum==root->val) return true;\\n        return hasPathSum(root->left,sum-(root->val)) or hasPathSum(root->right,sum-(root->val));\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1313180,
                "title": "easy-python-solution-98-77",
                "content": "Runtime: 32 ms, faster than 98.77% of Python3 online submissions for Path Sum.\\nMemory Usage: 15.7 MB, less than 92.65% of Python3 online submissions for Path Sum.\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def hasPathSum(self, root: TreeNode, targetSum: int) -> bool:\\n        def h(node,ans):\\n            if(node):\\n                ans-=node.val\\n            else:\\n                return None\\n            if(ans==0 and (node.left==node.right==None)):\\n                return True\\n            else:\\n                return h(node.left,ans) or h(node.right,ans)\\n        return h(root,targetSum)",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "Runtime: 32 ms, faster than 98.77% of Python3 online submissions for Path Sum.\\nMemory Usage: 15.7 MB, less than 92.65% of Python3 online submissions for Path Sum.\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def hasPathSum(self, root: TreeNode, targetSum: int) -> bool:\\n        def h(node,ans):\\n            if(node):\\n                ans-=node.val\\n            else:\\n                return None\\n            if(ans==0 and (node.left==node.right==None)):\\n                return True\\n            else:\\n                return h(node.left,ans) or h(node.right,ans)\\n        return h(root,targetSum)",
                "codeTag": "Java"
            },
            {
                "id": 1062745,
                "title": "c-simple-recursive-solution-faster-then-95",
                "content": "```\\nbool hasPathSum(struct TreeNode* root, int targetSum){\\n    if (root == NULL) return false;\\n    \\n    // root node is a leaf\\n    if(root->left == NULL && root->right== NULL){\\n        if(root->val == targetSum){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n    }\\n    return ((hasPathSum(root->left,targetSum - root->val))||\\n            (hasPathSum(root->right,targetSum - root->val)));\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nbool hasPathSum(struct TreeNode* root, int targetSum){\\n    if (root == NULL) return false;\\n    \\n    // root node is a leaf\\n    if(root->left == NULL && root->right== NULL){\\n        if(root->val == targetSum){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n    }\\n    return ((hasPathSum(root->left,targetSum - root->val))||\\n            (hasPathSum(root->right,targetSum - root->val)));\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1039799,
                "title": "elegant-recursive-java-solution",
                "content": "\\n```\\n    public boolean hasPathSum(TreeNode root, int targetSum) {\\n        if (root == null) return false;\\n        if (root.val == targetSum && root.left == null && root.right == null) return true;\\n        return hasPathSum(root.left, targetSum - root.val) || hasPathSum(root.right, targetSum - root.val);\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\n    public boolean hasPathSum(TreeNode root, int targetSum) {\\n        if (root == null) return false;\\n        if (root.val == targetSum && root.left == null && root.right == null) return true;\\n        return hasPathSum(root.left, targetSum - root.val) || hasPathSum(root.right, targetSum - root.val);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 779553,
                "title": "c-recursion-fast-then-94-of-solution-easy-to-understand",
                "content": "**Please UP Vote this solution if you like**\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n\\n    bool dfs(TreeNode *root,int sum)\\n    {\\n        if(!root)\\n            return 0;\\n        \\n        if(root->left==NULL && root->right==NULL && sum-root->val==0)// If this is a leaf node and sum-leafNodeValue==0 return True;\\n            return 1;\\n        \\n        return dfs(root->left,sum-root->val) || dfs(root->right,sum-root->val);//If left or right sub tree satisfy the condition the return true\\n    }\\n    \\n    bool hasPathSum(TreeNode* root, int sum) {\\n        return dfs(root,sum);\\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n\\n    bool dfs(TreeNode *root,int sum)\\n    {\\n        if(!root)\\n            return 0;\\n        \\n        if(root->left==NULL && root->right==NULL && sum-root->val==0)// If this is a leaf node and sum-leafNodeValue==0 return True;\\n            return 1;\\n        \\n        return dfs(root->left,sum-root->val) || dfs(root->right,sum-root->val);//If left or right sub tree satisfy the condition the return true\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 689922,
                "title": "simple-iterative-solution-c",
                "content": "Iterative Solution\\n```\\n    bool hasPathSum(TreeNode* root, int sum) {\\n        vector<TreeNode*> my_stack;\\n        my_stack.emplace_back(root);\\n        while(!my_stack.empty()){\\n            root = my_stack.back();\\n            my_stack.pop_back();\\n            if(root){\\n                if(!root->left&&!root->right&&root->val==sum) return true; //check terminating condition only at leaf node \\n                if(root->right){\\n                    root->right->val += root->val;\\n                    my_stack.emplace_back(root->right);\\n                }  \\n                if(root->left){\\n                    root->left->val += root->val;\\n                    my_stack.emplace_back(root->left);\\n                }  \\n            }\\n            \\n        }\\n        return false;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Iterator"
                ],
                "code": "```\\n    bool hasPathSum(TreeNode* root, int sum) {\\n        vector<TreeNode*> my_stack;\\n        my_stack.emplace_back(root);\\n        while(!my_stack.empty()){\\n            root = my_stack.back();\\n            my_stack.pop_back();\\n            if(root){\\n                if(!root->left&&!root->right&&root->val==sum) return true; //check terminating condition only at leaf node \\n                if(root->right){\\n                    root->right->val += root->val;\\n                    my_stack.emplace_back(root->right);\\n                }  \\n                if(root->left){\\n                    root->left->val += root->val;\\n                    my_stack.emplace_back(root->left);\\n                }  \\n            }\\n            \\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 683862,
                "title": "in-rust",
                "content": "```\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\n\\nimpl Solution {\\n    pub fn has_path_sum(root: Option<Rc<RefCell<TreeNode>>>, sum: i32) -> bool {\\n        if let Some(n) = root {\\n            let node = n.borrow();\\n            if node.left.is_none() && node.right.is_none() && node.val == sum {\\n                return true\\n            }\\n            return Solution::has_path_sum(node.left.clone(), sum - node.val) ||\\n                    Solution::has_path_sum(node.right.clone(), sum - node.val)\\n        }\\n        return false\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\n\\nimpl Solution {\\n    pub fn has_path_sum(root: Option<Rc<RefCell<TreeNode>>>, sum: i32) -> bool {\\n        if let Some(n) = root {\\n            let node = n.borrow();\\n            if node.left.is_none() && node.right.is_none() && node.val == sum {\\n                return true\\n            }\\n            return Solution::has_path_sum(node.left.clone(), sum - node.val) ||\\n                    Solution::has_path_sum(node.right.clone(), sum - node.val)\\n        }\\n        return false\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 673154,
                "title": "java-dfs-runtime-faster-100",
                "content": "```\\nclass Solution {\\n    public boolean hasPathSum(TreeNode root, int sum) {\\n        if (root == null) {\\n            return false;\\n        }\\n        \\n        sum -= root.val;\\n        if (sum == 0 && root.left == null && root.right == null) {\\n            return true;\\n        }\\n        \\n        return hasPathSum(root.left, sum) || hasPathSum(root.right, sum);\\n    }    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean hasPathSum(TreeNode root, int sum) {\\n        if (root == null) {\\n            return false;\\n        }\\n        \\n        sum -= root.val;\\n        if (sum == 0 && root.left == null && root.right == null) {\\n            return true;\\n        }\\n        \\n        return hasPathSum(root.left, sum) || hasPathSum(root.right, sum);\\n    }    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 519579,
                "title": "c-iterative-solution",
                "content": "```\\npublic class Solution {\\n    public bool HasPathSum(TreeNode root, int sum) {\\n        if (root == null)\\n\\t\\t\\treturn false;\\n\\n\\t    var stack = new Stack<(TreeNode Node, int Sum)>();\\n\\t    stack.Push((root, root.val));\\n\\t    while (stack.Count != 0) {\\n\\t\\t    var p = stack.Pop();\\n            TreeNode node = p.Node;\\n            int psum = p.Sum;\\n            \\n\\t\\t\\tif (node.right != null)\\n\\t\\t        stack.Push((node.right, node.right.val+psum));\\t\\t\\t\\n\\t\\t\\tif (node.left != null)\\n\\t\\t\\t\\tstack.Push((node.left, node.left.val+psum));\\n            \\n\\t\\t\\tif (node.left == null && node.right == null && psum == sum)\\n                return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Depth-First Search",
                    "Iterator"
                ],
                "code": "```\\npublic class Solution {\\n    public bool HasPathSum(TreeNode root, int sum) {\\n        if (root == null)\\n\\t\\t\\treturn false;\\n\\n\\t    var stack = new Stack<(TreeNode Node, int Sum)>();\\n\\t    stack.Push((root, root.val));\\n\\t    while (stack.Count != 0) {\\n\\t\\t    var p = stack.Pop();\\n            TreeNode node = p.Node;\\n            int psum = p.Sum;\\n            \\n\\t\\t\\tif (node.right != null)\\n\\t\\t        stack.Push((node.right, node.right.val+psum));\\t\\t\\t\\n\\t\\t\\tif (node.left != null)\\n\\t\\t\\t\\tstack.Push((node.left, node.left.val+psum));\\n            \\n\\t\\t\\tif (node.left == null && node.right == null && psum == sum)\\n                return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 466765,
                "title": "simple-recursion",
                "content": "```\\npublic boolean hasPathSum(TreeNode root, int sum) {\\n        if(root==null){\\n            return false;\\n        }else if(root.left==null && root.right==null && root.val == sum){\\n            return true;\\n        }\\n        return hasPathSum(root.left, sum-(root.val)) || hasPathSum(root.right, sum-(root.val));\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\npublic boolean hasPathSum(TreeNode root, int sum) {\\n        if(root==null){\\n            return false;\\n        }else if(root.left==null && root.right==null && root.val == sum){\\n            return true;\\n        }\\n        return hasPathSum(root.left, sum-(root.val)) || hasPathSum(root.right, sum-(root.val));\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 320633,
                "title": "c-88-beat-easy-win-o-n-recursive-solution-logic",
                "content": "```\\nclass Solution {\\npublic:\\n    bool hasPathSum(TreeNode* root, int sum) {        \\n        if (root == NULL) { return false; }\\n        sum -= root->val;\\n        if (root->left == NULL && root->right == NULL && sum == 0) { return true; }\\n        if (root->left  != NULL) { if (hasPathSum(root->left,  sum)) { return true; } }\\n        if (root->right != NULL) { if (hasPathSum(root->right, sum)) { return true; } }\\n        return false;\\n    }\\n};\\n```\\n\\nThe logic checks out.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool hasPathSum(TreeNode* root, int sum) {        \\n        if (root == NULL) { return false; }\\n        sum -= root->val;\\n        if (root->left == NULL && root->right == NULL && sum == 0) { return true; }\\n        if (root->left  != NULL) { if (hasPathSum(root->left,  sum)) { return true; } }\\n        if (root->right != NULL) { if (hasPathSum(root->right, sum)) { return true; } }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 315089,
                "title": "simple-rust-recursive-solution-faster-than-100-00-of-rust-online-submissions",
                "content": "```\\nimpl Solution {\\n    pub fn has_path_sum(root: Option<Rc<RefCell<TreeNode>>>, sum: i32) -> bool {\\n        Solution::helper(&root, sum)\\n    }\\n\\n    fn helper(root: &Option<Rc<RefCell<TreeNode>>>, sum: i32) -> bool {\\n        if let Some(data) = root {\\n            let node = data.borrow_mut();\\n            if node.left.is_none() && node.right.is_none() { // is leaf\\n                return sum == node.val;\\n            }\\n            return Solution::helper(&node.left, sum - node.val)\\n                || Solution::helper(&node.right, sum - node.val);\\n        }\\n        false\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimpl Solution {\\n    pub fn has_path_sum(root: Option<Rc<RefCell<TreeNode>>>, sum: i32) -> bool {\\n        Solution::helper(&root, sum)\\n    }\\n\\n    fn helper(root: &Option<Rc<RefCell<TreeNode>>>, sum: i32) -> bool {\\n        if let Some(data) = root {\\n            let node = data.borrow_mut();\\n            if node.left.is_none() && node.right.is_none() { // is leaf\\n                return sum == node.val;\\n            }\\n            return Solution::helper(&node.left, sum - node.val)\\n                || Solution::helper(&node.right, sum - node.val);\\n        }\\n        false\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 157106,
                "title": "easy-4-lines-scala",
                "content": "```\\n  def hasPathSum(root: TreeNode, sum: Int): Boolean = (root, sum) match {\\n    case (null, _) => false\\n    case (r, s) if r.left == null && r.right == null => r.value == sum\\n    case (r, s) =>\\n      hasPathSum(r.left, sum - r.value) || hasPathSum(r.right, sum - r.value)\\n  }\\n```",
                "solutionTags": [],
                "code": "```\\n  def hasPathSum(root: TreeNode, sum: Int): Boolean = (root, sum) match {\\n    case (null, _) => false\\n    case (r, s) if r.left == null && r.right == null => r.value == sum\\n    case (r, s) =>\\n      hasPathSum(r.left, sum - r.value) || hasPathSum(r.right, sum - r.value)\\n  }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 36361,
                "title": "3-lines-accepted-java-solution",
                "content": "```\\nclass Solution \\n{\\n    public boolean hasPathSum(TreeNode root, int sum) \\n    {  \\n        if (root == null) return false;\\n        if (root.val == sum && root.left == null && root.right == null) return true;\\n        return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\n    public boolean hasPathSum(TreeNode root, int sum) \\n    {  \\n        if (root == null) return false;\\n        if (root.val == sum && root.left == null && root.right == null) return true;\\n        return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 36428,
                "title": "java-3-line-easy-to-understand-1-ms",
                "content": "```\\n    public boolean hasPathSum(TreeNode root, int sum) {\\n        if(root==null)return false;\\n        if(sum-root.val==0 && root.left==null && root.right==null)return true;\\n        return hasPathSum(root.left,sum-root.val) || hasPathSum(root.right,sum-root.val);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public boolean hasPathSum(TreeNode root, int sum) {\\n        if(root==null)return false;\\n        if(sum-root.val==0 && root.left==null && root.right==null)return true;\\n        return hasPathSum(root.left,sum-root.val) || hasPathSum(root.right,sum-root.val);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 36499,
                "title": "one-line-c-solution",
                "content": "class Solution {\\npublic:\\n    bool hasPathSum(TreeNode* root, int sum) {\\n        return root && ((!root->left && !root->right && root->val == sum) || hasPathSum(root->left, sum - root->val) || hasPathSum(root->right, sum - root->val));\\n    }\\n};",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    bool hasPathSum(TreeNode* root, int sum) {\\n        return root && ((!root->left && !root->right && root->val == sum) || hasPathSum(root->left, sum - root->val) || hasPathSum(root->right, sum - root->val));\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 36537,
                "title": "c-bfs-solution",
                "content": "    class Solution {\\n    public:\\n        bool hasPathSum(TreeNode* root, int sum) {\\n            if(root == NULL) return false;\\n            queue<TreeNode*> myqueue;\\n            myqueue.push(root);\\n            while(!myqueue.empty()){\\n                TreeNode* cur = myqueue.front();\\n                myqueue.pop();\\n                if(cur->left != NULL){\\n                    cur->left->val+=cur->val;\\n                    myqueue.push(cur->left);\\n                }\\n                if(cur->right != NULL){\\n                    cur->right->val+=cur->val;\\n                    myqueue.push(cur->right);\\n                }\\n                if(cur->left == NULL && cur->right ==NULL && cur->val == sum) return true;\\n            }\\n            return false;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        bool hasPathSum(TreeNode* root, int sum) {\\n            if(root == NULL) return false;\\n            queue<TreeNode*> myqueue;\\n            myqueue.push(root);\\n            while(!myqueue.empty()){\\n                TreeNode* cur = myqueue.front();\\n                myqueue.pop();\\n                if(cur->left != NULL){\\n                    cur->left->val+=cur->val;\\n                    myqueue.push(cur->left);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 36546,
                "title": "c-12ms-recursive-iterative-solutions",
                "content": "    class Solution {\\n    public:\\n    bool hasPathSum(TreeNode* root, int sum) {\\n        //return solution1(root, sum);        //recursive\\n        return solution2(root, sum);        //iterative\\n    }\\n    private:\\n    bool solution1(TreeNode *n, int sum){\\n        if(!n) return false;\\n        if(!n->left && !n->right) return sum - n->val == 0;\\n        return solution1(n->left, sum - n->val) || solution1(n->right, sum - n->val);\\n    }\\n    bool solution2(TreeNode *n, int sum){\\n        if(!n) return false;\\n        stack<TreeNode *> st;\\n        TreeNode *cur = n, *pre;\\n        while(cur || !st.empty()){\\n            while(cur){\\n                st.push(cur);\\n                sum -= cur->val;\\n                cur = cur->left;\\n            }\\n            cur = st.top();\\n            if(!cur->left && !cur->right && !sum) return true;\\n            if(cur->right && pre != cur->right) cur = cur->right;\\n            else{\\n                st.pop();\\n                sum += cur->val;\\n                pre = cur;\\n                cur = NULL;\\n            }\\n        }\\n        return false;\\n    }\\n    };",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n    public:\\n    bool hasPathSum(TreeNode* root, int sum) {\\n        //return solution1(root, sum);        //recursive\\n        return solution2(root, sum);        //iterative\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 36590,
                "title": "simple-recursive-solution-in-ruby",
                "content": "    def has_path_sum(root, sum)\\n      return false if root.nil?\\n    \\n      if root.val == sum && root.left.nil? && root.right.nil?\\n        return true\\n      end\\n      \\n      has_path_sum(root.left, sum - root.val) || has_path_sum(root.right, sum - root.val)\\n    end",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "    def has_path_sum(root, sum)\\n      return false if root.nil?\\n    \\n      if root.val == sum && root.left.nil? && root.right.nil?\\n        return true\\n      end\\n      \\n      has_path_sum(root.left, sum - root.val) || has_path_sum(root.right, sum - root.val)\\n    end",
                "codeTag": "Python3"
            },
            {
                "id": 36599,
                "title": "8-ms-c-solution-one-line-of-code",
                "content": "    bool hasPathSum(struct TreeNode* root, int sum) {\\n        return !root? false: (root->right || root->left)? hasPathSum(root->left, sum-root->val)||hasPathSum(root->right, sum-root->val):sum==root->val ;\\n    }",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "    bool hasPathSum(struct TreeNode* root, int sum) {\\n        return !root? false: (root->right || root->left)? hasPathSum(root->left, sum-root->val)||hasPathSum(root->right, sum-root->val):sum==root->val ;\\n    }",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1565659,
                "content": [
                    {
                        "username": "dong12",
                        "content": "why should 'input [],0'   return false?  Isn't it true?"
                    },
                    {
                        "username": "mayankagarwal2402",
                        "content": "[@AKA_RAN](/AKA_RAN) now you\\'re just devising an argument to support the faulty somehow. To counter your argument I\\'d say \"the given input(zero nodes) satisfies the target(zero) already hence it should have been true\". This question should\\'ve focused on testing my analytical and coding skills and not my grammatical skills. "
                    },
                    {
                        "username": "garyyaoresearch",
                        "content": "Problem statement not specific enough and both your and relies\\' interpretation are possible. That case messes up the most elegant solution"
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "null != 0"
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "If you don\\'t have anything i.e. positive, negative or zero. Then how someone can achieve any target."
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "There has to be some path. In case of no nodes, there is no path. The null path isn't a path."
                    },
                    {
                        "username": "Jinlong",
                        "content": "       1\\n2            *\\n\\nThe struct is like above, and the sum of  right path is 1. Why the output is false?\\n\\nAdditional:\\n\\nFind another problem: the output of \"{1}, 1\" is true......\\n\\nwhy....."
                    },
                    {
                        "username": "nghiadq",
                        "content": "A leaf is a node with no children. in this case 1 is not a leaf because have children 2, 2 is a leaf"
                    },
                    {
                        "username": "obiwon84",
                        "content": "Just a suggestion but the [] 0 test case makes you create a helper method or add additional complexity for no real gain. Could we perhaps delete that test case?\\n\\nIn all honesty it is rather ambigious if [] 0 should return false or true as there is a path that sums to nothing, the null path. Removing this test case would also remove that ambiguity."
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "\"0\" is not NULL. It is real value. Instead of zero it can be any positive or negative value also.\\nTherefore don\\'t consider zero as NULL"
                    },
                    {
                        "username": "slovic",
                        "content": "It depends of usecase... but suggested behavior is more strict, and thou it should be preferred. From implementation point of view it is even simpler to implement it with current spec, because you can reuse top level behavior to left and right nodes (if they are nulls then result is false no matter what so you can call `hasPathSum(root.left, targetSum-root.value)` and if left was null it will return good result."
                    },
                    {
                        "username": "ravichandrae",
                        "content": "This problem has a test case for testing whether there is any path sum 0 for an empty binary tree.\\n{},0\\n\\nIt expects the result as false. But I think it's more intuitive to state the result as true."
                    },
                    {
                        "username": "suraj813",
                        "content": "Root node 1 has 2 children - 2 & None\\nPathSum_1 = 1+2 = 3\\nPathSum_2 = 1+None = 1\\n\\nThe expected answer is false. Is PathSum_2 not valid?"
                    },
                    {
                        "username": "nichita_trifan",
                        "content": "its not a leaf node"
                    },
                    {
                        "username": "leo3065",
                        "content": "I think PathSum_2 is not valid since it does not end in a leaf node"
                    },
                    {
                        "username": "hopeNoPip",
                        "content": "If a root has a value of [1] with a target value 1, the expected answer is True for this problem.\\nHowever, this root has no leaf which means it does not satisfy what the question is asking for....\\n\\n[1,2] 1 will result a false case... how is [1] 1 a true case?\\nPlease explain."
                    },
                    {
                        "username": "luqmansen",
                        "content": "[@luqmansen](/luqmansen) okay got it, the answer should be root to leaf.\\n\\nleaf is node with no children \\n\\nin this case, the node is a root and a leaf at the same time"
                    },
                    {
                        "username": "luqmansen",
                        "content": "same here, confused with the expected answer, anyone?"
                    },
                    {
                        "username": "johnny231198",
                        "content": "By definition an empty sum is 0 and this test case says that there is no path in this tree with sum equal to 0. I think this is a mistake... Please correct me if I am wrong."
                    },
                    {
                        "username": "khushiagarwal220",
                        "content": "if there is only root node, then targetSum would be \\nzero"
                    },
                    {
                        "username": "siddh",
                        "content": "Is this case valid tree= [] , sum=0, expected=false, shouldn\\'t this be true"
                    },
                    {
                        "username": "ashwani5",
                        "content": "This question has a lot of inconsistent test cases.\\n\\nroot=[1,2], targetSum=1 is false\\nroot=[1], targetSum=1 is true"
                    },
                    {
                        "username": "leson1106",
                        "content": "it\\'s true because [1, 2] should valid with targetSum = 3 where 1 + 2 = 3 and 2 is a leaf. And [1], yeah there is only 1 leaf so targetSum = 1 is correct"
                    },
                    {
                        "username": "an_98",
                        "content": "Your input\\n[1,2]\\n1\\nOutput : true\\nExpected : false\\n\\nThere is a tree clearly, then how is it false. Please tell me where I am wrong?"
                    },
                    {
                        "username": "kamalraj5544",
                        "content": "[@noobcoder1729](/noobcoder1729) definition of leaf : node with has no children --> but here root has one left child .. so it cant be leaf ! "
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "[@noobcoder1729](/noobcoder1729) how root behaves as a leaf, if it has a child node?"
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "There is one single branch in your example. And its path sum is 3. 3 != 1"
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "We have to find path from root to leaf. Root here itself behaves as the leaf also. Therefore true. "
                    }
                ]
            },
            {
                "id": 1564962,
                "content": [
                    {
                        "username": "dong12",
                        "content": "why should 'input [],0'   return false?  Isn't it true?"
                    },
                    {
                        "username": "mayankagarwal2402",
                        "content": "[@AKA_RAN](/AKA_RAN) now you\\'re just devising an argument to support the faulty somehow. To counter your argument I\\'d say \"the given input(zero nodes) satisfies the target(zero) already hence it should have been true\". This question should\\'ve focused on testing my analytical and coding skills and not my grammatical skills. "
                    },
                    {
                        "username": "garyyaoresearch",
                        "content": "Problem statement not specific enough and both your and relies\\' interpretation are possible. That case messes up the most elegant solution"
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "null != 0"
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "If you don\\'t have anything i.e. positive, negative or zero. Then how someone can achieve any target."
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "There has to be some path. In case of no nodes, there is no path. The null path isn't a path."
                    },
                    {
                        "username": "Jinlong",
                        "content": "       1\\n2            *\\n\\nThe struct is like above, and the sum of  right path is 1. Why the output is false?\\n\\nAdditional:\\n\\nFind another problem: the output of \"{1}, 1\" is true......\\n\\nwhy....."
                    },
                    {
                        "username": "nghiadq",
                        "content": "A leaf is a node with no children. in this case 1 is not a leaf because have children 2, 2 is a leaf"
                    },
                    {
                        "username": "obiwon84",
                        "content": "Just a suggestion but the [] 0 test case makes you create a helper method or add additional complexity for no real gain. Could we perhaps delete that test case?\\n\\nIn all honesty it is rather ambigious if [] 0 should return false or true as there is a path that sums to nothing, the null path. Removing this test case would also remove that ambiguity."
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "\"0\" is not NULL. It is real value. Instead of zero it can be any positive or negative value also.\\nTherefore don\\'t consider zero as NULL"
                    },
                    {
                        "username": "slovic",
                        "content": "It depends of usecase... but suggested behavior is more strict, and thou it should be preferred. From implementation point of view it is even simpler to implement it with current spec, because you can reuse top level behavior to left and right nodes (if they are nulls then result is false no matter what so you can call `hasPathSum(root.left, targetSum-root.value)` and if left was null it will return good result."
                    },
                    {
                        "username": "ravichandrae",
                        "content": "This problem has a test case for testing whether there is any path sum 0 for an empty binary tree.\\n{},0\\n\\nIt expects the result as false. But I think it's more intuitive to state the result as true."
                    },
                    {
                        "username": "suraj813",
                        "content": "Root node 1 has 2 children - 2 & None\\nPathSum_1 = 1+2 = 3\\nPathSum_2 = 1+None = 1\\n\\nThe expected answer is false. Is PathSum_2 not valid?"
                    },
                    {
                        "username": "nichita_trifan",
                        "content": "its not a leaf node"
                    },
                    {
                        "username": "leo3065",
                        "content": "I think PathSum_2 is not valid since it does not end in a leaf node"
                    },
                    {
                        "username": "hopeNoPip",
                        "content": "If a root has a value of [1] with a target value 1, the expected answer is True for this problem.\\nHowever, this root has no leaf which means it does not satisfy what the question is asking for....\\n\\n[1,2] 1 will result a false case... how is [1] 1 a true case?\\nPlease explain."
                    },
                    {
                        "username": "luqmansen",
                        "content": "[@luqmansen](/luqmansen) okay got it, the answer should be root to leaf.\\n\\nleaf is node with no children \\n\\nin this case, the node is a root and a leaf at the same time"
                    },
                    {
                        "username": "luqmansen",
                        "content": "same here, confused with the expected answer, anyone?"
                    },
                    {
                        "username": "johnny231198",
                        "content": "By definition an empty sum is 0 and this test case says that there is no path in this tree with sum equal to 0. I think this is a mistake... Please correct me if I am wrong."
                    },
                    {
                        "username": "khushiagarwal220",
                        "content": "if there is only root node, then targetSum would be \\nzero"
                    },
                    {
                        "username": "siddh",
                        "content": "Is this case valid tree= [] , sum=0, expected=false, shouldn\\'t this be true"
                    },
                    {
                        "username": "ashwani5",
                        "content": "This question has a lot of inconsistent test cases.\\n\\nroot=[1,2], targetSum=1 is false\\nroot=[1], targetSum=1 is true"
                    },
                    {
                        "username": "leson1106",
                        "content": "it\\'s true because [1, 2] should valid with targetSum = 3 where 1 + 2 = 3 and 2 is a leaf. And [1], yeah there is only 1 leaf so targetSum = 1 is correct"
                    },
                    {
                        "username": "an_98",
                        "content": "Your input\\n[1,2]\\n1\\nOutput : true\\nExpected : false\\n\\nThere is a tree clearly, then how is it false. Please tell me where I am wrong?"
                    },
                    {
                        "username": "kamalraj5544",
                        "content": "[@noobcoder1729](/noobcoder1729) definition of leaf : node with has no children --> but here root has one left child .. so it cant be leaf ! "
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "[@noobcoder1729](/noobcoder1729) how root behaves as a leaf, if it has a child node?"
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "There is one single branch in your example. And its path sum is 3. 3 != 1"
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "We have to find path from root to leaf. Root here itself behaves as the leaf also. Therefore true. "
                    }
                ]
            },
            {
                "id": 1566325,
                "content": [
                    {
                        "username": "dong12",
                        "content": "why should 'input [],0'   return false?  Isn't it true?"
                    },
                    {
                        "username": "mayankagarwal2402",
                        "content": "[@AKA_RAN](/AKA_RAN) now you\\'re just devising an argument to support the faulty somehow. To counter your argument I\\'d say \"the given input(zero nodes) satisfies the target(zero) already hence it should have been true\". This question should\\'ve focused on testing my analytical and coding skills and not my grammatical skills. "
                    },
                    {
                        "username": "garyyaoresearch",
                        "content": "Problem statement not specific enough and both your and relies\\' interpretation are possible. That case messes up the most elegant solution"
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "null != 0"
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "If you don\\'t have anything i.e. positive, negative or zero. Then how someone can achieve any target."
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "There has to be some path. In case of no nodes, there is no path. The null path isn't a path."
                    },
                    {
                        "username": "Jinlong",
                        "content": "       1\\n2            *\\n\\nThe struct is like above, and the sum of  right path is 1. Why the output is false?\\n\\nAdditional:\\n\\nFind another problem: the output of \"{1}, 1\" is true......\\n\\nwhy....."
                    },
                    {
                        "username": "nghiadq",
                        "content": "A leaf is a node with no children. in this case 1 is not a leaf because have children 2, 2 is a leaf"
                    },
                    {
                        "username": "obiwon84",
                        "content": "Just a suggestion but the [] 0 test case makes you create a helper method or add additional complexity for no real gain. Could we perhaps delete that test case?\\n\\nIn all honesty it is rather ambigious if [] 0 should return false or true as there is a path that sums to nothing, the null path. Removing this test case would also remove that ambiguity."
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "\"0\" is not NULL. It is real value. Instead of zero it can be any positive or negative value also.\\nTherefore don\\'t consider zero as NULL"
                    },
                    {
                        "username": "slovic",
                        "content": "It depends of usecase... but suggested behavior is more strict, and thou it should be preferred. From implementation point of view it is even simpler to implement it with current spec, because you can reuse top level behavior to left and right nodes (if they are nulls then result is false no matter what so you can call `hasPathSum(root.left, targetSum-root.value)` and if left was null it will return good result."
                    },
                    {
                        "username": "ravichandrae",
                        "content": "This problem has a test case for testing whether there is any path sum 0 for an empty binary tree.\\n{},0\\n\\nIt expects the result as false. But I think it's more intuitive to state the result as true."
                    },
                    {
                        "username": "suraj813",
                        "content": "Root node 1 has 2 children - 2 & None\\nPathSum_1 = 1+2 = 3\\nPathSum_2 = 1+None = 1\\n\\nThe expected answer is false. Is PathSum_2 not valid?"
                    },
                    {
                        "username": "nichita_trifan",
                        "content": "its not a leaf node"
                    },
                    {
                        "username": "leo3065",
                        "content": "I think PathSum_2 is not valid since it does not end in a leaf node"
                    },
                    {
                        "username": "hopeNoPip",
                        "content": "If a root has a value of [1] with a target value 1, the expected answer is True for this problem.\\nHowever, this root has no leaf which means it does not satisfy what the question is asking for....\\n\\n[1,2] 1 will result a false case... how is [1] 1 a true case?\\nPlease explain."
                    },
                    {
                        "username": "luqmansen",
                        "content": "[@luqmansen](/luqmansen) okay got it, the answer should be root to leaf.\\n\\nleaf is node with no children \\n\\nin this case, the node is a root and a leaf at the same time"
                    },
                    {
                        "username": "luqmansen",
                        "content": "same here, confused with the expected answer, anyone?"
                    },
                    {
                        "username": "johnny231198",
                        "content": "By definition an empty sum is 0 and this test case says that there is no path in this tree with sum equal to 0. I think this is a mistake... Please correct me if I am wrong."
                    },
                    {
                        "username": "khushiagarwal220",
                        "content": "if there is only root node, then targetSum would be \\nzero"
                    },
                    {
                        "username": "siddh",
                        "content": "Is this case valid tree= [] , sum=0, expected=false, shouldn\\'t this be true"
                    },
                    {
                        "username": "ashwani5",
                        "content": "This question has a lot of inconsistent test cases.\\n\\nroot=[1,2], targetSum=1 is false\\nroot=[1], targetSum=1 is true"
                    },
                    {
                        "username": "leson1106",
                        "content": "it\\'s true because [1, 2] should valid with targetSum = 3 where 1 + 2 = 3 and 2 is a leaf. And [1], yeah there is only 1 leaf so targetSum = 1 is correct"
                    },
                    {
                        "username": "an_98",
                        "content": "Your input\\n[1,2]\\n1\\nOutput : true\\nExpected : false\\n\\nThere is a tree clearly, then how is it false. Please tell me where I am wrong?"
                    },
                    {
                        "username": "kamalraj5544",
                        "content": "[@noobcoder1729](/noobcoder1729) definition of leaf : node with has no children --> but here root has one left child .. so it cant be leaf ! "
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "[@noobcoder1729](/noobcoder1729) how root behaves as a leaf, if it has a child node?"
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "There is one single branch in your example. And its path sum is 3. 3 != 1"
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "We have to find path from root to leaf. Root here itself behaves as the leaf also. Therefore true. "
                    }
                ]
            },
            {
                "id": 1566073,
                "content": [
                    {
                        "username": "dong12",
                        "content": "why should 'input [],0'   return false?  Isn't it true?"
                    },
                    {
                        "username": "mayankagarwal2402",
                        "content": "[@AKA_RAN](/AKA_RAN) now you\\'re just devising an argument to support the faulty somehow. To counter your argument I\\'d say \"the given input(zero nodes) satisfies the target(zero) already hence it should have been true\". This question should\\'ve focused on testing my analytical and coding skills and not my grammatical skills. "
                    },
                    {
                        "username": "garyyaoresearch",
                        "content": "Problem statement not specific enough and both your and relies\\' interpretation are possible. That case messes up the most elegant solution"
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "null != 0"
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "If you don\\'t have anything i.e. positive, negative or zero. Then how someone can achieve any target."
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "There has to be some path. In case of no nodes, there is no path. The null path isn't a path."
                    },
                    {
                        "username": "Jinlong",
                        "content": "       1\\n2            *\\n\\nThe struct is like above, and the sum of  right path is 1. Why the output is false?\\n\\nAdditional:\\n\\nFind another problem: the output of \"{1}, 1\" is true......\\n\\nwhy....."
                    },
                    {
                        "username": "nghiadq",
                        "content": "A leaf is a node with no children. in this case 1 is not a leaf because have children 2, 2 is a leaf"
                    },
                    {
                        "username": "obiwon84",
                        "content": "Just a suggestion but the [] 0 test case makes you create a helper method or add additional complexity for no real gain. Could we perhaps delete that test case?\\n\\nIn all honesty it is rather ambigious if [] 0 should return false or true as there is a path that sums to nothing, the null path. Removing this test case would also remove that ambiguity."
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "\"0\" is not NULL. It is real value. Instead of zero it can be any positive or negative value also.\\nTherefore don\\'t consider zero as NULL"
                    },
                    {
                        "username": "slovic",
                        "content": "It depends of usecase... but suggested behavior is more strict, and thou it should be preferred. From implementation point of view it is even simpler to implement it with current spec, because you can reuse top level behavior to left and right nodes (if they are nulls then result is false no matter what so you can call `hasPathSum(root.left, targetSum-root.value)` and if left was null it will return good result."
                    },
                    {
                        "username": "ravichandrae",
                        "content": "This problem has a test case for testing whether there is any path sum 0 for an empty binary tree.\\n{},0\\n\\nIt expects the result as false. But I think it's more intuitive to state the result as true."
                    },
                    {
                        "username": "suraj813",
                        "content": "Root node 1 has 2 children - 2 & None\\nPathSum_1 = 1+2 = 3\\nPathSum_2 = 1+None = 1\\n\\nThe expected answer is false. Is PathSum_2 not valid?"
                    },
                    {
                        "username": "nichita_trifan",
                        "content": "its not a leaf node"
                    },
                    {
                        "username": "leo3065",
                        "content": "I think PathSum_2 is not valid since it does not end in a leaf node"
                    },
                    {
                        "username": "hopeNoPip",
                        "content": "If a root has a value of [1] with a target value 1, the expected answer is True for this problem.\\nHowever, this root has no leaf which means it does not satisfy what the question is asking for....\\n\\n[1,2] 1 will result a false case... how is [1] 1 a true case?\\nPlease explain."
                    },
                    {
                        "username": "luqmansen",
                        "content": "[@luqmansen](/luqmansen) okay got it, the answer should be root to leaf.\\n\\nleaf is node with no children \\n\\nin this case, the node is a root and a leaf at the same time"
                    },
                    {
                        "username": "luqmansen",
                        "content": "same here, confused with the expected answer, anyone?"
                    },
                    {
                        "username": "johnny231198",
                        "content": "By definition an empty sum is 0 and this test case says that there is no path in this tree with sum equal to 0. I think this is a mistake... Please correct me if I am wrong."
                    },
                    {
                        "username": "khushiagarwal220",
                        "content": "if there is only root node, then targetSum would be \\nzero"
                    },
                    {
                        "username": "siddh",
                        "content": "Is this case valid tree= [] , sum=0, expected=false, shouldn\\'t this be true"
                    },
                    {
                        "username": "ashwani5",
                        "content": "This question has a lot of inconsistent test cases.\\n\\nroot=[1,2], targetSum=1 is false\\nroot=[1], targetSum=1 is true"
                    },
                    {
                        "username": "leson1106",
                        "content": "it\\'s true because [1, 2] should valid with targetSum = 3 where 1 + 2 = 3 and 2 is a leaf. And [1], yeah there is only 1 leaf so targetSum = 1 is correct"
                    },
                    {
                        "username": "an_98",
                        "content": "Your input\\n[1,2]\\n1\\nOutput : true\\nExpected : false\\n\\nThere is a tree clearly, then how is it false. Please tell me where I am wrong?"
                    },
                    {
                        "username": "kamalraj5544",
                        "content": "[@noobcoder1729](/noobcoder1729) definition of leaf : node with has no children --> but here root has one left child .. so it cant be leaf ! "
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "[@noobcoder1729](/noobcoder1729) how root behaves as a leaf, if it has a child node?"
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "There is one single branch in your example. And its path sum is 3. 3 != 1"
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "We have to find path from root to leaf. Root here itself behaves as the leaf also. Therefore true. "
                    }
                ]
            },
            {
                "id": 1568025,
                "content": [
                    {
                        "username": "dong12",
                        "content": "why should 'input [],0'   return false?  Isn't it true?"
                    },
                    {
                        "username": "mayankagarwal2402",
                        "content": "[@AKA_RAN](/AKA_RAN) now you\\'re just devising an argument to support the faulty somehow. To counter your argument I\\'d say \"the given input(zero nodes) satisfies the target(zero) already hence it should have been true\". This question should\\'ve focused on testing my analytical and coding skills and not my grammatical skills. "
                    },
                    {
                        "username": "garyyaoresearch",
                        "content": "Problem statement not specific enough and both your and relies\\' interpretation are possible. That case messes up the most elegant solution"
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "null != 0"
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "If you don\\'t have anything i.e. positive, negative or zero. Then how someone can achieve any target."
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "There has to be some path. In case of no nodes, there is no path. The null path isn't a path."
                    },
                    {
                        "username": "Jinlong",
                        "content": "       1\\n2            *\\n\\nThe struct is like above, and the sum of  right path is 1. Why the output is false?\\n\\nAdditional:\\n\\nFind another problem: the output of \"{1}, 1\" is true......\\n\\nwhy....."
                    },
                    {
                        "username": "nghiadq",
                        "content": "A leaf is a node with no children. in this case 1 is not a leaf because have children 2, 2 is a leaf"
                    },
                    {
                        "username": "obiwon84",
                        "content": "Just a suggestion but the [] 0 test case makes you create a helper method or add additional complexity for no real gain. Could we perhaps delete that test case?\\n\\nIn all honesty it is rather ambigious if [] 0 should return false or true as there is a path that sums to nothing, the null path. Removing this test case would also remove that ambiguity."
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "\"0\" is not NULL. It is real value. Instead of zero it can be any positive or negative value also.\\nTherefore don\\'t consider zero as NULL"
                    },
                    {
                        "username": "slovic",
                        "content": "It depends of usecase... but suggested behavior is more strict, and thou it should be preferred. From implementation point of view it is even simpler to implement it with current spec, because you can reuse top level behavior to left and right nodes (if they are nulls then result is false no matter what so you can call `hasPathSum(root.left, targetSum-root.value)` and if left was null it will return good result."
                    },
                    {
                        "username": "ravichandrae",
                        "content": "This problem has a test case for testing whether there is any path sum 0 for an empty binary tree.\\n{},0\\n\\nIt expects the result as false. But I think it's more intuitive to state the result as true."
                    },
                    {
                        "username": "suraj813",
                        "content": "Root node 1 has 2 children - 2 & None\\nPathSum_1 = 1+2 = 3\\nPathSum_2 = 1+None = 1\\n\\nThe expected answer is false. Is PathSum_2 not valid?"
                    },
                    {
                        "username": "nichita_trifan",
                        "content": "its not a leaf node"
                    },
                    {
                        "username": "leo3065",
                        "content": "I think PathSum_2 is not valid since it does not end in a leaf node"
                    },
                    {
                        "username": "hopeNoPip",
                        "content": "If a root has a value of [1] with a target value 1, the expected answer is True for this problem.\\nHowever, this root has no leaf which means it does not satisfy what the question is asking for....\\n\\n[1,2] 1 will result a false case... how is [1] 1 a true case?\\nPlease explain."
                    },
                    {
                        "username": "luqmansen",
                        "content": "[@luqmansen](/luqmansen) okay got it, the answer should be root to leaf.\\n\\nleaf is node with no children \\n\\nin this case, the node is a root and a leaf at the same time"
                    },
                    {
                        "username": "luqmansen",
                        "content": "same here, confused with the expected answer, anyone?"
                    },
                    {
                        "username": "johnny231198",
                        "content": "By definition an empty sum is 0 and this test case says that there is no path in this tree with sum equal to 0. I think this is a mistake... Please correct me if I am wrong."
                    },
                    {
                        "username": "khushiagarwal220",
                        "content": "if there is only root node, then targetSum would be \\nzero"
                    },
                    {
                        "username": "siddh",
                        "content": "Is this case valid tree= [] , sum=0, expected=false, shouldn\\'t this be true"
                    },
                    {
                        "username": "ashwani5",
                        "content": "This question has a lot of inconsistent test cases.\\n\\nroot=[1,2], targetSum=1 is false\\nroot=[1], targetSum=1 is true"
                    },
                    {
                        "username": "leson1106",
                        "content": "it\\'s true because [1, 2] should valid with targetSum = 3 where 1 + 2 = 3 and 2 is a leaf. And [1], yeah there is only 1 leaf so targetSum = 1 is correct"
                    },
                    {
                        "username": "an_98",
                        "content": "Your input\\n[1,2]\\n1\\nOutput : true\\nExpected : false\\n\\nThere is a tree clearly, then how is it false. Please tell me where I am wrong?"
                    },
                    {
                        "username": "kamalraj5544",
                        "content": "[@noobcoder1729](/noobcoder1729) definition of leaf : node with has no children --> but here root has one left child .. so it cant be leaf ! "
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "[@noobcoder1729](/noobcoder1729) how root behaves as a leaf, if it has a child node?"
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "There is one single branch in your example. And its path sum is 3. 3 != 1"
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "We have to find path from root to leaf. Root here itself behaves as the leaf also. Therefore true. "
                    }
                ]
            },
            {
                "id": 1572485,
                "content": [
                    {
                        "username": "dong12",
                        "content": "why should 'input [],0'   return false?  Isn't it true?"
                    },
                    {
                        "username": "mayankagarwal2402",
                        "content": "[@AKA_RAN](/AKA_RAN) now you\\'re just devising an argument to support the faulty somehow. To counter your argument I\\'d say \"the given input(zero nodes) satisfies the target(zero) already hence it should have been true\". This question should\\'ve focused on testing my analytical and coding skills and not my grammatical skills. "
                    },
                    {
                        "username": "garyyaoresearch",
                        "content": "Problem statement not specific enough and both your and relies\\' interpretation are possible. That case messes up the most elegant solution"
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "null != 0"
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "If you don\\'t have anything i.e. positive, negative or zero. Then how someone can achieve any target."
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "There has to be some path. In case of no nodes, there is no path. The null path isn't a path."
                    },
                    {
                        "username": "Jinlong",
                        "content": "       1\\n2            *\\n\\nThe struct is like above, and the sum of  right path is 1. Why the output is false?\\n\\nAdditional:\\n\\nFind another problem: the output of \"{1}, 1\" is true......\\n\\nwhy....."
                    },
                    {
                        "username": "nghiadq",
                        "content": "A leaf is a node with no children. in this case 1 is not a leaf because have children 2, 2 is a leaf"
                    },
                    {
                        "username": "obiwon84",
                        "content": "Just a suggestion but the [] 0 test case makes you create a helper method or add additional complexity for no real gain. Could we perhaps delete that test case?\\n\\nIn all honesty it is rather ambigious if [] 0 should return false or true as there is a path that sums to nothing, the null path. Removing this test case would also remove that ambiguity."
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "\"0\" is not NULL. It is real value. Instead of zero it can be any positive or negative value also.\\nTherefore don\\'t consider zero as NULL"
                    },
                    {
                        "username": "slovic",
                        "content": "It depends of usecase... but suggested behavior is more strict, and thou it should be preferred. From implementation point of view it is even simpler to implement it with current spec, because you can reuse top level behavior to left and right nodes (if they are nulls then result is false no matter what so you can call `hasPathSum(root.left, targetSum-root.value)` and if left was null it will return good result."
                    },
                    {
                        "username": "ravichandrae",
                        "content": "This problem has a test case for testing whether there is any path sum 0 for an empty binary tree.\\n{},0\\n\\nIt expects the result as false. But I think it's more intuitive to state the result as true."
                    },
                    {
                        "username": "suraj813",
                        "content": "Root node 1 has 2 children - 2 & None\\nPathSum_1 = 1+2 = 3\\nPathSum_2 = 1+None = 1\\n\\nThe expected answer is false. Is PathSum_2 not valid?"
                    },
                    {
                        "username": "nichita_trifan",
                        "content": "its not a leaf node"
                    },
                    {
                        "username": "leo3065",
                        "content": "I think PathSum_2 is not valid since it does not end in a leaf node"
                    },
                    {
                        "username": "hopeNoPip",
                        "content": "If a root has a value of [1] with a target value 1, the expected answer is True for this problem.\\nHowever, this root has no leaf which means it does not satisfy what the question is asking for....\\n\\n[1,2] 1 will result a false case... how is [1] 1 a true case?\\nPlease explain."
                    },
                    {
                        "username": "luqmansen",
                        "content": "[@luqmansen](/luqmansen) okay got it, the answer should be root to leaf.\\n\\nleaf is node with no children \\n\\nin this case, the node is a root and a leaf at the same time"
                    },
                    {
                        "username": "luqmansen",
                        "content": "same here, confused with the expected answer, anyone?"
                    },
                    {
                        "username": "johnny231198",
                        "content": "By definition an empty sum is 0 and this test case says that there is no path in this tree with sum equal to 0. I think this is a mistake... Please correct me if I am wrong."
                    },
                    {
                        "username": "khushiagarwal220",
                        "content": "if there is only root node, then targetSum would be \\nzero"
                    },
                    {
                        "username": "siddh",
                        "content": "Is this case valid tree= [] , sum=0, expected=false, shouldn\\'t this be true"
                    },
                    {
                        "username": "ashwani5",
                        "content": "This question has a lot of inconsistent test cases.\\n\\nroot=[1,2], targetSum=1 is false\\nroot=[1], targetSum=1 is true"
                    },
                    {
                        "username": "leson1106",
                        "content": "it\\'s true because [1, 2] should valid with targetSum = 3 where 1 + 2 = 3 and 2 is a leaf. And [1], yeah there is only 1 leaf so targetSum = 1 is correct"
                    },
                    {
                        "username": "an_98",
                        "content": "Your input\\n[1,2]\\n1\\nOutput : true\\nExpected : false\\n\\nThere is a tree clearly, then how is it false. Please tell me where I am wrong?"
                    },
                    {
                        "username": "kamalraj5544",
                        "content": "[@noobcoder1729](/noobcoder1729) definition of leaf : node with has no children --> but here root has one left child .. so it cant be leaf ! "
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "[@noobcoder1729](/noobcoder1729) how root behaves as a leaf, if it has a child node?"
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "There is one single branch in your example. And its path sum is 3. 3 != 1"
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "We have to find path from root to leaf. Root here itself behaves as the leaf also. Therefore true. "
                    }
                ]
            },
            {
                "id": 1566969,
                "content": [
                    {
                        "username": "dong12",
                        "content": "why should 'input [],0'   return false?  Isn't it true?"
                    },
                    {
                        "username": "mayankagarwal2402",
                        "content": "[@AKA_RAN](/AKA_RAN) now you\\'re just devising an argument to support the faulty somehow. To counter your argument I\\'d say \"the given input(zero nodes) satisfies the target(zero) already hence it should have been true\". This question should\\'ve focused on testing my analytical and coding skills and not my grammatical skills. "
                    },
                    {
                        "username": "garyyaoresearch",
                        "content": "Problem statement not specific enough and both your and relies\\' interpretation are possible. That case messes up the most elegant solution"
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "null != 0"
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "If you don\\'t have anything i.e. positive, negative or zero. Then how someone can achieve any target."
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "There has to be some path. In case of no nodes, there is no path. The null path isn't a path."
                    },
                    {
                        "username": "Jinlong",
                        "content": "       1\\n2            *\\n\\nThe struct is like above, and the sum of  right path is 1. Why the output is false?\\n\\nAdditional:\\n\\nFind another problem: the output of \"{1}, 1\" is true......\\n\\nwhy....."
                    },
                    {
                        "username": "nghiadq",
                        "content": "A leaf is a node with no children. in this case 1 is not a leaf because have children 2, 2 is a leaf"
                    },
                    {
                        "username": "obiwon84",
                        "content": "Just a suggestion but the [] 0 test case makes you create a helper method or add additional complexity for no real gain. Could we perhaps delete that test case?\\n\\nIn all honesty it is rather ambigious if [] 0 should return false or true as there is a path that sums to nothing, the null path. Removing this test case would also remove that ambiguity."
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "\"0\" is not NULL. It is real value. Instead of zero it can be any positive or negative value also.\\nTherefore don\\'t consider zero as NULL"
                    },
                    {
                        "username": "slovic",
                        "content": "It depends of usecase... but suggested behavior is more strict, and thou it should be preferred. From implementation point of view it is even simpler to implement it with current spec, because you can reuse top level behavior to left and right nodes (if they are nulls then result is false no matter what so you can call `hasPathSum(root.left, targetSum-root.value)` and if left was null it will return good result."
                    },
                    {
                        "username": "ravichandrae",
                        "content": "This problem has a test case for testing whether there is any path sum 0 for an empty binary tree.\\n{},0\\n\\nIt expects the result as false. But I think it's more intuitive to state the result as true."
                    },
                    {
                        "username": "suraj813",
                        "content": "Root node 1 has 2 children - 2 & None\\nPathSum_1 = 1+2 = 3\\nPathSum_2 = 1+None = 1\\n\\nThe expected answer is false. Is PathSum_2 not valid?"
                    },
                    {
                        "username": "nichita_trifan",
                        "content": "its not a leaf node"
                    },
                    {
                        "username": "leo3065",
                        "content": "I think PathSum_2 is not valid since it does not end in a leaf node"
                    },
                    {
                        "username": "hopeNoPip",
                        "content": "If a root has a value of [1] with a target value 1, the expected answer is True for this problem.\\nHowever, this root has no leaf which means it does not satisfy what the question is asking for....\\n\\n[1,2] 1 will result a false case... how is [1] 1 a true case?\\nPlease explain."
                    },
                    {
                        "username": "luqmansen",
                        "content": "[@luqmansen](/luqmansen) okay got it, the answer should be root to leaf.\\n\\nleaf is node with no children \\n\\nin this case, the node is a root and a leaf at the same time"
                    },
                    {
                        "username": "luqmansen",
                        "content": "same here, confused with the expected answer, anyone?"
                    },
                    {
                        "username": "johnny231198",
                        "content": "By definition an empty sum is 0 and this test case says that there is no path in this tree with sum equal to 0. I think this is a mistake... Please correct me if I am wrong."
                    },
                    {
                        "username": "khushiagarwal220",
                        "content": "if there is only root node, then targetSum would be \\nzero"
                    },
                    {
                        "username": "siddh",
                        "content": "Is this case valid tree= [] , sum=0, expected=false, shouldn\\'t this be true"
                    },
                    {
                        "username": "ashwani5",
                        "content": "This question has a lot of inconsistent test cases.\\n\\nroot=[1,2], targetSum=1 is false\\nroot=[1], targetSum=1 is true"
                    },
                    {
                        "username": "leson1106",
                        "content": "it\\'s true because [1, 2] should valid with targetSum = 3 where 1 + 2 = 3 and 2 is a leaf. And [1], yeah there is only 1 leaf so targetSum = 1 is correct"
                    },
                    {
                        "username": "an_98",
                        "content": "Your input\\n[1,2]\\n1\\nOutput : true\\nExpected : false\\n\\nThere is a tree clearly, then how is it false. Please tell me where I am wrong?"
                    },
                    {
                        "username": "kamalraj5544",
                        "content": "[@noobcoder1729](/noobcoder1729) definition of leaf : node with has no children --> but here root has one left child .. so it cant be leaf ! "
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "[@noobcoder1729](/noobcoder1729) how root behaves as a leaf, if it has a child node?"
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "There is one single branch in your example. And its path sum is 3. 3 != 1"
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "We have to find path from root to leaf. Root here itself behaves as the leaf also. Therefore true. "
                    }
                ]
            },
            {
                "id": 1570035,
                "content": [
                    {
                        "username": "dong12",
                        "content": "why should 'input [],0'   return false?  Isn't it true?"
                    },
                    {
                        "username": "mayankagarwal2402",
                        "content": "[@AKA_RAN](/AKA_RAN) now you\\'re just devising an argument to support the faulty somehow. To counter your argument I\\'d say \"the given input(zero nodes) satisfies the target(zero) already hence it should have been true\". This question should\\'ve focused on testing my analytical and coding skills and not my grammatical skills. "
                    },
                    {
                        "username": "garyyaoresearch",
                        "content": "Problem statement not specific enough and both your and relies\\' interpretation are possible. That case messes up the most elegant solution"
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "null != 0"
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "If you don\\'t have anything i.e. positive, negative or zero. Then how someone can achieve any target."
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "There has to be some path. In case of no nodes, there is no path. The null path isn't a path."
                    },
                    {
                        "username": "Jinlong",
                        "content": "       1\\n2            *\\n\\nThe struct is like above, and the sum of  right path is 1. Why the output is false?\\n\\nAdditional:\\n\\nFind another problem: the output of \"{1}, 1\" is true......\\n\\nwhy....."
                    },
                    {
                        "username": "nghiadq",
                        "content": "A leaf is a node with no children. in this case 1 is not a leaf because have children 2, 2 is a leaf"
                    },
                    {
                        "username": "obiwon84",
                        "content": "Just a suggestion but the [] 0 test case makes you create a helper method or add additional complexity for no real gain. Could we perhaps delete that test case?\\n\\nIn all honesty it is rather ambigious if [] 0 should return false or true as there is a path that sums to nothing, the null path. Removing this test case would also remove that ambiguity."
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "\"0\" is not NULL. It is real value. Instead of zero it can be any positive or negative value also.\\nTherefore don\\'t consider zero as NULL"
                    },
                    {
                        "username": "slovic",
                        "content": "It depends of usecase... but suggested behavior is more strict, and thou it should be preferred. From implementation point of view it is even simpler to implement it with current spec, because you can reuse top level behavior to left and right nodes (if they are nulls then result is false no matter what so you can call `hasPathSum(root.left, targetSum-root.value)` and if left was null it will return good result."
                    },
                    {
                        "username": "ravichandrae",
                        "content": "This problem has a test case for testing whether there is any path sum 0 for an empty binary tree.\\n{},0\\n\\nIt expects the result as false. But I think it's more intuitive to state the result as true."
                    },
                    {
                        "username": "suraj813",
                        "content": "Root node 1 has 2 children - 2 & None\\nPathSum_1 = 1+2 = 3\\nPathSum_2 = 1+None = 1\\n\\nThe expected answer is false. Is PathSum_2 not valid?"
                    },
                    {
                        "username": "nichita_trifan",
                        "content": "its not a leaf node"
                    },
                    {
                        "username": "leo3065",
                        "content": "I think PathSum_2 is not valid since it does not end in a leaf node"
                    },
                    {
                        "username": "hopeNoPip",
                        "content": "If a root has a value of [1] with a target value 1, the expected answer is True for this problem.\\nHowever, this root has no leaf which means it does not satisfy what the question is asking for....\\n\\n[1,2] 1 will result a false case... how is [1] 1 a true case?\\nPlease explain."
                    },
                    {
                        "username": "luqmansen",
                        "content": "[@luqmansen](/luqmansen) okay got it, the answer should be root to leaf.\\n\\nleaf is node with no children \\n\\nin this case, the node is a root and a leaf at the same time"
                    },
                    {
                        "username": "luqmansen",
                        "content": "same here, confused with the expected answer, anyone?"
                    },
                    {
                        "username": "johnny231198",
                        "content": "By definition an empty sum is 0 and this test case says that there is no path in this tree with sum equal to 0. I think this is a mistake... Please correct me if I am wrong."
                    },
                    {
                        "username": "khushiagarwal220",
                        "content": "if there is only root node, then targetSum would be \\nzero"
                    },
                    {
                        "username": "siddh",
                        "content": "Is this case valid tree= [] , sum=0, expected=false, shouldn\\'t this be true"
                    },
                    {
                        "username": "ashwani5",
                        "content": "This question has a lot of inconsistent test cases.\\n\\nroot=[1,2], targetSum=1 is false\\nroot=[1], targetSum=1 is true"
                    },
                    {
                        "username": "leson1106",
                        "content": "it\\'s true because [1, 2] should valid with targetSum = 3 where 1 + 2 = 3 and 2 is a leaf. And [1], yeah there is only 1 leaf so targetSum = 1 is correct"
                    },
                    {
                        "username": "an_98",
                        "content": "Your input\\n[1,2]\\n1\\nOutput : true\\nExpected : false\\n\\nThere is a tree clearly, then how is it false. Please tell me where I am wrong?"
                    },
                    {
                        "username": "kamalraj5544",
                        "content": "[@noobcoder1729](/noobcoder1729) definition of leaf : node with has no children --> but here root has one left child .. so it cant be leaf ! "
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "[@noobcoder1729](/noobcoder1729) how root behaves as a leaf, if it has a child node?"
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "There is one single branch in your example. And its path sum is 3. 3 != 1"
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "We have to find path from root to leaf. Root here itself behaves as the leaf also. Therefore true. "
                    }
                ]
            },
            {
                "id": 1815767,
                "content": [
                    {
                        "username": "dong12",
                        "content": "why should 'input [],0'   return false?  Isn't it true?"
                    },
                    {
                        "username": "mayankagarwal2402",
                        "content": "[@AKA_RAN](/AKA_RAN) now you\\'re just devising an argument to support the faulty somehow. To counter your argument I\\'d say \"the given input(zero nodes) satisfies the target(zero) already hence it should have been true\". This question should\\'ve focused on testing my analytical and coding skills and not my grammatical skills. "
                    },
                    {
                        "username": "garyyaoresearch",
                        "content": "Problem statement not specific enough and both your and relies\\' interpretation are possible. That case messes up the most elegant solution"
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "null != 0"
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "If you don\\'t have anything i.e. positive, negative or zero. Then how someone can achieve any target."
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "There has to be some path. In case of no nodes, there is no path. The null path isn't a path."
                    },
                    {
                        "username": "Jinlong",
                        "content": "       1\\n2            *\\n\\nThe struct is like above, and the sum of  right path is 1. Why the output is false?\\n\\nAdditional:\\n\\nFind another problem: the output of \"{1}, 1\" is true......\\n\\nwhy....."
                    },
                    {
                        "username": "nghiadq",
                        "content": "A leaf is a node with no children. in this case 1 is not a leaf because have children 2, 2 is a leaf"
                    },
                    {
                        "username": "obiwon84",
                        "content": "Just a suggestion but the [] 0 test case makes you create a helper method or add additional complexity for no real gain. Could we perhaps delete that test case?\\n\\nIn all honesty it is rather ambigious if [] 0 should return false or true as there is a path that sums to nothing, the null path. Removing this test case would also remove that ambiguity."
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "\"0\" is not NULL. It is real value. Instead of zero it can be any positive or negative value also.\\nTherefore don\\'t consider zero as NULL"
                    },
                    {
                        "username": "slovic",
                        "content": "It depends of usecase... but suggested behavior is more strict, and thou it should be preferred. From implementation point of view it is even simpler to implement it with current spec, because you can reuse top level behavior to left and right nodes (if they are nulls then result is false no matter what so you can call `hasPathSum(root.left, targetSum-root.value)` and if left was null it will return good result."
                    },
                    {
                        "username": "ravichandrae",
                        "content": "This problem has a test case for testing whether there is any path sum 0 for an empty binary tree.\\n{},0\\n\\nIt expects the result as false. But I think it's more intuitive to state the result as true."
                    },
                    {
                        "username": "suraj813",
                        "content": "Root node 1 has 2 children - 2 & None\\nPathSum_1 = 1+2 = 3\\nPathSum_2 = 1+None = 1\\n\\nThe expected answer is false. Is PathSum_2 not valid?"
                    },
                    {
                        "username": "nichita_trifan",
                        "content": "its not a leaf node"
                    },
                    {
                        "username": "leo3065",
                        "content": "I think PathSum_2 is not valid since it does not end in a leaf node"
                    },
                    {
                        "username": "hopeNoPip",
                        "content": "If a root has a value of [1] with a target value 1, the expected answer is True for this problem.\\nHowever, this root has no leaf which means it does not satisfy what the question is asking for....\\n\\n[1,2] 1 will result a false case... how is [1] 1 a true case?\\nPlease explain."
                    },
                    {
                        "username": "luqmansen",
                        "content": "[@luqmansen](/luqmansen) okay got it, the answer should be root to leaf.\\n\\nleaf is node with no children \\n\\nin this case, the node is a root and a leaf at the same time"
                    },
                    {
                        "username": "luqmansen",
                        "content": "same here, confused with the expected answer, anyone?"
                    },
                    {
                        "username": "johnny231198",
                        "content": "By definition an empty sum is 0 and this test case says that there is no path in this tree with sum equal to 0. I think this is a mistake... Please correct me if I am wrong."
                    },
                    {
                        "username": "khushiagarwal220",
                        "content": "if there is only root node, then targetSum would be \\nzero"
                    },
                    {
                        "username": "siddh",
                        "content": "Is this case valid tree= [] , sum=0, expected=false, shouldn\\'t this be true"
                    },
                    {
                        "username": "ashwani5",
                        "content": "This question has a lot of inconsistent test cases.\\n\\nroot=[1,2], targetSum=1 is false\\nroot=[1], targetSum=1 is true"
                    },
                    {
                        "username": "leson1106",
                        "content": "it\\'s true because [1, 2] should valid with targetSum = 3 where 1 + 2 = 3 and 2 is a leaf. And [1], yeah there is only 1 leaf so targetSum = 1 is correct"
                    },
                    {
                        "username": "an_98",
                        "content": "Your input\\n[1,2]\\n1\\nOutput : true\\nExpected : false\\n\\nThere is a tree clearly, then how is it false. Please tell me where I am wrong?"
                    },
                    {
                        "username": "kamalraj5544",
                        "content": "[@noobcoder1729](/noobcoder1729) definition of leaf : node with has no children --> but here root has one left child .. so it cant be leaf ! "
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "[@noobcoder1729](/noobcoder1729) how root behaves as a leaf, if it has a child node?"
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "There is one single branch in your example. And its path sum is 3. 3 != 1"
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "We have to find path from root to leaf. Root here itself behaves as the leaf also. Therefore true. "
                    }
                ]
            },
            {
                "id": 1574172,
                "content": [
                    {
                        "username": "dong12",
                        "content": "why should 'input [],0'   return false?  Isn't it true?"
                    },
                    {
                        "username": "mayankagarwal2402",
                        "content": "[@AKA_RAN](/AKA_RAN) now you\\'re just devising an argument to support the faulty somehow. To counter your argument I\\'d say \"the given input(zero nodes) satisfies the target(zero) already hence it should have been true\". This question should\\'ve focused on testing my analytical and coding skills and not my grammatical skills. "
                    },
                    {
                        "username": "garyyaoresearch",
                        "content": "Problem statement not specific enough and both your and relies\\' interpretation are possible. That case messes up the most elegant solution"
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "null != 0"
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "If you don\\'t have anything i.e. positive, negative or zero. Then how someone can achieve any target."
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "There has to be some path. In case of no nodes, there is no path. The null path isn't a path."
                    },
                    {
                        "username": "Jinlong",
                        "content": "       1\\n2            *\\n\\nThe struct is like above, and the sum of  right path is 1. Why the output is false?\\n\\nAdditional:\\n\\nFind another problem: the output of \"{1}, 1\" is true......\\n\\nwhy....."
                    },
                    {
                        "username": "nghiadq",
                        "content": "A leaf is a node with no children. in this case 1 is not a leaf because have children 2, 2 is a leaf"
                    },
                    {
                        "username": "obiwon84",
                        "content": "Just a suggestion but the [] 0 test case makes you create a helper method or add additional complexity for no real gain. Could we perhaps delete that test case?\\n\\nIn all honesty it is rather ambigious if [] 0 should return false or true as there is a path that sums to nothing, the null path. Removing this test case would also remove that ambiguity."
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "\"0\" is not NULL. It is real value. Instead of zero it can be any positive or negative value also.\\nTherefore don\\'t consider zero as NULL"
                    },
                    {
                        "username": "slovic",
                        "content": "It depends of usecase... but suggested behavior is more strict, and thou it should be preferred. From implementation point of view it is even simpler to implement it with current spec, because you can reuse top level behavior to left and right nodes (if they are nulls then result is false no matter what so you can call `hasPathSum(root.left, targetSum-root.value)` and if left was null it will return good result."
                    },
                    {
                        "username": "ravichandrae",
                        "content": "This problem has a test case for testing whether there is any path sum 0 for an empty binary tree.\\n{},0\\n\\nIt expects the result as false. But I think it's more intuitive to state the result as true."
                    },
                    {
                        "username": "suraj813",
                        "content": "Root node 1 has 2 children - 2 & None\\nPathSum_1 = 1+2 = 3\\nPathSum_2 = 1+None = 1\\n\\nThe expected answer is false. Is PathSum_2 not valid?"
                    },
                    {
                        "username": "nichita_trifan",
                        "content": "its not a leaf node"
                    },
                    {
                        "username": "leo3065",
                        "content": "I think PathSum_2 is not valid since it does not end in a leaf node"
                    },
                    {
                        "username": "hopeNoPip",
                        "content": "If a root has a value of [1] with a target value 1, the expected answer is True for this problem.\\nHowever, this root has no leaf which means it does not satisfy what the question is asking for....\\n\\n[1,2] 1 will result a false case... how is [1] 1 a true case?\\nPlease explain."
                    },
                    {
                        "username": "luqmansen",
                        "content": "[@luqmansen](/luqmansen) okay got it, the answer should be root to leaf.\\n\\nleaf is node with no children \\n\\nin this case, the node is a root and a leaf at the same time"
                    },
                    {
                        "username": "luqmansen",
                        "content": "same here, confused with the expected answer, anyone?"
                    },
                    {
                        "username": "johnny231198",
                        "content": "By definition an empty sum is 0 and this test case says that there is no path in this tree with sum equal to 0. I think this is a mistake... Please correct me if I am wrong."
                    },
                    {
                        "username": "khushiagarwal220",
                        "content": "if there is only root node, then targetSum would be \\nzero"
                    },
                    {
                        "username": "siddh",
                        "content": "Is this case valid tree= [] , sum=0, expected=false, shouldn\\'t this be true"
                    },
                    {
                        "username": "ashwani5",
                        "content": "This question has a lot of inconsistent test cases.\\n\\nroot=[1,2], targetSum=1 is false\\nroot=[1], targetSum=1 is true"
                    },
                    {
                        "username": "leson1106",
                        "content": "it\\'s true because [1, 2] should valid with targetSum = 3 where 1 + 2 = 3 and 2 is a leaf. And [1], yeah there is only 1 leaf so targetSum = 1 is correct"
                    },
                    {
                        "username": "an_98",
                        "content": "Your input\\n[1,2]\\n1\\nOutput : true\\nExpected : false\\n\\nThere is a tree clearly, then how is it false. Please tell me where I am wrong?"
                    },
                    {
                        "username": "kamalraj5544",
                        "content": "[@noobcoder1729](/noobcoder1729) definition of leaf : node with has no children --> but here root has one left child .. so it cant be leaf ! "
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "[@noobcoder1729](/noobcoder1729) how root behaves as a leaf, if it has a child node?"
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "There is one single branch in your example. And its path sum is 3. 3 != 1"
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "We have to find path from root to leaf. Root here itself behaves as the leaf also. Therefore true. "
                    }
                ]
            },
            {
                "id": 1565659,
                "content": [
                    {
                        "username": "dong12",
                        "content": "why should 'input [],0'   return false?  Isn't it true?"
                    },
                    {
                        "username": "mayankagarwal2402",
                        "content": "[@AKA_RAN](/AKA_RAN) now you\\'re just devising an argument to support the faulty somehow. To counter your argument I\\'d say \"the given input(zero nodes) satisfies the target(zero) already hence it should have been true\". This question should\\'ve focused on testing my analytical and coding skills and not my grammatical skills. "
                    },
                    {
                        "username": "garyyaoresearch",
                        "content": "Problem statement not specific enough and both your and relies\\' interpretation are possible. That case messes up the most elegant solution"
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "null != 0"
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "If you don\\'t have anything i.e. positive, negative or zero. Then how someone can achieve any target."
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "There has to be some path. In case of no nodes, there is no path. The null path isn't a path."
                    },
                    {
                        "username": "Jinlong",
                        "content": "       1\\n2            *\\n\\nThe struct is like above, and the sum of  right path is 1. Why the output is false?\\n\\nAdditional:\\n\\nFind another problem: the output of \"{1}, 1\" is true......\\n\\nwhy....."
                    },
                    {
                        "username": "nghiadq",
                        "content": "A leaf is a node with no children. in this case 1 is not a leaf because have children 2, 2 is a leaf"
                    },
                    {
                        "username": "obiwon84",
                        "content": "Just a suggestion but the [] 0 test case makes you create a helper method or add additional complexity for no real gain. Could we perhaps delete that test case?\\n\\nIn all honesty it is rather ambigious if [] 0 should return false or true as there is a path that sums to nothing, the null path. Removing this test case would also remove that ambiguity."
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "\"0\" is not NULL. It is real value. Instead of zero it can be any positive or negative value also.\\nTherefore don\\'t consider zero as NULL"
                    },
                    {
                        "username": "slovic",
                        "content": "It depends of usecase... but suggested behavior is more strict, and thou it should be preferred. From implementation point of view it is even simpler to implement it with current spec, because you can reuse top level behavior to left and right nodes (if they are nulls then result is false no matter what so you can call `hasPathSum(root.left, targetSum-root.value)` and if left was null it will return good result."
                    },
                    {
                        "username": "ravichandrae",
                        "content": "This problem has a test case for testing whether there is any path sum 0 for an empty binary tree.\\n{},0\\n\\nIt expects the result as false. But I think it's more intuitive to state the result as true."
                    },
                    {
                        "username": "suraj813",
                        "content": "Root node 1 has 2 children - 2 & None\\nPathSum_1 = 1+2 = 3\\nPathSum_2 = 1+None = 1\\n\\nThe expected answer is false. Is PathSum_2 not valid?"
                    },
                    {
                        "username": "nichita_trifan",
                        "content": "its not a leaf node"
                    },
                    {
                        "username": "leo3065",
                        "content": "I think PathSum_2 is not valid since it does not end in a leaf node"
                    },
                    {
                        "username": "hopeNoPip",
                        "content": "If a root has a value of [1] with a target value 1, the expected answer is True for this problem.\\nHowever, this root has no leaf which means it does not satisfy what the question is asking for....\\n\\n[1,2] 1 will result a false case... how is [1] 1 a true case?\\nPlease explain."
                    },
                    {
                        "username": "luqmansen",
                        "content": "[@luqmansen](/luqmansen) okay got it, the answer should be root to leaf.\\n\\nleaf is node with no children \\n\\nin this case, the node is a root and a leaf at the same time"
                    },
                    {
                        "username": "luqmansen",
                        "content": "same here, confused with the expected answer, anyone?"
                    },
                    {
                        "username": "johnny231198",
                        "content": "By definition an empty sum is 0 and this test case says that there is no path in this tree with sum equal to 0. I think this is a mistake... Please correct me if I am wrong."
                    },
                    {
                        "username": "khushiagarwal220",
                        "content": "if there is only root node, then targetSum would be \\nzero"
                    },
                    {
                        "username": "siddh",
                        "content": "Is this case valid tree= [] , sum=0, expected=false, shouldn\\'t this be true"
                    },
                    {
                        "username": "ashwani5",
                        "content": "This question has a lot of inconsistent test cases.\\n\\nroot=[1,2], targetSum=1 is false\\nroot=[1], targetSum=1 is true"
                    },
                    {
                        "username": "leson1106",
                        "content": "it\\'s true because [1, 2] should valid with targetSum = 3 where 1 + 2 = 3 and 2 is a leaf. And [1], yeah there is only 1 leaf so targetSum = 1 is correct"
                    },
                    {
                        "username": "an_98",
                        "content": "Your input\\n[1,2]\\n1\\nOutput : true\\nExpected : false\\n\\nThere is a tree clearly, then how is it false. Please tell me where I am wrong?"
                    },
                    {
                        "username": "kamalraj5544",
                        "content": "[@noobcoder1729](/noobcoder1729) definition of leaf : node with has no children --> but here root has one left child .. so it cant be leaf ! "
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "[@noobcoder1729](/noobcoder1729) how root behaves as a leaf, if it has a child node?"
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "There is one single branch in your example. And its path sum is 3. 3 != 1"
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "We have to find path from root to leaf. Root here itself behaves as the leaf also. Therefore true. "
                    }
                ]
            },
            {
                "id": 1564962,
                "content": [
                    {
                        "username": "dong12",
                        "content": "why should 'input [],0'   return false?  Isn't it true?"
                    },
                    {
                        "username": "mayankagarwal2402",
                        "content": "[@AKA_RAN](/AKA_RAN) now you\\'re just devising an argument to support the faulty somehow. To counter your argument I\\'d say \"the given input(zero nodes) satisfies the target(zero) already hence it should have been true\". This question should\\'ve focused on testing my analytical and coding skills and not my grammatical skills. "
                    },
                    {
                        "username": "garyyaoresearch",
                        "content": "Problem statement not specific enough and both your and relies\\' interpretation are possible. That case messes up the most elegant solution"
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "null != 0"
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "If you don\\'t have anything i.e. positive, negative or zero. Then how someone can achieve any target."
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "There has to be some path. In case of no nodes, there is no path. The null path isn't a path."
                    },
                    {
                        "username": "Jinlong",
                        "content": "       1\\n2            *\\n\\nThe struct is like above, and the sum of  right path is 1. Why the output is false?\\n\\nAdditional:\\n\\nFind another problem: the output of \"{1}, 1\" is true......\\n\\nwhy....."
                    },
                    {
                        "username": "nghiadq",
                        "content": "A leaf is a node with no children. in this case 1 is not a leaf because have children 2, 2 is a leaf"
                    },
                    {
                        "username": "obiwon84",
                        "content": "Just a suggestion but the [] 0 test case makes you create a helper method or add additional complexity for no real gain. Could we perhaps delete that test case?\\n\\nIn all honesty it is rather ambigious if [] 0 should return false or true as there is a path that sums to nothing, the null path. Removing this test case would also remove that ambiguity."
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "\"0\" is not NULL. It is real value. Instead of zero it can be any positive or negative value also.\\nTherefore don\\'t consider zero as NULL"
                    },
                    {
                        "username": "slovic",
                        "content": "It depends of usecase... but suggested behavior is more strict, and thou it should be preferred. From implementation point of view it is even simpler to implement it with current spec, because you can reuse top level behavior to left and right nodes (if they are nulls then result is false no matter what so you can call `hasPathSum(root.left, targetSum-root.value)` and if left was null it will return good result."
                    },
                    {
                        "username": "ravichandrae",
                        "content": "This problem has a test case for testing whether there is any path sum 0 for an empty binary tree.\\n{},0\\n\\nIt expects the result as false. But I think it's more intuitive to state the result as true."
                    },
                    {
                        "username": "suraj813",
                        "content": "Root node 1 has 2 children - 2 & None\\nPathSum_1 = 1+2 = 3\\nPathSum_2 = 1+None = 1\\n\\nThe expected answer is false. Is PathSum_2 not valid?"
                    },
                    {
                        "username": "nichita_trifan",
                        "content": "its not a leaf node"
                    },
                    {
                        "username": "leo3065",
                        "content": "I think PathSum_2 is not valid since it does not end in a leaf node"
                    },
                    {
                        "username": "hopeNoPip",
                        "content": "If a root has a value of [1] with a target value 1, the expected answer is True for this problem.\\nHowever, this root has no leaf which means it does not satisfy what the question is asking for....\\n\\n[1,2] 1 will result a false case... how is [1] 1 a true case?\\nPlease explain."
                    },
                    {
                        "username": "luqmansen",
                        "content": "[@luqmansen](/luqmansen) okay got it, the answer should be root to leaf.\\n\\nleaf is node with no children \\n\\nin this case, the node is a root and a leaf at the same time"
                    },
                    {
                        "username": "luqmansen",
                        "content": "same here, confused with the expected answer, anyone?"
                    },
                    {
                        "username": "johnny231198",
                        "content": "By definition an empty sum is 0 and this test case says that there is no path in this tree with sum equal to 0. I think this is a mistake... Please correct me if I am wrong."
                    },
                    {
                        "username": "khushiagarwal220",
                        "content": "if there is only root node, then targetSum would be \\nzero"
                    },
                    {
                        "username": "siddh",
                        "content": "Is this case valid tree= [] , sum=0, expected=false, shouldn\\'t this be true"
                    },
                    {
                        "username": "ashwani5",
                        "content": "This question has a lot of inconsistent test cases.\\n\\nroot=[1,2], targetSum=1 is false\\nroot=[1], targetSum=1 is true"
                    },
                    {
                        "username": "leson1106",
                        "content": "it\\'s true because [1, 2] should valid with targetSum = 3 where 1 + 2 = 3 and 2 is a leaf. And [1], yeah there is only 1 leaf so targetSum = 1 is correct"
                    },
                    {
                        "username": "an_98",
                        "content": "Your input\\n[1,2]\\n1\\nOutput : true\\nExpected : false\\n\\nThere is a tree clearly, then how is it false. Please tell me where I am wrong?"
                    },
                    {
                        "username": "kamalraj5544",
                        "content": "[@noobcoder1729](/noobcoder1729) definition of leaf : node with has no children --> but here root has one left child .. so it cant be leaf ! "
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "[@noobcoder1729](/noobcoder1729) how root behaves as a leaf, if it has a child node?"
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "There is one single branch in your example. And its path sum is 3. 3 != 1"
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "We have to find path from root to leaf. Root here itself behaves as the leaf also. Therefore true. "
                    }
                ]
            },
            {
                "id": 1566325,
                "content": [
                    {
                        "username": "dong12",
                        "content": "why should 'input [],0'   return false?  Isn't it true?"
                    },
                    {
                        "username": "mayankagarwal2402",
                        "content": "[@AKA_RAN](/AKA_RAN) now you\\'re just devising an argument to support the faulty somehow. To counter your argument I\\'d say \"the given input(zero nodes) satisfies the target(zero) already hence it should have been true\". This question should\\'ve focused on testing my analytical and coding skills and not my grammatical skills. "
                    },
                    {
                        "username": "garyyaoresearch",
                        "content": "Problem statement not specific enough and both your and relies\\' interpretation are possible. That case messes up the most elegant solution"
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "null != 0"
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "If you don\\'t have anything i.e. positive, negative or zero. Then how someone can achieve any target."
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "There has to be some path. In case of no nodes, there is no path. The null path isn't a path."
                    },
                    {
                        "username": "Jinlong",
                        "content": "       1\\n2            *\\n\\nThe struct is like above, and the sum of  right path is 1. Why the output is false?\\n\\nAdditional:\\n\\nFind another problem: the output of \"{1}, 1\" is true......\\n\\nwhy....."
                    },
                    {
                        "username": "nghiadq",
                        "content": "A leaf is a node with no children. in this case 1 is not a leaf because have children 2, 2 is a leaf"
                    },
                    {
                        "username": "obiwon84",
                        "content": "Just a suggestion but the [] 0 test case makes you create a helper method or add additional complexity for no real gain. Could we perhaps delete that test case?\\n\\nIn all honesty it is rather ambigious if [] 0 should return false or true as there is a path that sums to nothing, the null path. Removing this test case would also remove that ambiguity."
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "\"0\" is not NULL. It is real value. Instead of zero it can be any positive or negative value also.\\nTherefore don\\'t consider zero as NULL"
                    },
                    {
                        "username": "slovic",
                        "content": "It depends of usecase... but suggested behavior is more strict, and thou it should be preferred. From implementation point of view it is even simpler to implement it with current spec, because you can reuse top level behavior to left and right nodes (if they are nulls then result is false no matter what so you can call `hasPathSum(root.left, targetSum-root.value)` and if left was null it will return good result."
                    },
                    {
                        "username": "ravichandrae",
                        "content": "This problem has a test case for testing whether there is any path sum 0 for an empty binary tree.\\n{},0\\n\\nIt expects the result as false. But I think it's more intuitive to state the result as true."
                    },
                    {
                        "username": "suraj813",
                        "content": "Root node 1 has 2 children - 2 & None\\nPathSum_1 = 1+2 = 3\\nPathSum_2 = 1+None = 1\\n\\nThe expected answer is false. Is PathSum_2 not valid?"
                    },
                    {
                        "username": "nichita_trifan",
                        "content": "its not a leaf node"
                    },
                    {
                        "username": "leo3065",
                        "content": "I think PathSum_2 is not valid since it does not end in a leaf node"
                    },
                    {
                        "username": "hopeNoPip",
                        "content": "If a root has a value of [1] with a target value 1, the expected answer is True for this problem.\\nHowever, this root has no leaf which means it does not satisfy what the question is asking for....\\n\\n[1,2] 1 will result a false case... how is [1] 1 a true case?\\nPlease explain."
                    },
                    {
                        "username": "luqmansen",
                        "content": "[@luqmansen](/luqmansen) okay got it, the answer should be root to leaf.\\n\\nleaf is node with no children \\n\\nin this case, the node is a root and a leaf at the same time"
                    },
                    {
                        "username": "luqmansen",
                        "content": "same here, confused with the expected answer, anyone?"
                    },
                    {
                        "username": "johnny231198",
                        "content": "By definition an empty sum is 0 and this test case says that there is no path in this tree with sum equal to 0. I think this is a mistake... Please correct me if I am wrong."
                    },
                    {
                        "username": "khushiagarwal220",
                        "content": "if there is only root node, then targetSum would be \\nzero"
                    },
                    {
                        "username": "siddh",
                        "content": "Is this case valid tree= [] , sum=0, expected=false, shouldn\\'t this be true"
                    },
                    {
                        "username": "ashwani5",
                        "content": "This question has a lot of inconsistent test cases.\\n\\nroot=[1,2], targetSum=1 is false\\nroot=[1], targetSum=1 is true"
                    },
                    {
                        "username": "leson1106",
                        "content": "it\\'s true because [1, 2] should valid with targetSum = 3 where 1 + 2 = 3 and 2 is a leaf. And [1], yeah there is only 1 leaf so targetSum = 1 is correct"
                    },
                    {
                        "username": "an_98",
                        "content": "Your input\\n[1,2]\\n1\\nOutput : true\\nExpected : false\\n\\nThere is a tree clearly, then how is it false. Please tell me where I am wrong?"
                    },
                    {
                        "username": "kamalraj5544",
                        "content": "[@noobcoder1729](/noobcoder1729) definition of leaf : node with has no children --> but here root has one left child .. so it cant be leaf ! "
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "[@noobcoder1729](/noobcoder1729) how root behaves as a leaf, if it has a child node?"
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "There is one single branch in your example. And its path sum is 3. 3 != 1"
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "We have to find path from root to leaf. Root here itself behaves as the leaf also. Therefore true. "
                    }
                ]
            },
            {
                "id": 1566073,
                "content": [
                    {
                        "username": "dong12",
                        "content": "why should 'input [],0'   return false?  Isn't it true?"
                    },
                    {
                        "username": "mayankagarwal2402",
                        "content": "[@AKA_RAN](/AKA_RAN) now you\\'re just devising an argument to support the faulty somehow. To counter your argument I\\'d say \"the given input(zero nodes) satisfies the target(zero) already hence it should have been true\". This question should\\'ve focused on testing my analytical and coding skills and not my grammatical skills. "
                    },
                    {
                        "username": "garyyaoresearch",
                        "content": "Problem statement not specific enough and both your and relies\\' interpretation are possible. That case messes up the most elegant solution"
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "null != 0"
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "If you don\\'t have anything i.e. positive, negative or zero. Then how someone can achieve any target."
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "There has to be some path. In case of no nodes, there is no path. The null path isn't a path."
                    },
                    {
                        "username": "Jinlong",
                        "content": "       1\\n2            *\\n\\nThe struct is like above, and the sum of  right path is 1. Why the output is false?\\n\\nAdditional:\\n\\nFind another problem: the output of \"{1}, 1\" is true......\\n\\nwhy....."
                    },
                    {
                        "username": "nghiadq",
                        "content": "A leaf is a node with no children. in this case 1 is not a leaf because have children 2, 2 is a leaf"
                    },
                    {
                        "username": "obiwon84",
                        "content": "Just a suggestion but the [] 0 test case makes you create a helper method or add additional complexity for no real gain. Could we perhaps delete that test case?\\n\\nIn all honesty it is rather ambigious if [] 0 should return false or true as there is a path that sums to nothing, the null path. Removing this test case would also remove that ambiguity."
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "\"0\" is not NULL. It is real value. Instead of zero it can be any positive or negative value also.\\nTherefore don\\'t consider zero as NULL"
                    },
                    {
                        "username": "slovic",
                        "content": "It depends of usecase... but suggested behavior is more strict, and thou it should be preferred. From implementation point of view it is even simpler to implement it with current spec, because you can reuse top level behavior to left and right nodes (if they are nulls then result is false no matter what so you can call `hasPathSum(root.left, targetSum-root.value)` and if left was null it will return good result."
                    },
                    {
                        "username": "ravichandrae",
                        "content": "This problem has a test case for testing whether there is any path sum 0 for an empty binary tree.\\n{},0\\n\\nIt expects the result as false. But I think it's more intuitive to state the result as true."
                    },
                    {
                        "username": "suraj813",
                        "content": "Root node 1 has 2 children - 2 & None\\nPathSum_1 = 1+2 = 3\\nPathSum_2 = 1+None = 1\\n\\nThe expected answer is false. Is PathSum_2 not valid?"
                    },
                    {
                        "username": "nichita_trifan",
                        "content": "its not a leaf node"
                    },
                    {
                        "username": "leo3065",
                        "content": "I think PathSum_2 is not valid since it does not end in a leaf node"
                    },
                    {
                        "username": "hopeNoPip",
                        "content": "If a root has a value of [1] with a target value 1, the expected answer is True for this problem.\\nHowever, this root has no leaf which means it does not satisfy what the question is asking for....\\n\\n[1,2] 1 will result a false case... how is [1] 1 a true case?\\nPlease explain."
                    },
                    {
                        "username": "luqmansen",
                        "content": "[@luqmansen](/luqmansen) okay got it, the answer should be root to leaf.\\n\\nleaf is node with no children \\n\\nin this case, the node is a root and a leaf at the same time"
                    },
                    {
                        "username": "luqmansen",
                        "content": "same here, confused with the expected answer, anyone?"
                    },
                    {
                        "username": "johnny231198",
                        "content": "By definition an empty sum is 0 and this test case says that there is no path in this tree with sum equal to 0. I think this is a mistake... Please correct me if I am wrong."
                    },
                    {
                        "username": "khushiagarwal220",
                        "content": "if there is only root node, then targetSum would be \\nzero"
                    },
                    {
                        "username": "siddh",
                        "content": "Is this case valid tree= [] , sum=0, expected=false, shouldn\\'t this be true"
                    },
                    {
                        "username": "ashwani5",
                        "content": "This question has a lot of inconsistent test cases.\\n\\nroot=[1,2], targetSum=1 is false\\nroot=[1], targetSum=1 is true"
                    },
                    {
                        "username": "leson1106",
                        "content": "it\\'s true because [1, 2] should valid with targetSum = 3 where 1 + 2 = 3 and 2 is a leaf. And [1], yeah there is only 1 leaf so targetSum = 1 is correct"
                    },
                    {
                        "username": "an_98",
                        "content": "Your input\\n[1,2]\\n1\\nOutput : true\\nExpected : false\\n\\nThere is a tree clearly, then how is it false. Please tell me where I am wrong?"
                    },
                    {
                        "username": "kamalraj5544",
                        "content": "[@noobcoder1729](/noobcoder1729) definition of leaf : node with has no children --> but here root has one left child .. so it cant be leaf ! "
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "[@noobcoder1729](/noobcoder1729) how root behaves as a leaf, if it has a child node?"
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "There is one single branch in your example. And its path sum is 3. 3 != 1"
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "We have to find path from root to leaf. Root here itself behaves as the leaf also. Therefore true. "
                    }
                ]
            },
            {
                "id": 1568025,
                "content": [
                    {
                        "username": "dong12",
                        "content": "why should 'input [],0'   return false?  Isn't it true?"
                    },
                    {
                        "username": "mayankagarwal2402",
                        "content": "[@AKA_RAN](/AKA_RAN) now you\\'re just devising an argument to support the faulty somehow. To counter your argument I\\'d say \"the given input(zero nodes) satisfies the target(zero) already hence it should have been true\". This question should\\'ve focused on testing my analytical and coding skills and not my grammatical skills. "
                    },
                    {
                        "username": "garyyaoresearch",
                        "content": "Problem statement not specific enough and both your and relies\\' interpretation are possible. That case messes up the most elegant solution"
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "null != 0"
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "If you don\\'t have anything i.e. positive, negative or zero. Then how someone can achieve any target."
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "There has to be some path. In case of no nodes, there is no path. The null path isn't a path."
                    },
                    {
                        "username": "Jinlong",
                        "content": "       1\\n2            *\\n\\nThe struct is like above, and the sum of  right path is 1. Why the output is false?\\n\\nAdditional:\\n\\nFind another problem: the output of \"{1}, 1\" is true......\\n\\nwhy....."
                    },
                    {
                        "username": "nghiadq",
                        "content": "A leaf is a node with no children. in this case 1 is not a leaf because have children 2, 2 is a leaf"
                    },
                    {
                        "username": "obiwon84",
                        "content": "Just a suggestion but the [] 0 test case makes you create a helper method or add additional complexity for no real gain. Could we perhaps delete that test case?\\n\\nIn all honesty it is rather ambigious if [] 0 should return false or true as there is a path that sums to nothing, the null path. Removing this test case would also remove that ambiguity."
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "\"0\" is not NULL. It is real value. Instead of zero it can be any positive or negative value also.\\nTherefore don\\'t consider zero as NULL"
                    },
                    {
                        "username": "slovic",
                        "content": "It depends of usecase... but suggested behavior is more strict, and thou it should be preferred. From implementation point of view it is even simpler to implement it with current spec, because you can reuse top level behavior to left and right nodes (if they are nulls then result is false no matter what so you can call `hasPathSum(root.left, targetSum-root.value)` and if left was null it will return good result."
                    },
                    {
                        "username": "ravichandrae",
                        "content": "This problem has a test case for testing whether there is any path sum 0 for an empty binary tree.\\n{},0\\n\\nIt expects the result as false. But I think it's more intuitive to state the result as true."
                    },
                    {
                        "username": "suraj813",
                        "content": "Root node 1 has 2 children - 2 & None\\nPathSum_1 = 1+2 = 3\\nPathSum_2 = 1+None = 1\\n\\nThe expected answer is false. Is PathSum_2 not valid?"
                    },
                    {
                        "username": "nichita_trifan",
                        "content": "its not a leaf node"
                    },
                    {
                        "username": "leo3065",
                        "content": "I think PathSum_2 is not valid since it does not end in a leaf node"
                    },
                    {
                        "username": "hopeNoPip",
                        "content": "If a root has a value of [1] with a target value 1, the expected answer is True for this problem.\\nHowever, this root has no leaf which means it does not satisfy what the question is asking for....\\n\\n[1,2] 1 will result a false case... how is [1] 1 a true case?\\nPlease explain."
                    },
                    {
                        "username": "luqmansen",
                        "content": "[@luqmansen](/luqmansen) okay got it, the answer should be root to leaf.\\n\\nleaf is node with no children \\n\\nin this case, the node is a root and a leaf at the same time"
                    },
                    {
                        "username": "luqmansen",
                        "content": "same here, confused with the expected answer, anyone?"
                    },
                    {
                        "username": "johnny231198",
                        "content": "By definition an empty sum is 0 and this test case says that there is no path in this tree with sum equal to 0. I think this is a mistake... Please correct me if I am wrong."
                    },
                    {
                        "username": "khushiagarwal220",
                        "content": "if there is only root node, then targetSum would be \\nzero"
                    },
                    {
                        "username": "siddh",
                        "content": "Is this case valid tree= [] , sum=0, expected=false, shouldn\\'t this be true"
                    },
                    {
                        "username": "ashwani5",
                        "content": "This question has a lot of inconsistent test cases.\\n\\nroot=[1,2], targetSum=1 is false\\nroot=[1], targetSum=1 is true"
                    },
                    {
                        "username": "leson1106",
                        "content": "it\\'s true because [1, 2] should valid with targetSum = 3 where 1 + 2 = 3 and 2 is a leaf. And [1], yeah there is only 1 leaf so targetSum = 1 is correct"
                    },
                    {
                        "username": "an_98",
                        "content": "Your input\\n[1,2]\\n1\\nOutput : true\\nExpected : false\\n\\nThere is a tree clearly, then how is it false. Please tell me where I am wrong?"
                    },
                    {
                        "username": "kamalraj5544",
                        "content": "[@noobcoder1729](/noobcoder1729) definition of leaf : node with has no children --> but here root has one left child .. so it cant be leaf ! "
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "[@noobcoder1729](/noobcoder1729) how root behaves as a leaf, if it has a child node?"
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "There is one single branch in your example. And its path sum is 3. 3 != 1"
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "We have to find path from root to leaf. Root here itself behaves as the leaf also. Therefore true. "
                    }
                ]
            },
            {
                "id": 1572485,
                "content": [
                    {
                        "username": "dong12",
                        "content": "why should 'input [],0'   return false?  Isn't it true?"
                    },
                    {
                        "username": "mayankagarwal2402",
                        "content": "[@AKA_RAN](/AKA_RAN) now you\\'re just devising an argument to support the faulty somehow. To counter your argument I\\'d say \"the given input(zero nodes) satisfies the target(zero) already hence it should have been true\". This question should\\'ve focused on testing my analytical and coding skills and not my grammatical skills. "
                    },
                    {
                        "username": "garyyaoresearch",
                        "content": "Problem statement not specific enough and both your and relies\\' interpretation are possible. That case messes up the most elegant solution"
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "null != 0"
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "If you don\\'t have anything i.e. positive, negative or zero. Then how someone can achieve any target."
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "There has to be some path. In case of no nodes, there is no path. The null path isn't a path."
                    },
                    {
                        "username": "Jinlong",
                        "content": "       1\\n2            *\\n\\nThe struct is like above, and the sum of  right path is 1. Why the output is false?\\n\\nAdditional:\\n\\nFind another problem: the output of \"{1}, 1\" is true......\\n\\nwhy....."
                    },
                    {
                        "username": "nghiadq",
                        "content": "A leaf is a node with no children. in this case 1 is not a leaf because have children 2, 2 is a leaf"
                    },
                    {
                        "username": "obiwon84",
                        "content": "Just a suggestion but the [] 0 test case makes you create a helper method or add additional complexity for no real gain. Could we perhaps delete that test case?\\n\\nIn all honesty it is rather ambigious if [] 0 should return false or true as there is a path that sums to nothing, the null path. Removing this test case would also remove that ambiguity."
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "\"0\" is not NULL. It is real value. Instead of zero it can be any positive or negative value also.\\nTherefore don\\'t consider zero as NULL"
                    },
                    {
                        "username": "slovic",
                        "content": "It depends of usecase... but suggested behavior is more strict, and thou it should be preferred. From implementation point of view it is even simpler to implement it with current spec, because you can reuse top level behavior to left and right nodes (if they are nulls then result is false no matter what so you can call `hasPathSum(root.left, targetSum-root.value)` and if left was null it will return good result."
                    },
                    {
                        "username": "ravichandrae",
                        "content": "This problem has a test case for testing whether there is any path sum 0 for an empty binary tree.\\n{},0\\n\\nIt expects the result as false. But I think it's more intuitive to state the result as true."
                    },
                    {
                        "username": "suraj813",
                        "content": "Root node 1 has 2 children - 2 & None\\nPathSum_1 = 1+2 = 3\\nPathSum_2 = 1+None = 1\\n\\nThe expected answer is false. Is PathSum_2 not valid?"
                    },
                    {
                        "username": "nichita_trifan",
                        "content": "its not a leaf node"
                    },
                    {
                        "username": "leo3065",
                        "content": "I think PathSum_2 is not valid since it does not end in a leaf node"
                    },
                    {
                        "username": "hopeNoPip",
                        "content": "If a root has a value of [1] with a target value 1, the expected answer is True for this problem.\\nHowever, this root has no leaf which means it does not satisfy what the question is asking for....\\n\\n[1,2] 1 will result a false case... how is [1] 1 a true case?\\nPlease explain."
                    },
                    {
                        "username": "luqmansen",
                        "content": "[@luqmansen](/luqmansen) okay got it, the answer should be root to leaf.\\n\\nleaf is node with no children \\n\\nin this case, the node is a root and a leaf at the same time"
                    },
                    {
                        "username": "luqmansen",
                        "content": "same here, confused with the expected answer, anyone?"
                    },
                    {
                        "username": "johnny231198",
                        "content": "By definition an empty sum is 0 and this test case says that there is no path in this tree with sum equal to 0. I think this is a mistake... Please correct me if I am wrong."
                    },
                    {
                        "username": "khushiagarwal220",
                        "content": "if there is only root node, then targetSum would be \\nzero"
                    },
                    {
                        "username": "siddh",
                        "content": "Is this case valid tree= [] , sum=0, expected=false, shouldn\\'t this be true"
                    },
                    {
                        "username": "ashwani5",
                        "content": "This question has a lot of inconsistent test cases.\\n\\nroot=[1,2], targetSum=1 is false\\nroot=[1], targetSum=1 is true"
                    },
                    {
                        "username": "leson1106",
                        "content": "it\\'s true because [1, 2] should valid with targetSum = 3 where 1 + 2 = 3 and 2 is a leaf. And [1], yeah there is only 1 leaf so targetSum = 1 is correct"
                    },
                    {
                        "username": "an_98",
                        "content": "Your input\\n[1,2]\\n1\\nOutput : true\\nExpected : false\\n\\nThere is a tree clearly, then how is it false. Please tell me where I am wrong?"
                    },
                    {
                        "username": "kamalraj5544",
                        "content": "[@noobcoder1729](/noobcoder1729) definition of leaf : node with has no children --> but here root has one left child .. so it cant be leaf ! "
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "[@noobcoder1729](/noobcoder1729) how root behaves as a leaf, if it has a child node?"
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "There is one single branch in your example. And its path sum is 3. 3 != 1"
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "We have to find path from root to leaf. Root here itself behaves as the leaf also. Therefore true. "
                    }
                ]
            },
            {
                "id": 1566969,
                "content": [
                    {
                        "username": "dong12",
                        "content": "why should 'input [],0'   return false?  Isn't it true?"
                    },
                    {
                        "username": "mayankagarwal2402",
                        "content": "[@AKA_RAN](/AKA_RAN) now you\\'re just devising an argument to support the faulty somehow. To counter your argument I\\'d say \"the given input(zero nodes) satisfies the target(zero) already hence it should have been true\". This question should\\'ve focused on testing my analytical and coding skills and not my grammatical skills. "
                    },
                    {
                        "username": "garyyaoresearch",
                        "content": "Problem statement not specific enough and both your and relies\\' interpretation are possible. That case messes up the most elegant solution"
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "null != 0"
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "If you don\\'t have anything i.e. positive, negative or zero. Then how someone can achieve any target."
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "There has to be some path. In case of no nodes, there is no path. The null path isn't a path."
                    },
                    {
                        "username": "Jinlong",
                        "content": "       1\\n2            *\\n\\nThe struct is like above, and the sum of  right path is 1. Why the output is false?\\n\\nAdditional:\\n\\nFind another problem: the output of \"{1}, 1\" is true......\\n\\nwhy....."
                    },
                    {
                        "username": "nghiadq",
                        "content": "A leaf is a node with no children. in this case 1 is not a leaf because have children 2, 2 is a leaf"
                    },
                    {
                        "username": "obiwon84",
                        "content": "Just a suggestion but the [] 0 test case makes you create a helper method or add additional complexity for no real gain. Could we perhaps delete that test case?\\n\\nIn all honesty it is rather ambigious if [] 0 should return false or true as there is a path that sums to nothing, the null path. Removing this test case would also remove that ambiguity."
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "\"0\" is not NULL. It is real value. Instead of zero it can be any positive or negative value also.\\nTherefore don\\'t consider zero as NULL"
                    },
                    {
                        "username": "slovic",
                        "content": "It depends of usecase... but suggested behavior is more strict, and thou it should be preferred. From implementation point of view it is even simpler to implement it with current spec, because you can reuse top level behavior to left and right nodes (if they are nulls then result is false no matter what so you can call `hasPathSum(root.left, targetSum-root.value)` and if left was null it will return good result."
                    },
                    {
                        "username": "ravichandrae",
                        "content": "This problem has a test case for testing whether there is any path sum 0 for an empty binary tree.\\n{},0\\n\\nIt expects the result as false. But I think it's more intuitive to state the result as true."
                    },
                    {
                        "username": "suraj813",
                        "content": "Root node 1 has 2 children - 2 & None\\nPathSum_1 = 1+2 = 3\\nPathSum_2 = 1+None = 1\\n\\nThe expected answer is false. Is PathSum_2 not valid?"
                    },
                    {
                        "username": "nichita_trifan",
                        "content": "its not a leaf node"
                    },
                    {
                        "username": "leo3065",
                        "content": "I think PathSum_2 is not valid since it does not end in a leaf node"
                    },
                    {
                        "username": "hopeNoPip",
                        "content": "If a root has a value of [1] with a target value 1, the expected answer is True for this problem.\\nHowever, this root has no leaf which means it does not satisfy what the question is asking for....\\n\\n[1,2] 1 will result a false case... how is [1] 1 a true case?\\nPlease explain."
                    },
                    {
                        "username": "luqmansen",
                        "content": "[@luqmansen](/luqmansen) okay got it, the answer should be root to leaf.\\n\\nleaf is node with no children \\n\\nin this case, the node is a root and a leaf at the same time"
                    },
                    {
                        "username": "luqmansen",
                        "content": "same here, confused with the expected answer, anyone?"
                    },
                    {
                        "username": "johnny231198",
                        "content": "By definition an empty sum is 0 and this test case says that there is no path in this tree with sum equal to 0. I think this is a mistake... Please correct me if I am wrong."
                    },
                    {
                        "username": "khushiagarwal220",
                        "content": "if there is only root node, then targetSum would be \\nzero"
                    },
                    {
                        "username": "siddh",
                        "content": "Is this case valid tree= [] , sum=0, expected=false, shouldn\\'t this be true"
                    },
                    {
                        "username": "ashwani5",
                        "content": "This question has a lot of inconsistent test cases.\\n\\nroot=[1,2], targetSum=1 is false\\nroot=[1], targetSum=1 is true"
                    },
                    {
                        "username": "leson1106",
                        "content": "it\\'s true because [1, 2] should valid with targetSum = 3 where 1 + 2 = 3 and 2 is a leaf. And [1], yeah there is only 1 leaf so targetSum = 1 is correct"
                    },
                    {
                        "username": "an_98",
                        "content": "Your input\\n[1,2]\\n1\\nOutput : true\\nExpected : false\\n\\nThere is a tree clearly, then how is it false. Please tell me where I am wrong?"
                    },
                    {
                        "username": "kamalraj5544",
                        "content": "[@noobcoder1729](/noobcoder1729) definition of leaf : node with has no children --> but here root has one left child .. so it cant be leaf ! "
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "[@noobcoder1729](/noobcoder1729) how root behaves as a leaf, if it has a child node?"
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "There is one single branch in your example. And its path sum is 3. 3 != 1"
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "We have to find path from root to leaf. Root here itself behaves as the leaf also. Therefore true. "
                    }
                ]
            },
            {
                "id": 1570035,
                "content": [
                    {
                        "username": "dong12",
                        "content": "why should 'input [],0'   return false?  Isn't it true?"
                    },
                    {
                        "username": "mayankagarwal2402",
                        "content": "[@AKA_RAN](/AKA_RAN) now you\\'re just devising an argument to support the faulty somehow. To counter your argument I\\'d say \"the given input(zero nodes) satisfies the target(zero) already hence it should have been true\". This question should\\'ve focused on testing my analytical and coding skills and not my grammatical skills. "
                    },
                    {
                        "username": "garyyaoresearch",
                        "content": "Problem statement not specific enough and both your and relies\\' interpretation are possible. That case messes up the most elegant solution"
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "null != 0"
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "If you don\\'t have anything i.e. positive, negative or zero. Then how someone can achieve any target."
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "There has to be some path. In case of no nodes, there is no path. The null path isn't a path."
                    },
                    {
                        "username": "Jinlong",
                        "content": "       1\\n2            *\\n\\nThe struct is like above, and the sum of  right path is 1. Why the output is false?\\n\\nAdditional:\\n\\nFind another problem: the output of \"{1}, 1\" is true......\\n\\nwhy....."
                    },
                    {
                        "username": "nghiadq",
                        "content": "A leaf is a node with no children. in this case 1 is not a leaf because have children 2, 2 is a leaf"
                    },
                    {
                        "username": "obiwon84",
                        "content": "Just a suggestion but the [] 0 test case makes you create a helper method or add additional complexity for no real gain. Could we perhaps delete that test case?\\n\\nIn all honesty it is rather ambigious if [] 0 should return false or true as there is a path that sums to nothing, the null path. Removing this test case would also remove that ambiguity."
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "\"0\" is not NULL. It is real value. Instead of zero it can be any positive or negative value also.\\nTherefore don\\'t consider zero as NULL"
                    },
                    {
                        "username": "slovic",
                        "content": "It depends of usecase... but suggested behavior is more strict, and thou it should be preferred. From implementation point of view it is even simpler to implement it with current spec, because you can reuse top level behavior to left and right nodes (if they are nulls then result is false no matter what so you can call `hasPathSum(root.left, targetSum-root.value)` and if left was null it will return good result."
                    },
                    {
                        "username": "ravichandrae",
                        "content": "This problem has a test case for testing whether there is any path sum 0 for an empty binary tree.\\n{},0\\n\\nIt expects the result as false. But I think it's more intuitive to state the result as true."
                    },
                    {
                        "username": "suraj813",
                        "content": "Root node 1 has 2 children - 2 & None\\nPathSum_1 = 1+2 = 3\\nPathSum_2 = 1+None = 1\\n\\nThe expected answer is false. Is PathSum_2 not valid?"
                    },
                    {
                        "username": "nichita_trifan",
                        "content": "its not a leaf node"
                    },
                    {
                        "username": "leo3065",
                        "content": "I think PathSum_2 is not valid since it does not end in a leaf node"
                    },
                    {
                        "username": "hopeNoPip",
                        "content": "If a root has a value of [1] with a target value 1, the expected answer is True for this problem.\\nHowever, this root has no leaf which means it does not satisfy what the question is asking for....\\n\\n[1,2] 1 will result a false case... how is [1] 1 a true case?\\nPlease explain."
                    },
                    {
                        "username": "luqmansen",
                        "content": "[@luqmansen](/luqmansen) okay got it, the answer should be root to leaf.\\n\\nleaf is node with no children \\n\\nin this case, the node is a root and a leaf at the same time"
                    },
                    {
                        "username": "luqmansen",
                        "content": "same here, confused with the expected answer, anyone?"
                    },
                    {
                        "username": "johnny231198",
                        "content": "By definition an empty sum is 0 and this test case says that there is no path in this tree with sum equal to 0. I think this is a mistake... Please correct me if I am wrong."
                    },
                    {
                        "username": "khushiagarwal220",
                        "content": "if there is only root node, then targetSum would be \\nzero"
                    },
                    {
                        "username": "siddh",
                        "content": "Is this case valid tree= [] , sum=0, expected=false, shouldn\\'t this be true"
                    },
                    {
                        "username": "ashwani5",
                        "content": "This question has a lot of inconsistent test cases.\\n\\nroot=[1,2], targetSum=1 is false\\nroot=[1], targetSum=1 is true"
                    },
                    {
                        "username": "leson1106",
                        "content": "it\\'s true because [1, 2] should valid with targetSum = 3 where 1 + 2 = 3 and 2 is a leaf. And [1], yeah there is only 1 leaf so targetSum = 1 is correct"
                    },
                    {
                        "username": "an_98",
                        "content": "Your input\\n[1,2]\\n1\\nOutput : true\\nExpected : false\\n\\nThere is a tree clearly, then how is it false. Please tell me where I am wrong?"
                    },
                    {
                        "username": "kamalraj5544",
                        "content": "[@noobcoder1729](/noobcoder1729) definition of leaf : node with has no children --> but here root has one left child .. so it cant be leaf ! "
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "[@noobcoder1729](/noobcoder1729) how root behaves as a leaf, if it has a child node?"
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "There is one single branch in your example. And its path sum is 3. 3 != 1"
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "We have to find path from root to leaf. Root here itself behaves as the leaf also. Therefore true. "
                    }
                ]
            },
            {
                "id": 1815767,
                "content": [
                    {
                        "username": "dong12",
                        "content": "why should 'input [],0'   return false?  Isn't it true?"
                    },
                    {
                        "username": "mayankagarwal2402",
                        "content": "[@AKA_RAN](/AKA_RAN) now you\\'re just devising an argument to support the faulty somehow. To counter your argument I\\'d say \"the given input(zero nodes) satisfies the target(zero) already hence it should have been true\". This question should\\'ve focused on testing my analytical and coding skills and not my grammatical skills. "
                    },
                    {
                        "username": "garyyaoresearch",
                        "content": "Problem statement not specific enough and both your and relies\\' interpretation are possible. That case messes up the most elegant solution"
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "null != 0"
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "If you don\\'t have anything i.e. positive, negative or zero. Then how someone can achieve any target."
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "There has to be some path. In case of no nodes, there is no path. The null path isn't a path."
                    },
                    {
                        "username": "Jinlong",
                        "content": "       1\\n2            *\\n\\nThe struct is like above, and the sum of  right path is 1. Why the output is false?\\n\\nAdditional:\\n\\nFind another problem: the output of \"{1}, 1\" is true......\\n\\nwhy....."
                    },
                    {
                        "username": "nghiadq",
                        "content": "A leaf is a node with no children. in this case 1 is not a leaf because have children 2, 2 is a leaf"
                    },
                    {
                        "username": "obiwon84",
                        "content": "Just a suggestion but the [] 0 test case makes you create a helper method or add additional complexity for no real gain. Could we perhaps delete that test case?\\n\\nIn all honesty it is rather ambigious if [] 0 should return false or true as there is a path that sums to nothing, the null path. Removing this test case would also remove that ambiguity."
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "\"0\" is not NULL. It is real value. Instead of zero it can be any positive or negative value also.\\nTherefore don\\'t consider zero as NULL"
                    },
                    {
                        "username": "slovic",
                        "content": "It depends of usecase... but suggested behavior is more strict, and thou it should be preferred. From implementation point of view it is even simpler to implement it with current spec, because you can reuse top level behavior to left and right nodes (if they are nulls then result is false no matter what so you can call `hasPathSum(root.left, targetSum-root.value)` and if left was null it will return good result."
                    },
                    {
                        "username": "ravichandrae",
                        "content": "This problem has a test case for testing whether there is any path sum 0 for an empty binary tree.\\n{},0\\n\\nIt expects the result as false. But I think it's more intuitive to state the result as true."
                    },
                    {
                        "username": "suraj813",
                        "content": "Root node 1 has 2 children - 2 & None\\nPathSum_1 = 1+2 = 3\\nPathSum_2 = 1+None = 1\\n\\nThe expected answer is false. Is PathSum_2 not valid?"
                    },
                    {
                        "username": "nichita_trifan",
                        "content": "its not a leaf node"
                    },
                    {
                        "username": "leo3065",
                        "content": "I think PathSum_2 is not valid since it does not end in a leaf node"
                    },
                    {
                        "username": "hopeNoPip",
                        "content": "If a root has a value of [1] with a target value 1, the expected answer is True for this problem.\\nHowever, this root has no leaf which means it does not satisfy what the question is asking for....\\n\\n[1,2] 1 will result a false case... how is [1] 1 a true case?\\nPlease explain."
                    },
                    {
                        "username": "luqmansen",
                        "content": "[@luqmansen](/luqmansen) okay got it, the answer should be root to leaf.\\n\\nleaf is node with no children \\n\\nin this case, the node is a root and a leaf at the same time"
                    },
                    {
                        "username": "luqmansen",
                        "content": "same here, confused with the expected answer, anyone?"
                    },
                    {
                        "username": "johnny231198",
                        "content": "By definition an empty sum is 0 and this test case says that there is no path in this tree with sum equal to 0. I think this is a mistake... Please correct me if I am wrong."
                    },
                    {
                        "username": "khushiagarwal220",
                        "content": "if there is only root node, then targetSum would be \\nzero"
                    },
                    {
                        "username": "siddh",
                        "content": "Is this case valid tree= [] , sum=0, expected=false, shouldn\\'t this be true"
                    },
                    {
                        "username": "ashwani5",
                        "content": "This question has a lot of inconsistent test cases.\\n\\nroot=[1,2], targetSum=1 is false\\nroot=[1], targetSum=1 is true"
                    },
                    {
                        "username": "leson1106",
                        "content": "it\\'s true because [1, 2] should valid with targetSum = 3 where 1 + 2 = 3 and 2 is a leaf. And [1], yeah there is only 1 leaf so targetSum = 1 is correct"
                    },
                    {
                        "username": "an_98",
                        "content": "Your input\\n[1,2]\\n1\\nOutput : true\\nExpected : false\\n\\nThere is a tree clearly, then how is it false. Please tell me where I am wrong?"
                    },
                    {
                        "username": "kamalraj5544",
                        "content": "[@noobcoder1729](/noobcoder1729) definition of leaf : node with has no children --> but here root has one left child .. so it cant be leaf ! "
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "[@noobcoder1729](/noobcoder1729) how root behaves as a leaf, if it has a child node?"
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "There is one single branch in your example. And its path sum is 3. 3 != 1"
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "We have to find path from root to leaf. Root here itself behaves as the leaf also. Therefore true. "
                    }
                ]
            },
            {
                "id": 1574172,
                "content": [
                    {
                        "username": "dong12",
                        "content": "why should 'input [],0'   return false?  Isn't it true?"
                    },
                    {
                        "username": "mayankagarwal2402",
                        "content": "[@AKA_RAN](/AKA_RAN) now you\\'re just devising an argument to support the faulty somehow. To counter your argument I\\'d say \"the given input(zero nodes) satisfies the target(zero) already hence it should have been true\". This question should\\'ve focused on testing my analytical and coding skills and not my grammatical skills. "
                    },
                    {
                        "username": "garyyaoresearch",
                        "content": "Problem statement not specific enough and both your and relies\\' interpretation are possible. That case messes up the most elegant solution"
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "null != 0"
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "If you don\\'t have anything i.e. positive, negative or zero. Then how someone can achieve any target."
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "There has to be some path. In case of no nodes, there is no path. The null path isn't a path."
                    },
                    {
                        "username": "Jinlong",
                        "content": "       1\\n2            *\\n\\nThe struct is like above, and the sum of  right path is 1. Why the output is false?\\n\\nAdditional:\\n\\nFind another problem: the output of \"{1}, 1\" is true......\\n\\nwhy....."
                    },
                    {
                        "username": "nghiadq",
                        "content": "A leaf is a node with no children. in this case 1 is not a leaf because have children 2, 2 is a leaf"
                    },
                    {
                        "username": "obiwon84",
                        "content": "Just a suggestion but the [] 0 test case makes you create a helper method or add additional complexity for no real gain. Could we perhaps delete that test case?\\n\\nIn all honesty it is rather ambigious if [] 0 should return false or true as there is a path that sums to nothing, the null path. Removing this test case would also remove that ambiguity."
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "\"0\" is not NULL. It is real value. Instead of zero it can be any positive or negative value also.\\nTherefore don\\'t consider zero as NULL"
                    },
                    {
                        "username": "slovic",
                        "content": "It depends of usecase... but suggested behavior is more strict, and thou it should be preferred. From implementation point of view it is even simpler to implement it with current spec, because you can reuse top level behavior to left and right nodes (if they are nulls then result is false no matter what so you can call `hasPathSum(root.left, targetSum-root.value)` and if left was null it will return good result."
                    },
                    {
                        "username": "ravichandrae",
                        "content": "This problem has a test case for testing whether there is any path sum 0 for an empty binary tree.\\n{},0\\n\\nIt expects the result as false. But I think it's more intuitive to state the result as true."
                    },
                    {
                        "username": "suraj813",
                        "content": "Root node 1 has 2 children - 2 & None\\nPathSum_1 = 1+2 = 3\\nPathSum_2 = 1+None = 1\\n\\nThe expected answer is false. Is PathSum_2 not valid?"
                    },
                    {
                        "username": "nichita_trifan",
                        "content": "its not a leaf node"
                    },
                    {
                        "username": "leo3065",
                        "content": "I think PathSum_2 is not valid since it does not end in a leaf node"
                    },
                    {
                        "username": "hopeNoPip",
                        "content": "If a root has a value of [1] with a target value 1, the expected answer is True for this problem.\\nHowever, this root has no leaf which means it does not satisfy what the question is asking for....\\n\\n[1,2] 1 will result a false case... how is [1] 1 a true case?\\nPlease explain."
                    },
                    {
                        "username": "luqmansen",
                        "content": "[@luqmansen](/luqmansen) okay got it, the answer should be root to leaf.\\n\\nleaf is node with no children \\n\\nin this case, the node is a root and a leaf at the same time"
                    },
                    {
                        "username": "luqmansen",
                        "content": "same here, confused with the expected answer, anyone?"
                    },
                    {
                        "username": "johnny231198",
                        "content": "By definition an empty sum is 0 and this test case says that there is no path in this tree with sum equal to 0. I think this is a mistake... Please correct me if I am wrong."
                    },
                    {
                        "username": "khushiagarwal220",
                        "content": "if there is only root node, then targetSum would be \\nzero"
                    },
                    {
                        "username": "siddh",
                        "content": "Is this case valid tree= [] , sum=0, expected=false, shouldn\\'t this be true"
                    },
                    {
                        "username": "ashwani5",
                        "content": "This question has a lot of inconsistent test cases.\\n\\nroot=[1,2], targetSum=1 is false\\nroot=[1], targetSum=1 is true"
                    },
                    {
                        "username": "leson1106",
                        "content": "it\\'s true because [1, 2] should valid with targetSum = 3 where 1 + 2 = 3 and 2 is a leaf. And [1], yeah there is only 1 leaf so targetSum = 1 is correct"
                    },
                    {
                        "username": "an_98",
                        "content": "Your input\\n[1,2]\\n1\\nOutput : true\\nExpected : false\\n\\nThere is a tree clearly, then how is it false. Please tell me where I am wrong?"
                    },
                    {
                        "username": "kamalraj5544",
                        "content": "[@noobcoder1729](/noobcoder1729) definition of leaf : node with has no children --> but here root has one left child .. so it cant be leaf ! "
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "[@noobcoder1729](/noobcoder1729) how root behaves as a leaf, if it has a child node?"
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "There is one single branch in your example. And its path sum is 3. 3 != 1"
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "We have to find path from root to leaf. Root here itself behaves as the leaf also. Therefore true. "
                    }
                ]
            },
            {
                "id": 1566745,
                "content": [
                    {
                        "username": "amiyadiwan",
                        "content": "If only strictly positive numbers are allowed as values, then additional pruning of branches can be applied"
                    },
                    {
                        "username": "RandomDev123",
                        "content": "If the tree is empty and the supplied int value is 0, the \"expected\" response is false, but this isn\\'t specified in the question\\'s description. There\\'s a case to be made that the code should return TRUE in that case, as there does exist a path that adds to 0."
                    },
                    {
                        "username": "pavlic148",
                        "content": "In that case there\\'s no such path that adds to 0 since there are no paths at all."
                    },
                    {
                        "username": "krenarkrenarshatri",
                        "content": "Anyone else having issues with this test case \\nroot = [1,2,null,3,null,4,null,5], targetSum = 6, expected false????\\nAm I missing something here?\\n \\nTarget: 6, path: 1->2->3. \\n\\n[Submission](https://leetcode.com/problems/path-sum/submissions/1023144591/)\\n"
                    },
                    {
                        "username": "krenarkrenarshatri",
                        "content": "[@sjames8888](/sjames8888) Ahh got it. Yeah, I should have read the problem more carefully. Thanks"
                    },
                    {
                        "username": "sjames8888",
                        "content": "has a root-to-leaf path in question where implication is you must go all way down the side of tree root to leaf where both left right are null as end point \\n```java\\n // a leaf\\n        if (v == target && root.left == null && root.right == null) {\\n            return target;\\n        }\\n```"
                    },
                    {
                        "username": "krenarkrenarshatri",
                        "content": "[@sjames8888](/sjames8888) I\\'m not sure what you mean? The TreeNode is just on the left side(like a linked list) and the sum 1+2+3 should give a target of 6. Or you meant something else?!"
                    },
                    {
                        "username": "sjames8888",
                        "content": "Task :compileTestJava\n> Task :processTestResources NO-SOURCE\n> Task :testClasses\n> Task :test\n\n```txt\n                                    1\n                        /\n                       2\n                   /\n                  3\n                /\n               4\n              /\n             5\n```\n\ngraph is as above \n\n @Test\n    void case5() {\n        final var root = TreeNode.from(new Integer[] {1,2,null,3,null,4,null,5});\n        Assertions.assertNotNull(root);\n        System.out.println(root.prettyPrint());\n        final var res = new PathSum().hasPathSum(root, 6);\n        Assertions.assertFalse(res);\n    }\n\ns\n"
                    },
                    {
                        "username": "wjeevika",
                        "content": "Idk why but I like this question. It\\'s so cute. "
                    },
                    {
                        "username": "akashgkrishnan",
                        "content": "I had run the same code multiple times and found that the same code runs faster then 90 percent of submissions and also slower than 90 percent submissions. is there any particular reason why"
                    },
                    {
                        "username": "max_223",
                        "content": "Below are two related problems and solution in C++/Java/Python if anybody is interested:\\n\\n<a href=\"https://www.techiedelight.com/find-maximum-sum-root-to-leaf-path-binary-tree/\">Find maximum sum root-to-leaf path in a binary tree</a>\\n<a href=\"https://www.techiedelight.com/find-maximum-sum-path-between-two-leaves-in-a-binary-tree/\">Find maximum sum path between two leaves in a binary tree</a>"
                    },
                    {
                        "username": "sugikushal",
                        "content": "public boolean hasPathSum(TreeNode root, int sum) {\\n\\tif(root == null) return false;\\n\\tif(root.val == sum && root.right == null && root.left == null) return true;\\n\\tif(root.left != null) root.left.val += root.val;\\n\\tif(root.right != null) root.right.val += root.val;\\n\\treturn hasPathSum(root.left,sum) || hasPathSum(root.right,sum);\\n}"
                    },
                    {
                        "username": "wuhan9087",
                        "content": "What is root node,and its leftchild, rightchild?"
                    },
                    {
                        "username": "heena",
                        "content": "If the tree is empty but the sum is also zero then the function hasPathSum should return true .\\nBut the code is accepted on\\n `if(root==NULL) {\\nreturn false; }`   .I have this doubt that shouldn't this be `if(tree==NULL) return (sum==0);` \\n\\nNote: the code doesnt get accepted with return sum==0 but with return false."
                    },
                    {
                        "username": "iaarzoo40",
                        "content": "Python || Easy and Clean Code\\n\\n```\\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        if root==None:\\n            return False\\n        \\n        targetSum=targetSum-root.val\\n        \\n        if root.left==None and root.right==None:\\n            return targetSum==0\\n        \\n        return self.hasPathSum(root.left,targetSum) or self.hasPathSum(root.right,targetSum)\\n        \\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Easy and Clean Rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "noita_verse",
                        "content": "FYI there\\'s a new solutions tab to post your solutions"
                    }
                ]
            },
            {
                "id": 1569579,
                "content": [
                    {
                        "username": "amiyadiwan",
                        "content": "If only strictly positive numbers are allowed as values, then additional pruning of branches can be applied"
                    },
                    {
                        "username": "RandomDev123",
                        "content": "If the tree is empty and the supplied int value is 0, the \"expected\" response is false, but this isn\\'t specified in the question\\'s description. There\\'s a case to be made that the code should return TRUE in that case, as there does exist a path that adds to 0."
                    },
                    {
                        "username": "pavlic148",
                        "content": "In that case there\\'s no such path that adds to 0 since there are no paths at all."
                    },
                    {
                        "username": "krenarkrenarshatri",
                        "content": "Anyone else having issues with this test case \\nroot = [1,2,null,3,null,4,null,5], targetSum = 6, expected false????\\nAm I missing something here?\\n \\nTarget: 6, path: 1->2->3. \\n\\n[Submission](https://leetcode.com/problems/path-sum/submissions/1023144591/)\\n"
                    },
                    {
                        "username": "krenarkrenarshatri",
                        "content": "[@sjames8888](/sjames8888) Ahh got it. Yeah, I should have read the problem more carefully. Thanks"
                    },
                    {
                        "username": "sjames8888",
                        "content": "has a root-to-leaf path in question where implication is you must go all way down the side of tree root to leaf where both left right are null as end point \\n```java\\n // a leaf\\n        if (v == target && root.left == null && root.right == null) {\\n            return target;\\n        }\\n```"
                    },
                    {
                        "username": "krenarkrenarshatri",
                        "content": "[@sjames8888](/sjames8888) I\\'m not sure what you mean? The TreeNode is just on the left side(like a linked list) and the sum 1+2+3 should give a target of 6. Or you meant something else?!"
                    },
                    {
                        "username": "sjames8888",
                        "content": "Task :compileTestJava\n> Task :processTestResources NO-SOURCE\n> Task :testClasses\n> Task :test\n\n```txt\n                                    1\n                        /\n                       2\n                   /\n                  3\n                /\n               4\n              /\n             5\n```\n\ngraph is as above \n\n @Test\n    void case5() {\n        final var root = TreeNode.from(new Integer[] {1,2,null,3,null,4,null,5});\n        Assertions.assertNotNull(root);\n        System.out.println(root.prettyPrint());\n        final var res = new PathSum().hasPathSum(root, 6);\n        Assertions.assertFalse(res);\n    }\n\ns\n"
                    },
                    {
                        "username": "wjeevika",
                        "content": "Idk why but I like this question. It\\'s so cute. "
                    },
                    {
                        "username": "akashgkrishnan",
                        "content": "I had run the same code multiple times and found that the same code runs faster then 90 percent of submissions and also slower than 90 percent submissions. is there any particular reason why"
                    },
                    {
                        "username": "max_223",
                        "content": "Below are two related problems and solution in C++/Java/Python if anybody is interested:\\n\\n<a href=\"https://www.techiedelight.com/find-maximum-sum-root-to-leaf-path-binary-tree/\">Find maximum sum root-to-leaf path in a binary tree</a>\\n<a href=\"https://www.techiedelight.com/find-maximum-sum-path-between-two-leaves-in-a-binary-tree/\">Find maximum sum path between two leaves in a binary tree</a>"
                    },
                    {
                        "username": "sugikushal",
                        "content": "public boolean hasPathSum(TreeNode root, int sum) {\\n\\tif(root == null) return false;\\n\\tif(root.val == sum && root.right == null && root.left == null) return true;\\n\\tif(root.left != null) root.left.val += root.val;\\n\\tif(root.right != null) root.right.val += root.val;\\n\\treturn hasPathSum(root.left,sum) || hasPathSum(root.right,sum);\\n}"
                    },
                    {
                        "username": "wuhan9087",
                        "content": "What is root node,and its leftchild, rightchild?"
                    },
                    {
                        "username": "heena",
                        "content": "If the tree is empty but the sum is also zero then the function hasPathSum should return true .\\nBut the code is accepted on\\n `if(root==NULL) {\\nreturn false; }`   .I have this doubt that shouldn't this be `if(tree==NULL) return (sum==0);` \\n\\nNote: the code doesnt get accepted with return sum==0 but with return false."
                    },
                    {
                        "username": "iaarzoo40",
                        "content": "Python || Easy and Clean Code\\n\\n```\\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        if root==None:\\n            return False\\n        \\n        targetSum=targetSum-root.val\\n        \\n        if root.left==None and root.right==None:\\n            return targetSum==0\\n        \\n        return self.hasPathSum(root.left,targetSum) or self.hasPathSum(root.right,targetSum)\\n        \\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Easy and Clean Rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "noita_verse",
                        "content": "FYI there\\'s a new solutions tab to post your solutions"
                    }
                ]
            },
            {
                "id": 2016906,
                "content": [
                    {
                        "username": "amiyadiwan",
                        "content": "If only strictly positive numbers are allowed as values, then additional pruning of branches can be applied"
                    },
                    {
                        "username": "RandomDev123",
                        "content": "If the tree is empty and the supplied int value is 0, the \"expected\" response is false, but this isn\\'t specified in the question\\'s description. There\\'s a case to be made that the code should return TRUE in that case, as there does exist a path that adds to 0."
                    },
                    {
                        "username": "pavlic148",
                        "content": "In that case there\\'s no such path that adds to 0 since there are no paths at all."
                    },
                    {
                        "username": "krenarkrenarshatri",
                        "content": "Anyone else having issues with this test case \\nroot = [1,2,null,3,null,4,null,5], targetSum = 6, expected false????\\nAm I missing something here?\\n \\nTarget: 6, path: 1->2->3. \\n\\n[Submission](https://leetcode.com/problems/path-sum/submissions/1023144591/)\\n"
                    },
                    {
                        "username": "krenarkrenarshatri",
                        "content": "[@sjames8888](/sjames8888) Ahh got it. Yeah, I should have read the problem more carefully. Thanks"
                    },
                    {
                        "username": "sjames8888",
                        "content": "has a root-to-leaf path in question where implication is you must go all way down the side of tree root to leaf where both left right are null as end point \\n```java\\n // a leaf\\n        if (v == target && root.left == null && root.right == null) {\\n            return target;\\n        }\\n```"
                    },
                    {
                        "username": "krenarkrenarshatri",
                        "content": "[@sjames8888](/sjames8888) I\\'m not sure what you mean? The TreeNode is just on the left side(like a linked list) and the sum 1+2+3 should give a target of 6. Or you meant something else?!"
                    },
                    {
                        "username": "sjames8888",
                        "content": "Task :compileTestJava\n> Task :processTestResources NO-SOURCE\n> Task :testClasses\n> Task :test\n\n```txt\n                                    1\n                        /\n                       2\n                   /\n                  3\n                /\n               4\n              /\n             5\n```\n\ngraph is as above \n\n @Test\n    void case5() {\n        final var root = TreeNode.from(new Integer[] {1,2,null,3,null,4,null,5});\n        Assertions.assertNotNull(root);\n        System.out.println(root.prettyPrint());\n        final var res = new PathSum().hasPathSum(root, 6);\n        Assertions.assertFalse(res);\n    }\n\ns\n"
                    },
                    {
                        "username": "wjeevika",
                        "content": "Idk why but I like this question. It\\'s so cute. "
                    },
                    {
                        "username": "akashgkrishnan",
                        "content": "I had run the same code multiple times and found that the same code runs faster then 90 percent of submissions and also slower than 90 percent submissions. is there any particular reason why"
                    },
                    {
                        "username": "max_223",
                        "content": "Below are two related problems and solution in C++/Java/Python if anybody is interested:\\n\\n<a href=\"https://www.techiedelight.com/find-maximum-sum-root-to-leaf-path-binary-tree/\">Find maximum sum root-to-leaf path in a binary tree</a>\\n<a href=\"https://www.techiedelight.com/find-maximum-sum-path-between-two-leaves-in-a-binary-tree/\">Find maximum sum path between two leaves in a binary tree</a>"
                    },
                    {
                        "username": "sugikushal",
                        "content": "public boolean hasPathSum(TreeNode root, int sum) {\\n\\tif(root == null) return false;\\n\\tif(root.val == sum && root.right == null && root.left == null) return true;\\n\\tif(root.left != null) root.left.val += root.val;\\n\\tif(root.right != null) root.right.val += root.val;\\n\\treturn hasPathSum(root.left,sum) || hasPathSum(root.right,sum);\\n}"
                    },
                    {
                        "username": "wuhan9087",
                        "content": "What is root node,and its leftchild, rightchild?"
                    },
                    {
                        "username": "heena",
                        "content": "If the tree is empty but the sum is also zero then the function hasPathSum should return true .\\nBut the code is accepted on\\n `if(root==NULL) {\\nreturn false; }`   .I have this doubt that shouldn't this be `if(tree==NULL) return (sum==0);` \\n\\nNote: the code doesnt get accepted with return sum==0 but with return false."
                    },
                    {
                        "username": "iaarzoo40",
                        "content": "Python || Easy and Clean Code\\n\\n```\\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        if root==None:\\n            return False\\n        \\n        targetSum=targetSum-root.val\\n        \\n        if root.left==None and root.right==None:\\n            return targetSum==0\\n        \\n        return self.hasPathSum(root.left,targetSum) or self.hasPathSum(root.right,targetSum)\\n        \\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Easy and Clean Rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "noita_verse",
                        "content": "FYI there\\'s a new solutions tab to post your solutions"
                    }
                ]
            },
            {
                "id": 1674698,
                "content": [
                    {
                        "username": "amiyadiwan",
                        "content": "If only strictly positive numbers are allowed as values, then additional pruning of branches can be applied"
                    },
                    {
                        "username": "RandomDev123",
                        "content": "If the tree is empty and the supplied int value is 0, the \"expected\" response is false, but this isn\\'t specified in the question\\'s description. There\\'s a case to be made that the code should return TRUE in that case, as there does exist a path that adds to 0."
                    },
                    {
                        "username": "pavlic148",
                        "content": "In that case there\\'s no such path that adds to 0 since there are no paths at all."
                    },
                    {
                        "username": "krenarkrenarshatri",
                        "content": "Anyone else having issues with this test case \\nroot = [1,2,null,3,null,4,null,5], targetSum = 6, expected false????\\nAm I missing something here?\\n \\nTarget: 6, path: 1->2->3. \\n\\n[Submission](https://leetcode.com/problems/path-sum/submissions/1023144591/)\\n"
                    },
                    {
                        "username": "krenarkrenarshatri",
                        "content": "[@sjames8888](/sjames8888) Ahh got it. Yeah, I should have read the problem more carefully. Thanks"
                    },
                    {
                        "username": "sjames8888",
                        "content": "has a root-to-leaf path in question where implication is you must go all way down the side of tree root to leaf where both left right are null as end point \\n```java\\n // a leaf\\n        if (v == target && root.left == null && root.right == null) {\\n            return target;\\n        }\\n```"
                    },
                    {
                        "username": "krenarkrenarshatri",
                        "content": "[@sjames8888](/sjames8888) I\\'m not sure what you mean? The TreeNode is just on the left side(like a linked list) and the sum 1+2+3 should give a target of 6. Or you meant something else?!"
                    },
                    {
                        "username": "sjames8888",
                        "content": "Task :compileTestJava\n> Task :processTestResources NO-SOURCE\n> Task :testClasses\n> Task :test\n\n```txt\n                                    1\n                        /\n                       2\n                   /\n                  3\n                /\n               4\n              /\n             5\n```\n\ngraph is as above \n\n @Test\n    void case5() {\n        final var root = TreeNode.from(new Integer[] {1,2,null,3,null,4,null,5});\n        Assertions.assertNotNull(root);\n        System.out.println(root.prettyPrint());\n        final var res = new PathSum().hasPathSum(root, 6);\n        Assertions.assertFalse(res);\n    }\n\ns\n"
                    },
                    {
                        "username": "wjeevika",
                        "content": "Idk why but I like this question. It\\'s so cute. "
                    },
                    {
                        "username": "akashgkrishnan",
                        "content": "I had run the same code multiple times and found that the same code runs faster then 90 percent of submissions and also slower than 90 percent submissions. is there any particular reason why"
                    },
                    {
                        "username": "max_223",
                        "content": "Below are two related problems and solution in C++/Java/Python if anybody is interested:\\n\\n<a href=\"https://www.techiedelight.com/find-maximum-sum-root-to-leaf-path-binary-tree/\">Find maximum sum root-to-leaf path in a binary tree</a>\\n<a href=\"https://www.techiedelight.com/find-maximum-sum-path-between-two-leaves-in-a-binary-tree/\">Find maximum sum path between two leaves in a binary tree</a>"
                    },
                    {
                        "username": "sugikushal",
                        "content": "public boolean hasPathSum(TreeNode root, int sum) {\\n\\tif(root == null) return false;\\n\\tif(root.val == sum && root.right == null && root.left == null) return true;\\n\\tif(root.left != null) root.left.val += root.val;\\n\\tif(root.right != null) root.right.val += root.val;\\n\\treturn hasPathSum(root.left,sum) || hasPathSum(root.right,sum);\\n}"
                    },
                    {
                        "username": "wuhan9087",
                        "content": "What is root node,and its leftchild, rightchild?"
                    },
                    {
                        "username": "heena",
                        "content": "If the tree is empty but the sum is also zero then the function hasPathSum should return true .\\nBut the code is accepted on\\n `if(root==NULL) {\\nreturn false; }`   .I have this doubt that shouldn't this be `if(tree==NULL) return (sum==0);` \\n\\nNote: the code doesnt get accepted with return sum==0 but with return false."
                    },
                    {
                        "username": "iaarzoo40",
                        "content": "Python || Easy and Clean Code\\n\\n```\\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        if root==None:\\n            return False\\n        \\n        targetSum=targetSum-root.val\\n        \\n        if root.left==None and root.right==None:\\n            return targetSum==0\\n        \\n        return self.hasPathSum(root.left,targetSum) or self.hasPathSum(root.right,targetSum)\\n        \\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Easy and Clean Rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "noita_verse",
                        "content": "FYI there\\'s a new solutions tab to post your solutions"
                    }
                ]
            },
            {
                "id": 1574055,
                "content": [
                    {
                        "username": "amiyadiwan",
                        "content": "If only strictly positive numbers are allowed as values, then additional pruning of branches can be applied"
                    },
                    {
                        "username": "RandomDev123",
                        "content": "If the tree is empty and the supplied int value is 0, the \"expected\" response is false, but this isn\\'t specified in the question\\'s description. There\\'s a case to be made that the code should return TRUE in that case, as there does exist a path that adds to 0."
                    },
                    {
                        "username": "pavlic148",
                        "content": "In that case there\\'s no such path that adds to 0 since there are no paths at all."
                    },
                    {
                        "username": "krenarkrenarshatri",
                        "content": "Anyone else having issues with this test case \\nroot = [1,2,null,3,null,4,null,5], targetSum = 6, expected false????\\nAm I missing something here?\\n \\nTarget: 6, path: 1->2->3. \\n\\n[Submission](https://leetcode.com/problems/path-sum/submissions/1023144591/)\\n"
                    },
                    {
                        "username": "krenarkrenarshatri",
                        "content": "[@sjames8888](/sjames8888) Ahh got it. Yeah, I should have read the problem more carefully. Thanks"
                    },
                    {
                        "username": "sjames8888",
                        "content": "has a root-to-leaf path in question where implication is you must go all way down the side of tree root to leaf where both left right are null as end point \\n```java\\n // a leaf\\n        if (v == target && root.left == null && root.right == null) {\\n            return target;\\n        }\\n```"
                    },
                    {
                        "username": "krenarkrenarshatri",
                        "content": "[@sjames8888](/sjames8888) I\\'m not sure what you mean? The TreeNode is just on the left side(like a linked list) and the sum 1+2+3 should give a target of 6. Or you meant something else?!"
                    },
                    {
                        "username": "sjames8888",
                        "content": "Task :compileTestJava\n> Task :processTestResources NO-SOURCE\n> Task :testClasses\n> Task :test\n\n```txt\n                                    1\n                        /\n                       2\n                   /\n                  3\n                /\n               4\n              /\n             5\n```\n\ngraph is as above \n\n @Test\n    void case5() {\n        final var root = TreeNode.from(new Integer[] {1,2,null,3,null,4,null,5});\n        Assertions.assertNotNull(root);\n        System.out.println(root.prettyPrint());\n        final var res = new PathSum().hasPathSum(root, 6);\n        Assertions.assertFalse(res);\n    }\n\ns\n"
                    },
                    {
                        "username": "wjeevika",
                        "content": "Idk why but I like this question. It\\'s so cute. "
                    },
                    {
                        "username": "akashgkrishnan",
                        "content": "I had run the same code multiple times and found that the same code runs faster then 90 percent of submissions and also slower than 90 percent submissions. is there any particular reason why"
                    },
                    {
                        "username": "max_223",
                        "content": "Below are two related problems and solution in C++/Java/Python if anybody is interested:\\n\\n<a href=\"https://www.techiedelight.com/find-maximum-sum-root-to-leaf-path-binary-tree/\">Find maximum sum root-to-leaf path in a binary tree</a>\\n<a href=\"https://www.techiedelight.com/find-maximum-sum-path-between-two-leaves-in-a-binary-tree/\">Find maximum sum path between two leaves in a binary tree</a>"
                    },
                    {
                        "username": "sugikushal",
                        "content": "public boolean hasPathSum(TreeNode root, int sum) {\\n\\tif(root == null) return false;\\n\\tif(root.val == sum && root.right == null && root.left == null) return true;\\n\\tif(root.left != null) root.left.val += root.val;\\n\\tif(root.right != null) root.right.val += root.val;\\n\\treturn hasPathSum(root.left,sum) || hasPathSum(root.right,sum);\\n}"
                    },
                    {
                        "username": "wuhan9087",
                        "content": "What is root node,and its leftchild, rightchild?"
                    },
                    {
                        "username": "heena",
                        "content": "If the tree is empty but the sum is also zero then the function hasPathSum should return true .\\nBut the code is accepted on\\n `if(root==NULL) {\\nreturn false; }`   .I have this doubt that shouldn't this be `if(tree==NULL) return (sum==0);` \\n\\nNote: the code doesnt get accepted with return sum==0 but with return false."
                    },
                    {
                        "username": "iaarzoo40",
                        "content": "Python || Easy and Clean Code\\n\\n```\\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        if root==None:\\n            return False\\n        \\n        targetSum=targetSum-root.val\\n        \\n        if root.left==None and root.right==None:\\n            return targetSum==0\\n        \\n        return self.hasPathSum(root.left,targetSum) or self.hasPathSum(root.right,targetSum)\\n        \\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Easy and Clean Rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "noita_verse",
                        "content": "FYI there\\'s a new solutions tab to post your solutions"
                    }
                ]
            },
            {
                "id": 1573928,
                "content": [
                    {
                        "username": "amiyadiwan",
                        "content": "If only strictly positive numbers are allowed as values, then additional pruning of branches can be applied"
                    },
                    {
                        "username": "RandomDev123",
                        "content": "If the tree is empty and the supplied int value is 0, the \"expected\" response is false, but this isn\\'t specified in the question\\'s description. There\\'s a case to be made that the code should return TRUE in that case, as there does exist a path that adds to 0."
                    },
                    {
                        "username": "pavlic148",
                        "content": "In that case there\\'s no such path that adds to 0 since there are no paths at all."
                    },
                    {
                        "username": "krenarkrenarshatri",
                        "content": "Anyone else having issues with this test case \\nroot = [1,2,null,3,null,4,null,5], targetSum = 6, expected false????\\nAm I missing something here?\\n \\nTarget: 6, path: 1->2->3. \\n\\n[Submission](https://leetcode.com/problems/path-sum/submissions/1023144591/)\\n"
                    },
                    {
                        "username": "krenarkrenarshatri",
                        "content": "[@sjames8888](/sjames8888) Ahh got it. Yeah, I should have read the problem more carefully. Thanks"
                    },
                    {
                        "username": "sjames8888",
                        "content": "has a root-to-leaf path in question where implication is you must go all way down the side of tree root to leaf where both left right are null as end point \\n```java\\n // a leaf\\n        if (v == target && root.left == null && root.right == null) {\\n            return target;\\n        }\\n```"
                    },
                    {
                        "username": "krenarkrenarshatri",
                        "content": "[@sjames8888](/sjames8888) I\\'m not sure what you mean? The TreeNode is just on the left side(like a linked list) and the sum 1+2+3 should give a target of 6. Or you meant something else?!"
                    },
                    {
                        "username": "sjames8888",
                        "content": "Task :compileTestJava\n> Task :processTestResources NO-SOURCE\n> Task :testClasses\n> Task :test\n\n```txt\n                                    1\n                        /\n                       2\n                   /\n                  3\n                /\n               4\n              /\n             5\n```\n\ngraph is as above \n\n @Test\n    void case5() {\n        final var root = TreeNode.from(new Integer[] {1,2,null,3,null,4,null,5});\n        Assertions.assertNotNull(root);\n        System.out.println(root.prettyPrint());\n        final var res = new PathSum().hasPathSum(root, 6);\n        Assertions.assertFalse(res);\n    }\n\ns\n"
                    },
                    {
                        "username": "wjeevika",
                        "content": "Idk why but I like this question. It\\'s so cute. "
                    },
                    {
                        "username": "akashgkrishnan",
                        "content": "I had run the same code multiple times and found that the same code runs faster then 90 percent of submissions and also slower than 90 percent submissions. is there any particular reason why"
                    },
                    {
                        "username": "max_223",
                        "content": "Below are two related problems and solution in C++/Java/Python if anybody is interested:\\n\\n<a href=\"https://www.techiedelight.com/find-maximum-sum-root-to-leaf-path-binary-tree/\">Find maximum sum root-to-leaf path in a binary tree</a>\\n<a href=\"https://www.techiedelight.com/find-maximum-sum-path-between-two-leaves-in-a-binary-tree/\">Find maximum sum path between two leaves in a binary tree</a>"
                    },
                    {
                        "username": "sugikushal",
                        "content": "public boolean hasPathSum(TreeNode root, int sum) {\\n\\tif(root == null) return false;\\n\\tif(root.val == sum && root.right == null && root.left == null) return true;\\n\\tif(root.left != null) root.left.val += root.val;\\n\\tif(root.right != null) root.right.val += root.val;\\n\\treturn hasPathSum(root.left,sum) || hasPathSum(root.right,sum);\\n}"
                    },
                    {
                        "username": "wuhan9087",
                        "content": "What is root node,and its leftchild, rightchild?"
                    },
                    {
                        "username": "heena",
                        "content": "If the tree is empty but the sum is also zero then the function hasPathSum should return true .\\nBut the code is accepted on\\n `if(root==NULL) {\\nreturn false; }`   .I have this doubt that shouldn't this be `if(tree==NULL) return (sum==0);` \\n\\nNote: the code doesnt get accepted with return sum==0 but with return false."
                    },
                    {
                        "username": "iaarzoo40",
                        "content": "Python || Easy and Clean Code\\n\\n```\\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        if root==None:\\n            return False\\n        \\n        targetSum=targetSum-root.val\\n        \\n        if root.left==None and root.right==None:\\n            return targetSum==0\\n        \\n        return self.hasPathSum(root.left,targetSum) or self.hasPathSum(root.right,targetSum)\\n        \\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Easy and Clean Rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "noita_verse",
                        "content": "FYI there\\'s a new solutions tab to post your solutions"
                    }
                ]
            },
            {
                "id": 1573249,
                "content": [
                    {
                        "username": "amiyadiwan",
                        "content": "If only strictly positive numbers are allowed as values, then additional pruning of branches can be applied"
                    },
                    {
                        "username": "RandomDev123",
                        "content": "If the tree is empty and the supplied int value is 0, the \"expected\" response is false, but this isn\\'t specified in the question\\'s description. There\\'s a case to be made that the code should return TRUE in that case, as there does exist a path that adds to 0."
                    },
                    {
                        "username": "pavlic148",
                        "content": "In that case there\\'s no such path that adds to 0 since there are no paths at all."
                    },
                    {
                        "username": "krenarkrenarshatri",
                        "content": "Anyone else having issues with this test case \\nroot = [1,2,null,3,null,4,null,5], targetSum = 6, expected false????\\nAm I missing something here?\\n \\nTarget: 6, path: 1->2->3. \\n\\n[Submission](https://leetcode.com/problems/path-sum/submissions/1023144591/)\\n"
                    },
                    {
                        "username": "krenarkrenarshatri",
                        "content": "[@sjames8888](/sjames8888) Ahh got it. Yeah, I should have read the problem more carefully. Thanks"
                    },
                    {
                        "username": "sjames8888",
                        "content": "has a root-to-leaf path in question where implication is you must go all way down the side of tree root to leaf where both left right are null as end point \\n```java\\n // a leaf\\n        if (v == target && root.left == null && root.right == null) {\\n            return target;\\n        }\\n```"
                    },
                    {
                        "username": "krenarkrenarshatri",
                        "content": "[@sjames8888](/sjames8888) I\\'m not sure what you mean? The TreeNode is just on the left side(like a linked list) and the sum 1+2+3 should give a target of 6. Or you meant something else?!"
                    },
                    {
                        "username": "sjames8888",
                        "content": "Task :compileTestJava\n> Task :processTestResources NO-SOURCE\n> Task :testClasses\n> Task :test\n\n```txt\n                                    1\n                        /\n                       2\n                   /\n                  3\n                /\n               4\n              /\n             5\n```\n\ngraph is as above \n\n @Test\n    void case5() {\n        final var root = TreeNode.from(new Integer[] {1,2,null,3,null,4,null,5});\n        Assertions.assertNotNull(root);\n        System.out.println(root.prettyPrint());\n        final var res = new PathSum().hasPathSum(root, 6);\n        Assertions.assertFalse(res);\n    }\n\ns\n"
                    },
                    {
                        "username": "wjeevika",
                        "content": "Idk why but I like this question. It\\'s so cute. "
                    },
                    {
                        "username": "akashgkrishnan",
                        "content": "I had run the same code multiple times and found that the same code runs faster then 90 percent of submissions and also slower than 90 percent submissions. is there any particular reason why"
                    },
                    {
                        "username": "max_223",
                        "content": "Below are two related problems and solution in C++/Java/Python if anybody is interested:\\n\\n<a href=\"https://www.techiedelight.com/find-maximum-sum-root-to-leaf-path-binary-tree/\">Find maximum sum root-to-leaf path in a binary tree</a>\\n<a href=\"https://www.techiedelight.com/find-maximum-sum-path-between-two-leaves-in-a-binary-tree/\">Find maximum sum path between two leaves in a binary tree</a>"
                    },
                    {
                        "username": "sugikushal",
                        "content": "public boolean hasPathSum(TreeNode root, int sum) {\\n\\tif(root == null) return false;\\n\\tif(root.val == sum && root.right == null && root.left == null) return true;\\n\\tif(root.left != null) root.left.val += root.val;\\n\\tif(root.right != null) root.right.val += root.val;\\n\\treturn hasPathSum(root.left,sum) || hasPathSum(root.right,sum);\\n}"
                    },
                    {
                        "username": "wuhan9087",
                        "content": "What is root node,and its leftchild, rightchild?"
                    },
                    {
                        "username": "heena",
                        "content": "If the tree is empty but the sum is also zero then the function hasPathSum should return true .\\nBut the code is accepted on\\n `if(root==NULL) {\\nreturn false; }`   .I have this doubt that shouldn't this be `if(tree==NULL) return (sum==0);` \\n\\nNote: the code doesnt get accepted with return sum==0 but with return false."
                    },
                    {
                        "username": "iaarzoo40",
                        "content": "Python || Easy and Clean Code\\n\\n```\\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        if root==None:\\n            return False\\n        \\n        targetSum=targetSum-root.val\\n        \\n        if root.left==None and root.right==None:\\n            return targetSum==0\\n        \\n        return self.hasPathSum(root.left,targetSum) or self.hasPathSum(root.right,targetSum)\\n        \\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Easy and Clean Rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "noita_verse",
                        "content": "FYI there\\'s a new solutions tab to post your solutions"
                    }
                ]
            },
            {
                "id": 1571233,
                "content": [
                    {
                        "username": "amiyadiwan",
                        "content": "If only strictly positive numbers are allowed as values, then additional pruning of branches can be applied"
                    },
                    {
                        "username": "RandomDev123",
                        "content": "If the tree is empty and the supplied int value is 0, the \"expected\" response is false, but this isn\\'t specified in the question\\'s description. There\\'s a case to be made that the code should return TRUE in that case, as there does exist a path that adds to 0."
                    },
                    {
                        "username": "pavlic148",
                        "content": "In that case there\\'s no such path that adds to 0 since there are no paths at all."
                    },
                    {
                        "username": "krenarkrenarshatri",
                        "content": "Anyone else having issues with this test case \\nroot = [1,2,null,3,null,4,null,5], targetSum = 6, expected false????\\nAm I missing something here?\\n \\nTarget: 6, path: 1->2->3. \\n\\n[Submission](https://leetcode.com/problems/path-sum/submissions/1023144591/)\\n"
                    },
                    {
                        "username": "krenarkrenarshatri",
                        "content": "[@sjames8888](/sjames8888) Ahh got it. Yeah, I should have read the problem more carefully. Thanks"
                    },
                    {
                        "username": "sjames8888",
                        "content": "has a root-to-leaf path in question where implication is you must go all way down the side of tree root to leaf where both left right are null as end point \\n```java\\n // a leaf\\n        if (v == target && root.left == null && root.right == null) {\\n            return target;\\n        }\\n```"
                    },
                    {
                        "username": "krenarkrenarshatri",
                        "content": "[@sjames8888](/sjames8888) I\\'m not sure what you mean? The TreeNode is just on the left side(like a linked list) and the sum 1+2+3 should give a target of 6. Or you meant something else?!"
                    },
                    {
                        "username": "sjames8888",
                        "content": "Task :compileTestJava\n> Task :processTestResources NO-SOURCE\n> Task :testClasses\n> Task :test\n\n```txt\n                                    1\n                        /\n                       2\n                   /\n                  3\n                /\n               4\n              /\n             5\n```\n\ngraph is as above \n\n @Test\n    void case5() {\n        final var root = TreeNode.from(new Integer[] {1,2,null,3,null,4,null,5});\n        Assertions.assertNotNull(root);\n        System.out.println(root.prettyPrint());\n        final var res = new PathSum().hasPathSum(root, 6);\n        Assertions.assertFalse(res);\n    }\n\ns\n"
                    },
                    {
                        "username": "wjeevika",
                        "content": "Idk why but I like this question. It\\'s so cute. "
                    },
                    {
                        "username": "akashgkrishnan",
                        "content": "I had run the same code multiple times and found that the same code runs faster then 90 percent of submissions and also slower than 90 percent submissions. is there any particular reason why"
                    },
                    {
                        "username": "max_223",
                        "content": "Below are two related problems and solution in C++/Java/Python if anybody is interested:\\n\\n<a href=\"https://www.techiedelight.com/find-maximum-sum-root-to-leaf-path-binary-tree/\">Find maximum sum root-to-leaf path in a binary tree</a>\\n<a href=\"https://www.techiedelight.com/find-maximum-sum-path-between-two-leaves-in-a-binary-tree/\">Find maximum sum path between two leaves in a binary tree</a>"
                    },
                    {
                        "username": "sugikushal",
                        "content": "public boolean hasPathSum(TreeNode root, int sum) {\\n\\tif(root == null) return false;\\n\\tif(root.val == sum && root.right == null && root.left == null) return true;\\n\\tif(root.left != null) root.left.val += root.val;\\n\\tif(root.right != null) root.right.val += root.val;\\n\\treturn hasPathSum(root.left,sum) || hasPathSum(root.right,sum);\\n}"
                    },
                    {
                        "username": "wuhan9087",
                        "content": "What is root node,and its leftchild, rightchild?"
                    },
                    {
                        "username": "heena",
                        "content": "If the tree is empty but the sum is also zero then the function hasPathSum should return true .\\nBut the code is accepted on\\n `if(root==NULL) {\\nreturn false; }`   .I have this doubt that shouldn't this be `if(tree==NULL) return (sum==0);` \\n\\nNote: the code doesnt get accepted with return sum==0 but with return false."
                    },
                    {
                        "username": "iaarzoo40",
                        "content": "Python || Easy and Clean Code\\n\\n```\\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        if root==None:\\n            return False\\n        \\n        targetSum=targetSum-root.val\\n        \\n        if root.left==None and root.right==None:\\n            return targetSum==0\\n        \\n        return self.hasPathSum(root.left,targetSum) or self.hasPathSum(root.right,targetSum)\\n        \\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Easy and Clean Rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "noita_verse",
                        "content": "FYI there\\'s a new solutions tab to post your solutions"
                    }
                ]
            },
            {
                "id": 1571234,
                "content": [
                    {
                        "username": "amiyadiwan",
                        "content": "If only strictly positive numbers are allowed as values, then additional pruning of branches can be applied"
                    },
                    {
                        "username": "RandomDev123",
                        "content": "If the tree is empty and the supplied int value is 0, the \"expected\" response is false, but this isn\\'t specified in the question\\'s description. There\\'s a case to be made that the code should return TRUE in that case, as there does exist a path that adds to 0."
                    },
                    {
                        "username": "pavlic148",
                        "content": "In that case there\\'s no such path that adds to 0 since there are no paths at all."
                    },
                    {
                        "username": "krenarkrenarshatri",
                        "content": "Anyone else having issues with this test case \\nroot = [1,2,null,3,null,4,null,5], targetSum = 6, expected false????\\nAm I missing something here?\\n \\nTarget: 6, path: 1->2->3. \\n\\n[Submission](https://leetcode.com/problems/path-sum/submissions/1023144591/)\\n"
                    },
                    {
                        "username": "krenarkrenarshatri",
                        "content": "[@sjames8888](/sjames8888) Ahh got it. Yeah, I should have read the problem more carefully. Thanks"
                    },
                    {
                        "username": "sjames8888",
                        "content": "has a root-to-leaf path in question where implication is you must go all way down the side of tree root to leaf where both left right are null as end point \\n```java\\n // a leaf\\n        if (v == target && root.left == null && root.right == null) {\\n            return target;\\n        }\\n```"
                    },
                    {
                        "username": "krenarkrenarshatri",
                        "content": "[@sjames8888](/sjames8888) I\\'m not sure what you mean? The TreeNode is just on the left side(like a linked list) and the sum 1+2+3 should give a target of 6. Or you meant something else?!"
                    },
                    {
                        "username": "sjames8888",
                        "content": "Task :compileTestJava\n> Task :processTestResources NO-SOURCE\n> Task :testClasses\n> Task :test\n\n```txt\n                                    1\n                        /\n                       2\n                   /\n                  3\n                /\n               4\n              /\n             5\n```\n\ngraph is as above \n\n @Test\n    void case5() {\n        final var root = TreeNode.from(new Integer[] {1,2,null,3,null,4,null,5});\n        Assertions.assertNotNull(root);\n        System.out.println(root.prettyPrint());\n        final var res = new PathSum().hasPathSum(root, 6);\n        Assertions.assertFalse(res);\n    }\n\ns\n"
                    },
                    {
                        "username": "wjeevika",
                        "content": "Idk why but I like this question. It\\'s so cute. "
                    },
                    {
                        "username": "akashgkrishnan",
                        "content": "I had run the same code multiple times and found that the same code runs faster then 90 percent of submissions and also slower than 90 percent submissions. is there any particular reason why"
                    },
                    {
                        "username": "max_223",
                        "content": "Below are two related problems and solution in C++/Java/Python if anybody is interested:\\n\\n<a href=\"https://www.techiedelight.com/find-maximum-sum-root-to-leaf-path-binary-tree/\">Find maximum sum root-to-leaf path in a binary tree</a>\\n<a href=\"https://www.techiedelight.com/find-maximum-sum-path-between-two-leaves-in-a-binary-tree/\">Find maximum sum path between two leaves in a binary tree</a>"
                    },
                    {
                        "username": "sugikushal",
                        "content": "public boolean hasPathSum(TreeNode root, int sum) {\\n\\tif(root == null) return false;\\n\\tif(root.val == sum && root.right == null && root.left == null) return true;\\n\\tif(root.left != null) root.left.val += root.val;\\n\\tif(root.right != null) root.right.val += root.val;\\n\\treturn hasPathSum(root.left,sum) || hasPathSum(root.right,sum);\\n}"
                    },
                    {
                        "username": "wuhan9087",
                        "content": "What is root node,and its leftchild, rightchild?"
                    },
                    {
                        "username": "heena",
                        "content": "If the tree is empty but the sum is also zero then the function hasPathSum should return true .\\nBut the code is accepted on\\n `if(root==NULL) {\\nreturn false; }`   .I have this doubt that shouldn't this be `if(tree==NULL) return (sum==0);` \\n\\nNote: the code doesnt get accepted with return sum==0 but with return false."
                    },
                    {
                        "username": "iaarzoo40",
                        "content": "Python || Easy and Clean Code\\n\\n```\\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        if root==None:\\n            return False\\n        \\n        targetSum=targetSum-root.val\\n        \\n        if root.left==None and root.right==None:\\n            return targetSum==0\\n        \\n        return self.hasPathSum(root.left,targetSum) or self.hasPathSum(root.right,targetSum)\\n        \\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Easy and Clean Rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "noita_verse",
                        "content": "FYI there\\'s a new solutions tab to post your solutions"
                    }
                ]
            },
            {
                "id": 1630176,
                "content": [
                    {
                        "username": "amiyadiwan",
                        "content": "If only strictly positive numbers are allowed as values, then additional pruning of branches can be applied"
                    },
                    {
                        "username": "RandomDev123",
                        "content": "If the tree is empty and the supplied int value is 0, the \"expected\" response is false, but this isn\\'t specified in the question\\'s description. There\\'s a case to be made that the code should return TRUE in that case, as there does exist a path that adds to 0."
                    },
                    {
                        "username": "pavlic148",
                        "content": "In that case there\\'s no such path that adds to 0 since there are no paths at all."
                    },
                    {
                        "username": "krenarkrenarshatri",
                        "content": "Anyone else having issues with this test case \\nroot = [1,2,null,3,null,4,null,5], targetSum = 6, expected false????\\nAm I missing something here?\\n \\nTarget: 6, path: 1->2->3. \\n\\n[Submission](https://leetcode.com/problems/path-sum/submissions/1023144591/)\\n"
                    },
                    {
                        "username": "krenarkrenarshatri",
                        "content": "[@sjames8888](/sjames8888) Ahh got it. Yeah, I should have read the problem more carefully. Thanks"
                    },
                    {
                        "username": "sjames8888",
                        "content": "has a root-to-leaf path in question where implication is you must go all way down the side of tree root to leaf where both left right are null as end point \\n```java\\n // a leaf\\n        if (v == target && root.left == null && root.right == null) {\\n            return target;\\n        }\\n```"
                    },
                    {
                        "username": "krenarkrenarshatri",
                        "content": "[@sjames8888](/sjames8888) I\\'m not sure what you mean? The TreeNode is just on the left side(like a linked list) and the sum 1+2+3 should give a target of 6. Or you meant something else?!"
                    },
                    {
                        "username": "sjames8888",
                        "content": "Task :compileTestJava\n> Task :processTestResources NO-SOURCE\n> Task :testClasses\n> Task :test\n\n```txt\n                                    1\n                        /\n                       2\n                   /\n                  3\n                /\n               4\n              /\n             5\n```\n\ngraph is as above \n\n @Test\n    void case5() {\n        final var root = TreeNode.from(new Integer[] {1,2,null,3,null,4,null,5});\n        Assertions.assertNotNull(root);\n        System.out.println(root.prettyPrint());\n        final var res = new PathSum().hasPathSum(root, 6);\n        Assertions.assertFalse(res);\n    }\n\ns\n"
                    },
                    {
                        "username": "wjeevika",
                        "content": "Idk why but I like this question. It\\'s so cute. "
                    },
                    {
                        "username": "akashgkrishnan",
                        "content": "I had run the same code multiple times and found that the same code runs faster then 90 percent of submissions and also slower than 90 percent submissions. is there any particular reason why"
                    },
                    {
                        "username": "max_223",
                        "content": "Below are two related problems and solution in C++/Java/Python if anybody is interested:\\n\\n<a href=\"https://www.techiedelight.com/find-maximum-sum-root-to-leaf-path-binary-tree/\">Find maximum sum root-to-leaf path in a binary tree</a>\\n<a href=\"https://www.techiedelight.com/find-maximum-sum-path-between-two-leaves-in-a-binary-tree/\">Find maximum sum path between two leaves in a binary tree</a>"
                    },
                    {
                        "username": "sugikushal",
                        "content": "public boolean hasPathSum(TreeNode root, int sum) {\\n\\tif(root == null) return false;\\n\\tif(root.val == sum && root.right == null && root.left == null) return true;\\n\\tif(root.left != null) root.left.val += root.val;\\n\\tif(root.right != null) root.right.val += root.val;\\n\\treturn hasPathSum(root.left,sum) || hasPathSum(root.right,sum);\\n}"
                    },
                    {
                        "username": "wuhan9087",
                        "content": "What is root node,and its leftchild, rightchild?"
                    },
                    {
                        "username": "heena",
                        "content": "If the tree is empty but the sum is also zero then the function hasPathSum should return true .\\nBut the code is accepted on\\n `if(root==NULL) {\\nreturn false; }`   .I have this doubt that shouldn't this be `if(tree==NULL) return (sum==0);` \\n\\nNote: the code doesnt get accepted with return sum==0 but with return false."
                    },
                    {
                        "username": "iaarzoo40",
                        "content": "Python || Easy and Clean Code\\n\\n```\\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        if root==None:\\n            return False\\n        \\n        targetSum=targetSum-root.val\\n        \\n        if root.left==None and root.right==None:\\n            return targetSum==0\\n        \\n        return self.hasPathSum(root.left,targetSum) or self.hasPathSum(root.right,targetSum)\\n        \\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Easy and Clean Rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "noita_verse",
                        "content": "FYI there\\'s a new solutions tab to post your solutions"
                    }
                ]
            },
            {
                "id": 2039961,
                "content": [
                    {
                        "username": "eduard92",
                        "content": "Pretty proud in March April.. I started learn for the first time traversals in trees and now I can approach these types of problems with a good thought what I should do, sometimes I take a peek if isn\\'t working, but wish I was again in my student years to grind this shit non-stop. "
                    },
                    {
                        "username": "kenimaru360",
                        "content": "[1,1,1,1] and target sum 2 is a good test case."
                    },
                    {
                        "username": "TernyavskyIlya",
                        "content": "Where my fail?\\n `def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        if not root:\\n            return False\\n        def wrap(root, total):\\n            if not root.left and not root.right:\\n                print(total)\\n                if total == targetSum:\\n                    return False\\n            if root.left:\\n                wrap(root.left, total+root.left.val)\\n            if root.right:\\n                wrap(root.right, total+root.right.val)\\n            return True\\n        wrap(root, root.val)\\n`"
                    },
                    {
                        "username": "chahatgupta1060",
                        "content": " @[leetcode](https://leetcode.com) `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...`[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "SanjayLakum_011",
                        "content": "the question has 117 testcases i have passed 99 testcase but my code is break while passing 100 number test case. the question asked you want to check that the binery tree path sum is equal of target sum. \"you should think about decrease the targetsum either think about increment "
                    },
                    {
                        "username": "kush512",
                        "content": "class Solution {\\npublic:\\n\\n    bool solve(TreeNode* root, int targetSum) {\\n        if(root==NULL && targetSum==0) return true;\\n        if(root==NULL) return false;\\n        bool l=hasPathSum(root->left, targetSum-root->val);\\n        bool r=hasPathSum(root->right, targetSum-root->val);\\n        return l || r;\\n    }\\n\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        if(root==NULL) return false; \\n        else return solve(root,targetSum);\\n    }\\n};\\n\\nwhy is it not giving correct answer?"
                    },
                    {
                        "username": "mvalpha",
                        "content": "There is a test case where root=[1,2], and target sum = 1, so it should return true but it expects false, which I can\\'t understand why. This is a weird test case."
                    },
                    {
                        "username": "sjames8888",
                        "content": "That\\u2019s a one sided tree where root 1 has one child 2 and leaf defined as no children nodes so path sum in this case is sum of 2 nodes. You have to include sum of 2 as this has no nodes so sum is 3 in this case "
                    },
                    {
                        "username": "SanjayLakum_011",
                        "content": "testcase 70 has something issue there is expected output is true but while debug my code in visual studio then received correct output but leetcode has something issue"
                    },
                    {
                        "username": "batuczarny",
                        "content": "Why does this code not work? \\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n\\n        def check(root, curSum):\\n            if not root:\\n                return False\\n        \\n            if root.left is None and root.right is None and curSum==targetSum:\\n                return True\\n            \\n            left = check(root.left, curSum + root.val)\\n            right = check(root.right, curSum + root.val)\\n            \\n            return left or right\\n\\n        return check(root, 0) \\n\\n        "
                    },
                    {
                        "username": "1valeryvb",
                        "content": "curSum - root.val"
                    },
                    {
                        "username": "sjames8888",
                        "content": "Parsing given array into tree - suggested Java\n\nthe following Java seems to parse correctly.  Probably not best but incase it is useful to somone\n\n```java\nfinal var root = TreeNode.from2(new Integer[]{5,4,8,11,null,13,4,7,2,null,null,null,1});\n```\n\n\n                    5\n                /       \\\n               4         8\n             /         /   \\\n           11        13     4\n           / \\               \\\n          7   2               1\n\n```java\n  public static TreeNode from2(Integer[] arr) {\n        if (arr.length == 0) {\n            return null;\n        }\n        var ptr = 0;\n        final var root = new TreeNode(arr[ptr++]);\n        final Queue<TreeNode> q = new LinkedList<>();\n        q.add(root);\n\n        while (ptr < arr.length && !q.isEmpty()) {\n            final var size = q.size();\n            for (var i = 0; i < size; ++i) {\n                final var node = q.remove();\n                ptr = fromConsume(node, ptr, arr, q);\n            }\n        }\n\n        return root;\n    }\n\n    enum Position {\n        Left,\n        Right\n    }\n\n    public static int fromConsume(TreeNode focus, int ptr, Integer[] arr, Queue<TreeNode> q) {\n        if (ptr >= arr.length) return ptr;\n        if (focus == null) return ptr;\n\n        ptr  = fromConsumeOne(focus, ptr, arr,q, Position.Left);\n        if (ptr < arr.length) {\n            ptr  = fromConsumeOne(focus, ptr, arr,q,Position.Right);\n        }\n\n        return ptr;\n    }\n\n    public static TreeNode from(Integer[] arr) {\n        return from2(arr);\n\n    }\n\n    static int fromConsumeOne(TreeNode focus, int ptr, Integer[] arr, Queue<TreeNode> q, Position position) {\n        if (arr[ptr] == null) {\n            ptr++;\n        } else {\n            final var node = new TreeNode(arr[ptr++]);\n            q.add(node);\n            if (position == Position.Left) {\n                focus.left = node;\n            } else {\n                focus.right = node;\n            }\n        }\n        return ptr;\n    } \n```\n"
                    }
                ]
            },
            {
                "id": 2032318,
                "content": [
                    {
                        "username": "eduard92",
                        "content": "Pretty proud in March April.. I started learn for the first time traversals in trees and now I can approach these types of problems with a good thought what I should do, sometimes I take a peek if isn\\'t working, but wish I was again in my student years to grind this shit non-stop. "
                    },
                    {
                        "username": "kenimaru360",
                        "content": "[1,1,1,1] and target sum 2 is a good test case."
                    },
                    {
                        "username": "TernyavskyIlya",
                        "content": "Where my fail?\\n `def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        if not root:\\n            return False\\n        def wrap(root, total):\\n            if not root.left and not root.right:\\n                print(total)\\n                if total == targetSum:\\n                    return False\\n            if root.left:\\n                wrap(root.left, total+root.left.val)\\n            if root.right:\\n                wrap(root.right, total+root.right.val)\\n            return True\\n        wrap(root, root.val)\\n`"
                    },
                    {
                        "username": "chahatgupta1060",
                        "content": " @[leetcode](https://leetcode.com) `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...`[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "SanjayLakum_011",
                        "content": "the question has 117 testcases i have passed 99 testcase but my code is break while passing 100 number test case. the question asked you want to check that the binery tree path sum is equal of target sum. \"you should think about decrease the targetsum either think about increment "
                    },
                    {
                        "username": "kush512",
                        "content": "class Solution {\\npublic:\\n\\n    bool solve(TreeNode* root, int targetSum) {\\n        if(root==NULL && targetSum==0) return true;\\n        if(root==NULL) return false;\\n        bool l=hasPathSum(root->left, targetSum-root->val);\\n        bool r=hasPathSum(root->right, targetSum-root->val);\\n        return l || r;\\n    }\\n\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        if(root==NULL) return false; \\n        else return solve(root,targetSum);\\n    }\\n};\\n\\nwhy is it not giving correct answer?"
                    },
                    {
                        "username": "mvalpha",
                        "content": "There is a test case where root=[1,2], and target sum = 1, so it should return true but it expects false, which I can\\'t understand why. This is a weird test case."
                    },
                    {
                        "username": "sjames8888",
                        "content": "That\\u2019s a one sided tree where root 1 has one child 2 and leaf defined as no children nodes so path sum in this case is sum of 2 nodes. You have to include sum of 2 as this has no nodes so sum is 3 in this case "
                    },
                    {
                        "username": "SanjayLakum_011",
                        "content": "testcase 70 has something issue there is expected output is true but while debug my code in visual studio then received correct output but leetcode has something issue"
                    },
                    {
                        "username": "batuczarny",
                        "content": "Why does this code not work? \\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n\\n        def check(root, curSum):\\n            if not root:\\n                return False\\n        \\n            if root.left is None and root.right is None and curSum==targetSum:\\n                return True\\n            \\n            left = check(root.left, curSum + root.val)\\n            right = check(root.right, curSum + root.val)\\n            \\n            return left or right\\n\\n        return check(root, 0) \\n\\n        "
                    },
                    {
                        "username": "1valeryvb",
                        "content": "curSum - root.val"
                    },
                    {
                        "username": "sjames8888",
                        "content": "Parsing given array into tree - suggested Java\n\nthe following Java seems to parse correctly.  Probably not best but incase it is useful to somone\n\n```java\nfinal var root = TreeNode.from2(new Integer[]{5,4,8,11,null,13,4,7,2,null,null,null,1});\n```\n\n\n                    5\n                /       \\\n               4         8\n             /         /   \\\n           11        13     4\n           / \\               \\\n          7   2               1\n\n```java\n  public static TreeNode from2(Integer[] arr) {\n        if (arr.length == 0) {\n            return null;\n        }\n        var ptr = 0;\n        final var root = new TreeNode(arr[ptr++]);\n        final Queue<TreeNode> q = new LinkedList<>();\n        q.add(root);\n\n        while (ptr < arr.length && !q.isEmpty()) {\n            final var size = q.size();\n            for (var i = 0; i < size; ++i) {\n                final var node = q.remove();\n                ptr = fromConsume(node, ptr, arr, q);\n            }\n        }\n\n        return root;\n    }\n\n    enum Position {\n        Left,\n        Right\n    }\n\n    public static int fromConsume(TreeNode focus, int ptr, Integer[] arr, Queue<TreeNode> q) {\n        if (ptr >= arr.length) return ptr;\n        if (focus == null) return ptr;\n\n        ptr  = fromConsumeOne(focus, ptr, arr,q, Position.Left);\n        if (ptr < arr.length) {\n            ptr  = fromConsumeOne(focus, ptr, arr,q,Position.Right);\n        }\n\n        return ptr;\n    }\n\n    public static TreeNode from(Integer[] arr) {\n        return from2(arr);\n\n    }\n\n    static int fromConsumeOne(TreeNode focus, int ptr, Integer[] arr, Queue<TreeNode> q, Position position) {\n        if (arr[ptr] == null) {\n            ptr++;\n        } else {\n            final var node = new TreeNode(arr[ptr++]);\n            q.add(node);\n            if (position == Position.Left) {\n                focus.left = node;\n            } else {\n                focus.right = node;\n            }\n        }\n        return ptr;\n    } \n```\n"
                    }
                ]
            },
            {
                "id": 2020632,
                "content": [
                    {
                        "username": "eduard92",
                        "content": "Pretty proud in March April.. I started learn for the first time traversals in trees and now I can approach these types of problems with a good thought what I should do, sometimes I take a peek if isn\\'t working, but wish I was again in my student years to grind this shit non-stop. "
                    },
                    {
                        "username": "kenimaru360",
                        "content": "[1,1,1,1] and target sum 2 is a good test case."
                    },
                    {
                        "username": "TernyavskyIlya",
                        "content": "Where my fail?\\n `def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        if not root:\\n            return False\\n        def wrap(root, total):\\n            if not root.left and not root.right:\\n                print(total)\\n                if total == targetSum:\\n                    return False\\n            if root.left:\\n                wrap(root.left, total+root.left.val)\\n            if root.right:\\n                wrap(root.right, total+root.right.val)\\n            return True\\n        wrap(root, root.val)\\n`"
                    },
                    {
                        "username": "chahatgupta1060",
                        "content": " @[leetcode](https://leetcode.com) `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...`[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "SanjayLakum_011",
                        "content": "the question has 117 testcases i have passed 99 testcase but my code is break while passing 100 number test case. the question asked you want to check that the binery tree path sum is equal of target sum. \"you should think about decrease the targetsum either think about increment "
                    },
                    {
                        "username": "kush512",
                        "content": "class Solution {\\npublic:\\n\\n    bool solve(TreeNode* root, int targetSum) {\\n        if(root==NULL && targetSum==0) return true;\\n        if(root==NULL) return false;\\n        bool l=hasPathSum(root->left, targetSum-root->val);\\n        bool r=hasPathSum(root->right, targetSum-root->val);\\n        return l || r;\\n    }\\n\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        if(root==NULL) return false; \\n        else return solve(root,targetSum);\\n    }\\n};\\n\\nwhy is it not giving correct answer?"
                    },
                    {
                        "username": "mvalpha",
                        "content": "There is a test case where root=[1,2], and target sum = 1, so it should return true but it expects false, which I can\\'t understand why. This is a weird test case."
                    },
                    {
                        "username": "sjames8888",
                        "content": "That\\u2019s a one sided tree where root 1 has one child 2 and leaf defined as no children nodes so path sum in this case is sum of 2 nodes. You have to include sum of 2 as this has no nodes so sum is 3 in this case "
                    },
                    {
                        "username": "SanjayLakum_011",
                        "content": "testcase 70 has something issue there is expected output is true but while debug my code in visual studio then received correct output but leetcode has something issue"
                    },
                    {
                        "username": "batuczarny",
                        "content": "Why does this code not work? \\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n\\n        def check(root, curSum):\\n            if not root:\\n                return False\\n        \\n            if root.left is None and root.right is None and curSum==targetSum:\\n                return True\\n            \\n            left = check(root.left, curSum + root.val)\\n            right = check(root.right, curSum + root.val)\\n            \\n            return left or right\\n\\n        return check(root, 0) \\n\\n        "
                    },
                    {
                        "username": "1valeryvb",
                        "content": "curSum - root.val"
                    },
                    {
                        "username": "sjames8888",
                        "content": "Parsing given array into tree - suggested Java\n\nthe following Java seems to parse correctly.  Probably not best but incase it is useful to somone\n\n```java\nfinal var root = TreeNode.from2(new Integer[]{5,4,8,11,null,13,4,7,2,null,null,null,1});\n```\n\n\n                    5\n                /       \\\n               4         8\n             /         /   \\\n           11        13     4\n           / \\               \\\n          7   2               1\n\n```java\n  public static TreeNode from2(Integer[] arr) {\n        if (arr.length == 0) {\n            return null;\n        }\n        var ptr = 0;\n        final var root = new TreeNode(arr[ptr++]);\n        final Queue<TreeNode> q = new LinkedList<>();\n        q.add(root);\n\n        while (ptr < arr.length && !q.isEmpty()) {\n            final var size = q.size();\n            for (var i = 0; i < size; ++i) {\n                final var node = q.remove();\n                ptr = fromConsume(node, ptr, arr, q);\n            }\n        }\n\n        return root;\n    }\n\n    enum Position {\n        Left,\n        Right\n    }\n\n    public static int fromConsume(TreeNode focus, int ptr, Integer[] arr, Queue<TreeNode> q) {\n        if (ptr >= arr.length) return ptr;\n        if (focus == null) return ptr;\n\n        ptr  = fromConsumeOne(focus, ptr, arr,q, Position.Left);\n        if (ptr < arr.length) {\n            ptr  = fromConsumeOne(focus, ptr, arr,q,Position.Right);\n        }\n\n        return ptr;\n    }\n\n    public static TreeNode from(Integer[] arr) {\n        return from2(arr);\n\n    }\n\n    static int fromConsumeOne(TreeNode focus, int ptr, Integer[] arr, Queue<TreeNode> q, Position position) {\n        if (arr[ptr] == null) {\n            ptr++;\n        } else {\n            final var node = new TreeNode(arr[ptr++]);\n            q.add(node);\n            if (position == Position.Left) {\n                focus.left = node;\n            } else {\n                focus.right = node;\n            }\n        }\n        return ptr;\n    } \n```\n"
                    }
                ]
            },
            {
                "id": 2016841,
                "content": [
                    {
                        "username": "eduard92",
                        "content": "Pretty proud in March April.. I started learn for the first time traversals in trees and now I can approach these types of problems with a good thought what I should do, sometimes I take a peek if isn\\'t working, but wish I was again in my student years to grind this shit non-stop. "
                    },
                    {
                        "username": "kenimaru360",
                        "content": "[1,1,1,1] and target sum 2 is a good test case."
                    },
                    {
                        "username": "TernyavskyIlya",
                        "content": "Where my fail?\\n `def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        if not root:\\n            return False\\n        def wrap(root, total):\\n            if not root.left and not root.right:\\n                print(total)\\n                if total == targetSum:\\n                    return False\\n            if root.left:\\n                wrap(root.left, total+root.left.val)\\n            if root.right:\\n                wrap(root.right, total+root.right.val)\\n            return True\\n        wrap(root, root.val)\\n`"
                    },
                    {
                        "username": "chahatgupta1060",
                        "content": " @[leetcode](https://leetcode.com) `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...`[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "SanjayLakum_011",
                        "content": "the question has 117 testcases i have passed 99 testcase but my code is break while passing 100 number test case. the question asked you want to check that the binery tree path sum is equal of target sum. \"you should think about decrease the targetsum either think about increment "
                    },
                    {
                        "username": "kush512",
                        "content": "class Solution {\\npublic:\\n\\n    bool solve(TreeNode* root, int targetSum) {\\n        if(root==NULL && targetSum==0) return true;\\n        if(root==NULL) return false;\\n        bool l=hasPathSum(root->left, targetSum-root->val);\\n        bool r=hasPathSum(root->right, targetSum-root->val);\\n        return l || r;\\n    }\\n\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        if(root==NULL) return false; \\n        else return solve(root,targetSum);\\n    }\\n};\\n\\nwhy is it not giving correct answer?"
                    },
                    {
                        "username": "mvalpha",
                        "content": "There is a test case where root=[1,2], and target sum = 1, so it should return true but it expects false, which I can\\'t understand why. This is a weird test case."
                    },
                    {
                        "username": "sjames8888",
                        "content": "That\\u2019s a one sided tree where root 1 has one child 2 and leaf defined as no children nodes so path sum in this case is sum of 2 nodes. You have to include sum of 2 as this has no nodes so sum is 3 in this case "
                    },
                    {
                        "username": "SanjayLakum_011",
                        "content": "testcase 70 has something issue there is expected output is true but while debug my code in visual studio then received correct output but leetcode has something issue"
                    },
                    {
                        "username": "batuczarny",
                        "content": "Why does this code not work? \\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n\\n        def check(root, curSum):\\n            if not root:\\n                return False\\n        \\n            if root.left is None and root.right is None and curSum==targetSum:\\n                return True\\n            \\n            left = check(root.left, curSum + root.val)\\n            right = check(root.right, curSum + root.val)\\n            \\n            return left or right\\n\\n        return check(root, 0) \\n\\n        "
                    },
                    {
                        "username": "1valeryvb",
                        "content": "curSum - root.val"
                    },
                    {
                        "username": "sjames8888",
                        "content": "Parsing given array into tree - suggested Java\n\nthe following Java seems to parse correctly.  Probably not best but incase it is useful to somone\n\n```java\nfinal var root = TreeNode.from2(new Integer[]{5,4,8,11,null,13,4,7,2,null,null,null,1});\n```\n\n\n                    5\n                /       \\\n               4         8\n             /         /   \\\n           11        13     4\n           / \\               \\\n          7   2               1\n\n```java\n  public static TreeNode from2(Integer[] arr) {\n        if (arr.length == 0) {\n            return null;\n        }\n        var ptr = 0;\n        final var root = new TreeNode(arr[ptr++]);\n        final Queue<TreeNode> q = new LinkedList<>();\n        q.add(root);\n\n        while (ptr < arr.length && !q.isEmpty()) {\n            final var size = q.size();\n            for (var i = 0; i < size; ++i) {\n                final var node = q.remove();\n                ptr = fromConsume(node, ptr, arr, q);\n            }\n        }\n\n        return root;\n    }\n\n    enum Position {\n        Left,\n        Right\n    }\n\n    public static int fromConsume(TreeNode focus, int ptr, Integer[] arr, Queue<TreeNode> q) {\n        if (ptr >= arr.length) return ptr;\n        if (focus == null) return ptr;\n\n        ptr  = fromConsumeOne(focus, ptr, arr,q, Position.Left);\n        if (ptr < arr.length) {\n            ptr  = fromConsumeOne(focus, ptr, arr,q,Position.Right);\n        }\n\n        return ptr;\n    }\n\n    public static TreeNode from(Integer[] arr) {\n        return from2(arr);\n\n    }\n\n    static int fromConsumeOne(TreeNode focus, int ptr, Integer[] arr, Queue<TreeNode> q, Position position) {\n        if (arr[ptr] == null) {\n            ptr++;\n        } else {\n            final var node = new TreeNode(arr[ptr++]);\n            q.add(node);\n            if (position == Position.Left) {\n                focus.left = node;\n            } else {\n                focus.right = node;\n            }\n        }\n        return ptr;\n    } \n```\n"
                    }
                ]
            },
            {
                "id": 2013717,
                "content": [
                    {
                        "username": "eduard92",
                        "content": "Pretty proud in March April.. I started learn for the first time traversals in trees and now I can approach these types of problems with a good thought what I should do, sometimes I take a peek if isn\\'t working, but wish I was again in my student years to grind this shit non-stop. "
                    },
                    {
                        "username": "kenimaru360",
                        "content": "[1,1,1,1] and target sum 2 is a good test case."
                    },
                    {
                        "username": "TernyavskyIlya",
                        "content": "Where my fail?\\n `def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        if not root:\\n            return False\\n        def wrap(root, total):\\n            if not root.left and not root.right:\\n                print(total)\\n                if total == targetSum:\\n                    return False\\n            if root.left:\\n                wrap(root.left, total+root.left.val)\\n            if root.right:\\n                wrap(root.right, total+root.right.val)\\n            return True\\n        wrap(root, root.val)\\n`"
                    },
                    {
                        "username": "chahatgupta1060",
                        "content": " @[leetcode](https://leetcode.com) `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...`[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "SanjayLakum_011",
                        "content": "the question has 117 testcases i have passed 99 testcase but my code is break while passing 100 number test case. the question asked you want to check that the binery tree path sum is equal of target sum. \"you should think about decrease the targetsum either think about increment "
                    },
                    {
                        "username": "kush512",
                        "content": "class Solution {\\npublic:\\n\\n    bool solve(TreeNode* root, int targetSum) {\\n        if(root==NULL && targetSum==0) return true;\\n        if(root==NULL) return false;\\n        bool l=hasPathSum(root->left, targetSum-root->val);\\n        bool r=hasPathSum(root->right, targetSum-root->val);\\n        return l || r;\\n    }\\n\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        if(root==NULL) return false; \\n        else return solve(root,targetSum);\\n    }\\n};\\n\\nwhy is it not giving correct answer?"
                    },
                    {
                        "username": "mvalpha",
                        "content": "There is a test case where root=[1,2], and target sum = 1, so it should return true but it expects false, which I can\\'t understand why. This is a weird test case."
                    },
                    {
                        "username": "sjames8888",
                        "content": "That\\u2019s a one sided tree where root 1 has one child 2 and leaf defined as no children nodes so path sum in this case is sum of 2 nodes. You have to include sum of 2 as this has no nodes so sum is 3 in this case "
                    },
                    {
                        "username": "SanjayLakum_011",
                        "content": "testcase 70 has something issue there is expected output is true but while debug my code in visual studio then received correct output but leetcode has something issue"
                    },
                    {
                        "username": "batuczarny",
                        "content": "Why does this code not work? \\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n\\n        def check(root, curSum):\\n            if not root:\\n                return False\\n        \\n            if root.left is None and root.right is None and curSum==targetSum:\\n                return True\\n            \\n            left = check(root.left, curSum + root.val)\\n            right = check(root.right, curSum + root.val)\\n            \\n            return left or right\\n\\n        return check(root, 0) \\n\\n        "
                    },
                    {
                        "username": "1valeryvb",
                        "content": "curSum - root.val"
                    },
                    {
                        "username": "sjames8888",
                        "content": "Parsing given array into tree - suggested Java\n\nthe following Java seems to parse correctly.  Probably not best but incase it is useful to somone\n\n```java\nfinal var root = TreeNode.from2(new Integer[]{5,4,8,11,null,13,4,7,2,null,null,null,1});\n```\n\n\n                    5\n                /       \\\n               4         8\n             /         /   \\\n           11        13     4\n           / \\               \\\n          7   2               1\n\n```java\n  public static TreeNode from2(Integer[] arr) {\n        if (arr.length == 0) {\n            return null;\n        }\n        var ptr = 0;\n        final var root = new TreeNode(arr[ptr++]);\n        final Queue<TreeNode> q = new LinkedList<>();\n        q.add(root);\n\n        while (ptr < arr.length && !q.isEmpty()) {\n            final var size = q.size();\n            for (var i = 0; i < size; ++i) {\n                final var node = q.remove();\n                ptr = fromConsume(node, ptr, arr, q);\n            }\n        }\n\n        return root;\n    }\n\n    enum Position {\n        Left,\n        Right\n    }\n\n    public static int fromConsume(TreeNode focus, int ptr, Integer[] arr, Queue<TreeNode> q) {\n        if (ptr >= arr.length) return ptr;\n        if (focus == null) return ptr;\n\n        ptr  = fromConsumeOne(focus, ptr, arr,q, Position.Left);\n        if (ptr < arr.length) {\n            ptr  = fromConsumeOne(focus, ptr, arr,q,Position.Right);\n        }\n\n        return ptr;\n    }\n\n    public static TreeNode from(Integer[] arr) {\n        return from2(arr);\n\n    }\n\n    static int fromConsumeOne(TreeNode focus, int ptr, Integer[] arr, Queue<TreeNode> q, Position position) {\n        if (arr[ptr] == null) {\n            ptr++;\n        } else {\n            final var node = new TreeNode(arr[ptr++]);\n            q.add(node);\n            if (position == Position.Left) {\n                focus.left = node;\n            } else {\n                focus.right = node;\n            }\n        }\n        return ptr;\n    } \n```\n"
                    }
                ]
            },
            {
                "id": 2008249,
                "content": [
                    {
                        "username": "eduard92",
                        "content": "Pretty proud in March April.. I started learn for the first time traversals in trees and now I can approach these types of problems with a good thought what I should do, sometimes I take a peek if isn\\'t working, but wish I was again in my student years to grind this shit non-stop. "
                    },
                    {
                        "username": "kenimaru360",
                        "content": "[1,1,1,1] and target sum 2 is a good test case."
                    },
                    {
                        "username": "TernyavskyIlya",
                        "content": "Where my fail?\\n `def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        if not root:\\n            return False\\n        def wrap(root, total):\\n            if not root.left and not root.right:\\n                print(total)\\n                if total == targetSum:\\n                    return False\\n            if root.left:\\n                wrap(root.left, total+root.left.val)\\n            if root.right:\\n                wrap(root.right, total+root.right.val)\\n            return True\\n        wrap(root, root.val)\\n`"
                    },
                    {
                        "username": "chahatgupta1060",
                        "content": " @[leetcode](https://leetcode.com) `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...`[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "SanjayLakum_011",
                        "content": "the question has 117 testcases i have passed 99 testcase but my code is break while passing 100 number test case. the question asked you want to check that the binery tree path sum is equal of target sum. \"you should think about decrease the targetsum either think about increment "
                    },
                    {
                        "username": "kush512",
                        "content": "class Solution {\\npublic:\\n\\n    bool solve(TreeNode* root, int targetSum) {\\n        if(root==NULL && targetSum==0) return true;\\n        if(root==NULL) return false;\\n        bool l=hasPathSum(root->left, targetSum-root->val);\\n        bool r=hasPathSum(root->right, targetSum-root->val);\\n        return l || r;\\n    }\\n\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        if(root==NULL) return false; \\n        else return solve(root,targetSum);\\n    }\\n};\\n\\nwhy is it not giving correct answer?"
                    },
                    {
                        "username": "mvalpha",
                        "content": "There is a test case where root=[1,2], and target sum = 1, so it should return true but it expects false, which I can\\'t understand why. This is a weird test case."
                    },
                    {
                        "username": "sjames8888",
                        "content": "That\\u2019s a one sided tree where root 1 has one child 2 and leaf defined as no children nodes so path sum in this case is sum of 2 nodes. You have to include sum of 2 as this has no nodes so sum is 3 in this case "
                    },
                    {
                        "username": "SanjayLakum_011",
                        "content": "testcase 70 has something issue there is expected output is true but while debug my code in visual studio then received correct output but leetcode has something issue"
                    },
                    {
                        "username": "batuczarny",
                        "content": "Why does this code not work? \\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n\\n        def check(root, curSum):\\n            if not root:\\n                return False\\n        \\n            if root.left is None and root.right is None and curSum==targetSum:\\n                return True\\n            \\n            left = check(root.left, curSum + root.val)\\n            right = check(root.right, curSum + root.val)\\n            \\n            return left or right\\n\\n        return check(root, 0) \\n\\n        "
                    },
                    {
                        "username": "1valeryvb",
                        "content": "curSum - root.val"
                    },
                    {
                        "username": "sjames8888",
                        "content": "Parsing given array into tree - suggested Java\n\nthe following Java seems to parse correctly.  Probably not best but incase it is useful to somone\n\n```java\nfinal var root = TreeNode.from2(new Integer[]{5,4,8,11,null,13,4,7,2,null,null,null,1});\n```\n\n\n                    5\n                /       \\\n               4         8\n             /         /   \\\n           11        13     4\n           / \\               \\\n          7   2               1\n\n```java\n  public static TreeNode from2(Integer[] arr) {\n        if (arr.length == 0) {\n            return null;\n        }\n        var ptr = 0;\n        final var root = new TreeNode(arr[ptr++]);\n        final Queue<TreeNode> q = new LinkedList<>();\n        q.add(root);\n\n        while (ptr < arr.length && !q.isEmpty()) {\n            final var size = q.size();\n            for (var i = 0; i < size; ++i) {\n                final var node = q.remove();\n                ptr = fromConsume(node, ptr, arr, q);\n            }\n        }\n\n        return root;\n    }\n\n    enum Position {\n        Left,\n        Right\n    }\n\n    public static int fromConsume(TreeNode focus, int ptr, Integer[] arr, Queue<TreeNode> q) {\n        if (ptr >= arr.length) return ptr;\n        if (focus == null) return ptr;\n\n        ptr  = fromConsumeOne(focus, ptr, arr,q, Position.Left);\n        if (ptr < arr.length) {\n            ptr  = fromConsumeOne(focus, ptr, arr,q,Position.Right);\n        }\n\n        return ptr;\n    }\n\n    public static TreeNode from(Integer[] arr) {\n        return from2(arr);\n\n    }\n\n    static int fromConsumeOne(TreeNode focus, int ptr, Integer[] arr, Queue<TreeNode> q, Position position) {\n        if (arr[ptr] == null) {\n            ptr++;\n        } else {\n            final var node = new TreeNode(arr[ptr++]);\n            q.add(node);\n            if (position == Position.Left) {\n                focus.left = node;\n            } else {\n                focus.right = node;\n            }\n        }\n        return ptr;\n    } \n```\n"
                    }
                ]
            },
            {
                "id": 2003829,
                "content": [
                    {
                        "username": "eduard92",
                        "content": "Pretty proud in March April.. I started learn for the first time traversals in trees and now I can approach these types of problems with a good thought what I should do, sometimes I take a peek if isn\\'t working, but wish I was again in my student years to grind this shit non-stop. "
                    },
                    {
                        "username": "kenimaru360",
                        "content": "[1,1,1,1] and target sum 2 is a good test case."
                    },
                    {
                        "username": "TernyavskyIlya",
                        "content": "Where my fail?\\n `def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        if not root:\\n            return False\\n        def wrap(root, total):\\n            if not root.left and not root.right:\\n                print(total)\\n                if total == targetSum:\\n                    return False\\n            if root.left:\\n                wrap(root.left, total+root.left.val)\\n            if root.right:\\n                wrap(root.right, total+root.right.val)\\n            return True\\n        wrap(root, root.val)\\n`"
                    },
                    {
                        "username": "chahatgupta1060",
                        "content": " @[leetcode](https://leetcode.com) `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...`[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "SanjayLakum_011",
                        "content": "the question has 117 testcases i have passed 99 testcase but my code is break while passing 100 number test case. the question asked you want to check that the binery tree path sum is equal of target sum. \"you should think about decrease the targetsum either think about increment "
                    },
                    {
                        "username": "kush512",
                        "content": "class Solution {\\npublic:\\n\\n    bool solve(TreeNode* root, int targetSum) {\\n        if(root==NULL && targetSum==0) return true;\\n        if(root==NULL) return false;\\n        bool l=hasPathSum(root->left, targetSum-root->val);\\n        bool r=hasPathSum(root->right, targetSum-root->val);\\n        return l || r;\\n    }\\n\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        if(root==NULL) return false; \\n        else return solve(root,targetSum);\\n    }\\n};\\n\\nwhy is it not giving correct answer?"
                    },
                    {
                        "username": "mvalpha",
                        "content": "There is a test case where root=[1,2], and target sum = 1, so it should return true but it expects false, which I can\\'t understand why. This is a weird test case."
                    },
                    {
                        "username": "sjames8888",
                        "content": "That\\u2019s a one sided tree where root 1 has one child 2 and leaf defined as no children nodes so path sum in this case is sum of 2 nodes. You have to include sum of 2 as this has no nodes so sum is 3 in this case "
                    },
                    {
                        "username": "SanjayLakum_011",
                        "content": "testcase 70 has something issue there is expected output is true but while debug my code in visual studio then received correct output but leetcode has something issue"
                    },
                    {
                        "username": "batuczarny",
                        "content": "Why does this code not work? \\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n\\n        def check(root, curSum):\\n            if not root:\\n                return False\\n        \\n            if root.left is None and root.right is None and curSum==targetSum:\\n                return True\\n            \\n            left = check(root.left, curSum + root.val)\\n            right = check(root.right, curSum + root.val)\\n            \\n            return left or right\\n\\n        return check(root, 0) \\n\\n        "
                    },
                    {
                        "username": "1valeryvb",
                        "content": "curSum - root.val"
                    },
                    {
                        "username": "sjames8888",
                        "content": "Parsing given array into tree - suggested Java\n\nthe following Java seems to parse correctly.  Probably not best but incase it is useful to somone\n\n```java\nfinal var root = TreeNode.from2(new Integer[]{5,4,8,11,null,13,4,7,2,null,null,null,1});\n```\n\n\n                    5\n                /       \\\n               4         8\n             /         /   \\\n           11        13     4\n           / \\               \\\n          7   2               1\n\n```java\n  public static TreeNode from2(Integer[] arr) {\n        if (arr.length == 0) {\n            return null;\n        }\n        var ptr = 0;\n        final var root = new TreeNode(arr[ptr++]);\n        final Queue<TreeNode> q = new LinkedList<>();\n        q.add(root);\n\n        while (ptr < arr.length && !q.isEmpty()) {\n            final var size = q.size();\n            for (var i = 0; i < size; ++i) {\n                final var node = q.remove();\n                ptr = fromConsume(node, ptr, arr, q);\n            }\n        }\n\n        return root;\n    }\n\n    enum Position {\n        Left,\n        Right\n    }\n\n    public static int fromConsume(TreeNode focus, int ptr, Integer[] arr, Queue<TreeNode> q) {\n        if (ptr >= arr.length) return ptr;\n        if (focus == null) return ptr;\n\n        ptr  = fromConsumeOne(focus, ptr, arr,q, Position.Left);\n        if (ptr < arr.length) {\n            ptr  = fromConsumeOne(focus, ptr, arr,q,Position.Right);\n        }\n\n        return ptr;\n    }\n\n    public static TreeNode from(Integer[] arr) {\n        return from2(arr);\n\n    }\n\n    static int fromConsumeOne(TreeNode focus, int ptr, Integer[] arr, Queue<TreeNode> q, Position position) {\n        if (arr[ptr] == null) {\n            ptr++;\n        } else {\n            final var node = new TreeNode(arr[ptr++]);\n            q.add(node);\n            if (position == Position.Left) {\n                focus.left = node;\n            } else {\n                focus.right = node;\n            }\n        }\n        return ptr;\n    } \n```\n"
                    }
                ]
            },
            {
                "id": 1994356,
                "content": [
                    {
                        "username": "eduard92",
                        "content": "Pretty proud in March April.. I started learn for the first time traversals in trees and now I can approach these types of problems with a good thought what I should do, sometimes I take a peek if isn\\'t working, but wish I was again in my student years to grind this shit non-stop. "
                    },
                    {
                        "username": "kenimaru360",
                        "content": "[1,1,1,1] and target sum 2 is a good test case."
                    },
                    {
                        "username": "TernyavskyIlya",
                        "content": "Where my fail?\\n `def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        if not root:\\n            return False\\n        def wrap(root, total):\\n            if not root.left and not root.right:\\n                print(total)\\n                if total == targetSum:\\n                    return False\\n            if root.left:\\n                wrap(root.left, total+root.left.val)\\n            if root.right:\\n                wrap(root.right, total+root.right.val)\\n            return True\\n        wrap(root, root.val)\\n`"
                    },
                    {
                        "username": "chahatgupta1060",
                        "content": " @[leetcode](https://leetcode.com) `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...`[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "SanjayLakum_011",
                        "content": "the question has 117 testcases i have passed 99 testcase but my code is break while passing 100 number test case. the question asked you want to check that the binery tree path sum is equal of target sum. \"you should think about decrease the targetsum either think about increment "
                    },
                    {
                        "username": "kush512",
                        "content": "class Solution {\\npublic:\\n\\n    bool solve(TreeNode* root, int targetSum) {\\n        if(root==NULL && targetSum==0) return true;\\n        if(root==NULL) return false;\\n        bool l=hasPathSum(root->left, targetSum-root->val);\\n        bool r=hasPathSum(root->right, targetSum-root->val);\\n        return l || r;\\n    }\\n\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        if(root==NULL) return false; \\n        else return solve(root,targetSum);\\n    }\\n};\\n\\nwhy is it not giving correct answer?"
                    },
                    {
                        "username": "mvalpha",
                        "content": "There is a test case where root=[1,2], and target sum = 1, so it should return true but it expects false, which I can\\'t understand why. This is a weird test case."
                    },
                    {
                        "username": "sjames8888",
                        "content": "That\\u2019s a one sided tree where root 1 has one child 2 and leaf defined as no children nodes so path sum in this case is sum of 2 nodes. You have to include sum of 2 as this has no nodes so sum is 3 in this case "
                    },
                    {
                        "username": "SanjayLakum_011",
                        "content": "testcase 70 has something issue there is expected output is true but while debug my code in visual studio then received correct output but leetcode has something issue"
                    },
                    {
                        "username": "batuczarny",
                        "content": "Why does this code not work? \\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n\\n        def check(root, curSum):\\n            if not root:\\n                return False\\n        \\n            if root.left is None and root.right is None and curSum==targetSum:\\n                return True\\n            \\n            left = check(root.left, curSum + root.val)\\n            right = check(root.right, curSum + root.val)\\n            \\n            return left or right\\n\\n        return check(root, 0) \\n\\n        "
                    },
                    {
                        "username": "1valeryvb",
                        "content": "curSum - root.val"
                    },
                    {
                        "username": "sjames8888",
                        "content": "Parsing given array into tree - suggested Java\n\nthe following Java seems to parse correctly.  Probably not best but incase it is useful to somone\n\n```java\nfinal var root = TreeNode.from2(new Integer[]{5,4,8,11,null,13,4,7,2,null,null,null,1});\n```\n\n\n                    5\n                /       \\\n               4         8\n             /         /   \\\n           11        13     4\n           / \\               \\\n          7   2               1\n\n```java\n  public static TreeNode from2(Integer[] arr) {\n        if (arr.length == 0) {\n            return null;\n        }\n        var ptr = 0;\n        final var root = new TreeNode(arr[ptr++]);\n        final Queue<TreeNode> q = new LinkedList<>();\n        q.add(root);\n\n        while (ptr < arr.length && !q.isEmpty()) {\n            final var size = q.size();\n            for (var i = 0; i < size; ++i) {\n                final var node = q.remove();\n                ptr = fromConsume(node, ptr, arr, q);\n            }\n        }\n\n        return root;\n    }\n\n    enum Position {\n        Left,\n        Right\n    }\n\n    public static int fromConsume(TreeNode focus, int ptr, Integer[] arr, Queue<TreeNode> q) {\n        if (ptr >= arr.length) return ptr;\n        if (focus == null) return ptr;\n\n        ptr  = fromConsumeOne(focus, ptr, arr,q, Position.Left);\n        if (ptr < arr.length) {\n            ptr  = fromConsumeOne(focus, ptr, arr,q,Position.Right);\n        }\n\n        return ptr;\n    }\n\n    public static TreeNode from(Integer[] arr) {\n        return from2(arr);\n\n    }\n\n    static int fromConsumeOne(TreeNode focus, int ptr, Integer[] arr, Queue<TreeNode> q, Position position) {\n        if (arr[ptr] == null) {\n            ptr++;\n        } else {\n            final var node = new TreeNode(arr[ptr++]);\n            q.add(node);\n            if (position == Position.Left) {\n                focus.left = node;\n            } else {\n                focus.right = node;\n            }\n        }\n        return ptr;\n    } \n```\n"
                    }
                ]
            },
            {
                "id": 1990034,
                "content": [
                    {
                        "username": "eduard92",
                        "content": "Pretty proud in March April.. I started learn for the first time traversals in trees and now I can approach these types of problems with a good thought what I should do, sometimes I take a peek if isn\\'t working, but wish I was again in my student years to grind this shit non-stop. "
                    },
                    {
                        "username": "kenimaru360",
                        "content": "[1,1,1,1] and target sum 2 is a good test case."
                    },
                    {
                        "username": "TernyavskyIlya",
                        "content": "Where my fail?\\n `def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        if not root:\\n            return False\\n        def wrap(root, total):\\n            if not root.left and not root.right:\\n                print(total)\\n                if total == targetSum:\\n                    return False\\n            if root.left:\\n                wrap(root.left, total+root.left.val)\\n            if root.right:\\n                wrap(root.right, total+root.right.val)\\n            return True\\n        wrap(root, root.val)\\n`"
                    },
                    {
                        "username": "chahatgupta1060",
                        "content": " @[leetcode](https://leetcode.com) `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...`[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "SanjayLakum_011",
                        "content": "the question has 117 testcases i have passed 99 testcase but my code is break while passing 100 number test case. the question asked you want to check that the binery tree path sum is equal of target sum. \"you should think about decrease the targetsum either think about increment "
                    },
                    {
                        "username": "kush512",
                        "content": "class Solution {\\npublic:\\n\\n    bool solve(TreeNode* root, int targetSum) {\\n        if(root==NULL && targetSum==0) return true;\\n        if(root==NULL) return false;\\n        bool l=hasPathSum(root->left, targetSum-root->val);\\n        bool r=hasPathSum(root->right, targetSum-root->val);\\n        return l || r;\\n    }\\n\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        if(root==NULL) return false; \\n        else return solve(root,targetSum);\\n    }\\n};\\n\\nwhy is it not giving correct answer?"
                    },
                    {
                        "username": "mvalpha",
                        "content": "There is a test case where root=[1,2], and target sum = 1, so it should return true but it expects false, which I can\\'t understand why. This is a weird test case."
                    },
                    {
                        "username": "sjames8888",
                        "content": "That\\u2019s a one sided tree where root 1 has one child 2 and leaf defined as no children nodes so path sum in this case is sum of 2 nodes. You have to include sum of 2 as this has no nodes so sum is 3 in this case "
                    },
                    {
                        "username": "SanjayLakum_011",
                        "content": "testcase 70 has something issue there is expected output is true but while debug my code in visual studio then received correct output but leetcode has something issue"
                    },
                    {
                        "username": "batuczarny",
                        "content": "Why does this code not work? \\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n\\n        def check(root, curSum):\\n            if not root:\\n                return False\\n        \\n            if root.left is None and root.right is None and curSum==targetSum:\\n                return True\\n            \\n            left = check(root.left, curSum + root.val)\\n            right = check(root.right, curSum + root.val)\\n            \\n            return left or right\\n\\n        return check(root, 0) \\n\\n        "
                    },
                    {
                        "username": "1valeryvb",
                        "content": "curSum - root.val"
                    },
                    {
                        "username": "sjames8888",
                        "content": "Parsing given array into tree - suggested Java\n\nthe following Java seems to parse correctly.  Probably not best but incase it is useful to somone\n\n```java\nfinal var root = TreeNode.from2(new Integer[]{5,4,8,11,null,13,4,7,2,null,null,null,1});\n```\n\n\n                    5\n                /       \\\n               4         8\n             /         /   \\\n           11        13     4\n           / \\               \\\n          7   2               1\n\n```java\n  public static TreeNode from2(Integer[] arr) {\n        if (arr.length == 0) {\n            return null;\n        }\n        var ptr = 0;\n        final var root = new TreeNode(arr[ptr++]);\n        final Queue<TreeNode> q = new LinkedList<>();\n        q.add(root);\n\n        while (ptr < arr.length && !q.isEmpty()) {\n            final var size = q.size();\n            for (var i = 0; i < size; ++i) {\n                final var node = q.remove();\n                ptr = fromConsume(node, ptr, arr, q);\n            }\n        }\n\n        return root;\n    }\n\n    enum Position {\n        Left,\n        Right\n    }\n\n    public static int fromConsume(TreeNode focus, int ptr, Integer[] arr, Queue<TreeNode> q) {\n        if (ptr >= arr.length) return ptr;\n        if (focus == null) return ptr;\n\n        ptr  = fromConsumeOne(focus, ptr, arr,q, Position.Left);\n        if (ptr < arr.length) {\n            ptr  = fromConsumeOne(focus, ptr, arr,q,Position.Right);\n        }\n\n        return ptr;\n    }\n\n    public static TreeNode from(Integer[] arr) {\n        return from2(arr);\n\n    }\n\n    static int fromConsumeOne(TreeNode focus, int ptr, Integer[] arr, Queue<TreeNode> q, Position position) {\n        if (arr[ptr] == null) {\n            ptr++;\n        } else {\n            final var node = new TreeNode(arr[ptr++]);\n            q.add(node);\n            if (position == Position.Left) {\n                focus.left = node;\n            } else {\n                focus.right = node;\n            }\n        }\n        return ptr;\n    } \n```\n"
                    }
                ]
            },
            {
                "id": 1972828,
                "content": [
                    {
                        "username": "eduard92",
                        "content": "Pretty proud in March April.. I started learn for the first time traversals in trees and now I can approach these types of problems with a good thought what I should do, sometimes I take a peek if isn\\'t working, but wish I was again in my student years to grind this shit non-stop. "
                    },
                    {
                        "username": "kenimaru360",
                        "content": "[1,1,1,1] and target sum 2 is a good test case."
                    },
                    {
                        "username": "TernyavskyIlya",
                        "content": "Where my fail?\\n `def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        if not root:\\n            return False\\n        def wrap(root, total):\\n            if not root.left and not root.right:\\n                print(total)\\n                if total == targetSum:\\n                    return False\\n            if root.left:\\n                wrap(root.left, total+root.left.val)\\n            if root.right:\\n                wrap(root.right, total+root.right.val)\\n            return True\\n        wrap(root, root.val)\\n`"
                    },
                    {
                        "username": "chahatgupta1060",
                        "content": " @[leetcode](https://leetcode.com) `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...`[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "SanjayLakum_011",
                        "content": "the question has 117 testcases i have passed 99 testcase but my code is break while passing 100 number test case. the question asked you want to check that the binery tree path sum is equal of target sum. \"you should think about decrease the targetsum either think about increment "
                    },
                    {
                        "username": "kush512",
                        "content": "class Solution {\\npublic:\\n\\n    bool solve(TreeNode* root, int targetSum) {\\n        if(root==NULL && targetSum==0) return true;\\n        if(root==NULL) return false;\\n        bool l=hasPathSum(root->left, targetSum-root->val);\\n        bool r=hasPathSum(root->right, targetSum-root->val);\\n        return l || r;\\n    }\\n\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        if(root==NULL) return false; \\n        else return solve(root,targetSum);\\n    }\\n};\\n\\nwhy is it not giving correct answer?"
                    },
                    {
                        "username": "mvalpha",
                        "content": "There is a test case where root=[1,2], and target sum = 1, so it should return true but it expects false, which I can\\'t understand why. This is a weird test case."
                    },
                    {
                        "username": "sjames8888",
                        "content": "That\\u2019s a one sided tree where root 1 has one child 2 and leaf defined as no children nodes so path sum in this case is sum of 2 nodes. You have to include sum of 2 as this has no nodes so sum is 3 in this case "
                    },
                    {
                        "username": "SanjayLakum_011",
                        "content": "testcase 70 has something issue there is expected output is true but while debug my code in visual studio then received correct output but leetcode has something issue"
                    },
                    {
                        "username": "batuczarny",
                        "content": "Why does this code not work? \\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n\\n        def check(root, curSum):\\n            if not root:\\n                return False\\n        \\n            if root.left is None and root.right is None and curSum==targetSum:\\n                return True\\n            \\n            left = check(root.left, curSum + root.val)\\n            right = check(root.right, curSum + root.val)\\n            \\n            return left or right\\n\\n        return check(root, 0) \\n\\n        "
                    },
                    {
                        "username": "1valeryvb",
                        "content": "curSum - root.val"
                    },
                    {
                        "username": "sjames8888",
                        "content": "Parsing given array into tree - suggested Java\n\nthe following Java seems to parse correctly.  Probably not best but incase it is useful to somone\n\n```java\nfinal var root = TreeNode.from2(new Integer[]{5,4,8,11,null,13,4,7,2,null,null,null,1});\n```\n\n\n                    5\n                /       \\\n               4         8\n             /         /   \\\n           11        13     4\n           / \\               \\\n          7   2               1\n\n```java\n  public static TreeNode from2(Integer[] arr) {\n        if (arr.length == 0) {\n            return null;\n        }\n        var ptr = 0;\n        final var root = new TreeNode(arr[ptr++]);\n        final Queue<TreeNode> q = new LinkedList<>();\n        q.add(root);\n\n        while (ptr < arr.length && !q.isEmpty()) {\n            final var size = q.size();\n            for (var i = 0; i < size; ++i) {\n                final var node = q.remove();\n                ptr = fromConsume(node, ptr, arr, q);\n            }\n        }\n\n        return root;\n    }\n\n    enum Position {\n        Left,\n        Right\n    }\n\n    public static int fromConsume(TreeNode focus, int ptr, Integer[] arr, Queue<TreeNode> q) {\n        if (ptr >= arr.length) return ptr;\n        if (focus == null) return ptr;\n\n        ptr  = fromConsumeOne(focus, ptr, arr,q, Position.Left);\n        if (ptr < arr.length) {\n            ptr  = fromConsumeOne(focus, ptr, arr,q,Position.Right);\n        }\n\n        return ptr;\n    }\n\n    public static TreeNode from(Integer[] arr) {\n        return from2(arr);\n\n    }\n\n    static int fromConsumeOne(TreeNode focus, int ptr, Integer[] arr, Queue<TreeNode> q, Position position) {\n        if (arr[ptr] == null) {\n            ptr++;\n        } else {\n            final var node = new TreeNode(arr[ptr++]);\n            q.add(node);\n            if (position == Position.Left) {\n                focus.left = node;\n            } else {\n                focus.right = node;\n            }\n        }\n        return ptr;\n    } \n```\n"
                    }
                ]
            },
            {
                "id": 1891414,
                "content": [
                    {
                        "username": "divyapbagul",
                        "content": "var hasPathSum = function(root, targetSum) {\\n  root = [1,2,3];\\n  targetSum = 5;\\n    var arr =[];\\n      for(var i = 0;i < root.length;i++){\\n          arr[i] = root[i];\\n        //   console.log(arr);\\n          if(arr.length > 1){\\n              var result = arr[0] + arr[1] ;\\n              var result2 = arr[0] + arr[2] ;\\n                if(result == targetSum){\\n                    console.log(result);\\n                    return true;\\n                    \\n                }else if(result2 == targetSum){\\n                    console.log(result2);\\n                    return true;\\n                }else{\\n                    return false;\\n                }\\n             \\n          }\\n      }\\n             \\n          \\n      \\n\\n};\\nhasPathSum([1,2,3],5);"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "thatCoderGirl",
                        "content": "I think there are few incorrect test cases in this question. \\n\\nCase 1: root =[1] , targetSum = 1, expects answer to be true.\\nCase 2: root =[1, 2] , targetSum = 1, expects answer to be false.\\n\\nAre we considering a solution only if it has a root-to-leaf path , or just root as the path also works ? If we are allowing just root also as the answer, then why in case 2, just root is not an answer ?\\n"
                    },
                    {
                        "username": "sujan_mandal",
                        "content": "root = [1,-2,-3,1,3,-2,null,-1]\\ntarget sum = -1\\nhow can this be true?"
                    },
                    {
                        "username": "Ijkeller",
                        "content": "Do we need to construct the tree within the function?  Also, is the input actually an array or is it the root node in a binary tree?"
                    },
                    {
                        "username": "AyushGupta2114",
                        "content": "can somebody tell what is the error in this \\n\\n\\n `\\'class Solution {\\npublic:\\n    long ans=0;\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        if(root==NULL)\\n            return false;\\n        return preorder(root,targetSum,ans);\\n    }\\n    bool preorder(TreeNode *root, long targetSum,long ans)\\n    {\\n\\n        if(root!=NULL)\\n        {\\n         ans+=root->val;\\n         cout<<ans<<endl;\\n         if(ans==targetSum)\\n                return true;\\n        preorder(root->left,targetSum,ans);\\n        preorder(root->right,targetSum,ans);\\n        }\\n        return false;\\n    }\\n};.``\\n\\nfor test case 1 getting false\\nbut by cout getting this \\n5\\n9\\n20\\n27\\n22\\n13\\n26\\n17\\n18"
                    },
                    {
                        "username": "ScientificX",
                        "content": "Please why doesnt this code pass all test cases \n\n `your inline code...your inline code...`\n\n `..class Solution:\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\n        if not root: return 0\n        ans = False\n        def solve(node, path):\n            nonlocal ans\n            if not node:\n                ans = ans or (sum(path) == targetSum)\n                return\n\n            solve(node.right, path + [node.val])\n            solve(node.left, path + [node.val])\n\n        solve(root, [])\n        return ans.`"
                    },
                    {
                        "username": "sachin2000",
                        "content": "In my first attempt , i cleared 100 test cases but then it got wrong answer in below test case :\n[1,2] \noutput = true;\nexpected output false;\n\nThen I read the question again and found that the sum must be root to leaf not in between .\n\nfor more details find below: \nhttps://leetcode.com/problems/path-sum/submissions/890816375/"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 0 ms || Beats 100% runtime || Easy to understand\\nhttps://leetcode.com/problems/path-sum/solutions/3049936/simple-java-0-ms-beats-100-runtime-easy-to-understand/"
                    },
                    {
                        "username": "rahulseith",
                        "content": "why A. [1,2] target = 1 : expected is false B.  [1] : target as 1  has expected ans as true.\\nthese two are contradictory"
                    },
                    {
                        "username": "shin_98",
                        "content": "Those are two different situations. As statet in description *A leaf is a node with no children*.\n`[1,2]` - in this situation root with value \"1\" is not a *leaf* because it has left child with value 2. So only path from root to leaf is from 1 to 2. Thus there is only one path with sum 3 = 1 + 2\n3 != 1 (target) so it is expected to be False.\n`[1]` - in this situation root is also a leaf because it has no children. So path from root to leaf has only one step with sum 1\n1 == 1 (target) so it is expected to be True."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    }
                ]
            },
            {
                "id": 1875137,
                "content": [
                    {
                        "username": "divyapbagul",
                        "content": "var hasPathSum = function(root, targetSum) {\\n  root = [1,2,3];\\n  targetSum = 5;\\n    var arr =[];\\n      for(var i = 0;i < root.length;i++){\\n          arr[i] = root[i];\\n        //   console.log(arr);\\n          if(arr.length > 1){\\n              var result = arr[0] + arr[1] ;\\n              var result2 = arr[0] + arr[2] ;\\n                if(result == targetSum){\\n                    console.log(result);\\n                    return true;\\n                    \\n                }else if(result2 == targetSum){\\n                    console.log(result2);\\n                    return true;\\n                }else{\\n                    return false;\\n                }\\n             \\n          }\\n      }\\n             \\n          \\n      \\n\\n};\\nhasPathSum([1,2,3],5);"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "thatCoderGirl",
                        "content": "I think there are few incorrect test cases in this question. \\n\\nCase 1: root =[1] , targetSum = 1, expects answer to be true.\\nCase 2: root =[1, 2] , targetSum = 1, expects answer to be false.\\n\\nAre we considering a solution only if it has a root-to-leaf path , or just root as the path also works ? If we are allowing just root also as the answer, then why in case 2, just root is not an answer ?\\n"
                    },
                    {
                        "username": "sujan_mandal",
                        "content": "root = [1,-2,-3,1,3,-2,null,-1]\\ntarget sum = -1\\nhow can this be true?"
                    },
                    {
                        "username": "Ijkeller",
                        "content": "Do we need to construct the tree within the function?  Also, is the input actually an array or is it the root node in a binary tree?"
                    },
                    {
                        "username": "AyushGupta2114",
                        "content": "can somebody tell what is the error in this \\n\\n\\n `\\'class Solution {\\npublic:\\n    long ans=0;\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        if(root==NULL)\\n            return false;\\n        return preorder(root,targetSum,ans);\\n    }\\n    bool preorder(TreeNode *root, long targetSum,long ans)\\n    {\\n\\n        if(root!=NULL)\\n        {\\n         ans+=root->val;\\n         cout<<ans<<endl;\\n         if(ans==targetSum)\\n                return true;\\n        preorder(root->left,targetSum,ans);\\n        preorder(root->right,targetSum,ans);\\n        }\\n        return false;\\n    }\\n};.``\\n\\nfor test case 1 getting false\\nbut by cout getting this \\n5\\n9\\n20\\n27\\n22\\n13\\n26\\n17\\n18"
                    },
                    {
                        "username": "ScientificX",
                        "content": "Please why doesnt this code pass all test cases \n\n `your inline code...your inline code...`\n\n `..class Solution:\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\n        if not root: return 0\n        ans = False\n        def solve(node, path):\n            nonlocal ans\n            if not node:\n                ans = ans or (sum(path) == targetSum)\n                return\n\n            solve(node.right, path + [node.val])\n            solve(node.left, path + [node.val])\n\n        solve(root, [])\n        return ans.`"
                    },
                    {
                        "username": "sachin2000",
                        "content": "In my first attempt , i cleared 100 test cases but then it got wrong answer in below test case :\n[1,2] \noutput = true;\nexpected output false;\n\nThen I read the question again and found that the sum must be root to leaf not in between .\n\nfor more details find below: \nhttps://leetcode.com/problems/path-sum/submissions/890816375/"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 0 ms || Beats 100% runtime || Easy to understand\\nhttps://leetcode.com/problems/path-sum/solutions/3049936/simple-java-0-ms-beats-100-runtime-easy-to-understand/"
                    },
                    {
                        "username": "rahulseith",
                        "content": "why A. [1,2] target = 1 : expected is false B.  [1] : target as 1  has expected ans as true.\\nthese two are contradictory"
                    },
                    {
                        "username": "shin_98",
                        "content": "Those are two different situations. As statet in description *A leaf is a node with no children*.\n`[1,2]` - in this situation root with value \"1\" is not a *leaf* because it has left child with value 2. So only path from root to leaf is from 1 to 2. Thus there is only one path with sum 3 = 1 + 2\n3 != 1 (target) so it is expected to be False.\n`[1]` - in this situation root is also a leaf because it has no children. So path from root to leaf has only one step with sum 1\n1 == 1 (target) so it is expected to be True."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    }
                ]
            },
            {
                "id": 1847826,
                "content": [
                    {
                        "username": "divyapbagul",
                        "content": "var hasPathSum = function(root, targetSum) {\\n  root = [1,2,3];\\n  targetSum = 5;\\n    var arr =[];\\n      for(var i = 0;i < root.length;i++){\\n          arr[i] = root[i];\\n        //   console.log(arr);\\n          if(arr.length > 1){\\n              var result = arr[0] + arr[1] ;\\n              var result2 = arr[0] + arr[2] ;\\n                if(result == targetSum){\\n                    console.log(result);\\n                    return true;\\n                    \\n                }else if(result2 == targetSum){\\n                    console.log(result2);\\n                    return true;\\n                }else{\\n                    return false;\\n                }\\n             \\n          }\\n      }\\n             \\n          \\n      \\n\\n};\\nhasPathSum([1,2,3],5);"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "thatCoderGirl",
                        "content": "I think there are few incorrect test cases in this question. \\n\\nCase 1: root =[1] , targetSum = 1, expects answer to be true.\\nCase 2: root =[1, 2] , targetSum = 1, expects answer to be false.\\n\\nAre we considering a solution only if it has a root-to-leaf path , or just root as the path also works ? If we are allowing just root also as the answer, then why in case 2, just root is not an answer ?\\n"
                    },
                    {
                        "username": "sujan_mandal",
                        "content": "root = [1,-2,-3,1,3,-2,null,-1]\\ntarget sum = -1\\nhow can this be true?"
                    },
                    {
                        "username": "Ijkeller",
                        "content": "Do we need to construct the tree within the function?  Also, is the input actually an array or is it the root node in a binary tree?"
                    },
                    {
                        "username": "AyushGupta2114",
                        "content": "can somebody tell what is the error in this \\n\\n\\n `\\'class Solution {\\npublic:\\n    long ans=0;\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        if(root==NULL)\\n            return false;\\n        return preorder(root,targetSum,ans);\\n    }\\n    bool preorder(TreeNode *root, long targetSum,long ans)\\n    {\\n\\n        if(root!=NULL)\\n        {\\n         ans+=root->val;\\n         cout<<ans<<endl;\\n         if(ans==targetSum)\\n                return true;\\n        preorder(root->left,targetSum,ans);\\n        preorder(root->right,targetSum,ans);\\n        }\\n        return false;\\n    }\\n};.``\\n\\nfor test case 1 getting false\\nbut by cout getting this \\n5\\n9\\n20\\n27\\n22\\n13\\n26\\n17\\n18"
                    },
                    {
                        "username": "ScientificX",
                        "content": "Please why doesnt this code pass all test cases \n\n `your inline code...your inline code...`\n\n `..class Solution:\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\n        if not root: return 0\n        ans = False\n        def solve(node, path):\n            nonlocal ans\n            if not node:\n                ans = ans or (sum(path) == targetSum)\n                return\n\n            solve(node.right, path + [node.val])\n            solve(node.left, path + [node.val])\n\n        solve(root, [])\n        return ans.`"
                    },
                    {
                        "username": "sachin2000",
                        "content": "In my first attempt , i cleared 100 test cases but then it got wrong answer in below test case :\n[1,2] \noutput = true;\nexpected output false;\n\nThen I read the question again and found that the sum must be root to leaf not in between .\n\nfor more details find below: \nhttps://leetcode.com/problems/path-sum/submissions/890816375/"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 0 ms || Beats 100% runtime || Easy to understand\\nhttps://leetcode.com/problems/path-sum/solutions/3049936/simple-java-0-ms-beats-100-runtime-easy-to-understand/"
                    },
                    {
                        "username": "rahulseith",
                        "content": "why A. [1,2] target = 1 : expected is false B.  [1] : target as 1  has expected ans as true.\\nthese two are contradictory"
                    },
                    {
                        "username": "shin_98",
                        "content": "Those are two different situations. As statet in description *A leaf is a node with no children*.\n`[1,2]` - in this situation root with value \"1\" is not a *leaf* because it has left child with value 2. So only path from root to leaf is from 1 to 2. Thus there is only one path with sum 3 = 1 + 2\n3 != 1 (target) so it is expected to be False.\n`[1]` - in this situation root is also a leaf because it has no children. So path from root to leaf has only one step with sum 1\n1 == 1 (target) so it is expected to be True."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    }
                ]
            },
            {
                "id": 1839802,
                "content": [
                    {
                        "username": "divyapbagul",
                        "content": "var hasPathSum = function(root, targetSum) {\\n  root = [1,2,3];\\n  targetSum = 5;\\n    var arr =[];\\n      for(var i = 0;i < root.length;i++){\\n          arr[i] = root[i];\\n        //   console.log(arr);\\n          if(arr.length > 1){\\n              var result = arr[0] + arr[1] ;\\n              var result2 = arr[0] + arr[2] ;\\n                if(result == targetSum){\\n                    console.log(result);\\n                    return true;\\n                    \\n                }else if(result2 == targetSum){\\n                    console.log(result2);\\n                    return true;\\n                }else{\\n                    return false;\\n                }\\n             \\n          }\\n      }\\n             \\n          \\n      \\n\\n};\\nhasPathSum([1,2,3],5);"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "thatCoderGirl",
                        "content": "I think there are few incorrect test cases in this question. \\n\\nCase 1: root =[1] , targetSum = 1, expects answer to be true.\\nCase 2: root =[1, 2] , targetSum = 1, expects answer to be false.\\n\\nAre we considering a solution only if it has a root-to-leaf path , or just root as the path also works ? If we are allowing just root also as the answer, then why in case 2, just root is not an answer ?\\n"
                    },
                    {
                        "username": "sujan_mandal",
                        "content": "root = [1,-2,-3,1,3,-2,null,-1]\\ntarget sum = -1\\nhow can this be true?"
                    },
                    {
                        "username": "Ijkeller",
                        "content": "Do we need to construct the tree within the function?  Also, is the input actually an array or is it the root node in a binary tree?"
                    },
                    {
                        "username": "AyushGupta2114",
                        "content": "can somebody tell what is the error in this \\n\\n\\n `\\'class Solution {\\npublic:\\n    long ans=0;\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        if(root==NULL)\\n            return false;\\n        return preorder(root,targetSum,ans);\\n    }\\n    bool preorder(TreeNode *root, long targetSum,long ans)\\n    {\\n\\n        if(root!=NULL)\\n        {\\n         ans+=root->val;\\n         cout<<ans<<endl;\\n         if(ans==targetSum)\\n                return true;\\n        preorder(root->left,targetSum,ans);\\n        preorder(root->right,targetSum,ans);\\n        }\\n        return false;\\n    }\\n};.``\\n\\nfor test case 1 getting false\\nbut by cout getting this \\n5\\n9\\n20\\n27\\n22\\n13\\n26\\n17\\n18"
                    },
                    {
                        "username": "ScientificX",
                        "content": "Please why doesnt this code pass all test cases \n\n `your inline code...your inline code...`\n\n `..class Solution:\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\n        if not root: return 0\n        ans = False\n        def solve(node, path):\n            nonlocal ans\n            if not node:\n                ans = ans or (sum(path) == targetSum)\n                return\n\n            solve(node.right, path + [node.val])\n            solve(node.left, path + [node.val])\n\n        solve(root, [])\n        return ans.`"
                    },
                    {
                        "username": "sachin2000",
                        "content": "In my first attempt , i cleared 100 test cases but then it got wrong answer in below test case :\n[1,2] \noutput = true;\nexpected output false;\n\nThen I read the question again and found that the sum must be root to leaf not in between .\n\nfor more details find below: \nhttps://leetcode.com/problems/path-sum/submissions/890816375/"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 0 ms || Beats 100% runtime || Easy to understand\\nhttps://leetcode.com/problems/path-sum/solutions/3049936/simple-java-0-ms-beats-100-runtime-easy-to-understand/"
                    },
                    {
                        "username": "rahulseith",
                        "content": "why A. [1,2] target = 1 : expected is false B.  [1] : target as 1  has expected ans as true.\\nthese two are contradictory"
                    },
                    {
                        "username": "shin_98",
                        "content": "Those are two different situations. As statet in description *A leaf is a node with no children*.\n`[1,2]` - in this situation root with value \"1\" is not a *leaf* because it has left child with value 2. So only path from root to leaf is from 1 to 2. Thus there is only one path with sum 3 = 1 + 2\n3 != 1 (target) so it is expected to be False.\n`[1]` - in this situation root is also a leaf because it has no children. So path from root to leaf has only one step with sum 1\n1 == 1 (target) so it is expected to be True."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    }
                ]
            },
            {
                "id": 1833547,
                "content": [
                    {
                        "username": "divyapbagul",
                        "content": "var hasPathSum = function(root, targetSum) {\\n  root = [1,2,3];\\n  targetSum = 5;\\n    var arr =[];\\n      for(var i = 0;i < root.length;i++){\\n          arr[i] = root[i];\\n        //   console.log(arr);\\n          if(arr.length > 1){\\n              var result = arr[0] + arr[1] ;\\n              var result2 = arr[0] + arr[2] ;\\n                if(result == targetSum){\\n                    console.log(result);\\n                    return true;\\n                    \\n                }else if(result2 == targetSum){\\n                    console.log(result2);\\n                    return true;\\n                }else{\\n                    return false;\\n                }\\n             \\n          }\\n      }\\n             \\n          \\n      \\n\\n};\\nhasPathSum([1,2,3],5);"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "thatCoderGirl",
                        "content": "I think there are few incorrect test cases in this question. \\n\\nCase 1: root =[1] , targetSum = 1, expects answer to be true.\\nCase 2: root =[1, 2] , targetSum = 1, expects answer to be false.\\n\\nAre we considering a solution only if it has a root-to-leaf path , or just root as the path also works ? If we are allowing just root also as the answer, then why in case 2, just root is not an answer ?\\n"
                    },
                    {
                        "username": "sujan_mandal",
                        "content": "root = [1,-2,-3,1,3,-2,null,-1]\\ntarget sum = -1\\nhow can this be true?"
                    },
                    {
                        "username": "Ijkeller",
                        "content": "Do we need to construct the tree within the function?  Also, is the input actually an array or is it the root node in a binary tree?"
                    },
                    {
                        "username": "AyushGupta2114",
                        "content": "can somebody tell what is the error in this \\n\\n\\n `\\'class Solution {\\npublic:\\n    long ans=0;\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        if(root==NULL)\\n            return false;\\n        return preorder(root,targetSum,ans);\\n    }\\n    bool preorder(TreeNode *root, long targetSum,long ans)\\n    {\\n\\n        if(root!=NULL)\\n        {\\n         ans+=root->val;\\n         cout<<ans<<endl;\\n         if(ans==targetSum)\\n                return true;\\n        preorder(root->left,targetSum,ans);\\n        preorder(root->right,targetSum,ans);\\n        }\\n        return false;\\n    }\\n};.``\\n\\nfor test case 1 getting false\\nbut by cout getting this \\n5\\n9\\n20\\n27\\n22\\n13\\n26\\n17\\n18"
                    },
                    {
                        "username": "ScientificX",
                        "content": "Please why doesnt this code pass all test cases \n\n `your inline code...your inline code...`\n\n `..class Solution:\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\n        if not root: return 0\n        ans = False\n        def solve(node, path):\n            nonlocal ans\n            if not node:\n                ans = ans or (sum(path) == targetSum)\n                return\n\n            solve(node.right, path + [node.val])\n            solve(node.left, path + [node.val])\n\n        solve(root, [])\n        return ans.`"
                    },
                    {
                        "username": "sachin2000",
                        "content": "In my first attempt , i cleared 100 test cases but then it got wrong answer in below test case :\n[1,2] \noutput = true;\nexpected output false;\n\nThen I read the question again and found that the sum must be root to leaf not in between .\n\nfor more details find below: \nhttps://leetcode.com/problems/path-sum/submissions/890816375/"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 0 ms || Beats 100% runtime || Easy to understand\\nhttps://leetcode.com/problems/path-sum/solutions/3049936/simple-java-0-ms-beats-100-runtime-easy-to-understand/"
                    },
                    {
                        "username": "rahulseith",
                        "content": "why A. [1,2] target = 1 : expected is false B.  [1] : target as 1  has expected ans as true.\\nthese two are contradictory"
                    },
                    {
                        "username": "shin_98",
                        "content": "Those are two different situations. As statet in description *A leaf is a node with no children*.\n`[1,2]` - in this situation root with value \"1\" is not a *leaf* because it has left child with value 2. So only path from root to leaf is from 1 to 2. Thus there is only one path with sum 3 = 1 + 2\n3 != 1 (target) so it is expected to be False.\n`[1]` - in this situation root is also a leaf because it has no children. So path from root to leaf has only one step with sum 1\n1 == 1 (target) so it is expected to be True."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    }
                ]
            },
            {
                "id": 1830752,
                "content": [
                    {
                        "username": "divyapbagul",
                        "content": "var hasPathSum = function(root, targetSum) {\\n  root = [1,2,3];\\n  targetSum = 5;\\n    var arr =[];\\n      for(var i = 0;i < root.length;i++){\\n          arr[i] = root[i];\\n        //   console.log(arr);\\n          if(arr.length > 1){\\n              var result = arr[0] + arr[1] ;\\n              var result2 = arr[0] + arr[2] ;\\n                if(result == targetSum){\\n                    console.log(result);\\n                    return true;\\n                    \\n                }else if(result2 == targetSum){\\n                    console.log(result2);\\n                    return true;\\n                }else{\\n                    return false;\\n                }\\n             \\n          }\\n      }\\n             \\n          \\n      \\n\\n};\\nhasPathSum([1,2,3],5);"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "thatCoderGirl",
                        "content": "I think there are few incorrect test cases in this question. \\n\\nCase 1: root =[1] , targetSum = 1, expects answer to be true.\\nCase 2: root =[1, 2] , targetSum = 1, expects answer to be false.\\n\\nAre we considering a solution only if it has a root-to-leaf path , or just root as the path also works ? If we are allowing just root also as the answer, then why in case 2, just root is not an answer ?\\n"
                    },
                    {
                        "username": "sujan_mandal",
                        "content": "root = [1,-2,-3,1,3,-2,null,-1]\\ntarget sum = -1\\nhow can this be true?"
                    },
                    {
                        "username": "Ijkeller",
                        "content": "Do we need to construct the tree within the function?  Also, is the input actually an array or is it the root node in a binary tree?"
                    },
                    {
                        "username": "AyushGupta2114",
                        "content": "can somebody tell what is the error in this \\n\\n\\n `\\'class Solution {\\npublic:\\n    long ans=0;\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        if(root==NULL)\\n            return false;\\n        return preorder(root,targetSum,ans);\\n    }\\n    bool preorder(TreeNode *root, long targetSum,long ans)\\n    {\\n\\n        if(root!=NULL)\\n        {\\n         ans+=root->val;\\n         cout<<ans<<endl;\\n         if(ans==targetSum)\\n                return true;\\n        preorder(root->left,targetSum,ans);\\n        preorder(root->right,targetSum,ans);\\n        }\\n        return false;\\n    }\\n};.``\\n\\nfor test case 1 getting false\\nbut by cout getting this \\n5\\n9\\n20\\n27\\n22\\n13\\n26\\n17\\n18"
                    },
                    {
                        "username": "ScientificX",
                        "content": "Please why doesnt this code pass all test cases \n\n `your inline code...your inline code...`\n\n `..class Solution:\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\n        if not root: return 0\n        ans = False\n        def solve(node, path):\n            nonlocal ans\n            if not node:\n                ans = ans or (sum(path) == targetSum)\n                return\n\n            solve(node.right, path + [node.val])\n            solve(node.left, path + [node.val])\n\n        solve(root, [])\n        return ans.`"
                    },
                    {
                        "username": "sachin2000",
                        "content": "In my first attempt , i cleared 100 test cases but then it got wrong answer in below test case :\n[1,2] \noutput = true;\nexpected output false;\n\nThen I read the question again and found that the sum must be root to leaf not in between .\n\nfor more details find below: \nhttps://leetcode.com/problems/path-sum/submissions/890816375/"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 0 ms || Beats 100% runtime || Easy to understand\\nhttps://leetcode.com/problems/path-sum/solutions/3049936/simple-java-0-ms-beats-100-runtime-easy-to-understand/"
                    },
                    {
                        "username": "rahulseith",
                        "content": "why A. [1,2] target = 1 : expected is false B.  [1] : target as 1  has expected ans as true.\\nthese two are contradictory"
                    },
                    {
                        "username": "shin_98",
                        "content": "Those are two different situations. As statet in description *A leaf is a node with no children*.\n`[1,2]` - in this situation root with value \"1\" is not a *leaf* because it has left child with value 2. So only path from root to leaf is from 1 to 2. Thus there is only one path with sum 3 = 1 + 2\n3 != 1 (target) so it is expected to be False.\n`[1]` - in this situation root is also a leaf because it has no children. So path from root to leaf has only one step with sum 1\n1 == 1 (target) so it is expected to be True."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    }
                ]
            },
            {
                "id": 1786313,
                "content": [
                    {
                        "username": "divyapbagul",
                        "content": "var hasPathSum = function(root, targetSum) {\\n  root = [1,2,3];\\n  targetSum = 5;\\n    var arr =[];\\n      for(var i = 0;i < root.length;i++){\\n          arr[i] = root[i];\\n        //   console.log(arr);\\n          if(arr.length > 1){\\n              var result = arr[0] + arr[1] ;\\n              var result2 = arr[0] + arr[2] ;\\n                if(result == targetSum){\\n                    console.log(result);\\n                    return true;\\n                    \\n                }else if(result2 == targetSum){\\n                    console.log(result2);\\n                    return true;\\n                }else{\\n                    return false;\\n                }\\n             \\n          }\\n      }\\n             \\n          \\n      \\n\\n};\\nhasPathSum([1,2,3],5);"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "thatCoderGirl",
                        "content": "I think there are few incorrect test cases in this question. \\n\\nCase 1: root =[1] , targetSum = 1, expects answer to be true.\\nCase 2: root =[1, 2] , targetSum = 1, expects answer to be false.\\n\\nAre we considering a solution only if it has a root-to-leaf path , or just root as the path also works ? If we are allowing just root also as the answer, then why in case 2, just root is not an answer ?\\n"
                    },
                    {
                        "username": "sujan_mandal",
                        "content": "root = [1,-2,-3,1,3,-2,null,-1]\\ntarget sum = -1\\nhow can this be true?"
                    },
                    {
                        "username": "Ijkeller",
                        "content": "Do we need to construct the tree within the function?  Also, is the input actually an array or is it the root node in a binary tree?"
                    },
                    {
                        "username": "AyushGupta2114",
                        "content": "can somebody tell what is the error in this \\n\\n\\n `\\'class Solution {\\npublic:\\n    long ans=0;\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        if(root==NULL)\\n            return false;\\n        return preorder(root,targetSum,ans);\\n    }\\n    bool preorder(TreeNode *root, long targetSum,long ans)\\n    {\\n\\n        if(root!=NULL)\\n        {\\n         ans+=root->val;\\n         cout<<ans<<endl;\\n         if(ans==targetSum)\\n                return true;\\n        preorder(root->left,targetSum,ans);\\n        preorder(root->right,targetSum,ans);\\n        }\\n        return false;\\n    }\\n};.``\\n\\nfor test case 1 getting false\\nbut by cout getting this \\n5\\n9\\n20\\n27\\n22\\n13\\n26\\n17\\n18"
                    },
                    {
                        "username": "ScientificX",
                        "content": "Please why doesnt this code pass all test cases \n\n `your inline code...your inline code...`\n\n `..class Solution:\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\n        if not root: return 0\n        ans = False\n        def solve(node, path):\n            nonlocal ans\n            if not node:\n                ans = ans or (sum(path) == targetSum)\n                return\n\n            solve(node.right, path + [node.val])\n            solve(node.left, path + [node.val])\n\n        solve(root, [])\n        return ans.`"
                    },
                    {
                        "username": "sachin2000",
                        "content": "In my first attempt , i cleared 100 test cases but then it got wrong answer in below test case :\n[1,2] \noutput = true;\nexpected output false;\n\nThen I read the question again and found that the sum must be root to leaf not in between .\n\nfor more details find below: \nhttps://leetcode.com/problems/path-sum/submissions/890816375/"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 0 ms || Beats 100% runtime || Easy to understand\\nhttps://leetcode.com/problems/path-sum/solutions/3049936/simple-java-0-ms-beats-100-runtime-easy-to-understand/"
                    },
                    {
                        "username": "rahulseith",
                        "content": "why A. [1,2] target = 1 : expected is false B.  [1] : target as 1  has expected ans as true.\\nthese two are contradictory"
                    },
                    {
                        "username": "shin_98",
                        "content": "Those are two different situations. As statet in description *A leaf is a node with no children*.\n`[1,2]` - in this situation root with value \"1\" is not a *leaf* because it has left child with value 2. So only path from root to leaf is from 1 to 2. Thus there is only one path with sum 3 = 1 + 2\n3 != 1 (target) so it is expected to be False.\n`[1]` - in this situation root is also a leaf because it has no children. So path from root to leaf has only one step with sum 1\n1 == 1 (target) so it is expected to be True."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    }
                ]
            },
            {
                "id": 1757501,
                "content": [
                    {
                        "username": "divyapbagul",
                        "content": "var hasPathSum = function(root, targetSum) {\\n  root = [1,2,3];\\n  targetSum = 5;\\n    var arr =[];\\n      for(var i = 0;i < root.length;i++){\\n          arr[i] = root[i];\\n        //   console.log(arr);\\n          if(arr.length > 1){\\n              var result = arr[0] + arr[1] ;\\n              var result2 = arr[0] + arr[2] ;\\n                if(result == targetSum){\\n                    console.log(result);\\n                    return true;\\n                    \\n                }else if(result2 == targetSum){\\n                    console.log(result2);\\n                    return true;\\n                }else{\\n                    return false;\\n                }\\n             \\n          }\\n      }\\n             \\n          \\n      \\n\\n};\\nhasPathSum([1,2,3],5);"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "thatCoderGirl",
                        "content": "I think there are few incorrect test cases in this question. \\n\\nCase 1: root =[1] , targetSum = 1, expects answer to be true.\\nCase 2: root =[1, 2] , targetSum = 1, expects answer to be false.\\n\\nAre we considering a solution only if it has a root-to-leaf path , or just root as the path also works ? If we are allowing just root also as the answer, then why in case 2, just root is not an answer ?\\n"
                    },
                    {
                        "username": "sujan_mandal",
                        "content": "root = [1,-2,-3,1,3,-2,null,-1]\\ntarget sum = -1\\nhow can this be true?"
                    },
                    {
                        "username": "Ijkeller",
                        "content": "Do we need to construct the tree within the function?  Also, is the input actually an array or is it the root node in a binary tree?"
                    },
                    {
                        "username": "AyushGupta2114",
                        "content": "can somebody tell what is the error in this \\n\\n\\n `\\'class Solution {\\npublic:\\n    long ans=0;\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        if(root==NULL)\\n            return false;\\n        return preorder(root,targetSum,ans);\\n    }\\n    bool preorder(TreeNode *root, long targetSum,long ans)\\n    {\\n\\n        if(root!=NULL)\\n        {\\n         ans+=root->val;\\n         cout<<ans<<endl;\\n         if(ans==targetSum)\\n                return true;\\n        preorder(root->left,targetSum,ans);\\n        preorder(root->right,targetSum,ans);\\n        }\\n        return false;\\n    }\\n};.``\\n\\nfor test case 1 getting false\\nbut by cout getting this \\n5\\n9\\n20\\n27\\n22\\n13\\n26\\n17\\n18"
                    },
                    {
                        "username": "ScientificX",
                        "content": "Please why doesnt this code pass all test cases \n\n `your inline code...your inline code...`\n\n `..class Solution:\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\n        if not root: return 0\n        ans = False\n        def solve(node, path):\n            nonlocal ans\n            if not node:\n                ans = ans or (sum(path) == targetSum)\n                return\n\n            solve(node.right, path + [node.val])\n            solve(node.left, path + [node.val])\n\n        solve(root, [])\n        return ans.`"
                    },
                    {
                        "username": "sachin2000",
                        "content": "In my first attempt , i cleared 100 test cases but then it got wrong answer in below test case :\n[1,2] \noutput = true;\nexpected output false;\n\nThen I read the question again and found that the sum must be root to leaf not in between .\n\nfor more details find below: \nhttps://leetcode.com/problems/path-sum/submissions/890816375/"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 0 ms || Beats 100% runtime || Easy to understand\\nhttps://leetcode.com/problems/path-sum/solutions/3049936/simple-java-0-ms-beats-100-runtime-easy-to-understand/"
                    },
                    {
                        "username": "rahulseith",
                        "content": "why A. [1,2] target = 1 : expected is false B.  [1] : target as 1  has expected ans as true.\\nthese two are contradictory"
                    },
                    {
                        "username": "shin_98",
                        "content": "Those are two different situations. As statet in description *A leaf is a node with no children*.\n`[1,2]` - in this situation root with value \"1\" is not a *leaf* because it has left child with value 2. So only path from root to leaf is from 1 to 2. Thus there is only one path with sum 3 = 1 + 2\n3 != 1 (target) so it is expected to be False.\n`[1]` - in this situation root is also a leaf because it has no children. So path from root to leaf has only one step with sum 1\n1 == 1 (target) so it is expected to be True."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    }
                ]
            },
            {
                "id": 1738580,
                "content": [
                    {
                        "username": "divyapbagul",
                        "content": "var hasPathSum = function(root, targetSum) {\\n  root = [1,2,3];\\n  targetSum = 5;\\n    var arr =[];\\n      for(var i = 0;i < root.length;i++){\\n          arr[i] = root[i];\\n        //   console.log(arr);\\n          if(arr.length > 1){\\n              var result = arr[0] + arr[1] ;\\n              var result2 = arr[0] + arr[2] ;\\n                if(result == targetSum){\\n                    console.log(result);\\n                    return true;\\n                    \\n                }else if(result2 == targetSum){\\n                    console.log(result2);\\n                    return true;\\n                }else{\\n                    return false;\\n                }\\n             \\n          }\\n      }\\n             \\n          \\n      \\n\\n};\\nhasPathSum([1,2,3],5);"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "thatCoderGirl",
                        "content": "I think there are few incorrect test cases in this question. \\n\\nCase 1: root =[1] , targetSum = 1, expects answer to be true.\\nCase 2: root =[1, 2] , targetSum = 1, expects answer to be false.\\n\\nAre we considering a solution only if it has a root-to-leaf path , or just root as the path also works ? If we are allowing just root also as the answer, then why in case 2, just root is not an answer ?\\n"
                    },
                    {
                        "username": "sujan_mandal",
                        "content": "root = [1,-2,-3,1,3,-2,null,-1]\\ntarget sum = -1\\nhow can this be true?"
                    },
                    {
                        "username": "Ijkeller",
                        "content": "Do we need to construct the tree within the function?  Also, is the input actually an array or is it the root node in a binary tree?"
                    },
                    {
                        "username": "AyushGupta2114",
                        "content": "can somebody tell what is the error in this \\n\\n\\n `\\'class Solution {\\npublic:\\n    long ans=0;\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        if(root==NULL)\\n            return false;\\n        return preorder(root,targetSum,ans);\\n    }\\n    bool preorder(TreeNode *root, long targetSum,long ans)\\n    {\\n\\n        if(root!=NULL)\\n        {\\n         ans+=root->val;\\n         cout<<ans<<endl;\\n         if(ans==targetSum)\\n                return true;\\n        preorder(root->left,targetSum,ans);\\n        preorder(root->right,targetSum,ans);\\n        }\\n        return false;\\n    }\\n};.``\\n\\nfor test case 1 getting false\\nbut by cout getting this \\n5\\n9\\n20\\n27\\n22\\n13\\n26\\n17\\n18"
                    },
                    {
                        "username": "ScientificX",
                        "content": "Please why doesnt this code pass all test cases \n\n `your inline code...your inline code...`\n\n `..class Solution:\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\n        if not root: return 0\n        ans = False\n        def solve(node, path):\n            nonlocal ans\n            if not node:\n                ans = ans or (sum(path) == targetSum)\n                return\n\n            solve(node.right, path + [node.val])\n            solve(node.left, path + [node.val])\n\n        solve(root, [])\n        return ans.`"
                    },
                    {
                        "username": "sachin2000",
                        "content": "In my first attempt , i cleared 100 test cases but then it got wrong answer in below test case :\n[1,2] \noutput = true;\nexpected output false;\n\nThen I read the question again and found that the sum must be root to leaf not in between .\n\nfor more details find below: \nhttps://leetcode.com/problems/path-sum/submissions/890816375/"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 0 ms || Beats 100% runtime || Easy to understand\\nhttps://leetcode.com/problems/path-sum/solutions/3049936/simple-java-0-ms-beats-100-runtime-easy-to-understand/"
                    },
                    {
                        "username": "rahulseith",
                        "content": "why A. [1,2] target = 1 : expected is false B.  [1] : target as 1  has expected ans as true.\\nthese two are contradictory"
                    },
                    {
                        "username": "shin_98",
                        "content": "Those are two different situations. As statet in description *A leaf is a node with no children*.\n`[1,2]` - in this situation root with value \"1\" is not a *leaf* because it has left child with value 2. So only path from root to leaf is from 1 to 2. Thus there is only one path with sum 3 = 1 + 2\n3 != 1 (target) so it is expected to be False.\n`[1]` - in this situation root is also a leaf because it has no children. So path from root to leaf has only one step with sum 1\n1 == 1 (target) so it is expected to be True."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    }
                ]
            },
            {
                "id": 1728211,
                "content": [
                    {
                        "username": "divyapbagul",
                        "content": "var hasPathSum = function(root, targetSum) {\\n  root = [1,2,3];\\n  targetSum = 5;\\n    var arr =[];\\n      for(var i = 0;i < root.length;i++){\\n          arr[i] = root[i];\\n        //   console.log(arr);\\n          if(arr.length > 1){\\n              var result = arr[0] + arr[1] ;\\n              var result2 = arr[0] + arr[2] ;\\n                if(result == targetSum){\\n                    console.log(result);\\n                    return true;\\n                    \\n                }else if(result2 == targetSum){\\n                    console.log(result2);\\n                    return true;\\n                }else{\\n                    return false;\\n                }\\n             \\n          }\\n      }\\n             \\n          \\n      \\n\\n};\\nhasPathSum([1,2,3],5);"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "thatCoderGirl",
                        "content": "I think there are few incorrect test cases in this question. \\n\\nCase 1: root =[1] , targetSum = 1, expects answer to be true.\\nCase 2: root =[1, 2] , targetSum = 1, expects answer to be false.\\n\\nAre we considering a solution only if it has a root-to-leaf path , or just root as the path also works ? If we are allowing just root also as the answer, then why in case 2, just root is not an answer ?\\n"
                    },
                    {
                        "username": "sujan_mandal",
                        "content": "root = [1,-2,-3,1,3,-2,null,-1]\\ntarget sum = -1\\nhow can this be true?"
                    },
                    {
                        "username": "Ijkeller",
                        "content": "Do we need to construct the tree within the function?  Also, is the input actually an array or is it the root node in a binary tree?"
                    },
                    {
                        "username": "AyushGupta2114",
                        "content": "can somebody tell what is the error in this \\n\\n\\n `\\'class Solution {\\npublic:\\n    long ans=0;\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        if(root==NULL)\\n            return false;\\n        return preorder(root,targetSum,ans);\\n    }\\n    bool preorder(TreeNode *root, long targetSum,long ans)\\n    {\\n\\n        if(root!=NULL)\\n        {\\n         ans+=root->val;\\n         cout<<ans<<endl;\\n         if(ans==targetSum)\\n                return true;\\n        preorder(root->left,targetSum,ans);\\n        preorder(root->right,targetSum,ans);\\n        }\\n        return false;\\n    }\\n};.``\\n\\nfor test case 1 getting false\\nbut by cout getting this \\n5\\n9\\n20\\n27\\n22\\n13\\n26\\n17\\n18"
                    },
                    {
                        "username": "ScientificX",
                        "content": "Please why doesnt this code pass all test cases \n\n `your inline code...your inline code...`\n\n `..class Solution:\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\n        if not root: return 0\n        ans = False\n        def solve(node, path):\n            nonlocal ans\n            if not node:\n                ans = ans or (sum(path) == targetSum)\n                return\n\n            solve(node.right, path + [node.val])\n            solve(node.left, path + [node.val])\n\n        solve(root, [])\n        return ans.`"
                    },
                    {
                        "username": "sachin2000",
                        "content": "In my first attempt , i cleared 100 test cases but then it got wrong answer in below test case :\n[1,2] \noutput = true;\nexpected output false;\n\nThen I read the question again and found that the sum must be root to leaf not in between .\n\nfor more details find below: \nhttps://leetcode.com/problems/path-sum/submissions/890816375/"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 0 ms || Beats 100% runtime || Easy to understand\\nhttps://leetcode.com/problems/path-sum/solutions/3049936/simple-java-0-ms-beats-100-runtime-easy-to-understand/"
                    },
                    {
                        "username": "rahulseith",
                        "content": "why A. [1,2] target = 1 : expected is false B.  [1] : target as 1  has expected ans as true.\\nthese two are contradictory"
                    },
                    {
                        "username": "shin_98",
                        "content": "Those are two different situations. As statet in description *A leaf is a node with no children*.\n`[1,2]` - in this situation root with value \"1\" is not a *leaf* because it has left child with value 2. So only path from root to leaf is from 1 to 2. Thus there is only one path with sum 3 = 1 + 2\n3 != 1 (target) so it is expected to be False.\n`[1]` - in this situation root is also a leaf because it has no children. So path from root to leaf has only one step with sum 1\n1 == 1 (target) so it is expected to be True."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    }
                ]
            }
        ]
    }
]