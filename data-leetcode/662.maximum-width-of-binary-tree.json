[
    {
        "title": "Dungeon Game",
        "question_content": "The demons had captured the princess and imprisoned her in the bottom-right corner of a dungeon. The dungeon consists of m x n rooms laid out in a 2D grid. Our valiant knight was initially positioned in the top-left room and must fight his way through dungeon to rescue the princess.\nThe knight has an initial health point represented by a positive integer. If at any point his health point drops to 0 or below, he dies immediately.\nSome of the rooms are guarded by demons (represented by negative integers), so the knight loses health upon entering these rooms; other rooms are either empty (represented as 0) or contain magic orbs that increase the knight's health (represented by positive integers).\nTo reach the princess as quickly as possible, the knight decides to move only rightward or downward in each step.\nReturn the knight's minimum initial health so that he can rescue the princess.\nNote that any room can contain threats or power-ups, even the first room the knight enters and the bottom-right room where the princess is imprisoned.\n&nbsp;\nExample 1:\n\nInput: dungeon = [[-2,-3,3],[-5,-10,1],[10,30,-5]]\nOutput: 7\nExplanation: The initial health of the knight must be at least 7 if he follows the optimal path: RIGHT-> RIGHT -> DOWN -> DOWN.\n\nExample 2:\n\nInput: dungeon = [[0]]\nOutput: 1\n\n&nbsp;\nConstraints:\n\n\tm == dungeon.length\n\tn == dungeon[i].length\n\t1 <= m, n <= 200\n\t-1000 <= dungeon[i][j] <= 1000",
        "solutions": [
            {
                "id": 745340,
                "title": "post-dedicated-to-beginners-of-dp-or-have-no-clue-how-to-start",
                "content": "**before starting with DP one must master the art of recursion**\\nmost of the post shows you the optimal solution, briefly explains how it works, but doesn\\'t tell you how to arive at that solution. it goes as \"give man a fish, he can eat it whole day, tell then how to catch one, he can have it whole life\".\\nhere is how you should approach these recurrsive/Dp problems. hopefully you will learn something.\\n\\n**step1 : understand the problem**\\nhere we have been given a matrix we need to start from top and find a way to get to bottom right, we need the min cost that is required to do this\\n\\n**step 2: logic building and deriving recurence relation**\\n\\n**1st sub step : asking questions**\\n1. At any point if our health gets zero of below we dies, athem so :  we need 1 + (-mat[i][j]) for our health to be one.\\n2. What if we get some health if we arrive at some cell ? my guess is we still need 1 health in first case to arrive at that cell - cases like these need to be figure out by yourself.\\n3. at any cell what health do we need ? - since we can go only down and right therefore min health required will be minimun health required if we go right or down, ( futher explained in arriving at recurrance relation heading )\\n\\nfor brief answers/explanation for above point 1 and 2 , assume a 1D matrix this is what is ment by 1st and 2nd point.\\n```\\n[[-10]]                     : ans  = 1 + (-(-10)) = 11 (explanation to first point mentioned)\\n[[10]]                      : ans  = 1 as we still need 1 health at first place to get there (explanation to second point mentioned)\\n[[-2,-3,3,-5,-10]]          : ans = 1 + (-(-17)) = 18 same as 1st case\\n[[2,3,3,5,10]]              : ans = 1 same as 2nd test case, explanation to second point mentioned to asking question\\n```\\n\\n**2nd sub step : Ariving at recurence relation**\\nrecurrence relation is pretty straight forward at any cell ,if we are at any particular cell we must ask should we go right or down ? if we know the answer for min health req if we go right vs we go down, then we can easily choose\\n![image](https://assets.leetcode.com/users/images/cd28d2d9-256b-4d72-a875-ea82880bd8e3_1595226474.6431954.png)\\n\\n**step 3: code recursive solution - (TLE)**\\n```\\nint getVal(vector<vector<int>> &mat, int i=0, int j=0)\\n    {\\n        int n = mat.size();\\n        int m = mat[0].size();\\n        // Base case : we have crossed the matrix, ie. out of bound\\n        /// if current row crosses then my row is below the princess or \\n        /// if current column crosses then my column is ahead the column of princess\\n        /// and beacause we can go only down and right so we wont be able reach princess\\n        if(i == n || j == m)    return 1e9; \\n        \\n\\t\\t// Base Case : we have reached our destination ie. last cell\\n        /// we reached princess , cheers return this cost;\\n        if(i == n-1 and j == m-1)   \\n            return (mat[i][j] <= 0) ? -mat[i][j] + 1 : 1;\\n        \\n        /// now we must try all possible paths , we ask our right and and down cell\\n        int IfWeGoRight = getVal(mat , i , j+1);\\n        int IfWeGoDown = getVal(mat , i+1 , j);\\n        \\n        /// min of either values and then cost of this cell\\n        int minHealthRequired =  min(IfWeGoRight , IfWeGoDown) -mat[i][j];\\n        \\n        /// point 2 as explained \\n        return ( minHealthRequired <= 0 ) ? 1 : minHealthRequired;      \\n    }\\n    \\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        return getVal(dungeon);     \\n    }\\n```\\nNow you know how to solve this recurssively, lets now observe time complexity ...  ... yep its exponential ! . but luckily we are doing same task over and over again. ( for example we are asking 6 times the last cell its cost in 3X3 matrix), we can overcome this task by storing the values of cost at each cell ( aka memoization ).\\n\\n**step4 : memoization-top-down**\\nlets maintain a DP matrix which will store the calculated values for its cell. next time if we arrive at this cell we will return this calculated value to save recurrsive calls.\\n```\\nint getVal(vector<vector<int>> &mat, vector<vector<int>> &dp , int i=0, int j=0)\\n    {\\n        int n = mat.size();\\n        int m = mat[0].size();    \\n        \\n        if(i == n || j == m)    return 1e9; \\n        \\n        if(i == n-1 and j == m-1)\\n            return (mat[i][j] <= 0) ? -mat[i][j] + 1 : 1;\\n        \\n        /// if we know the answer for this cell then no need to recalculate those, simply return those values \\n        if( dp[i][j] != 1e9)\\n            return dp[i][j];\\n        \\n        int IfWeGoRight = getVal(mat , dp , i , j+1);\\n        int IfWeGoDown = getVal(mat , dp , i+1 , j);\\n        \\n        int minHealthRequired =  min(IfWeGoRight , IfWeGoDown) -mat[i][j];\\n        \\n        /// before returning the values, we must store the answers for this cell which we hacve calculated\\n        /// in next recurssive call this value will be used to save some computation, aka repetative work which we are doing.\\n        dp[i][j] = ( minHealthRequired <= 0 ) ? 1 : minHealthRequired;      \\n        return dp[i][j];\\n    }\\n    \\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        \\n        int n = dungeon.size();\\n        int m = dungeon[0].size();\\n        \\n        vector<vector<int>> dp(n , vector<int>(m , 1e9));\\n        \\n        return getVal(dungeon, dp);     \\n    }\\n```\\nso now you know the recursive solution , you have also tried memoization, so try coming up with bottomUp solution yourself, HINT : as you might have observed final destination is the last cell, so why dont we start with the bottom cell itself. then work all the way up to first cell.\\n\\n**step 5 :  You know the base casses , you know the sub problems so try coming up with bottom up solution yourself ( hint in above paragraph )**\\n```\\nint calculateMinimumHP(vector<vector<int> > &dungeon) {\\n\\n        int n = dungeon.size();\\n        int m = dungeon[0].size();\\n\\n        vector<vector<int> > dp(n + 1, vector<int>(m + 1, 1e9));\\n        dp[n][m - 1] = 1;\\n        dp[n - 1][m] = 1;\\n        \\n        for (int i = n - 1; i >= 0; i--) \\n        {\\n            for (int j = m - 1; j >= 0; j--) \\n            {\\n                int need = min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j];                \\n                // store this value\\n                dp[i][j] = need <= 0 ? 1 : need;\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n```\\n\\n**it takes a lots of time and effort to write post like these, if you learned something then, then consider upvoting, so that this post reach beginners.\\nHappy coding**\\n\\nprevious tutorial on DP\\nhttps://leetcode.com/problems/minimum-cost-for-tickets/discuss/630868/explanation-from-someone-who-took-2-hours-to-solve/\\nhttps://leetcode.com/problems/minimum-ascii-delete-sum-for-two-strings/discuss/642422/Lets-solve-it-together-%3A-step-by-step\\n\\n",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\n[[-10]]                     : ans  = 1 + (-(-10)) = 11 (explanation to first point mentioned)\\n[[10]]                      : ans  = 1 as we still need 1 health at first place to get there (explanation to second point mentioned)\\n[[-2,-3,3,-5,-10]]          : ans = 1 + (-(-17)) = 18 same as 1st case\\n[[2,3,3,5,10]]              : ans = 1 same as 2nd test case, explanation to second point mentioned to asking question\\n```\n```\\nint getVal(vector<vector<int>> &mat, int i=0, int j=0)\\n    {\\n        int n = mat.size();\\n        int m = mat[0].size();\\n        // Base case : we have crossed the matrix, ie. out of bound\\n        /// if current row crosses then my row is below the princess or \\n        /// if current column crosses then my column is ahead the column of princess\\n        /// and beacause we can go only down and right so we wont be able reach princess\\n        if(i == n || j == m)    return 1e9; \\n        \\n\\t\\t// Base Case : we have reached our destination ie. last cell\\n        /// we reached princess , cheers return this cost;\\n        if(i == n-1 and j == m-1)   \\n            return (mat[i][j] <= 0) ? -mat[i][j] + 1 : 1;\\n        \\n        /// now we must try all possible paths , we ask our right and and down cell\\n        int IfWeGoRight = getVal(mat , i , j+1);\\n        int IfWeGoDown = getVal(mat , i+1 , j);\\n        \\n        /// min of either values and then cost of this cell\\n        int minHealthRequired =  min(IfWeGoRight , IfWeGoDown) -mat[i][j];\\n        \\n        /// point 2 as explained \\n        return ( minHealthRequired <= 0 ) ? 1 : minHealthRequired;      \\n    }\\n    \\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        return getVal(dungeon);     \\n    }\\n```\n```\\nint getVal(vector<vector<int>> &mat, vector<vector<int>> &dp , int i=0, int j=0)\\n    {\\n        int n = mat.size();\\n        int m = mat[0].size();    \\n        \\n        if(i == n || j == m)    return 1e9; \\n        \\n        if(i == n-1 and j == m-1)\\n            return (mat[i][j] <= 0) ? -mat[i][j] + 1 : 1;\\n        \\n        /// if we know the answer for this cell then no need to recalculate those, simply return those values \\n        if( dp[i][j] != 1e9)\\n            return dp[i][j];\\n        \\n        int IfWeGoRight = getVal(mat , dp , i , j+1);\\n        int IfWeGoDown = getVal(mat , dp , i+1 , j);\\n        \\n        int minHealthRequired =  min(IfWeGoRight , IfWeGoDown) -mat[i][j];\\n        \\n        /// before returning the values, we must store the answers for this cell which we hacve calculated\\n        /// in next recurssive call this value will be used to save some computation, aka repetative work which we are doing.\\n        dp[i][j] = ( minHealthRequired <= 0 ) ? 1 : minHealthRequired;      \\n        return dp[i][j];\\n    }\\n    \\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        \\n        int n = dungeon.size();\\n        int m = dungeon[0].size();\\n        \\n        vector<vector<int>> dp(n , vector<int>(m , 1e9));\\n        \\n        return getVal(dungeon, dp);     \\n    }\\n```\n```\\nint calculateMinimumHP(vector<vector<int> > &dungeon) {\\n\\n        int n = dungeon.size();\\n        int m = dungeon[0].size();\\n\\n        vector<vector<int> > dp(n + 1, vector<int>(m + 1, 1e9));\\n        dp[n][m - 1] = 1;\\n        dp[n - 1][m] = 1;\\n        \\n        for (int i = n - 1; i >= 0; i--) \\n        {\\n            for (int j = m - 1; j >= 0; j--) \\n            {\\n                int need = min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j];                \\n                // store this value\\n                dp[i][j] = need <= 0 ? 1 : need;\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 52774,
                "title": "c-dp-solution",
                "content": "Use hp[i][j] to store the min hp needed at position (i, j), then do the calculation from right-bottom to left-up.\\n\\nNote: adding dummy row and column would make the code cleaner.\\n\\n    class Solution {\\n    public:\\n        int calculateMinimumHP(vector<vector<int> > &dungeon) {\\n            int M = dungeon.size();\\n            int N = dungeon[0].size();\\n            // hp[i][j] represents the min hp needed at position (i, j)\\n            // Add dummy row and column at bottom and right side\\n            vector<vector<int> > hp(M + 1, vector<int>(N + 1, INT_MAX));\\n            hp[M][N - 1] = 1;\\n            hp[M - 1][N] = 1;\\n            for (int i = M - 1; i >= 0; i--) {\\n                for (int j = N - 1; j >= 0; j--) {\\n                    int need = min(hp[i + 1][j], hp[i][j + 1]) - dungeon[i][j];\\n                    hp[i][j] = need <= 0 ? 1 : need;\\n                }\\n            }\\n            return hp[0][0];\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int calculateMinimumHP(vector<vector<int> > &dungeon) {\\n            int M = dungeon.size();\\n            int N = dungeon[0].size();\\n            // hp[i][j] represents the min hp needed at position (i, j)\\n            // Add dummy row and column at bottom and right side\\n            vector<vector<int> > hp(M + 1, vector<int>(N + 1, INT_MAX));\\n            hp[M][N - 1] = 1;\\n            hp[M - 1][N] = 1;\\n            for (int i = M - 1; i >= 0; i--) {\\n                for (int j = N - 1; j >= 0; j--) {\\n                    int need = min(hp[i + 1][j], hp[i][j + 1]) - dungeon[i][j];\\n                    hp[i][j] = need <= 0 ? 1 : need;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 698271,
                "title": "python-short-dp-7-lines-o-mn-top-down-explained",
                "content": "Probably when you see this problem and you have some experience in this type of problems you can guess, that this is **dynamic programming** problem. However even if you understand this, it is not easy to solve it. Let us use top-down dp, that is `Let dp[i][j]` be the minimum **hp** we need to reach the **princess** if we start from point `(i,j)`. Let us consider the following example:\\n\\n| -2  | -3  | +3 |\\n|---------|---------|--------|\\n| **-5**  | **-10** | **+1** |\\n| **+10** | **+30** | **-5** |\\n\\nLet us add bottom dummy row and right dummy column to handle border cases more easy. We fill it with infinities, except two ones - neibours of our princess. I will explain it a bit later.\\n\\nHow we can evaluate `dp[i][j]`? We need to look at two cells: `dp[i+1][j]` and `dp[i][j+1]` and evaluate two possible candidates: `dp[i+1][j]-dungeon[i][j]` and `dp[i][j+1]-dungeon[i][j]`.\\n1. If at least one of these two numbers is negative, it means that we can survive just with `1` hp: (look at number `+30` in our table for example)\\n2. If both this numbers are positive, we need to take the mimumum of them, see for example number `-10` in our table: to survive we need either `5- -10 = 15` if we go right and `1- -10 = 11` if we go down, of course we choose `11`.\\n3. This conditions can be written in one a bit ugly line: `dp[i][j] = max(min(dp[i+1][j],dp[i][j+1])-dungeon[i][j],1)`.\\n4. Finally, why I put `1` to two neibors of princess? To make this formula valid for princess cell: if we have negative number like `-5` in this cell, we need `6` hp to survive, if we have non-negative number in this cell, we need `1` hp to survive.\\n\\n| 7  | 5   | 2 | inf |\\n|---------|---------|-------|---------|\\n| **6**   | **11**  | **5** | **inf** |\\n| **1**   | **1**   | **6** | **1**   |\\n| **inf** | **inf** | **1** | **#**   |\\n\\n**Complexity**: both time and space is `O(mn)`. Space complexity can be reduced to `O(min(m,n))` as usual, because we look only to neibour cells. However code becomes a bit more difficult to follow.\\n\\n```\\nclass Solution:\\n    def calculateMinimumHP(self, dungeon):\\n        m, n = len(dungeon), len(dungeon[0])\\n        dp = [[float(\"inf\")]*(n+1) for _ in range(m+1)]\\n        dp[m-1][n], dp[m][n-1] = 1, 1\\n            \\n        for i in range(m-1,-1,-1):\\n            for j in range(n-1,-1,-1):\\n                dp[i][j] = max(min(dp[i+1][j],dp[i][j+1])-dungeon[i][j],1)\\n        \\n        return dp[0][0]\\n```\\n\\n**Further discussion** It is possible to do it with down-top dp as well, howerer in this case you need to use **binary search**, because you do not know in advance if you survive starting say `1000` hp or not. Complexity will be `O(nm log(MAX_INT))` in this case.\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def calculateMinimumHP(self, dungeon):\\n        m, n = len(dungeon), len(dungeon[0])\\n        dp = [[float(\"inf\")]*(n+1) for _ in range(m+1)]\\n        dp[m-1][n], dp[m][n-1] = 1, 1\\n            \\n        for i in range(m-1,-1,-1):\\n            for j in range(n-1,-1,-1):\\n                dp[i][j] = max(min(dp[i+1][j],dp[i][j+1])-dungeon[i][j],1)\\n        \\n        return dp[0][0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 52790,
                "title": "my-ac-java-version-suggestions-are-welcome",
                "content": "    public int calculateMinimumHP(int[][] dungeon) {\\n        if (dungeon == null || dungeon.length == 0 || dungeon[0].length == 0) return 0;\\n        \\n        int m = dungeon.length;\\n        int n = dungeon[0].length;\\n        \\n        int[][] health = new int[m][n];\\n\\n        health[m - 1][n - 1] = Math.max(1 - dungeon[m - 1][n - 1], 1);\\n\\n        for (int i = m - 2; i >= 0; i--) {            \\n            health[i][n - 1] = Math.max(health[i + 1][n - 1] - dungeon[i][n - 1], 1);\\n        }\\n\\n        for (int j = n - 2; j >= 0; j--) {\\n            health[m - 1][j] = Math.max(health[m - 1][j + 1] - dungeon[m - 1][j], 1);\\n        }\\n\\n        for (int i = m - 2; i >= 0; i--) {\\n            for (int j = n - 2; j >= 0; j--) {\\n                int down = Math.max(health[i + 1][j] - dungeon[i][j], 1);\\n                int right = Math.max(health[i][j + 1] - dungeon[i][j], 1);\\n                health[i][j] = Math.min(right, down);\\n            }\\n        }\\n\\n        return health[0][0];\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public int calculateMinimumHP(int[][] dungeon) {\\n        if (dungeon == null || dungeon.length == 0 || dungeon[0].length == 0) return 0;\\n        \\n        int m = dungeon.length;\\n        int n = dungeon[0].length;\\n        \\n        int[][] health = new int[m][n];\\n\\n        health[m - 1][n - 1] = Math.max(1 - dungeon[m - 1][n - 1], 1);\\n\\n        for (int i = m - 2; i >= 0; i--) {            \\n            health[i][n - 1] = Math.max(health[i + 1][n - 1] - dungeon[i][n - 1], 1);\\n        }\\n\\n        for (int j = n - 2; j >= 0; j--) {\\n            health[m - 1][j] = Math.max(health[m - 1][j + 1] - dungeon[m - 1][j], 1);\\n        }\\n\\n        for (int i = m - 2; i >= 0; i--) {\\n            for (int j = n - 2; j >= 0; j--) {\\n                int down = Math.max(health[i + 1][j] - dungeon[i][j], 1);\\n                int right = Math.max(health[i][j + 1] - dungeon[i][j], 1);\\n                health[i][j] = Math.min(right, down);\\n            }\\n        }\\n\\n        return health[0][0];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 52805,
                "title": "best-solution-i-have-found-with-explanations",
                "content": "\\n\\nhttp://leetcodesolution.blogspot.com/2015/01/leetcode-dungeon-game.html\\n\\nseems pretty simple... and easy to understand explanations...\\n\\n\\nIt is easy to know that at grid P, since \" at any point his health point drops to 0 or below, he dies immediately\", the remaining health value should be at least 1,  that is, initialHealth + dungeon >= 1, we have initialHealth = max(1, 1 - dungeon[i][j]).  (Notice, at any grid, the initial health should be at least 1 (for example,  test case [1,0,0] require initial health 1 even though it has positive remaining health at grid[0][1] and grid[0][2])\\nSimilarly, to satisfy the initial health of dungeon[i][j], the initial health of dungeon[i-1][j] (or dungeon[i][j-1]) should be at least initialHealth[i-1][j] + dungeon[i-1][j] = initialHealth[i][j], that is, initialHealth[i][j] = initialHealth[i][j] - dungeon[i-1][j]. \\nIn addition, if grid[i][j] can go both grid[i+1][j] and grid[i][j+1] to P,  we should choose a path with less initial health between grid[i+1][j] and grid[i][j+1] since it require less initial health of grid[i][j].\\nWe can simply code the solution by having the dynamic programming equations. \\n\\n\\n         int calculateMinimumHP(vector &dungeon) {\\n        int m = dungeon.size();\\n        int n = dungeon[0].size();\\n        vector minInitHealth(m, vector<int>(n,0));\\n        for(int i=m-1; i>=0; i--)\\n        {\\n            for (int j=n-1; j>=0; j--)\\n            {\\n                if (i == m-1 && j == n-1)\\n                {\\n                    minInitHealth[i][j] = max(1, 1 - dungeon[i][j]);\\n                }  \\n                else if (i == m-1)\\n                {\\n                    minInitHealth[i][j] = max(1, minInitHealth[i][j+1] - dungeon[i][j]);\\n                }  \\n                else if (j == n-1)\\n                {\\n                    minInitHealth[i][j] = max(1, minInitHealth[i+1][j] - dungeon[i][j]);\\n                }  \\n                else\\n                {\\n                    minInitHealth[i][j] = max(1, min(minInitHealth[i+1][j],minInitHealth[i][j+1]) - dungeon[i][j]);\\n                }  \\n            }\\n        }\\n        \\n        return  minInitHealth[0][0];\\n    }",
                "solutionTags": [],
                "code": "\\n\\nhttp://leetcodesolution.blogspot.com/2015/01/leetcode-dungeon-game.html\\n\\nseems pretty simple... and easy to understand explanations...\\n\\n\\nIt is easy to know that at grid P, since \" at any point his health point drops to 0 or below, he dies immediately\", the remaining health value should be at least 1,  that is, initialHealth + dungeon >= 1, we have initialHealth = max(1, 1 - dungeon[i][j]).  (Notice, at any grid, the initial health should be at least 1 (for example,  test case [1,0,0] require initial health 1 even though it has positive remaining health at grid[0][1] and grid[0][2])\\nSimilarly, to satisfy the initial health of dungeon[i][j], the initial health of dungeon[i-1][j] (or dungeon[i][j-1]) should be at least initialHealth[i-1][j] + dungeon[i-1][j] = initialHealth[i][j], that is, initialHealth[i][j] = initialHealth[i][j] - dungeon[i-1][j]. \\nIn addition, if grid[i][j] can go both grid[i+1][j] and grid[i][j+1] to P,  we should choose a path with less initial health between grid[i+1][j] and grid[i][j+1] since it require less initial health of grid[i][j].\\nWe can simply code the solution by having the dynamic programming equations. \\n\\n\\n         int calculateMinimumHP(vector &dungeon) {\\n        int m = dungeon.size();\\n        int n = dungeon[0].size();\\n        vector minInitHealth(m, vector<int>(n,0));\\n        for(int i=m-1; i>=0; i--)\\n        {\\n            for (int j=n-1; j>=0; j--)\\n            {\\n                if (i == m-1 && j == n-1)\\n                {\\n                    minInitHealth[i][j] = max(1, 1 - dungeon[i][j]);\\n                }  \\n                else if (i == m-1)\\n                {\\n                    minInitHealth[i][j] = max(1, minInitHealth[i][j+1] - dungeon[i][j]);\\n                }  \\n                else if (j == n-1)\\n                {\\n                    minInitHealth[i][j] = max(1, minInitHealth[i+1][j] - dungeon[i][j]);\\n                }  \\n                else\\n                {\\n                    minInitHealth[i][j] = max(1, min(minInitHealth[i+1][j],minInitHealth[i][j+1]) - dungeon[i][j]);\\n                }  \\n            }\\n        }\\n        \\n        return  minInitHealth[0][0];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 52826,
                "title": "a-very-clean-and-intuitive-solution-with-explanation",
                "content": "**Dynamic Programming**\\nFirst, we need to define the subproblem somewhat a little clever. If we define: \\n*dp[i][j] = minimum cost from (0, 0) to (i, j)*\\nIt won't help solving the problem, because the result of dp[i + 1][j + 1] does not depends only on previous solve subproblems, but also future unsolved subproblems. So, how about let's define the subproblem from the other end of the puzzle?\\n***dp[i][j] = minimum health level required to reach the princess when entering (i, j)***\\n\\nSo, what is dp[i + 1][j + 1] then? It depends on the minimum between dp[i][j + 1] and dp[i + 1][j], because we want to choose the cheapest way to go. Of course we also need to add or deduct the value from dungeon matrix. But be careful, if we find that the minimum required health level is less that 0, we need to set it to 0, because we are not allowed to overdraft health. With that said:\\n***dp[i + 1][j + 1] = max(min(dp[i][j + 1], dp[i + 1][j]) - dungeon[i + 1][j + 1], 0);***\\n\\n**Implementation**\\nTo get the code cleaner, I created the dp matrix 1 row and 1 column bigger that the original input. But we need to be careful when initializing the extra row and column, everything is initialized to Infinite except cell (m, n - 1) and (m - 1, n), which should be initialized to 0.\\nI attached a picture to illustrate the idea (based on the test case given in the problem statement). Then code becomes very readable.\\n\\n![0_1470070141386_dungeon.png](/uploads/files/1470070031420-dungeon.png) \\n\\n\\n```\\npublic class Solution {\\n    public int calculateMinimumHP(int[][] dungeon) {\\n\\t\\tint m = dungeon.length;\\n\\t\\tint n = m == 0 ? 0 : dungeon[0].length;\\n\\t\\tint[][] minRequred = new int[m + 1][n + 1];\\n\\n\\t\\tfor (int i = 0; i < m + 1; i++) {\\n\\t\\t\\tminRequred[i][n] = Integer.MAX_VALUE;\\n\\t\\t}\\n\\t\\tfor (int j = 0; j < n + 1; j++) {\\n\\t\\t\\tminRequred[m][j] = Integer.MAX_VALUE;\\n\\t\\t}\\n\\t\\tminRequred[m][n - 1] = 0;\\n\\t\\tminRequred[m - 1][n] = 0;\\n\\t\\t\\n                for (int i = m - 1; i >= 0; i--) {\\n\\t\\t\\tfor (int j = n - 1; j >= 0; j--) {\\n\\t\\t\\t\\tminRequred[i][j] = Math.max(\\n\\t\\t\\t\\t\\t\\tMath.min(minRequred[i + 1][j], minRequred[i][j + 1]) - dungeon[i][j], 0);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn minRequred[0][0] + 1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int calculateMinimumHP(int[][] dungeon) {\\n\\t\\tint m = dungeon.length;\\n\\t\\tint n = m == 0 ? 0 : dungeon[0].length;\\n\\t\\tint[][] minRequred = new int[m + 1][n + 1];\\n\\n\\t\\tfor (int i = 0; i < m + 1; i++) {\\n\\t\\t\\tminRequred[i][n] = Integer.MAX_VALUE;\\n\\t\\t}\\n\\t\\tfor (int j = 0; j < n + 1; j++) {\\n\\t\\t\\tminRequred[m][j] = Integer.MAX_VALUE;\\n\\t\\t}\\n\\t\\tminRequred[m][n - 1] = 0;\\n\\t\\tminRequred[m - 1][n] = 0;\\n\\t\\t\\n                for (int i = m - 1; i >= 0; i--) {\\n\\t\\t\\tfor (int j = n - 1; j >= 0; j--) {\\n\\t\\t\\t\\tminRequred[i][j] = Math.max(\\n\\t\\t\\t\\t\\t\\tMath.min(minRequred[i + 1][j], minRequred[i][j + 1]) - dungeon[i][j], 0);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn minRequred[0][0] + 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 698376,
                "title": "c-beginner-friendly-dp-explanation-and-idea",
                "content": "We want to reach the last cell of the dungeon which means that our health should be greater than 1 when we reach there. So the best way to calculate the minimum health required is by checking for the last cell and going our way upwards. The answer will be the value we get on arriving at the first cell;\\n```\\n-2 \\t -3\\t   3\\n-5\\t -10   1\\n10\\t  30  -5  <-  when we arrive here our health will be reduced by 5.\\n\\t\\t\\t\\tSo we need minimum 6 health to survive when we reach here. val = (1- (-5) = 6)\\n\\nIf this value was positive we dont need to worry and the minimum energy we need is 1. \\nSuppose the value was +5 then 1-5 = -4.  -4<1 => so ans is 1. i.e max(1,val).\\n```\\nNow for simplicity and to avoid the checks on the border we can create our dp with 1 additional bottom row and 1 additional rightmost column. (Similar to the dp we use in LCS and other problem).\\n\\nAlso what  values should we fill our dp with?\\nWell the answer is quite obvious the maximum possible value. For c++ we can use INT_MAX;\\nOur dp looks like this:\\n```\\n-2  -3   3  m      m -> denotes max \\n-5  10   1  m\\n10  30  -5  1   -> note: we have two value as 1 for the last element (I will explain this as we proceed)\\n m   m   1 m\\n \\n suppose the dimensions of dungeon matirx was \"r x c\", for our dp will be \" r+1 x c+1\".\\n We will start our iteration \\n from the value -5 that is the cell our princess is located.\\n We first have to see which value is minimum from that cell (the one on the right or bottom).\\n i.e. which cell requres less health to travel to\\n for this cell is (one which holds the princess):\\n val = min of dp[i+1][j] and dp[i][j+1] (min of bottom and right).\\n so val = min(1,1) = 1;\\n Also we have to reduce the health required to stay in the current cell.\\n val = val - dungeon[i][j] = 1 - (-5) = 6;\\n Now as i explained earlier:\\n dp[i][j] = max(1,val)   => if val is negetive that means we dont have to spend health on this cell so it should be kept minimum i.e. 1.\\n \\n So we had to keep both values 1 as instead of max as for calculating the health for princess\\' cell we only need 1 health minimum. \\n \\n Now let\\'s see for 2nd row 3rd column (one above the princess)\\n val = min(m,6) - 1;   (6 because the dp holds value 6 for princess\\' cell which was calculated earlier)\\n val = 5.\\n dp[1][2] = 5; So when we are at this cell we need health atleast 5. \\n As we will gain 1 health and then move on to the princess\\'s cell giving up  5  health and thus in this way we can calculate all the values. Code contains further explanation.\\n```\\n\\nC++ code: \\n\\n```\\nclass Solution {\\npublic:\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        int r = dungeon.size();   // no of rows\\n        if(r == 0) return 0; // if empty then return 0\\n        int c = dungeon[0].size();  // no of columns\\n\\t\\t// DP with r+1 x c+1 dimension and all values initialized to INT_MAX\\n        vector<vector<int>>dp(r+1,vector<int>(c+1,INT_MAX));\\n\\t\\t// Initializing the cell to the bottom and right of princess\\' cell with value 1.\\n        dp[r-1][c] = 1;\\n        dp[r][c-1] = 1;\\n\\t\\tIterating over dp excluding the additional row and column we added.\\n        for(int i=r-1;i>=0;i--){\\n            for(int j=c-1;j>=0;j--){\\n                int val = min(dp[i+1][j],dp[i][j+1]) - dungeon[i][j];  // value is minimum health to land on next - health need to stay\\n                dp[i][j] = max(1,val); // minimum value required is 1. maximum is the +ve value we calculated.\\n            }\\n        }\\n        \\n        return dp[0][0];  // The first element contains the minimum health needed to rescue the princess.\\n    }\\n};\\n```\\n\\nHope you enjoyed the explanation. If any point was not clear feel free to comment below.\\nThank you!",
                "solutionTags": [],
                "code": "```\\n-2 \\t -3\\t   3\\n-5\\t -10   1\\n10\\t  30  -5  <-  when we arrive here our health will be reduced by 5.\\n\\t\\t\\t\\tSo we need minimum 6 health to survive when we reach here. val = (1- (-5) = 6)\\n\\nIf this value was positive we dont need to worry and the minimum energy we need is 1. \\nSuppose the value was +5 then 1-5 = -4.  -4<1 => so ans is 1. i.e max(1,val).\\n```\n```\\n-2  -3   3  m      m -> denotes max \\n-5  10   1  m\\n10  30  -5  1   -> note: we have two value as 1 for the last element (I will explain this as we proceed)\\n m   m   1 m\\n \\n suppose the dimensions of dungeon matirx was \"r x c\", for our dp will be \" r+1 x c+1\".\\n We will start our iteration \\n from the value -5 that is the cell our princess is located.\\n We first have to see which value is minimum from that cell (the one on the right or bottom).\\n i.e. which cell requres less health to travel to\\n for this cell is (one which holds the princess):\\n val = min of dp[i+1][j] and dp[i][j+1] (min of bottom and right).\\n so val = min(1,1) = 1;\\n Also we have to reduce the health required to stay in the current cell.\\n val = val - dungeon[i][j] = 1 - (-5) = 6;\\n Now as i explained earlier:\\n dp[i][j] = max(1,val)   => if val is negetive that means we dont have to spend health on this cell so it should be kept minimum i.e. 1.\\n \\n So we had to keep both values 1 as instead of max as for calculating the health for princess\\' cell we only need 1 health minimum. \\n \\n Now let\\'s see for 2nd row 3rd column (one above the princess)\\n val = min(m,6) - 1;   (6 because the dp holds value 6 for princess\\' cell which was calculated earlier)\\n val = 5.\\n dp[1][2] = 5; So when we are at this cell we need health atleast 5. \\n As we will gain 1 health and then move on to the princess\\'s cell giving up  5  health and thus in this way we can calculate all the values. Code contains further explanation.\\n```\n```\\nclass Solution {\\npublic:\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        int r = dungeon.size();   // no of rows\\n        if(r == 0) return 0; // if empty then return 0\\n        int c = dungeon[0].size();  // no of columns\\n\\t\\t// DP with r+1 x c+1 dimension and all values initialized to INT_MAX\\n        vector<vector<int>>dp(r+1,vector<int>(c+1,INT_MAX));\\n\\t\\t// Initializing the cell to the bottom and right of princess\\' cell with value 1.\\n        dp[r-1][c] = 1;\\n        dp[r][c-1] = 1;\\n\\t\\tIterating over dp excluding the additional row and column we added.\\n        for(int i=r-1;i>=0;i--){\\n            for(int j=c-1;j>=0;j--){\\n                int val = min(dp[i+1][j],dp[i][j+1]) - dungeon[i][j];  // value is minimum health to land on next - health need to stay\\n                dp[i][j] = max(1,val); // minimum value required is 1. maximum is the +ve value we calculated.\\n            }\\n        }\\n        \\n        return dp[0][0];  // The first element contains the minimum health needed to rescue the princess.\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1500016,
                "title": "why-you-can-t-go-from-top-left-to-bottom-right-explained",
                "content": "Many solutions have eloquently explained how you need to solve this (going from bottom right to top left). However, I could not find a clear explanation for why you can\\'t go the other way around, as one would typically do in dp solutions. So I did a little digging and here\\'s what I found.\\n\\nFirst, how would a top-to-bottom solution work? Consider you\\'re at dp[i][j]. To calculate it, the states you would consider are dp[i - 1][j] and dp[i][j - 1] (i.e. one cell up, or one cell to your left) and add the current value nums[i][j] to max(dp[i - 1][j], dp[i][j - 1]) to get dp[i][j]. Howver, this is incorrect since dp[i][j] only tells you the best health at the *current* point. \\n\\nConsider an example, nums (also sample 1 of problem) :\\n[-2,\\t-3,\\t3]\\n[-5,\\t-10,\\t1]\\n[10,\\t30,\\t-5]\\n\\nThe optimal path is shown below (which gives the correct answer, 7) :\\n[**-2**,\\t**-3**,\\t**3**]\\n[-5,\\t-10,\\t**1**]\\n[10,\\t30,\\t**-5**]\\n\\nHowever, if you build a top->down dp, you\\'d get the following path:\\n\\n[**-2**,\\t-3,\\t3]\\n[**-5**,\\t-10,\\t1]\\n[**10**,\\t**30**,\\t**-5**]\\n\\nHere, the final health will be -2 + -5 + 10 + 30 + -5 = 28. And since you\\'re already adding 28 along this path, you might\\'ve as well started with the smallest positive value, namely 1 (which is incorrect)\\n\\nHowever, the problem statement states that at no point can the health be negative or 0 (i.e. it always has to be positive). So even if dp[i][j] is positive, if a previous element in its path was negative, then the current dp value is incorrect. Hence, we need to track the lowest health seen along the most optimal path.\\n\\nIn other words, we need to track the minimum value seen along each *path* leading up to dp[i][j]. Let\\'s do this - define another 2D array called minimum_in_path[][]. minimum_in_path[i][j] tracks the lowest health value that was seen reaching in the path leading up to dp[i][j]. So now instead of considering dp[i - 1][j] and dp[i][j - 1] to calculate dp[i][j], we would use minimum_in_path[i - 1][j], minimum_in_path[i][j - 1] and dp[i][j] to calculate minimum_in_path[i][j]. In other words, we would do the following:\\n```\\nif (minimum_in_path[i - 1][j] >= minimum_in_path[i][j - 1]) {\\n\\tdp[i][j] = dp[i - 1][j] + nums[i][j];\\n\\tminimum_in_path[i][j] = min(minimum_in_path[i - 1][j], dp[i][j]);\\n}\\nelse {\\n\\t// Same as above but use indexes [i][j - 1] instead of [i - 1][j]\\n\\tdp[i][j] = dp[i][j - 1] + nums[i][j];\\n\\tminimum_in_path[i][j] = min(minimum_in_path[i][j - 1], dp[i][j]);\\n}\\n```\\n\\nHowever, even using minimum_in_path[i][j] does not work. This is because you could make a local decision on the path seen so far based on the current minimum values and realize that afterwards the minimum goes down a lot more. So had you known earlier on that the minimum would drop a lot lower, you would\\'ve selected a different path to maximize dp. This is best illustrated with an example.\\n\\nConsider this 3x3 array, nums:\\n[1,  -3,  3]\\n[0,  -2,  0]\\n[-3, -3, -3]\\n\\nHere the right solution is shown in bold (this results in an answer of 3) :\\n[**1**,  **-3**,  **3**]\\n[  0,   -2,  **0**]\\n[-3,   -3, **-3**]\\n\\nHowever, if you choose the path with the maximized minimum value, so as to speak, you\\'d get this path (with an incorrect answer of 5) :\\n[**1**,  -3,  3]\\n[**0**,  **-2**,  **0**]\\n[-3, -3, **-3**]\\n\\nTo understand where this is flawed, consider row 2 and column 3 (1-indexed). minimum_in_path[1][1] is -1, while minimum_in_path[0][2] is -2. dp[1][1] is -1 and dp[0][2] is 1. However, since we are using minimum_in_path to make a decision, dp[1][2] consequently becomes -1 (i.e. dp[1][1] + nums[1][2]) instead of 1 (i.e. dp[0][2] + nums[1][2]). Note that as soon as you go to dp[2][2] (the bottom right node), the minimum along the path goes to -4 (since dp[2][2] = dp[0][2] + nums[2][2] = -1 + (-3) = -4). And since the new minimum is now lower than anything we\\'ve seen, we had unfortunately ignored some better paths that we saw earlier, just because their minimum was low *at that point*.",
                "solutionTags": [],
                "code": "```\\nif (minimum_in_path[i - 1][j] >= minimum_in_path[i][j - 1]) {\\n\\tdp[i][j] = dp[i - 1][j] + nums[i][j];\\n\\tminimum_in_path[i][j] = min(minimum_in_path[i - 1][j], dp[i][j]);\\n}\\nelse {\\n\\t// Same as above but use indexes [i][j - 1] instead of [i - 1][j]\\n\\tdp[i][j] = dp[i][j - 1] + nums[i][j];\\n\\tminimum_in_path[i][j] = min(minimum_in_path[i][j - 1], dp[i][j]);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 464716,
                "title": "diego-s-understandable-explanations-c",
                "content": "Hi, I\\'m trying to make easily understandable explanations for everyone. Hopefully I did a good job here.\\n*Please upvote if this post helped you, so that others can find it.*\\n\\n**Why this problem is tricky**\\nIf you\\'ve done a lot of dynamic programming problems, looking at this problem probably immediately set off a few bulbs in your head for how to go about solving it. This is a really good thing, because that means that your instincts are working properly! However, it\\'s possible that they led you nowhere useful, because this problem pushes a little on the formulaic form of dynamic programming problems. Let\\'s see why.\\n\\n**The bigger picture insight**\\nThe problem has start and end locations, and you have to find some start property to meet an end criterion. By far the largest insight of this problem is recognizing that it is better to tackle the problem by starting from what you know, which is the end criterion you must meet, and working towards what you don\\'t know, the start property.\\n\\nThis is important because, usually, simpler dynamic problems are best solved by starting from the start and ending at the end, but that is not the case here. The larger idea is that you should start from what you know and work towards what you don\\'t know, and that it just so happens that in simpler dynamic programming problems those tend to coincide with the start and end, respectively.\\n\\nWith that out of the way, let\\'s talk more about the problem.\\n\\n**The insight**\\nThe problem insight comes from recognizing that it is useful to remember the minimum health you need to exist at a particular location.\\n\\nWhen you\\'re in some room in the dungeon, you need enough health to do two things...\\n* survive the health cost of the room, and\\n* have enough health left over to move to a different room, either right or down.\\n\\nIf we add these two together, the sum represents the amount of health we need to *exist* at a particular location. Luckily, we already know one of these: the amount of health we need to survive the health cost of the room. What about the second one? Let\\'s think about it some more...\\n\\nThe amount of health we need to move to a different room is simply the amount of health we need to *exist* in another room, which is the exact kind of thing we\\'re calculating! This means that we can work backwards from the end, where the princess is, up to the start to get our answers.\\n\\nRemember that since we want to minimize the health we need at the start, of the two actions we can take, going right or down, we will take the one that requires the less amount of health.\\n\\n**But what about the end? You can\\'t move to a different room once you hit the end!**\\nYes, this is correct! That\\'s why we\\'ll have to do something special for the end, and pretend that the cost we need to \"move to a different room\" is 1. This works perfectly because it is the exact same thing as saying that, once we hit the end and paid the associated health cost, we must have at least 1 health left over to be alive! This is the end criterion we need to meet, which we know from the get-go.\\n\\n**Wrapping up**\\nNow that you know to start from the end and to work backwards, you have everything you need to know to arrive at the answer. One more important detail is that if you\\'re at a location where the room itself has a *health benefit* that is high enough that it **pays** for your cost of existence in the less health-demanding, different room, then you know that you only need at least 1 health to exist in that room!\\n\\n**A solution**\\nThis solution can be optimized in some ways for improved performance, but I leave that exercise to the reader.\\n```\\nint calculateMinimumHP(vector<vector<int>>& dungeon) {\\n    int m = dungeon.size(), n = dungeon.front().size();\\n    vector<vector<int>> dp(m + 1, vector<int>(n + 1, INT_MAX)); // Maximum penalty so you don\\'t go out of bounds!\\n\\t\\n\\t// The requirement to \"move to a different room\" at the end: you must be alive!\\n    dp[m][n - 1] = 1; dp[m - 1][n] = 1;\\n    for (int i = m - 1; i >= 0; i--) {\\n        for (int j = n - 1; j >= 0; j--) {\\n\\t\\t\\t// Give me the less costly room and add the cost of the current room,\\n\\t\\t\\t// or 1 if the cost for this room (which is actually a benefit) covers the next room!\\n            dp[i][j] = max(1, min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j]);\\n        }\\n    }\\n\\n    return dp.front().front();\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nint calculateMinimumHP(vector<vector<int>>& dungeon) {\\n    int m = dungeon.size(), n = dungeon.front().size();\\n    vector<vector<int>> dp(m + 1, vector<int>(n + 1, INT_MAX)); // Maximum penalty so you don\\'t go out of bounds!\\n\\t\\n\\t// The requirement to \"move to a different room\" at the end: you must be alive!\\n    dp[m][n - 1] = 1; dp[m - 1][n] = 1;\\n    for (int i = m - 1; i >= 0; i--) {\\n        for (int j = n - 1; j >= 0; j--) {\\n\\t\\t\\t// Give me the less costly room and add the cost of the current room,\\n\\t\\t\\t// or 1 if the cost for this room (which is actually a benefit) covers the next room!\\n            dp[i][j] = max(1, min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j]);\\n        }\\n    }\\n\\n    return dp.front().front();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1498367,
                "title": "c-python-2-solutions-binary-search-dp-clean-concise",
                "content": "**\\u2714\\uFE0F Solution 1: Binary Search & DP**\\n- Binary search to choose a `initHealth` of the knight which can survive and reach to the bottom left cell.\\n\\t- Minimum value `left = 1`, maximum value `right = (m+n) * 1000 + 1`  (because in the worst case, value of all cells in the grid is -1000).\\n\\t- `mid = (left + right) / 2`.\\n\\t- If `isGood(mid)` then:\\n\\t\\t- `ans = mid`\\n\\t\\t- `right = mid - 1` // Minimize init health as much as possible\\n\\t- Else:\\n\\t\\t- `left = mid + 1` // Increasing init health\\n- To check `isGood(initHealth)`\\n\\t- The knight has an initial health point in cell (0, 0).\\n\\t- Let `dp[r][c]` denote the maximum health we can get and we can reach from cell (0, 0) to cell (r, c).\\n\\t- Finally, if we found a path which `dp[m-1][n-1] > 0` means the knight can survive successfully which this `initHealth`. \\n\\n<iframe src=\"https://leetcode.com/playground/FGZt54hw/shared\" frameBorder=\"0\" width=\"100%\" height=\"580\"></iframe>\\n\\n**Complexity**\\n- Time: `O(M * N * logR)`, where `M <= 200` is the number of rows, `N <= 200` is the number of columns, `R = 1000 * (m+n)` is the binary search range.\\n- Space: `O(M * N)`\\n\\n---\\n**\\u2714\\uFE0F Solution 2: DP From Bottom Right cell to Top Left cell**\\n- Let `dpNeedHP[r][c]` denote the amount of HP we need before jumping into cell `(r, c)`.\\n```python\\nclass Solution:\\n    def calculateMinimumHP(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        dpNeedHP = [[math.inf] * (n+1) for _ in range(m+1)]\\n        dpNeedHP[m][n-1] = 1\\n        dpNeedHP[m-1][n] = 1\\n        for r in range(m-1, -1, -1):\\n            for c in range(n-1, -1, -1):\\n                need = min(dpNeedHP[r+1][c], dpNeedHP[r][c+1]) - grid[r][c]\\n                dpNeedHP[r][c] = 1 if need <= 0 else need\\n        return dpNeedHP[0][0]\\n```\\n**Complexity**\\n- Time: `O(M * N`, where `M <= 200` is the number of rows, `N <= 200` is the number of columns\\n- Space: `O(M * N)`, we can reuse input `grid` matrix to achieve in O(1) Space.\\n",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def calculateMinimumHP(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        dpNeedHP = [[math.inf] * (n+1) for _ in range(m+1)]\\n        dpNeedHP[m][n-1] = 1\\n        dpNeedHP[m-1][n] = 1\\n        for r in range(m-1, -1, -1):\\n            for c in range(n-1, -1, -1):\\n                need = min(dpNeedHP[r+1][c], dpNeedHP[r][c+1]) - grid[r][c]\\n                dpNeedHP[r][c] = 1 if need <= 0 else need\\n        return dpNeedHP[0][0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 52897,
                "title": "my-java-solution-with-explanation-in-detail",
                "content": "With a health array to store each grid's health, we should get the result at [0][0].\\n\\nNow the question become to how to create a health array using dungeon.\\n\\ndungeon\\n\\n    -2,-3,3\\n    -5,-10,1\\n    10,30,-5\\n\\nFrom the Dungeon grid, we can simply compute health for the [last row][last column].\\n\\nNow we get\\n\\n    ?,?,?\\n    ?,?,?\\n    ?,?,6\\n\\nNow because the knight can only move rightward or downward in each step, we can compute all the health value for last row from right to left using its rightward neighbor. we can also compute all the health value for last column from bottom to up using its downward neighbor.\\n\\n    ?,?,2\\n    ?,?,5\\n    1,1,6\\n\\nNow, we can compute all the health value using its downward neighbor and rightward neighbor(we use the min value of these 2 health value).\\n\\n    7,5,2\\n    6,11,5\\n    1,1,6\\n\\nNow we get the answer [0][0], which is 7.\\n\\n\\n\\n        public int calculateMinimumHP(int[][] dungeon) {\\n\\n            int row = dungeon.length;\\n            int column = dungeon[0].length;\\n\\n            int[][] tem = new int[row][];\\n            for (int i = 0; i < tem.length; i++) {\\n                tem[i] = new int[column];\\n            }\\n\\n            if (dungeon[row - 1][column - 1] >= 0) {\\n                tem[row - 1][column - 1] = 1;\\n            } else {\\n                tem[row - 1][column - 1] = 1 - dungeon[row - 1][column - 1];\\n            }\\n\\n            for (int i = row - 2; i >= 0; i--) {\\n                tem[i][column - 1] = c(dungeon[i][column - 1],\\n                        tem[i + 1][column - 1]);\\n            }\\n\\n            for (int j = column - 2; j >= 0; j--) {\\n                tem[row - 1][j] = c(dungeon[row - 1][j], tem[row - 1][j + 1]);\\n            }\\n\\n            for (int i = row - 2; i >= 0; i--) {\\n                for (int j = column - 2; j >= 0; j--) {\\n                    tem[i][j] = Math.min(c(dungeon[i][j], tem[i + 1][j]),\\n                            c(dungeon[i][j], tem[i][j + 1]));\\n                }\\n            }\\n\\n            return tem[0][0];\\n        }\\n\\n        private int c(int value, int preResult) {\\n            if (value == 0)\\n                return preResult;\\n\\n            if (value > 0) {\\n                if (value >= preResult)\\n                    return 1;\\n                return preResult - value;\\n            }\\n\\n            return preResult - value;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "With a health array to store each grid's health, we should get the result at [0][0].\\n\\nNow the question become to how to create a health array using dungeon.\\n\\ndungeon\\n\\n    -2,-3,3\\n    -5,-10,1\\n    10,30,-5\\n\\nFrom the Dungeon grid, we can simply compute health for the [last row][last column].\\n\\nNow we get\\n\\n    ?,?,?\\n    ?,?,?\\n    ?,?,6\\n\\nNow because the knight can only move rightward or downward in each step, we can compute all the health value for last row from right to left using its rightward neighbor. we can also compute all the health value for last column from bottom to up using its downward neighbor.\\n\\n    ?,?,2\\n    ?,?,5\\n    1,1,6\\n\\nNow, we can compute all the health value using its downward neighbor and rightward neighbor(we use the min value of these 2 health value).\\n\\n    7,5,2\\n    6,11,5\\n    1,1,6\\n\\nNow we get the answer [0][0], which is 7.\\n\\n\\n\\n        public int calculateMinimumHP(int[][] dungeon) {\\n\\n            int row = dungeon.length;\\n            int column = dungeon[0].length;\\n\\n            int[][] tem = new int[row][];\\n            for (int i = 0; i < tem.length; i++) {\\n                tem[i] = new int[column];\\n            }\\n\\n            if (dungeon[row - 1][column - 1] >= 0) {\\n                tem[row - 1][column - 1] = 1;\\n            } else {\\n                tem[row - 1][column - 1] = 1 - dungeon[row - 1][column - 1];\\n            }\\n\\n            for (int i = row - 2; i >= 0; i--) {\\n                tem[i][column - 1] = c(dungeon[i][column - 1],\\n                        tem[i + 1][column - 1]);\\n            }\\n\\n            for (int j = column - 2; j >= 0; j--) {\\n                tem[row - 1][j] = c(dungeon[row - 1][j], tem[row - 1][j + 1]);\\n            }\\n\\n            for (int i = row - 2; i >= 0; i--) {\\n                for (int j = column - 2; j >= 0; j--) {\\n                    tem[i][j] = Math.min(c(dungeon[i][j], tem[i + 1][j]),\\n                            c(dungeon[i][j], tem[i][j + 1]));\\n                }\\n            }\\n\\n            return tem[0][0];\\n        }\\n\\n        private int c(int value, int preResult) {\\n            if (value == 0)\\n                return preResult;\\n\\n            if (value > 0) {\\n                if (value >= preResult)\\n                    return 1;\\n                return preResult - value;\\n            }\\n\\n            return preResult - value;\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 192590,
                "title": "my-intuitive-dp-solution-with-text-and-video-explanation",
                "content": "## LeetCode 174. Dungeon Game\\n### Note\\nIf you prefer video over text, please check out this link: https://www.youtube.com/watch?v=Ir8ePM_gDUk\\nwhich has the same content as follows.\\n### Explanation\\n```java\\n// given the example dungeon, lets label cells as follows: \\n// +-+-+-+\\n// |1|2|3|\\n// +-+-+-+\\n// |4|5|6|\\n// +-+-+-+\\n// |7|8|9|\\n// +-+-+-+\\n\\nThe dungeon:                              Initial HP knight needed:       \\n+-------+-------+-------+                 +-------+-------+-------+\\n|       |       |       |                 |       |       |       |\\n|  -2   |  -3   |   3   |                 |   7   |   5   |   2   |\\n|       |       |       |                 |       |       |       |\\n+-------+-------+-------+                 +-------+-------+-------+\\n|       |       |       |                 |       |       |       |\\n|  -5   |  -10  |   1   |                 |   6   |   11  |   5   |\\n|       |       |       |                 |       |       |       |\\n+-------+-------+-------+                 +-------+-------+-------+\\n|       |       |       |                 |       |       |       |\\n|  10   |  30   |  -5(P)|                 |   1   |   1   |   6   |\\n|       |       |       |                 |       |       |       |\\n+-------+-------+-------+                 +-------+-------+-------+\\n\\nKnight HP: \\n\\n// To solve this problem, we can start with the simpliest cases.\\n// Les\\'s say,\\n\\n// If the knight starts from cell 9.\\nInitial HP: 6 (6 - 5 = 1), which means as long as the knight has 6 HP when reaching cell 9, he would be fine.\\n\\n// If the knight starts from cell 6.\\nInitial HP: 5 (5 + 1 = 6), which means as long as the knight has 5 HP when reaching cell 6, he would be fine.\\n\\n// If the knight starts from cell 8.\\nInitial HP: 1 (1 + 30 >= 6, HP needs to be at least 1, 0 means the knight is already dead), \\nwhich means as long as the kinght has 1 HP when reaching cell 7, he would be fine.\\n\\n// If the knight starts from cell 5.\\nEmm... the knight now has two options, going right or going down.\\nIf go right (5 --> 6 --> 9), Initial HP(R): 15 (15 - 10 = 5)\\nIf go down (5 --> 8 --> 9), Initial HP(D): 11 (11 - 10 = 1)\\nHence, Initial HP = MIN(HP(R), HP(D)) = 11\\n\\n// Sub-problems and state: \\nLet dp[i][j] denote Initial HP needed if the knight starts from dungeon[i][j].\\n\\n// recurrence relation:\\ndp[i][j] = min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j];\\nif(dp[i][j] <= 0) dp[i][j] = 1;\\n```\\n### Code\\n```java\\nclass Solution {\\n    public int calculateMinimumHP(int[][] dungeon) {\\n        if(dungeon == null || dungeon.length == 0 || dungeon[0].length == 0) return 1;\\n        \\n        int N = dungeon.length;\\n        int M = dungeon[0].length;\\n        int[][] dp = new int[N][M];\\n        dp[N - 1][M - 1] = 1 - dungeon[N - 1][M - 1];\\n        dp[N - 1][M - 1] = dp[N - 1][M - 1] <= 0 ? 1 : dp[N - 1][M - 1];\\n            \\n        for(int i = N - 1; i >= 0; --i){\\n            for(int j = M - 1; j >= 0; --j){\\n                if(i == N - 1 && j == M - 1) continue;\\n                int HP_D = i + 1 == N ? Integer.MAX_VALUE : dp[i + 1][j] - dungeon[i][j];\\n                int HP_R = j + 1 == M ? Integer.MAX_VALUE : dp[i][j + 1] - dungeon[i][j];\\n                int HP = Math.min(HP_D, HP_R);\\n                dp[i][j] = HP <= 0 ? 1 : HP;\\n            }    \\n        }\\n        \\n        return dp[0][0] ;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\n// given the example dungeon, lets label cells as follows: \\n// +-+-+-+\\n// |1|2|3|\\n// +-+-+-+\\n// |4|5|6|\\n// +-+-+-+\\n// |7|8|9|\\n// +-+-+-+\\n\\nThe dungeon:                              Initial HP knight needed:       \\n+-------+-------+-------+                 +-------+-------+-------+\\n|       |       |       |                 |       |       |       |\\n|  -2   |  -3   |   3   |                 |   7   |   5   |   2   |\\n|       |       |       |                 |       |       |       |\\n+-------+-------+-------+                 +-------+-------+-------+\\n|       |       |       |                 |       |       |       |\\n|  -5   |  -10  |   1   |                 |   6   |   11  |   5   |\\n|       |       |       |                 |       |       |       |\\n+-------+-------+-------+                 +-------+-------+-------+\\n|       |       |       |                 |       |       |       |\\n|  10   |  30   |  -5(P)|                 |   1   |   1   |   6   |\\n|       |       |       |                 |       |       |       |\\n+-------+-------+-------+                 +-------+-------+-------+\\n\\nKnight HP: \\n\\n// To solve this problem, we can start with the simpliest cases.\\n// Les\\'s say,\\n\\n// If the knight starts from cell 9.\\nInitial HP: 6 (6 - 5 = 1), which means as long as the knight has 6 HP when reaching cell 9, he would be fine.\\n\\n// If the knight starts from cell 6.\\nInitial HP: 5 (5 + 1 = 6), which means as long as the knight has 5 HP when reaching cell 6, he would be fine.\\n\\n// If the knight starts from cell 8.\\nInitial HP: 1 (1 + 30 >= 6, HP needs to be at least 1, 0 means the knight is already dead), \\nwhich means as long as the kinght has 1 HP when reaching cell 7, he would be fine.\\n\\n// If the knight starts from cell 5.\\nEmm... the knight now has two options, going right or going down.\\nIf go right (5 --> 6 --> 9), Initial HP(R): 15 (15 - 10 = 5)\\nIf go down (5 --> 8 --> 9), Initial HP(D): 11 (11 - 10 = 1)\\nHence, Initial HP = MIN(HP(R), HP(D)) = 11\\n\\n// Sub-problems and state: \\nLet dp[i][j] denote Initial HP needed if the knight starts from dungeon[i][j].\\n\\n// recurrence relation:\\ndp[i][j] = min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j];\\nif(dp[i][j] <= 0) dp[i][j] = 1;\\n```\n```java\\nclass Solution {\\n    public int calculateMinimumHP(int[][] dungeon) {\\n        if(dungeon == null || dungeon.length == 0 || dungeon[0].length == 0) return 1;\\n        \\n        int N = dungeon.length;\\n        int M = dungeon[0].length;\\n        int[][] dp = new int[N][M];\\n        dp[N - 1][M - 1] = 1 - dungeon[N - 1][M - 1];\\n        dp[N - 1][M - 1] = dp[N - 1][M - 1] <= 0 ? 1 : dp[N - 1][M - 1];\\n            \\n        for(int i = N - 1; i >= 0; --i){\\n            for(int j = M - 1; j >= 0; --j){\\n                if(i == N - 1 && j == M - 1) continue;\\n                int HP_D = i + 1 == N ? Integer.MAX_VALUE : dp[i + 1][j] - dungeon[i][j];\\n                int HP_R = j + 1 == M ? Integer.MAX_VALUE : dp[i][j + 1] - dungeon[i][j];\\n                int HP = Math.min(HP_D, HP_R);\\n                dp[i][j] = HP <= 0 ? 1 : HP;\\n            }    \\n        }\\n        \\n        return dp[0][0] ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 698961,
                "title": "python-simple-in-place-dp-solution-o-1-space",
                "content": "Traversing from bottom-right to top-left, we calculate how much hp is required to reach the princess from the current cell.\\n\\nThe first step is to calculate how much hp is required to save the princess upon reaching `dungeon[m-1][n-1]`:\\n`dungeon[i][j] = min(dungeon[i][j], 0) * -1 + 1`\\nFor example:\\nIf `dungeon[m-1][n-1] == -5`, then we need 6 hp.\\nIf `dungeon[m-1][n-1] >= 0` then we only need 1 hp.\\n\\nFor every other cell we find the minimum hp required to reach the princess by going either down or right.\\nWe subtract this minimum hp from the current cell\\'s value to find how much hp would be needed to reach the princess from the current cell.\\nIf this value is <=0, we change it to 1 because that means there is an abundance of hp in this cell and our minimum hp can never be <=0.\\n\\n```\\ndef calculateMinimumHP(self, dungeon):\\n\\tm, n = len(dungeon), len(dungeon[0])\\n\\tfor i in range(m-1, -1, -1):\\n\\t\\tfor j in range(n-1, -1, -1):\\n\\t\\t\\tif i == m-1 and j == n-1:\\n\\t\\t\\t\\tdungeon[i][j] = min(dungeon[i][j], 0) * -1 + 1\\n\\t\\t\\telif i == m-1:\\n\\t\\t\\t\\tdungeon[i][j] = max(dungeon[i][j+1] - dungeon[i][j], 1)\\n\\t\\t\\telif j == n-1:\\n\\t\\t\\t\\tdungeon[i][j] = max(dungeon[i+1][j] - dungeon[i][j], 1)\\n\\t\\t\\telse:\\n\\t\\t\\t\\tdungeon[i][j] = max(min(dungeon[i][j+1], dungeon[i+1][j]) - dungeon[i][j], 1)\\n\\treturn dungeon[0][0]\\n```\\n\\nInspired by [suryan0800\\'s comment](https://leetcode.com/problems/dungeon-game/discuss/698271/Python-Short-DP-7-lines-O(mn)-top-down-explained/588576) and [DBabichev\\'s great explanation](https://leetcode.com/problems/dungeon-game/discuss/698271/Python-Short-DP-7-lines-O(mn)-top-down-explained).",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef calculateMinimumHP(self, dungeon):\\n\\tm, n = len(dungeon), len(dungeon[0])\\n\\tfor i in range(m-1, -1, -1):\\n\\t\\tfor j in range(n-1, -1, -1):\\n\\t\\t\\tif i == m-1 and j == n-1:\\n\\t\\t\\t\\tdungeon[i][j] = min(dungeon[i][j], 0) * -1 + 1\\n\\t\\t\\telif i == m-1:\\n\\t\\t\\t\\tdungeon[i][j] = max(dungeon[i][j+1] - dungeon[i][j], 1)\\n\\t\\t\\telif j == n-1:\\n\\t\\t\\t\\tdungeon[i][j] = max(dungeon[i+1][j] - dungeon[i][j], 1)\\n\\t\\t\\telse:\\n\\t\\t\\t\\tdungeon[i][j] = max(min(dungeon[i][j+1], dungeon[i+1][j]) - dungeon[i][j], 1)\\n\\treturn dungeon[0][0]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 52887,
                "title": "sharing-my-solution-with-o-n-space-o-mn-runtime",
                "content": "Here is my solution using dp and rolling array --Dungeon Game:\\n\\n    int calculateMinimumHP(vector<vector<int> > &dungeon) {\\n        const int m = dungeon.size();\\n        const int n = dungeon[0].size();\\n        vector<int> dp(n + 1, INT_MAX);\\n        dp[n - 1] = 1; \\n        for(int i = m - 1; i >= 0; --i)\\n            for(int j = n - 1; j >= 0; --j)\\n                dp[j] = getMin(min(dp[j], dp[j + 1]) - dungeon[i][j]);\\n        return dp[0];\\n    }\\n    int getMin(int n){\\n        return n <= 0 ? 1 : n;\\n    }\\n\\nNote: Update from right to left and from bottom up.",
                "solutionTags": [],
                "code": "Here is my solution using dp and rolling array --Dungeon Game:\\n\\n    int calculateMinimumHP(vector<vector<int> > &dungeon) {\\n        const int m = dungeon.size();\\n        const int n = dungeon[0].size();\\n        vector<int> dp(n + 1, INT_MAX);\\n        dp[n - 1] = 1; \\n        for(int i = m - 1; i >= 0; --i)\\n            for(int j = n - 1; j >= 0; --j)\\n                dp[j] = getMin(min(dp[j], dp[j + 1]) - dungeon[i][j]);\\n        return dp[0];\\n    }\\n    int getMin(int n){\\n        return n <= 0 ? 1 : n;\\n    }\\n\\nNote: Update from right to left and from bottom up.",
                "codeTag": "Unknown"
            },
            {
                "id": 3055960,
                "title": "handwritten-step-by-step-in-detail-dry-run-fully-commented-recursive-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n![Screenshot_20230116_004830.png](https://assets.leetcode.com/users/images/b31c29d9-b217-45a1-95cb-73368eb4d077_1673810770.2499864.png)\\n![Screenshot_20230116_004905.png](https://assets.leetcode.com/users/images/d9521ce1-cf60-4f84-ac86-fa5cbb071c18_1673810784.8820758.png)\\n![Screenshot_20230116_004918.png](https://assets.leetcode.com/users/images/b9d9f8a6-b62e-4148-ac02-cef4ba42a3b8_1673810798.7564626.png)\\n![Screenshot_20230116_004927.png](https://assets.leetcode.com/users/images/a31b74a2-2b6f-4db8-9f4b-1a2de346e11c_1673810815.7368083.png)\\n![Screenshot_20230116_005814.png](https://assets.leetcode.com/users/images/20f8a03b-5229-451f-87ce-ce76f5824c95_1673810910.7959452.png)\\n\\n# Complexity\\n- Time complexity: O(M*N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(M*N) + Stack space\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    //this recursive fuction will return the min amount of health that the knight needs in the future\\n    //to rescue the queen\\n    int future(int row,int col,vector<vector<int>>& arr,vector<vector<int>>&dp)\\n    {\\n        int r=arr.size();\\n        int c=arr[0].size();\\n        //base case: if the knight goes out of the dungeon\\n        if(row>=r || col>=c)\\n            return 1e9;//very large number so that the knight does not choose this future health\\n\\n        if(row==r-1 && col==c-1)//knight has reached the queen\\n        {\\n            if(arr[row][col]>=0)//knight will not recure any additional health as he will gain health\\n                return dp[row][col]= 1;\\n            else //knight must enter this cell with additional health of +1 to survive\\n                return dp[row][col]= abs(arr[row][col])+1;\\n        }\\n        if(dp[row][col]!=-1)\\n            return dp[row][col];\\n        int future_health_left=future(row,col+1,arr,dp);//the min amount of health he will need to survive the left path\\n        int future_health_down=future(row+1,col,arr,dp);//the min amount of health he will need to survive the down path\\n        int future_health=min(future_health_down,future_health_left);//he will go to the path that will require the minimum health\\n        int health_gain=arr[row][col];//the health he gained or lost in this cell\\n        int health_needed=future_health-health_gain;//the min health he requires to survive cell as well as his chosen path\\n        if(health_needed>0)//he needed additional health to survive this cell as well as this chosen future path\\n            return dp[row][col]= health_needed;\\n        else//he gained health in this cell and he did not require health \\n            return dp[row][col]= 1;\\n    }\\n    int calculateMinimumHP(vector<vector<int>>&arr) \\n    {\\n        int r=arr.size();\\n        int c=arr[0].size();\\n        vector<vector<int>>dp(r,vector<int>(c,-1));//stores the future required health\\n        return future(0,0,arr,dp);\\n    }\\n};\\n```\\n**Please upvote. It takes a lot of effort to make such solutions :)**",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //this recursive fuction will return the min amount of health that the knight needs in the future\\n    //to rescue the queen\\n    int future(int row,int col,vector<vector<int>>& arr,vector<vector<int>>&dp)\\n    {\\n        int r=arr.size();\\n        int c=arr[0].size();\\n        //base case: if the knight goes out of the dungeon\\n        if(row>=r || col>=c)\\n            return 1e9;//very large number so that the knight does not choose this future health\\n\\n        if(row==r-1 && col==c-1)//knight has reached the queen\\n        {\\n            if(arr[row][col]>=0)//knight will not recure any additional health as he will gain health\\n                return dp[row][col]= 1;\\n            else //knight must enter this cell with additional health of +1 to survive\\n                return dp[row][col]= abs(arr[row][col])+1;\\n        }\\n        if(dp[row][col]!=-1)\\n            return dp[row][col];\\n        int future_health_left=future(row,col+1,arr,dp);//the min amount of health he will need to survive the left path\\n        int future_health_down=future(row+1,col,arr,dp);//the min amount of health he will need to survive the down path\\n        int future_health=min(future_health_down,future_health_left);//he will go to the path that will require the minimum health\\n        int health_gain=arr[row][col];//the health he gained or lost in this cell\\n        int health_needed=future_health-health_gain;//the min health he requires to survive cell as well as his chosen path\\n        if(health_needed>0)//he needed additional health to survive this cell as well as this chosen future path\\n            return dp[row][col]= health_needed;\\n        else//he gained health in this cell and he did not require health \\n            return dp[row][col]= 1;\\n    }\\n    int calculateMinimumHP(vector<vector<int>>&arr) \\n    {\\n        int r=arr.size();\\n        int c=arr[0].size();\\n        vector<vector<int>>dp(r,vector<int>(c,-1));//stores the future required health\\n        return future(0,0,arr,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 52859,
                "title": "simple-java-dp-code",
                "content": "     public int calculateMinimumHP(int[][] dungeon) {\\n        int m = dungeon.length;\\n        int n = dungeon[0].length;\\n        //dp[i][j] represents the minimum health points needed at position (i,j) and\\n        //the last row or column is just dummy (outside of the range).\\n        int[][] dp = new int[m+1][n+1];\\n        \\n        //Initialize the matrix to maximum possible.\\n        for (int i = 0; i <= m; i++)\\n        \\tArrays.fill(dp[i], Integer.MAX_VALUE);\\n        \\n        //initializing the boundary.\\n        dp[m][n-1] = 1; dp[m-1][n] = 1; \\n        \\n        for (int i = m-1; i >= 0; i--) {\\n        \\tfor (int j = n-1; j >= 0; j--) {\\n        \\t\\tint minHp = Math.min(dp[i+1][j], dp[i][j+1])  - dungeon[i][j];\\n        \\t\\tdp[i][j] = (minHp <= 0) ? 1 : minHp;\\n        \\t}\\n        }\\n        return dp[0][0];\\n    }",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "     public int calculateMinimumHP(int[][] dungeon) {\\n        int m = dungeon.length;\\n        int n = dungeon[0].length;\\n        //dp[i][j] represents the minimum health points needed at position (i,j) and\\n        //the last row or column is just dummy (outside of the range).\\n        int[][] dp = new int[m+1][n+1];\\n        \\n        //Initialize the matrix to maximum possible.\\n        for (int i = 0; i <= m; i++)\\n        \\tArrays.fill(dp[i], Integer.MAX_VALUE);\\n        \\n        //initializing the boundary.\\n        dp[m][n-1] = 1; dp[m-1][n] = 1; \\n        \\n        for (int i = m-1; i >= 0; i--) {\\n        \\tfor (int j = n-1; j >= 0; j--) {\\n        \\t\\tint minHp = Math.min(dp[i+1][j], dp[i][j+1])  - dungeon[i][j];\\n        \\t\\tdp[i][j] = (minHp <= 0) ? 1 : minHp;\\n        \\t}\\n        }\\n        return dp[0][0];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2704445,
                "title": "100-best-solution-explained-c-c-recursion-dp-memoization-dp-tabulation",
                "content": "if you like the solution please remember to upvote this blog \\uD83E\\uDD7A\\n\\n![image](https://assets.leetcode.com/users/images/49afdc7c-c5af-4330-bb30-26a6fe4ebba7_1665935047.5086565.gif)\\n\\n```\\n// TODO : Dungeon Game\\n    // brute force : TLE\\n        class Solution {\\n        public:\\n            int pre(int i,int j,int n,int m,vector<vector<int>>& arr){\\n                if(i >= n+1 or j >= m+1) return 1e9;\\n                if(i == n and j == m) return arr[i][j] > 0 ? 1 : 1 - arr[i][j];\\n\\n                int down = pre(i+1,j,n,m,arr);\\n                int right = pre(i,j+1,n,m,arr);\\n                int res = min(down,right)-arr[i][j];\\n                return res > 0 ? res : 1;\\n            }\\n            int calculateMinimumHP(vector<vector<int>>& arr) {\\n                int n = arr.size(), m = arr[0].size();\\n                vector<vector<int>> dp(n+1,vector<int> (m+1,-1));\\n                return pre(0,0,n-1,m-1,arr);\\n            }\\n        };\\n\\n    // memorization\\n        class Solution {\\n        public:\\n            int pre(int i,int j,int n,int m,vector<vector<int>>& arr,vector<vector<int>> &dp){\\n                if(i >= n+1 or j >= m+1) return 1e9;\\n                if(i == n and j == m) return arr[i][j] > 0 ? 1 : 1 - arr[i][j];\\n                if(dp[i][j] != -1) return dp[i][j];\\n                \\n                int down = pre(i+1,j,n,m,arr,dp);\\n                int right = pre(i,j+1,n,m,arr,dp);\\n                int res = min(down,right)-arr[i][j];\\n                return dp[i][j] = res > 0 ? res : 1;\\n            }\\n            int calculateMinimumHP(vector<vector<int>>& arr) {\\n                int n = arr.size(), m = arr[0].size();\\n                vector<vector<int>> dp(n+1,vector<int> (m+1,-1));\\n                return pre(0,0,n-1,m-1,arr,dp);\\n            }\\n        };\\n\\n    // Tabulation    \\n        class Solution {\\n        public:\\n            int calculateMinimumHP(vector<vector<int>>& arr) {\\n                int n = arr.size(), m = arr[0].size();\\n                vector<vector<int>> dp(n+1,vector<int> (m+1,0));\\n                \\n                for(int i=n;i>=0;i--){ dp[i][m] = 1e9; }\\n                for(int j=m;j>=0;j--){ dp[n][j] = 1e9; }\\n                \\n                for(int i=n-1;i>=0;i--){\\n                    for(int j=m-1;j>=0;j--){\\n                        if(i == n-1 and j==m-1){\\n                            dp[i][j] = arr[i][j] > 0 ? 1 : 1 - arr[i][j];\\n                            continue;\\n                        }\\n                        int down = dp[i+1][j];\\n                        int right = dp[i][j+1];\\n                        int res = min(down,right) - arr[i][j];\\n                        dp[i][j] = res > 0 ? res : 1;\\n                    }\\n                }\\n                \\n                return dp[0][0];\\n            }\\n        };\\n\\n    // optimize 2d\\n        class Solution {\\n        public:\\n            int calculateMinimumHP(vector<vector<int>>& arr) {\\n                int n = arr.size(), m = arr[0].size();\\n                vector<int> dp(m+1,1e9),curr(m+1,0);\\n                curr[m] = 1e9;\\n                \\n                for(int i=n-1;i>=0;i--){\\n                    for(int j=m-1;j>=0;j--){\\n                        if(i == n-1 and j==m-1){\\n                            curr[j] = arr[i][j] > 0 ? 1 : 1 - arr[i][j];\\n                            continue;\\n                        }\\n                        int down = dp[j];\\n                        int right = curr[j+1];\\n                        int res = min(down,right) - arr[i][j];\\n                        curr[j] = res > 0 ? res : 1;\\n                    }\\n                    dp = curr;\\n                }\\n                \\n                return dp[0];\\n            }\\n        };\\n\\n    // optimize 1d\\n        class Solution {\\n        public:\\n            int calculateMinimumHP(vector<vector<int>>& arr) {\\n                int n = arr.size(), m = arr[0].size();\\n                vector<int> dp(m+1,1e9);\\n                \\n                for(int i=n-1;i>=0;i--){\\n                    for(int j=m-1;j>=0;j--){\\n                        if(i == n-1 and j==m-1){\\n                            dp[j] = arr[i][j] > 0 ? 1 : 1 - arr[i][j];\\n                            continue;\\n                        }\\n                        int down = dp[j];\\n                        int right = dp[j+1];\\n                        int res = min(down,right) - arr[i][j];\\n                        dp[j] = res > 0 ? res : 1;\\n                    }\\n                }\\n                \\n                return dp[0];\\n            }\\n        };\\n```\\n\\nThank u for Upvoting\\n\\n![image](https://assets.leetcode.com/users/images/9b9093f9-0191-490e-b14d-891b5a933ffb_1665935057.2284648.gif)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n// TODO : Dungeon Game\\n    // brute force : TLE\\n        class Solution {\\n        public:\\n            int pre(int i,int j,int n,int m,vector<vector<int>>& arr){\\n                if(i >= n+1 or j >= m+1) return 1e9;\\n                if(i == n and j == m) return arr[i][j] > 0 ? 1 : 1 - arr[i][j];\\n\\n                int down = pre(i+1,j,n,m,arr);\\n                int right = pre(i,j+1,n,m,arr);\\n                int res = min(down,right)-arr[i][j];\\n                return res > 0 ? res : 1;\\n            }\\n            int calculateMinimumHP(vector<vector<int>>& arr) {\\n                int n = arr.size(), m = arr[0].size();\\n                vector<vector<int>> dp(n+1,vector<int> (m+1,-1));\\n                return pre(0,0,n-1,m-1,arr);\\n            }\\n        };\\n\\n    // memorization\\n        class Solution {\\n        public:\\n            int pre(int i,int j,int n,int m,vector<vector<int>>& arr,vector<vector<int>> &dp){\\n                if(i >= n+1 or j >= m+1) return 1e9;\\n                if(i == n and j == m) return arr[i][j] > 0 ? 1 : 1 - arr[i][j];\\n                if(dp[i][j] != -1) return dp[i][j];\\n                \\n                int down = pre(i+1,j,n,m,arr,dp);\\n                int right = pre(i,j+1,n,m,arr,dp);\\n                int res = min(down,right)-arr[i][j];\\n                return dp[i][j] = res > 0 ? res : 1;\\n            }\\n            int calculateMinimumHP(vector<vector<int>>& arr) {\\n                int n = arr.size(), m = arr[0].size();\\n                vector<vector<int>> dp(n+1,vector<int> (m+1,-1));\\n                return pre(0,0,n-1,m-1,arr,dp);\\n            }\\n        };\\n\\n    // Tabulation    \\n        class Solution {\\n        public:\\n            int calculateMinimumHP(vector<vector<int>>& arr) {\\n                int n = arr.size(), m = arr[0].size();\\n                vector<vector<int>> dp(n+1,vector<int> (m+1,0));\\n                \\n                for(int i=n;i>=0;i--){ dp[i][m] = 1e9; }\\n                for(int j=m;j>=0;j--){ dp[n][j] = 1e9; }\\n                \\n                for(int i=n-1;i>=0;i--){\\n                    for(int j=m-1;j>=0;j--){\\n                        if(i == n-1 and j==m-1){\\n                            dp[i][j] = arr[i][j] > 0 ? 1 : 1 - arr[i][j];\\n                            continue;\\n                        }\\n                        int down = dp[i+1][j];\\n                        int right = dp[i][j+1];\\n                        int res = min(down,right) - arr[i][j];\\n                        dp[i][j] = res > 0 ? res : 1;\\n                    }\\n                }\\n                \\n                return dp[0][0];\\n            }\\n        };\\n\\n    // optimize 2d\\n        class Solution {\\n        public:\\n            int calculateMinimumHP(vector<vector<int>>& arr) {\\n                int n = arr.size(), m = arr[0].size();\\n                vector<int> dp(m+1,1e9),curr(m+1,0);\\n                curr[m] = 1e9;\\n                \\n                for(int i=n-1;i>=0;i--){\\n                    for(int j=m-1;j>=0;j--){\\n                        if(i == n-1 and j==m-1){\\n                            curr[j] = arr[i][j] > 0 ? 1 : 1 - arr[i][j];\\n                            continue;\\n                        }\\n                        int down = dp[j];\\n                        int right = curr[j+1];\\n                        int res = min(down,right) - arr[i][j];\\n                        curr[j] = res > 0 ? res : 1;\\n                    }\\n                    dp = curr;\\n                }\\n                \\n                return dp[0];\\n            }\\n        };\\n\\n    // optimize 1d\\n        class Solution {\\n        public:\\n            int calculateMinimumHP(vector<vector<int>>& arr) {\\n                int n = arr.size(), m = arr[0].size();\\n                vector<int> dp(m+1,1e9);\\n                \\n                for(int i=n-1;i>=0;i--){\\n                    for(int j=m-1;j>=0;j--){\\n                        if(i == n-1 and j==m-1){\\n                            dp[j] = arr[i][j] > 0 ? 1 : 1 - arr[i][j];\\n                            continue;\\n                        }\\n                        int down = dp[j];\\n                        int right = dp[j+1];\\n                        int res = min(down,right) - arr[i][j];\\n                        dp[j] = res > 0 ? res : 1;\\n                    }\\n                }\\n                \\n                return dp[0];\\n            }\\n        };\\n```",
                "codeTag": "Java"
            },
            {
                "id": 52843,
                "title": "6-lines-16-ms-c-o-mn-time-o-n-space",
                "content": "    struct Solution {\\n        int calculateMinimumHP(vector<vector<int>>& d) {\\n            vector<int> dp(d.size() + 1, INT_MAX);\\n            dp[d.size() - 1] = 1;\\n            for (int i = d[0].size() - 1; i >= 0; --i)\\n                for (int j = d.size() - 1; j >= 0; --j)\\n                    dp[j] = max(1, min(dp[j + 1], dp[j]) - d[j][i]);\\n            return dp[0];\\n        }\\n    };",
                "solutionTags": [],
                "code": "    struct Solution {\\n        int calculateMinimumHP(vector<vector<int>>& d) {\\n            vector<int> dp(d.size() + 1, INT_MAX);\\n            dp[d.size() - 1] = 1;\\n            for (int i = d[0].size() - 1; i >= 0; --i)\\n                for (int j = d.size() - 1; j >= 0; --j)\\n                    dp[j] = max(1, min(dp[j + 1], dp[j]) - d[j][i]);\\n            return dp[0];\\n        }\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 52792,
                "title": "6-lines-python-8-lines-ruby",
                "content": "Just some DP.\\n\\n---\\n\\n**Python**\\n\\n    def calculateMinimumHP(self, dungeon):\\n        n = len(dungeon[0])\\n        need = [2**31] * (n-1) + [1]\\n        for row in dungeon[::-1]:\\n            for j in range(n)[::-1]:\\n                need[j] = max(min(need[j:j+2]) - row[j], 1)\\n        return need[0]\\n\\nGot accepted in 52 ms, faster than all other recent Python submissions (best was 56 ms, achieved by 5.7692%).\\n\\n---\\n\\n**Ruby**\\n\\n    def calculate_minimum_hp(dungeon)\\n        n = dungeon[0].size - 1\\n        need = [1/0.0] * n + [1]\\n        dungeon.reverse_each do |row|\\n            n.downto(0) do |j|\\n                need[j] = [need[j..j+1].min - row[j], 1].max\\n            end\\n        end\\n        need[0]\\n    end",
                "solutionTags": [
                    "Python",
                    "Ruby"
                ],
                "code": "Just some DP.\\n\\n---\\n\\n**Python**\\n\\n    def calculateMinimumHP(self, dungeon):\\n        n = len(dungeon[0])\\n        need = [2**31] * (n-1) + [1]\\n        for row in dungeon[::-1]:\\n            for j in range(n)[::-1]:\\n                need[j] = max(min(need[j:j+2]) - row[j], 1)\\n        return need[0]\\n\\nGot accepted in 52 ms, faster than all other recent Python submissions (best was 56 ms, achieved by 5.7692%).\\n\\n---\\n\\n**Ruby**\\n\\n    def calculate_minimum_hp(dungeon)\\n        n = dungeon[0].size - 1\\n        need = [1/0.0] * n + [1]\\n        dungeon.reverse_each do |row|\\n            n.downto(0) do |j|\\n                need[j] = [need[j..j+1].min - row[j], 1].max\\n            end\\n        end\\n        need[0]\\n    end",
                "codeTag": "Python3"
            },
            {
                "id": 1498636,
                "title": "c-solution-with-image-explaination",
                "content": "# Logic behind\\nEx. `dungeon = [[-2,-3,3],[-5,-10,1],[10,30,-5]]`\\nWe know that we start from left-top of the grid and we can only go right on down\\n![image](https://assets.leetcode.com/users/images/ad58c7dd-e805-43cb-a36e-29bfa3849456_1633168629.339159.png)\\nsame for each cell\\n![image](https://assets.leetcode.com/users/images/f801f1c8-4f17-482c-a722-b45ee6dfc671_1633168672.6553586.png)\\nNow if we think in the opposite way (so from the end point). since it is the end point we don\\'t need to go right or bottom, we just need to take this value\\n![image](https://assets.leetcode.com/users/images/adbd7e6e-9bc3-40b9-abe4-159942ed6b08_1633169767.3472998.png)\\nThen we go to the cell beside that end point and find the max(right and bottom cell) (**remember that we have to take the cell that gives more health, or lose less health)**, we have to do it for each cell (**remember we are doing it in opposite way, so last cell then second-last and so on**)\\n![image](https://assets.leetcode.com/users/images/e20bee0d-626a-42ea-923f-7eba1adbd382_1633169279.014217.png)\\nWe notice that in our case for `30` `10` we can\\'t take any value from bottom (It\\'s out of range) to avoid this error we set our dp bigger that dungeon and set them equal to INT_MIN (so it will never take those value). **Yellow cells are cells that I add to avoid error**\\n![image](https://assets.leetcode.com/users/images/babbabd3-e593-4fc6-a708-20f714666bb1_1633170411.4298382.png)\\nWe have to set the end point of dungeon to our dp (because as I said for the end point we don\\'t need to find the max(right,bottom), what we have to do is take this value)![image](https://assets.leetcode.com/users/images/b2ad905e-51cf-441d-bdeb-dafbc2b5a4d3_1633171035.4803393.png)\\n![image](https://assets.leetcode.com/users/images/73a9782a-a5e7-42a0-915b-d28d07ca37e3_1633170932.9055116.png)+\\nGo to the next (second-last) and find the max(right,bottom) + the value of current cell in dungeon\\n![image](https://assets.leetcode.com/users/images/6bc4ce05-7ba9-4de5-a48f-131d568f3721_1633171097.4836278.png)\\nThe result of this cell is 30 - 5 =25. But since we are doing in the opposite way we have to keep in mind that these \"healths\" it\\'s valid only for this cell and next one (the end point) so it means that we can\\'t use these healths for the cell on the left and top. So, we have to change it to 0 (means that from this cell to the end point I don\\'t need to lost any health).\\n![image](https://assets.leetcode.com/users/images/548fe008-f25d-4fa6-9d14-9cc7c4feecbc_1633171283.567383.png)\\nApply the same login with each cell \\n![image](https://assets.leetcode.com/users/images/23d5fb90-b704-4063-acaa-6c34cd21569e_1633171357.4401152.png)\\nSet to 0 (same concept as mentio before)\\n![image](https://assets.leetcode.com/users/images/108ebb14-1b39-481b-b03b-f84759b677f8_1633171373.5899377.png)\\nmin(right,bottom)\\n![image](https://assets.leetcode.com/users/images/05fb74a2-9f3e-4a3b-ad81-5bf8b63c3791_1633171482.341811.png)\\nThis time we don\\'t neet to set to 0 because in this case we have -4 which means that from this cell to the end point we have to lose 4 health\\n![image](https://assets.leetcode.com/users/images/f4e7cd0e-bf16-4539-adde-cb2a1d484e9d_1633171609.94062.png)\\nmax(right,bottom)\\n![image](https://assets.leetcode.com/users/images/7299fcf3-8b53-446f-b9df-b823689d361e_1633171720.3263557.png)\\n![image](https://assets.leetcode.com/users/images/9f6526e5-0bdd-45c0-9292-1fee25eec2f8_1633171771.464397.png)\\n![image](https://assets.leetcode.com/users/images/a5730df3-bced-48ce-b12d-8388009657ae_1633171811.8350272.png)\\n![image](https://assets.leetcode.com/users/images/414621dc-9402-4fb3-a7c1-616594480f87_1633171914.3503778.png)\\n![image](https://assets.leetcode.com/users/images/f6d6fb12-08cb-4ff0-be8a-89f2b8936dc2_1633172073.7771344.png)\\n![image](https://assets.leetcode.com/users/images/44f17f58-d0f3-47e7-9c34-57b24e865174_1633172170.1919072.png)\\n![image](https://assets.leetcode.com/users/images/12e7e3f5-c0d7-412c-bf08-d0cbc7b0f430_1633172199.5677192.png)\\n**We have to lost at least 6 health to reach the end point.** But remember that we need at least 1health, otherwise the knight dies. So we need to have health that we will lost + 1 = 6 + 1 = 7\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        int m = dungeon.size(), n = dungeon[0].size();\\n\\n        //set the size of dp bigger thatn dungeon (to avoid error when I need d[[i+1][j] or dp[i][j+1])\\n        vector<vector<int>> dp(m + 1, vector<int>(n + 1, INT_MIN));\\n\\n        //initialize the dp[m - 1][n - 1] which is the last value of dungeon\\n        //we have to initialize it because this value is the unique value which you don\\'t need to \"take\" from other\\n        //we just have to take the value that is in dungeon  \\n        dp[m - 1][n - 1] = dungeon[m - 1][n - 1];\\n        if (dp[m - 1][n - 1] > 0)dp[m - 1][n - 1] = 0;\\n\\n        //start to fill the dp\\n        for (int i = m - 1; i >= 0; i--) {\\n            for (int j = n - 1; j >= 0; j--) {\\n                if (i == m - 1 && j == n - 1)continue;\\n                dp[i][j] = max(dp[i][j + 1], dp[i + 1][j]) + dungeon[i][j];\\n                if (dp[i][j] > 0)dp[i][j] = 0;\\n            }\\n        }\\n\\n        //since in dp we saved how many health we spent to arrive to the end point in negative we have to change it in positive\\n        //to make sure that we don\\'t die we need at least 1 health, so health that we have to spent + 1\\n        return (dp[0][0] * -1) + 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        int m = dungeon.size(), n = dungeon[0].size();\\n\\n        //set the size of dp bigger thatn dungeon (to avoid error when I need d[[i+1][j] or dp[i][j+1])\\n        vector<vector<int>> dp(m + 1, vector<int>(n + 1, INT_MIN));\\n\\n        //initialize the dp[m - 1][n - 1] which is the last value of dungeon\\n        //we have to initialize it because this value is the unique value which you don\\'t need to \"take\" from other\\n        //we just have to take the value that is in dungeon  \\n        dp[m - 1][n - 1] = dungeon[m - 1][n - 1];\\n        if (dp[m - 1][n - 1] > 0)dp[m - 1][n - 1] = 0;\\n\\n        //start to fill the dp\\n        for (int i = m - 1; i >= 0; i--) {\\n            for (int j = n - 1; j >= 0; j--) {\\n                if (i == m - 1 && j == n - 1)continue;\\n                dp[i][j] = max(dp[i][j + 1], dp[i + 1][j]) + dungeon[i][j];\\n                if (dp[i][j] > 0)dp[i][j] = 0;\\n            }\\n        }\\n\\n        //since in dp we saved how many health we spent to arrive to the end point in negative we have to change it in positive\\n        //to make sure that we don\\'t die we need at least 1 health, so health that we have to spent + 1\\n        return (dp[0][0] * -1) + 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 404174,
                "title": "easy-python3-solution",
                "content": "Not pretending for unique solution, but I hope that my code will be easy to understand.\\n\\nThe main idea is that we go reversed and compare ``max(1, min(previous_cells_values))``. That\\'s the key. \\n\\nWhy do we compare max with 1? Because we don\\'t need extra 30 hp, only 1 to be alive.\\n\\n\\n```\\nclass Solution:\\n    def calculateMinimumHP(self, dungeon: List[List[int]]) -> int:\\n        \\n        rows, columns = len(dungeon), len(dungeon[0])\\n        hp = [[0]*columns for i in range(rows)]\\n        \\n        \\n        # We will start at endpoint:\\n        hp[-1][-1] = max(1, 1-dungeon[-1][-1]) # in example we will need 6 HP to cover -5 loss\\n        \\n        # Completing the border lines. Excluding endpoint everywhere\\n        for i in range(rows-2, -1,-1):\\n            hp[i][-1] = max(1, \\n                            hp[i+1][-1] - dungeon[i][-1])  \\n        for j in range(columns-2, -1, -1): \\n            hp[-1][j] = max(1, \\n                            hp[-1][j+1] - dungeon[-1][j])\\n        \\n        # print(hp) to see our HealthPoint table\\n        \\n\\t\\t\\n        # Next we complete the remaining table\\n        for i in range(rows-2, -1, -1):\\n            for j in range(columns-2, -1, -1):                \\n                hp[i][j] = max(1, min(hp[i+1][j] - dungeon[i][j], \\n                                      hp[i][j+1] - dungeon[i][j]) )\\n        \\n        return hp[0][0]\\n```\\n\\nRuntime: 80 ms, faster than 89.23% of Python3 online submissions for Dungeon Game.\\nMemory Usage: 15 MB, less than 11.11% of Python3 online submissions for Dungeon Game.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def calculateMinimumHP(self, dungeon: List[List[int]]) -> int:\\n        \\n        rows, columns = len(dungeon), len(dungeon[0])\\n        hp = [[0]*columns for i in range(rows)]\\n        \\n        \\n        # We will start at endpoint:\\n        hp[-1][-1] = max(1, 1-dungeon[-1][-1]) # in example we will need 6 HP to cover -5 loss\\n        \\n        # Completing the border lines. Excluding endpoint everywhere\\n        for i in range(rows-2, -1,-1):\\n            hp[i][-1] = max(1, \\n                            hp[i+1][-1] - dungeon[i][-1])  \\n        for j in range(columns-2, -1, -1): \\n            hp[-1][j] = max(1, \\n                            hp[-1][j+1] - dungeon[-1][j])\\n        \\n        # print(hp) to see our HealthPoint table\\n        \\n\\t\\t\\n        # Next we complete the remaining table\\n        for i in range(rows-2, -1, -1):\\n            for j in range(columns-2, -1, -1):                \\n                hp[i][j] = max(1, min(hp[i+1][j] - dungeon[i][j], \\n                                      hp[i][j+1] - dungeon[i][j]) )\\n        \\n        return hp[0][0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 52857,
                "title": "a-12-ms-c-solution-dp",
                "content": "This problem is quite like #64 Minimum Path Sum.\\n\\nThe trick is where is the Starting point. This problem ask us to find the least hp in top-left. So in the most optimistic situation, bottom-right value can be determined as 1. Then bottom-right is the starting point.\\n\\n    int calculateMinimumHP(vector<vector<int>>& dun) \\n    {\\n    \\tif (!dun.size() || !dun[0].size())\\n    \\t\\treturn 1;\\n    \\tint nrow = dun.size();\\n    \\tint ncol = dun[0].size();\\n    \\tvector<int> row(ncol + 1, INT_MAX);\\n    \\trow[ncol - 1] = 1;\\n    \\tint i, j, t;\\n    \\tfor (i = nrow - 1; i >= 0; --i)\\n    \\t{\\n    \\t\\tfor (j = ncol - 1; j >= 0; --j)\\n    \\t\\t{\\n    \\t\\t\\tt = min(row[j], row[j + 1]) - dun[i][j];\\n    \\t\\t\\trow[j] = max(t, 1); //row[j]=smaller value from below and right, but no smaller than 1.\\n    \\t\\t}\\n    \\t}\\n    \\treturn row[0];\\n    }",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "This problem is quite like #64 Minimum Path Sum.\\n\\nThe trick is where is the Starting point. This problem ask us to find the least hp in top-left. So in the most optimistic situation, bottom-right value can be determined as 1. Then bottom-right is the starting point.\\n\\n    int calculateMinimumHP(vector<vector<int>>& dun) \\n    {\\n    \\tif (!dun.size() || !dun[0].size())\\n    \\t\\treturn 1;\\n    \\tint nrow = dun.size();\\n    \\tint ncol = dun[0].size();\\n    \\tvector<int> row(ncol + 1, INT_MAX);\\n    \\trow[ncol - 1] = 1;\\n    \\tint i, j, t;\\n    \\tfor (i = nrow - 1; i >= 0; --i)\\n    \\t{\\n    \\t\\tfor (j = ncol - 1; j >= 0; --j)\\n    \\t\\t{\\n    \\t\\t\\tt = min(row[j], row[j + 1]) - dun[i][j];\\n    \\t\\t\\trow[j] = max(t, 1); //row[j]=smaller value from below and right, but no smaller than 1.\\n    \\t\\t}\\n    \\t}\\n    \\treturn row[0];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 52899,
                "title": "a-simple-c-solution-using-binary-search",
                "content": "<code> \\n  \\n    class Solution {\\n    public:\\n        int calculateMinimumHP(vector<vector<int> > &dungeon) {\\n            int N = dungeon.size();\\n            int M = dungeon[0].size();\\n    \\n            // just pick a simple path through the dungeon to obtain an upperbound\\n            int lowerbound = 0;\\n            int upperbound = 1;\\n            for (int i = 0; i < M; i++) {\\n                int val = dungeon[0][i];\\n                if (val < 0) upperbound += (-val);\\n            }\\n            for (int i = 0; i < N; i++) {\\n                int val = dungeon[i][M - 1];\\n                if (val < 0) upperbound += (-val);\\n            }\\n    \\n            // A number so small impossible to come back alive from\\n            static const int64_t dead = numeric_limits<int64_t>::min() / 3;\\n    \\n            // Binary search looking for the smallest starting health which we\\n            // survive from. Invariant we maintain is lowerbound dies and\\n            // upperbound survives\\n            while (lowerbound < upperbound - 1) {\\n                int mid = (upperbound - lowerbound) / 2 + lowerbound;\\n    \\n                // create a buffer N + 1 and M + 1 size so we have sentinal values\\n                // padding the first row and column.\\n                auto cur_health = vector<vector<int64_t> >(N + 1);\\n                for (int n = 0; n <= N; n++) {\\n                    cur_health[n].resize(M + 1, dead);\\n                }\\n    \\n                // Seed in our starting health\\n                cur_health[0][1] = cur_health[1][0] = mid;\\n                for (int n = 1; n <= N; n++) {\\n                    for (int m = 1; m <= M; m++) {\\n                        cur_health[n][m] = max(cur_health[n-1][m], cur_health[n][m-1]) + dungeon[n-1][m-1];\\n                        if (cur_health[n][m] < 1) {\\n                            // Once we are dead, ensure we stay dead\\n                            cur_health[n][m] = dead;\\n                        }\\n                    }\\n                }\\n    \\n                // If we have positive health at the end we survived!\\n                if (cur_health[N][M] > 0) {\\n                    upperbound = mid;\\n                } else {\\n                    lowerbound = mid;\\n                }\\n            }\\n            return upperbound;\\n        }\\n    };\\n</code>",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n    public:\\n        int calculateMinimumHP(vector<vector<int> > &dungeon) {\\n            int N = dungeon.size();\\n            int M = dungeon[0].size();\\n    \\n            // just pick a simple path through the dungeon to obtain an upperbound\\n            int lowerbound = 0;\\n            int upperbound = 1;\\n            for (int i = 0; i < M; i++) {\\n                int val = dungeon[0][i];\\n                if (val < 0) upperbound += (-val);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1497653,
                "title": "python-iterative-dp-solution-o-1-space-utilizing-given-matrix",
                "content": "We\\'ll denote the dungeon d.\\nThe intuition for the solution is as such:\\nIf we start at position (m-1, n-1), the amount of hp needed is the maximum between 1 and -d[m-1][n-1] + 1. \\nThis is because if d[m-1][n-1] is negative, we need to sustain the effect of the cell and add 1 so we won\\'t get to 0 hp (hence -d[m-1][n-1] +1). Otherwise, if d[m-1][n-1] isn\\'t negative, we only need 1 hp.\\n\\nIf we start at position (i, j), the amount of hp needed is the maximum between 1 and the minimum between d[i-1][j]-d[i][j] and d[i][j-1]-d[i][j].\\nThis is because we need to sustain the effects of our current cell, as well as add the needs of either the cell below or the cell to the right. We take the minimal between them because we want the minimal required hp.\\n\\nThe solution has O(1) space complexity because we overwrite the given cell\\'s values.\\n\\n```\\ndef calculateMinimumHP(self, d: List[List[int]]) -> int:\\n        m, n = len(d), len(d[0])\\n        for i in range(m-1, -1, -1):\\n            for j in range(n-1, -1, -1):\\n                if i == m-1 and j == n-1:\\n                    d[i][j] = max(1, -d[i][j] + 1)\\n                elif i < m-1 and j < n-1:\\n                    d[i][j] = max(1, min(-d[i][j] + d[i+1][j], -d[i][j] + d[i][j+1]))\\n                elif i < m-1:\\n                    d[i][j] = max(1, -d[i][j] + d[i+1][j])\\n                else:\\n                    d[i][j] = max(1, -d[i][j] + d[i][j+1])\\n        return d[0][0]\\n```\\n\\nHope this helps.",
                "solutionTags": [],
                "code": "```\\ndef calculateMinimumHP(self, d: List[List[int]]) -> int:\\n        m, n = len(d), len(d[0])\\n        for i in range(m-1, -1, -1):\\n            for j in range(n-1, -1, -1):\\n                if i == m-1 and j == n-1:\\n                    d[i][j] = max(1, -d[i][j] + 1)\\n                elif i < m-1 and j < n-1:\\n                    d[i][j] = max(1, min(-d[i][j] + d[i+1][j], -d[i][j] + d[i][j+1]))\\n                elif i < m-1:\\n                    d[i][j] = max(1, -d[i][j] + d[i+1][j])\\n                else:\\n                    d[i][j] = max(1, -d[i][j] + d[i][j+1])\\n        return d[0][0]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 52841,
                "title": "1ms-beat-100-java-dp-memorization-solution",
                "content": "DP + Memorization\\n\\n\\n    public class DungeonGame {\\n        public int calculateMinimumHP(int[][] dungeon) {\\n            if(dungeon == null || dungeon.length == 0 || dungeon[0].length == 0){//[],[[]]\\n                return 0;\\n            }\\n            int[][] flag = new int[dungeon.length][dungeon[0].length];\\n            int min = dfs(dungeon, flag, 0, 0);\\n            return min;\\n        }\\n        \\n        private int dfs(int[][] dungeon, int[][] flag, int x, int y){\\n            if(flag[x][y] != 0){\\n                return flag[x][y];\\n            }\\n            if(x == dungeon.length - 1 && y == dungeon[0].length - 1){//The down-right corner\\n                flag[x][y] = dungeon[x][y] < 0 ? -dungeon[x][y] + 1 : 1; //The minimum is 1\\n                return flag[x][y];\\n            }\\n            int min = Integer.MAX_VALUE;\\n            //go down\\n            if(x < dungeon.length - 1){\\n                int down = dfs(dungeon, flag, x + 1, y);\\n                min = min < down ? min : down; \\n            }\\n            //go right\\n            if(y < dungeon[0].length - 1){\\n                int right = dfs(dungeon, flag, x, y + 1);\\n                min = min < right ? min : right;\\n            }\\n            if(dungeon[x][y] >= min){//If min is 6, dungeon[x][y] if 10, then min should be updated to 1\\n                min = 1;\\n            }else{//If min is 6, dungeon[x][y] is 3 or -3, then min should be updated to 3 or 9\\n                min = min - dungeon[x][y];\\n            }\\n            flag[x][y] = min;\\n            return min;\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "DP + Memorization\\n\\n\\n    public class DungeonGame {\\n        public int calculateMinimumHP(int[][] dungeon) {\\n            if(dungeon == null || dungeon.length == 0 || dungeon[0].length == 0){//[],[[]]\\n                return 0;\\n            }\\n            int[][] flag = new int[dungeon.length][dungeon[0].length];\\n            int min = dfs(dungeon, flag, 0, 0);\\n            return min;\\n        }\\n        \\n        private int dfs(int[][] dungeon, int[][] flag, int x, int y){\\n            if(flag[x][y] != 0){\\n                return flag[x][y];\\n            }\\n            if(x == dungeon.length - 1 && y == dungeon[0].length - 1){//The down-right corner\\n                flag[x][y] = dungeon[x][y] < 0 ? -dungeon[x][y] + 1 : 1; //The minimum is 1\\n                return flag[x][y];\\n            }\\n            int min = Integer.MAX_VALUE;\\n            //go down\\n            if(x < dungeon.length - 1){\\n                int down = dfs(dungeon, flag, x + 1, y);\\n                min = min < down ? min : down; \\n            }\\n            //go right\\n            if(y < dungeon[0].length - 1){\\n                int right = dfs(dungeon, flag, x, y + 1);\\n                min = min < right ? min : right;\\n            }\\n            if(dungeon[x][y] >= min){//If min is 6, dungeon[x][y] if 10, then min should be updated to 1\\n                min = 1;\\n            }else{//If min is 6, dungeon[x][y] is 3 or -3, then min should be updated to 3 or 9\\n                min = min - dungeon[x][y];\\n            }\\n            flag[x][y] = min;\\n            return min;\\n        }\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 698423,
                "title": "c-easy-dp-solution-with-clear-comments-and-example",
                "content": "```\\nclass Solution {\\npublic:\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) { \\n        int m = dungeon.size(), n = dungeon[0].size();\\n\\n        // dp[i][j] means min hp needed at point (i, j) to survive (it cannot be 0 and has to be at least 1 at any point)\\n        vector<vector<int>> dp(m+1, vector<int>(n+1, INT_MAX));     // pad matrix with extra row and column for shorter code\\n        dp[m][n-1] = dp[m-1][n] = 1;\\n\\n        // since we need min hp when starting out (top left), we fill table from bottom right (princess) to top left (knight)\\n        for(int i = m-1; i >= 0; i--) {\\n            for(int j = n-1; j >= 0; j--) {\\n                // at any cell check cell below and on right\\n                int need = min(dp[i+1][j], dp[i][j+1]) - dungeon[i][j];\\n                dp[i][j] = need > 0 ? need : 1;\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n};\\n\\n/*\\n\\n-2  -3  3           7   5   2   \\u221E\\n-5  -10 1   --->    6   11  5   \\u221E\\n10  30  -5          1   1   6   1\\n                    \\u221E   \\u221E   1   \\u221E\\n*/\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) { \\n        int m = dungeon.size(), n = dungeon[0].size();\\n\\n        // dp[i][j] means min hp needed at point (i, j) to survive (it cannot be 0 and has to be at least 1 at any point)\\n        vector<vector<int>> dp(m+1, vector<int>(n+1, INT_MAX));     // pad matrix with extra row and column for shorter code\\n        dp[m][n-1] = dp[m-1][n] = 1;\\n\\n        // since we need min hp when starting out (top left), we fill table from bottom right (princess) to top left (knight)\\n        for(int i = m-1; i >= 0; i--) {\\n            for(int j = n-1; j >= 0; j--) {\\n                // at any cell check cell below and on right\\n                int need = min(dp[i+1][j], dp[i][j+1]) - dungeon[i][j];\\n                dp[i][j] = need > 0 ? need : 1;\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n};\\n\\n/*\\n\\n-2  -3  3           7   5   2   \\u221E\\n-5  -10 1   --->    6   11  5   \\u221E\\n10  30  -5          1   1   6   1\\n                    \\u221E   \\u221E   1   \\u221E\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 698227,
                "title": "my-c-dp-solution-i-think-it-s-easy-to-understand",
                "content": "`dp[i][j]` is the damage from `(i, j)` to `(m-1, n-1)`, and it\\'s a non-positive number. `-dp[i][j]+1` is the minimum health if knight stands on  `(i, j)`.\\n\\nDo dynamic programming from bottom-right to top-left. `-dp[0][0] + 1` is the answer.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        if (dungeon.empty() || dungeon[0].empty()) return 0;  // invalid\\n        int rows = dungeon.size(), cols = dungeon[0].size();\\n        vector<vector<int>> dp(rows, vector<int>(cols, 0));\\n        for (int i=rows-1; i >= 0; --i) {\\n            for (int j=cols-1; j >= 0; --j) {\\n                if (i == rows - 1 && j == cols - 1) {\\n                    dp[i][j] = min(0, dungeon[i][j]);\\n                }\\n                else if (i == rows - 1) {\\n                    dp[i][j] = min(0, dungeon[i][j] + dp[i][j+1]);\\n                }\\n                else if (j == cols - 1) {\\n                    dp[i][j] = min(0, dungeon[i][j] + dp[i+1][j]);\\n                }\\n                else {\\n                    dp[i][j] = min(0, dungeon[i][j] + max(dp[i][j+1], dp[i+1][j]));\\n                }\\n            }\\n        }\\n        return -dp[0][0] + 1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        if (dungeon.empty() || dungeon[0].empty()) return 0;  // invalid\\n        int rows = dungeon.size(), cols = dungeon[0].size();\\n        vector<vector<int>> dp(rows, vector<int>(cols, 0));\\n        for (int i=rows-1; i >= 0; --i) {\\n            for (int j=cols-1; j >= 0; --j) {\\n                if (i == rows - 1 && j == cols - 1) {\\n                    dp[i][j] = min(0, dungeon[i][j]);\\n                }\\n                else if (i == rows - 1) {\\n                    dp[i][j] = min(0, dungeon[i][j] + dp[i][j+1]);\\n                }\\n                else if (j == cols - 1) {\\n                    dp[i][j] = min(0, dungeon[i][j] + dp[i+1][j]);\\n                }\\n                else {\\n                    dp[i][j] = min(0, dungeon[i][j] + max(dp[i][j+1], dp[i+1][j]));\\n                }\\n            }\\n        }\\n        return -dp[0][0] + 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2340111,
                "title": "c-recursive-memoization-tabulation",
                "content": "## **1) RECURSIVE**\\n\\n**Gives TLE\\n41 / 45 test cases passed with this solution**\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int solve(int i, int j, int m , int n, vector<vector<int>> &grid)\\n    {\\n        // if we come out of the grid simply return a large value\\n        if(i >= m || j >= n)\\n            return INT_MAX;\\n        \\n        // calucate health by the 2 possible ways\\n        int down = solve(i + 1, j, m, n, grid);\\n        int right = solve(i, j + 1, m, n, grid);\\n        \\n\\t\\t// take the min both both\\n        int health = min(down, right);\\n        \\n        // we reach the destination when both the sides return INT_MAX\\n        if(health == INT_MAX)\\n        {\\n            health = 1; // both are +ve large integers so min health required = 1\\n        }\\n        \\n        int ans = 0;\\n        if(health - grid[i][j] > 0)\\n        {\\n            ans = health - grid[i][j];\\n        }\\n        else\\n        {\\n            ans = 1;\\n        }\\n             \\n        return ans;\\n    }\\n    \\n    int calculateMinimumHP(vector<vector<int>>& dungeon) \\n    {\\n        int m = dungeon.size();\\n        int n = dungeon[0].size();\\n        \\n        return solve(0, 0, m, n, dungeon);\\n    }\\n};\\n```\\n\\n\\n## **2) MEMOIZATION**\\n\\n**ALL TEST CASES PASSED!** \\uD83E\\uDD73 \\n\\n```\\nclass Solution {\\npublic:\\n    int solve(int i, int j, int m , int n, vector<vector<int>> &grid, vector<vector<int>> &dp)\\n    {\\n        // if we come out of the grid simply return a large value\\n        if(i >= m || j >= n)\\n            return INT_MAX;\\n        \\n        if(dp[i][j] != INT_MAX)\\n            return dp[i][j];\\n        \\n        // calucate health by the 2 possible ways\\n        int down = solve(i + 1, j, m, n, grid, dp);\\n        int right = solve(i, j + 1, m, n, grid, dp);\\n        \\n        int health = min(down, right);\\n        \\n        // we reach the destination when both the sides return INT_MAX\\n        if(health == INT_MAX)\\n        {\\n            health = 1; // both are +ve large integers so min health required = 1\\n        }\\n        \\n        int ans = 0;\\n        if(health - grid[i][j] > 0)\\n        {\\n            ans = health - grid[i][j];\\n        }\\n        else\\n        {\\n            ans = 1;\\n        }\\n             \\n        return dp[i][j] = ans;\\n    }\\n    \\n    int calculateMinimumHP(vector<vector<int>>& dungeon) \\n    {\\n        int m = dungeon.size();\\n        int n = dungeon[0].size();\\n        \\n        vector<vector<int>> dp(m + 1, vector<int> (n + 1, INT_MAX));\\n        \\n        return solve(0, 0, m, n, dungeon, dp);\\n    }\\n};\\n```\\n\\n## **3) TABULATION**\\n\\n**ALL TEST CASES PASSED!** \\uD83E\\uDD73 \\n\\n```\\nclass Solution {\\npublic:    \\n    int calculateMinimumHP(vector<vector<int>>& dungeon) \\n    {\\n        int m = dungeon.size();\\n        int n = dungeon[0].size();\\n        \\n        vector<vector<int>> dp(m + 1, vector<int> (n + 1, INT_MAX));\\n        \\n        for(int i = m - 1; i >= 0; i--)\\n        {\\n            for(int j = n - 1; j >= 0; j--)\\n            {\\n                int right = dp[i + 1][j];\\n                int down = dp[i][j + 1];\\n                \\n                int health = min(down, right);\\n                \\n                // we reach the destination when both the sides return INT_MAX\\n                if(health == INT_MAX)\\n                {\\n                    health = 1; // both are +ve large integers so min health required = 1\\n                }\\n                \\n                int ans = 0;\\n                if(health - dungeon[i][j] > 0)\\n                {\\n                    ans = health - dungeon[i][j];\\n                }\\n                else\\n                {\\n                    ans = 1;\\n                }\\n             \\n                dp[i][j] = ans;\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int i, int j, int m , int n, vector<vector<int>> &grid)\\n    {\\n        // if we come out of the grid simply return a large value\\n        if(i >= m || j >= n)\\n            return INT_MAX;\\n        \\n        // calucate health by the 2 possible ways\\n        int down = solve(i + 1, j, m, n, grid);\\n        int right = solve(i, j + 1, m, n, grid);\\n        \\n\\t\\t// take the min both both\\n        int health = min(down, right);\\n        \\n        // we reach the destination when both the sides return INT_MAX\\n        if(health == INT_MAX)\\n        {\\n            health = 1; // both are +ve large integers so min health required = 1\\n        }\\n        \\n        int ans = 0;\\n        if(health - grid[i][j] > 0)\\n        {\\n            ans = health - grid[i][j];\\n        }\\n        else\\n        {\\n            ans = 1;\\n        }\\n             \\n        return ans;\\n    }\\n    \\n    int calculateMinimumHP(vector<vector<int>>& dungeon) \\n    {\\n        int m = dungeon.size();\\n        int n = dungeon[0].size();\\n        \\n        return solve(0, 0, m, n, dungeon);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int solve(int i, int j, int m , int n, vector<vector<int>> &grid, vector<vector<int>> &dp)\\n    {\\n        // if we come out of the grid simply return a large value\\n        if(i >= m || j >= n)\\n            return INT_MAX;\\n        \\n        if(dp[i][j] != INT_MAX)\\n            return dp[i][j];\\n        \\n        // calucate health by the 2 possible ways\\n        int down = solve(i + 1, j, m, n, grid, dp);\\n        int right = solve(i, j + 1, m, n, grid, dp);\\n        \\n        int health = min(down, right);\\n        \\n        // we reach the destination when both the sides return INT_MAX\\n        if(health == INT_MAX)\\n        {\\n            health = 1; // both are +ve large integers so min health required = 1\\n        }\\n        \\n        int ans = 0;\\n        if(health - grid[i][j] > 0)\\n        {\\n            ans = health - grid[i][j];\\n        }\\n        else\\n        {\\n            ans = 1;\\n        }\\n             \\n        return dp[i][j] = ans;\\n    }\\n    \\n    int calculateMinimumHP(vector<vector<int>>& dungeon) \\n    {\\n        int m = dungeon.size();\\n        int n = dungeon[0].size();\\n        \\n        vector<vector<int>> dp(m + 1, vector<int> (n + 1, INT_MAX));\\n        \\n        return solve(0, 0, m, n, dungeon, dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:    \\n    int calculateMinimumHP(vector<vector<int>>& dungeon) \\n    {\\n        int m = dungeon.size();\\n        int n = dungeon[0].size();\\n        \\n        vector<vector<int>> dp(m + 1, vector<int> (n + 1, INT_MAX));\\n        \\n        for(int i = m - 1; i >= 0; i--)\\n        {\\n            for(int j = n - 1; j >= 0; j--)\\n            {\\n                int right = dp[i + 1][j];\\n                int down = dp[i][j + 1];\\n                \\n                int health = min(down, right);\\n                \\n                // we reach the destination when both the sides return INT_MAX\\n                if(health == INT_MAX)\\n                {\\n                    health = 1; // both are +ve large integers so min health required = 1\\n                }\\n                \\n                int ans = 0;\\n                if(health - dungeon[i][j] > 0)\\n                {\\n                    ans = health - dungeon[i][j];\\n                }\\n                else\\n                {\\n                    ans = 1;\\n                }\\n             \\n                dp[i][j] = ans;\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1206373,
                "title": "c-recursion-memoization-fastest-0ms-beats-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[205][205];\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        memset(dp, -1, sizeof(dp));\\n        return recur(0, 0, dungeon.size(), dungeon[0].size(), dungeon);\\n    }\\n    \\n    long recur(int i, int j, int n, int m, vector<vector<int>>& d){\\n        if(i >= n || j >= m){\\n            return INT_MAX;\\n        }\\n        \\n        if(i == n-1 && j == m-1){\\n            return d[i][j] <= 0 ? abs(d[i][j]) + 1 : 1;\\n        }\\n        \\n        if(dp[i][j] != -1){\\n            return dp[i][j];\\n        }\\n        \\n        int op1 = recur(i+1, j, n, m, d);\\n        int op2 = recur(i, j+1, n, m, d);\\n        \\n        int minHealthRequired = min(op1, op2) - d[i][j];\\n        return dp[i][j] = (minHealthRequired <= 0) ? 1 : minHealthRequired;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[205][205];\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        memset(dp, -1, sizeof(dp));\\n        return recur(0, 0, dungeon.size(), dungeon[0].size(), dungeon);\\n    }\\n    \\n    long recur(int i, int j, int n, int m, vector<vector<int>>& d){\\n        if(i >= n || j >= m){\\n            return INT_MAX;\\n        }\\n        \\n        if(i == n-1 && j == m-1){\\n            return d[i][j] <= 0 ? abs(d[i][j]) + 1 : 1;\\n        }\\n        \\n        if(dp[i][j] != -1){\\n            return dp[i][j];\\n        }\\n        \\n        int op1 = recur(i+1, j, n, m, d);\\n        int op2 = recur(i, j+1, n, m, d);\\n        \\n        int minHealthRequired = min(op1, op2) - d[i][j];\\n        return dp[i][j] = (minHealthRequired <= 0) ? 1 : minHealthRequired;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 699180,
                "title": "top-down-dp-java",
                "content": "simple case of \\n-2, 13 \\n-5, -6 \\n\\nwhen we reach -6(princess), we return Math.abs(6) +1, if it were positive just return 1 \\nbecause we need atleast 1 health in every cell, so if we were going to lose -6 health we should have 7 health atleast.\\n\\nin the recursive tree 7 is returned to -5 and we do Math.max(1, 7-(-5))) and return 12 to -2 \\n\\nsimilarly the recursive tree starting from 13 gives 1  and we pick min(1,12) which is 1 \\nand do Math.max(1,1-(-2)) \\nwhich gives ans = 3\\n\\nlook how 7-13 = -6 but we need atleast 1 health to survive so we return 1 to the parent call saying hey 1 health is enough to reach me.\\n\\nalso we need same i,j in multiple recursive calls so HashMap is used to cache those subproblems.\\n\\n![image](https://assets.leetcode.com/users/images/09d6daf1-9d77-42f5-b865-c4e64f254464_1592774107.280481.png)\\n\\n\\n```\\n public int calculateMinimumHP(int[][] dungeon) {                \\n        Map<String, Integer> cache = new HashMap<>();   \\n        int m = dungeon.length, n = dungeon[0].length; \\n        return dfs(dungeon, 0, 0, cache, m, n);        \\n    }   \\n    \\n    private int dfs(int[][] dungeon, int i, int j, Map<String, Integer> cache, int m, int n) {       \\n        String key = i + \"_\" + j;\\n        if (cache.containsKey(key))\\n            return cache.get(key);\\n        \\n        if (i==m-1 && j==n-1)\\n            return dungeon[i][j]>0 ? 1 : Math.abs(dungeon[i][j]) + 1;\\n        \\n        if (i>=m || j>=n)\\n            return Integer.MAX_VALUE;     \\n        \\n        int rightPath = dfs(dungeon, i, j+1, cache, m, n);\\n        int downPath = dfs(dungeon, i+1, j, cache, m, n);\\n        \\n        int health = Math.max(1, Math.min(rightPath, downPath) - dungeon[i][j]);\\n        \\n        cache.put(key, health);\\n        \\n        return cache.get(key);        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n public int calculateMinimumHP(int[][] dungeon) {                \\n        Map<String, Integer> cache = new HashMap<>();   \\n        int m = dungeon.length, n = dungeon[0].length; \\n        return dfs(dungeon, 0, 0, cache, m, n);        \\n    }   \\n    \\n    private int dfs(int[][] dungeon, int i, int j, Map<String, Integer> cache, int m, int n) {       \\n        String key = i + \"_\" + j;\\n        if (cache.containsKey(key))\\n            return cache.get(key);\\n        \\n        if (i==m-1 && j==n-1)\\n            return dungeon[i][j]>0 ? 1 : Math.abs(dungeon[i][j]) + 1;\\n        \\n        if (i>=m || j>=n)\\n            return Integer.MAX_VALUE;     \\n        \\n        int rightPath = dfs(dungeon, i, j+1, cache, m, n);\\n        int downPath = dfs(dungeon, i+1, j, cache, m, n);\\n        \\n        int health = Math.max(1, Math.min(rightPath, downPath) - dungeon[i][j]);\\n        \\n        cache.put(key, health);\\n        \\n        return cache.get(key);        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 698231,
                "title": "java-dp-solution-explained-o-n-m-time-and-o-m-space",
                "content": "We can iterate from end to the start end keep tracking minimum initial value for each cell.\\n\\n* `dp[n][m] = max(1, 1 - dungeon[n][m]);` For example: if value in cell is positive, we can have `1 hp`, else we should have `1 - dungeon[n][m]` points.\\n* `dp[i][j] = min(max(1, dp[i][j + 1] - dungeon[i][j]), max(1, dp[i+1][j] - dungeon[i][j]));`. We should take best value from bottom or from right\\n\\nSolution runs in `O(n m)` time and uses `O(n m)` space\\n\\n```\\nclass Solution {\\n    public int calculateMinimumHP(int[][] dungeon) {\\n        int n = dungeon.length;\\n        int m = dungeon[0].length;\\n        int[][] dp = new int[n][m];\\n        \\n        for (int i = n - 1; i >= 0; i--) {\\n            for (int j = m - 1; j >= 0; j--) {\\n                if (i + 1 == n && j + 1 == m) {\\n                    dp[i][j] = Math.max(1 - dungeon[i][j], 1);\\n                    continue;\\n                }\\n                \\n                if (i + 1 == n) {\\n                    dp[i][j] = Math.max(dp[i][j + 1] - dungeon[i][j], 1);\\n                } else if (j + 1 == m) {\\n                    dp[i][j] = Math.max(dp[i + 1][j] - dungeon[i][j], 1);\\n                } else {\\n                    int right = Math.max(dp[i][j + 1] - dungeon[i][j], 1);\\n                    int down = Math.max(dp[i + 1][j] - dungeon[i][j], 1);\\n                    dp[i][j] = Math.min(right, down);\\n                }\\n            }\\n        }\\n        \\n        return dp[0][0];\\n    }\\n}\\n```\\n\\nWe can reduce to `O(m)` space. To calculate row `dp[i]` we only need results from `dp[i+1]`, so we can use same array\\n\\n```\\nclass Solution {\\n    public int calculateMinimumHP(int[][] dungeon) {\\n        int n = dungeon.length;\\n        int m = dungeon[0].length;\\n        int[] dp = new int[m];\\n        \\n        for (int i = n - 1; i >= 0; i--) {\\n            for (int j = m - 1; j >= 0; j--) {\\n                if (i + 1 == n && j + 1 == m) {\\n                    dp[j] = Math.max(1 - dungeon[i][j], 1);\\n                    continue;\\n                }\\n                \\n                if (i + 1 == n) {\\n                    dp[j] = Math.max(dp[j + 1] - dungeon[i][j], 1);\\n                } else if (j + 1 == m) {\\n                    dp[j] = Math.max(dp[j] - dungeon[i][j], 1);\\n                } else {\\n                    int right = Math.max(dp[j + 1] - dungeon[i][j], 1);\\n                    int down = Math.max(dp[j] - dungeon[i][j], 1);\\n                    dp[j] = Math.min(right, down);\\n                }\\n            }\\n        }\\n        \\n        return dp[0];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int calculateMinimumHP(int[][] dungeon) {\\n        int n = dungeon.length;\\n        int m = dungeon[0].length;\\n        int[][] dp = new int[n][m];\\n        \\n        for (int i = n - 1; i >= 0; i--) {\\n            for (int j = m - 1; j >= 0; j--) {\\n                if (i + 1 == n && j + 1 == m) {\\n                    dp[i][j] = Math.max(1 - dungeon[i][j], 1);\\n                    continue;\\n                }\\n                \\n                if (i + 1 == n) {\\n                    dp[i][j] = Math.max(dp[i][j + 1] - dungeon[i][j], 1);\\n                } else if (j + 1 == m) {\\n                    dp[i][j] = Math.max(dp[i + 1][j] - dungeon[i][j], 1);\\n                } else {\\n                    int right = Math.max(dp[i][j + 1] - dungeon[i][j], 1);\\n                    int down = Math.max(dp[i + 1][j] - dungeon[i][j], 1);\\n                    dp[i][j] = Math.min(right, down);\\n                }\\n            }\\n        }\\n        \\n        return dp[0][0];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int calculateMinimumHP(int[][] dungeon) {\\n        int n = dungeon.length;\\n        int m = dungeon[0].length;\\n        int[] dp = new int[m];\\n        \\n        for (int i = n - 1; i >= 0; i--) {\\n            for (int j = m - 1; j >= 0; j--) {\\n                if (i + 1 == n && j + 1 == m) {\\n                    dp[j] = Math.max(1 - dungeon[i][j], 1);\\n                    continue;\\n                }\\n                \\n                if (i + 1 == n) {\\n                    dp[j] = Math.max(dp[j + 1] - dungeon[i][j], 1);\\n                } else if (j + 1 == m) {\\n                    dp[j] = Math.max(dp[j] - dungeon[i][j], 1);\\n                } else {\\n                    int right = Math.max(dp[j + 1] - dungeon[i][j], 1);\\n                    int down = Math.max(dp[j] - dungeon[i][j], 1);\\n                    dp[j] = Math.min(right, down);\\n                }\\n            }\\n        }\\n        \\n        return dp[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1879082,
                "title": "c-very-very-easy-simple-9-line-code-tc-o-n-m-sc-o-1",
                "content": "#### *Please Upvote if it helps\\u2B06\\uFE0F*\\n```\\n\\tint calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        int n=dungeon.size(),m=dungeon[0].size();\\n        for(int i=n-1;i>=0;--i){\\n            for(int j=m-1;j>=0;--j){\\n                if(i==n-1 && j==m-1) dungeon[i][j]=dungeon[i][j];\\n                else if(i==n-1) dungeon[i][j]+=dungeon[i][j+1];\\n                else if(j==m-1) dungeon[i][j]+=dungeon[i+1][j];\\n                else dungeon[i][j]+=max(dungeon[i][j+1],dungeon[i+1][j]);\\n                \\n                if(dungeon[i][j]>0) dungeon[i][j]=0;\\n            }\\n        }\\n        return abs(dungeon[0][0])+1;\\n    }",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "#### *Please Upvote if it helps\\u2B06\\uFE0F*\\n```\\n\\tint calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        int n=dungeon.size(),m=dungeon[0].size();\\n        for(int i=n-1;i>=0;--i){\\n            for(int j=m-1;j>=0;--j){\\n                if(i==n-1 && j==m-1) dungeon[i][j]=dungeon[i][j];\\n                else if(i==n-1) dungeon[i][j]+=dungeon[i][j+1];\\n                else if(j==m-1) dungeon[i][j]+=dungeon[i+1][j];\\n                else dungeon[i][j]+=max(dungeon[i][j+1],dungeon[i+1][j]);\\n                \\n                if(dungeon[i][j]>0) dungeon[i][j]=0;\\n            }\\n        }\\n        return abs(dungeon[0][0])+1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 982750,
                "title": "lol-beat-5-dp-binary-search-solution",
                "content": "Apparently there are better solutions out there but I found this one interesting when I saw the tag for the problem is DP + Binary Search. \\n\\nBasically, we can try all the possible health values to find the minimal viable health value. To make it faster, we know the upper bound needed for health is the negate of the sum of all the negative values in the dungeon - 1. Then we can use binary search to find the minimal viable health value, ranging from 1 to upper_bound. \\nuse DP to figure out given a particular health value, if it is viable to get to the princess. \\n\\nThis passes the OJ although it is pretty slow. It is fun ;) \\n\\n```\\nclass Solution(object):\\n    def calculateMinimumHP(self, dungeon):\\n        \"\"\"\\n        :type dungeon: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        upper_bound = sum([value for row in dungeon for value in row if value < 0]) - 1\\n        \\n        def isViable(health):\\n            dp = [[float(\\'-inf\\')] * len(dungeon[0]) for _ in range(len(dungeon))]\\n            \\n            for i in range(len(dp)):\\n                for j in range(len(dp[0])):\\n                    if i == 0 and j == 0:\\n                        dp[i][j] = health + dungeon[i][j]\\n                    elif i == 0:\\n                        dp[i][j] = dp[i][j-1] + dungeon[i][j]\\n                    elif j == 0:\\n                        dp[i][j] = dp[i-1][j] + dungeon[i][j]\\n                    else:\\n                        dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + dungeon[i][j]\\n                    \\n                    if dp[i][j] <= 0:\\n                        dp[i][j] = float(\\'-inf\\')\\n                                        \\n            return dp[-1][-1] != float(\\'-inf\\')\\n    \\n        l, r = 1, abs(upper_bound)\\n        while l < r:\\n            mid = l + (r-l) // 2\\n            viable = isViable(mid)\\n            if viable:\\n                r = mid\\n            else:\\n                l = mid + 1\\n        \\n        return r\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def calculateMinimumHP(self, dungeon):\\n        \"\"\"\\n        :type dungeon: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        upper_bound = sum([value for row in dungeon for value in row if value < 0]) - 1\\n        \\n        def isViable(health):\\n            dp = [[float(\\'-inf\\')] * len(dungeon[0]) for _ in range(len(dungeon))]\\n            \\n            for i in range(len(dp)):\\n                for j in range(len(dp[0])):\\n                    if i == 0 and j == 0:\\n                        dp[i][j] = health + dungeon[i][j]\\n                    elif i == 0:\\n                        dp[i][j] = dp[i][j-1] + dungeon[i][j]\\n                    elif j == 0:\\n                        dp[i][j] = dp[i-1][j] + dungeon[i][j]\\n                    else:\\n                        dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + dungeon[i][j]\\n                    \\n                    if dp[i][j] <= 0:\\n                        dp[i][j] = float(\\'-inf\\')\\n                                        \\n            return dp[-1][-1] != float(\\'-inf\\')\\n    \\n        l, r = 1, abs(upper_bound)\\n        while l < r:\\n            mid = l + (r-l) // 2\\n            viable = isViable(mid)\\n            if viable:\\n                r = mid\\n            else:\\n                l = mid + 1\\n        \\n        return r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 52920,
                "title": "share-my-c-dp-solution-with-explanation",
                "content": "###dp[i][j] means start from point (i,j) end at point (n-1,m-1) need at least dp[i][j] health.###\\n***dp[i][j] = min(  max( dp[i+1][j] - dungeon[i][j], 1),\\n                       max( dp[i][j+1] - dungeon[i][j], 1) );***\\n\\n\\n\\n\\n    class Solution { \\n    public:\\n        int calculateMinimumHP(vector<vector<int> > &dungeon) {\\n            int n = dungeon.size();\\n            int m = dungeon[0].size();\\n            int dp[n][m];\\n            memset(dp,0,sizeof(dp));\\n            for(int i=n-1;i>=0;--i){\\n                for(int j=m-1; j>=0; --j){\\n                    if(i+1==n && j+1 == m){\\n                        dp[i][j] = max(1-dungeon[i][j],1);\\n                        continue;\\n                    }\\n                    if(j+1<m){\\n                        dp[i][j] = max(dp[i][j+1] - dungeon[i][j],1);\\n                    }\\n                    if(i+1<n){\\n                        if(dp[i][j])\\n                            dp[i][j] = min(dp[i][j],max(dp[i+1][j] - dungeon[i][j],1));\\n                        else \\n                            dp[i][j] = max(dp[i+1][j]-dungeon[i][j],1);\\n                    }\\n                }\\n            }\\n    \\n            return dp[0][0];\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution { \\n    public:\\n        int calculateMinimumHP(vector<vector<int> > &dungeon) {\\n            int n = dungeon.size();\\n            int m = dungeon[0].size();\\n            int dp[n][m];\\n            memset(dp,0,sizeof(dp));\\n            for(int i=n-1;i>=0;--i){\\n                for(int j=m-1; j>=0; --j){\\n                    if(i+1==n && j+1 == m){\\n                        dp[i][j] = max(1-dungeon[i][j],1);\\n                        continue;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 2303535,
                "title": "c-challenge-most-simple-intuitive",
                "content": "# **If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n```\\nclass Solution {\\n    int n, m;\\n    int dfs(int x, int y, vector<vector<int>>& nums, vector<vector<int>> &dp)\\n    {\\n        if(x >= n || x < 0 || y >= m || y < 0)\\n            return INT_MIN;\\n        if(x == n-1 && y == m-1) return nums[x][y];\\n        if(dp[x][y] != -1) return  dp[x][y];\\n        int ans = nums[x][y];\\n        int val = nums[x][y]+max(dfs(x+1, y, nums, dp), dfs(x, y+1, nums, dp));\\n        return dp[x][y] = min(ans, val);\\n    }\\npublic:\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        n = dungeon.size();\\n        m = dungeon[0].size();\\n        vector<vector<int>> dp(n+1, vector<int> (m+1, -1));\\n        int val = dfs(0, 0, dungeon, dp);\\n        if(val >= 0)\\n            return 1;\\n        else\\n        {\\n            val = -1*val;\\n            return val + 1;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int n, m;\\n    int dfs(int x, int y, vector<vector<int>>& nums, vector<vector<int>> &dp)\\n    {\\n        if(x >= n || x < 0 || y >= m || y < 0)\\n            return INT_MIN;\\n        if(x == n-1 && y == m-1) return nums[x][y];\\n        if(dp[x][y] != -1) return  dp[x][y];\\n        int ans = nums[x][y];\\n        int val = nums[x][y]+max(dfs(x+1, y, nums, dp), dfs(x, y+1, nums, dp));\\n        return dp[x][y] = min(ans, val);\\n    }\\npublic:\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        n = dungeon.size();\\n        m = dungeon[0].size();\\n        vector<vector<int>> dp(n+1, vector<int> (m+1, -1));\\n        int val = dfs(0, 0, dungeon, dp);\\n        if(val >= 0)\\n            return 1;\\n        else\\n        {\\n            val = -1*val;\\n            return val + 1;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1498834,
                "title": "c-dp-with-explanation-in-depth",
                "content": "\\tdp[i][j] represents the minimum amount of health i should have when i enter the cell (i, j) in order to reach the bottom-right cell\\n\\t\\t\\tso i assume that the right and bottom values are already known , so my conditin reduces to the following \\n        \\n        x represents the answer for the current cell (dp[i][j] (the minimum health i need to have before entering this cell, for me to reach the destination))\\n        \\n        the change in my health after entering the cell (i, j) will be : x + dungeon[i][j] \\n         x + dp[i][j] is the amount of health that i will have after i enter this cell\\n        \\n          if i want to enter the cell (i+1, j) (below cell)\\n          as per the state of the dp, i should have a health at least dp[i+1][j] before entering the cell (i+1, j)\\n          also, x + dungeon[i][j] is the amount of health i will be left with after entering the cell (i ,j)\\n          \\n          so x + dungeon[i][j] >= dp[i+1][j]\\n            => x >= dp[i+1][j] - dungeon[i][j]\\n            \\n            as i need the limiting case x = dp[i+1][j] - dungeon[i][j]\\n            \\n            \\n          we can carry out the same analysis for the cell (i , j+1)\\n          \\n            this will yield x = dp[i][j+1] - dungeon[i][j]\\n            \\n            the minimum value of the above two will be taken \\n            \\n            in case x turns out to be negative, it just means that dungeon[i][j] is greater than dp[i][j+1], which just means that the health \\n            i am going to pick up at this point is greater than what i need to complete the task starting from the next cell, so even if i dont have any energy i can win, but as per the problem statement, the minimum health should be one\\n            \\n            so in case the answer for any cell turns out to be negative, just fill it with 1\\n            \\n            so the final equation reduces to \\n            \\n                dp[i][j] = min(dp[i+1][j] - dungeon[i][j], dp[i][j+1] - dungeon[i][j]);\\n        \\n```\\nclass Solution {\\npublic:\\n\\tint dirs[2][2] = {{0, 1}, {1, 0}};\\n\\tint calculateMinimumHP(vector<vector<int>>& b) {\\n\\t\\tint r = b.size();\\n\\t\\tint c = b[0].size();\\n    \\n\\t\\tvector<vector<int>> dp(r, vector<int>(c, INT_MAX));\\n   \\n\\t\\t// dp[r - 1][c - 1] = b[r - 1][c - 1] <= 0 ? -b[r - 1][c - 1] + 1 : 1;\\n\\t\\t\\n\\t\\tdp[r-1][c-1] = max(1, 1 - b[r-1][c-1]);\\n\\n\\n\\t\\tfor (int i = r - 1; i >= 0; i--)\\n\\t\\t{\\n\\t\\t\\tfor (int j = c - 1; j >= 0; j--) {\\n\\t\\t\\t\\tif (i == r - 1 && j == c - 1) continue;\\n\\n\\t\\t\\t\\tfor (auto d : dirs) {\\n\\t\\t\\t\\t\\tint ni = i + d[0];\\n\\t\\t\\t\\t\\tint nj = j + d[1];\\n\\n\\t\\t\\t\\t\\tif (ni >= 0 &&  ni < r && nj >= 0 && nj < c) {\\n\\n\\t\\t\\t\\t\\t\\tdp[i][j] = max(min(dp[ni][nj] - b[i][j] , dp[i][j]), 1);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn dp[0][0];\\n\\t}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n\\tint dirs[2][2] = {{0, 1}, {1, 0}};\\n\\tint calculateMinimumHP(vector<vector<int>>& b) {\\n\\t\\tint r = b.size();\\n\\t\\tint c = b[0].size();\\n    \\n\\t\\tvector<vector<int>> dp(r, vector<int>(c, INT_MAX));\\n   \\n\\t\\t// dp[r - 1][c - 1] = b[r - 1][c - 1] <= 0 ? -b[r - 1][c - 1] + 1 : 1;\\n\\t\\t\\n\\t\\tdp[r-1][c-1] = max(1, 1 - b[r-1][c-1]);\\n\\n\\n\\t\\tfor (int i = r - 1; i >= 0; i--)\\n\\t\\t{\\n\\t\\t\\tfor (int j = c - 1; j >= 0; j--) {\\n\\t\\t\\t\\tif (i == r - 1 && j == c - 1) continue;\\n\\n\\t\\t\\t\\tfor (auto d : dirs) {\\n\\t\\t\\t\\t\\tint ni = i + d[0];\\n\\t\\t\\t\\t\\tint nj = j + d[1];\\n\\n\\t\\t\\t\\t\\tif (ni >= 0 &&  ni < r && nj >= 0 && nj < c) {\\n\\n\\t\\t\\t\\t\\t\\tdp[i][j] = max(min(dp[ni][nj] - b[i][j] , dp[i][j]), 1);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn dp[0][0];\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1498373,
                "title": "python-easy-top-down-solution-memoization-and-detailed-explanation-which-is-easy-to-follow",
                "content": "```\\nclass Solution:\\n    def calculateMinimumHP(self, dungeon: List[List[int]]) -> int:\\n        m,n = len(dungeon), len(dungeon[0])\\n        \\n        # cache the states\\n        @lru_cache(None)\\n        def dp(x,y):\\n            \\n            # FOR BASE CASE:\\n            if x == m-1 and y==n-1:\\n                # if last element is negative, then i\\'ve to be one more than its abs value\\n                # else if its positive, i\\'ve to be 1 because that\\'s the least health i can have\\n                return max(1, -dungeon[x][y] + 1)\\n            \\n            # FOR THE CURRENT STATE I\\'M IN i.e., (x,y):\\n            \\n            # initially set answer to infinity for the (x,y) state that we\\'ll find out\\n            ans = float(\"inf\")\\n            \\n            # there are two moves possible, \\n            # so get answers from both the directions i.e., left and down\\n            # take the minimum answer from both of them in each direction\\n            \\n            # DOWN:\\n            if x+1 < m:\\n                ans = min(ans, dp(x+1, y))\\n            # LEFT:\\n            if y+1 < n:\\n                ans = min(ans, dp(x, y+1))\\n                \\n            # now you\\'ve the minimum answer required to go to left or down, \\n            # so we now calculate the total answer required by considering the state we are \\n            # currently in\\n            \\n            # since you are currently at a point, you\\'d have to add the negative of current value \\n            # to simulate the value i should have before hand to enter this current point\\n            # so negate the value and add (subracting basically)\\n            \\n            # for example if current value is -6 then i need 7 to come to this point\\n            # but if the current value is 8 then i virtually need 0 to come to this point\\n            \\n            ans += -dungeon[x][y]\\n            \\n            # again if your ans is +ve, then it means you\\'d need atleast *ans* health to enter \\n            # this current point\\n            # else if its negative, then it means you actually need no health to even enter because \\n            # of the positive orbs in the subsequent points.\\n            # so since i added the negative, i need to return the max of 1 and the ans at the end\\n            return max(1, ans)\\n            \\n        # start the recursion from top\\n        return dp(0,0)\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def calculateMinimumHP(self, dungeon: List[List[int]]) -> int:\\n        m,n = len(dungeon), len(dungeon[0])\\n        \\n        # cache the states\\n        @lru_cache(None)\\n        def dp(x,y):\\n            \\n            # FOR BASE CASE:\\n            if x == m-1 and y==n-1:\\n                # if last element is negative, then i\\'ve to be one more than its abs value\\n                # else if its positive, i\\'ve to be 1 because that\\'s the least health i can have\\n                return max(1, -dungeon[x][y] + 1)\\n            \\n            # FOR THE CURRENT STATE I\\'M IN i.e., (x,y):\\n            \\n            # initially set answer to infinity for the (x,y) state that we\\'ll find out\\n            ans = float(\"inf\")\\n            \\n            # there are two moves possible, \\n            # so get answers from both the directions i.e., left and down\\n            # take the minimum answer from both of them in each direction\\n            \\n            # DOWN:\\n            if x+1 < m:\\n                ans = min(ans, dp(x+1, y))\\n            # LEFT:\\n            if y+1 < n:\\n                ans = min(ans, dp(x, y+1))\\n                \\n            # now you\\'ve the minimum answer required to go to left or down, \\n            # so we now calculate the total answer required by considering the state we are \\n            # currently in\\n            \\n            # since you are currently at a point, you\\'d have to add the negative of current value \\n            # to simulate the value i should have before hand to enter this current point\\n            # so negate the value and add (subracting basically)\\n            \\n            # for example if current value is -6 then i need 7 to come to this point\\n            # but if the current value is 8 then i virtually need 0 to come to this point\\n            \\n            ans += -dungeon[x][y]\\n            \\n            # again if your ans is +ve, then it means you\\'d need atleast *ans* health to enter \\n            # this current point\\n            # else if its negative, then it means you actually need no health to even enter because \\n            # of the positive orbs in the subsequent points.\\n            # so since i added the negative, i need to return the max of 1 and the ans at the end\\n            return max(1, ans)\\n            \\n        # start the recursion from top\\n        return dp(0,0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 417313,
                "title": "7-liner-python-solution-48ms-javascript-solution-56ms-java-solution-1ms",
                "content": "dp[r][c]: min health required to reach bottom right\\n\\n**Python(48ms)**\\n```\\nclass Solution(object):\\n    def calculateMinimumHP(self, dungeon):\\n\\t\\tnrows, ncols = len(dungeon), len(dungeon[0])\\n        dp = [[float(\\'inf\\')]*(ncols+1) for _ in range(nrows+1)]\\n        dp[nrows-1][ncols] = dp[nrows][ncols-1] = 1\\n        for r in range(nrows-1, -1, -1):\\n            for c in range(ncols-1, -1, -1):\\n                dp[r][c] = max(1, min(dp[r+1][c], dp[r][c+1]) - dungeon[r][c])\\n        return dp[0][0]\\n```\\n\\n**JavaScript(56ms)**\\n```\\n/**\\n * @param {number[][]} dungeon\\n * @return {number}\\n */\\nvar calculateMinimumHP = function(dungeon) {\\n    var nrows = dungeon.length;\\n    var ncols = dungeon[0].length;\\n    \\n    var dp = [];\\n    for (var r=0; r<nrows+1; r++) {\\n        dp[r] = [];\\n        for (var c=0;c<ncols+1;c++) {\\n            dp[r][c] = Number.MAX_SAFE_INTEGER;\\n        }\\n    }\\n    dp[nrows-1][ncols] = dp[nrows][ncols-1] = 1;\\n    \\n    for (var r=nrows-1;r>=0;r--) {\\n        for (var c=ncols-1;c>=0;c--) {\\n            dp[r][c] = Math.max(1, Math.min(dp[r+1][c], dp[r][c+1])-dungeon[r][c]);\\n        }\\n    }\\n    return dp[0][0];\\n};\\n```\\n\\n**Java(1ms)**\\n```\\nclass Solution {\\n    public int calculateMinimumHP(int[][] dungeon) {\\n        int nrows = dungeon.length;\\n        int ncols = dungeon[0].length;\\n        int[][] dp = new int[nrows+1][ncols+1];\\n        for(int[] r:dp){\\n            Arrays.fill(r, Integer.MAX_VALUE);\\n        }\\n        dp[nrows-1][ncols] = dp[nrows][ncols-1] = 1;\\n        for(int r=nrows-1;r>=0;r--){\\n            for(int c=ncols-1;c>=0;c--){\\n                dp[r][c] = Math.max(1, Math.min(dp[r+1][c], dp[r][c+1])-dungeon[r][c]);\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution(object):\\n    def calculateMinimumHP(self, dungeon):\\n\\t\\tnrows, ncols = len(dungeon), len(dungeon[0])\\n        dp = [[float(\\'inf\\')]*(ncols+1) for _ in range(nrows+1)]\\n        dp[nrows-1][ncols] = dp[nrows][ncols-1] = 1\\n        for r in range(nrows-1, -1, -1):\\n            for c in range(ncols-1, -1, -1):\\n                dp[r][c] = max(1, min(dp[r+1][c], dp[r][c+1]) - dungeon[r][c])\\n        return dp[0][0]\\n```\n```\\n/**\\n * @param {number[][]} dungeon\\n * @return {number}\\n */\\nvar calculateMinimumHP = function(dungeon) {\\n    var nrows = dungeon.length;\\n    var ncols = dungeon[0].length;\\n    \\n    var dp = [];\\n    for (var r=0; r<nrows+1; r++) {\\n        dp[r] = [];\\n        for (var c=0;c<ncols+1;c++) {\\n            dp[r][c] = Number.MAX_SAFE_INTEGER;\\n        }\\n    }\\n    dp[nrows-1][ncols] = dp[nrows][ncols-1] = 1;\\n    \\n    for (var r=nrows-1;r>=0;r--) {\\n        for (var c=ncols-1;c>=0;c--) {\\n            dp[r][c] = Math.max(1, Math.min(dp[r+1][c], dp[r][c+1])-dungeon[r][c]);\\n        }\\n    }\\n    return dp[0][0];\\n};\\n```\n```\\nclass Solution {\\n    public int calculateMinimumHP(int[][] dungeon) {\\n        int nrows = dungeon.length;\\n        int ncols = dungeon[0].length;\\n        int[][] dp = new int[nrows+1][ncols+1];\\n        for(int[] r:dp){\\n            Arrays.fill(r, Integer.MAX_VALUE);\\n        }\\n        dp[nrows-1][ncols] = dp[nrows][ncols-1] = 1;\\n        for(int r=nrows-1;r>=0;r--){\\n            for(int c=ncols-1;c>=0;c--){\\n                dp[r][c] = Math.max(1, Math.min(dp[r+1][c], dp[r][c+1])-dungeon[r][c]);\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2546206,
                "title": "java-bottom-up-easy-completely-explained",
                "content": "```\\nclass Solution {\\n    public int calculateMinimumHP(int[][] dungeon) {\\n\\n    // if power required to reach a cell is positive then we place zero there instead of the positive number\\n   // this is to calculate the max negative number we should tackle during the path and we only take the negative value\\n        int r = dungeon.length;\\n        int c = dungeon[0].length;\\n        int [][] dp = new int[r][c];\\n        \\n        for(int i= r-1; i>=0;i--)\\n        {\\n            for(int j= c-1; j>=0;j--)\\n            {\\n\\t\\t\\t// for where the princess is located, if negative value then take the negative value else if positive then take zero\\n                if(i==r-1 && j==c-1)// princess is located\\n                {\\n                    dp[i][j]= Math.min(0,dungeon[i][j] );\\n                }\\n                   // last row move right and check and follow the same process as above  i. e add the value first of the dungeon matrix first and check\\n\\t\\t\\t\\t   // if positive or negative and process as above\\n                else if(i== r-1) // last row\\n                {\\n                    dp[i][j] = Math.min(0, dungeon[i][j] + dp[i][j+1]);\\n                }\\n                // same as above\\n                 else if(j == c-1) // last column\\n                {\\n                    dp[i][j] = Math.min(0, dungeon[i][j] + dp[i+1][j]);\\n                }\\n                // for choosing between down and right direction get the max value as we need the max negative value for the knight to safely travel\\n\\t\\t\\t\\t// and process the whole as same as above \\n                else \\n                {\\n                    dp[i][j] = Math.min(0, dungeon[i][j] + Math.max(dp[i][j+1], dp[i+1][j]));\\n                }\\n            \\n            }\\n        }\\n         return Math.abs(dp[0][0]) +1;                                  \\n  }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int calculateMinimumHP(int[][] dungeon) {\\n\\n    // if power required to reach a cell is positive then we place zero there instead of the positive number\\n   // this is to calculate the max negative number we should tackle during the path and we only take the negative value\\n        int r = dungeon.length;\\n        int c = dungeon[0].length;\\n        int [][] dp = new int[r][c];\\n        \\n        for(int i= r-1; i>=0;i--)\\n        {\\n            for(int j= c-1; j>=0;j--)\\n            {\\n\\t\\t\\t// for where the princess is located, if negative value then take the negative value else if positive then take zero\\n                if(i==r-1 && j==c-1)// princess is located\\n                {\\n                    dp[i][j]= Math.min(0,dungeon[i][j] );\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1445373,
                "title": "c-brute-force-thinking-choose-maximum-energy-path",
                "content": "Just a brute force thinking , choose maximum energy path\\n```\\n\\nint calculateMinimumHP(vector<vector<int>>& v) {\\n        int n = v.size() , m = v[0].size();\\n        int dp[n][m];\\n\\t\\t//dp[i][j] denotes nothing but sum of the min energy requriment to reach goal with just 0 energy\\n\\t\\t//will add 1 later for the condition\\n\\t\\t\\n\\t\\t//intialisation\\n        dp[n-1][m-1] = v[n-1][m-1];\\n        for(int i=n-2;i>=0;i--)\\n        {\\n\\t\\t//will take neg or max 0 value of ahead nodes as we need to maintain minimum 0 energy at every cell\\n            dp[i][m-1] = min(0,dp[i+1][m-1])+v[i][m-1];\\n        }\\n        for(int i=m-2;i>=0;i--)\\n        {\\n            dp[n-1][i] = min(0,dp[n-1][i+1])+v[n-1][i];\\n        }\\n        \\n\\t\\t\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            for(int j=m-2;j>=0;j--)\\n            {\\n\\t\\t\\t  // just simply will check which of two dirction cell have maximum energy to go\\n                dp[i][j] = v[i][j] + max(min(0,dp[i+1][j]), min(0,dp[i][j+1]));\\n            }\\n        }\\n        \\n\\t\\t//will return minimum energy rrequirement > 0  add 1 for condition\\n        return max(0,-1 * dp[0][0])+1;\\n        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\nint calculateMinimumHP(vector<vector<int>>& v) {\\n        int n = v.size() , m = v[0].size();\\n        int dp[n][m];\\n\\t\\t//dp[i][j] denotes nothing but sum of the min energy requriment to reach goal with just 0 energy\\n\\t\\t//will add 1 later for the condition\\n\\t\\t\\n\\t\\t//intialisation\\n        dp[n-1][m-1] = v[n-1][m-1];\\n        for(int i=n-2;i>=0;i--)\\n        {\\n\\t\\t//will take neg or max 0 value of ahead nodes as we need to maintain minimum 0 energy at every cell\\n            dp[i][m-1] = min(0,dp[i+1][m-1])+v[i][m-1];\\n        }\\n        for(int i=m-2;i>=0;i--)\\n        {\\n            dp[n-1][i] = min(0,dp[n-1][i+1])+v[n-1][i];\\n        }\\n        \\n\\t\\t\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            for(int j=m-2;j>=0;j--)\\n            {\\n\\t\\t\\t  // just simply will check which of two dirction cell have maximum energy to go\\n                dp[i][j] = v[i][j] + max(min(0,dp[i+1][j]), min(0,dp[i][j+1]));\\n            }\\n        }\\n        \\n\\t\\t//will return minimum energy rrequirement > 0  add 1 for condition\\n        return max(0,-1 * dp[0][0])+1;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1362586,
                "title": "python-simple-dijkstra-with-explanation-and-visuals",
                "content": "---------------------------------------------------------------------------------\\n# [2] Dijktsra | 60 ms, faster than 99.19% of Python3\\n---------------------------------------------------------------------------------\\n     \\n- What is the **minimum initial health** required for the knight to survive the journey (aka. **bare minimum health points**)?\\n- The **bare minimum health points** corresponds with the **healthiest path (aka. most energy preserving path)**\\n- To achive the healthiest path, the knight needs to constantly choose:\\n\\t-  the cell that consumes the least energy of all available cells (aka. the cell with the least powerful demon)**\\n\\t-  or even better, **choose cells that provides the knight with more energy (aka. cells containing magical orbs)**. \\n-  This behaviour can be achived with **Dijsktra\\'s algortihm with a maximum heap** as our frontier for exploring the grid.\\n- Dijkstra\\'s algortihm will surely spit out the best path, however, we still need an additional step.\\n-  We need to examine the optimal path and look at our knight\\'s health at each step along the journey. The lowest health points is the worst health condition that our knight had to endure during the journey. That value should be the basis upon which the minimum initial health is to be calculated.\\n\\n\\n\\t`minimum initial health points required = worst( best( all paths ) ) + 1`\\n\\n- We could have attempted to find the most optimal (healthiest path) via: DFS or a greedy search, however, Dijkstra is faster than brute-force DFS and more stable than heuristic/greedy (aka. guaranteed correctness)\\n\\n\\n![image](https://assets.leetcode.com/users/images/9c2a3756-470a-4540-a0ee-77d97a21e554_1638648477.109243.png)\\n\\n\\n```\\ndef calculateMinimumHP(self, dungeon: List[List[int]]) -> int:\\n\\tgrid = dungeon\\n\\ttrgtX, trgtY = len(grid)-1, len(grid[0])-1\\n\\n\\tif trgtX == trgtY == 0:\\n\\t\\tif grid[0][0] > 0:\\n\\t\\t\\treturn 1\\n\\t\\telse:\\n\\t\\t\\treturn abs(grid[0][0])+1\\n\\n\\th = []\\n\\tfrom heapq import heappush, heappop\\n\\n\\tstartNode = (-1*grid[0][0], (0,0)) # max heap to give priority to least cost \\n\\theappush(h, startNode) \\n\\tdirs = [(1,0), (0,1)]\\n\\tcost_so_far = {(0,0): grid[0][0]}\\n\\n\\tlowestHealth = max(0, -grid[0][0]) # --- NOTE [1] \\n\\n\\twhile h:\\n\\t\\tcost, node = heappop(h)\\n\\t\\tx, y = node\\n\\n\\t\\tlowestHealth = max(cost, neededHealth) # --- NOTE [2]\\n\\n\\t\\tif (x,y) == (trgtX, trgtY):\\n\\t\\t\\tbreak\\n\\n\\t\\tfor dir in dirs:\\n\\t\\t\\tnewX, newY = x+dir[0], y+dir[1]\\n\\t\\t\\tif newX <= len(grid)-1 and newY <= len(grid[0])-1:\\n\\t\\t\\t\\tedgeCost = -1*grid[newX][newY]\\n\\t\\t\\t\\tnewCost = cost + edgeCost\\n\\t\\t\\t\\tif (newX, newY) not in cost_so_far or ( (newX, newY) in cost_so_far and cost_so_far[(newX, newY)] > newCost ):\\n\\t\\t\\t\\t\\tcost_so_far[(newX, newY)] = newCost\\n\\t\\t\\t\\t\\theappush(h, ((newCost, (newX, newY))))\\n\\n\\t# print(cost_so_far)\\n\\t# return cost_so_far[(trgtX, trgtY)] + 1\\n\\treturn lowestHealth + 1  # ----- NOTE [3]\\n\\n\\n\\t# NOTE [1]\\n\\t# -------\\n\\t# if 0,0 cell is +ve -> then starting value of lowest health = 0\\n\\t# if 0,0 cell is -ve -> starting value of lowest health = the +ve value of grid[0][0])\\n\\t\\n\\t# lowestHealth = max(0, -grid[0][0])  \\n\\t\\n\\t# -- OR --\\n\\t\\n\\t# lowestHealth = 0\\n        if grid[0][0] < 0:\\n            lowestHealth = abs(grid[0][0])\\n\\t\\t\\t\\n\\t# if value of cell is +ve -> i don\\'t need health points\\n\\t# neededHealth is always going to be a +ve number\\n\\t# we need to do this because initialHeath has to be determined based on\\n\\t# ->   the highest damage encountered along the way\\n\\t# ->   not the the overall pathCost by the time we reach target\\n\\n\\t# we could have used DFS with a reqular stack and we wouldve arrived to the solution (slower)\\n\\t# Disjktra is to speed up the search while making sure optimality is gauaranteed\\n\\t# pure greedy is not gauarnteed\\n\\n\\t# NOTE [2]\\n\\t# ---------\\n\\t# We use max() bcuz our heap is a max-heap (costs are with opp sign) (by taking max() \\n\\t# -> we are in reality choosing the lowest health points)\\n\\t\\n\\t\\n\\t\\n\\t# NOTE [3]\\n\\t# --------\\n\\t# If at any point his health point drops to 0 or below, he dies immediately.\\n\\t# neededhealth is either a:\\n\\t#   a) optimal pathCost is +ve -> zero ->                but we add 1 because min allowed health points = 1 (otherwise knight dies)  \\n\\t#   b) optimal pathCost is -ve -> abs(that -ve value) -> but we add 1 to stay above 0 by the time we reach the princess at the end of the quest\\n```\\n\\n---------------------------------------------------------------------------------\\n# [1] DP (Bottom up) | 68 ms, faster than 90.49% of Python3\\n---------------------------------------------------------------------------------\\n\\n\\n```\\ndef calculateMinimumHP(self, dungeon: List[List[int]]) -> int:\\n\\tgrid = dungeon\\n\\tm, n = len(grid), len(grid[0])\\n\\tfor i in range(m-1, -1, -1):\\n\\t\\tfor j in range(n-1, -1, -1):\\n\\n\\t\\t\\tif i == m-1 and j == n-1:\\n\\t\\t\\t\\tif grid[i][j] < 0:\\n\\t\\t\\t\\t\\tgrid[i][j] = abs(1-grid[i][j])\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tgrid[i][j] = 1\\n\\n\\t\\t\\telif i == m-1:\\n\\t\\t\\t\\tif grid[i][j+1] > grid[i][j]:\\n\\t\\t\\t\\t\\tgrid[i][j] = grid[i][j+1] - grid[i][j]\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tgrid[i][j] = 1\\n\\n\\t\\t\\telif j == n-1:\\n\\t\\t\\t\\tif grid[i+1][j] > grid[i][j]:\\n\\t\\t\\t\\t\\tgrid[i][j] = grid[i+1][j] - grid[i][j]\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tgrid[i][j] = 1\\n\\n\\t\\t\\telse:\\n\\t\\t\\t\\tif grid[i][j+1] > grid[i][j] and grid[i+1][j] > grid[i][j]:\\n\\t\\t\\t\\t\\tgrid[i][j] = min(grid[i][j+1], grid[i+1][j]) - grid[i][j]\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tgrid[i][j] = 1\\n\\n\\treturn grid[0][0]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef calculateMinimumHP(self, dungeon: List[List[int]]) -> int:\\n\\tgrid = dungeon\\n\\ttrgtX, trgtY = len(grid)-1, len(grid[0])-1\\n\\n\\tif trgtX == trgtY == 0:\\n\\t\\tif grid[0][0] > 0:\\n\\t\\t\\treturn 1\\n\\t\\telse:\\n\\t\\t\\treturn abs(grid[0][0])+1\\n\\n\\th = []\\n\\tfrom heapq import heappush, heappop\\n\\n\\tstartNode = (-1*grid[0][0], (0,0)) # max heap to give priority to least cost \\n\\theappush(h, startNode) \\n\\tdirs = [(1,0), (0,1)]\\n\\tcost_so_far = {(0,0): grid[0][0]}\\n\\n\\tlowestHealth = max(0, -grid[0][0]) # --- NOTE [1] \\n\\n\\twhile h:\\n\\t\\tcost, node = heappop(h)\\n\\t\\tx, y = node\\n\\n\\t\\tlowestHealth = max(cost, neededHealth) # --- NOTE [2]\\n\\n\\t\\tif (x,y) == (trgtX, trgtY):\\n\\t\\t\\tbreak\\n\\n\\t\\tfor dir in dirs:\\n\\t\\t\\tnewX, newY = x+dir[0], y+dir[1]\\n\\t\\t\\tif newX <= len(grid)-1 and newY <= len(grid[0])-1:\\n\\t\\t\\t\\tedgeCost = -1*grid[newX][newY]\\n\\t\\t\\t\\tnewCost = cost + edgeCost\\n\\t\\t\\t\\tif (newX, newY) not in cost_so_far or ( (newX, newY) in cost_so_far and cost_so_far[(newX, newY)] > newCost ):\\n\\t\\t\\t\\t\\tcost_so_far[(newX, newY)] = newCost\\n\\t\\t\\t\\t\\theappush(h, ((newCost, (newX, newY))))\\n\\n\\t# print(cost_so_far)\\n\\t# return cost_so_far[(trgtX, trgtY)] + 1\\n\\treturn lowestHealth + 1  # ----- NOTE [3]\\n\\n\\n\\t# NOTE [1]\\n\\t# -------\\n\\t# if 0,0 cell is +ve -> then starting value of lowest health = 0\\n\\t# if 0,0 cell is -ve -> starting value of lowest health = the +ve value of grid[0][0])\\n\\t\\n\\t# lowestHealth = max(0, -grid[0][0])  \\n\\t\\n\\t# -- OR --\\n\\t\\n\\t# lowestHealth = 0\\n        if grid[0][0] < 0:\\n            lowestHealth = abs(grid[0][0])\\n\\t\\t\\t\\n\\t# if value of cell is +ve -> i don\\'t need health points\\n\\t# neededHealth is always going to be a +ve number\\n\\t# we need to do this because initialHeath has to be determined based on\\n\\t# ->   the highest damage encountered along the way\\n\\t# ->   not the the overall pathCost by the time we reach target\\n\\n\\t# we could have used DFS with a reqular stack and we wouldve arrived to the solution (slower)\\n\\t# Disjktra is to speed up the search while making sure optimality is gauaranteed\\n\\t# pure greedy is not gauarnteed\\n\\n\\t# NOTE [2]\\n\\t# ---------\\n\\t# We use max() bcuz our heap is a max-heap (costs are with opp sign) (by taking max() \\n\\t# -> we are in reality choosing the lowest health points)\\n\\t\\n\\t\\n\\t\\n\\t# NOTE [3]\\n\\t# --------\\n\\t# If at any point his health point drops to 0 or below, he dies immediately.\\n\\t# neededhealth is either a:\\n\\t#   a) optimal pathCost is +ve -> zero ->                but we add 1 because min allowed health points = 1 (otherwise knight dies)  \\n\\t#   b) optimal pathCost is -ve -> abs(that -ve value) -> but we add 1 to stay above 0 by the time we reach the princess at the end of the quest\\n```\n```\\ndef calculateMinimumHP(self, dungeon: List[List[int]]) -> int:\\n\\tgrid = dungeon\\n\\tm, n = len(grid), len(grid[0])\\n\\tfor i in range(m-1, -1, -1):\\n\\t\\tfor j in range(n-1, -1, -1):\\n\\n\\t\\t\\tif i == m-1 and j == n-1:\\n\\t\\t\\t\\tif grid[i][j] < 0:\\n\\t\\t\\t\\t\\tgrid[i][j] = abs(1-grid[i][j])\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tgrid[i][j] = 1\\n\\n\\t\\t\\telif i == m-1:\\n\\t\\t\\t\\tif grid[i][j+1] > grid[i][j]:\\n\\t\\t\\t\\t\\tgrid[i][j] = grid[i][j+1] - grid[i][j]\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tgrid[i][j] = 1\\n\\n\\t\\t\\telif j == n-1:\\n\\t\\t\\t\\tif grid[i+1][j] > grid[i][j]:\\n\\t\\t\\t\\t\\tgrid[i][j] = grid[i+1][j] - grid[i][j]\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tgrid[i][j] = 1\\n\\n\\t\\t\\telse:\\n\\t\\t\\t\\tif grid[i][j+1] > grid[i][j] and grid[i+1][j] > grid[i][j]:\\n\\t\\t\\t\\t\\tgrid[i][j] = min(grid[i][j+1], grid[i+1][j]) - grid[i][j]\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tgrid[i][j] = 1\\n\\n\\treturn grid[0][0]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1116248,
                "title": "c-dp-recursion-memonization-bottom-up-with-explanation",
                "content": "```\\n/*\\n * TopDown Approach or Recursive Solution\\n *\\n * The solution is to find the minimum health that is required by knight to save Queen\\n * If incase the kinight and Queen at the same point in the dungeon, then to save Queen\\n * the knight requires\\n * For Eg: [[-3]] or [[3]] ie.., Knight and Queen are same point\\n *     . If there is a demons, then the health required is min 4, so that Knight can fight\\n *        with daemon and save the queen i.e.., 4 - 3 = 1\\n *     . If there a magic orbs, then health is required is min 1 bcz knight should be alive\\n *       to save the queen.\\n *\\n *  From above it is clear that min health needed is 1 and in case of dameon it is\\n *             1 + abs(dameon health) => 1 -(dameon health)\\n *\\n *  In general health = std::max(1, 1-value at gird) if both queen and Knigth at same position\\n\\n * The Knight can only have two ways to go from top to botomm either right or down ie.., there\\n * will 2 subproblems for each problem.\\n * Starting at index 0,0 to m-1, n-1\\n *\\n *                     (0,0)\\n *                       |\\n *            ------------------------\\n *           |                        |\\n *         (1,0)                     (0,1)\\n *           |\\n *     -------------\\n *    |             |\\n *  (2,0)          (1,1)\\n *\\n * ie..,\\n * std::max(1, min(calcminHealth(row+1, col), calcminHealth(row, col+1)) - grid[row][col])\\n *\\n * Base cases:\\n * If the row and column reaches queen, then the result will be -current + 1 if there is a\\n * demon else 1.\\n * If the row reaches the tail, then knight can only move right\\n * If the col reaches the tail, then knight can only move down\\n *\\n */\\nint calculateMinHP(vector<vector<int>>& d, int row, int col) {\\n\\tif (row >= d.size() - 1 && col >= d[row].size() - 1) {\\n\\t\\t// Both Knight and Queen are at same position, then min health required is\\n\\t\\t// 1 -(dameon health) or 1 if dameon or magic orb is present at that grid\\n\\t\\treturn d[row][col] < 0 ? 1 - d[row][col] : 1;\\n\\t}\\n\\n\\tif (col == d[row].size() - 1) {\\n\\t\\t// knight reaches end of the columns in a row, it can move only down\\n\\t\\treturn std::max(1, calculateMinHP(d, row + 1, col) - d[row][col]);\\n\\t}\\n\\n\\tif (row == d.size() - 1) {\\n\\t\\t// Knight reaches the end of the row in column, it can only move right\\n\\t\\treturn std::max(1, calculateMinHP(d, row, col + 1) - d[row][col]);\\n\\t}\\n\\n\\t// Else Knight can move either down or right\\n\\treturn std::max(1, std::min(calculateMinHP(d, row + 1, col),\\n\\t\\t                        calculateMinHP(d, row, col + 1)) - d[row][col]);\\n}\\n\\nint calculateMinimumHP(vector<vector<int>>& dungeon) {\\n\\treturn calculateMinHP(dungeon, 0, 0);\\n}\\n\\t/*\\n     * CalculateMinHealth BottomUp solution\\n     * Since there are many overlapping subproblems in Recursive solution, and the\\n     * Solution for the main problem can ba attained if there are solutions for\\n     * suproblems, Dynamic Programming can be applied.\\n     *\\n     * Dynamic Programming Bottom up solution, conditions are similar to recursive\\n     * but the intemediate results are stored in a dp table. Bottom up is to find\\n     * bottom solutions first to yield the top solution i.e.., solution of the problem\\n     *\\n     * As there are 2 subproblems for each problem i.e.., one can move to either\\n     * Right or Bottom the solution from row & col is\\n     *    dp[row][col] = max(1, min(dp[row-1][col], dp[row][col-1]) - d[row][col])\\n     *\\n     * If the Knight and Queen are at end, then\\n     *    dp[m-1][n-1] = d[m-1][n-1] > 0 ? 1 : 1 - d[m-1][n-1]\\n     *\\n     */\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        if (dungeon.empty()) {\\n            // If the dungeon is empty, return zero\\n            return 0;\\n        }\\n\\n        int m = dungeon.size();\\n        int n = dungeon[0].size();\\n        // dp array to store the cummulative sum of each subproblem\\n        vector<vector<int>> dp(m, vector<int>(n, 0));\\n\\n        // If the knight and Queen are at the end ie.., last cell\\n        dp[m - 1][n - 1] = dungeon[m - 1][n - 1] > 0 ? 1 : 1 - dungeon[m - 1][n - 1];\\n\\n        // fill last column cell only\\n        for (int i = m - 2; i >= 0; i--) {\\n            dp[i][n - 1] = std::max(1, dp[i + 1][n - 1] - dungeon[i][n - 1]);\\n        }\\n\\n        // fill last row cell only\\n        for (int j = n - 2; j >= 0; j--) {\\n            dp[m - 1][j] = std::max(1, dp[m - 1][j + 1] - dungeon[m - 1][j]);\\n        }\\n\\n        for (int i = m - 2; i >= 0; i--) {\\n            for (int j = n - 2; j >= 0; j--) {\\n                dp[i][j] = std::max(1,\\n                    std::min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j]);\\n            }\\n        }\\n\\n        return dp[0][0];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n * TopDown Approach or Recursive Solution\\n *\\n * The solution is to find the minimum health that is required by knight to save Queen\\n * If incase the kinight and Queen at the same point in the dungeon, then to save Queen\\n * the knight requires\\n * For Eg: [[-3]] or [[3]] ie.., Knight and Queen are same point\\n *     . If there is a demons, then the health required is min 4, so that Knight can fight\\n *        with daemon and save the queen i.e.., 4 - 3 = 1\\n *     . If there a magic orbs, then health is required is min 1 bcz knight should be alive\\n *       to save the queen.\\n *\\n *  From above it is clear that min health needed is 1 and in case of dameon it is\\n *             1 + abs(dameon health) => 1 -(dameon health)\\n *\\n *  In general health = std::max(1, 1-value at gird) if both queen and Knigth at same position\\n\\n * The Knight can only have two ways to go from top to botomm either right or down ie.., there\\n * will 2 subproblems for each problem.\\n * Starting at index 0,0 to m-1, n-1\\n *\\n *                     (0,0)\\n *                       |\\n *            ------------------------\\n *           |                        |\\n *         (1,0)                     (0,1)\\n *           |\\n *     -------------\\n *    |             |\\n *  (2,0)          (1,1)\\n *\\n * ie..,\\n * std::max(1, min(calcminHealth(row+1, col), calcminHealth(row, col+1)) - grid[row][col])\\n *\\n * Base cases:\\n * If the row and column reaches queen, then the result will be -current + 1 if there is a\\n * demon else 1.\\n * If the row reaches the tail, then knight can only move right\\n * If the col reaches the tail, then knight can only move down\\n *\\n */\\nint calculateMinHP(vector<vector<int>>& d, int row, int col) {\\n\\tif (row >= d.size() - 1 && col >= d[row].size() - 1) {\\n\\t\\t// Both Knight and Queen are at same position, then min health required is\\n\\t\\t// 1 -(dameon health) or 1 if dameon or magic orb is present at that grid\\n\\t\\treturn d[row][col] < 0 ? 1 - d[row][col] : 1;\\n\\t}\\n\\n\\tif (col == d[row].size() - 1) {\\n\\t\\t// knight reaches end of the columns in a row, it can move only down\\n\\t\\treturn std::max(1, calculateMinHP(d, row + 1, col) - d[row][col]);\\n\\t}\\n\\n\\tif (row == d.size() - 1) {\\n\\t\\t// Knight reaches the end of the row in column, it can only move right\\n\\t\\treturn std::max(1, calculateMinHP(d, row, col + 1) - d[row][col]);\\n\\t}\\n\\n\\t// Else Knight can move either down or right\\n\\treturn std::max(1, std::min(calculateMinHP(d, row + 1, col),\\n\\t\\t                        calculateMinHP(d, row, col + 1)) - d[row][col]);\\n}\\n\\nint calculateMinimumHP(vector<vector<int>>& dungeon) {\\n\\treturn calculateMinHP(dungeon, 0, 0);\\n}\\n\\t/*\\n     * CalculateMinHealth BottomUp solution\\n     * Since there are many overlapping subproblems in Recursive solution, and the\\n     * Solution for the main problem can ba attained if there are solutions for\\n     * suproblems, Dynamic Programming can be applied.\\n     *\\n     * Dynamic Programming Bottom up solution, conditions are similar to recursive\\n     * but the intemediate results are stored in a dp table. Bottom up is to find\\n     * bottom solutions first to yield the top solution i.e.., solution of the problem\\n     *\\n     * As there are 2 subproblems for each problem i.e.., one can move to either\\n     * Right or Bottom the solution from row & col is\\n     *    dp[row][col] = max(1, min(dp[row-1][col], dp[row][col-1]) - d[row][col])\\n     *\\n     * If the Knight and Queen are at end, then\\n     *    dp[m-1][n-1] = d[m-1][n-1] > 0 ? 1 : 1 - d[m-1][n-1]\\n     *\\n     */\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        if (dungeon.empty()) {\\n            // If the dungeon is empty, return zero\\n            return 0;\\n        }\\n\\n        int m = dungeon.size();\\n        int n = dungeon[0].size();\\n        // dp array to store the cummulative sum of each subproblem\\n        vector<vector<int>> dp(m, vector<int>(n, 0));\\n\\n        // If the knight and Queen are at the end ie.., last cell\\n        dp[m - 1][n - 1] = dungeon[m - 1][n - 1] > 0 ? 1 : 1 - dungeon[m - 1][n - 1];\\n\\n        // fill last column cell only\\n        for (int i = m - 2; i >= 0; i--) {\\n            dp[i][n - 1] = std::max(1, dp[i + 1][n - 1] - dungeon[i][n - 1]);\\n        }\\n\\n        // fill last row cell only\\n        for (int j = n - 2; j >= 0; j--) {\\n            dp[m - 1][j] = std::max(1, dp[m - 1][j + 1] - dungeon[m - 1][j]);\\n        }\\n\\n        for (int i = m - 2; i >= 0; i--) {\\n            for (int j = n - 2; j >= 0; j--) {\\n                dp[i][j] = std::max(1,\\n                    std::min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j]);\\n            }\\n        }\\n\\n        return dp[0][0];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 698800,
                "title": "c-2d-dp-slightly-easier-alternative-approach-bottom-up-12-ms-explained",
                "content": "Every post on here uses DP rather non-intuitively (for me). I made it a simpler solution with different logic.\\n\\nHere we try to obtain the lowest value along the chosen path and ensure that our life will be >0 at that point.\\nOur metric for the best path is one on which the lowest value at any point is maximum.\\n\\nOur DP table tries to ascertain that if we started at (i, j), what would be the lowest life in the best path from (i, j) to P.\\n\\nThe logic:\\nLets consider an array [1, 2, -5, 3, 4] representing a path. Consider array [-5, 3, 4] where the lowest life is -5, if we started with 0 life right before jumping into it. If we add another number making it [2, -5, 3, 4], we raise the \"life-sum\" at each point in [-5,3,4] by 2 points. Therefore, the point of lowest life will still remain the same in [-5, 3, 4] except the lowest life is raised by 2 points(= -3).\\nBUT lowest life for the whole array may occur at [2] itself. Thus we need to find the minimum between [2](=2) and jumping into [-5,3,4] with 2 initially (=-3). Thus the minimization is as follows:\\n\\n```\\ndp[i][j] = min(dungeon[i][j],  dungeon[i][j] + lowest in the further path)\\n```\\n\\nWe need to optimize paths too(which is the maximum of the two options right and down). Thus:\\n\\n```\\ndp[i][j] = min(dungeon[i][j], dungeon[i][j] + max(dp[i+1][j], dp[i][j+1]));\\n```\\n\\nFurther if the lowest we go in the most optimum path is >0, then we need only 1 life. Otherwise, we return:\\n```\\n1 + (-dp[0][0]);\\n```\\nMy AC code:\\n```\\nclass Solution {\\npublic:\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        if(dungeon.size()==0){\\n            return 0;\\n        }\\n        int m = dungeon.size();\\n        int n = dungeon[0].size();\\n        vector<vector<int>> dp(m,vector<int>(n));\\n        dp[m-1][n-1] = dungeon[m-1][n-1];\\n        for(int i=m-2;i>=0;i--){\\n            dp[i][n-1] = min(dungeon[i][n-1], dungeon[i][n-1] + dp[i+1][n-1]);\\n        }\\n        for(int i=n-2;i>=0;i--){\\n            dp[m-1][i] = min(dungeon[m-1][i], dungeon[m-1][i] + dp[m-1][i+1]);\\n        }\\n        for(int i=m-2;i>=0;i--){\\n            for(int j=n-2;j>=0;j--){\\n                dp[i][j] = min(dungeon[i][j], dungeon[i][j] + max(dp[i+1][j], dp[i][j+1]));\\n            }\\n        }\\n        return 1 + max(-dp[0][0], 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\ndp[i][j] = min(dungeon[i][j],  dungeon[i][j] + lowest in the further path)\\n```\n```\\ndp[i][j] = min(dungeon[i][j], dungeon[i][j] + max(dp[i+1][j], dp[i][j+1]));\\n```\n```\\n1 + (-dp[0][0]);\\n```\n```\\nclass Solution {\\npublic:\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        if(dungeon.size()==0){\\n            return 0;\\n        }\\n        int m = dungeon.size();\\n        int n = dungeon[0].size();\\n        vector<vector<int>> dp(m,vector<int>(n));\\n        dp[m-1][n-1] = dungeon[m-1][n-1];\\n        for(int i=m-2;i>=0;i--){\\n            dp[i][n-1] = min(dungeon[i][n-1], dungeon[i][n-1] + dp[i+1][n-1]);\\n        }\\n        for(int i=n-2;i>=0;i--){\\n            dp[m-1][i] = min(dungeon[m-1][i], dungeon[m-1][i] + dp[m-1][i+1]);\\n        }\\n        for(int i=m-2;i>=0;i--){\\n            for(int j=n-2;j>=0;j--){\\n                dp[i][j] = min(dungeon[i][j], dungeon[i][j] + max(dp[i+1][j], dp[i][j+1]));\\n            }\\n        }\\n        return 1 + max(-dp[0][0], 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 447899,
                "title": "python-straightforward-memoization",
                "content": "```python\\ndef calculateMinimumHP(self, dungeon: List[List[int]]) -> int:\\n\\tm, n = len(dungeon), len(dungeon[0])\\n\\t# returns minimum possible amount of health required at position (i, j)\\n\\tdef calculate(i, j):\\n\\t\\tif i == m or j == n:\\n\\t\\t\\treturn float(\\'inf\\')\\n\\t\\telif i == m-1 and j == n-1:\\n\\t\\t\\treturn max(1,  1 - dungeon[i][j])\\n\\t\\telif (i, j) in memory:\\n\\t\\t\\treturn memory[i, j]\\n\\t\\tdown = calculate(i+1, j) # min health required to go down and survive\\n\\t\\tright = calculate(i, j+1) # min health required to go right and survive\\n\\t\\tcur = min(max(down - dungeon[i][j], 1), max(right - dungeon[i][j], 1))\\n\\t\\tmemory[i, j] = cur\\n\\t\\treturn cur\\n\\tmemory = {}\\n\\treturn calculate(0, 0)\\n```",
                "solutionTags": [],
                "code": "```python\\ndef calculateMinimumHP(self, dungeon: List[List[int]]) -> int:\\n\\tm, n = len(dungeon), len(dungeon[0])\\n\\t# returns minimum possible amount of health required at position (i, j)\\n\\tdef calculate(i, j):\\n\\t\\tif i == m or j == n:\\n\\t\\t\\treturn float(\\'inf\\')\\n\\t\\telif i == m-1 and j == n-1:\\n\\t\\t\\treturn max(1,  1 - dungeon[i][j])\\n\\t\\telif (i, j) in memory:\\n\\t\\t\\treturn memory[i, j]\\n\\t\\tdown = calculate(i+1, j) # min health required to go down and survive\\n\\t\\tright = calculate(i, j+1) # min health required to go right and survive\\n\\t\\tcur = min(max(down - dungeon[i][j], 1), max(right - dungeon[i][j], 1))\\n\\t\\tmemory[i, j] = cur\\n\\t\\treturn cur\\n\\tmemory = {}\\n\\treturn calculate(0, 0)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 376060,
                "title": "java-100-dp-top-down-bottom-up-space-optimzied",
                "content": "```\\nThis question is extension of https://leetcode.com/problems/minimum-path-sum/\\n```\\n\\nWe\\'ll apply same logic as above question. Lets first understand the algorithm.\\n\\n In order to find the minimum health that  knight should have, is all depends how he is able to reach at the Princes.\\n  In case we need to find a number that make sure knight should alive at the end, then we can assign any big number\\n  that is enough to reach from (0,0) to (m-1,n-1)\\n  \\n  Since we need to find `\\'minimum\\'` health to be, we need to traverse back from princes (m-1,n-1)  to (0,0)\\n  and see, what is the minimum value expected to be.\\n  Example:\\n  \\n        -2 (K)\\t    -3\\t    3\\n        -5\\t        -10\\t    1\\n         10\\t        30\\t   -5 (P)\\n\\n  -5 -> 1 -> 3 -> -3 -> -2 = -6 means with health 6, knight will reach prices but he\\'ll get die as health become zero. Hence answer is 7\\n  \\n```\\n  -8, -6, 3\\n   2, 8, -10\\n  -8,-12,-6\\n```\\n  -6 -> -10 -> 8 -> 2 -> -8 = -14 => 15 is our answer\\n  \\n  Hence, we need to see the optimal path from bottom-to-top. \\n  \\n```\\n minHealth(i, j)  = Min ( minHealth(i+1,j), minHealth(i,j+1) )  - grid[i][j]\\nreturn minHealth[i][j] <= 0 ? 1 : minHealth[i][j]  {power-ups}\\n\\nBase case: When there is only one cell, and you are at princes. \\nThen if grid[m-1][n-1] > 0 Means you don\\'t need extra health, as no one is proteting princies {but has power-ups} Hence \\'1\\'\\notherwise -grid[m-1][n-1] +1 because at least that much blood will be taken by that guard. \\n\\n```\\n\\n\\n**Top - Down implemenation **\\n* Runtime: 0 ms, faster than 100.00% of Java online submissions for Dungeon Game.\\n * Memory Usage: 36.2 MB, less than 100.00% of Java online submissions for Dungeon Game.\\n \\n```\\npublic int calculateMinimumHP(int[][] dungeon) {\\n        if (dungeon == null || dungeon.length == 0 || dungeon[0].length == 0)\\n            return 0;\\n\\n        int m = dungeon.length;\\n        int n = dungeon[0].length;\\n        int dp[][] = new int[m][n];\\n\\n        //when you are at princes . m-1,n-1\\n        dp[m - 1][n - 1] = dungeon[m - 1][n - 1] >= 0 ? 1 : -dungeon[m - 1][n - 1] + 1;\\n\\n        return calculateMinimumHP(dungeon, 0, 0, dp);\\n\\n\\n    }\\n\\n    private int calculateMinimumHP(int[][] dungeon, int i, int j, int[][] dp) {\\n        if (i >= dungeon.length || j >= dungeon[0].length)\\n            return Integer.MAX_VALUE;\\n\\n        if (dp[i][j] != 0)\\n            return dp[i][j];\\n\\n\\n        int down = calculateMinimumHP(dungeon, i + 1, j, dp);\\n        int right = calculateMinimumHP(dungeon, i, j + 1, dp);\\n\\n        int min = Math.min(down, right);\\n\\n\\n        final int hp = min - dungeon[i][j];\\n\\n        dp[i][j] = hp <= 0 ? 1 : hp;\\n\\n\\n        return dp[i][j];\\n    }\\n```\\n\\n\\nTranslate above to Bottom up dp\\n```\\ndp[i][j] Minimum health by coming from either [i+1][j] or [i][j+1]\\ndp[i][j] = {    dungeon[i][j] > 0 ? 1 : -dungeon[i][j] + 1; ; i==m-1, j==n-1\\n\\t\\t\\t\\t\\tMin{dp[i+1][j] , dp[i][j+1]} - grid[i][j] ; i < m-1 && j<n-1;\\n\\t\\t\\t\\t\\tdp[i][j+1] - grid[i][j] ; i==m-1 && j<n-1\\n\\t\\t\\t\\t\\tdp[i + 1][j] - dungeon[i][j];  j == n-1; i<m-1\\n\\t\\t\\t\\t\\t\\ndp[i][j] <= 0 ? 1 : dp[i][j]\\n\\nSolution dp[0][0]\\n```\\n * Runtime: 2 ms, faster than 47.89% of Java online submissions for Dungeon Game.\\n * Memory Usage: 42.5 MB, less than 58.82% of Java online submissions for Dungeon Game.\\n```\\n public int calculateMinimumHP(int[][] dungeon) {\\n        if (dungeon == null || dungeon.length == 0 || dungeon[0].length == 0)\\n            return 0;\\n\\n        int m = dungeon.length;\\n        int n = dungeon[0].length;\\n        int dp[][] = new int[m][n];\\n\\n        for (int i = m - 1; i >= 0; i--) {\\n\\n            for (int j = n - 1; j >= 0; j--) {\\n\\n                //when you are at princes . m-1,n-1\\n                if (i == m - 1 && j == n - 1)\\n                    dp[i][j] = dungeon[i][j] > 0 ? 1 : -dungeon[i][j] + 1;\\n                else if (i == m - 1)\\n                    dp[i][j] = dp[i][j + 1] - dungeon[i][j];\\n                else if (j == n - 1)\\n                    dp[i][j] = dp[i + 1][j] - dungeon[i][j];\\n                else {\\n\\n                    dp[i][j] = Math.min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j];\\n                }\\n\\n                dp[i][j] = dp[i][j] <= 0 ? 1 : dp[i][j];\\n\\n            }\\n        }\\n\\n        return dp[0][0];\\n    }\\n```\\n\\nSpace optimization:\\n * Only two rows are used at a time\\n```\\n  dp[i+1][j] => dp[j]\\n  dp[i][j+1] => dp[j+1]\\n```\\n\\n * Runtime: 1 ms, faster than 96.34% of Java online submissions for Dungeon Game.\\n * Memory Usage: 42.3 MB, less than 58.82% of Java online submissions for Dungeon Game.\\n \\n```\\npublic int calculateMinimumHP(int[][] dungeon) {\\n        if (dungeon == null || dungeon.length == 0 || dungeon[0].length == 0)\\n            return 0;\\n\\n        int m = dungeon.length;\\n        int n = dungeon[0].length;\\n        int dp[] = new int[n];\\n\\n        for (int i = m - 1; i >= 0; i--) {\\n\\n            for (int j = n - 1; j >= 0; j--) {\\n\\n                //when you are at princes . m-1,n-1\\n                if (i == m - 1 && j == n - 1)\\n                    dp[j] = dungeon[i][j] > 0 ? 1 : -dungeon[i][j] + 1;\\n                else if (i == m - 1)\\n                    dp[j] = dp[j + 1] - dungeon[i][j];\\n                else if (j == n - 1)\\n                    dp[j] = dp[j] - dungeon[i][j];\\n                else {\\n\\n                    dp[j] = Math.min(dp[j], dp[j + 1]) - dungeon[i][j];\\n                }\\n\\n                dp[j] = dp[j] <= 0 ? 1 : dp[j];\\n\\n            }\\n        }\\n\\n        return dp[0];\\n    }\\n\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nThis question is extension of https://leetcode.com/problems/minimum-path-sum/\\n```\n```\\n  -8, -6, 3\\n   2, 8, -10\\n  -8,-12,-6\\n```\n```\\n minHealth(i, j)  = Min ( minHealth(i+1,j), minHealth(i,j+1) )  - grid[i][j]\\nreturn minHealth[i][j] <= 0 ? 1 : minHealth[i][j]  {power-ups}\\n\\nBase case: When there is only one cell, and you are at princes. \\nThen if grid[m-1][n-1] > 0 Means you don\\'t need extra health, as no one is proteting princies {but has power-ups} Hence \\'1\\'\\notherwise -grid[m-1][n-1] +1 because at least that much blood will be taken by that guard. \\n\\n```\n```\\npublic int calculateMinimumHP(int[][] dungeon) {\\n        if (dungeon == null || dungeon.length == 0 || dungeon[0].length == 0)\\n            return 0;\\n\\n        int m = dungeon.length;\\n        int n = dungeon[0].length;\\n        int dp[][] = new int[m][n];\\n\\n        //when you are at princes . m-1,n-1\\n        dp[m - 1][n - 1] = dungeon[m - 1][n - 1] >= 0 ? 1 : -dungeon[m - 1][n - 1] + 1;\\n\\n        return calculateMinimumHP(dungeon, 0, 0, dp);\\n\\n\\n    }\\n\\n    private int calculateMinimumHP(int[][] dungeon, int i, int j, int[][] dp) {\\n        if (i >= dungeon.length || j >= dungeon[0].length)\\n            return Integer.MAX_VALUE;\\n\\n        if (dp[i][j] != 0)\\n            return dp[i][j];\\n\\n\\n        int down = calculateMinimumHP(dungeon, i + 1, j, dp);\\n        int right = calculateMinimumHP(dungeon, i, j + 1, dp);\\n\\n        int min = Math.min(down, right);\\n\\n\\n        final int hp = min - dungeon[i][j];\\n\\n        dp[i][j] = hp <= 0 ? 1 : hp;\\n\\n\\n        return dp[i][j];\\n    }\\n```\n```\\ndp[i][j] Minimum health by coming from either [i+1][j] or [i][j+1]\\ndp[i][j] = {    dungeon[i][j] > 0 ? 1 : -dungeon[i][j] + 1; ; i==m-1, j==n-1\\n\\t\\t\\t\\t\\tMin{dp[i+1][j] , dp[i][j+1]} - grid[i][j] ; i < m-1 && j<n-1;\\n\\t\\t\\t\\t\\tdp[i][j+1] - grid[i][j] ; i==m-1 && j<n-1\\n\\t\\t\\t\\t\\tdp[i + 1][j] - dungeon[i][j];  j == n-1; i<m-1\\n\\t\\t\\t\\t\\t\\ndp[i][j] <= 0 ? 1 : dp[i][j]\\n\\nSolution dp[0][0]\\n```\n```\\n public int calculateMinimumHP(int[][] dungeon) {\\n        if (dungeon == null || dungeon.length == 0 || dungeon[0].length == 0)\\n            return 0;\\n\\n        int m = dungeon.length;\\n        int n = dungeon[0].length;\\n        int dp[][] = new int[m][n];\\n\\n        for (int i = m - 1; i >= 0; i--) {\\n\\n            for (int j = n - 1; j >= 0; j--) {\\n\\n                //when you are at princes . m-1,n-1\\n                if (i == m - 1 && j == n - 1)\\n                    dp[i][j] = dungeon[i][j] > 0 ? 1 : -dungeon[i][j] + 1;\\n                else if (i == m - 1)\\n                    dp[i][j] = dp[i][j + 1] - dungeon[i][j];\\n                else if (j == n - 1)\\n                    dp[i][j] = dp[i + 1][j] - dungeon[i][j];\\n                else {\\n\\n                    dp[i][j] = Math.min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j];\\n                }\\n\\n                dp[i][j] = dp[i][j] <= 0 ? 1 : dp[i][j];\\n\\n            }\\n        }\\n\\n        return dp[0][0];\\n    }\\n```\n```\\n  dp[i+1][j] => dp[j]\\n  dp[i][j+1] => dp[j+1]\\n```\n```\\npublic int calculateMinimumHP(int[][] dungeon) {\\n        if (dungeon == null || dungeon.length == 0 || dungeon[0].length == 0)\\n            return 0;\\n\\n        int m = dungeon.length;\\n        int n = dungeon[0].length;\\n        int dp[] = new int[n];\\n\\n        for (int i = m - 1; i >= 0; i--) {\\n\\n            for (int j = n - 1; j >= 0; j--) {\\n\\n                //when you are at princes . m-1,n-1\\n                if (i == m - 1 && j == n - 1)\\n                    dp[j] = dungeon[i][j] > 0 ? 1 : -dungeon[i][j] + 1;\\n                else if (i == m - 1)\\n                    dp[j] = dp[j + 1] - dungeon[i][j];\\n                else if (j == n - 1)\\n                    dp[j] = dp[j] - dungeon[i][j];\\n                else {\\n\\n                    dp[j] = Math.min(dp[j], dp[j + 1]) - dungeon[i][j];\\n                }\\n\\n                dp[j] = dp[j] <= 0 ? 1 : dp[j];\\n\\n            }\\n        }\\n\\n        return dp[0];\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 52869,
                "title": "python-easy-to-understand-solutions-o-m-n-o-n-space",
                "content": "        \\n    # O(m*n) space\\n    def calculateMinimumHP1(self, dungeon):\\n        if not dungeon:\\n            return \\n        r, c = len(dungeon), len(dungeon[0])\\n        dp = [[0 for _ in xrange(c)] for _ in xrange(r)]\\n        dp[-1][-1] = max(1, 1-dungeon[-1][-1])\\n        for i in xrange(c-2, -1, -1):\\n            dp[-1][i] = max(1, dp[-1][i+1]-dungeon[-1][i])\\n        for i in xrange(r-2, -1, -1):\\n            dp[i][-1] = max(1, dp[i+1][-1]-dungeon[i][-1])\\n        for i in xrange(r-2, -1, -1):\\n            for j in xrange(c-2, -1, -1):\\n                dp[i][j] = max(1, min(dp[i+1][j], dp[i][j+1])-dungeon[i][j])\\n        return dp[0][0]\\n        \\n    # O(n) space\\n    def calculateMinimumHP(self, dungeon):\\n        if not dungeon:\\n            return \\n        r, c = len(dungeon), len(dungeon[0])\\n        dp = [0 for _ in xrange(c)]\\n        dp[-1] = max(1, 1-dungeon[-1][-1])\\n        for i in xrange(c-2, -1, -1):\\n            dp[i] = max(1, dp[i+1]-dungeon[-1][i])\\n        for i in xrange(r-2, -1, -1):\\n            dp[-1] = max(1, dp[-1]-dungeon[i][-1])\\n            for j in xrange(c-2, -1, -1):\\n                dp[j] = max(1, min(dp[j], dp[j+1])-dungeon[i][j])\\n        return dp[0]",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "        \\n    # O(m*n) space\\n    def calculateMinimumHP1(self, dungeon):\\n        if not dungeon:\\n            return \\n        r, c = len(dungeon), len(dungeon[0])\\n        dp = [[0 for _ in xrange(c)] for _ in xrange(r)]\\n        dp[-1][-1] = max(1, 1-dungeon[-1][-1])\\n        for i in xrange(c-2, -1, -1):\\n            dp[-1][i] = max(1, dp[-1][i+1]-dungeon[-1][i])\\n        for i in xrange(r-2, -1, -1):\\n            dp[i][-1] = max(1, dp[i+1][-1]-dungeon[i][-1])\\n        for i in xrange(r-2, -1, -1):\\n            for j in xrange(c-2, -1, -1):\\n                dp[i][j] = max(1, min(dp[i+1][j], dp[i][j+1])-dungeon[i][j])\\n        return dp[0][0]\\n        \\n    # O(n) space\\n    def calculateMinimumHP(self, dungeon):\\n        if not dungeon:\\n            return \\n        r, c = len(dungeon), len(dungeon[0])\\n        dp = [0 for _ in xrange(c)]\\n        dp[-1] = max(1, 1-dungeon[-1][-1])\\n        for i in xrange(c-2, -1, -1):\\n            dp[i] = max(1, dp[i+1]-dungeon[-1][i])\\n        for i in xrange(r-2, -1, -1):\\n            dp[-1] = max(1, dp[-1]-dungeon[i][-1])\\n            for j in xrange(c-2, -1, -1):\\n                dp[j] = max(1, min(dp[j], dp[j+1])-dungeon[i][j])\\n        return dp[0]",
                "codeTag": "Python3"
            },
            {
                "id": 2433560,
                "title": "easy-bottom-up-dp-solution-c",
                "content": "*important*\\n\\nIn this problem, we need to use bottom up DP approach but in a reverse way. That is, we start from the end of matrix.\\n\\n```\\n    int calculateMinimumHP(vector<vector<int>>& dun) {\\n        \\n        int n = dun.size();\\n        int m = dun[0].size();\\n        \\n        int dp[n][m];\\n        memset(dp,0,sizeof(dp));\\n        \\n        for(int i=n-1; i>=0; i--){\\n            for(int j=m-1;j>=0;j-- ){\\n                \\n                if(i==n-1 and j==m-1)\\n                    dp[i][j] = dun[i][j];                \\n                else if(i==n-1)\\n                    dp[i][j] = dun[i][j] + dp[i][j+1];                  \\n                else if( j==m-1)\\n                    dp[i][j] = dun[i][j] + dp[i+1][j];  \\n                else\\n                    dp[i][j] = dun[i][j] + max(dp[i+1][j], dp[i][j+1]);                    \\n                \\n                \\n                //to make positive values zero\\n                if(dp[i][j]>0)\\n                        dp[i][j] = 0;\\n            }\\n        }\\n        \\n        \\n        if(dp[0][0]>=0)\\n            return 1;\\n        else \\n            return (abs(dp[0][0])+1);\\n        \\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n    int calculateMinimumHP(vector<vector<int>>& dun) {\\n        \\n        int n = dun.size();\\n        int m = dun[0].size();\\n        \\n        int dp[n][m];\\n        memset(dp,0,sizeof(dp));\\n        \\n        for(int i=n-1; i>=0; i--){\\n            for(int j=m-1;j>=0;j-- ){\\n                \\n                if(i==n-1 and j==m-1)\\n                    dp[i][j] = dun[i][j];                \\n                else if(i==n-1)\\n                    dp[i][j] = dun[i][j] + dp[i][j+1];                  \\n                else if( j==m-1)\\n                    dp[i][j] = dun[i][j] + dp[i+1][j];  \\n                else\\n                    dp[i][j] = dun[i][j] + max(dp[i+1][j], dp[i][j+1]);                    \\n                \\n                \\n                //to make positive values zero\\n                if(dp[i][j]>0)\\n                        dp[i][j] = 0;\\n            }\\n        }\\n        \\n        \\n        if(dp[0][0]>=0)\\n            return 1;\\n        else \\n            return (abs(dp[0][0])+1);\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2174366,
                "title": "c-dp-with-image-explanation",
                "content": "* Consider the image below for explanation. The answer is implemented using recursion considering the approach explained in the image. Matrix DP is used to optimize it by memoization.\\n* Answer could be completely converted without recursion as well, by using bottom up DP matrix\\n\\n![image](https://assets.leetcode.com/users/images/827425ee-c868-466c-9c68-3261475069d9_1655725663.4921842.jpeg)\\n\\n```\\nclass Solution {\\n    int dp[201][201];\\nprivate:\\n    int Calculate_DP(int i, int j, vector<vector<int>> &dungeon) {\\n        int m = dungeon.size();\\n        int n = dungeon[0].size();\\n        \\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n        \\n        if(i == m || j == n)\\n            return INT_MAX;\\n        \\n        if(i == (m - 1) && j == (n - 1))\\n            return dungeon[i][j] < 0 ? -dungeon[i][j] + 1 : 1;\\n        \\n        int right_val = Calculate_DP(i, j + 1, dungeon); // Answer for the right cell if we move right\\n        int down_val = Calculate_DP(i + 1, j, dungeon); // Answer for the below cell if we move down\\n        \\n        int min_health_required = min(right_val, down_val) - dungeon[i][j];\\n        \\n        return dp[i][j] = min_health_required <= 0 ? 1: min_health_required;\\n    }\\n    \\npublic:\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        memset(dp, -1, sizeof dp);\\n        return Calculate_DP(0, 0, dungeon);\\n    }\\n};\\n```\\n\\nFeel free to ask doubts",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    int dp[201][201];\\nprivate:\\n    int Calculate_DP(int i, int j, vector<vector<int>> &dungeon) {\\n        int m = dungeon.size();\\n        int n = dungeon[0].size();\\n        \\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n        \\n        if(i == m || j == n)\\n            return INT_MAX;\\n        \\n        if(i == (m - 1) && j == (n - 1))\\n            return dungeon[i][j] < 0 ? -dungeon[i][j] + 1 : 1;\\n        \\n        int right_val = Calculate_DP(i, j + 1, dungeon); // Answer for the right cell if we move right\\n        int down_val = Calculate_DP(i + 1, j, dungeon); // Answer for the below cell if we move down\\n        \\n        int min_health_required = min(right_val, down_val) - dungeon[i][j];\\n        \\n        return dp[i][j] = min_health_required <= 0 ? 1: min_health_required;\\n    }\\n    \\npublic:\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        memset(dp, -1, sizeof dp);\\n        return Calculate_DP(0, 0, dungeon);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 941108,
                "title": "c-recursion-memorization",
                "content": "a typical board traversal problem. We can use a recursive function to return the min health needed when starting from i,j position\\n\\n```\\nclass Solution {\\n    // enter i,j, min health to reach last cell\\n    \\n    int solve (vector<vector<int>>& dungeon, int i, int j)\\n    {\\n        // out of bounds, return max cost to avoid choosing it\\n        if (i==row || j==col) return INT_MAX;  \\n        \\n        if (i==row-1 && j==col-1)\\n        {\\n            if (dungeon[i][j]<0)\\n                return 1-dungeon[i][j];\\n            else \\n                return 1; \\n        }\\n        \\n        if (memo[i][j]!=INT_MAX)\\n            return memo[i][j]; \\n        // now we enter other cell:\\n        // we have two choice\\n        int right_min = solve (dungeon, i,j+1);\\n        int down_min = solve (dungeon, i+1, j);\\n        \\n        // -3  5 // two \\n        //  4\\n        \\n        //  2  5  // min_next - cell if (cell)\\n        //  4\\n        int min_next = min (right_min, down_min);\\n        // to reach min_next\\n        \\n        int ret; \\n        if (dungeon[i][j]>=min_next)\\n            ret= 1; //\\n        else\\n            ret = min_next - dungeon[i][j];\\n        \\n        memo[i][j]=ret; \\n        return memo[i][j];\\n        \\n    }\\n    int row, col; \\n    // do I need memo? yes\\n    vector<vector<int>> memo; \\npublic:\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        row=dungeon.size(); \\n        if (!row) return 1; \\n        col=dungeon[0].size();\\n        memo.resize(row, vector<int>(col, INT_MAX)); \\n        \\n        return solve (dungeon, 0,0);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    // enter i,j, min health to reach last cell\\n    \\n    int solve (vector<vector<int>>& dungeon, int i, int j)\\n    {\\n        // out of bounds, return max cost to avoid choosing it\\n        if (i==row || j==col) return INT_MAX;  \\n        \\n        if (i==row-1 && j==col-1)\\n        {\\n            if (dungeon[i][j]<0)\\n                return 1-dungeon[i][j];\\n            else \\n                return 1; \\n        }\\n        \\n        if (memo[i][j]!=INT_MAX)\\n            return memo[i][j]; \\n        // now we enter other cell:\\n        // we have two choice\\n        int right_min = solve (dungeon, i,j+1);\\n        int down_min = solve (dungeon, i+1, j);\\n        \\n        // -3  5 // two \\n        //  4\\n        \\n        //  2  5  // min_next - cell if (cell)\\n        //  4\\n        int min_next = min (right_min, down_min);\\n        // to reach min_next\\n        \\n        int ret; \\n        if (dungeon[i][j]>=min_next)\\n            ret= 1; //\\n        else\\n            ret = min_next - dungeon[i][j];\\n        \\n        memo[i][j]=ret; \\n        return memo[i][j];\\n        \\n    }\\n    int row, col; \\n    // do I need memo? yes\\n    vector<vector<int>> memo; \\npublic:\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        row=dungeon.size(); \\n        if (!row) return 1; \\n        col=dungeon[0].size();\\n        memo.resize(row, vector<int>(col, INT_MAX)); \\n        \\n        return solve (dungeon, 0,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 772663,
                "title": "recursion-with-memoization-top-down-solution-in-java-beats-100-in-runtime",
                "content": "```\\nclass Solution {    \\n    public static int[][] dp;\\n    \\n    public int calculateMinimumHP(int[][] dungeon) {        \\n        dp = new int[dungeon.length][dungeon[0].length];\\n        \\n        for (int i = 0; i < dungeon.length; i++)\\n            Arrays.fill(dp[i], -1);\\n        \\n        return f(dungeon, 0, 0);\\n    }\\n    \\n    public int f(int[][] dungeon, int n, int m) {\\n        if (n >= dungeon.length || m >= dungeon[0].length)\\n            return Integer.MAX_VALUE;\\n        \\n        if (n == dungeon.length - 1 && m == dungeon[0].length - 1)\\n            return Math.max(1, 1 - dungeon[n][m]);\\n        \\n        if (dp[n][m] != -1)\\n            return dp[n][m];\\n        \\n        int res = Math.min(f(dungeon, n + 1, m), f(dungeon, n, m + 1)) - dungeon[n][m];\\n        res = Math.max(1, res);\\n        \\n        return dp[n][m] = res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {    \\n    public static int[][] dp;\\n    \\n    public int calculateMinimumHP(int[][] dungeon) {        \\n        dp = new int[dungeon.length][dungeon[0].length];\\n        \\n        for (int i = 0; i < dungeon.length; i++)\\n            Arrays.fill(dp[i], -1);\\n        \\n        return f(dungeon, 0, 0);\\n    }\\n    \\n    public int f(int[][] dungeon, int n, int m) {\\n        if (n >= dungeon.length || m >= dungeon[0].length)\\n            return Integer.MAX_VALUE;\\n        \\n        if (n == dungeon.length - 1 && m == dungeon[0].length - 1)\\n            return Math.max(1, 1 - dungeon[n][m]);\\n        \\n        if (dp[n][m] != -1)\\n            return dp[n][m];\\n        \\n        int res = Math.min(f(dungeon, n + 1, m), f(dungeon, n, m + 1)) - dungeon[n][m];\\n        res = Math.max(1, res);\\n        \\n        return dp[n][m] = res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 771711,
                "title": "c-dp-easy-fast-o-m-n-tc",
                "content": "```\\nclass Solution {\\npublic:\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        // dp[i][j]: hp needed at dungeon[i][j]\\n        int m = dungeon.size(), n = dungeon[0].size();\\n        vector<vector<int>> dp (m+1,vector<int>(n+1,INT_MAX));\\n        dp[m][n-1] = dp[m-1][n] = 1;\\n        for(int i=m-1;i>=0;--i){\\n            for(int j=n-1;j>=0;--j){\\n                dp[i][j] = max(1,min(dp[i+1][j],dp[i][j+1])-dungeon[i][j]);\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        // dp[i][j]: hp needed at dungeon[i][j]\\n        int m = dungeon.size(), n = dungeon[0].size();\\n        vector<vector<int>> dp (m+1,vector<int>(n+1,INT_MAX));\\n        dp[m][n-1] = dp[m-1][n] = 1;\\n        for(int i=m-1;i>=0;--i){\\n            for(int j=n-1;j>=0;--j){\\n                dp[i][j] = max(1,min(dp[i+1][j],dp[i][j+1])-dungeon[i][j]);\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 761905,
                "title": "c-dp-solution-by-codeforces-red-coder",
                "content": "**DP State-** dp[i][j] is the amount of health required by the knight before entering the dungeon(i, j) cell.\\n\\nInitialize dp[n-1][m-1] with the value required based on a few facts.\\nThe health of the knight before entering any cell should be at least 1. So if the value of the last dungeon cell is +ve, we need at least 1 health before entering.\\nThe health of the knight after going into the cell should also be at least 1. So if the value of the last dungeon cell is -ve, we need at least 1-(dungeon[n-1][m-1] before entering the cell.\\n\\nWe build the the DP table bottom up. \\nThe health required before entering a cell is the minimum of the health required in it\\'s neighbouring cells +- the value of the cell (positive or negative accordingly).\\n\\n```\\nconst int inf = 1e9+7;\\nclass Solution {\\npublic:\\n    int calculateMinimumHP(vector<vector<int>>& v) {\\n        int n = v.size();\\n        int m = v[0].size();\\n        \\n        vector<vector<int> > dp(n, vector<int> (m, inf));\\n        \\n        dp[n-1][m-1] = v[n-1][m-1]>0 ? 1 : 1-v[n-1][m-1];\\n        \\n        for(int i=n-1; i>=0; i--){\\n            for(int j=m-1; j>=0; j--){\\n                if(i<n-1){\\n                    dp[i][j] = min(dp[i][j], dp[i+1][j]);\\n                }\\n                if(j<m-1){\\n                    dp[i][j] = min(dp[i][j], dp[i][j+1]);\\n                }\\n                if(i!=n-1 || j!=m-1){\\n                    dp[i][j]-=v[i][j];\\n                    if(dp[i][j]<=0){\\n                        dp[i][j] = 1;\\n                    }\\n                }\\n            }\\n        }\\n        // for(int i=0; i<n; i++){\\n        //     for(int j=0; j<m; j++){\\n        //         cout<<dp[i][j]<<\" \";\\n        //     }\\n        //     cout<<endl;\\n        // }\\n        \\n        return dp[0][0];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nconst int inf = 1e9+7;\\nclass Solution {\\npublic:\\n    int calculateMinimumHP(vector<vector<int>>& v) {\\n        int n = v.size();\\n        int m = v[0].size();\\n        \\n        vector<vector<int> > dp(n, vector<int> (m, inf));\\n        \\n        dp[n-1][m-1] = v[n-1][m-1]>0 ? 1 : 1-v[n-1][m-1];\\n        \\n        for(int i=n-1; i>=0; i--){\\n            for(int j=m-1; j>=0; j--){\\n                if(i<n-1){\\n                    dp[i][j] = min(dp[i][j], dp[i+1][j]);\\n                }\\n                if(j<m-1){\\n                    dp[i][j] = min(dp[i][j], dp[i][j+1]);\\n                }\\n                if(i!=n-1 || j!=m-1){\\n                    dp[i][j]-=v[i][j];\\n                    if(dp[i][j]<=0){\\n                        dp[i][j] = 1;\\n                    }\\n                }\\n            }\\n        }\\n        // for(int i=0; i<n; i++){\\n        //     for(int j=0; j<m; j++){\\n        //         cout<<dp[i][j]<<\" \";\\n        //     }\\n        //     cout<<endl;\\n        // }\\n        \\n        return dp[0][0];\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 423092,
                "title": "clean-clear-java-dp-solution-top-down-and-bottom-up-with-explanation-0ms-beat-100",
                "content": "bottom-up implementation bases on happygirlzt\\'s video on youtube\\n\\n```\\nclass Solution {\\n    public int calculateMinimumHP(int[][] dungeon) {\\n        // health array store the min hp require when reaching the current point (before beating the obstacle)\\n        // condtion: as least 1 hp at each tile before and after\\n        // to get to the current tile at the require hp: health[cur] = health[prev] - dungeon[prev] (obstacle)\\n        //\\n        // building the health array: need to satisfy 2 things:\\n        // * in the recursive loop, every location, we can move right or down\\n        // * ending condition: last tile move would end with 1hp\\n        // * edge cases: cannot go out of bound \\n        // 2 similar ways:\\n        // * [rNum][cNum] & process 3 cases (last tile, last row, last col) before the main loop\\n        // * [rNum+1][cNum+1] make 1 extra unit each side. Then set the ending condition tiles (right/down from [rNum-1][cNum-1]) to 1 & set the edges to maxInt to avoid going out of bound\\n        //\\n        // recurive move:\\n        // at evevery tile we can either move down or right, find the minimum hp required to come in this tile and survive at least 1 of those moves.\\n        // since we start with the end goal, this guarrantees that both moves would get us to the goal as long as we end this tile with health[nextTile]\\n        \\n        if (dungeon == null || dungeon.length == 0 || dungeon[0].length == 0)\\n            return 0;\\n        \\n        int rNum = dungeon.length, cNum = dungeon[0].length;\\n\\n        int[][] health = new int[rNum+1][cNum+1];\\n        // block borders: can fill the whole array, since only the last column and row use these values\\n        for (int[] row : health)\\n            Arrays.fill(row, Integer.MAX_VALUE);\\n        // ending condition:\\n        health[rNum][cNum-1] = 1;\\n        health[rNum-1][cNum] = 1;\\n        // recursive move\\n        for (int r = rNum - 1; r >= 0; r--) {\\n            for (int c = cNum - 1; c >= 0; c--) {\\n                int next = Math.min(health[r+1][c], health[r][c+1]);\\n                health[r][c] = Math.max(next - dungeon[r][c], 1);\\n            }\\n        }\\n        return health[0][0];\\n    }\\n}\\n```\\n\\n\\ntop-down memoization bases on the same idea:\\n\\n```\\nclass Solution {\\n    int[][] cache;\\n    int[][] dungeon;\\n    \\n    public int calculateMinimumHP(int[][] dungeon) {\\n        if (dungeon == null || dungeon.length == 0 || dungeon[0].length == 0)\\n            return 0;\\n        this.cache = new int[dungeon.length][dungeon[0].length];\\n        this.dungeon = dungeon;\\n        return dfs(0, 0);\\n    }\\n    \\n    private int dfs(int r, int c) {\\n        // out of bound\\n        if(r >= dungeon.length || c >= dungeon[0].length)\\n            return Integer.MAX_VALUE;\\n        // check cache\\n        if (cache[r][c] > 0) return cache[r][c];\\n        // recursive move\\n        int next = Math.min(dfs(r+1,c), dfs(r,c+1));\\n        // the only location that both right and down move leads to out-of-bound is the end state\\n        next = next == Integer.MAX_VALUE ? 1 : next;\\n        int res = Math.max(next - dungeon[r][c], 1);\\n        cache[r][c] = res;\\n        return cache[r][c];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int calculateMinimumHP(int[][] dungeon) {\\n        // health array store the min hp require when reaching the current point (before beating the obstacle)\\n        // condtion: as least 1 hp at each tile before and after\\n        // to get to the current tile at the require hp: health[cur] = health[prev] - dungeon[prev] (obstacle)\\n        //\\n        // building the health array: need to satisfy 2 things:\\n        // * in the recursive loop, every location, we can move right or down\\n        // * ending condition: last tile move would end with 1hp\\n        // * edge cases: cannot go out of bound \\n        // 2 similar ways:\\n        // * [rNum][cNum] & process 3 cases (last tile, last row, last col) before the main loop\\n        // * [rNum+1][cNum+1] make 1 extra unit each side. Then set the ending condition tiles (right/down from [rNum-1][cNum-1]) to 1 & set the edges to maxInt to avoid going out of bound\\n        //\\n        // recurive move:\\n        // at evevery tile we can either move down or right, find the minimum hp required to come in this tile and survive at least 1 of those moves.\\n        // since we start with the end goal, this guarrantees that both moves would get us to the goal as long as we end this tile with health[nextTile]\\n        \\n        if (dungeon == null || dungeon.length == 0 || dungeon[0].length == 0)\\n            return 0;\\n        \\n        int rNum = dungeon.length, cNum = dungeon[0].length;\\n\\n        int[][] health = new int[rNum+1][cNum+1];\\n        // block borders: can fill the whole array, since only the last column and row use these values\\n        for (int[] row : health)\\n            Arrays.fill(row, Integer.MAX_VALUE);\\n        // ending condition:\\n        health[rNum][cNum-1] = 1;\\n        health[rNum-1][cNum] = 1;\\n        // recursive move\\n        for (int r = rNum - 1; r >= 0; r--) {\\n            for (int c = cNum - 1; c >= 0; c--) {\\n                int next = Math.min(health[r+1][c], health[r][c+1]);\\n                health[r][c] = Math.max(next - dungeon[r][c], 1);\\n            }\\n        }\\n        return health[0][0];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    int[][] cache;\\n    int[][] dungeon;\\n    \\n    public int calculateMinimumHP(int[][] dungeon) {\\n        if (dungeon == null || dungeon.length == 0 || dungeon[0].length == 0)\\n            return 0;\\n        this.cache = new int[dungeon.length][dungeon[0].length];\\n        this.dungeon = dungeon;\\n        return dfs(0, 0);\\n    }\\n    \\n    private int dfs(int r, int c) {\\n        // out of bound\\n        if(r >= dungeon.length || c >= dungeon[0].length)\\n            return Integer.MAX_VALUE;\\n        // check cache\\n        if (cache[r][c] > 0) return cache[r][c];\\n        // recursive move\\n        int next = Math.min(dfs(r+1,c), dfs(r,c+1));\\n        // the only location that both right and down move leads to out-of-bound is the end state\\n        next = next == Integer.MAX_VALUE ? 1 : next;\\n        int res = Math.max(next - dungeon[r][c], 1);\\n        cache[r][c] = res;\\n        return cache[r][c];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 275325,
                "title": "python-concise-dp",
                "content": "We can use ```dp[i][j]``` to store the minimal health we need at ```dungeon[i][j]```. And knight needs at least 1 health wherever it is. \\nSince knight should either go right or down, ```dp[i][j] = max(min(dp[i+1][j], dp[i][j+1]) - dungeon[i][j], 1)```. \\nTo avoid special handle for border cell, I introduce a pivot row and column at bottom and rightmost in my dp array. The cells are filled with ```inf``` so knight will never choose to go to there. While I set right-bottom corner cells to ```1```s, indicating knight should eventully **pass** ```dungeon[-1][-1] ``` with at least health 1. That\\'s our recurrence base.\\nSo after recurrence, ```dp[0][0]``` will have the minimal health knight needs to walk to princess.\\n```\\ndef calculateMinimumHP(dungeon):\\n\\tm, n = len(dungeon), len(dungeon[0])\\n\\tdp = [[0]*n + [float(\\'inf\\')] for _ in range(m)] + [[float(\\'inf\\')]*(n-1)+[1,1]]\\n\\tfor i in range(m)[::-1]:\\n\\t\\tfor j in range(n)[::-1]:\\n\\t\\t\\tdp[i][j] = max(min(dp[i+1][j], dp[i][j+1]) - dungeon[i][j], 1)\\n\\treturn dp[0][0]\\n```",
                "solutionTags": [],
                "code": "```dp[i][j]```\n```dungeon[i][j]```\n```dp[i][j] = max(min(dp[i+1][j], dp[i][j+1]) - dungeon[i][j], 1)```\n```inf```\n```1```\n```dungeon[-1][-1] ```\n```dp[0][0]```\n```\\ndef calculateMinimumHP(dungeon):\\n\\tm, n = len(dungeon), len(dungeon[0])\\n\\tdp = [[0]*n + [float(\\'inf\\')] for _ in range(m)] + [[float(\\'inf\\')]*(n-1)+[1,1]]\\n\\tfor i in range(m)[::-1]:\\n\\t\\tfor j in range(n)[::-1]:\\n\\t\\t\\tdp[i][j] = max(min(dp[i+1][j], dp[i][j+1]) - dungeon[i][j], 1)\\n\\treturn dp[0][0]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 52801,
                "title": "generic-idea-for-board-movement-problems-java-solution",
                "content": "All these \"Move from top left to bottom right by only moving rightward or downward\" problems can be solved using the same DP idea which can be extended to multiple problems.\\n\\nStart from the end point (bottom right) and work backward (top left).\\n\\nHere's a solution to \"Unique Paths\".\\nhttps://leetcode.com/problems/unique-paths/\\n```\\n        for(int i = m - 1; i >= 0; i--)\\n        {\\n            for(int j = n - 1; j >= 0; j--)\\n            {\\n                if(i == m-1 && j != n-1)\\n                {\\n                    dp[i][j] = dp[i][j+1];\\n                }\\n                else if( i != m-1 && j == n-1)\\n                {\\n                    dp[i][j] = dp[i+1][j];\\n                }\\n                else if(i != m-1 && j != n-1)\\n                {\\n                    dp[i][j] = dp[i+1][j] + dp[i][j+1];\\n                }\\n            }\\n        }\\n        \\n        return dp[0][0];\\n```\\n\\nHere's a solution to \"Minimum Path Sum\" which is very similar:\\nhttps://leetcode.com/problems/minimum-path-sum/\\n\\n```\\n        for(int i = rows - 1; i >= 0; i--)\\n        {\\n            for(int j = cols - 1; j >= 0; j--)\\n            {\\n                if(i == rows-1 && j != cols-1)\\n                {\\n                    dp[i][j] = grid[i][j] + dp[i][j+1];\\n                }\\n                \\n                else if(i != rows-1 && j == cols-1)\\n                {\\n                    dp[i][j] = grid[i][j] + dp[i+1][j];\\n                }\\n                \\n                else if(i != rows-1 && j != cols-1)\\n                {\\n                    dp[i][j] = grid[i][j] + Math.min(dp[i][j+1], dp[i+1][j]);\\n                }\\n                \\n                else\\n                {\\n                    dp[i][j] = grid[i][j];\\n                }\\n            }\\n        }\\n        \\n        return dp[0][0];\\n```\\nThis method can be extended to the \"Dungeon Game\" as well:\\n\\n```\\npublic class Solution {\\n    public int calculateMinimumHP(int[][] dungeon) {\\n        \\n        int m = dungeon.length;\\n        int n = dungeon[0].length;\\n        \\n        int[][] dp = new int[m][n];\\n        \\n        for(int i = m - 1; i >= 0; i--)\\n        {\\n            for(int j = n - 1; j >= 0; j--)\\n            {\\n                if(i == m-1 && j != n-1)\\n                {\\n                    dp[i][j] = Math.max(1, dp[i][j+1] - dungeon[i][j]);\\n                }\\n                else if(i != m-1 && j == n-1)\\n                {\\n                    dp[i][j] = Math.max(1, dp[i+1][j] - dungeon[i][j]);\\n                }\\n                else if(i != m-1 && j != n-1)\\n                {\\n                    dp[i][j] = Math.max(1, Math.min(dp[i+1][j], dp[i][j+1]) - dungeon[i][j]);\\n                }\\n                else\\n                {\\n                    dp[i][j] = Math.max(1, 1 - dungeon[i][j]);\\n                }\\n            }\\n        }\\n        \\n        return dp[0][0];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n        for(int i = m - 1; i >= 0; i--)\\n        {\\n            for(int j = n - 1; j >= 0; j--)\\n            {\\n                if(i == m-1 && j != n-1)\\n                {\\n                    dp[i][j] = dp[i][j+1];\\n                }\\n                else if( i != m-1 && j == n-1)\\n                {\\n                    dp[i][j] = dp[i+1][j];\\n                }\\n                else if(i != m-1 && j != n-1)\\n                {\\n                    dp[i][j] = dp[i+1][j] + dp[i][j+1];\\n                }\\n            }\\n        }\\n        \\n        return dp[0][0];\\n```\n```\\n        for(int i = rows - 1; i >= 0; i--)\\n        {\\n            for(int j = cols - 1; j >= 0; j--)\\n            {\\n                if(i == rows-1 && j != cols-1)\\n                {\\n                    dp[i][j] = grid[i][j] + dp[i][j+1];\\n                }\\n                \\n                else if(i != rows-1 && j == cols-1)\\n                {\\n                    dp[i][j] = grid[i][j] + dp[i+1][j];\\n                }\\n                \\n                else if(i != rows-1 && j != cols-1)\\n                {\\n                    dp[i][j] = grid[i][j] + Math.min(dp[i][j+1], dp[i+1][j]);\\n                }\\n                \\n                else\\n                {\\n                    dp[i][j] = grid[i][j];\\n                }\\n            }\\n        }\\n        \\n        return dp[0][0];\\n```\n```\\npublic class Solution {\\n    public int calculateMinimumHP(int[][] dungeon) {\\n        \\n        int m = dungeon.length;\\n        int n = dungeon[0].length;\\n        \\n        int[][] dp = new int[m][n];\\n        \\n        for(int i = m - 1; i >= 0; i--)\\n        {\\n            for(int j = n - 1; j >= 0; j--)\\n            {\\n                if(i == m-1 && j != n-1)\\n                {\\n                    dp[i][j] = Math.max(1, dp[i][j+1] - dungeon[i][j]);\\n                }\\n                else if(i != m-1 && j == n-1)\\n                {\\n                    dp[i][j] = Math.max(1, dp[i+1][j] - dungeon[i][j]);\\n                }\\n                else if(i != m-1 && j != n-1)\\n                {\\n                    dp[i][j] = Math.max(1, Math.min(dp[i+1][j], dp[i][j+1]) - dungeon[i][j]);\\n                }\\n                else\\n                {\\n                    dp[i][j] = Math.max(1, 1 - dungeon[i][j]);\\n                }\\n            }\\n        }\\n        \\n        return dp[0][0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 52848,
                "title": "accepted-python-dp-solution",
                "content": "    class Solution:\\n        # @param dungeon, a list of lists of integers\\n        # @return a integer\\n        def calculateMinimumHP(self, dungeon):\\n        #If at any point his health point drops to 0 or below, he dies immediately.\\n        #have to make sure at any point health is > 0\\n        #dp[i][j] is minimum health needed when arriving at this grid\\n        #dp[i][j] = min(max(1, dp[right]-right_grid_value), max(1, dp[down]-down_grid_value))\\n            row, col = len(dungeon), len(dungeon[0])\\n            dp = [[0 for x in range(col)] for x in range(row)]\\n            dp[row-1][col-1] = 1\\n            for i in range(row-2, -1, -1):\\n                dp[i][col-1] = max(1, dp[i+1][col-1]-dungeon[i+1][col-1])\\n            for i in range(col-2, -1, -1):\\n                dp[row-1][i] = max(1, dp[row-1][i+1]-dungeon[row-1][i+1])\\n            for i in range(row-2, -1, -1):\\n                for j in range(col-2, -1, -1):\\n                    right = max(1, dp[i][j+1]-dungeon[i][j+1])\\n                    down = max(1, dp[i+1][j]-dungeon[i+1][j])\\n                    dp[i][j] = min(right, down)\\n            return max(1, dp[0][0]-dungeon[0][0])",
                "solutionTags": [],
                "code": "    class Solution:\\n        # @param dungeon, a list of lists of integers\\n        # @return a integer\\n        def calculateMinimumHP(self, dungeon):\\n        #If at any point his health point drops to 0 or below, he dies immediately.\\n        #have to make sure at any point health is > 0\\n        #dp[i][j] is minimum health needed when arriving at this grid\\n        #dp[i][j] = min(max(1, dp[right]-right_grid_value), max(1, dp[down]-down_grid_value))\\n            row, col = len(dungeon), len(dungeon[0])\\n            dp = [[0 for x in range(col)] for x in range(row)]\\n            dp[row-1][col-1] = 1\\n            for i in range(row-2, -1, -1):\\n                dp[i][col-1] = max(1, dp[i+1][col-1]-dungeon[i+1][col-1])\\n            for i in range(col-2, -1, -1):\\n                dp[row-1][i] = max(1, dp[row-1][i+1]-dungeon[row-1][i+1])\\n            for i in range(row-2, -1, -1):\\n                for j in range(col-2, -1, -1):\\n                    right = max(1, dp[i][j+1]-dungeon[i][j+1])\\n                    down = max(1, dp[i+1][j]-dungeon[i+1][j])\\n                    dp[i][j] = min(right, down)\\n            return max(1, dp[0][0]-dungeon[0][0])",
                "codeTag": "Java"
            },
            {
                "id": 3850671,
                "title": "c-2d-1d-dynamic-programming-beats-100",
                "content": "We can only go down or to the right, thus we know that we can construct an optimal solution beginning `dungeon[i][j]` by using the optimal solution for starting from `dungeon[i + 1][j]` and `dungeon[i][j + 1]`. If `dp[i][j]` denotes the minimum initial health needed to travel from `dungeon[i][j]` to `dungeon[m - 1][n - 1]`, `dp[i][j] = max(1, min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j])`. If we travel through `dungeon[i][j]`, we lose `-dungeon[i][j]` health points, which is why we have `- dungeon[i][j]`. Additionally, we want to minimize the starting health for the path beginning at  `dungeon[i][j]`, which is why we have `min(dp[i + 1][j], dp[i][j + 1])`. It is possible, however, that `min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j] < 1` because we don\\'t necessarily lose health points at each `dungeon[i][j]`, however, to begin traveling from any `dungeon[i][j]`, we need at least `1` health point, which is why we have `max(1, min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j])`.\\n\\n# 2D Dynamic Programming\\n\\n## Time Complexity\\n- Time complexity: $$O(m \\\\cdot n)$$\\n\\n- Space complexity: $$O(m \\\\cdot n)$$\\n\\n## Code\\n```\\nclass Solution {\\npublic:\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n\\n        int m = dungeon.size(), n = dungeon[0].size();\\n        vector<vector<int>> dp(m, vector<int>(n));\\n\\n        // dp[i][j] denotes the minimum initial health needed to travel from dungeon[i][j] to\\n        // the dungeon dungeon[m - 1][n - 1] \\n\\n        dp[m - 1][n - 1] = max(1, 1 - dungeon[m - 1][n - 1]);\\n        \\n        for (int i = n - 2; i > -1; --i)\\n            dp[m - 1][i] = max(1, dp[m - 1][i + 1] - dungeon[m - 1][i]);\\n\\n        for (int i = m - 2; i > -1; --i)\\n        {\\n            dp[i][n - 1] = max(1, dp[i + 1][n - 1] - dungeon[i][n - 1]);\\n            for (int j = n - 2; j > -1; --j)\\n                dp[i][j] = max(1, min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j]);\\n        }\\n\\n        return dp[0][0];\\n    }\\n};\\n```\\n\\n# 1D Dynamic Programming \\n\\n## Time Complexity\\n- Time complexity: $$O(m \\\\cdot n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n## Code \\n```\\nclass Solution {\\npublic:\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n\\n        int m = dungeon.size(), n = dungeon[0].size();\\n        vector<int> dp(n);\\n        \\n        dp[n - 1] = max(1, 1 - dungeon[m - 1][n - 1]);\\n        \\n        for (int i = n - 2; i > -1; --i)\\n            dp[i] = max(1, dp[i + 1] - dungeon[m - 1][i]);\\n\\n        for (int i = m - 2; i > -1; --i)\\n        {\\n            dp[n - 1] = max(1, dp[n - 1] - dungeon[i][n - 1]);\\n            for (int j = n - 2; j > -1; --j)\\n                dp[j] = max(1, min(dp[j], dp[j + 1]) - dungeon[i][j]);\\n        }\\n\\n        return dp[0];\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n\\n        int m = dungeon.size(), n = dungeon[0].size();\\n        vector<vector<int>> dp(m, vector<int>(n));\\n\\n        // dp[i][j] denotes the minimum initial health needed to travel from dungeon[i][j] to\\n        // the dungeon dungeon[m - 1][n - 1] \\n\\n        dp[m - 1][n - 1] = max(1, 1 - dungeon[m - 1][n - 1]);\\n        \\n        for (int i = n - 2; i > -1; --i)\\n            dp[m - 1][i] = max(1, dp[m - 1][i + 1] - dungeon[m - 1][i]);\\n\\n        for (int i = m - 2; i > -1; --i)\\n        {\\n            dp[i][n - 1] = max(1, dp[i + 1][n - 1] - dungeon[i][n - 1]);\\n            for (int j = n - 2; j > -1; --j)\\n                dp[i][j] = max(1, min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j]);\\n        }\\n\\n        return dp[0][0];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n\\n        int m = dungeon.size(), n = dungeon[0].size();\\n        vector<int> dp(n);\\n        \\n        dp[n - 1] = max(1, 1 - dungeon[m - 1][n - 1]);\\n        \\n        for (int i = n - 2; i > -1; --i)\\n            dp[i] = max(1, dp[i + 1] - dungeon[m - 1][i]);\\n\\n        for (int i = m - 2; i > -1; --i)\\n        {\\n            dp[n - 1] = max(1, dp[n - 1] - dungeon[i][n - 1]);\\n            for (int j = n - 2; j > -1; --j)\\n                dp[j] = max(1, min(dp[j], dp[j + 1]) - dungeon[i][j]);\\n        }\\n\\n        return dp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3101565,
                "title": "intutive-recursive-approach",
                "content": "# Intuition\\nthe approach is dp as we have to see all the possible ways we can go down because greedy approach is not valid due to lack of uniformity \\n\\n# Approach\\ndynamic programming (recursive approach)\\n\\n# Complexity\\n- Time complexity:\\no(mn)\\n\\n- Space complexity:\\no(mn)+stack space\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n \\nint f(int i ,int j,vector<vector<int>>&d,vector<vector<int>>&dp){\\n    if(i==d.size()||j==d[0].size()){\\n        return 1e9;\\n    }\\n    if(i==d.size()-1&&j==d[0].size()-1){\\n        if(d[i][j]<0){\\n            return abs(d[i][j])+1;\\n        }\\n        else{\\n            return 1;\\n        }\\n    }\\n    if(dp[i][j]!=-1)return dp[i][j];\\n    if(d[i][j]<0){\\n        int r=abs(d[i][j])+f(i,j+1,d,dp);\\n        int l=abs(d[i][j])+f(i+1,j,d,dp);\\n        return dp[i][j]= min(l,r);\\n    }\\n    else{\\n        int r=d[i][j]-f(i,j+1,d,dp);\\n        int l=d[i][j]-f(i+1,j,d,dp);\\n        if(r>=0||l>=0) return dp[i][j]=1;\\n        else{\\n            return dp[i][j]=min(abs(l),abs(r));\\n        }\\n    }\\n}\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n     vector<vector<int>>dp(dungeon.size(),vector<int>(dungeon[0].size(),-1));\\n       return f(0,0,dungeon,dp); \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n \\nint f(int i ,int j,vector<vector<int>>&d,vector<vector<int>>&dp){\\n    if(i==d.size()||j==d[0].size()){\\n        return 1e9;\\n    }\\n    if(i==d.size()-1&&j==d[0].size()-1){\\n        if(d[i][j]<0){\\n            return abs(d[i][j])+1;\\n        }\\n        else{\\n            return 1;\\n        }\\n    }\\n    if(dp[i][j]!=-1)return dp[i][j];\\n    if(d[i][j]<0){\\n        int r=abs(d[i][j])+f(i,j+1,d,dp);\\n        int l=abs(d[i][j])+f(i+1,j,d,dp);\\n        return dp[i][j]= min(l,r);\\n    }\\n    else{\\n        int r=d[i][j]-f(i,j+1,d,dp);\\n        int l=d[i][j]-f(i+1,j,d,dp);\\n        if(r>=0||l>=0) return dp[i][j]=1;\\n        else{\\n            return dp[i][j]=min(abs(l),abs(r));\\n        }\\n    }\\n}\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n     vector<vector<int>>dp(dungeon.size(),vector<int>(dungeon[0].size(),-1));\\n       return f(0,0,dungeon,dp); \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2644408,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Using Bottom Up Dp***\\n\\n* ***Time Complexity :- O(N * N)***\\n\\n* ***Space Complexity :- O(N * N)***\\n\\n```\\nclass Solution {\\npublic:\\n    int calculateMinimumHP(vector<vector<int>>& grid) {\\n        \\n        int n = grid.size();\\n        \\n        int m = grid[0].size();\\n        \\n        // declare a dp\\n        \\n        vector<vector<int>> dp(n, vector<int> (m, 0));\\n        \\n        // fill the dp table\\n        \\n        // dp[i][j] will store the minimum initial energy required from (i, j) to (n - 1, m - 1)\\n        \\n        for(int i = n - 1; i >= 0; i--)\\n        {\\n            for(int j = m - 1; j >= 0; j--)\\n            {\\n                if(i == n - 1 && j == m - 1)\\n                {\\n                    dp[i][j] = grid[i][j] >= 0 ? 0 : grid[i][j];\\n                }\\n                else if(j == m - 1)\\n                {\\n                    dp[i][j] = grid[i][j] + dp[i + 1][j] >= 0 ? 0 : (grid[i][j] + dp[i + 1][j]);\\n                }\\n                else if(i == n - 1)\\n                {\\n                    dp[i][j] = grid[i][j] + dp[i][j + 1] >= 0 ? 0 : (grid[i][j] + dp[i][j + 1]);\\n                }\\n                else\\n                {\\n                    int right = grid[i][j] + dp[i][j + 1] >= 0 ? 0 : (grid[i][j] + dp[i][j + 1]);\\n                    \\n                    int down = grid[i][j] + dp[i + 1][j] >= 0 ? 0 : (grid[i][j] + dp[i + 1][j]);\\n                    \\n                    dp[i][j] = max(right, down);\\n                }\\n            }\\n        }\\n        \\n        return -dp[0][0] + 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int calculateMinimumHP(vector<vector<int>>& grid) {\\n        \\n        int n = grid.size();\\n        \\n        int m = grid[0].size();\\n        \\n        // declare a dp\\n        \\n        vector<vector<int>> dp(n, vector<int> (m, 0));\\n        \\n        // fill the dp table\\n        \\n        // dp[i][j] will store the minimum initial energy required from (i, j) to (n - 1, m - 1)\\n        \\n        for(int i = n - 1; i >= 0; i--)\\n        {\\n            for(int j = m - 1; j >= 0; j--)\\n            {\\n                if(i == n - 1 && j == m - 1)\\n                {\\n                    dp[i][j] = grid[i][j] >= 0 ? 0 : grid[i][j];\\n                }\\n                else if(j == m - 1)\\n                {\\n                    dp[i][j] = grid[i][j] + dp[i + 1][j] >= 0 ? 0 : (grid[i][j] + dp[i + 1][j]);\\n                }\\n                else if(i == n - 1)\\n                {\\n                    dp[i][j] = grid[i][j] + dp[i][j + 1] >= 0 ? 0 : (grid[i][j] + dp[i][j + 1]);\\n                }\\n                else\\n                {\\n                    int right = grid[i][j] + dp[i][j + 1] >= 0 ? 0 : (grid[i][j] + dp[i][j + 1]);\\n                    \\n                    int down = grid[i][j] + dp[i + 1][j] >= 0 ? 0 : (grid[i][j] + dp[i + 1][j]);\\n                    \\n                    dp[i][j] = max(right, down);\\n                }\\n            }\\n        }\\n        \\n        return -dp[0][0] + 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2562360,
                "title": "cpp-dp-memoization-tabulation-space-optimization-easy-explanation",
                "content": "/*\\n    Here, we have 3 Solutions:\\n    \\n    1. Top down DP (Memoization)\\n    2. Bottom Up DP (Tabulation)\\n    3. Tabulation with Space optimisation (Space optimised)\\n    \\n    Intuition:\\n    \\n    ** The idea is to find out minimum strength needed at any node to reach the bottom right corner\\n    ** Strength needed to reach bottom right corner if we are at bottom right corner \\n        -> Will be = 1 if it has an energy booster ( +ve value )\\n        -> Will be 1 - value if it is astrength\\n    ** We can either move right or down\\n    ** Now here we need to understand one important thing, i.e.\\n        -> The value we get as return from right or down is the amount of energy needed if we move in either direction\\n        -> Now, once we get that value, we need to find out the minimum amount of energy needed from current node to bottom\\n            right\\n        -> To do that, we consider the direction through which minimum energy is needed\\n        -> Now, there are two scenarios \\n            1. Current cell contains a booster\\n            2. Energy decrementer\\n        -> Here, we simply subtract the current value from minimum of moving in both the directions\\n            because this will give us the amount of energy needed from current node to reach bottom right node\\n        -> If this value is positive, we simply return that\\n        -> Otherwise we return 1 if the result is negative as that means we need only 1 if we start from this point\\n            -> This is the case when energy booster at this node is greater than the energy needed from it\\'s predecessors to                reach bottom right node\\n            \\n    \\n    Step 1: Express everything in terms of indexes\\n    Dungeon is a matrix so we express things in terms of rows and columns and traverse through the matrix \\n    row -> rInd,\\n    col -> cInd\\n    \\n    Step 2: Find boundary conditions\\n    Edge cases will be \\n    1. We go out of matrix\\n    2. We reach the end\\n    3. It\\'s an overlapping subproblem which we already solved (We have the solution in our DP array)\\n    \\n    Step 3: Explore all posibilities\\n    1. Explore right index from current \\n    2. Explore down index from current\\n    \\n    Step 4: Find minimum of both and subtract current from that and return value if it is positive else return 1 if value is        negative\\n    \\n    \\n*/\\n\\nclass Solution {\\npublic:\\n    \\n    int pathVal(int rInd, int cInd, int m, int n, vector<vector<int>> &dungeon, vector<vector<int>> &dp)\\n    {\\n        if(rInd >= m || cInd >= n)\\n            return 1e9;\\n        \\n        if(rInd == m - 1 && cInd == n - 1)\\n            return dungeon[rInd][cInd] > 0 ? 1 : 1 - dungeon[rInd][cInd];\\n        \\n        if(dp[rInd][cInd] != -1)\\n            return dp[rInd][cInd];\\n        \\n        int right = pathVal(rInd, cInd + 1, m, n, dungeon, dp);\\n        int down = pathVal(rInd + 1, cInd, m, n, dungeon, dp);\\n        \\n        int res = min(right, down) - dungeon[rInd][cInd];\\n        return dp[rInd][cInd] = res > 0 ? res : 1;\\n    }\\n    \\n    int tabulation(int m, int n, vector<vector<int>> &dungeon)\\n    {\\n        vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));  \\n        \\n        for(int cInd = 0; cInd < n + 1; cInd++)\\n            dp[m][cInd] = 1e9;\\n\\n        for(int rInd = 0; rInd < m + 1; rInd++)\\n            dp[rInd][n] = 1e9;\\n\\n        dp[m - 1][n - 1] = dungeon[m - 1][n - 1] > 0 ? 1 : 1 - dungeon[m - 1][n - 1];\\n        \\n        for(int rInd = m - 1; rInd >= 0; rInd--)\\n        {\\n            for(int cInd = n - 1; cInd >= 0; cInd--)\\n            {\\n                int right = dp[rInd][cInd + 1];\\n                int down = dp[rInd + 1][cInd];\\n\\n                int res = min(right, down) - dungeon[rInd][cInd];\\n\\n                if(rInd == m - 1 && cInd == n -1)\\n                    dp[m - 1][n - 1] = dungeon[m - 1][n - 1] > 0 ? 1 : 1 - dungeon[m - 1][n - 1];\\n                else\\n                    dp[rInd][cInd] = res > 0 ? res : 1;\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n    \\n    int tabulationSpaceOptimised(int m, int n, vector<vector<int>> &dungeon)\\n    {\\n        vector<int> dp(n + 1, 0);  \\n        \\n        for(int cInd = 0; cInd < n + 1; cInd++)\\n            dp[cInd] = 1e9;\\n                \\n        for(int rInd = m - 1; rInd >= 0; rInd--)\\n        {        \\n            vector<int> temp(n + 1, 0);  \\n            temp[n] = 1e9; \\n            for(int cInd = n - 1; cInd >= 0; cInd--)\\n            {\\n                int right = temp[cInd + 1];\\n                int down = dp[cInd];\\n\\n                int res = min(right, down) - dungeon[rInd][cInd];\\n\\n                if(rInd == m - 1 && cInd == n - 1)\\n                    temp[n - 1] = dungeon[m - 1][n - 1] > 0 ? 1 : 1 - dungeon[m - 1][n - 1];\\n                else\\n                    temp[cInd] = res > 0 ? res : 1;\\n            }\\n            dp = temp;\\n        }\\n        return dp[0];\\n    }\\n    \\n    int calculateMinimumHP(vector<vector<int>>& dungeon) \\n    {\\n        int m = dungeon.size(), n = dungeon[0].size();\\n\\n        // vector<vector<int>> dp(m + 1, vector<int>(n + 1, -1));\\n        // return pathVal(0, 0, m, n, dungeon, dp);\\n        \\n        // return tabulation(m, n, dungeon);\\n        \\n        return tabulationSpaceOptimised(m, n, dungeon);\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    int pathVal(int rInd, int cInd, int m, int n, vector<vector<int>> &dungeon, vector<vector<int>> &dp)\\n    {\\n        if(rInd >= m || cInd >= n)\\n            return 1e9;\\n        \\n        if(rInd == m - 1 && cInd == n - 1)\\n            return dungeon[rInd][cInd] > 0 ? 1 : 1 - dungeon[rInd][cInd];\\n        \\n        if(dp[rInd][cInd] != -1)\\n            return dp[rInd][cInd];\\n        \\n        int right = pathVal(rInd, cInd + 1, m, n, dungeon, dp);\\n        int down = pathVal(rInd + 1, cInd, m, n, dungeon, dp);\\n        \\n        int res = min(right, down) - dungeon[rInd][cInd];\\n        return dp[rInd][cInd] = res > 0 ? res : 1;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2186275,
                "title": "c-simplest-dp-solution-w-easiest-explanation",
                "content": "We need to return the **minimum** initail health that the knight needs to save the princess.\\n\\n* Before getting into the algorithm, we need to understand:\\n\\t* To stay alive in any cell / move to the next right/down cell, the minimum health needed is ```1``` (Becuase the knight would die if it drops to ```0``` or low).\\n\\n\\t * So, if a cell is guarded by demons and the knight would lose  (*say*) ```5```health points to them, the minimum health for him to stay alive in that cell is ```6```.\\n\\n\\t* After understanding this, there\\'s one more thing to notice: This question has  start and end locations, and you have to find some ```start``` property to meet an end criterion. So we\\'ll start from the ```end``` location because we know the end criterion (Min ```1``` health point is needed tp leave from the last cell) and work our way up to the start cell.\\n\\n**Code:**\\n```\\nclass Solution {\\npublic:\\n    int calculateMinimumHP(vector<vector<int>>& d) {\\n        int m = d.size(), n = d[0].size();\\n        \\n        vector<vector<int>> dp(m+1, vector<int>(n+1, INT_MAX));\\n        dp[m][n-1] = dp[m-1][n] = 1;    //the DOWN and RIGHT cells from the end cell (As explained above, the minimum cost needed to move to the next cells)\\n        \\n        for(int i=m-1; i>=0; i--) {\\n            for(int j=n-1; j>=0; j--) {    //start filling from the bottom-right corner \\n                dp[i][j] = max(1, min(dp[i+1][j], dp[i][j+1]) - d[i][j]);     //We need to see that the health point doesn\\'t drop to 0 or low. Hence --> max(1, ...). Now this \"...\" is the strength that\\'s needed for this cell + that needed to travel to the next cell.  //d[i][j] is the strength provided by this cell and the strength needed to travel to the next cell is min(dp[i+1][j], dp[i][j+1])\\n            }\\n        }\\n        return dp[0][0];    //return the health needed in the first cell\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```1```\n```0```\n```5```\n```6```\n```start```\n```end```\n```1```\n```\\nclass Solution {\\npublic:\\n    int calculateMinimumHP(vector<vector<int>>& d) {\\n        int m = d.size(), n = d[0].size();\\n        \\n        vector<vector<int>> dp(m+1, vector<int>(n+1, INT_MAX));\\n        dp[m][n-1] = dp[m-1][n] = 1;    //the DOWN and RIGHT cells from the end cell (As explained above, the minimum cost needed to move to the next cells)\\n        \\n        for(int i=m-1; i>=0; i--) {\\n            for(int j=n-1; j>=0; j--) {    //start filling from the bottom-right corner \\n                dp[i][j] = max(1, min(dp[i+1][j], dp[i][j+1]) - d[i][j]);     //We need to see that the health point doesn\\'t drop to 0 or low. Hence --> max(1, ...). Now this \"...\" is the strength that\\'s needed for this cell + that needed to travel to the next cell.  //d[i][j] is the strength provided by this cell and the strength needed to travel to the next cell is min(dp[i+1][j], dp[i][j+1])\\n            }\\n        }\\n        return dp[0][0];    //return the health needed in the first cell\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2108535,
                "title": "explained-solution-comprehensible-for-begineer-of-dp-also",
                "content": "```\\n//dp[i][j] means that how much minimum life needed so that from this cell,we can reach destination and remain alive\\nclass Solution {\\npublic:\\n    int solve(int i,int j,vector<vector<int>> &dungeon,vector<vector<int>> &dp,int &row,int &cols)\\n    {\\n        if(i<0 || i>=row || j<0 || j>=cols) return INT_MAX;//infinite life needed to reach to destination from outside dungeon\\n        if(i==row-1 && j==cols-1) return dungeon[i][j]<0?(-dungeon[i][j]+1):1;\\n        \\t\\t\\t\\t\\t\\t\\t//if reached dungeon then it should be alive. So if final cell has negative point then one more point\\n        \\t\\t\\t\\t\\t\\t\\t//than absoulute value of it will be needed so that it remains alive. Otherwise it should just come alive\\n        \\t\\t\\t\\t\\t\\t\\t//with life = 1 and it will remain alive in the destination cell\\n        \\n        if(dp[i][j] != -1) return dp[i][j];\\n        \\n        int right = solve(i,j+1,dungeon,dp,row,cols);//minimum life required when going on right path\\n        int down = solve(i+1,j,dungeon,dp,row,cols);//minimum life required when going on down path\\n        \\n        //No DFS call will fall in infinite loop as movement is restricted to right and down direction only\\n        \\n        int lifeReqFromThisCell = min(right,down) - dungeon[i][j];//after getting answers from right and left path, we have to subtract value\\n        \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t//at this cell because for e.g., suppose this cell has value 4 so it will boost\\n        \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t//life by 4 hence in order to get minimum life required, we have to subtract 4\\n        \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t//similarily if this cell is -4 hence it will add (-(-4)) as this cell itself \\n        \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t//will consume life of 4 points\\n        return dp[i][j] = lifeReqFromThisCell<=0 ? 1 : lifeReqFromThisCell;\\n        \\t\\t\\t\\t//if lifeReqFromThisCell is somehow coming to be -ve or 0 it means there is no additional life required to boost \\n        \\t\\t\\t\\t//from this cell because all the cells in the path are positive hence in such case it is just required that we\\n        \\t\\t\\t\\t//land up at this cell with minimum life of 1 point\\n    }\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        int row = dungeon.size(), cols = dungeon[0].size();\\n        vector<vector<int>> dp(row,vector<int>(cols,-1));\\n        return solve(0,0,dungeon,dp,row,cols);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n//dp[i][j] means that how much minimum life needed so that from this cell,we can reach destination and remain alive\\nclass Solution {\\npublic:\\n    int solve(int i,int j,vector<vector<int>> &dungeon,vector<vector<int>> &dp,int &row,int &cols)\\n    {\\n        if(i<0 || i>=row || j<0 || j>=cols) return INT_MAX;//infinite life needed to reach to destination from outside dungeon\\n        if(i==row-1 && j==cols-1) return dungeon[i][j]<0?(-dungeon[i][j]+1):1;\\n        \\t\\t\\t\\t\\t\\t\\t//if reached dungeon then it should be alive. So if final cell has negative point then one more point\\n        \\t\\t\\t\\t\\t\\t\\t//than absoulute value of it will be needed so that it remains alive. Otherwise it should just come alive\\n        \\t\\t\\t\\t\\t\\t\\t//with life = 1 and it will remain alive in the destination cell\\n        \\n        if(dp[i][j] != -1) return dp[i][j];\\n        \\n        int right = solve(i,j+1,dungeon,dp,row,cols);//minimum life required when going on right path\\n        int down = solve(i+1,j,dungeon,dp,row,cols);//minimum life required when going on down path\\n        \\n        //No DFS call will fall in infinite loop as movement is restricted to right and down direction only\\n        \\n        int lifeReqFromThisCell = min(right,down) - dungeon[i][j];//after getting answers from right and left path, we have to subtract value\\n        \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t//at this cell because for e.g., suppose this cell has value 4 so it will boost\\n        \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t//life by 4 hence in order to get minimum life required, we have to subtract 4\\n        \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t//similarily if this cell is -4 hence it will add (-(-4)) as this cell itself \\n        \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t//will consume life of 4 points\\n        return dp[i][j] = lifeReqFromThisCell<=0 ? 1 : lifeReqFromThisCell;\\n        \\t\\t\\t\\t//if lifeReqFromThisCell is somehow coming to be -ve or 0 it means there is no additional life required to boost \\n        \\t\\t\\t\\t//from this cell because all the cells in the path are positive hence in such case it is just required that we\\n        \\t\\t\\t\\t//land up at this cell with minimum life of 1 point\\n    }\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        int row = dungeon.size(), cols = dungeon[0].size();\\n        vector<vector<int>> dp(row,vector<int>(cols,-1));\\n        return solve(0,0,dungeon,dp,row,cols);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2052055,
                "title": "clean-and-clear-dp-solution-in-python-easy-to-understand",
                "content": "A great **DP** question that requires some time to understand!\\n\\n**Initiate** a DP matrix.\\nUse dp to keep the **minimum health point** that the knight needs **when arriving** at each cell!\\n**At each cell**, we should **compute the health point we need** to be able to reach its right connecting cell and down connecting cell (using helper function getHealth()). Then take the minimum of the right one and down one, insert into the dp matrix.\\n**Order to fill:**\\nUpwards and leftwards.\\n\\n**Time:** O(mn)\\n**Space:** O(mn)\\n\\n```\\nclass Solution:\\n    def calculateMinimumHP(self, dungeon: List[List[int]]) -> int:\\n        \\n        rows, cols = len(dungeon), len(dungeon[0])\\n        dp = [[float(\\'inf\\')] * cols for _ in range(rows)]\\n        \\n        dp[rows - 1][cols - 1] = 1 if dungeon[rows - 1][cols - 1] >= 0 else (1 - dungeon[rows - 1][cols - 1])\\n        \\n        for row in reversed(range(rows)):\\n            for col in reversed(range(cols)):\\n                if row == rows - 1 and col == cols - 1:\\n                    continue\\n                \\n                curr_cell = dungeon[row][col]\\n\\n                right_health = self.getHealth(curr_cell, row, col + 1, rows, cols, dp)\\n                down_health = self.getHealth(curr_cell, row + 1, col, rows, cols, dp)\\n                next_health = min(right_health, down_health)\\n\\n                dp[row][col] = next_health\\n\\n        return dp[0][0]\\n    \\n    def getHealth(self, curr_cell, next_row, next_col, rows, cols, dp):\\n        \\n        if next_row >= rows or next_col >= cols:\\n            return float(\\'inf\\')\\n        next_cell = dp[next_row][next_col]\\n        # note that the knight needs at least 1 point at any cell\\n        return max(1, next_cell - curr_cell)\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def calculateMinimumHP(self, dungeon: List[List[int]]) -> int:\\n        \\n        rows, cols = len(dungeon), len(dungeon[0])\\n        dp = [[float(\\'inf\\')] * cols for _ in range(rows)]\\n        \\n        dp[rows - 1][cols - 1] = 1 if dungeon[rows - 1][cols - 1] >= 0 else (1 - dungeon[rows - 1][cols - 1])\\n        \\n        for row in reversed(range(rows)):\\n            for col in reversed(range(cols)):\\n                if row == rows - 1 and col == cols - 1:\\n                    continue\\n                \\n                curr_cell = dungeon[row][col]\\n\\n                right_health = self.getHealth(curr_cell, row, col + 1, rows, cols, dp)\\n                down_health = self.getHealth(curr_cell, row + 1, col, rows, cols, dp)\\n                next_health = min(right_health, down_health)\\n\\n                dp[row][col] = next_health\\n\\n        return dp[0][0]\\n    \\n    def getHealth(self, curr_cell, next_row, next_col, rows, cols, dp):\\n        \\n        if next_row >= rows or next_col >= cols:\\n            return float(\\'inf\\')\\n        next_cell = dp[next_row][next_col]\\n        # note that the knight needs at least 1 point at any cell\\n        return max(1, next_cell - curr_cell)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1582288,
                "title": "easy-to-understand-in-c-amazing-approach",
                "content": "class Solution {\\npublic:\\n    \\n    int solve(vector<vector<int>>& dungeon,int n,int m){\\n        vector<vector<int>> hp(n+1,vector<int>(m+1,INT_MAX));\\n        hp[n][m-1]=1;\\n        hp[n-1][m]=1;\\n        \\n        for(int i=n-1;i>=0;i--){\\n            for(int j=m-1;j>=0;j--){\\n                int need=min(hp[i+1][j],hp[i][j+1])-dungeon[i][j];\\n                hp[i][j]=need<=0?1:need;\\n            }\\n        }\\n        return hp[0][0];\\n    }\\n        \\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        int n=dungeon.size();\\n        int m=dungeon[0].size();\\n        return solve(dungeon,n,m);\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    int solve(vector<vector<int>>& dungeon,int n,int m){\\n        vector<vector<int>> hp(n+1,vector<int>(m+1,INT_MAX));\\n        hp[n][m-1]=1;\\n        hp[n-1][m]=1;\\n        \\n        for(int i=n-1;i>=0;i--){\\n            for(int j=m-1;j>=0;j--){\\n                int need=min(hp[i+1][j],hp[i][j+1])-dungeon[i][j];\\n                hp[i][j]=need<=0?1:need;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1528466,
                "title": "c-using-dynamic-programming",
                "content": "**Please Upvote if you like the Solution!**\\n\\n    class Solution {\\n    public:\\n    int calculateMinimumHP(vector<vector<int>>& dungeon)\\n    {\\n        int rows=dungeon.size();//row size\\n        int cols=dungeon[0].size();//column size\\n        \\n        vector<vector<int>> dp(rows,vector<int> (cols,0));//creating dp table same as size of dungeon\\n        \\n        //Using Bottom-Up Approach\\n        \\n        for(int i=rows-1;i>=0;i--)\\n        {\\n            for(int j=cols-1;j>=0;j--)\\n            {\\n                if(i==rows-1 && j==cols-1)\\n                {\\n                    dp[i][j]=min(0,dungeon[i][j]);//we don\\'t take positive values\\n                }\\n                else if(i==rows-1)//whenever we are in last row\\n                {\\n                    dp[i][j]=min(0,dungeon[i][j]+dp[i][j+1]);//adding current dungeon value and adjacent right value\\n                }\\n                else if(j==cols-1)//whenever we are in last column\\n                {\\n                    dp[i][j]=min(0,dungeon[i][j]+dp[i+1][j]);//add current dungeon value and adjacent down value\\n                }\\n                else\\n                {\\n                    dp[i][j]=min(0,dungeon[i][j]+max(dp[i+1][j],dp[i][j+1]));//taking current dungeon value and maximum of adjacent down and adjacent right\\n                }\\n                \\n            }\\n        }\\n        return abs(dp[0][0])+1;//taking absolute of dp[0][0] and adding 1 to it as minimum 1 positive energy is required to alive for a knight\\n    }\\n    };\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    public:\\n    int calculateMinimumHP(vector<vector<int>>& dungeon)\\n    {\\n        int rows=dungeon.size();//row size\\n        int cols=dungeon[0].size();//column size\\n        \\n        vector<vector<int>> dp(rows,vector<int> (cols,0));//creating dp table same as size of dungeon\\n        \\n        //Using Bottom-Up Approach\\n        \\n        for(int i=rows-1;i>=0;i--)\\n        {\\n            for(int j=cols-1;j>=0;j--)\\n            {\\n                if(i==rows-1 && j==cols-1)\\n                {\\n                    dp[i][j]=min(0,dungeon[i][j]);//we don\\'t take positive values\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1498650,
                "title": "c-binary-search-and-dp",
                "content": "**Connect with me on LinkedIn**: https://www.linkedin.com/in/abhay5349singh/\\n\\n**Approach:** Since knight will hold some initial energy, so we can add some enrgy to it from ( 1 --> 1e6 ) and check for minimum possible energy to given such that there exisits at least 1 path from (0,0) --> (n-1,m-1) with values of each cell > 0\\n\\n**Binary Search Sollution**\\n```\\nclass Solution {\\npublic:\\n    \\n    bool possible(vector<vector<int>>& grid, int val) {\\n        int n=grid.size(), m=grid[0].size();\\n        \\n        int dp[n][m];\\n        memset(dp,INT_MIN,sizeof(dp));\\n        dp[0][0]=grid[0][0]+val;\\n\\t\\t\\n\\t\\t// we can move to next cell only if previous cell value > 0\\n        for(int i=0,j=1;j<m;j++) if(dp[i][j-1]>0) dp[i][j]=dp[i][j-1]+grid[i][j];\\n        for(int i=1,j=0;i<n;i++) if(dp[i-1][j]>0) dp[i][j]=dp[i-1][j]+grid[i][j];\\n        \\n        for(int i=1;i<n;i++){\\n            for(int j=1;j<m;j++){\\n                if(dp[i-1][j]>0) dp[i][j]=dp[i-1][j]+grid[i][j];\\n                if(dp[i][j-1]>0) dp[i][j]=max(dp[i][j],dp[i][j-1]+grid[i][j]);\\n            }\\n        }\\n        return (dp[n-1][m-1]>0);\\n    }\\n    \\n    int calculateMinimumHP(vector<vector<int>>& grid) {\\n        int n=grid.size(), m=grid[0].size();\\n        \\n        int l=1, r=1e6;\\n        while(l<r){\\n            int m=l+(r-l)/2;\\n            if(possible(grid,m)){\\n                r=m;\\n            }else{\\n                l=m+1;\\n            }\\n        } \\n        return l;\\n    }\\n};\\n```\\n\\n**DP Sollution**\\n```\\nclass Solution {\\npublic:\\n    \\n    int calculateMinimumHP(vector<vector<int>>& grid) {\\n        int n=grid.size(), m=grid[0].size();\\n        \\n        int dp[n][m];\\n        dp[n-1][m-1]=min(0,grid[n-1][m-1]);\\n        for(int i=n-1,j=m-2;j>=0;j--) dp[i][j]=min(0,dp[i][j+1]+grid[i][j]);\\n        for(int i=n-2,j=m-1;i>=0;i--) dp[i][j]=min(0,dp[i+1][j]+grid[i][j]);\\n        \\n        for(int i=n-2;i>=0;i--){\\n            for(int j=m-2;j>=0;j--){\\n                dp[i][j]=min(0,max(dp[i+1][j],dp[i][j+1])+grid[i][j]);\\n            }\\n        }\\n        return 1-dp[0][0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool possible(vector<vector<int>>& grid, int val) {\\n        int n=grid.size(), m=grid[0].size();\\n        \\n        int dp[n][m];\\n        memset(dp,INT_MIN,sizeof(dp));\\n        dp[0][0]=grid[0][0]+val;\\n\\t\\t\\n\\t\\t// we can move to next cell only if previous cell value > 0\\n        for(int i=0,j=1;j<m;j++) if(dp[i][j-1]>0) dp[i][j]=dp[i][j-1]+grid[i][j];\\n        for(int i=1,j=0;i<n;i++) if(dp[i-1][j]>0) dp[i][j]=dp[i-1][j]+grid[i][j];\\n        \\n        for(int i=1;i<n;i++){\\n            for(int j=1;j<m;j++){\\n                if(dp[i-1][j]>0) dp[i][j]=dp[i-1][j]+grid[i][j];\\n                if(dp[i][j-1]>0) dp[i][j]=max(dp[i][j],dp[i][j-1]+grid[i][j]);\\n            }\\n        }\\n        return (dp[n-1][m-1]>0);\\n    }\\n    \\n    int calculateMinimumHP(vector<vector<int>>& grid) {\\n        int n=grid.size(), m=grid[0].size();\\n        \\n        int l=1, r=1e6;\\n        while(l<r){\\n            int m=l+(r-l)/2;\\n            if(possible(grid,m)){\\n                r=m;\\n            }else{\\n                l=m+1;\\n            }\\n        } \\n        return l;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    int calculateMinimumHP(vector<vector<int>>& grid) {\\n        int n=grid.size(), m=grid[0].size();\\n        \\n        int dp[n][m];\\n        dp[n-1][m-1]=min(0,grid[n-1][m-1]);\\n        for(int i=n-1,j=m-2;j>=0;j--) dp[i][j]=min(0,dp[i][j+1]+grid[i][j]);\\n        for(int i=n-2,j=m-1;i>=0;i--) dp[i][j]=min(0,dp[i+1][j]+grid[i][j]);\\n        \\n        for(int i=n-2;i>=0;i--){\\n            for(int j=m-2;j>=0;j--){\\n                dp[i][j]=min(0,max(dp[i+1][j],dp[i][j+1])+grid[i][j]);\\n            }\\n        }\\n        return 1-dp[0][0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1498134,
                "title": "c-recursion-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[200][200];\\n    int solve(vector<vector<int>> &grid, int n, int m, int i, int j) \\n    {\\n        if(i >= n || j >= m) \\n            return INT_MAX;\\n        if(i == n-1 && j == m-1) \\n            return grid[i][j] <= 0 ? abs(grid[i][j]) + 1 : 1;\\n        if (dp[i][j] != -1) \\n            return dp[i][j];\\n        int right = solve(grid, n, m, i, j+1);\\n        int down = solve(grid, n, m, i+1, j);\\n        int ans = min(right, down) - grid[i][j];\\n        return dp[i][j] = ans <=0 ? 1 : ans;\\n    }\\n    int calculateMinimumHP(vector<vector<int>> &dungeon) \\n    {\\n        if(dungeon.size() == 0) \\n            return 0;\\n        memset(dp, -1, sizeof(dp));\\n        return solve(dungeon, dungeon.size(), dungeon[0].size(), 0, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[200][200];\\n    int solve(vector<vector<int>> &grid, int n, int m, int i, int j) \\n    {\\n        if(i >= n || j >= m) \\n            return INT_MAX;\\n        if(i == n-1 && j == m-1) \\n            return grid[i][j] <= 0 ? abs(grid[i][j]) + 1 : 1;\\n        if (dp[i][j] != -1) \\n            return dp[i][j];\\n        int right = solve(grid, n, m, i, j+1);\\n        int down = solve(grid, n, m, i+1, j);\\n        int ans = min(right, down) - grid[i][j];\\n        return dp[i][j] = ans <=0 ? 1 : ans;\\n    }\\n    int calculateMinimumHP(vector<vector<int>> &dungeon) \\n    {\\n        if(dungeon.size() == 0) \\n            return 0;\\n        memset(dp, -1, sizeof(dp));\\n        return solve(dungeon, dungeon.size(), dungeon[0].size(), 0, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1498123,
                "title": "java-solution",
                "content": "\\tclass Solution {\\n    public int calculateMinimumHP(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        \\n        int dp[][] = new int[n][m];\\n        for(int i=n-1; i>=0; i--){\\n            for(int j=m-1; j>=0; j--){\\n                if(i==n-1 && j==m-1){\\n                    dp[i][j] = Math.max(1, 1 - grid[i][j]);\\n                }\\n                else if(i==n-1){\\n                    dp[i][j] = Math.max(1, dp[i][j+1] - grid[i][j]);\\n                }\\n                else if(j==m-1){\\n                    dp[i][j] = Math.max(1, dp[i+1][j] - grid[i][j]);\\n                }\\n                else{\\n                    dp[i][j] = Math.max(1, Math.min(dp[i][j+1], dp[i+1][j]) - grid[i][j]);\\n                }\\n            }\\n        }\\n        \\n        return dp[0][0];\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    public int calculateMinimumHP(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        \\n        int dp[][] = new int[n][m];\\n        for(int i=n-1; i>=0; i--){\\n            for(int j=m-1; j>=0; j--){\\n                if(i==n-1 && j==m-1){\\n                    dp[i][j] = Math.max(1, 1 - grid[i][j]);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1401190,
                "title": "c-recursion-memoization",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>>dp;\\n    \\n    \\tint recurs(vector<vector<int>>&arr, int n, int m,int i,int j)\\n\\t{\\n\\t    \\n            if(i>=n||j>=m)\\n                 return  1000000;\\n            \\n\\n                \\n            if(i==n-1&&j==m-1)\\n            {\\n                if(arr[i][j]>0)\\n                     return dp[i][j]= 1;\\n                \\n                return dp[i][j]=abs(arr[i][j])+1;\\n            }\\n            \\n            if(dp[i][j]!=-1)\\n                 return dp[i][j];\\n                \\n            \\n            \\n            int a=recurs(arr,n,m,i+1,j);\\n            int b=recurs(arr,n,m,i,j+1);\\n            \\n            if(arr[i][j]>=min(a,b))\\n                return dp[i][j]=1;\\n            \\n            return dp[i][j]=min(a,b)-arr[i][j];\\n\\t}\\n    \\n    int calculateMinimumHP(vector<vector<int>>& points) {\\n       \\n         int n=points.size(),m=points[0].size();\\n         dp.clear();\\n         dp.resize(n,vector<int>(m,-1));\\n        \\n        int k=recurs(points,n,m,0,0);\\n        \\n          if(k<=0)\\n               k=1;\\n\\t     return k;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>>dp;\\n    \\n    \\tint recurs(vector<vector<int>>&arr, int n, int m,int i,int j)\\n\\t{\\n\\t    \\n            if(i>=n||j>=m)\\n                 return  1000000;\\n            \\n\\n                \\n            if(i==n-1&&j==m-1)\\n            {\\n                if(arr[i][j]>0)\\n                     return dp[i][j]= 1;\\n                \\n                return dp[i][j]=abs(arr[i][j])+1;\\n            }\\n            \\n            if(dp[i][j]!=-1)\\n                 return dp[i][j];\\n                \\n            \\n            \\n            int a=recurs(arr,n,m,i+1,j);\\n            int b=recurs(arr,n,m,i,j+1);\\n            \\n            if(arr[i][j]>=min(a,b))\\n                return dp[i][j]=1;\\n            \\n            return dp[i][j]=min(a,b)-arr[i][j];\\n\\t}\\n    \\n    int calculateMinimumHP(vector<vector<int>>& points) {\\n       \\n         int n=points.size(),m=points[0].size();\\n         dp.clear();\\n         dp.resize(n,vector<int>(m,-1));\\n        \\n        int k=recurs(points,n,m,0,0);\\n        \\n          if(k<=0)\\n               k=1;\\n\\t     return k;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1114660,
                "title": "java-dp-1ms",
                "content": "```\\nclass Solution {\\n    public int calculateMinimumHP(int[][] D) {\\n        int r = D.length;\\n        int c = D[0].length;\\n        \\n        // Padding on the right and the bottom of the Dungeon\\n        // dp[i][j] meas the least HP needed if knight want to reach the room(i, j)\\n        int[][] dp = new int[r + 1][c + 1];\\n        for (int[] row : dp) Arrays.fill(row, Integer.MAX_VALUE);\\n        // It means if the knight want to reach the right or the bottom room of the princess,\\n        // He needs at least 1 HP\\n        dp[r][c - 1] = dp[r - 1][c] = 1;\\n        \\n        for (int i = r - 1; i >= 0; i--) {\\n            for (int j = c - 1; j >= 0; j--) {\\n                // Now the kight is in the room(i, j), he wants to go room(i+1, j) or room(i, j+1)\\n                // Before the knight goes into room(i+1, j), he needs at least dp[i + 1][j] - D[i][j].\\n                // Same as room(i, j+1)\\n                int need = Math.min(dp[i + 1][j], dp[i][j + 1]) - D[i][j];\\n                dp[i][j] = Math.max(1, need);\\n            }\\n        }\\n        \\n        return dp[0][0];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int calculateMinimumHP(int[][] D) {\\n        int r = D.length;\\n        int c = D[0].length;\\n        \\n        // Padding on the right and the bottom of the Dungeon\\n        // dp[i][j] meas the least HP needed if knight want to reach the room(i, j)\\n        int[][] dp = new int[r + 1][c + 1];\\n        for (int[] row : dp) Arrays.fill(row, Integer.MAX_VALUE);\\n        // It means if the knight want to reach the right or the bottom room of the princess,\\n        // He needs at least 1 HP\\n        dp[r][c - 1] = dp[r - 1][c] = 1;\\n        \\n        for (int i = r - 1; i >= 0; i--) {\\n            for (int j = c - 1; j >= 0; j--) {\\n                // Now the kight is in the room(i, j), he wants to go room(i+1, j) or room(i, j+1)\\n                // Before the knight goes into room(i+1, j), he needs at least dp[i + 1][j] - D[i][j].\\n                // Same as room(i, j+1)\\n                int need = Math.min(dp[i + 1][j], dp[i][j + 1]) - D[i][j];\\n                dp[i][j] = Math.max(1, need);\\n            }\\n        }\\n        \\n        return dp[0][0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 989558,
                "title": "concise-java-solution-using-bellman-ford-bfs-priority-queue",
                "content": "```\\nclass Solution {\\n    \\n    private int[] dr = new int[]{0, 1};\\n    private int[] dc = new int[]{1, 0};\\n    \\n    public int calculateMinimumHP(int[][] dungeon) {\\n        \\n        int M = dungeon.length, N = dungeon[0].length;\\n        int[][] maxHealthSum = new int[M][N]; // maxHealthSum[i][j] means the max health sum at (i, j)\\n        \\n        for (int i = 0; i < M; i++)\\n            for (int j = 0; j < N; j++)\\n                maxHealthSum[i][j] = Integer.MIN_VALUE;\\n        \\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> b[3] - a[3]); // [x, y, sum value on the path, min sum]\\n        \\n        pq.offer(new int[]{0, 0, dungeon[0][0], dungeon[0][0]});\\n        \\n        while (!pq.isEmpty())\\n        {\\n            int[] vals = pq.poll();\\n            int x = vals[0], y = vals[1], sum = vals[2], minSum = vals[3];\\n            \\n            if (sum < maxHealthSum[x][y])\\n                continue;\\n            else\\n                maxHealthSum[x][y] = sum;\\n            \\n            if (x == M-1 && y == N-1)\\n            {\\n                if (minSum < 0)\\n                    return 1 - minSum;\\n                else\\n                    return 1;\\n            }\\n            \\n            for (int k = 0; k < 2; k++)\\n            {\\n                int r = x + dr[k], c = y + dc[k];\\n                \\n                if (r >= 0 && r < M && c >= 0 && c < N)\\n                    pq.offer(new int[]{r, c, sum + dungeon[r][c], Math.min(minSum, sum + dungeon[r][c])});\\n            }\\n        }\\n        \\n        return 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    \\n    private int[] dr = new int[]{0, 1};\\n    private int[] dc = new int[]{1, 0};\\n    \\n    public int calculateMinimumHP(int[][] dungeon) {\\n        \\n        int M = dungeon.length, N = dungeon[0].length;\\n        int[][] maxHealthSum = new int[M][N]; // maxHealthSum[i][j] means the max health sum at (i, j)\\n        \\n        for (int i = 0; i < M; i++)\\n            for (int j = 0; j < N; j++)\\n                maxHealthSum[i][j] = Integer.MIN_VALUE;\\n        \\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> b[3] - a[3]); // [x, y, sum value on the path, min sum]\\n        \\n        pq.offer(new int[]{0, 0, dungeon[0][0], dungeon[0][0]});\\n        \\n        while (!pq.isEmpty())\\n        {\\n            int[] vals = pq.poll();\\n            int x = vals[0], y = vals[1], sum = vals[2], minSum = vals[3];\\n            \\n            if (sum < maxHealthSum[x][y])\\n                continue;\\n            else\\n                maxHealthSum[x][y] = sum;\\n            \\n            if (x == M-1 && y == N-1)\\n            {\\n                if (minSum < 0)\\n                    return 1 - minSum;\\n                else\\n                    return 1;\\n            }\\n            \\n            for (int k = 0; k < 2; k++)\\n            {\\n                int r = x + dr[k], c = y + dc[k];\\n                \\n                if (r >= 0 && r < M && c >= 0 && c < N)\\n                    pq.offer(new int[]{r, c, sum + dungeon[r][c], Math.min(minSum, sum + dungeon[r][c])});\\n            }\\n        }\\n        \\n        return 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 704443,
                "title": "javascript-clean-dp-table",
                "content": "```javascript\\nvar calculateMinimumHP = function(dungeon) {\\n    const rowNum = dungeon.length, colNum = dungeon[0].length;\\n    const dp = Array.from({length: rowNum+1}, () => Array(colNum+1).fill(Infinity));\\n    dp[rowNum][colNum-1] = 1;\\n    \\n    for(let r = rowNum-1; r >= 0; r--) {\\n        for(let c = colNum-1; c >= 0; c--) {\\n            const minPath = Math.min(dp[r+1][c], dp[r][c+1]) - dungeon[r][c];\\n            dp[r][c] = Math.max(1, minPath);\\n        }\\n    }\\n    return dp[0][0];  \\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```javascript\\nvar calculateMinimumHP = function(dungeon) {\\n    const rowNum = dungeon.length, colNum = dungeon[0].length;\\n    const dp = Array.from({length: rowNum+1}, () => Array(colNum+1).fill(Infinity));\\n    dp[rowNum][colNum-1] = 1;\\n    \\n    for(let r = rowNum-1; r >= 0; r--) {\\n        for(let c = colNum-1; c >= 0; c--) {\\n            const minPath = Math.min(dp[r+1][c], dp[r][c+1]) - dungeon[r][c];\\n            dp[r][c] = Math.max(1, minPath);\\n        }\\n    }\\n    return dp[0][0];  \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 52796,
                "title": "6-lines-python-dp-o-mn-time-o-n-space-and-my-thinking-process",
                "content": "First, the 6lines final 1-dimentsional DP version as attached. \\n```\\nclass Solution(object):\\n    def calculateMinimumHP(self, dungeon):\\n        \"\"\"\\n        :type dungeon: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        m, n = len(dungeon), len(dungeon[0]) if dungeon else 0\\n        dp = [float('inf')] * (n-1) + [1]\\n        for i in range(m)[::-1]:\\n            for j in range(n)[::-1]:\\n                dp[j] = max(1, min(dp[j:j+2]) - dungeon[i][j])\\n        return dp[0]\\n```\\nOkay, now let me share my thinking process and hope it can help someone who is still struggling with this problem. (I'm just a guy who started to learn CS myself several months ago, so any comments are welcome!)\\n\\nWhen I saw this problem, **```BFS```** came to my mind first. Since we can only move downward or rightward at each step, it's pretty clear what we have is a directional graph. But wait a second, in order to keep the efficiency, we'd better have a ```memo``` (dictionary in Python) and it needs some extra space and syntax. Do we have a better way?\\n\\nThe answer is **YES** and let's do **```DP```** instead. Build 2-dimensional DP is pretty straight forward. We build a matrix called ```dp``` whose size is exactly the same as ```dungeon```. Since what we want is the minimum hp we need at the starting point ```dp[0][0]``` and our destination is ```dp[m-1][n-1]```, let's update our ```dp[i][j]``` from bottom right. Attached is my first 2-dimensional DP version.\\n```\\nclass Solution(object):\\n    def calculateMinimumHP(self, dungeon):\\n        \"\"\"\\n        :type dungeon: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        m, n = len(dungeon), len(dungeon[0]) if dungeon else 0\\n        dp = [[0] * n for _ in range(m)]\\n        dp[-1][-1] = max(1, 1 - dungeon[-1][-1])\\n        for i in range(m)[::-1]:\\n            for j in range(n)[::-1]:\\n                dp[i][j] = max(1, min([dp[x][y] for x, y in ((i+1, j), (i, j+1)) \\\\\\n                               if x < m and y < n] or [1]) - dungeon[i][j])\\n        return dp[0][0]\\n```\\nSince I'm only using ```dp[i+1][j]``` and ```dp[i][j+1]``` to calculate ```dp[i][j]```, I realized we can transform the 2-dimensional DP to 1-dimensional version and the corresponding space complexity drops from O(mn) to O(n). Attached is the 1-d O(n) DP. Instead of storing O(mn) ```dp```, we only need ```dp``` for current row and the previous result ```pre``` we just got. Thus, O(n) space achieved.\\n```\\nclass Solution(object):\\n    def calculateMinimumHP(self, dungeon):\\n        \"\"\"\\n        :type dungeon: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        m, n = len(dungeon), len(dungeon[0]) if dungeon else 0\\n        dp, pre = [1] * n, [0] * n\\n        neigh = []\\n        for i in range(m)[::-1]:\\n            for j in range(n)[::-1]:\\n                neigh = dp[j+1:j+2] if i == m-1 else pre[j:j+1] + dp[j+1:j+2]\\n                dp[j] = max(1, min(neigh or [1]) - dungeon[i][j])\\n            pre[:] = dp[:]\\n        return dp[0]\\n```\\nCan we do better? Yes we can. After a little observation, I realized that we don't even need ```pre```. Because ```dp[i]``` == ```pre[i]``` indeed! Finally I got the final 1-dimensional DP version on the top of this post. (Of course I made some adjustment to the initial condition for ```dp``` to make the code more concise.) And that's all my thinking process for this problem, hope it can help and any comments are welcome!\\n\\n**EDIT**: I just found my idol @StefanPochmann has a post [here](https://discuss.leetcode.com/topic/19179/6-lines-python-8-lines-ruby) and my final version DP is almost the same as his. Haha, I'm so excited!",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def calculateMinimumHP(self, dungeon):\\n        \"\"\"\\n        :type dungeon: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        m, n = len(dungeon), len(dungeon[0]) if dungeon else 0\\n        dp = [float('inf')] * (n-1) + [1]\\n        for i in range(m)[::-1]:\\n            for j in range(n)[::-1]:\\n                dp[j] = max(1, min(dp[j:j+2]) - dungeon[i][j])\\n        return dp[0]\\n```\n```BFS```\n```memo```\n```DP```\n```dp```\n```dungeon```\n```dp[0][0]```\n```dp[m-1][n-1]```\n```dp[i][j]```\n```\\nclass Solution(object):\\n    def calculateMinimumHP(self, dungeon):\\n        \"\"\"\\n        :type dungeon: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        m, n = len(dungeon), len(dungeon[0]) if dungeon else 0\\n        dp = [[0] * n for _ in range(m)]\\n        dp[-1][-1] = max(1, 1 - dungeon[-1][-1])\\n        for i in range(m)[::-1]:\\n            for j in range(n)[::-1]:\\n                dp[i][j] = max(1, min([dp[x][y] for x, y in ((i+1, j), (i, j+1)) \\\\\\n                               if x < m and y < n] or [1]) - dungeon[i][j])\\n        return dp[0][0]\\n```\n```dp[i+1][j]```\n```dp[i][j+1]```\n```dp[i][j]```\n```dp```\n```dp```\n```pre```\n```\\nclass Solution(object):\\n    def calculateMinimumHP(self, dungeon):\\n        \"\"\"\\n        :type dungeon: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        m, n = len(dungeon), len(dungeon[0]) if dungeon else 0\\n        dp, pre = [1] * n, [0] * n\\n        neigh = []\\n        for i in range(m)[::-1]:\\n            for j in range(n)[::-1]:\\n                neigh = dp[j+1:j+2] if i == m-1 else pre[j:j+1] + dp[j+1:j+2]\\n                dp[j] = max(1, min(neigh or [1]) - dungeon[i][j])\\n            pre[:] = dp[:]\\n        return dp[0]\\n```\n```pre```\n```dp[i]```\n```pre[i]```\n```dp```",
                "codeTag": "Java"
            },
            {
                "id": 52863,
                "title": "java-dp-solution",
                "content": "    public int calculateMinimumHP(int[][] dungeon) {\\n        if(dungeon == null || dungeon.length == 0) return 0;\\n        int m = dungeon.length, n = dungeon[0].length;\\n        int dp[][] = new int[m][n];\\n        for(int i = m - 1; i >= 0; --i){\\n            for(int j = n - 1; j >= 0; --j){\\n                if(i == m - 1 && j == n - 1) dp[i][j] = Math.max(1, 1 - dungeon[i][j]);\\n                else if(i == m - 1) dp[i][j] = Math.max(1, dp[i][j + 1] - dungeon[i][j]);\\n                else if(j == n - 1) dp[i][j] = Math.max(1, dp[i + 1][j] - dungeon[i][j]);\\n                else dp[i][j] = Math.max(1, Math.min(dp[i][j + 1], dp[i + 1][j]) - dungeon[i][j]);\\n            }\\n        }\\n        return dp[0][0];\\n    }",
                "solutionTags": [],
                "code": "    public int calculateMinimumHP(int[][] dungeon) {\\n        if(dungeon == null || dungeon.length == 0) return 0;\\n        int m = dungeon.length, n = dungeon[0].length;\\n        int dp[][] = new int[m][n];\\n        for(int i = m - 1; i >= 0; --i){\\n            for(int j = n - 1; j >= 0; --j){\\n                if(i == m - 1 && j == n - 1) dp[i][j] = Math.max(1, 1 - dungeon[i][j]);\\n                else if(i == m - 1) dp[i][j] = Math.max(1, dp[i][j + 1] - dungeon[i][j]);\\n                else if(j == n - 1) dp[i][j] = Math.max(1, dp[i + 1][j] - dungeon[i][j]);\\n                else dp[i][j] = Math.max(1, Math.min(dp[i][j + 1], dp[i + 1][j]) - dungeon[i][j]);\\n            }\\n        }\\n        return dp[0][0];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 52923,
                "title": "my-java-ac-solution-with-dp-and-o-1-space",
                "content": "Start from the destination, we can calculate the minimum HP required then store it in the cell since we won't be needing it later. This way we can achieve constant space.\\n\\nIf we care not allowed to change the matrix, then we need at least a 1-D array.\\n\\n\\n\\n    public class Solution {\\n        public int calculateMinimumHP(int[][] dungeon) {\\n            // return 0 if dungeon does not exist\\n            if (dungeon == null || dungeon.length == 0 || dungeon[0].length == 0) return 0;\\n            int m = dungeon.length -1, n = dungeon[0].length -1;\\n            //make sure alive after rescue\\n            dungeon[m][n] = setHp(1-dungeon[m][n]);\\n            \\n            //fill bottom row and right-most column\\n            for (int i = m-1; i >= 0; i--)\\n                dungeon[i][n] = setHp(dungeon[i+1][n] - dungeon[i][n]);\\n            for (int j = n-1; j >= 0; j--)\\n                dungeon[m][j] = setHp(dungeon[m][j+1] - dungeon[m][j]);\\n            \\n            //fill the rest\\n            for (int i = m-1; i >= 0; i--)\\n                for (int j = n-1; j >= 0; j--)\\n                    //pick minimum hp needed after this cell\\n                    dungeon[i][j] = setHp(Math.min(dungeon[i+1][j],dungeon[i][j+1])-dungeon[i][j]);\\n            \\n            return dungeon[0][0];\\n        }\\n        //if needed Hp is negative set hp to 1, otherwise positive\\n        private int setHp (int hp) {\\n            return hp <= 0 ? 1: hp;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int calculateMinimumHP(int[][] dungeon) {\\n            // return 0 if dungeon does not exist\\n            if (dungeon == null || dungeon.length == 0 || dungeon[0].length == 0) return 0;\\n            int m = dungeon.length -1, n = dungeon[0].length -1;\\n            //make sure alive after rescue\\n            dungeon[m][n] = setHp(1-dungeon[m][n]);\\n            \\n            //fill bottom row and right-most column\\n            for (int i = m-1; i >= 0; i--)\\n                dungeon[i][n] = setHp(dungeon[i+1][n] - dungeon[i][n]);\\n            for (int j = n-1; j >= 0; j--)\\n                dungeon[m][j] = setHp(dungeon[m][j+1] - dungeon[m][j]);\\n            \\n            //fill the rest\\n            for (int i = m-1; i >= 0; i--)\\n                for (int j = n-1; j >= 0; j--)\\n                    //pick minimum hp needed after this cell\\n                    dungeon[i][j] = setHp(Math.min(dungeon[i+1][j],dungeon[i][j+1])-dungeon[i][j]);\\n            \\n            return dungeon[0][0];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3212862,
                "title": "174-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThis solution uses dynamic programming to solve the problem. The main idea is to build a 2D array dp to store the minimum initial health required at each position to reach the bottom-right corner. We start from the bottom-right corner and work our way backwards to the top-left corner.\\n\\nAt each position, we take the minimum of the minimum initial health required at the position below and the position to the right, and subtract the dungeon value at the current position. If the result is less than or equal to 0, we set it to 1 (since the knight needs to have at least 1 health point to be alive). Finally, we return the value at the top-left corner of the dp array.\\n\\nTo handle the boundary cases, we add an extra row and an extra column to the dp array, and set them all to infinity except for dp[m-1][n] and dp[m][n-1], which are set to 1.\\n\\nThis solution has a time complexity of O(mn) and a space complexity of O(mn).\\n\\n# Complexity\\n- Time complexity:\\nBeats\\n68.28%\\n\\n- Space complexity:\\nBeats\\n97.32%\\n\\n# Code\\n```\\nclass Solution:\\n    def calculateMinimumHP(self, dungeon: List[List[int]]) -> int:\\n        m, n = len(dungeon), len(dungeon[0])\\n        dp = [[float(\\'inf\\')] * (n+1) for _ in range(m+1)]\\n        dp[m-1][n] = dp[m][n-1] = 1\\n        for i in range(m-1, -1, -1):\\n            for j in range(n-1, -1, -1):\\n                dp[i][j] = max(min(dp[i+1][j], dp[i][j+1]) - dungeon[i][j], 1)\\n        return dp[0][0]\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Dynamic Programming",
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    def calculateMinimumHP(self, dungeon: List[List[int]]) -> int:\\n        m, n = len(dungeon), len(dungeon[0])\\n        dp = [[float(\\'inf\\')] * (n+1) for _ in range(m+1)]\\n        dp[m-1][n] = dp[m][n-1] = 1\\n        for i in range(m-1, -1, -1):\\n            for j in range(n-1, -1, -1):\\n                dp[i][j] = max(min(dp[i+1][j], dp[i][j+1]) - dungeon[i][j], 1)\\n        return dp[0][0]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3180049,
                "title": "beginner-friendly-recursion-c-dp-memoization",
                "content": "# Intuition\\nas in question it mentioned that that knight can reach any specific grid if he has some positive health so what we will have to keep in mind is if grid[i][j]>=0 then the minimum health he must have will be equql to 1\\n\\nif grid[i][j]<0 then knight must have minimum health =abs(grid[i][j])+1\\n\\n# Approach\\nfun(i,j)--->will tell us mininum health required to reach  grid[i][j]\\n\\n# Complexity\\n- Time complexity:\\nO(m*n)\\n\\n- Space complexity:\\nO(m*n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint fun(int i,int j,vector<vector<int>>& dungeon,vector<vector<int>> &dp){\\n    if(i>=dp.size()||j>=dp[0].size()) return 5e5;\\n    if(i==dp.size()-1&&j==dp[0].size()-1) {\\n        if(dungeon[i][j]<=0) return abs(dungeon[i][j])+1;\\n        else return 1;\\n    } \\n    if(dp[i][j]!=-1) return dp[i][j];\\n    int up=fun(i+1,j,dungeon,dp);\\n    int down=fun(i,j+1,dungeon,dp);\\n    int minhealthreq=min(up,down)-dungeon[i][j];\\n    return dp[i][j]=(minhealthreq<=0)?1:minhealthreq;\\n}\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        int m=dungeon.size(),n=dungeon[0].size();\\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n       return fun(0,0,dungeon,dp); \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint fun(int i,int j,vector<vector<int>>& dungeon,vector<vector<int>> &dp){\\n    if(i>=dp.size()||j>=dp[0].size()) return 5e5;\\n    if(i==dp.size()-1&&j==dp[0].size()-1) {\\n        if(dungeon[i][j]<=0) return abs(dungeon[i][j])+1;\\n        else return 1;\\n    } \\n    if(dp[i][j]!=-1) return dp[i][j];\\n    int up=fun(i+1,j,dungeon,dp);\\n    int down=fun(i,j+1,dungeon,dp);\\n    int minhealthreq=min(up,down)-dungeon[i][j];\\n    return dp[i][j]=(minhealthreq<=0)?1:minhealthreq;\\n}\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        int m=dungeon.size(),n=dungeon[0].size();\\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n       return fun(0,0,dungeon,dp); \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2983069,
                "title": "intuitive-2-d-dp-in-the-table-python-beats-97-on-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIntuitive DP in 2-D graph, we calculate DP for each point in the dungeon table.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- dp[ i ][ j ] indicates the minimum life requirement to reach the finish point.\\n# Complexity\\n- Time complexity: O(mn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(mn)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def calculateMinimumHP(self, dungeon):\\n        \"\"\"\\n        :type dungeon: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n\\n        # the minimum life needed to survive to the finish point\\n        m = len(dungeon)\\n        n = len(dungeon[0])\\n        dp = dungeon\\n\\n        dp[m-1][n-1] = max(1, -dp[m-1][n-1]+1)\\n\\n        for i in range(n-2, -1, -1):\\n            dp[m-1][i] = max(1, -dp[m-1][i] + dp[m-1][i+1])\\n        for j in range(m-2, -1, -1):\\n            dp[j][n-1] = max(1, -dp[j][n-1] + dp[j+1][n-1]) \\n \\n        for j in range(m-2, -1, -1):\\n            for i in range(n-2, -1, -1):\\n                dp[j][i] = max(1, -dp[j][i] + min(dp[j+1][i], dp[j][i+1]))\\n        \\n        return dp[0][0]\\n\\n\\n\\n\\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution(object):\\n    def calculateMinimumHP(self, dungeon):\\n        \"\"\"\\n        :type dungeon: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n\\n        # the minimum life needed to survive to the finish point\\n        m = len(dungeon)\\n        n = len(dungeon[0])\\n        dp = dungeon\\n\\n        dp[m-1][n-1] = max(1, -dp[m-1][n-1]+1)\\n\\n        for i in range(n-2, -1, -1):\\n            dp[m-1][i] = max(1, -dp[m-1][i] + dp[m-1][i+1])\\n        for j in range(m-2, -1, -1):\\n            dp[j][n-1] = max(1, -dp[j][n-1] + dp[j+1][n-1]) \\n \\n        for j in range(m-2, -1, -1):\\n            for i in range(n-2, -1, -1):\\n                dp[j][i] = max(1, -dp[j][i] + min(dp[j+1][i], dp[j][i+1]))\\n        \\n        return dp[0][0]\\n\\n\\n\\n\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2567313,
                "title": "explanation-from-scratch-frequenty-asked-in-interviews-c",
                "content": "```\\nint calculateMinimumHP(vector<vector<int>>& grid) {\\n        \\n        int m=grid.size(),n=grid[0].size();\\n        int dp[m][n];\\n        memset(dp,-1,sizeof dp);\\n\\n        //main logic --> hum top se bottom ki trf jaa rhe to total path ka sum nahi krna calculate kya pta path sum >0 ho aur hum ans=1 krde par pehle cell me hi -4 ho kaise cross kroge . dp[i][j] ye return krega ki use kitni energy chiye (-ve me) agar koi cell (20 lets say) apne down wle cell ki negative(-7) ko compensate kr skta to vo dp[i][j] me 0 likhega ki bhai dp[i][j] wli subproblem b 0 energy chiye hume ab baaki problem solve krlo tum\\n        \\n        for(int i=m-1;i>=0;i--)\\n        {\\n            for(int j=n-1;j>=0;j--)\\n            {    \\n                if(i==m-1 and j==n-1)                          //yaha aane ke liye\\n                    dp[i][j]=grid[i][j]>=0?0:grid[i][j];  // hi mujhe itni energy chiye\\n                \\n                else if(i==m-1)\\n                    dp[i][j]=(grid[i][j]+dp[i][j+1])>=0? 0:grid[i][j]+dp[i][j+1];\\n                \\n                else if(j==n-1)\\n                    dp[i][j]=(grid[i][j]+dp[i+1][j])>=0? 0:grid[i][j]+dp[i+1][j];\\n                else\\n                {\\n                    int val=grid[i][j]+max(dp[i+1][j],dp[i][j+1]);\\n                    dp[i][j]=(val>=0)? 0:val;\\n                }\\n                    \\n            }\\n        }\\n        return dp[0][0]==0?1:abs(dp[0][0])+1;\\n    }",
                "solutionTags": [],
                "code": "```\\nint calculateMinimumHP(vector<vector<int>>& grid) {\\n        \\n        int m=grid.size(),n=grid[0].size();\\n        int dp[m][n];\\n        memset(dp,-1,sizeof dp);\\n\\n        //main logic --> hum top se bottom ki trf jaa rhe to total path ka sum nahi krna calculate kya pta path sum >0 ho aur hum ans=1 krde par pehle cell me hi -4 ho kaise cross kroge . dp[i][j] ye return krega ki use kitni energy chiye (-ve me) agar koi cell (20 lets say) apne down wle cell ki negative(-7) ko compensate kr skta to vo dp[i][j] me 0 likhega ki bhai dp[i][j] wli subproblem b 0 energy chiye hume ab baaki problem solve krlo tum\\n        \\n        for(int i=m-1;i>=0;i--)\\n        {\\n            for(int j=n-1;j>=0;j--)\\n            {    \\n                if(i==m-1 and j==n-1)                          //yaha aane ke liye\\n                    dp[i][j]=grid[i][j]>=0?0:grid[i][j];  // hi mujhe itni energy chiye\\n                \\n                else if(i==m-1)\\n                    dp[i][j]=(grid[i][j]+dp[i][j+1])>=0? 0:grid[i][j]+dp[i][j+1];\\n                \\n                else if(j==n-1)\\n                    dp[i][j]=(grid[i][j]+dp[i+1][j])>=0? 0:grid[i][j]+dp[i+1][j];\\n                else\\n                {\\n                    int val=grid[i][j]+max(dp[i+1][j],dp[i][j+1]);\\n                    dp[i][j]=(val>=0)? 0:val;\\n                }\\n                    \\n            }\\n        }\\n        return dp[0][0]==0?1:abs(dp[0][0])+1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1912920,
                "title": "c-solution-recursive-memoization-tabulation",
                "content": "```\\n// RECURSIVE APPROACH\\nclass Solution {\\npublic:\\n    int helper(int i,int j,int m,int n,vector<vector<int>> &dungeon){\\n        if(i>=m || j>=n) return INT_MAX;\\n        int right=helper(i,j+1,m,n,dungeon);\\n        int down=helper(i+1,j,m,n,dungeon);\\n        int health=min(right,down);\\n        if(health==INT_MAX){\\n            health=1;\\n        }\\n        \\n        int res=0;\\n        if(health-dungeon[i][j]>0){\\n            res=health-dungeon[i][j];\\n        }\\n        else{\\n            res=1;\\n        }\\n        return res;\\n    }\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        return helper(0,0,dungeon.size(),dungeon[0].size(),dungeon);\\n    }\\n};\\n\\n// MEMOIZATION\\nclass Solution {\\npublic:\\n    int dp[201][201];\\n    int helper(int i,int j,int m,int n,vector<vector<int>> &dungeon){\\n        if(i>=m || j>=n) return INT_MAX;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int right=helper(i,j+1,m,n,dungeon);\\n        int down=helper(i+1,j,m,n,dungeon);\\n        int health=min(right,down);\\n        if(health==INT_MAX){\\n            health=1;\\n        }\\n        \\n        int res=0;\\n        if(health-dungeon[i][j]>0){\\n            res=health-dungeon[i][j];\\n        }\\n        else{\\n            res=1;\\n        }\\n        return dp[i][j]=res;\\n    }\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        memset(dp,-1,sizeof(dp));\\n        return helper(0,0,dungeon.size(),dungeon[0].size(),dungeon);\\n    }\\n};\\n\\n// TABULATION\\nclass Solution {\\npublic:\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        int m=dungeon.size();\\n        int n=dungeon[0].size();\\n        vector<vector<int>> dp(m+1,vector<int> (n+1,INT_MAX));\\n        for(int i=m-1;i>=0;i--){\\n            for(int j=n-1;j>=0;j--){\\n                int right=dp[i][j+1];\\n                int down=dp[i+1][j];\\n                int health=min(right,down);\\n                if(health==INT_MAX){\\n                    health=1;\\n                }\\n                int res=0;\\n                if(health-dungeon[i][j]>0){\\n                    res=health-dungeon[i][j];\\n                }\\n                else{\\n                    res=1;\\n                }\\n                dp[i][j]=res;\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n};\\n```\\nPLEASE UPVOTE IF YOU LIKE THE POST :)",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n// RECURSIVE APPROACH\\nclass Solution {\\npublic:\\n    int helper(int i,int j,int m,int n,vector<vector<int>> &dungeon){\\n        if(i>=m || j>=n) return INT_MAX;\\n        int right=helper(i,j+1,m,n,dungeon);\\n        int down=helper(i+1,j,m,n,dungeon);\\n        int health=min(right,down);\\n        if(health==INT_MAX){\\n            health=1;\\n        }\\n        \\n        int res=0;\\n        if(health-dungeon[i][j]>0){\\n            res=health-dungeon[i][j];\\n        }\\n        else{\\n            res=1;\\n        }\\n        return res;\\n    }\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        return helper(0,0,dungeon.size(),dungeon[0].size(),dungeon);\\n    }\\n};\\n\\n// MEMOIZATION\\nclass Solution {\\npublic:\\n    int dp[201][201];\\n    int helper(int i,int j,int m,int n,vector<vector<int>> &dungeon){\\n        if(i>=m || j>=n) return INT_MAX;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int right=helper(i,j+1,m,n,dungeon);\\n        int down=helper(i+1,j,m,n,dungeon);\\n        int health=min(right,down);\\n        if(health==INT_MAX){\\n            health=1;\\n        }\\n        \\n        int res=0;\\n        if(health-dungeon[i][j]>0){\\n            res=health-dungeon[i][j];\\n        }\\n        else{\\n            res=1;\\n        }\\n        return dp[i][j]=res;\\n    }\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        memset(dp,-1,sizeof(dp));\\n        return helper(0,0,dungeon.size(),dungeon[0].size(),dungeon);\\n    }\\n};\\n\\n// TABULATION\\nclass Solution {\\npublic:\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        int m=dungeon.size();\\n        int n=dungeon[0].size();\\n        vector<vector<int>> dp(m+1,vector<int> (n+1,INT_MAX));\\n        for(int i=m-1;i>=0;i--){\\n            for(int j=n-1;j>=0;j--){\\n                int right=dp[i][j+1];\\n                int down=dp[i+1][j];\\n                int health=min(right,down);\\n                if(health==INT_MAX){\\n                    health=1;\\n                }\\n                int res=0;\\n                if(health-dungeon[i][j]>0){\\n                    res=health-dungeon[i][j];\\n                }\\n                else{\\n                    res=1;\\n                }\\n                dp[i][j]=res;\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1755117,
                "title": "dp-solution-easy-to-understand-o-n-m",
                "content": "This problem can be easily solved by the approach of DP on grid. \\nIdea:\\n  We will start from the index (0,0) and on each index we have two choices i.e either move to down or move to right. \\n  As mentioned in the question we have to find the minimum value of health such that knight reaches the queen,\\n  therefore for this purpose we have to find the path such that the minimum of (health on particular index, total sum of health from that index to (n-1,m-1) ) should be maximum.\\n  The subproblem of this question will be minimum value of health  knight requires such that he starts at the index (i,j) and reaches the queen situated at index (n-1,m-1) and this subproblem will be stored in the dp grid.\\n  \\n\\n```class Solution {\\npublic:\\n    \\n    // here n= number of rows and m=number of column\\n    \\n    \\n bool check(int row, int col, int n, int m)  // checking if the index is out of bound or not\\n{\\n\\tif (row < 0 || col < 0 || row >= n || col >= m)\\n\\t{\\n\\t\\treturn false;\\n\\t}\\n\\n\\treturn true;\\n}\\n\\nint solve(int row, int col, vector<vector<int>>& dungeon, vector<vector<int>>&dp)\\n{\\n\\tint n = dungeon.size();\\n\\tint m = dungeon[0].size();\\n\\n\\tif (row == n - 1 && col == m - 1) // base condition i.e if the  knight reaches the princess then return the value as stated below\\n\\t{\\n\\t\\treturn dp[row][col] = dungeon[row][col];\\n\\t}\\n// if the subproblem is already calculated then return the ans stored of that particular subproblem\\n\\tif (dp[row][col] != -1e6)\\n\\t{\\n\\t\\treturn dp[row][col];\\n\\t}\\n\\t// calculating the value of particular subproblem\\n\\tint ans = -1e6;\\n\\n\\tif (check(row, col + 1, n, m))\\n\\t{\\n\\t\\tans = max(ans, min(dungeon[row][col], solve(row, col + 1, dungeon, dp) + dungeon[row][col]));\\n\\t}\\n\\tif (check(row + 1, col, n, m))\\n\\t{\\n\\t\\tans = max(ans, min(dungeon[row][col], solve(row + 1, col, dungeon, dp) + dungeon[row][col]));\\n\\t}\\n// storing the ans of the subproblem (row,col) in the grid\\n\\treturn dp[row][col] = ans;\\n\\n\\n}\\n\\nint calculateMinimumHP(vector<vector<int>>& dungeon) {\\n\\tint n = dungeon.size();\\n\\tint m = dungeon[0].size();\\n\\tvector<vector<int>>dp(n, vector<int>(m, -1e6));\\n\\n\\tint ans = solve(0, 0, dungeon, dp);\\n\\tif (ans > 0)\\n\\t{\\n\\t\\treturn 1;\\n\\n\\t}\\n\\n\\n\\n\\treturn 1 - ans;\\n\\n}\\n};",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    // here n= number of rows and m=number of column\\n    \\n    \\n bool check(int row, int col, int n, int m)  // checking if the index is out of bound or not\\n{\\n\\tif (row < 0 || col < 0 || row >= n || col >= m)\\n\\t{\\n\\t\\treturn false;\\n\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1502316,
                "title": "c-solution",
                "content": "```\\nclass Solution\\n{\\n    public:\\n    int calculateMinimumHP(vector<vector<int>> &dungeon)\\n    {\\n        vector<int> dp(dungeon.size() + 1, INT_MAX);\\n        dp[dungeon.size() - 1] = 1;\\n        for (int i = dungeon[0].size() - 1; i >= 0; i--)\\n        {\\n            for (int j = dungeon.size() - 1; j >= 0; j--)\\n            {\\n                dp[j] = max(1, min(dp[j + 1], dp[j]) - dungeon[j][i]);\\n            }\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n    int calculateMinimumHP(vector<vector<int>> &dungeon)\\n    {\\n        vector<int> dp(dungeon.size() + 1, INT_MAX);\\n        dp[dungeon.size() - 1] = 1;\\n        for (int i = dungeon[0].size() - 1; i >= 0; i--)\\n        {\\n            for (int j = dungeon.size() - 1; j >= 0; j--)\\n            {\\n                dp[j] = max(1, min(dp[j + 1], dp[j]) - dungeon[j][i]);\\n            }\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1498811,
                "title": "python-using-dp",
                "content": "```\\nclass Solution:\\n    def calculateMinimumHP(self, dungeon: List[List[int]]) -> int:\\n        row = len(dungeon)\\n        col = len(dungeon[0])\\n        dp = [[ 0 for _ in range(col)] for _ in range(row)]\\n        for i in range(row - 1,-1,-1):\\n            for j in range(col - 1,-1,-1):\\n                if i == row - 1 and j == col - 1:\\n                    dp[i][j] = min(0, dungeon[i][j])\\n                elif i == row - 1:\\n                    dp[i][j] = min(0, dungeon[i][j] + dp[i][j + 1])\\n                elif j == col - 1:\\n                    dp[i][j] = min(0,dungeon[i][j] + dp[i + 1][j]) \\n                else:\\n                    dp[i][j] = min(0,dungeon[i][j] + max(dp[i + 1][j], dp[i][j + 1]))\\n        print(dp)\\n        return abs(dp[0][0]) + 1\\n```\\nI hope that you\\'ve found the solution useful.\\nIn that case, please do upvote and encourage me to on my quest to document all leetcode problems\\uD83D\\uDE03",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def calculateMinimumHP(self, dungeon: List[List[int]]) -> int:\\n        row = len(dungeon)\\n        col = len(dungeon[0])\\n        dp = [[ 0 for _ in range(col)] for _ in range(row)]\\n        for i in range(row - 1,-1,-1):\\n            for j in range(col - 1,-1,-1):\\n                if i == row - 1 and j == col - 1:\\n                    dp[i][j] = min(0, dungeon[i][j])\\n                elif i == row - 1:\\n                    dp[i][j] = min(0, dungeon[i][j] + dp[i][j + 1])\\n                elif j == col - 1:\\n                    dp[i][j] = min(0,dungeon[i][j] + dp[i + 1][j]) \\n                else:\\n                    dp[i][j] = min(0,dungeon[i][j] + max(dp[i + 1][j], dp[i][j + 1]))\\n        print(dp)\\n        return abs(dp[0][0]) + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1498591,
                "title": "c-solution",
                "content": "class Solution\\n{\\npublic:\\n\\n    int calculateMinimumHP(vector<vector<int>> &dungeon)\\n    {\\n        vector<int> dp(dungeon.size() + 1, INT_MAX);\\n        dp[dungeon.size() - 1] = 1;\\n\\n        for (int i = dungeon[0].size() - 1; i >= 0; i--)\\n        {\\n            for (int j = dungeon.size() - 1; j >= 0; j--)\\n            {\\n                dp[j] = max(1, min(dp[j + 1], dp[j]) - dungeon[j][i]);\\n            }\\n        }\\n        return dp[0];\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution\\n{\\npublic:\\n\\n    int calculateMinimumHP(vector<vector<int>> &dungeon)\\n    {\\n        vector<int> dp(dungeon.size() + 1, INT_MAX);\\n        dp[dungeon.size() - 1] = 1;\\n\\n        for (int i = dungeon[0].size() - 1; i >= 0; i--)\\n        {\\n            for (int j = dungeon.size() - 1; j >= 0; j--)\\n            {\\n                dp[j] = max(1, min(dp[j + 1], dp[j]) - dungeon[j][i]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1382683,
                "title": "dungeon-game-all-3-approaches-c",
                "content": "# Recursion\\n\\n```\\n   \\tint solve(int i, int j,vector<vector<int>> &p, int M, int N)\\n\\t{\\n\\t    if(i>=M || j>=N) return INT_MAX;\\n            \\n        if(i==M-1 && j==N-1)\\n\\t    return p[i][j]<=0 ? 1+abs(p[i][j]) : 1;\\n            \\n\\t    int right = solve(i,j+1,p,M,N);\\n        int left  = solve(i+1,j,p,M,N);\\n        \\n        int minEnergy = min(left,right)-p[i][j];\\n        \\n        return (minEnergy<=0) ? 1: minEnergy;\\n            \\n \\n\\t}\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        int M=dungeon.size(),N=dungeon[0].size();\\n        return solve(0,0,dungeon,M,N);\\n    }\\n```\\n\\n# Memoization\\n```\\n   \\tint solve(int i, int j,vector<vector<int>> &p, int M, int N,vector<vector<int>> &dp)\\n\\t{\\n\\t    if(i>=M || j>=N) return INT_MAX;\\n            \\n        if(i==M-1 && j==N-1)\\n\\t    return p[i][j]<=0 ? 1+abs(p[i][j]) : 1;\\n        \\n        if(dp[i][j]!=-1) return dp[i][j];\\n            \\n\\t    int right = solve(i,j+1,p,M,N,dp);\\n        int left  = solve(i+1,j,p,M,N,dp);\\n        \\n        int minEnergy = min(left,right)-p[i][j];\\n        \\n        return dp[i][j] = (minEnergy<=0) ? 1: minEnergy;\\n            \\n \\n\\t}\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        int M=dungeon.size(),N=dungeon[0].size();\\n        vector<vector<int>>dp(M,vector<int>(N,-1));\\n        return solve(0,0,dungeon,M,N,dp);\\n    }\\n```\\n\\n# Pure DP:\\n```\\n int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        int M=dungeon.size(),N=dungeon[0].size();\\n        \\n        // we have to start from top 2 bottom as we require previous knowledge\\n        // for bottom to top its not possible as we require future knowledge\\n        \\n        vector<vector<int> > dp(M + 1, vector<int>(N + 1, INT_MAX));\\n        // reduntant rows\\n        dp[M-1][N]=1;\\n        dp[M][N-1]=1; \\n        \\n        for(int i=M-1;i>=0;i--)\\n        {\\n            for(int j=N-1;j>=0;j--)\\n            {\\n                int minEnergy = min(dp[i+1][j],dp[i][j+1])-dungeon[i][j];\\n                dp[i][j] = (minEnergy<=0) ? 1 : minEnergy;\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n   \\tint solve(int i, int j,vector<vector<int>> &p, int M, int N)\\n\\t{\\n\\t    if(i>=M || j>=N) return INT_MAX;\\n            \\n        if(i==M-1 && j==N-1)\\n\\t    return p[i][j]<=0 ? 1+abs(p[i][j]) : 1;\\n            \\n\\t    int right = solve(i,j+1,p,M,N);\\n        int left  = solve(i+1,j,p,M,N);\\n        \\n        int minEnergy = min(left,right)-p[i][j];\\n        \\n        return (minEnergy<=0) ? 1: minEnergy;\\n            \\n \\n\\t}\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        int M=dungeon.size(),N=dungeon[0].size();\\n        return solve(0,0,dungeon,M,N);\\n    }\\n```\n```\\n   \\tint solve(int i, int j,vector<vector<int>> &p, int M, int N,vector<vector<int>> &dp)\\n\\t{\\n\\t    if(i>=M || j>=N) return INT_MAX;\\n            \\n        if(i==M-1 && j==N-1)\\n\\t    return p[i][j]<=0 ? 1+abs(p[i][j]) : 1;\\n        \\n        if(dp[i][j]!=-1) return dp[i][j];\\n            \\n\\t    int right = solve(i,j+1,p,M,N,dp);\\n        int left  = solve(i+1,j,p,M,N,dp);\\n        \\n        int minEnergy = min(left,right)-p[i][j];\\n        \\n        return dp[i][j] = (minEnergy<=0) ? 1: minEnergy;\\n            \\n \\n\\t}\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        int M=dungeon.size(),N=dungeon[0].size();\\n        vector<vector<int>>dp(M,vector<int>(N,-1));\\n        return solve(0,0,dungeon,M,N,dp);\\n    }\\n```\n```\\n int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        int M=dungeon.size(),N=dungeon[0].size();\\n        \\n        // we have to start from top 2 bottom as we require previous knowledge\\n        // for bottom to top its not possible as we require future knowledge\\n        \\n        vector<vector<int> > dp(M + 1, vector<int>(N + 1, INT_MAX));\\n        // reduntant rows\\n        dp[M-1][N]=1;\\n        dp[M][N-1]=1; \\n        \\n        for(int i=M-1;i>=0;i--)\\n        {\\n            for(int j=N-1;j>=0;j--)\\n            {\\n                int minEnergy = min(dp[i+1][j],dp[i][j+1])-dungeon[i][j];\\n                dp[i][j] = (minEnergy<=0) ? 1 : minEnergy;\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1342157,
                "title": "faster-easy",
                "content": "***Do upvote if you like the solution to keep me motivated*** \\uD83D\\uDE0A\\u270C\\n```\\nclass Solution {\\npublic:\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n      int m = dungeon.size(), n = dungeon[0].size();\\n      vector<vector<int>> dp(m + 1, vector<int>(n + 1, INT_MAX)); \\n      dp[m][n - 1] = 1; \\n      dp[m - 1][n] = 1;\\n      for (int i = m - 1; i >= 0; i--) \\n     {\\n        for (int j = n - 1; j >= 0; j--) \\n      {     \\n          dp[i][j] = max(1, min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j]);\\n      }\\n     }\\n       return dp[0][0];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n      int m = dungeon.size(), n = dungeon[0].size();\\n      vector<vector<int>> dp(m + 1, vector<int>(n + 1, INT_MAX)); \\n      dp[m][n - 1] = 1; \\n      dp[m - 1][n] = 1;\\n      for (int i = m - 1; i >= 0; i--) \\n     {\\n        for (int j = n - 1; j >= 0; j--) \\n      {     \\n          dp[i][j] = max(1, min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j]);\\n      }\\n     }\\n       return dp[0][0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 916283,
                "title": "java-recursive-tle-memoization-2d-bottom-up-1d-bottom-up",
                "content": "```\\n- It will be difficult to determine the initial health of the knight\\n\\t- But, we can predict the amount the health that the knight should end on AFTER he has saved the princess\\n\\t\\t- If the princess is located at \\'m - 1, n - 1\\'\\n\\t\\t\\t- Then if the knight continues to move rightward or downward\\n\\t\\t\\t\\t- The knight\\'s hp at \\'m - 1, n\\' or \\'m, n - 1\\' should be equal to 1\\n- We will implement a recursive approach starting from the top left\\n\\t- In each of the recursive call\\n\\t\\t- We will move downward or rightward\\n\\t\\t\\t- We will pick the choice that will give us the least amount of hp\\n\\t\\t- In order to stay at the current cell at \\'r,c\\'\\n\\t\\t\\t- The minimum health needs to be \\'min health of going rightward or downward - dungeon[r][c]\\'\\n\\t\\t\\t- We should note that if min health goes below 0\\n\\t\\t\\t\\t- We have to default the min health to 1\\n```\\n```\\npublic class DungeonGameRecursiveApproach {\\n    public int calculateMinimumHP(int[][] dungeon) {\\n        if (dungeon.length == 0) return 0;\\n\\n        return calculateMinimumHP(0, 0, dungeon, dungeon.length, dungeon[0].length);\\n    }\\n\\n    private int calculateMinimumHP(int r, int c, int[][] dungeon, int m, int n) {\\n        if ((r == m && c == n - 1) || (r == m - 1 && c == n)) return 1;\\n        if (r == m || c == n) return Integer.MAX_VALUE;\\n\\n        int health1 = calculateMinimumHP(r, c + 1, dungeon, m, n);\\n        int health2 = calculateMinimumHP(r + 1, c, dungeon, m, n);\\n        int minHealth = Math.min(health1, health2) - dungeon[r][c];\\n\\n        return Math.max(1, minHealth);\\n    }\\n}\\n```\\n```\\npublic class DungeonGameMemoizationApproach {\\n    public int calculateMinimumHP(int[][] dungeon) {\\n        if (dungeon.length == 0) return 0;\\n\\n        int m = dungeon.length, n = dungeon[0].length;\\n        return calculateMinimumHP(0, 0, dungeon, m, n, new int[m + 1][n + 1]);\\n    }\\n\\n    private int calculateMinimumHP(int r, int c, int[][] dungeon, int m, int n, int[][] memo) {\\n        if ((r == m && c == n - 1) || (r == m - 1 && c == n)) return 1;\\n        if (r == m || c == n) return Integer.MAX_VALUE;\\n        if (memo[r][c] != 0) return memo[r][c];\\n\\n        int health1 = calculateMinimumHP(r, c + 1, dungeon, m, n, memo);\\n        int health2 = calculateMinimumHP(r + 1, c, dungeon, m, n, memo);\\n        int minHealth = Math.min(health1, health2) - dungeon[r][c];\\n\\n        return memo[r][c] = Math.max(1, minHealth);\\n    }\\n}\\n```\\n```\\npublic class DungeonGameBottomUp2DApproach {\\n    public int calculateMinimumHP(int[][] dungeon) {\\n        int m = dungeon.length, n = dungeon[0].length;\\n        int[][] minHealth = new int[m + 1][n + 1];\\n\\n        for (int r = m; r >= 0; r--) {\\n            for (int c = n; c >= 0; c--) {\\n                if ((r == m && c == n - 1) || (r == m - 1 && c == n)) {\\n                    minHealth[r][c] = 1;\\n                    continue;\\n                }\\n\\n                if (r == m || c == n) {\\n                    minHealth[r][c] = Integer.MAX_VALUE;\\n                    continue;\\n                }\\n\\n                minHealth[r][c] = Math.max(1, Math.min(minHealth[r + 1][c], minHealth[r][c + 1]) - dungeon[r][c]);\\n            }\\n        }\\n\\n        return minHealth[0][0];\\n    }\\n}\\n```\\n```\\npublic class DungeonGameBottomUp1DApproach {\\n    public int calculateMinimumHP(int[][] dungeon) {\\n        int m = dungeon.length, n = dungeon[0].length;\\n        int[] minHealth = new int[n + 1];\\n\\n        for (int r = m; r >= 0; r--) {\\n            for (int c = n; c >= 0; c--) {\\n                if ((r == m && c == n - 1) || (r == m - 1 && c == n)) {\\n                    minHealth[c] = 1;\\n                    continue;\\n                }\\n\\n                if (r == m || c == n) {\\n                    minHealth[c] = Integer.MAX_VALUE;\\n                    continue;\\n                }\\n\\n                minHealth[c] = Math.max(1, Math.min(minHealth[c], minHealth[c + 1]) - dungeon[r][c]);\\n            }\\n        }\\n\\n        return minHealth[0];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n- It will be difficult to determine the initial health of the knight\\n\\t- But, we can predict the amount the health that the knight should end on AFTER he has saved the princess\\n\\t\\t- If the princess is located at \\'m - 1, n - 1\\'\\n\\t\\t\\t- Then if the knight continues to move rightward or downward\\n\\t\\t\\t\\t- The knight\\'s hp at \\'m - 1, n\\' or \\'m, n - 1\\' should be equal to 1\\n- We will implement a recursive approach starting from the top left\\n\\t- In each of the recursive call\\n\\t\\t- We will move downward or rightward\\n\\t\\t\\t- We will pick the choice that will give us the least amount of hp\\n\\t\\t- In order to stay at the current cell at \\'r,c\\'\\n\\t\\t\\t- The minimum health needs to be \\'min health of going rightward or downward - dungeon[r][c]\\'\\n\\t\\t\\t- We should note that if min health goes below 0\\n\\t\\t\\t\\t- We have to default the min health to 1\\n```\n```\\npublic class DungeonGameRecursiveApproach {\\n    public int calculateMinimumHP(int[][] dungeon) {\\n        if (dungeon.length == 0) return 0;\\n\\n        return calculateMinimumHP(0, 0, dungeon, dungeon.length, dungeon[0].length);\\n    }\\n\\n    private int calculateMinimumHP(int r, int c, int[][] dungeon, int m, int n) {\\n        if ((r == m && c == n - 1) || (r == m - 1 && c == n)) return 1;\\n        if (r == m || c == n) return Integer.MAX_VALUE;\\n\\n        int health1 = calculateMinimumHP(r, c + 1, dungeon, m, n);\\n        int health2 = calculateMinimumHP(r + 1, c, dungeon, m, n);\\n        int minHealth = Math.min(health1, health2) - dungeon[r][c];\\n\\n        return Math.max(1, minHealth);\\n    }\\n}\\n```\n```\\npublic class DungeonGameMemoizationApproach {\\n    public int calculateMinimumHP(int[][] dungeon) {\\n        if (dungeon.length == 0) return 0;\\n\\n        int m = dungeon.length, n = dungeon[0].length;\\n        return calculateMinimumHP(0, 0, dungeon, m, n, new int[m + 1][n + 1]);\\n    }\\n\\n    private int calculateMinimumHP(int r, int c, int[][] dungeon, int m, int n, int[][] memo) {\\n        if ((r == m && c == n - 1) || (r == m - 1 && c == n)) return 1;\\n        if (r == m || c == n) return Integer.MAX_VALUE;\\n        if (memo[r][c] != 0) return memo[r][c];\\n\\n        int health1 = calculateMinimumHP(r, c + 1, dungeon, m, n, memo);\\n        int health2 = calculateMinimumHP(r + 1, c, dungeon, m, n, memo);\\n        int minHealth = Math.min(health1, health2) - dungeon[r][c];\\n\\n        return memo[r][c] = Math.max(1, minHealth);\\n    }\\n}\\n```\n```\\npublic class DungeonGameBottomUp2DApproach {\\n    public int calculateMinimumHP(int[][] dungeon) {\\n        int m = dungeon.length, n = dungeon[0].length;\\n        int[][] minHealth = new int[m + 1][n + 1];\\n\\n        for (int r = m; r >= 0; r--) {\\n            for (int c = n; c >= 0; c--) {\\n                if ((r == m && c == n - 1) || (r == m - 1 && c == n)) {\\n                    minHealth[r][c] = 1;\\n                    continue;\\n                }\\n\\n                if (r == m || c == n) {\\n                    minHealth[r][c] = Integer.MAX_VALUE;\\n                    continue;\\n                }\\n\\n                minHealth[r][c] = Math.max(1, Math.min(minHealth[r + 1][c], minHealth[r][c + 1]) - dungeon[r][c]);\\n            }\\n        }\\n\\n        return minHealth[0][0];\\n    }\\n}\\n```\n```\\npublic class DungeonGameBottomUp1DApproach {\\n    public int calculateMinimumHP(int[][] dungeon) {\\n        int m = dungeon.length, n = dungeon[0].length;\\n        int[] minHealth = new int[n + 1];\\n\\n        for (int r = m; r >= 0; r--) {\\n            for (int c = n; c >= 0; c--) {\\n                if ((r == m && c == n - 1) || (r == m - 1 && c == n)) {\\n                    minHealth[c] = 1;\\n                    continue;\\n                }\\n\\n                if (r == m || c == n) {\\n                    minHealth[c] = Integer.MAX_VALUE;\\n                    continue;\\n                }\\n\\n                minHealth[c] = Math.max(1, Math.min(minHealth[c], minHealth[c + 1]) - dungeon[r][c]);\\n            }\\n        }\\n\\n        return minHealth[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 882429,
                "title": "java-0ms-100-time-and-95-99-space-memoization",
                "content": "```\\nclass Solution {\\n    public int calculateMinimumHP(int[][] dungeon) {\\n        int r = findMin(dungeon, 0, 0, new Integer[dungeon.length][dungeon[0].length]);\\n        return r <= 0 ? -r+1 : 1;\\n    }\\n    \\n    int findMin(int[][] dn, int i, int j, Integer[][] memo){\\n        if(i == dn.length-1 && j == dn[0].length-1) return dn[i][j];\\n        if(i>=dn.length || j>=dn[0].length) return Integer.MIN_VALUE;\\n        \\n        if(memo[i][j] != null) return memo[i][j];\\n        \\n        int r1 = findMin(dn, i, j+1, memo);\\n        int r2 = findMin(dn, i+1, j, memo);\\n        int r = Math.max(r1, r2);\\n        r = Math.min(dn[i][j], r+dn[i][j]);\\n        memo[i][j] = r;\\n        return memo[i][j];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int calculateMinimumHP(int[][] dungeon) {\\n        int r = findMin(dungeon, 0, 0, new Integer[dungeon.length][dungeon[0].length]);\\n        return r <= 0 ? -r+1 : 1;\\n    }\\n    \\n    int findMin(int[][] dn, int i, int j, Integer[][] memo){\\n        if(i == dn.length-1 && j == dn[0].length-1) return dn[i][j];\\n        if(i>=dn.length || j>=dn[0].length) return Integer.MIN_VALUE;\\n        \\n        if(memo[i][j] != null) return memo[i][j];\\n        \\n        int r1 = findMin(dn, i, j+1, memo);\\n        int r2 = findMin(dn, i+1, j, memo);\\n        int r = Math.max(r1, r2);\\n        r = Math.min(dn[i][j], r+dn[i][j]);\\n        memo[i][j] = r;\\n        return memo[i][j];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 779712,
                "title": "python-top-down-bottom-up-soln-dp",
                "content": "**Top-Down**\\n\\n```\\nclass Solution:\\n    def dp(self, A, i, j, dp):\\n        m = len(A)\\n        n = len(A[0])\\n        if dp[i][j] != float(\\'inf\\'):\\n            return dp[i][j]\\n\\n        if i == m or j == n:\\n            return float(\\'inf\\')\\n\\n        if i == m-1 and j == n-1:\\n            hp = 1 - A[i][j] if A[i][j] <= 0 else 1\\n        else:\\n            hp = min(self.dp(A,i+1,j,dp), self.dp(A,i,j+1,dp)) - A[i][j]\\n\\n        dp[i][j] = 1 if hp <= 0 else hp\\n        return dp[i][j]\\n    \\n    def calculateMinimumHP(self, A: List[List[int]]) -> int:\\n        m = len(A)\\n        n = len(A[0])\\n        dp = [[float(\\'inf\\')]*(n+1) for _ in range(m+1)]\\n        return self.dp(A,0,0,dp)\\n```\\n\\n**Bottom-Up**\\n\\n```\\nclass Solution:\\n    def calculateMinimumHP(self, A: List[List[int]]) -> int:\\n        m = len(A)\\n        n = len(A[0])\\n        dp = [[float(\\'inf\\')]*(n+1) for _ in range(m+1)]\\n        \\n        dp[m][n-1] = 1\\n        dp[m-1][n] = 1\\n\\n        for i in reversed(range(m)):\\n            for j in reversed(range(n)):\\n                dp[i][j] = max(min(dp[i+1][j], dp[i][j+1]) - A[i][j], 1)\\n                \\n        return dp[0][0]\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def dp(self, A, i, j, dp):\\n        m = len(A)\\n        n = len(A[0])\\n        if dp[i][j] != float(\\'inf\\'):\\n            return dp[i][j]\\n\\n        if i == m or j == n:\\n            return float(\\'inf\\')\\n\\n        if i == m-1 and j == n-1:\\n            hp = 1 - A[i][j] if A[i][j] <= 0 else 1\\n        else:\\n            hp = min(self.dp(A,i+1,j,dp), self.dp(A,i,j+1,dp)) - A[i][j]\\n\\n        dp[i][j] = 1 if hp <= 0 else hp\\n        return dp[i][j]\\n    \\n    def calculateMinimumHP(self, A: List[List[int]]) -> int:\\n        m = len(A)\\n        n = len(A[0])\\n        dp = [[float(\\'inf\\')]*(n+1) for _ in range(m+1)]\\n        return self.dp(A,0,0,dp)\\n```\n```\\nclass Solution:\\n    def calculateMinimumHP(self, A: List[List[int]]) -> int:\\n        m = len(A)\\n        n = len(A[0])\\n        dp = [[float(\\'inf\\')]*(n+1) for _ in range(m+1)]\\n        \\n        dp[m][n-1] = 1\\n        dp[m-1][n] = 1\\n\\n        for i in reversed(range(m)):\\n            for j in reversed(range(n)):\\n                dp[i][j] = max(min(dp[i+1][j], dp[i][j+1]) - A[i][j], 1)\\n                \\n        return dp[0][0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 699902,
                "title": "a-solution-easy-on-eyes-of-programming-noobs-like-us",
                "content": "**Approach** \\n    this question is similar to questions like \"Number of ways to reach Home\" or \"Minimum number of moves to reach destination\"\\n    Now for dp\\n    First Question\\n   **what will every cell in dp represent?**\\n    every cell should represent the minimum power required to reach the cell\\n    \\n**how to find the minimum power for each cell?**\\n Minimum of power \"magnitude wise\" required to reach the cell +value of current cell \\n\\nmore formally \\n   \\n   currpow=dungeon[i][j]+\\n\\t**(if both right and down possible)**\\n\\t\\n   ```\\n /*if magnitude(right)<magnitude(down)\\n     currpow+=right\\n         else\\n       currpow+=down */ \\n```    \\n    so if power for a cell comes out to be positive what should be the minimum number required to reach the cell?\\n    it should be zero\\n    for negative power the value should be stored as it is in the table\\n    also the health should  be atleast 1\\nclass Solution {\\n  \\n    public int calculateMinimumHP(int[][] dungeon) {\\n     int n=dungeon.length,m=dungeon[0].length;\\n       int [][] dp=new int[n][m];\\n       //start filling up table in top down manner\\n        dp[n-1][m-1]=dungeon[n-1][m-1]>0?0:dungeon[n-1][m-1];\\n        //for last row only right moves possible\\n       for(int i=m-2;i>=0;i--)\\n           dp[n-1][i]=dungeon[n-1][i]+dp[n-1][i+1]>0?0:dungeon[n-1][i]+dp[n-1][i+1];\\n        //for last column only down moves possible\\n      for(int i=n-2;i>=0;i--)\\n          dp[i][m-1]=dungeon[i][m-1]+dp[i+1][m-1]>0?0:dungeon[i][m-1]+dp[i+1][m-1];\\n          for(int i=n-2;i>=0;i--)\\n          {\\n              for(int j=m-2;j>=0;j--)\\n              {\\n                  int temp=dungeon[i][j];\\n                  //both down and right moves are possible\\n                  //why abs?\\n\\t\\t\\t\\t  \\n                  //think of it like this \"-\" only denotes that we have to give power\\n\\t\\t\\t\\t  \\n                  //so only magnitude is relevant to determine the optimal move\\n\\t\\t\\t\\t \\n                  if(Math.abs(dp[i+1][j])<Math.abs(dp[i][j+1]))\\n                  {\\n                      temp+=dp[i+1][j];\\n                  }\\n                  else\\n                  {\\n                      temp+=dp[i][j+1];\\n                  }\\n                  //don\\'t do something like below\\n                  //bcoz we need to add negative value in case both are negative\\n                  //like -2 and -3 we need to add 2 and not 3\\n                  //int temp=dungeon[i][j]+Math.min(Math.abs(dp[i+1][j]),Math.abs(dp[i][j+1]));\\n                  dp[i][j]=temp>0?0:temp;\\n              }\\n          }\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                System.out.print(dp[i][j]+\" \");\\n            }\\n            System.out.println();\\n        }\\n        //why abs?\\n        //we care for magnitude only\\n        // +1 bcoz we need atleast 1 health\\n       return Math.abs(dp[0][0])+1;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\n /*if magnitude(right)<magnitude(down)\\n     currpow+=right\\n         else\\n       currpow+=down */ \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 698935,
                "title": "python-3-dp-solution-easy-to-understand-explanation-o-m-n",
                "content": "### **Preface**\\n\\nMany of the solutions I\\'ve seen have made it really difficult to understand what it is we are trying to solve for and how we build an optimal solution, so this post aims to remedy that. A quick look at the problem seems to indicate that DP is a good approach to solving this problem and this is indeed the case.\\n\\n### **First Attempt**\\n\\nYou might try to solve this by building up from the beginning of the maze and trying to find out the minimal health required along the way. The problem is that we cannot make a locally optimal choice in this way because which path we depends on how much health we will need in the future! This brings us to an important observation: we can solve the problem if we build the solution in reverse.\\n\\n### **Solution**\\n\\n* Let `M` denote the number of rows.\\n* Let `N` denote the number of columns.\\n* Let `dp` denote an `M` by `N` 2D list.\\n\\n##### **Princess cell**\\n\\nFor each cell in `dp` we want to know what is the minimal health we need in that cell to survive. If we look at just the subproblem of just the last square we see that we can determine how much health we need with the following choice:\\n* if `dungeon[M-1][N-1] < 0` then `1 - dungeon[M-1][N-1]` is the amount of health we need to survive.\\n* if `dungeon[M-1][N-1] >= 0` then `1` is the amount of health we need to survive.\\n\\nThis brings us to the first step: `dp[M-1][N-1] = max(1, 1 - dungeon[M-1][N-1])`\\n\\n##### **Last row and column**\\n\\nFor the subproblem of just the Mth row we can build the minimum health required to survive by working in reverse. Starting with index `i = M-2` and working backward to index `i = 0` we have the following choices to make:\\n* if `dp[i+1][N-1] - dungeon[i][N-1] < 0` then we have enough health to survive and could use the minimal amount.\\n* if `dp[i+1][N-1] - dungeon[i][N-1] >= 0` then we need more health to survive and calculate how much we were short by.\\n\\nThis gives us our row iteration: `dp[i][N - 1] = max(1, dp[i + 1][N - 1] - dungeon[i][N - 1])`\\n\\nSimilar steps to the row logic give use our column iteration: `dp[M - 1][j] = max(1, dp[M - 1][j + 1] - dungeon[M - 1][j])`\\n\\n##### **All other cells**\\n\\nFinally, now that we\\'ve figure out the cells where there isn\\'t a choice in path, we start to look at the cells where there is and come up with a way to decide how much health we will need if we start at those cells. For a given cell `dp[i][j]` we need to do the following:\\n1. Determine which of the cells to the bottom (`dp[i + 1][j]`) or to the right (`dp[i][j + 1]`) requires the least amount of health when entered.\\n2. Subtract the current cell\\'s damage value (`dungeon[i][j]`) from the minimal value in step 1 to determine how much health we need to have to survive.\\n3. Set the health to 1 if the value in step 3 is less than 1 because we know 1 health is sufficient.\\n\\nThese steps can be written as:\\n\\n```\\nhealth_required = min(dp[i + 1][j], dp[i][j + 1])\\nhealth_required -= dungeon[i][j]\\ndp[i][j] = max(1, health_required)\\n```\\n\\nCombining these steps gives us our final step: `dp[i][j] = max(1, min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j])`\\n\\n### **Code**\\n\\nCombining the steps we just derived we get the DP solution below. If you have any questions or suggestions for improvements please comment below!\\n\\n```\\ndef calculateMinimumHP(self, dungeon: List[List[int]]) -> int:\\n    M = len(dungeon)\\n    if M == 0:\\n        return 0\\n    N = len(dungeon[0])\\n    if N == 0:\\n        return 0\\n    dp = [[0 for _ in row] for row in dungeon]\\n    # Set health for last cell\\n    dp[M - 1][N - 1] = max(1, 1 - dungeon[M - 1][N - 1])\\n    # There\\'s no choice for health on the Mth row and Nth column\\n    for i in reversed(range(0, M - 1)):\\n        dp[i][N - 1] = max(1, dp[i + 1][N - 1] - dungeon[i][N - 1])\\n    for j in reversed(range(0, N - 1)):\\n        dp[M - 1][j] = max(1, dp[M - 1][j + 1] - dungeon[M - 1][j])\\n    # Our goal is to minimize the health required, but clamp this value by the smallest health value\\n    for i in reversed(range(M - 1)):\\n        for j in reversed(range(N - 1)):\\n            dp[i][j] = max(1, min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j])\\n    return dp[0][0]\\n```",
                "solutionTags": [],
                "code": "```\\nhealth_required = min(dp[i + 1][j], dp[i][j + 1])\\nhealth_required -= dungeon[i][j]\\ndp[i][j] = max(1, health_required)\\n```\n```\\ndef calculateMinimumHP(self, dungeon: List[List[int]]) -> int:\\n    M = len(dungeon)\\n    if M == 0:\\n        return 0\\n    N = len(dungeon[0])\\n    if N == 0:\\n        return 0\\n    dp = [[0 for _ in row] for row in dungeon]\\n    # Set health for last cell\\n    dp[M - 1][N - 1] = max(1, 1 - dungeon[M - 1][N - 1])\\n    # There\\'s no choice for health on the Mth row and Nth column\\n    for i in reversed(range(0, M - 1)):\\n        dp[i][N - 1] = max(1, dp[i + 1][N - 1] - dungeon[i][N - 1])\\n    for j in reversed(range(0, N - 1)):\\n        dp[M - 1][j] = max(1, dp[M - 1][j + 1] - dungeon[M - 1][j])\\n    # Our goal is to minimize the health required, but clamp this value by the smallest health value\\n    for i in reversed(range(M - 1)):\\n        for j in reversed(range(N - 1)):\\n            dp[i][j] = max(1, min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j])\\n    return dp[0][0]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 698212,
                "title": "java-binary-search-on-answer-and-check-if-true",
                "content": "We can binary search on answer in `O(log K)` where K is maximum possible value\\nTo check we need `O(n m)` time.\\nOverall `O(n m log k)`\\n\\n```\\nclass Solution {\\n    public int calculateMinimumHP(int[][] dungeon) {\\n        int left = 1;\\n        int right = Integer.MAX_VALUE;\\n        \\n        while (left < right) {\\n            int middle = left + ((right - left) >> 1);\\n            \\n            if (isReachable(dungeon, middle)) {\\n                right = middle;\\n            } else {\\n                left = middle + 1;\\n            }\\n        }\\n        \\n        return left;\\n    }\\n    \\n    private boolean isReachable(int[][] dungeon, int initialValue) {\\n        int n = dungeon.length;\\n        int m = dungeon[0].length;\\n        int[][] matrix = new int[n][m];\\n        matrix[0][0] = dungeon[0][0] + initialValue;\\n        \\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (i == 0 && j == 0) {\\n                    matrix[0][0] = dungeon[0][0] + initialValue;\\n                    continue;\\n                }\\n                \\n                if (j > 0 && matrix[i][j - 1] > 0) {\\n                    matrix[i][j] = Math.max(matrix[i][j], matrix[i][j - 1] + dungeon[i][j]);\\n                }\\n                \\n                if (i > 0 && matrix[i - 1][j] > 0) {\\n                    matrix[i][j] = Math.max(matrix[i][j], matrix[i - 1][j] + dungeon[i][j]);\\n                }\\n            }\\n        }\\n        \\n        return matrix[n - 1][m - 1] > 0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int calculateMinimumHP(int[][] dungeon) {\\n        int left = 1;\\n        int right = Integer.MAX_VALUE;\\n        \\n        while (left < right) {\\n            int middle = left + ((right - left) >> 1);\\n            \\n            if (isReachable(dungeon, middle)) {\\n                right = middle;\\n            } else {\\n                left = middle + 1;\\n            }\\n        }\\n        \\n        return left;\\n    }\\n    \\n    private boolean isReachable(int[][] dungeon, int initialValue) {\\n        int n = dungeon.length;\\n        int m = dungeon[0].length;\\n        int[][] matrix = new int[n][m];\\n        matrix[0][0] = dungeon[0][0] + initialValue;\\n        \\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (i == 0 && j == 0) {\\n                    matrix[0][0] = dungeon[0][0] + initialValue;\\n                    continue;\\n                }\\n                \\n                if (j > 0 && matrix[i][j - 1] > 0) {\\n                    matrix[i][j] = Math.max(matrix[i][j], matrix[i][j - 1] + dungeon[i][j]);\\n                }\\n                \\n                if (i > 0 && matrix[i - 1][j] > 0) {\\n                    matrix[i][j] = Math.max(matrix[i][j], matrix[i - 1][j] + dungeon[i][j]);\\n                }\\n            }\\n        }\\n        \\n        return matrix[n - 1][m - 1] > 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 537454,
                "title": "binary-search-c",
                "content": "```\\nclass Solution {\\nprivate:\\n    int m, n;\\npublic:\\n    bool savePricess(vector<vector<int>> d, int health) {\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                int prev = -1;\\n                if (i == 0 && j == 0) {\\n                    d[i][j] += health;\\n                    continue;\\n                } else if (i == 0) {\\n                    prev = d[i][j-1];\\n                } else if (j == 0) {\\n                    prev = d[i-1][j];\\n                } else {\\n                    prev = max(d[i-1][j], d[i][j-1]);\\n                }\\n                if (prev <= 0) d[i][j] = -1;\\n                else d[i][j] += prev;\\n            }\\n        }\\n        return d[m-1][n-1] > 0;\\n    }\\n    \\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        m = dungeon.size(), n = dungeon[0].size();\\n        int lo = 1, hi = INT_MAX;\\n        while (lo < hi) {\\n            int mid = lo + (hi-lo)/2;\\n            if (savePricess(dungeon, mid)) {\\n                hi = mid;\\n            } else {\\n                lo = mid+1;\\n            }\\n        }\\n        return hi;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n    int m, n;\\npublic:\\n    bool savePricess(vector<vector<int>> d, int health) {\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                int prev = -1;\\n                if (i == 0 && j == 0) {\\n                    d[i][j] += health;\\n                    continue;\\n                } else if (i == 0) {\\n                    prev = d[i][j-1];\\n                } else if (j == 0) {\\n                    prev = d[i-1][j];\\n                } else {\\n                    prev = max(d[i-1][j], d[i][j-1]);\\n                }\\n                if (prev <= 0) d[i][j] = -1;\\n                else d[i][j] += prev;\\n            }\\n        }\\n        return d[m-1][n-1] > 0;\\n    }\\n    \\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        m = dungeon.size(), n = dungeon[0].size();\\n        int lo = 1, hi = INT_MAX;\\n        while (lo < hi) {\\n            int mid = lo + (hi-lo)/2;\\n            if (savePricess(dungeon, mid)) {\\n                hi = mid;\\n            } else {\\n                lo = mid+1;\\n            }\\n        }\\n        return hi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 517679,
                "title": "java-memozied-beats-100-0ms-contains-tabulated-approach-as-well",
                "content": "The Memoized Approach took 0 ms and beat 100%. The Tabulated approach took 2ms.\\nUncomment to run bottom up approach \\n```\\n\\nclass Solution \\n{\\n    \\n    \\n    //Top Down - Memoized\\n    \\n    int[][] dp; int rows, cols;\\n    public int calculateMinimumHP(int[][] A)\\n    {\\n        rows = A.length; cols = A[0].length;\\n        dp = new int[rows][cols];\\n        \\n        calculateMinimumHPHelper(A, 0, 0);\\n        return dp[0][0];\\n    }\\n    \\n    public int calculateMinimumHPHelper(int[][] A, int i, int j)\\n    {\\n        if(i >= rows || j >= cols)\\n            return Integer.MAX_VALUE;\\n       \\n        if(dp[i][j] > 0)\\n            return dp[i][j];\\n            \\n        int leftPath = calculateMinimumHPHelper(A, i, j+ 1);\\n        int rightPath = calculateMinimumHPHelper(A, i + 1, j);\\n        \\n        \\n        // Handling the only case which is the right bottom seperately.\\n        if(leftPath == Integer.MAX_VALUE && rightPath == Integer.MAX_VALUE)\\n        {\\n            dp[i][j] = A[i][j] > 0 ? 1 : Math.abs(A[i][j]) + 1;\\n            return dp[i][j];\\n        }\\n            \\n        int bestPath = Math.min(leftPath, rightPath);\\n        \\n        if(A[i][j] > 0)\\n            dp[i][j] = Math.max(bestPath - A[i][j], 1);\\n            \\n        else\\n            dp[i][j] = Math.abs(A[i][j]) + bestPath;\\n        \\n        return dp[i][j];\\n    }\\n   \\n    \\n    \\n    \\n    /*\\n    //Bottom Up - Tabulated\\n    public int calculateMinimumHP(int[][] A)\\n    {\\n        int rows = A.length - 1, cols = A[0].length - 1;\\n        int[][] dp = new int[rows + 1][cols + 1];\\n\\n        dp[rows][cols] = A[rows][cols] >= 0 ? 1 :  Math.abs(A[rows][cols]) + 1;\\n\\n        for(int i = rows - 1; i >= 0; i--)\\n        {\\n            if(dp[i + 1][cols] > A[i][cols])\\n                dp[i][cols] = dp[i+1][cols]- A[i][cols];\\n\\n            else\\n                dp[i][cols] = 1;\\n        }\\n\\n        for(int j = cols - 1; j >= 0; j--)\\n        {\\n            if(dp[rows][j + 1] > A[rows][j])\\n                dp[rows][j] = dp[rows][j + 1] - A[rows][j];\\n\\n            else\\n                dp[rows][j] = 1;\\n        }\\n        \\n\\n        for(int i = rows - 1; i >= 0; i--)\\n        {\\n            for(int j = cols - 1; j >= 0; j--)\\n            {\\n                if( A[i][j] < 0)\\n                    dp[i][j] = Math.abs(A[i][j]) + Math.min(dp[i+1][j], dp[i][j+1]);\\n\\n                else if(Math.min(dp[i+1][j], dp[i][j+1]) > A[i][j])\\n                    dp[i][j] = Math.min(dp[i+1][j], dp[i][j+1]) - A[i][j];\\n                    \\n                else\\n                    dp[i][j] = 1;\\n            }\\n        }\\n\\n        return dp[0][0];\\n    }\\n    */\\n    \\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\n\\nclass Solution \\n{\\n    \\n    \\n    //Top Down - Memoized\\n    \\n    int[][] dp; int rows, cols;\\n    public int calculateMinimumHP(int[][] A)\\n    {\\n        rows = A.length; cols = A[0].length;\\n        dp = new int[rows][cols];\\n        \\n        calculateMinimumHPHelper(A, 0, 0);\\n        return dp[0][0];\\n    }\\n    \\n    public int calculateMinimumHPHelper(int[][] A, int i, int j)\\n    {\\n        if(i >= rows || j >= cols)\\n            return Integer.MAX_VALUE;\\n       \\n        if(dp[i][j] > 0)\\n            return dp[i][j];\\n            \\n        int leftPath = calculateMinimumHPHelper(A, i, j+ 1);\\n        int rightPath = calculateMinimumHPHelper(A, i + 1, j);\\n        \\n        \\n        // Handling the only case which is the right bottom seperately.\\n        if(leftPath == Integer.MAX_VALUE && rightPath == Integer.MAX_VALUE)\\n        {\\n            dp[i][j] = A[i][j] > 0 ? 1 : Math.abs(A[i][j]) + 1;\\n            return dp[i][j];\\n        }\\n            \\n        int bestPath = Math.min(leftPath, rightPath);\\n        \\n        if(A[i][j] > 0)\\n            dp[i][j] = Math.max(bestPath - A[i][j], 1);\\n            \\n        else\\n            dp[i][j] = Math.abs(A[i][j]) + bestPath;\\n        \\n        return dp[i][j];\\n    }\\n   \\n    \\n    \\n    \\n    /*\\n    //Bottom Up - Tabulated\\n    public int calculateMinimumHP(int[][] A)\\n    {\\n        int rows = A.length - 1, cols = A[0].length - 1;\\n        int[][] dp = new int[rows + 1][cols + 1];\\n\\n        dp[rows][cols] = A[rows][cols] >= 0 ? 1 :  Math.abs(A[rows][cols]) + 1;\\n\\n        for(int i = rows - 1; i >= 0; i--)\\n        {\\n            if(dp[i + 1][cols] > A[i][cols])\\n                dp[i][cols] = dp[i+1][cols]- A[i][cols];\\n\\n            else\\n                dp[i][cols] = 1;\\n        }\\n\\n        for(int j = cols - 1; j >= 0; j--)\\n        {\\n            if(dp[rows][j + 1] > A[rows][j])\\n                dp[rows][j] = dp[rows][j + 1] - A[rows][j];\\n\\n            else\\n                dp[rows][j] = 1;\\n        }\\n        \\n\\n        for(int i = rows - 1; i >= 0; i--)\\n        {\\n            for(int j = cols - 1; j >= 0; j--)\\n            {\\n                if( A[i][j] < 0)\\n                    dp[i][j] = Math.abs(A[i][j]) + Math.min(dp[i+1][j], dp[i][j+1]);\\n\\n                else if(Math.min(dp[i+1][j], dp[i][j+1]) > A[i][j])\\n                    dp[i][j] = Math.min(dp[i+1][j], dp[i][j+1]) - A[i][j];\\n                    \\n                else\\n                    dp[i][j] = 1;\\n            }\\n        }\\n\\n        return dp[0][0];\\n    }\\n    */\\n    \\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 491281,
                "title": "short-java-dp-bottom-up-solution-beat-95",
                "content": "To build a dynamic programming solution need to take care two important things,\\n* The init values for each state, in this solution, set all start state values to MAX_VALUE, only set the target one to 1, because the state values should not less or equal to zero. \\n* The state transfer function, i.e, tranfer from last state to current state, and the state transfer function can conclude from examples. Below is the example, note that caculate from bottom to up and right to left, the value in () are state values. (M) stands for MAX_VALUE\\n\\n-2 (7)  -3 (5)    3 (2)\\n-5 (6) -10 (11) 1 (5)\\n10 (1)  30 (1)  -5 (6)\\n. (M)    . (M)        . (1)  . (M)\\n\\nThe caculation could have two steps, \\n* Minium target value, t = min(dp[i], dp[i+1]), which is the opptimize the better path and select the requires lesser starting life\\n* Update current dp[i] value based on t and current cell value num, as requires dp[i] + num >= t, and also requires dp[i] >= 1, so setting the state transfer function to max(1, t-num)\\n\\nWrite out to code implementation. \\n\\nThe time complexity is O(n*m), which n is the length of colum and m is the width of the row. \\n\\n```\\nclass Solution {\\n    public int calculateMinimumHP(int[][] dungeon) {\\n        if(dungeon==null || dungeon.length==0 || dungeon[0]==null || dungeon[0].length==0) return 0;\\n        \\n        int n = dungeon[0].length;\\n        int dp[] = new int[n + 1];\\n        Arrays.fill(dp, Integer.MAX_VALUE);\\n        dp[n-1] = 1;\\n        \\n        for(int row=dungeon.length-1; row>=0; row--) {\\n            for(int col=n-1; col>=0; col--) {\\n                int t = Math.min(dp[col], dp[col+1]);\\n                dp[col] = Math.max(1, t - dungeon[row][col]);\\n            }\\n        }\\n        \\n        return dp[0];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int calculateMinimumHP(int[][] dungeon) {\\n        if(dungeon==null || dungeon.length==0 || dungeon[0]==null || dungeon[0].length==0) return 0;\\n        \\n        int n = dungeon[0].length;\\n        int dp[] = new int[n + 1];\\n        Arrays.fill(dp, Integer.MAX_VALUE);\\n        dp[n-1] = 1;\\n        \\n        for(int row=dungeon.length-1; row>=0; row--) {\\n            for(int col=n-1; col>=0; col--) {\\n                int t = Math.min(dp[col], dp[col+1]);\\n                dp[col] = Math.max(1, t - dungeon[row][col]);\\n            }\\n        }\\n        \\n        return dp[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 464519,
                "title": "c-solution-time-98-with-explanation",
                "content": "```\\n/*\\n    https://leetcode.com/problems/dungeon-game/submissions/\\n*/\\n\\nclass Solution {\\npublic:\\n    /*\\n        Since the objective is to find the min val such that\\n        path never sees a negative value, so if we start from top,\\n        we can\\'t guarantee of finding a value which is min such that -ve\\n        never happens, at most we can a +ve val that can make that possible\\n        So we start from the destination cell and go towards the start.\\n        For each cell we find the min value that is needed if we have to reach the destination\\n        from that cell. Also each cell contribute to its right and down cells.\\n        So that value is simply the min value req to make \\n        dungeon(i, j) + min(dungeon(i,j+1), dungeon(i+1, j)) = +ve\\n        Since we start from destination cell we can have an initial value for the health, \\n        which is 1 in best case scenario. \\n    */\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        if(dungeon.empty())\\n            return 0;\\n        \\n        const int M = dungeon.size(), N = dungeon.front().size();\\n        vector<vector<int>> dp(M, vector<int>(N, INT_MAX));\\n        \\n        for(int i = M - 1; i >= 0; i--) {\\n            for(int j = N - 1; j >= 0; j--) {\\n                // if current dungeon value is +ve then, then below becomes negative so we can take\\n                // 1(min value for survival), if current dungeon val is negative then we calculate \\n                // the additional value req for current cell on top of min health for the contributing cells.\\n                if(i == M - 1 && j == N - 1)\\n                    dp[i][j] = max(1, 1 - dungeon[i][j]);\\n                else if(i == M - 1) // last row, each cell can allow movement towards right\\n                    dp[i][j] = max(1, dp[i][j+1] - dungeon[i][j]);\\n                else if(j == N - 1) // last column, each cell can allow movement towards bottom\\n                    dp[i][j] = max(1, dp[i+1][j] - dungeon[i][j]);\\n                else    // select the cell in left or right which requires least value \\n                    dp[i][j] = max(1, min(dp[i+1][j], dp[i][j+1]) - dungeon[i][j]);\\n            }\\n        }\\n        \\n        return dp[0][0];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n    https://leetcode.com/problems/dungeon-game/submissions/\\n*/\\n\\nclass Solution {\\npublic:\\n    /*\\n        Since the objective is to find the min val such that\\n        path never sees a negative value, so if we start from top,\\n        we can\\'t guarantee of finding a value which is min such that -ve\\n        never happens, at most we can a +ve val that can make that possible\\n        So we start from the destination cell and go towards the start.\\n        For each cell we find the min value that is needed if we have to reach the destination\\n        from that cell. Also each cell contribute to its right and down cells.\\n        So that value is simply the min value req to make \\n        dungeon(i, j) + min(dungeon(i,j+1), dungeon(i+1, j)) = +ve\\n        Since we start from destination cell we can have an initial value for the health, \\n        which is 1 in best case scenario. \\n    */\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        if(dungeon.empty())\\n            return 0;\\n        \\n        const int M = dungeon.size(), N = dungeon.front().size();\\n        vector<vector<int>> dp(M, vector<int>(N, INT_MAX));\\n        \\n        for(int i = M - 1; i >= 0; i--) {\\n            for(int j = N - 1; j >= 0; j--) {\\n                // if current dungeon value is +ve then, then below becomes negative so we can take\\n                // 1(min value for survival), if current dungeon val is negative then we calculate \\n                // the additional value req for current cell on top of min health for the contributing cells.\\n                if(i == M - 1 && j == N - 1)\\n                    dp[i][j] = max(1, 1 - dungeon[i][j]);\\n                else if(i == M - 1) // last row, each cell can allow movement towards right\\n                    dp[i][j] = max(1, dp[i][j+1] - dungeon[i][j]);\\n                else if(j == N - 1) // last column, each cell can allow movement towards bottom\\n                    dp[i][j] = max(1, dp[i+1][j] - dungeon[i][j]);\\n                else    // select the cell in left or right which requires least value \\n                    dp[i][j] = max(1, min(dp[i+1][j], dp[i][j+1]) - dungeon[i][j]);\\n            }\\n        }\\n        \\n        return dp[0][0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 321561,
                "title": "java-memorization",
                "content": "Suck at sloving this problem. Just rewrite into recursion from [this DP answer](https://leetcode.com/problems/dungeon-game/discuss/52859/Simple-Java-DP-code.) :P\\n\\n```java\\n    public int calculateMinimumHP(int[][] dungeon) {\\n        // boundary check\\n        if (dungeon == null || dungeon.length == 0 || dungeon[0].length == 0) return 0;\\n\\n        int m = dungeon.length;\\n        int n = dungeon[0].length;\\n        // init cache\\n        int[][] cache = new int[m + 1][n + 1];\\n        return dfs(0, 0, dungeon, cache);\\n    }\\n    \\n    public static int dfs(int m, int n, int[][] dungeon, int[][] cache) {\\n        if (m == dungeon.length - 1 && n > dungeon[0].length - 1) return 1;\\n        if (m > dungeon.length - 1 && n == dungeon[0].length - 1) return 1;\\n        if (m > dungeon.length - 1 || n > dungeon[0].length - 1) return Integer.MAX_VALUE;\\n        if (cache[m][n] == 0) {\\n            int minHP = Math.min(dfs(m + 1, n, dungeon, cache), dfs(m, n + 1, dungeon, cache)) - dungeon[m][n];\\n            cache[m][n] = (minHP <= 0) ? 1 : minHP;\\n        }\\n        return cache[m][n];\\n    }\\n```",
                "solutionTags": [],
                "code": "```java\\n    public int calculateMinimumHP(int[][] dungeon) {\\n        // boundary check\\n        if (dungeon == null || dungeon.length == 0 || dungeon[0].length == 0) return 0;\\n\\n        int m = dungeon.length;\\n        int n = dungeon[0].length;\\n        // init cache\\n        int[][] cache = new int[m + 1][n + 1];\\n        return dfs(0, 0, dungeon, cache);\\n    }\\n    \\n    public static int dfs(int m, int n, int[][] dungeon, int[][] cache) {\\n        if (m == dungeon.length - 1 && n > dungeon[0].length - 1) return 1;\\n        if (m > dungeon.length - 1 && n == dungeon[0].length - 1) return 1;\\n        if (m > dungeon.length - 1 || n > dungeon[0].length - 1) return Integer.MAX_VALUE;\\n        if (cache[m][n] == 0) {\\n            int minHP = Math.min(dfs(m + 1, n, dungeon, cache), dfs(m, n + 1, dungeon, cache)) - dungeon[m][n];\\n            cache[m][n] = (minHP <= 0) ? 1 : minHP;\\n        }\\n        return cache[m][n];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 52785,
                "title": "dfs-cache-beat-98-8-including-transfer-to-dp-space-optimize",
                "content": "DFS+Cache:\\n```\\npublic class Solution {\\n    int[][] cache;\\n    public int calculateMinimumHP(int[][] dungeon) {\\n        cache = new int[dungeon.length][dungeon[0].length];\\n        int ret = search(dungeon, 0, 0);\\n        return ret > 0 ? 1 : -ret + 1;\\n    }\\n    private int search(int[][] matrix, int x, int y) {\\n        if (x == matrix.length - 1 && y == matrix[0].length - 1) return matrix[x][y] > 0 ? 0 : matrix[x][y];\\n        if (x < 0 || y < 0 || x >= matrix.length || y >= matrix[0].length) return Integer.MIN_VALUE;\\n        if (cache[x][y] != 0) return cache[x][y] == -1 ? 0 : cache[x][y];\\n        \\n        int left = search(matrix, x + 1, y);\\n        int right = search(matrix, x, y + 1);\\n        int cur = matrix[x][y] + Math.max(left, right);\\n        \\n        cache[x][y] = cur > 0 ? -1 : cur;\\n        return cur > 0 ? 0 : cur;\\n    }\\n}\\n```\\nDP:\\n```\\npublic class Solution {\\n    public int calculateMinimumHP(int[][] dungeon) {\\n        int row = dungeon.length, col = dungeon[0].length;\\n        int[][] F = new int[row][col];\\n        for (int i = row - 1; i >= 0; i--) {\\n            for (int j = col - 1; j >= 0; j--) {\\n                if (i == row - 1 && j == col - 1) F[i][j] = dungeon[i][j] > 0 ? 0 : dungeon[i][j];\\n                else {\\n                    int left = i + 1 >= row ? Integer.MIN_VALUE : F[i + 1][j];\\n                    int right = j + 1 >= col ? Integer.MIN_VALUE : F[i][j + 1];\\n                    int cur = dungeon[i][j] + Math.max(left, right);\\n                    F[i][j] = cur > 0 ? 0 : cur;\\n                }\\n            }\\n        }\\n        return F[0][0] > 0 ? 1 : -F[0][0] + 1;\\n    }\\n}\\n```\\nSpace optimize to O(n):\\n```\\npublic class Solution {\\n    public int calculateMinimumHP(int[][] dungeon) {\\n        int row = dungeon.length, col = dungeon[0].length;\\n        int[][] F = new int[2][col];\\n        for (int i = row - 1; i >= 0; i--) {\\n            for (int j = col - 1; j >= 0; j--) {\\n                if (i == row - 1 && j == col - 1) F[i % 2][j] = dungeon[i][j] > 0 ? 0 : dungeon[i][j];\\n                else {\\n                    int left = i + 1 >= row ? Integer.MIN_VALUE : F[(i + 1) % 2][j];\\n                    int right = j + 1 >= col ? Integer.MIN_VALUE : F[i % 2][j + 1];\\n                    int cur = dungeon[i][j] + Math.max(left, right);\\n                    F[i % 2][j] = cur > 0 ? 0 : cur;\\n                }\\n            }\\n        }\\n        return F[0][0] > 0 ? 1 : -F[0][0] + 1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    int[][] cache;\\n    public int calculateMinimumHP(int[][] dungeon) {\\n        cache = new int[dungeon.length][dungeon[0].length];\\n        int ret = search(dungeon, 0, 0);\\n        return ret > 0 ? 1 : -ret + 1;\\n    }\\n    private int search(int[][] matrix, int x, int y) {\\n        if (x == matrix.length - 1 && y == matrix[0].length - 1) return matrix[x][y] > 0 ? 0 : matrix[x][y];\\n        if (x < 0 || y < 0 || x >= matrix.length || y >= matrix[0].length) return Integer.MIN_VALUE;\\n        if (cache[x][y] != 0) return cache[x][y] == -1 ? 0 : cache[x][y];\\n        \\n        int left = search(matrix, x + 1, y);\\n        int right = search(matrix, x, y + 1);\\n        int cur = matrix[x][y] + Math.max(left, right);\\n        \\n        cache[x][y] = cur > 0 ? -1 : cur;\\n        return cur > 0 ? 0 : cur;\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public int calculateMinimumHP(int[][] dungeon) {\\n        int row = dungeon.length, col = dungeon[0].length;\\n        int[][] F = new int[row][col];\\n        for (int i = row - 1; i >= 0; i--) {\\n            for (int j = col - 1; j >= 0; j--) {\\n                if (i == row - 1 && j == col - 1) F[i][j] = dungeon[i][j] > 0 ? 0 : dungeon[i][j];\\n                else {\\n                    int left = i + 1 >= row ? Integer.MIN_VALUE : F[i + 1][j];\\n                    int right = j + 1 >= col ? Integer.MIN_VALUE : F[i][j + 1];\\n                    int cur = dungeon[i][j] + Math.max(left, right);\\n                    F[i][j] = cur > 0 ? 0 : cur;\\n                }\\n            }\\n        }\\n        return F[0][0] > 0 ? 1 : -F[0][0] + 1;\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public int calculateMinimumHP(int[][] dungeon) {\\n        int row = dungeon.length, col = dungeon[0].length;\\n        int[][] F = new int[2][col];\\n        for (int i = row - 1; i >= 0; i--) {\\n            for (int j = col - 1; j >= 0; j--) {\\n                if (i == row - 1 && j == col - 1) F[i % 2][j] = dungeon[i][j] > 0 ? 0 : dungeon[i][j];\\n                else {\\n                    int left = i + 1 >= row ? Integer.MIN_VALUE : F[(i + 1) % 2][j];\\n                    int right = j + 1 >= col ? Integer.MIN_VALUE : F[i % 2][j + 1];\\n                    int cur = dungeon[i][j] + Math.max(left, right);\\n                    F[i % 2][j] = cur > 0 ? 0 : cur;\\n                }\\n            }\\n        }\\n        return F[0][0] > 0 ? 1 : -F[0][0] + 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 52839,
                "title": "my-short-c-solution",
                "content": "It is a typical DP question. The only trick is that we need to do search from the bottom right to the top left corner. The reason is that: if we do search in a normal top-left to bottom-right way, then at a middle point (i,j), we can not do local \"greedy\" decision (i.e. only keep the local optimal path and discard all the other paths) since there are two metrics here: one is the minimum points needed to reach the current point from the top-left corner and the other is the current left points that can be used for future move. We have to consider both to define \"optimal path\". However, if we do search in a reverse order, we only need to consider only one metric, which is the minimum points needed at (i,j) that enables us to move to the destination. We don't care how many points left at (i,j) when it moves from the top-left point, >=1 is enough. \\nThe recursion relationship is dp[i][j] = max(1, min(dp[i-1][j], dp[i][j+1]) - dungeon[i][j]) (here max(1,) is to guarantee that at least 1 point left when entering into [i][j]). Since dp[i][j] is only related to dp[i-1][j] and dp[i][j+1], so we can reduce dp to a one-dimensional array and do the recursion in a reverse order.\\n\\n    class Solution {\\n    public:\\n        int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n            int row = dungeon.size(), col= dungeon[0].size(),  i, j;\\n            vector<int> dp(col+1,INT_MAX);\\n    \\n            for(i=row-1, dp[col-1] = 1; i>=0;--i)\\n            for(j=col-1; j>=0; --j)\\n                dp[j] = max(1, min(dp[j], dp[j+1]) - dungeon[i][j]);\\n            \\n            return dp[0];    \\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n            int row = dungeon.size(), col= dungeon[0].size(),  i, j;\\n            vector<int> dp(col+1,INT_MAX);\\n    \\n            for(i=row-1, dp[col-1] = 1; i>=0;--i)\\n            for(j=col-1; j>=0; --j)\\n                dp[j] = max(1, min(dp[j], dp[j+1]) - dungeon[i][j]);\\n            \\n            return dp[0];    \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 52850,
                "title": "ac-solution-code",
                "content": "**Solutino1. Bottom-Up DP - Runtime = O(nm); Space = O(nm)**\\n\\n    Iterate from last row to first row:\\n    2-D table for the minimum DP.\\n    h[i][j] is the minimum helth to enter (i, j) \\n    h[0][0] is the anwser.\\t\\n\\n**JAVA Code:**\\n\\n    public int calculateMinimumHP(int[][] A) {\\n    \\tint n = A.length, m = A[0].length;\\n    \\tint dp[][] = new int[n][m];// dp[i][j]: minimum hp to enter (i, j) \\n    \\t\\n    \\tdp[n-1][m-1] = Math.max(-A[n-1][m-1], 0) + 1;// right-bottom node    \\t\\n    \\tfor (int i = n - 2; i >= 0; i--) // last row\\n    \\t\\tdp[i][m-1] = Math.max(1, dp[i+1][m-1] - A[i][m-1]);    \\t\\n    \\tfor (int j = m - 2; j >= 0; j--) // last column\\n    \\t\\tdp[n-1][j] = Math.max(1, dp[n-1][j+1] - A[n-1][j]);\\n    \\t\\n    \\tfor (int i = n - 2; i >= 0; i--) {// calculate dp table\\n    \\t\\tfor (int j = m - 2; j >= 0; j--) {\\n    \\t\\t\\tdp[i][j] = Math.min(dp[i][j+1], dp[i+1][j]);// right, down\\n    \\t\\t\\tdp[i][j] = Math.max(1, dp[i][j] - A[i][j]);\\n    \\t\\t}\\n    \\t}     \\t\\n        return dp[0][0];\\n    }\\n\\n**Solution2. Memorized DFS**\\n\\nRegular DFS without memorization will cause TLE error.\\n \\n    public int calculateMinimumHP(int[][] A) {\\n    \\tint maxDamages[][] = new int[A.length][A[0].length];// KEY optimization: Memorization for the previous results\\n    \\tfor (int i = 0; i < A.length; i++) Arrays.fill(maxDamages[i], Integer.MAX_VALUE);\\n    \\t\\n    \\tint maxDamage = DFS(A, 0, 0, maxDamages);\\n        return Math.max(0, -maxDamage) + 1;\\n    }\\n    \\n    int DFS(int[][] A, int i, int j, int maxDamages[][]) {// Total damage for one path\\n    \\tif (i > A.length - 1 || j > A[0].length - 1) return Integer.MIN_VALUE;    \\t\\n    \\tif (maxDamages[i][j] != Integer.MAX_VALUE) return maxDamages[i][j];// **Return the memorized result, to avoid duplicated DFS\\n    \\t\\n    \\tint maxDamage;\\n    \\tif (i == A.length - 1 && j == A[0].length - 1) {// Right-bottom node \\t\\n    \\t\\tmaxDamage = A[i][j];\\n    \\t} else {\\n    \\t\\tint right = DFS(A, i, j+1, maxDamages);\\n    \\t\\tint down =  DFS(A, i+1, j, maxDamages);    \\t\\n    \\t\\tmaxDamage = Math.max(right, down) + A[i][j];// Choose the path with less damage: rightward, downward\\n    \\t}\\t\\t\\n    \\tmaxDamages[i][j] = Math.min(0, maxDamage);\\t\\t\\t\\n    \\treturn maxDamages[i][j];\\n    }",
                "solutionTags": [],
                "code": "**Solutino1. Bottom-Up DP - Runtime = O(nm); Space = O(nm)**\\n\\n    Iterate from last row to first row:\\n    2-D table for the minimum DP.\\n    h[i][j] is the minimum helth to enter (i, j) \\n    h[0][0] is the anwser.\\t\\n\\n**JAVA Code:**\\n\\n    public int calculateMinimumHP(int[][] A) {\\n    \\tint n = A.length, m = A[0].length;\\n    \\tint dp[][] = new int[n][m];// dp[i][j]: minimum hp to enter (i, j) \\n    \\t\\n    \\tdp[n-1][m-1] = Math.max(-A[n-1][m-1], 0) + 1;// right-bottom node    \\t\\n    \\tfor (int i = n - 2; i >= 0; i--) // last row\\n    \\t\\tdp[i][m-1] = Math.max(1, dp[i+1][m-1] - A[i][m-1]);    \\t\\n    \\tfor (int j = m - 2; j >= 0; j--) // last column\\n    \\t\\tdp[n-1][j] = Math.max(1, dp[n-1][j+1] - A[n-1][j]);\\n    \\t\\n    \\tfor (int i = n - 2; i >= 0; i--) {// calculate dp table\\n    \\t\\tfor (int j = m - 2; j >= 0; j--) {\\n    \\t\\t\\tdp[i][j] = Math.min(dp[i][j+1], dp[i+1][j]);// right, down\\n    \\t\\t\\tdp[i][j] = Math.max(1, dp[i][j] - A[i][j]);\\n    \\t\\t}\\n    \\t}     \\t\\n        return dp[0][0];\\n    }\\n\\n**Solution2. Memorized DFS**\\n\\nRegular DFS without memorization will cause TLE error.\\n \\n    public int calculateMinimumHP(int[][] A) {\\n    \\tint maxDamages[][] = new int[A.length][A[0].length];// KEY optimization: Memorization for the previous results\\n    \\tfor (int i = 0; i < A.length; i++) Arrays.fill(maxDamages[i], Integer.MAX_VALUE);\\n    \\t\\n    \\tint maxDamage = DFS(A, 0, 0, maxDamages);\\n        return Math.max(0, -maxDamage) + 1;\\n    }\\n    \\n    int DFS(int[][] A, int i, int j, int maxDamages[][]) {// Total damage for one path\\n    \\tif (i > A.length - 1 || j > A[0].length - 1) return Integer.MIN_VALUE;    \\t\\n    \\tif (maxDamages[i][j] != Integer.MAX_VALUE) return maxDamages[i][j];// **Return the memorized result, to avoid duplicated DFS\\n    \\t\\n    \\tint maxDamage;\\n    \\tif (i == A.length - 1 && j == A[0].length - 1) {// Right-bottom node \\t\\n    \\t\\tmaxDamage = A[i][j];\\n    \\t} else {\\n    \\t\\tint right = DFS(A, i, j+1, maxDamages);\\n    \\t\\tint down =  DFS(A, i+1, j, maxDamages);    \\t\\n    \\t\\tmaxDamage = Math.max(right, down) + A[i][j];// Choose the path with less damage: rightward, downward\\n    \\t}\\t\\t\\n    \\tmaxDamages[i][j] = Math.min(0, maxDamage);\\t\\t\\t\\n    \\treturn maxDamages[i][j];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 52855,
                "title": "java-dp-solution-3ms",
                "content": "    public class Solution {\\n    public int calculateMinimumHP(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[][] dp = new int[m][n];\\n        dp[m-1][n-1] = Math.max(1 - grid[m-1][n-1], 1);\\n        //fill out the last row\\n        for(int j = n-2; j >= 0; j--) {\\n            dp[m-1][j] = Math.max(dp[m-1][j+1] - grid[m-1][j], 1);\\n        }\\n        //fill out the last column\\n        for(int i = m-2; i >= 0; i--) {\\n            dp[i][n-1] = Math.max(dp[i+1][n-1] - grid[i][n-1], 1);\\n        }\\n        //fill out the rest of the dp\\n        for(int i = m-2; i >= 0; i--) {\\n            for(int j = n-2; j >= 0; j--) {\\n                int next = Math.min(dp[i+1][j], dp[i][j+1]);\\n                dp[i][j] = Math.max(next - grid[i][j], 1);\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n    }",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    public int calculateMinimumHP(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[][] dp = new int[m][n];\\n        dp[m-1][n-1] = Math.max(1 - grid[m-1][n-1], 1);\\n        //fill out the last row\\n        for(int j = n-2; j >= 0; j--) {\\n            dp[m-1][j] = Math.max(dp[m-1][j+1] - grid[m-1][j], 1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 52865,
                "title": "simple-c-solution-with-o-1-space-complexity",
                "content": "    class Solution {\\n    public:\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n\\t\\tint m = dungeon.size() - 1;\\n\\t\\tint n = dungeon[0].size() - 1;\\n\\n\\t\\tdungeon[m][n] = dungeon[m][n]>0 ? 0 : dungeon[m][n];\\n\\n\\t\\tfor (int i = m; i >= 0; i--) {\\n\\t\\t\\tfor (int j = n; j >= 0; j--) {\\n\\t\\t\\t\\tif (i < m && j < n)\\n\\t\\t\\t\\t\\tdungeon[i][j] = max(dungeon[i + 1][j], dungeon[i][j + 1]) + dungeon[i][j];\\n\\t\\t\\t\\telse if (i < m)\\n\\t\\t\\t\\t\\tdungeon[i][j] = dungeon[i + 1][j] + dungeon[i][j];\\n\\t\\t\\t\\telse if (j < n)\\n\\t\\t\\t\\t\\tdungeon[i][j] = dungeon[i][j + 1] + dungeon[i][j];\\n\\n\\t\\t\\t\\tdungeon[i][j] = dungeon[i][j] > 0 ? 0 : dungeon[i][j];\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn dungeon[0][0] > 0 ? 1 : abs(dungeon[0][0]) + 1;\\n\\t  }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n\\t\\tint m = dungeon.size() - 1;\\n\\t\\tint n = dungeon[0].size() - 1;\\n\\n\\t\\tdungeon[m][n] = dungeon[m][n]>0 ? 0 : dungeon[m][n];\\n\\n\\t\\tfor (int i = m; i >= 0; i--) {\\n\\t\\t\\tfor (int j = n; j >= 0; j--) {\\n\\t\\t\\t\\tif (i < m && j < n)\\n\\t\\t\\t\\t\\tdungeon[i][j] = max(dungeon[i + 1][j], dungeon[i][j + 1]) + dungeon[i][j];\\n\\t\\t\\t\\telse if (i < m)\\n\\t\\t\\t\\t\\tdungeon[i][j] = dungeon[i + 1][j] + dungeon[i][j];\\n\\t\\t\\t\\telse if (j < n)\\n\\t\\t\\t\\t\\tdungeon[i][j] = dungeon[i][j + 1] + dungeon[i][j];\\n\\n\\t\\t\\t\\tdungeon[i][j] = dungeon[i][j] > 0 ? 0 : dungeon[i][j];\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3542962,
                "title": "memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int solve(int i , int j ,vector<vector<int>>& d,int n,int m,vector<vector<int>> &dp) {\\n       if(i>=n || j >=m)\\n           return INT_MAX;\\n        \\n        if(i==n-1 && j == m-1)\\n        {\\n            return dp[i][j] = ((d[i][j]>0) ? 1 : -d[i][j]+1);\\n        }\\n        \\n         \\n        if(dp[i][j]!=INT_MAX)\\n            return dp[i][j];\\n       \\n        \\n        int a  = solve(i+1,j,d,n,m,dp);\\n        int b  = solve(i,j+1,d,n,m,dp);\\n        \\n        int c = min(a,b) - d[i][j];\\n        return dp[i][j] = ((c>0)?c:1);\\n        \\n    }\\n    int calculateMinimumHP(vector<vector<int>>& d) {\\n        \\n        int n = d.size();\\n        int m = d[0].size();\\n        vector<vector<int>> dp(n,vector<int> (m,INT_MAX)); \\n        return solve(0,0,d,n,m,dp);\\n    }\\n};```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int solve(int i , int j ,vector<vector<int>>& d,int n,int m,vector<vector<int>> &dp) {\\n       if(i>=n || j >=m)\\n           return INT_MAX;\\n        \\n        if(i==n-1 && j == m-1)\\n        {\\n            return dp[i][j] = ((d[i][j]>0) ? 1 : -d[i][j]+1);\\n        }\\n        \\n         \\n        if(dp[i][j]!=INT_MAX)\\n            return dp[i][j];\\n       \\n        \\n        int a  = solve(i+1,j,d,n,m,dp);\\n        int b  = solve(i,j+1,d,n,m,dp);\\n        \\n        int c = min(a,b) - d[i][j];\\n        return dp[i][j] = ((c>0)?c:1);\\n        \\n    }\\n    int calculateMinimumHP(vector<vector<int>>& d) {\\n        \\n        int n = d.size();\\n        int m = d[0].size();\\n        vector<vector<int>> dp(n,vector<int> (m,INT_MAX)); \\n        return solve(0,0,d,n,m,dp);\\n    }\\n};```",
                "codeTag": "Java"
            },
            {
                "id": 3393340,
                "title": "174-dungeon-game",
                "content": "- Time complexity:\\nO(mn)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        int row = dungeon.size(), col = dungeon[0].size();\\n        vector<int> HP(col + 1, 1e5);\\n        HP[col - 1] = HP[col] = 1;\\n        for(int i = row - 1; i >= 0; --i) {\\n            vector<int> temp(col + 1, 1e5);\\n            for(int j = col - 1; j >= 0; --j) {\\n                int minHP = -dungeon[i][j] + min(temp[j + 1], HP[j]);\\n                temp[j] = minHP <= 0 ? 1 : minHP;\\n            }\\n            HP = temp;\\n        }\\n        return HP[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        int row = dungeon.size(), col = dungeon[0].size();\\n        vector<int> HP(col + 1, 1e5);\\n        HP[col - 1] = HP[col] = 1;\\n        for(int i = row - 1; i >= 0; --i) {\\n            vector<int> temp(col + 1, 1e5);\\n            for(int j = col - 1; j >= 0; --j) {\\n                int minHP = -dungeon[i][j] + min(temp[j + 1], HP[j]);\\n                temp[j] = minHP <= 0 ? 1 : minHP;\\n            }\\n            HP = temp;\\n        }\\n        return HP[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367443,
                "title": "a-try-to-explain-in-an-easy-way",
                "content": "So what is the Problem basically \\nUnderstand\\n\\nThere is  a King \\uD83E\\uDEC5 and his princess was kidnapped by a gang and the gang leader is at bottom right and king has to save him. During his journey he found two types of either they give boon i.e. health or they take bribe i.e. health.\\n\\nSo King has to think before start journey that how much life he had to hold before start the journey. Because in the journey if at any moment the life becomes 0 or becomes negative then the Gang leader would marry the Princess\\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31\\n\\nSo as a King he had to think of the journey and he can think like if he start from the life needed to fight with leader if suppose -5 life lose at leader so at that king needed minimum of 6 life  no matter it comes from upper block or following the left side block.\\nThis approach King has to follow recursively to all spots available.\\n\\nAs same if we consider the left block and if there is demon that would need -2 health so our total required at that block would be 6-(-2). and if instead of demon if there is healer so our health at that block would be 6-(2);\\nWe follow this for that particular row and column in which princess is there.\\n\\nBut for remaining matrix we have to first find from below and right block that which is giving minimum health and after that apply the same operation.\\nSo in this we start from the adjacent diagonal block of princess and after that traverse the whole remaining array.\\nAnd entry for that block would be max ( min(below block value,right block value) - dungeon diagonal block , 1);\\n\\nAnd At last we return the value at newMatrix[0][0];\\n\\nSo code is \\n\\nC++ Code\\n```\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n     \\n        int m=dungeon.size(),n=dungeon[0].size();\\n        vector<vector<int>>dp(m,vector<int>(n,0));\\n        \\n        dp[m-1][n-1]= dungeon[m-1][n-1]>0?1:1-dungeon[m-1][n-1];\\n        \\n        for(int i=m-2;i>=0;i--){\\n            dp[i][n-1]=max(dp[i+1][n-1]-dungeon[i][n-1],1);\\n        }\\n         for(int j=n-2;j>=0;j--){\\n            dp[m-1][j]=max(dp[m-1][j+1]-dungeon[m-1][j],1);\\n        }\\n        \\n        for(int i=m-2;i>=0;i--){\\n            for(int j=n-2;j>=0;j--){\\n                dp[i][j]=max(min(dp[i+1][j],dp[i][j+1])-dungeon[i][j],1);\\n            }\\n        }\\n        return dp[0][0];\\n        \\n        \\n    }\\n\\t```\\n\\t\\n\\tJAVA CODE\\n\\t```\\n\\t    public int calculateMinimumHP(int[][] dungeon) {\\n        \\n        int m=dungeon.length,n=dungeon[0].length;\\n        int [][]dp=new int[m][n];\\n        dp[m-1][n-1]=dungeon[m-1][n-1]>0?1:1-dungeon[m-1][n-1];\\n        \\n        for(int i=m-2;i>=0;i--)\\n            dp[i][n-1]=Math.max(dp[i+1][n-1]-dungeon[i][n-1],1);\\n        for(int j=n-2;j>=0;j--)\\n            dp[m-1][j]=Math.max(dp[m-1][j+1]-dungeon[m-1][j],1);\\n        for(int i=m-2;i>=0;i--){\\n            for(int j=n-2;j>=0;j--){\\n                dp[i][j]=Math.max(Math.min(dp[i][j+1],dp[i+1][j])-dungeon[i][j],1);\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n\\t```\\n\\t\\n\\tA Try that may help, If helped please upvote if not for me but for Prince and Princess you helped by saving from Kidnappers \\uD83D\\uDE09\\uD83D\\uDE09 Let them marry and give your wishes in form of upvotes\\n\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n     \\n        int m=dungeon.size(),n=dungeon[0].size();\\n        vector<vector<int>>dp(m,vector<int>(n,0));\\n        \\n        dp[m-1][n-1]= dungeon[m-1][n-1]>0?1:1-dungeon[m-1][n-1];\\n        \\n        for(int i=m-2;i>=0;i--){\\n            dp[i][n-1]=max(dp[i+1][n-1]-dungeon[i][n-1],1);\\n        }\\n         for(int j=n-2;j>=0;j--){\\n            dp[m-1][j]=max(dp[m-1][j+1]-dungeon[m-1][j],1);\\n        }\\n        \\n        for(int i=m-2;i>=0;i--){\\n            for(int j=n-2;j>=0;j--){\\n                dp[i][j]=max(min(dp[i+1][j],dp[i][j+1])-dungeon[i][j],1);\\n            }\\n        }\\n        return dp[0][0];\\n        \\n        \\n    }\\n\\t```\n```\\n\\t    public int calculateMinimumHP(int[][] dungeon) {\\n        \\n        int m=dungeon.length,n=dungeon[0].length;\\n        int [][]dp=new int[m][n];\\n        dp[m-1][n-1]=dungeon[m-1][n-1]>0?1:1-dungeon[m-1][n-1];\\n        \\n        for(int i=m-2;i>=0;i--)\\n            dp[i][n-1]=Math.max(dp[i+1][n-1]-dungeon[i][n-1],1);\\n        for(int j=n-2;j>=0;j--)\\n            dp[m-1][j]=Math.max(dp[m-1][j+1]-dungeon[m-1][j],1);\\n        for(int i=m-2;i>=0;i--){\\n            for(int j=n-2;j>=0;j--){\\n                dp[i][j]=Math.max(Math.min(dp[i][j+1],dp[i+1][j])-dungeon[i][j],1);\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 3065468,
                "title": "easy-soln-adobe",
                "content": "# Please Upvote if you found the solution helpful\\uD83D\\uDE0A\\n**#ReviseWithArsh #6Companies30Days Challenge 2023\\nChallenge Company 3 : Adobe\\nQ13. Game of Dungeon**\\n\\n# Complexity\\n- Time complexity: O(mn), where m is the number of rows in the dungeon matrix and n is the number of columns\\n\\n- Space complexity: O(mn), as we are using a 2D dp array to store the minimum health points required for each cell.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n    int rows = dungeon.size(), cols = dungeon[0].size();\\n    vector<vector<int>> dp(rows, vector<int>(cols, INT_MAX)); // Initialize dp array with maximum value\\n    dp[rows-1][cols-1] = max(1, 1 - dungeon[rows-1][cols-1]); // Initialize last cell of dp array\\n    for(int i = rows-2; i >= 0; i--) {\\ndp[i][cols-1] = max(1, dp[i+1][cols-1] - dungeon[i][cols-1]); // Initialize last column of dp array\\n    }\\n    for(int i = cols-2; i >= 0; i--) {\\ndp[rows-1][i] = max(1, dp[rows-1][i+1] - dungeon[rows-1][i]); // Initialize last row of dp array\\n    }\\n    // fill the dp array\\n    for(int i=rows-2; i>=0; i--) {\\n        for(int j=cols-2; j>=0; j--) {\\n            dp[i][j] = max(1, min(dp[i+1][j], dp[i][j+1]) - dungeon[i][j]);\\n        }\\n    }\\n    \\n    return dp[0][0];\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n    int rows = dungeon.size(), cols = dungeon[0].size();\\n    vector<vector<int>> dp(rows, vector<int>(cols, INT_MAX)); // Initialize dp array with maximum value\\n    dp[rows-1][cols-1] = max(1, 1 - dungeon[rows-1][cols-1]); // Initialize last cell of dp array\\n    for(int i = rows-2; i >= 0; i--) {\\ndp[i][cols-1] = max(1, dp[i+1][cols-1] - dungeon[i][cols-1]); // Initialize last column of dp array\\n    }\\n    for(int i = cols-2; i >= 0; i--) {\\ndp[rows-1][i] = max(1, dp[rows-1][i+1] - dungeon[rows-1][i]); // Initialize last row of dp array\\n    }\\n    // fill the dp array\\n    for(int i=rows-2; i>=0; i--) {\\n        for(int j=cols-2; j>=0; j--) {\\n            dp[i][j] = max(1, min(dp[i+1][j], dp[i][j+1]) - dungeon[i][j]);\\n        }\\n    }\\n    \\n    return dp[0][0];\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2876312,
                "title": "clean-golang-dp-explained-solution-complexity",
                "content": "# Approach\\nLet\\'s use dynamic programming approach here, going from the bottom right cell to the top left one.\\n\\nFirst, we need to create the dp array.\\n```dp[i][j]``` would store the **minimum** HP needed to get to the ```dungeon[i][j]``` and survive the whole dungeon assuming that we\\'ve chosen the best path.\\n\\n## The bottom right cell of dp\\nHow do we decide what to put in ```dp[lastRow][lastCol]```? Let\\'s see two cases:\\n1. ```Dungeon[lastRow][lastCol] > 0```. Then we are not getting damaged at this cell and we can safely step inside this dungeon with the minimum HP of $1$.\\n2. ```Dungeon[lastRow][lastCol] <= 0```. Then we are getting damaged and to survive we need to give some extra HP to our hero. Suppose that there is value of $-5$ in the dungeon. Then the knight must have **at least** $6$ HP to survive this room.\\n\\nA simple solution without any if-statements would look like this:\\n```\\ndp[lastRow][lastCol] = max(1, 1 - dungeon[lastRow][lastCol])\\n```\\n\\n## Filling the right column and the bottom row of dp\\nTo fill the rest of the table, we need to calculate the right column and the bottom row of the dp table.\\nLet\\'s start with the right column:\\n```\\nfor i := lastRow - 1; i >= 0; i-- {\\n    dp[i][lastCol] = max(1, dp[i+1][lastCol] - dungeon[i][lastCol])\\n}\\n```\\nWe are looping from the bottom cell to the top one. If the character comes from the dungeon where he got additional HP, then we would want to lower the mininum HP we gave him at the start. Otherwise, if the current dungeon cell takes a lot of HP from him, then ```dp[i+1][lastCol] - dungeon[i][lastCol]``` would be a big number, so we give the knight additional HP to survive this dungeon.\\n\\nThe logic for the bottom row is the same, we just swap the indices:\\n\\n```\\n// Fill the bottom row of dp.\\nfor i := lastCol - 1; i >= 0; i-- {\\n    dp[lastRow][i] = max(1, dp[lastRow][i+1] - dungeon[lastRow][i])\\n}\\n```\\n\\n## Filling the rest of the matrix\\n\\nNow we can fill the rest of the matrix:\\n```\\nfor i := lastRow - 1; i >= 0; i-- {\\n    for j := lastCol - 1; j >= 0; j-- {\\n        minRightBottom := min(dp[i+1][j], dp[i][j+1])\\n        dp[i][j] = max(1, minRightBottom - dungeon[i][j])\\n    }\\n}\\n```\\nThe ```minRightBottom``` variable is calculated in order to decide whether it\\'s less painful for our hero to go down or to go right after the current ```dp[i][j]``` cell. Then the same logic is applied: if the current dungeon cell damages the knight, then we increase the value of ```dp[i][j]```, otherwise we see if we could go even lower than HP we gave him before.\\n\\n## The answer\\n```dp[0][0]``` would be the minimum health required step into ```dungeon[0][0]``` and go through the best path and be alive at the end.\\n\\n# Complexity\\n$m$ - number of rows in the dungeon table, $n$ - number of cols.\\n- Time complexity: $O(m\\\\cdot n)$ - we go through every cell of the dungeon matrix.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(m\\\\cdot n)$ - we create a dp array with the size of the dungeon matrix.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc calculateMinimumHP(dungeon [][]int) int {\\n    // Let\\'s say that dp[i][j] is the minimum HP needed to get to room [i][j]\\n    // and still be alive after passing the dungeon via the best path.\\n    dp := make([][]int, len(dungeon))\\n    for i := range dp {\\n        dp[i] = make([]int, len(dungeon[0]))\\n    }\\n\\n    // For convenience\\n    lastCol := len(dungeon[0]) - 1\\n    lastRow := len(dungeon) - 1\\n\\n    // Fill the bottom right dp cell.\\n    dp[lastRow][lastCol] = max(1, 1 - dungeon[lastRow][lastCol])\\n\\n    // Fill the right column of dp.\\n    for i := lastRow - 1; i >= 0; i-- {\\n        dp[i][lastCol] = max(1, dp[i+1][lastCol] - dungeon[i][lastCol])\\n    }\\n    // Fill the bottom row of dp.\\n    for i := lastCol - 1; i >= 0; i-- {\\n        dp[lastRow][i] = max(1, dp[lastRow][i+1] - dungeon[lastRow][i])\\n    }\\n\\n    // Calculate the rest of the dp matrix.\\n    for i := lastRow - 1; i >= 0; i-- {\\n        for j := lastCol - 1; j >= 0; j-- {\\n            minRightBottom := min(dp[i+1][j], dp[i][j+1])\\n            dp[i][j] = max(1, minRightBottom - dungeon[i][j])\\n        }\\n    }\\n\\n    // dp[0][0] would be the min health required step into dungeon[0][0]\\n    // and go through the best path and be alive at the end.\\n    return dp[0][0]\\n}\\n\\nfunc min(a, b int) int {\\n    if a < b {\\n        return a\\n    }\\n    return b\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```dp[i][j]```\n```dungeon[i][j]```\n```dp[lastRow][lastCol]```\n```Dungeon[lastRow][lastCol] > 0```\n```Dungeon[lastRow][lastCol] <= 0```\n```\\ndp[lastRow][lastCol] = max(1, 1 - dungeon[lastRow][lastCol])\\n```\n```\\nfor i := lastRow - 1; i >= 0; i-- {\\n    dp[i][lastCol] = max(1, dp[i+1][lastCol] - dungeon[i][lastCol])\\n}\\n```\n```dp[i+1][lastCol] - dungeon[i][lastCol]```\n```\\n// Fill the bottom row of dp.\\nfor i := lastCol - 1; i >= 0; i-- {\\n    dp[lastRow][i] = max(1, dp[lastRow][i+1] - dungeon[lastRow][i])\\n}\\n```\n```\\nfor i := lastRow - 1; i >= 0; i-- {\\n    for j := lastCol - 1; j >= 0; j-- {\\n        minRightBottom := min(dp[i+1][j], dp[i][j+1])\\n        dp[i][j] = max(1, minRightBottom - dungeon[i][j])\\n    }\\n}\\n```\n```minRightBottom```\n```dp[i][j]```\n```dp[i][j]```\n```dp[0][0]```\n```dungeon[0][0]```\n```\\nfunc calculateMinimumHP(dungeon [][]int) int {\\n    // Let\\'s say that dp[i][j] is the minimum HP needed to get to room [i][j]\\n    // and still be alive after passing the dungeon via the best path.\\n    dp := make([][]int, len(dungeon))\\n    for i := range dp {\\n        dp[i] = make([]int, len(dungeon[0]))\\n    }\\n\\n    // For convenience\\n    lastCol := len(dungeon[0]) - 1\\n    lastRow := len(dungeon) - 1\\n\\n    // Fill the bottom right dp cell.\\n    dp[lastRow][lastCol] = max(1, 1 - dungeon[lastRow][lastCol])\\n\\n    // Fill the right column of dp.\\n    for i := lastRow - 1; i >= 0; i-- {\\n        dp[i][lastCol] = max(1, dp[i+1][lastCol] - dungeon[i][lastCol])\\n    }\\n    // Fill the bottom row of dp.\\n    for i := lastCol - 1; i >= 0; i-- {\\n        dp[lastRow][i] = max(1, dp[lastRow][i+1] - dungeon[lastRow][i])\\n    }\\n\\n    // Calculate the rest of the dp matrix.\\n    for i := lastRow - 1; i >= 0; i-- {\\n        for j := lastCol - 1; j >= 0; j-- {\\n            minRightBottom := min(dp[i+1][j], dp[i][j+1])\\n            dp[i][j] = max(1, minRightBottom - dungeon[i][j])\\n        }\\n    }\\n\\n    // dp[0][0] would be the min health required step into dungeon[0][0]\\n    // and go through the best path and be alive at the end.\\n    return dp[0][0]\\n}\\n\\nfunc min(a, b int) int {\\n    if a < b {\\n        return a\\n    }\\n    return b\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2676478,
                "title": "easy-c-dp-solution-explained-o-m-n",
                "content": "# Intuition\\nLet us consider a matrix M $$(m * n)$$, which indicates minimum health required at $$(m,n)$$ to reach the princess. \\nAfter reaching the princess, the knight must have atleast health 1.\\n\\nStarting from the last cell $$M[m-1, n-1]$$, down to $M[0, 0]$.\\nWe can calculate $$M[i, j]$$ as least health loss from bottom or right cell.\\n\\nBut we cannot make the health become zero or lesser. So for each cell, min health should be 1.\\n\\nSo, $$M[i, j] = min(M[i+1, j], M[i, j+1])-dungeon[i, j]$$ or 1, whichever is higher.\\n\\nTherefore, \\n$$M[i, j] = max(1, min(M[i+1, j], M[i, j+1])-dungeon[i, j])$$\\n\\n# Approach\\nUsing the final equation of $$M[i, j]$$, we can tabulate the matrix using **Top-Down Dynamic Programming**\\n\\nFor edge cases, we dont have to consider the out-lying cells or we can consider them to be **INFINITY**.\\n\\n# Complexity\\n- Time complexity: $$O(m*n)$$\\n\\n- Space complexity: $$O(m*n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        int m=dungeon.size(), n=dungeon[0].size();\\n        vector<vector<int>> dp(m, vector<int>(n, 11111111));\\n        for(int i=m-1; i>=0; i--) {\\n            for(int j=n-1; j>=0; j--) {\\n                if(i==m-1 && j==n-1)\\n                    dp[i][j] = max(1, 1 - dungeon[i][j]);\\n                else if(i==m-1)\\n                    dp[i][j] = max(1, dp[i][j+1] - dungeon[i][j]);\\n                else if(j==n-1)\\n                    dp[i][j] = max(1, dp[i+1][j] - dungeon[i][j]);\\n                else\\n                    dp[i][j] = max(1, min(dp[i+1][j], dp[i][j+1]) - dungeon[i][j]);\\n            }\\n        }\\n\\n        return dp[0][0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        int m=dungeon.size(), n=dungeon[0].size();\\n        vector<vector<int>> dp(m, vector<int>(n, 11111111));\\n        for(int i=m-1; i>=0; i--) {\\n            for(int j=n-1; j>=0; j--) {\\n                if(i==m-1 && j==n-1)\\n                    dp[i][j] = max(1, 1 - dungeon[i][j]);\\n                else if(i==m-1)\\n                    dp[i][j] = max(1, dp[i][j+1] - dungeon[i][j]);\\n                else if(j==n-1)\\n                    dp[i][j] = max(1, dp[i+1][j] - dungeon[i][j]);\\n                else\\n                    dp[i][j] = max(1, min(dp[i+1][j], dp[i][j+1]) - dungeon[i][j]);\\n            }\\n        }\\n\\n        return dp[0][0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2344431,
                "title": "dynamic-programming",
                "content": "```\\n int calculateMinimumHP(vector<vector<int>>&arr) {\\n        int n=arr.size();\\n        int m=arr[0].size();\\n        vector<vector<int>>dp(n+1,vector<int>(m+1,INT_MAX));\\n        for(int i=n-1;i>=0;i--){\\n            for(int j=m-1;j>=0;j--){\\n                if(i==n-1 && j==m-1){\\n                    dp[i][j]=1-arr[i][j];\\n                    dp[i][j]=(dp[i][j]<=0)?1:dp[i][j];\\n                    continue;\\n                }\\n                dp[i][j]=min(dp[i+1][j],dp[i][j+1])-arr[i][j];\\n                  dp[i][j]=(dp[i][j]<=0)?1:dp[i][j];\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n\\t",
                "solutionTags": [],
                "code": "```\\n int calculateMinimumHP(vector<vector<int>>&arr) {\\n        int n=arr.size();\\n        int m=arr[0].size();\\n        vector<vector<int>>dp(n+1,vector<int>(m+1,INT_MAX));\\n        for(int i=n-1;i>=0;i--){\\n            for(int j=m-1;j>=0;j--){\\n                if(i==n-1 && j==m-1){\\n                    dp[i][j]=1-arr[i][j];\\n                    dp[i][j]=(dp[i][j]<=0)?1:dp[i][j];\\n                    continue;\\n                }\\n                dp[i][j]=min(dp[i+1][j],dp[i][j+1])-arr[i][j];\\n                  dp[i][j]=(dp[i][j]<=0)?1:dp[i][j];\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 2242126,
                "title": "c-dp-memoization-little-catch",
                "content": "# At first glance this problem looks similar to minium path problem but after you realise one thing that if you apply bottom to up approch (like every problem in recursion) then it is wrong coz king is moving up to bottom and while moving this way the ans is always be total of values in thats but we need the prefix -ve required health in this problem .\\n# For that at every instance of recursive call we dont have to return the extra health which we got while coming from the bottom to the function , we have to return only required health (if required) otherwise return zero .\\n# (if the health is regitive then it considered as a required health and if it is positive then it means that while coming to this position from the bottom we got / we have that much of extra health , in actual problem we cannot use that extra health coz in actual problem we are moving up to bottom)\\n```\\nclass Solution {\\npublic:\\n    int minpath(vector<vector<int>>& grid ,int h, int v,int n ,int m, vector<vector<int>>& dp)\\n    {\\n        if(h==n-1 and v==m-1) \\n        {\\n            if(grid[v][h]>0) return dp[v][h]=0;\\n            return dp[v][h]=grid[v][h];\\n        }\\n        if(h>n-1 or v>m-1) return INT_MIN;\\n        \\n        if(dp[v][h]!=-1) return dp[v][h];\\n        \\n        int right = minpath(grid,h+1,v,n,m,dp);\\n        int left = minpath(grid,h,v+1,n,m,dp);\\n        \\n        if(max(right,left)+grid[v][h]>0)   // while moving bottom to up, if the health till includeing current grid is positive then pass 0 otherwise if it negitive then (that mod value is required health) return it.\\n            return dp[v][h]=0;\\n        else\\n        return dp[v][h]=max(right,left)+grid[v][h]; \\n    }\\n    \\n    int calculateMinimumHP(vector<vector<int>>& dungeon) \\n    {\\n        int m = dungeon.size();\\n        int n = dungeon[0].size();\\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n        \\n        int call = minpath(dungeon,0,0,n,m,dp);\\n        if(call<0) return -1*call+1;\\n        else\\n        return 1; \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minpath(vector<vector<int>>& grid ,int h, int v,int n ,int m, vector<vector<int>>& dp)\\n    {\\n        if(h==n-1 and v==m-1) \\n        {\\n            if(grid[v][h]>0) return dp[v][h]=0;\\n            return dp[v][h]=grid[v][h];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2187361,
                "title": "java-2ms-solution-bottom-up-dp-approach",
                "content": "\\n\\t\\n\\tclass Solution {\\n \\n    public int calculateMinimumHP(int[][] dungeon) {\\n        \\n        int health[][] = new int[dungeon.length][dungeon[0].length];\\n        int targethealth=1;\\n        for(int i=dungeon.length-1;i>=0;i--){\\n            for(int j=dungeon[0].length-1;j>=0;j--){\\n                \\n                if(i==dungeon.length-1 && j==dungeon[0].length-1){\\n                    targethealth=targethealth-dungeon[i][j];\\n                    if(targethealth<=0)\\n                        health[i][j]=1;\\n                    else\\n                        health[i][j]=targethealth;\\n                }\\n                \\n                else if(i==dungeon.length-1){\\n                    targethealth=health[i][j+1]-dungeon[i][j];\\n                    if(targethealth<=0)\\n                        health[i][j]=1;\\n                    else\\n                        health[i][j]=targethealth;\\n                }\\n                else if(j==dungeon[0].length-1){\\n                    targethealth=health[i+1][j]-dungeon[i][j];\\n                    if(targethealth<=0)\\n                        health[i][j]=1;\\n                    else\\n                        health[i][j]=targethealth;\\n                }\\n                else\\n                {\\n                    \\n                    targethealth = Math.min(health[i+1][j]-dungeon[i][j],\\n                                      health[i][j+1]-dungeon[i][j]);\\n                    if(targethealth<=0)\\n                        health[i][j]=1;\\n                    else\\n                        health[i][j]=targethealth;\\n                }\\n                    \\n            }\\n        }\\n        \\n        return health[0][0];    \\n    }\\n    }\\n",
                "solutionTags": [],
                "code": "class Solution {\\n \\n    public int calculateMinimumHP(int[][] dungeon) {\\n        \\n        int health[][] = new int[dungeon.length][dungeon[0].length];\\n        int targethealth=1;\\n        for(int i=dungeon.length-1;i>=0;i--){\\n            for(int j=dungeon[0].length-1;j>=0;j--){\\n                \\n                if(i==dungeon.length-1 && j==dungeon[0].length-1){\\n                    targethealth=targethealth-dungeon[i][j];\\n                    if(targethealth<=0)\\n                        health[i][j]=1;\\n                    else\\n                        health[i][j]=targethealth;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2103067,
                "title": "python-2-solutions-top-down-bottom-up-dp",
                "content": "1st Solution (Top Down):\\n\\n```\\nclass Solution:\\n    def calculateMinimumHP(self, arr: List[List[int]]) -> int:\\n        m,n=len(arr),len(arr[0])\\n        directions=((0,1),(1,0))\\n        @lru_cache(None)\\n        def dp(i,j):\\n            if i==m-1 and j==n-1:\\n                return arr[i][j] if arr[i][j]<0 else 0\\n            ans=-sys.maxsize\\n            for d in directions:\\n                ni,nj=d[0]+i,d[1]+j\\n                if 0<=ni<m and 0<=nj<n:\\n                    ans=max(ans,dp(ni,nj)+arr[i][j])\\n            print(i,j,ans)\\n            return ans if ans<0 else 0\\n        return abs(dp(0,0))+1\\n```\\n\\n2nd Solution (Bottom Up):\\n\\n```\\nclass Solution:\\n    def calculateMinimumHP(self, dungeon: List[List[int]]) -> int:\\n        m=len(dungeon)\\n        n=len(dungeon[0])\\n        t=[[0]*(n) for _ in range(m)]\\n        for i in range(m-1,-1,-1):\\n            for j in range(n-1,-1,-1):\\n                if i==(m-1) and j==(n-1):\\n                    t[i][j]=min(0,dungeon[i][j])\\n                elif i==(m-1):\\n                    t[i][j]=min(0,dungeon[i][j]+t[i][j+1])\\n                elif j==(n-1):\\n                    t[i][j]=min(0,dungeon[i][j]+t[i+1][j])\\n                else:\\n                    a=max(dungeon[i][j]+t[i+1][j],dungeon[i][j]+t[i][j+1])\\n                    t[i][j]=min(0,a)\\n        if t[0][0]>=0 and dungeon[0][0]<0:\\n            return abs(dungeon[0][0])+1\\n        elif t[0][0]>=0:\\n            return 1\\n        else:\\n            return abs(min(t[0][0],dungeon[0][0]))+1\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def calculateMinimumHP(self, arr: List[List[int]]) -> int:\\n        m,n=len(arr),len(arr[0])\\n        directions=((0,1),(1,0))\\n        @lru_cache(None)\\n        def dp(i,j):\\n            if i==m-1 and j==n-1:\\n                return arr[i][j] if arr[i][j]<0 else 0\\n            ans=-sys.maxsize\\n            for d in directions:\\n                ni,nj=d[0]+i,d[1]+j\\n                if 0<=ni<m and 0<=nj<n:\\n                    ans=max(ans,dp(ni,nj)+arr[i][j])\\n            print(i,j,ans)\\n            return ans if ans<0 else 0\\n        return abs(dp(0,0))+1\\n```\n```\\nclass Solution:\\n    def calculateMinimumHP(self, dungeon: List[List[int]]) -> int:\\n        m=len(dungeon)\\n        n=len(dungeon[0])\\n        t=[[0]*(n) for _ in range(m)]\\n        for i in range(m-1,-1,-1):\\n            for j in range(n-1,-1,-1):\\n                if i==(m-1) and j==(n-1):\\n                    t[i][j]=min(0,dungeon[i][j])\\n                elif i==(m-1):\\n                    t[i][j]=min(0,dungeon[i][j]+t[i][j+1])\\n                elif j==(n-1):\\n                    t[i][j]=min(0,dungeon[i][j]+t[i+1][j])\\n                else:\\n                    a=max(dungeon[i][j]+t[i+1][j],dungeon[i][j]+t[i][j+1])\\n                    t[i][j]=min(0,a)\\n        if t[0][0]>=0 and dungeon[0][0]<0:\\n            return abs(dungeon[0][0])+1\\n        elif t[0][0]>=0:\\n            return 1\\n        else:\\n            return abs(min(t[0][0],dungeon[0][0]))+1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2024999,
                "title": "dp-top-down-approach-recursive",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    int dp[1000][1000];\\n\\n    int solve(int i, int j, vector<vector<int>> &dungeon)\\n    {\\n        int n = dungeon.size(), m = dungeon[0].size();\\n        if (i >= n or j >= m)\\n            return INT_MIN;\\n        if (dp[i][j] != -1)\\n            return dp[i][j];\\n        if (i == n - 1 and j == m - 1)\\n            return min(0, dungeon[i][j]);\\n        return dp[i][j] = min(0, max(solve(i, j + 1, dungeon), solve(i + 1, j, dungeon)) + dungeon[i][j]);\\n    }\\n\\n    int calculateMinimumHP(vector<vector<int>> &dungeon)\\n    {\\n        memset(dp, -1, sizeof(dp));\\n        return abs(solve(0, 0, dungeon)) + 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int dp[1000][1000];\\n\\n    int solve(int i, int j, vector<vector<int>> &dungeon)\\n    {\\n        int n = dungeon.size(), m = dungeon[0].size();\\n        if (i >= n or j >= m)\\n            return INT_MIN;\\n        if (dp[i][j] != -1)\\n            return dp[i][j];\\n        if (i == n - 1 and j == m - 1)\\n            return min(0, dungeon[i][j]);\\n        return dp[i][j] = min(0, max(solve(i, j + 1, dungeon), solve(i + 1, j, dungeon)) + dungeon[i][j]);\\n    }\\n\\n    int calculateMinimumHP(vector<vector<int>> &dungeon)\\n    {\\n        memset(dp, -1, sizeof(dp));\\n        return abs(solve(0, 0, dungeon)) + 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2023298,
                "title": "100-faster-memoization",
                "content": "First we fill the bottommost row... and then the rightmost coloumn and start filling our DP array using memoization.\\n\\n```\\nclass Solution {\\n    public int calculateMinimumHP(int[][] A) {\\n        int n = A.length;\\n        int m = A[0].length;\\n        int[][] dp = new int[A.length][A[0].length];\\n        for (int i = 0; i < n; i++) {\\n            Arrays.fill(dp[i], -1);\\n        }\\n        if(1-A[n-1][m-1] > 0)\\n            dp[n-1][m-1] = 1-A[n-1][m-1];\\n        else\\n            dp[n-1][m-1] =1;\\n        for (int j = m-2; j >= 0; j--) {\\n            if(dp[n-1][j+1]-A[n-1][j] > 0)\\n                dp[n-1][j] = dp[n-1][j+1]-A[n-1][j];\\n            else\\n                dp[n-1][j] =1;\\n        }\\n        for (int i = n-2; i >= 0 ; i--) {\\n            if(dp[i+1][m-1]-A[i][m-1] > 0)\\n                dp[i][m-1] = dp[i+1][m-1]-A[i][m-1];\\n            else\\n                dp[i][m-1] = 1;\\n        }\\n        int ans = life(dp, A, 0, 0);\\n        return ans;\\n    }\\n    \\n    public int life(int[][] dp, int[][] A, int i, int j){\\n        if(i>=A.length || j>=A[0].length) return 0;\\n        if(dp[i][j] == -1){\\n            int a1 = life(dp, A, i+1,j);\\n            int a2 = life(dp, A, i, j+1);\\n            int temp = Math.min(a1,a2) - A[i][j];\\n            if(temp>0){\\n                dp[i][j] = temp;\\n            }else{\\n                dp[i][j] = 1;\\n            }\\n        }\\n        return dp[i][j];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int calculateMinimumHP(int[][] A) {\\n        int n = A.length;\\n        int m = A[0].length;\\n        int[][] dp = new int[A.length][A[0].length];\\n        for (int i = 0; i < n; i++) {\\n            Arrays.fill(dp[i], -1);\\n        }\\n        if(1-A[n-1][m-1] > 0)\\n            dp[n-1][m-1] = 1-A[n-1][m-1];\\n        else\\n            dp[n-1][m-1] =1;\\n        for (int j = m-2; j >= 0; j--) {\\n            if(dp[n-1][j+1]-A[n-1][j] > 0)\\n                dp[n-1][j] = dp[n-1][j+1]-A[n-1][j];\\n            else\\n                dp[n-1][j] =1;\\n        }\\n        for (int i = n-2; i >= 0 ; i--) {\\n            if(dp[i+1][m-1]-A[i][m-1] > 0)\\n                dp[i][m-1] = dp[i+1][m-1]-A[i][m-1];\\n            else\\n                dp[i][m-1] = 1;\\n        }\\n        int ans = life(dp, A, 0, 0);\\n        return ans;\\n    }\\n    \\n    public int life(int[][] dp, int[][] A, int i, int j){\\n        if(i>=A.length || j>=A[0].length) return 0;\\n        if(dp[i][j] == -1){\\n            int a1 = life(dp, A, i+1,j);\\n            int a2 = life(dp, A, i, j+1);\\n            int temp = Math.min(a1,a2) - A[i][j];\\n            if(temp>0){\\n                dp[i][j] = temp;\\n            }else{\\n                dp[i][j] = 1;\\n            }\\n        }\\n        return dp[i][j];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1940592,
                "title": "c-easy-to-understand",
                "content": "class Solution {\\npublic:\\n\\n    int dp[201][201];\\n    int calculateMinimumHP(vector<vector<int>>& mat) {\\n        int n=mat.size();\\n        int m=mat[0].size();\\n        int ans;\\n        int l=1,h=1e9;\\n        memset(dp ,-1,sizeof dp);\\n        int x=solve(mat,0,0,n,m);\\n        return abs(x)+1;\\n    }\\n    int solve(vector<vector<int>>&mat ,int i,int j,int n,int m){\\n      if(i<0 || j<0 || i>=n || j>=m)\\n      return INT_MIN;\\n      if(dp[i][j]!=-1)\\n        return dp[i][j];\\n      int ans=0;\\n      if(i==n-1 && j==m-1){\\n        return min(0,ans+mat[i][j]); \\n      }\\n      ans=min(0,mat[i][j]+max(solve(mat,i+1,j,n,m) , solve(mat,i,j+1,n,m)));\\n      return dp[i][j]=ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int dp[201][201];\\n    int calculateMinimumHP(vector<vector<int>>& mat) {\\n        int n=mat.size();\\n        int m=mat[0].size();\\n        int ans;\\n        int l=1,h=1e9;\\n        memset(dp ,-1,sizeof dp);\\n        int x=solve(mat,0,0,n,m);\\n        return abs(x)+1;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1706481,
                "title": "95-accuracy-solution-in-java-step-by-step-explanation",
                "content": "```\\nclass Solution {\\n    public int calculateMinimumHP(int[][] dungeon) {\\n        int r=dungeon.length;// rows\\n        int c= dungeon[0].length;//cols\\n        int [][] alt = new int [r][c];//alternate matrix to store\\n        if(dungeon[r-1][c-1]<0)//if last element is negative\\n            alt[r-1][c-1]=1-dungeon[r-1][c-1];// make it positive store in alternate matrix.. \\n        else//if positive..\\n            alt[r-1][c-1]=1;// assuming 1 as minimum health required..\\n        for(int i=r-2;i>=0;i--)// checking for last col excluding last element.\\n            //diff= alternate matrix last element - current value in dungeon matrix..\\n            alt[i][c-1]=Math.max(alt[i+1][c-1]-dungeon[i][c-1],1);// taking max because the diff might be negative.. \\n        for(int j=c-2;j>=0;j--)--)// checking for last row excluding last element..\\n            //diff= alternate matrix last element - current value in dungeon matrix..\\n            alt[r-1][j]=Math.max(alt[r-1][j+1]-dungeon[r-1][j],1);// taking max because the diff might be negative.. \\n        for(int i=r-2;i>=0;i--)// rest elements.. excluding last row \\n            for(int j=c-2;j>=0;j--)//rest elements.. excluding last col\\n                //firstly taking the minimum of adjacent alternate matrix so as to get min health.. diff= min of adjacent alt matrix - current value in dungeon..\\n                alt[i][j]=Math.max(Math.min(alt[i][j+1],alt[i+1][j])-dungeon[i][j],1););// taking max because the diff might be negative.. if negative ,1 will be given to alt matrix..\\n        return alt[0][0];// bottom to top approach.. so the first element will return the minimum health required..\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int calculateMinimumHP(int[][] dungeon) {\\n        int r=dungeon.length;// rows\\n        int c= dungeon[0].length;//cols\\n        int [][] alt = new int [r][c];//alternate matrix to store\\n        if(dungeon[r-1][c-1]<0)//if last element is negative\\n            alt[r-1][c-1]=1-dungeon[r-1][c-1];// make it positive store in alternate matrix.. \\n        else//if positive..\\n            alt[r-1][c-1]=1;// assuming 1 as minimum health required..\\n        for(int i=r-2;i>=0;i--)// checking for last col excluding last element.\\n            //diff= alternate matrix last element - current value in dungeon matrix..\\n            alt[i][c-1]=Math.max(alt[i+1][c-1]-dungeon[i][c-1],1);// taking max because the diff might be negative.. \\n        for(int j=c-2;j>=0;j--)--)// checking for last row excluding last element..\\n            //diff= alternate matrix last element - current value in dungeon matrix..\\n            alt[r-1][j]=Math.max(alt[r-1][j+1]-dungeon[r-1][j],1);// taking max because the diff might be negative.. \\n        for(int i=r-2;i>=0;i--)// rest elements.. excluding last row \\n            for(int j=c-2;j>=0;j--)//rest elements.. excluding last col\\n                //firstly taking the minimum of adjacent alternate matrix so as to get min health.. diff= min of adjacent alt matrix - current value in dungeon..\\n                alt[i][j]=Math.max(Math.min(alt[i][j+1],alt[i+1][j])-dungeon[i][j],1););// taking max because the diff might be negative.. if negative ,1 will be given to alt matrix..\\n        return alt[0][0];// bottom to top approach.. so the first element will return the minimum health required..\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1705490,
                "title": "simplest-solution-like-minimum-path-only-two-loops-very-understandable-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int calculateMinimumHP(vector<vector<int>>& vec) {\\n   vector<vector<int>> vec2(vec.size(),vector<int> (vec[0].size(),0));\\n    \\n    for(int i=vec.size()-1;i>=0;i--)\\n    {\\n        for(int j=vec[0].size()-1;j>=0;j--)\\n        {\\n            if(i==vec.size()-1 && j==vec[0].size()-1)\\n            vec2[i][j]=vec[i][j]>=0?1:abs(vec[i][j])+1;\\n            else if(j==vec[0].size()-1)\\n            vec2[i][j]=max(1,vec2[i+1][j]-vec[i][j]);\\n            else if(i==vec.size()-1)\\n            vec2[i][j]=max(1,vec2[i][j+1]-vec[i][j]);\\n            else\\n            vec2[i][j]=max(1,min(vec2[i][j+1],vec2[i+1][j])-vec[i][j]);\\n        }\\n    }\\n    return vec2[0][0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int calculateMinimumHP(vector<vector<int>>& vec) {\\n   vector<vector<int>> vec2(vec.size(),vector<int> (vec[0].size(),0));\\n    \\n    for(int i=vec.size()-1;i>=0;i--)\\n    {\\n        for(int j=vec[0].size()-1;j>=0;j--)\\n        {\\n            if(i==vec.size()-1 && j==vec[0].size()-1)\\n            vec2[i][j]=vec[i][j]>=0?1:abs(vec[i][j])+1;\\n            else if(j==vec[0].size()-1)\\n            vec2[i][j]=max(1,vec2[i+1][j]-vec[i][j]);\\n            else if(i==vec.size()-1)\\n            vec2[i][j]=max(1,vec2[i][j+1]-vec[i][j]);\\n            else\\n            vec2[i][j]=max(1,min(vec2[i][j+1],vec2[i+1][j])-vec[i][j]);\\n        }\\n    }\\n    return vec2[0][0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1625593,
                "title": "java-dijkstra-shortest-path-using-heap-priorityqueue-slow",
                "content": "```\\nclass Solution {\\n    public int calculateMinimumHP(int[][] dungeon) {\\n        int rows = dungeon.length;\\n        int cols = dungeon[0].length;\\n        int[][] healthForCell = new int[rows][cols];\\n        healthForCell[0][0] = dungeon[0][0];\\n        for (int i = 0; i < rows; i++) {\\n            Arrays.fill(healthForCell[i], Integer.MIN_VALUE);\\n        }\\n        // max heap, save [row, column, health]\\n        Queue<int[]> q = new PriorityQueue<>((a, b) -> {\\n            return b[2] - a[2];\\n        });\\n        q.add(new int[]{0, 0, dungeon[0][0]});\\n        // to get min health needed for cell with negative current health\\n        int minHealthForCell = Integer.MAX_VALUE;\\n        while (!q.isEmpty()) {\\n            int[] curr = q.poll();\\n            minHealthForCell = Math.min(curr[2], minHealthForCell);\\n            if (curr[0] == rows - 1 && curr[1] == cols - 1) {\\n                // if result health is positive, return 1\\n                int healthAtPathEnd = (curr[2] >= 0) ? 1 : -curr[2] + 1;\\n                // e.g if first cell is with negative health, need to return it\\'s value +1,\\n                // even if next cell in the path will increase the health\\n                minHealthForCell = minHealthForCell >= 0 ? 1 : -minHealthForCell + 1;\\n                return Math.max(healthAtPathEnd, minHealthForCell);\\n            }\\n            // add to heap next cell if it gives more health than we discovered already in a different path\\n            int nextR = curr[0] + 1;\\n            if (nextR < rows && healthForCell[nextR][curr[1]] < curr[2] + dungeon[nextR][curr[1]]) {\\n                healthForCell[nextR][curr[1]] = curr[2] + dungeon[nextR][curr[1]];\\n                q.add(new int[]{nextR, curr[1], healthForCell[nextR][curr[1]]});\\n            }\\n            int nextC = curr[1] + 1;\\n            if (nextC < cols && healthForCell[curr[0]][nextC] < curr[2] + dungeon[curr[0]][nextC]) {\\n                healthForCell[curr[0]][nextC] = curr[2] + dungeon[curr[0]][nextC];\\n                q.add(new int[]{curr[0], nextC, curr[2] + dungeon[curr[0]][nextC]});\\n            }\\n        }\\n        return Integer.MAX_VALUE;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)",
                    "Shortest Path"
                ],
                "code": "```\\nclass Solution {\\n    public int calculateMinimumHP(int[][] dungeon) {\\n        int rows = dungeon.length;\\n        int cols = dungeon[0].length;\\n        int[][] healthForCell = new int[rows][cols];\\n        healthForCell[0][0] = dungeon[0][0];\\n        for (int i = 0; i < rows; i++) {\\n            Arrays.fill(healthForCell[i], Integer.MIN_VALUE);\\n        }\\n        // max heap, save [row, column, health]\\n        Queue<int[]> q = new PriorityQueue<>((a, b) -> {\\n            return b[2] - a[2];\\n        });\\n        q.add(new int[]{0, 0, dungeon[0][0]});\\n        // to get min health needed for cell with negative current health\\n        int minHealthForCell = Integer.MAX_VALUE;\\n        while (!q.isEmpty()) {\\n            int[] curr = q.poll();\\n            minHealthForCell = Math.min(curr[2], minHealthForCell);\\n            if (curr[0] == rows - 1 && curr[1] == cols - 1) {\\n                // if result health is positive, return 1\\n                int healthAtPathEnd = (curr[2] >= 0) ? 1 : -curr[2] + 1;\\n                // e.g if first cell is with negative health, need to return it\\'s value +1,\\n                // even if next cell in the path will increase the health\\n                minHealthForCell = minHealthForCell >= 0 ? 1 : -minHealthForCell + 1;\\n                return Math.max(healthAtPathEnd, minHealthForCell);\\n            }\\n            // add to heap next cell if it gives more health than we discovered already in a different path\\n            int nextR = curr[0] + 1;\\n            if (nextR < rows && healthForCell[nextR][curr[1]] < curr[2] + dungeon[nextR][curr[1]]) {\\n                healthForCell[nextR][curr[1]] = curr[2] + dungeon[nextR][curr[1]];\\n                q.add(new int[]{nextR, curr[1], healthForCell[nextR][curr[1]]});\\n            }\\n            int nextC = curr[1] + 1;\\n            if (nextC < cols && healthForCell[curr[0]][nextC] < curr[2] + dungeon[curr[0]][nextC]) {\\n                healthForCell[curr[0]][nextC] = curr[2] + dungeon[curr[0]][nextC];\\n                q.add(new int[]{curr[0], nextC, curr[2] + dungeon[curr[0]][nextC]});\\n            }\\n        }\\n        return Integer.MAX_VALUE;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1588446,
                "title": "python-dp-space-optimization-with-detailed-explanation",
                "content": "The basic idea is, we calculate the minimum health we need for the current cell based on the already calculated right and bottom cell. This is more efficient than DFS because we will calculate a cell mutiple times if we do this with DFS. For example, consider two possible paths: -2 -> -3 -> -10 -> 1 -> -5 and -2 -> -5 -> -10 -> 1 -> -5,  here we go through -10 -> 1 -> -5 twice, if the dungeon is huge, we\\'ll have many duplicate caculations. So we go backwards, every cell will be calculated just once.\\n\\n<img src=\"https://assets.leetcode.com/users/images/ad4f6ae7-55e5-4532-a63b-3ad34b645707_1637428662.0373414.png\" alt=\"dungeon\" width=\"150\"/>\\n\\n**1. We start from the bottom right cell, it\\'s simple, two cases:**\\n```\\nif dungeon[-1][-1] <= 0:\\n\\thealth = 1 - dungeon[-1][-1]\\nelse:\\n\\thealth = 1\\n```\\n\\ncan be written as:\\n```\\nhealth = 1 + max(0, -dungeon[-1][-1])\\n```\\n\\n**2. For each cell, assume we already know the optimal value for `right` and `down`, the health for this cell will be:**\\n```\\nnxt = min(right, down)\\nif dungeon[i][j] <= 0:\\n\\thealth = nxt - dungeon[i][j]\\nelse:\\n\\t# we can reduce the initial health if we can get some orbs here\\n\\thealth = nxt - dungeon[i][j]\\n\\t# if we have a large enough positive value here, we just need to have a health 1\\n\\tif health < 0:\\n\\t\\thealth = 1\\n```\\nthe above can be simply written as:\\n```\\nhealth = max(min(right, down) - dungeon[i][j], 1)\\n```\\n\\n**Implementation O(MN) time + O(N) space**\\n```\\ndef calculateMinimumHP(self, dungeon: List[List[int]]) -> int:\\n        m, n = len(dungeon), len(dungeon[0])\\n\\t\\t\\n\\t\\t# we only need to memorize the whole next row and one right cell\\n\\t\\t# initialize the row, note that we don\\'t actually need two rows, just\\n\\t\\t# keep updating the same row \\n        health = [math.inf] * n\\n\\t\\t# initialize the bottom right cell\\n        health[-1] = 1 + max(0, -dungeon[-1][-1])\\n\\t\\t\\n\\t\\t# Iterate each cell row by row and caculate the minimun health\\n        for i in range(m - 1, -1, -1):\\n            for j in range(n - 1, -1, -1):\\n\\t\\t\\t\\t# skip the last cell as we\\'ve already initialized it\\n                if i == m - 1 and j == n - 1:\\n                    continue\\n                # the right cell of the current row, need to consider the boundary\\n                right = health[j + 1] if j < n - 1 else math.inf\\n\\t\\t\\t\\t# the down cell of the previous row\\n                down = health[j]\\n                health[j] = max(1, min(right, down) - dungeon[i][j])\\n        return health[0]\\n```\\n\\nWe can further optimize the space complexity by only keeping track of the smaller dimention. Say if n << m, we can use ` health = [math.inf] * m` instead, and iterate column by column.",
                "solutionTags": [],
                "code": "```\\nif dungeon[-1][-1] <= 0:\\n\\thealth = 1 - dungeon[-1][-1]\\nelse:\\n\\thealth = 1\\n```\n```\\nhealth = 1 + max(0, -dungeon[-1][-1])\\n```\n```\\nnxt = min(right, down)\\nif dungeon[i][j] <= 0:\\n\\thealth = nxt - dungeon[i][j]\\nelse:\\n\\t# we can reduce the initial health if we can get some orbs here\\n\\thealth = nxt - dungeon[i][j]\\n\\t# if we have a large enough positive value here, we just need to have a health 1\\n\\tif health < 0:\\n\\t\\thealth = 1\\n```\n```\\nhealth = max(min(right, down) - dungeon[i][j], 1)\\n```\n```\\ndef calculateMinimumHP(self, dungeon: List[List[int]]) -> int:\\n        m, n = len(dungeon), len(dungeon[0])\\n\\t\\t\\n\\t\\t# we only need to memorize the whole next row and one right cell\\n\\t\\t# initialize the row, note that we don\\'t actually need two rows, just\\n\\t\\t# keep updating the same row \\n        health = [math.inf] * n\\n\\t\\t# initialize the bottom right cell\\n        health[-1] = 1 + max(0, -dungeon[-1][-1])\\n\\t\\t\\n\\t\\t# Iterate each cell row by row and caculate the minimun health\\n        for i in range(m - 1, -1, -1):\\n            for j in range(n - 1, -1, -1):\\n\\t\\t\\t\\t# skip the last cell as we\\'ve already initialized it\\n                if i == m - 1 and j == n - 1:\\n                    continue\\n                # the right cell of the current row, need to consider the boundary\\n                right = health[j + 1] if j < n - 1 else math.inf\\n\\t\\t\\t\\t# the down cell of the previous row\\n                down = health[j]\\n                health[j] = max(1, min(right, down) - dungeon[i][j])\\n        return health[0]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1566160,
                "title": "recursion-memo-dp-c",
                "content": "```\\nclass Solution {\\npublic:\\n//     RECURSIVE\\n    int solve(int i,int j,int n,int m,vector<vector<int>>& dungeon){\\n        if(i>=n || j>=m) return INT_MAX;\\n        if(i==n-1 && j==m-1) return dungeon[i][j]<=0 ? abs(dungeon[i][j])+1 : 1;\\n        int down = solve(i+1,j,n,m,dungeon);\\n        int right = solve(i,j+1,n,m,dungeon);\\n        int ans = min(down,right) - dungeon[i][j]; //neg ans rep sufficiency pos rep required energy\\n        return ans<=0?1:ans; //if we are suff,we at least req 1 to survive and if we are short we need the req energy i.e. ans\\n    }\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        int n = dungeon.size();\\n        int m = dungeon[0].size();\\n        return solve(0,0,n,m,dungeon);\\n    }\\n};\\n```\\n\\n```\\nclass Solution {\\npublic:\\n//     MEMO\\n    int solve(int i,int j,int n,int m,vector<vector<int>>& dungeon,vector<vector<int>>& dp){\\n        if(i>=n || j>=m) return INT_MAX;\\n        if(i==n-1 && j==m-1) return dungeon[i][j]<=0 ? abs(dungeon[i][j])+1 : 1;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int down = solve(i+1,j,n,m,dungeon,dp);\\n        int right = solve(i,j+1,n,m,dungeon,dp);\\n        int ans = min(down,right) - dungeon[i][j]; //neg ans rep sufficiency pos rep required energy\\n        return dp[i][j] = ans<=0?1:ans; //if we are suff,we at least req 1 to survive and if we are short we need the req energy i.e. ans\\n    }\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        int n = dungeon.size();\\n        int m = dungeon[0].size();\\n        vector<vector<int>>dp(n,vector<int>(m,-1));\\n        return solve(0,0,n,m,dungeon,dp);\\n    }\\n};\\n```\\n\\n```\\nclass Solution {\\npublic:\\n//     DYNAMIC PROG.\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        vector<vector<int>>dp(n,vector<int>(m,0));\\n        for(int i=n-1;i>=0;i--){\\n            for(int j=m-1;j>=0;j--){\\n                if(i==n-1 && j==m-1)\\n                    dp[i][j] = min(0,dungeon[i][j]);\\n                else if(i==n-1)\\n                    dp[i][j] = min(0,dungeon[i][j]+dp[i][j+1]);\\n                else if(j==m-1)\\n                    dp[i][j] = min(0,dungeon[i][j]+dp[i+1][j]);\\n                else\\n                    dp[i][j] = min(0,dungeon[i][j]+max(dp[i+1][j],dp[i][j+1]));\\n            }\\n        }\\n        return abs(dp[0][0])+1;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n//     RECURSIVE\\n    int solve(int i,int j,int n,int m,vector<vector<int>>& dungeon){\\n        if(i>=n || j>=m) return INT_MAX;\\n        if(i==n-1 && j==m-1) return dungeon[i][j]<=0 ? abs(dungeon[i][j])+1 : 1;\\n        int down = solve(i+1,j,n,m,dungeon);\\n        int right = solve(i,j+1,n,m,dungeon);\\n        int ans = min(down,right) - dungeon[i][j]; //neg ans rep sufficiency pos rep required energy\\n        return ans<=0?1:ans; //if we are suff,we at least req 1 to survive and if we are short we need the req energy i.e. ans\\n    }\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        int n = dungeon.size();\\n        int m = dungeon[0].size();\\n        return solve(0,0,n,m,dungeon);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n//     MEMO\\n    int solve(int i,int j,int n,int m,vector<vector<int>>& dungeon,vector<vector<int>>& dp){\\n        if(i>=n || j>=m) return INT_MAX;\\n        if(i==n-1 && j==m-1) return dungeon[i][j]<=0 ? abs(dungeon[i][j])+1 : 1;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int down = solve(i+1,j,n,m,dungeon,dp);\\n        int right = solve(i,j+1,n,m,dungeon,dp);\\n        int ans = min(down,right) - dungeon[i][j]; //neg ans rep sufficiency pos rep required energy\\n        return dp[i][j] = ans<=0?1:ans; //if we are suff,we at least req 1 to survive and if we are short we need the req energy i.e. ans\\n    }\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        int n = dungeon.size();\\n        int m = dungeon[0].size();\\n        vector<vector<int>>dp(n,vector<int>(m,-1));\\n        return solve(0,0,n,m,dungeon,dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n//     DYNAMIC PROG.\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        vector<vector<int>>dp(n,vector<int>(m,0));\\n        for(int i=n-1;i>=0;i--){\\n            for(int j=m-1;j>=0;j--){\\n                if(i==n-1 && j==m-1)\\n                    dp[i][j] = min(0,dungeon[i][j]);\\n                else if(i==n-1)\\n                    dp[i][j] = min(0,dungeon[i][j]+dp[i][j+1]);\\n                else if(j==m-1)\\n                    dp[i][j] = min(0,dungeon[i][j]+dp[i+1][j]);\\n                else\\n                    dp[i][j] = min(0,dungeon[i][j]+max(dp[i+1][j],dp[i][j+1]));\\n            }\\n        }\\n        return abs(dp[0][0])+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1552743,
                "title": "python3-clean-implementation",
                "content": "```\\nclass Solution:\\n    \\n    def __init__(self):\\n        self.dungeon = None\\n        self.n = None\\n        self.m = None\\n        self.dp = None\\n    \\n    def helper_func(self, position):\\n        \\n        x, y = position\\n        if x >= self.n or y >= self.m or x < 0 or y < 0:\\n            return sys.maxsize\\n        elif x == self.n-1 and y == self.m-1:\\n            return -self.dungeon[x][y] if self.dungeon[x][y] < 0 else 0\\n        \\n        elif position in self.dp:\\n            return self.dp[position]\\n        \\n        else:\\n            right_init = self.helper_func((x, y+1))\\n            down_init = self.helper_func((x+1, y))\\n            curr_init = min(right_init, down_init) - self.dungeon[x][y]\\n            if curr_init < 0: curr_init = 0\\n            self.dp[position] = curr_init \\n            return self.dp[position]         \\n    \\n    \\n    def calculateMinimumHP(self, dungeon: List[List[int]]) -> int:\\n        \\n        self.dungeon = dungeon\\n        self.dp = {}\\n        self.n = len(dungeon)\\n        self.m = len(dungeon[0])\\n        \\n        return self.helper_func((0,0)) + 1\\n        \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    \\n    def __init__(self):\\n        self.dungeon = None\\n        self.n = None\\n        self.m = None\\n        self.dp = None\\n    \\n    def helper_func(self, position):\\n        \\n        x, y = position\\n        if x >= self.n or y >= self.m or x < 0 or y < 0:\\n            return sys.maxsize\\n        elif x == self.n-1 and y == self.m-1:\\n            return -self.dungeon[x][y] if self.dungeon[x][y] < 0 else 0\\n        \\n        elif position in self.dp:\\n            return self.dp[position]\\n        \\n        else:\\n            right_init = self.helper_func((x, y+1))\\n            down_init = self.helper_func((x+1, y))\\n            curr_init = min(right_init, down_init) - self.dungeon[x][y]\\n            if curr_init < 0: curr_init = 0\\n            self.dp[position] = curr_init \\n            return self.dp[position]         \\n    \\n    \\n    def calculateMinimumHP(self, dungeon: List[List[int]]) -> int:\\n        \\n        self.dungeon = dungeon\\n        self.dp = {}\\n        self.n = len(dungeon)\\n        self.m = len(dungeon[0])\\n        \\n        return self.helper_func((0,0)) + 1\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1499387,
                "title": "java-100-fast-reallly-eassssy-self-explanatory-solution",
                "content": "lets take this way\\n\\narr=[[-2,-3,3],[-5,-10,1],[10,30,-5]]\\n\\nif you observe health always will be most -ve value in path\\nand another thing if you gain health take eg of 30 -> -5 we donot need 25 health so we save dp value to 0 as furthure we donot need extra health it will take care of rest path \\nso we have to return\\n\\nmin(0,arr[i][j]+Math.max(right,down));\\n\\nmax because we need maximum of power gain and health loss\\n\\nlook below digram you will understand logic \\n\\n![image](https://assets.leetcode.com/users/images/2a45dc35-2974-4e4c-adc1-312a5b1dfe47_1633197382.4547212.png)\\n\\n\\n# here is code\\n\\n```\\nclass Solution {\\n    Integer[][] memo;\\n    public int calculateMinimumHP(int[][] arr) \\n    {\\n        \\n        int n=arr.length;\\n        int m=arr[0].length;\\n        \\n        memo=new Integer[n][m];\\n        \\n        int answ=f(arr,0,0,n,m);\\n        \\n        return Math.abs(answ)+1;\\n        \\n    }\\n    \\n    int f(int[][] arr,int i,int j,int n,int m)\\n    {\\n        \\n        if(i>=n || j>=m)\\n        return Integer.MIN_VALUE;\\n        \\n        if(memo[i][j]!=null)\\n        return memo[i][j];\\n        \\n        if(i==n-1 && j==m-1)\\n        return Math.min(0,arr[i][j]);\\n        \\n        int down=f(arr,i+1,j,n,m);\\n        int right=f(arr,i,j+1,n,m);\\n        \\n        int max=Math.max(right,down);\\n        \\n        return memo[i][j]=Math.min(0,max+arr[i][j]);\\n        \\n        \\n    }\\n    \\n    \\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    Integer[][] memo;\\n    public int calculateMinimumHP(int[][] arr) \\n    {\\n        \\n        int n=arr.length;\\n        int m=arr[0].length;\\n        \\n        memo=new Integer[n][m];\\n        \\n        int answ=f(arr,0,0,n,m);\\n        \\n        return Math.abs(answ)+1;\\n        \\n    }\\n    \\n    int f(int[][] arr,int i,int j,int n,int m)\\n    {\\n        \\n        if(i>=n || j>=m)\\n        return Integer.MIN_VALUE;\\n        \\n        if(memo[i][j]!=null)\\n        return memo[i][j];\\n        \\n        if(i==n-1 && j==m-1)\\n        return Math.min(0,arr[i][j]);\\n        \\n        int down=f(arr,i+1,j,n,m);\\n        int right=f(arr,i,j+1,n,m);\\n        \\n        int max=Math.max(right,down);\\n        \\n        return memo[i][j]=Math.min(0,max+arr[i][j]);\\n        \\n        \\n    }\\n    \\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1499253,
                "title": "java-dp-o-n-2",
                "content": "```\\nclass Solution {\\n    public int calculateMinimumHP(int[][] dungeon) {\\n        int rows = dungeon.length;\\n        int cols = dungeon[0].length;\\n        \\n        int[][] memo = new int[rows + 1][cols + 1];\\n        for (int[] m : memo) {\\n            Arrays.fill(m, Integer.MAX_VALUE);\\n        }\\n        // the positions behind the princess.\\n        memo[rows][cols - 1] = 1;\\n        memo[rows - 1][cols] = 1;\\n        \\n        for (int r = rows - 1; r >= 0; r--) {\\n            for (int c = cols - 1; c >= 0; c--) {\\n                memo[r][c] = Math.max(1, Math.min(memo[r + 1][c], memo[r][c + 1]) - dungeon[r][c]);\\n            }\\n        }\\n        return memo[0][0];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int calculateMinimumHP(int[][] dungeon) {\\n        int rows = dungeon.length;\\n        int cols = dungeon[0].length;\\n        \\n        int[][] memo = new int[rows + 1][cols + 1];\\n        for (int[] m : memo) {\\n            Arrays.fill(m, Integer.MAX_VALUE);\\n        }\\n        // the positions behind the princess.\\n        memo[rows][cols - 1] = 1;\\n        memo[rows - 1][cols] = 1;\\n        \\n        for (int r = rows - 1; r >= 0; r--) {\\n            for (int c = cols - 1; c >= 0; c--) {\\n                memo[r][c] = Math.max(1, Math.min(memo[r + 1][c], memo[r][c + 1]) - dungeon[r][c]);\\n            }\\n        }\\n        return memo[0][0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1476571,
                "title": "c-dp-recursion-only-for-those-who-like-memorization",
                "content": "```\\nint dp[201][201];\\n    int helper(vector<vector<int>> &dungeon ,int i,int j){\\n        if(i>=dungeon.size() || j>= dungeon[0].size())\\n            return INT_MAX;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        \\n        int health=min(helper(dungeon,i+1,j),helper(dungeon,i,j+1));\\n        if(health==INT_MAX)\\n            health=1;\\n        int res=0;\\n        if(health-dungeon[i][j]>0){\\n            res=health-dungeon[i][j];\\n        }\\n        else res=1;\\n        return dp[i][j]=res;\\n\\n    }\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        memset(dp,-1,sizeof(dp));\\n        return helper(dungeon,0,0);\\n    }",
                "solutionTags": [
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nint dp[201][201];\\n    int helper(vector<vector<int>> &dungeon ,int i,int j){\\n        if(i>=dungeon.size() || j>= dungeon[0].size())\\n            return INT_MAX;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        \\n        int health=min(helper(dungeon,i+1,j),helper(dungeon,i,j+1));\\n        if(health==INT_MAX)\\n            health=1;\\n        int res=0;\\n        if(health-dungeon[i][j]>0){\\n            res=health-dungeon[i][j];\\n        }\\n        else res=1;\\n        return dp[i][j]=res;\\n\\n    }\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        memset(dp,-1,sizeof(dp));\\n        return helper(dungeon,0,0);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1247263,
                "title": "c-recursion-memoisation",
                "content": "```\\nclass Solution {\\nprivate:\\n    int n;\\n    int m;\\n    int dp[202][202];\\n    \\npublic:\\n    int dfs(vector<vector<int>>& d,int x,int y)\\n    {\\n        if(x==n || y==m)return INT_MAX;\\n        if(x==n-1 && y==m-1)\\n        {\\n           return (d[x][y] <= 0) ? -d[x][y] + 1 : 1;\\n        }\\n        if(dp[x][y]!=-1)return dp[x][y];\\n        int a=dfs(d,x+1,y);\\n        int b=dfs(d,x,y+1);\\n        int ans= min(a,b);\\n        if(d[x][y]>=ans)ans=1;\\n        else\\n        {\\n            ans=ans-d[x][y];\\n        }\\n        return dp[x][y]=ans;\\n        \\n    }\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        n=dungeon.size();\\n        m=dungeon[0].size();\\n        memset(dp,-1,sizeof(dp));\\n        return dfs(dungeon,0,0);\\n            \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n    int n;\\n    int m;\\n    int dp[202][202];\\n    \\npublic:\\n    int dfs(vector<vector<int>>& d,int x,int y)\\n    {\\n        if(x==n || y==m)return INT_MAX;\\n        if(x==n-1 && y==m-1)\\n        {\\n           return (d[x][y] <= 0) ? -d[x][y] + 1 : 1;\\n        }\\n        if(dp[x][y]!=-1)return dp[x][y];\\n        int a=dfs(d,x+1,y);\\n        int b=dfs(d,x,y+1);\\n        int ans= min(a,b);\\n        if(d[x][y]>=ans)ans=1;\\n        else\\n        {\\n            ans=ans-d[x][y];\\n        }\\n        return dp[x][y]=ans;\\n        \\n    }\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        n=dungeon.size();\\n        m=dungeon[0].size();\\n        memset(dp,-1,sizeof(dp));\\n        return dfs(dungeon,0,0);\\n            \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1091495,
                "title": "c-no-extra-space-dp-solution-short-simple",
                "content": "0-> *We will approach this problem from the end;*\\n\\n1-> He can enter that room from either above or from left; \\n2-> We can know minimum health needed to enter the room to reach the end;\\n3-> In any position his health should never be less than 1;\\n\\n4-> **DP state is the minimum health requried to reach the end from given room[i,j];**\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int calculateMinimumHP(vector<vector<int>>& DG) {\\n        \\n        int m=DG.size(),n=DG[0].size();\\n        //0\\n        DG[m-1][n-1]=DG[m-1][n-1]<1?1-DG[m-1][n-1]:1;\\n        //2,3\\n        for(int i=m-2;i>=0;i--) {int t=DG[i+1][n-1]-DG[i][n-1];     DG[i][n-1]= t<1?1:t;}\\n        //2,3\\n        for(int j=n-2;j>=0;j--) {int t=DG[m-1][j+1]-DG[m-1][j];     DG[m-1][j]= t<1?1:t;}\\n        \\n        for(int i=m-2;i>=0;i--)\\n            for(int j=n-2;j>=0;j--)\\n            {\\n\\t\\t\\t//1,2,3\\n                int t=min(DG[i+1][j]-DG[i][j],DG[i][j+1]-DG[i][j]);\\n                DG[i][j]=t<1?1:t;\\n            }\\n        //4\\n        return DG[0][0];\\n        \\n        \\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int calculateMinimumHP(vector<vector<int>>& DG) {\\n        \\n        int m=DG.size(),n=DG[0].size();\\n        //0\\n        DG[m-1][n-1]=DG[m-1][n-1]<1?1-DG[m-1][n-1]:1;\\n        //2,3\\n        for(int i=m-2;i>=0;i--) {int t=DG[i+1][n-1]-DG[i][n-1];     DG[i][n-1]= t<1?1:t;}",
                "codeTag": "Java"
            },
            {
                "id": 1046406,
                "title": "python-dijkstra-and-dp-solutions",
                "content": "Another possible solution is to binary search all the possible values of starting health and see if exists a path in the matrix with that starting point.\\n```\\nfrom heapq import heappush, heappop\\n\\nclass Solution:\\n    def calculateMinimumHP(self, dungeon: List[List[int]]) -> int:\\n        \\n        n = len(dungeon)\\n        m = len(dungeon[0])\\n        q = [(-dungeon[0][0], 0, 0)]\\n        vis = {}\\n        valid = lambda x, y: 0 <= x < n and 0 <= y < m\\n        needed = max(0, -dungeon[0][0])\\n        \\n        while q:\\n            h, x, y = heappop(q) # pop all values, the h is negative\\n            vis[(x,y)] = h\\n            needed = max(needed, h) # evaluate if we need to worsen our estimate\\n            \\n            if x == n - 1 and y == m - 1:\\n                return needed + 1\\n                \\n            if valid(x + 1, y):\\n                if (x + 1, y) not in vis or vis[(x + 1, y)] > h - dungeon[x + 1][y]: \\n                    heappush(q, (h - dungeon[x + 1][y], x + 1, y))\\n            if valid(x, y + 1):\\n                if (x, y + 1) not in vis or vis[(x, y + 1)] > h - dungeon[x][y + 1]: \\n                    heappush(q, (h - dungeon[x][y + 1], x, y + 1))\\n        \\n        return needed\\n    \\n    \\n    def calculateMinimumHP(self, dungeon: List[List[int]]) -> int:\\n        \\n        n = len(dungeon)\\n        m = len(dungeon[0])\\n        dp = [[inf for _ in range(m + 1)] for _ in range(n + 1)]\\n        dp[n-1][m] = 1\\n        dp[n][m-1] = 1\\n        \\n        for r in range(n - 1, -1, -1):\\n            for c in range(m - 1, -1, -1):\\n                dp[r][c] = max(min(dp[r + 1][c], dp[r][c + 1]) - dungeon[r][c], 1)\\n                \\n        return dp[0][0]\\n```",
                "solutionTags": [],
                "code": "```\\nfrom heapq import heappush, heappop\\n\\nclass Solution:\\n    def calculateMinimumHP(self, dungeon: List[List[int]]) -> int:\\n        \\n        n = len(dungeon)\\n        m = len(dungeon[0])\\n        q = [(-dungeon[0][0], 0, 0)]\\n        vis = {}\\n        valid = lambda x, y: 0 <= x < n and 0 <= y < m\\n        needed = max(0, -dungeon[0][0])\\n        \\n        while q:\\n            h, x, y = heappop(q) # pop all values, the h is negative\\n            vis[(x,y)] = h\\n            needed = max(needed, h) # evaluate if we need to worsen our estimate\\n            \\n            if x == n - 1 and y == m - 1:\\n                return needed + 1\\n                \\n            if valid(x + 1, y):\\n                if (x + 1, y) not in vis or vis[(x + 1, y)] > h - dungeon[x + 1][y]: \\n                    heappush(q, (h - dungeon[x + 1][y], x + 1, y))\\n            if valid(x, y + 1):\\n                if (x, y + 1) not in vis or vis[(x, y + 1)] > h - dungeon[x][y + 1]: \\n                    heappush(q, (h - dungeon[x][y + 1], x, y + 1))\\n        \\n        return needed\\n    \\n    \\n    def calculateMinimumHP(self, dungeon: List[List[int]]) -> int:\\n        \\n        n = len(dungeon)\\n        m = len(dungeon[0])\\n        dp = [[inf for _ in range(m + 1)] for _ in range(n + 1)]\\n        dp[n-1][m] = 1\\n        dp[n][m-1] = 1\\n        \\n        for r in range(n - 1, -1, -1):\\n            for c in range(m - 1, -1, -1):\\n                dp[r][c] = max(min(dp[r + 1][c], dp[r][c + 1]) - dungeon[r][c], 1)\\n                \\n        return dp[0][0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 981943,
                "title": "java-precise-dp-approach",
                "content": "```\\nclass Solution {\\n    public int calculateMinimumHP(int[][] dungeon) {\\n        int[][] dp = new int [dungeon.length + 1][dungeon[0].length+1]; //memoization is needed to store the output of the repeatitive parts\\n        for(int i=0;i<=dungeon.length;i++) Arrays.fill(dp[i],-1); //initialise the dp matrix with -1\\n\\t    return minHealth(dungeon,0,0,dp); //pass the starting positions\\n    }\\n    \\n    public int minHealth(int[][] arr,int i,int j,int[][] dp){\\n        if(dp[i][j] != -1) return dp[i][j]; //\\n        if(i==arr.length-1 && j==arr[0].length-1) return arr[i][j] > 0 ? 1 : Math.abs(arr[i][j]) + 1;\\n        if(i==arr.length || j==arr[0].length) return Integer.MAX_VALUE;\\n        return dp[i][j] = Math.max(1,Math.min(minHealth(arr,i+1,j,dp),minHealth(arr,i,j+1,dp))-arr[i][j]);\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int calculateMinimumHP(int[][] dungeon) {\\n        int[][] dp = new int [dungeon.length + 1][dungeon[0].length+1]; //memoization is needed to store the output of the repeatitive parts\\n        for(int i=0;i<=dungeon.length;i++) Arrays.fill(dp[i],-1); //initialise the dp matrix with -1\\n\\t    return minHealth(dungeon,0,0,dp); //pass the starting positions\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 704711,
                "title": "top-down-approach-2-state-dp",
                "content": "class Solution {\\n    \\n    static int inf=Integer.MAX_VALUE;\\n    \\n    public int calculateMinimumHP(int[][] dungeon) {\\n        \\n        int[][] dp=new int[dungeon.length][dungeon[0].length];\\n        \\n        return go(dungeon,0,0,dungeon.length,dungeon[0].length,dp);\\n        \\n    }\\n    static int go(int[][] ar,int i,int j,int n,int m,int[][] dp){\\n        \\n        if(i>=n || j>=m){\\n            return inf;\\n        }\\n        \\n        if(dp[i][j]!=0){\\n            return dp[i][j];\\n        }\\n        \\n        int down =go(ar,i+1,j,n,m,dp);\\n        int right=go(ar,i,j+1,n,m,dp);\\n        \\n        if(right==inf && down==inf){\\n           return ar[i][j]>0?1:Math.abs(ar[i][j])+1;\\n        }\\n        \\n        int best=Math.min(down,right);\\n        if(ar[i][j]>0){\\n            dp[i][j]=Math.max(best-ar[i][j],1);\\n        }else{\\n            dp[i][j]=Math.abs(ar[i][j])+best;\\n        }\\n        \\n        return dp[i][j];\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    \\n    static int inf=Integer.MAX_VALUE;\\n    \\n    public int calculateMinimumHP(int[][] dungeon) {\\n        \\n        int[][] dp=new int[dungeon.length][dungeon[0].length];\\n        \\n        return go(dungeon,0,0,dungeon.length,dungeon[0].length,dp);\\n        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 701595,
                "title": "similar-to-max-path-sum-from-top-left-to-right-bottom",
                "content": "```\\n\\n//when the maximum path sum greater than 0 return 0,\\n//because from that point we can reach to princess easily...\\n\\nint findmin(vector<vector<int>> &dungeon,int row,int col,vector<vector<int>> &dp)\\n    {\\n        if(row==dungeon.size()-1 && col==dungeon[0].size()-1 )\\n        {   \\n            if(dungeon[row][col] < 0)\\n                return dungeon[row][col];\\n            else\\n                return 0;\\n        }\\n        else if(row>=dungeon.size() || col>=dungeon[0].size())\\n            return INT_MIN;\\n        if(dp[row][col]!=-1)\\n            return dp[row][col];\\n        int x= dungeon[row][col]+max(findmin(dungeon,row,col+1,dp),\\n                                     findmin(dungeon,row+1,col,dp));\\n        if(x<0)\\n            return dp[row][col]=x;\\n        else\\n            return dp[row][col]=0;\\n    }\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) \\n    {\\n        if(dungeon.size()==0)\\n            return 0;\\n        vector<vector<int>> dp(dungeon.size()+1,vector<int>(dungeon[0].size()+1,-1));\\n        return abs(findmin(dungeon,0,0,dp))+1;\\n    }",
                "solutionTags": [],
                "code": "```\\n\\n//when the maximum path sum greater than 0 return 0,\\n//because from that point we can reach to princess easily...\\n\\nint findmin(vector<vector<int>> &dungeon,int row,int col,vector<vector<int>> &dp)\\n    {\\n        if(row==dungeon.size()-1 && col==dungeon[0].size()-1 )\\n        {   \\n            if(dungeon[row][col] < 0)\\n                return dungeon[row][col];\\n            else\\n                return 0;\\n        }\\n        else if(row>=dungeon.size() || col>=dungeon[0].size())\\n            return INT_MIN;\\n        if(dp[row][col]!=-1)\\n            return dp[row][col];\\n        int x= dungeon[row][col]+max(findmin(dungeon,row,col+1,dp),\\n                                     findmin(dungeon,row+1,col,dp));\\n        if(x<0)\\n            return dp[row][col]=x;\\n        else\\n            return dp[row][col]=0;\\n    }\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) \\n    {\\n        if(dungeon.size()==0)\\n            return 0;\\n        vector<vector<int>> dp(dungeon.size()+1,vector<int>(dungeon[0].size()+1,-1));\\n        return abs(findmin(dungeon,0,0,dp))+1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 699219,
                "title": "java-recursion-memoization-minimum-deficit-0-ms-beats-100",
                "content": "Slightly different approach to given solutions I\\'ve seen. Instead I keep track of minimum deficit, and if there\\'s no deficit (deficit is greater than 0), we set deficit to 0. So at the end, we either have a deficit (result is negative) or we have no deficit (result is 0). If negative, we take Math.abs() and add 1 to get required health. If no deficit, we just return 1 since that is the minimum health required.\\n```\\nclass Solution {\\n    public int calculateMinimumHP(int[][] dungeon) {\\n        return recursionMemo(dungeon);\\n    }\\n\\t\\n\\tprivate Integer[][] memo;\\n    \\n    public int recursionMemo(int[][] dungeon) {\\n        memo = new Integer[dungeon.length][dungeon[0].length];\\n\\n        int result = dfs(dungeon, 0, 0);\\n        if (result < 0) {\\n            result = Math.abs(result) + 1;\\n        } else {\\n            result = 1;\\n        }\\n        return result;\\n    }\\n    \\n    private int dfs(int[][] dungeon, int i, int j) {\\n        if (i == dungeon.length - 1 && j == dungeon[0].length - 1) {\\n            return dungeon[i][j] > 0 ? 0 : dungeon[i][j];\\n        } else if (memo[i][j] != null) {\\n            return memo[i][j];\\n        }\\n        \\n        int down = Integer.MIN_VALUE;\\n        int right = Integer.MIN_VALUE;\\n        if (isValid(i + 1, j, dungeon)) {\\n            down = dfs(dungeon, i + 1, j);\\n        }\\n        if (isValid(i, j + 1, dungeon)) {\\n            right = dfs(dungeon, i, j + 1);\\n        }\\n\\n        int deficit = dungeon[i][j] + Math.max(down, right);\\n\\t\\tdeficit = (deficit > 0) ? 0 : deficit;\\n\\n        memo[i][j] = deficit;\\n        \\n        return memo[i][j];\\n    }\\n    \\n    private boolean isValid(int i, int j, int[][] dungeon) {\\n        return i >= 0 && i < dungeon.length && j >= 0 && j < dungeon[0].length;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int calculateMinimumHP(int[][] dungeon) {\\n        return recursionMemo(dungeon);\\n    }\\n\\t\\n\\tprivate Integer[][] memo;\\n    \\n    public int recursionMemo(int[][] dungeon) {\\n        memo = new Integer[dungeon.length][dungeon[0].length];\\n\\n        int result = dfs(dungeon, 0, 0);\\n        if (result < 0) {\\n            result = Math.abs(result) + 1;\\n        } else {\\n            result = 1;\\n        }\\n        return result;\\n    }\\n    \\n    private int dfs(int[][] dungeon, int i, int j) {\\n        if (i == dungeon.length - 1 && j == dungeon[0].length - 1) {\\n            return dungeon[i][j] > 0 ? 0 : dungeon[i][j];\\n        } else if (memo[i][j] != null) {\\n            return memo[i][j];\\n        }\\n        \\n        int down = Integer.MIN_VALUE;\\n        int right = Integer.MIN_VALUE;\\n        if (isValid(i + 1, j, dungeon)) {\\n            down = dfs(dungeon, i + 1, j);\\n        }\\n        if (isValid(i, j + 1, dungeon)) {\\n            right = dfs(dungeon, i, j + 1);\\n        }\\n\\n        int deficit = dungeon[i][j] + Math.max(down, right);\\n\\t\\tdeficit = (deficit > 0) ? 0 : deficit;\\n\\n        memo[i][j] = deficit;\\n        \\n        return memo[i][j];\\n    }\\n    \\n    private boolean isValid(int i, int j, int[][] dungeon) {\\n        return i >= 0 && i < dungeon.length && j >= 0 && j < dungeon[0].length;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 698986,
                "title": "top-down-python-solution",
                "content": "```python\\nclass Solution:\\n    def calculateMinimumHP(self, dungeon: List[List[int]]) -> int:\\n        n = len(dungeon)\\n        m = len(dungeon[0])\\n        INF = float(\"inf\")\\n        dp = [[-1 for i in range(m+1)] for j in range(n+1)]\\n        \\n        def dfs(i,j):\\n            if (i,j) == (n-1,m-1):\\n                return 1 if (dungeon[i][j] > 0) else abs(dungeon[i][j]) + 1\\n            \\n            if i > (n-1) or j > (m-1):\\n                return INF\\n           \\n            if dp[i][j] != -1:\\n                return dp[i][j]\\n            \\n            dp[i][j] = max(1, min(dfs(i+1,j) , dfs(i,j+1)) - dungeon[i][j]) \\n            return dp[i][j]\\n        \\n        return dfs(0,0)\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def calculateMinimumHP(self, dungeon: List[List[int]]) -> int:\\n        n = len(dungeon)\\n        m = len(dungeon[0])\\n        INF = float(\"inf\")\\n        dp = [[-1 for i in range(m+1)] for j in range(n+1)]\\n        \\n        def dfs(i,j):\\n            if (i,j) == (n-1,m-1):\\n                return 1 if (dungeon[i][j] > 0) else abs(dungeon[i][j]) + 1\\n            \\n            if i > (n-1) or j > (m-1):\\n                return INF\\n           \\n            if dp[i][j] != -1:\\n                return dp[i][j]\\n            \\n            dp[i][j] = max(1, min(dfs(i+1,j) , dfs(i,j+1)) - dungeon[i][j]) \\n            return dp[i][j]\\n        \\n        return dfs(0,0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 698571,
                "title": "rust-dp-bottom-up-0ms-explanation-by-example",
                "content": "Well, let\\'s take this dungeon as an example for demonstration purpose:\\n```\\n[-2,  -3,  3]\\n[-5, -10, -1]\\n[10,  30, -5]\\n```\\nAt right bottom, meaning position `(2,2)`, the hero must have at least 1 HP. So our dp table will look like this:\\n```\\n[_,_,_]\\n[_,_,_]\\n[_,_,1]\\n```\\nNow we begin to fill in the table. Because at `(2,2)` the hero loses 5 HP, so at `(1,2)` and `(2,1)` he must have at least 6 HP.\\n```\\n[_,_,_]\\n[_,_,6]\\n[_,6,1]\\n```\\nAt `(2,1)`, he gains 30 HP so `dp[2][0]` and `dp[1,1]` can be `-24`, but again, the hero would die if that happened so we put in `1` instead.\\n```\\n[_,_,_]\\n[_,1,6]\\n[1,6,1]\\n```\\nAt `(1,2)` he gains `1` HP so `dp[0][2]` and `dp[1][1]` can be `5`. But `dp[1][1]` is already `1`, so which one should we choose? Let\\'s remember, we need the hero to have minimum possible HP at the beginning, so of course we would choose whichever is less. The dp table become\\n```\\n[_,_,5]\\n[_,1,6]\\n[1,6,1]\\n```\\nNow you got the general idea, let\\'s quickly fill all the blanks\\n```\\n[5,2,5]\\n[1,1,6]\\n[1,6,1]\\n```\\nWe can see the hero must have at least `5` HP at `(0,0)`, but at that position he loses `2` HP. Therefore, from the beginning, the hero must have at least `7` HP, and that\\'s the answer.\\n```rust\\nuse std::cmp::{min, max};\\nimpl Solution {\\n    pub fn calculate_minimum_hp(dungeon: Vec<Vec<i32>>) -> i32 {\\n        let m = dungeon.len();\\n        let n = dungeon[0].len();\\n        let mut dp = vec![vec![std::i32::MAX;n];m];\\n        dp[m-1][n-1] = 1;\\n        for i in (0..m).rev() {\\n            for j in (0..n).rev() {\\n                if i > 0 {\\n                    dp[i-1][j] = min(max(dp[i][j]-dungeon[i][j], 1), dp[i-1][j]);\\n                }\\n                if j > 0 {\\n                    dp[i][j-1] = min(max(dp[i][j]-dungeon[i][j], 1), dp[i][j-1]);\\n                }\\n            }\\n        }\\n        max(dp[0][0] - dungeon[0][0], 1)\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n[-2,  -3,  3]\\n[-5, -10, -1]\\n[10,  30, -5]\\n```\n```\\n[_,_,_]\\n[_,_,_]\\n[_,_,1]\\n```\n```\\n[_,_,_]\\n[_,_,6]\\n[_,6,1]\\n```\n```\\n[_,_,_]\\n[_,1,6]\\n[1,6,1]\\n```\n```\\n[_,_,5]\\n[_,1,6]\\n[1,6,1]\\n```\n```\\n[5,2,5]\\n[1,1,6]\\n[1,6,1]\\n```\n```rust\\nuse std::cmp::{min, max};\\nimpl Solution {\\n    pub fn calculate_minimum_hp(dungeon: Vec<Vec<i32>>) -> i32 {\\n        let m = dungeon.len();\\n        let n = dungeon[0].len();\\n        let mut dp = vec![vec![std::i32::MAX;n];m];\\n        dp[m-1][n-1] = 1;\\n        for i in (0..m).rev() {\\n            for j in (0..n).rev() {\\n                if i > 0 {\\n                    dp[i-1][j] = min(max(dp[i][j]-dungeon[i][j], 1), dp[i-1][j]);\\n                }\\n                if j > 0 {\\n                    dp[i][j-1] = min(max(dp[i][j]-dungeon[i][j], 1), dp[i][j-1]);\\n                }\\n            }\\n        }\\n        max(dp[0][0] - dungeon[0][0], 1)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 698264,
                "title": "java-dp-solution",
                "content": "This problem is a reversed process of classic DP problem to find the shortest path in 2D matrix. We start the process from the destination to the source. \\n\\nExplaination of DP rules:\\n1. `hp[i][j]` represent the minimum health point to reach point `(i, j)`. \\n2. At least 1 point needed for each position. The destination need 1 after reduce or bonus in the final position: `Math.max(1, 1 - dungeon[m-1][n-1])`. \\n3. The minimum `hp` needed from current position `hp[i][j]` to reach one of the next hops (`hp[i+1][j] or hp[i][j+1]`) is `Math.max(1, hp[i+1][j] - dungeon[i][j])` or `Math.max(1, hp[i][j+1] - dungeon[i][j])`. Choose the smaller one. \\n\\n```java\\nclass Solution {\\n    public int calculateMinimumHP(int[][] dungeon) {\\n        int m = dungeon.length, n = dungeon[0].length;\\n        \\n        int[][] hp = new int[m][n];\\n        \\n        hp[m-1][n-1] = Math.max(1, 1 - dungeon[m-1][n-1]);\\n        \\n        for (int i = m - 2; i >= 0; i--)\\n            hp[i][n-1] = Math.max(1, hp[i+1][n-1] - dungeon[i][n-1]);\\n        \\n        for (int i = n - 2; i >= 0; i--)\\n            hp[m-1][i] = Math.max(1, hp[m-1][i+1] - dungeon[m-1][i]);\\n        \\n        for (int i = m - 2; i >= 0; i--) {\\n            for (int j = n - 2; j >= 0; j--) {\\n                int opt1 = Math.max(1, hp[i+1][j] - dungeon[i][j]);\\n                int opt2 = Math.max(1, hp[i][j+1] - dungeon[i][j]);\\n                hp[i][j] = Math.min(opt1, opt2);\\n            }\\n        }\\n        \\n        return hp[0][0];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int calculateMinimumHP(int[][] dungeon) {\\n        int m = dungeon.length, n = dungeon[0].length;\\n        \\n        int[][] hp = new int[m][n];\\n        \\n        hp[m-1][n-1] = Math.max(1, 1 - dungeon[m-1][n-1]);\\n        \\n        for (int i = m - 2; i >= 0; i--)\\n            hp[i][n-1] = Math.max(1, hp[i+1][n-1] - dungeon[i][n-1]);\\n        \\n        for (int i = n - 2; i >= 0; i--)\\n            hp[m-1][i] = Math.max(1, hp[m-1][i+1] - dungeon[m-1][i]);\\n        \\n        for (int i = m - 2; i >= 0; i--) {\\n            for (int j = n - 2; j >= 0; j--) {\\n                int opt1 = Math.max(1, hp[i+1][j] - dungeon[i][j]);\\n                int opt2 = Math.max(1, hp[i][j+1] - dungeon[i][j]);\\n                hp[i][j] = Math.min(opt1, opt2);\\n            }\\n        }\\n        \\n        return hp[0][0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 692055,
                "title": "python-simple-dp-solution-with-dp-table",
                "content": "```\\nclass Solution:\\n    def calculateMinimumHP(self, dungeon: List[List[int]]) -> int:\\n        ## RC ##\\n\\t\\t## APPROACH : DP ##\\n\\t\\t## TIME COMPLEXICITY : O(M*N) ##\\n\\t\\t## SPACE COMPLEXICITY : O(M*N) ##\\n\\t\\n\\t\\t## EXAMPLE ##\\n\\t\\t# [\\n\\t\\t# [-2,-3,3],\\n\\t\\t# [-5,-10,1],\\n\\t\\t# [10,30,-5]\\n\\t\\t# ]\\n\\t\\t## STACK TRACE ##\\n\\t\\t# [\\n\\t\\t# [7, 5, 2], \\n\\t\\t# [6, 11, 5], \\n\\t\\t# [1, 1, 6]\\n\\t\\t# ]\\n\\n        m, n = len(dungeon), len(dungeon[0])\\n        dp = [[0] * n for _ in range(m)]\\n        \\n        # base case, start\\n        dp[-1][-1] = max( 1, 1 - dungeon[-1][-1] )\\n        \\n        # borders first, base case\\n        for j in range(n-1, 0, -1):\\n            dp[-1][j-1] = max( 1, dp[-1][j] - dungeon[-1][j-1] )\\n        \\n        for i in range(m-1, 0, -1):\\n            dp[i-1][-1] = max( 1, dp[i][-1] - dungeon[i-1][-1] )\\n        \\n        for i in range(m-2, -1, -1):\\n            for j in range(n-2, -1, -1):\\n                dp[i][j] = min( max( 1, dp[i+1][j] - dungeon[i][j] ), max( 1, dp[i][j+1] - dungeon[i][j] ))        \\n        return dp[0][0]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def calculateMinimumHP(self, dungeon: List[List[int]]) -> int:\\n        ## RC ##\\n\\t\\t## APPROACH : DP ##\\n\\t\\t## TIME COMPLEXICITY : O(M*N) ##\\n\\t\\t## SPACE COMPLEXICITY : O(M*N) ##\\n\\t\\n\\t\\t## EXAMPLE ##\\n\\t\\t# [\\n\\t\\t# [-2,-3,3],\\n\\t\\t# [-5,-10,1],\\n\\t\\t# [10,30,-5]\\n\\t\\t# ]\\n\\t\\t## STACK TRACE ##\\n\\t\\t# [\\n\\t\\t# [7, 5, 2], \\n\\t\\t# [6, 11, 5], \\n\\t\\t# [1, 1, 6]\\n\\t\\t# ]\\n\\n        m, n = len(dungeon), len(dungeon[0])\\n        dp = [[0] * n for _ in range(m)]\\n        \\n        # base case, start\\n        dp[-1][-1] = max( 1, 1 - dungeon[-1][-1] )\\n        \\n        # borders first, base case\\n        for j in range(n-1, 0, -1):\\n            dp[-1][j-1] = max( 1, dp[-1][j] - dungeon[-1][j-1] )\\n        \\n        for i in range(m-1, 0, -1):\\n            dp[i-1][-1] = max( 1, dp[i][-1] - dungeon[i-1][-1] )\\n        \\n        for i in range(m-2, -1, -1):\\n            for j in range(n-2, -1, -1):\\n                dp[i][j] = min( max( 1, dp[i+1][j] - dungeon[i][j] ), max( 1, dp[i][j+1] - dungeon[i][j] ))        \\n        return dp[0][0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 642054,
                "title": "c-concise-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        if (dungeon.empty()) return 0;\\n        \\n        int m = dungeon.size();\\n        int n = dungeon[0].size();\\n        vector<vector<int>>dp(m+1, vector<int>(n+1, INT_MAX));\\n        \\n        dp[m][n-1] = 1; dp[m-1][n] = 1;\\n        for (int i = m-1; i >= 0; i--) {\\n            for (int j = n-1; j >= 0; j--) {\\n                int need = min(dp[i+1][j], dp[i][j+1]) - dungeon[i][j];\\n                dp[i][j] = (need <= 0) ? 1 : need;\\n            }\\n        }\\n        \\n        return dp[0][0];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        if (dungeon.empty()) return 0;\\n        \\n        int m = dungeon.size();\\n        int n = dungeon[0].size();\\n        vector<vector<int>>dp(m+1, vector<int>(n+1, INT_MAX));\\n        \\n        dp[m][n-1] = 1; dp[m-1][n] = 1;\\n        for (int i = m-1; i >= 0; i--) {\\n            for (int j = n-1; j >= 0; j--) {\\n                int need = min(dp[i+1][j], dp[i][j+1]) - dungeon[i][j];\\n                dp[i][j] = (need <= 0) ? 1 : need;\\n            }\\n        }\\n        \\n        return dp[0][0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 590024,
                "title": "ez-dp-question-javascript-solution-with-simple-explanation",
                "content": "```javascript\\n/**\\n * @param {number[][]} dungeon\\n * @return {number}\\n */\\nvar calculateMinimumHP = function(dungeon) {\\n    // first, lets allow knight\\'s health can be zero\\n    // A[i][j] shows the min health that knight needs to rescue the pricess from dungeon[i][j]\\n    // then we get the following DP formular\\n    //\\n    // A[i][j] = max{ min{A[i][j+1], A[i+1][j]} - dungeon[i][j], 0}\\n    //\\n    // explanation:\\n    // 1. min{A[i][j+1], A[i+1][j]}-dungeon[i][j] \\n    // find the min health required and add the health cost at current position \\n    // 2. max{ min{A[i][j+1], A[i+1][j]} - dungeon[i][j], 0}\\n    // if the min health required is negative, we set it as 0! \\n    // (this is because that knight\\'s health can not be negative)\\n    // 3. return A[0][0] + 1 (question does not allow 0 health, so we add 1)\\n    \\n    let m = dungeon.length\\n    let n = dungeon[0].length\\n    \\n\\n    let A = new Array(m)\\n    for(let i=0; i<m; i++){\\n        A[i] = new Array(n)\\n    }\\n\\n    \\n    for(let i = m-1; i>=0; i--) {\\n        for(let j = n-1; j>=0; j--) {\\n            let goLeft=Infinity, goDown=Infinity\\n            if(i+1>=m && j+1>=n){\\n                goLeft=0\\n                goDown=0\\n            }else if(i+1<m && j+1 <n){\\n                goLeft = A[i][j+1]\\n                goDown = A[i+1][j]\\n            } else if(j+1<n){\\n                goLeft = A[i][j+1]\\n            } else {\\n                goDown = A[i+1][j]\\n            }\\n\\n            A[i][j] = Math.max(Math.min(goLeft,goDown)-dungeon[i][j], 0)\\n\\n        }  \\n    }\\n    return A[0][0]+1\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\n/**\\n * @param {number[][]} dungeon\\n * @return {number}\\n */\\nvar calculateMinimumHP = function(dungeon) {\\n    // first, lets allow knight\\'s health can be zero\\n    // A[i][j] shows the min health that knight needs to rescue the pricess from dungeon[i][j]\\n    // then we get the following DP formular\\n    //\\n    // A[i][j] = max{ min{A[i][j+1], A[i+1][j]} - dungeon[i][j], 0}\\n    //\\n    // explanation:\\n    // 1. min{A[i][j+1], A[i+1][j]}-dungeon[i][j] \\n    // find the min health required and add the health cost at current position \\n    // 2. max{ min{A[i][j+1], A[i+1][j]} - dungeon[i][j], 0}\\n    // if the min health required is negative, we set it as 0! \\n    // (this is because that knight\\'s health can not be negative)\\n    // 3. return A[0][0] + 1 (question does not allow 0 health, so we add 1)\\n    \\n    let m = dungeon.length\\n    let n = dungeon[0].length\\n    \\n\\n    let A = new Array(m)\\n    for(let i=0; i<m; i++){\\n        A[i] = new Array(n)\\n    }\\n\\n    \\n    for(let i = m-1; i>=0; i--) {\\n        for(let j = n-1; j>=0; j--) {\\n            let goLeft=Infinity, goDown=Infinity\\n            if(i+1>=m && j+1>=n){\\n                goLeft=0\\n                goDown=0\\n            }else if(i+1<m && j+1 <n){\\n                goLeft = A[i][j+1]\\n                goDown = A[i+1][j]\\n            } else if(j+1<n){\\n                goLeft = A[i][j+1]\\n            } else {\\n                goDown = A[i+1][j]\\n            }\\n\\n            A[i][j] = Math.max(Math.min(goLeft,goDown)-dungeon[i][j], 0)\\n\\n        }  \\n    }\\n    return A[0][0]+1\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 558798,
                "title": "from-recursion-to-efficient-dp-solution",
                "content": "**Recursion Solution** *Time Limit* :\\n\\n```\\npublic int Solution(int[][] dungeon)\\n{\\n\\tif (dungeon.Length == 0) return 0;\\n\\treturn Help(dungeon, dungeon.Length - 1, dungeon[0].Length - 1, 0, 0, 0, 0);\\n}\\n\\nprivate int Help(int[][] matrix, int m, int n, int hp, int need, int i, int j)\\n{\\n\\thp += matrix[i][j];\\n\\tneed = Math.Min(need, hp);\\n\\tif (i == m && j == n) return need >= 0 ? 1 : 1 - need;\\n\\n\\tif (i == m)// last line\\n\\t\\treturn Help(matrix, m, n, hp, need, i, j + 1);\\n\\n\\tif (j == n)// last column\\n\\t\\treturn Help(matrix, m, n, hp, need, i + 1, j);\\n\\n\\treturn Math.Min(Help(matrix, m, n, hp, need, i, j + 1), Help(matrix, m, n, hp, need, i + 1, j));\\n\\n}\\n```\\n\\n**Dp Solution** *Efficient*\\n\\nnote: from The last element not The first element begin\\n\\n```\\npublic int DpSolution4(int[][] dungeon)// dungeon ==> dp\\n{\\n\\tif (dungeon.Length == 0) return 0;\\n\\tint m = dungeon.Length, n = dungeon[0].Length;\\n\\n\\tfor (int i = m - 2; i >= 0; i--)// last column\\n\\t\\tdungeon[i][n-1] = Math.Min(dungeon[i][n - 1], dungeon[i][n - 1] + dungeon[i + 1][n - 1]);\\n\\n\\tfor (int i = n - 2; i >= 0; i--)// last line\\n\\t\\tdungeon[m-1][i] = Math.Min(dungeon[m - 1][i], dungeon[m - 1][i] + dungeon[m - 1][i + 1]);\\n\\n\\tfor (int i = m - 2; i >= 0; i--)\\n\\t\\tfor (int j = n - 2; j >= 0; j--)\\n\\t\\t    // down or right\\n\\t\\t\\tdungeon[i][j] = Math.Max(Math.Min(dungeon[i][j], dungeon[i][j] + dungeon[i][j + 1]), Math.Min(dungeon[i][j], dungeon[i][j] + dungeon[i + 1][j]));\\n\\n\\treturn dungeon[0][0] >= 0 ? 1 : 1 - dungeon[0][0];\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\npublic int Solution(int[][] dungeon)\\n{\\n\\tif (dungeon.Length == 0) return 0;\\n\\treturn Help(dungeon, dungeon.Length - 1, dungeon[0].Length - 1, 0, 0, 0, 0);\\n}\\n\\nprivate int Help(int[][] matrix, int m, int n, int hp, int need, int i, int j)\\n{\\n\\thp += matrix[i][j];\\n\\tneed = Math.Min(need, hp);\\n\\tif (i == m && j == n) return need >= 0 ? 1 : 1 - need;\\n\\n\\tif (i == m)// last line\\n\\t\\treturn Help(matrix, m, n, hp, need, i, j + 1);\\n\\n\\tif (j == n)// last column\\n\\t\\treturn Help(matrix, m, n, hp, need, i + 1, j);\\n\\n\\treturn Math.Min(Help(matrix, m, n, hp, need, i, j + 1), Help(matrix, m, n, hp, need, i + 1, j));\\n\\n}\\n```\n```\\npublic int DpSolution4(int[][] dungeon)// dungeon ==> dp\\n{\\n\\tif (dungeon.Length == 0) return 0;\\n\\tint m = dungeon.Length, n = dungeon[0].Length;\\n\\n\\tfor (int i = m - 2; i >= 0; i--)// last column\\n\\t\\tdungeon[i][n-1] = Math.Min(dungeon[i][n - 1], dungeon[i][n - 1] + dungeon[i + 1][n - 1]);\\n\\n\\tfor (int i = n - 2; i >= 0; i--)// last line\\n\\t\\tdungeon[m-1][i] = Math.Min(dungeon[m - 1][i], dungeon[m - 1][i] + dungeon[m - 1][i + 1]);\\n\\n\\tfor (int i = m - 2; i >= 0; i--)\\n\\t\\tfor (int j = n - 2; j >= 0; j--)\\n\\t\\t    // down or right\\n\\t\\t\\tdungeon[i][j] = Math.Max(Math.Min(dungeon[i][j], dungeon[i][j] + dungeon[i][j + 1]), Math.Min(dungeon[i][j], dungeon[i][j] + dungeon[i + 1][j]));\\n\\n\\treturn dungeon[0][0] >= 0 ? 1 : 1 - dungeon[0][0];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 508267,
                "title": "python-solution-91-time",
                "content": "```\\nclass Solution:\\n    def calculateMinimumHP(self, dungeon: List[List[int]]) -> int:\\n        if not dungeon:\\n            return 1\\n        tmp_int = len(dungeon[0])+1\\n        dp = []\\n        for i in range(len(dungeon)+1):\\n            dp.append([10000000000] * tmp_int) # max int\\n        dp[-1][-2],dp[-2][-1],dp[-1][-1] = 1,1,1\\n        #print(dp)\\n        for i in range(len(dungeon)-1,-1,-1):\\n            for j in range(len(dungeon[0])-1,-1,-1):\\n                dp[i][j] = max(1,min(dp[i+1][j],dp[i][j+1]) - dungeon[i][j])\\n        #print(dp)\\n        return dp[0][0]\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def calculateMinimumHP(self, dungeon: List[List[int]]) -> int:\\n        if not dungeon:\\n            return 1\\n        tmp_int = len(dungeon[0])+1\\n        dp = []\\n        for i in range(len(dungeon)+1):\\n            dp.append([10000000000] * tmp_int) # max int\\n        dp[-1][-2],dp[-2][-1],dp[-1][-1] = 1,1,1\\n        #print(dp)\\n        for i in range(len(dungeon)-1,-1,-1):\\n            for j in range(len(dungeon[0])-1,-1,-1):\\n                dp[i][j] = max(1,min(dp[i+1][j],dp[i][j+1]) - dungeon[i][j])\\n        #print(dp)\\n        return dp[0][0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 440230,
                "title": "c-solution",
                "content": "```\\npublic class Solution \\n{\\n    public int CalculateMinimumHP(int[][] d)\\n    {\\n        int c = d.Length, r = d[0].Length;\\n        int[] dp = Enumerable.Repeat(int.MaxValue, r + 1).ToArray();\\n        dp[r - 1] = 1;\\n        for (int i = c - 1; i >= 0; i--)\\n            for (int j = r - 1; j >= 0; j--)\\n                dp[j] = Math.Max(1 , Math.Min(dp[j], dp[j + 1]) - d[i][j]);\\n\\n        return dp[0];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution \\n{\\n    public int CalculateMinimumHP(int[][] d)\\n    {\\n        int c = d.Length, r = d[0].Length;\\n        int[] dp = Enumerable.Repeat(int.MaxValue, r + 1).ToArray();\\n        dp[r - 1] = 1;\\n        for (int i = c - 1; i >= 0; i--)\\n            for (int j = r - 1; j >= 0; j--)\\n                dp[j] = Math.Max(1 , Math.Min(dp[j], dp[j + 1]) - d[i][j]);\\n\\n        return dp[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 412324,
                "title": "dfs-memorization-easy-to-think-in-terms-of-memorization-as-compared-to-bottom-up",
                "content": "Let us talk about in terms of memorization.\\n(IE = initial energy, CBV = current block value)\\nBasically there are only 2 ways possible:\\n1) Dungeon moves to block having -ve value\\n2) Dungeon moves to block having +ve value\\n\\nSo, if dungeon moves to block with -ve value, it must have IE>=abs(cbv)+1 and if CBV>=0, IE=1.\\nSo in general if we go to right then we check for minimum required IE recurrsively using formula\\nInitial Energy required for any general block (i,j) when next move is right:\\nint tmp = g[i][j]>=0 ? -1*g[i][j] : abs(g[i][j])\\nright = max(tmp, tmp+dfs(i, j+1))\\nInitial Energy required for any general block (i,j) when next move is left:\\ndown = max(tmp, tmp+dfs(i+1, j))\\n\\nSo, dp[i][j] = min(right, left)\\n\\nBase conditions:\\ni==n-1, j==m-1 return g[i][j]>=0 ? -1*g[i][j] : abs(g[i][j])\\n\\nval = dfs(g, dp, 0, 0);\\nans = val>=0 ? ans+1:1;\\n```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    typedef vector<vector<int>> vvi;\\n    typedef vector<int> vi;   \\n    int n,m;\\n    \\n    int dfs(vvi &g, vvi &dp, int i, int j){\\n        if(i==n-1 && j==m-1)\\n            return g[i][j]>=0 ? -1*g[i][j]:abs(g[i][j]);\\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        \\n        ll r=INT_MAX, d=INT_MAX, tmp;\\n        tmp = g[i][j]>=0 ? -1*g[i][j]:abs(g[i][j]);\\n        \\n        if((j+1)<m) r = max(tmp, tmp+dfs(g, dp, i, j+1));\\n        if((i+1)<n) d = max(tmp, tmp+dfs(g, dp, i+1, j));\\n        \\n        dp[i][j] = min(r, d);\\n        return dp[i][j];\\n        \\n    }\\n      \\n    int calculateMinimumHP(vvi& g) {\\n        n=g.size();\\n        m=g[0].size();\\n        vvi dp(n, vi(m, -1));\\n        ll ans = dfs(g, dp, 0, 0);\\n        return ans>=0 ? ans+1:1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    typedef vector<vector<int>> vvi;\\n    typedef vector<int> vi;   \\n    int n,m;\\n    \\n    int dfs(vvi &g, vvi &dp, int i, int j){\\n        if(i==n-1 && j==m-1)\\n            return g[i][j]>=0 ? -1*g[i][j]:abs(g[i][j]);\\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        \\n        ll r=INT_MAX, d=INT_MAX, tmp;\\n        tmp = g[i][j]>=0 ? -1*g[i][j]:abs(g[i][j]);\\n        \\n        if((j+1)<m) r = max(tmp, tmp+dfs(g, dp, i, j+1));\\n        if((i+1)<n) d = max(tmp, tmp+dfs(g, dp, i+1, j));\\n        \\n        dp[i][j] = min(r, d);\\n        return dp[i][j];\\n        \\n    }\\n      \\n    int calculateMinimumHP(vvi& g) {\\n        n=g.size();\\n        m=g[0].size();\\n        vvi dp(n, vi(m, -1));\\n        ll ans = dfs(g, dp, 0, 0);\\n        return ans>=0 ? ans+1:1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 355341,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int calculateMinimumHP(int[][] dungeon) {\\n        if(dungeon == null || dungeon.length == 0 || dungeon[0].length == 0)\\n            return 0;\\n        \\n        int m = dungeon.length, n = dungeon[0].length;\\n        int[][] health = new int[m][n];\\n        health[m - 1][n - 1] = Math.max(1 - dungeon[m - 1][n - 1], 1);\\n        \\n        //Initialize health matrix\\n        for(int i = m - 2; i >= 0; i--)\\n            health[i][n - 1] = Math.max(health[i + 1][n - 1] - dungeon[i][n - 1], 1);\\n        \\n        for(int j = n - 2; j >= 0; j--)\\n            health[m - 1][j] = Math.max(health[m - 1][j + 1] - dungeon[m - 1][j], 1);\\n        \\n        //Update the rest of health matrix\\n        for(int i = m - 2; i >= 0; i--){\\n            for(int j = n - 2; j >= 0; j--){\\n                int down = Math.max(health[i + 1][j] - dungeon[i][j], 1);\\n                int right = Math.max(health[i][j + 1] - dungeon[i][j], 1);\\n                health[i][j] = Math.min(down, right);\\n            }\\n        }\\n        \\n        return health[0][0];\\n        \\n    }\\n}\\n```\\n\\nRuntime: 3 ms, faster than 6.69% of Java online submissions for Dungeon Game.\\nMemory Usage: 39.9 MB, less than 82.35% of Java online submissions for Dungeon Game.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int calculateMinimumHP(int[][] dungeon) {\\n        if(dungeon == null || dungeon.length == 0 || dungeon[0].length == 0)\\n            return 0;\\n        \\n        int m = dungeon.length, n = dungeon[0].length;\\n        int[][] health = new int[m][n];\\n        health[m - 1][n - 1] = Math.max(1 - dungeon[m - 1][n - 1], 1);\\n        \\n        //Initialize health matrix\\n        for(int i = m - 2; i >= 0; i--)\\n            health[i][n - 1] = Math.max(health[i + 1][n - 1] - dungeon[i][n - 1], 1);\\n        \\n        for(int j = n - 2; j >= 0; j--)\\n            health[m - 1][j] = Math.max(health[m - 1][j + 1] - dungeon[m - 1][j], 1);\\n        \\n        //Update the rest of health matrix\\n        for(int i = m - 2; i >= 0; i--){\\n            for(int j = n - 2; j >= 0; j--){\\n                int down = Math.max(health[i + 1][j] - dungeon[i][j], 1);\\n                int right = Math.max(health[i][j + 1] - dungeon[i][j], 1);\\n                health[i][j] = Math.min(down, right);\\n            }\\n        }\\n        \\n        return health[0][0];\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 330370,
                "title": "go-4ms-dynamic-programming-submission-beating-100",
                "content": "Deduction: you need to start from the last room.\\n\\nWhen you fall into the last room (M,N), you need to have at least `1 - room[M][N]` health points.\\n\\nWhen you fall into a room (r,c), you need at least enough life to jump into this room and to jump into the right or bottom room, whichever requires the less health points.\\n\\nAlso, each jump into a room needs to be normalized to 1 if the calculated required life is <0.\\n\\n```golang\\nfunc calculateMinimumHP(dungeon [][]int) int {\\n\\tM := len(dungeon) - 1    // rows\\n\\tN := len(dungeon[0]) - 1 // columns\\n\\n\\tfor r := M; r >= 0; r-- {\\n\\t\\tfor c := N; c >= 0; c-- {\\n\\t\\t\\tif r == M && c == N { // bottom-right room\\n\\t\\t\\t\\tdungeon[r][c] = max(1, 1-dungeon[r][c])\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\t\\t\\tif r == M { // bottom-margin room\\n\\t\\t\\t\\tdungeon[r][c] = max(1, dungeon[r][c+1]-dungeon[r][c])\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\t\\t\\tif c == N { // right-margin room\\n\\t\\t\\t\\tdungeon[r][c] = max(1, dungeon[r+1][c]-dungeon[r][c])\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n       // any other room\\n\\t\\t\\tdungeon[r][c] = max(1, min(dungeon[r+1][c], dungeon[r][c+1])-dungeon[r][c])\\n\\t\\t}\\n\\t}\\n\\n\\treturn dungeon[0][0]\\n}\\n\\nfunc min(i, j int) int {\\n\\tif i < j {\\n\\t\\treturn i\\n\\t}\\n\\treturn j\\n}\\n\\nfunc max(i, j int) int {\\n\\tif i > j {\\n\\t\\treturn i\\n\\t}\\n\\treturn j\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```golang\\nfunc calculateMinimumHP(dungeon [][]int) int {\\n\\tM := len(dungeon) - 1    // rows\\n\\tN := len(dungeon[0]) - 1 // columns\\n\\n\\tfor r := M; r >= 0; r-- {\\n\\t\\tfor c := N; c >= 0; c-- {\\n\\t\\t\\tif r == M && c == N { // bottom-right room\\n\\t\\t\\t\\tdungeon[r][c] = max(1, 1-dungeon[r][c])\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\t\\t\\tif r == M { // bottom-margin room\\n\\t\\t\\t\\tdungeon[r][c] = max(1, dungeon[r][c+1]-dungeon[r][c])\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\t\\t\\tif c == N { // right-margin room\\n\\t\\t\\t\\tdungeon[r][c] = max(1, dungeon[r+1][c]-dungeon[r][c])\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n       // any other room\\n\\t\\t\\tdungeon[r][c] = max(1, min(dungeon[r+1][c], dungeon[r][c+1])-dungeon[r][c])\\n\\t\\t}\\n\\t}\\n\\n\\treturn dungeon[0][0]\\n}\\n\\nfunc min(i, j int) int {\\n\\tif i < j {\\n\\t\\treturn i\\n\\t}\\n\\treturn j\\n}\\n\\nfunc max(i, j int) int {\\n\\tif i > j {\\n\\t\\treturn i\\n\\t}\\n\\treturn j\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 272589,
                "title": "dp-and-binary-search-solution",
                "content": "**DP solution:**\\n\\nThe idea of dp is simple. We will start from last cell. Then for every cell from the last cell we will calculate what is the minimum power needed to reach the last cell from current cell.\\nWhen we are calculating minimum power for cell (i,j), we will only onsider cell (i+1,j)=x and (i, j+1)=y. If max(x,y) is positive then we will need 0 extra power for reaching last cell, but we might need extrapower for current cell if current cell is negative.\\nBut if max(x,y) is negative then we need to add it with the current cell to calculate the minimum cost needed to reach from current cell.\\n\\nAfter the iteration if (0,0) cell has power>=0 then answer will be 1.\\nIf (0,0) cell has power<0 then answer will be abs((0,0))+1.\\n\\n```\\n#define LL long long\\n\\nclass Solution {\\npublic:\\n    int calculateMinimumHP(vector<vector<int>>& grid) {\\n        int r = grid.size();\\n        int c = grid[0].size();\\n        for(int i=r-1; i>=0; i--){\\n            for(int j=c-1; j>=0; j--){\\n                if(i==r-1 && j==c-1)continue;\\n                int a = INT_MIN;\\n                int b = INT_MIN;\\n                if(i+1<r){\\n                    a = min(0, grid[i+1][j]);\\n                }\\n                if(j+1<c){\\n                    b = min(0, grid[i][j+1]);\\n                }\\n                grid[i][j] = grid[i][j] + max(a, b);\\n            }\\n        }\\n        if(grid[0][0]>=0)return 1;\\n        return abs(grid[0][0])+1;\\n    }\\n    \\n};\\n```\\nTime complexity: ```O(r*c)```\\nspace complexity: ```O(1)```\\n\\n**Binary Search solution:**\\nBinary search idea is more simpler. First we will start from a range. Then in each iteration we will check if we can reach (r-1,c-1) cell with this initial cost.\\nIf we can reach the end cell we will set the range_end = cur_mid\\notherwise we will set range_start = cur_mid+1\\n\\n```\\n#define LL long long\\n\\nclass Solution {\\npublic:\\n    int calculateMinimumHP(vector<vector<int>>& grid) {\\n        LL start = 1;\\n        LL end = INT_MAX;\\n        while(start<end){\\n            LL mid = (start + end)/2;\\n            if(can_cross(grid, mid)==true){\\n                end = mid;\\n            }else{\\n                start = mid+1;\\n            }\\n        }\\n        return start;\\n    }\\n    \\n    \\n    bool can_cross(vector<vector<int>> &grid, int start){\\n        int r = grid.size();\\n        int c = grid[0].size();\\n        vector<vector<int>> mat(grid.size(), vector<int>(grid[0].size(), 0));\\n        for(int i=0; i<mat.size(); i++){\\n            for(int j=0; j<mat[i].size(); j++){\\n                if(i==0 && j==0){\\n                    mat[i][j] = start + grid[0][0];\\n                }else{\\n                    int a = INT_MIN;\\n                    int b = INT_MIN;\\n                    if(i>0 && mat[i-1][j]>0){\\n                        a = mat[i-1][j] + grid[i][j];\\n                    }\\n                    if(j>0 && mat[i][j-1]>0){\\n                        b = mat[i][j-1] + grid[i][j];\\n                    }\\n                    mat[i][j] = max(a, b);\\n                }\\n            }\\n        }\\n        return mat[r-1][c-1]>0;\\n    }\\n    \\n};\\n```\\n\\nTime Complexity: ```O(r*c*log(INT_MAX))```\\nSpace Complexity: ```O(r*c)```",
                "solutionTags": [],
                "code": "```\\n#define LL long long\\n\\nclass Solution {\\npublic:\\n    int calculateMinimumHP(vector<vector<int>>& grid) {\\n        int r = grid.size();\\n        int c = grid[0].size();\\n        for(int i=r-1; i>=0; i--){\\n            for(int j=c-1; j>=0; j--){\\n                if(i==r-1 && j==c-1)continue;\\n                int a = INT_MIN;\\n                int b = INT_MIN;\\n                if(i+1<r){\\n                    a = min(0, grid[i+1][j]);\\n                }\\n                if(j+1<c){\\n                    b = min(0, grid[i][j+1]);\\n                }\\n                grid[i][j] = grid[i][j] + max(a, b);\\n            }\\n        }\\n        if(grid[0][0]>=0)return 1;\\n        return abs(grid[0][0])+1;\\n    }\\n    \\n};\\n```\n```O(r*c)```\n```O(1)```\n```\\n#define LL long long\\n\\nclass Solution {\\npublic:\\n    int calculateMinimumHP(vector<vector<int>>& grid) {\\n        LL start = 1;\\n        LL end = INT_MAX;\\n        while(start<end){\\n            LL mid = (start + end)/2;\\n            if(can_cross(grid, mid)==true){\\n                end = mid;\\n            }else{\\n                start = mid+1;\\n            }\\n        }\\n        return start;\\n    }\\n    \\n    \\n    bool can_cross(vector<vector<int>> &grid, int start){\\n        int r = grid.size();\\n        int c = grid[0].size();\\n        vector<vector<int>> mat(grid.size(), vector<int>(grid[0].size(), 0));\\n        for(int i=0; i<mat.size(); i++){\\n            for(int j=0; j<mat[i].size(); j++){\\n                if(i==0 && j==0){\\n                    mat[i][j] = start + grid[0][0];\\n                }else{\\n                    int a = INT_MIN;\\n                    int b = INT_MIN;\\n                    if(i>0 && mat[i-1][j]>0){\\n                        a = mat[i-1][j] + grid[i][j];\\n                    }\\n                    if(j>0 && mat[i][j-1]>0){\\n                        b = mat[i][j-1] + grid[i][j];\\n                    }\\n                    mat[i][j] = max(a, b);\\n                }\\n            }\\n        }\\n        return mat[r-1][c-1]>0;\\n    }\\n    \\n};\\n```\n```O(r*c*log(INT_MAX))```\n```O(r*c)```",
                "codeTag": "Java"
            },
            {
                "id": 230589,
                "title": "binary-search-top-left-to-bottom-right-dp-beats-100-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        int l = 1, r = findMax(dungeon);\\n        while (l < r) {\\n            int m = l+(r-l)/2;\\n            if (canWin(dungeon, m)) {\\n                r = m;\\n            } else {\\n                l = m+1;\\n            }\\n        }\\n        return l;\\n    }\\n    \\nprivate:\\n    bool canWin(vector<vector<int>>& dungeon, int init) {\\n        const int m = dungeon.size(), n = dungeon[0].size();\\n        vector<vector<int>> dp(m, vector<int>(n, 0));\\n        \\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                if (i == 0 && j == 0) {\\n                    dp[i][j] = init+dungeon[i][j];\\n                } else {\\n                    int prev_max = -1;\\n                    if (i > 0) {\\n                        prev_max = dp[i-1][j];\\n                    }\\n                    if (j > 0) {\\n                        prev_max = max(prev_max, dp[i][j-1]);\\n                    }\\n                    if (prev_max <= 0) {\\n                        dp[i][j] = -1;\\n                    } else {\\n                        dp[i][j] = dungeon[i][j]+prev_max;\\n                    }\\n                }\\n            }\\n        }\\n        return dp[m-1][n-1] > 0;\\n    }\\n    \\n    // Go all the way down, and then right, to find an upperbound of neccessary initial hp.\\n    int findMax(const vector<vector<int>>& dungeon) {\\n        const int m = dungeon.size(), n = dungeon[0].size();\\n        int r = 0, bottom = 0;\\n        for (int i = 0; i < m; ++i) {\\n            r += dungeon[i][0];\\n            bottom = min(bottom, r);\\n        }\\n        for (int j = 1; j < n; ++j) {\\n            r += dungeon[m-1][j];\\n            bottom = min(bottom, r);\\n        }\\n        return bottom > 0 ? 1 : -bottom+1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        int l = 1, r = findMax(dungeon);\\n        while (l < r) {\\n            int m = l+(r-l)/2;\\n            if (canWin(dungeon, m)) {\\n                r = m;\\n            } else {\\n                l = m+1;\\n            }\\n        }\\n        return l;\\n    }\\n    \\nprivate:\\n    bool canWin(vector<vector<int>>& dungeon, int init) {\\n        const int m = dungeon.size(), n = dungeon[0].size();\\n        vector<vector<int>> dp(m, vector<int>(n, 0));\\n        \\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                if (i == 0 && j == 0) {\\n                    dp[i][j] = init+dungeon[i][j];\\n                } else {\\n                    int prev_max = -1;\\n                    if (i > 0) {\\n                        prev_max = dp[i-1][j];\\n                    }\\n                    if (j > 0) {\\n                        prev_max = max(prev_max, dp[i][j-1]);\\n                    }\\n                    if (prev_max <= 0) {\\n                        dp[i][j] = -1;\\n                    } else {\\n                        dp[i][j] = dungeon[i][j]+prev_max;\\n                    }\\n                }\\n            }\\n        }\\n        return dp[m-1][n-1] > 0;\\n    }\\n    \\n    // Go all the way down, and then right, to find an upperbound of neccessary initial hp.\\n    int findMax(const vector<vector<int>>& dungeon) {\\n        const int m = dungeon.size(), n = dungeon[0].size();\\n        int r = 0, bottom = 0;\\n        for (int i = 0; i < m; ++i) {\\n            r += dungeon[i][0];\\n            bottom = min(bottom, r);\\n        }\\n        for (int j = 1; j < n; ++j) {\\n            r += dungeon[m-1][j];\\n            bottom = min(bottom, r);\\n        }\\n        return bottom > 0 ? 1 : -bottom+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 184638,
                "title": "swift-awesome-cool-solution-backwards-walk-dp-dynamic-winz-kool",
                "content": "```\\nclass Solution {\\n    func calculateMinimumHP(_ dungeon: [[Int]]) -> Int {\\n        \\n        var h = dungeon.count\\n        if h <= 0 { return 0 }\\n        \\n        var w = dungeon[0].count\\n        if w <= 0 { return 0 }\\n        \\n        var health:[[Int]] = [[Int]](repeating: [Int](repeating: 0, count: w), count: h)\\n        \\n        health[h-1][w-1] = max(1, 1-dungeon[h-1][w-1])\\n        \\n        var i: Int = w-2\\n        while i >= 0 {\\n            health[h-1][i] = max(1, health[h-1][i+1] - dungeon[h-1][i])\\n            i -= 1\\n        }\\n        \\n        var n: Int = h-2\\n        while n >= 0 {\\n            health[n][w-1] = max(1, health[n+1][w-1] - dungeon[n][w-1])\\n            n -= 1\\n        }\\n        \\n        n = h-2\\n        while n >= 0 {\\n            i = w-2\\n            while i >= 0 {\\n                var c1 = max(1, health[n+1][i] - dungeon[n][i])\\n                var c2 = max(1, health[n][i+1] - dungeon[n][i])\\n                health[n][i] = min(c1, c2)\\n                i -= 1\\n            }\\n            n -= 1\\n        }\\n        \\n        return health[0][0]\\n    }\\n}\\n```\\n\\nNo rules, just right. Outback Steakhouse.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func calculateMinimumHP(_ dungeon: [[Int]]) -> Int {\\n        \\n        var h = dungeon.count\\n        if h <= 0 { return 0 }\\n        \\n        var w = dungeon[0].count\\n        if w <= 0 { return 0 }\\n        \\n        var health:[[Int]] = [[Int]](repeating: [Int](repeating: 0, count: w), count: h)\\n        \\n        health[h-1][w-1] = max(1, 1-dungeon[h-1][w-1])\\n        \\n        var i: Int = w-2\\n        while i >= 0 {\\n            health[h-1][i] = max(1, health[h-1][i+1] - dungeon[h-1][i])\\n            i -= 1\\n        }\\n        \\n        var n: Int = h-2\\n        while n >= 0 {\\n            health[n][w-1] = max(1, health[n+1][w-1] - dungeon[n][w-1])\\n            n -= 1\\n        }\\n        \\n        n = h-2\\n        while n >= 0 {\\n            i = w-2\\n            while i >= 0 {\\n                var c1 = max(1, health[n+1][i] - dungeon[n][i])\\n                var c2 = max(1, health[n][i+1] - dungeon[n][i])\\n                health[n][i] = min(c1, c2)\\n                i -= 1\\n            }\\n            n -= 1\\n        }\\n        \\n        return health[0][0]\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 144264,
                "title": "java-dp-solution-o-n-space-and-from-top-left-to-bottom-right-traversal",
                "content": "```\\nclass Solution {\\n    public int calculateMinimumHP(int[][] dungeon) {\\n        int [] health = new int[dungeon[0].length];\\n        int [] cost = new int[health.length]; \\n        for(int i = 0; i < dungeon.length; ++i){\\n            int [] healthTemp = new int[dungeon[0].length]; \\n            int [] costTemp = new int[health.length]; \\n            for(int j = 0; j < dungeon[i].length; ++j){\\n                if(i == 0 && j == 0){\\n                    healthTemp[j] = dungeon[i][j];\\n                    costTemp[j] = Math.min(0, dungeon[i][j]);\\n                }else if( j == 0){\\n                    healthTemp[j] = health[j] + dungeon[i][j];\\n                    costTemp[j] = Math.min(healthTemp[j], cost[j]);\\n                }else if(i == 0){\\n                    healthTemp[j] = healthTemp[j-1] + dungeon[i][j];\\n                    costTemp[j] = Math.min(costTemp[j-1], healthTemp[j]);\\n                }else{\\n                    healthTemp[j] = Math.max(healthTemp[j-1], health[j]) + dungeon[i][j];\\n                    costTemp[j] = Math.max(Math.min(costTemp[j-1], Math.min(0, (healthTemp[j-1] == 0 ? costTemp[j-1] : healthTemp[j-1]) + dungeon[i][j])),\\n                                           Math.min(cost[j], Math.min(0, (health[j] == 0 ? cost[j]: health[j])  + dungeon[i][j])));\\n                }   \\n            }\\n            \\n            cost = costTemp; health = healthTemp; \\n        }\\n        return Math.abs(cost[cost.length-1]) + 1;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int calculateMinimumHP(int[][] dungeon) {\\n        int [] health = new int[dungeon[0].length];\\n        int [] cost = new int[health.length]; \\n        for(int i = 0; i < dungeon.length; ++i){\\n            int [] healthTemp = new int[dungeon[0].length]; \\n            int [] costTemp = new int[health.length]; \\n            for(int j = 0; j < dungeon[i].length; ++j){\\n                if(i == 0 && j == 0){\\n                    healthTemp[j] = dungeon[i][j];\\n                    costTemp[j] = Math.min(0, dungeon[i][j]);\\n                }else if( j == 0){\\n                    healthTemp[j] = health[j] + dungeon[i][j];\\n                    costTemp[j] = Math.min(healthTemp[j], cost[j]);\\n                }else if(i == 0){\\n                    healthTemp[j] = healthTemp[j-1] + dungeon[i][j];\\n                    costTemp[j] = Math.min(costTemp[j-1], healthTemp[j]);\\n                }else{\\n                    healthTemp[j] = Math.max(healthTemp[j-1], health[j]) + dungeon[i][j];\\n                    costTemp[j] = Math.max(Math.min(costTemp[j-1], Math.min(0, (healthTemp[j-1] == 0 ? costTemp[j-1] : healthTemp[j-1]) + dungeon[i][j])),\\n                                           Math.min(cost[j], Math.min(0, (health[j] == 0 ? cost[j]: health[j])  + dungeon[i][j])));\\n                }   \\n            }\\n            \\n            cost = costTemp; health = healthTemp; \\n        }\\n        return Math.abs(cost[cost.length-1]) + 1;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 136983,
                "title": "python-dp-soultion",
                "content": "After observing the problem, we can find that there is one requirement.  **knight\\'s health must >= 1**. since the goal is to find the minimum health. A intuitive thought is to traverse from destination, from each cell compute the minimum health required to enter such cell. then back propagate to top will get us muimum health required\\n ```\\ndef calculateMinimumHP(self, dungeon):\\n        \"\"\"\\n        :type dungeon: List[List[int]]\\n        :rtype: int\\n        \"\"\\'\\n        \\n        R, C = len(dungeon), len(dungeon[0])\\n        dp = [[0] * C for _ in range(R)]\\n        dp[-1][-1] = max(1 - dungeon[-1][-1], 1)\\n        for i in range(R - 2, -1, -1):\\n            dp[i][C - 1] = max(dp[i + 1][C - 1] - dungeon[i][C - 1], 1)\\n        for i in range(C - 2, -1, -1):\\n            dp[R - 1][i] = max(dp[R - 1][i + 1] - dungeon[R - 1][i], 1)\\n        \\n        for i in range(R - 2, -1, -1):\\n            for j in range(C - 2, -1, -1):\\n                # if adding health is much larger than health required, set it to 1\\n                dp[i][j] = max(min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j], 1)\\n        \\n        return dp[0][0]\\n                \\n        \\n       \\n```",
                "solutionTags": [],
                "code": "```\\ndef calculateMinimumHP(self, dungeon):\\n        \"\"\"\\n        :type dungeon: List[List[int]]\\n        :rtype: int\\n        \"\"\\'\\n        \\n        R, C = len(dungeon), len(dungeon[0])\\n        dp = [[0] * C for _ in range(R)]\\n        dp[-1][-1] = max(1 - dungeon[-1][-1], 1)\\n        for i in range(R - 2, -1, -1):\\n            dp[i][C - 1] = max(dp[i + 1][C - 1] - dungeon[i][C - 1], 1)\\n        for i in range(C - 2, -1, -1):\\n            dp[R - 1][i] = max(dp[R - 1][i + 1] - dungeon[R - 1][i], 1)\\n        \\n        for i in range(R - 2, -1, -1):\\n            for j in range(C - 2, -1, -1):\\n                # if adding health is much larger than health required, set it to 1\\n                dp[i][j] = max(min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j], 1)\\n        \\n        return dp[0][0]\\n                \\n        \\n       \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 52811,
                "title": "c-solution-with-explanation",
                "content": "```\\npublic class Solution {\\n    public int CalculateMinimumHP(int[,] dungeon) {\\n        int rows = dungeon.GetLength(0);\\n        int cols = dungeon.GetLength(1);\\n        \\n        // save partial solutions in a matrix\\n        int[,] solutions = new int[rows, cols];\\n        \\n        // start with last room in the dungeon and ask the following question:\\n        // what would the minimum health of the Knight need to be so he can survive the last room?\\n        // Answer: if the room has a devil (negative value) than his health needs to be at least 1 above\\n        // the devil's strength. Otherwise (room is empty or has a magic orb) his health only needs to be equal to 1\\n        // Therefore, we can set his health to the max value between 1 and 1 - dungeon[rows - 1, cols - 1]\\n        int bottomRow = rows - 1;\\n        int rightCol = cols - 1;\\n        solutions[bottomRow, rightCol] = Math.Max(1, 1 - dungeon[bottomRow, rightCol]);\\n        \\n        // now that we know the Knight's minimal health required in the last room, we can compute his minimal health\\n        // in other rooms. For each room he enters, he needs to be strong enough to survie that room AND meet the minimum\\n        // health required in the next room immediately after that. Since there are two rooms immediately after (except\\n        // for when his is at the borders), we compute both of those health values and keep the smaller one (because we want the \\n        // minumum health required)\\n        \\n        // first, we take care of the borders (bottom row and right column)\\n        \\n        // right column: traverse the rooms from the bottom to the top and make sure the Knight is strong enough to survive the room\\n        // AND arrive at the next room (on its bottom side) with a health greater than or equal to solutions[i + 1, rightCol]\\n        for (int i = bottomRow - 1; i >= 0; i--) {\\n            solutions[i, rightCol] = Math.Max(1, solutions[i + 1, rightCol] - dungeon[i, rightCol]);\\n        }\\n        \\n        // bottom row: traverse the rooms from right to left and make sure the Knight is strong enough to survive the room AND arrive\\n        // at the next room (on its right side) with a health greater than or equal to solutions[bottomRow, j + 1]\\n        for (int j = rightCol - 1; j >= 0; j--) {\\n            solutions[bottomRow, j] = Math.Max(1, solutions[bottomRow, j + 1] - dungeon[bottomRow, j]);\\n        }\\n        \\n        // now, take care of the inner dungeon. Each room has now two neighboring rooms (to the right and down), so we need\\n        // to compute the minimum health with respect to each of them. We then take the minimum value.\\n        for (int i = bottomRow - 1; i >= 0; i--) {\\n            for (int j = rightCol - 1; j >= 0; j--) {\\n                \\n                //compute min health to survive this room AND room to the right\\n                int minRight = Math.Max(1, solutions[i, j + 1] - dungeon[i, j]);\\n                \\n                //compute min health to survie this room AND room down to the bottom\\n                int minDown = Math.Max(1, solutions[i + 1, j] - dungeon[i, j]);\\n                \\n                //take min of the two\\n                solutions[i, j] = Math.Min(minRight, minDown);\\n            }\\n        }\\n        \\n        // our solution is the minimal health the Knight needs to have in the very first room (0,0)\\n        return solutions[0, 0];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int CalculateMinimumHP(int[,] dungeon) {\\n        int rows = dungeon.GetLength(0);\\n        int cols = dungeon.GetLength(1);\\n        \\n        // save partial solutions in a matrix\\n        int[,] solutions = new int[rows, cols];\\n        \\n        // start with last room in the dungeon and ask the following question:\\n        // what would the minimum health of the Knight need to be so he can survive the last room?\\n        // Answer: if the room has a devil (negative value) than his health needs to be at least 1 above\\n        // the devil's strength. Otherwise (room is empty or has a magic orb) his health only needs to be equal to 1\\n        // Therefore, we can set his health to the max value between 1 and 1 - dungeon[rows - 1, cols - 1]\\n        int bottomRow = rows - 1;\\n        int rightCol = cols - 1;\\n        solutions[bottomRow, rightCol] = Math.Max(1, 1 - dungeon[bottomRow, rightCol]);\\n        \\n        // now that we know the Knight's minimal health required in the last room, we can compute his minimal health\\n        // in other rooms. For each room he enters, he needs to be strong enough to survie that room AND meet the minimum\\n        // health required in the next room immediately after that. Since there are two rooms immediately after (except\\n        // for when his is at the borders), we compute both of those health values and keep the smaller one (because we want the \\n        // minumum health required)\\n        \\n        // first, we take care of the borders (bottom row and right column)\\n        \\n        // right column: traverse the rooms from the bottom to the top and make sure the Knight is strong enough to survive the room\\n        // AND arrive at the next room (on its bottom side) with a health greater than or equal to solutions[i + 1, rightCol]\\n        for (int i = bottomRow - 1; i >= 0; i--) {\\n            solutions[i, rightCol] = Math.Max(1, solutions[i + 1, rightCol] - dungeon[i, rightCol]);\\n        }\\n        \\n        // bottom row: traverse the rooms from right to left and make sure the Knight is strong enough to survive the room AND arrive\\n        // at the next room (on its right side) with a health greater than or equal to solutions[bottomRow, j + 1]\\n        for (int j = rightCol - 1; j >= 0; j--) {\\n            solutions[bottomRow, j] = Math.Max(1, solutions[bottomRow, j + 1] - dungeon[bottomRow, j]);\\n        }\\n        \\n        // now, take care of the inner dungeon. Each room has now two neighboring rooms (to the right and down), so we need\\n        // to compute the minimum health with respect to each of them. We then take the minimum value.\\n        for (int i = bottomRow - 1; i >= 0; i--) {\\n            for (int j = rightCol - 1; j >= 0; j--) {\\n                \\n                //compute min health to survive this room AND room to the right\\n                int minRight = Math.Max(1, solutions[i, j + 1] - dungeon[i, j]);\\n                \\n                //compute min health to survie this room AND room down to the bottom\\n                int minDown = Math.Max(1, solutions[i + 1, j] - dungeon[i, j]);\\n                \\n                //take min of the two\\n                solutions[i, j] = Math.Min(minRight, minDown);\\n            }\\n        }\\n        \\n        // our solution is the minimal health the Knight needs to have in the very first room (0,0)\\n        return solutions[0, 0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 52817,
                "title": "knight-to-princess-and-not-reverse-direction-solution-using-binary-search",
                "content": "Since most solutions solve it in reverse (which is actually pretty neat), what I cam up with is a front to back (and not back to front) solution that uses binary search to find the smallest HP required to rescue. Running time is O(n^2 log(D)), where D is the maximum value of an integer.\\n\\n```\\nclass Solution {\\n    bool canSolve(vector<vector<int>> &dungeon, int guess) {\\n        dungeon[0][0] += guess;\\n        if (dungeon[0][0] <= 0) return false;\\n        for (int i = 1; i < dungeon.size(); ++i) {\\n            dungeon[i][0] += dungeon[i-1][0];\\n            if (dungeon[i][0] <= 0) {\\n                dungeon[i][0] = INT_MIN / 2;\\n            }\\n        }\\n        for (int i = 1; i < dungeon[0].size(); ++i) {\\n            dungeon[0][i] += dungeon[0][i-1];\\n            if (dungeon[0][i] <= 0) {\\n                dungeon[0][i] = INT_MIN / 2;\\n            }\\n        }\\n        for (int i = 1; i < dungeon.size(); ++i) {\\n            for (int j = 1; j < dungeon[0].size(); ++j) {\\n                dungeon[i][j] += std::max(dungeon[i-1][j], dungeon[i][j-1]);\\n                if (dungeon[i][j] <= 0) {\\n                    dungeon[i][j] = INT_MIN / 2;\\n                }\\n            }\\n        }\\n        return dungeon.back().back() != INT_MIN / 2;\\n    }\\npublic:\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        if (dungeon.empty() || dungeon[0].empty()) return 1;\\n        int lo = 1, hi = INT_MAX;\\n        int guess = hi;\\n        int mid = lo + (hi - lo) / 2;\\n        while (lo != hi) {\\n            auto dcopy = dungeon;\\n            bool cs = canSolve(dcopy, mid);\\n            if (cs) {\\n                guess = mid;\\n                hi = mid;\\n            } else {\\n                lo = mid + 1;\\n            }\\n            mid = lo + (hi - lo) / 2;\\n        }\\n        return guess;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    bool canSolve(vector<vector<int>> &dungeon, int guess) {\\n        dungeon[0][0] += guess;\\n        if (dungeon[0][0] <= 0) return false;\\n        for (int i = 1; i < dungeon.size(); ++i) {\\n            dungeon[i][0] += dungeon[i-1][0];\\n            if (dungeon[i][0] <= 0) {\\n                dungeon[i][0] = INT_MIN / 2;\\n            }\\n        }\\n        for (int i = 1; i < dungeon[0].size(); ++i) {\\n            dungeon[0][i] += dungeon[0][i-1];\\n            if (dungeon[0][i] <= 0) {\\n                dungeon[0][i] = INT_MIN / 2;\\n            }\\n        }\\n        for (int i = 1; i < dungeon.size(); ++i) {\\n            for (int j = 1; j < dungeon[0].size(); ++j) {\\n                dungeon[i][j] += std::max(dungeon[i-1][j], dungeon[i][j-1]);\\n                if (dungeon[i][j] <= 0) {\\n                    dungeon[i][j] = INT_MIN / 2;\\n                }\\n            }\\n        }\\n        return dungeon.back().back() != INT_MIN / 2;\\n    }\\npublic:\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        if (dungeon.empty() || dungeon[0].empty()) return 1;\\n        int lo = 1, hi = INT_MAX;\\n        int guess = hi;\\n        int mid = lo + (hi - lo) / 2;\\n        while (lo != hi) {\\n            auto dcopy = dungeon;\\n            bool cs = canSolve(dcopy, mid);\\n            if (cs) {\\n                guess = mid;\\n                hi = mid;\\n            } else {\\n                lo = mid + 1;\\n            }\\n            mid = lo + (hi - lo) / 2;\\n        }\\n        return guess;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564963,
                "content": [
                    {
                        "username": "hhzsls",
                        "content": "Why we fill the table from the bottom right corner to left top?"
                    },
                    {
                        "username": "Msey",
                        "content": "These crafty Australians...!"
                    },
                    {
                        "username": "kmathur68",
                        "content": "If you start from top left to bottom right, then at every point you need to make a decision whether you are going right or down. \\nIn order to do that you need to know what is the minimum health required if you start from i+1,j and i,j+1 positions. \\n\\nYou can actually implement in this way, but they will have to be recursive calls. \\nSee more on here -> https://leetcode.com/problems/dungeon-game/solutions/745340/post-dedicated-to-beginners-of-dp-or-have-no-clue-how-to-start/"
                    },
                    {
                        "username": "clue",
                        "content": "As we all know the typical solution is via DP, which is also the given solution. I can't think of how it can relate to binary search, any ideas?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You could set the lower bound to 0 and the upper bound to 20,000 and than do binary search to see if for a certain amount of health you can find a path. It was what I first thought of, but DP is a much better approach here I think. \\n\\n1970. Last Day Where You Can Still Cross \\nis a somewhat similar problem (also traversing a matrix) where Binary search is useful: https://leetcode.com/problems/last-day-where-you-can-still-cross/"
                    },
                    {
                        "username": "packle",
                        "content": "[@shivasaineelam](/shivasaineelam) \\n\\nneat problem - reminds me of minimum path sum (dp), trapping rain water (variant Dijkstra), and safest path in grid (binary search). the max of the search could probably be tightened with some graph algorithm but above my pay grade. I set it to the sum of all negative values and similarly TLEd"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "we can think of a search space \na particular health and every health greater than that can save the princess \nwe need the minimum one\nbut mine got tle at 42 test case:)"
                    },
                    {
                        "username": "mmontgomery",
                        "content": "Submitting my answer, I\\'m told my code gets the wrong answer for a very simple input `[[0,0]]`, but when I run a custom testcase with this same input, I get the correct answer. What gives? \\n\\n![image](https://assets.leetcode.com/users/mmontgomery/image_1538528784.png)\\n\\nThis isn\\'t the first time this has happened to me on Leetcode problems. "
                    },
                    {
                        "username": "Sivarama_Krishnan_Venktrayan",
                        "content": "I used global static variable without mentioning the scope of the variable.\n\n```\nstatic int minHP = Integer.MAX_VALUE;\n```\n\nAfter i changed it to, \n\n```\npublic int minHP = Integer.MAX_VALUE;\n```\n\n#### Detailed explaination:\n<a>https://support.leetcode.com/hc/en-us/articles/360011834174-I-encountered-Wrong-Answer-Runtime-Error-for-a-specific-test-case-When-I-test-my-code-using-this-test-case-it-produced-the-correct-output-Why-</a>"
                    },
                    {
                        "username": "Bloody_Marry",
                        "content": "you may be using global variables."
                    },
                    {
                        "username": "david500",
                        "content": "I started this question trying to start from the top left, couldn\\'t sovle it and realized it\\'s best to solve it from the bottom right corner instead. Now I\\'m wondering if it\\'s even possible to do it from the top left, if anyone knows, please share"
                    },
                    {
                        "username": "aaryanman05",
                        "content": "[@bizco8](/bizco8)  Too confusing mate. I started from bottom right, and after some brainstorming it went smooth\\n\\n"
                    },
                    {
                        "username": "bizco8",
                        "content": "yes we can do it starting from the top left:\\n \\nclass Solution {\\n  int N;\\n  int M;\\n  Integer[][] cache;\\n  public int calculateMinimumHP(int[][] dungeon) {\\n    N = dungeon.length;\\n    M = dungeon[0].length;\\n    cache = new Integer[N][M];\\n    int res = Math.abs(helper(dungeon, 0, 0));\\n    return  res + 1;\\n  }\\n\\n  public int helper(int[][] dungeon, int i, int j){\\n    if(i >= N || i < 0 || j >= M || j < 0) return Integer.MIN_VALUE;\\n    if(cache[i][j] != null) return cache[i][j];\\n    if(i == N - 1 && j == M - 1){\\n      cache[i][j] = Math.min(0, dungeon[i][j]);\\n      return cache[i][j];\\n    }\\n    int minRight = helper(dungeon, i, j + 1);\\n    int minDown =  helper(dungeon, i + 1, j);\\n    if(minRight != Integer.MIN_VALUE) minRight = Math.min(0, dungeon[i][j] +  minRight);\\n    if(minDown != Integer.MIN_VALUE) minDown = Math.min(0, dungeon[i][j] +  minDown);\\n    cache[i][j] = Math.max(minDown, minRight);\\n    return cache[i][j];\\n  }\\n}"
                    },
                    {
                        "username": "kimeshgupta",
                        "content": "Can we solve this by start from dungeon[0][0] instead of dungeon[row-1][column-1] and get final result at dungeon[row-1][column-1] using same or another dp approach??? Please help."
                    },
                    {
                        "username": "thevirtuoso1973",
                        "content": "As usual I like to provide hints,  albeit this one is slightly less of a hint and more of a reassurance.\\n\\nThis is a pure DP question. The difficulty lies in defining your subproblems/recursion. Some special trick is _not_ necessary to solve the question.\\n\\n### Further Hint:\\nI can\\'t say much more without entering spoiler territory, but just think about how you can figure out the minimum health at (i,j) assuming you have the (i+1,j) and (i,j+1) solutions."
                    },
                    {
                        "username": "bingcoder",
                        "content": "in this case [[100]] , why the correct output is 1? I think it should be 0."
                    },
                    {
                        "username": "Akashdeep_Gupta",
                        "content": "[@abacusrehan](/abacusrehan) yes at any point health should be minimum 1 even before starting."
                    },
                    {
                        "username": "abacusrehan",
                        "content": "too late, but still\\n> The knight has an initial health point represented by a positive integer. If at any point his health point drops to 0 or below, he dies immediately.\\n\\n"
                    },
                    {
                        "username": "god_like",
                        "content": "The description didn\\'t mention if the health could boost exceed the knight\\'s initial health, which would make a whole lot difference if that\\'s considered.\\n\\nImaging this: \\n[[0, 100, -98]] \\n\\nthe answer could be either 1 or 99."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I was also confused, because a typical video game logic would put a cap on the max health you can have.\nHowever, if you just read the solution, you do realize that nothing is mentionned relative to that, that the wording never implies a maximum health cap, and that you would only be making things up by implementing a limit for health.\nBasically, the problem description is correct, we just confused ourselves by making nerdy assumptions. Just gotta learn to read more carefully!"
                    },
                    {
                        "username": "aboulmagd",
                        "content": "So why does bottom up DP work when started from the bottom right cell, and not from the top left cell?\\n\\nAny intuition/visuals would really help.\\nI was only able to solve this problem using the former approach, but why is the DP not symmetrical as with other problems (i.e maximum subarray)?"
                    },
                    {
                        "username": "hebele",
                        "content": "Start from bottom right (not from top left)"
                    }
                ]
            },
            {
                "id": 1565596,
                "content": [
                    {
                        "username": "hhzsls",
                        "content": "Why we fill the table from the bottom right corner to left top?"
                    },
                    {
                        "username": "Msey",
                        "content": "These crafty Australians...!"
                    },
                    {
                        "username": "kmathur68",
                        "content": "If you start from top left to bottom right, then at every point you need to make a decision whether you are going right or down. \\nIn order to do that you need to know what is the minimum health required if you start from i+1,j and i,j+1 positions. \\n\\nYou can actually implement in this way, but they will have to be recursive calls. \\nSee more on here -> https://leetcode.com/problems/dungeon-game/solutions/745340/post-dedicated-to-beginners-of-dp-or-have-no-clue-how-to-start/"
                    },
                    {
                        "username": "clue",
                        "content": "As we all know the typical solution is via DP, which is also the given solution. I can't think of how it can relate to binary search, any ideas?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You could set the lower bound to 0 and the upper bound to 20,000 and than do binary search to see if for a certain amount of health you can find a path. It was what I first thought of, but DP is a much better approach here I think. \\n\\n1970. Last Day Where You Can Still Cross \\nis a somewhat similar problem (also traversing a matrix) where Binary search is useful: https://leetcode.com/problems/last-day-where-you-can-still-cross/"
                    },
                    {
                        "username": "packle",
                        "content": "[@shivasaineelam](/shivasaineelam) \\n\\nneat problem - reminds me of minimum path sum (dp), trapping rain water (variant Dijkstra), and safest path in grid (binary search). the max of the search could probably be tightened with some graph algorithm but above my pay grade. I set it to the sum of all negative values and similarly TLEd"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "we can think of a search space \na particular health and every health greater than that can save the princess \nwe need the minimum one\nbut mine got tle at 42 test case:)"
                    },
                    {
                        "username": "mmontgomery",
                        "content": "Submitting my answer, I\\'m told my code gets the wrong answer for a very simple input `[[0,0]]`, but when I run a custom testcase with this same input, I get the correct answer. What gives? \\n\\n![image](https://assets.leetcode.com/users/mmontgomery/image_1538528784.png)\\n\\nThis isn\\'t the first time this has happened to me on Leetcode problems. "
                    },
                    {
                        "username": "Sivarama_Krishnan_Venktrayan",
                        "content": "I used global static variable without mentioning the scope of the variable.\n\n```\nstatic int minHP = Integer.MAX_VALUE;\n```\n\nAfter i changed it to, \n\n```\npublic int minHP = Integer.MAX_VALUE;\n```\n\n#### Detailed explaination:\n<a>https://support.leetcode.com/hc/en-us/articles/360011834174-I-encountered-Wrong-Answer-Runtime-Error-for-a-specific-test-case-When-I-test-my-code-using-this-test-case-it-produced-the-correct-output-Why-</a>"
                    },
                    {
                        "username": "Bloody_Marry",
                        "content": "you may be using global variables."
                    },
                    {
                        "username": "david500",
                        "content": "I started this question trying to start from the top left, couldn\\'t sovle it and realized it\\'s best to solve it from the bottom right corner instead. Now I\\'m wondering if it\\'s even possible to do it from the top left, if anyone knows, please share"
                    },
                    {
                        "username": "aaryanman05",
                        "content": "[@bizco8](/bizco8)  Too confusing mate. I started from bottom right, and after some brainstorming it went smooth\\n\\n"
                    },
                    {
                        "username": "bizco8",
                        "content": "yes we can do it starting from the top left:\\n \\nclass Solution {\\n  int N;\\n  int M;\\n  Integer[][] cache;\\n  public int calculateMinimumHP(int[][] dungeon) {\\n    N = dungeon.length;\\n    M = dungeon[0].length;\\n    cache = new Integer[N][M];\\n    int res = Math.abs(helper(dungeon, 0, 0));\\n    return  res + 1;\\n  }\\n\\n  public int helper(int[][] dungeon, int i, int j){\\n    if(i >= N || i < 0 || j >= M || j < 0) return Integer.MIN_VALUE;\\n    if(cache[i][j] != null) return cache[i][j];\\n    if(i == N - 1 && j == M - 1){\\n      cache[i][j] = Math.min(0, dungeon[i][j]);\\n      return cache[i][j];\\n    }\\n    int minRight = helper(dungeon, i, j + 1);\\n    int minDown =  helper(dungeon, i + 1, j);\\n    if(minRight != Integer.MIN_VALUE) minRight = Math.min(0, dungeon[i][j] +  minRight);\\n    if(minDown != Integer.MIN_VALUE) minDown = Math.min(0, dungeon[i][j] +  minDown);\\n    cache[i][j] = Math.max(minDown, minRight);\\n    return cache[i][j];\\n  }\\n}"
                    },
                    {
                        "username": "kimeshgupta",
                        "content": "Can we solve this by start from dungeon[0][0] instead of dungeon[row-1][column-1] and get final result at dungeon[row-1][column-1] using same or another dp approach??? Please help."
                    },
                    {
                        "username": "thevirtuoso1973",
                        "content": "As usual I like to provide hints,  albeit this one is slightly less of a hint and more of a reassurance.\\n\\nThis is a pure DP question. The difficulty lies in defining your subproblems/recursion. Some special trick is _not_ necessary to solve the question.\\n\\n### Further Hint:\\nI can\\'t say much more without entering spoiler territory, but just think about how you can figure out the minimum health at (i,j) assuming you have the (i+1,j) and (i,j+1) solutions."
                    },
                    {
                        "username": "bingcoder",
                        "content": "in this case [[100]] , why the correct output is 1? I think it should be 0."
                    },
                    {
                        "username": "Akashdeep_Gupta",
                        "content": "[@abacusrehan](/abacusrehan) yes at any point health should be minimum 1 even before starting."
                    },
                    {
                        "username": "abacusrehan",
                        "content": "too late, but still\\n> The knight has an initial health point represented by a positive integer. If at any point his health point drops to 0 or below, he dies immediately.\\n\\n"
                    },
                    {
                        "username": "god_like",
                        "content": "The description didn\\'t mention if the health could boost exceed the knight\\'s initial health, which would make a whole lot difference if that\\'s considered.\\n\\nImaging this: \\n[[0, 100, -98]] \\n\\nthe answer could be either 1 or 99."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I was also confused, because a typical video game logic would put a cap on the max health you can have.\nHowever, if you just read the solution, you do realize that nothing is mentionned relative to that, that the wording never implies a maximum health cap, and that you would only be making things up by implementing a limit for health.\nBasically, the problem description is correct, we just confused ourselves by making nerdy assumptions. Just gotta learn to read more carefully!"
                    },
                    {
                        "username": "aboulmagd",
                        "content": "So why does bottom up DP work when started from the bottom right cell, and not from the top left cell?\\n\\nAny intuition/visuals would really help.\\nI was only able to solve this problem using the former approach, but why is the DP not symmetrical as with other problems (i.e maximum subarray)?"
                    },
                    {
                        "username": "hebele",
                        "content": "Start from bottom right (not from top left)"
                    }
                ]
            },
            {
                "id": 1566099,
                "content": [
                    {
                        "username": "hhzsls",
                        "content": "Why we fill the table from the bottom right corner to left top?"
                    },
                    {
                        "username": "Msey",
                        "content": "These crafty Australians...!"
                    },
                    {
                        "username": "kmathur68",
                        "content": "If you start from top left to bottom right, then at every point you need to make a decision whether you are going right or down. \\nIn order to do that you need to know what is the minimum health required if you start from i+1,j and i,j+1 positions. \\n\\nYou can actually implement in this way, but they will have to be recursive calls. \\nSee more on here -> https://leetcode.com/problems/dungeon-game/solutions/745340/post-dedicated-to-beginners-of-dp-or-have-no-clue-how-to-start/"
                    },
                    {
                        "username": "clue",
                        "content": "As we all know the typical solution is via DP, which is also the given solution. I can't think of how it can relate to binary search, any ideas?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You could set the lower bound to 0 and the upper bound to 20,000 and than do binary search to see if for a certain amount of health you can find a path. It was what I first thought of, but DP is a much better approach here I think. \\n\\n1970. Last Day Where You Can Still Cross \\nis a somewhat similar problem (also traversing a matrix) where Binary search is useful: https://leetcode.com/problems/last-day-where-you-can-still-cross/"
                    },
                    {
                        "username": "packle",
                        "content": "[@shivasaineelam](/shivasaineelam) \\n\\nneat problem - reminds me of minimum path sum (dp), trapping rain water (variant Dijkstra), and safest path in grid (binary search). the max of the search could probably be tightened with some graph algorithm but above my pay grade. I set it to the sum of all negative values and similarly TLEd"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "we can think of a search space \na particular health and every health greater than that can save the princess \nwe need the minimum one\nbut mine got tle at 42 test case:)"
                    },
                    {
                        "username": "mmontgomery",
                        "content": "Submitting my answer, I\\'m told my code gets the wrong answer for a very simple input `[[0,0]]`, but when I run a custom testcase with this same input, I get the correct answer. What gives? \\n\\n![image](https://assets.leetcode.com/users/mmontgomery/image_1538528784.png)\\n\\nThis isn\\'t the first time this has happened to me on Leetcode problems. "
                    },
                    {
                        "username": "Sivarama_Krishnan_Venktrayan",
                        "content": "I used global static variable without mentioning the scope of the variable.\n\n```\nstatic int minHP = Integer.MAX_VALUE;\n```\n\nAfter i changed it to, \n\n```\npublic int minHP = Integer.MAX_VALUE;\n```\n\n#### Detailed explaination:\n<a>https://support.leetcode.com/hc/en-us/articles/360011834174-I-encountered-Wrong-Answer-Runtime-Error-for-a-specific-test-case-When-I-test-my-code-using-this-test-case-it-produced-the-correct-output-Why-</a>"
                    },
                    {
                        "username": "Bloody_Marry",
                        "content": "you may be using global variables."
                    },
                    {
                        "username": "david500",
                        "content": "I started this question trying to start from the top left, couldn\\'t sovle it and realized it\\'s best to solve it from the bottom right corner instead. Now I\\'m wondering if it\\'s even possible to do it from the top left, if anyone knows, please share"
                    },
                    {
                        "username": "aaryanman05",
                        "content": "[@bizco8](/bizco8)  Too confusing mate. I started from bottom right, and after some brainstorming it went smooth\\n\\n"
                    },
                    {
                        "username": "bizco8",
                        "content": "yes we can do it starting from the top left:\\n \\nclass Solution {\\n  int N;\\n  int M;\\n  Integer[][] cache;\\n  public int calculateMinimumHP(int[][] dungeon) {\\n    N = dungeon.length;\\n    M = dungeon[0].length;\\n    cache = new Integer[N][M];\\n    int res = Math.abs(helper(dungeon, 0, 0));\\n    return  res + 1;\\n  }\\n\\n  public int helper(int[][] dungeon, int i, int j){\\n    if(i >= N || i < 0 || j >= M || j < 0) return Integer.MIN_VALUE;\\n    if(cache[i][j] != null) return cache[i][j];\\n    if(i == N - 1 && j == M - 1){\\n      cache[i][j] = Math.min(0, dungeon[i][j]);\\n      return cache[i][j];\\n    }\\n    int minRight = helper(dungeon, i, j + 1);\\n    int minDown =  helper(dungeon, i + 1, j);\\n    if(minRight != Integer.MIN_VALUE) minRight = Math.min(0, dungeon[i][j] +  minRight);\\n    if(minDown != Integer.MIN_VALUE) minDown = Math.min(0, dungeon[i][j] +  minDown);\\n    cache[i][j] = Math.max(minDown, minRight);\\n    return cache[i][j];\\n  }\\n}"
                    },
                    {
                        "username": "kimeshgupta",
                        "content": "Can we solve this by start from dungeon[0][0] instead of dungeon[row-1][column-1] and get final result at dungeon[row-1][column-1] using same or another dp approach??? Please help."
                    },
                    {
                        "username": "thevirtuoso1973",
                        "content": "As usual I like to provide hints,  albeit this one is slightly less of a hint and more of a reassurance.\\n\\nThis is a pure DP question. The difficulty lies in defining your subproblems/recursion. Some special trick is _not_ necessary to solve the question.\\n\\n### Further Hint:\\nI can\\'t say much more without entering spoiler territory, but just think about how you can figure out the minimum health at (i,j) assuming you have the (i+1,j) and (i,j+1) solutions."
                    },
                    {
                        "username": "bingcoder",
                        "content": "in this case [[100]] , why the correct output is 1? I think it should be 0."
                    },
                    {
                        "username": "Akashdeep_Gupta",
                        "content": "[@abacusrehan](/abacusrehan) yes at any point health should be minimum 1 even before starting."
                    },
                    {
                        "username": "abacusrehan",
                        "content": "too late, but still\\n> The knight has an initial health point represented by a positive integer. If at any point his health point drops to 0 or below, he dies immediately.\\n\\n"
                    },
                    {
                        "username": "god_like",
                        "content": "The description didn\\'t mention if the health could boost exceed the knight\\'s initial health, which would make a whole lot difference if that\\'s considered.\\n\\nImaging this: \\n[[0, 100, -98]] \\n\\nthe answer could be either 1 or 99."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I was also confused, because a typical video game logic would put a cap on the max health you can have.\nHowever, if you just read the solution, you do realize that nothing is mentionned relative to that, that the wording never implies a maximum health cap, and that you would only be making things up by implementing a limit for health.\nBasically, the problem description is correct, we just confused ourselves by making nerdy assumptions. Just gotta learn to read more carefully!"
                    },
                    {
                        "username": "aboulmagd",
                        "content": "So why does bottom up DP work when started from the bottom right cell, and not from the top left cell?\\n\\nAny intuition/visuals would really help.\\nI was only able to solve this problem using the former approach, but why is the DP not symmetrical as with other problems (i.e maximum subarray)?"
                    },
                    {
                        "username": "hebele",
                        "content": "Start from bottom right (not from top left)"
                    }
                ]
            },
            {
                "id": 1568690,
                "content": [
                    {
                        "username": "hhzsls",
                        "content": "Why we fill the table from the bottom right corner to left top?"
                    },
                    {
                        "username": "Msey",
                        "content": "These crafty Australians...!"
                    },
                    {
                        "username": "kmathur68",
                        "content": "If you start from top left to bottom right, then at every point you need to make a decision whether you are going right or down. \\nIn order to do that you need to know what is the minimum health required if you start from i+1,j and i,j+1 positions. \\n\\nYou can actually implement in this way, but they will have to be recursive calls. \\nSee more on here -> https://leetcode.com/problems/dungeon-game/solutions/745340/post-dedicated-to-beginners-of-dp-or-have-no-clue-how-to-start/"
                    },
                    {
                        "username": "clue",
                        "content": "As we all know the typical solution is via DP, which is also the given solution. I can't think of how it can relate to binary search, any ideas?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You could set the lower bound to 0 and the upper bound to 20,000 and than do binary search to see if for a certain amount of health you can find a path. It was what I first thought of, but DP is a much better approach here I think. \\n\\n1970. Last Day Where You Can Still Cross \\nis a somewhat similar problem (also traversing a matrix) where Binary search is useful: https://leetcode.com/problems/last-day-where-you-can-still-cross/"
                    },
                    {
                        "username": "packle",
                        "content": "[@shivasaineelam](/shivasaineelam) \\n\\nneat problem - reminds me of minimum path sum (dp), trapping rain water (variant Dijkstra), and safest path in grid (binary search). the max of the search could probably be tightened with some graph algorithm but above my pay grade. I set it to the sum of all negative values and similarly TLEd"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "we can think of a search space \na particular health and every health greater than that can save the princess \nwe need the minimum one\nbut mine got tle at 42 test case:)"
                    },
                    {
                        "username": "mmontgomery",
                        "content": "Submitting my answer, I\\'m told my code gets the wrong answer for a very simple input `[[0,0]]`, but when I run a custom testcase with this same input, I get the correct answer. What gives? \\n\\n![image](https://assets.leetcode.com/users/mmontgomery/image_1538528784.png)\\n\\nThis isn\\'t the first time this has happened to me on Leetcode problems. "
                    },
                    {
                        "username": "Sivarama_Krishnan_Venktrayan",
                        "content": "I used global static variable without mentioning the scope of the variable.\n\n```\nstatic int minHP = Integer.MAX_VALUE;\n```\n\nAfter i changed it to, \n\n```\npublic int minHP = Integer.MAX_VALUE;\n```\n\n#### Detailed explaination:\n<a>https://support.leetcode.com/hc/en-us/articles/360011834174-I-encountered-Wrong-Answer-Runtime-Error-for-a-specific-test-case-When-I-test-my-code-using-this-test-case-it-produced-the-correct-output-Why-</a>"
                    },
                    {
                        "username": "Bloody_Marry",
                        "content": "you may be using global variables."
                    },
                    {
                        "username": "david500",
                        "content": "I started this question trying to start from the top left, couldn\\'t sovle it and realized it\\'s best to solve it from the bottom right corner instead. Now I\\'m wondering if it\\'s even possible to do it from the top left, if anyone knows, please share"
                    },
                    {
                        "username": "aaryanman05",
                        "content": "[@bizco8](/bizco8)  Too confusing mate. I started from bottom right, and after some brainstorming it went smooth\\n\\n"
                    },
                    {
                        "username": "bizco8",
                        "content": "yes we can do it starting from the top left:\\n \\nclass Solution {\\n  int N;\\n  int M;\\n  Integer[][] cache;\\n  public int calculateMinimumHP(int[][] dungeon) {\\n    N = dungeon.length;\\n    M = dungeon[0].length;\\n    cache = new Integer[N][M];\\n    int res = Math.abs(helper(dungeon, 0, 0));\\n    return  res + 1;\\n  }\\n\\n  public int helper(int[][] dungeon, int i, int j){\\n    if(i >= N || i < 0 || j >= M || j < 0) return Integer.MIN_VALUE;\\n    if(cache[i][j] != null) return cache[i][j];\\n    if(i == N - 1 && j == M - 1){\\n      cache[i][j] = Math.min(0, dungeon[i][j]);\\n      return cache[i][j];\\n    }\\n    int minRight = helper(dungeon, i, j + 1);\\n    int minDown =  helper(dungeon, i + 1, j);\\n    if(minRight != Integer.MIN_VALUE) minRight = Math.min(0, dungeon[i][j] +  minRight);\\n    if(minDown != Integer.MIN_VALUE) minDown = Math.min(0, dungeon[i][j] +  minDown);\\n    cache[i][j] = Math.max(minDown, minRight);\\n    return cache[i][j];\\n  }\\n}"
                    },
                    {
                        "username": "kimeshgupta",
                        "content": "Can we solve this by start from dungeon[0][0] instead of dungeon[row-1][column-1] and get final result at dungeon[row-1][column-1] using same or another dp approach??? Please help."
                    },
                    {
                        "username": "thevirtuoso1973",
                        "content": "As usual I like to provide hints,  albeit this one is slightly less of a hint and more of a reassurance.\\n\\nThis is a pure DP question. The difficulty lies in defining your subproblems/recursion. Some special trick is _not_ necessary to solve the question.\\n\\n### Further Hint:\\nI can\\'t say much more without entering spoiler territory, but just think about how you can figure out the minimum health at (i,j) assuming you have the (i+1,j) and (i,j+1) solutions."
                    },
                    {
                        "username": "bingcoder",
                        "content": "in this case [[100]] , why the correct output is 1? I think it should be 0."
                    },
                    {
                        "username": "Akashdeep_Gupta",
                        "content": "[@abacusrehan](/abacusrehan) yes at any point health should be minimum 1 even before starting."
                    },
                    {
                        "username": "abacusrehan",
                        "content": "too late, but still\\n> The knight has an initial health point represented by a positive integer. If at any point his health point drops to 0 or below, he dies immediately.\\n\\n"
                    },
                    {
                        "username": "god_like",
                        "content": "The description didn\\'t mention if the health could boost exceed the knight\\'s initial health, which would make a whole lot difference if that\\'s considered.\\n\\nImaging this: \\n[[0, 100, -98]] \\n\\nthe answer could be either 1 or 99."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I was also confused, because a typical video game logic would put a cap on the max health you can have.\nHowever, if you just read the solution, you do realize that nothing is mentionned relative to that, that the wording never implies a maximum health cap, and that you would only be making things up by implementing a limit for health.\nBasically, the problem description is correct, we just confused ourselves by making nerdy assumptions. Just gotta learn to read more carefully!"
                    },
                    {
                        "username": "aboulmagd",
                        "content": "So why does bottom up DP work when started from the bottom right cell, and not from the top left cell?\\n\\nAny intuition/visuals would really help.\\nI was only able to solve this problem using the former approach, but why is the DP not symmetrical as with other problems (i.e maximum subarray)?"
                    },
                    {
                        "username": "hebele",
                        "content": "Start from bottom right (not from top left)"
                    }
                ]
            },
            {
                "id": 1566484,
                "content": [
                    {
                        "username": "hhzsls",
                        "content": "Why we fill the table from the bottom right corner to left top?"
                    },
                    {
                        "username": "Msey",
                        "content": "These crafty Australians...!"
                    },
                    {
                        "username": "kmathur68",
                        "content": "If you start from top left to bottom right, then at every point you need to make a decision whether you are going right or down. \\nIn order to do that you need to know what is the minimum health required if you start from i+1,j and i,j+1 positions. \\n\\nYou can actually implement in this way, but they will have to be recursive calls. \\nSee more on here -> https://leetcode.com/problems/dungeon-game/solutions/745340/post-dedicated-to-beginners-of-dp-or-have-no-clue-how-to-start/"
                    },
                    {
                        "username": "clue",
                        "content": "As we all know the typical solution is via DP, which is also the given solution. I can't think of how it can relate to binary search, any ideas?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You could set the lower bound to 0 and the upper bound to 20,000 and than do binary search to see if for a certain amount of health you can find a path. It was what I first thought of, but DP is a much better approach here I think. \\n\\n1970. Last Day Where You Can Still Cross \\nis a somewhat similar problem (also traversing a matrix) where Binary search is useful: https://leetcode.com/problems/last-day-where-you-can-still-cross/"
                    },
                    {
                        "username": "packle",
                        "content": "[@shivasaineelam](/shivasaineelam) \\n\\nneat problem - reminds me of minimum path sum (dp), trapping rain water (variant Dijkstra), and safest path in grid (binary search). the max of the search could probably be tightened with some graph algorithm but above my pay grade. I set it to the sum of all negative values and similarly TLEd"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "we can think of a search space \na particular health and every health greater than that can save the princess \nwe need the minimum one\nbut mine got tle at 42 test case:)"
                    },
                    {
                        "username": "mmontgomery",
                        "content": "Submitting my answer, I\\'m told my code gets the wrong answer for a very simple input `[[0,0]]`, but when I run a custom testcase with this same input, I get the correct answer. What gives? \\n\\n![image](https://assets.leetcode.com/users/mmontgomery/image_1538528784.png)\\n\\nThis isn\\'t the first time this has happened to me on Leetcode problems. "
                    },
                    {
                        "username": "Sivarama_Krishnan_Venktrayan",
                        "content": "I used global static variable without mentioning the scope of the variable.\n\n```\nstatic int minHP = Integer.MAX_VALUE;\n```\n\nAfter i changed it to, \n\n```\npublic int minHP = Integer.MAX_VALUE;\n```\n\n#### Detailed explaination:\n<a>https://support.leetcode.com/hc/en-us/articles/360011834174-I-encountered-Wrong-Answer-Runtime-Error-for-a-specific-test-case-When-I-test-my-code-using-this-test-case-it-produced-the-correct-output-Why-</a>"
                    },
                    {
                        "username": "Bloody_Marry",
                        "content": "you may be using global variables."
                    },
                    {
                        "username": "david500",
                        "content": "I started this question trying to start from the top left, couldn\\'t sovle it and realized it\\'s best to solve it from the bottom right corner instead. Now I\\'m wondering if it\\'s even possible to do it from the top left, if anyone knows, please share"
                    },
                    {
                        "username": "aaryanman05",
                        "content": "[@bizco8](/bizco8)  Too confusing mate. I started from bottom right, and after some brainstorming it went smooth\\n\\n"
                    },
                    {
                        "username": "bizco8",
                        "content": "yes we can do it starting from the top left:\\n \\nclass Solution {\\n  int N;\\n  int M;\\n  Integer[][] cache;\\n  public int calculateMinimumHP(int[][] dungeon) {\\n    N = dungeon.length;\\n    M = dungeon[0].length;\\n    cache = new Integer[N][M];\\n    int res = Math.abs(helper(dungeon, 0, 0));\\n    return  res + 1;\\n  }\\n\\n  public int helper(int[][] dungeon, int i, int j){\\n    if(i >= N || i < 0 || j >= M || j < 0) return Integer.MIN_VALUE;\\n    if(cache[i][j] != null) return cache[i][j];\\n    if(i == N - 1 && j == M - 1){\\n      cache[i][j] = Math.min(0, dungeon[i][j]);\\n      return cache[i][j];\\n    }\\n    int minRight = helper(dungeon, i, j + 1);\\n    int minDown =  helper(dungeon, i + 1, j);\\n    if(minRight != Integer.MIN_VALUE) minRight = Math.min(0, dungeon[i][j] +  minRight);\\n    if(minDown != Integer.MIN_VALUE) minDown = Math.min(0, dungeon[i][j] +  minDown);\\n    cache[i][j] = Math.max(minDown, minRight);\\n    return cache[i][j];\\n  }\\n}"
                    },
                    {
                        "username": "kimeshgupta",
                        "content": "Can we solve this by start from dungeon[0][0] instead of dungeon[row-1][column-1] and get final result at dungeon[row-1][column-1] using same or another dp approach??? Please help."
                    },
                    {
                        "username": "thevirtuoso1973",
                        "content": "As usual I like to provide hints,  albeit this one is slightly less of a hint and more of a reassurance.\\n\\nThis is a pure DP question. The difficulty lies in defining your subproblems/recursion. Some special trick is _not_ necessary to solve the question.\\n\\n### Further Hint:\\nI can\\'t say much more without entering spoiler territory, but just think about how you can figure out the minimum health at (i,j) assuming you have the (i+1,j) and (i,j+1) solutions."
                    },
                    {
                        "username": "bingcoder",
                        "content": "in this case [[100]] , why the correct output is 1? I think it should be 0."
                    },
                    {
                        "username": "Akashdeep_Gupta",
                        "content": "[@abacusrehan](/abacusrehan) yes at any point health should be minimum 1 even before starting."
                    },
                    {
                        "username": "abacusrehan",
                        "content": "too late, but still\\n> The knight has an initial health point represented by a positive integer. If at any point his health point drops to 0 or below, he dies immediately.\\n\\n"
                    },
                    {
                        "username": "god_like",
                        "content": "The description didn\\'t mention if the health could boost exceed the knight\\'s initial health, which would make a whole lot difference if that\\'s considered.\\n\\nImaging this: \\n[[0, 100, -98]] \\n\\nthe answer could be either 1 or 99."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I was also confused, because a typical video game logic would put a cap on the max health you can have.\nHowever, if you just read the solution, you do realize that nothing is mentionned relative to that, that the wording never implies a maximum health cap, and that you would only be making things up by implementing a limit for health.\nBasically, the problem description is correct, we just confused ourselves by making nerdy assumptions. Just gotta learn to read more carefully!"
                    },
                    {
                        "username": "aboulmagd",
                        "content": "So why does bottom up DP work when started from the bottom right cell, and not from the top left cell?\\n\\nAny intuition/visuals would really help.\\nI was only able to solve this problem using the former approach, but why is the DP not symmetrical as with other problems (i.e maximum subarray)?"
                    },
                    {
                        "username": "hebele",
                        "content": "Start from bottom right (not from top left)"
                    }
                ]
            },
            {
                "id": 1568361,
                "content": [
                    {
                        "username": "hhzsls",
                        "content": "Why we fill the table from the bottom right corner to left top?"
                    },
                    {
                        "username": "Msey",
                        "content": "These crafty Australians...!"
                    },
                    {
                        "username": "kmathur68",
                        "content": "If you start from top left to bottom right, then at every point you need to make a decision whether you are going right or down. \\nIn order to do that you need to know what is the minimum health required if you start from i+1,j and i,j+1 positions. \\n\\nYou can actually implement in this way, but they will have to be recursive calls. \\nSee more on here -> https://leetcode.com/problems/dungeon-game/solutions/745340/post-dedicated-to-beginners-of-dp-or-have-no-clue-how-to-start/"
                    },
                    {
                        "username": "clue",
                        "content": "As we all know the typical solution is via DP, which is also the given solution. I can't think of how it can relate to binary search, any ideas?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You could set the lower bound to 0 and the upper bound to 20,000 and than do binary search to see if for a certain amount of health you can find a path. It was what I first thought of, but DP is a much better approach here I think. \\n\\n1970. Last Day Where You Can Still Cross \\nis a somewhat similar problem (also traversing a matrix) where Binary search is useful: https://leetcode.com/problems/last-day-where-you-can-still-cross/"
                    },
                    {
                        "username": "packle",
                        "content": "[@shivasaineelam](/shivasaineelam) \\n\\nneat problem - reminds me of minimum path sum (dp), trapping rain water (variant Dijkstra), and safest path in grid (binary search). the max of the search could probably be tightened with some graph algorithm but above my pay grade. I set it to the sum of all negative values and similarly TLEd"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "we can think of a search space \na particular health and every health greater than that can save the princess \nwe need the minimum one\nbut mine got tle at 42 test case:)"
                    },
                    {
                        "username": "mmontgomery",
                        "content": "Submitting my answer, I\\'m told my code gets the wrong answer for a very simple input `[[0,0]]`, but when I run a custom testcase with this same input, I get the correct answer. What gives? \\n\\n![image](https://assets.leetcode.com/users/mmontgomery/image_1538528784.png)\\n\\nThis isn\\'t the first time this has happened to me on Leetcode problems. "
                    },
                    {
                        "username": "Sivarama_Krishnan_Venktrayan",
                        "content": "I used global static variable without mentioning the scope of the variable.\n\n```\nstatic int minHP = Integer.MAX_VALUE;\n```\n\nAfter i changed it to, \n\n```\npublic int minHP = Integer.MAX_VALUE;\n```\n\n#### Detailed explaination:\n<a>https://support.leetcode.com/hc/en-us/articles/360011834174-I-encountered-Wrong-Answer-Runtime-Error-for-a-specific-test-case-When-I-test-my-code-using-this-test-case-it-produced-the-correct-output-Why-</a>"
                    },
                    {
                        "username": "Bloody_Marry",
                        "content": "you may be using global variables."
                    },
                    {
                        "username": "david500",
                        "content": "I started this question trying to start from the top left, couldn\\'t sovle it and realized it\\'s best to solve it from the bottom right corner instead. Now I\\'m wondering if it\\'s even possible to do it from the top left, if anyone knows, please share"
                    },
                    {
                        "username": "aaryanman05",
                        "content": "[@bizco8](/bizco8)  Too confusing mate. I started from bottom right, and after some brainstorming it went smooth\\n\\n"
                    },
                    {
                        "username": "bizco8",
                        "content": "yes we can do it starting from the top left:\\n \\nclass Solution {\\n  int N;\\n  int M;\\n  Integer[][] cache;\\n  public int calculateMinimumHP(int[][] dungeon) {\\n    N = dungeon.length;\\n    M = dungeon[0].length;\\n    cache = new Integer[N][M];\\n    int res = Math.abs(helper(dungeon, 0, 0));\\n    return  res + 1;\\n  }\\n\\n  public int helper(int[][] dungeon, int i, int j){\\n    if(i >= N || i < 0 || j >= M || j < 0) return Integer.MIN_VALUE;\\n    if(cache[i][j] != null) return cache[i][j];\\n    if(i == N - 1 && j == M - 1){\\n      cache[i][j] = Math.min(0, dungeon[i][j]);\\n      return cache[i][j];\\n    }\\n    int minRight = helper(dungeon, i, j + 1);\\n    int minDown =  helper(dungeon, i + 1, j);\\n    if(minRight != Integer.MIN_VALUE) minRight = Math.min(0, dungeon[i][j] +  minRight);\\n    if(minDown != Integer.MIN_VALUE) minDown = Math.min(0, dungeon[i][j] +  minDown);\\n    cache[i][j] = Math.max(minDown, minRight);\\n    return cache[i][j];\\n  }\\n}"
                    },
                    {
                        "username": "kimeshgupta",
                        "content": "Can we solve this by start from dungeon[0][0] instead of dungeon[row-1][column-1] and get final result at dungeon[row-1][column-1] using same or another dp approach??? Please help."
                    },
                    {
                        "username": "thevirtuoso1973",
                        "content": "As usual I like to provide hints,  albeit this one is slightly less of a hint and more of a reassurance.\\n\\nThis is a pure DP question. The difficulty lies in defining your subproblems/recursion. Some special trick is _not_ necessary to solve the question.\\n\\n### Further Hint:\\nI can\\'t say much more without entering spoiler territory, but just think about how you can figure out the minimum health at (i,j) assuming you have the (i+1,j) and (i,j+1) solutions."
                    },
                    {
                        "username": "bingcoder",
                        "content": "in this case [[100]] , why the correct output is 1? I think it should be 0."
                    },
                    {
                        "username": "Akashdeep_Gupta",
                        "content": "[@abacusrehan](/abacusrehan) yes at any point health should be minimum 1 even before starting."
                    },
                    {
                        "username": "abacusrehan",
                        "content": "too late, but still\\n> The knight has an initial health point represented by a positive integer. If at any point his health point drops to 0 or below, he dies immediately.\\n\\n"
                    },
                    {
                        "username": "god_like",
                        "content": "The description didn\\'t mention if the health could boost exceed the knight\\'s initial health, which would make a whole lot difference if that\\'s considered.\\n\\nImaging this: \\n[[0, 100, -98]] \\n\\nthe answer could be either 1 or 99."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I was also confused, because a typical video game logic would put a cap on the max health you can have.\nHowever, if you just read the solution, you do realize that nothing is mentionned relative to that, that the wording never implies a maximum health cap, and that you would only be making things up by implementing a limit for health.\nBasically, the problem description is correct, we just confused ourselves by making nerdy assumptions. Just gotta learn to read more carefully!"
                    },
                    {
                        "username": "aboulmagd",
                        "content": "So why does bottom up DP work when started from the bottom right cell, and not from the top left cell?\\n\\nAny intuition/visuals would really help.\\nI was only able to solve this problem using the former approach, but why is the DP not symmetrical as with other problems (i.e maximum subarray)?"
                    },
                    {
                        "username": "hebele",
                        "content": "Start from bottom right (not from top left)"
                    }
                ]
            },
            {
                "id": 1571382,
                "content": [
                    {
                        "username": "hhzsls",
                        "content": "Why we fill the table from the bottom right corner to left top?"
                    },
                    {
                        "username": "Msey",
                        "content": "These crafty Australians...!"
                    },
                    {
                        "username": "kmathur68",
                        "content": "If you start from top left to bottom right, then at every point you need to make a decision whether you are going right or down. \\nIn order to do that you need to know what is the minimum health required if you start from i+1,j and i,j+1 positions. \\n\\nYou can actually implement in this way, but they will have to be recursive calls. \\nSee more on here -> https://leetcode.com/problems/dungeon-game/solutions/745340/post-dedicated-to-beginners-of-dp-or-have-no-clue-how-to-start/"
                    },
                    {
                        "username": "clue",
                        "content": "As we all know the typical solution is via DP, which is also the given solution. I can't think of how it can relate to binary search, any ideas?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You could set the lower bound to 0 and the upper bound to 20,000 and than do binary search to see if for a certain amount of health you can find a path. It was what I first thought of, but DP is a much better approach here I think. \\n\\n1970. Last Day Where You Can Still Cross \\nis a somewhat similar problem (also traversing a matrix) where Binary search is useful: https://leetcode.com/problems/last-day-where-you-can-still-cross/"
                    },
                    {
                        "username": "packle",
                        "content": "[@shivasaineelam](/shivasaineelam) \\n\\nneat problem - reminds me of minimum path sum (dp), trapping rain water (variant Dijkstra), and safest path in grid (binary search). the max of the search could probably be tightened with some graph algorithm but above my pay grade. I set it to the sum of all negative values and similarly TLEd"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "we can think of a search space \na particular health and every health greater than that can save the princess \nwe need the minimum one\nbut mine got tle at 42 test case:)"
                    },
                    {
                        "username": "mmontgomery",
                        "content": "Submitting my answer, I\\'m told my code gets the wrong answer for a very simple input `[[0,0]]`, but when I run a custom testcase with this same input, I get the correct answer. What gives? \\n\\n![image](https://assets.leetcode.com/users/mmontgomery/image_1538528784.png)\\n\\nThis isn\\'t the first time this has happened to me on Leetcode problems. "
                    },
                    {
                        "username": "Sivarama_Krishnan_Venktrayan",
                        "content": "I used global static variable without mentioning the scope of the variable.\n\n```\nstatic int minHP = Integer.MAX_VALUE;\n```\n\nAfter i changed it to, \n\n```\npublic int minHP = Integer.MAX_VALUE;\n```\n\n#### Detailed explaination:\n<a>https://support.leetcode.com/hc/en-us/articles/360011834174-I-encountered-Wrong-Answer-Runtime-Error-for-a-specific-test-case-When-I-test-my-code-using-this-test-case-it-produced-the-correct-output-Why-</a>"
                    },
                    {
                        "username": "Bloody_Marry",
                        "content": "you may be using global variables."
                    },
                    {
                        "username": "david500",
                        "content": "I started this question trying to start from the top left, couldn\\'t sovle it and realized it\\'s best to solve it from the bottom right corner instead. Now I\\'m wondering if it\\'s even possible to do it from the top left, if anyone knows, please share"
                    },
                    {
                        "username": "aaryanman05",
                        "content": "[@bizco8](/bizco8)  Too confusing mate. I started from bottom right, and after some brainstorming it went smooth\\n\\n"
                    },
                    {
                        "username": "bizco8",
                        "content": "yes we can do it starting from the top left:\\n \\nclass Solution {\\n  int N;\\n  int M;\\n  Integer[][] cache;\\n  public int calculateMinimumHP(int[][] dungeon) {\\n    N = dungeon.length;\\n    M = dungeon[0].length;\\n    cache = new Integer[N][M];\\n    int res = Math.abs(helper(dungeon, 0, 0));\\n    return  res + 1;\\n  }\\n\\n  public int helper(int[][] dungeon, int i, int j){\\n    if(i >= N || i < 0 || j >= M || j < 0) return Integer.MIN_VALUE;\\n    if(cache[i][j] != null) return cache[i][j];\\n    if(i == N - 1 && j == M - 1){\\n      cache[i][j] = Math.min(0, dungeon[i][j]);\\n      return cache[i][j];\\n    }\\n    int minRight = helper(dungeon, i, j + 1);\\n    int minDown =  helper(dungeon, i + 1, j);\\n    if(minRight != Integer.MIN_VALUE) minRight = Math.min(0, dungeon[i][j] +  minRight);\\n    if(minDown != Integer.MIN_VALUE) minDown = Math.min(0, dungeon[i][j] +  minDown);\\n    cache[i][j] = Math.max(minDown, minRight);\\n    return cache[i][j];\\n  }\\n}"
                    },
                    {
                        "username": "kimeshgupta",
                        "content": "Can we solve this by start from dungeon[0][0] instead of dungeon[row-1][column-1] and get final result at dungeon[row-1][column-1] using same or another dp approach??? Please help."
                    },
                    {
                        "username": "thevirtuoso1973",
                        "content": "As usual I like to provide hints,  albeit this one is slightly less of a hint and more of a reassurance.\\n\\nThis is a pure DP question. The difficulty lies in defining your subproblems/recursion. Some special trick is _not_ necessary to solve the question.\\n\\n### Further Hint:\\nI can\\'t say much more without entering spoiler territory, but just think about how you can figure out the minimum health at (i,j) assuming you have the (i+1,j) and (i,j+1) solutions."
                    },
                    {
                        "username": "bingcoder",
                        "content": "in this case [[100]] , why the correct output is 1? I think it should be 0."
                    },
                    {
                        "username": "Akashdeep_Gupta",
                        "content": "[@abacusrehan](/abacusrehan) yes at any point health should be minimum 1 even before starting."
                    },
                    {
                        "username": "abacusrehan",
                        "content": "too late, but still\\n> The knight has an initial health point represented by a positive integer. If at any point his health point drops to 0 or below, he dies immediately.\\n\\n"
                    },
                    {
                        "username": "god_like",
                        "content": "The description didn\\'t mention if the health could boost exceed the knight\\'s initial health, which would make a whole lot difference if that\\'s considered.\\n\\nImaging this: \\n[[0, 100, -98]] \\n\\nthe answer could be either 1 or 99."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I was also confused, because a typical video game logic would put a cap on the max health you can have.\nHowever, if you just read the solution, you do realize that nothing is mentionned relative to that, that the wording never implies a maximum health cap, and that you would only be making things up by implementing a limit for health.\nBasically, the problem description is correct, we just confused ourselves by making nerdy assumptions. Just gotta learn to read more carefully!"
                    },
                    {
                        "username": "aboulmagd",
                        "content": "So why does bottom up DP work when started from the bottom right cell, and not from the top left cell?\\n\\nAny intuition/visuals would really help.\\nI was only able to solve this problem using the former approach, but why is the DP not symmetrical as with other problems (i.e maximum subarray)?"
                    },
                    {
                        "username": "hebele",
                        "content": "Start from bottom right (not from top left)"
                    }
                ]
            },
            {
                "id": 1570594,
                "content": [
                    {
                        "username": "hhzsls",
                        "content": "Why we fill the table from the bottom right corner to left top?"
                    },
                    {
                        "username": "Msey",
                        "content": "These crafty Australians...!"
                    },
                    {
                        "username": "kmathur68",
                        "content": "If you start from top left to bottom right, then at every point you need to make a decision whether you are going right or down. \\nIn order to do that you need to know what is the minimum health required if you start from i+1,j and i,j+1 positions. \\n\\nYou can actually implement in this way, but they will have to be recursive calls. \\nSee more on here -> https://leetcode.com/problems/dungeon-game/solutions/745340/post-dedicated-to-beginners-of-dp-or-have-no-clue-how-to-start/"
                    },
                    {
                        "username": "clue",
                        "content": "As we all know the typical solution is via DP, which is also the given solution. I can't think of how it can relate to binary search, any ideas?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You could set the lower bound to 0 and the upper bound to 20,000 and than do binary search to see if for a certain amount of health you can find a path. It was what I first thought of, but DP is a much better approach here I think. \\n\\n1970. Last Day Where You Can Still Cross \\nis a somewhat similar problem (also traversing a matrix) where Binary search is useful: https://leetcode.com/problems/last-day-where-you-can-still-cross/"
                    },
                    {
                        "username": "packle",
                        "content": "[@shivasaineelam](/shivasaineelam) \\n\\nneat problem - reminds me of minimum path sum (dp), trapping rain water (variant Dijkstra), and safest path in grid (binary search). the max of the search could probably be tightened with some graph algorithm but above my pay grade. I set it to the sum of all negative values and similarly TLEd"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "we can think of a search space \na particular health and every health greater than that can save the princess \nwe need the minimum one\nbut mine got tle at 42 test case:)"
                    },
                    {
                        "username": "mmontgomery",
                        "content": "Submitting my answer, I\\'m told my code gets the wrong answer for a very simple input `[[0,0]]`, but when I run a custom testcase with this same input, I get the correct answer. What gives? \\n\\n![image](https://assets.leetcode.com/users/mmontgomery/image_1538528784.png)\\n\\nThis isn\\'t the first time this has happened to me on Leetcode problems. "
                    },
                    {
                        "username": "Sivarama_Krishnan_Venktrayan",
                        "content": "I used global static variable without mentioning the scope of the variable.\n\n```\nstatic int minHP = Integer.MAX_VALUE;\n```\n\nAfter i changed it to, \n\n```\npublic int minHP = Integer.MAX_VALUE;\n```\n\n#### Detailed explaination:\n<a>https://support.leetcode.com/hc/en-us/articles/360011834174-I-encountered-Wrong-Answer-Runtime-Error-for-a-specific-test-case-When-I-test-my-code-using-this-test-case-it-produced-the-correct-output-Why-</a>"
                    },
                    {
                        "username": "Bloody_Marry",
                        "content": "you may be using global variables."
                    },
                    {
                        "username": "david500",
                        "content": "I started this question trying to start from the top left, couldn\\'t sovle it and realized it\\'s best to solve it from the bottom right corner instead. Now I\\'m wondering if it\\'s even possible to do it from the top left, if anyone knows, please share"
                    },
                    {
                        "username": "aaryanman05",
                        "content": "[@bizco8](/bizco8)  Too confusing mate. I started from bottom right, and after some brainstorming it went smooth\\n\\n"
                    },
                    {
                        "username": "bizco8",
                        "content": "yes we can do it starting from the top left:\\n \\nclass Solution {\\n  int N;\\n  int M;\\n  Integer[][] cache;\\n  public int calculateMinimumHP(int[][] dungeon) {\\n    N = dungeon.length;\\n    M = dungeon[0].length;\\n    cache = new Integer[N][M];\\n    int res = Math.abs(helper(dungeon, 0, 0));\\n    return  res + 1;\\n  }\\n\\n  public int helper(int[][] dungeon, int i, int j){\\n    if(i >= N || i < 0 || j >= M || j < 0) return Integer.MIN_VALUE;\\n    if(cache[i][j] != null) return cache[i][j];\\n    if(i == N - 1 && j == M - 1){\\n      cache[i][j] = Math.min(0, dungeon[i][j]);\\n      return cache[i][j];\\n    }\\n    int minRight = helper(dungeon, i, j + 1);\\n    int minDown =  helper(dungeon, i + 1, j);\\n    if(minRight != Integer.MIN_VALUE) minRight = Math.min(0, dungeon[i][j] +  minRight);\\n    if(minDown != Integer.MIN_VALUE) minDown = Math.min(0, dungeon[i][j] +  minDown);\\n    cache[i][j] = Math.max(minDown, minRight);\\n    return cache[i][j];\\n  }\\n}"
                    },
                    {
                        "username": "kimeshgupta",
                        "content": "Can we solve this by start from dungeon[0][0] instead of dungeon[row-1][column-1] and get final result at dungeon[row-1][column-1] using same or another dp approach??? Please help."
                    },
                    {
                        "username": "thevirtuoso1973",
                        "content": "As usual I like to provide hints,  albeit this one is slightly less of a hint and more of a reassurance.\\n\\nThis is a pure DP question. The difficulty lies in defining your subproblems/recursion. Some special trick is _not_ necessary to solve the question.\\n\\n### Further Hint:\\nI can\\'t say much more without entering spoiler territory, but just think about how you can figure out the minimum health at (i,j) assuming you have the (i+1,j) and (i,j+1) solutions."
                    },
                    {
                        "username": "bingcoder",
                        "content": "in this case [[100]] , why the correct output is 1? I think it should be 0."
                    },
                    {
                        "username": "Akashdeep_Gupta",
                        "content": "[@abacusrehan](/abacusrehan) yes at any point health should be minimum 1 even before starting."
                    },
                    {
                        "username": "abacusrehan",
                        "content": "too late, but still\\n> The knight has an initial health point represented by a positive integer. If at any point his health point drops to 0 or below, he dies immediately.\\n\\n"
                    },
                    {
                        "username": "god_like",
                        "content": "The description didn\\'t mention if the health could boost exceed the knight\\'s initial health, which would make a whole lot difference if that\\'s considered.\\n\\nImaging this: \\n[[0, 100, -98]] \\n\\nthe answer could be either 1 or 99."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I was also confused, because a typical video game logic would put a cap on the max health you can have.\nHowever, if you just read the solution, you do realize that nothing is mentionned relative to that, that the wording never implies a maximum health cap, and that you would only be making things up by implementing a limit for health.\nBasically, the problem description is correct, we just confused ourselves by making nerdy assumptions. Just gotta learn to read more carefully!"
                    },
                    {
                        "username": "aboulmagd",
                        "content": "So why does bottom up DP work when started from the bottom right cell, and not from the top left cell?\\n\\nAny intuition/visuals would really help.\\nI was only able to solve this problem using the former approach, but why is the DP not symmetrical as with other problems (i.e maximum subarray)?"
                    },
                    {
                        "username": "hebele",
                        "content": "Start from bottom right (not from top left)"
                    }
                ]
            },
            {
                "id": 1573955,
                "content": [
                    {
                        "username": "hhzsls",
                        "content": "Why we fill the table from the bottom right corner to left top?"
                    },
                    {
                        "username": "Msey",
                        "content": "These crafty Australians...!"
                    },
                    {
                        "username": "kmathur68",
                        "content": "If you start from top left to bottom right, then at every point you need to make a decision whether you are going right or down. \\nIn order to do that you need to know what is the minimum health required if you start from i+1,j and i,j+1 positions. \\n\\nYou can actually implement in this way, but they will have to be recursive calls. \\nSee more on here -> https://leetcode.com/problems/dungeon-game/solutions/745340/post-dedicated-to-beginners-of-dp-or-have-no-clue-how-to-start/"
                    },
                    {
                        "username": "clue",
                        "content": "As we all know the typical solution is via DP, which is also the given solution. I can't think of how it can relate to binary search, any ideas?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You could set the lower bound to 0 and the upper bound to 20,000 and than do binary search to see if for a certain amount of health you can find a path. It was what I first thought of, but DP is a much better approach here I think. \\n\\n1970. Last Day Where You Can Still Cross \\nis a somewhat similar problem (also traversing a matrix) where Binary search is useful: https://leetcode.com/problems/last-day-where-you-can-still-cross/"
                    },
                    {
                        "username": "packle",
                        "content": "[@shivasaineelam](/shivasaineelam) \\n\\nneat problem - reminds me of minimum path sum (dp), trapping rain water (variant Dijkstra), and safest path in grid (binary search). the max of the search could probably be tightened with some graph algorithm but above my pay grade. I set it to the sum of all negative values and similarly TLEd"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "we can think of a search space \na particular health and every health greater than that can save the princess \nwe need the minimum one\nbut mine got tle at 42 test case:)"
                    },
                    {
                        "username": "mmontgomery",
                        "content": "Submitting my answer, I\\'m told my code gets the wrong answer for a very simple input `[[0,0]]`, but when I run a custom testcase with this same input, I get the correct answer. What gives? \\n\\n![image](https://assets.leetcode.com/users/mmontgomery/image_1538528784.png)\\n\\nThis isn\\'t the first time this has happened to me on Leetcode problems. "
                    },
                    {
                        "username": "Sivarama_Krishnan_Venktrayan",
                        "content": "I used global static variable without mentioning the scope of the variable.\n\n```\nstatic int minHP = Integer.MAX_VALUE;\n```\n\nAfter i changed it to, \n\n```\npublic int minHP = Integer.MAX_VALUE;\n```\n\n#### Detailed explaination:\n<a>https://support.leetcode.com/hc/en-us/articles/360011834174-I-encountered-Wrong-Answer-Runtime-Error-for-a-specific-test-case-When-I-test-my-code-using-this-test-case-it-produced-the-correct-output-Why-</a>"
                    },
                    {
                        "username": "Bloody_Marry",
                        "content": "you may be using global variables."
                    },
                    {
                        "username": "david500",
                        "content": "I started this question trying to start from the top left, couldn\\'t sovle it and realized it\\'s best to solve it from the bottom right corner instead. Now I\\'m wondering if it\\'s even possible to do it from the top left, if anyone knows, please share"
                    },
                    {
                        "username": "aaryanman05",
                        "content": "[@bizco8](/bizco8)  Too confusing mate. I started from bottom right, and after some brainstorming it went smooth\\n\\n"
                    },
                    {
                        "username": "bizco8",
                        "content": "yes we can do it starting from the top left:\\n \\nclass Solution {\\n  int N;\\n  int M;\\n  Integer[][] cache;\\n  public int calculateMinimumHP(int[][] dungeon) {\\n    N = dungeon.length;\\n    M = dungeon[0].length;\\n    cache = new Integer[N][M];\\n    int res = Math.abs(helper(dungeon, 0, 0));\\n    return  res + 1;\\n  }\\n\\n  public int helper(int[][] dungeon, int i, int j){\\n    if(i >= N || i < 0 || j >= M || j < 0) return Integer.MIN_VALUE;\\n    if(cache[i][j] != null) return cache[i][j];\\n    if(i == N - 1 && j == M - 1){\\n      cache[i][j] = Math.min(0, dungeon[i][j]);\\n      return cache[i][j];\\n    }\\n    int minRight = helper(dungeon, i, j + 1);\\n    int minDown =  helper(dungeon, i + 1, j);\\n    if(minRight != Integer.MIN_VALUE) minRight = Math.min(0, dungeon[i][j] +  minRight);\\n    if(minDown != Integer.MIN_VALUE) minDown = Math.min(0, dungeon[i][j] +  minDown);\\n    cache[i][j] = Math.max(minDown, minRight);\\n    return cache[i][j];\\n  }\\n}"
                    },
                    {
                        "username": "kimeshgupta",
                        "content": "Can we solve this by start from dungeon[0][0] instead of dungeon[row-1][column-1] and get final result at dungeon[row-1][column-1] using same or another dp approach??? Please help."
                    },
                    {
                        "username": "thevirtuoso1973",
                        "content": "As usual I like to provide hints,  albeit this one is slightly less of a hint and more of a reassurance.\\n\\nThis is a pure DP question. The difficulty lies in defining your subproblems/recursion. Some special trick is _not_ necessary to solve the question.\\n\\n### Further Hint:\\nI can\\'t say much more without entering spoiler territory, but just think about how you can figure out the minimum health at (i,j) assuming you have the (i+1,j) and (i,j+1) solutions."
                    },
                    {
                        "username": "bingcoder",
                        "content": "in this case [[100]] , why the correct output is 1? I think it should be 0."
                    },
                    {
                        "username": "Akashdeep_Gupta",
                        "content": "[@abacusrehan](/abacusrehan) yes at any point health should be minimum 1 even before starting."
                    },
                    {
                        "username": "abacusrehan",
                        "content": "too late, but still\\n> The knight has an initial health point represented by a positive integer. If at any point his health point drops to 0 or below, he dies immediately.\\n\\n"
                    },
                    {
                        "username": "god_like",
                        "content": "The description didn\\'t mention if the health could boost exceed the knight\\'s initial health, which would make a whole lot difference if that\\'s considered.\\n\\nImaging this: \\n[[0, 100, -98]] \\n\\nthe answer could be either 1 or 99."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I was also confused, because a typical video game logic would put a cap on the max health you can have.\nHowever, if you just read the solution, you do realize that nothing is mentionned relative to that, that the wording never implies a maximum health cap, and that you would only be making things up by implementing a limit for health.\nBasically, the problem description is correct, we just confused ourselves by making nerdy assumptions. Just gotta learn to read more carefully!"
                    },
                    {
                        "username": "aboulmagd",
                        "content": "So why does bottom up DP work when started from the bottom right cell, and not from the top left cell?\\n\\nAny intuition/visuals would really help.\\nI was only able to solve this problem using the former approach, but why is the DP not symmetrical as with other problems (i.e maximum subarray)?"
                    },
                    {
                        "username": "hebele",
                        "content": "Start from bottom right (not from top left)"
                    }
                ]
            },
            {
                "id": 1568998,
                "content": [
                    {
                        "username": "hhzsls",
                        "content": "Why we fill the table from the bottom right corner to left top?"
                    },
                    {
                        "username": "Msey",
                        "content": "These crafty Australians...!"
                    },
                    {
                        "username": "kmathur68",
                        "content": "If you start from top left to bottom right, then at every point you need to make a decision whether you are going right or down. \\nIn order to do that you need to know what is the minimum health required if you start from i+1,j and i,j+1 positions. \\n\\nYou can actually implement in this way, but they will have to be recursive calls. \\nSee more on here -> https://leetcode.com/problems/dungeon-game/solutions/745340/post-dedicated-to-beginners-of-dp-or-have-no-clue-how-to-start/"
                    },
                    {
                        "username": "clue",
                        "content": "As we all know the typical solution is via DP, which is also the given solution. I can't think of how it can relate to binary search, any ideas?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You could set the lower bound to 0 and the upper bound to 20,000 and than do binary search to see if for a certain amount of health you can find a path. It was what I first thought of, but DP is a much better approach here I think. \\n\\n1970. Last Day Where You Can Still Cross \\nis a somewhat similar problem (also traversing a matrix) where Binary search is useful: https://leetcode.com/problems/last-day-where-you-can-still-cross/"
                    },
                    {
                        "username": "packle",
                        "content": "[@shivasaineelam](/shivasaineelam) \\n\\nneat problem - reminds me of minimum path sum (dp), trapping rain water (variant Dijkstra), and safest path in grid (binary search). the max of the search could probably be tightened with some graph algorithm but above my pay grade. I set it to the sum of all negative values and similarly TLEd"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "we can think of a search space \na particular health and every health greater than that can save the princess \nwe need the minimum one\nbut mine got tle at 42 test case:)"
                    },
                    {
                        "username": "mmontgomery",
                        "content": "Submitting my answer, I\\'m told my code gets the wrong answer for a very simple input `[[0,0]]`, but when I run a custom testcase with this same input, I get the correct answer. What gives? \\n\\n![image](https://assets.leetcode.com/users/mmontgomery/image_1538528784.png)\\n\\nThis isn\\'t the first time this has happened to me on Leetcode problems. "
                    },
                    {
                        "username": "Sivarama_Krishnan_Venktrayan",
                        "content": "I used global static variable without mentioning the scope of the variable.\n\n```\nstatic int minHP = Integer.MAX_VALUE;\n```\n\nAfter i changed it to, \n\n```\npublic int minHP = Integer.MAX_VALUE;\n```\n\n#### Detailed explaination:\n<a>https://support.leetcode.com/hc/en-us/articles/360011834174-I-encountered-Wrong-Answer-Runtime-Error-for-a-specific-test-case-When-I-test-my-code-using-this-test-case-it-produced-the-correct-output-Why-</a>"
                    },
                    {
                        "username": "Bloody_Marry",
                        "content": "you may be using global variables."
                    },
                    {
                        "username": "david500",
                        "content": "I started this question trying to start from the top left, couldn\\'t sovle it and realized it\\'s best to solve it from the bottom right corner instead. Now I\\'m wondering if it\\'s even possible to do it from the top left, if anyone knows, please share"
                    },
                    {
                        "username": "aaryanman05",
                        "content": "[@bizco8](/bizco8)  Too confusing mate. I started from bottom right, and after some brainstorming it went smooth\\n\\n"
                    },
                    {
                        "username": "bizco8",
                        "content": "yes we can do it starting from the top left:\\n \\nclass Solution {\\n  int N;\\n  int M;\\n  Integer[][] cache;\\n  public int calculateMinimumHP(int[][] dungeon) {\\n    N = dungeon.length;\\n    M = dungeon[0].length;\\n    cache = new Integer[N][M];\\n    int res = Math.abs(helper(dungeon, 0, 0));\\n    return  res + 1;\\n  }\\n\\n  public int helper(int[][] dungeon, int i, int j){\\n    if(i >= N || i < 0 || j >= M || j < 0) return Integer.MIN_VALUE;\\n    if(cache[i][j] != null) return cache[i][j];\\n    if(i == N - 1 && j == M - 1){\\n      cache[i][j] = Math.min(0, dungeon[i][j]);\\n      return cache[i][j];\\n    }\\n    int minRight = helper(dungeon, i, j + 1);\\n    int minDown =  helper(dungeon, i + 1, j);\\n    if(minRight != Integer.MIN_VALUE) minRight = Math.min(0, dungeon[i][j] +  minRight);\\n    if(minDown != Integer.MIN_VALUE) minDown = Math.min(0, dungeon[i][j] +  minDown);\\n    cache[i][j] = Math.max(minDown, minRight);\\n    return cache[i][j];\\n  }\\n}"
                    },
                    {
                        "username": "kimeshgupta",
                        "content": "Can we solve this by start from dungeon[0][0] instead of dungeon[row-1][column-1] and get final result at dungeon[row-1][column-1] using same or another dp approach??? Please help."
                    },
                    {
                        "username": "thevirtuoso1973",
                        "content": "As usual I like to provide hints,  albeit this one is slightly less of a hint and more of a reassurance.\\n\\nThis is a pure DP question. The difficulty lies in defining your subproblems/recursion. Some special trick is _not_ necessary to solve the question.\\n\\n### Further Hint:\\nI can\\'t say much more without entering spoiler territory, but just think about how you can figure out the minimum health at (i,j) assuming you have the (i+1,j) and (i,j+1) solutions."
                    },
                    {
                        "username": "bingcoder",
                        "content": "in this case [[100]] , why the correct output is 1? I think it should be 0."
                    },
                    {
                        "username": "Akashdeep_Gupta",
                        "content": "[@abacusrehan](/abacusrehan) yes at any point health should be minimum 1 even before starting."
                    },
                    {
                        "username": "abacusrehan",
                        "content": "too late, but still\\n> The knight has an initial health point represented by a positive integer. If at any point his health point drops to 0 or below, he dies immediately.\\n\\n"
                    },
                    {
                        "username": "god_like",
                        "content": "The description didn\\'t mention if the health could boost exceed the knight\\'s initial health, which would make a whole lot difference if that\\'s considered.\\n\\nImaging this: \\n[[0, 100, -98]] \\n\\nthe answer could be either 1 or 99."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I was also confused, because a typical video game logic would put a cap on the max health you can have.\nHowever, if you just read the solution, you do realize that nothing is mentionned relative to that, that the wording never implies a maximum health cap, and that you would only be making things up by implementing a limit for health.\nBasically, the problem description is correct, we just confused ourselves by making nerdy assumptions. Just gotta learn to read more carefully!"
                    },
                    {
                        "username": "aboulmagd",
                        "content": "So why does bottom up DP work when started from the bottom right cell, and not from the top left cell?\\n\\nAny intuition/visuals would really help.\\nI was only able to solve this problem using the former approach, but why is the DP not symmetrical as with other problems (i.e maximum subarray)?"
                    },
                    {
                        "username": "hebele",
                        "content": "Start from bottom right (not from top left)"
                    }
                ]
            },
            {
                "id": 1564963,
                "content": [
                    {
                        "username": "hhzsls",
                        "content": "Why we fill the table from the bottom right corner to left top?"
                    },
                    {
                        "username": "Msey",
                        "content": "These crafty Australians...!"
                    },
                    {
                        "username": "kmathur68",
                        "content": "If you start from top left to bottom right, then at every point you need to make a decision whether you are going right or down. \\nIn order to do that you need to know what is the minimum health required if you start from i+1,j and i,j+1 positions. \\n\\nYou can actually implement in this way, but they will have to be recursive calls. \\nSee more on here -> https://leetcode.com/problems/dungeon-game/solutions/745340/post-dedicated-to-beginners-of-dp-or-have-no-clue-how-to-start/"
                    },
                    {
                        "username": "clue",
                        "content": "As we all know the typical solution is via DP, which is also the given solution. I can't think of how it can relate to binary search, any ideas?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You could set the lower bound to 0 and the upper bound to 20,000 and than do binary search to see if for a certain amount of health you can find a path. It was what I first thought of, but DP is a much better approach here I think. \\n\\n1970. Last Day Where You Can Still Cross \\nis a somewhat similar problem (also traversing a matrix) where Binary search is useful: https://leetcode.com/problems/last-day-where-you-can-still-cross/"
                    },
                    {
                        "username": "packle",
                        "content": "[@shivasaineelam](/shivasaineelam) \\n\\nneat problem - reminds me of minimum path sum (dp), trapping rain water (variant Dijkstra), and safest path in grid (binary search). the max of the search could probably be tightened with some graph algorithm but above my pay grade. I set it to the sum of all negative values and similarly TLEd"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "we can think of a search space \na particular health and every health greater than that can save the princess \nwe need the minimum one\nbut mine got tle at 42 test case:)"
                    },
                    {
                        "username": "mmontgomery",
                        "content": "Submitting my answer, I\\'m told my code gets the wrong answer for a very simple input `[[0,0]]`, but when I run a custom testcase with this same input, I get the correct answer. What gives? \\n\\n![image](https://assets.leetcode.com/users/mmontgomery/image_1538528784.png)\\n\\nThis isn\\'t the first time this has happened to me on Leetcode problems. "
                    },
                    {
                        "username": "Sivarama_Krishnan_Venktrayan",
                        "content": "I used global static variable without mentioning the scope of the variable.\n\n```\nstatic int minHP = Integer.MAX_VALUE;\n```\n\nAfter i changed it to, \n\n```\npublic int minHP = Integer.MAX_VALUE;\n```\n\n#### Detailed explaination:\n<a>https://support.leetcode.com/hc/en-us/articles/360011834174-I-encountered-Wrong-Answer-Runtime-Error-for-a-specific-test-case-When-I-test-my-code-using-this-test-case-it-produced-the-correct-output-Why-</a>"
                    },
                    {
                        "username": "Bloody_Marry",
                        "content": "you may be using global variables."
                    },
                    {
                        "username": "david500",
                        "content": "I started this question trying to start from the top left, couldn\\'t sovle it and realized it\\'s best to solve it from the bottom right corner instead. Now I\\'m wondering if it\\'s even possible to do it from the top left, if anyone knows, please share"
                    },
                    {
                        "username": "aaryanman05",
                        "content": "[@bizco8](/bizco8)  Too confusing mate. I started from bottom right, and after some brainstorming it went smooth\\n\\n"
                    },
                    {
                        "username": "bizco8",
                        "content": "yes we can do it starting from the top left:\\n \\nclass Solution {\\n  int N;\\n  int M;\\n  Integer[][] cache;\\n  public int calculateMinimumHP(int[][] dungeon) {\\n    N = dungeon.length;\\n    M = dungeon[0].length;\\n    cache = new Integer[N][M];\\n    int res = Math.abs(helper(dungeon, 0, 0));\\n    return  res + 1;\\n  }\\n\\n  public int helper(int[][] dungeon, int i, int j){\\n    if(i >= N || i < 0 || j >= M || j < 0) return Integer.MIN_VALUE;\\n    if(cache[i][j] != null) return cache[i][j];\\n    if(i == N - 1 && j == M - 1){\\n      cache[i][j] = Math.min(0, dungeon[i][j]);\\n      return cache[i][j];\\n    }\\n    int minRight = helper(dungeon, i, j + 1);\\n    int minDown =  helper(dungeon, i + 1, j);\\n    if(minRight != Integer.MIN_VALUE) minRight = Math.min(0, dungeon[i][j] +  minRight);\\n    if(minDown != Integer.MIN_VALUE) minDown = Math.min(0, dungeon[i][j] +  minDown);\\n    cache[i][j] = Math.max(minDown, minRight);\\n    return cache[i][j];\\n  }\\n}"
                    },
                    {
                        "username": "kimeshgupta",
                        "content": "Can we solve this by start from dungeon[0][0] instead of dungeon[row-1][column-1] and get final result at dungeon[row-1][column-1] using same or another dp approach??? Please help."
                    },
                    {
                        "username": "thevirtuoso1973",
                        "content": "As usual I like to provide hints,  albeit this one is slightly less of a hint and more of a reassurance.\\n\\nThis is a pure DP question. The difficulty lies in defining your subproblems/recursion. Some special trick is _not_ necessary to solve the question.\\n\\n### Further Hint:\\nI can\\'t say much more without entering spoiler territory, but just think about how you can figure out the minimum health at (i,j) assuming you have the (i+1,j) and (i,j+1) solutions."
                    },
                    {
                        "username": "bingcoder",
                        "content": "in this case [[100]] , why the correct output is 1? I think it should be 0."
                    },
                    {
                        "username": "Akashdeep_Gupta",
                        "content": "[@abacusrehan](/abacusrehan) yes at any point health should be minimum 1 even before starting."
                    },
                    {
                        "username": "abacusrehan",
                        "content": "too late, but still\\n> The knight has an initial health point represented by a positive integer. If at any point his health point drops to 0 or below, he dies immediately.\\n\\n"
                    },
                    {
                        "username": "god_like",
                        "content": "The description didn\\'t mention if the health could boost exceed the knight\\'s initial health, which would make a whole lot difference if that\\'s considered.\\n\\nImaging this: \\n[[0, 100, -98]] \\n\\nthe answer could be either 1 or 99."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I was also confused, because a typical video game logic would put a cap on the max health you can have.\nHowever, if you just read the solution, you do realize that nothing is mentionned relative to that, that the wording never implies a maximum health cap, and that you would only be making things up by implementing a limit for health.\nBasically, the problem description is correct, we just confused ourselves by making nerdy assumptions. Just gotta learn to read more carefully!"
                    },
                    {
                        "username": "aboulmagd",
                        "content": "So why does bottom up DP work when started from the bottom right cell, and not from the top left cell?\\n\\nAny intuition/visuals would really help.\\nI was only able to solve this problem using the former approach, but why is the DP not symmetrical as with other problems (i.e maximum subarray)?"
                    },
                    {
                        "username": "hebele",
                        "content": "Start from bottom right (not from top left)"
                    }
                ]
            },
            {
                "id": 1565596,
                "content": [
                    {
                        "username": "hhzsls",
                        "content": "Why we fill the table from the bottom right corner to left top?"
                    },
                    {
                        "username": "Msey",
                        "content": "These crafty Australians...!"
                    },
                    {
                        "username": "kmathur68",
                        "content": "If you start from top left to bottom right, then at every point you need to make a decision whether you are going right or down. \\nIn order to do that you need to know what is the minimum health required if you start from i+1,j and i,j+1 positions. \\n\\nYou can actually implement in this way, but they will have to be recursive calls. \\nSee more on here -> https://leetcode.com/problems/dungeon-game/solutions/745340/post-dedicated-to-beginners-of-dp-or-have-no-clue-how-to-start/"
                    },
                    {
                        "username": "clue",
                        "content": "As we all know the typical solution is via DP, which is also the given solution. I can't think of how it can relate to binary search, any ideas?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You could set the lower bound to 0 and the upper bound to 20,000 and than do binary search to see if for a certain amount of health you can find a path. It was what I first thought of, but DP is a much better approach here I think. \\n\\n1970. Last Day Where You Can Still Cross \\nis a somewhat similar problem (also traversing a matrix) where Binary search is useful: https://leetcode.com/problems/last-day-where-you-can-still-cross/"
                    },
                    {
                        "username": "packle",
                        "content": "[@shivasaineelam](/shivasaineelam) \\n\\nneat problem - reminds me of minimum path sum (dp), trapping rain water (variant Dijkstra), and safest path in grid (binary search). the max of the search could probably be tightened with some graph algorithm but above my pay grade. I set it to the sum of all negative values and similarly TLEd"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "we can think of a search space \na particular health and every health greater than that can save the princess \nwe need the minimum one\nbut mine got tle at 42 test case:)"
                    },
                    {
                        "username": "mmontgomery",
                        "content": "Submitting my answer, I\\'m told my code gets the wrong answer for a very simple input `[[0,0]]`, but when I run a custom testcase with this same input, I get the correct answer. What gives? \\n\\n![image](https://assets.leetcode.com/users/mmontgomery/image_1538528784.png)\\n\\nThis isn\\'t the first time this has happened to me on Leetcode problems. "
                    },
                    {
                        "username": "Sivarama_Krishnan_Venktrayan",
                        "content": "I used global static variable without mentioning the scope of the variable.\n\n```\nstatic int minHP = Integer.MAX_VALUE;\n```\n\nAfter i changed it to, \n\n```\npublic int minHP = Integer.MAX_VALUE;\n```\n\n#### Detailed explaination:\n<a>https://support.leetcode.com/hc/en-us/articles/360011834174-I-encountered-Wrong-Answer-Runtime-Error-for-a-specific-test-case-When-I-test-my-code-using-this-test-case-it-produced-the-correct-output-Why-</a>"
                    },
                    {
                        "username": "Bloody_Marry",
                        "content": "you may be using global variables."
                    },
                    {
                        "username": "david500",
                        "content": "I started this question trying to start from the top left, couldn\\'t sovle it and realized it\\'s best to solve it from the bottom right corner instead. Now I\\'m wondering if it\\'s even possible to do it from the top left, if anyone knows, please share"
                    },
                    {
                        "username": "aaryanman05",
                        "content": "[@bizco8](/bizco8)  Too confusing mate. I started from bottom right, and after some brainstorming it went smooth\\n\\n"
                    },
                    {
                        "username": "bizco8",
                        "content": "yes we can do it starting from the top left:\\n \\nclass Solution {\\n  int N;\\n  int M;\\n  Integer[][] cache;\\n  public int calculateMinimumHP(int[][] dungeon) {\\n    N = dungeon.length;\\n    M = dungeon[0].length;\\n    cache = new Integer[N][M];\\n    int res = Math.abs(helper(dungeon, 0, 0));\\n    return  res + 1;\\n  }\\n\\n  public int helper(int[][] dungeon, int i, int j){\\n    if(i >= N || i < 0 || j >= M || j < 0) return Integer.MIN_VALUE;\\n    if(cache[i][j] != null) return cache[i][j];\\n    if(i == N - 1 && j == M - 1){\\n      cache[i][j] = Math.min(0, dungeon[i][j]);\\n      return cache[i][j];\\n    }\\n    int minRight = helper(dungeon, i, j + 1);\\n    int minDown =  helper(dungeon, i + 1, j);\\n    if(minRight != Integer.MIN_VALUE) minRight = Math.min(0, dungeon[i][j] +  minRight);\\n    if(minDown != Integer.MIN_VALUE) minDown = Math.min(0, dungeon[i][j] +  minDown);\\n    cache[i][j] = Math.max(minDown, minRight);\\n    return cache[i][j];\\n  }\\n}"
                    },
                    {
                        "username": "kimeshgupta",
                        "content": "Can we solve this by start from dungeon[0][0] instead of dungeon[row-1][column-1] and get final result at dungeon[row-1][column-1] using same or another dp approach??? Please help."
                    },
                    {
                        "username": "thevirtuoso1973",
                        "content": "As usual I like to provide hints,  albeit this one is slightly less of a hint and more of a reassurance.\\n\\nThis is a pure DP question. The difficulty lies in defining your subproblems/recursion. Some special trick is _not_ necessary to solve the question.\\n\\n### Further Hint:\\nI can\\'t say much more without entering spoiler territory, but just think about how you can figure out the minimum health at (i,j) assuming you have the (i+1,j) and (i,j+1) solutions."
                    },
                    {
                        "username": "bingcoder",
                        "content": "in this case [[100]] , why the correct output is 1? I think it should be 0."
                    },
                    {
                        "username": "Akashdeep_Gupta",
                        "content": "[@abacusrehan](/abacusrehan) yes at any point health should be minimum 1 even before starting."
                    },
                    {
                        "username": "abacusrehan",
                        "content": "too late, but still\\n> The knight has an initial health point represented by a positive integer. If at any point his health point drops to 0 or below, he dies immediately.\\n\\n"
                    },
                    {
                        "username": "god_like",
                        "content": "The description didn\\'t mention if the health could boost exceed the knight\\'s initial health, which would make a whole lot difference if that\\'s considered.\\n\\nImaging this: \\n[[0, 100, -98]] \\n\\nthe answer could be either 1 or 99."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I was also confused, because a typical video game logic would put a cap on the max health you can have.\nHowever, if you just read the solution, you do realize that nothing is mentionned relative to that, that the wording never implies a maximum health cap, and that you would only be making things up by implementing a limit for health.\nBasically, the problem description is correct, we just confused ourselves by making nerdy assumptions. Just gotta learn to read more carefully!"
                    },
                    {
                        "username": "aboulmagd",
                        "content": "So why does bottom up DP work when started from the bottom right cell, and not from the top left cell?\\n\\nAny intuition/visuals would really help.\\nI was only able to solve this problem using the former approach, but why is the DP not symmetrical as with other problems (i.e maximum subarray)?"
                    },
                    {
                        "username": "hebele",
                        "content": "Start from bottom right (not from top left)"
                    }
                ]
            },
            {
                "id": 1566099,
                "content": [
                    {
                        "username": "hhzsls",
                        "content": "Why we fill the table from the bottom right corner to left top?"
                    },
                    {
                        "username": "Msey",
                        "content": "These crafty Australians...!"
                    },
                    {
                        "username": "kmathur68",
                        "content": "If you start from top left to bottom right, then at every point you need to make a decision whether you are going right or down. \\nIn order to do that you need to know what is the minimum health required if you start from i+1,j and i,j+1 positions. \\n\\nYou can actually implement in this way, but they will have to be recursive calls. \\nSee more on here -> https://leetcode.com/problems/dungeon-game/solutions/745340/post-dedicated-to-beginners-of-dp-or-have-no-clue-how-to-start/"
                    },
                    {
                        "username": "clue",
                        "content": "As we all know the typical solution is via DP, which is also the given solution. I can't think of how it can relate to binary search, any ideas?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You could set the lower bound to 0 and the upper bound to 20,000 and than do binary search to see if for a certain amount of health you can find a path. It was what I first thought of, but DP is a much better approach here I think. \\n\\n1970. Last Day Where You Can Still Cross \\nis a somewhat similar problem (also traversing a matrix) where Binary search is useful: https://leetcode.com/problems/last-day-where-you-can-still-cross/"
                    },
                    {
                        "username": "packle",
                        "content": "[@shivasaineelam](/shivasaineelam) \\n\\nneat problem - reminds me of minimum path sum (dp), trapping rain water (variant Dijkstra), and safest path in grid (binary search). the max of the search could probably be tightened with some graph algorithm but above my pay grade. I set it to the sum of all negative values and similarly TLEd"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "we can think of a search space \na particular health and every health greater than that can save the princess \nwe need the minimum one\nbut mine got tle at 42 test case:)"
                    },
                    {
                        "username": "mmontgomery",
                        "content": "Submitting my answer, I\\'m told my code gets the wrong answer for a very simple input `[[0,0]]`, but when I run a custom testcase with this same input, I get the correct answer. What gives? \\n\\n![image](https://assets.leetcode.com/users/mmontgomery/image_1538528784.png)\\n\\nThis isn\\'t the first time this has happened to me on Leetcode problems. "
                    },
                    {
                        "username": "Sivarama_Krishnan_Venktrayan",
                        "content": "I used global static variable without mentioning the scope of the variable.\n\n```\nstatic int minHP = Integer.MAX_VALUE;\n```\n\nAfter i changed it to, \n\n```\npublic int minHP = Integer.MAX_VALUE;\n```\n\n#### Detailed explaination:\n<a>https://support.leetcode.com/hc/en-us/articles/360011834174-I-encountered-Wrong-Answer-Runtime-Error-for-a-specific-test-case-When-I-test-my-code-using-this-test-case-it-produced-the-correct-output-Why-</a>"
                    },
                    {
                        "username": "Bloody_Marry",
                        "content": "you may be using global variables."
                    },
                    {
                        "username": "david500",
                        "content": "I started this question trying to start from the top left, couldn\\'t sovle it and realized it\\'s best to solve it from the bottom right corner instead. Now I\\'m wondering if it\\'s even possible to do it from the top left, if anyone knows, please share"
                    },
                    {
                        "username": "aaryanman05",
                        "content": "[@bizco8](/bizco8)  Too confusing mate. I started from bottom right, and after some brainstorming it went smooth\\n\\n"
                    },
                    {
                        "username": "bizco8",
                        "content": "yes we can do it starting from the top left:\\n \\nclass Solution {\\n  int N;\\n  int M;\\n  Integer[][] cache;\\n  public int calculateMinimumHP(int[][] dungeon) {\\n    N = dungeon.length;\\n    M = dungeon[0].length;\\n    cache = new Integer[N][M];\\n    int res = Math.abs(helper(dungeon, 0, 0));\\n    return  res + 1;\\n  }\\n\\n  public int helper(int[][] dungeon, int i, int j){\\n    if(i >= N || i < 0 || j >= M || j < 0) return Integer.MIN_VALUE;\\n    if(cache[i][j] != null) return cache[i][j];\\n    if(i == N - 1 && j == M - 1){\\n      cache[i][j] = Math.min(0, dungeon[i][j]);\\n      return cache[i][j];\\n    }\\n    int minRight = helper(dungeon, i, j + 1);\\n    int minDown =  helper(dungeon, i + 1, j);\\n    if(minRight != Integer.MIN_VALUE) minRight = Math.min(0, dungeon[i][j] +  minRight);\\n    if(minDown != Integer.MIN_VALUE) minDown = Math.min(0, dungeon[i][j] +  minDown);\\n    cache[i][j] = Math.max(minDown, minRight);\\n    return cache[i][j];\\n  }\\n}"
                    },
                    {
                        "username": "kimeshgupta",
                        "content": "Can we solve this by start from dungeon[0][0] instead of dungeon[row-1][column-1] and get final result at dungeon[row-1][column-1] using same or another dp approach??? Please help."
                    },
                    {
                        "username": "thevirtuoso1973",
                        "content": "As usual I like to provide hints,  albeit this one is slightly less of a hint and more of a reassurance.\\n\\nThis is a pure DP question. The difficulty lies in defining your subproblems/recursion. Some special trick is _not_ necessary to solve the question.\\n\\n### Further Hint:\\nI can\\'t say much more without entering spoiler territory, but just think about how you can figure out the minimum health at (i,j) assuming you have the (i+1,j) and (i,j+1) solutions."
                    },
                    {
                        "username": "bingcoder",
                        "content": "in this case [[100]] , why the correct output is 1? I think it should be 0."
                    },
                    {
                        "username": "Akashdeep_Gupta",
                        "content": "[@abacusrehan](/abacusrehan) yes at any point health should be minimum 1 even before starting."
                    },
                    {
                        "username": "abacusrehan",
                        "content": "too late, but still\\n> The knight has an initial health point represented by a positive integer. If at any point his health point drops to 0 or below, he dies immediately.\\n\\n"
                    },
                    {
                        "username": "god_like",
                        "content": "The description didn\\'t mention if the health could boost exceed the knight\\'s initial health, which would make a whole lot difference if that\\'s considered.\\n\\nImaging this: \\n[[0, 100, -98]] \\n\\nthe answer could be either 1 or 99."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I was also confused, because a typical video game logic would put a cap on the max health you can have.\nHowever, if you just read the solution, you do realize that nothing is mentionned relative to that, that the wording never implies a maximum health cap, and that you would only be making things up by implementing a limit for health.\nBasically, the problem description is correct, we just confused ourselves by making nerdy assumptions. Just gotta learn to read more carefully!"
                    },
                    {
                        "username": "aboulmagd",
                        "content": "So why does bottom up DP work when started from the bottom right cell, and not from the top left cell?\\n\\nAny intuition/visuals would really help.\\nI was only able to solve this problem using the former approach, but why is the DP not symmetrical as with other problems (i.e maximum subarray)?"
                    },
                    {
                        "username": "hebele",
                        "content": "Start from bottom right (not from top left)"
                    }
                ]
            },
            {
                "id": 1568690,
                "content": [
                    {
                        "username": "hhzsls",
                        "content": "Why we fill the table from the bottom right corner to left top?"
                    },
                    {
                        "username": "Msey",
                        "content": "These crafty Australians...!"
                    },
                    {
                        "username": "kmathur68",
                        "content": "If you start from top left to bottom right, then at every point you need to make a decision whether you are going right or down. \\nIn order to do that you need to know what is the minimum health required if you start from i+1,j and i,j+1 positions. \\n\\nYou can actually implement in this way, but they will have to be recursive calls. \\nSee more on here -> https://leetcode.com/problems/dungeon-game/solutions/745340/post-dedicated-to-beginners-of-dp-or-have-no-clue-how-to-start/"
                    },
                    {
                        "username": "clue",
                        "content": "As we all know the typical solution is via DP, which is also the given solution. I can't think of how it can relate to binary search, any ideas?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You could set the lower bound to 0 and the upper bound to 20,000 and than do binary search to see if for a certain amount of health you can find a path. It was what I first thought of, but DP is a much better approach here I think. \\n\\n1970. Last Day Where You Can Still Cross \\nis a somewhat similar problem (also traversing a matrix) where Binary search is useful: https://leetcode.com/problems/last-day-where-you-can-still-cross/"
                    },
                    {
                        "username": "packle",
                        "content": "[@shivasaineelam](/shivasaineelam) \\n\\nneat problem - reminds me of minimum path sum (dp), trapping rain water (variant Dijkstra), and safest path in grid (binary search). the max of the search could probably be tightened with some graph algorithm but above my pay grade. I set it to the sum of all negative values and similarly TLEd"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "we can think of a search space \na particular health and every health greater than that can save the princess \nwe need the minimum one\nbut mine got tle at 42 test case:)"
                    },
                    {
                        "username": "mmontgomery",
                        "content": "Submitting my answer, I\\'m told my code gets the wrong answer for a very simple input `[[0,0]]`, but when I run a custom testcase with this same input, I get the correct answer. What gives? \\n\\n![image](https://assets.leetcode.com/users/mmontgomery/image_1538528784.png)\\n\\nThis isn\\'t the first time this has happened to me on Leetcode problems. "
                    },
                    {
                        "username": "Sivarama_Krishnan_Venktrayan",
                        "content": "I used global static variable without mentioning the scope of the variable.\n\n```\nstatic int minHP = Integer.MAX_VALUE;\n```\n\nAfter i changed it to, \n\n```\npublic int minHP = Integer.MAX_VALUE;\n```\n\n#### Detailed explaination:\n<a>https://support.leetcode.com/hc/en-us/articles/360011834174-I-encountered-Wrong-Answer-Runtime-Error-for-a-specific-test-case-When-I-test-my-code-using-this-test-case-it-produced-the-correct-output-Why-</a>"
                    },
                    {
                        "username": "Bloody_Marry",
                        "content": "you may be using global variables."
                    },
                    {
                        "username": "david500",
                        "content": "I started this question trying to start from the top left, couldn\\'t sovle it and realized it\\'s best to solve it from the bottom right corner instead. Now I\\'m wondering if it\\'s even possible to do it from the top left, if anyone knows, please share"
                    },
                    {
                        "username": "aaryanman05",
                        "content": "[@bizco8](/bizco8)  Too confusing mate. I started from bottom right, and after some brainstorming it went smooth\\n\\n"
                    },
                    {
                        "username": "bizco8",
                        "content": "yes we can do it starting from the top left:\\n \\nclass Solution {\\n  int N;\\n  int M;\\n  Integer[][] cache;\\n  public int calculateMinimumHP(int[][] dungeon) {\\n    N = dungeon.length;\\n    M = dungeon[0].length;\\n    cache = new Integer[N][M];\\n    int res = Math.abs(helper(dungeon, 0, 0));\\n    return  res + 1;\\n  }\\n\\n  public int helper(int[][] dungeon, int i, int j){\\n    if(i >= N || i < 0 || j >= M || j < 0) return Integer.MIN_VALUE;\\n    if(cache[i][j] != null) return cache[i][j];\\n    if(i == N - 1 && j == M - 1){\\n      cache[i][j] = Math.min(0, dungeon[i][j]);\\n      return cache[i][j];\\n    }\\n    int minRight = helper(dungeon, i, j + 1);\\n    int minDown =  helper(dungeon, i + 1, j);\\n    if(minRight != Integer.MIN_VALUE) minRight = Math.min(0, dungeon[i][j] +  minRight);\\n    if(minDown != Integer.MIN_VALUE) minDown = Math.min(0, dungeon[i][j] +  minDown);\\n    cache[i][j] = Math.max(minDown, minRight);\\n    return cache[i][j];\\n  }\\n}"
                    },
                    {
                        "username": "kimeshgupta",
                        "content": "Can we solve this by start from dungeon[0][0] instead of dungeon[row-1][column-1] and get final result at dungeon[row-1][column-1] using same or another dp approach??? Please help."
                    },
                    {
                        "username": "thevirtuoso1973",
                        "content": "As usual I like to provide hints,  albeit this one is slightly less of a hint and more of a reassurance.\\n\\nThis is a pure DP question. The difficulty lies in defining your subproblems/recursion. Some special trick is _not_ necessary to solve the question.\\n\\n### Further Hint:\\nI can\\'t say much more without entering spoiler territory, but just think about how you can figure out the minimum health at (i,j) assuming you have the (i+1,j) and (i,j+1) solutions."
                    },
                    {
                        "username": "bingcoder",
                        "content": "in this case [[100]] , why the correct output is 1? I think it should be 0."
                    },
                    {
                        "username": "Akashdeep_Gupta",
                        "content": "[@abacusrehan](/abacusrehan) yes at any point health should be minimum 1 even before starting."
                    },
                    {
                        "username": "abacusrehan",
                        "content": "too late, but still\\n> The knight has an initial health point represented by a positive integer. If at any point his health point drops to 0 or below, he dies immediately.\\n\\n"
                    },
                    {
                        "username": "god_like",
                        "content": "The description didn\\'t mention if the health could boost exceed the knight\\'s initial health, which would make a whole lot difference if that\\'s considered.\\n\\nImaging this: \\n[[0, 100, -98]] \\n\\nthe answer could be either 1 or 99."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I was also confused, because a typical video game logic would put a cap on the max health you can have.\nHowever, if you just read the solution, you do realize that nothing is mentionned relative to that, that the wording never implies a maximum health cap, and that you would only be making things up by implementing a limit for health.\nBasically, the problem description is correct, we just confused ourselves by making nerdy assumptions. Just gotta learn to read more carefully!"
                    },
                    {
                        "username": "aboulmagd",
                        "content": "So why does bottom up DP work when started from the bottom right cell, and not from the top left cell?\\n\\nAny intuition/visuals would really help.\\nI was only able to solve this problem using the former approach, but why is the DP not symmetrical as with other problems (i.e maximum subarray)?"
                    },
                    {
                        "username": "hebele",
                        "content": "Start from bottom right (not from top left)"
                    }
                ]
            },
            {
                "id": 1566484,
                "content": [
                    {
                        "username": "hhzsls",
                        "content": "Why we fill the table from the bottom right corner to left top?"
                    },
                    {
                        "username": "Msey",
                        "content": "These crafty Australians...!"
                    },
                    {
                        "username": "kmathur68",
                        "content": "If you start from top left to bottom right, then at every point you need to make a decision whether you are going right or down. \\nIn order to do that you need to know what is the minimum health required if you start from i+1,j and i,j+1 positions. \\n\\nYou can actually implement in this way, but they will have to be recursive calls. \\nSee more on here -> https://leetcode.com/problems/dungeon-game/solutions/745340/post-dedicated-to-beginners-of-dp-or-have-no-clue-how-to-start/"
                    },
                    {
                        "username": "clue",
                        "content": "As we all know the typical solution is via DP, which is also the given solution. I can't think of how it can relate to binary search, any ideas?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You could set the lower bound to 0 and the upper bound to 20,000 and than do binary search to see if for a certain amount of health you can find a path. It was what I first thought of, but DP is a much better approach here I think. \\n\\n1970. Last Day Where You Can Still Cross \\nis a somewhat similar problem (also traversing a matrix) where Binary search is useful: https://leetcode.com/problems/last-day-where-you-can-still-cross/"
                    },
                    {
                        "username": "packle",
                        "content": "[@shivasaineelam](/shivasaineelam) \\n\\nneat problem - reminds me of minimum path sum (dp), trapping rain water (variant Dijkstra), and safest path in grid (binary search). the max of the search could probably be tightened with some graph algorithm but above my pay grade. I set it to the sum of all negative values and similarly TLEd"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "we can think of a search space \na particular health and every health greater than that can save the princess \nwe need the minimum one\nbut mine got tle at 42 test case:)"
                    },
                    {
                        "username": "mmontgomery",
                        "content": "Submitting my answer, I\\'m told my code gets the wrong answer for a very simple input `[[0,0]]`, but when I run a custom testcase with this same input, I get the correct answer. What gives? \\n\\n![image](https://assets.leetcode.com/users/mmontgomery/image_1538528784.png)\\n\\nThis isn\\'t the first time this has happened to me on Leetcode problems. "
                    },
                    {
                        "username": "Sivarama_Krishnan_Venktrayan",
                        "content": "I used global static variable without mentioning the scope of the variable.\n\n```\nstatic int minHP = Integer.MAX_VALUE;\n```\n\nAfter i changed it to, \n\n```\npublic int minHP = Integer.MAX_VALUE;\n```\n\n#### Detailed explaination:\n<a>https://support.leetcode.com/hc/en-us/articles/360011834174-I-encountered-Wrong-Answer-Runtime-Error-for-a-specific-test-case-When-I-test-my-code-using-this-test-case-it-produced-the-correct-output-Why-</a>"
                    },
                    {
                        "username": "Bloody_Marry",
                        "content": "you may be using global variables."
                    },
                    {
                        "username": "david500",
                        "content": "I started this question trying to start from the top left, couldn\\'t sovle it and realized it\\'s best to solve it from the bottom right corner instead. Now I\\'m wondering if it\\'s even possible to do it from the top left, if anyone knows, please share"
                    },
                    {
                        "username": "aaryanman05",
                        "content": "[@bizco8](/bizco8)  Too confusing mate. I started from bottom right, and after some brainstorming it went smooth\\n\\n"
                    },
                    {
                        "username": "bizco8",
                        "content": "yes we can do it starting from the top left:\\n \\nclass Solution {\\n  int N;\\n  int M;\\n  Integer[][] cache;\\n  public int calculateMinimumHP(int[][] dungeon) {\\n    N = dungeon.length;\\n    M = dungeon[0].length;\\n    cache = new Integer[N][M];\\n    int res = Math.abs(helper(dungeon, 0, 0));\\n    return  res + 1;\\n  }\\n\\n  public int helper(int[][] dungeon, int i, int j){\\n    if(i >= N || i < 0 || j >= M || j < 0) return Integer.MIN_VALUE;\\n    if(cache[i][j] != null) return cache[i][j];\\n    if(i == N - 1 && j == M - 1){\\n      cache[i][j] = Math.min(0, dungeon[i][j]);\\n      return cache[i][j];\\n    }\\n    int minRight = helper(dungeon, i, j + 1);\\n    int minDown =  helper(dungeon, i + 1, j);\\n    if(minRight != Integer.MIN_VALUE) minRight = Math.min(0, dungeon[i][j] +  minRight);\\n    if(minDown != Integer.MIN_VALUE) minDown = Math.min(0, dungeon[i][j] +  minDown);\\n    cache[i][j] = Math.max(minDown, minRight);\\n    return cache[i][j];\\n  }\\n}"
                    },
                    {
                        "username": "kimeshgupta",
                        "content": "Can we solve this by start from dungeon[0][0] instead of dungeon[row-1][column-1] and get final result at dungeon[row-1][column-1] using same or another dp approach??? Please help."
                    },
                    {
                        "username": "thevirtuoso1973",
                        "content": "As usual I like to provide hints,  albeit this one is slightly less of a hint and more of a reassurance.\\n\\nThis is a pure DP question. The difficulty lies in defining your subproblems/recursion. Some special trick is _not_ necessary to solve the question.\\n\\n### Further Hint:\\nI can\\'t say much more without entering spoiler territory, but just think about how you can figure out the minimum health at (i,j) assuming you have the (i+1,j) and (i,j+1) solutions."
                    },
                    {
                        "username": "bingcoder",
                        "content": "in this case [[100]] , why the correct output is 1? I think it should be 0."
                    },
                    {
                        "username": "Akashdeep_Gupta",
                        "content": "[@abacusrehan](/abacusrehan) yes at any point health should be minimum 1 even before starting."
                    },
                    {
                        "username": "abacusrehan",
                        "content": "too late, but still\\n> The knight has an initial health point represented by a positive integer. If at any point his health point drops to 0 or below, he dies immediately.\\n\\n"
                    },
                    {
                        "username": "god_like",
                        "content": "The description didn\\'t mention if the health could boost exceed the knight\\'s initial health, which would make a whole lot difference if that\\'s considered.\\n\\nImaging this: \\n[[0, 100, -98]] \\n\\nthe answer could be either 1 or 99."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I was also confused, because a typical video game logic would put a cap on the max health you can have.\nHowever, if you just read the solution, you do realize that nothing is mentionned relative to that, that the wording never implies a maximum health cap, and that you would only be making things up by implementing a limit for health.\nBasically, the problem description is correct, we just confused ourselves by making nerdy assumptions. Just gotta learn to read more carefully!"
                    },
                    {
                        "username": "aboulmagd",
                        "content": "So why does bottom up DP work when started from the bottom right cell, and not from the top left cell?\\n\\nAny intuition/visuals would really help.\\nI was only able to solve this problem using the former approach, but why is the DP not symmetrical as with other problems (i.e maximum subarray)?"
                    },
                    {
                        "username": "hebele",
                        "content": "Start from bottom right (not from top left)"
                    }
                ]
            },
            {
                "id": 1568361,
                "content": [
                    {
                        "username": "hhzsls",
                        "content": "Why we fill the table from the bottom right corner to left top?"
                    },
                    {
                        "username": "Msey",
                        "content": "These crafty Australians...!"
                    },
                    {
                        "username": "kmathur68",
                        "content": "If you start from top left to bottom right, then at every point you need to make a decision whether you are going right or down. \\nIn order to do that you need to know what is the minimum health required if you start from i+1,j and i,j+1 positions. \\n\\nYou can actually implement in this way, but they will have to be recursive calls. \\nSee more on here -> https://leetcode.com/problems/dungeon-game/solutions/745340/post-dedicated-to-beginners-of-dp-or-have-no-clue-how-to-start/"
                    },
                    {
                        "username": "clue",
                        "content": "As we all know the typical solution is via DP, which is also the given solution. I can't think of how it can relate to binary search, any ideas?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You could set the lower bound to 0 and the upper bound to 20,000 and than do binary search to see if for a certain amount of health you can find a path. It was what I first thought of, but DP is a much better approach here I think. \\n\\n1970. Last Day Where You Can Still Cross \\nis a somewhat similar problem (also traversing a matrix) where Binary search is useful: https://leetcode.com/problems/last-day-where-you-can-still-cross/"
                    },
                    {
                        "username": "packle",
                        "content": "[@shivasaineelam](/shivasaineelam) \\n\\nneat problem - reminds me of minimum path sum (dp), trapping rain water (variant Dijkstra), and safest path in grid (binary search). the max of the search could probably be tightened with some graph algorithm but above my pay grade. I set it to the sum of all negative values and similarly TLEd"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "we can think of a search space \na particular health and every health greater than that can save the princess \nwe need the minimum one\nbut mine got tle at 42 test case:)"
                    },
                    {
                        "username": "mmontgomery",
                        "content": "Submitting my answer, I\\'m told my code gets the wrong answer for a very simple input `[[0,0]]`, but when I run a custom testcase with this same input, I get the correct answer. What gives? \\n\\n![image](https://assets.leetcode.com/users/mmontgomery/image_1538528784.png)\\n\\nThis isn\\'t the first time this has happened to me on Leetcode problems. "
                    },
                    {
                        "username": "Sivarama_Krishnan_Venktrayan",
                        "content": "I used global static variable without mentioning the scope of the variable.\n\n```\nstatic int minHP = Integer.MAX_VALUE;\n```\n\nAfter i changed it to, \n\n```\npublic int minHP = Integer.MAX_VALUE;\n```\n\n#### Detailed explaination:\n<a>https://support.leetcode.com/hc/en-us/articles/360011834174-I-encountered-Wrong-Answer-Runtime-Error-for-a-specific-test-case-When-I-test-my-code-using-this-test-case-it-produced-the-correct-output-Why-</a>"
                    },
                    {
                        "username": "Bloody_Marry",
                        "content": "you may be using global variables."
                    },
                    {
                        "username": "david500",
                        "content": "I started this question trying to start from the top left, couldn\\'t sovle it and realized it\\'s best to solve it from the bottom right corner instead. Now I\\'m wondering if it\\'s even possible to do it from the top left, if anyone knows, please share"
                    },
                    {
                        "username": "aaryanman05",
                        "content": "[@bizco8](/bizco8)  Too confusing mate. I started from bottom right, and after some brainstorming it went smooth\\n\\n"
                    },
                    {
                        "username": "bizco8",
                        "content": "yes we can do it starting from the top left:\\n \\nclass Solution {\\n  int N;\\n  int M;\\n  Integer[][] cache;\\n  public int calculateMinimumHP(int[][] dungeon) {\\n    N = dungeon.length;\\n    M = dungeon[0].length;\\n    cache = new Integer[N][M];\\n    int res = Math.abs(helper(dungeon, 0, 0));\\n    return  res + 1;\\n  }\\n\\n  public int helper(int[][] dungeon, int i, int j){\\n    if(i >= N || i < 0 || j >= M || j < 0) return Integer.MIN_VALUE;\\n    if(cache[i][j] != null) return cache[i][j];\\n    if(i == N - 1 && j == M - 1){\\n      cache[i][j] = Math.min(0, dungeon[i][j]);\\n      return cache[i][j];\\n    }\\n    int minRight = helper(dungeon, i, j + 1);\\n    int minDown =  helper(dungeon, i + 1, j);\\n    if(minRight != Integer.MIN_VALUE) minRight = Math.min(0, dungeon[i][j] +  minRight);\\n    if(minDown != Integer.MIN_VALUE) minDown = Math.min(0, dungeon[i][j] +  minDown);\\n    cache[i][j] = Math.max(minDown, minRight);\\n    return cache[i][j];\\n  }\\n}"
                    },
                    {
                        "username": "kimeshgupta",
                        "content": "Can we solve this by start from dungeon[0][0] instead of dungeon[row-1][column-1] and get final result at dungeon[row-1][column-1] using same or another dp approach??? Please help."
                    },
                    {
                        "username": "thevirtuoso1973",
                        "content": "As usual I like to provide hints,  albeit this one is slightly less of a hint and more of a reassurance.\\n\\nThis is a pure DP question. The difficulty lies in defining your subproblems/recursion. Some special trick is _not_ necessary to solve the question.\\n\\n### Further Hint:\\nI can\\'t say much more without entering spoiler territory, but just think about how you can figure out the minimum health at (i,j) assuming you have the (i+1,j) and (i,j+1) solutions."
                    },
                    {
                        "username": "bingcoder",
                        "content": "in this case [[100]] , why the correct output is 1? I think it should be 0."
                    },
                    {
                        "username": "Akashdeep_Gupta",
                        "content": "[@abacusrehan](/abacusrehan) yes at any point health should be minimum 1 even before starting."
                    },
                    {
                        "username": "abacusrehan",
                        "content": "too late, but still\\n> The knight has an initial health point represented by a positive integer. If at any point his health point drops to 0 or below, he dies immediately.\\n\\n"
                    },
                    {
                        "username": "god_like",
                        "content": "The description didn\\'t mention if the health could boost exceed the knight\\'s initial health, which would make a whole lot difference if that\\'s considered.\\n\\nImaging this: \\n[[0, 100, -98]] \\n\\nthe answer could be either 1 or 99."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I was also confused, because a typical video game logic would put a cap on the max health you can have.\nHowever, if you just read the solution, you do realize that nothing is mentionned relative to that, that the wording never implies a maximum health cap, and that you would only be making things up by implementing a limit for health.\nBasically, the problem description is correct, we just confused ourselves by making nerdy assumptions. Just gotta learn to read more carefully!"
                    },
                    {
                        "username": "aboulmagd",
                        "content": "So why does bottom up DP work when started from the bottom right cell, and not from the top left cell?\\n\\nAny intuition/visuals would really help.\\nI was only able to solve this problem using the former approach, but why is the DP not symmetrical as with other problems (i.e maximum subarray)?"
                    },
                    {
                        "username": "hebele",
                        "content": "Start from bottom right (not from top left)"
                    }
                ]
            },
            {
                "id": 1571382,
                "content": [
                    {
                        "username": "hhzsls",
                        "content": "Why we fill the table from the bottom right corner to left top?"
                    },
                    {
                        "username": "Msey",
                        "content": "These crafty Australians...!"
                    },
                    {
                        "username": "kmathur68",
                        "content": "If you start from top left to bottom right, then at every point you need to make a decision whether you are going right or down. \\nIn order to do that you need to know what is the minimum health required if you start from i+1,j and i,j+1 positions. \\n\\nYou can actually implement in this way, but they will have to be recursive calls. \\nSee more on here -> https://leetcode.com/problems/dungeon-game/solutions/745340/post-dedicated-to-beginners-of-dp-or-have-no-clue-how-to-start/"
                    },
                    {
                        "username": "clue",
                        "content": "As we all know the typical solution is via DP, which is also the given solution. I can't think of how it can relate to binary search, any ideas?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You could set the lower bound to 0 and the upper bound to 20,000 and than do binary search to see if for a certain amount of health you can find a path. It was what I first thought of, but DP is a much better approach here I think. \\n\\n1970. Last Day Where You Can Still Cross \\nis a somewhat similar problem (also traversing a matrix) where Binary search is useful: https://leetcode.com/problems/last-day-where-you-can-still-cross/"
                    },
                    {
                        "username": "packle",
                        "content": "[@shivasaineelam](/shivasaineelam) \\n\\nneat problem - reminds me of minimum path sum (dp), trapping rain water (variant Dijkstra), and safest path in grid (binary search). the max of the search could probably be tightened with some graph algorithm but above my pay grade. I set it to the sum of all negative values and similarly TLEd"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "we can think of a search space \na particular health and every health greater than that can save the princess \nwe need the minimum one\nbut mine got tle at 42 test case:)"
                    },
                    {
                        "username": "mmontgomery",
                        "content": "Submitting my answer, I\\'m told my code gets the wrong answer for a very simple input `[[0,0]]`, but when I run a custom testcase with this same input, I get the correct answer. What gives? \\n\\n![image](https://assets.leetcode.com/users/mmontgomery/image_1538528784.png)\\n\\nThis isn\\'t the first time this has happened to me on Leetcode problems. "
                    },
                    {
                        "username": "Sivarama_Krishnan_Venktrayan",
                        "content": "I used global static variable without mentioning the scope of the variable.\n\n```\nstatic int minHP = Integer.MAX_VALUE;\n```\n\nAfter i changed it to, \n\n```\npublic int minHP = Integer.MAX_VALUE;\n```\n\n#### Detailed explaination:\n<a>https://support.leetcode.com/hc/en-us/articles/360011834174-I-encountered-Wrong-Answer-Runtime-Error-for-a-specific-test-case-When-I-test-my-code-using-this-test-case-it-produced-the-correct-output-Why-</a>"
                    },
                    {
                        "username": "Bloody_Marry",
                        "content": "you may be using global variables."
                    },
                    {
                        "username": "david500",
                        "content": "I started this question trying to start from the top left, couldn\\'t sovle it and realized it\\'s best to solve it from the bottom right corner instead. Now I\\'m wondering if it\\'s even possible to do it from the top left, if anyone knows, please share"
                    },
                    {
                        "username": "aaryanman05",
                        "content": "[@bizco8](/bizco8)  Too confusing mate. I started from bottom right, and after some brainstorming it went smooth\\n\\n"
                    },
                    {
                        "username": "bizco8",
                        "content": "yes we can do it starting from the top left:\\n \\nclass Solution {\\n  int N;\\n  int M;\\n  Integer[][] cache;\\n  public int calculateMinimumHP(int[][] dungeon) {\\n    N = dungeon.length;\\n    M = dungeon[0].length;\\n    cache = new Integer[N][M];\\n    int res = Math.abs(helper(dungeon, 0, 0));\\n    return  res + 1;\\n  }\\n\\n  public int helper(int[][] dungeon, int i, int j){\\n    if(i >= N || i < 0 || j >= M || j < 0) return Integer.MIN_VALUE;\\n    if(cache[i][j] != null) return cache[i][j];\\n    if(i == N - 1 && j == M - 1){\\n      cache[i][j] = Math.min(0, dungeon[i][j]);\\n      return cache[i][j];\\n    }\\n    int minRight = helper(dungeon, i, j + 1);\\n    int minDown =  helper(dungeon, i + 1, j);\\n    if(minRight != Integer.MIN_VALUE) minRight = Math.min(0, dungeon[i][j] +  minRight);\\n    if(minDown != Integer.MIN_VALUE) minDown = Math.min(0, dungeon[i][j] +  minDown);\\n    cache[i][j] = Math.max(minDown, minRight);\\n    return cache[i][j];\\n  }\\n}"
                    },
                    {
                        "username": "kimeshgupta",
                        "content": "Can we solve this by start from dungeon[0][0] instead of dungeon[row-1][column-1] and get final result at dungeon[row-1][column-1] using same or another dp approach??? Please help."
                    },
                    {
                        "username": "thevirtuoso1973",
                        "content": "As usual I like to provide hints,  albeit this one is slightly less of a hint and more of a reassurance.\\n\\nThis is a pure DP question. The difficulty lies in defining your subproblems/recursion. Some special trick is _not_ necessary to solve the question.\\n\\n### Further Hint:\\nI can\\'t say much more without entering spoiler territory, but just think about how you can figure out the minimum health at (i,j) assuming you have the (i+1,j) and (i,j+1) solutions."
                    },
                    {
                        "username": "bingcoder",
                        "content": "in this case [[100]] , why the correct output is 1? I think it should be 0."
                    },
                    {
                        "username": "Akashdeep_Gupta",
                        "content": "[@abacusrehan](/abacusrehan) yes at any point health should be minimum 1 even before starting."
                    },
                    {
                        "username": "abacusrehan",
                        "content": "too late, but still\\n> The knight has an initial health point represented by a positive integer. If at any point his health point drops to 0 or below, he dies immediately.\\n\\n"
                    },
                    {
                        "username": "god_like",
                        "content": "The description didn\\'t mention if the health could boost exceed the knight\\'s initial health, which would make a whole lot difference if that\\'s considered.\\n\\nImaging this: \\n[[0, 100, -98]] \\n\\nthe answer could be either 1 or 99."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I was also confused, because a typical video game logic would put a cap on the max health you can have.\nHowever, if you just read the solution, you do realize that nothing is mentionned relative to that, that the wording never implies a maximum health cap, and that you would only be making things up by implementing a limit for health.\nBasically, the problem description is correct, we just confused ourselves by making nerdy assumptions. Just gotta learn to read more carefully!"
                    },
                    {
                        "username": "aboulmagd",
                        "content": "So why does bottom up DP work when started from the bottom right cell, and not from the top left cell?\\n\\nAny intuition/visuals would really help.\\nI was only able to solve this problem using the former approach, but why is the DP not symmetrical as with other problems (i.e maximum subarray)?"
                    },
                    {
                        "username": "hebele",
                        "content": "Start from bottom right (not from top left)"
                    }
                ]
            },
            {
                "id": 1570594,
                "content": [
                    {
                        "username": "hhzsls",
                        "content": "Why we fill the table from the bottom right corner to left top?"
                    },
                    {
                        "username": "Msey",
                        "content": "These crafty Australians...!"
                    },
                    {
                        "username": "kmathur68",
                        "content": "If you start from top left to bottom right, then at every point you need to make a decision whether you are going right or down. \\nIn order to do that you need to know what is the minimum health required if you start from i+1,j and i,j+1 positions. \\n\\nYou can actually implement in this way, but they will have to be recursive calls. \\nSee more on here -> https://leetcode.com/problems/dungeon-game/solutions/745340/post-dedicated-to-beginners-of-dp-or-have-no-clue-how-to-start/"
                    },
                    {
                        "username": "clue",
                        "content": "As we all know the typical solution is via DP, which is also the given solution. I can't think of how it can relate to binary search, any ideas?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You could set the lower bound to 0 and the upper bound to 20,000 and than do binary search to see if for a certain amount of health you can find a path. It was what I first thought of, but DP is a much better approach here I think. \\n\\n1970. Last Day Where You Can Still Cross \\nis a somewhat similar problem (also traversing a matrix) where Binary search is useful: https://leetcode.com/problems/last-day-where-you-can-still-cross/"
                    },
                    {
                        "username": "packle",
                        "content": "[@shivasaineelam](/shivasaineelam) \\n\\nneat problem - reminds me of minimum path sum (dp), trapping rain water (variant Dijkstra), and safest path in grid (binary search). the max of the search could probably be tightened with some graph algorithm but above my pay grade. I set it to the sum of all negative values and similarly TLEd"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "we can think of a search space \na particular health and every health greater than that can save the princess \nwe need the minimum one\nbut mine got tle at 42 test case:)"
                    },
                    {
                        "username": "mmontgomery",
                        "content": "Submitting my answer, I\\'m told my code gets the wrong answer for a very simple input `[[0,0]]`, but when I run a custom testcase with this same input, I get the correct answer. What gives? \\n\\n![image](https://assets.leetcode.com/users/mmontgomery/image_1538528784.png)\\n\\nThis isn\\'t the first time this has happened to me on Leetcode problems. "
                    },
                    {
                        "username": "Sivarama_Krishnan_Venktrayan",
                        "content": "I used global static variable without mentioning the scope of the variable.\n\n```\nstatic int minHP = Integer.MAX_VALUE;\n```\n\nAfter i changed it to, \n\n```\npublic int minHP = Integer.MAX_VALUE;\n```\n\n#### Detailed explaination:\n<a>https://support.leetcode.com/hc/en-us/articles/360011834174-I-encountered-Wrong-Answer-Runtime-Error-for-a-specific-test-case-When-I-test-my-code-using-this-test-case-it-produced-the-correct-output-Why-</a>"
                    },
                    {
                        "username": "Bloody_Marry",
                        "content": "you may be using global variables."
                    },
                    {
                        "username": "david500",
                        "content": "I started this question trying to start from the top left, couldn\\'t sovle it and realized it\\'s best to solve it from the bottom right corner instead. Now I\\'m wondering if it\\'s even possible to do it from the top left, if anyone knows, please share"
                    },
                    {
                        "username": "aaryanman05",
                        "content": "[@bizco8](/bizco8)  Too confusing mate. I started from bottom right, and after some brainstorming it went smooth\\n\\n"
                    },
                    {
                        "username": "bizco8",
                        "content": "yes we can do it starting from the top left:\\n \\nclass Solution {\\n  int N;\\n  int M;\\n  Integer[][] cache;\\n  public int calculateMinimumHP(int[][] dungeon) {\\n    N = dungeon.length;\\n    M = dungeon[0].length;\\n    cache = new Integer[N][M];\\n    int res = Math.abs(helper(dungeon, 0, 0));\\n    return  res + 1;\\n  }\\n\\n  public int helper(int[][] dungeon, int i, int j){\\n    if(i >= N || i < 0 || j >= M || j < 0) return Integer.MIN_VALUE;\\n    if(cache[i][j] != null) return cache[i][j];\\n    if(i == N - 1 && j == M - 1){\\n      cache[i][j] = Math.min(0, dungeon[i][j]);\\n      return cache[i][j];\\n    }\\n    int minRight = helper(dungeon, i, j + 1);\\n    int minDown =  helper(dungeon, i + 1, j);\\n    if(minRight != Integer.MIN_VALUE) minRight = Math.min(0, dungeon[i][j] +  minRight);\\n    if(minDown != Integer.MIN_VALUE) minDown = Math.min(0, dungeon[i][j] +  minDown);\\n    cache[i][j] = Math.max(minDown, minRight);\\n    return cache[i][j];\\n  }\\n}"
                    },
                    {
                        "username": "kimeshgupta",
                        "content": "Can we solve this by start from dungeon[0][0] instead of dungeon[row-1][column-1] and get final result at dungeon[row-1][column-1] using same or another dp approach??? Please help."
                    },
                    {
                        "username": "thevirtuoso1973",
                        "content": "As usual I like to provide hints,  albeit this one is slightly less of a hint and more of a reassurance.\\n\\nThis is a pure DP question. The difficulty lies in defining your subproblems/recursion. Some special trick is _not_ necessary to solve the question.\\n\\n### Further Hint:\\nI can\\'t say much more without entering spoiler territory, but just think about how you can figure out the minimum health at (i,j) assuming you have the (i+1,j) and (i,j+1) solutions."
                    },
                    {
                        "username": "bingcoder",
                        "content": "in this case [[100]] , why the correct output is 1? I think it should be 0."
                    },
                    {
                        "username": "Akashdeep_Gupta",
                        "content": "[@abacusrehan](/abacusrehan) yes at any point health should be minimum 1 even before starting."
                    },
                    {
                        "username": "abacusrehan",
                        "content": "too late, but still\\n> The knight has an initial health point represented by a positive integer. If at any point his health point drops to 0 or below, he dies immediately.\\n\\n"
                    },
                    {
                        "username": "god_like",
                        "content": "The description didn\\'t mention if the health could boost exceed the knight\\'s initial health, which would make a whole lot difference if that\\'s considered.\\n\\nImaging this: \\n[[0, 100, -98]] \\n\\nthe answer could be either 1 or 99."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I was also confused, because a typical video game logic would put a cap on the max health you can have.\nHowever, if you just read the solution, you do realize that nothing is mentionned relative to that, that the wording never implies a maximum health cap, and that you would only be making things up by implementing a limit for health.\nBasically, the problem description is correct, we just confused ourselves by making nerdy assumptions. Just gotta learn to read more carefully!"
                    },
                    {
                        "username": "aboulmagd",
                        "content": "So why does bottom up DP work when started from the bottom right cell, and not from the top left cell?\\n\\nAny intuition/visuals would really help.\\nI was only able to solve this problem using the former approach, but why is the DP not symmetrical as with other problems (i.e maximum subarray)?"
                    },
                    {
                        "username": "hebele",
                        "content": "Start from bottom right (not from top left)"
                    }
                ]
            },
            {
                "id": 1573955,
                "content": [
                    {
                        "username": "hhzsls",
                        "content": "Why we fill the table from the bottom right corner to left top?"
                    },
                    {
                        "username": "Msey",
                        "content": "These crafty Australians...!"
                    },
                    {
                        "username": "kmathur68",
                        "content": "If you start from top left to bottom right, then at every point you need to make a decision whether you are going right or down. \\nIn order to do that you need to know what is the minimum health required if you start from i+1,j and i,j+1 positions. \\n\\nYou can actually implement in this way, but they will have to be recursive calls. \\nSee more on here -> https://leetcode.com/problems/dungeon-game/solutions/745340/post-dedicated-to-beginners-of-dp-or-have-no-clue-how-to-start/"
                    },
                    {
                        "username": "clue",
                        "content": "As we all know the typical solution is via DP, which is also the given solution. I can't think of how it can relate to binary search, any ideas?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You could set the lower bound to 0 and the upper bound to 20,000 and than do binary search to see if for a certain amount of health you can find a path. It was what I first thought of, but DP is a much better approach here I think. \\n\\n1970. Last Day Where You Can Still Cross \\nis a somewhat similar problem (also traversing a matrix) where Binary search is useful: https://leetcode.com/problems/last-day-where-you-can-still-cross/"
                    },
                    {
                        "username": "packle",
                        "content": "[@shivasaineelam](/shivasaineelam) \\n\\nneat problem - reminds me of minimum path sum (dp), trapping rain water (variant Dijkstra), and safest path in grid (binary search). the max of the search could probably be tightened with some graph algorithm but above my pay grade. I set it to the sum of all negative values and similarly TLEd"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "we can think of a search space \na particular health and every health greater than that can save the princess \nwe need the minimum one\nbut mine got tle at 42 test case:)"
                    },
                    {
                        "username": "mmontgomery",
                        "content": "Submitting my answer, I\\'m told my code gets the wrong answer for a very simple input `[[0,0]]`, but when I run a custom testcase with this same input, I get the correct answer. What gives? \\n\\n![image](https://assets.leetcode.com/users/mmontgomery/image_1538528784.png)\\n\\nThis isn\\'t the first time this has happened to me on Leetcode problems. "
                    },
                    {
                        "username": "Sivarama_Krishnan_Venktrayan",
                        "content": "I used global static variable without mentioning the scope of the variable.\n\n```\nstatic int minHP = Integer.MAX_VALUE;\n```\n\nAfter i changed it to, \n\n```\npublic int minHP = Integer.MAX_VALUE;\n```\n\n#### Detailed explaination:\n<a>https://support.leetcode.com/hc/en-us/articles/360011834174-I-encountered-Wrong-Answer-Runtime-Error-for-a-specific-test-case-When-I-test-my-code-using-this-test-case-it-produced-the-correct-output-Why-</a>"
                    },
                    {
                        "username": "Bloody_Marry",
                        "content": "you may be using global variables."
                    },
                    {
                        "username": "david500",
                        "content": "I started this question trying to start from the top left, couldn\\'t sovle it and realized it\\'s best to solve it from the bottom right corner instead. Now I\\'m wondering if it\\'s even possible to do it from the top left, if anyone knows, please share"
                    },
                    {
                        "username": "aaryanman05",
                        "content": "[@bizco8](/bizco8)  Too confusing mate. I started from bottom right, and after some brainstorming it went smooth\\n\\n"
                    },
                    {
                        "username": "bizco8",
                        "content": "yes we can do it starting from the top left:\\n \\nclass Solution {\\n  int N;\\n  int M;\\n  Integer[][] cache;\\n  public int calculateMinimumHP(int[][] dungeon) {\\n    N = dungeon.length;\\n    M = dungeon[0].length;\\n    cache = new Integer[N][M];\\n    int res = Math.abs(helper(dungeon, 0, 0));\\n    return  res + 1;\\n  }\\n\\n  public int helper(int[][] dungeon, int i, int j){\\n    if(i >= N || i < 0 || j >= M || j < 0) return Integer.MIN_VALUE;\\n    if(cache[i][j] != null) return cache[i][j];\\n    if(i == N - 1 && j == M - 1){\\n      cache[i][j] = Math.min(0, dungeon[i][j]);\\n      return cache[i][j];\\n    }\\n    int minRight = helper(dungeon, i, j + 1);\\n    int minDown =  helper(dungeon, i + 1, j);\\n    if(minRight != Integer.MIN_VALUE) minRight = Math.min(0, dungeon[i][j] +  minRight);\\n    if(minDown != Integer.MIN_VALUE) minDown = Math.min(0, dungeon[i][j] +  minDown);\\n    cache[i][j] = Math.max(minDown, minRight);\\n    return cache[i][j];\\n  }\\n}"
                    },
                    {
                        "username": "kimeshgupta",
                        "content": "Can we solve this by start from dungeon[0][0] instead of dungeon[row-1][column-1] and get final result at dungeon[row-1][column-1] using same or another dp approach??? Please help."
                    },
                    {
                        "username": "thevirtuoso1973",
                        "content": "As usual I like to provide hints,  albeit this one is slightly less of a hint and more of a reassurance.\\n\\nThis is a pure DP question. The difficulty lies in defining your subproblems/recursion. Some special trick is _not_ necessary to solve the question.\\n\\n### Further Hint:\\nI can\\'t say much more without entering spoiler territory, but just think about how you can figure out the minimum health at (i,j) assuming you have the (i+1,j) and (i,j+1) solutions."
                    },
                    {
                        "username": "bingcoder",
                        "content": "in this case [[100]] , why the correct output is 1? I think it should be 0."
                    },
                    {
                        "username": "Akashdeep_Gupta",
                        "content": "[@abacusrehan](/abacusrehan) yes at any point health should be minimum 1 even before starting."
                    },
                    {
                        "username": "abacusrehan",
                        "content": "too late, but still\\n> The knight has an initial health point represented by a positive integer. If at any point his health point drops to 0 or below, he dies immediately.\\n\\n"
                    },
                    {
                        "username": "god_like",
                        "content": "The description didn\\'t mention if the health could boost exceed the knight\\'s initial health, which would make a whole lot difference if that\\'s considered.\\n\\nImaging this: \\n[[0, 100, -98]] \\n\\nthe answer could be either 1 or 99."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I was also confused, because a typical video game logic would put a cap on the max health you can have.\nHowever, if you just read the solution, you do realize that nothing is mentionned relative to that, that the wording never implies a maximum health cap, and that you would only be making things up by implementing a limit for health.\nBasically, the problem description is correct, we just confused ourselves by making nerdy assumptions. Just gotta learn to read more carefully!"
                    },
                    {
                        "username": "aboulmagd",
                        "content": "So why does bottom up DP work when started from the bottom right cell, and not from the top left cell?\\n\\nAny intuition/visuals would really help.\\nI was only able to solve this problem using the former approach, but why is the DP not symmetrical as with other problems (i.e maximum subarray)?"
                    },
                    {
                        "username": "hebele",
                        "content": "Start from bottom right (not from top left)"
                    }
                ]
            },
            {
                "id": 1568998,
                "content": [
                    {
                        "username": "hhzsls",
                        "content": "Why we fill the table from the bottom right corner to left top?"
                    },
                    {
                        "username": "Msey",
                        "content": "These crafty Australians...!"
                    },
                    {
                        "username": "kmathur68",
                        "content": "If you start from top left to bottom right, then at every point you need to make a decision whether you are going right or down. \\nIn order to do that you need to know what is the minimum health required if you start from i+1,j and i,j+1 positions. \\n\\nYou can actually implement in this way, but they will have to be recursive calls. \\nSee more on here -> https://leetcode.com/problems/dungeon-game/solutions/745340/post-dedicated-to-beginners-of-dp-or-have-no-clue-how-to-start/"
                    },
                    {
                        "username": "clue",
                        "content": "As we all know the typical solution is via DP, which is also the given solution. I can't think of how it can relate to binary search, any ideas?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You could set the lower bound to 0 and the upper bound to 20,000 and than do binary search to see if for a certain amount of health you can find a path. It was what I first thought of, but DP is a much better approach here I think. \\n\\n1970. Last Day Where You Can Still Cross \\nis a somewhat similar problem (also traversing a matrix) where Binary search is useful: https://leetcode.com/problems/last-day-where-you-can-still-cross/"
                    },
                    {
                        "username": "packle",
                        "content": "[@shivasaineelam](/shivasaineelam) \\n\\nneat problem - reminds me of minimum path sum (dp), trapping rain water (variant Dijkstra), and safest path in grid (binary search). the max of the search could probably be tightened with some graph algorithm but above my pay grade. I set it to the sum of all negative values and similarly TLEd"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "we can think of a search space \na particular health and every health greater than that can save the princess \nwe need the minimum one\nbut mine got tle at 42 test case:)"
                    },
                    {
                        "username": "mmontgomery",
                        "content": "Submitting my answer, I\\'m told my code gets the wrong answer for a very simple input `[[0,0]]`, but when I run a custom testcase with this same input, I get the correct answer. What gives? \\n\\n![image](https://assets.leetcode.com/users/mmontgomery/image_1538528784.png)\\n\\nThis isn\\'t the first time this has happened to me on Leetcode problems. "
                    },
                    {
                        "username": "Sivarama_Krishnan_Venktrayan",
                        "content": "I used global static variable without mentioning the scope of the variable.\n\n```\nstatic int minHP = Integer.MAX_VALUE;\n```\n\nAfter i changed it to, \n\n```\npublic int minHP = Integer.MAX_VALUE;\n```\n\n#### Detailed explaination:\n<a>https://support.leetcode.com/hc/en-us/articles/360011834174-I-encountered-Wrong-Answer-Runtime-Error-for-a-specific-test-case-When-I-test-my-code-using-this-test-case-it-produced-the-correct-output-Why-</a>"
                    },
                    {
                        "username": "Bloody_Marry",
                        "content": "you may be using global variables."
                    },
                    {
                        "username": "david500",
                        "content": "I started this question trying to start from the top left, couldn\\'t sovle it and realized it\\'s best to solve it from the bottom right corner instead. Now I\\'m wondering if it\\'s even possible to do it from the top left, if anyone knows, please share"
                    },
                    {
                        "username": "aaryanman05",
                        "content": "[@bizco8](/bizco8)  Too confusing mate. I started from bottom right, and after some brainstorming it went smooth\\n\\n"
                    },
                    {
                        "username": "bizco8",
                        "content": "yes we can do it starting from the top left:\\n \\nclass Solution {\\n  int N;\\n  int M;\\n  Integer[][] cache;\\n  public int calculateMinimumHP(int[][] dungeon) {\\n    N = dungeon.length;\\n    M = dungeon[0].length;\\n    cache = new Integer[N][M];\\n    int res = Math.abs(helper(dungeon, 0, 0));\\n    return  res + 1;\\n  }\\n\\n  public int helper(int[][] dungeon, int i, int j){\\n    if(i >= N || i < 0 || j >= M || j < 0) return Integer.MIN_VALUE;\\n    if(cache[i][j] != null) return cache[i][j];\\n    if(i == N - 1 && j == M - 1){\\n      cache[i][j] = Math.min(0, dungeon[i][j]);\\n      return cache[i][j];\\n    }\\n    int minRight = helper(dungeon, i, j + 1);\\n    int minDown =  helper(dungeon, i + 1, j);\\n    if(minRight != Integer.MIN_VALUE) minRight = Math.min(0, dungeon[i][j] +  minRight);\\n    if(minDown != Integer.MIN_VALUE) minDown = Math.min(0, dungeon[i][j] +  minDown);\\n    cache[i][j] = Math.max(minDown, minRight);\\n    return cache[i][j];\\n  }\\n}"
                    },
                    {
                        "username": "kimeshgupta",
                        "content": "Can we solve this by start from dungeon[0][0] instead of dungeon[row-1][column-1] and get final result at dungeon[row-1][column-1] using same or another dp approach??? Please help."
                    },
                    {
                        "username": "thevirtuoso1973",
                        "content": "As usual I like to provide hints,  albeit this one is slightly less of a hint and more of a reassurance.\\n\\nThis is a pure DP question. The difficulty lies in defining your subproblems/recursion. Some special trick is _not_ necessary to solve the question.\\n\\n### Further Hint:\\nI can\\'t say much more without entering spoiler territory, but just think about how you can figure out the minimum health at (i,j) assuming you have the (i+1,j) and (i,j+1) solutions."
                    },
                    {
                        "username": "bingcoder",
                        "content": "in this case [[100]] , why the correct output is 1? I think it should be 0."
                    },
                    {
                        "username": "Akashdeep_Gupta",
                        "content": "[@abacusrehan](/abacusrehan) yes at any point health should be minimum 1 even before starting."
                    },
                    {
                        "username": "abacusrehan",
                        "content": "too late, but still\\n> The knight has an initial health point represented by a positive integer. If at any point his health point drops to 0 or below, he dies immediately.\\n\\n"
                    },
                    {
                        "username": "god_like",
                        "content": "The description didn\\'t mention if the health could boost exceed the knight\\'s initial health, which would make a whole lot difference if that\\'s considered.\\n\\nImaging this: \\n[[0, 100, -98]] \\n\\nthe answer could be either 1 or 99."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I was also confused, because a typical video game logic would put a cap on the max health you can have.\nHowever, if you just read the solution, you do realize that nothing is mentionned relative to that, that the wording never implies a maximum health cap, and that you would only be making things up by implementing a limit for health.\nBasically, the problem description is correct, we just confused ourselves by making nerdy assumptions. Just gotta learn to read more carefully!"
                    },
                    {
                        "username": "aboulmagd",
                        "content": "So why does bottom up DP work when started from the bottom right cell, and not from the top left cell?\\n\\nAny intuition/visuals would really help.\\nI was only able to solve this problem using the former approach, but why is the DP not symmetrical as with other problems (i.e maximum subarray)?"
                    },
                    {
                        "username": "hebele",
                        "content": "Start from bottom right (not from top left)"
                    }
                ]
            },
            {
                "id": 2069973,
                "content": [
                    {
                        "username": "jrmurro",
                        "content": "How does [[-3,5]] require a mininum health of 4 when we can just use a health value of 1 from the beginning?"
                    },
                    {
                        "username": "jrmurro",
                        "content": "[@Akashdeep_Gupta](/Akashdeep_Gupta) That makes sense!"
                    },
                    {
                        "username": "Akashdeep_Gupta",
                        "content": "if you start with health =1 and got to -3 then your health will become -2 (-3+1) hence you die, because every time the health should be greater than 0 that is minimum 1, so to tackle -3 you have to start with health =4. so when you land on -3 your health will be 1 (-3+4) means you are alive."
                    },
                    {
                        "username": "makSyak",
                        "content": "My first hard :)"
                    },
                    {
                        "username": "docentovich",
                        "content": "We must start from the end because we calculate the starting position parameter. The health parameter from which we should start, not end. We don\\'t know the beginning. We know that as a result of the path sum, the health at the end must be greater than or equal to 1. (The additional condition that the health should not be zeroed on the way is essentially an additional condition). We do not know from which parameter the health should start. We minimize the health parameter to the start. Therefore, we need to calculate it to the start because the already calculated values will be closer to the end from the current position."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "After hitting a wall when trying to build dp from the start to the end, I was very surprised that doing it the other way just magically solves all problem. However, I am still confused how you could clearly realize that right away when looking at the problem?\\nCould anyone explain me what is the characterstic of this problem that makes it a \"one-way DP\"? Like what general property does this problem have that makes it easier to solve from one way rather than the other?"
                    },
                    {
                        "username": "ttaylor27",
                        "content": "For me when solving, what led me to immediately realize that I had to start at the bottom right (end) was the idea that I needed to figure out the minimum health needed to reach the end at every given point. The easiest way to build up for the whole traversal is to start at the end, where you know the minimum health you'd need for the final square is simply however much is required for that one square. From there, as you traverse, you can find the minimum from any previous paths you have built, and eventually your minimum will be at the start once you finish your traversal. Basically, start with the minimum health required for the end square, then find the minimum required for the last 2 squares, then last 3 squares, etc. and eventually you will be back at the start with your path fully constructed. (For clarity, I used a tabulation method)"
                    },
                    {
                        "username": "Manashi",
                        "content": "You need to maintain both minimum values and sum along a path, which is not possible in O(NM). O(NM * log(INT_MAX)) will work, which uses binary search on the knight\\'s initial health, and checking if the knight can reach the princess with that initial health, and choosing left or right branch of binary search based on that."
                    },
                    {
                        "username": "rabeeh",
                        "content": "Hi,\\nfor me, it is always hard to think bottom-up, and i am looking for a top-down DP solution for this question, I could not find one in the discussions, I wonder if one could submit one, I tried to do it myself, however, for me it gets timelimit, I wonder if one could submit  a working top-down DP version as reference for others?\\n\\nthanks"
                    },
                    {
                        "username": "FinalTheory",
                        "content": "Is there any rules that I should comply with? For example, how the input data is generated and so on?"
                    },
                    {
                        "username": "xu4",
                        "content": "otherwise, in the example, if the knight has 5 initially and he can move right->right->down->up->down->down"
                    },
                    {
                        "username": "tushargupta9800",
                        "content": "![image](https://assets.leetcode.com/users/images/d82d73af-4f79-4a2f-814b-b38542a17c1e_1634581073.285247.png)\\n\\nPassed all test cases still TLE"
                    },
                    {
                        "username": "daniel_9650",
                        "content": "From the discussion it seems the accepted approach is DP; I first started to approach this with DFS, modeling the grid as a directed graph and trying to find the min cost path from top left to bottom right. I am still trying to see if DFS is a sensible approach or a dead end.\\n\\nDid anyone else try to do this using some method besides DP/recursion?"
                    }
                ]
            },
            {
                "id": 1925915,
                "content": [
                    {
                        "username": "jrmurro",
                        "content": "How does [[-3,5]] require a mininum health of 4 when we can just use a health value of 1 from the beginning?"
                    },
                    {
                        "username": "jrmurro",
                        "content": "[@Akashdeep_Gupta](/Akashdeep_Gupta) That makes sense!"
                    },
                    {
                        "username": "Akashdeep_Gupta",
                        "content": "if you start with health =1 and got to -3 then your health will become -2 (-3+1) hence you die, because every time the health should be greater than 0 that is minimum 1, so to tackle -3 you have to start with health =4. so when you land on -3 your health will be 1 (-3+4) means you are alive."
                    },
                    {
                        "username": "makSyak",
                        "content": "My first hard :)"
                    },
                    {
                        "username": "docentovich",
                        "content": "We must start from the end because we calculate the starting position parameter. The health parameter from which we should start, not end. We don\\'t know the beginning. We know that as a result of the path sum, the health at the end must be greater than or equal to 1. (The additional condition that the health should not be zeroed on the way is essentially an additional condition). We do not know from which parameter the health should start. We minimize the health parameter to the start. Therefore, we need to calculate it to the start because the already calculated values will be closer to the end from the current position."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "After hitting a wall when trying to build dp from the start to the end, I was very surprised that doing it the other way just magically solves all problem. However, I am still confused how you could clearly realize that right away when looking at the problem?\\nCould anyone explain me what is the characterstic of this problem that makes it a \"one-way DP\"? Like what general property does this problem have that makes it easier to solve from one way rather than the other?"
                    },
                    {
                        "username": "ttaylor27",
                        "content": "For me when solving, what led me to immediately realize that I had to start at the bottom right (end) was the idea that I needed to figure out the minimum health needed to reach the end at every given point. The easiest way to build up for the whole traversal is to start at the end, where you know the minimum health you'd need for the final square is simply however much is required for that one square. From there, as you traverse, you can find the minimum from any previous paths you have built, and eventually your minimum will be at the start once you finish your traversal. Basically, start with the minimum health required for the end square, then find the minimum required for the last 2 squares, then last 3 squares, etc. and eventually you will be back at the start with your path fully constructed. (For clarity, I used a tabulation method)"
                    },
                    {
                        "username": "Manashi",
                        "content": "You need to maintain both minimum values and sum along a path, which is not possible in O(NM). O(NM * log(INT_MAX)) will work, which uses binary search on the knight\\'s initial health, and checking if the knight can reach the princess with that initial health, and choosing left or right branch of binary search based on that."
                    },
                    {
                        "username": "rabeeh",
                        "content": "Hi,\\nfor me, it is always hard to think bottom-up, and i am looking for a top-down DP solution for this question, I could not find one in the discussions, I wonder if one could submit one, I tried to do it myself, however, for me it gets timelimit, I wonder if one could submit  a working top-down DP version as reference for others?\\n\\nthanks"
                    },
                    {
                        "username": "FinalTheory",
                        "content": "Is there any rules that I should comply with? For example, how the input data is generated and so on?"
                    },
                    {
                        "username": "xu4",
                        "content": "otherwise, in the example, if the knight has 5 initially and he can move right->right->down->up->down->down"
                    },
                    {
                        "username": "tushargupta9800",
                        "content": "![image](https://assets.leetcode.com/users/images/d82d73af-4f79-4a2f-814b-b38542a17c1e_1634581073.285247.png)\\n\\nPassed all test cases still TLE"
                    },
                    {
                        "username": "daniel_9650",
                        "content": "From the discussion it seems the accepted approach is DP; I first started to approach this with DFS, modeling the grid as a directed graph and trying to find the min cost path from top left to bottom right. I am still trying to see if DFS is a sensible approach or a dead end.\\n\\nDid anyone else try to do this using some method besides DP/recursion?"
                    }
                ]
            },
            {
                "id": 1870212,
                "content": [
                    {
                        "username": "jrmurro",
                        "content": "How does [[-3,5]] require a mininum health of 4 when we can just use a health value of 1 from the beginning?"
                    },
                    {
                        "username": "jrmurro",
                        "content": "[@Akashdeep_Gupta](/Akashdeep_Gupta) That makes sense!"
                    },
                    {
                        "username": "Akashdeep_Gupta",
                        "content": "if you start with health =1 and got to -3 then your health will become -2 (-3+1) hence you die, because every time the health should be greater than 0 that is minimum 1, so to tackle -3 you have to start with health =4. so when you land on -3 your health will be 1 (-3+4) means you are alive."
                    },
                    {
                        "username": "makSyak",
                        "content": "My first hard :)"
                    },
                    {
                        "username": "docentovich",
                        "content": "We must start from the end because we calculate the starting position parameter. The health parameter from which we should start, not end. We don\\'t know the beginning. We know that as a result of the path sum, the health at the end must be greater than or equal to 1. (The additional condition that the health should not be zeroed on the way is essentially an additional condition). We do not know from which parameter the health should start. We minimize the health parameter to the start. Therefore, we need to calculate it to the start because the already calculated values will be closer to the end from the current position."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "After hitting a wall when trying to build dp from the start to the end, I was very surprised that doing it the other way just magically solves all problem. However, I am still confused how you could clearly realize that right away when looking at the problem?\\nCould anyone explain me what is the characterstic of this problem that makes it a \"one-way DP\"? Like what general property does this problem have that makes it easier to solve from one way rather than the other?"
                    },
                    {
                        "username": "ttaylor27",
                        "content": "For me when solving, what led me to immediately realize that I had to start at the bottom right (end) was the idea that I needed to figure out the minimum health needed to reach the end at every given point. The easiest way to build up for the whole traversal is to start at the end, where you know the minimum health you'd need for the final square is simply however much is required for that one square. From there, as you traverse, you can find the minimum from any previous paths you have built, and eventually your minimum will be at the start once you finish your traversal. Basically, start with the minimum health required for the end square, then find the minimum required for the last 2 squares, then last 3 squares, etc. and eventually you will be back at the start with your path fully constructed. (For clarity, I used a tabulation method)"
                    },
                    {
                        "username": "Manashi",
                        "content": "You need to maintain both minimum values and sum along a path, which is not possible in O(NM). O(NM * log(INT_MAX)) will work, which uses binary search on the knight\\'s initial health, and checking if the knight can reach the princess with that initial health, and choosing left or right branch of binary search based on that."
                    },
                    {
                        "username": "rabeeh",
                        "content": "Hi,\\nfor me, it is always hard to think bottom-up, and i am looking for a top-down DP solution for this question, I could not find one in the discussions, I wonder if one could submit one, I tried to do it myself, however, for me it gets timelimit, I wonder if one could submit  a working top-down DP version as reference for others?\\n\\nthanks"
                    },
                    {
                        "username": "FinalTheory",
                        "content": "Is there any rules that I should comply with? For example, how the input data is generated and so on?"
                    },
                    {
                        "username": "xu4",
                        "content": "otherwise, in the example, if the knight has 5 initially and he can move right->right->down->up->down->down"
                    },
                    {
                        "username": "tushargupta9800",
                        "content": "![image](https://assets.leetcode.com/users/images/d82d73af-4f79-4a2f-814b-b38542a17c1e_1634581073.285247.png)\\n\\nPassed all test cases still TLE"
                    },
                    {
                        "username": "daniel_9650",
                        "content": "From the discussion it seems the accepted approach is DP; I first started to approach this with DFS, modeling the grid as a directed graph and trying to find the min cost path from top left to bottom right. I am still trying to see if DFS is a sensible approach or a dead end.\\n\\nDid anyone else try to do this using some method besides DP/recursion?"
                    }
                ]
            },
            {
                "id": 1862120,
                "content": [
                    {
                        "username": "jrmurro",
                        "content": "How does [[-3,5]] require a mininum health of 4 when we can just use a health value of 1 from the beginning?"
                    },
                    {
                        "username": "jrmurro",
                        "content": "[@Akashdeep_Gupta](/Akashdeep_Gupta) That makes sense!"
                    },
                    {
                        "username": "Akashdeep_Gupta",
                        "content": "if you start with health =1 and got to -3 then your health will become -2 (-3+1) hence you die, because every time the health should be greater than 0 that is minimum 1, so to tackle -3 you have to start with health =4. so when you land on -3 your health will be 1 (-3+4) means you are alive."
                    },
                    {
                        "username": "makSyak",
                        "content": "My first hard :)"
                    },
                    {
                        "username": "docentovich",
                        "content": "We must start from the end because we calculate the starting position parameter. The health parameter from which we should start, not end. We don\\'t know the beginning. We know that as a result of the path sum, the health at the end must be greater than or equal to 1. (The additional condition that the health should not be zeroed on the way is essentially an additional condition). We do not know from which parameter the health should start. We minimize the health parameter to the start. Therefore, we need to calculate it to the start because the already calculated values will be closer to the end from the current position."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "After hitting a wall when trying to build dp from the start to the end, I was very surprised that doing it the other way just magically solves all problem. However, I am still confused how you could clearly realize that right away when looking at the problem?\\nCould anyone explain me what is the characterstic of this problem that makes it a \"one-way DP\"? Like what general property does this problem have that makes it easier to solve from one way rather than the other?"
                    },
                    {
                        "username": "ttaylor27",
                        "content": "For me when solving, what led me to immediately realize that I had to start at the bottom right (end) was the idea that I needed to figure out the minimum health needed to reach the end at every given point. The easiest way to build up for the whole traversal is to start at the end, where you know the minimum health you'd need for the final square is simply however much is required for that one square. From there, as you traverse, you can find the minimum from any previous paths you have built, and eventually your minimum will be at the start once you finish your traversal. Basically, start with the minimum health required for the end square, then find the minimum required for the last 2 squares, then last 3 squares, etc. and eventually you will be back at the start with your path fully constructed. (For clarity, I used a tabulation method)"
                    },
                    {
                        "username": "Manashi",
                        "content": "You need to maintain both minimum values and sum along a path, which is not possible in O(NM). O(NM * log(INT_MAX)) will work, which uses binary search on the knight\\'s initial health, and checking if the knight can reach the princess with that initial health, and choosing left or right branch of binary search based on that."
                    },
                    {
                        "username": "rabeeh",
                        "content": "Hi,\\nfor me, it is always hard to think bottom-up, and i am looking for a top-down DP solution for this question, I could not find one in the discussions, I wonder if one could submit one, I tried to do it myself, however, for me it gets timelimit, I wonder if one could submit  a working top-down DP version as reference for others?\\n\\nthanks"
                    },
                    {
                        "username": "FinalTheory",
                        "content": "Is there any rules that I should comply with? For example, how the input data is generated and so on?"
                    },
                    {
                        "username": "xu4",
                        "content": "otherwise, in the example, if the knight has 5 initially and he can move right->right->down->up->down->down"
                    },
                    {
                        "username": "tushargupta9800",
                        "content": "![image](https://assets.leetcode.com/users/images/d82d73af-4f79-4a2f-814b-b38542a17c1e_1634581073.285247.png)\\n\\nPassed all test cases still TLE"
                    },
                    {
                        "username": "daniel_9650",
                        "content": "From the discussion it seems the accepted approach is DP; I first started to approach this with DFS, modeling the grid as a directed graph and trying to find the min cost path from top left to bottom right. I am still trying to see if DFS is a sensible approach or a dead end.\\n\\nDid anyone else try to do this using some method besides DP/recursion?"
                    }
                ]
            },
            {
                "id": 1573024,
                "content": [
                    {
                        "username": "jrmurro",
                        "content": "How does [[-3,5]] require a mininum health of 4 when we can just use a health value of 1 from the beginning?"
                    },
                    {
                        "username": "jrmurro",
                        "content": "[@Akashdeep_Gupta](/Akashdeep_Gupta) That makes sense!"
                    },
                    {
                        "username": "Akashdeep_Gupta",
                        "content": "if you start with health =1 and got to -3 then your health will become -2 (-3+1) hence you die, because every time the health should be greater than 0 that is minimum 1, so to tackle -3 you have to start with health =4. so when you land on -3 your health will be 1 (-3+4) means you are alive."
                    },
                    {
                        "username": "makSyak",
                        "content": "My first hard :)"
                    },
                    {
                        "username": "docentovich",
                        "content": "We must start from the end because we calculate the starting position parameter. The health parameter from which we should start, not end. We don\\'t know the beginning. We know that as a result of the path sum, the health at the end must be greater than or equal to 1. (The additional condition that the health should not be zeroed on the way is essentially an additional condition). We do not know from which parameter the health should start. We minimize the health parameter to the start. Therefore, we need to calculate it to the start because the already calculated values will be closer to the end from the current position."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "After hitting a wall when trying to build dp from the start to the end, I was very surprised that doing it the other way just magically solves all problem. However, I am still confused how you could clearly realize that right away when looking at the problem?\\nCould anyone explain me what is the characterstic of this problem that makes it a \"one-way DP\"? Like what general property does this problem have that makes it easier to solve from one way rather than the other?"
                    },
                    {
                        "username": "ttaylor27",
                        "content": "For me when solving, what led me to immediately realize that I had to start at the bottom right (end) was the idea that I needed to figure out the minimum health needed to reach the end at every given point. The easiest way to build up for the whole traversal is to start at the end, where you know the minimum health you'd need for the final square is simply however much is required for that one square. From there, as you traverse, you can find the minimum from any previous paths you have built, and eventually your minimum will be at the start once you finish your traversal. Basically, start with the minimum health required for the end square, then find the minimum required for the last 2 squares, then last 3 squares, etc. and eventually you will be back at the start with your path fully constructed. (For clarity, I used a tabulation method)"
                    },
                    {
                        "username": "Manashi",
                        "content": "You need to maintain both minimum values and sum along a path, which is not possible in O(NM). O(NM * log(INT_MAX)) will work, which uses binary search on the knight\\'s initial health, and checking if the knight can reach the princess with that initial health, and choosing left or right branch of binary search based on that."
                    },
                    {
                        "username": "rabeeh",
                        "content": "Hi,\\nfor me, it is always hard to think bottom-up, and i am looking for a top-down DP solution for this question, I could not find one in the discussions, I wonder if one could submit one, I tried to do it myself, however, for me it gets timelimit, I wonder if one could submit  a working top-down DP version as reference for others?\\n\\nthanks"
                    },
                    {
                        "username": "FinalTheory",
                        "content": "Is there any rules that I should comply with? For example, how the input data is generated and so on?"
                    },
                    {
                        "username": "xu4",
                        "content": "otherwise, in the example, if the knight has 5 initially and he can move right->right->down->up->down->down"
                    },
                    {
                        "username": "tushargupta9800",
                        "content": "![image](https://assets.leetcode.com/users/images/d82d73af-4f79-4a2f-814b-b38542a17c1e_1634581073.285247.png)\\n\\nPassed all test cases still TLE"
                    },
                    {
                        "username": "daniel_9650",
                        "content": "From the discussion it seems the accepted approach is DP; I first started to approach this with DFS, modeling the grid as a directed graph and trying to find the min cost path from top left to bottom right. I am still trying to see if DFS is a sensible approach or a dead end.\\n\\nDid anyone else try to do this using some method besides DP/recursion?"
                    }
                ]
            },
            {
                "id": 1571380,
                "content": [
                    {
                        "username": "jrmurro",
                        "content": "How does [[-3,5]] require a mininum health of 4 when we can just use a health value of 1 from the beginning?"
                    },
                    {
                        "username": "jrmurro",
                        "content": "[@Akashdeep_Gupta](/Akashdeep_Gupta) That makes sense!"
                    },
                    {
                        "username": "Akashdeep_Gupta",
                        "content": "if you start with health =1 and got to -3 then your health will become -2 (-3+1) hence you die, because every time the health should be greater than 0 that is minimum 1, so to tackle -3 you have to start with health =4. so when you land on -3 your health will be 1 (-3+4) means you are alive."
                    },
                    {
                        "username": "makSyak",
                        "content": "My first hard :)"
                    },
                    {
                        "username": "docentovich",
                        "content": "We must start from the end because we calculate the starting position parameter. The health parameter from which we should start, not end. We don\\'t know the beginning. We know that as a result of the path sum, the health at the end must be greater than or equal to 1. (The additional condition that the health should not be zeroed on the way is essentially an additional condition). We do not know from which parameter the health should start. We minimize the health parameter to the start. Therefore, we need to calculate it to the start because the already calculated values will be closer to the end from the current position."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "After hitting a wall when trying to build dp from the start to the end, I was very surprised that doing it the other way just magically solves all problem. However, I am still confused how you could clearly realize that right away when looking at the problem?\\nCould anyone explain me what is the characterstic of this problem that makes it a \"one-way DP\"? Like what general property does this problem have that makes it easier to solve from one way rather than the other?"
                    },
                    {
                        "username": "ttaylor27",
                        "content": "For me when solving, what led me to immediately realize that I had to start at the bottom right (end) was the idea that I needed to figure out the minimum health needed to reach the end at every given point. The easiest way to build up for the whole traversal is to start at the end, where you know the minimum health you'd need for the final square is simply however much is required for that one square. From there, as you traverse, you can find the minimum from any previous paths you have built, and eventually your minimum will be at the start once you finish your traversal. Basically, start with the minimum health required for the end square, then find the minimum required for the last 2 squares, then last 3 squares, etc. and eventually you will be back at the start with your path fully constructed. (For clarity, I used a tabulation method)"
                    },
                    {
                        "username": "Manashi",
                        "content": "You need to maintain both minimum values and sum along a path, which is not possible in O(NM). O(NM * log(INT_MAX)) will work, which uses binary search on the knight\\'s initial health, and checking if the knight can reach the princess with that initial health, and choosing left or right branch of binary search based on that."
                    },
                    {
                        "username": "rabeeh",
                        "content": "Hi,\\nfor me, it is always hard to think bottom-up, and i am looking for a top-down DP solution for this question, I could not find one in the discussions, I wonder if one could submit one, I tried to do it myself, however, for me it gets timelimit, I wonder if one could submit  a working top-down DP version as reference for others?\\n\\nthanks"
                    },
                    {
                        "username": "FinalTheory",
                        "content": "Is there any rules that I should comply with? For example, how the input data is generated and so on?"
                    },
                    {
                        "username": "xu4",
                        "content": "otherwise, in the example, if the knight has 5 initially and he can move right->right->down->up->down->down"
                    },
                    {
                        "username": "tushargupta9800",
                        "content": "![image](https://assets.leetcode.com/users/images/d82d73af-4f79-4a2f-814b-b38542a17c1e_1634581073.285247.png)\\n\\nPassed all test cases still TLE"
                    },
                    {
                        "username": "daniel_9650",
                        "content": "From the discussion it seems the accepted approach is DP; I first started to approach this with DFS, modeling the grid as a directed graph and trying to find the min cost path from top left to bottom right. I am still trying to see if DFS is a sensible approach or a dead end.\\n\\nDid anyone else try to do this using some method besides DP/recursion?"
                    }
                ]
            },
            {
                "id": 1571381,
                "content": [
                    {
                        "username": "jrmurro",
                        "content": "How does [[-3,5]] require a mininum health of 4 when we can just use a health value of 1 from the beginning?"
                    },
                    {
                        "username": "jrmurro",
                        "content": "[@Akashdeep_Gupta](/Akashdeep_Gupta) That makes sense!"
                    },
                    {
                        "username": "Akashdeep_Gupta",
                        "content": "if you start with health =1 and got to -3 then your health will become -2 (-3+1) hence you die, because every time the health should be greater than 0 that is minimum 1, so to tackle -3 you have to start with health =4. so when you land on -3 your health will be 1 (-3+4) means you are alive."
                    },
                    {
                        "username": "makSyak",
                        "content": "My first hard :)"
                    },
                    {
                        "username": "docentovich",
                        "content": "We must start from the end because we calculate the starting position parameter. The health parameter from which we should start, not end. We don\\'t know the beginning. We know that as a result of the path sum, the health at the end must be greater than or equal to 1. (The additional condition that the health should not be zeroed on the way is essentially an additional condition). We do not know from which parameter the health should start. We minimize the health parameter to the start. Therefore, we need to calculate it to the start because the already calculated values will be closer to the end from the current position."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "After hitting a wall when trying to build dp from the start to the end, I was very surprised that doing it the other way just magically solves all problem. However, I am still confused how you could clearly realize that right away when looking at the problem?\\nCould anyone explain me what is the characterstic of this problem that makes it a \"one-way DP\"? Like what general property does this problem have that makes it easier to solve from one way rather than the other?"
                    },
                    {
                        "username": "ttaylor27",
                        "content": "For me when solving, what led me to immediately realize that I had to start at the bottom right (end) was the idea that I needed to figure out the minimum health needed to reach the end at every given point. The easiest way to build up for the whole traversal is to start at the end, where you know the minimum health you'd need for the final square is simply however much is required for that one square. From there, as you traverse, you can find the minimum from any previous paths you have built, and eventually your minimum will be at the start once you finish your traversal. Basically, start with the minimum health required for the end square, then find the minimum required for the last 2 squares, then last 3 squares, etc. and eventually you will be back at the start with your path fully constructed. (For clarity, I used a tabulation method)"
                    },
                    {
                        "username": "Manashi",
                        "content": "You need to maintain both minimum values and sum along a path, which is not possible in O(NM). O(NM * log(INT_MAX)) will work, which uses binary search on the knight\\'s initial health, and checking if the knight can reach the princess with that initial health, and choosing left or right branch of binary search based on that."
                    },
                    {
                        "username": "rabeeh",
                        "content": "Hi,\\nfor me, it is always hard to think bottom-up, and i am looking for a top-down DP solution for this question, I could not find one in the discussions, I wonder if one could submit one, I tried to do it myself, however, for me it gets timelimit, I wonder if one could submit  a working top-down DP version as reference for others?\\n\\nthanks"
                    },
                    {
                        "username": "FinalTheory",
                        "content": "Is there any rules that I should comply with? For example, how the input data is generated and so on?"
                    },
                    {
                        "username": "xu4",
                        "content": "otherwise, in the example, if the knight has 5 initially and he can move right->right->down->up->down->down"
                    },
                    {
                        "username": "tushargupta9800",
                        "content": "![image](https://assets.leetcode.com/users/images/d82d73af-4f79-4a2f-814b-b38542a17c1e_1634581073.285247.png)\\n\\nPassed all test cases still TLE"
                    },
                    {
                        "username": "daniel_9650",
                        "content": "From the discussion it seems the accepted approach is DP; I first started to approach this with DFS, modeling the grid as a directed graph and trying to find the min cost path from top left to bottom right. I am still trying to see if DFS is a sensible approach or a dead end.\\n\\nDid anyone else try to do this using some method besides DP/recursion?"
                    }
                ]
            },
            {
                "id": 1571383,
                "content": [
                    {
                        "username": "jrmurro",
                        "content": "How does [[-3,5]] require a mininum health of 4 when we can just use a health value of 1 from the beginning?"
                    },
                    {
                        "username": "jrmurro",
                        "content": "[@Akashdeep_Gupta](/Akashdeep_Gupta) That makes sense!"
                    },
                    {
                        "username": "Akashdeep_Gupta",
                        "content": "if you start with health =1 and got to -3 then your health will become -2 (-3+1) hence you die, because every time the health should be greater than 0 that is minimum 1, so to tackle -3 you have to start with health =4. so when you land on -3 your health will be 1 (-3+4) means you are alive."
                    },
                    {
                        "username": "makSyak",
                        "content": "My first hard :)"
                    },
                    {
                        "username": "docentovich",
                        "content": "We must start from the end because we calculate the starting position parameter. The health parameter from which we should start, not end. We don\\'t know the beginning. We know that as a result of the path sum, the health at the end must be greater than or equal to 1. (The additional condition that the health should not be zeroed on the way is essentially an additional condition). We do not know from which parameter the health should start. We minimize the health parameter to the start. Therefore, we need to calculate it to the start because the already calculated values will be closer to the end from the current position."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "After hitting a wall when trying to build dp from the start to the end, I was very surprised that doing it the other way just magically solves all problem. However, I am still confused how you could clearly realize that right away when looking at the problem?\\nCould anyone explain me what is the characterstic of this problem that makes it a \"one-way DP\"? Like what general property does this problem have that makes it easier to solve from one way rather than the other?"
                    },
                    {
                        "username": "ttaylor27",
                        "content": "For me when solving, what led me to immediately realize that I had to start at the bottom right (end) was the idea that I needed to figure out the minimum health needed to reach the end at every given point. The easiest way to build up for the whole traversal is to start at the end, where you know the minimum health you'd need for the final square is simply however much is required for that one square. From there, as you traverse, you can find the minimum from any previous paths you have built, and eventually your minimum will be at the start once you finish your traversal. Basically, start with the minimum health required for the end square, then find the minimum required for the last 2 squares, then last 3 squares, etc. and eventually you will be back at the start with your path fully constructed. (For clarity, I used a tabulation method)"
                    },
                    {
                        "username": "Manashi",
                        "content": "You need to maintain both minimum values and sum along a path, which is not possible in O(NM). O(NM * log(INT_MAX)) will work, which uses binary search on the knight\\'s initial health, and checking if the knight can reach the princess with that initial health, and choosing left or right branch of binary search based on that."
                    },
                    {
                        "username": "rabeeh",
                        "content": "Hi,\\nfor me, it is always hard to think bottom-up, and i am looking for a top-down DP solution for this question, I could not find one in the discussions, I wonder if one could submit one, I tried to do it myself, however, for me it gets timelimit, I wonder if one could submit  a working top-down DP version as reference for others?\\n\\nthanks"
                    },
                    {
                        "username": "FinalTheory",
                        "content": "Is there any rules that I should comply with? For example, how the input data is generated and so on?"
                    },
                    {
                        "username": "xu4",
                        "content": "otherwise, in the example, if the knight has 5 initially and he can move right->right->down->up->down->down"
                    },
                    {
                        "username": "tushargupta9800",
                        "content": "![image](https://assets.leetcode.com/users/images/d82d73af-4f79-4a2f-814b-b38542a17c1e_1634581073.285247.png)\\n\\nPassed all test cases still TLE"
                    },
                    {
                        "username": "daniel_9650",
                        "content": "From the discussion it seems the accepted approach is DP; I first started to approach this with DFS, modeling the grid as a directed graph and trying to find the min cost path from top left to bottom right. I am still trying to see if DFS is a sensible approach or a dead end.\\n\\nDid anyone else try to do this using some method besides DP/recursion?"
                    }
                ]
            },
            {
                "id": 1575872,
                "content": [
                    {
                        "username": "jrmurro",
                        "content": "How does [[-3,5]] require a mininum health of 4 when we can just use a health value of 1 from the beginning?"
                    },
                    {
                        "username": "jrmurro",
                        "content": "[@Akashdeep_Gupta](/Akashdeep_Gupta) That makes sense!"
                    },
                    {
                        "username": "Akashdeep_Gupta",
                        "content": "if you start with health =1 and got to -3 then your health will become -2 (-3+1) hence you die, because every time the health should be greater than 0 that is minimum 1, so to tackle -3 you have to start with health =4. so when you land on -3 your health will be 1 (-3+4) means you are alive."
                    },
                    {
                        "username": "makSyak",
                        "content": "My first hard :)"
                    },
                    {
                        "username": "docentovich",
                        "content": "We must start from the end because we calculate the starting position parameter. The health parameter from which we should start, not end. We don\\'t know the beginning. We know that as a result of the path sum, the health at the end must be greater than or equal to 1. (The additional condition that the health should not be zeroed on the way is essentially an additional condition). We do not know from which parameter the health should start. We minimize the health parameter to the start. Therefore, we need to calculate it to the start because the already calculated values will be closer to the end from the current position."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "After hitting a wall when trying to build dp from the start to the end, I was very surprised that doing it the other way just magically solves all problem. However, I am still confused how you could clearly realize that right away when looking at the problem?\\nCould anyone explain me what is the characterstic of this problem that makes it a \"one-way DP\"? Like what general property does this problem have that makes it easier to solve from one way rather than the other?"
                    },
                    {
                        "username": "ttaylor27",
                        "content": "For me when solving, what led me to immediately realize that I had to start at the bottom right (end) was the idea that I needed to figure out the minimum health needed to reach the end at every given point. The easiest way to build up for the whole traversal is to start at the end, where you know the minimum health you'd need for the final square is simply however much is required for that one square. From there, as you traverse, you can find the minimum from any previous paths you have built, and eventually your minimum will be at the start once you finish your traversal. Basically, start with the minimum health required for the end square, then find the minimum required for the last 2 squares, then last 3 squares, etc. and eventually you will be back at the start with your path fully constructed. (For clarity, I used a tabulation method)"
                    },
                    {
                        "username": "Manashi",
                        "content": "You need to maintain both minimum values and sum along a path, which is not possible in O(NM). O(NM * log(INT_MAX)) will work, which uses binary search on the knight\\'s initial health, and checking if the knight can reach the princess with that initial health, and choosing left or right branch of binary search based on that."
                    },
                    {
                        "username": "rabeeh",
                        "content": "Hi,\\nfor me, it is always hard to think bottom-up, and i am looking for a top-down DP solution for this question, I could not find one in the discussions, I wonder if one could submit one, I tried to do it myself, however, for me it gets timelimit, I wonder if one could submit  a working top-down DP version as reference for others?\\n\\nthanks"
                    },
                    {
                        "username": "FinalTheory",
                        "content": "Is there any rules that I should comply with? For example, how the input data is generated and so on?"
                    },
                    {
                        "username": "xu4",
                        "content": "otherwise, in the example, if the knight has 5 initially and he can move right->right->down->up->down->down"
                    },
                    {
                        "username": "tushargupta9800",
                        "content": "![image](https://assets.leetcode.com/users/images/d82d73af-4f79-4a2f-814b-b38542a17c1e_1634581073.285247.png)\\n\\nPassed all test cases still TLE"
                    },
                    {
                        "username": "daniel_9650",
                        "content": "From the discussion it seems the accepted approach is DP; I first started to approach this with DFS, modeling the grid as a directed graph and trying to find the min cost path from top left to bottom right. I am still trying to see if DFS is a sensible approach or a dead end.\\n\\nDid anyone else try to do this using some method besides DP/recursion?"
                    }
                ]
            },
            {
                "id": 2049722,
                "content": [
                    {
                        "username": "jrmurro",
                        "content": "How does [[-3,5]] require a mininum health of 4 when we can just use a health value of 1 from the beginning?"
                    },
                    {
                        "username": "jrmurro",
                        "content": "[@Akashdeep_Gupta](/Akashdeep_Gupta) That makes sense!"
                    },
                    {
                        "username": "Akashdeep_Gupta",
                        "content": "if you start with health =1 and got to -3 then your health will become -2 (-3+1) hence you die, because every time the health should be greater than 0 that is minimum 1, so to tackle -3 you have to start with health =4. so when you land on -3 your health will be 1 (-3+4) means you are alive."
                    },
                    {
                        "username": "makSyak",
                        "content": "My first hard :)"
                    },
                    {
                        "username": "docentovich",
                        "content": "We must start from the end because we calculate the starting position parameter. The health parameter from which we should start, not end. We don\\'t know the beginning. We know that as a result of the path sum, the health at the end must be greater than or equal to 1. (The additional condition that the health should not be zeroed on the way is essentially an additional condition). We do not know from which parameter the health should start. We minimize the health parameter to the start. Therefore, we need to calculate it to the start because the already calculated values will be closer to the end from the current position."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "After hitting a wall when trying to build dp from the start to the end, I was very surprised that doing it the other way just magically solves all problem. However, I am still confused how you could clearly realize that right away when looking at the problem?\\nCould anyone explain me what is the characterstic of this problem that makes it a \"one-way DP\"? Like what general property does this problem have that makes it easier to solve from one way rather than the other?"
                    },
                    {
                        "username": "ttaylor27",
                        "content": "For me when solving, what led me to immediately realize that I had to start at the bottom right (end) was the idea that I needed to figure out the minimum health needed to reach the end at every given point. The easiest way to build up for the whole traversal is to start at the end, where you know the minimum health you'd need for the final square is simply however much is required for that one square. From there, as you traverse, you can find the minimum from any previous paths you have built, and eventually your minimum will be at the start once you finish your traversal. Basically, start with the minimum health required for the end square, then find the minimum required for the last 2 squares, then last 3 squares, etc. and eventually you will be back at the start with your path fully constructed. (For clarity, I used a tabulation method)"
                    },
                    {
                        "username": "Manashi",
                        "content": "You need to maintain both minimum values and sum along a path, which is not possible in O(NM). O(NM * log(INT_MAX)) will work, which uses binary search on the knight\\'s initial health, and checking if the knight can reach the princess with that initial health, and choosing left or right branch of binary search based on that."
                    },
                    {
                        "username": "rabeeh",
                        "content": "Hi,\\nfor me, it is always hard to think bottom-up, and i am looking for a top-down DP solution for this question, I could not find one in the discussions, I wonder if one could submit one, I tried to do it myself, however, for me it gets timelimit, I wonder if one could submit  a working top-down DP version as reference for others?\\n\\nthanks"
                    },
                    {
                        "username": "FinalTheory",
                        "content": "Is there any rules that I should comply with? For example, how the input data is generated and so on?"
                    },
                    {
                        "username": "xu4",
                        "content": "otherwise, in the example, if the knight has 5 initially and he can move right->right->down->up->down->down"
                    },
                    {
                        "username": "tushargupta9800",
                        "content": "![image](https://assets.leetcode.com/users/images/d82d73af-4f79-4a2f-814b-b38542a17c1e_1634581073.285247.png)\\n\\nPassed all test cases still TLE"
                    },
                    {
                        "username": "daniel_9650",
                        "content": "From the discussion it seems the accepted approach is DP; I first started to approach this with DFS, modeling the grid as a directed graph and trying to find the min cost path from top left to bottom right. I am still trying to see if DFS is a sensible approach or a dead end.\\n\\nDid anyone else try to do this using some method besides DP/recursion?"
                    }
                ]
            },
            {
                "id": 2046467,
                "content": [
                    {
                        "username": "layyy",
                        "content": "hint : start from the bottom right"
                    },
                    {
                        "username": "dhruv-1010",
                        "content": "why top-down slower?\\n"
                    },
                    {
                        "username": "guavacannes",
                        "content": " `class Solution {\\n    typedef vector<vector<int>> vv;\\n    int m, n;\\n    vector<vector<int>> mv;\\n\\n    int f(vv &dun, vv &dp, int i, int j, int a) {\\n        if(i == m - 1 && j == n - 1) return (a + dun[i][j] > 0)? 1 : 0;\\n\\n        if(dp[i][j] != -1) return dp[i][j];\\n\\n        if(a + dun[i][j] <= 0) return dp[i][j] = 0;\\n\\n        int flag = 0;\\n        for(int k = 0; k < 2; k++) {\\n\\n            int dx = i + mv[k][0], dy = j + mv[k][1];\\n            if(dx < m && dy < n) {\\n                if( f(dun, dp, dx, dy, a + dun[i][j]) )\\n                    flag = 1;      \\n            }   \\n\\n        }\\n\\n        return dp[i][j] = flag;\\n    }\\npublic:\\n    int calculateMinimumHP(vv& dun) {\\n        m = dun.size(), n = dun[0].size();\\n        mv = {{0, 1}, {1, 0}};\\n        int l = 1, r = 1e3 + 1;\\n        while(l < r) {\\n            vv dp(m, vector<int>(n, -1));\\n            int mid = l + (r - l) / 2;\\n            if(f(dun, dp, 0, 0, mid))\\n                r = mid;\\n            else l = mid + 1;\\n        }\\n        return l;\\n    }\\n};`\\n\\nPlease help me understand why this logic cannot give the right solution\\n\\nI make use of the dp values as a true or false (or not computed)"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "this is good type of dp problem, a little different"
                    },
                    {
                        "username": "ayush_way",
                        "content": "int solve(int i, int j, int req,vector<vector<int> > &nums,vector<vector<int>> &dp){\\n    //base cases\\n    if(i==0 && j==0)\\n    {\\n     int t=req-nums[0][0];\\n     if(t<=0) \\n     {        \\n         return 1;\\n     }  \\n    return t;\\n    }\\n    if(i<0 || j<0) return INT_MAX;\\n\\n    if(dp[i][j]!=-1) return dp[i][j];\\n    \\n   \\n    int s= req-nums[i][j];\\n    if(s<=0){\\n         int  up=solve(i-1,j,1,nums,dp);\\n       int   left=solve(i,j-1,1,nums,dp);\\n         return dp[i][j] = min(up,left);\\n    }\\n    else \\n    {\\n       int up=solve(i-1,j,req-nums[i][j],nums,dp);\\n       int  left=solve(i,j-1,req-nums[i][j],nums,dp);\\n          return dp[i][j] = min(up,left);\\n    }\\n   \\n    \\n    \\n}\\n  int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n int n=dungeon.size(),m=dungeon[0].size();\\n    vector<vector<int>> dp(n+1,vector<int> (m+1,-1));\\n    return solve(n-1,m-1,1,dungeon,dp);\\n \\n\\n\\nPlease help me !!\\n[[3,0,-3],[-3,-2,-2],[3,1,-3]] for this test case my code gives 6 but ans is 1 i dont know why is this happening please find fault in the code . Its the 31st test case out of 45.\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "This problem is pain in the ass problem. Took me few months to crack it (the problem haha but who knows what is better)"
                    },
                    {
                        "username": "sonder7",
                        "content": "we should inversely visit the array for dp instead of visiting sequently. Otherwise, we should keep the first blood and can\\'t find the logic for dp.\\n\\n```\\nclass Solution {\\npublic:\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        int m = dungeon.size();\\n        int n = dungeon[0].size();\\n        vector<vector<int>> f(m, vector<int>(n, 0x3f3f3f3f));\\n        if (dungeon[m - 1][n - 1] > 0) {\\n            f[m - 1][n - 1] = 1;\\n        } else {\\n            f[m - 1][n - 1] = 1 - dungeon[m - 1][n - 1];\\n        }\\n        for (int i = m - 1; i >= 0; i--) {\\n            for (int j = n - 1;j >= 0; j--) {\\n                if (i < m - 1) f[i][j] = max(1, f[i + 1][j] - dungeon[i][j]);\\n                if (j < n - 1) f[i][j] = min(f[i][j], max(1, f[i][j + 1] - dungeon[i][j]));\\n            }\\n        }\\n        return f[0][0];\\n    }\\n};\\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "mahendramaism",
                        "content": "Please check this test case and correct me if i am wrong. \\nhttps://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/10846 "
                    },
                    {
                        "username": "user2049D",
                        "content": "Good solution for your test case ([[-5, 1, 3],[30, -10, -3],[10, -5, -2]]) is 6.\\nDOWN, DOWN, RIGHT, RIGHT is the good path."
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "This might help understanding the overlapping subproblems. I have explained it better [here](https://leetcode.com/problems/dungeon-game/solutions/3011638/python3-calculate-extrahealth-needed-at-each-cell/)\n\n![image.png](https://assets.leetcode.com/users/images/0d90a36f-f760-48a9-8173-5a34c17da3b7_1673065577.0750911.png)"
                    }
                ]
            },
            {
                "id": 2042294,
                "content": [
                    {
                        "username": "layyy",
                        "content": "hint : start from the bottom right"
                    },
                    {
                        "username": "dhruv-1010",
                        "content": "why top-down slower?\\n"
                    },
                    {
                        "username": "guavacannes",
                        "content": " `class Solution {\\n    typedef vector<vector<int>> vv;\\n    int m, n;\\n    vector<vector<int>> mv;\\n\\n    int f(vv &dun, vv &dp, int i, int j, int a) {\\n        if(i == m - 1 && j == n - 1) return (a + dun[i][j] > 0)? 1 : 0;\\n\\n        if(dp[i][j] != -1) return dp[i][j];\\n\\n        if(a + dun[i][j] <= 0) return dp[i][j] = 0;\\n\\n        int flag = 0;\\n        for(int k = 0; k < 2; k++) {\\n\\n            int dx = i + mv[k][0], dy = j + mv[k][1];\\n            if(dx < m && dy < n) {\\n                if( f(dun, dp, dx, dy, a + dun[i][j]) )\\n                    flag = 1;      \\n            }   \\n\\n        }\\n\\n        return dp[i][j] = flag;\\n    }\\npublic:\\n    int calculateMinimumHP(vv& dun) {\\n        m = dun.size(), n = dun[0].size();\\n        mv = {{0, 1}, {1, 0}};\\n        int l = 1, r = 1e3 + 1;\\n        while(l < r) {\\n            vv dp(m, vector<int>(n, -1));\\n            int mid = l + (r - l) / 2;\\n            if(f(dun, dp, 0, 0, mid))\\n                r = mid;\\n            else l = mid + 1;\\n        }\\n        return l;\\n    }\\n};`\\n\\nPlease help me understand why this logic cannot give the right solution\\n\\nI make use of the dp values as a true or false (or not computed)"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "this is good type of dp problem, a little different"
                    },
                    {
                        "username": "ayush_way",
                        "content": "int solve(int i, int j, int req,vector<vector<int> > &nums,vector<vector<int>> &dp){\\n    //base cases\\n    if(i==0 && j==0)\\n    {\\n     int t=req-nums[0][0];\\n     if(t<=0) \\n     {        \\n         return 1;\\n     }  \\n    return t;\\n    }\\n    if(i<0 || j<0) return INT_MAX;\\n\\n    if(dp[i][j]!=-1) return dp[i][j];\\n    \\n   \\n    int s= req-nums[i][j];\\n    if(s<=0){\\n         int  up=solve(i-1,j,1,nums,dp);\\n       int   left=solve(i,j-1,1,nums,dp);\\n         return dp[i][j] = min(up,left);\\n    }\\n    else \\n    {\\n       int up=solve(i-1,j,req-nums[i][j],nums,dp);\\n       int  left=solve(i,j-1,req-nums[i][j],nums,dp);\\n          return dp[i][j] = min(up,left);\\n    }\\n   \\n    \\n    \\n}\\n  int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n int n=dungeon.size(),m=dungeon[0].size();\\n    vector<vector<int>> dp(n+1,vector<int> (m+1,-1));\\n    return solve(n-1,m-1,1,dungeon,dp);\\n \\n\\n\\nPlease help me !!\\n[[3,0,-3],[-3,-2,-2],[3,1,-3]] for this test case my code gives 6 but ans is 1 i dont know why is this happening please find fault in the code . Its the 31st test case out of 45.\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "This problem is pain in the ass problem. Took me few months to crack it (the problem haha but who knows what is better)"
                    },
                    {
                        "username": "sonder7",
                        "content": "we should inversely visit the array for dp instead of visiting sequently. Otherwise, we should keep the first blood and can\\'t find the logic for dp.\\n\\n```\\nclass Solution {\\npublic:\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        int m = dungeon.size();\\n        int n = dungeon[0].size();\\n        vector<vector<int>> f(m, vector<int>(n, 0x3f3f3f3f));\\n        if (dungeon[m - 1][n - 1] > 0) {\\n            f[m - 1][n - 1] = 1;\\n        } else {\\n            f[m - 1][n - 1] = 1 - dungeon[m - 1][n - 1];\\n        }\\n        for (int i = m - 1; i >= 0; i--) {\\n            for (int j = n - 1;j >= 0; j--) {\\n                if (i < m - 1) f[i][j] = max(1, f[i + 1][j] - dungeon[i][j]);\\n                if (j < n - 1) f[i][j] = min(f[i][j], max(1, f[i][j + 1] - dungeon[i][j]));\\n            }\\n        }\\n        return f[0][0];\\n    }\\n};\\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "mahendramaism",
                        "content": "Please check this test case and correct me if i am wrong. \\nhttps://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/10846 "
                    },
                    {
                        "username": "user2049D",
                        "content": "Good solution for your test case ([[-5, 1, 3],[30, -10, -3],[10, -5, -2]]) is 6.\\nDOWN, DOWN, RIGHT, RIGHT is the good path."
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "This might help understanding the overlapping subproblems. I have explained it better [here](https://leetcode.com/problems/dungeon-game/solutions/3011638/python3-calculate-extrahealth-needed-at-each-cell/)\n\n![image.png](https://assets.leetcode.com/users/images/0d90a36f-f760-48a9-8173-5a34c17da3b7_1673065577.0750911.png)"
                    }
                ]
            },
            {
                "id": 2042160,
                "content": [
                    {
                        "username": "layyy",
                        "content": "hint : start from the bottom right"
                    },
                    {
                        "username": "dhruv-1010",
                        "content": "why top-down slower?\\n"
                    },
                    {
                        "username": "guavacannes",
                        "content": " `class Solution {\\n    typedef vector<vector<int>> vv;\\n    int m, n;\\n    vector<vector<int>> mv;\\n\\n    int f(vv &dun, vv &dp, int i, int j, int a) {\\n        if(i == m - 1 && j == n - 1) return (a + dun[i][j] > 0)? 1 : 0;\\n\\n        if(dp[i][j] != -1) return dp[i][j];\\n\\n        if(a + dun[i][j] <= 0) return dp[i][j] = 0;\\n\\n        int flag = 0;\\n        for(int k = 0; k < 2; k++) {\\n\\n            int dx = i + mv[k][0], dy = j + mv[k][1];\\n            if(dx < m && dy < n) {\\n                if( f(dun, dp, dx, dy, a + dun[i][j]) )\\n                    flag = 1;      \\n            }   \\n\\n        }\\n\\n        return dp[i][j] = flag;\\n    }\\npublic:\\n    int calculateMinimumHP(vv& dun) {\\n        m = dun.size(), n = dun[0].size();\\n        mv = {{0, 1}, {1, 0}};\\n        int l = 1, r = 1e3 + 1;\\n        while(l < r) {\\n            vv dp(m, vector<int>(n, -1));\\n            int mid = l + (r - l) / 2;\\n            if(f(dun, dp, 0, 0, mid))\\n                r = mid;\\n            else l = mid + 1;\\n        }\\n        return l;\\n    }\\n};`\\n\\nPlease help me understand why this logic cannot give the right solution\\n\\nI make use of the dp values as a true or false (or not computed)"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "this is good type of dp problem, a little different"
                    },
                    {
                        "username": "ayush_way",
                        "content": "int solve(int i, int j, int req,vector<vector<int> > &nums,vector<vector<int>> &dp){\\n    //base cases\\n    if(i==0 && j==0)\\n    {\\n     int t=req-nums[0][0];\\n     if(t<=0) \\n     {        \\n         return 1;\\n     }  \\n    return t;\\n    }\\n    if(i<0 || j<0) return INT_MAX;\\n\\n    if(dp[i][j]!=-1) return dp[i][j];\\n    \\n   \\n    int s= req-nums[i][j];\\n    if(s<=0){\\n         int  up=solve(i-1,j,1,nums,dp);\\n       int   left=solve(i,j-1,1,nums,dp);\\n         return dp[i][j] = min(up,left);\\n    }\\n    else \\n    {\\n       int up=solve(i-1,j,req-nums[i][j],nums,dp);\\n       int  left=solve(i,j-1,req-nums[i][j],nums,dp);\\n          return dp[i][j] = min(up,left);\\n    }\\n   \\n    \\n    \\n}\\n  int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n int n=dungeon.size(),m=dungeon[0].size();\\n    vector<vector<int>> dp(n+1,vector<int> (m+1,-1));\\n    return solve(n-1,m-1,1,dungeon,dp);\\n \\n\\n\\nPlease help me !!\\n[[3,0,-3],[-3,-2,-2],[3,1,-3]] for this test case my code gives 6 but ans is 1 i dont know why is this happening please find fault in the code . Its the 31st test case out of 45.\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "This problem is pain in the ass problem. Took me few months to crack it (the problem haha but who knows what is better)"
                    },
                    {
                        "username": "sonder7",
                        "content": "we should inversely visit the array for dp instead of visiting sequently. Otherwise, we should keep the first blood and can\\'t find the logic for dp.\\n\\n```\\nclass Solution {\\npublic:\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        int m = dungeon.size();\\n        int n = dungeon[0].size();\\n        vector<vector<int>> f(m, vector<int>(n, 0x3f3f3f3f));\\n        if (dungeon[m - 1][n - 1] > 0) {\\n            f[m - 1][n - 1] = 1;\\n        } else {\\n            f[m - 1][n - 1] = 1 - dungeon[m - 1][n - 1];\\n        }\\n        for (int i = m - 1; i >= 0; i--) {\\n            for (int j = n - 1;j >= 0; j--) {\\n                if (i < m - 1) f[i][j] = max(1, f[i + 1][j] - dungeon[i][j]);\\n                if (j < n - 1) f[i][j] = min(f[i][j], max(1, f[i][j + 1] - dungeon[i][j]));\\n            }\\n        }\\n        return f[0][0];\\n    }\\n};\\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "mahendramaism",
                        "content": "Please check this test case and correct me if i am wrong. \\nhttps://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/10846 "
                    },
                    {
                        "username": "user2049D",
                        "content": "Good solution for your test case ([[-5, 1, 3],[30, -10, -3],[10, -5, -2]]) is 6.\\nDOWN, DOWN, RIGHT, RIGHT is the good path."
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "This might help understanding the overlapping subproblems. I have explained it better [here](https://leetcode.com/problems/dungeon-game/solutions/3011638/python3-calculate-extrahealth-needed-at-each-cell/)\n\n![image.png](https://assets.leetcode.com/users/images/0d90a36f-f760-48a9-8173-5a34c17da3b7_1673065577.0750911.png)"
                    }
                ]
            },
            {
                "id": 2016848,
                "content": [
                    {
                        "username": "layyy",
                        "content": "hint : start from the bottom right"
                    },
                    {
                        "username": "dhruv-1010",
                        "content": "why top-down slower?\\n"
                    },
                    {
                        "username": "guavacannes",
                        "content": " `class Solution {\\n    typedef vector<vector<int>> vv;\\n    int m, n;\\n    vector<vector<int>> mv;\\n\\n    int f(vv &dun, vv &dp, int i, int j, int a) {\\n        if(i == m - 1 && j == n - 1) return (a + dun[i][j] > 0)? 1 : 0;\\n\\n        if(dp[i][j] != -1) return dp[i][j];\\n\\n        if(a + dun[i][j] <= 0) return dp[i][j] = 0;\\n\\n        int flag = 0;\\n        for(int k = 0; k < 2; k++) {\\n\\n            int dx = i + mv[k][0], dy = j + mv[k][1];\\n            if(dx < m && dy < n) {\\n                if( f(dun, dp, dx, dy, a + dun[i][j]) )\\n                    flag = 1;      \\n            }   \\n\\n        }\\n\\n        return dp[i][j] = flag;\\n    }\\npublic:\\n    int calculateMinimumHP(vv& dun) {\\n        m = dun.size(), n = dun[0].size();\\n        mv = {{0, 1}, {1, 0}};\\n        int l = 1, r = 1e3 + 1;\\n        while(l < r) {\\n            vv dp(m, vector<int>(n, -1));\\n            int mid = l + (r - l) / 2;\\n            if(f(dun, dp, 0, 0, mid))\\n                r = mid;\\n            else l = mid + 1;\\n        }\\n        return l;\\n    }\\n};`\\n\\nPlease help me understand why this logic cannot give the right solution\\n\\nI make use of the dp values as a true or false (or not computed)"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "this is good type of dp problem, a little different"
                    },
                    {
                        "username": "ayush_way",
                        "content": "int solve(int i, int j, int req,vector<vector<int> > &nums,vector<vector<int>> &dp){\\n    //base cases\\n    if(i==0 && j==0)\\n    {\\n     int t=req-nums[0][0];\\n     if(t<=0) \\n     {        \\n         return 1;\\n     }  \\n    return t;\\n    }\\n    if(i<0 || j<0) return INT_MAX;\\n\\n    if(dp[i][j]!=-1) return dp[i][j];\\n    \\n   \\n    int s= req-nums[i][j];\\n    if(s<=0){\\n         int  up=solve(i-1,j,1,nums,dp);\\n       int   left=solve(i,j-1,1,nums,dp);\\n         return dp[i][j] = min(up,left);\\n    }\\n    else \\n    {\\n       int up=solve(i-1,j,req-nums[i][j],nums,dp);\\n       int  left=solve(i,j-1,req-nums[i][j],nums,dp);\\n          return dp[i][j] = min(up,left);\\n    }\\n   \\n    \\n    \\n}\\n  int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n int n=dungeon.size(),m=dungeon[0].size();\\n    vector<vector<int>> dp(n+1,vector<int> (m+1,-1));\\n    return solve(n-1,m-1,1,dungeon,dp);\\n \\n\\n\\nPlease help me !!\\n[[3,0,-3],[-3,-2,-2],[3,1,-3]] for this test case my code gives 6 but ans is 1 i dont know why is this happening please find fault in the code . Its the 31st test case out of 45.\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "This problem is pain in the ass problem. Took me few months to crack it (the problem haha but who knows what is better)"
                    },
                    {
                        "username": "sonder7",
                        "content": "we should inversely visit the array for dp instead of visiting sequently. Otherwise, we should keep the first blood and can\\'t find the logic for dp.\\n\\n```\\nclass Solution {\\npublic:\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        int m = dungeon.size();\\n        int n = dungeon[0].size();\\n        vector<vector<int>> f(m, vector<int>(n, 0x3f3f3f3f));\\n        if (dungeon[m - 1][n - 1] > 0) {\\n            f[m - 1][n - 1] = 1;\\n        } else {\\n            f[m - 1][n - 1] = 1 - dungeon[m - 1][n - 1];\\n        }\\n        for (int i = m - 1; i >= 0; i--) {\\n            for (int j = n - 1;j >= 0; j--) {\\n                if (i < m - 1) f[i][j] = max(1, f[i + 1][j] - dungeon[i][j]);\\n                if (j < n - 1) f[i][j] = min(f[i][j], max(1, f[i][j + 1] - dungeon[i][j]));\\n            }\\n        }\\n        return f[0][0];\\n    }\\n};\\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "mahendramaism",
                        "content": "Please check this test case and correct me if i am wrong. \\nhttps://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/10846 "
                    },
                    {
                        "username": "user2049D",
                        "content": "Good solution for your test case ([[-5, 1, 3],[30, -10, -3],[10, -5, -2]]) is 6.\\nDOWN, DOWN, RIGHT, RIGHT is the good path."
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "This might help understanding the overlapping subproblems. I have explained it better [here](https://leetcode.com/problems/dungeon-game/solutions/3011638/python3-calculate-extrahealth-needed-at-each-cell/)\n\n![image.png](https://assets.leetcode.com/users/images/0d90a36f-f760-48a9-8173-5a34c17da3b7_1673065577.0750911.png)"
                    }
                ]
            },
            {
                "id": 1966404,
                "content": [
                    {
                        "username": "layyy",
                        "content": "hint : start from the bottom right"
                    },
                    {
                        "username": "dhruv-1010",
                        "content": "why top-down slower?\\n"
                    },
                    {
                        "username": "guavacannes",
                        "content": " `class Solution {\\n    typedef vector<vector<int>> vv;\\n    int m, n;\\n    vector<vector<int>> mv;\\n\\n    int f(vv &dun, vv &dp, int i, int j, int a) {\\n        if(i == m - 1 && j == n - 1) return (a + dun[i][j] > 0)? 1 : 0;\\n\\n        if(dp[i][j] != -1) return dp[i][j];\\n\\n        if(a + dun[i][j] <= 0) return dp[i][j] = 0;\\n\\n        int flag = 0;\\n        for(int k = 0; k < 2; k++) {\\n\\n            int dx = i + mv[k][0], dy = j + mv[k][1];\\n            if(dx < m && dy < n) {\\n                if( f(dun, dp, dx, dy, a + dun[i][j]) )\\n                    flag = 1;      \\n            }   \\n\\n        }\\n\\n        return dp[i][j] = flag;\\n    }\\npublic:\\n    int calculateMinimumHP(vv& dun) {\\n        m = dun.size(), n = dun[0].size();\\n        mv = {{0, 1}, {1, 0}};\\n        int l = 1, r = 1e3 + 1;\\n        while(l < r) {\\n            vv dp(m, vector<int>(n, -1));\\n            int mid = l + (r - l) / 2;\\n            if(f(dun, dp, 0, 0, mid))\\n                r = mid;\\n            else l = mid + 1;\\n        }\\n        return l;\\n    }\\n};`\\n\\nPlease help me understand why this logic cannot give the right solution\\n\\nI make use of the dp values as a true or false (or not computed)"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "this is good type of dp problem, a little different"
                    },
                    {
                        "username": "ayush_way",
                        "content": "int solve(int i, int j, int req,vector<vector<int> > &nums,vector<vector<int>> &dp){\\n    //base cases\\n    if(i==0 && j==0)\\n    {\\n     int t=req-nums[0][0];\\n     if(t<=0) \\n     {        \\n         return 1;\\n     }  \\n    return t;\\n    }\\n    if(i<0 || j<0) return INT_MAX;\\n\\n    if(dp[i][j]!=-1) return dp[i][j];\\n    \\n   \\n    int s= req-nums[i][j];\\n    if(s<=0){\\n         int  up=solve(i-1,j,1,nums,dp);\\n       int   left=solve(i,j-1,1,nums,dp);\\n         return dp[i][j] = min(up,left);\\n    }\\n    else \\n    {\\n       int up=solve(i-1,j,req-nums[i][j],nums,dp);\\n       int  left=solve(i,j-1,req-nums[i][j],nums,dp);\\n          return dp[i][j] = min(up,left);\\n    }\\n   \\n    \\n    \\n}\\n  int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n int n=dungeon.size(),m=dungeon[0].size();\\n    vector<vector<int>> dp(n+1,vector<int> (m+1,-1));\\n    return solve(n-1,m-1,1,dungeon,dp);\\n \\n\\n\\nPlease help me !!\\n[[3,0,-3],[-3,-2,-2],[3,1,-3]] for this test case my code gives 6 but ans is 1 i dont know why is this happening please find fault in the code . Its the 31st test case out of 45.\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "This problem is pain in the ass problem. Took me few months to crack it (the problem haha but who knows what is better)"
                    },
                    {
                        "username": "sonder7",
                        "content": "we should inversely visit the array for dp instead of visiting sequently. Otherwise, we should keep the first blood and can\\'t find the logic for dp.\\n\\n```\\nclass Solution {\\npublic:\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        int m = dungeon.size();\\n        int n = dungeon[0].size();\\n        vector<vector<int>> f(m, vector<int>(n, 0x3f3f3f3f));\\n        if (dungeon[m - 1][n - 1] > 0) {\\n            f[m - 1][n - 1] = 1;\\n        } else {\\n            f[m - 1][n - 1] = 1 - dungeon[m - 1][n - 1];\\n        }\\n        for (int i = m - 1; i >= 0; i--) {\\n            for (int j = n - 1;j >= 0; j--) {\\n                if (i < m - 1) f[i][j] = max(1, f[i + 1][j] - dungeon[i][j]);\\n                if (j < n - 1) f[i][j] = min(f[i][j], max(1, f[i][j + 1] - dungeon[i][j]));\\n            }\\n        }\\n        return f[0][0];\\n    }\\n};\\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "mahendramaism",
                        "content": "Please check this test case and correct me if i am wrong. \\nhttps://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/10846 "
                    },
                    {
                        "username": "user2049D",
                        "content": "Good solution for your test case ([[-5, 1, 3],[30, -10, -3],[10, -5, -2]]) is 6.\\nDOWN, DOWN, RIGHT, RIGHT is the good path."
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "This might help understanding the overlapping subproblems. I have explained it better [here](https://leetcode.com/problems/dungeon-game/solutions/3011638/python3-calculate-extrahealth-needed-at-each-cell/)\n\n![image.png](https://assets.leetcode.com/users/images/0d90a36f-f760-48a9-8173-5a34c17da3b7_1673065577.0750911.png)"
                    }
                ]
            },
            {
                "id": 1833523,
                "content": [
                    {
                        "username": "layyy",
                        "content": "hint : start from the bottom right"
                    },
                    {
                        "username": "dhruv-1010",
                        "content": "why top-down slower?\\n"
                    },
                    {
                        "username": "guavacannes",
                        "content": " `class Solution {\\n    typedef vector<vector<int>> vv;\\n    int m, n;\\n    vector<vector<int>> mv;\\n\\n    int f(vv &dun, vv &dp, int i, int j, int a) {\\n        if(i == m - 1 && j == n - 1) return (a + dun[i][j] > 0)? 1 : 0;\\n\\n        if(dp[i][j] != -1) return dp[i][j];\\n\\n        if(a + dun[i][j] <= 0) return dp[i][j] = 0;\\n\\n        int flag = 0;\\n        for(int k = 0; k < 2; k++) {\\n\\n            int dx = i + mv[k][0], dy = j + mv[k][1];\\n            if(dx < m && dy < n) {\\n                if( f(dun, dp, dx, dy, a + dun[i][j]) )\\n                    flag = 1;      \\n            }   \\n\\n        }\\n\\n        return dp[i][j] = flag;\\n    }\\npublic:\\n    int calculateMinimumHP(vv& dun) {\\n        m = dun.size(), n = dun[0].size();\\n        mv = {{0, 1}, {1, 0}};\\n        int l = 1, r = 1e3 + 1;\\n        while(l < r) {\\n            vv dp(m, vector<int>(n, -1));\\n            int mid = l + (r - l) / 2;\\n            if(f(dun, dp, 0, 0, mid))\\n                r = mid;\\n            else l = mid + 1;\\n        }\\n        return l;\\n    }\\n};`\\n\\nPlease help me understand why this logic cannot give the right solution\\n\\nI make use of the dp values as a true or false (or not computed)"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "this is good type of dp problem, a little different"
                    },
                    {
                        "username": "ayush_way",
                        "content": "int solve(int i, int j, int req,vector<vector<int> > &nums,vector<vector<int>> &dp){\\n    //base cases\\n    if(i==0 && j==0)\\n    {\\n     int t=req-nums[0][0];\\n     if(t<=0) \\n     {        \\n         return 1;\\n     }  \\n    return t;\\n    }\\n    if(i<0 || j<0) return INT_MAX;\\n\\n    if(dp[i][j]!=-1) return dp[i][j];\\n    \\n   \\n    int s= req-nums[i][j];\\n    if(s<=0){\\n         int  up=solve(i-1,j,1,nums,dp);\\n       int   left=solve(i,j-1,1,nums,dp);\\n         return dp[i][j] = min(up,left);\\n    }\\n    else \\n    {\\n       int up=solve(i-1,j,req-nums[i][j],nums,dp);\\n       int  left=solve(i,j-1,req-nums[i][j],nums,dp);\\n          return dp[i][j] = min(up,left);\\n    }\\n   \\n    \\n    \\n}\\n  int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n int n=dungeon.size(),m=dungeon[0].size();\\n    vector<vector<int>> dp(n+1,vector<int> (m+1,-1));\\n    return solve(n-1,m-1,1,dungeon,dp);\\n \\n\\n\\nPlease help me !!\\n[[3,0,-3],[-3,-2,-2],[3,1,-3]] for this test case my code gives 6 but ans is 1 i dont know why is this happening please find fault in the code . Its the 31st test case out of 45.\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "This problem is pain in the ass problem. Took me few months to crack it (the problem haha but who knows what is better)"
                    },
                    {
                        "username": "sonder7",
                        "content": "we should inversely visit the array for dp instead of visiting sequently. Otherwise, we should keep the first blood and can\\'t find the logic for dp.\\n\\n```\\nclass Solution {\\npublic:\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        int m = dungeon.size();\\n        int n = dungeon[0].size();\\n        vector<vector<int>> f(m, vector<int>(n, 0x3f3f3f3f));\\n        if (dungeon[m - 1][n - 1] > 0) {\\n            f[m - 1][n - 1] = 1;\\n        } else {\\n            f[m - 1][n - 1] = 1 - dungeon[m - 1][n - 1];\\n        }\\n        for (int i = m - 1; i >= 0; i--) {\\n            for (int j = n - 1;j >= 0; j--) {\\n                if (i < m - 1) f[i][j] = max(1, f[i + 1][j] - dungeon[i][j]);\\n                if (j < n - 1) f[i][j] = min(f[i][j], max(1, f[i][j + 1] - dungeon[i][j]));\\n            }\\n        }\\n        return f[0][0];\\n    }\\n};\\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "mahendramaism",
                        "content": "Please check this test case and correct me if i am wrong. \\nhttps://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/10846 "
                    },
                    {
                        "username": "user2049D",
                        "content": "Good solution for your test case ([[-5, 1, 3],[30, -10, -3],[10, -5, -2]]) is 6.\\nDOWN, DOWN, RIGHT, RIGHT is the good path."
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "This might help understanding the overlapping subproblems. I have explained it better [here](https://leetcode.com/problems/dungeon-game/solutions/3011638/python3-calculate-extrahealth-needed-at-each-cell/)\n\n![image.png](https://assets.leetcode.com/users/images/0d90a36f-f760-48a9-8173-5a34c17da3b7_1673065577.0750911.png)"
                    }
                ]
            },
            {
                "id": 1802751,
                "content": [
                    {
                        "username": "layyy",
                        "content": "hint : start from the bottom right"
                    },
                    {
                        "username": "dhruv-1010",
                        "content": "why top-down slower?\\n"
                    },
                    {
                        "username": "guavacannes",
                        "content": " `class Solution {\\n    typedef vector<vector<int>> vv;\\n    int m, n;\\n    vector<vector<int>> mv;\\n\\n    int f(vv &dun, vv &dp, int i, int j, int a) {\\n        if(i == m - 1 && j == n - 1) return (a + dun[i][j] > 0)? 1 : 0;\\n\\n        if(dp[i][j] != -1) return dp[i][j];\\n\\n        if(a + dun[i][j] <= 0) return dp[i][j] = 0;\\n\\n        int flag = 0;\\n        for(int k = 0; k < 2; k++) {\\n\\n            int dx = i + mv[k][0], dy = j + mv[k][1];\\n            if(dx < m && dy < n) {\\n                if( f(dun, dp, dx, dy, a + dun[i][j]) )\\n                    flag = 1;      \\n            }   \\n\\n        }\\n\\n        return dp[i][j] = flag;\\n    }\\npublic:\\n    int calculateMinimumHP(vv& dun) {\\n        m = dun.size(), n = dun[0].size();\\n        mv = {{0, 1}, {1, 0}};\\n        int l = 1, r = 1e3 + 1;\\n        while(l < r) {\\n            vv dp(m, vector<int>(n, -1));\\n            int mid = l + (r - l) / 2;\\n            if(f(dun, dp, 0, 0, mid))\\n                r = mid;\\n            else l = mid + 1;\\n        }\\n        return l;\\n    }\\n};`\\n\\nPlease help me understand why this logic cannot give the right solution\\n\\nI make use of the dp values as a true or false (or not computed)"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "this is good type of dp problem, a little different"
                    },
                    {
                        "username": "ayush_way",
                        "content": "int solve(int i, int j, int req,vector<vector<int> > &nums,vector<vector<int>> &dp){\\n    //base cases\\n    if(i==0 && j==0)\\n    {\\n     int t=req-nums[0][0];\\n     if(t<=0) \\n     {        \\n         return 1;\\n     }  \\n    return t;\\n    }\\n    if(i<0 || j<0) return INT_MAX;\\n\\n    if(dp[i][j]!=-1) return dp[i][j];\\n    \\n   \\n    int s= req-nums[i][j];\\n    if(s<=0){\\n         int  up=solve(i-1,j,1,nums,dp);\\n       int   left=solve(i,j-1,1,nums,dp);\\n         return dp[i][j] = min(up,left);\\n    }\\n    else \\n    {\\n       int up=solve(i-1,j,req-nums[i][j],nums,dp);\\n       int  left=solve(i,j-1,req-nums[i][j],nums,dp);\\n          return dp[i][j] = min(up,left);\\n    }\\n   \\n    \\n    \\n}\\n  int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n int n=dungeon.size(),m=dungeon[0].size();\\n    vector<vector<int>> dp(n+1,vector<int> (m+1,-1));\\n    return solve(n-1,m-1,1,dungeon,dp);\\n \\n\\n\\nPlease help me !!\\n[[3,0,-3],[-3,-2,-2],[3,1,-3]] for this test case my code gives 6 but ans is 1 i dont know why is this happening please find fault in the code . Its the 31st test case out of 45.\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "This problem is pain in the ass problem. Took me few months to crack it (the problem haha but who knows what is better)"
                    },
                    {
                        "username": "sonder7",
                        "content": "we should inversely visit the array for dp instead of visiting sequently. Otherwise, we should keep the first blood and can\\'t find the logic for dp.\\n\\n```\\nclass Solution {\\npublic:\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        int m = dungeon.size();\\n        int n = dungeon[0].size();\\n        vector<vector<int>> f(m, vector<int>(n, 0x3f3f3f3f));\\n        if (dungeon[m - 1][n - 1] > 0) {\\n            f[m - 1][n - 1] = 1;\\n        } else {\\n            f[m - 1][n - 1] = 1 - dungeon[m - 1][n - 1];\\n        }\\n        for (int i = m - 1; i >= 0; i--) {\\n            for (int j = n - 1;j >= 0; j--) {\\n                if (i < m - 1) f[i][j] = max(1, f[i + 1][j] - dungeon[i][j]);\\n                if (j < n - 1) f[i][j] = min(f[i][j], max(1, f[i][j + 1] - dungeon[i][j]));\\n            }\\n        }\\n        return f[0][0];\\n    }\\n};\\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "mahendramaism",
                        "content": "Please check this test case and correct me if i am wrong. \\nhttps://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/10846 "
                    },
                    {
                        "username": "user2049D",
                        "content": "Good solution for your test case ([[-5, 1, 3],[30, -10, -3],[10, -5, -2]]) is 6.\\nDOWN, DOWN, RIGHT, RIGHT is the good path."
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "This might help understanding the overlapping subproblems. I have explained it better [here](https://leetcode.com/problems/dungeon-game/solutions/3011638/python3-calculate-extrahealth-needed-at-each-cell/)\n\n![image.png](https://assets.leetcode.com/users/images/0d90a36f-f760-48a9-8173-5a34c17da3b7_1673065577.0750911.png)"
                    }
                ]
            },
            {
                "id": 1756387,
                "content": [
                    {
                        "username": "layyy",
                        "content": "hint : start from the bottom right"
                    },
                    {
                        "username": "dhruv-1010",
                        "content": "why top-down slower?\\n"
                    },
                    {
                        "username": "guavacannes",
                        "content": " `class Solution {\\n    typedef vector<vector<int>> vv;\\n    int m, n;\\n    vector<vector<int>> mv;\\n\\n    int f(vv &dun, vv &dp, int i, int j, int a) {\\n        if(i == m - 1 && j == n - 1) return (a + dun[i][j] > 0)? 1 : 0;\\n\\n        if(dp[i][j] != -1) return dp[i][j];\\n\\n        if(a + dun[i][j] <= 0) return dp[i][j] = 0;\\n\\n        int flag = 0;\\n        for(int k = 0; k < 2; k++) {\\n\\n            int dx = i + mv[k][0], dy = j + mv[k][1];\\n            if(dx < m && dy < n) {\\n                if( f(dun, dp, dx, dy, a + dun[i][j]) )\\n                    flag = 1;      \\n            }   \\n\\n        }\\n\\n        return dp[i][j] = flag;\\n    }\\npublic:\\n    int calculateMinimumHP(vv& dun) {\\n        m = dun.size(), n = dun[0].size();\\n        mv = {{0, 1}, {1, 0}};\\n        int l = 1, r = 1e3 + 1;\\n        while(l < r) {\\n            vv dp(m, vector<int>(n, -1));\\n            int mid = l + (r - l) / 2;\\n            if(f(dun, dp, 0, 0, mid))\\n                r = mid;\\n            else l = mid + 1;\\n        }\\n        return l;\\n    }\\n};`\\n\\nPlease help me understand why this logic cannot give the right solution\\n\\nI make use of the dp values as a true or false (or not computed)"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "this is good type of dp problem, a little different"
                    },
                    {
                        "username": "ayush_way",
                        "content": "int solve(int i, int j, int req,vector<vector<int> > &nums,vector<vector<int>> &dp){\\n    //base cases\\n    if(i==0 && j==0)\\n    {\\n     int t=req-nums[0][0];\\n     if(t<=0) \\n     {        \\n         return 1;\\n     }  \\n    return t;\\n    }\\n    if(i<0 || j<0) return INT_MAX;\\n\\n    if(dp[i][j]!=-1) return dp[i][j];\\n    \\n   \\n    int s= req-nums[i][j];\\n    if(s<=0){\\n         int  up=solve(i-1,j,1,nums,dp);\\n       int   left=solve(i,j-1,1,nums,dp);\\n         return dp[i][j] = min(up,left);\\n    }\\n    else \\n    {\\n       int up=solve(i-1,j,req-nums[i][j],nums,dp);\\n       int  left=solve(i,j-1,req-nums[i][j],nums,dp);\\n          return dp[i][j] = min(up,left);\\n    }\\n   \\n    \\n    \\n}\\n  int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n int n=dungeon.size(),m=dungeon[0].size();\\n    vector<vector<int>> dp(n+1,vector<int> (m+1,-1));\\n    return solve(n-1,m-1,1,dungeon,dp);\\n \\n\\n\\nPlease help me !!\\n[[3,0,-3],[-3,-2,-2],[3,1,-3]] for this test case my code gives 6 but ans is 1 i dont know why is this happening please find fault in the code . Its the 31st test case out of 45.\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "This problem is pain in the ass problem. Took me few months to crack it (the problem haha but who knows what is better)"
                    },
                    {
                        "username": "sonder7",
                        "content": "we should inversely visit the array for dp instead of visiting sequently. Otherwise, we should keep the first blood and can\\'t find the logic for dp.\\n\\n```\\nclass Solution {\\npublic:\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        int m = dungeon.size();\\n        int n = dungeon[0].size();\\n        vector<vector<int>> f(m, vector<int>(n, 0x3f3f3f3f));\\n        if (dungeon[m - 1][n - 1] > 0) {\\n            f[m - 1][n - 1] = 1;\\n        } else {\\n            f[m - 1][n - 1] = 1 - dungeon[m - 1][n - 1];\\n        }\\n        for (int i = m - 1; i >= 0; i--) {\\n            for (int j = n - 1;j >= 0; j--) {\\n                if (i < m - 1) f[i][j] = max(1, f[i + 1][j] - dungeon[i][j]);\\n                if (j < n - 1) f[i][j] = min(f[i][j], max(1, f[i][j + 1] - dungeon[i][j]));\\n            }\\n        }\\n        return f[0][0];\\n    }\\n};\\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "mahendramaism",
                        "content": "Please check this test case and correct me if i am wrong. \\nhttps://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/10846 "
                    },
                    {
                        "username": "user2049D",
                        "content": "Good solution for your test case ([[-5, 1, 3],[30, -10, -3],[10, -5, -2]]) is 6.\\nDOWN, DOWN, RIGHT, RIGHT is the good path."
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "This might help understanding the overlapping subproblems. I have explained it better [here](https://leetcode.com/problems/dungeon-game/solutions/3011638/python3-calculate-extrahealth-needed-at-each-cell/)\n\n![image.png](https://assets.leetcode.com/users/images/0d90a36f-f760-48a9-8173-5a34c17da3b7_1673065577.0750911.png)"
                    }
                ]
            },
            {
                "id": 1747631,
                "content": [
                    {
                        "username": "layyy",
                        "content": "hint : start from the bottom right"
                    },
                    {
                        "username": "dhruv-1010",
                        "content": "why top-down slower?\\n"
                    },
                    {
                        "username": "guavacannes",
                        "content": " `class Solution {\\n    typedef vector<vector<int>> vv;\\n    int m, n;\\n    vector<vector<int>> mv;\\n\\n    int f(vv &dun, vv &dp, int i, int j, int a) {\\n        if(i == m - 1 && j == n - 1) return (a + dun[i][j] > 0)? 1 : 0;\\n\\n        if(dp[i][j] != -1) return dp[i][j];\\n\\n        if(a + dun[i][j] <= 0) return dp[i][j] = 0;\\n\\n        int flag = 0;\\n        for(int k = 0; k < 2; k++) {\\n\\n            int dx = i + mv[k][0], dy = j + mv[k][1];\\n            if(dx < m && dy < n) {\\n                if( f(dun, dp, dx, dy, a + dun[i][j]) )\\n                    flag = 1;      \\n            }   \\n\\n        }\\n\\n        return dp[i][j] = flag;\\n    }\\npublic:\\n    int calculateMinimumHP(vv& dun) {\\n        m = dun.size(), n = dun[0].size();\\n        mv = {{0, 1}, {1, 0}};\\n        int l = 1, r = 1e3 + 1;\\n        while(l < r) {\\n            vv dp(m, vector<int>(n, -1));\\n            int mid = l + (r - l) / 2;\\n            if(f(dun, dp, 0, 0, mid))\\n                r = mid;\\n            else l = mid + 1;\\n        }\\n        return l;\\n    }\\n};`\\n\\nPlease help me understand why this logic cannot give the right solution\\n\\nI make use of the dp values as a true or false (or not computed)"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "this is good type of dp problem, a little different"
                    },
                    {
                        "username": "ayush_way",
                        "content": "int solve(int i, int j, int req,vector<vector<int> > &nums,vector<vector<int>> &dp){\\n    //base cases\\n    if(i==0 && j==0)\\n    {\\n     int t=req-nums[0][0];\\n     if(t<=0) \\n     {        \\n         return 1;\\n     }  \\n    return t;\\n    }\\n    if(i<0 || j<0) return INT_MAX;\\n\\n    if(dp[i][j]!=-1) return dp[i][j];\\n    \\n   \\n    int s= req-nums[i][j];\\n    if(s<=0){\\n         int  up=solve(i-1,j,1,nums,dp);\\n       int   left=solve(i,j-1,1,nums,dp);\\n         return dp[i][j] = min(up,left);\\n    }\\n    else \\n    {\\n       int up=solve(i-1,j,req-nums[i][j],nums,dp);\\n       int  left=solve(i,j-1,req-nums[i][j],nums,dp);\\n          return dp[i][j] = min(up,left);\\n    }\\n   \\n    \\n    \\n}\\n  int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n int n=dungeon.size(),m=dungeon[0].size();\\n    vector<vector<int>> dp(n+1,vector<int> (m+1,-1));\\n    return solve(n-1,m-1,1,dungeon,dp);\\n \\n\\n\\nPlease help me !!\\n[[3,0,-3],[-3,-2,-2],[3,1,-3]] for this test case my code gives 6 but ans is 1 i dont know why is this happening please find fault in the code . Its the 31st test case out of 45.\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "This problem is pain in the ass problem. Took me few months to crack it (the problem haha but who knows what is better)"
                    },
                    {
                        "username": "sonder7",
                        "content": "we should inversely visit the array for dp instead of visiting sequently. Otherwise, we should keep the first blood and can\\'t find the logic for dp.\\n\\n```\\nclass Solution {\\npublic:\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        int m = dungeon.size();\\n        int n = dungeon[0].size();\\n        vector<vector<int>> f(m, vector<int>(n, 0x3f3f3f3f));\\n        if (dungeon[m - 1][n - 1] > 0) {\\n            f[m - 1][n - 1] = 1;\\n        } else {\\n            f[m - 1][n - 1] = 1 - dungeon[m - 1][n - 1];\\n        }\\n        for (int i = m - 1; i >= 0; i--) {\\n            for (int j = n - 1;j >= 0; j--) {\\n                if (i < m - 1) f[i][j] = max(1, f[i + 1][j] - dungeon[i][j]);\\n                if (j < n - 1) f[i][j] = min(f[i][j], max(1, f[i][j + 1] - dungeon[i][j]));\\n            }\\n        }\\n        return f[0][0];\\n    }\\n};\\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "mahendramaism",
                        "content": "Please check this test case and correct me if i am wrong. \\nhttps://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/10846 "
                    },
                    {
                        "username": "user2049D",
                        "content": "Good solution for your test case ([[-5, 1, 3],[30, -10, -3],[10, -5, -2]]) is 6.\\nDOWN, DOWN, RIGHT, RIGHT is the good path."
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "This might help understanding the overlapping subproblems. I have explained it better [here](https://leetcode.com/problems/dungeon-game/solutions/3011638/python3-calculate-extrahealth-needed-at-each-cell/)\n\n![image.png](https://assets.leetcode.com/users/images/0d90a36f-f760-48a9-8173-5a34c17da3b7_1673065577.0750911.png)"
                    }
                ]
            },
            {
                "id": 1745676,
                "content": [
                    {
                        "username": "layyy",
                        "content": "hint : start from the bottom right"
                    },
                    {
                        "username": "dhruv-1010",
                        "content": "why top-down slower?\\n"
                    },
                    {
                        "username": "guavacannes",
                        "content": " `class Solution {\\n    typedef vector<vector<int>> vv;\\n    int m, n;\\n    vector<vector<int>> mv;\\n\\n    int f(vv &dun, vv &dp, int i, int j, int a) {\\n        if(i == m - 1 && j == n - 1) return (a + dun[i][j] > 0)? 1 : 0;\\n\\n        if(dp[i][j] != -1) return dp[i][j];\\n\\n        if(a + dun[i][j] <= 0) return dp[i][j] = 0;\\n\\n        int flag = 0;\\n        for(int k = 0; k < 2; k++) {\\n\\n            int dx = i + mv[k][0], dy = j + mv[k][1];\\n            if(dx < m && dy < n) {\\n                if( f(dun, dp, dx, dy, a + dun[i][j]) )\\n                    flag = 1;      \\n            }   \\n\\n        }\\n\\n        return dp[i][j] = flag;\\n    }\\npublic:\\n    int calculateMinimumHP(vv& dun) {\\n        m = dun.size(), n = dun[0].size();\\n        mv = {{0, 1}, {1, 0}};\\n        int l = 1, r = 1e3 + 1;\\n        while(l < r) {\\n            vv dp(m, vector<int>(n, -1));\\n            int mid = l + (r - l) / 2;\\n            if(f(dun, dp, 0, 0, mid))\\n                r = mid;\\n            else l = mid + 1;\\n        }\\n        return l;\\n    }\\n};`\\n\\nPlease help me understand why this logic cannot give the right solution\\n\\nI make use of the dp values as a true or false (or not computed)"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "this is good type of dp problem, a little different"
                    },
                    {
                        "username": "ayush_way",
                        "content": "int solve(int i, int j, int req,vector<vector<int> > &nums,vector<vector<int>> &dp){\\n    //base cases\\n    if(i==0 && j==0)\\n    {\\n     int t=req-nums[0][0];\\n     if(t<=0) \\n     {        \\n         return 1;\\n     }  \\n    return t;\\n    }\\n    if(i<0 || j<0) return INT_MAX;\\n\\n    if(dp[i][j]!=-1) return dp[i][j];\\n    \\n   \\n    int s= req-nums[i][j];\\n    if(s<=0){\\n         int  up=solve(i-1,j,1,nums,dp);\\n       int   left=solve(i,j-1,1,nums,dp);\\n         return dp[i][j] = min(up,left);\\n    }\\n    else \\n    {\\n       int up=solve(i-1,j,req-nums[i][j],nums,dp);\\n       int  left=solve(i,j-1,req-nums[i][j],nums,dp);\\n          return dp[i][j] = min(up,left);\\n    }\\n   \\n    \\n    \\n}\\n  int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n int n=dungeon.size(),m=dungeon[0].size();\\n    vector<vector<int>> dp(n+1,vector<int> (m+1,-1));\\n    return solve(n-1,m-1,1,dungeon,dp);\\n \\n\\n\\nPlease help me !!\\n[[3,0,-3],[-3,-2,-2],[3,1,-3]] for this test case my code gives 6 but ans is 1 i dont know why is this happening please find fault in the code . Its the 31st test case out of 45.\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "This problem is pain in the ass problem. Took me few months to crack it (the problem haha but who knows what is better)"
                    },
                    {
                        "username": "sonder7",
                        "content": "we should inversely visit the array for dp instead of visiting sequently. Otherwise, we should keep the first blood and can\\'t find the logic for dp.\\n\\n```\\nclass Solution {\\npublic:\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        int m = dungeon.size();\\n        int n = dungeon[0].size();\\n        vector<vector<int>> f(m, vector<int>(n, 0x3f3f3f3f));\\n        if (dungeon[m - 1][n - 1] > 0) {\\n            f[m - 1][n - 1] = 1;\\n        } else {\\n            f[m - 1][n - 1] = 1 - dungeon[m - 1][n - 1];\\n        }\\n        for (int i = m - 1; i >= 0; i--) {\\n            for (int j = n - 1;j >= 0; j--) {\\n                if (i < m - 1) f[i][j] = max(1, f[i + 1][j] - dungeon[i][j]);\\n                if (j < n - 1) f[i][j] = min(f[i][j], max(1, f[i][j + 1] - dungeon[i][j]));\\n            }\\n        }\\n        return f[0][0];\\n    }\\n};\\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "mahendramaism",
                        "content": "Please check this test case and correct me if i am wrong. \\nhttps://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/10846 "
                    },
                    {
                        "username": "user2049D",
                        "content": "Good solution for your test case ([[-5, 1, 3],[30, -10, -3],[10, -5, -2]]) is 6.\\nDOWN, DOWN, RIGHT, RIGHT is the good path."
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "This might help understanding the overlapping subproblems. I have explained it better [here](https://leetcode.com/problems/dungeon-game/solutions/3011638/python3-calculate-extrahealth-needed-at-each-cell/)\n\n![image.png](https://assets.leetcode.com/users/images/0d90a36f-f760-48a9-8173-5a34c17da3b7_1673065577.0750911.png)"
                    }
                ]
            }
        ]
    },
    {
        "title": "Maximum Width of Binary Tree",
        "question_content": "<p>Given the <code>root</code> of a binary tree, return <em>the <strong>maximum width</strong> of the given tree</em>.</p>\n\n<p>The <strong>maximum width</strong> of a tree is the maximum <strong>width</strong> among all levels.</p>\n\n<p>The <strong>width</strong> of one level is defined as the length between the end-nodes (the leftmost and rightmost non-null nodes), where the null nodes between the end-nodes that would be present in a complete binary tree extending down to that level are also counted into the length calculation.</p>\n\n<p>It is <strong>guaranteed</strong> that the answer will in the range of a <strong>32-bit</strong> signed integer.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/05/03/width1-tree.jpg\" style=\"width: 359px; height: 302px;\" />\n<pre>\n<strong>Input:</strong> root = [1,3,2,5,3,null,9]\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> The maximum width exists in the third level with length 4 (5,3,null,9).\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/03/14/maximum-width-of-binary-tree-v3.jpg\" style=\"width: 442px; height: 422px;\" />\n<pre>\n<strong>Input:</strong> root = [1,3,2,5,null,null,9,6,null,7]\n<strong>Output:</strong> 7\n<strong>Explanation:</strong> The maximum width exists in the fourth level with length 7 (6,null,null,null,null,null,7).\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/05/03/width3-tree.jpg\" style=\"width: 289px; height: 299px;\" />\n<pre>\n<strong>Input:</strong> root = [1,3,2,5]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> The maximum width exists in the second level with length 2 (3,2).\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[1, 3000]</code>.</li>\n\t<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 1802311,
                "title": "c-bfs-easy-to-understand-full-explanation",
                "content": "# 662. Maximum Width of Binary Tree\\n**KNOCKCAT**\\n\\n```\\n1. Easy C++\\n2. Line by Line Explanation with Comments.\\n3. BFS (breadth first Search)\\n4. Detailed Explanation \\u2705\\n5. Please Upvote if it helps\\u2B06\\uFE0F\\n6. Link to my Github Profile contains a repository of Leetcode with all my Solutions. \\u2B07\\uFE0F\\n\\t// \\uD83D\\uDE09If you Like the repository don\\'t foget to star & fork the repository\\uD83D\\uDE09 \\n```\\n[LeetCode](https://github.com/knockcat/Leetcode)       **Link to LeetCode Repository**\\n\\n\\n* **EXPLANATION**\\n```\\n1.  According to Problem , we have also to count null nodes b/w two nodes.\\n\\n\\t\\t  5\\t\\t\\t\\t\\t1\\n\\t     / \\\\\\n\\t    3   6\\t\\t\\t\\t2\\n\\t   /   /\\n\\t  2   4\\t\\t\\t\\t\\t2\\n\\n2.  Above example we have max 2 nodes in a level, but if you see the second level you\\nwill find that right child of 3 is NULL and therefore we also have to count that \\nNULL node, and with that the last level now contain 3 nodes, refer to diagram below.\\n\\n\\t      5\\t\\t\\t\\t\\t1\\n\\t   /     \\\\\\n\\t   3      6\\t\\t\\t\\t2\\n\\t /  \\\\    /\\n\\t2  NULL  4\\t\\t\\t\\t3 (NULL node also counted)\\n\\nSo Last Level Contains 3 Nodes Including NULL.\\n\\n3 . We will also assign index to every node\\n\\n\\t(if we are startting index from 0)\\n\\taccording to binary heap\\n\\n\\tleft(idx) = 2 idx + 1\\t\\t\\t// left child\\n\\tright(idx) = 2 idx + 2\\t\\t\\t// right child\\n\\n\\nwe will also insert index with node , so that we will know,\\nthe first element at index __ & the last node is at index __\\n```\\n\\n* **LET CONSIDER THE DRY RUN FOR ABOVE EXAMPLE**\\n\\n```\\n\\t      5\\t\\t\\t\\t\\t    1\\n\\t   /     \\\\\\n\\t   3      6\\t\\t\\t\\t\\t2\\n\\t /  \\\\    /\\n\\t2  NULL  4\\t\\t\\t\\t    3 (NULL node also counted)\\n\\n\\nif root is empty // return NULL\\n\\ninsert(5, 0) in queue,  queue is not empty\\nwe will continue.\\n\\nres = 1; \\n\\n1. pop(5,0);\\n\\n\\tnow we look at size of queue, size is one therefore\\n\\tand now we will insert,\\n\\tleft and right child of popped node that is 5 in this case\\n\\ttherefore,  \\n2. (3,1) , (6,2)  is inserted.\\n\\nwhen we will finish with one iteration,\\nwe will see the index of first element and index of last element in the current level..\\n\\ni.e difference,\\n\\n(2 - 1) + 1 and we will assign this to result.\\n\\nso we will check  as,   res  = max(res, endIdx - startIdx + 1)\\n\\t\\t\\t\\tres  = max(0, (2-1) + 1)\\n\\t\\t\\t\\tres  = 2\\n\\n3. Now (3,1)  is poped and its left and right child will be inserted.\\n\\n\\ti.e (2,3)  its right is empty it will not insert\\n\\n   Poped (6,2)\\n\\tand now right & left child of (6,2) will inserted.\\n\\n\\ti.e (4,5) its right is empty it will not insert,\\n\\nnow at this level the startIdx is 3 (2,3)  & the endIndx is 5\\n\\ntherefore res = max(res  = max(res, endIdx - startIdx + 1)\\n\\t    res = max(2, (5-3) + 1)\\n\\t    res = 3\\n\\n4. Now we will pop it and now there is nothing to push.\\n\\nSo finally we will return the result... (3)\\n\\n\\nAs tree is Going Exponentially so we can come accross signed overflow,\\ntherefore for preventing that we will do,\\n\\n\\tint idx = p.second - start;\\n\\nas we don\\'t need  previous values. also we will type cast 2 * idx to  long long\\n```\\n\\n *AS EACH NODE IS VISITED ONCE*\\n\\t\\t\\t\\t**Time Complexity O(N)\\n\\t\\t\\t\\tSpace Comlexity O(N)**\\n\\n **CODE WITH EXPLANATION**\\n```\\n\\t\\t\\t\\t\\t\\t// \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09Please upvote if it helps \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\nclass Solution {\\npublic:\\n    int widthOfBinaryTree(TreeNode* root) {\\n        if(root == NULL)\\n            return 0;\\n        \\n        long long res = 1;\\n        queue<pair<TreeNode*, long long>> q;\\n        \\n        // I am using intialising list\\n        q.push({root, 0});      // also can use make_pair\\n        \\n        while(!q.empty())\\n        {\\n            long long cnt = q.size();\\n            // start is the index of root node for first level\\n            long long start = q.front().second;\\n            long long end = q.back().second;\\n            \\n            res = max(res,end-start + 1);\\n            \\n            for(int i = 0; i <cnt; ++i)\\n            {\\n                pair<TreeNode*, int> p = q.front();\\n                // we will use it while inserting it children\\n                // left child will be 2 * idx + 1;\\n                // right chils will be 2 * idx + 2;\\n                long long idx = p.second - start;\\n                \\n                q.pop();\\n                \\n                // if  left child exist\\n                if(p.first->left != NULL)\\n                    q.push({p.first->left, (long long)2 * idx + 1});\\n                \\n                // if right child exist\\n                if(p.first->right != NULL)\\n                    q.push({p.first->right, (long long) 2 * idx + 2});\\n            }\\n        }\\n        \\n        return res;\\n        \\n    }\\n};\\n```\\n\\n**HOW WE ARE PREVENTING SIGNED OVERFLOW**\\nwe have to prevent signed overflowe that\\'s why..\\n\\nConsider if we have a sparse tree like this\\n\\n```\\n\\t\\t\\t\\t\\t   90\\n\\t                  /  \\\\\\n                     45   110\\n                     /\\t    \\\\\\n                   34\\t     130\\n\\t               /\\t\\t    \\\\\\n\\t\\t\\t\\t24               200\\n\\t\\t\\t\\t/\\t\\t          \\\\\\t\\n\\t\\t        and so  on increasing\\n```\\n**If each level contains only 2 nodes**\\n1            (2^0)\\n2\\t      (2^1)\\n4\\t      (2^2)\\n8\\t     (2^3 and so  on)\\n16\\t\\n\\'\\t    (**2 ^ level**)\\n\\'\\n\\'\\n\\'\\n\\'\\nthey will increase in this fashion.\\n\\nso even though we have  2 nodes on each level but indexes for null nodes will also be counted,\\nas these are the  left most and right most nodes. all the intermediate nodes indeces will \\nconsumed even they are not present \\n\\n**so after 31 levels it will come upto 2^31 which will become greater than the value of INT_MAX**\\nso we have to take **long long but also after 2 ^ 63 the long long limit will also be reached** \\nso we have to optimised the code in some way.\\n\\n*we are pushing one level and popping one level so we are working with 1 level at a time or we say \\n2 level at a time*\\nso when iteration end all the nodes in the queue are of one level\\n**so we are bothered about only 2 level at a time.**\\n\\nfrom 3 to 6\\nwe know the first index is 3 here and last index is 6\\n**so does it matter if the index is from 3 - 6 or 0 - 3**\\n\\nfrom 7 to 14\\nthe index which is 7 - 14 can be represednted as 0 - 7\\n**so we see the diff is 7 in both the case.**\\n\\nso in all levels it will propogate like that\\n\\n**so once we will done with the level we will reset it and we will take first index as 0 always.**\\nso if it started from 33 to 64\\nso it will become 0 and frome 64 we will subtract 33\\n\\nso from 0 to 31\\n\\n**so that\\'s why we are doing this ( int idx = p.second - start)   to prevent the overflow.**\\n\\n**Hope Everything is clear now.**\\n\\n",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\n1. Easy C++\\n2. Line by Line Explanation with Comments.\\n3. BFS (breadth first Search)\\n4. Detailed Explanation \\u2705\\n5. Please Upvote if it helps\\u2B06\\uFE0F\\n6. Link to my Github Profile contains a repository of Leetcode with all my Solutions. \\u2B07\\uFE0F\\n\\t// \\uD83D\\uDE09If you Like the repository don\\'t foget to star & fork the repository\\uD83D\\uDE09 \\n```\n```\\n1.  According to Problem , we have also to count null nodes b/w two nodes.\\n\\n\\t\\t  5\\t\\t\\t\\t\\t1\\n\\t     / \\\\\\n\\t    3   6\\t\\t\\t\\t2\\n\\t   /   /\\n\\t  2   4\\t\\t\\t\\t\\t2\\n\\n2.  Above example we have max 2 nodes in a level, but if you see the second level you\\nwill find that right child of 3 is NULL and therefore we also have to count that \\nNULL node, and with that the last level now contain 3 nodes, refer to diagram below.\\n\\n\\t      5\\t\\t\\t\\t\\t1\\n\\t   /     \\\\\\n\\t   3      6\\t\\t\\t\\t2\\n\\t /  \\\\    /\\n\\t2  NULL  4\\t\\t\\t\\t3 (NULL node also counted)\\n\\nSo Last Level Contains 3 Nodes Including NULL.\\n\\n3 . We will also assign index to every node\\n\\n\\t(if we are startting index from 0)\\n\\taccording to binary heap\\n\\n\\tleft(idx) = 2 idx + 1\\t\\t\\t// left child\\n\\tright(idx) = 2 idx + 2\\t\\t\\t// right child\\n\\n\\nwe will also insert index with node , so that we will know,\\nthe first element at index __ & the last node is at index __\\n```\n```\\n\\t      5\\t\\t\\t\\t\\t    1\\n\\t   /     \\\\\\n\\t   3      6\\t\\t\\t\\t\\t2\\n\\t /  \\\\    /\\n\\t2  NULL  4\\t\\t\\t\\t    3 (NULL node also counted)\\n\\n\\nif root is empty // return NULL\\n\\ninsert(5, 0) in queue,  queue is not empty\\nwe will continue.\\n\\nres = 1; \\n\\n1. pop(5,0);\\n\\n\\tnow we look at size of queue, size is one therefore\\n\\tand now we will insert,\\n\\tleft and right child of popped node that is 5 in this case\\n\\ttherefore,  \\n2. (3,1) , (6,2)  is inserted.\\n\\nwhen we will finish with one iteration,\\nwe will see the index of first element and index of last element in the current level..\\n\\ni.e difference,\\n\\n(2 - 1) + 1 and we will assign this to result.\\n\\nso we will check  as,   res  = max(res, endIdx - startIdx + 1)\\n\\t\\t\\t\\tres  = max(0, (2-1) + 1)\\n\\t\\t\\t\\tres  = 2\\n\\n3. Now (3,1)  is poped and its left and right child will be inserted.\\n\\n\\ti.e (2,3)  its right is empty it will not insert\\n\\n   Poped (6,2)\\n\\tand now right & left child of (6,2) will inserted.\\n\\n\\ti.e (4,5) its right is empty it will not insert,\\n\\nnow at this level the startIdx is 3 (2,3)  & the endIndx is 5\\n\\ntherefore res = max(res  = max(res, endIdx - startIdx + 1)\\n\\t    res = max(2, (5-3) + 1)\\n\\t    res = 3\\n\\n4. Now we will pop it and now there is nothing to push.\\n\\nSo finally we will return the result... (3)\\n\\n\\nAs tree is Going Exponentially so we can come accross signed overflow,\\ntherefore for preventing that we will do,\\n\\n\\tint idx = p.second - start;\\n\\nas we don\\'t need  previous values. also we will type cast 2 * idx to  long long\\n```\n```\\n\\t\\t\\t\\t\\t\\t// \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09Please upvote if it helps \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\nclass Solution {\\npublic:\\n    int widthOfBinaryTree(TreeNode* root) {\\n        if(root == NULL)\\n            return 0;\\n        \\n        long long res = 1;\\n        queue<pair<TreeNode*, long long>> q;\\n        \\n        // I am using intialising list\\n        q.push({root, 0});      // also can use make_pair\\n        \\n        while(!q.empty())\\n        {\\n            long long cnt = q.size();\\n            // start is the index of root node for first level\\n            long long start = q.front().second;\\n            long long end = q.back().second;\\n            \\n            res = max(res,end-start + 1);\\n            \\n            for(int i = 0; i <cnt; ++i)\\n            {\\n                pair<TreeNode*, int> p = q.front();\\n                // we will use it while inserting it children\\n                // left child will be 2 * idx + 1;\\n                // right chils will be 2 * idx + 2;\\n                long long idx = p.second - start;\\n                \\n                q.pop();\\n                \\n                // if  left child exist\\n                if(p.first->left != NULL)\\n                    q.push({p.first->left, (long long)2 * idx + 1});\\n                \\n                // if right child exist\\n                if(p.first->right != NULL)\\n                    q.push({p.first->right, (long long) 2 * idx + 2});\\n            }\\n        }\\n        \\n        return res;\\n        \\n    }\\n};\\n```\n```\\n\\t\\t\\t\\t\\t   90\\n\\t                  /  \\\\\\n                     45   110\\n                     /\\t    \\\\\\n                   34\\t     130\\n\\t               /\\t\\t    \\\\\\n\\t\\t\\t\\t24               200\\n\\t\\t\\t\\t/\\t\\t          \\\\\\t\\n\\t\\t        and so  on increasing\\n```",
                "codeTag": "Java"
            },
            {
                "id": 106653,
                "title": "java-one-queue-solution-with-hashmap",
                "content": "The idea is to traverse all the node in the tree in level order(Here I use one Queue to store each level's nodes. The time I traverse each level is the queue's size(the number of nodes from upper level)). Each time a node is traversed, the position of the node(as it is in a full binary tree) is stored in the HashMap. If the position of the parent node is 'n', then the left child is '2 * n' and the right child is '2 * n + 1'. The width of each level is the last node's position in this level subtracts the first node's position in this level plus 1.\\n```\\nclass Solution {\\n    public int widthOfBinaryTree(TreeNode root) {\\n        if(root == null) return 0;\\n        Queue<TreeNode> q = new LinkedList<TreeNode>();\\n        Map<TreeNode, Integer> m = new HashMap<TreeNode, Integer>();\\n        q.offer(root);\\n        m.put(root, 1);\\n        int curW = 0;\\n        int maxW = 0;\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            int start = 0;\\n            int end = 0;\\n            for(int i = 0; i < size; i++){\\n                TreeNode node = q.poll();\\n                if(i == 0) start = m.get(node);\\n                if(i == size - 1) end = m.get(node);\\n                if(node.left != null){\\n                    m.put(node.left, m.get(node) * 2);\\n                    q.offer(node.left);\\n                }\\n                if(node.right != null){\\n                    m.put(node.right, m.get(node) * 2 + 1);\\n                    q.offer(node.right);\\n                }\\n            }\\n            curW = end - start + 1;\\n            maxW = Math.max(curW, maxW);\\n        }\\n        return maxW;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int widthOfBinaryTree(TreeNode root) {\\n        if(root == null) return 0;\\n        Queue<TreeNode> q = new LinkedList<TreeNode>();\\n        Map<TreeNode, Integer> m = new HashMap<TreeNode, Integer>();\\n        q.offer(root);\\n        m.put(root, 1);\\n        int curW = 0;\\n        int maxW = 0;\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            int start = 0;\\n            int end = 0;\\n            for(int i = 0; i < size; i++){\\n                TreeNode node = q.poll();\\n                if(i == 0) start = m.get(node);\\n                if(i == size - 1) end = m.get(node);\\n                if(node.left != null){\\n                    m.put(node.left, m.get(node) * 2);\\n                    q.offer(node.left);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 106654,
                "title": "java-c-very-simple-dfs-solution",
                "content": "We know that  a binary tree can be represented by an array  (assume the root begins from the position with  index ```1``` in the array). If the index of a node is ```i```, the indices of its two children are ```2*i ``` and ```2*i + 1```. The idea is to use two arrays (```start[]``` and ```end[]```) to record the the indices of the leftmost node and rightmost node in each level, respectively. For each level of the tree, the width is  ```end[level] - start[level] + 1```. Then, we just need to find the maximum width.\\n\\nJava version:\\n```\\n    public int widthOfBinaryTree(TreeNode root) {\\n        return dfs(root, 0, 1, new ArrayList<Integer>(), new ArrayList<Integer>());\\n    }\\n    \\n    public int dfs(TreeNode root, int level, int order, List<Integer> start, List<Integer> end){\\n        if(root == null)return 0;\\n        if(start.size() == level){\\n            start.add(order); end.add(order);\\n        }\\n        else end.set(level, order);\\n        int cur = end.get(level) - start.get(level) + 1;\\n        int left = dfs(root.left, level + 1, 2*order, start, end);\\n        int right = dfs(root.right, level + 1, 2*order + 1, start, end);\\n        return Math.max(cur, Math.max(left, right));\\n    }\\n```\\n\\nC++ version (use ```vector<pair<int,int>>``` to replace the arrays ```start``` and ```end``` in Java ):\\n```\\n   int widthOfBinaryTree(TreeNode* root) {\\n        return dfs(root, 0, 1, vector<pair<int, int>>() = {});\\n    }\\n    \\n    int dfs(TreeNode* root, int level, int order, vector<pair<int, int>>& vec){\\n        if(root == NULL)return 0;\\n        if(vec.size() == level)vec.push_back({order, order});\\n        else vec[level].second = order;\\n        return max({vec[level].second - vec[level].first + 1, dfs(root->left, level + 1, 2*order, vec), dfs(root->right, level + 1, 2*order + 1, vec)});\\n    }\\n```",
                "solutionTags": [],
                "code": "```1```\n```i```\n```2*i ```\n```2*i + 1```\n```start[]```\n```end[]```\n```end[level] - start[level] + 1```\n```\\n    public int widthOfBinaryTree(TreeNode root) {\\n        return dfs(root, 0, 1, new ArrayList<Integer>(), new ArrayList<Integer>());\\n    }\\n    \\n    public int dfs(TreeNode root, int level, int order, List<Integer> start, List<Integer> end){\\n        if(root == null)return 0;\\n        if(start.size() == level){\\n            start.add(order); end.add(order);\\n        }\\n        else end.set(level, order);\\n        int cur = end.get(level) - start.get(level) + 1;\\n        int left = dfs(root.left, level + 1, 2*order, start, end);\\n        int right = dfs(root.right, level + 1, 2*order + 1, start, end);\\n        return Math.max(cur, Math.max(left, right));\\n    }\\n```\n```vector<pair<int,int>>```\n```start```\n```end```\n```\\n   int widthOfBinaryTree(TreeNode* root) {\\n        return dfs(root, 0, 1, vector<pair<int, int>>() = {});\\n    }\\n    \\n    int dfs(TreeNode* root, int level, int order, vector<pair<int, int>>& vec){\\n        if(root == NULL)return 0;\\n        if(vec.size() == level)vec.push_back({order, order});\\n        else vec[level].second = order;\\n        return max({vec[level].second - vec[level].first + 1, dfs(root->left, level + 1, 2*order, vec), dfs(root->right, level + 1, 2*order + 1, vec)});\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 106645,
                "title": "c-java-bfs-dfs-3liner-clean-code-with-explanation",
                "content": "The idea is to use heap indexing:\\n```\\n        1\\n   2         3\\n 4   5     6   7\\n8 9 x 11  x 13 x 15\\n```\\nRegardless whether these nodes exist:\\n- Always make the id of left child as `parent_id * 2`;\\n- Always make the id of right child as `parent_id * 2 + 1`;\\n\\nSo we can just:\\n1. Record the `id` of `left most node` when first time at each level of the tree during an pre-order run.(you can tell by check the size of the container to hold the first nodes);\\n2. At each node, compare the `distance` from it the left most node with the current `max width`;\\n\\n**DFS - Return Value**\\nC++\\n```\\nclass Solution {\\npublic:\\n    int widthOfBinaryTree(TreeNode* root) {\\n        vector<int> lefts; // left most nodes at each level;\\n        return dfs(root, 1, 0, lefts);\\n    }\\nprivate:\\n    int dfs(TreeNode* n, int id, int d, vector<int>& lefts) { // d : depth\\n        if (!n) return 0;\\n        if (d >= lefts.size()) lefts.push_back(id);  // add left most node\\n        return max({id + 1 - lefts[d], dfs(n->left, id * 2, d + 1, lefts), dfs(n->right, id * 2 + 1, d + 1, lefts)});\\n    }\\n};\\n```\\n3 liner\\n```\\nclass Solution {\\npublic:\\n    int widthOfBinaryTree(TreeNode* root) {\\n        unordered_map<int, vector<int>> m;\\n        function<int(TreeNode*, int, int)> dfs = [&](TreeNode* n, int id, int d){ return n ? m[d].push_back(id), max({id+1-m[d][0], dfs(n->left, id*2, d+1), dfs(n->right, id*2+1, d+1)}) : 0; };\\n        return dfs(root, 1, 0);\\n    }\\n};\\n```\\nJava\\n```\\nclass Solution {\\n    public int widthOfBinaryTree(TreeNode root) {\\n        List<Integer> lefts = new ArrayList<Integer>(); // left most nodes at each level;\\n        return dfs(root, 1, 0, lefts);\\n    }\\n\\n    private int dfs(TreeNode n, int id, int d, List<Integer> lefts) { // d : depth\\n        if (n == null) return 0;\\n        if (d >= lefts.size()) lefts.add(id);   // add left most node\\n        return Math.max(id + 1 - lefts.get(d), Math.max(dfs(n.left, id*2, d+1, lefts), dfs(n.right, id*2+1, d+1, lefts)));\\n    }\\n}\\n```\\n**DFS - Side Effect**\\nC++\\n```\\nclass Solution {\\npublic:\\n    int widthOfBinaryTree(TreeNode* root) {\\n        vector<int> lefts; // left most nodes at each level;\\n        int maxwidth = 0;\\n        dfs(root, 1, 0, lefts, maxwidth);\\n        return maxwidth;\\n    }\\nprivate:\\n    void dfs(TreeNode* node, int id, int depth, vector<int>& lefts, int& maxwidth) {\\n        if (!node) return;\\n        if (depth >= lefts.size()) lefts.push_back(id);  // add left most node\\n        maxwidth = max(maxwidth, id + 1 - lefts[depth]);\\n        dfs(node->left, id * 2, depth + 1, lefts, maxwidth);\\n        dfs(node->right, id * 2 + 1, depth + 1, lefts, maxwidth);\\n    }\\n};\\n```\\nJava\\n```\\nclass Solution {\\n    public int widthOfBinaryTree(TreeNode root) {\\n        List<Integer> lefts = new ArrayList<Integer>(); // left most nodes at each level;\\n        int[] res = new int[1]; // max width\\n        dfs(root, 1, 0, lefts, res);\\n        return res[0];\\n    }\\n    private void dfs(TreeNode node, int id, int depth, List<Integer> lefts, int[] res) {\\n        if (node == null) return;\\n        if (depth >= lefts.size()) lefts.add(id);   // add left most node\\n        res[0] = Integer.max(res[0], id + 1 - lefts.get(depth));\\n        dfs(node.left,  id * 2,     depth + 1, lefts, res);\\n        dfs(node.right, id * 2 + 1, depth + 1, lefts, res);\\n    }\\n}\\n```\\n**BFS**\\nC++\\n```\\nclass Solution {\\npublic:\\n    int widthOfBinaryTree(TreeNode* root) {\\n        if (!root) return 0;\\n        int max = 0;\\n        queue<pair<TreeNode*, int>> q;\\n        q.push(pair<TreeNode*, int>(root, 1));\\n        while (!q.empty()) {\\n            int l = q.front().second, r = l; // right started same as left\\n            for (int i = 0, n = q.size(); i < n; i++) {\\n                TreeNode* node = q.front().first;\\n                r = q.front().second;\\n                q.pop();\\n                if (node->left) q.push(pair<TreeNode*, int>(node->left, r * 2));\\n                if (node->right) q.push(pair<TreeNode*, int>(node->right, r * 2 + 1));\\n            }\\n            max = std::max(max, r + 1 - l);\\n        }\\n        return max;\\n    }\\n};\\n```\\nJava\\n```\\nimport java.util.AbstractMap;\\nclass Solution {\\n    public int widthOfBinaryTree(TreeNode root) {\\n        if (root == null) return 0;\\n        int max = 0;\\n        Queue<Map.Entry<TreeNode, Integer>> q = new LinkedList<Map.Entry<TreeNode, Integer>>();\\n        q.offer(new AbstractMap.SimpleEntry(root, 1));\\n\\n        while (!q.isEmpty()) {\\n            int l = q.peek().getValue(), r = l; // right started same as left\\n            for (int i = 0, n = q.size(); i < n; i++) {\\n                TreeNode node = q.peek().getKey();\\n                r = q.poll().getValue();\\n                if (node.left != null) q.offer(new AbstractMap.SimpleEntry(node.left, r * 2));\\n                if (node.right != null) q.offer(new AbstractMap.SimpleEntry(node.right, r * 2 + 1));\\n            }\\n            max = Math.max(max, r + 1 - l);\\n        }\\n\\n        return maxwidth;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n        1\\n   2         3\\n 4   5     6   7\\n8 9 x 11  x 13 x 15\\n```\n```\\nclass Solution {\\npublic:\\n    int widthOfBinaryTree(TreeNode* root) {\\n        vector<int> lefts; // left most nodes at each level;\\n        return dfs(root, 1, 0, lefts);\\n    }\\nprivate:\\n    int dfs(TreeNode* n, int id, int d, vector<int>& lefts) { // d : depth\\n        if (!n) return 0;\\n        if (d >= lefts.size()) lefts.push_back(id);  // add left most node\\n        return max({id + 1 - lefts[d], dfs(n->left, id * 2, d + 1, lefts), dfs(n->right, id * 2 + 1, d + 1, lefts)});\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int widthOfBinaryTree(TreeNode* root) {\\n        unordered_map<int, vector<int>> m;\\n        function<int(TreeNode*, int, int)> dfs = [&](TreeNode* n, int id, int d){ return n ? m[d].push_back(id), max({id+1-m[d][0], dfs(n->left, id*2, d+1), dfs(n->right, id*2+1, d+1)}) : 0; };\\n        return dfs(root, 1, 0);\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int widthOfBinaryTree(TreeNode root) {\\n        List<Integer> lefts = new ArrayList<Integer>(); // left most nodes at each level;\\n        return dfs(root, 1, 0, lefts);\\n    }\\n\\n    private int dfs(TreeNode n, int id, int d, List<Integer> lefts) { // d : depth\\n        if (n == null) return 0;\\n        if (d >= lefts.size()) lefts.add(id);   // add left most node\\n        return Math.max(id + 1 - lefts.get(d), Math.max(dfs(n.left, id*2, d+1, lefts), dfs(n.right, id*2+1, d+1, lefts)));\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int widthOfBinaryTree(TreeNode* root) {\\n        vector<int> lefts; // left most nodes at each level;\\n        int maxwidth = 0;\\n        dfs(root, 1, 0, lefts, maxwidth);\\n        return maxwidth;\\n    }\\nprivate:\\n    void dfs(TreeNode* node, int id, int depth, vector<int>& lefts, int& maxwidth) {\\n        if (!node) return;\\n        if (depth >= lefts.size()) lefts.push_back(id);  // add left most node\\n        maxwidth = max(maxwidth, id + 1 - lefts[depth]);\\n        dfs(node->left, id * 2, depth + 1, lefts, maxwidth);\\n        dfs(node->right, id * 2 + 1, depth + 1, lefts, maxwidth);\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int widthOfBinaryTree(TreeNode root) {\\n        List<Integer> lefts = new ArrayList<Integer>(); // left most nodes at each level;\\n        int[] res = new int[1]; // max width\\n        dfs(root, 1, 0, lefts, res);\\n        return res[0];\\n    }\\n    private void dfs(TreeNode node, int id, int depth, List<Integer> lefts, int[] res) {\\n        if (node == null) return;\\n        if (depth >= lefts.size()) lefts.add(id);   // add left most node\\n        res[0] = Integer.max(res[0], id + 1 - lefts.get(depth));\\n        dfs(node.left,  id * 2,     depth + 1, lefts, res);\\n        dfs(node.right, id * 2 + 1, depth + 1, lefts, res);\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int widthOfBinaryTree(TreeNode* root) {\\n        if (!root) return 0;\\n        int max = 0;\\n        queue<pair<TreeNode*, int>> q;\\n        q.push(pair<TreeNode*, int>(root, 1));\\n        while (!q.empty()) {\\n            int l = q.front().second, r = l; // right started same as left\\n            for (int i = 0, n = q.size(); i < n; i++) {\\n                TreeNode* node = q.front().first;\\n                r = q.front().second;\\n                q.pop();\\n                if (node->left) q.push(pair<TreeNode*, int>(node->left, r * 2));\\n                if (node->right) q.push(pair<TreeNode*, int>(node->right, r * 2 + 1));\\n            }\\n            max = std::max(max, r + 1 - l);\\n        }\\n        return max;\\n    }\\n};\\n```\n```\\nimport java.util.AbstractMap;\\nclass Solution {\\n    public int widthOfBinaryTree(TreeNode root) {\\n        if (root == null) return 0;\\n        int max = 0;\\n        Queue<Map.Entry<TreeNode, Integer>> q = new LinkedList<Map.Entry<TreeNode, Integer>>();\\n        q.offer(new AbstractMap.SimpleEntry(root, 1));\\n\\n        while (!q.isEmpty()) {\\n            int l = q.peek().getValue(), r = l; // right started same as left\\n            for (int i = 0, n = q.size(); i < n; i++) {\\n                TreeNode node = q.peek().getKey();\\n                r = q.poll().getValue();\\n                if (node.left != null) q.offer(new AbstractMap.SimpleEntry(node.left, r * 2));\\n                if (node.right != null) q.offer(new AbstractMap.SimpleEntry(node.right, r * 2 + 1));\\n            }\\n            max = Math.max(max, r + 1 - l);\\n        }\\n\\n        return maxwidth;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3436593,
                "title": "image-explanation-why-long-to-int-c-java-python",
                "content": "# Video Solution (`Aryan Mittal`) - Link in LeetCode Profile\\n`Maximum Width of Binary Tree` by `Aryan Mittal`\\n![lc.png](https://assets.leetcode.com/users/images/94fedf53-397c-4d98-af10-2a3294d7aa3f_1681960611.903535.png)\\n\\n\\n# Approach & Intution\\n![image.png](https://assets.leetcode.com/users/images/da9eb2ad-cbc7-4e2b-9c16-321da4ee5cd2_1681955754.2438705.png)\\n![image.png](https://assets.leetcode.com/users/images/c2882c94-8b48-4bdf-bd0d-62f9b61dacf4_1681955763.2809882.png)\\n![image.png](https://assets.leetcode.com/users/images/d3638ce5-662f-4dd2-9360-cd2fec3efec0_1681955779.4070249.png)\\n![image.png](https://assets.leetcode.com/users/images/13155d90-22e0-4655-91da-25039ff9d7ea_1681955787.3679965.png)\\n![image.png](https://assets.leetcode.com/users/images/79e60c4a-35b0-4e78-a510-0d2736321730_1681955803.4565988.png)\\n![image.png](https://assets.leetcode.com/users/images/e017ff12-a875-40f8-986e-df79127c52e3_1681955812.5953107.png)\\n![image.png](https://assets.leetcode.com/users/images/e9398c47-996f-4f49-bb0e-c2e42ac1a31d_1681955822.712192.png)\\n![image.png](https://assets.leetcode.com/users/images/7057e729-9a00-408a-97af-aa293f96b356_1681955846.7296906.png)\\n![image.png](https://assets.leetcode.com/users/images/b2c531ec-f4f2-4f03-978e-2ae20d65d91b_1681955853.2918196.png)\\n![image.png](https://assets.leetcode.com/users/images/1902d5a2-85f7-4357-adec-1481604ee37f_1681955864.8128388.png)\\n![image.png](https://assets.leetcode.com/users/images/f14b322d-c4bb-4483-878e-b9d49d84f240_1681955875.9353483.png)\\n![image.png](https://assets.leetcode.com/users/images/717ce925-3922-4281-8113-1ca55cf432df_1681955884.251242.png)\\n![image.png](https://assets.leetcode.com/users/images/92f95c5b-8b0b-4356-9be8-404e7f04706d_1681955891.1895175.png)\\n\\n\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    int widthOfBinaryTree(TreeNode* root) {\\n        if (root == NULL) return 0;\\n        \\n        int max_width = 1;\\n        queue<pair<TreeNode*, int>> q;\\n        q.push({root, 0});\\n\\n        while (!q.empty()) {\\n            int level_size = q.size();\\n            int start_index = q.front().second;\\n            int end_index = q.back().second;\\n            max_width = max(max_width, end_index - start_index + 1);\\n            \\n            for (int i = 0; i < level_size; ++i) {\\n                auto node_index_pair = q.front();\\n                TreeNode* node = node_index_pair.first;\\n                int node_index = node_index_pair.second - start_index;\\n                q.pop();\\n                \\n                if (node->left != nullptr) {\\n                    q.push({node->left, 2LL * node_index + 1});\\n                }\\n                \\n                if (node->right != nullptr) {\\n                    q.push({node->right, 2LL * node_index + 2});\\n                }\\n            }\\n        }\\n        \\n        return max_width;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int widthOfBinaryTree(TreeNode root) {\\n        if (root == null) return 0;\\n        \\n        Queue<Pair<TreeNode, Integer>> queue = new LinkedList<>();\\n        queue.add(new Pair<>(root, 0));\\n        int maxWidth = 0;\\n        \\n        while (!queue.isEmpty()) {\\n            int levelLength = queue.size();\\n            int levelStart = queue.peek().getValue();\\n            int index = 0;\\n            \\n            for (int i = 0; i < levelLength; i++) {\\n                Pair<TreeNode, Integer> pair = queue.poll();\\n                TreeNode node = pair.getKey();\\n                index = pair.getValue();\\n                \\n                if (node.left != null) {\\n                    queue.add(new Pair<>(node.left, 2*index));\\n                }\\n                \\n                if (node.right != null) {\\n                    queue.add(new Pair<>(node.right, 2*index+1));\\n                }\\n            }\\n            \\n            maxWidth = Math.max(maxWidth, index - levelStart + 1);\\n        }\\n        \\n        return maxWidth;\\n    }\\n}\\n```\\n```Python []\\nclass Solution:\\n    def widthOfBinaryTree(self, root: TreeNode) -> int:\\n        if not root:\\n            return 0\\n        \\n        queue = deque([(root, 0)])\\n        max_width = 0\\n        \\n        while queue:\\n            level_length = len(queue)\\n            _, level_start = queue[0]\\n            \\n            for i in range(level_length):\\n                node, index = queue.popleft()\\n                \\n                if node.left:\\n                    queue.append((node.left, 2*index))\\n                \\n                if node.right:\\n                    queue.append((node.right, 2*index+1))\\n                    \\n            max_width = max(max_width, index - level_start + 1)\\n            \\n        return max_width\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int widthOfBinaryTree(TreeNode* root) {\\n        if (root == NULL) return 0;\\n        \\n        int max_width = 1;\\n        queue<pair<TreeNode*, int>> q;\\n        q.push({root, 0});\\n\\n        while (!q.empty()) {\\n            int level_size = q.size();\\n            int start_index = q.front().second;\\n            int end_index = q.back().second;\\n            max_width = max(max_width, end_index - start_index + 1);\\n            \\n            for (int i = 0; i < level_size; ++i) {\\n                auto node_index_pair = q.front();\\n                TreeNode* node = node_index_pair.first;\\n                int node_index = node_index_pair.second - start_index;\\n                q.pop();\\n                \\n                if (node->left != nullptr) {\\n                    q.push({node->left, 2LL * node_index + 1});\\n                }\\n                \\n                if (node->right != nullptr) {\\n                    q.push({node->right, 2LL * node_index + 2});\\n                }\\n            }\\n        }\\n        \\n        return max_width;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int widthOfBinaryTree(TreeNode root) {\\n        if (root == null) return 0;\\n        \\n        Queue<Pair<TreeNode, Integer>> queue = new LinkedList<>();\\n        queue.add(new Pair<>(root, 0));\\n        int maxWidth = 0;\\n        \\n        while (!queue.isEmpty()) {\\n            int levelLength = queue.size();\\n            int levelStart = queue.peek().getValue();\\n            int index = 0;\\n            \\n            for (int i = 0; i < levelLength; i++) {\\n                Pair<TreeNode, Integer> pair = queue.poll();\\n                TreeNode node = pair.getKey();\\n                index = pair.getValue();\\n                \\n                if (node.left != null) {\\n                    queue.add(new Pair<>(node.left, 2*index));\\n                }\\n                \\n                if (node.right != null) {\\n                    queue.add(new Pair<>(node.right, 2*index+1));\\n                }\\n            }\\n            \\n            maxWidth = Math.max(maxWidth, index - levelStart + 1);\\n        }\\n        \\n        return maxWidth;\\n    }\\n}\\n```\n```Python []\\nclass Solution:\\n    def widthOfBinaryTree(self, root: TreeNode) -> int:\\n        if not root:\\n            return 0\\n        \\n        queue = deque([(root, 0)])\\n        max_width = 0\\n        \\n        while queue:\\n            level_length = len(queue)\\n            _, level_start = queue[0]\\n            \\n            for i in range(level_length):\\n                node, index = queue.popleft()\\n                \\n                if node.left:\\n                    queue.append((node.left, 2*index))\\n                \\n                if node.right:\\n                    queue.append((node.right, 2*index+1))\\n                    \\n            max_width = max(max_width, index - level_start + 1)\\n            \\n        return max_width\\n```",
                "codeTag": "Java"
            },
            {
                "id": 726732,
                "title": "python-10-lines-bfs-explained-with-figure",
                "content": "In this problem we need to find maximum width of binary tree, so we need to use some tree traversal algorithm. BFS or DFS? I prefer to use **BFS**, because it emulate level by level traversal. While we traverse we need to keep some information about our node: its `level`, but also its `num`, which is number in level if this level was full. So, let us keep 3 informations for each node: `[num, level, node]`. How we change this information, when we traverse tree? We increase level by `1`, and for `num`, for left children we evaluate `2*num` and for the right we evaluate `2*num + 1`.  You can see how it works on the following tree (here in brackets I show 2 numbers : `[num, level]`. For example for node with `[num, level] = [5, 3]`, left children will have `[10, 4]` and right `[11, 4]`.\\n\\n![image](https://assets.leetcode.com/users/images/38d6acca-03cc-4e3f-a95d-190af6757a82_1594280740.1000175.png)\\n\\nSo, we traverse our tree, using **BFS**, keep this information. Also we have `level_old` and `num_old` variable, which keep information for the first (the most left) node on each level, using this values we can understand if new level is started, and if started, we update it and for each new node we can evaluate current width of traversing layer.\\n\\n**Complexity**: time complexity is `O(n)`, where `n` is number of nodes, because we traverse our tree, using bfs. Space complexity is `O(w)`, where `w` is the biggest number of nodes in level, because we need to keep our queue. Potentially it is equal to `O(n)`. If we use **DFS**, then space complexity will be `O(h)`, where `h` is height of tree.\\n\\n\\n\\n\\n```\\nclass Solution:\\n    def widthOfBinaryTree(self, root):\\n        level_old, num_old, max_width = 1, 1, 0\\n        queue = deque([[level_old,num_old,root]])\\n\\n        while queue:    \\n            [num, level, node] = queue.popleft()\\n            if level > level_old:\\n                level_old, num_old = level, num\\n                \\n            max_width = max(max_width, num - num_old + 1)\\n            if node.left:  queue.append([num*2,  level+1, node.left])\\n            if node.right: queue.append([num*2+1,level+1, node.right])\\n                \\n        return max_width\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def widthOfBinaryTree(self, root):\\n        level_old, num_old, max_width = 1, 1, 0\\n        queue = deque([[level_old,num_old,root]])\\n\\n        while queue:    \\n            [num, level, node] = queue.popleft()\\n            if level > level_old:\\n                level_old, num_old = level, num\\n                \\n            max_width = max(max_width, num - num_old + 1)\\n            if node.left:  queue.append([num*2,  level+1, node.left])\\n            if node.right: queue.append([num*2+1,level+1, node.right])\\n                \\n        return max_width\\n```",
                "codeTag": "Java"
            },
            {
                "id": 106650,
                "title": "python",
                "content": "    def widthOfBinaryTree(self, root):\\n        width = 0\\n        level = [(1, root)]\\n        while level:\\n            width = max(width, level[-1][0] - level[0][0] + 1)\\n            level = [kid\\n                     for number, node in level\\n                     for kid in enumerate((node.left, node.right), 2 * number)\\n                     if kid[1]]\\n        return width\\n\\nThat's numbering nodes (and nulls) like this:\\n\\n                      1\\n              2               3\\n          4       5       6       7\\n        8   9   ...",
                "solutionTags": [],
                "code": "    def widthOfBinaryTree(self, root):\\n        width = 0\\n        level = [(1, root)]\\n        while level:\\n            width = max(width, level[-1][0] - level[0][0] + 1)\\n            level = [kid\\n                     for number, node in level\\n                     for kid in enumerate((node.left, node.right), 2 * number)\\n                     if kid[1]]\\n        return width\\n\\nThat's numbering nodes (and nulls) like this:\\n\\n                      1\\n              2               3\\n          4       5       6       7\\n        8   9   ...",
                "codeTag": "Python3"
            },
            {
                "id": 1803302,
                "title": "c-detailed-explanation-w-why-covering-integer-overflow-condition-dry-run",
                "content": "***Brief note about Question-***\\n* We have to *return the maximum width of the given tree.*\\n* And width is defind as the length between the end-nodes (the leftmost and rightmost non-null nodes), where the null nodes between the end-nodes are also counted into the length calculation.\\n```\\nLet\\'s take an example not given in question -\\nSuppose tree given to us is like : [1,2,3,4,null,null,6]\\nIt should look like -\\n                                 1               Here width = 1\\n\\t\\t\\t\\t\\t\\t\\t\\t/  \\\\\\n\\t\\t\\t\\t\\t\\t\\t   /    \\\\\\n\\t\\t\\t\\t\\t\\t\\t  /      \\\\\\n\\t\\t\\t\\t\\t\\t\\t 2        3          Here width = 2\\n\\t\\t\\t\\t\\t\\t\\t/ \\\\       /\\\\\\n\\t\\t\\t\\t\\t\\t   /   \\\\     /  \\\\\\n\\t\\t\\t\\t\\t\\t  4\\t null  null  6       Here width = 4 i.e (4, null,null, 6)\\n\\t\\t\\t\\t\\t\\t  \\nTherefore, maximum width among {1,2,4} is 4\\nSo, 4 should be our answer.\\n```\\n___________\\n***What we will see-***\\n* The first and most basic thing we can observe here is, manually just by seeing tree how we came to know that what is the maximum width.\\n* We will say we just see every level and then count the number of nodes and the number of nodes that are present at that level is termed to as width of that level, right.\\n* For e.g in the above example, if we will see then we will find out that maximum width at first level is 1, as only one node is present i.e root node (1). And after that similiarly on moving ahead we will find out then their are two nodes on second level i.e 2 ,3 so width should be 2\\n* Again on the last level we will see that their are 4 nodes i.e (4, null, null, 6) so width should be 4, and this is the maximum node. So we will return 4 as our answer.\\n* But this is the thing that we will do by seeing our tree manually, but how we will implement it.\\n\\n* See below.\\n_______\\n***Some Observations-***\\n* As we discussed above, One thing that we can clearly say that for calculating width, **we see our number of nodes level by level.** \\n* Therefore, we can say that we are going to ***use level order*** traveral for solving this problem.\\n* Okay, Manually we are able to tell the width just by seeing tree but in order to code it we need something by which we can calculate our width.\\n* And in order to calculate number of nodes at a certain level we can use `indexing`.\\n* But again question arises, In order to use indexing, how we are able to give index to our tree.\\n\\n* We can take an example, let\\'s see-\\n```\\nLet\\'s take an example for better understanding-\\nSuupose our tree given to us like this and if we want to give its index then how we will give it-\\nWe are assuming 1 based indexing-\\nSuppose tree given to us as [12, 23, 34, 76, null, null, 64]\\n\\n                                      Index\\n                                 12   (1)            Width here = 1\\n\\t\\t\\t\\t\\t\\t\\t\\t/  \\\\\\n\\t\\t\\t\\t\\t\\t\\t   /    \\\\\\n\\t\\t\\t       Index\\t  /      \\\\      Index     \\n\\t\\t\\t\\t   (2)\\t    23       34      (3)     Width here = (3 - 2 + 1) = 2\\n\\t\\t\\t\\t\\t\\t\\t/ \\\\       /\\\\\\n\\t\\t\\t\\t\\t\\t   /   \\\\     /  \\\\\\n\\t\\t\\t\\t\\t\\t  76 null  null  64    \\n\\t\\t\\t       Index (4)  (5)  (6)   (7)\\t\\tWidth here = (7 - 4 + 1) = 4\\t  \\n\\t\\t\\t\\t   \\n\\t\\t\\t\\t   If we observe carefully then, \\n\\t\\t\\t\\t   how we are able to find width (see left)\\n\\t\\t\\t\\t   We find width at any particular level by saying that,\\n\\t\\t\\t\\t   \\n\\t\\t\" width = (maximum index at level) - (minimum index at level) + 1 \"\\n```\\n* Now, we know one thing that, if anyhow we are able to give index our tree than easily we are able to find width of our tree, just by using formula-\\n\\n* `width = (maximum index at that level) - (minimum index at  that level) + 1`\\n* Again, question arises, how we will know our indexing for any general level.\\n* Let\\'s again take an example for better understanding-\\n```\\nLet\\'s take an tree in general way, and find out how we generate our indexing\\n\\n                                      Index   Let say if this index is \\'i\\'\\n                                 \\u2731   (1)       i     \\n\\t\\t\\t\\t\\t\\t\\t\\t/  \\\\\\n\\t\\t\\t\\t\\t\\t\\t   /    \\\\\\n\\t\\t\\t       Index\\t  /      \\\\      Index     \\n\\t\\t\\t\\t   (2)\\t     \\u2731        \\u2731      (3)     \\ncan we say that this is  (2 * i )\\t(2 * i + 1)\\t\\n\\nSo, In this way, we are also able to generate formula for our indexing.\\n```\\n* Therefore, for any generliaze term we are also able to find it\\'s indexing. \\n* And if we are able to find it\\'s indexing then also we are able to find it\\'s width,\\n* So, can we code now?\\n\\n* Answer is **NO**. Something is left, let\\'s find out.\\n```\\nSuppose our tree given to us is like-\\n\\n                              Let suppose index here is \\'i\\'\\n                                   \\u2731    (i)\\n\\t\\t\\t\\t\\t\\t\\t\\t  /\\n\\t\\t\\t\\t\\t\\t\\t\\t /\\n\\t\\t\\t\\t\\t\\t\\t\\t\\u2731  then, index here (2 * i)\\n\\t\\t\\t\\t\\t\\t\\t   /\\n\\t\\t\\t\\t\\t\\t\\t  /\\n\\t\\t\\t\\t\\t\\t\\t \\u2731  after that, index here (2 * (2 * i))\\n\\t\\t\\t\\t\\t\\t\\t/\\n\\t\\t\\t\\t\\t\\t   /\\n\\t\\t\\t\\t\\t\\t  \\u2731 again, index here (2 * (2 * (2 * i))\\n\\t\\t\\t\\t\\t\\t /\\n\\t\\t\\t\\t\\t\\t/\\n\\t\\t\\t\\t\\t   \\u2731 and also, index here (2 * (2 * (2 * (2 * i)))\\n\\t\\t\\t\\t\\t   \\n\\t\\t\\t\\t\\t   And in this way,  our trr continues,\\n\\t\\t\\t\\t\\t   Then there may be a condition arieses when we got overflow,\\n\\t\\t\\t\\t\\t   so In order to prevent overflow, we again have to do some arrangement.\\n```\\n* Now question arises, how we prevent our overflow.\\n\\n* Let\\'s see-\\n```\\nLet\\'s take an tree in general way-\\n\\nWe take minimum value of index at evey level, after that we subtract that minimum value with other indicies then we end up get like that-\\n\\nIdeally it should be 1, but if i decrease minimum vale from this present at this index i.e 1, it becomes\\n                                 \\u2731   (1 - 1 + 1) = 1         // + 1 because we are using 1 based indexing,\\n\\t\\t\\t\\t\\t\\t\\t\\t/  \\\\\\n\\t\\t\\t\\t\\t\\t\\t   /    \\\\\\nthen it becomes (2 * i) = 2   /      \\\\      it become (2 * i + 1) = (2 * 1 + 1) = 3   //min at this level = 2\\ndecreasing mn (2 - 2 + 1)=1  \\u2731        \\u2731      but, decreasing minimum, (3 - 2 + 1) = 2   // + 1 because we are using 1 based indexing,\\n\\t\\t\\t\\t            /\\\\       / \\\\\\n\\t\\t\\t\\t\\t\\t   /  \\\\     /   \\\\\\nbecomes (2 * i) = 2\\t\\t  /    \\\\   /     \\\\  it become (2 * i + 1) = (2 * 1 + 1) = 3   //min at this level = 2\\n\\t\\t\\t\\t\\t\\t \\u2731      \\u2731 \\u2731       \\u2731\\ndecreasing mn (2 - 2 + 1) = 1\\t\\t but, decreasing minimum, (3 - 2 + 1) = 2\\t // + 1 because we are using 1 based indexing,\\n\\n\\nSo, we find out a way to decrease overflow, \\nWhat we will do?\\n\\nWe will decrease the minimum index of the level from each index, \\nso that it again reorder in form of indexing 1, 2, 3 ...like that \\n```\\n____________\\n```\\nTime Complexity --> O(n) // where n is the number of all nodes present in the tree \\nSpace Complexity --> O(n) // we are using queue from our side\\n\\nIt paases [ 113 / 113 ] in built test cases\\n```\\n_______\\n**Code (C++)**\\n```\\nclass Solution {\\npublic:\\n    int widthOfBinaryTree(TreeNode* root) {\\n        if(root == NULL) // if root is null \\n            return 0;   // simply return zero\\n        \\n        int ans = 0; // variable to store answer\\n        \\n        // queue for level order traveral\\n        queue<pair<TreeNode*, int>> q; // pair contain { node, index}\\n        \\n        q.push({root, 1}); // intially push root node \\n        \\n        // Implementing BFS\\n        while(q.empty() == false) // until queue is not empty\\n        {\\n            int size = q.size(); // take size of the queue\\n            \\n            // tells us minimum index at particular level\\n            int minAtLevel = q.front().second; \\n            \\n            // declaring minimum and maximum variable used for finding width\\n            int mn, mx;\\n            \\n            // traverse from the queue\\n            for(int i= 0; i < size; i++)\\n            {\\n                // changes index of level by decreasing minimum index\\n                int curr_index = q.front().second - minAtLevel + 1; //+ 1 because we are using 1 based indexing,\\n                \\n                // take out current node\\n                TreeNode* node = q.front().first;\\n                q.pop(); // pop from the queue\\n                \\n                // remember the formula we discussed\\n            //width = (maximum index at level) - (minimum index at level) + 1\\n                \\n                if(i == 0) \\n                    mn = curr_index; // minimum index at level\\n                \\n                if(i == size - 1)\\n                    mx = curr_index; //maximum index at level\\n                \\n                // push left and right for further calculation\\n\\t\\t\\t\\t\\n                if(node -> left != NULL) //2   * i\\n                    q.push({node -> left, 2LL * curr_index});\\n                \\n                if(node -> right != NULL) //2   * i  + 1\\n                    q.push({node -> right, 2LL * curr_index + 1});\\n                   \\n            }\\n            ans = max(ans, mx - mn + 1); // update our answer\\n        }\\n        \\n        return ans; // finally return our answer\\n        \\n    }\\n};\\n```\\n* *Even I tried my best to explain everything, but still if u have any confusion or advice, please comment below and for reference you may see striver (take u forward) video.*\\n\\n***`If u find this useful , please consider to give a upvote!!`***",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nLet\\'s take an example not given in question -\\nSuppose tree given to us is like : [1,2,3,4,null,null,6]\\nIt should look like -\\n                                 1               Here width = 1\\n\\t\\t\\t\\t\\t\\t\\t\\t/  \\\\\\n\\t\\t\\t\\t\\t\\t\\t   /    \\\\\\n\\t\\t\\t\\t\\t\\t\\t  /      \\\\\\n\\t\\t\\t\\t\\t\\t\\t 2        3          Here width = 2\\n\\t\\t\\t\\t\\t\\t\\t/ \\\\       /\\\\\\n\\t\\t\\t\\t\\t\\t   /   \\\\     /  \\\\\\n\\t\\t\\t\\t\\t\\t  4\\t null  null  6       Here width = 4 i.e (4, null,null, 6)\\n\\t\\t\\t\\t\\t\\t  \\nTherefore, maximum width among {1,2,4} is 4\\nSo, 4 should be our answer.\\n```\n```\\nLet\\'s take an example for better understanding-\\nSuupose our tree given to us like this and if we want to give its index then how we will give it-\\nWe are assuming 1 based indexing-\\nSuppose tree given to us as [12, 23, 34, 76, null, null, 64]\\n\\n                                      Index\\n                                 12   (1)            Width here = 1\\n\\t\\t\\t\\t\\t\\t\\t\\t/  \\\\\\n\\t\\t\\t\\t\\t\\t\\t   /    \\\\\\n\\t\\t\\t       Index\\t  /      \\\\      Index     \\n\\t\\t\\t\\t   (2)\\t    23       34      (3)     Width here = (3 - 2 + 1) = 2\\n\\t\\t\\t\\t\\t\\t\\t/ \\\\       /\\\\\\n\\t\\t\\t\\t\\t\\t   /   \\\\     /  \\\\\\n\\t\\t\\t\\t\\t\\t  76 null  null  64    \\n\\t\\t\\t       Index (4)  (5)  (6)   (7)\\t\\tWidth here = (7 - 4 + 1) = 4\\t  \\n\\t\\t\\t\\t   \\n\\t\\t\\t\\t   If we observe carefully then, \\n\\t\\t\\t\\t   how we are able to find width (see left)\\n\\t\\t\\t\\t   We find width at any particular level by saying that,\\n\\t\\t\\t\\t   \\n\\t\\t\" width = (maximum index at level) - (minimum index at level) + 1 \"\\n```\n```\\nLet\\'s take an tree in general way, and find out how we generate our indexing\\n\\n                                      Index   Let say if this index is \\'i\\'\\n                                 \\u2731   (1)       i     \\n\\t\\t\\t\\t\\t\\t\\t\\t/  \\\\\\n\\t\\t\\t\\t\\t\\t\\t   /    \\\\\\n\\t\\t\\t       Index\\t  /      \\\\      Index     \\n\\t\\t\\t\\t   (2)\\t     \\u2731        \\u2731      (3)     \\ncan we say that this is  (2 * i )\\t(2 * i + 1)\\t\\n\\nSo, In this way, we are also able to generate formula for our indexing.\\n```\n```\\nSuppose our tree given to us is like-\\n\\n                              Let suppose index here is \\'i\\'\\n                                   \\u2731    (i)\\n\\t\\t\\t\\t\\t\\t\\t\\t  /\\n\\t\\t\\t\\t\\t\\t\\t\\t /\\n\\t\\t\\t\\t\\t\\t\\t\\t\\u2731  then, index here (2 * i)\\n\\t\\t\\t\\t\\t\\t\\t   /\\n\\t\\t\\t\\t\\t\\t\\t  /\\n\\t\\t\\t\\t\\t\\t\\t \\u2731  after that, index here (2 * (2 * i))\\n\\t\\t\\t\\t\\t\\t\\t/\\n\\t\\t\\t\\t\\t\\t   /\\n\\t\\t\\t\\t\\t\\t  \\u2731 again, index here (2 * (2 * (2 * i))\\n\\t\\t\\t\\t\\t\\t /\\n\\t\\t\\t\\t\\t\\t/\\n\\t\\t\\t\\t\\t   \\u2731 and also, index here (2 * (2 * (2 * (2 * i)))\\n\\t\\t\\t\\t\\t   \\n\\t\\t\\t\\t\\t   And in this way,  our trr continues,\\n\\t\\t\\t\\t\\t   Then there may be a condition arieses when we got overflow,\\n\\t\\t\\t\\t\\t   so In order to prevent overflow, we again have to do some arrangement.\\n```\n```\\nLet\\'s take an tree in general way-\\n\\nWe take minimum value of index at evey level, after that we subtract that minimum value with other indicies then we end up get like that-\\n\\nIdeally it should be 1, but if i decrease minimum vale from this present at this index i.e 1, it becomes\\n                                 \\u2731   (1 - 1 + 1) = 1         // + 1 because we are using 1 based indexing,\\n\\t\\t\\t\\t\\t\\t\\t\\t/  \\\\\\n\\t\\t\\t\\t\\t\\t\\t   /    \\\\\\nthen it becomes (2 * i) = 2   /      \\\\      it become (2 * i + 1) = (2 * 1 + 1) = 3   //min at this level = 2\\ndecreasing mn (2 - 2 + 1)=1  \\u2731        \\u2731      but, decreasing minimum, (3 - 2 + 1) = 2   // + 1 because we are using 1 based indexing,\\n\\t\\t\\t\\t            /\\\\       / \\\\\\n\\t\\t\\t\\t\\t\\t   /  \\\\     /   \\\\\\nbecomes (2 * i) = 2\\t\\t  /    \\\\   /     \\\\  it become (2 * i + 1) = (2 * 1 + 1) = 3   //min at this level = 2\\n\\t\\t\\t\\t\\t\\t \\u2731      \\u2731 \\u2731       \\u2731\\ndecreasing mn (2 - 2 + 1) = 1\\t\\t but, decreasing minimum, (3 - 2 + 1) = 2\\t // + 1 because we are using 1 based indexing,\\n\\n\\nSo, we find out a way to decrease overflow, \\nWhat we will do?\\n\\nWe will decrease the minimum index of the level from each index, \\nso that it again reorder in form of indexing 1, 2, 3 ...like that \\n```\n```\\nTime Complexity --> O(n) // where n is the number of all nodes present in the tree \\nSpace Complexity --> O(n) // we are using queue from our side\\n\\nIt paases [ 113 / 113 ] in built test cases\\n```\n```\\nclass Solution {\\npublic:\\n    int widthOfBinaryTree(TreeNode* root) {\\n        if(root == NULL) // if root is null \\n            return 0;   // simply return zero\\n        \\n        int ans = 0; // variable to store answer\\n        \\n        // queue for level order traveral\\n        queue<pair<TreeNode*, int>> q; // pair contain { node, index}\\n        \\n        q.push({root, 1}); // intially push root node \\n        \\n        // Implementing BFS\\n        while(q.empty() == false) // until queue is not empty\\n        {\\n            int size = q.size(); // take size of the queue\\n            \\n            // tells us minimum index at particular level\\n            int minAtLevel = q.front().second; \\n            \\n            // declaring minimum and maximum variable used for finding width\\n            int mn, mx;\\n            \\n            // traverse from the queue\\n            for(int i= 0; i < size; i++)\\n            {\\n                // changes index of level by decreasing minimum index\\n                int curr_index = q.front().second - minAtLevel + 1; //+ 1 because we are using 1 based indexing,\\n                \\n                // take out current node\\n                TreeNode* node = q.front().first;\\n                q.pop(); // pop from the queue\\n                \\n                // remember the formula we discussed\\n            //width = (maximum index at level) - (minimum index at level) + 1\\n                \\n                if(i == 0) \\n                    mn = curr_index; // minimum index at level\\n                \\n                if(i == size - 1)\\n                    mx = curr_index; //maximum index at level\\n                \\n                // push left and right for further calculation\\n\\t\\t\\t\\t\\n                if(node -> left != NULL) //2   * i\\n                    q.push({node -> left, 2LL * curr_index});\\n                \\n                if(node -> right != NULL) //2   * i  + 1\\n                    q.push({node -> right, 2LL * curr_index + 1});\\n                   \\n            }\\n            ans = max(ans, mx - mn + 1); // update our answer\\n        }\\n        \\n        return ans; // finally return our answer\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 106707,
                "title": "python-straightforward-bfs-and-dfs-solutions",
                "content": "The main idea with this question is we will give each node a position value.  If we go down the left neighbor, then position -> position * 2; and if we go down the right neighbor, then position -> position * 2 + 1.  This makes it so that when we look at the position values L and R of two nodes with the same depth, the width will be R - L + 1.\\n\\nFrom there, we have two choices for traversals: BFS or DFS.  In a BFS, all the nodes with the same depth are searched adjacent to each other, so we only need to remember the first and last positions seen for each depth.\\n\\n```\\ndef widthOfBinaryTree(self, root):\\n    queue = [(root, 0, 0)]\\n    cur_depth = left = ans = 0\\n    for node, depth, pos in queue:\\n        if node:\\n            queue.append((node.left, depth+1, pos*2))\\n            queue.append((node.right, depth+1, pos*2 + 1))\\n            if cur_depth != depth:\\n                cur_depth = depth\\n                left = pos\\n            ans = max(pos - left + 1, ans)\\n\\n    return ans\\n```\\n\\nIt might be more natural to attempt a DFS.  Here, we create a dfs iterator that yields the depth and position of each node.\\n\\nAfter, we need to know for each depth, what was the leftmost position left[depth] and the rightmost position right[depth].  We'll remember the largest width as we iterate through the nodes.\\n\\n```\\ndef widthOfBinaryTree(self, root):\\n    def dfs(node, depth = 0, pos = 0):\\n        if node:\\n            yield depth, pos\\n            yield from dfs(node.left, depth + 1, pos * 2)\\n            yield from dfs(node.right, depth + 1, pos * 2 + 1)\\n\\n    left = {}\\n    right = {}\\n    ans = 0\\n    for depth, pos in dfs(root):\\n        left[depth] = min(left.get(depth, pos), pos)\\n        right[depth] = max(right.get(depth, pos), pos)\\n        ans = max(ans, right[depth] - left[depth] + 1)\\n\\n    return ans\\n```",
                "solutionTags": [],
                "code": "```\\ndef widthOfBinaryTree(self, root):\\n    queue = [(root, 0, 0)]\\n    cur_depth = left = ans = 0\\n    for node, depth, pos in queue:\\n        if node:\\n            queue.append((node.left, depth+1, pos*2))\\n            queue.append((node.right, depth+1, pos*2 + 1))\\n            if cur_depth != depth:\\n                cur_depth = depth\\n                left = pos\\n            ans = max(pos - left + 1, ans)\\n\\n    return ans\\n```\n```\\ndef widthOfBinaryTree(self, root):\\n    def dfs(node, depth = 0, pos = 0):\\n        if node:\\n            yield depth, pos\\n            yield from dfs(node.left, depth + 1, pos * 2)\\n            yield from dfs(node.right, depth + 1, pos * 2 + 1)\\n\\n    left = {}\\n    right = {}\\n    ans = 0\\n    for depth, pos in dfs(root):\\n        left[depth] = min(left.get(depth, pos), pos)\\n        right[depth] = max(right.get(depth, pos), pos)\\n        ans = max(ans, right[depth] - left[depth] + 1)\\n\\n    return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3436483,
                "title": "c-bfs-approach-with-explanation-simple-solution",
                "content": "# **PLEASE UPVOTE \\uD83D\\uDC4D**\\n# Intuition\\n- #### The intuition behind this problem is to find the maximum width of a binary tree, which is the maximum distance between the leftmost and rightmost non-null nodes at any level of the tree.\\n\\n- #### To solve this problem, we need to traverse the tree level by level and keep track of the leftmost and rightmost nodes at each level.\\n\\n# Approach\\n- #### To solve this problem, we can use breadth-first search (BFS) to traverse the tree level by level. At each level, we keep track of the indices of the leftmost and rightmost non-null nodes. The width of the level is the difference between these indices plus one.\\n\\n- ### We can maintain a queue of pairs, where each pair represents a node and its index. The index of the root is 0, and we can assign indices to the left and right child nodes as follows:\\n    1. #### For a node with index i, its left child has index 2i+1.\\n    1. #### For a node with index i, its right child has index 2i+2.\\n\\n- ### We can use a ans variable to store the maximum value of ***rightmost index - leftmost index + 1***.\\n\\n- ### After we have traversed the entire tree, ans variable now holds the maximum value and we return it.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int widthOfBinaryTree(TreeNode* a) {\\n        vector<int>v;\\n    \\n        if(!a)\\n        return 0;\\n        \\n        int ans = 1;\\n        queue<pair<TreeNode*,long long int>>q;\\n        q.push({a,0});\\n\\n        while(!q.empty())\\n        {\\n            int sz = q.size();\\n            int a1 = 0, b1 = 0;\\n            int l = 0;\\n            int mn = q.front().second;\\n            for(int i = 0; i < sz; i++)\\n            {\\n                auto p = q.front();\\n                TreeNode* b = p.first;\\n                // To avoid integer overflow,\\n                // we modify all the address values with \\n                // respect to leftmost tree address value.\\n                long long int k = p.second-mn;\\n                q.pop();\\n                // leftmost node\\n                if(i == 0)\\n                a1 = k;\\n                // rightmost node\\n                if(i == sz-1)\\n                b1 = k;\\n\\n                if(b->left)\\n                q.push({b->left,2*k+1});\\n                \\n                if(b->right)\\n                q.push({b->right,2*k+2});\\n            }\\n            // To store maximum difference.\\n            ans = max(ans,b1-a1+1);\\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n```\\n# **PLEASE UPVOTE \\uD83D\\uDC4D**\\n\\n![e2515d84-99cf-4499-80fb-fe458e1bbae2_1678932606.8004954.png](https://assets.leetcode.com/users/images/57ee4dd9-6abd-4162-a36b-2186ac032f58_1681949635.4953403.png)\\n",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int widthOfBinaryTree(TreeNode* a) {\\n        vector<int>v;\\n    \\n        if(!a)\\n        return 0;\\n        \\n        int ans = 1;\\n        queue<pair<TreeNode*,long long int>>q;\\n        q.push({a,0});\\n\\n        while(!q.empty())\\n        {\\n            int sz = q.size();\\n            int a1 = 0, b1 = 0;\\n            int l = 0;\\n            int mn = q.front().second;\\n            for(int i = 0; i < sz; i++)\\n            {\\n                auto p = q.front();\\n                TreeNode* b = p.first;\\n                // To avoid integer overflow,\\n                // we modify all the address values with \\n                // respect to leftmost tree address value.\\n                long long int k = p.second-mn;\\n                q.pop();\\n                // leftmost node\\n                if(i == 0)\\n                a1 = k;\\n                // rightmost node\\n                if(i == sz-1)\\n                b1 = k;\\n\\n                if(b->left)\\n                q.push({b->left,2*k+1});\\n                \\n                if(b->right)\\n                q.push({b->right,2*k+2});\\n            }\\n            // To store maximum difference.\\n            ans = max(ans,b1-a1+1);\\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 750068,
                "title": "simple-dfs-python-with-drawing-explanation",
                "content": "The idea is simple, as shown in the drawing below, blue number is the `column`. From observation, each node\\n`node.left.column = node.column*2`\\n`node.right.column = node.column*2+1`\\nWe only need to traversal all the nodes and record the columns in by level \\n\\n![image](https://assets.leetcode.com/users/images/f165ec86-5f3d-4b20-a320-bbae107afaf2_1595466533.4134023.png)\\n\\n```\\nfrom collections import defaultdict\\nclass Solution:\\n    def widthOfBinaryTree(self, root: TreeNode) -> int:\\n        di = defaultdict(list)\\n        def dfs(node, level, column):\\n            if node:\\n                di[level].append(column)\\n                dfs(node.left, level+1, column*2)\\n                dfs(node.right, level+1, column*2+1)\\n        dfs(root, 0 , 0)\\n        return max([max(di[level]) - min(di[level]) +1 for level in di])\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def widthOfBinaryTree(self, root: TreeNode) -> int:\\n        di = defaultdict(list)\\n        def dfs(node, level, column):\\n            if node:\\n                di[level].append(column)\\n                dfs(node.left, level+1, column*2)\\n                dfs(node.right, level+1, column*2+1)\\n        dfs(root, 0 , 0)\\n        return max([max(di[level]) - min(di[level]) +1 for level in di])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3436680,
                "title": "java-easy-image-explaination-level-order-beginner-friendly",
                "content": "# Intuition\\nSince we need to find width of the tree first approach that comes to mind is level order traversal but we will need to apply with some simple modifictions.\\nIf you haven\\'t solved Level order traversal i would recommend you to solve that first. \\n[LC 102 Binary Tree Level Order Traversal](https://leetcode.com/problems/binary-tree-level-order-traversal/description/)\\n\\nIf the position of the parent node is ```n```, then the left child is ```2 * n``` and the right child is ```2 * n + 1``` The width of each level is the last node\\'s position in this level subtraction the first node\\'s position in this level plus 1 that is at any level ```width = lastNodePostion- firstNodePosition + 1 ```\\n\\n\\nPicture below explains the intuition\\n![WhatsApp Image 2023-04-20 at 8.28.33 AM.jpeg](https://assets.leetcode.com/users/images/e566f6ae-86d4-4f6d-a04c-26a30013b70c_1681959602.2330675.jpeg)\\n\\n---\\n\\n# Approach\\n1) For normal level order we use a queue but here we need to store an index too.\\n2) So either use pair in java or create a class which has 2 variables \\n- TreeNode (to store current-node)\\n- Index (will track of index for each Node)\\n3) Insert first root into the queue with 0 index and now unitl queue is not empty\\n4) Run a for loop till queue size(it is nothing but all the nodes/child at that level)\\n5) Find left(i==0), find righmost of the level(i==queue.size()-1) and at each level compare max with\\nthat levels max ie ```max = Math.max(max, end - start + 1)```\\n\\n\\n---\\n\\n# Complexity\\n- Time complexity:\\nO(n) since we are iterating over all the elements of the tree once.\\n\\n- Space complexity:\\nO(n) at max we can have n elements in queue.\\n\\n---\\n\\nHope it is easy to understand.\\nLet me know if there is something unclear and i can fix it.\\n\\nOtherwise, please upvote if you like the solution, it would be encouraging.\\n\\n---\\n\\n\\n# Code\\n```\\nclass Solution {\\n    \\n    class Node {\\n        TreeNode node;\\n        int idx;\\n        Node(TreeNode node, int idx){\\n            this.node = node;\\n            this.idx = idx;\\n        }\\n    }\\n    \\n    public int widthOfBinaryTree(TreeNode root) {\\n        Queue<Node> queue = new LinkedList<>();\\n        queue.add(new Node(root,0));\\n        int max = 0;\\n        while(!queue.isEmpty())\\n        {\\n            int size = queue.size();\\n            int start = 0, end = 0;\\n            for(int i=0; i<size; i++)\\n            {\\n                Node eachNode = queue.remove();\\n                int index = eachNode.idx; \\n                if(i==0) \\n                    start = index; //start and end index for each level\\n                \\n                if(i==size-1) \\n                    end = index;\\n                \\n                if(eachNode.node.left!=null)\\n                    queue.add(new Node(eachNode.node.left, 2*eachNode.idx));\\n\\n                if(eachNode.node.right!=null)\\n                    queue.add(new Node(eachNode.node.right, 2*eachNode.idx+1));\\n                \\n            }\\n            max = Math.max(max, end - start + 1);\\n        }\\n        return max;    \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```n```\n```2 * n```\n```2 * n + 1```\n```width = lastNodePostion- firstNodePosition + 1 ```\n```max = Math.max(max, end - start + 1)```\n```\\nclass Solution {\\n    \\n    class Node {\\n        TreeNode node;\\n        int idx;\\n        Node(TreeNode node, int idx){\\n            this.node = node;\\n            this.idx = idx;\\n        }\\n    }\\n    \\n    public int widthOfBinaryTree(TreeNode root) {\\n        Queue<Node> queue = new LinkedList<>();\\n        queue.add(new Node(root,0));\\n        int max = 0;\\n        while(!queue.isEmpty())\\n        {\\n            int size = queue.size();\\n            int start = 0, end = 0;\\n            for(int i=0; i<size; i++)\\n            {\\n                Node eachNode = queue.remove();\\n                int index = eachNode.idx; \\n                if(i==0) \\n                    start = index; //start and end index for each level\\n                \\n                if(i==size-1) \\n                    end = index;\\n                \\n                if(eachNode.node.left!=null)\\n                    queue.add(new Node(eachNode.node.left, 2*eachNode.idx));\\n\\n                if(eachNode.node.right!=null)\\n                    queue.add(new Node(eachNode.node.right, 2*eachNode.idx+1));\\n                \\n            }\\n            max = Math.max(max, end - start + 1);\\n        }\\n        return max;    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 232952,
                "title": "c-bfs-fix-overflow-problem",
                "content": "```\\nclass Solution {\\npublic:\\n    int widthOfBinaryTree(TreeNode* root) {\\n        if( !root ) return 0;\\n        queue<pair<TreeNode*, int> > q;\\n        q.push({root, 1 });\\n        int ans = 0;\\n        while(!q.empty() ){\\n            int size = q.size();\\n            if (size == 1){\\n                q.push({q.front().first,1});\\n                q.pop();\\n            }\\n            ans = max( q.back().second - q.front().second + 1, ans);\\n        \\n            while( size-->0 ){\\n                auto node = q.front().first;\\n                auto idx = q.front().second;\\n                q.pop();\\n                if( node->left )\\n                    q.push({node->left, idx*2});\\n                if( node->right )\\n                    q.push({node->right, idx*2+1});\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int widthOfBinaryTree(TreeNode* root) {\\n        if( !root ) return 0;\\n        queue<pair<TreeNode*, int> > q;\\n        q.push({root, 1 });\\n        int ans = 0;\\n        while(!q.empty() ){\\n            int size = q.size();\\n            if (size == 1){\\n                q.push({q.front().first,1});\\n                q.pop();\\n            }\\n            ans = max( q.back().second - q.front().second + 1, ans);\\n        \\n            while( size-->0 ){\\n                auto node = q.front().first;\\n                auto idx = q.front().second;\\n                q.pop();\\n                if( node->left )\\n                    q.push({node->left, idx*2});\\n                if( node->right )\\n                    q.push({node->right, idx*2+1});\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 726946,
                "title": "c-fastest-bfs",
                "content": "```\\nint widthOfBinaryTree(TreeNode* root) {\\n\\tif (!root)return 0;\\n\\tqueue<pair<TreeNode*, unsigned long long int>> que;\\n\\tque.push({root, 0});\\n\\tint width = 0;\\n\\twhile (que.size() != 0) {\\n\\t\\tunsigned long long int left = que.front().second, right = 0;\\n\\t\\tint size = que.size();\\n\\t\\twhile (size-- > 0) {\\n\\t\\t\\tpair<TreeNode*, unsigned long long int> rNode = que.front();\\n\\t\\t\\tque.pop();\\n\\t\\t\\tright = rNode.second;\\n\\t\\t\\tif (rNode.first->left) {\\n\\t\\t\\t\\tque.push({rNode.first->left, 2 * rNode.second + 1});\\n\\t\\t\\t}\\n\\t\\t\\tif (rNode.first->right) {\\n\\t\\t\\t\\tque.push({rNode.first->right, 2 * rNode.second + 2});\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\twidth = max(width, int(right - left + 1));\\n\\t}\\n\\treturn width;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nint widthOfBinaryTree(TreeNode* root) {\\n\\tif (!root)return 0;\\n\\tqueue<pair<TreeNode*, unsigned long long int>> que;\\n\\tque.push({root, 0});\\n\\tint width = 0;\\n\\twhile (que.size() != 0) {\\n\\t\\tunsigned long long int left = que.front().second, right = 0;\\n\\t\\tint size = que.size();\\n\\t\\twhile (size-- > 0) {\\n\\t\\t\\tpair<TreeNode*, unsigned long long int> rNode = que.front();\\n\\t\\t\\tque.pop();\\n\\t\\t\\tright = rNode.second;\\n\\t\\t\\tif (rNode.first->left) {\\n\\t\\t\\t\\tque.push({rNode.first->left, 2 * rNode.second + 1});\\n\\t\\t\\t}\\n\\t\\t\\tif (rNode.first->right) {\\n\\t\\t\\t\\tque.push({rNode.first->right, 2 * rNode.second + 2});\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\twidth = max(width, int(right - left + 1));\\n\\t}\\n\\treturn width;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1802355,
                "title": "java-reuse-lc-102-explained",
                "content": "**Thought process:**\\n* The problem requires us to process each level to solve a sub-problem (width of a level) which leads us to solve a bigger problem (max width across levels).\\n* To process each level, we need to do Level Order Traversal (LOT) using BFS. \\n* These kind of problems fall under the category of Tree BFS. To find examples of this pattern, find questions tagged with tree and BFS.\\n* The next problem is to assign indices to non-null nodes using a formula. This can come from having done a basic course of Data Structures, or having an experience with data structures like trees and heaps from problem solving.\\n* Once these things are figured out, the problem is a simple LOT.\\n\\n**Idea:**\\n* Reuse [LC 102. Binary Tree Level Order Traversal](https://leetcode.com/problems/binary-tree-level-order-traversal/discuss/1394405/Java-or-BFS-or-Time-beats-100) with slight change\\n* Instead of storing just the node in the queue of BFS, store an augmented data structure of node and its position in the binary tree\\n* For a [fuIl binary tree](https://www.programiz.com/dsa/full-binary-tree), if parent node has position = i, then left-child\\'s position = `2i` and right-child\\'s position = `2i + 1`\\n* Width of a level in the tree = position of last node - position of first node + 1\\n* Max width will be the max of widths of all levels\\n* Instead of using an augmented data structure, you can:\\n\\t* use a hash-map of node-to-position, but it would take up more space (O(n))\\n\\t* or if modifying the input is allowed, then you can replace node.val with node.pos\\n* Example\\n\\n![image](https://assets.leetcode.com/users/images/1365a66b-5798-4f38-b390-7c7692a68e9c_1645931207.8733404.png)\\n\\n>**T/S:** O(n)/O(w), where n = number of nodes in the tree, d = max nodes at a level\\n```\\nrecord Pair(TreeNode node, int pos) {} // replace with class for Java < 14\\n\\npublic int widthOfBinaryTree(TreeNode root) {\\n\\troot.val = 0;\\n\\tvar maxWidth = 1;\\n\\n\\tfor (var q = new ArrayDeque<>(List.of(root)); !q.isEmpty();) {\\n\\t\\tvar head = q.peek();\\n\\t\\tvar tail = head;\\n\\n\\t\\tfor (var i = q.size(); i > 0; i--) {\\n\\t\\t\\ttail = q.poll();\\n\\t\\t\\tif (tail.left != null) {\\n\\t\\t\\t\\ttail.left.val = 2 * tail.val;\\n\\t\\t\\t\\tq.add(tail.left);\\n\\t\\t\\t}\\n\\t\\t\\tif (tail.right != null) {\\n\\t\\t\\t\\ttail.right.val = 2 * tail.val + 1;\\n\\t\\t\\t\\tq.add(tail.right);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tmaxWidth = Math.max(maxWidth, tail.val - head.val + 1);\\n\\t}\\n\\treturn maxWidth;\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nrecord Pair(TreeNode node, int pos) {} // replace with class for Java < 14\\n\\npublic int widthOfBinaryTree(TreeNode root) {\\n\\troot.val = 0;\\n\\tvar maxWidth = 1;\\n\\n\\tfor (var q = new ArrayDeque<>(List.of(root)); !q.isEmpty();) {\\n\\t\\tvar head = q.peek();\\n\\t\\tvar tail = head;\\n\\n\\t\\tfor (var i = q.size(); i > 0; i--) {\\n\\t\\t\\ttail = q.poll();\\n\\t\\t\\tif (tail.left != null) {\\n\\t\\t\\t\\ttail.left.val = 2 * tail.val;\\n\\t\\t\\t\\tq.add(tail.left);\\n\\t\\t\\t}\\n\\t\\t\\tif (tail.right != null) {\\n\\t\\t\\t\\ttail.right.val = 2 * tail.val + 1;\\n\\t\\t\\t\\tq.add(tail.right);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tmaxWidth = Math.max(maxWidth, tail.val - head.val + 1);\\n\\t}\\n\\treturn maxWidth;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 106663,
                "title": "java-o-n-bfs-one-queue-clean-solution",
                "content": "change the val of node to be the index to save space. The value is useless. All we need is just the index.\\n```\\nclass Solution {\\n    public int widthOfBinaryTree(TreeNode root) {\\n        if (root == null) {\\n            return 0;\\n        }\\n        LinkedList<TreeNode> queue = new LinkedList<>();\\n        queue.offer(root);\\n        root.val = 0;\\n        int max = 1;\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            max = Math.max(max, queue.peekLast().val - queue.peekFirst().val + 1);\\n            for (int i = 0; i < size; i++) {\\n                root = queue.poll();\\n                if (root.left != null) {\\n                    root.left.val = root.val * 2;\\n                    queue.offer(root.left);\\n                }\\n                if (root.right != null) {\\n                    root.right.val = root.val * 2 + 1;\\n                    queue.offer(root.right);\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int widthOfBinaryTree(TreeNode root) {\\n        if (root == null) {\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3436503,
                "title": "dfs-solution-visualized-explanation-c-go",
                "content": "We will index all nodes with non zero indexing for all levels. Also we save min index of the level in hashtable.\\n![photo_2023-04-20_05-48-38.jpg](https://assets.leetcode.com/users/images/43c61439-9710-42e2-ab4d-1556cdce35e3_1681953314.9079616.jpeg)\\n\\n\\n\\n# Approach\\nDepth First Search algorithm\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(depth)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```Go []\\nfunc widthOfBinaryTree(root *TreeNode) int {\\n\\tset := make(map[int]int)\\n\\n\\treturn dfs(root, 1, 0, set)\\n}\\n\\nfunc dfs(node *TreeNode, index, level int, set map[int]int) int {\\n\\tif node == nil {\\n\\t\\treturn 0\\n\\t}\\n\\n\\tif _, ok := set[level]; !ok {\\n\\t\\tset[level] = index\\n\\t}\\n\\n\\tcur := index - set[level] + 1\\n\\tleft := dfs(node.Left, index*2-1, level+1, set)\\n\\tright := dfs(node.Right, index*2, level+1, set)\\n\\t\\n\\treturn max(cur, max(left, right))\\n}\\n\\nfunc max(a, b int) int {\\n\\tif a > b {\\n\\t\\treturn a\\n\\t}\\n\\n\\treturn b\\n}\\n```\\n```C# []\\npublic class Solution {\\n    public int WidthOfBinaryTree(TreeNode root) {\\n        var set = new Dictionary<int, int>();\\n        return DFS(root, 1, 0, set);\\n    }\\n\\n    public int DFS(TreeNode node, int index, int level, Dictionary<int, int> set) {\\n        if (node == null) return 0;\\n\\n        if (!set.ContainsKey(level)) {\\n            set[level] = index;\\n        }\\n\\n        int cur = index - set[level] + 1;\\n\\n        int left = DFS(node.left, index*2-1, level+1, set);\\n        int right = DFS(node.right, index*2, level+1, set);\\n\\n        return Math.Max(cur, Math.Max(left, right));\\n    }\\n}\\n```\\n![a6c83c54-1d1a-4f26-8273-b687d119dd5b_1679889261.1494205.png](https://assets.leetcode.com/users/images/cc82e8aa-dc98-4f10-af4c-64b1528c0fb6_1680844232.130332.png)",
                "solutionTags": [
                    "C#",
                    "Go",
                    "Hash Table",
                    "Depth-First Search"
                ],
                "code": "```Go []\\nfunc widthOfBinaryTree(root *TreeNode) int {\\n\\tset := make(map[int]int)\\n\\n\\treturn dfs(root, 1, 0, set)\\n}\\n\\nfunc dfs(node *TreeNode, index, level int, set map[int]int) int {\\n\\tif node == nil {\\n\\t\\treturn 0\\n\\t}\\n\\n\\tif _, ok := set[level]; !ok {\\n\\t\\tset[level] = index\\n\\t}\\n\\n\\tcur := index - set[level] + 1\\n\\tleft := dfs(node.Left, index*2-1, level+1, set)\\n\\tright := dfs(node.Right, index*2, level+1, set)\\n\\t\\n\\treturn max(cur, max(left, right))\\n}\\n\\nfunc max(a, b int) int {\\n\\tif a > b {\\n\\t\\treturn a\\n\\t}\\n\\n\\treturn b\\n}\\n```\n```C# []\\npublic class Solution {\\n    public int WidthOfBinaryTree(TreeNode root) {\\n        var set = new Dictionary<int, int>();\\n        return DFS(root, 1, 0, set);\\n    }\\n\\n    public int DFS(TreeNode node, int index, int level, Dictionary<int, int> set) {\\n        if (node == null) return 0;\\n\\n        if (!set.ContainsKey(level)) {\\n            set[level] = index;\\n        }\\n\\n        int cur = index - set[level] + 1;\\n\\n        int left = DFS(node.left, index*2-1, level+1, set);\\n        int right = DFS(node.right, index*2, level+1, set);\\n\\n        return Math.Max(cur, Math.Max(left, right));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 727354,
                "title": "c-o-n-intuitive-bfs-solution-using-queue-detailed-explanation",
                "content": "**EDIT**: This is my initial solution which got accepted earlier when there were 108 test cases. There are 111 test cases now and this was resulting in TLE for one of the testcases. Please check out the **new working solution** below.\\n\\n**Initial Approach**\\n\\nPerform a level order traversal (BFS) with modifications.\\nRemove all **NULL** nodes from the beginning and end of the deque. Deque provides **O(1)** constant time complexity for insertion and deletion of elements from front and back.\\nAfter removing NULL nodes from front and back, compare the size with maxwidth to update maxwidth if needed.\\nProcess all the nodes in queue:\\n- for non-NULL nodes,  push the left and right child in the deque (using push_back)\\n- for NULL nodes present in the deque, push two NULL nodes in the queue (using push_back). \\n\\n```\\nclass Solution {\\npublic:\\n    int widthOfBinaryTree(TreeNode* root) {\\n        \\n        if(!root) return 0;\\n        \\n        //similar to level order\\n        deque<TreeNode *> q;\\n        int count = 0, maxwidth =0;\\n        q.push_front(root);\\n        \\n        while(!q.empty()){\\n            \\n            while(!q.empty() && q.back()==NULL){\\n                q.pop_back(); //removing NULL nodes at the end\\n            }\\n            \\n            while(!q.empty() && q.front()==NULL){\\n                q.pop_front(); //removing NULL nodes in the front\\n            }\\n            \\n            int sz = q.size();\\n            maxwidth = max(maxwidth, sz);\\n            \\n            for(int i=0; i<sz; i++){\\n                TreeNode *tmp = q.front();\\n                q.pop_front();\\n                if(tmp){\\n                    q.push_back(tmp->left);\\n                    q.push_back(tmp->right);\\n                }\\n                \\n                else{\\n                    q.push_back(NULL);\\n                    q.push_back(NULL);\\n                }\\n            }\\n        }\\n        \\n        return maxwidth;\\n        \\n    }\\n};\\n```\\n\\nIf the tree given is highly sparse (as was in the example test case), the space requirement will increase exponentially with depth and hence result in TLE as we process all the empty nodes in the deque.\\n\\n**New Approach**\\n\\nThis new approach inserts only the **non-NULL nodes** in the **queue** along with their indices in the tree. The index of the left and right child nodes are ```2*parent_index + 1``` and ```2*parent_index + 2``` respectively. Thus, the space and time required to process the NULL nodes earlier being pushed into the deque is eliminated.\\n\\n```\\nclass Solution {\\npublic:\\n    int widthOfBinaryTree(TreeNode* root) {\\n    \\n     if(!root) return 0;\\n        \\n        //similar to level order\\n        queue<pair<TreeNode *, unsigned long long int>> q;\\n        int maxwidth =0;\\n        q.push(make_pair(root, 0));\\n        \\n        while(!q.empty()){\\n            \\n            \\n            unsigned long long int left_index = q.front().second, right_index = 0;\\n            unsigned long long int sz = q.size();\\n            \\n            \\n            for(unsigned long long int i=0; i<sz; i++){\\n                \\n                pair<TreeNode *, unsigned long long int> p = q.front();\\n                q.pop();\\n                TreeNode *temp = p.first;\\n                right_index = p.second;\\n                \\n                if(temp->left)\\n                    q.push(make_pair(temp->left, 2*right_index + 1));\\n                if(temp->right)\\n                    q.push(make_pair(temp->right, 2*right_index + 2));\\n                \\n            }\\n            \\n            maxwidth = max(maxwidth, int(right_index - left_index + 1));\\n        }\\n        \\n        return maxwidth;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int widthOfBinaryTree(TreeNode* root) {\\n        \\n        if(!root) return 0;\\n        \\n        //similar to level order\\n        deque<TreeNode *> q;\\n        int count = 0, maxwidth =0;\\n        q.push_front(root);\\n        \\n        while(!q.empty()){\\n            \\n            while(!q.empty() && q.back()==NULL){\\n                q.pop_back(); //removing NULL nodes at the end\\n            }\\n            \\n            while(!q.empty() && q.front()==NULL){\\n                q.pop_front(); //removing NULL nodes in the front\\n            }\\n            \\n            int sz = q.size();\\n            maxwidth = max(maxwidth, sz);\\n            \\n            for(int i=0; i<sz; i++){\\n                TreeNode *tmp = q.front();\\n                q.pop_front();\\n                if(tmp){\\n                    q.push_back(tmp->left);\\n                    q.push_back(tmp->right);\\n                }\\n                \\n                else{\\n                    q.push_back(NULL);\\n                    q.push_back(NULL);\\n                }\\n            }\\n        }\\n        \\n        return maxwidth;\\n        \\n    }\\n};\\n```\n```2*parent_index + 1```\n```2*parent_index + 2```\n```\\nclass Solution {\\npublic:\\n    int widthOfBinaryTree(TreeNode* root) {\\n    \\n     if(!root) return 0;\\n        \\n        //similar to level order\\n        queue<pair<TreeNode *, unsigned long long int>> q;\\n        int maxwidth =0;\\n        q.push(make_pair(root, 0));\\n        \\n        while(!q.empty()){\\n            \\n            \\n            unsigned long long int left_index = q.front().second, right_index = 0;\\n            unsigned long long int sz = q.size();\\n            \\n            \\n            for(unsigned long long int i=0; i<sz; i++){\\n                \\n                pair<TreeNode *, unsigned long long int> p = q.front();\\n                q.pop();\\n                TreeNode *temp = p.first;\\n                right_index = p.second;\\n                \\n                if(temp->left)\\n                    q.push(make_pair(temp->left, 2*right_index + 1));\\n                if(temp->right)\\n                    q.push(make_pair(temp->right, 2*right_index + 2));\\n                \\n            }\\n            \\n            maxwidth = max(maxwidth, int(right_index - left_index + 1));\\n        }\\n        \\n        return maxwidth;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 106648,
                "title": "java-uff0clevel-traversal-using-two-queue",
                "content": " It's easy to use a travel traversal template, use another queue to keep the index of each level nodes. left node index = this node index * 2, right = this node index*2 + 1. the width should be the last node index - first node index + 1\\n```java\\n    public int widthOfBinaryTree(TreeNode root) {\\n        if(root == null) return 0;\\n        ArrayDeque<TreeNode> queue = new ArrayDeque<>();\\n        ArrayDeque<Integer>  count = new ArrayDeque<>();\\n        queue.offer(root);\\n        count.offer(0);\\n        int max = 1;\\n        \\n        while(!queue.isEmpty()) {\\n            int size = queue.size();\\n            int left = 0;\\n            int right = 0;\\n            for(int i = 0; i < size; i++) {\\n                TreeNode node = queue.poll();\\n                int index = count.poll();\\n                if(i == 0)  left = index;\\n                if(i == size-1)  right = index;\\n                if(node.left != null) {\\n                    queue.offer(node.left);\\n                    count.offer(index*2);\\n                }\\n                if(node.right != null) {\\n                    queue.offer(node.right);\\n                    count.offer(index*2 + 1);\\n                }\\n            }\\n            max = Math.max(max,right - left + 1);\\n        }\\n        return max;\\n    }\\n```",
                "solutionTags": [],
                "code": "```java\\n    public int widthOfBinaryTree(TreeNode root) {\\n        if(root == null) return 0;\\n        ArrayDeque<TreeNode> queue = new ArrayDeque<>();\\n        ArrayDeque<Integer>  count = new ArrayDeque<>();\\n        queue.offer(root);\\n        count.offer(0);\\n        int max = 1;\\n        \\n        while(!queue.isEmpty()) {\\n            int size = queue.size();\\n            int left = 0;\\n            int right = 0;\\n            for(int i = 0; i < size; i++) {\\n                TreeNode node = queue.poll();\\n                int index = count.poll();\\n                if(i == 0)  left = index;\\n                if(i == size-1)  right = index;\\n                if(node.left != null) {\\n                    queue.offer(node.left);\\n                    count.offer(index*2);\\n                }\\n                if(node.right != null) {\\n                    queue.offer(node.right);\\n                    count.offer(index*2 + 1);\\n                }\\n            }\\n            max = Math.max(max,right - left + 1);\\n        }\\n        return max;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1803055,
                "title": "python-easy-bfs",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def widthOfBinaryTree(self, root: Optional[TreeNode]) -> int:\\n        #queue for keeping track\\n        q = [(0, root)]\\n        ans = 0\\n        while q:\\n            n = len(q)\\n            # nodes list to store indexes of all nodes at a level\\n            nodes = []\\n            for _ in range(n):\\n                idx, node = q.pop(0)\\n                nodes.append(idx)\\n                if node.left:\\n                    q.append((2*idx+1 , node.left))\\n                if node.right:\\n                    q.append((2*idx+2 , node.right))\\n            # max of ans or (right-most index - left-most index + 1) for a level\\n            ans = max(ans, max(nodes)-min(nodes)+1)\\n        return ans\\n```\\n\\n**Concepts to be known:**\\n\\n**For a binary tree**\\nindex of left child of a node -> 2 * parent node level + 1\\nindex of right child of a node -> 2 * parent node level + 2\\nwidth = right_most node index  -  left_most node index  + 1  ( for a single level )\\n\\n**Approach**\\n\\n1. One queue for keeping track for all nodes\\n2. One list (named: nodes) to store all nodes\\' indexes for a level\\n3. Ans = max( Ans , current level\\'s width )\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def widthOfBinaryTree(self, root: Optional[TreeNode]) -> int:\\n        #queue for keeping track\\n        q = [(0, root)]\\n        ans = 0\\n        while q:\\n            n = len(q)\\n            # nodes list to store indexes of all nodes at a level\\n            nodes = []\\n            for _ in range(n):\\n                idx, node = q.pop(0)\\n                nodes.append(idx)\\n                if node.left:\\n                    q.append((2*idx+1 , node.left))\\n                if node.right:\\n                    q.append((2*idx+2 , node.right))\\n            # max of ans or (right-most index - left-most index + 1) for a level\\n            ans = max(ans, max(nodes)-min(nodes)+1)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3436772,
                "title": "easy-solutions-in-java-python-and-c-look-at-once-with-exaplanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n>**To find the maximum width of a binary tree, we can traverse the tree level by level using a BFS (Breadth-First Search) approach. At each level, we keep track of the leftmost and rightmost non-null nodes using two variables. We calculate the width of the level by subtracting the index of the leftmost node from the index of the rightmost node and adding 1. Finally, we update the maximum width with the width of the current level if it is greater than the previous maximum.**\\n\\n---\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n> 1. Create a queue to store the nodes of the binary tree and another queue to store the indices of the nodes.\\n> 2. Enqueue the root node and its index into the two queues.\\n> 3. Initialize the maximum width to 1.\\n> 4. While the queue is not empty, perform the following steps:\\na. Get the size of the current level.\\nb. Traverse the current level and update the left and right indices.\\nc. Enqueue the left and right child nodes of the current node into the queues with updated indices.\\nd. Update the maximum width with the width of the current level.\\n> 5. Return the maximum width.\\n\\n---\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n>O(N), where N is the number of nodes in the binary tree. We need to visit every node once.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n>O(N), where N is the number of nodes in the binary tree. In the worst case, the queue can contain all the nodes of the last level of the binary tree.\\n---\\n\\n![image.png](https://assets.leetcode.com/users/images/b427e686-2e5d-469a-8e7a-db5140022a6b_1677715904.0948765.png)\\n\\n\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\\n# Code\\n```java []\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int widthOfBinaryTree(TreeNode root) {\\n        if (root == null) {\\n            return 0;\\n        }\\n        \\n        int maxWidth = 1;\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        Queue<Integer> indexQueue = new LinkedList<>();\\n        queue.offer(root);\\n        indexQueue.offer(1);\\n        \\n        while (!queue.isEmpty()) {\\n            int levelSize = queue.size();\\n            int leftIndex = 0, rightIndex = 0;\\n            \\n            for (int i = 0; i < levelSize; i++) {\\n                TreeNode node = queue.poll();\\n                int index = indexQueue.poll();\\n                \\n                if (i == 0) {\\n                    leftIndex = index;\\n                }\\n                if (i == levelSize - 1) {\\n                    rightIndex = index;\\n                }\\n                \\n                if (node.left != null) {\\n                    queue.offer(node.left);\\n                    indexQueue.offer(index * 2);\\n                }\\n                if (node.right != null) {\\n                    queue.offer(node.right);\\n                    indexQueue.offer(index * 2 + 1);\\n                }\\n            }\\n            \\n            maxWidth = Math.max(maxWidth, rightIndex - leftIndex + 1);\\n        }\\n        \\n        return maxWidth;\\n    }\\n}\\n```\\n```C++ []\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int widthOfBinaryTree(TreeNode* root) {\\n        if (!root) return 0;\\n        int maxWidth = 0;\\n        queue<TreeNode*> node_q;\\n        queue<unsigned long long> index_q;\\n        node_q.push(root);\\n        index_q.push(1);\\n        while (!node_q.empty()) {\\n            int size = node_q.size();\\n            unsigned long long leftIndex = index_q.front(), rightIndex = 0;\\n            for (int i = 0; i < size; ++i) {\\n                TreeNode* curr = node_q.front();\\n                unsigned long long index = index_q.front();\\n                node_q.pop();\\n                index_q.pop();\\n                rightIndex = index;\\n                if (curr->left) {\\n                    node_q.push(curr->left);\\n                    index_q.push(index * 2);\\n                }\\n                if (curr->right) {\\n                    node_q.push(curr->right);\\n                    index_q.push(index * 2 + 1);\\n                }\\n            }\\n            maxWidth = max(maxWidth, (int)(rightIndex - leftIndex + 1));\\n        }\\n        return maxWidth;\\n    }\\n};\\n\\n```\\n\\n\\n```python []\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\nclass Solution:\\n     def widthOfBinaryTree(self, root):\\n        if not root:\\n            return 0\\n        \\n        max_width = 1\\n        queue = deque([root])\\n        index_queue = deque([1])\\n        \\n        while queue:\\n            level_size = len(queue)\\n            left_index, right_index = 0, 0\\n            \\n            for i in range(level_size):\\n                node = queue.popleft()\\n                index = index_queue.popleft()\\n                \\n                if i == 0:\\n                    left_index = index\\n                if i == level_size - 1:\\n                    right_index = index\\n                \\n                if node.left:\\n                    queue.append(node.left)\\n                    index_queue.append(index * 2)\\n                if node.right:\\n                    queue.append(node.right)\\n                    index_queue.append(index * 2 + 1)\\n            \\n            max_width = max(max_width, right_index - left_index + 1)\\n        \\n        return max_width\\n\\n```\\n# Please Comment\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution comment below if you like it.\\uD83D\\uDE0A\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\n```java []\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int widthOfBinaryTree(TreeNode root) {\\n        if (root == null) {\\n            return 0;\\n        }\\n        \\n        int maxWidth = 1;\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        Queue<Integer> indexQueue = new LinkedList<>();\\n        queue.offer(root);\\n        indexQueue.offer(1);\\n        \\n        while (!queue.isEmpty()) {\\n            int levelSize = queue.size();\\n            int leftIndex = 0, rightIndex = 0;\\n            \\n            for (int i = 0; i < levelSize; i++) {\\n                TreeNode node = queue.poll();\\n                int index = indexQueue.poll();\\n                \\n                if (i == 0) {\\n                    leftIndex = index;\\n                }\\n                if (i == levelSize - 1) {\\n                    rightIndex = index;\\n                }\\n                \\n                if (node.left != null) {\\n                    queue.offer(node.left);\\n                    indexQueue.offer(index * 2);\\n                }\\n                if (node.right != null) {\\n                    queue.offer(node.right);\\n                    indexQueue.offer(index * 2 + 1);\\n                }\\n            }\\n            \\n            maxWidth = Math.max(maxWidth, rightIndex - leftIndex + 1);\\n        }\\n        \\n        return maxWidth;\\n    }\\n}\\n```\n```C++ []\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int widthOfBinaryTree(TreeNode* root) {\\n        if (!root) return 0;\\n        int maxWidth = 0;\\n        queue<TreeNode*> node_q;\\n        queue<unsigned long long> index_q;\\n        node_q.push(root);\\n        index_q.push(1);\\n        while (!node_q.empty()) {\\n            int size = node_q.size();\\n            unsigned long long leftIndex = index_q.front(), rightIndex = 0;\\n            for (int i = 0; i < size; ++i) {\\n                TreeNode* curr = node_q.front();\\n                unsigned long long index = index_q.front();\\n                node_q.pop();\\n                index_q.pop();\\n                rightIndex = index;\\n                if (curr->left) {\\n                    node_q.push(curr->left);\\n                    index_q.push(index * 2);\\n                }\\n                if (curr->right) {\\n                    node_q.push(curr->right);\\n                    index_q.push(index * 2 + 1);\\n                }\\n            }\\n            maxWidth = max(maxWidth, (int)(rightIndex - leftIndex + 1));\\n        }\\n        return maxWidth;\\n    }\\n};\\n\\n```\n```python []\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\nclass Solution:\\n     def widthOfBinaryTree(self, root):\\n        if not root:\\n            return 0\\n        \\n        max_width = 1\\n        queue = deque([root])\\n        index_queue = deque([1])\\n        \\n        while queue:\\n            level_size = len(queue)\\n            left_index, right_index = 0, 0\\n            \\n            for i in range(level_size):\\n                node = queue.popleft()\\n                index = index_queue.popleft()\\n                \\n                if i == 0:\\n                    left_index = index\\n                if i == level_size - 1:\\n                    right_index = index\\n                \\n                if node.left:\\n                    queue.append(node.left)\\n                    index_queue.append(index * 2)\\n                if node.right:\\n                    queue.append(node.right)\\n                    index_queue.append(index * 2 + 1)\\n            \\n            max_width = max(max_width, right_index - left_index + 1)\\n        \\n        return max_width\\n\\n```\n```\\nThanks for visiting my solution comment below if you like it.\\uD83D\\uDE0A\\n```",
                "codeTag": "Java"
            },
            {
                "id": 106655,
                "title": "java-solution-node-position-of-binary-tree",
                "content": "```\\nclass Solution {\\n    Map<Integer, int[]> map = new HashMap<>();\\n    \\n    public int widthOfBinaryTree(TreeNode root) {\\n        if (root == null) return 0;\\n        \\n        findMax(root, 0, 0);\\n        \\n        int res = 1;\\n        for (int[] rec : map.values()) {\\n            res = Math.max(res, rec[1] - rec[0] + 1);\\n        }\\n        \\n        return res;\\n    }\\n    \\n    private void findMax(TreeNode root, int level, int pos) {\\n        if (root == null) return;\\n        \\n        int[] rec = map.get(level);\\n        if (rec == null) {\\n            rec = new int[2];\\n            rec[0] = Integer.MAX_VALUE;\\n            rec[1] = Integer.MIN_VALUE;\\n        }\\n\\n        rec[0] = Math.min(rec[0], pos);\\n        rec[1] = Math.max(rec[1], pos);\\n        map.put(level, rec);\\n        \\n        findMax(root.left, level + 1, 2 * pos);\\n        findMax(root.right, level + 1, 2 * pos + 1);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    Map<Integer, int[]> map = new HashMap<>();\\n    \\n    public int widthOfBinaryTree(TreeNode root) {\\n        if (root == null) return 0;\\n        \\n        findMax(root, 0, 0);\\n        \\n        int res = 1;\\n        for (int[] rec : map.values()) {\\n            res = Math.max(res, rec[1] - rec[0] + 1);\\n        }\\n        \\n        return res;\\n    }\\n    \\n    private void findMax(TreeNode root, int level, int pos) {\\n        if (root == null) return;\\n        \\n        int[] rec = map.get(level);\\n        if (rec == null) {\\n            rec = new int[2];\\n            rec[0] = Integer.MAX_VALUE;\\n            rec[1] = Integer.MIN_VALUE;\\n        }\\n\\n        rec[0] = Math.min(rec[0], pos);\\n        rec[1] = Math.max(rec[1], pos);\\n        map.put(level, rec);\\n        \\n        findMax(root.left, level + 1, 2 * pos);\\n        findMax(root.right, level + 1, 2 * pos + 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1318023,
                "title": "java-explanation-in-simple-english-bfs",
                "content": "\\n**Idea:** See the idea is to assosiate a index number with each node. Suppose the index number of a root is say X , then index of its left child is 2*X + 1 and index of right child is 2*X + 2.\\nSo perform normal BFS and for each level we will calculate the width as (index of last element - index of first element + 1) and find the maximum of all widths. \\n\\n**Trick:** Instead of just pushing the node to the  queue, push a Pair<Node, Integer>. which will keep track of index of all the node \\n\\n##### Please upvote if you like the explaination\\n\\n```\\nclass Solution {\\n    public int widthOfBinaryTree(TreeNode root) {\\n        \\n        if(root == null) return 0;\\n        \\n        int result = Integer.MIN_VALUE;\\n\\n        ArrayDeque<Pair<TreeNode, Integer>> q = new ArrayDeque<Pair<TreeNode, Integer>>();\\n        q.add(new Pair<>(root, 0));\\n\\n        while(!q.isEmpty()) {\\n\\n            int size = q.size();\\n            result = Math.max(result, (q.getLast().getValue() - q.getFirst().getValue() + 1));\\n\\n            for(int i = 0; i < size; i++) {\\n\\n                Pair<TreeNode, Integer> pair = q.poll();\\n                TreeNode item = pair.getKey();\\n                int index = pair.getValue();\\n\\n                if(item.left != null) q.add(new Pair<>(item.left, 2*index+1));\\n                if(item.right != null) q.add(new Pair<>(item.right, 2*index+2));\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int widthOfBinaryTree(TreeNode root) {\\n        \\n        if(root == null) return 0;\\n        \\n        int result = Integer.MIN_VALUE;\\n\\n        ArrayDeque<Pair<TreeNode, Integer>> q = new ArrayDeque<Pair<TreeNode, Integer>>();\\n        q.add(new Pair<>(root, 0));\\n\\n        while(!q.isEmpty()) {\\n\\n            int size = q.size();\\n            result = Math.max(result, (q.getLast().getValue() - q.getFirst().getValue() + 1));\\n\\n            for(int i = 0; i < size; i++) {\\n\\n                Pair<TreeNode, Integer> pair = q.poll();\\n                TreeNode item = pair.getKey();\\n                int index = pair.getValue();\\n\\n                if(item.left != null) q.add(new Pair<>(item.left, 2*index+1));\\n                if(item.right != null) q.add(new Pair<>(item.right, 2*index+2));\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 727197,
                "title": "javascript-clean-dfs-no-bigint",
                "content": "```javascript\\nvar widthOfBinaryTree = function(root) {\\n    const minPos = [0];\\n    let maxWidth = 0;\\n    \\n    callDFS(root, 0, 0);\\n    return maxWidth;\\n    \\n    function callDFS(node, level, pos) {\\n        if(!node) return;\\n        if(minPos[level] === undefined) minPos.push(pos);\\n        \\n        const diff = pos - minPos[level];\\n        maxWidth = Math.max(maxWidth, diff+1);\\n        \\n        callDFS(node.left, level+1, diff*2);\\n        callDFS(node.right, level+1, diff*2+1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar widthOfBinaryTree = function(root) {\\n    const minPos = [0];\\n    let maxWidth = 0;\\n    \\n    callDFS(root, 0, 0);\\n    return maxWidth;\\n    \\n    function callDFS(node, level, pos) {\\n        if(!node) return;\\n        if(minPos[level] === undefined) minPos.push(pos);\\n        \\n        const diff = pos - minPos[level];\\n        maxWidth = Math.max(maxWidth, diff+1);\\n        \\n        callDFS(node.left, level+1, diff*2);\\n        callDFS(node.right, level+1, diff*2+1);\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 106659,
                "title": "java-easy-to-understand-solution-bfs",
                "content": "The solution is based on the traditional BFS.  Below are the steps of the algorithm:\\n\\n1. When traversing the current level, try to construct the next level. When constructing, we add all nodes from next level no matter it is a null node or not. \\n2. Then will make the next level valid. That is, get rid of the null nodes that appear before the first non-null node and after the last non-null node. \\n\\n    For example:\\nnext level when constructing: [null, 1, 2, 3, null, null, null, 4, null, null]\\nAfter validating: [1, 2, 3, null, null, null, 4]\\n\\n3. Then, after validating, it is a potential width of the tree. Compare it with the existing width. \\n\\n4. Do this for all levels.\\n\\n```\\npublic int widthOfBinaryTree(TreeNode root) {\\n        if (root == null) return 0;\\n        List<TreeNode> cur = new ArrayList<>();\\n        cur.add(root);\\n        int res = 1;\\n        \\n        while (cur.size() != 0) {\\n            List<TreeNode> next = new ArrayList<>();\\n            for (int i = 0; i < cur.size(); i++) {\\n                TreeNode node = cur.get(i);\\n                if (node == null) {\\n                    next.add(null);\\n                    next.add(null);\\n                }else {\\n                    next.add(node.left);\\n                    next.add(node.right);\\n                }\\n            }\\n            next = makeValid(next);\\n            res = Math.max(res, next.size());\\n            cur = next;\\n        }\\n        return res;\\n    }\\n    \\n    private List<TreeNode> makeValid(List<TreeNode> list) {\\n        List<TreeNode> res = new ArrayList<>();\\n        if (list == null) return res;\\n        int left = 0, right = list.size() - 1;\\n        \\n        while (left <= right && list.get(left) == null) {\\n            left++;\\n        }\\n        while (left <= right && list.get(right) == null) {\\n            right--;\\n        }\\n        \\n        for (; left <= right; left++) {\\n            res.add(list.get(left));\\n        }\\n        return res;\\n    }\\n````",
                "solutionTags": [],
                "code": "```\\npublic int widthOfBinaryTree(TreeNode root) {\\n        if (root == null) return 0;\\n        List<TreeNode> cur = new ArrayList<>();\\n        cur.add(root);\\n        int res = 1;\\n        \\n        while (cur.size() != 0) {\\n            List<TreeNode> next = new ArrayList<>();\\n            for (int i = 0; i < cur.size(); i++) {\\n                TreeNode node = cur.get(i);\\n                if (node == null) {\\n                    next.add(null);\\n                    next.add(null);\\n                }else {\\n                    next.add(node.left);\\n                    next.add(node.right);\\n                }\\n            }\\n            next = makeValid(next);\\n            res = Math.max(res, next.size());\\n            cur = next;\\n        }\\n        return res;\\n    }\\n    \\n    private List<TreeNode> makeValid(List<TreeNode> list) {\\n        List<TreeNode> res = new ArrayList<>();\\n        if (list == null) return res;\\n        int left = 0, right = list.size() - 1;\\n        \\n        while (left <= right && list.get(left) == null) {\\n            left++;\\n        }\\n        while (left <= right && list.get(right) == null) {\\n            right--;\\n        }\\n        \\n        for (; left <= right; left++) {\\n            res.add(list.get(left));\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1338308,
                "title": "c-dfs-bfs-with-no-overflow",
                "content": "## BFS\\n```\\n// Soln 1: BFS - Level order traversal with added logic - O(n) time | O(n) space\\n\\nclass Solution {\\npublic:\\n int widthOfBinaryTree(TreeNode* root) {\\n        if(root == NULL) return 0;\\n     \\n        int maxWidth = 0;\\n        queue<pair<TreeNode*, int>> q;\\n        q.push({root, 1}); // or root,0 here\\n     \\n        while(!q.empty()){\\n            int levelSize = q.size();\\n            \\n            int startPosition = q.front().second;\\n            int endPosition = q.back().second;\\n            \\n            maxWidth = max(maxWidth, endPosition - startPosition + 1);\\n      \\n            for(int i = 0; i < levelSize; ++i){\\n                pair<TreeNode*,int> p = q.front();\\n                q.pop();\\n                \\n                TreeNode* node = p.first;\\n                int position = p.second;\\n                int offsettedPosition = position - startPosition; // we subtract startPosition as otherwise it \\n                                                                // was overflowing the 2*position below\\n                \\n                if(node->left) q.push({node->left, 2*offsettedPosition}); // or 2 * idx + 1\\n                if(node->right) q.push({node->right, 2*offsettedPosition+1}); // or 2* idx + 2\\n                \\n            }\\n           \\n        }\\n        return maxWidth;\\n    }\\n};\\n```\\n\\n## DFS\\n```\\n// Soln 2: DFS - O(n) time | O(n) space\\nclass Solution {\\npublic:\\n    int maxWidth;\\n    int widthOfBinaryTree(TreeNode* root) {\\n        vector<int> levelLefts; // first(leftmost) nodes at each level\\n        dfs(root, 1, 0, levelLefts);\\n        return maxWidth;\\n    }\\n    \\n    void dfs(TreeNode* root, int position, int depth, vector<int>& levelLefts) {\\n        if(depth >= levelLefts.size()) {\\n            levelLefts.push_back(position); // add first node\\n        }\\n        \\n        maxWidth = max(maxWidth, position - levelLefts[depth] + 1);\\n        \\n        if(root->left) {\\n            dfs(root->left,  2*(position - levelLefts[depth]), depth + 1, levelLefts);\\n        }\\n        if(root->right) {\\n            dfs(root->right, 2*(position - levelLefts[depth]) + 1, depth + 1, levelLefts);\\n        }\\n    }\\n};\\n```\\n\\n\\nP.S Checkout my free Chrome LeetCode Video solutions extension: [Link to Chrome store](https://chrome.google.com/webstore/detail/leetcode-video-solutions/ilnmgkahgjdpkoliooildngldmilhelm?hl=en)\\n\\nPlease upvote if found useful :)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion",
                    "Queue"
                ],
                "code": "```\\n// Soln 1: BFS - Level order traversal with added logic - O(n) time | O(n) space\\n\\nclass Solution {\\npublic:\\n int widthOfBinaryTree(TreeNode* root) {\\n        if(root == NULL) return 0;\\n     \\n        int maxWidth = 0;\\n        queue<pair<TreeNode*, int>> q;\\n        q.push({root, 1}); // or root,0 here\\n     \\n        while(!q.empty()){\\n            int levelSize = q.size();\\n            \\n            int startPosition = q.front().second;\\n            int endPosition = q.back().second;\\n            \\n            maxWidth = max(maxWidth, endPosition - startPosition + 1);\\n      \\n            for(int i = 0; i < levelSize; ++i){\\n                pair<TreeNode*,int> p = q.front();\\n                q.pop();\\n                \\n                TreeNode* node = p.first;\\n                int position = p.second;\\n                int offsettedPosition = position - startPosition; // we subtract startPosition as otherwise it \\n                                                                // was overflowing the 2*position below\\n                \\n                if(node->left) q.push({node->left, 2*offsettedPosition}); // or 2 * idx + 1\\n                if(node->right) q.push({node->right, 2*offsettedPosition+1}); // or 2* idx + 2\\n                \\n            }\\n           \\n        }\\n        return maxWidth;\\n    }\\n};\\n```\n```\\n// Soln 2: DFS - O(n) time | O(n) space\\nclass Solution {\\npublic:\\n    int maxWidth;\\n    int widthOfBinaryTree(TreeNode* root) {\\n        vector<int> levelLefts; // first(leftmost) nodes at each level\\n        dfs(root, 1, 0, levelLefts);\\n        return maxWidth;\\n    }\\n    \\n    void dfs(TreeNode* root, int position, int depth, vector<int>& levelLefts) {\\n        if(depth >= levelLefts.size()) {\\n            levelLefts.push_back(position); // add first node\\n        }\\n        \\n        maxWidth = max(maxWidth, position - levelLefts[depth] + 1);\\n        \\n        if(root->left) {\\n            dfs(root->left,  2*(position - levelLefts[depth]), depth + 1, levelLefts);\\n        }\\n        if(root->right) {\\n            dfs(root->right, 2*(position - levelLefts[depth]) + 1, depth + 1, levelLefts);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3436597,
                "title": "leetcode-the-hard-way-explained-line-by-line",
                "content": "We want to traverse each node level by level to calculate the width between the leftmost and the rightmost non-null nodes on the same level. We can use queue to perform BFS. \\n\\nFirst we initialise a queue with a pair of tuple `(node, idx)` . Then we append the root with idx `0` at the beginning. How do we assign `idx` for other nodes? Given a full binary tree, we can easily see a pattern here. If a node with idx `i` has the left node, the its idx would be `2 * i` . If a node with idx `i`  has the right node, the its idx would be `2 * i + 1`.  \\n\\n![image](https://assets.leetcode.com/users/images/324093c2-57a7-4103-b0e4-ec13d0d06220_1645973336.7817879.png)\\n\\nFor each level, we calculate the width between the leftmost and rightmost nodes, which are the first element  in the queue and the last element  in the queue respectively, and check if it could be maximum value. The width between those two nodes is simply `r_idx - l_idx + 1`. For example, on the last level, the width between the leftmost node and the rightmost node would be `7 - 4 + 1 = 4`.\\n\\nFor each element in the queue, we check if it has the left node or the right node. If so, we add it to the queue for further processing. We return the answer after we process all the nodes.\\n\\n```\\nclass Solution {\\npublic:\\n    using ll = long long;\\n    int widthOfBinaryTree(TreeNode* root) {\\n        int ans = 0;\\n        queue<pair<TreeNode*, int>> d; // <node, idx>\\n        // push the first element with idx = 0\\n        d.push({root, 0});\\n        // BFS\\n        while (!d.empty()) {\\n            // l_idx is the idx of the leftmost node\\n            // r_idx is the idx of the rightmost node\\n            ll l_idx = d.front().second, r_idx = d.back().second;\\n            // define n here outside as d.size() may be changed\\n            int n = (int) d.size();\\n            // iterate each tuple\\n            for (int i = 0; i < n; i++) {\\n                // get one tuple and pop it\\n                auto x = d.front(); d.pop();\\n                // get the idx of the current node\\n                auto idx = x.second ;\\n                // if it has the left node, push it for the next level\\n                // with idx = 2 * cur_idx\\n                if (x.first->left)  d.push({x.first->left, (ll) 2 * idx});\\n                // if it has the right node, push it for the next level\\n                // with idx = 2 * cur_idx + 1\\n                if (x.first->right) d.push({x.first->right, (ll) 2 * idx + 1});\\n            }\\n            // check if the current level got the max width\\n            ans = max(ans, int(r_idx - l_idx + 1));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    using ll = long long;\\n    int widthOfBinaryTree(TreeNode* root) {\\n        int ans = 0;\\n        queue<pair<TreeNode*, int>> d; // <node, idx>\\n        // push the first element with idx = 0\\n        d.push({root, 0});\\n        // BFS\\n        while (!d.empty()) {\\n            // l_idx is the idx of the leftmost node\\n            // r_idx is the idx of the rightmost node\\n            ll l_idx = d.front().second, r_idx = d.back().second;\\n            // define n here outside as d.size() may be changed\\n            int n = (int) d.size();\\n            // iterate each tuple\\n            for (int i = 0; i < n; i++) {\\n                // get one tuple and pop it\\n                auto x = d.front(); d.pop();\\n                // get the idx of the current node\\n                auto idx = x.second ;\\n                // if it has the left node, push it for the next level\\n                // with idx = 2 * cur_idx\\n                if (x.first->left)  d.push({x.first->left, (ll) 2 * idx});\\n                // if it has the right node, push it for the next level\\n                // with idx = 2 * cur_idx + 1\\n                if (x.first->right) d.push({x.first->right, (ll) 2 * idx + 1});\\n            }\\n            // check if the current level got the max width\\n            ans = max(ans, int(r_idx - l_idx + 1));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1803819,
                "title": "simple-java-solution-using-2-queue-with-explaination-bfs",
                "content": "we know how to apply level order traversal level wise.\\nso will implement logic similar to that, just we will keep one queue extra to manage index of the node.\\nhow to fill and remove from 2nd queue?\\nwhen we add node to queue, also add its index to queueIndex. for left child index will be 2 * i and for right child it will be 2 * i +1\\nwhen we remove node from queue remove from queueIndex also.\\n\\nNow while iterating level wise just update start and end index variable of that particular level retrieved from queueIndex poll.\\nonce inner loop finishes, just update maxWidth = Math.max(maxWidth,end-start+1)\\n\\nbelow code contains above info in comments which is quite self explainatory\\n```\\npublic int widthOfBinaryTree(TreeNode root) {\\n\\t\\t//queue to hold bfs order\\n\\t\\tQueue<TreeNode> queue = new LinkedList<>();\\n\\t\\t//queue to hold index of corresponding node in bfs order\\n\\t\\tQueue<Integer> queueIndex = new LinkedList<>();\\n\\t\\t//add first node to queue\\n\\t\\tqueue.add(root);\\n\\t\\t//first node index is let say 1\\n\\t\\tqueueIndex.add(1);\\n\\t\\t//hold max width\\n\\t\\tint width = 0;\\n\\t\\t//do level order traversal\\n\\t\\twhile (!queue.isEmpty()) {\\n\\t\\t\\tint size = queue.size();\\n\\t\\t\\t//hold the index of first node in a level\\n\\t\\t\\tint start = 0;\\n\\t\\t\\t//hold index of last node in a level\\n\\t\\t\\tint end = 0;\\n\\t\\t\\tfor (int i = 0; i < size; i++) {\\n\\t\\t\\t\\t//remove from both queue\\n\\t\\t\\t\\tTreeNode node = queue.poll();\\n\\t\\t\\t\\tint index = queueIndex.poll();\\n\\t\\t\\t\\t//if i==0 it means its first node\\n\\t\\t\\t\\tif (i == 0) {\\n\\t\\t\\t\\t\\t//update start index\\n\\t\\t\\t\\t\\tstart = index;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t//if i==last index update end index\\n\\t\\t\\t\\tif (i == size - 1) {\\n\\t\\t\\t\\t\\tend = index;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t//normal bfs logic to add node to queue if present. here add to both queue\\n\\t\\t\\t\\tif (node.left != null) {\\n\\t\\t\\t\\t\\tqueue.add(node.left);\\n\\t\\t\\t\\t\\tqueueIndex.add(index * 2);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t//normal bfs logic to add node to queue if present. here add to both queue\\n\\t\\t\\t\\tif (node.right != null) {\\n\\t\\t\\t\\t\\tqueue.add(node.right);\\n\\t\\t\\t\\t\\tqueueIndex.add(index * 2 + 1);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t//update max width\\n\\t\\t\\twidth = Math.max(width, end - start + 1);\\n\\t\\t}\\n\\t\\t//return answer\\n\\t\\treturn width;\\n\\t}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\npublic int widthOfBinaryTree(TreeNode root) {\\n\\t\\t//queue to hold bfs order\\n\\t\\tQueue<TreeNode> queue = new LinkedList<>();\\n\\t\\t//queue to hold index of corresponding node in bfs order\\n\\t\\tQueue<Integer> queueIndex = new LinkedList<>();\\n\\t\\t//add first node to queue\\n\\t\\tqueue.add(root);\\n\\t\\t//first node index is let say 1\\n\\t\\tqueueIndex.add(1);\\n\\t\\t//hold max width\\n\\t\\tint width = 0;\\n\\t\\t//do level order traversal\\n\\t\\twhile (!queue.isEmpty()) {\\n\\t\\t\\tint size = queue.size();\\n\\t\\t\\t//hold the index of first node in a level\\n\\t\\t\\tint start = 0;\\n\\t\\t\\t//hold index of last node in a level\\n\\t\\t\\tint end = 0;\\n\\t\\t\\tfor (int i = 0; i < size; i++) {\\n\\t\\t\\t\\t//remove from both queue\\n\\t\\t\\t\\tTreeNode node = queue.poll();\\n\\t\\t\\t\\tint index = queueIndex.poll();\\n\\t\\t\\t\\t//if i==0 it means its first node\\n\\t\\t\\t\\tif (i == 0) {\\n\\t\\t\\t\\t\\t//update start index\\n\\t\\t\\t\\t\\tstart = index;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t//if i==last index update end index\\n\\t\\t\\t\\tif (i == size - 1) {\\n\\t\\t\\t\\t\\tend = index;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t//normal bfs logic to add node to queue if present. here add to both queue\\n\\t\\t\\t\\tif (node.left != null) {\\n\\t\\t\\t\\t\\tqueue.add(node.left);\\n\\t\\t\\t\\t\\tqueueIndex.add(index * 2);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t//normal bfs logic to add node to queue if present. here add to both queue\\n\\t\\t\\t\\tif (node.right != null) {\\n\\t\\t\\t\\t\\tqueue.add(node.right);\\n\\t\\t\\t\\t\\tqueueIndex.add(index * 2 + 1);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t//update max width\\n\\t\\t\\twidth = Math.max(width, end - start + 1);\\n\\t\\t}\\n\\t\\t//return answer\\n\\t\\treturn width;\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3436513,
                "title": "python-bfs",
                "content": "```\\nclass Solution:\\n    def widthOfBinaryTree(self, root: Optional[TreeNode]) -> int:\\n        q, width = deque([(root, 0)]), 0\\n        while q:\\n            width = max(width, q[-1][1] - q[0][1])\\n            for _ in range(len(q)):\\n                node, k = q.popleft()\\n                if node.left:\\n                    q.append((node.left, k * 2 - 1))\\n                if node.right:\\n                    q.append((node.right, k * 2))\\n        return width + 1\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def widthOfBinaryTree(self, root: Optional[TreeNode]) -> int:\\n        q, width = deque([(root, 0)]), 0\\n        while q:\\n            width = max(width, q[-1][1] - q[0][1])\\n            for _ in range(len(q)):\\n                node, k = q.popleft()\\n                if node.left:\\n                    q.append((node.left, k * 2 - 1))\\n                if node.right:\\n                    q.append((node.right, k * 2))\\n        return width + 1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 902500,
                "title": "java-100-dfs-well-explained-easy-to-understand",
                "content": "Width can be seen as = index of rightmost node - index of leftmost node + 1\\nassign index to each node, similar as heap on a tree \\nroot\\'s index = 1, left child is 1 * 2, right child is 1 * 2 + 1, and so on...\\nTo avoid Integer overflow, still need to do offset by the index of leftmost node\\n\\n```\\nclass Solution {\\n    public int widthOfBinaryTree(TreeNode root) {\\n       if (root == null) {\\n           return 0;\\n       }\\n        return helper(root, 0, 1, new ArrayList<Integer>());\\n\\n    }\\n    private int helper(TreeNode root, int depth, int index, List<Integer> list) {\\n        if (root == null) {\\n            return 0;\\n        }\\n\\t\\t//add index of leftmost node to list, at depth\\'th position in list\\n        if (depth == list.size()) {\\n            list.add(index);\\n        }\\n        int currWidth = index - list.get(depth) + 1;\\n        int leftWidth = helper(root.left, depth + 1, index * 2, list);\\n        int rightWidth = helper(root.right, depth + 1, index * 2 + 1, list);\\n        return Math.max(currWidth, Math.max(leftWidth, rightWidth));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int widthOfBinaryTree(TreeNode root) {\\n       if (root == null) {\\n           return 0;\\n       }\\n        return helper(root, 0, 1, new ArrayList<Integer>());\\n\\n    }\\n    private int helper(TreeNode root, int depth, int index, List<Integer> list) {\\n        if (root == null) {\\n            return 0;\\n        }\\n\\t\\t//add index of leftmost node to list, at depth\\'th position in list\\n        if (depth == list.size()) {\\n            list.add(index);\\n        }\\n        int currWidth = index - list.get(depth) + 1;\\n        int leftWidth = helper(root.left, depth + 1, index * 2, list);\\n        int rightWidth = helper(root.right, depth + 1, index * 2 + 1, list);\\n        return Math.max(currWidth, Math.max(leftWidth, rightWidth));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 186975,
                "title": "swift-accepted-swift-solution-with-bfs",
                "content": "For Swift, when Int operation meets a overflow, it will directly crash the program and will meet a Runtime Error. \\nOne simply solution is to add \"&\" before the operators to tell Swift to ingnore the overflow. At this time, overflow will be treated like C++, when over the max, the number will turn to -1.\\n```\\n    func widthOfBinaryTree(_ root: TreeNode?) -> Int {\\n        guard let root = root else { return 0 }\\n        var queue: [(TreeNode, Int)] = []\\n        queue.append((root, 1))\\n        var maxLen = 1\\n        while !queue.isEmpty {\\n            let count = queue.count\\n            for _ in 0 ..< count {\\n                let curr = queue.removeFirst() \\n                let index = curr.1\\n                if let left = curr.0.left {\\n                    queue.append((left, index &* 2))\\n                }\\n\\n                if let right = curr.0.right {\\n                    queue.append((right, index &* 2 + 1))\\n                }\\n            }\\n            if !queue.isEmpty {\\n                maxLen = max(maxLen, queue.last!.1 &- queue.first!.1 &+ 1)                \\n            }\\n        }\\n        \\n        return maxLen\\n    }",
                "solutionTags": [],
                "code": "For Swift, when Int operation meets a overflow, it will directly crash the program and will meet a Runtime Error. \\nOne simply solution is to add \"&\" before the operators to tell Swift to ingnore the overflow. At this time, overflow will be treated like C++, when over the max, the number will turn to -1.\\n```\\n    func widthOfBinaryTree(_ root: TreeNode?) -> Int {\\n        guard let root = root else { return 0 }\\n        var queue: [(TreeNode, Int)] = []\\n        queue.append((root, 1))\\n        var maxLen = 1\\n        while !queue.isEmpty {\\n            let count = queue.count\\n            for _ in 0 ..< count {\\n                let curr = queue.removeFirst() \\n                let index = curr.1\\n                if let left = curr.0.left {\\n                    queue.append((left, index &* 2))\\n                }\\n\\n                if let right = curr.0.right {\\n                    queue.append((right, index &* 2 + 1))\\n                }\\n            }\\n            if !queue.isEmpty {\\n                maxLen = max(maxLen, queue.last!.1 &- queue.first!.1 &+ 1)                \\n            }\\n        }\\n        \\n        return maxLen\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2624349,
                "title": "fastest-solution-with-explain-best-approach-easy-to-understand",
                "content": "**Read the below approach to understand the logic.**\\n\\n***Please upvote if you like it!!!***\\n\\n**Approach :**\\nBasically we have to maintain index value while traversing binary tree. On each node we set index value such that left node is not null then left node index value will be ```(2*(current_index)+1)``` and also right node is not null then right node index value will be ```(2*(current_index)+2)```. At each level we check maximum width of binary tree using this formulla ```first node index value minus last node index value of current level plus one```\\n\\n**Paper Dry Run:**\\n\\n![image](https://assets.leetcode.com/users/images/d2382241-fd1c-49fb-87fb-1842ba2ed365_1664136598.7076073.jpeg)\\n\\n**~Time Complexity: O(N)**\\n* **Reason:** We are doing a simple level order traversal. The inner loop simply traverses the nodes level-wise and doesn\\u2019t add to the complexity.\\n\\n**~Space Complexity: O(N)**\\n\\n**C++ Code:-**\\n```\\nclass Solution {\\npublic:\\n    int widthOfBinaryTree(TreeNode* root) {\\n        long ans=0;\\n        if(!root) return ans;\\n        queue<pair<TreeNode*,int>> q;\\n        q.push({root,0});\\n        while(!q.empty()){\\n            int sz=q.size();\\n            long start=q.front().second;\\n            long end=q.back().second;\\n            ans=max(end-start+1,ans);\\n            while(sz--){\\n                TreeNode* temp=q.front().first;\\n                long idx=q.front().second;\\n                q.pop();\\n                if(temp->left) q.push({temp->left,2*idx+1});\\n                if(temp->right) q.push({temp->right,2*idx+2});\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Queue",
                    "Binary Tree"
                ],
                "code": "```(2*(current_index)+1)```\n```(2*(current_index)+2)```\n```first node index value minus last node index value of current level plus one```\n```\\nclass Solution {\\npublic:\\n    int widthOfBinaryTree(TreeNode* root) {\\n        long ans=0;\\n        if(!root) return ans;\\n        queue<pair<TreeNode*,int>> q;\\n        q.push({root,0});\\n        while(!q.empty()){\\n            int sz=q.size();\\n            long start=q.front().second;\\n            long end=q.back().second;\\n            ans=max(end-start+1,ans);\\n            while(sz--){\\n                TreeNode* temp=q.front().first;\\n                long idx=q.front().second;\\n                q.pop();\\n                if(temp->left) q.push({temp->left,2*idx+1});\\n                if(temp->right) q.push({temp->right,2*idx+2});\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802810,
                "title": "c-8ms-bfs-intuition-o-n",
                "content": "**INTUITION**\\n\\nAccording to the problem description, width of tree is the maximum width among all levels, width of level is the length between non-null end nodes.\\nIt is inductive to apply BFS Level Order Traversal, however, how should we record the leftmost non-null node and the rightmost one?\\nWe may attach position information to each TreeNode, e.g., root in the position of 0.    \\n\\n\\n\\n\\t\\n\\t\\n\\t\\n\\t\\n\\tclass Solution {\\n     public:\\n       int widthOfBinaryTree(TreeNode* root) {\\n        if(!root)\\n            return 0;\\n        int ans=0;\\n        queue<pair<TreeNode* ,int>>q;\\n        q.push({root,0});\\n        while(!q.empty()){\\n            int size=q.size();\\n            int mini=q.front().second;\\n            int first,last;\\n            for(int i=0;i<size;i++){\\n                int id=q.front().second-mini;\\n                TreeNode* node=q.front().first;\\n                q.pop();\\n                if(i==0)\\n                    first=id;\\n                if(i==size-1)\\n                    last=id;\\n                if(node->left)\\n                    q.push({node->left,(long long int)id*2+1});\\n                if(node->right)\\n                    q.push({node->right,(long long int)id*2+2});\\n            }\\n            ans=max(ans,last-first+1);\\n        }\\n        return ans;\\n      }\\n      };",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\n     public:\\n       int widthOfBinaryTree(TreeNode* root) {\\n        if(!root)\\n            return 0;\\n        int ans=0;\\n        queue<pair<TreeNode* ,int>>q;\\n        q.push({root,0}",
                "codeTag": "Java"
            },
            {
                "id": 1360994,
                "title": "easy-bfs-approach-in-c",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    int widthOfBinaryTree(TreeNode* root) \\n    {\\n        if(!root)\\n        {\\n            return 0;\\n        }\\n        queue<pair<TreeNode *,int>>q;\\n        q.push({root,0});\\n        int ans=0;\\n        while(!q.empty())\\n        {\\n            int n=q.size(),x=0,count=n,start=q.front().second;\\n            ans=max(ans,q.back().second-q.front().second+1);\\n            while(n)\\n            {\\n                auto node=q.front();\\n                q.pop();\\n                int index=node.second-start;\\n                if(node.first->left)\\n                {\\n                    q.push({node.first->left,2*index+1});\\n                }\\n                if(node.first->right)\\n                {\\n                    q.push({node.first->right,2*index+2});\\n                }\\n                n--;\\n                x++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n***Please upvote if you have got any help from my code. Thank you.***",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int widthOfBinaryTree(TreeNode* root) \\n    {\\n        if(!root)\\n        {\\n            return 0;\\n        }\\n        queue<pair<TreeNode *,int>>q;\\n        q.push({root,0});\\n        int ans=0;\\n        while(!q.empty())\\n        {\\n            int n=q.size(),x=0,count=n,start=q.front().second;\\n            ans=max(ans,q.back().second-q.front().second+1);\\n            while(n)\\n            {\\n                auto node=q.front();\\n                q.pop();\\n                int index=node.second-start;\\n                if(node.first->left)\\n                {\\n                    q.push({node.first->left,2*index+1});\\n                }\\n                if(node.first->right)\\n                {\\n                    q.push({node.first->right,2*index+2});\\n                }\\n                n--;\\n                x++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 727662,
                "title": "java-bfs-easy-solution-o-n-time-complexity",
                "content": "```\\nclass Solution {\\n    \\n    class node{\\n        \\n        TreeNode data;\\n        int index;\\n        \\n        public node(TreeNode data, int index)\\n        {\\n            this.data = data;\\n            this.index = index;\\n        }\\n    }\\n    \\n    public int widthOfBinaryTree(TreeNode root) {\\n        \\n        if(root == null)\\n            return 0;\\n        \\n        Queue<node> q = new LinkedList<>();\\n        q.add(new node(root, 0));\\n        int min = 0;\\n        int max = 0;\\n        int res = 1;\\n        \\n        while(!q.isEmpty())\\n        {\\n            int size = q.size();\\n    \\n            for(int i = 0; i<size; i++)\\n            {\\n                node temp = q.poll();\\n                \\n                if(i == 0)\\n                    min = temp.index;\\n                \\n                if(i == size-1)\\n                    max = temp.index;\\n                \\n                if(temp!=null && temp.data.left!=null)\\n                    q.add(new node(temp.data.left, 2*temp.index + 1));\\n                \\n                if(temp!=null && temp.data.right!=null)\\n                    q.add(new node(temp.data.right, 2*temp.index + 2));\\n                \\n            }\\n\\t\\t\\t\\n            res = Math.max(res, max - min + 1);\\n        }\\n        \\n        return res;\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\n    \\n    class node{\\n        \\n        TreeNode data;\\n        int index;\\n        \\n        public node(TreeNode data, int index)\\n        {\\n            this.data = data;\\n            this.index = index;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 726881,
                "title": "overflow-maximum-width-of-binary-tree",
                "content": "The first idea come to my mind is using DFS. \\nAnd I stucked (so sad). I try to change the int to unsigned int but it still does not work.\\n#### The depth of the tree > 1000\\nThen I checked the test case and found out the tree has more then 1000 layers!!! \\nEach layer only has 1 node and each node only has one child. Like this\\n```\\n  0\\nx   0\\n   x   0\\n      x    0 \\n\\t\\t  ....>1000 layers\\n```\\n\\nSo the easier way to solve this problem turns out to be BFS.\\nWhen we encouter a layer that has exactly only 1 node, just reset the id of the node to 1.\\n\\n#### BFS\\n```cpp\\nclass Solution {\\npublic:\\n    int widthOfBinaryTree(TreeNode* root) {\\n        queue<pair<TreeNode*, int>> q; //root, id pair\\n        if(root==nullptr) return 0;\\n        q.emplace(root, 1);\\n        int res = 0;\\n        while(!q.empty()){\\n            if(q.size()==1) q.front().second=1; //reset id to 1\\n            int n = q.size(); //need to store the q size here, since we\\n            //will keep pushing element to queue.\\n            int minv = 0;\\n            int maxv = 0;\\n            for(int i = 0; i<n; i++){\\n                TreeNode* node = q.front().first;\\n                int id = q.front().second;\\n                q.pop();\\n                if(i==0) minv=id;\\n                if(i==n-1) {\\n                    maxv=id;\\n                    res = max(maxv-minv+1, res);\\n                }\\n                if(node->left) q.emplace(node->left, id*2);\\n                if(node->right) q.emplace(node->right, id*2+1);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\nThough BFS works, I still wonder\\nIs there any work around that can make DFS valid? \\n",
                "solutionTags": [],
                "code": "```\\n  0\\nx   0\\n   x   0\\n      x    0 \\n\\t\\t  ....>1000 layers\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int widthOfBinaryTree(TreeNode* root) {\\n        queue<pair<TreeNode*, int>> q; //root, id pair\\n        if(root==nullptr) return 0;\\n        q.emplace(root, 1);\\n        int res = 0;\\n        while(!q.empty()){\\n            if(q.size()==1) q.front().second=1; //reset id to 1\\n            int n = q.size(); //need to store the q size here, since we\\n            //will keep pushing element to queue.\\n            int minv = 0;\\n            int maxv = 0;\\n            for(int i = 0; i<n; i++){\\n                TreeNode* node = q.front().first;\\n                int id = q.front().second;\\n                q.pop();\\n                if(i==0) minv=id;\\n                if(i==n-1) {\\n                    maxv=id;\\n                    res = max(maxv-minv+1, res);\\n                }\\n                if(node->left) q.emplace(node->left, id*2);\\n                if(node->right) q.emplace(node->right, id*2+1);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 541471,
                "title": "javascript-simple-bfs-beats-97-level-order-traversal-with-explanation",
                "content": "* Like many fellow leetcoders, I struggled with the test case for a tree with +32 levels, that was getting my position math out of whack. Thanks to other posts, I implemented the solution for that edge case, which is setting the level width to 1 , if only 1 elem at that level.\\n* So, brief explanation:\\n\\t* Do a level-order traversal (which is an off-the-shelf bfs but dequeuing on a sub-loop all nodes enqueued in previous level)\\n\\t* when enqueuing nodes, extend node properties into an object that also includes a computed position\\n\\t* compute a new position, just like you would do on a [min / max heap](https://en.wikipedia.org/wiki/Binary_heap#Heap_implementation) :\\n\\t\\t* left child: parent pos * 2 + 1\\n\\t\\t* right child: parent pos * 2 + 2\\n\\t* when de-queuing nodes, keep track of min and max position for that level\\n\\t* after de-queuing all nodes for that level, compute width based on diff of max and min + 1 (so it is inclusive)\\n\\t* update global max\\n\\n```javascript\\nconst widthOfBinaryTree = (root) => {\\n    const queue = [{ node: root, pos: 0}];\\n    let maxWidth = 0;\\n    \\n    while(queue.length) {\\n        const levelLength = queue.length;\\n\\n        let min = Number.MAX_VALUE,\\n            max = 0;\\n\\n        for(let i = 0; i < levelLength; i++) {\\n            const curr = queue.pop();\\n            min = Math.min(min, curr.pos);\\n            max = Math.max(max, curr.pos);\\n            \\n            if(curr.node.left) queue.unshift({ node: curr.node.left, pos: curr.pos * 2 + 1 });\\n\\n            if(curr.node.right) queue.unshift({node:curr.node.right, pos: curr.pos * 2 + 2 });\\n        }\\n        \\n        const levelWidth = levelLength === 1 ? 1 : max - min + 1;\\n        maxWidth = Math.max(maxWidth, levelWidth);\\n    }\\n    \\n    return maxWidth;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search"
                ],
                "code": "```javascript\\nconst widthOfBinaryTree = (root) => {\\n    const queue = [{ node: root, pos: 0}];\\n    let maxWidth = 0;\\n    \\n    while(queue.length) {\\n        const levelLength = queue.length;\\n\\n        let min = Number.MAX_VALUE,\\n            max = 0;\\n\\n        for(let i = 0; i < levelLength; i++) {\\n            const curr = queue.pop();\\n            min = Math.min(min, curr.pos);\\n            max = Math.max(max, curr.pos);\\n            \\n            if(curr.node.left) queue.unshift({ node: curr.node.left, pos: curr.pos * 2 + 1 });\\n\\n            if(curr.node.right) queue.unshift({node:curr.node.right, pos: curr.pos * 2 + 2 });\\n        }\\n        \\n        const levelWidth = levelLength === 1 ? 1 : max - min + 1;\\n        maxWidth = Math.max(maxWidth, levelWidth);\\n    }\\n    \\n    return maxWidth;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1307834,
                "title": "js-o-n-level-order-traversal-100",
                "content": "Approach: Using Level Order Traversal using the Queue. \\n- Initially add the root and the root index 0 to the queue.\\n- At each level, save the first and last index of the nodes and push the left and right child nodes along with their index. \\nIf the parent node has index `i`, the left child index will be `2 * i + 1` and of right child index will be `2 * i + 2`.\\n- At the end of each level, calculate the width by subtracting the first index from the last index of the level. If the width exceeds the maxWidth, assign that.\\n\\nNote: Substituting the index in this solution since the solution needs to handle values over 32-bit integers. If we don\\'t normalize, the  value is overflowing and the width at the end of those levels is NaN. Basically, just subtracting the initial node index value with each node index, so after subtraction, the width will still be the same and we won\\'t get NaN as a result.\\n\\n```\\nvar widthOfBinaryTree = function(root) {\\n    if(!root) {\\n        return 0;\\n    }\\n    const q = [[root, 0]];\\n    let maxWidth = 0, l = 0, r = 0;\\n    while(q.length) {\\n        const size = q.length;\\n        const startIdx = q[0][1];\\n        for(let i = 0; i < size; ++i) {\\n            const [node, idx] = q.shift();\\n            if(i === 0) {\\n                l = idx;\\n            }\\n            if(i === size - 1) {\\n                r = idx;\\n            }\\n\\t\\t\\tconst subIdx = idx - startIdx;\\n            if(node.left !== null) {\\n                q.push([node.left, 2 * subIdx + 1]);\\n            }\\n            if(node.right !== null) {\\n                q.push([node.right, 2 * subIdx + 2]);\\n            }\\n        }\\n        maxWidth = Math.max(maxWidth, r - l + 1);\\n    }\\n    return maxWidth;\\n};\\n```\\n\\nTime Complexity = O(n) [level order traversal, add each node to queue]\\nSpace Complexity = O(n) [queue]",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search"
                ],
                "code": "```\\nvar widthOfBinaryTree = function(root) {\\n    if(!root) {\\n        return 0;\\n    }\\n    const q = [[root, 0]];\\n    let maxWidth = 0, l = 0, r = 0;\\n    while(q.length) {\\n        const size = q.length;\\n        const startIdx = q[0][1];\\n        for(let i = 0; i < size; ++i) {\\n            const [node, idx] = q.shift();\\n            if(i === 0) {\\n                l = idx;\\n            }\\n            if(i === size - 1) {\\n                r = idx;\\n            }\\n\\t\\t\\tconst subIdx = idx - startIdx;\\n            if(node.left !== null) {\\n                q.push([node.left, 2 * subIdx + 1]);\\n            }\\n            if(node.right !== null) {\\n                q.push([node.right, 2 * subIdx + 2]);\\n            }\\n        }\\n        maxWidth = Math.max(maxWidth, r - l + 1);\\n    }\\n    return maxWidth;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 726700,
                "title": "python-recursion-explained-98",
                "content": "```\\nclass Solution:\\n    def widthOfBinaryTree(self, root: TreeNode) -> int:\\n        self.d = [[]]\\n        def f(l,p,r):\\n            if r:\\n                if len(self.d)<=l:\\n                    self.d.append([p])\\n                else:\\n                    self.d[l].append(p)\\n                f(l+1,2*p,r.left)\\n                f(l+1,2*p+1,r.right)\\n        f(0,0,root)\\n        return max(max(d) - min(d) + 1 for d in self.d )\\n```\\n\\nThe idea is simple - we traverse tree using recursive function `f()`. it takes 3 arguments:\\n```\\nl - level\\np - position\\nr - root of the current sub-tree\\n```\\nAs it traverses the tree, it populates `self.d[]`, it looks like:\\n```\\n[[0],[0,1],[0,2,3]]\\n```\\nWhere `self.d[i]` lists all taken positions at level `i`.\\n\\nNow we just need to calculate `max - min + 1` for each level and return the highest value.\\n\\nHere is a slight variation. Instead of storing all positions for each level, we just keep track of the highest and lowest:\\n\\n```\\nclass Solution:\\n    def widthOfBinaryTree(self, root: TreeNode) -> int:\\n        self.d = [[0,0]]\\n        def f(l,p,r):\\n            if r:\\n                if len(self.d)<=l:\\n                    self.d.append([p,p])\\n                else:\\n                    self.d[l]=[min(self.d[l][0],p),max(self.d[l][1],p)]\\n                f(l+1,2*p,r.left)\\n                f(l+1,2*p+1,r.right)\\n        f(0,0,root)\\n        return max(d[1] - d[0] + 1 for d in self.d )\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def widthOfBinaryTree(self, root: TreeNode) -> int:\\n        self.d = [[]]\\n        def f(l,p,r):\\n            if r:\\n                if len(self.d)<=l:\\n                    self.d.append([p])\\n                else:\\n                    self.d[l].append(p)\\n                f(l+1,2*p,r.left)\\n                f(l+1,2*p+1,r.right)\\n        f(0,0,root)\\n        return max(max(d) - min(d) + 1 for d in self.d )\\n```\n```\\nl - level\\np - position\\nr - root of the current sub-tree\\n```\n```\\n[[0],[0,1],[0,2,3]]\\n```\n```\\nclass Solution:\\n    def widthOfBinaryTree(self, root: TreeNode) -> int:\\n        self.d = [[0,0]]\\n        def f(l,p,r):\\n            if r:\\n                if len(self.d)<=l:\\n                    self.d.append([p,p])\\n                else:\\n                    self.d[l]=[min(self.d[l][0],p),max(self.d[l][1],p)]\\n                f(l+1,2*p,r.left)\\n                f(l+1,2*p+1,r.right)\\n        f(0,0,root)\\n        return max(d[1] - d[0] + 1 for d in self.d )\\n```",
                "codeTag": "Java"
            },
            {
                "id": 482151,
                "title": "python-bfs-easy-to-understand-with-comments",
                "content": "\\n\\n```python\\n\\'\\'\\'\\nFor node at i\\'th position position of node.left will be 2*i \\nand  node.right will be 2*i + 1. We traverse through the tree\\nand assign position to nodes. Width of a level is difference of \\npositions between the leftmost and rightmost nodes in that level.\\n\\'\\'\\'\\n    def widthOfBinaryTree(self, root: TreeNode) -> int:\\n        if not root: return 0\\n        q = [(root, 1)]\\n        ans = 1  # because cases like [1], [1,3] etc. has width 1\\n        while q:            \\n\\t\\t# first element in q is leftmost element in that level and\\n\\t\\t# last element is rightmost element\\n\\t\\t# the difference in their position is the width of that level\\n            if len(q) >= 2:\\n                ans = max(q[-1][1] - q[0][1] + 1, ans)\\n            new_q = []          # this stores nodes for next level  \\n            while q:\\n                node, pos = q.pop(0)                      \\n                if node.left: new_q.append((node.left, 2*pos))\\n                if node.right: new_q.append((node.right, 2*pos + 1))            \\n            q = new_q\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```python\\n\\'\\'\\'\\nFor node at i\\'th position position of node.left will be 2*i \\nand  node.right will be 2*i + 1. We traverse through the tree\\nand assign position to nodes. Width of a level is difference of \\npositions between the leftmost and rightmost nodes in that level.\\n\\'\\'\\'\\n    def widthOfBinaryTree(self, root: TreeNode) -> int:\\n        if not root: return 0\\n        q = [(root, 1)]\\n        ans = 1  # because cases like [1], [1,3] etc. has width 1\\n        while q:            \\n\\t\\t# first element in q is leftmost element in that level and\\n\\t\\t# last element is rightmost element\\n\\t\\t# the difference in their position is the width of that level\\n            if len(q) >= 2:\\n                ans = max(q[-1][1] - q[0][1] + 1, ans)\\n            new_q = []          # this stores nodes for next level  \\n            while q:\\n                node, pos = q.pop(0)                      \\n                if node.left: new_q.append((node.left, 2*pos))\\n                if node.right: new_q.append((node.right, 2*pos + 1))            \\n            q = new_q\\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 387039,
                "title": "simply-simple-python-solution-level-order-traversal",
                "content": "\\tdef widthOfBinaryTree(self, root: TreeNode) -> int:\\n        if not root:\\n            return 0\\n        # Treat tree as Heap array and save idx as 2*i and 2*i + 1\\n        # diff of first and last node when level ends is the result\\n        \\n        q = [(root, 1)]\\n        \\n        res = 1\\n        lastNode = root\\n        while len(q) > 0:\\n            node, idx = q.pop(0)\\n            \\n            if node.left:\\n                q.append((node.left, idx * 2))\\n            if node.right:\\n                q.append((node.right, idx * 2 + 1))\\n        \\n            if node == lastNode:\\n                if len(q) > 0:\\n                    res = max(res, q[-1][1] - q[0][1] + 1)\\n                    lastNode = q[-1][0]\\n                    \\n        return res",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\tdef widthOfBinaryTree(self, root: TreeNode) -> int:\\n        if not root:\\n            return 0\\n        # Treat tree as Heap array and save idx as 2*i and 2*i + 1\\n        # diff of first and last node when level ends is the result\\n        \\n        q = [(root, 1)]\\n        \\n        res = 1\\n        lastNode = root\\n        while len(q) > 0:\\n            node, idx = q.pop(0)\\n            \\n            if node.left:\\n                q.append((node.left, idx * 2))\\n            if node.right:\\n                q.append((node.right, idx * 2 + 1))\\n        \\n            if node == lastNode:\\n                if len(q) > 0:\\n                    res = max(res, q[-1][1] - q[0][1] + 1)\\n                    lastNode = q[-1][0]\\n                    \\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 4069531,
                "title": "2method-c-java-python-javascript",
                "content": "\\uD83D\\uDCAF\\uD83D\\uDD25 C++ | Java || Python || JavaScript \\uD83D\\uDCAF\\uD83D\\uDD25\\nRead Whole article :https://www.nileshblog.tech/662-maximum-width-of-binary-tree/\\n\\nExplanation Eg.\\nTime Complexity:\\n\\nLevel Order (BFS)\\n\\nPre Order (DFS )\\nPython :\\nJava:\\nc++:\\nJavaScript:\\n\\nRead Whole article :https://www.nileshblog.tech/662-maximum-width-of-binary-tree/",
                "solutionTags": [
                    "Java",
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "\\uD83D\\uDCAF\\uD83D\\uDD25 C++ | Java || Python || JavaScript \\uD83D\\uDCAF\\uD83D\\uDD25\\nRead Whole article :https://www.nileshblog.tech/662-maximum-width-of-binary-tree/\\n\\nExplanation Eg.\\nTime Complexity:\\n\\nLevel Order (BFS)\\n\\nPre Order (DFS )\\nPython :\\nJava:\\nc++:\\nJavaScript:\\n\\nRead Whole article :https://www.nileshblog.tech/662-maximum-width-of-binary-tree/",
                "codeTag": "Unknown"
            },
            {
                "id": 3436959,
                "title": "python-solution-with-diagrams-and-explanation",
                "content": "# Intuition\\nInstead of keeping track of distance between each node.\\nKeep track of \"what could be the possible index\"\\n\\nFor example \\nIf we look at the example tree\\n![image.png](https://assets.leetcode.com/users/images/dc27cc63-bffb-493e-93d6-2aeb2952f049_1681966705.9880064.png)\\n\\nWe could fill out our indexes as such \\n![image.png](https://assets.leetcode.com/users/images/bae86a5d-ce4a-403f-87c8-94b2e0bea431_1681966743.2774932.png)\\n\\nNotice how relation between a node\\'s index and it\\'s left child index is (2 node\\'s index) and it\\'s right child is (2 X node+1).\\nFor example at `node=9` which is at `index=3`. So it\\'s left child is at `index=3*2` for `node=7` and its possible right child would be at `index=(3*2)+1`\\nLet\\'s see how we can use this to our advantage.\\n\\n# Approach\\nStore the left and right index in a dictionary of 2 elements `dic` and a `self.max_diff` to keep track of maximum diff in a level.\\n\\nAt every level we update the level\\'s maximum and minimum index and set our `self.max_diff` accordingly\\n```\\ndic.setdefault(level, [index, index])\\ndic[level][0] = min(dic[level][0], index)\\ndic[level][1] = max(dic[level][1], index)\\nself.max_diff = max(self.max_diff, dic[level][1] - dic[level][0])\\n```\\nWe are using index at `0` to keep our minimum index and `1` to keep our maximum index.\\n\\nEverytime we traverse left we take our node\\'s current index, and multiply it by 2.\\n```\\ntraversal(root.left, 2*index, level+1, dic)\\n```\\nEverytime we traverse right we take the node\\'s current index, multiply it by 2 and add 1 (Check initution section)\\n```\\ntraversal(root.right, 2*index+1, level+1, dic)\\n```\\n\\nSimply start the call by passing the original root, index as `0` and level as `0`.\\n```\\ntraversal(root, 0, 0, dic)\\n```\\n\\nIn the end return \\n```\\nreturn self.max_diff+1\\n```\\nWhy the +1? Since we need to also include the node in our distance calculation.\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n) Since we need to take into account every node.\\nNote: It might be intuitive to think that just traversing the left and right boundary is enough. However that doesn\\'t seem to be the case, as a larger subtree can be found from one of the middle nodes of the tree.\\n\\n- Space complexity:\\nO(log n) Since our dictionary size is same as level size.\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def widthOfBinaryTree(self, root: Optional[TreeNode]) -> int:\\n        dic = {}\\n        self.max_diff = 0\\n        def traversal(root, index, level, dic):\\n            if root is None:\\n                return \\n            dic.setdefault(level, [index, index])\\n            dic[level][0] = min(dic[level][0], index)\\n            dic[level][1] = max(dic[level][1], index)\\n            self.max_diff = max(self.max_diff, dic[level][1] - dic[level][0])\\n\\n            traversal(root.left, 2*index, level+1, dic)\\n            traversal(root.right, 2*index+1, level+1, dic)\\n        traversal(root, 0, 0, dic)\\n        return self.max_diff+1\\n```",
                "solutionTags": [
                    "Python3",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\ndic.setdefault(level, [index, index])\\ndic[level][0] = min(dic[level][0], index)\\ndic[level][1] = max(dic[level][1], index)\\nself.max_diff = max(self.max_diff, dic[level][1] - dic[level][0])\\n```\n```\\ntraversal(root.left, 2*index, level+1, dic)\\n```\n```\\ntraversal(root.right, 2*index+1, level+1, dic)\\n```\n```\\ntraversal(root, 0, 0, dic)\\n```\n```\\nreturn self.max_diff+1\\n```\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def widthOfBinaryTree(self, root: Optional[TreeNode]) -> int:\\n        dic = {}\\n        self.max_diff = 0\\n        def traversal(root, index, level, dic):\\n            if root is None:\\n                return \\n            dic.setdefault(level, [index, index])\\n            dic[level][0] = min(dic[level][0], index)\\n            dic[level][1] = max(dic[level][1], index)\\n            self.max_diff = max(self.max_diff, dic[level][1] - dic[level][0])\\n\\n            traversal(root.left, 2*index, level+1, dic)\\n            traversal(root.right, 2*index+1, level+1, dic)\\n        traversal(root, 0, 0, dic)\\n        return self.max_diff+1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1803137,
                "title": "js-bfs-commented-overflow-fixed-bigint",
                "content": "```\\nvar widthOfBinaryTree = function (root) {\\n\\t// If no root return 0\\n\\tif (!root) return 0;\\n\\t// 0n denotes a bigint number i.e n after any number makes it bigint\\n\\tlet maxWidth = 0n;\\n\\tconst queue = [];\\n\\t// we will store nodes along with their positions. Starting with root node from 0n (bigint 0)\\n\\tqueue.push([root, 0n]);\\n\\t// While we have elements in our queue we will iterate (bfs)\\n\\twhile (queue.length) {\\n\\t\\tconst len = queue.length;\\n\\t\\tlet node, //Node at current position\\n\\t\\t\\tpos = 0n, //position of the respective node\\n\\t\\t\\tfirst = 0n; //first node will be at 0th position\\n\\t\\tfor (let i = 0; i < len; i++) {\\n\\t\\t\\t[node, pos] = queue.shift();\\n\\t\\t\\t// first will always be the 1st node at current level in bfs\\n\\t\\t\\tif (i === 0) first = pos;\\n\\t\\t\\t// If node has left child then we push it in queue and child\\'s position will be current node position * 2 (n denotes bigint)\\n\\t\\t\\tif (node.left) queue.push([node.left, pos * 2n]);\\n\\t\\t\\t// If node has right child then we push it in queue and child\\'s position will be current node position * 2 + 1 (n denotes bigint)\\n\\t\\t\\tif (node.right) queue.push([node.right, pos * 2n + 1n]);\\n\\t\\t}\\n\\t\\t// At last number of nodes (width) will be pos i.e last node index - first node index + 1 (n denotes big int)\\n\\t\\tconst currWidth = pos - first + 1n;\\n\\t\\t// Math.max cannot be used with big int so we calculate maximum value as below\\n\\t\\tmaxWidth = maxWidth > currWidth ? maxWidth : currWidth;\\n\\t}\\n\\n\\treturn maxWidth;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search"
                ],
                "code": "```\\nvar widthOfBinaryTree = function (root) {\\n\\t// If no root return 0\\n\\tif (!root) return 0;\\n\\t// 0n denotes a bigint number i.e n after any number makes it bigint\\n\\tlet maxWidth = 0n;\\n\\tconst queue = [];\\n\\t// we will store nodes along with their positions. Starting with root node from 0n (bigint 0)\\n\\tqueue.push([root, 0n]);\\n\\t// While we have elements in our queue we will iterate (bfs)\\n\\twhile (queue.length) {\\n\\t\\tconst len = queue.length;\\n\\t\\tlet node, //Node at current position\\n\\t\\t\\tpos = 0n, //position of the respective node\\n\\t\\t\\tfirst = 0n; //first node will be at 0th position\\n\\t\\tfor (let i = 0; i < len; i++) {\\n\\t\\t\\t[node, pos] = queue.shift();\\n\\t\\t\\t// first will always be the 1st node at current level in bfs\\n\\t\\t\\tif (i === 0) first = pos;\\n\\t\\t\\t// If node has left child then we push it in queue and child\\'s position will be current node position * 2 (n denotes bigint)\\n\\t\\t\\tif (node.left) queue.push([node.left, pos * 2n]);\\n\\t\\t\\t// If node has right child then we push it in queue and child\\'s position will be current node position * 2 + 1 (n denotes bigint)\\n\\t\\t\\tif (node.right) queue.push([node.right, pos * 2n + 1n]);\\n\\t\\t}\\n\\t\\t// At last number of nodes (width) will be pos i.e last node index - first node index + 1 (n denotes big int)\\n\\t\\tconst currWidth = pos - first + 1n;\\n\\t\\t// Math.max cannot be used with big int so we calculate maximum value as below\\n\\t\\tmaxWidth = maxWidth > currWidth ? maxWidth : currWidth;\\n\\t}\\n\\n\\treturn maxWidth;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1748049,
                "title": "c-solution-dfs-maximum-width-of-binary-tree",
                "content": "\\nclass Solution {\\npublic:\\n    \\n    unsigned long long ans = 1;\\n    \\n    void solve(TreeNode* root,vector<unsigned long long > &v,int l,unsigned long long p){\\n        \\n        if(root == NULL){\\n            return;\\n        }\\n        \\n        if(v[l] == -1){\\n            v[l] = p;\\n        }\\n        \\n        ans = max(ans,p-v[l]+1);\\n     \\n        \\n        solve(root->left,v,l+1,2*p);\\n        solve(root->right,v,l+1,2*p+1);\\n    }\\n    int widthOfBinaryTree(TreeNode* root) {\\n        if(root == NULL){\\n            return 0;\\n        }\\n        \\n        vector<unsigned long long> v(3000,-1);\\n        solve(root,v,0,1);\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    unsigned long long ans = 1;\\n    \\n    void solve(TreeNode* root,vector<unsigned long long > &v,int l,unsigned long long p){\\n        \\n        if(root == NULL){\\n            return;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1184525,
                "title": "c-bfs-with-int-only",
                "content": "[Code Credits](https://leetcode.com/qianying_1996/)\\n \\n##  Approach :- In Heap data structure which is also a Complete Binary Tree can be represented as in the form of array where if root will be presented at index `i` then it\\'s left child may be present at `2*i+1` and it\\'s right child may be present at `2*i+2`.\\n \\n Generally, We want maximum nodes at a particular level in the given tree but by including `NULL` nodes too.\\n We can change the id of the first node of each level to 0. Since the ans will not exceed 2^31, so int is ok.\\n \\n```\\nclass Solution {\\npublic:\\n    int widthOfBinaryTree(TreeNode* root) {\\n        if(!root)\\n            return 0;\\n        \\n        int ans = 0;\\n        queue<pair<TreeNode*, int>> q;\\n        q.push({root,0});\\n\\n        while(!q.empty()){\\n            int size = q.size();\\n            int mmin = q.front().second;    //to make the id starting from zero\\n            int last;\\n\\n            for(int i=0; i<size; i++){\\n            \\t\\n                int cur_id = q.front().second-mmin;  // this is to maintain int range bound\\n                TreeNode* node = q.front().first;\\n                q.pop();\\n\\n                if(i==size-1)\\n                    last = cur_id;\\n\\n                if(node->left)\\n                    q.push({node->left, cur_id*2+1});\\n                if(node->right)\\n                    q.push({node->right, cur_id*2+2});\\n            }\\n\\n            ans = max(ans, last+1);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Here, last will contain the last index till the nodes were accompanied at recent/last level we have processed.**\\n\\n***P.S.:- You can also fetch last from queue.back() and accordingly, find the same what we are doing above. I haven\\'t done due to reading/understanding credibility.***\\n\\n*Kindly **UpVote** this article, if it\\'s helps you a bit in understanding..*",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int widthOfBinaryTree(TreeNode* root) {\\n        if(!root)\\n            return 0;\\n        \\n        int ans = 0;\\n        queue<pair<TreeNode*, int>> q;\\n        q.push({root,0});\\n\\n        while(!q.empty()){\\n            int size = q.size();\\n            int mmin = q.front().second;    //to make the id starting from zero\\n            int last;\\n\\n            for(int i=0; i<size; i++){\\n            \\t\\n                int cur_id = q.front().second-mmin;  // this is to maintain int range bound\\n                TreeNode* node = q.front().first;\\n                q.pop();\\n\\n                if(i==size-1)\\n                    last = cur_id;\\n\\n                if(node->left)\\n                    q.push({node->left, cur_id*2+1});\\n                if(node->right)\\n                    q.push({node->right, cur_id*2+2});\\n            }\\n\\n            ans = max(ans, last+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 855439,
                "title": "c-intuitive-bfs-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int widthOfBinaryTree(TreeNode* root) {\\n    \\tsize_t ans = 1;\\n    \\tif(root){\\n    \\t\\tqueue<pair<TreeNode*, size_t>> q;\\n    \\t\\tq.push({root, 0});\\n    \\t\\t\\n    \\t\\twhile(!q.empty()){\\n\\t\\t\\t\\tans = max(ans, q.back().second-q.front().second+1);\\n    \\t\\t\\tint size = q.size();\\n    \\t\\t\\tfor(int i = 0; i<size; i++){\\n    \\t\\t\\t\\tTreeNode* current = q.front().first;\\n    \\t\\t\\t\\tsize_t curInd = q.front().second;\\n    \\t\\t\\t\\tq.pop();\\n    \\t\\t\\t\\tif(current->left){\\n    \\t\\t\\t\\t\\tq.push({current->left, curInd*2});\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t\\tif(current->right){\\n    \\t\\t\\t\\t\\tq.push({current->right, curInd*2+1});\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t}\\n    \\treturn (int)ans;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int widthOfBinaryTree(TreeNode* root) {\\n    \\tsize_t ans = 1;\\n    \\tif(root){\\n    \\t\\tqueue<pair<TreeNode*, size_t>> q;\\n    \\t\\tq.push({root, 0});\\n    \\t\\t\\n    \\t\\twhile(!q.empty()){\\n\\t\\t\\t\\tans = max(ans, q.back().second-q.front().second+1);\\n    \\t\\t\\tint size = q.size();\\n    \\t\\t\\tfor(int i = 0; i<size; i++){\\n    \\t\\t\\t\\tTreeNode* current = q.front().first;\\n    \\t\\t\\t\\tsize_t curInd = q.front().second;\\n    \\t\\t\\t\\tq.pop();\\n    \\t\\t\\t\\tif(current->left){\\n    \\t\\t\\t\\t\\tq.push({current->left, curInd*2});\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t\\tif(current->right){\\n    \\t\\t\\t\\t\\tq.push({current->right, curInd*2+1});\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t}\\n    \\treturn (int)ans;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 726856,
                "title": "c-complete-explanation-using-map-and-recursion",
                "content": "In this problem we are required to find the left most node(not null) and right most node(not null) position in a particular level, then width of that level is obtained by [right-left+1], we can do this for each and every level in the tree and keep track of max Width among all the levels in tree. Performing this thing we need to perform bfs on the tree using queue,(but using bfs approach I am able to pass only 105/108 test cases rest giving tle in c++).(Maybe I was wrong somewhere).\\n\\nThus we move onto next approach, we will assign each node in the tree with position value, for a given level left most node is assigned a value of 1 and remaining node in same level is assigned value of 1 greater than the previous node in same level i.e(for level 2 nodes are assigned value of 4,5,6,7).\\nThen we create a map with key as level in the tree and value as pair<int,int> holding the position of left most and right most not null node in a level. After performing the recursion and filling up data for all level in map we iterate over the map and find width of each level and return maximum among them.\\n***HOW TO ASSIGN POSITION***\\nSuppose you are standing at a node having position value of x, then the left child of this node(in next level) has position value of 2*x and its right child has a position value of (2*x + 1). You can figure this out by drawing a tree.\\n```\\ntypedef unsigned long long int ull;\\n\\nvoid fillDataLevelWise(TreeNode* root,unordered_map<int,pair<int,int>>& mp,ull currLevel,ull position){\\n    \\n    if(!root)   return ;\\n    \\n    if(mp.find(currLevel) == mp.end()){\\n        mp[currLevel] = make_pair(position,position);\\n    }else{\\n        pair<int,int> p = mp[currLevel];\\n        if(p.first > position)  p.first = position;\\n        if(p.second < position) p.second = position;\\n        mp[currLevel] = p;    \\n    }\\n    \\n    fillDataLevelWise(root->left,mp,currLevel+1,2*position);\\n    fillDataLevelWise(root->right,mp,currLevel+1,2*position + 1);\\n}\\n\\nclass Solution {\\npublic:\\n    int widthOfBinaryTree(TreeNode* root) {\\n        //completely different solution and approach as I wass thinking about it\\n        //requires use of map also mapping along with the depth\\n        if(!root)   return 0;\\n        unordered_map<int,pair<int,int>> mp;\\n        fillDataLevelWise(root,mp,0,1);\\n        \\n        unordered_map<int,pair<int,int>>::iterator it;\\n        \\n        int maxWidth = 0;\\n        \\n        for(it=mp.begin();it!=mp.end();it++){\\n            \\n            int left = it->second.first;\\n            int right = it->second.second;\\n            int t = right-left+1;\\n            maxWidth = max(t,maxWidth);\\n            \\n        }\\n        \\n        return maxWidth;\\n    }\\n};\\n```\\nTime Complexity O(nodes), since you visit each node exactly once\\nSpace Complexity O(nodes)\\n***UPVOTE IF IT HELPS***",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\ntypedef unsigned long long int ull;\\n\\nvoid fillDataLevelWise(TreeNode* root,unordered_map<int,pair<int,int>>& mp,ull currLevel,ull position){\\n    \\n    if(!root)   return ;\\n    \\n    if(mp.find(currLevel) == mp.end()){\\n        mp[currLevel] = make_pair(position,position);\\n    }else{\\n        pair<int,int> p = mp[currLevel];\\n        if(p.first > position)  p.first = position;\\n        if(p.second < position) p.second = position;\\n        mp[currLevel] = p;    \\n    }\\n    \\n    fillDataLevelWise(root->left,mp,currLevel+1,2*position);\\n    fillDataLevelWise(root->right,mp,currLevel+1,2*position + 1);\\n}\\n\\nclass Solution {\\npublic:\\n    int widthOfBinaryTree(TreeNode* root) {\\n        //completely different solution and approach as I wass thinking about it\\n        //requires use of map also mapping along with the depth\\n        if(!root)   return 0;\\n        unordered_map<int,pair<int,int>> mp;\\n        fillDataLevelWise(root,mp,0,1);\\n        \\n        unordered_map<int,pair<int,int>>::iterator it;\\n        \\n        int maxWidth = 0;\\n        \\n        for(it=mp.begin();it!=mp.end();it++){\\n            \\n            int left = it->second.first;\\n            int right = it->second.second;\\n            int t = right-left+1;\\n            maxWidth = max(t,maxWidth);\\n            \\n        }\\n        \\n        return maxWidth;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 545941,
                "title": "simplest-ever-c-solution",
                "content": "```\\nint widthOfBinaryTree(TreeNode* root) {\\n        if(!root) return 0;\\n        queue<pair<TreeNode*,int>> q;\\n        q.push({root,1});\\n        int ans = 0;\\n        while(!q.empty())\\n        {\\n            int size = q.size();\\n            ans = max(ans,q.back().second-q.front().second+1);\\n            while(size--)\\n            {\\n                auto front = q.front();\\n                q.pop();\\n                if(front.first->left)\\n                    q.push({front.first->left,2LL*front.second});\\n                if(front.first->right)\\n                     q.push({front.first->right,2LL*front.second+1});\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nint widthOfBinaryTree(TreeNode* root) {\\n        if(!root) return 0;\\n        queue<pair<TreeNode*,int>> q;\\n        q.push({root,1});\\n        int ans = 0;\\n        while(!q.empty())\\n        {\\n            int size = q.size();\\n            ans = max(ans,q.back().second-q.front().second+1);\\n            while(size--)\\n            {\\n                auto front = q.front();\\n                q.pop();\\n                if(front.first->left)\\n                    q.push({front.first->left,2LL*front.second});\\n                if(front.first->right)\\n                     q.push({front.first->right,2LL*front.second+1});\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 154200,
                "title": "javascript-dfs-solution",
                "content": "```js\\nfunction widthOfBinaryTree(root) {\\n  const mins = [0];\\n  let max = 0;\\n  \\n  dfs(root, 0, 0);\\n  return max;\\n  \\n  function dfs(v, lvl, pos) {\\n    if (!v) return;\\n    if (lvl === mins.length) {\\n      mins[lvl] = pos;\\n    }\\n    \\n    const delta = pos-mins[lvl];\\n    max = Math.max(max, delta+1);\\n    dfs(v.left, lvl+1, delta*2);\\n    dfs(v.right, lvl+1, delta*2+1);\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```js\\nfunction widthOfBinaryTree(root) {\\n  const mins = [0];\\n  let max = 0;\\n  \\n  dfs(root, 0, 0);\\n  return max;\\n  \\n  function dfs(v, lvl, pos) {\\n    if (!v) return;\\n    if (lvl === mins.length) {\\n      mins[lvl] = pos;\\n    }\\n    \\n    const delta = pos-mins[lvl];\\n    max = Math.max(max, delta+1);\\n    dfs(v.left, lvl+1, delta*2);\\n    dfs(v.right, lvl+1, delta*2+1);\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 106666,
                "title": "my-accepted-java-solution-using-deque",
                "content": "```\\npublic int widthOfBinaryTree(TreeNode root) {\\n        if(root==null)\\n            return 0;\\n        Deque<TreeNode> q=new LinkedList<>();\\n        q.add(root);\\n        int max=0;\\n        while(!q.isEmpty()){\\n            int count=0;\\n            max=Math.max(max,q.size());\\n            int size=q.size();\\n            while(count<size){\\n                TreeNode node=q.poll();\\n                if(node==null){\\n                    q.add(null);q.add(null);\\n                }else{\\n                    q.add(node.left);q.add(node.right);\\n                }\\n                count++;\\n            }\\n            while(!q.isEmpty()&&q.peekFirst()==null)\\n                q.pollFirst();\\n            while(!q.isEmpty()&&q.peekLast()==null)\\n                q.pollLast();\\n        }\\n        return max;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int widthOfBinaryTree(TreeNode root) {\\n        if(root==null)\\n            return 0;\\n        Deque<TreeNode> q=new LinkedList<>();\\n        q.add(root);\\n        int max=0;\\n        while(!q.isEmpty()){\\n            int count=0;\\n            max=Math.max(max,q.size());\\n            int size=q.size();\\n            while(count<size){\\n                TreeNode node=q.poll();\\n                if(node==null){\\n                    q.add(null);q.add(null);\\n                }else{\\n                    q.add(node.left);q.add(node.right);\\n                }\\n                count++;\\n            }\\n            while(!q.isEmpty()&&q.peekFirst()==null)\\n                q.pollFirst();\\n            while(!q.isEmpty()&&q.peekLast()==null)\\n                q.pollLast();\\n        }\\n        return max;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3437541,
                "title": "python3-bfs-easy-solution-clearly-explained",
                "content": "This solution uses a **breadth-first search (BFS)** approach to traverse the binary tree level by level and compute the maximum width of the tree.\\n* First, a **deque** is initialized with the root node and its corresponding position (index = **1**) in the binary tree. The maximum width is set to 0 initially.\\n* The while loop runs as long as there are nodes in the deque. At each iteration, the leftmost and rightmost nodes in the current level of the binary tree are identified by comparing the position of the first node and the last node in the deque. **If the positions are different**, it means that *there are nodes in between the leftmost and rightmost* nodes, so the maximum width is updated accordingly.\\n* Next, for each node in the current level, its left and right child nodes (if they exist) are added to the deque along with their corresponding positions. The position of a child node is determined by **multiplying** the position of its parent node **by 2 and subtracting 1** for the **left** child or **adding 1** for the *right* child. This ensures that the position of a node\\'s left child is always **odd** and the position of its right child is always **even**.\\n* Finally, the maximum width of the binary tree is returned. If there is only one node in the tree, the width is 1 by definition.\\n\\n```\\nclass Solution:\\n    def widthOfBinaryTree(self, root: Optional[TreeNode]) -> int:\\n        deq = collections.deque([(root, 1)])\\n        max_w = 0\\n        \\n        while deq:\\n\\t\\t    # update max_width if there are more then one element on the current level\\n            if deq[0][1] != deq[-1][1]:\\n                max_w = max(max_w, (1 + deq[-1][1] - deq[0][1]))\\n            for i in range(len(deq)):\\n                node, cur = deq.popleft() # pop current node and current position on the level of a tree \\n                if node.left: \\n                    deq.append((node.left, cur * 2 - 1))   # left node always odd\\n                if node.right: \\n                    deq.append((node.right, cur * 2))   # right node always even\\n                    \\n        return max(1, max_w)\\n```\\n**P.S.**\\nIf you found something useful in the post, please upvote.\\nGood luck!",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def widthOfBinaryTree(self, root: Optional[TreeNode]) -> int:\\n        deq = collections.deque([(root, 1)])\\n        max_w = 0\\n        \\n        while deq:\\n\\t\\t    # update max_width if there are more then one element on the current level\\n            if deq[0][1] != deq[-1][1]:\\n                max_w = max(max_w, (1 + deq[-1][1] - deq[0][1]))\\n            for i in range(len(deq)):\\n                node, cur = deq.popleft() # pop current node and current position on the level of a tree \\n                if node.left: \\n                    deq.append((node.left, cur * 2 - 1))   # left node always odd\\n                if node.right: \\n                    deq.append((node.right, cur * 2))   # right node always even\\n                    \\n        return max(1, max_w)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1804230,
                "title": "c-bfs-resolving-overflow-using-modulo",
                "content": "One easy way of easily calculating the width of the binary tree at each level is to assign an \\'index\\' to each node in the tree. This can be achieved easily by letting the root node\\'s index be ``1``, the left child node\\'s index be ``2x``, and the right child node\\'s index be ``2x+1``, where ``x`` is the parent node\\'s index, as follows:\\n\\n![image](https://assets.leetcode.com/users/images/84a1287b-9eb3-4f59-8851-8e620f309766_1645971262.8060641.png)\\n\\nBy traversing the binary tree using BFS (and ignoring any child nodes which are NULL), the width of each layer can be easily computed as the difference between the index of the left-most node in the layer and the index of the right-most node in the layer (which are the first and last elements in the queue).\\n\\nHowever, this method runs into the issue of having integer overflows when the binary tree is very deep, e.g.\\n![image](https://assets.leetcode.com/users/images/57d88d6f-b2c2-49af-9bc5-8e79bb1a54f9_1645971667.1523497.png)\\n(Image is truncated as the tree is _very_ deep)\\n\\nThe overflow issues occur as the index of each node is 2 times (or 2 times plus 1) its parent node\\'s index. It is important to note, however, that the challange guarantees:\\n> the answer will in the range of 32-bit signed integer.\\n\\nIn other words, this means that the index difference will never exceed a 32-bit signed integer.\\n\\nCompared to other solutions that use arbritrary precision integers or conditionals to prevent the indices from overflowing, I found out that modulo can also be used to resolve overflow:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int widthOfBinaryTree(TreeNode* root) {\\n        if(root == NULL) return 0;\\n        queue<pair<TreeNode*, long>> q;\\n        q.push({root, 1});\\n        long ans = 0, MOD = 2147483649; //MOD = 2^31 + 1\\n        \\n        while(!q.empty()){\\n            int sz = q.size();\\n            ans = max(ans, q.back().second - q.front().second + 1);\\n            \\n            while(sz > 0){\\n                auto node = q.front().first;\\n                auto idx = q.front().second;\\n                q.pop();\\n                if(node->left != NULL) q.push({node->left, (2*idx) % MOD});\\n                if(node->right != NULL) q.push({node->right, (2*idx+1) % MOD});\\n                sz--;\\n            }\\n        }\\n        \\n        return (int)ans;\\n    }\\n};\\n```\\n\\nNote: The data type ``long`` is used purely for the sake of not having to perform type conversions when calculating the nodes\\' indices.\\n\\nThis solution beats 85.32% of C++ solutions for runtime, and 79.50% of C++ solutions for memory as of writing this post.\\n\\nUsing modulo works as the goal is to calculate the index difference within the same layer, there will not be issues with the right-most node having an index greater than the left-most node (for instance).",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int widthOfBinaryTree(TreeNode* root) {\\n        if(root == NULL) return 0;\\n        queue<pair<TreeNode*, long>> q;\\n        q.push({root, 1});\\n        long ans = 0, MOD = 2147483649; //MOD = 2^31 + 1\\n        \\n        while(!q.empty()){\\n            int sz = q.size();\\n            ans = max(ans, q.back().second - q.front().second + 1);\\n            \\n            while(sz > 0){\\n                auto node = q.front().first;\\n                auto idx = q.front().second;\\n                q.pop();\\n                if(node->left != NULL) q.push({node->left, (2*idx) % MOD});\\n                if(node->right != NULL) q.push({node->right, (2*idx+1) % MOD});\\n                sz--;\\n            }\\n        }\\n        \\n        return (int)ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802246,
                "title": "java-bfs-solution",
                "content": "```\\nclass Solution {\\n    public int widthOfBinaryTree(TreeNode root) {\\n        Deque<TreeNode> queue=new ArrayDeque<>();\\n        root.val=0;\\n        queue.add(root);\\n        return bfs(queue);\\n    }\\n    \\n    public int bfs(Deque<TreeNode> queue){\\n        int maxWidth = 1;\\n        while(!queue.isEmpty()){\\n            int s=queue.size();\\n            int left = queue.peek().val;\\n            int right = left;\\n            for(int i=0;i<s;i++){\\n                TreeNode node=queue.removeFirst();           \\n                \\n                if(node.left!=null){\\n                    node.left.val = node.val * 2 - 1;\\n                    queue.add(node.left);\\n                }\\n                if(node.right!=null){\\n                    node.right.val = node.val * 2;\\n                    queue.add(node.right);\\n                }\\n                if(i==s-1)\\n                    right=node.val;\\n            }\\n            maxWidth=Math.max(maxWidth,right-left+1);\\n        }\\n        return maxWidth;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int widthOfBinaryTree(TreeNode root) {\\n        Deque<TreeNode> queue=new ArrayDeque<>();\\n        root.val=0;\\n        queue.add(root);\\n        return bfs(queue);\\n    }\\n    \\n    public int bfs(Deque<TreeNode> queue){\\n        int maxWidth = 1;\\n        while(!queue.isEmpty()){\\n            int s=queue.size();\\n            int left = queue.peek().val;\\n            int right = left;\\n            for(int i=0;i<s;i++){\\n                TreeNode node=queue.removeFirst();           \\n                \\n                if(node.left!=null){\\n                    node.left.val = node.val * 2 - 1;\\n                    queue.add(node.left);\\n                }\\n                if(node.right!=null){\\n                    node.right.val = node.val * 2;\\n                    queue.add(node.right);\\n                }\\n                if(i==s-1)\\n                    right=node.val;\\n            }\\n            maxWidth=Math.max(maxWidth,right-left+1);\\n        }\\n        return maxWidth;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 726944,
                "title": "c-maximum-width-of-binary-tree",
                "content": "so the idea is to get the position of each node in the given tree \\nfor the left nodes = position_of_root * 2 and for the right node = position_of_root * 2+1\\nand we keep track only of the most left nodes per level  in the hash table so when we meet a right node in the same level we subtrack them and we get the level width \\n```\\n\\nunsigned long long max_width;\\n    map<int,unsigned long long>left_positions;\\n    void get_width(TreeNode* root ,int depth,unsigned long long position)\\n    {\\n        if(root==NULL)return;\\n        if(left_positions.find(depth)==left_positions.end())\\n            left_positions[depth]=position;\\n        max_width=max(max_width ,position-left_positions[depth]+1);\\n        get_width(root->left,depth+1,position*2);\\n        get_width(root->right,depth+1,position*2+1);\\n    }\\n    int widthOfBinaryTree(TreeNode* root) {\\n        max_width=0;\\n        get_width(root,0,0);\\n        return max_width;\\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```\\n\\nunsigned long long max_width;\\n    map<int,unsigned long long>left_positions;\\n    void get_width(TreeNode* root ,int depth,unsigned long long position)\\n    {\\n        if(root==NULL)return;\\n        if(left_positions.find(depth)==left_positions.end())\\n            left_positions[depth]=position;\\n        max_width=max(max_width ,position-left_positions[depth]+1);\\n        get_width(root->left,depth+1,position*2);\\n        get_width(root->right,depth+1,position*2+1);\\n    }\\n    int widthOfBinaryTree(TreeNode* root) {\\n        max_width=0;\\n        get_width(root,0,0);\\n        return max_width;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 726792,
                "title": "python-bfs-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def widthOfBinaryTree(self, root: TreeNode) -> int:\\n        result = 0\\n        queue = collections.deque()\\n        queue.append((root, 1))\\n        \\n        while queue:\\n            n = len(queue)\\n            result = max(result, queue[-1][1] - queue[0][1] + 1)\\n            \\n            while n > 0:\\n                node, pos = queue.popleft()\\n                \\n                if node.left:\\n                    queue.append((node.left, pos*2))\\n                \\n                if node.right:\\n                    queue.append((node.right, pos*2 + 1))\\n                \\n                n -= 1\\n        \\n        return result\\n```\\n\\nPlease **upvote**, if you find the solution understandable.",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def widthOfBinaryTree(self, root: TreeNode) -> int:\\n        result = 0\\n        queue = collections.deque()\\n        queue.append((root, 1))\\n        \\n        while queue:\\n            n = len(queue)\\n            result = max(result, queue[-1][1] - queue[0][1] + 1)\\n            \\n            while n > 0:\\n                node, pos = queue.popleft()\\n                \\n                if node.left:\\n                    queue.append((node.left, pos*2))\\n                \\n                if node.right:\\n                    queue.append((node.right, pos*2 + 1))\\n                \\n                n -= 1\\n        \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 467845,
                "title": "bfs-c-handling-overflow-issue",
                "content": "```\\n    int widthOfBinaryTree(TreeNode* root) {\\n        if (!root) return 0;\\n        queue<pair<TreeNode*, int>> q;\\n        q.push({root, 0});\\n        \\n        int ans = 1;\\n        while (!q.empty()) {\\n            int n = q.size();\\n            \\n            // handle integer overflow\\n            if (n == 1) {\\n                pair<TreeNode*, int> node = q.front();\\n                q.pop();\\n                q.push({node.first, 1});\\n            }\\n\\n            ans = max (ans, q.back().second - q.front().second + 1);\\n            for (int i = 0; i < n; i++) {\\n                pair<TreeNode*, int> node = q.front();\\n                q.pop();\\n                if (node.first->left) q.push({node.first->left, node.second * 2});\\n                if (node.first->right) q.push({node.first->right, node.second * 2 + 1});\\n            }\\n        }\\n\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int widthOfBinaryTree(TreeNode* root) {\\n        if (!root) return 0;\\n        queue<pair<TreeNode*, int>> q;\\n        q.push({root, 0});\\n        \\n        int ans = 1;\\n        while (!q.empty()) {\\n            int n = q.size();\\n            \\n            // handle integer overflow\\n            if (n == 1) {\\n                pair<TreeNode*, int> node = q.front();\\n                q.pop();\\n                q.push({node.first, 1});\\n            }\\n\\n            ans = max (ans, q.back().second - q.front().second + 1);\\n            for (int i = 0; i < n; i++) {\\n                pair<TreeNode*, int> node = q.front();\\n                q.pop();\\n                if (node.first->left) q.push({node.first->left, node.second * 2});\\n                if (node.first->right) q.push({node.first->right, node.second * 2 + 1});\\n            }\\n        }\\n\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3438764,
                "title": "java-queue",
                "content": "```\\nclass Solution {\\n    class Pair {\\n        TreeNode node;\\n        int state;\\n        Pair (TreeNode node, int state) {\\n            this.node = node;\\n            this.state = state;\\n        }\\n    }\\n    \\n    public int widthOfBinaryTree(TreeNode root) {\\n        if (root == null) {\\n            return 0;\\n        }\\n        //  priority Queue (complete binary tree property)\\n        //  assigning indexes as we assign indexes in the implementatiaon of PriorityQueue\\n        LinkedList<Pair> q = new LinkedList<>();\\n        q.add(new Pair(root, 0));\\n        int maxWidth = 0;\\n        \\n        while (q.size() != 0) {\\n            int size = q.size();\\n            maxWidth = Math.max(maxWidth, Math.abs(q.peekFirst().state - q.peekLast().state) + 1);\\n            while (size-- > 0) {\\n                Pair rem = q.removeLast();\\n                if (rem.node.left != null) {\\n                    q.addFirst(new Pair(rem.node.left, 2 * rem.state + 1));\\n                }\\n                if (rem.node.right != null) {\\n                    q.addFirst(new Pair(rem.node.right, 2 * rem.state + 2));\\n                }\\n            }\\n        }\\n        return maxWidth;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    class Pair {\\n        TreeNode node;\\n        int state;\\n        Pair (TreeNode node, int state) {\\n            this.node = node;\\n            this.state = state;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3436537,
                "title": "easy-solution-of-java-c-100-faster-code-bfs-beginner-friendly",
                "content": "\\n\\n# Code\\nPLEASE UPVOTE IF YOU LIKE.\\n```\\nclass Solution {\\n    public int widthOfBinaryTree(TreeNode root) {\\n        Deque<TreeNode> queue=new ArrayDeque<>();\\n        root.val=0;\\n        queue.add(root);\\n        return bfs(queue);\\n    }\\n    \\n    public int bfs(Deque<TreeNode> queue){\\n        int maxWidth = 1;\\n        while(!queue.isEmpty()){\\n            int s=queue.size();\\n            int left = queue.peek().val;\\n            int right = left;\\n            for(int i=0;i<s;i++){\\n                TreeNode node=queue.removeFirst();           \\n                \\n                if(node.left!=null){\\n                    node.left.val = node.val * 2 - 1;\\n                    queue.add(node.left);\\n                }\\n                if(node.right!=null){\\n                    node.right.val = node.val * 2;\\n                    queue.add(node.right);\\n                }\\n                if(i==s-1)\\n                    right=node.val;\\n            }\\n            maxWidth=Math.max(maxWidth,right-left+1);\\n        }\\n        return maxWidth;\\n    }\\n}\\n```\\nC++\\n```\\nclass Solution {\\npublic:\\n    int widthOfBinaryTree(TreeNode* root) {\\n    \\tsize_t ans = 1;\\n    \\tif(root){\\n    \\t\\tqueue<pair<TreeNode*, size_t>> q;\\n    \\t\\tq.push({root, 0});\\n    \\t\\t\\n    \\t\\twhile(!q.empty()){\\n\\t\\t\\t\\tans = max(ans, q.back().second-q.front().second+1);\\n    \\t\\t\\tint size = q.size();\\n    \\t\\t\\tfor(int i = 0; i<size; i++){\\n    \\t\\t\\t\\tTreeNode* current = q.front().first;\\n    \\t\\t\\t\\tsize_t curInd = q.front().second;\\n    \\t\\t\\t\\tq.pop();\\n    \\t\\t\\t\\tif(current->left){\\n    \\t\\t\\t\\t\\tq.push({current->left, curInd*2});\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t\\tif(current->right){\\n    \\t\\t\\t\\t\\tq.push({current->right, curInd*2+1});\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t}\\n    \\treturn (int)ans;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int widthOfBinaryTree(TreeNode root) {\\n        Deque<TreeNode> queue=new ArrayDeque<>();\\n        root.val=0;\\n        queue.add(root);\\n        return bfs(queue);\\n    }\\n    \\n    public int bfs(Deque<TreeNode> queue){\\n        int maxWidth = 1;\\n        while(!queue.isEmpty()){\\n            int s=queue.size();\\n            int left = queue.peek().val;\\n            int right = left;\\n            for(int i=0;i<s;i++){\\n                TreeNode node=queue.removeFirst();           \\n                \\n                if(node.left!=null){\\n                    node.left.val = node.val * 2 - 1;\\n                    queue.add(node.left);\\n                }\\n                if(node.right!=null){\\n                    node.right.val = node.val * 2;\\n                    queue.add(node.right);\\n                }\\n                if(i==s-1)\\n                    right=node.val;\\n            }\\n            maxWidth=Math.max(maxWidth,right-left+1);\\n        }\\n        return maxWidth;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int widthOfBinaryTree(TreeNode* root) {\\n    \\tsize_t ans = 1;\\n    \\tif(root){\\n    \\t\\tqueue<pair<TreeNode*, size_t>> q;\\n    \\t\\tq.push({root, 0});\\n    \\t\\t\\n    \\t\\twhile(!q.empty()){\\n\\t\\t\\t\\tans = max(ans, q.back().second-q.front().second+1);\\n    \\t\\t\\tint size = q.size();\\n    \\t\\t\\tfor(int i = 0; i<size; i++){\\n    \\t\\t\\t\\tTreeNode* current = q.front().first;\\n    \\t\\t\\t\\tsize_t curInd = q.front().second;\\n    \\t\\t\\t\\tq.pop();\\n    \\t\\t\\t\\tif(current->left){\\n    \\t\\t\\t\\t\\tq.push({current->left, curInd*2});\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t\\tif(current->right){\\n    \\t\\t\\t\\t\\tq.push({current->right, curInd*2+1});\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t}\\n    \\treturn (int)ans;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3436466,
                "title": "daily-leetcoding-challenge-april-day-20",
                "content": "This problem is the Daily LeetCoding Challenge for April, Day 20.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/maximum-width-of-binary-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** BFS Traversal\n\n  \n**Approach 2:** DFS Traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/maximum-width-of-binary-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 3097704,
                "title": "accepted-easy-solution-short-simple-best-method",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int widthOfBinaryTree(TreeNode* root) {\\n        if(!root)\\n            return 0;\\n        queue<pair<TreeNode*,long long>> q;\\n        q.push({root,0});\\n        long long ans=0;\\n        while(!q.empty())\\n        {\\n            long long s=q.size();\\n            long long x,y;\\n            long long d2=q.front().second;\\n            for(int i=0;i<s;i++)\\n            {\\n                long long d1=q.front().second;\\n                long long d=d1-d2;\\n                if(i==0)\\n                    x=d;\\n                if(i==s-1)\\n                    y=d;\\n                TreeNode* t=q.front().first;\\n                q.pop();\\n                if(t->left)\\n                {\\n                    q.push({t->left,2*d+1});\\n                }\\n                if(t->right)\\n                    q.push({t->right, 2*d+2});\\n            }\\n            ans=max(ans, y-x+1);\\n        }\\n        return ans;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int widthOfBinaryTree(TreeNode* root) {\\n        if(!root)\\n            return 0;\\n        queue<pair<TreeNode*,long long>> q;\\n        q.push({root,0});\\n        long long ans=0;\\n        while(!q.empty())\\n        {\\n            long long s=q.size();\\n            long long x,y;\\n            long long d2=q.front().second;\\n            for(int i=0;i<s;i++)\\n            {\\n                long long d1=q.front().second;\\n                long long d=d1-d2;\\n                if(i==0)\\n                    x=d;\\n                if(i==s-1)\\n                    y=d;\\n                TreeNode* t=q.front().first;\\n                q.pop();\\n                if(t->left)\\n                {\\n                    q.push({t->left,2*d+1});\\n                }\\n                if(t->right)\\n                    q.push({t->right, 2*d+2});\\n            }\\n            ans=max(ans, y-x+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1803336,
                "title": "c-efficient-bfs-using-queue-tc-o-n-sc-o-n-with-video-solution-link",
                "content": "##### *please upvote , if u find it helpfull :)*\\n##### *Thanks* ;)\\n```\\nclass Solution {\\npublic:\\n    int widthOfBinaryTree(TreeNode* root) {\\n        if(root==NULL) return 0;\\n        int ans=0;\\n        queue<pair<TreeNode*,int >>q;//{node,index}\\n        q.push({root,0});\\n        while(!q.empty()){\\n             int size=q.size();\\n             int mmin=q.front().second;//to make the index starting from zore\\n             int first,last;\\n            for(int i=0;i<size;i++){\\n                int index=q.front().second -mmin;//-mmin for controling overflow cases\\n                TreeNode * node=q.front().first;\\n                q.pop();\\n                if(i==0) first=index;\\n                if(i==size-1) last=index;\\n                \\n                if(node->left!=NULL){\\n                    q.push({node->left, (long)index*2 + 1});\\n                }\\n                if(node->right!=NULL){\\n                    q.push({node->right, (long)index*2 + 2});\\n                }\\n            }\\n            ans=max(ans, last-first +1);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n*if u still not understood, then look at comment section for video solution :)*",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int widthOfBinaryTree(TreeNode* root) {\\n        if(root==NULL) return 0;\\n        int ans=0;\\n        queue<pair<TreeNode*,int >>q;//{node,index}\\n        q.push({root,0});\\n        while(!q.empty()){\\n             int size=q.size();\\n             int mmin=q.front().second;//to make the index starting from zore\\n             int first,last;\\n            for(int i=0;i<size;i++){\\n                int index=q.front().second -mmin;//-mmin for controling overflow cases\\n                TreeNode * node=q.front().first;\\n                q.pop();\\n                if(i==0) first=index;\\n                if(i==size-1) last=index;\\n                \\n                if(node->left!=NULL){\\n                    q.push({node->left, (long)index*2 + 1});\\n                }\\n                if(node->right!=NULL){\\n                    q.push({node->right, (long)index*2 + 2});\\n                }\\n            }\\n            ans=max(ans, last-first +1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1347755,
                "title": "java-dfs-approach-beats-100-time-and-space",
                "content": "```\\nclass Solution {\\n    HashMap<Integer,Integer> hm=new HashMap<>();\\n        int maxWidth=0;\\n    public int widthOfBinaryTree(TreeNode root) {\\n        width(root,0,0);\\n        return maxWidth;\\n    }\\n    public void width(TreeNode root,int depth,int position){\\n        if(root==null){\\n            return;\\n        }\\n        if(!hm.containsKey(depth)){\\n            hm.put(depth,position);\\n        }\\n        maxWidth=Math.max(maxWidth,position-hm.get(depth)+1);\\n        width(root.left,depth+1,position*2);\\n        width(root.right,depth+1,position*2+1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    HashMap<Integer,Integer> hm=new HashMap<>();\\n        int maxWidth=0;\\n    public int widthOfBinaryTree(TreeNode root) {\\n        width(root,0,0);\\n        return maxWidth;\\n    }\\n    public void width(TreeNode root,int depth,int position){\\n        if(root==null){\\n            return;\\n        }\\n        if(!hm.containsKey(depth)){\\n            hm.put(depth,position);\\n        }\\n        maxWidth=Math.max(maxWidth,position-hm.get(depth)+1);\\n        width(root.left,depth+1,position*2);\\n        width(root.right,depth+1,position*2+1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1255840,
                "title": "2-steps-elegant-precise-heavily-explained-o-n-time-bfs-c",
                "content": "### **EXPLANATION :-**\\n*  \\t**`IDEA:- Just calculate the difference between first index of current level node to the last index of current level node..`**  \\n\\t\\t\\t\\t**`And for this purpose, we\\'re maintaing pair of TreeNode* & int in the queue. the second integer value in pair denotes the indexes of the current node`**\\n          **`We\\'re updating result variable at every level of the tree by picking up the maximum differenced index.`**\\n\\t\\t  \\n\\t   **`BUT HOW DO WE MAINTAIN THE INDEXS OF THE NODES?`**\\n       **`There is formula to access the children of the binary tree of the current node \\'w\\'(let say)`**\\n       **`1. for left children :  2 * (w) + 1`**\\n       **`2. for right children : 2 * (w) + 2`**\\n```\\n```\\n* **C++ CODE :-   SIMPLE  BFS    `[Accepted : ~10ms]`**\\n```\\nclass Solution {\\npublic:\\n    int widthOfBinaryTree(TreeNode* root) {\\n        if(root == NULL) return 0;\\n        int res = 0;\\n\\t\\tqueue<pair<TreeNode*, unsigned int>> q;        // queue<Nodes, Indexes of the Nodes> q\\n        q.push({root, 0});\\n\\n        while(!q.empty()){\\n        \\tauto size = q.size();\\n\\t\\t\\tunsigned int leftNodeIdx = q.front().second;     // Here, idx can\\'t go negative. Therefore, I\\'ve used Unsigned Int\\n        \\tunsigned int rightNodeIdx = 0;\\n        \\twhile(size--){\\n        \\t\\tauto [node, rightIdx] = q.front();\\tq.pop();\\n        \\t\\trightNodeIdx = rightIdx;\\n\\n        \\t\\tif(node->left != NULL) q.push({node->left, 2 * rightNodeIdx + 1});\\n        \\t\\tif(node->right != NULL) q.push({node->right, 2 * rightNodeIdx + 2});\\n        \\t}\\n        \\tres = max(res, int(rightNodeIdx - leftNodeIdx + 1));\\n        }\\n        return res;\\n    }\\n};\\n```\\n**TIME    COMPLEXITY : `O(N), `Where `N :`, total number of nodes in the tree**\\n**SPACE  COMPLEXITY :  `O(N) `**\\n\\nif you **find any mistakes pls** drop a comment,\\nif it makes any sense **Please Upvote :)**\\n",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\n```\n```\\nclass Solution {\\npublic:\\n    int widthOfBinaryTree(TreeNode* root) {\\n        if(root == NULL) return 0;\\n        int res = 0;\\n\\t\\tqueue<pair<TreeNode*, unsigned int>> q;        // queue<Nodes, Indexes of the Nodes> q\\n        q.push({root, 0});\\n\\n        while(!q.empty()){\\n        \\tauto size = q.size();\\n\\t\\t\\tunsigned int leftNodeIdx = q.front().second;     // Here, idx can\\'t go negative. Therefore, I\\'ve used Unsigned Int\\n        \\tunsigned int rightNodeIdx = 0;\\n        \\twhile(size--){\\n        \\t\\tauto [node, rightIdx] = q.front();\\tq.pop();\\n        \\t\\trightNodeIdx = rightIdx;\\n\\n        \\t\\tif(node->left != NULL) q.push({node->left, 2 * rightNodeIdx + 1});\\n        \\t\\tif(node->right != NULL) q.push({node->right, 2 * rightNodeIdx + 2});\\n        \\t}\\n        \\tres = max(res, int(rightNodeIdx - leftNodeIdx + 1));\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 726785,
                "title": "c-level-order-traversal-with-detailed-explanation",
                "content": "My approach:\\nLet\\'s take a complete binary tree to understand\\n```\\n\\t       1\\n         /   \\\\\\n        2     3\\n       / \\\\    /\\\\ \\n      4   5  6  7 \\n```\\n### Basic structure\\nWe will use a pair ``{node,val}`` where value is the position of the element in that level from right if the tree was full\\nSo the values of pair for node 1 to 7 will be:\\n``{1,1}``\\n``{2,2} {3,1}``\\n``{4,4} {5,3} {6,2} {7,1}``\\nAs you can see the position of 7 from right is 1 and 4 is (4 is the 4th node from right in that level)\\nSo the width will be ``position of 4 - position of 7 +1`` = 4.\\nEven if any number between 4 and 7 were absent the ans will be 4. \\nWhat if seven is absent then we have 6 which is the rightmost node of that level, so width should be 3:\\n``position of 4 - position of 6 +1`` =3\\ni.e.\\n``Leftmost node postion - rightmost node position + 1 `` so when we run algo we can calculate this by :\\n``max - min +1``\\n\\n###  Calculation of position\\n\\nNow how to fill in these position:\\nThe value of pair will be filled this way:\\nfor the root node it will be ``{node,val} : {1,1}`` \\nthen for left node: ``{node->left, val*2}``\\nfor right node:  ``{node->right, val*2 - 1}``\\n```\\n\\t       1 - {1,1}\\n         /   \\\\\\n        2     3     for 2: {2,2*1} = {2,2} | 3: {3,2*1-1} = {3,1}\\n       / \\\\    /\\\\ \\n      4   5  6  7 \\n\\nfor  4: {4,2*2} = {4,4}\\n5: {5,2*2-1} = {5,3}\\n6: {6,2*1} = {6,2}  - parent of 6 and 7 is 3: {3,1}\\n7: {7,2*1-1} = {7,1}\\n```\\n\\n### Calculating width and finding max width\\n\\nSo you can see this will give the correct position to all existing nodes even if the nodes in between or before or after were absent.\\n\\nThen we just need to do ``current max = maxpos - minpos + 1`` (plus 1 bcoz we while subtracting we are removing one position)\\nthe ``ans = max(currentmax, ans)`` which will be the final ans.\\n\\n### Datastructures and other factors in code\\n1. The First is a queue to perform level order traversal\\n2. Queue will contain pair of type ``{TreeNode*,int}`` where first is node and second is position of the node\\n3. ``minval`` and ``maxval`` contain the minimum and maximum position of the current level\\n4. ``maxval - minval +1`` will give the width of current level\\n5. ``ans`` will contain the max width  of the entire tree\\n\\nExplanation also given in code as comments.\\n\\nCODE: \\n```\\nclass Solution {\\npublic:\\n    int widthOfBinaryTree(TreeNode* root) {\\n        if(!root)return 0;  \\n        queue<pair<TreeNode*,int>>q;   // queue containg all pairs in a level\\n        q.push({root,1});        // push the root node with position 1\\n        int ans = 1;             //min width will be 1\\n        while(!q.empty()){\\n            int sz = q.size();      // get number of nodes in current level\\n            int minval = INT_MAX,maxval = 0;\\n            while(sz--){     // for all nodes in this level\\n                auto node = q.front();q.pop();     // get the pair\\n                int x = node.second*2;      // to calculate position\\t\\n\\t\\t\\t\\tif(node.first->left){    \\n                    q.push({node.first->left,x});\\n                    minval = min(minval,x);\\n                    maxval = max(maxval,x);\\n                }\\n                if(node.first->right){\\n                    q.push({node.first->right, x - 1 });\\n                    minval = min(minval,x-1);\\n                    maxval = max(maxval,x-1);\\n                }\\n            }\\n // in case there were no children added set minval to 0  as maxval is already 0\\n            minval = (minval == INT_MAX) ? 0 : minval; \\n            ans = max((maxval - minval+1),ans);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\t       1\\n         /   \\\\\\n        2     3\\n       / \\\\    /\\\\ \\n      4   5  6  7 \\n```\n```\\n\\t       1 - {1,1}\\n         /   \\\\\\n        2     3     for 2: {2,2*1} = {2,2} | 3: {3,2*1-1} = {3,1}\\n       / \\\\    /\\\\ \\n      4   5  6  7 \\n\\nfor  4: {4,2*2} = {4,4}\\n5: {5,2*2-1} = {5,3}\\n6: {6,2*1} = {6,2}  - parent of 6 and 7 is 3: {3,1}\\n7: {7,2*1-1} = {7,1}\\n```\n```\\nclass Solution {\\npublic:\\n    int widthOfBinaryTree(TreeNode* root) {\\n        if(!root)return 0;  \\n        queue<pair<TreeNode*,int>>q;   // queue containg all pairs in a level\\n        q.push({root,1});        // push the root node with position 1\\n        int ans = 1;             //min width will be 1\\n        while(!q.empty()){\\n            int sz = q.size();      // get number of nodes in current level\\n            int minval = INT_MAX,maxval = 0;\\n            while(sz--){     // for all nodes in this level\\n                auto node = q.front();q.pop();     // get the pair\\n                int x = node.second*2;      // to calculate position\\t\\n\\t\\t\\t\\tif(node.first->left){    \\n                    q.push({node.first->left,x});\\n                    minval = min(minval,x);\\n                    maxval = max(maxval,x);\\n                }\\n                if(node.first->right){\\n                    q.push({node.first->right, x - 1 });\\n                    minval = min(minval,x-1);\\n                    maxval = max(maxval,x-1);\\n                }\\n            }\\n // in case there were no children added set minval to 0  as maxval is already 0\\n            minval = (minval == INT_MAX) ? 0 : minval; \\n            ans = max((maxval - minval+1),ans);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 726667,
                "title": "very-simple-c-solution-easy-to-understand",
                "content": "```\\n\\nclass Solution {\\npublic:\\n   \\n    \\n    int widthOfBinaryTree(TreeNode* root) {\\n        \\n       if (root == NULL) \\n        return 0; \\n\\n    int result = 0; \\n  \\n   \\n    queue<pair<TreeNode*,int>> q; \\n    q.push(make_pair(root,1));\\n    while (!q.empty()) \\n    { \\n        // Get the size of queue when the level order \\n        // traversal for one level finishes \\n        int count = q.size() ; \\n  result=max(result,(q.back().second-q.front().second)+1);\\n        while (count--) \\n        { \\n            // Dequeue an node from queue \\n            pair<TreeNode*,int>temp = q.front(); \\n            q.pop(); \\n       \\n            if (temp.first->left != NULL) \\n            {q.push(make_pair(temp.first->left,2*(long)temp.second)); }\\n           \\n            if (temp.first->right != NULL) \\n            { q.push(make_pair(temp.first->right,2*(long)temp.second+1)); }\\n        \\n    } \\n \\n        \\n    }\\n        return result;\\n       // return height;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n   \\n    \\n    int widthOfBinaryTree(TreeNode* root) {\\n        \\n       if (root == NULL) \\n        return 0; \\n\\n    int result = 0; \\n  \\n   \\n    queue<pair<TreeNode*,int>> q; \\n    q.push(make_pair(root,1));\\n    while (!q.empty()) \\n    { \\n        // Get the size of queue when the level order \\n        // traversal for one level finishes \\n        int count = q.size() ; \\n  result=max(result,(q.back().second-q.front().second)+1);\\n        while (count--) \\n        { \\n            // Dequeue an node from queue \\n            pair<TreeNode*,int>temp = q.front(); \\n            q.pop(); \\n       \\n            if (temp.first->left != NULL) \\n            {q.push(make_pair(temp.first->left,2*(long)temp.second)); }\\n           \\n            if (temp.first->right != NULL) \\n            { q.push(make_pair(temp.first->right,2*(long)temp.second+1)); }\\n        \\n    } \\n \\n        \\n    }\\n        return result;\\n       // return height;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 162684,
                "title": "python-bfs-o",
                "content": "```\\nclass Solution:\\n    def widthOfBinaryTree(self, root):\\n        if not root:\\n            return 0\\n        q = [(root, 0)]\\n        res = 1\\n        \\n        while q:\\n            level = []\\n            \\n            for i in range(len(q)):\\n                node = q.pop(0)\\n                \\n                if node[0].left:\\n                    level.append((node[0].left, node[1] * 2))\\n                if node[0].right:\\n                    level.append((node[0].right, node[1] * 2 + 1))\\n            \\n            if level:\\n                res = max(res, level[-1][1] - level[0][1] + 1)\\n            q = level\\n        \\n        return res\\n ```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def widthOfBinaryTree(self, root):\\n        if not root:\\n            return 0\\n        q = [(root, 0)]\\n        res = 1\\n        \\n        while q:\\n            level = []\\n            \\n            for i in range(len(q)):\\n                node = q.pop(0)\\n                \\n                if node[0].left:\\n                    level.append((node[0].left, node[1] * 2))\\n                if node[0].right:\\n                    level.append((node[0].right, node[1] * 2 + 1))\\n            \\n            if level:\\n                res = max(res, level[-1][1] - level[0][1] + 1)\\n            q = level\\n        \\n        return res\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 149624,
                "title": "java-elegant-bfs-solution",
                "content": "```\\nclass Solution {\\n    public int widthOfBinaryTree(TreeNode root) {\\n        if(root == null) return 0;\\n        Map<TreeNode, Integer> map = new HashMap<>();\\n        Queue<TreeNode> q = new LinkedList<>();\\n        map.put(root, 1);\\n        q.add(root);\\n        int max = 1;\\n        while(!q.isEmpty()) {\\n            int size = q.size();\\n            int left = 0;\\n            for(int i = 0; i < size; i++) {\\n                TreeNode curr = q.poll();\\n                int index = map.get(curr);\\n                if(i == 0) {\\n                    left = index;\\n                }\\n                if(i == size - 1) {\\n                    max = Math.max(max, index - left + 1);\\n                }\\n                if(curr.left != null) {\\n                    map.put(curr.left, index * 2);\\n                    q.add(curr.left);\\n                }\\n                if(curr.right != null) {\\n                    map.put(curr.right, index * 2 + 1);\\n                    q.add(curr.right);\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int widthOfBinaryTree(TreeNode root) {\\n        if(root == null) return 0;\\n        Map<TreeNode, Integer> map = new HashMap<>();\\n        Queue<TreeNode> q = new LinkedList<>();\\n        map.put(root, 1);\\n        q.add(root);\\n        int max = 1;\\n        while(!q.isEmpty()) {\\n            int size = q.size();\\n            int left = 0;\\n            for(int i = 0; i < size; i++) {\\n                TreeNode curr = q.poll();\\n                int index = map.get(curr);\\n                if(i == 0) {\\n                    left = index;\\n                }\\n                if(i == size - 1) {\\n                    max = Math.max(max, index - left + 1);\\n                }\\n                if(curr.left != null) {\\n                    map.put(curr.left, index * 2);\\n                    q.add(curr.left);\\n                }\\n                if(curr.right != null) {\\n                    map.put(curr.right, index * 2 + 1);\\n                    q.add(curr.right);\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3527542,
                "title": "easy-c-solution-runtime-beats-93-63-memory-beats-90-51",
                "content": "# Intution\\n<!-- Describe your approach to solving the problem. -->\\nSegment Trees\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe simple approach toward this questio was to just give the indexing to the node which are the part of the binary tree and to the imaginary nodes which should have been there instead of NULL.\\nThe Node on the left of the parent nodes will have index of the pattern - **2*i+1**. (considering Zero based Indexing)\\n\\n```\\nq.push({node->left,2*currIndex+1});\\n```\\n\\n\\nThe Node on the right of the parent nodes will have index of the pattern - **2*i+2**.\\n\\n```\\nq.push({node->right,2*currIndex+2});\\n```\\n\\nBut instead of multiplying it by 2 every simgle time it will be better if we just multiply it with (**i-min index of the level** (*which is the index of the first node of the level*)).\\n```\\nint minn = q.front().second;\\n```\\n```\\nlong currIndex = q.front().second - minn;\\n```\\n```\\nif(node->left){\\n    q.push({node->left,2*currIndex+1});\\n}\\nif(node->right){\\n    q.push({node->right,2*currIndex+2});\\n}\\n```\\n\\n \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nSince we are doing the level order traversal, the time complexity will be O(n).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSince we are using pair data structure for therefore space complexity - O(n).\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int widthOfBinaryTree(TreeNode* root) {\\n        if(root==NULL) return 0;\\n        queue<pair<TreeNode*,int> > q;\\n        q.push({root,0});\\n        int ans = 0;\\n\\n        while(!q.empty()){\\n            int size = q.size();\\n            int minn = q.front().second;\\n            int first = 0;\\n            int last = 0;\\n            for(int i=0;i<size;i++){\\n            long currIndex = q.front().second - minn;\\n                TreeNode* node = q.front().first;\\n                q.pop();\\n                if(i==0) first = currIndex;\\n                if(i==size- 1) last = currIndex;\\n\\n                if(node->left){\\n                    q.push({node->left,2*currIndex+1});\\n                }\\n                if(node->right){\\n                    q.push({node->right,2*currIndex+2});\\n                }\\n            }\\n            ans = max(ans,last-first+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nq.push({node->left,2*currIndex+1});\\n```\n```\\nq.push({node->right,2*currIndex+2});\\n```\n```\\nint minn = q.front().second;\\n```\n```\\nlong currIndex = q.front().second - minn;\\n```\n```\\nif(node->left){\\n    q.push({node->left,2*currIndex+1});\\n}\\nif(node->right){\\n    q.push({node->right,2*currIndex+2});\\n}\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int widthOfBinaryTree(TreeNode* root) {\\n        if(root==NULL) return 0;\\n        queue<pair<TreeNode*,int> > q;\\n        q.push({root,0});\\n        int ans = 0;\\n\\n        while(!q.empty()){\\n            int size = q.size();\\n            int minn = q.front().second;\\n            int first = 0;\\n            int last = 0;\\n            for(int i=0;i<size;i++){\\n            long currIndex = q.front().second - minn;\\n                TreeNode* node = q.front().first;\\n                q.pop();\\n                if(i==0) first = currIndex;\\n                if(i==size- 1) last = currIndex;\\n\\n                if(node->left){\\n                    q.push({node->left,2*currIndex+1});\\n                }\\n                if(node->right){\\n                    q.push({node->right,2*currIndex+2});\\n                }\\n            }\\n            ans = max(ans,last-first+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3437980,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int widthOfBinaryTree(TreeNode* root) \\n    {\\n        queue<pair<TreeNode*,long>> q;\\n        q.push({root,1});\\n        int n,start,end,dif;\\n        int res = 1;\\n        while(!q.empty())\\n        {\\n            n = q.size();\\n            for(int i=0; i<n; i++)\\n            {\\n                auto [node,pos] = q.front();\\n                q.pop();\\n                if(i==0)\\n                {\\n                    start = pos;\\n                    dif = pos-1;\\n                }\\n                if(i==n-1) end = pos;\\n                pos -= dif;\\n                if(node->left!=nullptr) q.push({node->left,pos*2-1});\\n                if(node->right!=nullptr) q.push({node->right,pos*2});\\n            }\\n            res = max(res,end-start+1);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int widthOfBinaryTree(TreeNode* root) \\n    {\\n        queue<pair<TreeNode*,long>> q;\\n        q.push({root,1});\\n        int n,start,end,dif;\\n        int res = 1;\\n        while(!q.empty())\\n        {\\n            n = q.size();\\n            for(int i=0; i<n; i++)\\n            {\\n                auto [node,pos] = q.front();\\n                q.pop();\\n                if(i==0)\\n                {\\n                    start = pos;\\n                    dif = pos-1;\\n                }\\n                if(i==n-1) end = pos;\\n                pos -= dif;\\n                if(node->left!=nullptr) q.push({node->left,pos*2-1});\\n                if(node->right!=nullptr) q.push({node->right,pos*2});\\n            }\\n            res = max(res,end-start+1);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1804506,
                "title": "java-easy-bfs-solution-using-queue",
                "content": "```\\nclass Pair{\\n    TreeNode root;\\n    int index;\\n        \\n    Pair(TreeNode root,int index){\\n        this.root=root;\\n        this.index=index;\\n    }\\n}\\n    \\nclass Solution {\\n    public int widthOfBinaryTree(TreeNode root) {\\n        if(root==null) return 0;\\n        \\n        int ans=0;\\n        \\n        Queue<Pair> q=new LinkedList<>();\\n        q.add(new Pair(root,0));\\n        \\n        \\n        while(q.size()>0){\\n            int size=q.size();\\n            int l=q.peek().index;\\n            int r=q.peek().index;\\n            \\n            while(size-->0){\\n                Pair temp=q.poll();\\n                r=temp.index;\\n                \\n                if(temp.root.left!=null) q.add(new Pair(temp.root.left,temp.index*2+1));\\n                if(temp.root.right!=null) q.add(new Pair(temp.root.right,temp.index*2+2));\\n            }\\n            ans=Math.max(ans,r-l+1);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Queue"
                ],
                "code": "```\\nclass Pair{\\n    TreeNode root;\\n    int index;\\n        \\n    Pair(TreeNode root,int index){\\n        this.root=root;\\n        this.index=index;\\n    }\\n}\\n    \\nclass Solution {\\n    public int widthOfBinaryTree(TreeNode root) {\\n        if(root==null) return 0;\\n        \\n        int ans=0;\\n        \\n        Queue<Pair> q=new LinkedList<>();\\n        q.add(new Pair(root,0));\\n        \\n        \\n        while(q.size()>0){\\n            int size=q.size();\\n            int l=q.peek().index;\\n            int r=q.peek().index;\\n            \\n            while(size-->0){\\n                Pair temp=q.poll();\\n                r=temp.index;\\n                \\n                if(temp.root.left!=null) q.add(new Pair(temp.root.left,temp.index*2+1));\\n                if(temp.root.right!=null) q.add(new Pair(temp.root.right,temp.index*2+2));\\n            }\\n            ans=Math.max(ans,r-l+1);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1541723,
                "title": "python-simple-commented-code",
                "content": "```\\ndef widthOfBinaryTree(self, root: Optional[TreeNode]) -> int:\\n        # Treat tree as Heap array and save idx as 2*i and 2*i + 1\\n        # diff of first and last node when level ends is the result\\n        if not root: return 0\\n        q = [[root,1]]\\n        maxWidth = 0\\n        while q:\\n            maxWidth = max(maxWidth,q[-1][1] - q[0][1] + 1) # find the difference for upcomming queue\\n            for _ in range(len(q)):\\n                curr,idx = q.pop(0)\\n                if curr.left: q.append((curr.left,idx*2))\\n                if curr.right: q.append((curr.right, idx*2+1))\\n        return maxWidth\\n\\t\\t# like if you find it useful\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\ndef widthOfBinaryTree(self, root: Optional[TreeNode]) -> int:\\n        # Treat tree as Heap array and save idx as 2*i and 2*i + 1\\n        # diff of first and last node when level ends is the result\\n        if not root: return 0\\n        q = [[root,1]]\\n        maxWidth = 0\\n        while q:\\n            maxWidth = max(maxWidth,q[-1][1] - q[0][1] + 1) # find the difference for upcomming queue\\n            for _ in range(len(q)):\\n                curr,idx = q.pop(0)\\n                if curr.left: q.append((curr.left,idx*2))\\n                if curr.right: q.append((curr.right, idx*2+1))\\n        return maxWidth\\n\\t\\t# like if you find it useful\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1514554,
                "title": "runtime-0-ms-faster-than-100-00-of-c-online-submissions",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int max(int x,int y){\\n        return (x>y?x:y);\\n    }\\n    int widthOfBinaryTree(TreeNode* root) {\\n        if(!root) return 0;\\n        queue<pair<TreeNode*,unsigned long long int>>q;\\n        q.push({root,0});\\n        int width=0;\\n        while(!q.empty()){\\n            unsigned long long int l=q.front().second;\\n            unsigned long long int r=0;\\n            int n=q.size();\\n            for(auto i=0;i<n;i++){\\n                pair<TreeNode*,unsigned long long int >ptr=q.front();\\n                q.pop();\\n                r=ptr.second;\\n                if(ptr.first->left){\\n                    q.push({ptr.first->left,2*r+1});\\n                }\\n                if(ptr.first->right){\\n                    q.push({ptr.first->right,2*r+2});\\n                }\\n            }\\n            width=max(width,(r-l+1));\\n        }\\n        return width;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int max(int x,int y){\\n        return (x>y?x:y);\\n    }\\n    int widthOfBinaryTree(TreeNode* root) {\\n        if(!root) return 0;\\n        queue<pair<TreeNode*,unsigned long long int>>q;\\n        q.push({root,0});\\n        int width=0;\\n        while(!q.empty()){\\n            unsigned long long int l=q.front().second;\\n            unsigned long long int r=0;\\n            int n=q.size();\\n            for(auto i=0;i<n;i++){\\n                pair<TreeNode*,unsigned long long int >ptr=q.front();\\n                q.pop();\\n                r=ptr.second;\\n                if(ptr.first->left){\\n                    q.push({ptr.first->left,2*r+1});\\n                }\\n                if(ptr.first->right){\\n                    q.push({ptr.first->right,2*r+2});\\n                }\\n            }\\n            width=max(width,(r-l+1));\\n        }\\n        return width;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1276163,
                "title": "java-easy-solution-using-heap-property-detailed-explanation-faster-than-94",
                "content": "**//Do vote up if you like it :)**\\n\\nThe idea is to get the 1st NodePair idx and the last NodePair idx at each level and get the difference + 1 (Inclusive) to find the maxWidth.\\n\\n\\nUsing heap indexing property: 1\\nIf we give 1 to root, suppose idx of root is idx = 1 , then it\\'s left child would be 2 from (2 * idx) formula and right child would be 3 from (2 * idx + 1) formula and so on for the subtree.\\n```\\nclass Solution {\\n    \\n    class NodePair{\\n        TreeNode node;\\n        int idx;\\n        \\n        public NodePair(TreeNode node, int idx){\\n            this.node = node;\\n            this.idx = idx;\\n        }\\n    }\\n    \\n    public int widthOfBinaryTree(TreeNode root) {\\n        if(root == null)\\n            return 0;\\n        \\n        Queue<NodePair> queue = new LinkedList<>();\\n        queue.offer(new NodePair(root, 1));\\n        int maxWidth = 0;\\n        \\n        while(!queue.isEmpty()){\\n            NodePair firstNodePair = queue.peek();\\n            NodePair currentNodePair = null;\\n            int size = queue.size();\\n            while(size-- > 0){\\n                currentNodePair = queue.poll();\\n                if(currentNodePair.node.left != null)\\n                    queue.offer(new NodePair(currentNodePair.node.left, 2 * currentNodePair.idx));\\n                if(currentNodePair.node.right != null)\\n                    queue.offer(new NodePair(currentNodePair.node.right, 2 * currentNodePair.idx + 1));\\n            }\\n            maxWidth = Math.max(maxWidth, (currentNodePair.idx - firstNodePair.idx) + 1);\\n        }\\n        return maxWidth;\\n    }\\n}\\n```\\n-----------------------------------------------------------------------------------------------------------------\\nUsing heap indexing property: 0\\nIf we give 0 to root, suppose idx of root is idx = 0 , then it\\'s left child would be 1 from (2 * idx + 1) formula and right child would be 2 from (2 * idx + 2) formula and so on for the subtree.\\n```\\nclass Solution {\\n    \\n    class NodePair{\\n        TreeNode node;\\n        int idx;\\n        \\n        public NodePair(TreeNode node, int idx){\\n            this.node = node;\\n            this.idx = idx;\\n        }\\n    }\\n    \\n    public int widthOfBinaryTree(TreeNode root) {\\n        if(root == null)\\n            return 0;\\n        \\n        Queue<NodePair> queue = new LinkedList<>();\\n        queue.offer(new NodePair(root, 0));\\n        int maxWidth = 0;\\n        \\n        while(!queue.isEmpty()){\\n            NodePair firstNodePair = queue.peek();\\n            NodePair currentNodePair = null;\\n            int size = queue.size();\\n            while(size-- > 0){\\n                currentNodePair = queue.poll();\\n                if(currentNodePair.node.left != null)\\n                    queue.offer(new NodePair(currentNodePair.node.left, 2 * currentNodePair.idx + 1));\\n                if(currentNodePair.node.right != null)\\n                    queue.offer(new NodePair(currentNodePair.node.right, 2 * currentNodePair.idx + 2));\\n            }\\n            maxWidth = Math.max(maxWidth, (currentNodePair.idx - firstNodePair.idx) + 1);\\n        }\\n        return maxWidth;\\n    }\\n}\\n\\n---------------------------------------------------------------------------------------------------\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    class NodePair{\\n        TreeNode node;\\n        int idx;\\n        \\n        public NodePair(TreeNode node, int idx){\\n            this.node = node;\\n            this.idx = idx;\\n        }\\n    }\\n    \\n    public int widthOfBinaryTree(TreeNode root) {\\n        if(root == null)\\n            return 0;\\n        \\n        Queue<NodePair> queue = new LinkedList<>();\\n        queue.offer(new NodePair(root, 1));\\n        int maxWidth = 0;\\n        \\n        while(!queue.isEmpty()){\\n            NodePair firstNodePair = queue.peek();\\n            NodePair currentNodePair = null;\\n            int size = queue.size();\\n            while(size-- > 0){\\n                currentNodePair = queue.poll();\\n                if(currentNodePair.node.left != null)\\n                    queue.offer(new NodePair(currentNodePair.node.left, 2 * currentNodePair.idx));\\n                if(currentNodePair.node.right != null)\\n                    queue.offer(new NodePair(currentNodePair.node.right, 2 * currentNodePair.idx + 1));\\n            }\\n            maxWidth = Math.max(maxWidth, (currentNodePair.idx - firstNodePair.idx) + 1);\\n        }\\n        return maxWidth;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    \\n    class NodePair{\\n        TreeNode node;\\n        int idx;\\n        \\n        public NodePair(TreeNode node, int idx){\\n            this.node = node;\\n            this.idx = idx;\\n        }\\n    }\\n    \\n    public int widthOfBinaryTree(TreeNode root) {\\n        if(root == null)\\n            return 0;\\n        \\n        Queue<NodePair> queue = new LinkedList<>();\\n        queue.offer(new NodePair(root, 0));\\n        int maxWidth = 0;\\n        \\n        while(!queue.isEmpty()){\\n            NodePair firstNodePair = queue.peek();\\n            NodePair currentNodePair = null;\\n            int size = queue.size();\\n            while(size-- > 0){\\n                currentNodePair = queue.poll();\\n                if(currentNodePair.node.left != null)\\n                    queue.offer(new NodePair(currentNodePair.node.left, 2 * currentNodePair.idx + 1));\\n                if(currentNodePair.node.right != null)\\n                    queue.offer(new NodePair(currentNodePair.node.right, 2 * currentNodePair.idx + 2));\\n            }\\n            maxWidth = Math.max(maxWidth, (currentNodePair.idx - firstNodePair.idx) + 1);\\n        }\\n        return maxWidth;\\n    }\\n}\\n\\n---------------------------------------------------------------------------------------------------\\n```",
                "codeTag": "Java"
            },
            {
                "id": 651353,
                "title": "c-simple-solution-with-explanation-level-order",
                "content": "1. In general, when binary tree is represented in array we traverse to left and right using 2n and 2n+1 where n is the position of current element. \\n2. We use same idea, for every node we encounter we store its position in that level and also maintain prev and curr variables, containing left most node\\'s rank/position and right most node\\'s rank/position. \\n3. Finally when we are done processing all nodes at a given level and we got our left and right most nodes positions set to prev and curr then we find the width as (curr-prev+1) after each level. Since we have many levels, we have to keep maintaining the max answer after each level.\\n\\n```\\nclass Solution {\\npublic:\\n    int widthOfBinaryTree(TreeNode* root) \\n    {\\n        queue<pair<TreeNode*,double>> que; // using double because of a test case where it crosses limit of long long for levels more than 32\\n        double ans = 0;\\n        if(root==NULL)\\n            return ans;\\n        \\n        que.push({root,1}); \\n        while(!que.empty())\\n        {// level-order traversal\\n            int n = (int)que.size();\\n            double prev = 0;\\n            double curr = 0;\\n            while(n--)\\n            {\\n                pair<TreeNode*,double> temp = que.front();\\n                curr = temp.second;\\n                que.pop();\\n                if(temp.first->left!=NULL)\\n                    que.push({temp.first->left,2*temp.second-1});\\n                if(temp.first->right!=NULL)\\n                    que.push({temp.first->right,2*temp.second});\\n                if(prev==0) // For the first node in the queue, there is no prev so prev will be curr.\\n                    prev = curr;\\n            }\\n            ans = max(ans,curr-prev+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int widthOfBinaryTree(TreeNode* root) \\n    {\\n        queue<pair<TreeNode*,double>> que; // using double because of a test case where it crosses limit of long long for levels more than 32\\n        double ans = 0;\\n        if(root==NULL)\\n            return ans;\\n        \\n        que.push({root,1}); \\n        while(!que.empty())\\n        {// level-order traversal\\n            int n = (int)que.size();\\n            double prev = 0;\\n            double curr = 0;\\n            while(n--)\\n            {\\n                pair<TreeNode*,double> temp = que.front();\\n                curr = temp.second;\\n                que.pop();\\n                if(temp.first->left!=NULL)\\n                    que.push({temp.first->left,2*temp.second-1});\\n                if(temp.first->right!=NULL)\\n                    que.push({temp.first->right,2*temp.second});\\n                if(prev==0) // For the first node in the queue, there is no prev so prev will be curr.\\n                    prev = curr;\\n            }\\n            ans = max(ans,curr-prev+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 379454,
                "title": "full-explanation-100-beat-3-solution-thought-process-java",
                "content": "I\\'ll try to explain the approach step by step so that you can build the logic just like i build to solve this problem. We\\'ll look from most obvious thinking to optimized (100% beat).\\n\\n\\n\\n The obvious things comes in mind on seeing above question is Level order traversal.\\n\\n We can achieve above using modified level order traversal. In modification, we\\'ll push null nodes also in our queue.\\n Note that whenever you hit null node (the node don\\'t exist) as you poped node, you need to push two null node in queue to cover distance between leftmost and right most node\\n * *           1\\n * *          / \\\\\\n * *         3   2\\n * *        /     \\\\\\n * *       5       9\\n * *      /         \\\\\\n * *     6           7\\n\\n on the last level, there are 6 nulls in between 6 and 7.\\n\\n Hence when you iterating on current level, we need to build next level by pushing appropriate null nodes. Important fact here is, if we keep doing, then queue\\n will never empty (each null node push 2 more null node). Hence we need to pop those unnecessary null node from each level. For example\\n  * *           1\\n * *          / \\\\\\n * *         3   2\\n * *        /     \\\\\\n * *       5       9\\n * *       \\\\        \\\\\\n * *       6        7\\n\\n then at last level the queue would look like [null, 6, null, null, null, null, null, 7 ], since the first null node can\\'t be use to compute width, we need to remove it.\\n The same could happen on other side too.\\n Hence use deque.\\n\\n ```\\nAlgorithm:\\n 1. Push the first node in queue\\n 2. continue till its empty;\\n 2.1 Pop from front and see what is the length of queue, this will denote the current width of tree.\\n 2.2 build next level and get rid of null nodes\\n```\\n\\n Runtime: 36 ms, faster than 9.61% of Java online submissions for Maximum Width of Binary Tree.\\n Memory Usage: 49.8 MB, less than 11.11% of Java online submissions for Maximum Width of Binary Tree.\\n \\n ```\\n  public int widthOfBinaryTree(TreeNode root) {\\n\\n        if (null == root)\\n            return 0;\\n\\n        int maxWidth = 1;\\n\\n\\n        final Deque<TreeNode> deque = new LinkedList<>();\\n        deque.offerLast(root);\\n\\n        while (!deque.isEmpty()) {\\n\\n            int count = deque.size();\\n            //evaluate current level, build next level\\n            while (count > 0) {\\n                TreeNode current = deque.pollFirst();\\n\\n                if (current == null) {\\n                    deque.offerLast(null);\\n                    deque.offerLast(null);\\n                } else {\\n                    deque.offerLast(current.left);\\n                    deque.offerLast(current.right);\\n                }\\n                count--;\\n            }\\n\\n            //Fix left\\n            while (!deque.isEmpty() && deque.peekFirst() == null)\\n                deque.pollFirst();\\n\\n            //Fix right\\n            while (!deque.isEmpty() && deque.peekLast() == null)\\n                deque.pollLast();\\n\\n            int size = deque.size();\\n            maxWidth = Math.max(maxWidth, size);\\n        }\\n\\n        return maxWidth;\\n\\n\\n    }\\n ```\\n\\n\\n**Optimization**\\n\\n\\n\\n The width of binary tree solely depends on left most node and right most node.\\n\\n case 1: when there is only one node in tree : Width = 1\\n case 2: When tree has either left or right child : width = 1\\n case 3: when tree has both child then width  = 2\\n\\n Now in order to find the width of tree roted at node \\'root\\' we need to know the left most node and right most node of this root.\\n We know that in binary tree (like in heap), if root is at \\'i\\'th then left is on 2*i and right is on 2*i+1\\n We\\'ll use both as index.\\n\\n So for a tree has left and right node (assuming i=1) would be at left =2 and right =3 hence width = right - left + 1 = 2.\\n\\n\\n In order to find the max width, we need to keep track both left most node and right most node.\\n Or we can track only one and use current \\'i\\' to compute overall width.\\n\\n One more important aspect that the width of tree rooted at i having only a left and a right should be 1.\\n Means, at any depth, we just need to keep track on left most index.  { two node at same height }\\n \\n  * Runtime: 2 ms, faster than 38.25% of Java online submissions for Maximum Width of Binary Tree.\\n * Memory Usage: 36 MB, less than 100.00% of Java online submissions for Maximum Width of Binary Tree.\\n ```\\n public int widthOfBinaryTree(TreeNode root) {\\n\\n        if (null == root)\\n            return 0;\\n\\n        final int width[] = {0};\\n\\n        widthOfBinaryTree(root, width, 0, 1, new HashMap<>());\\n        return width[0];\\n\\n\\n    }\\n\\n    private void widthOfBinaryTree(TreeNode root, int[] width, int depth, int index, Map<Integer, Integer> map) {\\n\\n        if (null == root)\\n            return;\\n\\n\\n        //at current depth; only keep left most index. Since we\\'ll use left-root-right then first time we see this depth, then the index is\\n        //the leftmost\\n        if (!map.containsKey(depth))\\n            map.put(depth, index);\\n\\n        width[0] = Math.max(width[0], index - map.get(depth) + 1); //index will be like right, and at this depth what is the leftmost will be get from map\\n\\n        widthOfBinaryTree(root.left, width, depth + 1, 2 * index, map);\\n        widthOfBinaryTree(root.right, width, depth + 1, 2 * index + 1, map);\\n\\n\\n    }\\n ```\\n \\n**Optimization 2**: Beat 100% \\n\\n * Same as above, But instead of map, using list\\n * Runtime: 1 ms, faster than 100.00% of Java online submissions for Maximum Width of Binary Tree.\\n * Memory Usage: 36.4 MB, less than 100.00% of Java online submissions for Maximum Width of Binary Tree.\\n * \\n```\\n public int widthOfBinaryTree(TreeNode root) {\\n\\n        if (null == root)\\n            return 0;\\n\\n        final int width[] = {0};\\n\\n        widthOfBinaryTree(root, width, 0, 1, new ArrayList<>());\\n        return width[0];\\n\\n\\n    }\\n\\n    private void widthOfBinaryTree(TreeNode root, int[] width, int depth, int index, ArrayList<Integer> map) {\\n\\n        if (null == root)\\n            return;\\n\\n\\n        //at current depth; only keep left most index. Since we\\'ll use left-root-right then first time we see this depth, then the index is\\n        //the leftmost\\n        if (depth >= map.size())\\n            map.add(index);\\n\\n        width[0] = Math.max(width[0], index - map.get(depth) + 1); //index will be like right, and at this depth what is the leftmost will be get from map\\n\\n        widthOfBinaryTree(root.left, width, depth + 1, 2 * index, map);\\n        widthOfBinaryTree(root.right, width, depth + 1, 2 * index + 1, map);\\n\\n\\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```\\nAlgorithm:\\n 1. Push the first node in queue\\n 2. continue till its empty;\\n 2.1 Pop from front and see what is the length of queue, this will denote the current width of tree.\\n 2.2 build next level and get rid of null nodes\\n```\n```\\n  public int widthOfBinaryTree(TreeNode root) {\\n\\n        if (null == root)\\n            return 0;\\n\\n        int maxWidth = 1;\\n\\n\\n        final Deque<TreeNode> deque = new LinkedList<>();\\n        deque.offerLast(root);\\n\\n        while (!deque.isEmpty()) {\\n\\n            int count = deque.size();\\n            //evaluate current level, build next level\\n            while (count > 0) {\\n                TreeNode current = deque.pollFirst();\\n\\n                if (current == null) {\\n                    deque.offerLast(null);\\n                    deque.offerLast(null);\\n                } else {\\n                    deque.offerLast(current.left);\\n                    deque.offerLast(current.right);\\n                }\\n                count--;\\n            }\\n\\n            //Fix left\\n            while (!deque.isEmpty() && deque.peekFirst() == null)\\n                deque.pollFirst();\\n\\n            //Fix right\\n            while (!deque.isEmpty() && deque.peekLast() == null)\\n                deque.pollLast();\\n\\n            int size = deque.size();\\n            maxWidth = Math.max(maxWidth, size);\\n        }\\n\\n        return maxWidth;\\n\\n\\n    }\\n ```\n```\\n public int widthOfBinaryTree(TreeNode root) {\\n\\n        if (null == root)\\n            return 0;\\n\\n        final int width[] = {0};\\n\\n        widthOfBinaryTree(root, width, 0, 1, new HashMap<>());\\n        return width[0];\\n\\n\\n    }\\n\\n    private void widthOfBinaryTree(TreeNode root, int[] width, int depth, int index, Map<Integer, Integer> map) {\\n\\n        if (null == root)\\n            return;\\n\\n\\n        //at current depth; only keep left most index. Since we\\'ll use left-root-right then first time we see this depth, then the index is\\n        //the leftmost\\n        if (!map.containsKey(depth))\\n            map.put(depth, index);\\n\\n        width[0] = Math.max(width[0], index - map.get(depth) + 1); //index will be like right, and at this depth what is the leftmost will be get from map\\n\\n        widthOfBinaryTree(root.left, width, depth + 1, 2 * index, map);\\n        widthOfBinaryTree(root.right, width, depth + 1, 2 * index + 1, map);\\n\\n\\n    }\\n ```\n```\\n public int widthOfBinaryTree(TreeNode root) {\\n\\n        if (null == root)\\n            return 0;\\n\\n        final int width[] = {0};\\n\\n        widthOfBinaryTree(root, width, 0, 1, new ArrayList<>());\\n        return width[0];\\n\\n\\n    }\\n\\n    private void widthOfBinaryTree(TreeNode root, int[] width, int depth, int index, ArrayList<Integer> map) {\\n\\n        if (null == root)\\n            return;\\n\\n\\n        //at current depth; only keep left most index. Since we\\'ll use left-root-right then first time we see this depth, then the index is\\n        //the leftmost\\n        if (depth >= map.size())\\n            map.add(index);\\n\\n        width[0] = Math.max(width[0], index - map.get(depth) + 1); //index will be like right, and at this depth what is the leftmost will be get from map\\n\\n        widthOfBinaryTree(root.left, width, depth + 1, 2 * index, map);\\n        widthOfBinaryTree(root.right, width, depth + 1, 2 * index + 1, map);\\n\\n\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 149505,
                "title": "logical-thinking-with-java-code-beats-95-97",
                "content": "**Logical Thinking**\\nAccording to the problem description, \\n`width of tree` is the maximum width among all levels,\\n`width of level `is the length between non-null end nodes.\\nIt is inductive to apply **BFS Level Order Traversal**, however, how should we record the leftmost non-null node and the rightmost one?\\nWe may attach `position` information to each TreeNode, e.g., root in the position of 0.\\n\\n**Clear Java Code**\\n```\\n    public int widthOfBinaryTree(TreeNode root) {\\n\\n        if (root == null) {\\n            return 0;\\n        }\\n\\n        Queue<TreeNodeWithPosition> queue = new LinkedList<>();\\n        queue.offer(new TreeNodeWithPosition(root, 0, 0));\\n        int maxWidth = 0;\\n\\n        while (!queue.isEmpty()) {\\n            int sz = queue.size();\\n            int leftmost = Integer.MAX_VALUE, rightmost = Integer.MIN_VALUE;\\n            for (int i = 0; i < sz; i++) {\\n                TreeNodeWithPosition curNode = queue.poll();\\n                if (curNode.node != null) {\\n                    leftmost = Math.min(leftmost, curNode.position);\\n                    rightmost = Math.max(rightmost, curNode.position);\\n                    queue.offer(new TreeNodeWithPosition(curNode.node.left, 2 * curNode.position, curNode.depth + 1));\\n                    queue.offer(new TreeNodeWithPosition(curNode.node.right, 2 * curNode.position + 1, curNode.depth + 1));\\n                }\\n            }\\n            if (rightmost != Integer.MIN_VALUE && leftmost != Integer.MAX_VALUE) {\\n                int width = rightmost - leftmost + 1;\\n                maxWidth = Math.max(maxWidth, width);\\n            }\\n        }\\n\\n        return maxWidth;\\n    }\\n    \\n    class TreeNodeWithPosition {\\n        TreeNode node;\\n        int position;\\n        int depth;\\n\\n        public TreeNodeWithPosition(TreeNode node, int position, int depth) {\\n            this.node = node;\\n            this.position = position;\\n            this.depth = depth;\\n        }\\n    }\\n```\\n**I would appreciate your VOTE UP ;)**",
                "solutionTags": [],
                "code": "```\\n    public int widthOfBinaryTree(TreeNode root) {\\n\\n        if (root == null) {\\n            return 0;\\n        }\\n\\n        Queue<TreeNodeWithPosition> queue = new LinkedList<>();\\n        queue.offer(new TreeNodeWithPosition(root, 0, 0));\\n        int maxWidth = 0;\\n\\n        while (!queue.isEmpty()) {\\n            int sz = queue.size();\\n            int leftmost = Integer.MAX_VALUE, rightmost = Integer.MIN_VALUE;\\n            for (int i = 0; i < sz; i++) {\\n                TreeNodeWithPosition curNode = queue.poll();\\n                if (curNode.node != null) {\\n                    leftmost = Math.min(leftmost, curNode.position);\\n                    rightmost = Math.max(rightmost, curNode.position);\\n                    queue.offer(new TreeNodeWithPosition(curNode.node.left, 2 * curNode.position, curNode.depth + 1));\\n                    queue.offer(new TreeNodeWithPosition(curNode.node.right, 2 * curNode.position + 1, curNode.depth + 1));\\n                }\\n            }\\n            if (rightmost != Integer.MIN_VALUE && leftmost != Integer.MAX_VALUE) {\\n                int width = rightmost - leftmost + 1;\\n                maxWidth = Math.max(maxWidth, width);\\n            }\\n        }\\n\\n        return maxWidth;\\n    }\\n    \\n    class TreeNodeWithPosition {\\n        TreeNode node;\\n        int position;\\n        int depth;\\n\\n        public TreeNodeWithPosition(TreeNode node, int position, int depth) {\\n            this.node = node;\\n            this.position = position;\\n            this.depth = depth;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3881803,
                "title": "best-o-n-solution",
                "content": "# Approach\\nLevel Order Traversal\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int widthOfBinaryTree(TreeNode* root) {\\n        int maxWidth = 0;\\n        queue <pair<TreeNode*, long long>> q;\\n        q.push({root, 0});\\n        while (!q.empty()) {\\n            int size = q.size();\\n            long long cur = q.front().second;\\n            int leftmost, rightmost;\\n            for (int i = 0; i < size; i++) {\\n                TreeNode* node = q.front().first;\\n                long long num = q.front().second - cur;\\n                q.pop();\\n                if (i == 0) leftmost = num;\\n                if (i == size - 1) rightmost = num; \\n                if (node->left)\\n                    q.push({node->left, 2 * num + 1}); \\n                if (node->right)\\n                    q.push({node->right, 2 * num + 2});  \\n            }\\n            int curWidth = rightmost - leftmost + 1;\\n            maxWidth = max (curWidth, maxWidth);\\n        }    \\n        return maxWidth;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int widthOfBinaryTree(TreeNode* root) {\\n        int maxWidth = 0;\\n        queue <pair<TreeNode*, long long>> q;\\n        q.push({root, 0});\\n        while (!q.empty()) {\\n            int size = q.size();\\n            long long cur = q.front().second;\\n            int leftmost, rightmost;\\n            for (int i = 0; i < size; i++) {\\n                TreeNode* node = q.front().first;\\n                long long num = q.front().second - cur;\\n                q.pop();\\n                if (i == 0) leftmost = num;\\n                if (i == size - 1) rightmost = num; \\n                if (node->left)\\n                    q.push({node->left, 2 * num + 1}); \\n                if (node->right)\\n                    q.push({node->right, 2 * num + 2});  \\n            }\\n            int curWidth = rightmost - leftmost + 1;\\n            maxWidth = max (curWidth, maxWidth);\\n        }    \\n        return maxWidth;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3437894,
                "title": "bfs-python-easy-to-understand-simple-solution-beats-90",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBFS\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ndo bfs and count the nodes in order. root will be 0 and left is 2n+1\\nand right is 2n+2\\n\\nin each level of our BFS, if we see a node, we will append the node number to res array. \\n\\nwe can get the width at each level by takin the node number of rightmost in res subtract the node number of the leftmost in res.\\n\\nAfter each level we update the maxwidth if it is the largest width\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n![image.png](https://assets.leetcode.com/users/images/a567dfe4-66ab-4565-8d29-1853bda23047_1681991736.078584.png)\\nUpvote for cat plz\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def widthOfBinaryTree(self, root: Optional[TreeNode]) -> int:\\n        q = deque([(root, 0)])\\n        maxwidth = 0\\n        while q:\\n            res = []\\n            for i in range(len(q)):\\n                node, num = q.popleft()\\n                res.append(num)\\n                if node.left:\\n                    q.append((node.left, num*2+1))\\n                if node.right:\\n                    q.append((node.right, num*2+2))\\n            maxwidth = max(maxwidth, res[-1] - res[0] + 1)\\n        return maxwidth\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def widthOfBinaryTree(self, root: Optional[TreeNode]) -> int:\\n        q = deque([(root, 0)])\\n        maxwidth = 0\\n        while q:\\n            res = []\\n            for i in range(len(q)):\\n                node, num = q.popleft()\\n                res.append(num)\\n                if node.left:\\n                    q.append((node.left, num*2+1))\\n                if node.right:\\n                    q.append((node.right, num*2+2))\\n            maxwidth = max(maxwidth, res[-1] - res[0] + 1)\\n        return maxwidth\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3437877,
                "title": "java-binary-tree-maximum-width-of-binary-tree",
                "content": "\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public void addNode(LinkedList<TreeNode> queue, TreeNode node, int val, int left)\\n    {\\n        if (node == null) return;\\n        node.val = val * 2 - left;\\n        queue.add(node);\\n    }\\n\\n    public int bfs(LinkedList<TreeNode> queue)\\n    {\\n        int maxCount = 1;\\n        int size = 1;\\n        while (size > 0) {\\n            while (size-- > 0) {\\n                TreeNode node = queue.poll();\\n                addNode(queue, node.left, node.val, 1);\\n                addNode(queue, node.right,node.val, 0);\\n            }\\n            size = queue.size();\\n            if (size > 0)\\n                maxCount = Math.max(queue.getLast().val - queue.getFirst().val + 1, maxCount);\\n        }\\n        return maxCount;\\n    }\\n\\n    public int widthOfBinaryTree(TreeNode root) {\\n        LinkedList<TreeNode> queue = new LinkedList<>();\\n        if (root == null) return 0;\\n        root.val = 1;\\n        queue.offer(root);\\n        return bfs(queue);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public void addNode(LinkedList<TreeNode> queue, TreeNode node, int val, int left)\\n    {\\n        if (node == null) return;\\n        node.val = val * 2 - left;\\n        queue.add(node);\\n    }\\n\\n    public int bfs(LinkedList<TreeNode> queue)\\n    {\\n        int maxCount = 1;\\n        int size = 1;\\n        while (size > 0) {\\n            while (size-- > 0) {\\n                TreeNode node = queue.poll();\\n                addNode(queue, node.left, node.val, 1);\\n                addNode(queue, node.right,node.val, 0);\\n            }\\n            size = queue.size();\\n            if (size > 0)\\n                maxCount = Math.max(queue.getLast().val - queue.getFirst().val + 1, maxCount);\\n        }\\n        return maxCount;\\n    }\\n\\n    public int widthOfBinaryTree(TreeNode root) {\\n        LinkedList<TreeNode> queue = new LinkedList<>();\\n        if (root == null) return 0;\\n        root.val = 1;\\n        queue.offer(root);\\n        return bfs(queue);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3436773,
                "title": "java-runtime-1-ms-beats-100-memory-42-5-mb-beats-28-18",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Pair{\\n    int pos;\\n    TreeNode node;\\n    Pair(int x,TreeNode y){\\n        pos = x;\\n        node = y;\\n    }\\n}\\nclass Solution {\\n    public int widthOfBinaryTree(TreeNode root) {\\n        Queue<Pair> q = new LinkedList<>();\\n        q.offer(new Pair(0,root));\\n        int max = Integer.MIN_VALUE;\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            int start = 0;\\n            int end = 0;\\n            for(int i = 0 ; i < size; i ++){\\n                Pair p = q.poll();\\n                int pos = p.pos;\\n                TreeNode node = p.node;\\n                \\n                if(i == 0){\\n                    start = pos;\\n                }\\n                if(i == size -1){\\n                    end = pos;\\n                }\\n                if(node.left != null){\\n                    q.offer(new Pair(2*pos+1,node.left));\\n                }\\n                if(node.right != null){\\n                    q.offer(new Pair(2*pos+2,node.right));\\n                }\\n            }\\n            max = Math.max(max,end+1-start);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Pair{\\n    int pos;\\n    TreeNode node;\\n    Pair(int x,TreeNode y){\\n        pos = x;\\n        node = y;\\n    }\\n}\\nclass Solution {\\n    public int widthOfBinaryTree(TreeNode root) {\\n        Queue<Pair> q = new LinkedList<>();\\n        q.offer(new Pair(0,root));\\n        int max = Integer.MIN_VALUE;\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            int start = 0;\\n            int end = 0;\\n            for(int i = 0 ; i < size; i ++){\\n                Pair p = q.poll();\\n                int pos = p.pos;\\n                TreeNode node = p.node;\\n                \\n                if(i == 0){\\n                    start = pos;\\n                }\\n                if(i == size -1){\\n                    end = pos;\\n                }\\n                if(node.left != null){\\n                    q.offer(new Pair(2*pos+1,node.left));\\n                }\\n                if(node.right != null){\\n                    q.offer(new Pair(2*pos+2,node.right));\\n                }\\n            }\\n            max = Math.max(max,end+1-start);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3379476,
                "title": "100-faster-java-solution-step-by-step-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(N)\\n![Screenshot_20230205_171246.png](https://assets.leetcode.com/users/images/e93f7e05-183f-41bf-85b3-6fe503bd241c_1680616829.8403409.png)\\n\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    \\n    class Pair {\\n      \\n      TreeNode node; \\n      int num; \\n      Pair(TreeNode _node, int _num) {\\n        num = _num;\\n        node = _node; \\n      }\\n    }\\n\\n    public int widthOfBinaryTree(TreeNode root) {\\n      \\n      // If the root node is null, the tree is empty\\n      if(root == null){\\n        return 0;\\n      }\\n\\n    // Initialize the queue to store nodes of the tree\\n    Queue<Pair> q = new LinkedList<>();\\n\\n    // Add the root node to the queue with position 0\\n    q.offer(new Pair(root,0));\\n\\n    int ans = 0; // Initialize the width to 0\\n\\n    // Traverse the tree level by level\\n    while(!q.isEmpty()){\\n\\n      int size = q.size(); // Number of nodes in the current level\\n      int min = q.peek().num; // Minimum position of the nodes in the current level\\n\\n      int first = 0; // Position of the first node in the current level\\n      int last = 0; // Position of the last node in the current level\\n\\n      // Traverse all the nodes in the current level\\n      for(int i = 0; i < size; i++){\\n        int cur_id = q.peek().num-min; // Position of the current node\\n        TreeNode node = q.peek().node; // Current node\\n\\n        q.poll(); // Remove the current node from the queue\\n\\n        if(i == 0){ // If this is the first node of the level\\n          first = cur_id; // Update the position of the first node\\n        }\\n        if(i == size -1){ // If this is the last node of the level\\n          last = cur_id; // Update the position of the last node\\n        }\\n\\n        // Add the left child of the current node to the queue\\n        if(node.left != null){\\n          q.offer(new Pair(node.left, cur_id*2+1));\\n        }\\n\\n        // Add the right child of the current node to the queue\\n        if(node.right != null){\\n          q.offer(new Pair(node.right, cur_id*2+2));\\n        }\\n      }\\n\\n      // Calculate the width of the current level and update the maximum width\\n      ans = Math.max(ans,last - first + 1);\\n    }\\n\\n    // Return the maximum width of all the levels of the tree\\n    return ans;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    \\n    class Pair {\\n      \\n      TreeNode node; \\n      int num; \\n      Pair(TreeNode _node, int _num) {\\n        num = _num;\\n        node = _node; \\n      }\\n    }\\n\\n    public int widthOfBinaryTree(TreeNode root) {\\n      \\n      // If the root node is null, the tree is empty\\n      if(root == null){\\n        return 0;\\n      }\\n\\n    // Initialize the queue to store nodes of the tree\\n    Queue<Pair> q = new LinkedList<>();\\n\\n    // Add the root node to the queue with position 0\\n    q.offer(new Pair(root,0));\\n\\n    int ans = 0; // Initialize the width to 0\\n\\n    // Traverse the tree level by level\\n    while(!q.isEmpty()){\\n\\n      int size = q.size(); // Number of nodes in the current level\\n      int min = q.peek().num; // Minimum position of the nodes in the current level\\n\\n      int first = 0; // Position of the first node in the current level\\n      int last = 0; // Position of the last node in the current level\\n\\n      // Traverse all the nodes in the current level\\n      for(int i = 0; i < size; i++){\\n        int cur_id = q.peek().num-min; // Position of the current node\\n        TreeNode node = q.peek().node; // Current node\\n\\n        q.poll(); // Remove the current node from the queue\\n\\n        if(i == 0){ // If this is the first node of the level\\n          first = cur_id; // Update the position of the first node\\n        }\\n        if(i == size -1){ // If this is the last node of the level\\n          last = cur_id; // Update the position of the last node\\n        }\\n\\n        // Add the left child of the current node to the queue\\n        if(node.left != null){\\n          q.offer(new Pair(node.left, cur_id*2+1));\\n        }\\n\\n        // Add the right child of the current node to the queue\\n        if(node.right != null){\\n          q.offer(new Pair(node.right, cur_id*2+2));\\n        }\\n      }\\n\\n      // Calculate the width of the current level and update the maximum width\\n      ans = Math.max(ans,last - first + 1);\\n    }\\n\\n    // Return the maximum width of all the levels of the tree\\n    return ans;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2026613,
                "title": "help-wanted-bfs-solution-process-exited-with-signal-sigill",
                "content": "The solution is right, and straitforward.\\nUnfortunatly sometimes leetcode returns.\\n```\\nRuntime Error\\nprocess exited with signal SIGILL\\n```\\nfor this input:\\n[0,0,0,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null]\\n\\nIt is my solution, but I tested all other solution that were before accepted and get a Runtime Error for all of them.\\n```\\nclass Solution {\\n    \\n    func widthOfBinaryTree(_ root: TreeNode?) -> Int {\\n        guard let root = root else {\\n            return 0\\n        }\\n        \\n        var deque: [(TreeNode, Int)] = [(root, 1)]\\n        var maxWidth = 1\\n        \\n        \\n        while deque.count > 0 {\\n            let count = deque.count\\n            let (_, indexL) = deque.first!\\n            let (_, indexR) = deque.last!\\n            maxWidth = max(indexR - indexL + 1, maxWidth)\\n            \\n            for _ in 0..<count {\\n                let (node, index) = deque.removeFirst()\\n                if let left = node.left {\\n                    deque.append((left, index * 2))\\n                }\\n                if let right = node.right {\\n                    deque.append((right, index * 2 + 1))\\n                }\\n            }   \\n        }\\n        return maxWidth\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Breadth-First Search"
                ],
                "code": "```\\nRuntime Error\\nprocess exited with signal SIGILL\\n```\n```\\nclass Solution {\\n    \\n    func widthOfBinaryTree(_ root: TreeNode?) -> Int {\\n        guard let root = root else {\\n            return 0\\n        }\\n        \\n        var deque: [(TreeNode, Int)] = [(root, 1)]\\n        var maxWidth = 1\\n        \\n        \\n        while deque.count > 0 {\\n            let count = deque.count\\n            let (_, indexL) = deque.first!\\n            let (_, indexR) = deque.last!\\n            maxWidth = max(indexR - indexL + 1, maxWidth)\\n            \\n            for _ in 0..<count {\\n                let (node, index) = deque.removeFirst()\\n                if let left = node.left {\\n                    deque.append((left, index * 2))\\n                }\\n                if let right = node.right {\\n                    deque.append((right, index * 2 + 1))\\n                }\\n            }   \\n        }\\n        return maxWidth\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1804805,
                "title": "one-pass-c-beginner-friendly-bfs-in-disguise",
                "content": "There\\u2019s a standard bfs approach to this. What I did was that I recursively called the bfs function on each child, and numbered all the nodes in a map where the index was the depth inside the binary tree. The numbering should be done 2 * parent\\u2019s index if the node is a left child, and +1 if right child. The width would be right-left+1 maxed over all depths. The reason why didn\\u2019t we go with the conventional indices for the nodes (2p+1, 2p+2) is in case of skewed trees, our index of the leftmost child might overflow the values in int and long long. If we just take 2p, and p is zero for the root node, for the left children, we will always maintain a zero pointer. We can also subtract the minimum value at a given particular height since we are going in inorder fashion of traversal and only the difference matters for diameter. Here\\u2019s an implementation for the given solution. Also, I maintained the heights and corresponding labels in a map, you can even do a normal iterative bfs for the same.\\nPlease upvote if you liked it!\\n```\\nclass Solution {\\npublic:\\n    map<int, vector<int>> ht;\\n    \\n    void rec(TreeNode* root, long long x, int h)\\n    {//h is the height, x is label\\n        if(!root) return;\\n        \\n        if(ht.find(h) != ht.end()) ht[h].push_back(x);\\n        else\\n        {\\n            vector<int> p; p.push_back(x);\\n            ht.insert({h,p});\\n        }\\n\\n        int minh = *min_element(ht[h].begin(), ht[h].end());\\n        long long int t = 2*x-minh;\\n        rec(root->left, t+1, h+1);\\n        rec(root->right, t+2, h+1);\\n    }\\n    int widthOfBinaryTree(TreeNode* root) {\\n        long long int te = 0;\\n        rec(root, te, 0 );\\n        \\n        int ans = 0;\\n        for(auto it = ht.begin(); it != ht.end(); it++)\\n        {\\n            vector<int> t = it->second;\\n            int temp =  *max_element(t.begin(), t.end())-*min_element(t.begin(), t.end())+1;\\n            ans = (ans < temp)? temp : ans;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    map<int, vector<int>> ht;\\n    \\n    void rec(TreeNode* root, long long x, int h)\\n    {//h is the height, x is label\\n        if(!root) return;\\n        \\n        if(ht.find(h) != ht.end()) ht[h].push_back(x);\\n        else\\n        {\\n            vector<int> p; p.push_back(x);\\n            ht.insert({h,p});\\n        }\\n\\n        int minh = *min_element(ht[h].begin(), ht[h].end());\\n        long long int t = 2*x-minh;\\n        rec(root->left, t+1, h+1);\\n        rec(root->right, t+2, h+1);\\n    }\\n    int widthOfBinaryTree(TreeNode* root) {\\n        long long int te = 0;\\n        rec(root, te, 0 );\\n        \\n        int ans = 0;\\n        for(auto it = ht.begin(); it != ht.end(); it++)\\n        {\\n            vector<int> t = it->second;\\n            int temp =  *max_element(t.begin(), t.end())-*min_element(t.begin(), t.end())+1;\\n            ans = (ans < temp)? temp : ans;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1803613,
                "title": "python-3-bfs-and-dfs-solutions-and-explanation",
                "content": "**\\uD83D\\uDC46Please UPVOTE it if you find my soulutions are useful \\uD83D\\uDC46 Feel free to ask any question**\\n# \\uD83C\\uDF1F[Python 3] BFS and DFS Solutions and Explanation \\uD83D\\uDC95\\n\\n## 1\\uFE0F\\u20E3 BFS Approach:\\nBecause we want return maximum width of the binary tree, so we use BFS to iterate through level by level. And every time we pass its idx in that level.\\n* **leftChildIdx = parentIdx * 2, rightChildIdx = parentIdx * 2 + 1**\\n```\\n# Indexed level by level\\n        0\\n      /    \\\\\\n    0        1\\n  /  \\\\     /   \\\\\\n0    1    2      3\\n```\\n\\nWe will append child from left to right at every level, so we can make sure queue[0] and queue[-1] are left and right most node.\\nAnd once we append all child to nextLevelQueue, we then iterate nextLevelQueue to find maximum width.\\n\\n## Complexity Analysis\\n* Time: O(N) : We use BFS to traverse whole tree.\\n* Space: O(N) : There are at worst N // 2 nodes at final level => O(N)\\n## BFS Code\\n```\\n# BFS Solution O(N) | O(N)\\nclass Solution:\\n    def widthOfBinaryTree(self, root: Optional[TreeNode]) -> int:\\n        # Each index in queue store node and its index in its level\\n        queue = [(root, 0)]\\n        maxLength = 1\\n        while queue:\\n            nextLevelQueue = []\\n            # Calculate leftMost and rightMost node\\n            leftMost, rightMost = queue[0][1], queue[-1][1]\\n            maxLength = max(maxLength, rightMost - leftMost + 1)\\n            \\n            # Append next level\\'s node into new queue\\n            for currNode, idx in queue:\\n                # If left, right child exist: append it and its idx\\n                if currNode.left:\\n                    nextLevelQueue.append((currNode.left, idx * 2))\\n                if currNode.right:\\n                    nextLevelQueue.append((currNode.right, idx * 2 + 1))\\n            # Replace queue to nextLevelQueue\\n            queue = nextLevelQueue\\n        return maxLength\\n\\n```\\n\\n## 2\\uFE0F\\u20E3 DFS Naive Approach:\\nBFS Solution may seem intuitive for this question. But we can also use DFS to solve this question as well.\\n\\n1. **Init HashMap**\\n\\t* We use levelHash to store leftMost and rightMost index at certain level\\n\\t* Once we traverse through whole tree we can simply itreate through levelHash to find maximum width\\n\\n2. **Make DFS Call**\\n\\t* Every time we recursive call dfs function, we also have to pass in its **index and level** to update levelHash\\n3. **Find max width**\\n\\t* Iterate through levelHash\\'s values to find maximum width and return\\n\\n## Complexity Analysis\\n* Time: O(N) :  1. We use DFS to traverse whole tree => O(N) | 2. Iterate through levelHash update maxLength => O(N). So its O(N)\\n* Space: O(N) : levelHash and recursive call at worst take O(N) (Skewed binary tree)\\n## DFS Code\\n```\\n# DFS Soultion O(N) | O(N)\\nclass Solution:\\n    def widthOfBinaryTree(self, root: Optional[TreeNode]) -> int:\\n        # Make hashMap level = [leftMost, rightMost]\\n        levelHash = {}\\n        self.dfs(root, 0, 0, levelHash)\\n        maxLength = 0\\n        for leftMost, rightMost in levelHash.values():\\n            maxLength = max(maxLength, rightMost - leftMost + 1)\\n        return maxLength\\n        \\n        \\n    def dfs(self, node, idx, level, levelHash):\\n        if node is None:\\n            return\\n        if level not in levelHash:\\n            # Make level = [leftMost, rightMost]\\n            levelHash[level] = [idx, idx]\\n        else:\\n            if idx < levelHash[level][0]:\\n                levelHash[level][0] = idx\\n            if idx > levelHash[level][1]:\\n                levelHash[level][1] = idx\\n                \\n        # Search left and right\\n        self.dfs(node.left, idx * 2, level + 1, levelHash)\\n        self.dfs(node.right, idx * 2 + 1, level + 1, levelHash)\\n```\\n\\n## 3\\uFE0F\\u20E3 Optimal DFS Approach:\\n* Since we use preorder traverse. It\\'s guarantee that the first node we meet at its level would be leftMost. \\nSo we make maxLength = max(maxLength, idx - levelHash[level] + 1)\\n\\n## Complexity Analysis\\n* Time: O(N) :  1. We use DFS to traverse whole tree => O(N) | 2. Iterate through levelHash update maxLength => O(N). So its O(N)\\n* Space: O(N) : Still O(N) but **only store leftMost** idx in levelHash\\n\\n## DFS Optimal Code\\n```\\n# DFS Optimal Soultion O(N) | O(N)\\nclass Solution:\\n    def widthOfBinaryTree(self, root: Optional[TreeNode]) -> int:\\n        # Make hashMap level = [leftMost, rightMost]\\n        levelHash = {}\\n        maxLength = 1\\n        def dfs(node, idx, level):\\n            nonlocal maxLength\\n            if node is None:\\n                return\\n            # Since we search left child fist, It\\'s guarantee that the first node we meet at its level would be leftMost\\n            if level not in levelHash:\\n                # Make level = leftMost idx\\n                levelHash[level] = idx\\n            else:\\n                # Update maxLength\\n                maxLength = max(maxLength, idx - levelHash[level] + 1)\\n\\t\\t\\t\\t\\n            # Search left and right\\n            dfs(node.left, idx * 2, level + 1)\\n            dfs(node.right, idx * 2 + 1, level + 1)\\n        dfs(root, 0, 0)\\n        return maxLength\\n```\\n\\n* See more 2022 Daily Challenge Solution : [GitHub](https://github.com/gcobs0834/2022-Daily-LeetCoding-Challenge-python3-)",
                "solutionTags": [
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\n# Indexed level by level\\n        0\\n      /    \\\\\\n    0        1\\n  /  \\\\     /   \\\\\\n0    1    2      3\\n```\n```\\n# BFS Solution O(N) | O(N)\\nclass Solution:\\n    def widthOfBinaryTree(self, root: Optional[TreeNode]) -> int:\\n        # Each index in queue store node and its index in its level\\n        queue = [(root, 0)]\\n        maxLength = 1\\n        while queue:\\n            nextLevelQueue = []\\n            # Calculate leftMost and rightMost node\\n            leftMost, rightMost = queue[0][1], queue[-1][1]\\n            maxLength = max(maxLength, rightMost - leftMost + 1)\\n            \\n            # Append next level\\'s node into new queue\\n            for currNode, idx in queue:\\n                # If left, right child exist: append it and its idx\\n                if currNode.left:\\n                    nextLevelQueue.append((currNode.left, idx * 2))\\n                if currNode.right:\\n                    nextLevelQueue.append((currNode.right, idx * 2 + 1))\\n            # Replace queue to nextLevelQueue\\n            queue = nextLevelQueue\\n        return maxLength\\n\\n```\n```\\n# DFS Soultion O(N) | O(N)\\nclass Solution:\\n    def widthOfBinaryTree(self, root: Optional[TreeNode]) -> int:\\n        # Make hashMap level = [leftMost, rightMost]\\n        levelHash = {}\\n        self.dfs(root, 0, 0, levelHash)\\n        maxLength = 0\\n        for leftMost, rightMost in levelHash.values():\\n            maxLength = max(maxLength, rightMost - leftMost + 1)\\n        return maxLength\\n        \\n        \\n    def dfs(self, node, idx, level, levelHash):\\n        if node is None:\\n            return\\n        if level not in levelHash:\\n            # Make level = [leftMost, rightMost]\\n            levelHash[level] = [idx, idx]\\n        else:\\n            if idx < levelHash[level][0]:\\n                levelHash[level][0] = idx\\n            if idx > levelHash[level][1]:\\n                levelHash[level][1] = idx\\n                \\n        # Search left and right\\n        self.dfs(node.left, idx * 2, level + 1, levelHash)\\n        self.dfs(node.right, idx * 2 + 1, level + 1, levelHash)\\n```\n```\\n# DFS Optimal Soultion O(N) | O(N)\\nclass Solution:\\n    def widthOfBinaryTree(self, root: Optional[TreeNode]) -> int:\\n        # Make hashMap level = [leftMost, rightMost]\\n        levelHash = {}\\n        maxLength = 1\\n        def dfs(node, idx, level):\\n            nonlocal maxLength\\n            if node is None:\\n                return\\n            # Since we search left child fist, It\\'s guarantee that the first node we meet at its level would be leftMost\\n            if level not in levelHash:\\n                # Make level = leftMost idx\\n                levelHash[level] = idx\\n            else:\\n                # Update maxLength\\n                maxLength = max(maxLength, idx - levelHash[level] + 1)\\n\\t\\t\\t\\t\\n            # Search left and right\\n            dfs(node.left, idx * 2, level + 1)\\n            dfs(node.right, idx * 2 + 1, level + 1)\\n        dfs(root, 0, 0)\\n        return maxLength\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1307721,
                "title": "java-1ms-dfs-solution-checking-width-of-each-level",
                "content": "PS : I am learning and trying to help the community ! This is not the best solution out there, but just my approach to this question. Feel free to give your suggestions or correct me in the comments \\uD83D\\uDE42. Thanks for reading.\\n\\nHere I am dividing the tree into left and right subtrees, the left subtree all have negative indexing and the right subtrees have positive indexing.\\nSince the null nodes are to be counted too, I am assuming that this is a full binary tree, which allows me too find the index of any particlar node\\'s left and right children.\\n\\n![image](https://assets.leetcode.com/users/images/a357ec53-1e42-4e87-aacd-2b8e56abcea6_1625081048.083926.jpeg)\\n\\n\\n```\\nclass Solution {\\n    \\n    ArrayList<Integer> left = new ArrayList<Integer>();\\n    ArrayList<Integer> right = new ArrayList<Integer>();\\n    \\n    public void solve(int width, int depth, TreeNode root) {\\n        \\n        if (root == null)\\n            return;\\n        \\n        if (depth >= right.size())\\n        {\\n            right.add(width);\\n        }\\n        else\\n        {\\n            int curVal = right.get(depth);\\n            curVal = Math.max(curVal, width);\\n            right.set(depth, curVal);\\n        }\\n        \\n        if (depth >= left.size())\\n        {\\n            left.add(width);\\n        }\\n        else\\n        {\\n            int curVal = left.get(depth);\\n            curVal = Math.min(curVal, width);\\n            left.set(depth, curVal);\\n        }\\n        \\n        int nodes = Math.abs(width) - 1;\\n        int leftWidth = -1; int rightWidth = 1;\\n        \\n        if (width < 0)\\n        {\\n            leftWidth = -nodes*2 - 2;\\n            rightWidth = -nodes*2 - 1;\\n        }\\n        \\n        else if (width > 0)\\n        {\\n            leftWidth = nodes*2 + 1;\\n            rightWidth = nodes*2 + 2;\\n        }\\n            \\n        solve(leftWidth, depth+1, root.left);\\n        solve(rightWidth, depth+1, root.right);\\n    }\\n    \\n    public int widthOfBinaryTree(TreeNode root) {\\n        \\n        if (root.left == null && root.right == null)\\n            return 1;\\n        \\n        solve(0, 0, root);\\n\\n        int max = 0;\\n        \\n        for(int idx = 0; idx < left.size(); idx++)\\n        {   \\n            int rightIdx = right.get(idx);\\n            int leftIdx = left.get(idx);\\n            \\n            if ((rightIdx < 0 && leftIdx < 0) || (rightIdx > 0 && leftIdx > 0))\\n            {\\n                max = Math.max(max, rightIdx - leftIdx +1);\\n            }\\n            \\n            else\\n            {\\n                max = Math.max(max, rightIdx - leftIdx);\\n            }\\n        }\\n        \\n        left = new ArrayList<Integer>();\\n        right = new ArrayList<Integer>();\\n        \\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    \\n    ArrayList<Integer> left = new ArrayList<Integer>();\\n    ArrayList<Integer> right = new ArrayList<Integer>();\\n    \\n    public void solve(int width, int depth, TreeNode root) {\\n        \\n        if (root == null)\\n            return;\\n        \\n        if (depth >= right.size())\\n        {\\n            right.add(width);\\n        }\\n        else\\n        {\\n            int curVal = right.get(depth);\\n            curVal = Math.max(curVal, width);\\n            right.set(depth, curVal);\\n        }\\n        \\n        if (depth >= left.size())\\n        {\\n            left.add(width);\\n        }\\n        else\\n        {\\n            int curVal = left.get(depth);\\n            curVal = Math.min(curVal, width);\\n            left.set(depth, curVal);\\n        }\\n        \\n        int nodes = Math.abs(width) - 1;\\n        int leftWidth = -1; int rightWidth = 1;\\n        \\n        if (width < 0)\\n        {\\n            leftWidth = -nodes*2 - 2;\\n            rightWidth = -nodes*2 - 1;\\n        }\\n        \\n        else if (width > 0)\\n        {\\n            leftWidth = nodes*2 + 1;\\n            rightWidth = nodes*2 + 2;\\n        }\\n            \\n        solve(leftWidth, depth+1, root.left);\\n        solve(rightWidth, depth+1, root.right);\\n    }\\n    \\n    public int widthOfBinaryTree(TreeNode root) {\\n        \\n        if (root.left == null && root.right == null)\\n            return 1;\\n        \\n        solve(0, 0, root);\\n\\n        int max = 0;\\n        \\n        for(int idx = 0; idx < left.size(); idx++)\\n        {   \\n            int rightIdx = right.get(idx);\\n            int leftIdx = left.get(idx);\\n            \\n            if ((rightIdx < 0 && leftIdx < 0) || (rightIdx > 0 && leftIdx > 0))\\n            {\\n                max = Math.max(max, rightIdx - leftIdx +1);\\n            }\\n            \\n            else\\n            {\\n                max = Math.max(max, rightIdx - leftIdx);\\n            }\\n        }\\n        \\n        left = new ArrayList<Integer>();\\n        right = new ArrayList<Integer>();\\n        \\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1025145,
                "title": "javascript-nan-you-need-to-mod-2-32-or-use-bigint",
                "content": "Just fyi, only for Javascripters\\n\\n```javascript\\nfunction dfs (node, level = 0, levelIndex = [], index = 0) {\\n\\tif (!node) return 0;\\n\\tif (!levelIndex[level]) levelIndex[level] = index;\\n\\n\\treturn Math.max(\\n\\t\\tindex - levelIndex[level] + 1,\\n\\t\\tdfs(node.left, level + 1, levelIndex, (index * 2 + 1) % 2**32),\\n\\t\\tdfs(node.right, level + 1, levelIndex, (index * 2 + 2) % 2**32)\\n\\t);\\n}\\n```",
                "solutionTags": [],
                "code": "```javascript\\nfunction dfs (node, level = 0, levelIndex = [], index = 0) {\\n\\tif (!node) return 0;\\n\\tif (!levelIndex[level]) levelIndex[level] = index;\\n\\n\\treturn Math.max(\\n\\t\\tindex - levelIndex[level] + 1,\\n\\t\\tdfs(node.left, level + 1, levelIndex, (index * 2 + 1) % 2**32),\\n\\t\\tdfs(node.right, level + 1, levelIndex, (index * 2 + 2) % 2**32)\\n\\t);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 737257,
                "title": "c-detailed-level-order-traversal",
                "content": "```\\n/*\\nidea---\\n1.do level order traversal\\n2.just counting the nodes isnt enough.the number of non null nodes between leftmost and rightmost non null node is insignificant.we only care about the leftmost and rightmost non null node.but we obviously have to explore all  nodes in that level since they could contribute the leftmost or rightmost null node of the next level.\\n*******3(a).a very special system of indexing trees-->>roots\\'s index=0.\\n*******3(b).left child=2*(index of parent),right child=2*i+1.\\ndraw and check,the indexing solves 90% of the problem\\n4.now explore each level...first element in the queue would be left most element and last element(the one we explore last) would be rightmost\\n5.we put a child into the queue only if it is not null.as we are looking for the left most and right most non-null node.also to do level order traversal we can only add non null nodes into the queue\\n6.just keep tag of the max width\\n\\n*/\\n\\nclass Solution {\\npublic:\\n    int widthOfBinaryTree(TreeNode* root) {\\n        queue<pair<TreeNode*,unsigned long long>> q;\\n        if(!root)\\n            return 0;\\n        q.push({root,0});\\n        unsigned long long ret=0;\\n        while(!q.empty())\\n        {\\n            auto fir=q.front();\\n            int si=q.size();\\n            auto curr=q.front();\\n            for(int i=0;i<si;i++)\\n            {\\n                curr=q.front();\\n                unsigned long long ind=curr.second;\\n                q.pop();\\n                if(curr.first->left)\\n                    q.push({curr.first->left,2*ind});\\n                if(curr.first->right)\\n                    q.push({curr.first->right,2*ind+1});\\n            }\\n            ret=max(ret,curr.second-fir.second+1);\\n        }\\n        return ret;;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int widthOfBinaryTree(TreeNode* root) {\\n        queue<pair<TreeNode*,unsigned long long>> q;\\n        if(!root)\\n            return 0;\\n        q.push({root,0}",
                "codeTag": "Java"
            },
            {
                "id": 727201,
                "title": "a-few-solutions",
                "content": "The general strategy is to uniquely identify each node with an <u>*absolute* i<sup>th</sup> index value</u>:\\n\\n**If the parent is `i`, then:**\\n* left-child is `2 * i + 1`\\n* right-child is `2 * i + 2`\\n\\n**\"How to avoid integer overflow?\"**\\n\\nBy using a <u>*relative* i<sup>th</sup> index value</u>  based upon the <u>*minimum* i<sup>th</sup> index value</u> per `depth`.\\n* Let `m` be a map which stores each minimum value per `depth`.\\n\\n**If the parent is `i`, then:**\\n* left-child is `2 * (i - m[depth]) + 1`\\n* right-child is `2 * (i - m[depth]) + 2`\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun widthOfBinaryTree(root: TreeNode?): Int {\\n        var best = 0L\\n        var m = mutableMapOf<Int, Long>()\\n        fun go(node: TreeNode? = root, depth: Int = 0, i: Long = 0) {\\n            if (node == null)\\n                return\\n            if (!m.contains(depth))\\n                m[depth] = i\\n            best = Math.max(best, i - m[depth]!! + 1)\\n            go(node?.left, depth + 1, 2 * (i - m[depth]!!) + 1)\\n            go(node?.right, depth + 1, 2 * (i - m[depth]!!) + 2)\\n        }\\n        go()\\n        return best.toInt()\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet widthOfBinaryTree = (root, m = new Map(), best = 0) => {\\n    let go = (node = root, depth = 0, i = 0) => {\\n        if (!node)\\n            return;\\n        if (!m.has(depth))\\n            m.set(depth, i);\\n        best = Math.max(best, i - m.get(depth) + 1);\\n        go(node.left, depth + 1, 2 * (i - m.get(depth)) + 1);\\n        go(node.right, depth + 1, 2 * (i - m.get(depth)) + 2);\\n    };\\n    go();\\n    return best;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def widthOfBinaryTree(self, root: Optional[TreeNode], best = 0) -> int:\\n        m = defaultdict(list)\\n        def go(node = root, depth = 0, i = 0):\\n            nonlocal best\\n            if not node:\\n                return\\n            if depth not in m:\\n                m[depth] = i\\n            best = max(best, i - m[depth] + 1)\\n            go(node.left, depth + 1, 2 * (i - m[depth]) + 1)\\n            go(node.right, depth + 1, 2 * (i - m[depth]) + 2)\\n        go()\\n        return best\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using LL = long long;\\n    using fun = function<void(TreeNode*, int, LL)>;\\n    using Map = unordered_map<int, LL>;\\n    int widthOfBinaryTree(TreeNode* root, Map m = {}, LL best = 0) {\\n        fun go = [&](auto node, auto depth, auto i) {\\n            if (!node)\\n                return;\\n            if (m.find(depth) == m.end())\\n                m[depth] = i;\\n            best = max(best, i - m[depth] + 1);\\n            go(node->left, depth + 1, 2 * (i - m[depth]) + 1);\\n            go(node->right, depth + 1, 2 * (i - m[depth]) + 2);\\n        };\\n        go(root, 0, 0);\\n        return best;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun widthOfBinaryTree(root: TreeNode?): Int {\\n        var best = 0L\\n        var m = mutableMapOf<Int, Long>()\\n        fun go(node: TreeNode? = root, depth: Int = 0, i: Long = 0) {\\n            if (node == null)\\n                return\\n            if (!m.contains(depth))\\n                m[depth] = i\\n            best = Math.max(best, i - m[depth]!! + 1)\\n            go(node?.left, depth + 1, 2 * (i - m[depth]!!) + 1)\\n            go(node?.right, depth + 1, 2 * (i - m[depth]!!) + 2)\\n        }\\n        go()\\n        return best.toInt()\\n    }\\n}\\n```\n```\\nlet widthOfBinaryTree = (root, m = new Map(), best = 0) => {\\n    let go = (node = root, depth = 0, i = 0) => {\\n        if (!node)\\n            return;\\n        if (!m.has(depth))\\n            m.set(depth, i);\\n        best = Math.max(best, i - m.get(depth) + 1);\\n        go(node.left, depth + 1, 2 * (i - m.get(depth)) + 1);\\n        go(node.right, depth + 1, 2 * (i - m.get(depth)) + 2);\\n    };\\n    go();\\n    return best;\\n};\\n```\n```\\nclass Solution:\\n    def widthOfBinaryTree(self, root: Optional[TreeNode], best = 0) -> int:\\n        m = defaultdict(list)\\n        def go(node = root, depth = 0, i = 0):\\n            nonlocal best\\n            if not node:\\n                return\\n            if depth not in m:\\n                m[depth] = i\\n            best = max(best, i - m[depth] + 1)\\n            go(node.left, depth + 1, 2 * (i - m[depth]) + 1)\\n            go(node.right, depth + 1, 2 * (i - m[depth]) + 2)\\n        go()\\n        return best\\n```\n```\\nclass Solution {\\npublic:\\n    using LL = long long;\\n    using fun = function<void(TreeNode*, int, LL)>;\\n    using Map = unordered_map<int, LL>;\\n    int widthOfBinaryTree(TreeNode* root, Map m = {}, LL best = 0) {\\n        fun go = [&](auto node, auto depth, auto i) {\\n            if (!node)\\n                return;\\n            if (m.find(depth) == m.end())\\n                m[depth] = i;\\n            best = max(best, i - m[depth] + 1);\\n            go(node->left, depth + 1, 2 * (i - m[depth]) + 1);\\n            go(node->right, depth + 1, 2 * (i - m[depth]) + 2);\\n        };\\n        go(root, 0, 0);\\n        return best;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 688259,
                "title": "python-solution-o-n-bfs-traversal",
                "content": "```\\nclass Solution:\\n    def widthOfBinaryTree(self, root: TreeNode) -> int:\\n        Q = collections.deque()\\n        Q.append((root,0))\\n        ans = 0\\n        while Q:\\n            length = len(Q)\\n            _, start = Q[0]\\n            for i in range(length):\\n                node, index = Q.popleft()\\n                if node.left:\\n                    Q.append((node.left, 2*index))\\n                if node.right:\\n                    Q.append((node.right, 2*index+1))\\n            ans = max(ans, index-start+1)\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def widthOfBinaryTree(self, root: TreeNode) -> int:\\n        Q = collections.deque()\\n        Q.append((root,0))\\n        ans = 0\\n        while Q:\\n            length = len(Q)\\n            _, start = Q[0]\\n            for i in range(length):\\n                node, index = Q.popleft()\\n                if node.left:\\n                    Q.append((node.left, 2*index))\\n                if node.right:\\n                    Q.append((node.right, 2*index+1))\\n            ans = max(ans, index-start+1)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 559139,
                "title": "straightforward-java-solution-beats-90-o-n-time-o-n-space",
                "content": "Since the value of the treenode is irrelevant to our problem, we can change the value to represent treenode\\'s horizontal position, e.g. one node\\'s value is set to x, its left child(if exists) will contain the value 2x - 1 and right child(if exists) 2x. And the root node\\'s value is set to 1 at the beginning.\\n```\\nclass Solution {\\n    public int widthOfBinaryTree(TreeNode root) {\\n        if (root == null) return 0;\\n        root.val = 1;\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.offer(root);\\n        int maxWidth = 1;\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            int left = q.peek().val;\\n            int right = left;\\n            for (int i = 0; i < size; i++){\\n                root = q.poll();\\n                if (root.val > right) right = root.val;\\n                if (root.left != null) {\\n                    root.left.val = root.val * 2 - 1;\\n                    q.offer(root.left);\\n                }\\n                if (root.right != null){\\n                    root.right.val = root.val * 2;\\n                    q.offer(root.right);\\n                }\\n            }\\n            if ((right - left + 1) > maxWidth) maxWidth = right - left + 1;\\n        }\\n        return maxWidth;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int widthOfBinaryTree(TreeNode root) {\\n        if (root == null) return 0;\\n        root.val = 1;\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.offer(root);\\n        int maxWidth = 1;\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            int left = q.peek().val;\\n            int right = left;\\n            for (int i = 0; i < size; i++){\\n                root = q.poll();\\n                if (root.val > right) right = root.val;\\n                if (root.left != null) {\\n                    root.left.val = root.val * 2 - 1;\\n                    q.offer(root.left);\\n                }\\n                if (root.right != null){\\n                    root.right.val = root.val * 2;\\n                    q.offer(root.right);\\n                }\\n            }\\n            if ((right - left + 1) > maxWidth) maxWidth = right - left + 1;\\n        }\\n        return maxWidth;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 522034,
                "title": "javascript-bfs-solution-that-handles-32-bit-overflow-testcase",
                "content": "I was a bit annoyed by the fact that both the prompt and the provided solution didn\\'t mention the solution needed to handle values over 32-bit integers. JavaScript gets a bit funky at these levels so extra steps need to be taken to ensure these extreme cases don\\'t return an error value:\\n\\n```\\nvar widthOfBinaryTree = function(root) {\\n    if (root == null) return 0;\\n\\n    let queue = [[root, 0, 0]];\\n    let curDepth = left = maxWidth = 0;\\n    \\n    while (queue.length) {\\n        const [node, depth, col] = queue.shift();\\n        \\n        if (node.left) {\\n            queue.push([node.left, depth+1, 2*col])\\n        }\\n        \\n        if (node.right) {\\n            queue.push([node.right, depth+1, 2*col+1])\\n        }\\n        \\n        if (curDepth != depth) {\\n            curDepth = depth;\\n            left = col;\\n        }\\n        \\n        maxWidth = Math.max((col-left+1) || 1, maxWidth);\\n    }\\n    \\n    return maxWidth;\\n};\\n```\\n\\nThe key here to handlng 32-bit overflow is the following line:\\n```\\nmaxWidth = Math.max((col-left+1) || 1, maxWidth);\\n```\\n\\nBasically, for any new node we check if its distance from the starting value + 1 is greater than the current maxWidth. However, at larger values (col-left+1) becomes NaN, which curiously in JavaScript is considered a higher value than a number. The key to solving this issue is to short-circuit any value that returns NaN with 1. We know that any node will represent at least one width value at a given depth which is the reasoning behind this. \\n\\nThis unfortunately does not correctly handle situations where there is more than one value at a given depth over the 32-bit range. This is one of those situations where you just have to build a solution to the test cases.",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search"
                ],
                "code": "```\\nvar widthOfBinaryTree = function(root) {\\n    if (root == null) return 0;\\n\\n    let queue = [[root, 0, 0]];\\n    let curDepth = left = maxWidth = 0;\\n    \\n    while (queue.length) {\\n        const [node, depth, col] = queue.shift();\\n        \\n        if (node.left) {\\n            queue.push([node.left, depth+1, 2*col])\\n        }\\n        \\n        if (node.right) {\\n            queue.push([node.right, depth+1, 2*col+1])\\n        }\\n        \\n        if (curDepth != depth) {\\n            curDepth = depth;\\n            left = col;\\n        }\\n        \\n        maxWidth = Math.max((col-left+1) || 1, maxWidth);\\n    }\\n    \\n    return maxWidth;\\n};\\n```\n```\\nmaxWidth = Math.max((col-left+1) || 1, maxWidth);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 359700,
                "title": "t-100-s-100-solution-and-complexities-explained",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public int widthOfBinaryTree(TreeNode root) {\\n        \\n        if(root == null)\\n            return 0;\\n            \\n        Deque<TreeNode> q = new LinkedList<TreeNode>();\\n        int max = 1;\\n        root.val = 1;\\n        q.offer(root);\\n        \\n        while(!q.isEmpty()) {\\n            int levelSize = q.size();\\n\\n            if(levelSize>=2)\\n                max = Math.max(max, q.peekLast().val - q.peekFirst().val + 1);\\n\\n            for(int i=0; i<levelSize; i++) {\\n                TreeNode node = q.poll();\\n                \\n                if(node.left!=null) {\\n                    node.left.val = 2 * node.val;\\n                    q.offer(node.left);\\n                }\\n                \\n                if(node.right!=null) {\\n                    node.right.val = 2 * node.val + 1;\\n                    q.offer(node.right);\\n                }\\n               \\n            }\\n        }\\n        return max;\\n    }\\n}\\n```\\n\\n**Algorithm Design**\\nWe need to find the maximum width at any level, where width is the difference of non-null right and left child indexes at any level.\\n\\nIn a compete binary tree left child = 2^h,, right child = 2^h + 1.\\nor we can say \\n- Left Child = 2 * parent node\\n- Right Child = 2 * parent node + 1\\n\\nSo,\\nStep 1 : Do a level order traversal\\nStep 2 : Traverse the nodes using DFS.\\nStep 3 : Update the value of each node as :\\n\\n* * Left Child = 2 * parent node\\n* * Right Child = 2 * parent node + 1. \\n\\nStep 4 : Count the difference b/w the right and the left child value.\\nStep 5 : Compute max at each point.\\n**Explanation**\\n*Step 1 :To do a level order traversal, we will be using DFS*\\nWe will be using a de-queue to do this traversal - as we can easily access the first and last node of a deque.\\n*Step 2 : Traverse the nodes, DFS*\\n        `while(!q.isEmpty())`\\nThis way we will keep going to the end of each array.\\nWe are also keeping a count of number of nodes at each level with. `levelOrder`\\nAnd at each level adding the non null child-node back to the queue.\\n```\\n                if(node.left!=null) {\\n                    **q.offer(node.left);**\\n                }\\n                \\n                if(node.right!=null) {\\n                    **q.offer(node.right);**\\n                }\\n```\\n\\n*Step 3 : Update the value of each node as :*\\n\\n- Left Child = 2 * parent node\\n\\t- `node.left.val = 2 * node.val;`\\n- Right Child = 2 * parent node + 1\\n\\t- `node.right.val = 2 * node.val + 1;`\\n\\n*Step 4 : Count the difference b/w the right and the left child value.*\\n\\n`q.peekLast().val - q.peekFirst().val + 1`\\nThis is where the choice of deque is made, to to access the left-most and right-most child  at each level.\\n\\n*Step 5 : Compute max at each point.*\\n\\nCompare the current max with current level right and node value differences\\n`max = Math.max(max, q.peekLast().val - q.peekFirst().val + 1);`\\n\\n**Complexities**\\n*Time Complexity - O(N)*\\nO(N) - Same as in order traversal - as you visit each node only once.\\n\\n*Space Complexity - O(W) i.e O(N)*\\nWhere W is the Width of the tree. This is because we are storing each level in the queue.\\nSince we can have a maximum of N/2 nodes at any level (There are N/2 nodes at the last level) therefore we will need O(N) space to store them in the queue.\\nLets say a tree of height = 3, In a compete binary tree left child = 2^h,, right child = 2^h + 1and max 2^h children.\\n2^0 = 1\\n2^1 = 2\\n2^2 = 4\\n2^3 = 8\\ntotal = 15, last level = 8\\n",
                "solutionTags": [
                    "Tree",
                    "Depth-First Search",
                    "Queue"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public int widthOfBinaryTree(TreeNode root) {\\n        \\n        if(root == null)\\n            return 0;\\n            \\n        Deque<TreeNode> q = new LinkedList<TreeNode>();\\n        int max = 1;\\n        root.val = 1;\\n        q.offer(root);\\n        \\n        while(!q.isEmpty()) {\\n            int levelSize = q.size();\\n\\n            if(levelSize>=2)\\n                max = Math.max(max, q.peekLast().val - q.peekFirst().val + 1);\\n\\n            for(int i=0; i<levelSize; i++) {\\n                TreeNode node = q.poll();\\n                \\n                if(node.left!=null) {\\n                    node.left.val = 2 * node.val;\\n                    q.offer(node.left);\\n                }\\n                \\n                if(node.right!=null) {\\n                    node.right.val = 2 * node.val + 1;\\n                    q.offer(node.right);\\n                }\\n               \\n            }\\n        }\\n        return max;\\n    }\\n}\\n```\n```\\n                if(node.left!=null) {\\n                    **q.offer(node.left);**\\n                }\\n                \\n                if(node.right!=null) {\\n                    **q.offer(node.right);**\\n                }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 351139,
                "title": "javascript-bfs-solution",
                "content": "The idea is simple. Do the classic BFS, but add two additional properties: depth and position of the node. We can wrap it into a new object: `{ node: node, depth: depth + 1, position: [READ BELOW] } `\\n\\nFor a left node, a position is: `2 * position`\\nFor a right node, a position is: `2 * position + 1`\\n\\nThe initial position is `0`, the initial depth is `0 `as well.\\n\\n*Important notice:* what if we have a very big depth and width of the level is `1`? `[0,null.. many times 0 and null ... 0]`. Just return `1` if width is `1`. I don\\'t need calculate: `positions[positions.length - 1] - positions[0] + 1`.\\n\\n```\\n    let maxWidth = 0\\n    const queue = [{ node: root, depth: 0, pos: 0 }]\\n    \\n    while (queue.length) {\\n        let len = queue.length\\n        const positions = []\\n\\n        while (len--) {\\n            const { node, depth, pos } = queue.shift()\\n            \\n            positions.push(pos)\\n            \\n            if (node.left) {\\n                queue.push({\\n                    node: node.left,\\n                    depth: depth + 1,\\n                    pos: 2 * pos\\n                })\\n            }\\n            \\n            if (node.right) {\\n                queue.push({\\n                    node: node.right,\\n                    depth: depth + 1,\\n                    pos: 2 * pos + 1\\n                })\\n            }\\n        }\\n        \\n        const levelWidth = positions.length === 1 ? 1 : positions[positions.length - 1] - positions[0] + 1\\n        maxWidth = Math.max(maxWidth, levelWidth)\\n    }\\n    \\n    return maxWidth\\n```\\n\\n***UPDATED*** *(29 September 2020)*\\n\\nThey added two new test cases, so I fixed my code.\\n\\n1. We don\\'t need unnecessary `depth` property, I have no idea why I wrote so \\xAF\\\\_(\\u30C4)_/\\n2. We need to cut unnecessary branches without left or right side (root -> right-> right -> right and so on)\\n\\n```\\n    let maxWidth = 0\\n\\n    while (root.left && !root.right) {\\n        root = root.left\\n    }\\n\\n    while (root.right && !root.left) {\\n        root = root.right\\n    }\\n    \\n    const queue = [{ node: root, pos: 0 }]\\n\\n    while (queue.length) {\\n        let len = queue.length\\n        const positions = []\\n\\n        while (len--) {\\n            const { node, pos } = queue.shift()\\n            \\n            positions.push(pos)\\n            \\n            if (node.left) {\\n                queue.push({ node: node.left,pos: 2 * pos })\\n            }\\n            \\n            if (node.right) {\\n                queue.push({ node: node.right, pos: 2 * pos + 1 })\\n            }\\n        }\\n\\n        const levelWidth = positions[positions.length - 1] - positions[0] + 1\\n\\n        maxWidth = Math.max(maxWidth, levelWidth)\\n    }\\n    \\n    return maxWidth\\n```",
                "solutionTags": [],
                "code": "```\\n    let maxWidth = 0\\n    const queue = [{ node: root, depth: 0, pos: 0 }]\\n    \\n    while (queue.length) {\\n        let len = queue.length\\n        const positions = []\\n\\n        while (len--) {\\n            const { node, depth, pos } = queue.shift()\\n            \\n            positions.push(pos)\\n            \\n            if (node.left) {\\n                queue.push({\\n                    node: node.left,\\n                    depth: depth + 1,\\n                    pos: 2 * pos\\n                })\\n            }\\n            \\n            if (node.right) {\\n                queue.push({\\n                    node: node.right,\\n                    depth: depth + 1,\\n                    pos: 2 * pos + 1\\n                })\\n            }\\n        }\\n        \\n        const levelWidth = positions.length === 1 ? 1 : positions[positions.length - 1] - positions[0] + 1\\n        maxWidth = Math.max(maxWidth, levelWidth)\\n    }\\n    \\n    return maxWidth\\n```\n```\\n    let maxWidth = 0\\n\\n    while (root.left && !root.right) {\\n        root = root.left\\n    }\\n\\n    while (root.right && !root.left) {\\n        root = root.right\\n    }\\n    \\n    const queue = [{ node: root, pos: 0 }]\\n\\n    while (queue.length) {\\n        let len = queue.length\\n        const positions = []\\n\\n        while (len--) {\\n            const { node, pos } = queue.shift()\\n            \\n            positions.push(pos)\\n            \\n            if (node.left) {\\n                queue.push({ node: node.left,pos: 2 * pos })\\n            }\\n            \\n            if (node.right) {\\n                queue.push({ node: node.right, pos: 2 * pos + 1 })\\n            }\\n        }\\n\\n        const levelWidth = positions[positions.length - 1] - positions[0] + 1\\n\\n        maxWidth = Math.max(maxWidth, levelWidth)\\n    }\\n    \\n    return maxWidth\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 193968,
                "title": "java-regular-bfs-solution-without-major-modification",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public int widthOfBinaryTree(TreeNode root) {\\n        \\n        if (root == null)\\n            return 1;\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        int maxWidth = 0, left = 0;\\n        Map<TreeNode, Integer> map = new HashMap<>();\\n        map.put(root, 0);\\n        queue.add(root);\\n        while (!queue.isEmpty()){\\n            \\n            int len = queue.size();\\n            left = map.get(queue.peek());\\n            for (int i=1; i<=len; i++){\\n                \\n                TreeNode p = queue.poll();\\n                int pos = map.get(p);\\n                maxWidth = Math.max(maxWidth, pos - left + 1);\\n                if (p.left != null){\\n                    queue.offer(p.left);\\n                    map.put(p.left, 2*pos);\\n                }\\n                if (p.right != null){\\n                    queue.offer(p.right);\\n                    map.put(p.right, 2*pos+1);\\n                }\\n            }\\n        }\\n        return maxWidth;\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public int widthOfBinaryTree(TreeNode root) {\\n        \\n        if (root == null)\\n            return 1;\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        int maxWidth = 0, left = 0;\\n        Map<TreeNode, Integer> map = new HashMap<>();\\n        map.put(root, 0);\\n        queue.add(root);\\n        while (!queue.isEmpty()){\\n            \\n            int len = queue.size();\\n            left = map.get(queue.peek());\\n            for (int i=1; i<=len; i++){\\n                \\n                TreeNode p = queue.poll();\\n                int pos = map.get(p);\\n                maxWidth = Math.max(maxWidth, pos - left + 1);\\n                if (p.left != null){\\n                    queue.offer(p.left);\\n                    map.put(p.left, 2*pos);\\n                }\\n                if (p.right != null){\\n                    queue.offer(p.right);\\n                    map.put(p.right, 2*pos+1);\\n                }\\n            }\\n        }\\n        return maxWidth;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 176812,
                "title": "java-level-order-traversal-with-trim-null",
                "content": "```java\\nclass Solution {\\n    public int widthOfBinaryTree(TreeNode root) {\\n        // Level Order Traversal\\n        // Edge case\\n        if(root == null) return 0;\\n        \\n        // Queue\\n        LinkedList<TreeNode> queue = new LinkedList<>();\\n        queue.offer(root);\\n        // null only counted between end points\\n        int max = 0;\\n        while(!queue.isEmpty()) {\\n            // Trim nulls in queue\\n            while(!queue.isEmpty() && queue.getFirst() == null )    queue.removeFirst();\\n            while(!queue.isEmpty() && queue.getLast() == null )    queue.removeLast();\\n            max = Math.max(max, queue.size());\\n            for(int sz = queue.size(); sz > 0; sz--) {\\n                TreeNode temp = queue.poll();\\n                if(temp == null) {\\n                    queue.offer(null);\\n                    queue.offer(null);\\n                } else {\\n                    queue.offer(temp.left);\\n                    queue.offer(temp.right);\\n                }\\n                \\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int widthOfBinaryTree(TreeNode root) {\\n        // Level Order Traversal\\n        // Edge case\\n        if(root == null) return 0;\\n        \\n        // Queue\\n        LinkedList<TreeNode> queue = new LinkedList<>();\\n        queue.offer(root);\\n        // null only counted between end points\\n        int max = 0;\\n        while(!queue.isEmpty()) {\\n            // Trim nulls in queue\\n            while(!queue.isEmpty() && queue.getFirst() == null )    queue.removeFirst();\\n            while(!queue.isEmpty() && queue.getLast() == null )    queue.removeLast();\\n            max = Math.max(max, queue.size());\\n            for(int sz = queue.size(); sz > 0; sz--) {\\n                TreeNode temp = queue.poll();\\n                if(temp == null) {\\n                    queue.offer(null);\\n                    queue.offer(null);\\n                } else {\\n                    queue.offer(temp.left);\\n                    queue.offer(temp.right);\\n                }\\n                \\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 106660,
                "title": "c-level-traverse",
                "content": "```\\nclass Solution {\\npublic:\\n    int widthOfBinaryTree(TreeNode* root) {\\n        if (root == nullptr) return 0;\\n        queue<pair<TreeNode*, int>> q;\\n        q.push(make_pair(root, 0));\\n        int res = 0;\\n        while (!q.empty())\\n        {\\n            int size = q.size();\\n            int begin, end;\\n            for (int i = 0; i < size; i++)\\n            {\\n                auto cur = q.front();\\n                q.pop();\\n                if (i == 0)\\n                {\\n                    begin = cur.second;\\n                }\\n                if (i == size-1)\\n                {\\n                    end = cur.second;\\n                }\\n                if ((cur.first)->left != nullptr)\\n                {\\n                    q.push(make_pair(cur.first->left, cur.second * 2));\\n                }\\n                if ((cur.first)->right != nullptr)\\n                {\\n                    q.push(make_pair(cur.first->right, cur.second * 2+1));\\n                }\\n            }\\n            res = max (res, end -begin +1);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int widthOfBinaryTree(TreeNode* root) {\\n        if (root == nullptr) return 0;\\n        queue<pair<TreeNode*, int>> q;\\n        q.push(make_pair(root, 0));\\n        int res = 0;\\n        while (!q.empty())\\n        {\\n            int size = q.size();\\n            int begin, end;\\n            for (int i = 0; i < size; i++)\\n            {\\n                auto cur = q.front();\\n                q.pop();\\n                if (i == 0)\\n                {\\n                    begin = cur.second;\\n                }\\n                if (i == size-1)\\n                {\\n                    end = cur.second;\\n                }\\n                if ((cur.first)->left != nullptr)\\n                {\\n                    q.push(make_pair(cur.first->left, cur.second * 2));\\n                }\\n                if ((cur.first)->right != nullptr)\\n                {\\n                    q.push(make_pair(cur.first->right, cur.second * 2+1));\\n                }\\n            }\\n            res = max (res, end -begin +1);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3438989,
                "title": "java-easy-explaination-for-beginner-level",
                "content": "# Intuition\\n Here it need to find width of the tree first approach that is level order traversal but it will need to apply with optimaization.\\n\\nIf the position of the parent node is n, then the left child is 2 * n and the right child is 2 * n + 1 The width of each level is the last node\\'s position in this level subtraction the first node\\'s position in this level plus 1 that is at any level width = lastNodePostion- firstNodePosition + 1\\n# Approach\\n1) Genrally we use a queue but here we need to store an index too.\\nSo either use pair in java or create a class which has 2 variables.\\nThat is :-\\n       i)TreeNode (to store current-node).\\n       ii)Index (will track of index for each Node).\\n2) Insert first root into the queue with 0 index and now unitl queue is not empty.\\n3) Run a for loop till queue size.\\n4) Find left(i==0), find righmost of the level(i==queue.size()-1) and at each level compare max width.\\nthat levels max ie max = Math.max(max, end - start + 1).\\n\\nI tried to explaned in easy way, I hope this solution will be understanable.\\n# Complexity\\n- Time complexity:\\nTime complexity O(n)\\n\\n- Space complexity:\\nO(n) at max that can have n elements in queue.\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int widthOfBinaryTree(TreeNode root) {\\n        if(root == null)\\n            return 0;\\n        \\n        int width = 1;\\n        Queue<TreeNode> qu = new LinkedList<>();\\n        Queue<Integer> idxqu = new LinkedList<>();\\n\\n        qu.offer(root);\\n        idxqu.offer(1);\\n\\n        while(!qu.isEmpty())\\n        {\\n            int level = qu.size();\\n            int leftIdx = 0, rightIdx = 0;\\n\\n            for(int i = 0; i < level; i++)\\n            {\\n                TreeNode temp = qu.poll();\\n                int idx = idxqu.poll();\\n\\n                if(i == 0)\\n                    leftIdx = idx;\\n                if(i == level - 1)\\n                    rightIdx = idx;\\n                \\n                if(temp.left != null)\\n                {\\n                    qu.offer(temp.left);\\n                    idxqu.offer(idx * 2);\\n                }\\n                if(temp.right != null)\\n                {\\n                    qu.offer(temp.right);\\n                    idxqu.offer(idx * 2 + 1);\\n                }\\n            }\\n            width = Math.max(width, rightIdx - leftIdx + 1);\\n        }\\n        return width;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int widthOfBinaryTree(TreeNode root) {\\n        if(root == null)\\n            return 0;\\n        \\n        int width = 1;\\n        Queue<TreeNode> qu = new LinkedList<>();\\n        Queue<Integer> idxqu = new LinkedList<>();\\n\\n        qu.offer(root);\\n        idxqu.offer(1);\\n\\n        while(!qu.isEmpty())\\n        {\\n            int level = qu.size();\\n            int leftIdx = 0, rightIdx = 0;\\n\\n            for(int i = 0; i < level; i++)\\n            {\\n                TreeNode temp = qu.poll();\\n                int idx = idxqu.poll();\\n\\n                if(i == 0)\\n                    leftIdx = idx;\\n                if(i == level - 1)\\n                    rightIdx = idx;\\n                \\n                if(temp.left != null)\\n                {\\n                    qu.offer(temp.left);\\n                    idxqu.offer(idx * 2);\\n                }\\n                if(temp.right != null)\\n                {\\n                    qu.offer(temp.right);\\n                    idxqu.offer(idx * 2 + 1);\\n                }\\n            }\\n            width = Math.max(width, rightIdx - leftIdx + 1);\\n        }\\n        return width;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3438927,
                "title": "simple-and-beginner-friendly-solution-with-comments-using-bfs",
                "content": "# Code\\n```\\n//  Using BFS approach\\nclass Solution {\\npublic:\\n    int widthOfBinaryTree(TreeNode* root) {\\n        \\n        // In case there is no node in the given input tree\\n        if(root == NULL) return 0;\\n        \\n        long long ans = 0;\\n\\n        // Creating a queue to push in nodes and corresponding values starting from\\n        // 0 on the current level\\n        queue<pair<TreeNode*, long long>> q;\\n\\n        // Pushing root node and 0 to start with the next steps\\n        q.push({root, 0});\\n\\n\\n        while(!q.empty()){\\n            int size = q.size();\\n            int to_sub = q.front().second;\\n            long long start, end;\\n            \\n            // for traversing each level\\n            for(int i = 0; i < size; i++){\\n                long long myuse = q.front().second - to_sub;\\n                TreeNode* mynode = q.front().first;\\n                q.pop();\\n                \\n                // to store the first ind of node in the level\\n                if(i == 0) start = myuse;\\n\\n                // to store the last ind of node in the level\\n                if(i == size-1) end = myuse;\\n\\n                // pushing in nodes for next level using the current level\\n                if(mynode->left){\\n                    q.push({mynode->left, myuse*2 +1});\\n                }\\n\\n                if(mynode->right){\\n                    q.push({mynode->right, myuse*2+2});\\n                }\\n            }\\n            \\n            // Checking if the current width is greater than previous\\n            ans = max(ans, end-start+1);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n//  Using BFS approach\\nclass Solution {\\npublic:\\n    int widthOfBinaryTree(TreeNode* root) {\\n        \\n        // In case there is no node in the given input tree\\n        if(root == NULL) return 0;\\n        \\n        long long ans = 0;\\n\\n        // Creating a queue to push in nodes and corresponding values starting from\\n        // 0 on the current level\\n        queue<pair<TreeNode*, long long>> q;\\n\\n        // Pushing root node and 0 to start with the next steps\\n        q.push({root, 0});\\n\\n\\n        while(!q.empty()){\\n            int size = q.size();\\n            int to_sub = q.front().second;\\n            long long start, end;\\n            \\n            // for traversing each level\\n            for(int i = 0; i < size; i++){\\n                long long myuse = q.front().second - to_sub;\\n                TreeNode* mynode = q.front().first;\\n                q.pop();\\n                \\n                // to store the first ind of node in the level\\n                if(i == 0) start = myuse;\\n\\n                // to store the last ind of node in the level\\n                if(i == size-1) end = myuse;\\n\\n                // pushing in nodes for next level using the current level\\n                if(mynode->left){\\n                    q.push({mynode->left, myuse*2 +1});\\n                }\\n\\n                if(mynode->right){\\n                    q.push({mynode->right, myuse*2+2});\\n                }\\n            }\\n            \\n            // Checking if the current width is greater than previous\\n            ans = max(ans, end-start+1);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3438491,
                "title": "easy-to-understand-c-solution-using-bfs",
                "content": "# Approach\\n\\nThis code implements a function named `WidthOfBinaryTree()`, which takes a binary tree\\'s root node as input and returns the maximum width of the tree. The width of a binary tree is the maximum number of nodes present in any level of the tree, where nodes at the same level are at the same distance from the root.\\n\\nThe approach to find the width of the tree taken here is the Breadth-First Search (BFS) algorithm. The algorithm scans the tree level by level, and for each level, it calculates the width by taking the difference between the index of the leftmost node and the index of the rightmost node in that level.\\n\\nThe algorithm uses a queue to store the nodes of the tree. Initially, the root node is enqueued with an index of 0, which represents the root\\'s position. In each iteration, the algorithm dequeues all the nodes of the current level, calculates their indices and enqueues their child nodes with updated indices. The loop continues until the queue becomes empty.\\n\\n# Time Complexity: *O(n)*\\n\\nThe time complexity of the algorithm is O(n), where n is the number of nodes in the tree. The algorithm traverses each node once, and the enqueue and dequeue operations on the queue take constant time. Therefore, the overall time complexity of the algorithm is proportional to the number of nodes in the tree.\\n\\n# Space Complexity: *O(w)*\\n\\nThe space complexity of the algorithm is O(w), where w is the maximum width of the tree. At any point in time, the queue holds the nodes of a single level, and the maximum number of nodes in a level is the width of the tree. Therefore, the space complexity of the algorithm is proportional to the maximum width of the tree.\\n\\n# Code\\n```\\npublic class Solution \\n{\\n    public int WidthOfBinaryTree(TreeNode root)\\n    {\\n        var maxWidth = 0;\\n        var queue = new Queue<(TreeNode Node, int Index)>();\\n        queue.Enqueue((root, 0));\\n\\n        while (queue.Count != 0)\\n        {\\n            var size = queue.Count;\\n            var left = queue.Peek().Index;\\n            var right = left;\\n\\n            for (var i = 0; i < size; i++)\\n            {\\n                var current = queue.Dequeue();\\n                right = current.Index;\\n\\n                if (current.Node.left != null)\\n                {\\n                    queue.Enqueue((current.Node.left, 2 * current.Index + 1));\\n                }\\n\\n                if (current.Node.right != null)\\n                {\\n                    queue.Enqueue((current.Node.right, 2 * current.Index + 2));\\n                }\\n            }\\n\\n            maxWidth = Math.Max(maxWidth, right - left + 1);\\n        }\\n\\n        return maxWidth;\\n    }\\n}\\n```\\n\\n![pleaseupvote.jpg](https://assets.leetcode.com/users/images/c8ea99e4-169e-41c6-92de-a63a48a654d7_1682005244.4977388.jpeg)\\n",
                "solutionTags": [
                    "C#",
                    "Tree",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\npublic class Solution \\n{\\n    public int WidthOfBinaryTree(TreeNode root)\\n    {\\n        var maxWidth = 0;\\n        var queue = new Queue<(TreeNode Node, int Index)>();\\n        queue.Enqueue((root, 0));\\n\\n        while (queue.Count != 0)\\n        {\\n            var size = queue.Count;\\n            var left = queue.Peek().Index;\\n            var right = left;\\n\\n            for (var i = 0; i < size; i++)\\n            {\\n                var current = queue.Dequeue();\\n                right = current.Index;\\n\\n                if (current.Node.left != null)\\n                {\\n                    queue.Enqueue((current.Node.left, 2 * current.Index + 1));\\n                }\\n\\n                if (current.Node.right != null)\\n                {\\n                    queue.Enqueue((current.Node.right, 2 * current.Index + 2));\\n                }\\n            }\\n\\n            maxWidth = Math.Max(maxWidth, right - left + 1);\\n        }\\n\\n        return maxWidth;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3438024,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int widthOfBinaryTree(TreeNode* root) {\\n        if(!root) return 0;\\n        int ans=0;\\n        queue<pair<TreeNode* , long long>> q;\\n        q.push({root,0});\\n        while(!q.empty())\\n        {\\n            int sizz=q.size();\\n            int minn=q.front().second;\\n            int ft,lt;\\n            for(int i=0; i<sizz; i++)\\n            {\\n                long long curr_id=q.front().second-minn;\\n                TreeNode* node=q.front().first;\\n                q.pop();\\n                if(i==0) ft=curr_id;\\n                if(i==sizz-1) lt=curr_id;\\n                if(node->left) q.push({node->left,curr_id*2+1});\\n                if(node->right) q.push({node->right,curr_id*2+2});\\n                \\n            }\\n            ans=max(ans,lt-ft+1);\\n        }\\n        return ans;\\n    }\\n};\\n```\\nPlease Upvote \\uD83E\\uDD7A\\uD83D\\uDE4F",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int widthOfBinaryTree(TreeNode* root) {\\n        if(!root) return 0;\\n        int ans=0;\\n        queue<pair<TreeNode* , long long>> q;\\n        q.push({root,0});\\n        while(!q.empty())\\n        {\\n            int sizz=q.size();\\n            int minn=q.front().second;\\n            int ft,lt;\\n            for(int i=0; i<sizz; i++)\\n            {\\n                long long curr_id=q.front().second-minn;\\n                TreeNode* node=q.front().first;\\n                q.pop();\\n                if(i==0) ft=curr_id;\\n                if(i==sizz-1) lt=curr_id;\\n                if(node->left) q.push({node->left,curr_id*2+1});\\n                if(node->right) q.push({node->right,curr_id*2+2});\\n                \\n            }\\n            ans=max(ans,lt-ft+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3437875,
                "title": "c-queue-easy-to-understand-simple",
                "content": "````\\n#define ll long long int\\nclass Solution {\\npublic:\\n    int widthOfBinaryTree(TreeNode* root) {\\n        queue<pair<TreeNode*,ll>> q;\\n        q.push({root,0});\\n        int n;\\n        pair<TreeNode*,ll> p;\\n        ll ans = 1;\\n        while(!q.empty()){\\n            n = q.size();\\n            ll a=0,b,c=q.front().second;\\n            for(int i = 0; i < n; i++){\\n                p = q.front();\\n                q.pop();\\n                if(p.first->left){\\n                    q.push({p.first->left,(p.second-c)*1LL*2});\\n                }\\n                if(p.first->right){\\n                    q.push({p.first->right,(p.second-c)*1LL*2+1});\\n                }\\n                \\n                if(i==0){\\n                    a = (p.second);\\n                }\\n                if(i==n-1){\\n                    b = (p.second);\\n                }\\n            }\\n            ans = max(ans,b-a+1);\\n        }\\n        return ans;\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "````\\n#define ll long long int\\nclass Solution {\\npublic:\\n    int widthOfBinaryTree(TreeNode* root) {\\n        queue<pair<TreeNode*,ll>> q;\\n        q.push({root,0});\\n        int n;\\n        pair<TreeNode*,ll> p;\\n        ll ans = 1;\\n        while(!q.empty()){\\n            n = q.size();\\n            ll a=0,b,c=q.front().second;\\n            for(int i = 0; i < n; i++){\\n                p = q.front();\\n                q.pop();\\n                if(p.first->left){\\n                    q.push({p.first->left,(p.second-c)*1LL*2});\\n                }\\n                if(p.first->right){\\n                    q.push({p.first->right,(p.second-c)*1LL*2+1});\\n                }\\n                \\n                if(i==0){\\n                    a = (p.second);\\n                }\\n                if(i==n-1){\\n                    b = (p.second);\\n                }\\n            }\\n            ans = max(ans,b-a+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3437661,
                "title": "c-bfs-intuitive-approach",
                "content": "This took an unusually long time.\\n\\nWe have to take care of the **relative postion** of every **child** node in the **next** layer, but we have an ***upper limit*** as to the *absolute* position or limit any data type can handle.\\n\\nFor instance, for a node at position **```i```**, child nodes will be at position **```2 * i```** and **```2 * i + 1```**.\\n\\nBut we cannot continue in this fashion since this is ***increasing exponentially***.\\nYet, we have to manipulate the fact that there is \\'k\\' distance between two specific nodes in the next layer.\\n\\nHere, ***```diff```*** takes care of it.\\nEg --> consider two nodes ***X*** and ***Y***, with ***posX*** and ***posY***. Difference between posX and posY is the **same** as the difference between ***(posX - diff)*** and ***(posY - diff)*** .\\n\\nPlease upvote if you find the solution clean and concise.\\n***Thank You!!***\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\ntypedef long long int ll;\\ntypedef pair<TreeNode*, ll> pi;\\nclass Solution {\\npublic:\\n    int widthOfBinaryTree(TreeNode* root) {\\n        ll res = 0;\\n        queue<pi> q;\\n        q.push({root, 1});\\n        while(q.size()) {\\n            int n = q.size();\\n            ll itr = 1, left = -101, right;\\n            ll diff = -101;\\n            while(n--) {\\n                pi currnode = q.front(); q.pop();\\n                if(left == -101) left = currnode.second;\\n                right = currnode.second;\\n                if(diff == -101 and currnode.first->left)\\n                    diff = (currnode.second<<1) - 1;\\n                if(diff == -101 and currnode.first->right)\\n                    diff = (currnode.second<<1) + 1 - 1;\\n                if(currnode.first->left)\\n                    q.push({currnode.first->left, (currnode.second<<1) - diff});\\n                if(currnode.first->right) \\n                    q.push({currnode.first->right, (currnode.second<<1) - diff + 1});\\n            }\\n            // cout<<left<<\" \"<<right<<\"\\\\n\";\\n            res = max(res, right - left + 1);\\n        }\\n        return (int)res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree",
                    "Breadth-First Search"
                ],
                "code": "```i```\n```2 * i```\n```2 * i + 1```\n```diff```\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\ntypedef long long int ll;\\ntypedef pair<TreeNode*, ll> pi;\\nclass Solution {\\npublic:\\n    int widthOfBinaryTree(TreeNode* root) {\\n        ll res = 0;\\n        queue<pi> q;\\n        q.push({root, 1});\\n        while(q.size()) {\\n            int n = q.size();\\n            ll itr = 1, left = -101, right;\\n            ll diff = -101;\\n            while(n--) {\\n                pi currnode = q.front(); q.pop();\\n                if(left == -101) left = currnode.second;\\n                right = currnode.second;\\n                if(diff == -101 and currnode.first->left)\\n                    diff = (currnode.second<<1) - 1;\\n                if(diff == -101 and currnode.first->right)\\n                    diff = (currnode.second<<1) + 1 - 1;\\n                if(currnode.first->left)\\n                    q.push({currnode.first->left, (currnode.second<<1) - diff});\\n                if(currnode.first->right) \\n                    q.push({currnode.first->right, (currnode.second<<1) - diff + 1});\\n            }\\n            // cout<<left<<\" \"<<right<<\"\\\\n\";\\n            res = max(res, right - left + 1);\\n        }\\n        return (int)res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3436650,
                "title": "c-left-right-dfs",
                "content": "# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int widthOfBinaryTree(TreeNode* root) {\\n        unordered_map<int, unsigned long long> firstIndex;\\n        return dfs(root, 0, 0, firstIndex);\\n    }\\nprivate:\\n    unsigned long long dfs(TreeNode* root, int level, unsigned long long index, unordered_map<int, unsigned long long>& firstIndex) {\\n        if(!root) return 0;\\n        if(firstIndex.find(level) == firstIndex.end()) {\\n            firstIndex[level] = index;\\n        }\\n        unsigned long long left = dfs(root->left, level + 1, 2 * index, firstIndex);\\n        unsigned long long right = dfs(root->right, level + 1, 2 * index + 1, firstIndex);\\n        return max(index - firstIndex[level] + 1, max(left, right));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int widthOfBinaryTree(TreeNode* root) {\\n        unordered_map<int, unsigned long long> firstIndex;\\n        return dfs(root, 0, 0, firstIndex);\\n    }\\nprivate:\\n    unsigned long long dfs(TreeNode* root, int level, unsigned long long index, unordered_map<int, unsigned long long>& firstIndex) {\\n        if(!root) return 0;\\n        if(firstIndex.find(level) == firstIndex.end()) {\\n            firstIndex[level] = index;\\n        }\\n        unsigned long long left = dfs(root->left, level + 1, 2 * index, firstIndex);\\n        unsigned long long right = dfs(root->right, level + 1, 2 * index + 1, firstIndex);\\n        return max(index - firstIndex[level] + 1, max(left, right));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3436521,
                "title": "java-bfs-beats-100-clean-simple-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse BFS to traverse through the tree level by level. Change the value of the nodes by their position number in the tree. For instance, `root.val = 0`, and for any `node`, `node.left.val = node.val * 2` and `node.right.val = node.val * 2 + 1`. Now, the width of any level can be computed as the value of the last node `r` minus the value of the first node `l` plus 1. Keep track of the maximum of the widths across all the levels, and that\\'s your answer.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public int widthOfBinaryTree(TreeNode root) {\\n    var max = 0;\\n    var queue = new ArrayDeque<TreeNode>();\\n    root.val = 0;\\n    queue.offer(root);\\n\\n    while (!queue.isEmpty()) {\\n      int l = 0, r = 0, n = queue.size();\\n\\n      for (var i = n; i > 0; i--) {\\n        var node = queue.poll();\\n\\n        if (i == n) l = node.val;\\n        if (i == 1) r = node.val;\\n\\n        if (node.left != null) {\\n          node.left.val = node.val * 2;\\n          queue.offer(node.left);\\n        }\\n        if (node.right != null) {\\n          node.right.val = node.val * 2 + 1;\\n          queue.offer(node.right);\\n        }\\n      }\\n      max = Math.max(max, r - l + 1);\\n    }\\n    return max;\\n  }\\n}\\n```\\nIf you like my solution, please upvote it!",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n  public int widthOfBinaryTree(TreeNode root) {\\n    var max = 0;\\n    var queue = new ArrayDeque<TreeNode>();\\n    root.val = 0;\\n    queue.offer(root);\\n\\n    while (!queue.isEmpty()) {\\n      int l = 0, r = 0, n = queue.size();\\n\\n      for (var i = n; i > 0; i--) {\\n        var node = queue.poll();\\n\\n        if (i == n) l = node.val;\\n        if (i == 1) r = node.val;\\n\\n        if (node.left != null) {\\n          node.left.val = node.val * 2;\\n          queue.offer(node.left);\\n        }\\n        if (node.right != null) {\\n          node.right.val = node.val * 2 + 1;\\n          queue.offer(node.right);\\n        }\\n      }\\n      max = Math.max(max, r - l + 1);\\n    }\\n    return max;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3436497,
                "title": "c-solutions-easty-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int widthOfBinaryTree(TreeNode* root) {\\n        vector<int> widths;\\n    \\n        // Handle base case of empty tree\\n        if (!root)\\n            return 0;\\n        \\n        int max_width = 1;\\n        queue<pair<TreeNode*, long long int>> q;\\n        // Push the root node with position 0 to the queue\\n        q.push({root, 0});\\n\\n        while (!q.empty()) {\\n            int level_size = q.size();\\n            int leftmost_pos = 0, rightmost_pos = 0;\\n            int level_offset = 0;\\n            long long int level_min_pos = q.front().second;\\n            \\n            // Traverse all nodes at current level\\n            for (int i = 0; i < level_size; i++) {\\n                auto node_pos_pair = q.front();\\n                TreeNode* node = node_pos_pair.first;\\n                long long int pos = node_pos_pair.second - level_min_pos;\\n                q.pop();\\n                \\n                // Keep track of leftmost and rightmost positions of current level\\n                if (i == 0)\\n                    leftmost_pos = pos;\\n                \\n                if (i == level_size-1)\\n                    rightmost_pos = pos;\\n\\n                // Push the child nodes with updated positions to the queue\\n                if (node->left)\\n                    q.push({node->left, 2 * pos + 1});\\n                \\n                if (node->right)\\n                    q.push({node->right, 2 * pos + 2});\\n            }\\n            \\n            // Compute the width of current level and update max_width if necessary\\n            int width = rightmost_pos - leftmost_pos + 1;\\n            max_width = max(max_width, width);\\n        }\\n\\n        return max_width;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int widthOfBinaryTree(TreeNode* root) {\\n        vector<int> widths;\\n    \\n        // Handle base case of empty tree\\n        if (!root)\\n            return 0;\\n        \\n        int max_width = 1;\\n        queue<pair<TreeNode*, long long int>> q;\\n        // Push the root node with position 0 to the queue\\n        q.push({root, 0});\\n\\n        while (!q.empty()) {\\n            int level_size = q.size();\\n            int leftmost_pos = 0, rightmost_pos = 0;\\n            int level_offset = 0;\\n            long long int level_min_pos = q.front().second;\\n            \\n            // Traverse all nodes at current level\\n            for (int i = 0; i < level_size; i++) {\\n                auto node_pos_pair = q.front();\\n                TreeNode* node = node_pos_pair.first;\\n                long long int pos = node_pos_pair.second - level_min_pos;\\n                q.pop();\\n                \\n                // Keep track of leftmost and rightmost positions of current level\\n                if (i == 0)\\n                    leftmost_pos = pos;\\n                \\n                if (i == level_size-1)\\n                    rightmost_pos = pos;\\n\\n                // Push the child nodes with updated positions to the queue\\n                if (node->left)\\n                    q.push({node->left, 2 * pos + 1});\\n                \\n                if (node->right)\\n                    q.push({node->right, 2 * pos + 2});\\n            }\\n            \\n            // Compute the width of current level and update max_width if necessary\\n            int width = rightmost_pos - leftmost_pos + 1;\\n            max_width = max(max_width, width);\\n        }\\n\\n        return max_width;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3436477,
                "title": "csharp-simple-queue-solution",
                "content": "# Code\\n```\\npublic class Solution\\n{\\n    public int WidthOfBinaryTree(TreeNode root)\\n    {\\n        if (root is null)\\n            return 0;\\n\\n        int maxWidth = 0;\\n        var queue = new Queue<(TreeNode, int)>();\\n        queue.Enqueue((root, 0));\\n\\n        while (queue.Count > 0)\\n        {\\n            int size = queue.Count;\\n            int left = queue.Peek().Item2;\\n            int right = left;\\n\\n            for (int i = 0; i < size; i++)\\n            {\\n                (TreeNode node, int index) = queue.Dequeue();\\n                right = index;\\n\\n                if (node.left is not null)\\n                    queue.Enqueue((node.left, 2 * index));\\n\\n                if (node.right is not null)\\n                    queue.Enqueue((node.right, 2 * index + 1));\\n            }\\n            maxWidth = Math.Max(maxWidth, right - left + 1);\\n        }\\n        return maxWidth;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public int WidthOfBinaryTree(TreeNode root)\\n    {\\n        if (root is null)\\n            return 0;\\n\\n        int maxWidth = 0;\\n        var queue = new Queue<(TreeNode, int)>();\\n        queue.Enqueue((root, 0));\\n\\n        while (queue.Count > 0)\\n        {\\n            int size = queue.Count;\\n            int left = queue.Peek().Item2;\\n            int right = left;\\n\\n            for (int i = 0; i < size; i++)\\n            {\\n                (TreeNode node, int index) = queue.Dequeue();\\n                right = index;\\n\\n                if (node.left is not null)\\n                    queue.Enqueue((node.left, 2 * index));\\n\\n                if (node.right is not null)\\n                    queue.Enqueue((node.right, 2 * index + 1));\\n            }\\n            maxWidth = Math.Max(maxWidth, right - left + 1);\\n        }\\n        return maxWidth;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3314809,
                "title": "662-space-95-44-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Check if the root is None. If it is, return 0.\\n2. Create a queue and add the root to the queue with position 0.\\n3. Initialize a variable max_width to 0.\\n4. While the queue is not empty, do the following:\\na. Get the size of the current level by getting the length of the queue.\\nb. Get the position of the leftmost node in the current level by getting the position of the first item in the queue.\\nc. Get the position of the rightmost node in the current level by getting the position of the last item in the queue.\\nd. Update max_width to the maximum of its current value and the width of the current level (i.e., right_pos - left_pos + 1).\\ne. For each node in the current level, remove it from the queue and add its left and right children (if they exist) to the queue with positions calculated using the formula pos2 and pos2 + 1, respectively.\\nf. Reset the positions of all nodes in the queue by subtracting left_pos from their positions. This is done to avoid integer overflow.\\n5. Return max_width.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def widthOfBinaryTree(self, root: TreeNode) -> int:\\n        if not root:\\n            return 0\\n        queue = [(root, 0)]\\n        max_width = 0\\n        while queue:\\n            level_size = len(queue)\\n            left_pos = queue[0][1]\\n            right_pos = queue[-1][1]\\n            max_width = max(max_width, right_pos - left_pos + 1)\\n            for i in range(level_size):\\n                node, pos = queue.pop(0)\\n                if node.left:\\n                    queue.append((node.left, pos*2))\\n                if node.right:\\n                    queue.append((node.right, pos*2 + 1))\\n            # Reset positions to avoid integer overflow\\n            for i in range(len(queue)):\\n                queue[i] = (queue[i][0], queue[i][1] - left_pos)\\n        return max_width\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Tree",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def widthOfBinaryTree(self, root: TreeNode) -> int:\\n        if not root:\\n            return 0\\n        queue = [(root, 0)]\\n        max_width = 0\\n        while queue:\\n            level_size = len(queue)\\n            left_pos = queue[0][1]\\n            right_pos = queue[-1][1]\\n            max_width = max(max_width, right_pos - left_pos + 1)\\n            for i in range(level_size):\\n                node, pos = queue.pop(0)\\n                if node.left:\\n                    queue.append((node.left, pos*2))\\n                if node.right:\\n                    queue.append((node.right, pos*2 + 1))\\n            # Reset positions to avoid integer overflow\\n            for i in range(len(queue)):\\n                queue[i] = (queue[i][0], queue[i][1] - left_pos)\\n        return max_width\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2838332,
                "title": "striver-method-easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int widthOfBinaryTree(TreeNode* root) {\\n        if(!root)return 0;\\n        int ans=0;\\n        queue<pair<TreeNode*,int>> q;\\n\\n        q.push({root,0});\\n        while(!q.empty()){\\n            int size=q.size();\\n            auto top=q.front();\\n            int min=top.second;\\n            int first,last;\\n            for(int i=0;i<size;i++){\\n                int cur_id=q.front().second-min;\\n                TreeNode* node=q.front().first;\\n                q.pop();\\n                if(i==0)first=cur_id;\\n                if(i==size-1)last=cur_id;\\n\\n                if(node->left){\\n                    q.push({node->left,(long long)2*cur_id+1});\\n                }\\n                if(node->right){\\n                    q.push({node->right,(long long)2*cur_id+2});\\n                }\\n            }\\n            ans=max(ans,last-first+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int widthOfBinaryTree(TreeNode* root) {\\n        if(!root)return 0;\\n        int ans=0;\\n        queue<pair<TreeNode*,int>> q;\\n\\n        q.push({root,0});\\n        while(!q.empty()){\\n            int size=q.size();\\n            auto top=q.front();\\n            int min=top.second;\\n            int first,last;\\n            for(int i=0;i<size;i++){\\n                int cur_id=q.front().second-min;\\n                TreeNode* node=q.front().first;\\n                q.pop();\\n                if(i==0)first=cur_id;\\n                if(i==size-1)last=cur_id;\\n\\n                if(node->left){\\n                    q.push({node->left,(long long)2*cur_id+1});\\n                }\\n                if(node->right){\\n                    q.push({node->right,(long long)2*cur_id+2});\\n                }\\n            }\\n            ans=max(ans,last-first+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2629935,
                "title": "maximum-width-of-binary-tree-best-approach-easy-to-understand",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int widthOfBinaryTree(TreeNode* root) \\n    {\\n        long long int ans=INT_MIN;\\n        queue<pair<TreeNode*,int>>q;\\n        q.push(make_pair(root,0));\\n\\n\\n        while(!q.empty())\\n        {\\n            int size=q.size();\\n\\n            int start=q.front().second;\\n            int end=q.back().second;\\n\\n            if((end-start+1)>ans)\\n            ans=(end-start+1);\\n\\n            for(int i=0;i<size;i++)\\n            {\\n               TreeNode* temp=q.front().first;\\n               long long int idx=q.front().second;\\n               q.pop();\\n\\n               if(temp->left!=NULL)\\n               q.push(make_pair(temp->left,2*idx+1));\\n\\n               if(temp->right!=NULL)\\n               q.push(make_pair(temp->right,2*idx+2));       \\t\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int widthOfBinaryTree(TreeNode* root) \\n    {\\n        long long int ans=INT_MIN;\\n        queue<pair<TreeNode*,int>>q;\\n        q.push(make_pair(root,0));\\n\\n\\n        while(!q.empty())\\n        {\\n            int size=q.size();\\n\\n            int start=q.front().second;\\n            int end=q.back().second;\\n\\n            if((end-start+1)>ans)\\n            ans=(end-start+1);\\n\\n            for(int i=0;i<size;i++)\\n            {\\n               TreeNode* temp=q.front().first;\\n               long long int idx=q.front().second;\\n               q.pop();\\n\\n               if(temp->left!=NULL)\\n               q.push(make_pair(temp->left,2*idx+1));\\n\\n               if(temp->right!=NULL)\\n               q.push(make_pair(temp->right,2*idx+2));       \\t\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2566366,
                "title": "easy-java-solution-beginner-friendly",
                "content": "**If you really found my solution helpful please upvote it, as it motivates me to post such kind of codes and help the coding community, if you have some queries or some improvements please feel free to comment and share your views.**\\n```\\nclass Pair{\\n    int pos;\\n    TreeNode node;\\n    Pair(int x,TreeNode y){\\n        pos = x;\\n        node = y;\\n    }\\n}\\nclass Solution {\\n    public int widthOfBinaryTree(TreeNode root) {\\n        Queue<Pair> q = new LinkedList<>();\\n        q.offer(new Pair(0,root));\\n        int max = Integer.MIN_VALUE;\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            int start = 0;\\n            int end = 0;\\n            for(int i = 0 ; i < size; i ++){\\n                Pair p = q.poll();\\n                int pos = p.pos;\\n                TreeNode node = p.node;\\n                \\n                if(i == 0){\\n                    start = pos;\\n                }\\n                if(i == size -1){\\n                    end = pos;\\n                }\\n                if(node.left != null){\\n                    q.offer(new Pair(2*pos+1,node.left));\\n                }\\n                if(node.right != null){\\n                    q.offer(new Pair(2*pos+2,node.right));\\n                }\\n            }\\n            max = Math.max(max,end+1-start);\\n        }\\n        return max;\\n    }\\n}\\n```\\n**Happy Coding**",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\nclass Pair{\\n    int pos;\\n    TreeNode node;\\n    Pair(int x,TreeNode y){\\n        pos = x;\\n        node = y;\\n    }\\n}\\nclass Solution {\\n    public int widthOfBinaryTree(TreeNode root) {\\n        Queue<Pair> q = new LinkedList<>();\\n        q.offer(new Pair(0,root));\\n        int max = Integer.MIN_VALUE;\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            int start = 0;\\n            int end = 0;\\n            for(int i = 0 ; i < size; i ++){\\n                Pair p = q.poll();\\n                int pos = p.pos;\\n                TreeNode node = p.node;\\n                \\n                if(i == 0){\\n                    start = pos;\\n                }\\n                if(i == size -1){\\n                    end = pos;\\n                }\\n                if(node.left != null){\\n                    q.offer(new Pair(2*pos+1,node.left));\\n                }\\n                if(node.right != null){\\n                    q.offer(new Pair(2*pos+2,node.right));\\n                }\\n            }\\n            max = Math.max(max,end+1-start);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2073947,
                "title": "c-solution-which-handles-the-overflow-test-cases",
                "content": "To deal with overflow, we could reset the first node in each row to be 0-indexed.\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    // O(N), O(N)\\n    int widthOfBinaryTree(TreeNode* root) {\\n        if (!root) {\\n            return 0;\\n        }\\n\\n        long res = 0;\\n        queue<pair<TreeNode*, long>> qs;\\n        qs.push({root, 0});\\n        while (!qs.empty()) {\\n            int sz = qs.size();\\n            long low = qs.front().second;\\n            long high = low;\\n            long base = -1;\\n            while (sz--) {\\n                auto [node, index] = qs.front();\\n                high = index;\\n                qs.pop();\\n\\n                if (node->left) {\\n                    if (base == -1) {\\n                        base = 2 * index;\\n                    }\\n                    qs.push({node->left, 2 * index - base});\\n                }\\n                \\n                if (node->right) {\\n                    if (base == -1) {\\n                        base = 2 * index + 1;\\n                    }\\n                    qs.push({node->right, 2 * index + 1 - base});\\n                }\\n            }\\n            res = max(res, high - low + 1);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    // O(N), O(N)\\n    int widthOfBinaryTree(TreeNode* root) {\\n        if (!root) {\\n            return 0;\\n        }\\n\\n        long res = 0;\\n        queue<pair<TreeNode*, long>> qs;\\n        qs.push({root, 0});\\n        while (!qs.empty()) {\\n            int sz = qs.size();\\n            long low = qs.front().second;\\n            long high = low;\\n            long base = -1;\\n            while (sz--) {\\n                auto [node, index] = qs.front();\\n                high = index;\\n                qs.pop();\\n\\n                if (node->left) {\\n                    if (base == -1) {\\n                        base = 2 * index;\\n                    }\\n                    qs.push({node->left, 2 * index - base});\\n                }\\n                \\n                if (node->right) {\\n                    if (base == -1) {\\n                        base = 2 * index + 1;\\n                    }\\n                    qs.push({node->right, 2 * index + 1 - base});\\n                }\\n            }\\n            res = max(res, high - low + 1);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1977233,
                "title": "c-bfs-100-easy-intutive",
                "content": "\\nT.C -> O(N)\\nS.C: -> O(N)  for using queue\\n\\nIdea->\\n\\nIndexing =>\\nnode = i;\\nleft child = 2 * i + 1;\\nright child = 2 * i + 2;\\n\\nwe do indexing such that first node of each level has index = 0;\\ni.e=>\\n![image](https://assets.leetcode.com/users/images/1f4fdf13-b34c-4eac-a27c-899fccda7812_1650776388.3629544.jpeg)\\n\\n    int widthOfBinaryTree(TreeNode* root) \\n    {\\n        if(!root)  return 0;\\n        \\n        queue<pair<TreeNode*, int>> q;\\n        q.push({root, 0});\\n        \\n        int ans = 0;\\n        \\n        while(!q.empty())\\n        {\\n            int n = q.size();\\n            \\n            //at each level width is number of nodes(including null) between \\n            //leftmost & rightmost non-null nodes\\n            int start = q.front().second;          //front gives leftmost of a level\\n            int end = q.back().second;              //back gives rightmost of a level\\n            \\n            ans = max(ans, end - start + 1);   //find max width, between 2 non null nodes\\n            \\n            for(int i = 0; i < n; i++)\\n            {\\n                TreeNode* t = q.front().first;\\n                \\n                //do,  - start as \\n                // doing this make first node of each level as index 0 \\n                int idx = q.front().second - start;  \\n                \\n                q.pop();\\n                \\n                if(t->left)\\n                   q.push({t->left, (long long)2 * idx + 1});     //long long to handle overflow\\n                if(t->right)\\n                   q.push({t->right, (long long)2 * idx + 2});\\n            }\\n        }\\n      return ans;\\n    }\\n\\t\\n# Please Upvote , if find Useful",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "\\nT.C -> O(N)\\nS.C: -> O(N)  for using queue\\n\\nIdea->\\n\\nIndexing =>\\nnode = i;\\nleft child = 2 * i + 1;\\nright child = 2 * i + 2;\\n\\nwe do indexing such that first node of each level has index = 0;\\ni.e=>\\n![image](https://assets.leetcode.com/users/images/1f4fdf13-b34c-4eac-a27c-899fccda7812_1650776388.3629544.jpeg)\\n\\n    int widthOfBinaryTree(TreeNode* root) \\n    {\\n        if(!root)  return 0;\\n        \\n        queue<pair<TreeNode*, int>> q;\\n        q.push({root, 0});\\n        \\n        int ans = 0;\\n        \\n        while(!q.empty())\\n        {\\n            int n = q.size();\\n            \\n            //at each level width is number of nodes(including null) between \\n            //leftmost & rightmost non-null nodes\\n            int start = q.front().second;          //front gives leftmost of a level\\n            int end = q.back().second;              //back gives rightmost of a level\\n            \\n            ans = max(ans, end - start + 1);   //find max width, between 2 non null nodes\\n            \\n            for(int i = 0; i < n; i++)\\n            {\\n                TreeNode* t = q.front().first;\\n                \\n                //do,  - start as \\n                // doing this make first node of each level as index 0 \\n                int idx = q.front().second - start;  \\n                \\n                q.pop();\\n                \\n                if(t->left)\\n                   q.push({t->left, (long long)2 * idx + 1});     //long long to handle overflow\\n                if(t->right)\\n                   q.push({t->right, (long long)2 * idx + 2});\\n            }\\n        }\\n      return ans;\\n    }\\n\\t\\n# Please Upvote , if find Useful",
                "codeTag": "Unknown"
            },
            {
                "id": 1820371,
                "title": "simple-js-solution-w-comments-bfs",
                "content": "```\\n/**\\n * *Time: O(N)\\n * *Space: O(N)\\n */\\n// Runtime: 121 ms, faster than 35.19% of JavaScript online submissions for Maximum Width of Binary Tree.\\n// Memory Usage: 46.2 MB, less than 88.72% of JavaScript online submissions for Maximum Width of Binary Tree.\\nconst widthOfBinaryTree = root => {\\n\\tlet max = 0;\\n\\tconst queue = [[root, 0]]; // [node, index]\\n\\n\\tif (!root) return 0;\\n\\n\\twhile (queue.length) {\\n\\t\\tconst len = queue.length;\\n\\t\\tlet first = queue[0][1]; // 1st idx\\n\\t\\tlet last = queue[len - 1][1]; // last idx\\n\\n\\t\\tfor (let i = 0; i < len; i++) {\\n\\t\\t\\tconst [node, idx] = queue.shift();\\n\\t\\t\\tconst subIdx = idx - first; // normalize index to handle Big numbers\\n\\n\\t\\t\\tif (node.left) queue.push([node.left, subIdx * 2 + 1]); // find next left idx & node\\n\\t\\t\\tif (node.right) queue.push([node.right, subIdx * 2 + 2]); // find next right idx & node\\n\\t\\t}\\n\\n\\t\\tconst width = last - first + 1; // add 1, 0-index based\\n\\t\\tmax = Math.max(max, width);\\n\\t}\\n\\n\\treturn max;\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * *Time: O(N)\\n * *Space: O(N)\\n */\\n// Runtime: 121 ms, faster than 35.19% of JavaScript online submissions for Maximum Width of Binary Tree.\\n// Memory Usage: 46.2 MB, less than 88.72% of JavaScript online submissions for Maximum Width of Binary Tree.\\nconst widthOfBinaryTree = root => {\\n\\tlet max = 0;\\n\\tconst queue = [[root, 0]]; // [node, index]\\n\\n\\tif (!root) return 0;\\n\\n\\twhile (queue.length) {\\n\\t\\tconst len = queue.length;\\n\\t\\tlet first = queue[0][1]; // 1st idx\\n\\t\\tlet last = queue[len - 1][1]; // last idx\\n\\n\\t\\tfor (let i = 0; i < len; i++) {\\n\\t\\t\\tconst [node, idx] = queue.shift();\\n\\t\\t\\tconst subIdx = idx - first; // normalize index to handle Big numbers\\n\\n\\t\\t\\tif (node.left) queue.push([node.left, subIdx * 2 + 1]); // find next left idx & node\\n\\t\\t\\tif (node.right) queue.push([node.right, subIdx * 2 + 2]); // find next right idx & node\\n\\t\\t}\\n\\n\\t\\tconst width = last - first + 1; // add 1, 0-index based\\n\\t\\tmax = Math.max(max, width);\\n\\t}\\n\\n\\treturn max;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1817420,
                "title": "easy-c-solution-bfs-avoided-overflow",
                "content": "```\\nclass Solution {\\npublic:\\n    int widthOfBinaryTree(TreeNode* root) {\\n        if(!root)\\n            return 0;\\n        queue <pair<TreeNode*, int>> q;\\n        q.push({root, 0});\\n        \\n        int ans=1;\\n        while(!q.empty()){\\n            int size= q.size();\\n            ans=max(ans,q.back().second-q.front().second+1);\\n            \\n            for(int i=0; i<size; i++){\\n                auto temp = q.front();\\n                long long int index = temp.second;\\n                q.pop();\\n                \\n                if(temp.first->left)\\n                    q.push({temp.first->left, index*2+1});\\n                if(temp.first->right)\\n                    q.push({temp.first->right, index*2+2});\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Queue",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int widthOfBinaryTree(TreeNode* root) {\\n        if(!root)\\n            return 0;\\n        queue <pair<TreeNode*, int>> q;\\n        q.push({root, 0});\\n        \\n        int ans=1;\\n        while(!q.empty()){\\n            int size= q.size();\\n            ans=max(ans,q.back().second-q.front().second+1);\\n            \\n            for(int i=0; i<size; i++){\\n                auto temp = q.front();\\n                long long int index = temp.second;\\n                q.pop();\\n                \\n                if(temp.first->left)\\n                    q.push({temp.first->left, index*2+1});\\n                if(temp.first->right)\\n                    q.push({temp.first->right, index*2+2});\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1803818,
                "title": "c-easy-to-understand",
                "content": "class Solution {\\npublic:\\n\\n    int widthOfBinaryTree(TreeNode* root) {\\n        if(!root)\\n          return 0;\\n        long ans=0;\\n        queue<pair<TreeNode* ,int >>q;\\n        q.push({root,0});\\n        while(q.size()){\\n          int sz=q.size();\\n          auto mn=q.front().second;\\n          long l;\\n          for(int i=0;i<sz;i++){\\n             int idx=q.front().second-mn;\\n             auto node=q.front().first;\\n             q.pop();\\n             if(i==sz-1)\\n               l=idx;\\n             if(node->left)\\n               q.push({node->left,(long)idx*2});\\n             if(node->right)\\n               q.push({node->right,(long)idx*2+1});\\n          }\\n          ans=max(ans,l+1);\\n        }\\n      return ans;\\n    }\\n};",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int widthOfBinaryTree(TreeNode* root) {\\n        if(!root)\\n          return 0;\\n        long ans=0;\\n        queue<pair<TreeNode* ,int >>q;\\n        q.push({root,0}",
                "codeTag": "Java"
            },
            {
                "id": 1803433,
                "title": "c-2-steps-solution-concise-detailed-explanation-bfs",
                "content": "### **EXPLANATION :-**\\n*  \\t**`IDEA:- Just calculate the difference between first index of current level node to the last index of current level node..`**  \\n\\t\\t\\t\\t**`And for this purpose, we\\'re maintaing pair of TreeNode* & int in the queue. the second integer value in pair denotes the indexes of the current node`**\\n          **`We\\'re updating result variable at every level of the tree by picking up the maximum differenced index.`**\\n\\t\\t  \\n\\t   **`BUT HOW DO WE MAINTAIN THE INDEXS OF THE NODES?`**\\n       **`There is formula to access the children of the binary tree of the current node \\'w\\'(let say)`**\\n       **`1. for left children :  2 * (w) + 1`**\\n       **`2. for right children : 2 * (w) + 2`**\\n```\\n```\\n* **C++ CODE :-   SIMPLE  BFS    `[Accepted : ~10ms]`**\\n```\\nclass Solution {\\npublic:\\n    int widthOfBinaryTree(TreeNode* root) {\\n        if(root == NULL) return 0;\\n        int res = 0;\\n\\t\\tqueue<pair<TreeNode*, unsigned int>> q;        // queue<Nodes, Indexes of the Nodes> q\\n        q.push({root, 0});\\n\\n        while(!q.empty()){\\n        \\tauto size = q.size();\\n\\t\\t\\tunsigned int leftNodeIdx = q.front().second;     // Here, idx can\\'t go negative. Therefore, I\\'ve used Unsigned Int\\n        \\tunsigned int rightNodeIdx = 0;\\n        \\twhile(size--){\\n        \\t\\tauto [node, rightIdx] = q.front();\\tq.pop();\\n        \\t\\trightNodeIdx = rightIdx;\\n\\n        \\t\\tif(node->left != NULL) q.push({node->left, 2 * rightNodeIdx + 1});\\n        \\t\\tif(node->right != NULL) q.push({node->right, 2 * rightNodeIdx + 2});\\n        \\t}\\n        \\tres = max(res, int(rightNodeIdx - leftNodeIdx + 1));\\n        }\\n        return res;\\n    }\\n};\\n```\\n**TIME    COMPLEXITY : `O(N), `Where `N :`, total number of nodes in the tree**\\n**SPACE  COMPLEXITY :  `O(N) `**\\n\\nif you **find any mistakes pls** drop a comment,\\nif it makes any sense **Please Upvote :)**\\n",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n```\n```\\nclass Solution {\\npublic:\\n    int widthOfBinaryTree(TreeNode* root) {\\n        if(root == NULL) return 0;\\n        int res = 0;\\n\\t\\tqueue<pair<TreeNode*, unsigned int>> q;        // queue<Nodes, Indexes of the Nodes> q\\n        q.push({root, 0});\\n\\n        while(!q.empty()){\\n        \\tauto size = q.size();\\n\\t\\t\\tunsigned int leftNodeIdx = q.front().second;     // Here, idx can\\'t go negative. Therefore, I\\'ve used Unsigned Int\\n        \\tunsigned int rightNodeIdx = 0;\\n        \\twhile(size--){\\n        \\t\\tauto [node, rightIdx] = q.front();\\tq.pop();\\n        \\t\\trightNodeIdx = rightIdx;\\n\\n        \\t\\tif(node->left != NULL) q.push({node->left, 2 * rightNodeIdx + 1});\\n        \\t\\tif(node->right != NULL) q.push({node->right, 2 * rightNodeIdx + 2});\\n        \\t}\\n        \\tres = max(res, int(rightNodeIdx - leftNodeIdx + 1));\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802945,
                "title": "dfs-comments-intuition-logic-c",
                "content": "```\\n#define ull unsigned long long\\n#define um unordered_map\\nclass Solution {\\npublic:\\n    int widthOfBinaryTree(TreeNode* root) {\\n        um<int,ull> f; //storing the last possible index at each level\\n        return dfs(root,0,0,f); // dfs will return you the max width\\n    }\\n    private:\\n    ull dfs(TreeNode* root, int l, ull i, um<int,ull>&m) {\\n        if(!root) return 0; //base case\\n        if(m.find(l)==m.end()) m[l] = i; //storing the first node in the map at level l\\n        ull left = dfs(root->left,l+1,2*i,m); //recurse on left subtree\\n        ull right = dfs(root->right,l+1,2*i+1,m); //recurse on right subtree\\n        return max(i-m[l]+1,max(left,right)); //return max of the difference between first and last index and max of left,right\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n#define ull unsigned long long\\n#define um unordered_map\\nclass Solution {\\npublic:\\n    int widthOfBinaryTree(TreeNode* root) {\\n        um<int,ull> f; //storing the last possible index at each level\\n        return dfs(root,0,0,f); // dfs will return you the max width\\n    }\\n    private:\\n    ull dfs(TreeNode* root, int l, ull i, um<int,ull>&m) {\\n        if(!root) return 0; //base case\\n        if(m.find(l)==m.end()) m[l] = i; //storing the first node in the map at level l\\n        ull left = dfs(root->left,l+1,2*i,m); //recurse on left subtree\\n        ull right = dfs(root->right,l+1,2*i+1,m); //recurse on right subtree\\n        return max(i-m[l]+1,max(left,right)); //return max of the difference between first and last index and max of left,right\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1776750,
                "title": "python-easy-to-read-and-understand-bfs",
                "content": "* index of node.left on array is : 2*index + 1\\n* index of node.right on array is : 2*index + 2\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def widthOfBinaryTree(self, root: Optional[TreeNode]) -> int:\\n        q = [(0, root)]\\n        ans = 0\\n        while q:\\n            temp = []\\n            for i in range(len(q)):\\n                ind, node = q.pop(0)\\n                temp.append(ind)\\n                if node.left:\\n                    q.append((2*ind+1, node.left))\\n                if node.right:\\n                    q.append((2*ind+2, node.right))\\n            ans = max(ans, max(temp)-min(temp)+1)\\n        return ans",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "* index of node.left on array is : 2*index + 1\\n* index of node.right on array is : 2*index + 2\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def widthOfBinaryTree(self, root: Optional[TreeNode]) -> int:\\n        q = [(0, root)]\\n        ans = 0\\n        while q:\\n            temp = []\\n            for i in range(len(q)):\\n                ind, node = q.pop(0)\\n                temp.append(ind)\\n                if node.left:\\n                    q.append((2*ind+1, node.left))\\n                if node.right:\\n                    q.append((2*ind+2, node.right))\\n            ans = max(ans, max(temp)-min(temp)+1)\\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 1702694,
                "title": "c-code-fixes-overflow-problem-simple-dfs-solution",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    long long ans;\\n    vector<long long> left,right;\\n   void  dfs(TreeNode* root,int lvl,long long pos){\\n       if(!root) return;\\n        if(left.size()==lvl){ \\n            right.push_back(pos); \\n            left.push_back(pos);\\n        }\\n       right[lvl]=pos;\\n       \\n       ans=max(ans,right[lvl]-left[lvl]+1);\\n       dfs(root->left,lvl+1,pos*2-left[lvl]);\\n       dfs(root->right,lvl+1,pos*2+1-left[lvl]);\\n    }\\n    \\n    int widthOfBinaryTree(TreeNode* root) {\\n        ans=0;\\n        dfs(root,0,1);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long ans;\\n    vector<long long> left,right;\\n   void  dfs(TreeNode* root,int lvl,long long pos){\\n       if(!root) return;\\n        if(left.size()==lvl){ \\n            right.push_back(pos); \\n            left.push_back(pos);\\n        }\\n       right[lvl]=pos;\\n       \\n       ans=max(ans,right[lvl]-left[lvl]+1);\\n       dfs(root->left,lvl+1,pos*2-left[lvl]);\\n       dfs(root->right,lvl+1,pos*2+1-left[lvl]);\\n    }\\n    \\n    int widthOfBinaryTree(TreeNode* root) {\\n        ans=0;\\n        dfs(root,0,1);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1670798,
                "title": "my-1-queue-java-solution-with-bfs",
                "content": "\\n**Algorithm**\\n1. Index all the elements of the tree, either use 0 based or 1 based indexing. I am using 0 based indexing in my solution.\\n2. If the index of parent is let\\'s say **i**, the indices of it\\'s left and right children will be **2i+1** and **2i+2**\\n3. What if the left or right child is null? Doesn\\'t matter, the index is based on the parent and we store only the non null nodes.\\n3. The width of any level will be the lastIndex-firstIndex of the level + 1, i.e. **w=(l-f) +1**\\n4. Do a level order traversal, store the nodes and their indices using the above formula in a Queue of Pair : **Queue< Pair >**  where Pair class has 2 instance variables **node** of type TreeNode and the integer index **idx** \\n5. After each level is traversed, we calculate the **w=(l-f) +1** and compare it with the result and take the max.\\n\\n\\n\\n```\\nclass Solution {\\n    \\n    class Pair{\\n        TreeNode node;\\n        int idx;\\n        \\n        public Pair(TreeNode node, int idx){\\n            this.node = node;\\n            this.idx = idx;\\n        }\\n    }\\n    \\n    public int widthOfBinaryTree(TreeNode root) {\\n        Queue<Pair> q = new LinkedList<Pair>();\\n        q.add(new Pair(root, 0));  //0 based index, root will have the index 0\\n        int res = 1;  //At least there will be one node in the tree\\n        \\n        while(!q.isEmpty()){\\n            int qSize = q.size();\\n            int lastIdx = 0, firstIdx = 0;\\n            \\n            for(int i=0; i<qSize ;i++){\\n                Pair temp = q.poll();\\n                \\n                if(i==0)\\n                    firstIdx = temp.idx;\\n                if(i==qSize-1)\\n                    lastIdx = temp.idx;\\n\\n                if(temp.node.left!=null)\\n                    q.add(new Pair(temp.node.left, 2*(temp.idx)+1));\\n                if(temp.node.right!=null)\\n                     q.add(new Pair(temp.node.right, 2*(temp.idx)+2));\\n            }\\n            res = Math.max((lastIdx-firstIdx)+1, res);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    \\n    class Pair{\\n        TreeNode node;\\n        int idx;\\n        \\n        public Pair(TreeNode node, int idx){\\n            this.node = node;\\n            this.idx = idx;\\n        }\\n    }\\n    \\n    public int widthOfBinaryTree(TreeNode root) {\\n        Queue<Pair> q = new LinkedList<Pair>();\\n        q.add(new Pair(root, 0));  //0 based index, root will have the index 0\\n        int res = 1;  //At least there will be one node in the tree\\n        \\n        while(!q.isEmpty()){\\n            int qSize = q.size();\\n            int lastIdx = 0, firstIdx = 0;\\n            \\n            for(int i=0; i<qSize ;i++){\\n                Pair temp = q.poll();\\n                \\n                if(i==0)\\n                    firstIdx = temp.idx;\\n                if(i==qSize-1)\\n                    lastIdx = temp.idx;\\n\\n                if(temp.node.left!=null)\\n                    q.add(new Pair(temp.node.left, 2*(temp.idx)+1));\\n                if(temp.node.right!=null)\\n                     q.add(new Pair(temp.node.right, 2*(temp.idx)+2));\\n            }\\n            res = Math.max((lastIdx-firstIdx)+1, res);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1396872,
                "title": "c-solution-bfs-4ms-logic-explained",
                "content": "```\\nclass Solution {\\n    typedef pair<TreeNode*, unsigned long> pni;\\npublic:\\n    int widthOfBinaryTree(TreeNode* root) {\\n        // Idea is to use bfs to traverse the BT along with storing an index for each\\n        // node. Index is derived using the array representation of BT i.e if root ind\\n        // is 1 then left child\\'s ind is 2 * ind and right child\\'s ind is 2 * ind + 1\\n        // finally the width of any level is: (level first_node ind - level\\'s last_node ind) + 1\\n        // NOTE: we need to handle the int overflow cases as no. of levels can be large to cause overflow\\n        // NOTE: there are some other method/ tweeks used by other submissions, do check them out \\n        // on discussions tab (most votes section)\\n        int maxWidth = INT_MIN, levelWidth = INT_MIN;\\n        // BFS\\n        queue<pni> bfs;\\n        bfs.push({root, 1});\\n        bfs.push({NULL, 0});\\n        pni levelFirstNode = {root, 1};\\n        pni levelLastNode = {root, 1};\\n        while (!bfs.empty()) {\\n            auto currNode = bfs.front();\\n            bfs.pop();\\n            if (currNode.first) {\\n                if (!bfs.front().first)\\n                    levelLastNode = currNode;\\n                if (currNode.first->left)\\n                    bfs.push({currNode.first->left, 2 * currNode.second});\\n                if (currNode.first->right)\\n                    bfs.push({currNode.first->right, 2 * currNode.second + 1});\\n            }\\n            else {\\n                // the difference can be stored in an int (so no need to use unsigned long \\n                // for levelWidth and maxWidth)\\n                levelWidth = levelLastNode.second - levelFirstNode.second + 1;\\n                maxWidth = max(maxWidth, levelWidth);\\n                if (!bfs.empty()) {\\n                    levelFirstNode = bfs.front();\\n                    bfs.push({NULL, 0});\\n                }\\n            }\\n        }\\n        return maxWidth;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    typedef pair<TreeNode*, unsigned long> pni;\\npublic:\\n    int widthOfBinaryTree(TreeNode* root) {\\n        // Idea is to use bfs to traverse the BT along with storing an index for each\\n        // node. Index is derived using the array representation of BT i.e if root ind\\n        // is 1 then left child\\'s ind is 2 * ind and right child\\'s ind is 2 * ind + 1\\n        // finally the width of any level is: (level first_node ind - level\\'s last_node ind) + 1\\n        // NOTE: we need to handle the int overflow cases as no. of levels can be large to cause overflow\\n        // NOTE: there are some other method/ tweeks used by other submissions, do check them out \\n        // on discussions tab (most votes section)\\n        int maxWidth = INT_MIN, levelWidth = INT_MIN;\\n        // BFS\\n        queue<pni> bfs;\\n        bfs.push({root, 1});\\n        bfs.push({NULL, 0});\\n        pni levelFirstNode = {root, 1};\\n        pni levelLastNode = {root, 1};\\n        while (!bfs.empty()) {\\n            auto currNode = bfs.front();\\n            bfs.pop();\\n            if (currNode.first) {\\n                if (!bfs.front().first)\\n                    levelLastNode = currNode;\\n                if (currNode.first->left)\\n                    bfs.push({currNode.first->left, 2 * currNode.second});\\n                if (currNode.first->right)\\n                    bfs.push({currNode.first->right, 2 * currNode.second + 1});\\n            }\\n            else {\\n                // the difference can be stored in an int (so no need to use unsigned long \\n                // for levelWidth and maxWidth)\\n                levelWidth = levelLastNode.second - levelFirstNode.second + 1;\\n                maxWidth = max(maxWidth, levelWidth);\\n                if (!bfs.empty()) {\\n                    levelFirstNode = bfs.front();\\n                    bfs.push({NULL, 0});\\n                }\\n            }\\n        }\\n        return maxWidth;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1368928,
                "title": "c-short-solution-using-int-type-only-not-long-long-or-unsigned-long-long",
                "content": "```\\nclass Solution {\\npublic:\\n    int widthOfBinaryTree(TreeNode* root) {\\n        // bfs\\n        int maxx=1;\\n        queue<pair<TreeNode*,int>> q; // pair(node, index)\\n        q.push(make_pair(root,0));\\n        while (!q.empty()){\\n            int sz=q.size();\\n            int leftId=-1, rightId=-1;\\n            for (int i=0; i<sz; i++){\\n                TreeNode *x=q.front().first;\\n                int id=q.front().second;\\n                q.pop();\\n                if (x->left!=NULL){\\n                    if (leftId==-1){\\n                        leftId=id*2;\\n                    }\\n                    int newId=id*2-leftId;\\n                    q.push(make_pair(x->left,newId));\\n                    rightId=newId;\\n                }\\n                if (x->right!=NULL){\\n                    if (leftId==-1){\\n                        leftId=id*2+1;\\n                    }\\n                    int newId=id*2+1-leftId;\\n                    q.push(make_pair(x->right,newId));\\n                    rightId=newId;\\n                }               \\n            }\\n            maxx=max(maxx,rightId+1);            \\n        }\\n        return maxx;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int widthOfBinaryTree(TreeNode* root) {\\n        // bfs\\n        int maxx=1;\\n        queue<pair<TreeNode*,int>> q; // pair(node, index)\\n        q.push(make_pair(root,0));\\n        while (!q.empty()){\\n            int sz=q.size();\\n            int leftId=-1, rightId=-1;\\n            for (int i=0; i<sz; i++){\\n                TreeNode *x=q.front().first;\\n                int id=q.front().second;\\n                q.pop();\\n                if (x->left!=NULL){\\n                    if (leftId==-1){\\n                        leftId=id*2;\\n                    }\\n                    int newId=id*2-leftId;\\n                    q.push(make_pair(x->left,newId));\\n                    rightId=newId;\\n                }\\n                if (x->right!=NULL){\\n                    if (leftId==-1){\\n                        leftId=id*2+1;\\n                    }\\n                    int newId=id*2+1-leftId;\\n                    q.push(make_pair(x->right,newId));\\n                    rightId=newId;\\n                }               \\n            }\\n            maxx=max(maxx,rightId+1);            \\n        }\\n        return maxx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1326383,
                "title": "2-minute-read-simple-dfs-bfs-solution",
                "content": "The basic idea to this problem is that, if we would want to number each node in a particular level of the binary tree from left to right (including the `null` nodes), starting from `1`, then it would look something like this....\\n```\\n              1\\n        /           \\\\\\n      1               2\\n   /     \\\\         /     \\\\\\n  1       2       3       4\\n / \\\\     / \\\\     / \\\\     / \\\\\\n1   2   3   4   5   6   7   8\\n```\\nSo, as it could be seen from this example, the `left` child of any node (which has a number say `x`) would have a number `(2 * x - 1)` and the `right` child would have a number `(2 * x)`. Using the property, our algorithm for this problem comes out to be : \\n1. Perform DFS and save the node and the corresponding number calculated for this node in a `HashMap`.\\n2. Now perform Level-Order Traversal (BFS) and for each level, find the width of that level using the first and last element of that level.\\n3. Find the maximum width among all the levels of the tree.\\n\\nBelow is the Java Code for the above algorithm \\n\\n```java\\nclass Solution {\\n    Map<TreeNode, Integer> map;\\n    public int widthOfBinaryTree(TreeNode root) {\\n        map = new HashMap<>();\\n        if(root == null) return 0;\\n        dfs(root, 1);\\n        \\n        Queue<TreeNode> q = new LinkedList<>();\\n        int ans = 0;\\n        q.add(root);\\n        while(!q.isEmpty()) {\\n            int size = q.size();\\n            int start = 0, end = 0;\\n            for(int i = 0; i < size; i++) {\\n                TreeNode temp = q.poll();\\n                if(i == 0) start = map.get(temp);\\n                if(i == size - 1) end = map.get(temp);\\n                if(temp.left != null) q.add(temp.left);\\n                if(temp.right != null) q.add(temp.right);\\n            }\\n            ans = Math.max(ans, end - start + 1);\\n        }\\n        return ans;\\n    }\\n    \\n    public void dfs(TreeNode node, int val) {\\n        if(node == null) return;\\n        \\n        map.put(node, val);\\n        dfs(node.left, 2 * val - 1);\\n        dfs(node.right, 2 * val);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n              1\\n        /           \\\\\\n      1               2\\n   /     \\\\         /     \\\\\\n  1       2       3       4\\n / \\\\     / \\\\     / \\\\     / \\\\\\n1   2   3   4   5   6   7   8\\n```\n```java\\nclass Solution {\\n    Map<TreeNode, Integer> map;\\n    public int widthOfBinaryTree(TreeNode root) {\\n        map = new HashMap<>();\\n        if(root == null) return 0;\\n        dfs(root, 1);\\n        \\n        Queue<TreeNode> q = new LinkedList<>();\\n        int ans = 0;\\n        q.add(root);\\n        while(!q.isEmpty()) {\\n            int size = q.size();\\n            int start = 0, end = 0;\\n            for(int i = 0; i < size; i++) {\\n                TreeNode temp = q.poll();\\n                if(i == 0) start = map.get(temp);\\n                if(i == size - 1) end = map.get(temp);\\n                if(temp.left != null) q.add(temp.left);\\n                if(temp.right != null) q.add(temp.right);\\n            }\\n            ans = Math.max(ans, end - start + 1);\\n        }\\n        return ans;\\n    }\\n    \\n    public void dfs(TreeNode node, int val) {\\n        if(node == null) return;\\n        \\n        map.put(node, val);\\n        dfs(node.left, 2 * val - 1);\\n        dfs(node.right, 2 * val);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1308795,
                "title": "easy-c-bfs-solution-commented",
                "content": "```\\nclass Solution {\\npublic:\\n    int widthOfBinaryTree(TreeNode* root) {\\n        \\n        //we use bfs to traverse the nodes\\n        queue<pair<TreeNode*,unsigned long long int>> q;\\n        //pair.first is the node  and pair.second (id) is a number  \\n        //it denotes the number of nodes in the complete tree that can be present  upto current level\\n        q.push({root,1});\\n        int res=0;\\n        int curr;\\n        while(!q.empty())\\n        {\\n            int size=q.size();\\n            if(size==1)\\n            {\\n                //rename the pair.second value as 1 now this sub tree can be considered as seperate tree\\n                q.push({q.front().first,1});\\n                q.pop();\\n            }\\n            curr=q.back().second-q.front().second +1;\\n            //update the maximum result with   the current level result\\n            res=max(res,curr );\\n            for(int i=0;i<size;i++)\\n            {\\n                auto [front,id]=q.front();\\n                q.pop();\\n                //if left child exists then the id would be 2*current node id\\n                if(front->left)\\n                    q.push({front->left,2*id});\\n                //if right child exists then the id would be 2*current node id +1 \\n                if(front->right)\\n                    q.push({front->right,2*id+1});\\n            }\\n        }\\n        return res;\\n        \\n    }\\n};\\n```\\n**Upvote if this helps you :)**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int widthOfBinaryTree(TreeNode* root) {\\n        \\n        //we use bfs to traverse the nodes\\n        queue<pair<TreeNode*,unsigned long long int>> q;\\n        //pair.first is the node  and pair.second (id) is a number  \\n        //it denotes the number of nodes in the complete tree that can be present  upto current level\\n        q.push({root,1});\\n        int res=0;\\n        int curr;\\n        while(!q.empty())\\n        {\\n            int size=q.size();\\n            if(size==1)\\n            {\\n                //rename the pair.second value as 1 now this sub tree can be considered as seperate tree\\n                q.push({q.front().first,1});\\n                q.pop();\\n            }\\n            curr=q.back().second-q.front().second +1;\\n            //update the maximum result with   the current level result\\n            res=max(res,curr );\\n            for(int i=0;i<size;i++)\\n            {\\n                auto [front,id]=q.front();\\n                q.pop();\\n                //if left child exists then the id would be 2*current node id\\n                if(front->left)\\n                    q.push({front->left,2*id});\\n                //if right child exists then the id would be 2*current node id +1 \\n                if(front->right)\\n                    q.push({front->right,2*id+1});\\n            }\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1130116,
                "title": "java-1ms-using-one-queue-with-pair",
                "content": "```\\nclass Solution {\\n    public int widthOfBinaryTree(TreeNode root) {\\n        int max = Integer.MIN_VALUE, left = 0, right = 0;\\n        Queue<Pair<TreeNode, Integer>> q = new LinkedList<>();\\n        if(root != null)\\n            q.add(new Pair<TreeNode, Integer>(root, 1));\\n        \\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            for(int i=0;i<size;i++){\\n                Pair<TreeNode, Integer> temp = q.poll();\\n                if(i==0)\\n                    left = temp.getValue();\\n                if(i==size-1)\\n                    right = temp.getValue();\\n                if(temp.getKey().left != null)\\n                    q.add(new Pair<TreeNode, Integer>(temp.getKey().left , temp.getValue()*2));\\n                if(temp.getKey().right != null)\\n                    q.add(new Pair<TreeNode, Integer>(temp.getKey().right, temp.getValue()*2 + 1));\\n            }\\n            max = Math.max(max , right - left + 1);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int widthOfBinaryTree(TreeNode root) {\\n        int max = Integer.MIN_VALUE, left = 0, right = 0;\\n        Queue<Pair<TreeNode, Integer>> q = new LinkedList<>();\\n        if(root != null)\\n            q.add(new Pair<TreeNode, Integer>(root, 1));\\n        \\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            for(int i=0;i<size;i++){\\n                Pair<TreeNode, Integer> temp = q.poll();\\n                if(i==0)\\n                    left = temp.getValue();\\n                if(i==size-1)\\n                    right = temp.getValue();\\n                if(temp.getKey().left != null)\\n                    q.add(new Pair<TreeNode, Integer>(temp.getKey().left , temp.getValue()*2));\\n                if(temp.getKey().right != null)\\n                    q.add(new Pair<TreeNode, Integer>(temp.getKey().right, temp.getValue()*2 + 1));\\n            }\\n            max = Math.max(max , right - left + 1);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1051024,
                "title": "python-bfs-a-few-notes",
                "content": "A few notes:\\n* We essentially want to keep a running (x, y) coordinate of the current node\\n\\t* We do this by assigning left nodes (2*x, y+1) and right nodes (2*x + 1, y+1) coordinates respectively\\n* Make sure not to use `defaultdict` as when you update the min, it could return `0`, throwing off your width\\n\\t* If you get really large widths, e.g, 32, when the answer should be 4 or 8 for example, this may be your issue\\n* Remember to do `right - left + 1` (this hopefully is intuitive)\\n\\n\\nI think this problem is really tricky because its easy to intuitively assign left and right (x-1, y) and (x+1, y) respectively, for example, which obviously cannot be used to solve this problem. This is honestly a fantastic practice problem.\\n\\n\\n```python\\nclass Solution:\\n    \\n    def widthOfBinaryTree(self, root: TreeNode) -> int:        \\n \\n        queue = collections.deque([(root, 0, 0)])\\n    \\n        left, right = {}, {}\\n    \\n        result = 0\\n    \\n        while queue:\\n            node, x, y = queue.popleft()\\n            if not node: continue\\n            left[y] = min(left.get(y, x), x)\\n            right[y] = max(right.get(y, x), x)\\n            result = max(result, right[y]-left[y]+1)\\n            queue.extend([\\n                (node.left, 2*x, y+1),\\n                (node.right, (2*x)+1, y+1)\\n            ])\\n            \\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```python\\nclass Solution:\\n    \\n    def widthOfBinaryTree(self, root: TreeNode) -> int:        \\n \\n        queue = collections.deque([(root, 0, 0)])\\n    \\n        left, right = {}, {}\\n    \\n        result = 0\\n    \\n        while queue:\\n            node, x, y = queue.popleft()\\n            if not node: continue\\n            left[y] = min(left.get(y, x), x)\\n            right[y] = max(right.get(y, x), x)\\n            result = max(result, right[y]-left[y]+1)\\n            queue.extend([\\n                (node.left, 2*x, y+1),\\n                (node.right, (2*x)+1, y+1)\\n            ])\\n            \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 992533,
                "title": "easy-bfs-solution-with-one-queue",
                "content": "class Solution {\\n\\n    public int widthOfBinaryTree(TreeNode root) {\\n        if(root == null){\\n                return 0;\\n        }\\n\\t\\t//Store the TreeNode and counter which keep track of the position of each node in the Queue \\n        Queue<Pair<TreeNode, Integer>> queue = new LinkedList<>();\\n\\t\\t//Count will start from 1 and will increase by 1 for the next node in level order traversal\\n        queue.add(new Pair(root, 1));\\n        int width = 0;\\n        while(queue.size() > 0){\\n\\t\\t// To keep track of the first TreeNode in a level we store it.\\n            Pair<TreeNode, Integer> first = queue.peek();\\t\\n            int size = queue.size();\\n            Pair<TreeNode, Integer> second = null;\\n            for(int i = 0; i< size; i++){\\n                second = queue.poll();\\n                TreeNode node = second.getKey();\\n                if(node.left != null){\\n                    queue.add(new Pair<>(node.left, 2 * second.getValue()));\\n                }\\n                if(node.right != null){\\n                    queue.add(new Pair<>(node.right, 2 * second.getValue()+1));\\n                }\\n            }\\n\\t\\t\\t//calculating the width\\n            width = Math.max(width, second.getValue() - first.getValue() +1);\\n        }\\n        return width;\\n}\\n}",
                "solutionTags": [
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "class Solution {\\n\\n    public int widthOfBinaryTree(TreeNode root) {\\n        if(root == null){\\n                return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 944730,
                "title": "java-1ms-bfs-elegantly-solves-integer-overflow-without-using-long-or-a-custom-class",
                "content": "1. Store node position in TreeNode.val, where node position is a distance from left edge in the same level. Initializing root position with 0, each child position will be calculated by following code\\n```\\nnode.left.val = node.val * 2;\\nnode.right.val = node.val * 2 + 1;\\n```\\n \\n![image](https://assets.leetcode.com/users/images/80e8d981-05be-45a8-8106-543bff6496e8_1606021271.5873144.png)\\n\\n2. To fix integer overflow we offset node position by the position of the leftmost node:\\n```\\nint normalizedNodePosition = node.val - leftNodePosition;\\nnode.left.val = normalizedNodePosition * 2;\\nnode.right.val = normalizedNodePosition * 2 + 1;\\n```\\n![image](https://assets.leetcode.com/users/images/7d24f70e-68f5-487d-8554-88d6767bce93_1606024153.5481968.png)\\n\\n**[Java]**\\n```\\n    public int widthOfBinaryTree(TreeNode root) {\\n        int maxWidth = 0;\\n        \\n        Queue<TreeNode> q = new LinkedList<>();\\n\\t\\t// Utilize val to store node position in current level\\n        root.val = 0;\\n        q.add(root);\\n        \\n        while (!q.isEmpty()) {\\n            int len = q.size();\\n\\n\\t\\t\\t// Store leftmost node position of current level\\n            int leftNodePosition = q.peek().val;\\n            \\n\\t\\t\\tTreeNode node = null;\\n\\t\\t\\t\\n            for (int i = 0; i < len; i++) {\\n                node = q.poll();\\n                \\n\\t\\t\\t\\t// Offset node position by leftmost node position\\n\\t\\t\\t\\tint normalizedNodePosition = node.val - leftNodePosition;\\n\\t\\t\\t\\t\\n                if (node.left != null) {\\n                    node.left.val = normalizedNodePosition * 2;\\n                    q.add(node.left);\\n                }\\n                \\n                if (node.right != null) {\\n                    node.right.val = normalizedNodePosition * 2 + 1;\\n                    q.add(node.right);\\n                }\\n            }\\n            \\n\\t\\t\\t// node at this point is the rightmost node of current level\\n\\t\\t\\tint rightNodePosition = node.val;\\n            maxWidth = Math.max(maxWidth, rightNodePosition - leftNodePosition + 1);\\n        }\\n        \\n        return maxWidth;\\n    }\\n```\\n\\nSome variables are added so code is easier to undestand",
                "solutionTags": [],
                "code": "```\\nnode.left.val = node.val * 2;\\nnode.right.val = node.val * 2 + 1;\\n```\n```\\nint normalizedNodePosition = node.val - leftNodePosition;\\nnode.left.val = normalizedNodePosition * 2;\\nnode.right.val = normalizedNodePosition * 2 + 1;\\n```\n```\\n    public int widthOfBinaryTree(TreeNode root) {\\n        int maxWidth = 0;\\n        \\n        Queue<TreeNode> q = new LinkedList<>();\\n\\t\\t// Utilize val to store node position in current level\\n        root.val = 0;\\n        q.add(root);\\n        \\n        while (!q.isEmpty()) {\\n            int len = q.size();\\n\\n\\t\\t\\t// Store leftmost node position of current level\\n            int leftNodePosition = q.peek().val;\\n            \\n\\t\\t\\tTreeNode node = null;\\n\\t\\t\\t\\n            for (int i = 0; i < len; i++) {\\n                node = q.poll();\\n                \\n\\t\\t\\t\\t// Offset node position by leftmost node position\\n\\t\\t\\t\\tint normalizedNodePosition = node.val - leftNodePosition;\\n\\t\\t\\t\\t\\n                if (node.left != null) {\\n                    node.left.val = normalizedNodePosition * 2;\\n                    q.add(node.left);\\n                }\\n                \\n                if (node.right != null) {\\n                    node.right.val = normalizedNodePosition * 2 + 1;\\n                    q.add(node.right);\\n                }\\n            }\\n            \\n\\t\\t\\t// node at this point is the rightmost node of current level\\n\\t\\t\\tint rightNodePosition = node.val;\\n            maxWidth = Math.max(maxWidth, rightNodePosition - leftNodePosition + 1);\\n        }\\n        \\n        return maxWidth;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 920333,
                "title": "beats-99-easiest-c-well-explained",
                "content": "```\\n#define ll unsigned long long\\nclass Solution {\\n    \\n// the idea is simply to do a bfs traversal and compare the first and\\n// the last node of a level, now rather than storing vertical distance \\n// (to avoid complications of whether both node are at one side of root)\\n// nodes from root, we will use heap based index, that is indexing the \\n// level wise and then left to right: 2*index(left) & 2*index + 1(right)\\n// then simply compare the index of first and last node of the level\\n    \\npublic:\\n    int widthOfBinaryTree(TreeNode* root) {\\n        \\n        if(!root)\\n            return 0;\\n        \\n        ll maxi = 1;\\n        queue<pair<TreeNode*, ll>> level;\\n        level.push({root, 1});\\n        \\n        while(!level.empty()){\\n            \\n            long long size = level.size();\\n            \\n            // storing index of first node and index of last node will\\n            // be stored in variable index when size loop terminates\\n            ll first_index = level.front().second, index;\\n            \\n            // traversing level wise\\n            while(size--){\\n                \\n                TreeNode * node = level.front().first;    \\n                index = level.front().second;\\n                level.pop();\\n                \\n                if(node->left) level.push({node->left, 2*index});\\n                if(node->right) level.push({node->right, 2*index+1});\\n            }\\n            \\n            //comparing the width of current level to max so far\\n            maxi = max(maxi, (index - first_index) + 1);\\n        }\\n        \\n        return maxi;\\n    }   \\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define ll unsigned long long\\nclass Solution {\\n    \\n// the idea is simply to do a bfs traversal and compare the first and\\n// the last node of a level, now rather than storing vertical distance \\n// (to avoid complications of whether both node are at one side of root)\\n// nodes from root, we will use heap based index, that is indexing the \\n// level wise and then left to right: 2*index(left) & 2*index + 1(right)\\n// then simply compare the index of first and last node of the level\\n    \\npublic:\\n    int widthOfBinaryTree(TreeNode* root) {\\n        \\n        if(!root)\\n            return 0;\\n        \\n        ll maxi = 1;\\n        queue<pair<TreeNode*, ll>> level;\\n        level.push({root, 1});\\n        \\n        while(!level.empty()){\\n            \\n            long long size = level.size();\\n            \\n            // storing index of first node and index of last node will\\n            // be stored in variable index when size loop terminates\\n            ll first_index = level.front().second, index;\\n            \\n            // traversing level wise\\n            while(size--){\\n                \\n                TreeNode * node = level.front().first;    \\n                index = level.front().second;\\n                level.pop();\\n                \\n                if(node->left) level.push({node->left, 2*index});\\n                if(node->right) level.push({node->right, 2*index+1});\\n            }\\n            \\n            //comparing the width of current level to max so far\\n            maxi = max(maxi, (index - first_index) + 1);\\n        }\\n        \\n        return maxi;\\n    }   \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 812383,
                "title": "c-simple-o-n-bfs-solution-c-overflow-fix-detailed-explanation",
                "content": "```\\n/*\\n    Approach 1:\\n    My first approach was to use normal BFS with null + non null nodes as well.\\n    Idea was to push 2 child nodes(left + right) for a null node and for non-null node\\n    push its childrean, incase there was only one, then the other child is pushed as null.\\n    This solution resulted in timeout.\\n    \\n    Approach 2:\\n    A binary tree can also be saved in an array, the way we see in a heap implementation. To save a binary\\n    tree in an array like DS, for ith index node, we save its left child at 2*i, right: 2*i + 1, when 1 based indexing is\\n    considered.\\n    So now in that array if we knew the the range of elements belonging to diff levels, we could have just taken the diff\\n    of last and first node index and keep track of this for all the levels. So to know the level, we can use BFS.\\n        1\\n       / \\\\\\n      2   NULL\\n    eg: 1(1) 2(2) NULL(3), (1 based index)\\n    \\n    We do BFS, and we associate each node with the index where it would have been saved incase it was stored in an array.\\n    Now since in BFS, we can track the first and last node, we check the diff of index position between them and compare \\n    with max width found so far.\\n    \\n    Challenge(Applicable to lang. with no native big Integer support): Since the index numbers can get too big, the case needs to be handled well.\\n        If we use a signed int, then for bigger numbers that result is a -ve num, now\\n        to find the diff in indices, (-A) - (+B), where A and B both are big and A > max limit so it is -ve, and has\\n        an undefined behavior in C++.\\n        So to solve this, we can use an unsigned int/long, so even with big nums, there is \\n        a defined behavior using % N incase of unsigned.\\n*/\\n\\n\\nclass Solution {\\npublic:\\n    // Tree node with index position\\n    struct NodeIndex {\\n        TreeNode *node = nullptr;\\n        unsigned long index = -1;\\n        NodeIndex(TreeNode *node, unsigned long idx): node(node), index(idx) {};\\n    };\\n    \\n    // TC: O(N)\\n    int widthOfBinaryTree(TreeNode* root) {\\n        queue<NodeIndex> q;\\n        unsigned long max_width = 0;\\n        // keeps track of first and last position index\\n        unsigned long first = -1, last = -1;\\n        \\n        q.emplace(NodeIndex(root, 1));\\n        int n_level = q.size();\\n        \\n        // Do a normal BFS, and for each level find the\\n        // diff of first and last element index if they are stored in array like storage \\n        while(!q.empty()) {\\n            NodeIndex curr = q.front();\\n            q.pop();\\n            --n_level;\\n            \\n            if(first == -1)\\n                first = curr.index;\\n            \\n            if(curr.node->left)\\n                q.emplace(NodeIndex(curr.node->left, 2 * curr.index));\\n\\n            if(curr.node->right)\\n                q.emplace(NodeIndex(curr.node->right, 2 * curr.index + 1));\\n            \\n            // end of level\\n            if(n_level == 0) {\\n                last = curr.index;\\n                // update max width if applicable\\n                max_width = max(max_width, last - first + 1);\\n                n_level = q.size();\\n                // reset\\n                first = -1, last = -1;\\n            }\\n        }\\n        \\n        return max_width;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n/*\\n    Approach 1:\\n    My first approach was to use normal BFS with null + non null nodes as well.\\n    Idea was to push 2 child nodes(left + right) for a null node and for non-null node\\n    push its childrean, incase there was only one, then the other child is pushed as null.\\n    This solution resulted in timeout.\\n    \\n    Approach 2:\\n    A binary tree can also be saved in an array, the way we see in a heap implementation. To save a binary\\n    tree in an array like DS, for ith index node, we save its left child at 2*i, right: 2*i + 1, when 1 based indexing is\\n    considered.\\n    So now in that array if we knew the the range of elements belonging to diff levels, we could have just taken the diff\\n    of last and first node index and keep track of this for all the levels. So to know the level, we can use BFS.\\n        1\\n       / \\\\\\n      2   NULL\\n    eg: 1(1) 2(2) NULL(3), (1 based index)\\n    \\n    We do BFS, and we associate each node with the index where it would have been saved incase it was stored in an array.\\n    Now since in BFS, we can track the first and last node, we check the diff of index position between them and compare \\n    with max width found so far.\\n    \\n    Challenge(Applicable to lang. with no native big Integer support): Since the index numbers can get too big, the case needs to be handled well.\\n        If we use a signed int, then for bigger numbers that result is a -ve num, now\\n        to find the diff in indices, (-A) - (+B), where A and B both are big and A > max limit so it is -ve, and has\\n        an undefined behavior in C++.\\n        So to solve this, we can use an unsigned int/long, so even with big nums, there is \\n        a defined behavior using % N incase of unsigned.\\n*/\\n\\n\\nclass Solution {\\npublic:\\n    // Tree node with index position\\n    struct NodeIndex {\\n        TreeNode *node = nullptr;\\n        unsigned long index = -1;\\n        NodeIndex(TreeNode *node, unsigned long idx): node(node), index(idx) {};\\n    };\\n    \\n    // TC: O(N)\\n    int widthOfBinaryTree(TreeNode* root) {\\n        queue<NodeIndex> q;\\n        unsigned long max_width = 0;\\n        // keeps track of first and last position index\\n        unsigned long first = -1, last = -1;\\n        \\n        q.emplace(NodeIndex(root, 1));\\n        int n_level = q.size();\\n        \\n        // Do a normal BFS, and for each level find the\\n        // diff of first and last element index if they are stored in array like storage \\n        while(!q.empty()) {\\n            NodeIndex curr = q.front();\\n            q.pop();\\n            --n_level;\\n            \\n            if(first == -1)\\n                first = curr.index;\\n            \\n            if(curr.node->left)\\n                q.emplace(NodeIndex(curr.node->left, 2 * curr.index));\\n\\n            if(curr.node->right)\\n                q.emplace(NodeIndex(curr.node->right, 2 * curr.index + 1));\\n            \\n            // end of level\\n            if(n_level == 0) {\\n                last = curr.index;\\n                // update max width if applicable\\n                max_width = max(max_width, last - first + 1);\\n                n_level = q.size();\\n                // reset\\n                first = -1, last = -1;\\n            }\\n        }\\n        \\n        return max_width;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 727527,
                "title": "simple-bfs-and-dfs-solution-in-c-with-explanation",
                "content": "The question asks about the maximum width of the binary tree if the binary tree is full. So lets forget about what val is stored in each node, but lets try to figure if the binary tree is full, how mamy values can it store.\\n\\n```\\nLets take the testcase given:\\n\\t\\t  1\\n         /   \\\\\\n        3     2\\n       / \\\\     \\\\  \\n      5   3     9 \\n\\t  \\nHere 1, 3, 2, 5, 3, 9 are values. Don\\'t care about the values but its 3 level tree. A 3 level full binary tree looks like:\\n    1\\n   /  \\\\\\n  2     3\\n /  \\\\  /  \\\\\\n4  5  6    7\\n\\nThis is a full binary tree of depth or level 3. Here 1,2,3,4,5,6,7 are not the values but indices. Values can be anything and we don\\'t care.\\n\\nNow take node 1 - the index to the left is 2 and right is 3 which is basically 2 * n and 2 * n + 1.\\nSimilarly for node 3 - the index to the left is 6 and right is 7 which is again 2 * n and 2 * n + 1.\\n\\nNow whats the width? \\nFor level 1, it is 1 - 1 + 1 = 1\\nlevel 2 = 3 - 2 + 1 = 2\\nlevel 3 = 7 - 4 + 1 = 4\\n\\nThis is nothing but lastIndex - firstIndex + 1 in a level.\\n\\n\\nMaximum width is 4. Hence the ans.\\n```\\n\\nDFS:\\n```\\nvoid widthOfBinaryTreeDFS(TreeNode* node, unordered_map<int, int>& hashmap, int& ans, int depth, int val)\\n\\t{\\n\\t\\tif (node == nullptr)\\n\\t\\t{\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tif (hashmap.find(depth) == hashmap.end())\\n\\t\\t{\\n\\t\\t\\thashmap[depth] = val;\\n\\t\\t}\\n\\n\\t\\tint firstVal = hashmap[depth];\\n\\t\\tans = std::max(ans, val - firstVal + 1);\\n\\n\\t\\twidthOfBinaryTreeDFS(node->left, hashmap, ans, depth + 1, 2 * (long)val);\\n\\t\\twidthOfBinaryTreeDFS(node->right, hashmap, ans, depth + 1, 2 * (long)val + 1);\\n\\t}\\n    \\n    int widthOfBinaryTree(TreeNode* root) {\\n        unordered_map<int, int> hashmap;\\n\\t\\tint ans = 0;\\n\\n\\t\\twidthOfBinaryTreeDFS(root, hashmap, ans, 0, 0);\\n\\t\\treturn ans;\\n    }\\n\\t```\\n\\t\\n\\t\\n\\t\\n\\t\\n\\tBFS:\\n\\t\\n\\tint widthOfBinaryTree(TreeNode* root)\\n\\t{\\n\\t\\tif (root == nullptr)\\n\\t\\t{\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\n\\t\\tqueue<pair<TreeNode*, int>> q;\\n\\t\\tq.push({ root, 1 });\\n\\t\\tint ans = 0;\\n\\n\\t\\twhile (!q.empty())\\n\\t\\t{\\n\\t\\t\\tint size = q.size();\\n\\t\\t\\tpair<TreeNode *, int> end = q.back();\\n\\t\\t\\tpair<TreeNode *, int> start = q.front();\\n\\t\\t\\tans = std::max(ans, (end.second - start.second) + 1);\\n\\n\\t\\t\\tfor (int i = 0; i < size; ++i)\\n\\t\\t\\t{\\n\\t\\t\\t\\tconst auto &[node, val] = q.front();\\n\\t\\t\\t\\tq.pop();\\n\\n\\t\\t\\t\\tif (node->left != nullptr)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tq.push({ node->left, 2 * (long)val });\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif (node->right != nullptr)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tq.push({ node->right, 2 * (long)val + 1 });\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n\\t```",
                "solutionTags": [],
                "code": "```\\nLets take the testcase given:\\n\\t\\t  1\\n         /   \\\\\\n        3     2\\n       / \\\\     \\\\  \\n      5   3     9 \\n\\t  \\nHere 1, 3, 2, 5, 3, 9 are values. Don\\'t care about the values but its 3 level tree. A 3 level full binary tree looks like:\\n    1\\n   /  \\\\\\n  2     3\\n /  \\\\  /  \\\\\\n4  5  6    7\\n\\nThis is a full binary tree of depth or level 3. Here 1,2,3,4,5,6,7 are not the values but indices. Values can be anything and we don\\'t care.\\n\\nNow take node 1 - the index to the left is 2 and right is 3 which is basically 2 * n and 2 * n + 1.\\nSimilarly for node 3 - the index to the left is 6 and right is 7 which is again 2 * n and 2 * n + 1.\\n\\nNow whats the width? \\nFor level 1, it is 1 - 1 + 1 = 1\\nlevel 2 = 3 - 2 + 1 = 2\\nlevel 3 = 7 - 4 + 1 = 4\\n\\nThis is nothing but lastIndex - firstIndex + 1 in a level.\\n\\n\\nMaximum width is 4. Hence the ans.\\n```\n```\\nvoid widthOfBinaryTreeDFS(TreeNode* node, unordered_map<int, int>& hashmap, int& ans, int depth, int val)\\n\\t{\\n\\t\\tif (node == nullptr)\\n\\t\\t{\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tif (hashmap.find(depth) == hashmap.end())\\n\\t\\t{\\n\\t\\t\\thashmap[depth] = val;\\n\\t\\t}\\n\\n\\t\\tint firstVal = hashmap[depth];\\n\\t\\tans = std::max(ans, val - firstVal + 1);\\n\\n\\t\\twidthOfBinaryTreeDFS(node->left, hashmap, ans, depth + 1, 2 * (long)val);\\n\\t\\twidthOfBinaryTreeDFS(node->right, hashmap, ans, depth + 1, 2 * (long)val + 1);\\n\\t}\\n    \\n    int widthOfBinaryTree(TreeNode* root) {\\n        unordered_map<int, int> hashmap;\\n\\t\\tint ans = 0;\\n\\n\\t\\twidthOfBinaryTreeDFS(root, hashmap, ans, 0, 0);\\n\\t\\treturn ans;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 727061,
                "title": "javascript-bfs-adjusted",
                "content": "```New code passing new test cases```\\n```\\nconst widthOfBinaryTree = (root) => {\\n    if (root === null) return 0;\\n    let maxWidth = 0;\\n    const queue = [[root,0]];\\n    while (queue.length){\\n        const size = queue.length;\\n        let leftIdx = -1, rightIdx = -1;\\n        for (let i = 0; i < size; i++){\\n            const [curNode, index] = queue.shift();\\n            if (i === 0) leftIdx = index;\\n            if (i === size-1) rightIdx = index;\\n            \\n            if (curNode.left !== null) queue.push([curNode.left, (index*2+0) % 2**32]);\\n            if (curNode.right !== null) queue.push([curNode.right, (index*2+1) % 2**32]);\\n        }\\n        \\n        maxWidth = Math.max(maxWidth, rightIdx-leftIdx+1);\\n    }\\n    return maxWidth;\\n}\\n```\\n```Old code failing new test cases```\\n- BFS with each node and its position\\n- left node has a position of 2 * previous node\\'s position\\n- right node has a position of 2 * previous node\\'s position + 1\\n- root is at position 0\\n- calculate the width of the level as furthest right position - furthest left position + 1\\n- for each level, if the size is 1, right position - furthest left position + 1 = 0 + 1 = 1\\n\\n- maintained in an array, width = position of last element - position of first element + 1\\n\\n```\\n\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number}\\n */\\n\\nvar widthOfBinaryTree = function(root) {\\n    if (root == null) return 0\\n    let max = 0\\n    let queue = [[root, 0]]\\n    while (queue.length){\\n        let size = queue.length\\n        let currentLevel = []\\n        for (let i = 0; i < size; i++){\\n            let [node, position] = queue.shift()\\n            currentLevel.push([node, position])\\n            if (node.left){\\n                queue.push([node.left, position * 2])\\n            }\\n            if (node.right){\\n                queue.push([node.right, position * 2 + 1])\\n            }\\n        }\\n\\n        let currLevelWidth = currentLevel.length === 1 ? 1 : currentLevel[currentLevel.length - 1][1] - currentLevel[0][1] + 1\\n        max = Math.max(max, currLevelWidth)\\n    }\\n    return max\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```New code passing new test cases```\n```\\nconst widthOfBinaryTree = (root) => {\\n    if (root === null) return 0;\\n    let maxWidth = 0;\\n    const queue = [[root,0]];\\n    while (queue.length){\\n        const size = queue.length;\\n        let leftIdx = -1, rightIdx = -1;\\n        for (let i = 0; i < size; i++){\\n            const [curNode, index] = queue.shift();\\n            if (i === 0) leftIdx = index;\\n            if (i === size-1) rightIdx = index;\\n            \\n            if (curNode.left !== null) queue.push([curNode.left, (index*2+0) % 2**32]);\\n            if (curNode.right !== null) queue.push([curNode.right, (index*2+1) % 2**32]);\\n        }\\n        \\n        maxWidth = Math.max(maxWidth, rightIdx-leftIdx+1);\\n    }\\n    return maxWidth;\\n}\\n```\n```Old code failing new test cases```\n```\\n\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number}\\n */\\n\\nvar widthOfBinaryTree = function(root) {\\n    if (root == null) return 0\\n    let max = 0\\n    let queue = [[root, 0]]\\n    while (queue.length){\\n        let size = queue.length\\n        let currentLevel = []\\n        for (let i = 0; i < size; i++){\\n            let [node, position] = queue.shift()\\n            currentLevel.push([node, position])\\n            if (node.left){\\n                queue.push([node.left, position * 2])\\n            }\\n            if (node.right){\\n                queue.push([node.right, position * 2 + 1])\\n            }\\n        }\\n\\n        let currLevelWidth = currentLevel.length === 1 ? 1 : currentLevel[currentLevel.length - 1][1] - currentLevel[0][1] + 1\\n        max = Math.max(max, currLevelWidth)\\n    }\\n    return max\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 727054,
                "title": "max-width-of-binary-tree-simple-java-solution",
                "content": "```\\nclass Solution {\\n    int maxWidth = 0;\\n    Map<Integer, Integer> map;\\n    \\n    public int widthOfBinaryTree(TreeNode root) {\\n        \\n        if(root == null) return 0;\\n        \\n        this.map = new HashMap<Integer, Integer>();        \\n        \\n        this.maxWidth(root, 0, 0);\\n        \\n        return this.maxWidth;\\n        \\n    }\\n    \\n    public void maxWidth(TreeNode root, int depth, int position){\\n        \\n        if(root == null) return;\\n        \\n        this.map.computeIfAbsent(depth, x -> position);\\n        \\n        this.maxWidth = Math.max(this.maxWidth, position - this.map.get(depth) + 1);\\n        \\n        this.maxWidth(root.left, depth + 1 , position * 2);\\n        \\n        this.maxWidth(root.right, depth + 1 , position * 2 + 1);\\n               \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int maxWidth = 0;\\n    Map<Integer, Integer> map;\\n    \\n    public int widthOfBinaryTree(TreeNode root) {\\n        \\n        if(root == null) return 0;\\n        \\n        this.map = new HashMap<Integer, Integer>();        \\n        \\n        this.maxWidth(root, 0, 0);\\n        \\n        return this.maxWidth;\\n        \\n    }\\n    \\n    public void maxWidth(TreeNode root, int depth, int position){\\n        \\n        if(root == null) return;\\n        \\n        this.map.computeIfAbsent(depth, x -> position);\\n        \\n        this.maxWidth = Math.max(this.maxWidth, position - this.map.get(depth) + 1);\\n        \\n        this.maxWidth(root.left, depth + 1 , position * 2);\\n        \\n        this.maxWidth(root.right, depth + 1 , position * 2 + 1);\\n               \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 727006,
                "title": "simple-java-solution-easy",
                "content": "So based on the examples, you should not cound the null nodes on the edge, but you need to count them if they are in the middle of two non-null nodes.\\nSolution:\\n* Do a BFS on the tree\\n* Beginning of every level, compare the width with the max\\n* Before starting the next level, make sure the start and end node are not null (delete if necessary)\\n```\\nclass Solution {\\n    public int widthOfBinaryTree(TreeNode root) {\\n        \\n        List<TreeNode> q = new LinkedList<>();\\n        q.add(root);\\n        int max = 0;\\n        while(! q.isEmpty()){\\n            int n = q.size();\\n            \\n            if(n > max) max = n;\\n            \\n            for(int i=0; i<n; i++){\\n                TreeNode tn = q.remove(0);\\n                \\n                if(tn != null){\\n                    q.add(tn.left);\\n                    q.add(tn.right);\\n                }else{\\n                    q.add(null);\\n                    q.add(null);\\n                }\\n            }\\n            \\n            // trim the queue from left\\n            while(!q.isEmpty() && q.get(0) == null){\\n                q.remove(0);\\n            }\\n            // trim the queue from right\\n            while(!q.isEmpty() && q.get(q.size()-1) == null){\\n                q.remove(q.size()-1);\\n            }\\n        }\\n        \\n        return max;\\n    }\\n}\\n```\\n**Solution 2 (optimal)**\\nThe above solution works but its slow because you are keeping extra values (nulls) in the queue, and you need to iterate through them as wel in the next round.\\nWhat if you could number the nodes on each level, so that you have the leftmost number as 0 and each node in the right increase by 1. Then \\nwithout requiring the middle nodes, you could simply calculate the width of that level (right-left + 1) and you don\\'t have to store the extra nulls.\\n\\nIf you number the root as 0, and each left node = (parent * 2) , and right node = (parent * 2 + 1) -> you achieve exactly that.\\n```\\nclass Solution {\\n    public int widthOfBinaryTree(TreeNode root) {\\n        if(root == null) return 0;\\n        int max = 0;\\n        \\n        LinkedList<Pair> q = new LinkedList<>();\\n        q.add(new Pair(root, 0));\\n        \\n        while( !q.isEmpty() ) {\\n            int size = q.size();\\n            int left = q.getFirst().index, right = q.getLast().index;\\n            max = Math.max(max, right-left+1);\\n            \\n            for(int i=0; i<size; i++) {\\n                Pair p = q.remove();\\n                int index = p.index;\\n                TreeNode tn = p.node;\\n                \\n                if(tn.left != null) {\\n                    q.add(new Pair(tn.left, 2 * index));\\n                }\\n                \\n                if(tn.right != null) {\\n                    q.add(new Pair(tn.right, 2 * index + 1));\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n    \\n    class Pair{\\n        TreeNode node;\\n        int index = 0;\\n        public Pair(TreeNode node, int index) {\\n            this.node = node;\\n            this.index = index;\\n        }\\n    }\\n}\\n\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int widthOfBinaryTree(TreeNode root) {\\n        \\n        List<TreeNode> q = new LinkedList<>();\\n        q.add(root);\\n        int max = 0;\\n        while(! q.isEmpty()){\\n            int n = q.size();\\n            \\n            if(n > max) max = n;\\n            \\n            for(int i=0; i<n; i++){\\n                TreeNode tn = q.remove(0);\\n                \\n                if(tn != null){\\n                    q.add(tn.left);\\n                    q.add(tn.right);\\n                }else{\\n                    q.add(null);\\n                    q.add(null);\\n                }\\n            }\\n            \\n            // trim the queue from left\\n            while(!q.isEmpty() && q.get(0) == null){\\n                q.remove(0);\\n            }\\n            // trim the queue from right\\n            while(!q.isEmpty() && q.get(q.size()-1) == null){\\n                q.remove(q.size()-1);\\n            }\\n        }\\n        \\n        return max;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int widthOfBinaryTree(TreeNode root) {\\n        if(root == null) return 0;\\n        int max = 0;\\n        \\n        LinkedList<Pair> q = new LinkedList<>();\\n        q.add(new Pair(root, 0));\\n        \\n        while( !q.isEmpty() ) {\\n            int size = q.size();\\n            int left = q.getFirst().index, right = q.getLast().index;\\n            max = Math.max(max, right-left+1);\\n            \\n            for(int i=0; i<size; i++) {\\n                Pair p = q.remove();\\n                int index = p.index;\\n                TreeNode tn = p.node;\\n                \\n                if(tn.left != null) {\\n                    q.add(new Pair(tn.left, 2 * index));\\n                }\\n                \\n                if(tn.right != null) {\\n                    q.add(new Pair(tn.right, 2 * index + 1));\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n    \\n    class Pair{\\n        TreeNode node;\\n        int index = 0;\\n        public Pair(TreeNode node, int index) {\\n            this.node = node;\\n            this.index = index;\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 726775,
                "title": "python-simple-python-bfs",
                "content": "my python solution\\n\\n```python\\nclass Solution:\\n    def widthOfBinaryTree(self, root: TreeNode) -> int:\\n        ans = 0\\n        if not root:\\n            return ans\\n        \\n        queue = collections.deque([(root, 0)])\\n        while queue:\\n            l, r = queue[0][1], queue[-1][1]\\n            ans = max(ans, r-l + 1)\\n            \\n            for _ in range(len(queue)):\\n                node, idx = queue.popleft()\\n                if node.left:\\n                    queue.append((node.left, idx*2+1))\\n                if node.right:\\n                    queue.append((node.right, idx*2+2))\\n                \\n        return ans\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def widthOfBinaryTree(self, root: TreeNode) -> int:\\n        ans = 0\\n        if not root:\\n            return ans\\n        \\n        queue = collections.deque([(root, 0)])\\n        while queue:\\n            l, r = queue[0][1], queue[-1][1]\\n            ans = max(ans, r-l + 1)\\n            \\n            for _ in range(len(queue)):\\n                node, idx = queue.popleft()\\n                if node.left:\\n                    queue.append((node.left, idx*2+1))\\n                if node.right:\\n                    queue.append((node.right, idx*2+2))\\n                \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 603925,
                "title": "ruby-beats-100",
                "content": "1. Use a queue and next_queue system to BFS down the tree.\\n2. The width of the tree is 1 if there\\'s only 1 element in the queue\\n3. min and max are similar to how you calculate a child node\\'s index in a heap, 2x+1 and 2x+2\\n\\n```\\ndef width_of_binary_tree(root)\\n    max = 0\\n    queue = [{node: root, pos: 0}]\\n    while queue.length>0 do\\n        next_queue = []\\n        length = queue.length\\n        min_pos = +1.0/0.0\\n        max_pos = 0\\n        while queue.length>0 do\\n            current = queue.pop\\n            if current[:node].left\\n               next_queue << {node: current[:node].left, pos: 2*current[:pos]+1} \\n            end \\n            if current[:node].right\\n               next_queue << {node: current[:node].right, pos: 2*current[:pos]+2} \\n            end\\n            min_pos = [min_pos, current[:pos]].min\\n            max_pos = [max_pos, current[:pos]].max\\n        end\\n        queue = next_queue\\n        level_length = length == 1 ? 1 : max_pos - min_pos + 1\\n        max = [max, level_length].max\\n    end\\n    max\\nend\\n```",
                "solutionTags": [
                    "Ruby",
                    "Queue"
                ],
                "code": "```\\ndef width_of_binary_tree(root)\\n    max = 0\\n    queue = [{node: root, pos: 0}]\\n    while queue.length>0 do\\n        next_queue = []\\n        length = queue.length\\n        min_pos = +1.0/0.0\\n        max_pos = 0\\n        while queue.length>0 do\\n            current = queue.pop\\n            if current[:node].left\\n               next_queue << {node: current[:node].left, pos: 2*current[:pos]+1} \\n            end \\n            if current[:node].right\\n               next_queue << {node: current[:node].right, pos: 2*current[:pos]+2} \\n            end\\n            min_pos = [min_pos, current[:pos]].min\\n            max_pos = [max_pos, current[:pos]].max\\n        end\\n        queue = next_queue\\n        level_length = length == 1 ? 1 : max_pos - min_pos + 1\\n        max = [max, level_length].max\\n    end\\n    max\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 534936,
                "title": "go-golang-bfs-0ms",
                "content": "```\\nfunc widthOfBinaryTree(root *TreeNode) int {\\n    if root == nil {\\n        return 0\\n    }    \\n    curr := []*TreeNode{&TreeNode{0, root.Left, root.Right}}\\n    next := []*TreeNode{}\\n    max := 0\\n    for len(curr) != 0 {\\n        length := curr[len(curr) - 1].Val - curr[0].Val + 1\\n        if length > max {\\n            max = length\\n        }\\n        for _, c := range curr{\\n            if c.Left != nil {\\n                next = append(next, &TreeNode{c.Val * 2, c.Left.Left, c.Left.Right})\\n            } \\n            if c.Right != nil {\\n                next = append(next, &TreeNode{c.Val * 2 + 1, c.Right.Left, c.Right.Right})\\n            }\\n        }\\n        curr = next\\n        next = []*TreeNode{}\\n    }\\n    return max\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc widthOfBinaryTree(root *TreeNode) int {\\n    if root == nil {\\n        return 0\\n    }    \\n    curr := []*TreeNode{&TreeNode{0, root.Left, root.Right}}\\n    next := []*TreeNode{}\\n    max := 0\\n    for len(curr) != 0 {\\n        length := curr[len(curr) - 1].Val - curr[0].Val + 1\\n        if length > max {\\n            max = length\\n        }\\n        for _, c := range curr{\\n            if c.Left != nil {\\n                next = append(next, &TreeNode{c.Val * 2, c.Left.Left, c.Left.Right})\\n            } \\n            if c.Right != nil {\\n                next = append(next, &TreeNode{c.Val * 2 + 1, c.Right.Left, c.Right.Right})\\n            }\\n        }\\n        curr = next\\n        next = []*TreeNode{}\\n    }\\n    return max\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 405485,
                "title": "java-solution-1ms-beats-100-100-with-explaination",
                "content": "Java Solution with explaination\\nObviously, I would rather use a BFS to solve this problem because if we do BFS as a level layer which means in each for loop, we visit every node in the same layer and determine the largest distance in this layer and compare the largest layer with return value. \\n\\nIt first came to me that we could just found our path to the left and to the right bottom of this tree, but this idea is absolutely wrong. Becuase sometimes, it\\'s not always the bottom layer who has the largest distance. So we have to go through every node and rule out every possible situation.\\n\\nNow we do BFS, but instead we put Node in our queue, we need to store a specific number to remember the position of this node among this layer. \\n\\n\\t\\t\\t\\tA\\n\\t\\t\\t  /    \\\\\\n\\t\\t\\tB        C\\n\\t\\t   /  \\\\     /  \\\\  \\n         D .  E    F    G\\n\\nLike in this tree, we remeber A as the position of 0. B is the position 0 of second layer C is 1 of second layer. So we know the distance is 1 - 0 + 1. In the third layer is 0 1 2 3 and the distance will be 3 - 0 + 1.\\nSo it\\'s very obvious that the the left son\\'s position value = 2 * father\\'s position value. and the right son\\'s position value will be one larger than the left. 2 * father\\'s position value + 1.\\nSo we make a new class and this class contains two things. First, the node, second the position value.\\nIn each for loop, we go through every node in the same layer, so if we just get the first node, we could find out the most left node in this layer. If we get the last node, we could find out the most right node in this layer. Then we could find out the largest distance in this layer. Still, we need to add all the node\\'s sons into this queue.\\n\\n------- that\\'s the idea of my algo and here we make some improvement\\n\\nThere is one particular test case, it only contains right node and the it\\'s value long wich cause the position value double double and double which make it out of range of int. \\nSo I came up with a solution that if we find out there is only one node in this queue (in the beginning of looping the same layer), then we could just set the position value of it to 0. Because we take it as root again and all the following son\\'s nodes\\' position value would be set from 0 so it perfectly solve this problem.\\n```\\nclass TreeNodePair {\\n    public int position;\\n    public TreeNode node;\\n    public TreeNodePair(TreeNode x , int z){\\n        this.node = x;\\n        this.position = z;\\n    }\\n}\\nclass Solution {\\n    public int widthOfBinaryTree(TreeNode root) {\\n        Queue<TreeNodePair> queue = new LinkedList<>();\\n        queue.offer(new TreeNodePair(root, 0));\\n        int ret = 0;\\n        while (!queue.isEmpty()){\\n            int size = queue.size();\\n            int left = Integer.MAX_VALUE , right = 0;\\n            if (size == 1){\\n                queue.peek().position = 0;\\n            }\\n            for (int i = 0; i < size ; i++){\\n                TreeNodePair node = queue.poll();\\n                int position = node.position;\\n\\t\\t\\t\\t// it\\'s the most left node\\n                if (i == 0){\\n                    left = Math.min(position , left);\\n                }\\n\\t\\t\\t\\t// it\\'s the most right node\\n                if (i == size - 1){\\n                    right = Math.max(right , position);\\n                }\\n\\t\\t\\t\\t// we add the left and right son of this node into queue\\n                TreeNode anode = node.node;\\n                if (anode.left != null){\\n                    queue.offer(new TreeNodePair(anode.left, position * 2));\\n                }\\n                if (anode.right != null){\\n                    queue.offer(new TreeNodePair(anode.right, position * 2 + 1));\\n                }\\n            }\\n            ret = Math.max(ret , right - left + 1);\\n        }\\n        return ret;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass TreeNodePair {\\n    public int position;\\n    public TreeNode node;\\n    public TreeNodePair(TreeNode x , int z){\\n        this.node = x;\\n        this.position = z;\\n    }\\n}\\nclass Solution {\\n    public int widthOfBinaryTree(TreeNode root) {\\n        Queue<TreeNodePair> queue = new LinkedList<>();\\n        queue.offer(new TreeNodePair(root, 0));\\n        int ret = 0;\\n        while (!queue.isEmpty()){\\n            int size = queue.size();\\n            int left = Integer.MAX_VALUE , right = 0;\\n            if (size == 1){\\n                queue.peek().position = 0;\\n            }\\n            for (int i = 0; i < size ; i++){\\n                TreeNodePair node = queue.poll();\\n                int position = node.position;\\n\\t\\t\\t\\t// it\\'s the most left node\\n                if (i == 0){\\n                    left = Math.min(position , left);\\n                }\\n\\t\\t\\t\\t// it\\'s the most right node\\n                if (i == size - 1){\\n                    right = Math.max(right , position);\\n                }\\n\\t\\t\\t\\t// we add the left and right son of this node into queue\\n                TreeNode anode = node.node;\\n                if (anode.left != null){\\n                    queue.offer(new TreeNodePair(anode.left, position * 2));\\n                }\\n                if (anode.right != null){\\n                    queue.offer(new TreeNodePair(anode.right, position * 2 + 1));\\n                }\\n            }\\n            ret = Math.max(ret , right - left + 1);\\n        }\\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 293205,
                "title": "c-bfs-fix-overflow-4ms",
                "content": "Learned from the comments below Solution @ZhihuiShao.\\nAt each level, we reset the index of leftmost node to 0, and as a result, each node at this level subtracts the offset too.\\n```\\nclass Solution {\\npublic:\\n    int widthOfBinaryTree(TreeNode* root) {\\n\\t\\tif(!root)\\n\\t\\t\\treturn 0;\\n\\t\\tqueue<pair<TreeNode *, int>> que;\\n\\t\\tque.push({root, 1});\\n\\t\\tint res = 0;\\n\\t\\twhile(!que.empty()){\\n\\t\\t\\tint size = que.size();\\n\\t\\t\\tint offset = -1, r = -1;\\n\\t\\t\\twhile(size--){\\n\\t\\t\\t\\tauto cur = que.front().first;\\n\\t\\t\\t\\tint index = que.front().second;\\n\\t\\t\\t\\tque.pop();\\n\\t\\t\\t\\tif(offset == -1){\\n\\t\\t\\t\\t\\toffset = index;//set offset of each level\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tindex -= offset;//each index subtract the offset, fix the overflow.\\n\\t\\t\\t\\tr = index;\\n\\t\\t\\t\\tif(cur->left)\\n\\t\\t\\t\\t\\tque.push({cur->left, 2 * index});\\n\\t\\t\\t\\tif(cur->right)\\n\\t\\t\\t\\t\\tque.push({cur->right, 2 * index + 1});\\n\\t\\t\\t}\\n\\t\\t\\tres = max(res, r+1);//l==0, length = r-l+1\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int widthOfBinaryTree(TreeNode* root) {\\n\\t\\tif(!root)\\n\\t\\t\\treturn 0;\\n\\t\\tqueue<pair<TreeNode *, int>> que;\\n\\t\\tque.push({root, 1});\\n\\t\\tint res = 0;\\n\\t\\twhile(!que.empty()){\\n\\t\\t\\tint size = que.size();\\n\\t\\t\\tint offset = -1, r = -1;\\n\\t\\t\\twhile(size--){\\n\\t\\t\\t\\tauto cur = que.front().first;\\n\\t\\t\\t\\tint index = que.front().second;\\n\\t\\t\\t\\tque.pop();\\n\\t\\t\\t\\tif(offset == -1){\\n\\t\\t\\t\\t\\toffset = index;//set offset of each level\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tindex -= offset;//each index subtract the offset, fix the overflow.\\n\\t\\t\\t\\tr = index;\\n\\t\\t\\t\\tif(cur->left)\\n\\t\\t\\t\\t\\tque.push({cur->left, 2 * index});\\n\\t\\t\\t\\tif(cur->right)\\n\\t\\t\\t\\t\\tque.push({cur->right, 2 * index + 1});\\n\\t\\t\\t}\\n\\t\\t\\tres = max(res, r+1);//l==0, length = r-l+1\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 289914,
                "title": "python-bfs",
                "content": "\\t\\'\\'\\'\\n\\tclass Solution(object):\\n\\t\\tdef widthOfBinaryTree(self, root):\\n\\t\\t\\t\"\"\"\\n\\t\\t\\t:type root: TreeNode\\n\\t\\t\\t:rtype: int\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tqueue = [(root,1)]\\n\\t\\t\\tres = 0\\n\\t\\t\\twhile queue:\\n\\t\\t\\t\\twidth = queue[-1][1]-queue[0][1]+1\\n\\t\\t\\t\\tres = max(res,width)\\n\\t\\t\\t\\tfor _ in range(len(queue)):\\n\\t\\t\\t\\t\\tnode,k = queue.pop(0)\\n\\t\\t\\t\\t\\tif node.left:\\n\\t\\t\\t\\t\\t\\tqueue.append((node.left,2*k))\\n\\t\\t\\t\\t\\tif node.right:\\n\\t\\t\\t\\t\\t\\tqueue.append((node.right,2*k+1))\\n\\t\\t\\treturn res\\n\\t\\'\\'\\'",
                "solutionTags": [],
                "code": "\\t\\'\\'\\'\\n\\tclass Solution(object):\\n\\t\\tdef widthOfBinaryTree(self, root):\\n\\t\\t\\t\"\"\"\\n\\t\\t\\t:type root: TreeNode\\n\\t\\t\\t:rtype: int\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tqueue = [(root,1)]\\n\\t\\t\\tres = 0\\n\\t\\t\\twhile queue:\\n\\t\\t\\t\\twidth = queue[-1][1]-queue[0][1]+1\\n\\t\\t\\t\\tres = max(res,width)\\n\\t\\t\\t\\tfor _ in range(len(queue)):\\n\\t\\t\\t\\t\\tnode,k = queue.pop(0)\\n\\t\\t\\t\\t\\tif node.left:\\n\\t\\t\\t\\t\\t\\tqueue.append((node.left,2*k))\\n\\t\\t\\t\\t\\tif node.right:\\n\\t\\t\\t\\t\\t\\tqueue.append((node.right,2*k+1))\\n\\t\\t\\treturn res\\n\\t\\'\\'\\'",
                "codeTag": "Java"
            },
            {
                "id": 209626,
                "title": "concise-solution-c-bfs",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int widthOfBinaryTree(TreeNode* root) {\\n        if( !root ) return 0;\\n        queue<pair<TreeNode*, int> > q;\\n        q.push({root, 1 });\\n        int ans = 0;\\n        while(q.size() ){\\n            int size = q.size();\\n            ans = max( q.back().second - q.front().second + 1, ans);\\n            while( size--> 0 ){\\n                auto node = q.front().first;\\n                auto idx = q.front().second;\\n                q.pop();\\n                if( node->left )\\n                    q.push({node->left, idx*2});\\n                if( node->right )\\n                    q.push({node->right, idx*2+1});\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int widthOfBinaryTree(TreeNode* root) {\\n        if( !root ) return 0;\\n        queue<pair<TreeNode*, int> > q;\\n        q.push({root, 1 });\\n        int ans = 0;\\n        while(q.size() ){\\n            int size = q.size();\\n            ans = max( q.back().second - q.front().second + 1, ans);\\n            while( size--> 0 ){\\n                auto node = q.front().first;\\n                auto idx = q.front().second;\\n                q.pop();\\n                if( node->left )\\n                    q.push({node->left, idx*2});\\n                if( node->right )\\n                    q.push({node->right, idx*2+1});\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3665599,
                "title": "image-explanation-c-simple-and-easy-to-understand",
                "content": "# Intuition\\n![trr1.png](https://assets.leetcode.com/users/images/140448d8-7ba6-40e9-a4ea-28570a914c62_1687350197.798783.png)\\n![trr2.png](https://assets.leetcode.com/users/images/99cefcab-0c2e-4556-ab8b-63ccdd31f5f7_1687350200.8464518.png)\\n![trr3.png](https://assets.leetcode.com/users/images/1e657d4e-d20a-4310-a456-2a2ae5223df5_1687350203.7045455.png)\\n![trr4.png](https://assets.leetcode.com/users/images/d5fd8c15-d707-4154-b3c5-a1056e276100_1687350206.7682889.png)\\n![trr5.png](https://assets.leetcode.com/users/images/768fafcc-aec4-46e4-855f-ee6d6e48a4a8_1687350210.5447702.png)\\n![trr6.png](https://assets.leetcode.com/users/images/5188ce11-5a78-4c20-ac06-dc349fee10cc_1687350214.179592.png)\\n![trr7.png](https://assets.leetcode.com/users/images/3284d12c-d52e-4dc6-bdec-6be9c49be639_1687350218.121706.png)\\n\\n# Complexity\\n- Time complexity: O(N), for traversing through all nodes\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N), worst case storing all nodes in queue\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int widthOfBinaryTree(TreeNode* root) {\\n        if(root==NULL) return 0;\\n        queue<pair<TreeNode*, long long>> q;\\n        q.push({root, 0});\\n        int ans = 0;\\n        while(!q.empty())\\n        {\\n            int s = q.size();\\n            int min_idx = q.front().second;\\n            int start, last;\\n            for(int i =0;i<s;i++)\\n            {\\n                TreeNode* node = q.front().first;\\n                long long idx = q.front().second - min_idx;\\n                if(i==0) start = idx;\\n                if(i==s-1) last = idx;\\n                q.pop();\\n                if(node->left) q.push({node->left, idx*2+1});\\n                if(node->right) q.push({node->right, idx*2+2});\\n            }\\n            ans = max(ans, last-start+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int widthOfBinaryTree(TreeNode* root) {\\n        if(root==NULL) return 0;\\n        queue<pair<TreeNode*, long long>> q;\\n        q.push({root, 0});\\n        int ans = 0;\\n        while(!q.empty())\\n        {\\n            int s = q.size();\\n            int min_idx = q.front().second;\\n            int start, last;\\n            for(int i =0;i<s;i++)\\n            {\\n                TreeNode* node = q.front().first;\\n                long long idx = q.front().second - min_idx;\\n                if(i==0) start = idx;\\n                if(i==s-1) last = idx;\\n                q.pop();\\n                if(node->left) q.push({node->left, idx*2+1});\\n                if(node->right) q.push({node->right, idx*2+2});\\n            }\\n            ans = max(ans, last-start+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3439156,
                "title": "optimal-solution-using-dfs",
                "content": "\\n\\n# Approach\\nIn this solution, we use two vectors leftmost and rightmost to store the index of the leftmost and rightmost nodes at each level, respectively. We also pass the current level as an argument to the recursive dfs function, along with the current index and the maximum width seen so far. For each node, we update the leftmost and rightmost vectors accordingly, and compute the width of the current level as the difference between the rightmost and leftmost indices. We update the max_width variable if the current level\\'s width is greater than the previous maximum.\\n\\n# Complexity\\n- Time complexity:\\nO(n), where n is the number of nodes in the binary tree \\n\\n- Space complexity:\\n O(h), where h is the height of the binary tree, since we only store the leftmost and rightmost indices of each level in the two arrays. \\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int widthOfBinaryTree(TreeNode* root) {\\n        if (!root) return 0;\\n        \\n        int max_width = 0;\\n        vector<int> leftmost, rightmost;\\n        \\n        dfs(root, 0, 1, leftmost, rightmost, max_width);\\n        \\n        return max_width;\\n    }\\n    \\n    void dfs(TreeNode* node, int level, unsigned long long index, vector<int>& leftmost, vector<int>& rightmost, int& max_width) {\\n        if (!node) return;\\n        \\n        if (level == leftmost.size()) {\\n            leftmost.push_back(index);\\n            rightmost.push_back(index);\\n        } else {\\n            rightmost[level] = index;\\n        }\\n        \\n        max_width = max(max_width, static_cast<int>(index - leftmost[level] + 1));\\n        \\n        dfs(node->left, level + 1, 2 * index, leftmost, rightmost, max_width);\\n        dfs(node->right, level + 1, 2 * index + 1, leftmost, rightmost, max_width);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int widthOfBinaryTree(TreeNode* root) {\\n        if (!root) return 0;\\n        \\n        int max_width = 0;\\n        vector<int> leftmost, rightmost;\\n        \\n        dfs(root, 0, 1, leftmost, rightmost, max_width);\\n        \\n        return max_width;\\n    }\\n    \\n    void dfs(TreeNode* node, int level, unsigned long long index, vector<int>& leftmost, vector<int>& rightmost, int& max_width) {\\n        if (!node) return;\\n        \\n        if (level == leftmost.size()) {\\n            leftmost.push_back(index);\\n            rightmost.push_back(index);\\n        } else {\\n            rightmost[level] = index;\\n        }\\n        \\n        max_width = max(max_width, static_cast<int>(index - leftmost[level] + 1));\\n        \\n        dfs(node->left, level + 1, 2 * index, leftmost, rightmost, max_width);\\n        dfs(node->right, level + 1, 2 * index + 1, leftmost, rightmost, max_width);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3439057,
                "title": "smooth-solution-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int widthOfBinaryTree(TreeNode* root) {\\n        queue<pair<TreeNode*,int>>q;\\n        q.push({root,0});//store node and ind of that node in queue;\\n        long long  ans =1;\\n        while(!q.empty()){\\n            long long  n = q.size();\\n            long long  a = q.front().second;\\n            long long  b = q.back().second;\\n            ans= max(ans,b-a+1);\\n            for(int i =0; i<n ; i++){\\n                TreeNode* node =q.front().first;\\n                long long  ind = q.front().second;\\n                q.pop();\\n                if(node->left){\\n                    q.push({node->left,2*ind+1});//left child = 2*root_index +1 ;\\n                }\\n                if(node->right){\\n                    q.push({node->right,2*ind+2});//right child = 2*root_index +1;\\n                }\\n            }\\n\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int widthOfBinaryTree(TreeNode* root) {\\n        queue<pair<TreeNode*,int>>q;\\n        q.push({root,0});//store node and ind of that node in queue;\\n        long long  ans =1;\\n        while(!q.empty()){\\n            long long  n = q.size();\\n            long long  a = q.front().second;\\n            long long  b = q.back().second;\\n            ans= max(ans,b-a+1);\\n            for(int i =0; i<n ; i++){\\n                TreeNode* node =q.front().first;\\n                long long  ind = q.front().second;\\n                q.pop();\\n                if(node->left){\\n                    q.push({node->left,2*ind+1});//left child = 2*root_index +1 ;\\n                }\\n                if(node->right){\\n                    q.push({node->right,2*ind+2});//right child = 2*root_index +1;\\n                }\\n            }\\n\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3438665,
                "title": "best-and-easy-solution-100-dfs",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    \\n    int ans=0;\\n    public int widthOfBinaryTree(TreeNode root) {\\n        if(root==null)return 0;\\n        return width(root, 0, 1, new ArrayList<Integer>());\\n    }\\n\\n    public int width( TreeNode root, int i, int j, List<Integer> list) {\\n        if(root==null)return 0;\\n        if(i==list.size())list.add(j);\\n        int curr = j-list.get(i)+1;\\n        int lh = width(root.left, i+1, j*2, list);\\n        int rh = width(root.right, i+1, j*2+1, list);\\n        return Math.max(curr,Math.max(lh,rh));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    \\n    int ans=0;\\n    public int widthOfBinaryTree(TreeNode root) {\\n        if(root==null)return 0;\\n        return width(root, 0, 1, new ArrayList<Integer>());\\n    }\\n\\n    public int width( TreeNode root, int i, int j, List<Integer> list) {\\n        if(root==null)return 0;\\n        if(i==list.size())list.add(j);\\n        int curr = j-list.get(i)+1;\\n        int lh = width(root.left, i+1, j*2, list);\\n        int rh = width(root.right, i+1, j*2+1, list);\\n        return Math.max(curr,Math.max(lh,rh));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3437168,
                "title": "calculate-index-and-find-max-width",
                "content": "for left child `(2*i) + 1` to find index where `i` == parent index\\n for right child `(2*i) + 2` to find index where `i` == parent index\\n\\nAfter each row we check maxWidth\\n\\n\\n\\n# Code\\n```\\n// for left child (2*i) + 1 to find index where i == parent index\\n// for right child (2*i) + 2 to find index where i == parent index\\nclass Solution {\\n    public int widthOfBinaryTree(TreeNode root) {\\n        ArrayDeque<Pair> queue = new ArrayDeque<>();\\n        queue.add(new Pair(root, 0));\\n        int maxWidth = Integer.MIN_VALUE;\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            int min = queue.getFirst().index;\\n            int max = queue.getLast().index;\\n            maxWidth = Math.max(maxWidth, max - min);\\n            while (size != 0) {\\n                Pair pair = queue.remove();\\n                if (pair.node.left != null) {\\n                    queue.add(new Pair(pair.node.left, (2 * pair.index + 1)));\\n                }\\n                if (pair.node.right != null) {\\n                    queue.add(new Pair(pair.node.right, (2 * pair.index) + 2));\\n                }\\n                size--;\\n            }\\n        }\\n        return maxWidth + 1;\\n    }\\n}\\n\\nclass Pair {\\n    TreeNode node;\\n    int index;\\n    Pair(TreeNode a, int b) {\\n        this.node = a;\\n        this.index = b;\\n    }\\n    void setValue(TreeNode a, int b) {\\n        this.node = a;\\n        this.index = b;\\n    }\\n    Pair getValue() {\\n        return this;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\n// for left child (2*i) + 1 to find index where i == parent index\\n// for right child (2*i) + 2 to find index where i == parent index\\nclass Solution {\\n    public int widthOfBinaryTree(TreeNode root) {\\n        ArrayDeque<Pair> queue = new ArrayDeque<>();\\n        queue.add(new Pair(root, 0));\\n        int maxWidth = Integer.MIN_VALUE;\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            int min = queue.getFirst().index;\\n            int max = queue.getLast().index;\\n            maxWidth = Math.max(maxWidth, max - min);\\n            while (size != 0) {\\n                Pair pair = queue.remove();\\n                if (pair.node.left != null) {\\n                    queue.add(new Pair(pair.node.left, (2 * pair.index + 1)));\\n                }\\n                if (pair.node.right != null) {\\n                    queue.add(new Pair(pair.node.right, (2 * pair.index) + 2));\\n                }\\n                size--;\\n            }\\n        }\\n        return maxWidth + 1;\\n    }\\n}\\n\\nclass Pair {\\n    TreeNode node;\\n    int index;\\n    Pair(TreeNode a, int b) {\\n        this.node = a;\\n        this.index = b;\\n    }\\n    void setValue(TreeNode a, int b) {\\n        this.node = a;\\n        this.index = b;\\n    }\\n    Pair getValue() {\\n        return this;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3436881,
                "title": "level-order-traversal",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int widthOfBinaryTree(TreeNode *root)\\n    {\\n        if (root == nullptr)\\n        {\\n            return 0;\\n        }\\n        queue<pair<TreeNode *, long long int>> q;\\n        q.push({root, 0});\\n        long long int ans = 0;\\n\\n        while (!q.empty())\\n        {\\n            long long int sz = q.size();\\n            long long int lb, ub;\\n            int mn = q.front().second;\\n\\n            for (int i = 0; i < sz; i++)\\n            {\\n                TreeNode *node = q.front().first;\\n                long long int pos = q.front().second;\\n                q.pop();\\n                pos -= mn;\\n\\n                if (i == 0)\\n                {\\n                    lb = pos;\\n                }\\n                if (i == sz - 1)\\n                {\\n                    ub = pos;\\n                }\\n\\n                if (node->left)\\n                {\\n                    long int p = 1LL * 2 * pos + 1;\\n                    q.push({node->left, p});\\n                }\\n                if (node->right)\\n                {\\n                    long int p = 1LL * 2 * pos + 2;\\n                    q.push({node->right, p});\\n                }\\n            }\\n\\n            ans = max(ans, ub - lb + 1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int widthOfBinaryTree(TreeNode *root)\\n    {\\n        if (root == nullptr)\\n        {\\n            return 0;\\n        }\\n        queue<pair<TreeNode *, long long int>> q;\\n        q.push({root, 0});\\n        long long int ans = 0;\\n\\n        while (!q.empty())\\n        {\\n            long long int sz = q.size();\\n            long long int lb, ub;\\n            int mn = q.front().second;\\n\\n            for (int i = 0; i < sz; i++)\\n            {\\n                TreeNode *node = q.front().first;\\n                long long int pos = q.front().second;\\n                q.pop();\\n                pos -= mn;\\n\\n                if (i == 0)\\n                {\\n                    lb = pos;\\n                }\\n                if (i == sz - 1)\\n                {\\n                    ub = pos;\\n                }\\n\\n                if (node->left)\\n                {\\n                    long int p = 1LL * 2 * pos + 1;\\n                    q.push({node->left, p});\\n                }\\n                if (node->right)\\n                {\\n                    long int p = 1LL * 2 * pos + 2;\\n                    q.push({node->right, p});\\n                }\\n            }\\n\\n            ans = max(ans, ub - lb + 1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3436754,
                "title": "easy-to-understand-solution-bfs-approach-c",
                "content": "# Intuition\\nFirst level contains only one node with index 0, so its width is 1. The second level contains nodes with indices 1 and 2, so its width is 2-1+1=2. The third level contains nodes with indices 3, 4, and 5, so its width is 5-2+1=4. Therefore, the maximum width of this binary tree is 4.\\n\\nWe can use a queue to perform a level-order traversal of the binary tree. For each node, we calculate its corresponding index value based on its level order traversal. We keep track of the start index of each level to calculate the width of the level. Finally, we return the maximum width of all levels.\\n\\nThe intuition behind this approach is that the level-order traversal of the binary tree allows us to calculate the index values of the nodes in a left-to-right order. \\n# Please Sir Up-Vote Don\\'t Just Go and Copy \\n![c2826b72-fb1c-464c-9f95-d9e578abcaf3_1674104075.4732099.jpeg](https://assets.leetcode.com/users/images/69230dfd-ccb4-4c43-a034-dbf266c5f174_1681962078.2193751.jpeg)\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nFor each node, we calculate its corresponding index value based on the level order traversal. We keep track of the start index of each level to calculate the width of the level. Finally, we return the maximum width of all levels.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n# Time complexity: 0(n)\\nThe time complexity of finding the maximum width of a binary tree using a breadth-first search approach is O(n), where n is the number of nodes in the tree. This is because we need to visit each node once in order to calculate the width of the tree. The algorithm involves traversing the binary tree in a level-by-level manner, using a queue to keep track of the nodes at each level. At each level, we calculate the width of the level by subtracting the index of the first non-null node from the index of the last non-null node. We then update the maximum width seen so far. Since each node is visited only once, the time complexity of this algorithm is linear in the number of nodes in the tree.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Space complexity: 0(w)\\n- The space complexity of finding the maximum width of a binary tree using a breadth-first search approach is O(w), where w is the maximum width of the tree at any level. This is because we need to store the nodes at each level in a queue, and the maximum number of nodes that can be present at any level is the width of the tree. At each level, we add the child nodes to the queue and remove the parent nodes from the queue, so the maximum size of the queue at any time is the maximum number of nodes at any level. Therefore, the space complexity of this algorithm is proportional to the maximum width of the tree at any level. In the worst case, where the tree is a complete binary tree, the maximum width would be 2^(h-1), where h is the height of the tree, and the space complexity would be O(2^(h-1)). However, in practice, the maximum width of a tree is likely to be much smaller than this, so the space complexity would be much lower.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int widthOfBinaryTree(TreeNode* root) \\n    {//define the treeNode* root\\n//driver code\\n        if (root == nullptr) \\n        {\\n            return 0;\\n        }\\n        \\n        int max_width = 1;\\n        //taking the max_width\\n        queue<pair<TreeNode*, int>> q;\\n        //make the queue<pair<TreeNode*, int into q;\\n        q.push({root, 0});\\n        \\n        while (!q.empty()) {\\n\\n            int level_size = q.size();\\n            int start_index = q.front().second;\\n            int end_index = q.back().second;\\n            //define the size, index, from front to back depending upon size\\n            max_width = max(max_width, end_index - start_index + 1);\\n            \\n            for (int i = 0; i < level_size; ++i) \\n            {\\n                auto node_index_pair = q.front();\\n                //node pair for front\\n                TreeNode* node = node_index_pair.first;\\n\\n                int node_index = node_index_pair.second - start_index;\\n                q.pop();\\n                                \\n                if (node->left != nullptr)\\n                { //node into  left\\n                    q.push({node->left, 2LL * node_index + 1});\\n                //push the node into left into the node\\'s index, \\n                }\\n                \\n                if (node->right != nullptr) \\n                {\\n                    q.push({node->right, 2LL * node_index + 2});\\n                }//push the left node and the index node will be added into it,\\n            }\\n        }\\n        //  \\n        return max_width;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int widthOfBinaryTree(TreeNode* root) \\n    {//define the treeNode* root\\n//driver code\\n        if (root == nullptr) \\n        {\\n            return 0;\\n        }\\n        \\n        int max_width = 1;\\n        //taking the max_width\\n        queue<pair<TreeNode*, int>> q;\\n        //make the queue<pair<TreeNode*, int into q;\\n        q.push({root, 0});\\n        \\n        while (!q.empty()) {\\n\\n            int level_size = q.size();\\n            int start_index = q.front().second;\\n            int end_index = q.back().second;\\n            //define the size, index, from front to back depending upon size\\n            max_width = max(max_width, end_index - start_index + 1);\\n            \\n            for (int i = 0; i < level_size; ++i) \\n            {\\n                auto node_index_pair = q.front();\\n                //node pair for front\\n                TreeNode* node = node_index_pair.first;\\n\\n                int node_index = node_index_pair.second - start_index;\\n                q.pop();\\n                                \\n                if (node->left != nullptr)\\n                { //node into  left\\n                    q.push({node->left, 2LL * node_index + 1});\\n                //push the node into left into the node\\'s index, \\n                }\\n                \\n                if (node->right != nullptr) \\n                {\\n                    q.push({node->right, 2LL * node_index + 2});\\n                }//push the left node and the index node will be added into it,\\n            }\\n        }\\n        //  \\n        return max_width;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3436538,
                "title": "kotlin-bfs",
                "content": "```\\nclass Solution {\\n  fun widthOfBinaryTree(root: TreeNode?): Int {\\n    if (root == null)\\n      return 0\\n\\n    var res = 0L\\n    val q = ArrayDeque<Pair<TreeNode, Long>>()\\n    q.add(Pair(root, 0L))\\n\\n    while (q.isNotEmpty()) {\\n      var min = Long.MAX_VALUE\\n      var max = Long.MIN_VALUE\\n      repeat(q.size) {\\n        val (node, id) = q.removeFirst()\\n\\n        min = minOf(min, id)\\n        max = maxOf(max, id)\\n\\n        if (node.left != null)\\n          q.add(Pair(node.left!!, id * 2L))\\n\\n        if(node.right != null)\\n          q.add(Pair(node.right!!, id * 2L + 1))\\n      }\\n      res = maxOf(res, (max - min + 1))\\n    }\\n    return res.toInt()\\n  }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n  fun widthOfBinaryTree(root: TreeNode?): Int {\\n    if (root == null)\\n      return 0\\n\\n    var res = 0L\\n    val q = ArrayDeque<Pair<TreeNode, Long>>()\\n    q.add(Pair(root, 0L))\\n\\n    while (q.isNotEmpty()) {\\n      var min = Long.MAX_VALUE\\n      var max = Long.MIN_VALUE\\n      repeat(q.size) {\\n        val (node, id) = q.removeFirst()\\n\\n        min = minOf(min, id)\\n        max = maxOf(max, id)\\n\\n        if (node.left != null)\\n          q.add(Pair(node.left!!, id * 2L))\\n\\n        if(node.right != null)\\n          q.add(Pair(node.right!!, id * 2L + 1))\\n      }\\n      res = maxOf(res, (max - min + 1))\\n    }\\n    return res.toInt()\\n  }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1565112,
                "content": [
                    {
                        "username": "mayank17081998",
                        "content": "See these images, you will get every idea..![image](https://assets.leetcode.com/users/images/fd1dd3c6-d121-43f2-a4ce-8bf529f190bd_1645930387.2246904.png)\\n![image](https://assets.leetcode.com/users/images/3ef66bd5-c49f-4fe3-8fb8-da76ada7136d_1645930439.4141164.png)\\n![image](https://assets.leetcode.com/users/images/311933bc-6041-497e-9ff4-a9af99dd2aa2_1645930452.510014.png)\\n![image](https://assets.leetcode.com/users/images/f28cd784-ae35-4c75-9e9b-0668b1168e0b_1645930452.716098.png)\\n![image](https://assets.leetcode.com/users/images/33142dc2-f781-4403-b872-88b3eb4d792d_1645930458.9626606.png)\\n\\n\\nhttps://www.linkedin.com/posts/mayank-singh-1004981a4_maximum-width-of-binary-tree-ugcPost-6903531275865702400-t3f0\\n\\n\\n"
                    },
                    {
                        "username": "jotho_",
                        "content": "[@Hsiao-Chien-Ti](/Hsiao-Chien-Ti) I think because the maximum difference is guaranteed to fit in an int, then the max can never overflow twice before the min also overflows.  I used DFS as well"
                    },
                    {
                        "username": "Hsiao-Chien-Ti",
                        "content": "Hi [@Mayank Singh](/mayank17081998) Why won\\'t you get overflow by storing a long long type (long long)currentNo*2+1 into a int type pair in queue? I wrote a dfs version with similar concepts as yours, but I am suffering from overflow now. I print the currentNo of yours out, and found that there are some negative numbers, which I guess is overflow."
                    },
                    {
                        "username": "mohak_gaur",
                        "content": "Why have you written this line inside the for loop...\\nrightMostNodeNo = max(rightMostNodeNo, rootNode.first);\\n\\nyou can simply replace it with...\\nrightMostNodeNo = rootNode.first;\\n\\ni submitted with the above one and it was accepted."
                    },
                    {
                        "username": "pilaniya",
                        "content": "Maximum width of above test case should be 6 but expected output is 8. Or am I doing this wrong?"
                    },
                    {
                        "username": "rajveer_09",
                        "content": "You are doing \"SOMETHING\" wrong."
                    },
                    {
                        "username": "Anupkrpal",
                        "content": "it should be 8\\n"
                    },
                    {
                        "username": "amanchandna",
                        "content": "![image.png](https://assets.leetcode.com/users/images/bc506e3e-0ddf-48e9-9a3e-3d345bfb7ebe_1681964515.560179.png)"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Looks easy, but very tricky"
                    },
                    {
                        "username": "pokaChika",
                        "content": "Hint: If Parents index is n left child is 2*n and right child is 2*n+1. Think along these lines\\n"
                    },
                    {
                        "username": "sk4142",
                        "content": "Extremely good hint"
                    },
                    {
                        "username": "Sudhanshu145",
                        "content": "thanks\\n"
                    },
                    {
                        "username": "thephilosoft",
                        "content": "It is a good idea to test your solution with this input\\n\\n```\\n[-64,12,18,-4,-53,null,76,null,-51,null,null,-93,3,null,-31,47,null,3,53,-81,33,4,null,-51,-44,-60,11,null,null,null,null,78,null,-35,-64,26,-81,-31,27,60,74,null,null,8,-38,47,12,-24,null,-59,-49,-11,-51,67,null,null,null,null,null,null,null,-67,null,-37,-19,10,-55,72,null,null,null,-70,17,-4,null,null,null,null,null,null,null,3,80,44,-88,-91,null,48,-90,-30,null,null,90,-34,37,null,null,73,-38,-31,-85,-31,-96,null,null,-18,67,34,72,null,-17,-77,null,56,-65,-88,-53,null,null,null,-33,86,null,81,-42,null,null,98,-40,70,-26,24,null,null,null,null,92,72,-27,null,null,null,null,null,null,-67,null,null,null,null,null,null,null,-54,-66,-36,null,-72,null,null,43,null,null,null,-92,-1,-98,null,null,null,null,null,null,null,39,-84,null,null,null,null,null,null,null,null,null,null,null,null,null,-93,null,null,null,98]\\n```\\n\\nThe expected answer is `169`"
                    },
                    {
                        "username": "anwendeng",
                        "content": "C++ solution must use unsigned long long !!! Then every thing goes well.\n===============================\noverflow ! 72 / 114 testcases passed\nLine 19: Char 34: runtime error: signed integer overflow: 9223372036854775807 * 2 cannot be represented in type 'long long' (solution.cpp)\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:28:34\n===============================\n[0,0,0,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null]"
                    },
                    {
                        "username": "user4750s",
                        "content": "even long long works fine."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "It\\'s a life (streak) savior comment"
                    },
                    {
                        "username": "user5400vw",
                        "content": "this solution doesn\\'t use unsigned https://leetcode.com/problems/maximum-width-of-binary-tree/solutions/3436483/c-bfs-approach-with-explanation-simple-solution/"
                    },
                    {
                        "username": "andrew99154",
                        "content": "It\\'s helpful for C++ programmers, thanks a lot."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@cskrisz](/cskrisz)  64-bit unsigned int, I think!"
                    },
                    {
                        "username": "cskrisz",
                        "content": "The key is that it\\'s unsigned. You can use `unsigned int` too. `unsigned long long` still can\\'t represent all the indices, but it wraps around without undefined behavior, and then the subtraction works too."
                    },
                    {
                        "username": "anwendeng",
                        "content": "C++ solution must use unsigned long long https://leetcode.com/problems/maximum-width-of-binary-tree/solutions/3436610/dfs-c-solution-must-use-unsigned-long-long/"
                    },
                    {
                        "username": "jskat",
                        "content": "This question reinforced the idea of reading the whole question prompt. I have such a bad habit of reading the first sentence and then trying to solve immediately"
                    },
                    {
                        "username": "leetdaily11",
                        "content": "was just about to post this in discussion! Need to be patient!"
                    },
                    {
                        "username": "jknagin",
                        "content": "This should be a hard."
                    },
                    {
                        "username": "JoshuaMorris95",
                        "content": "Frustrating challenge as some test cases require the use of BigInt when solving in JavaScript."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yep, starts around case 72"
                    }
                ]
            },
            {
                "id": 1565320,
                "content": [
                    {
                        "username": "mayank17081998",
                        "content": "See these images, you will get every idea..![image](https://assets.leetcode.com/users/images/fd1dd3c6-d121-43f2-a4ce-8bf529f190bd_1645930387.2246904.png)\\n![image](https://assets.leetcode.com/users/images/3ef66bd5-c49f-4fe3-8fb8-da76ada7136d_1645930439.4141164.png)\\n![image](https://assets.leetcode.com/users/images/311933bc-6041-497e-9ff4-a9af99dd2aa2_1645930452.510014.png)\\n![image](https://assets.leetcode.com/users/images/f28cd784-ae35-4c75-9e9b-0668b1168e0b_1645930452.716098.png)\\n![image](https://assets.leetcode.com/users/images/33142dc2-f781-4403-b872-88b3eb4d792d_1645930458.9626606.png)\\n\\n\\nhttps://www.linkedin.com/posts/mayank-singh-1004981a4_maximum-width-of-binary-tree-ugcPost-6903531275865702400-t3f0\\n\\n\\n"
                    },
                    {
                        "username": "jotho_",
                        "content": "[@Hsiao-Chien-Ti](/Hsiao-Chien-Ti) I think because the maximum difference is guaranteed to fit in an int, then the max can never overflow twice before the min also overflows.  I used DFS as well"
                    },
                    {
                        "username": "Hsiao-Chien-Ti",
                        "content": "Hi [@Mayank Singh](/mayank17081998) Why won\\'t you get overflow by storing a long long type (long long)currentNo*2+1 into a int type pair in queue? I wrote a dfs version with similar concepts as yours, but I am suffering from overflow now. I print the currentNo of yours out, and found that there are some negative numbers, which I guess is overflow."
                    },
                    {
                        "username": "mohak_gaur",
                        "content": "Why have you written this line inside the for loop...\\nrightMostNodeNo = max(rightMostNodeNo, rootNode.first);\\n\\nyou can simply replace it with...\\nrightMostNodeNo = rootNode.first;\\n\\ni submitted with the above one and it was accepted."
                    },
                    {
                        "username": "pilaniya",
                        "content": "Maximum width of above test case should be 6 but expected output is 8. Or am I doing this wrong?"
                    },
                    {
                        "username": "rajveer_09",
                        "content": "You are doing \"SOMETHING\" wrong."
                    },
                    {
                        "username": "Anupkrpal",
                        "content": "it should be 8\\n"
                    },
                    {
                        "username": "amanchandna",
                        "content": "![image.png](https://assets.leetcode.com/users/images/bc506e3e-0ddf-48e9-9a3e-3d345bfb7ebe_1681964515.560179.png)"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Looks easy, but very tricky"
                    },
                    {
                        "username": "pokaChika",
                        "content": "Hint: If Parents index is n left child is 2*n and right child is 2*n+1. Think along these lines\\n"
                    },
                    {
                        "username": "sk4142",
                        "content": "Extremely good hint"
                    },
                    {
                        "username": "Sudhanshu145",
                        "content": "thanks\\n"
                    },
                    {
                        "username": "thephilosoft",
                        "content": "It is a good idea to test your solution with this input\\n\\n```\\n[-64,12,18,-4,-53,null,76,null,-51,null,null,-93,3,null,-31,47,null,3,53,-81,33,4,null,-51,-44,-60,11,null,null,null,null,78,null,-35,-64,26,-81,-31,27,60,74,null,null,8,-38,47,12,-24,null,-59,-49,-11,-51,67,null,null,null,null,null,null,null,-67,null,-37,-19,10,-55,72,null,null,null,-70,17,-4,null,null,null,null,null,null,null,3,80,44,-88,-91,null,48,-90,-30,null,null,90,-34,37,null,null,73,-38,-31,-85,-31,-96,null,null,-18,67,34,72,null,-17,-77,null,56,-65,-88,-53,null,null,null,-33,86,null,81,-42,null,null,98,-40,70,-26,24,null,null,null,null,92,72,-27,null,null,null,null,null,null,-67,null,null,null,null,null,null,null,-54,-66,-36,null,-72,null,null,43,null,null,null,-92,-1,-98,null,null,null,null,null,null,null,39,-84,null,null,null,null,null,null,null,null,null,null,null,null,null,-93,null,null,null,98]\\n```\\n\\nThe expected answer is `169`"
                    },
                    {
                        "username": "anwendeng",
                        "content": "C++ solution must use unsigned long long !!! Then every thing goes well.\n===============================\noverflow ! 72 / 114 testcases passed\nLine 19: Char 34: runtime error: signed integer overflow: 9223372036854775807 * 2 cannot be represented in type 'long long' (solution.cpp)\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:28:34\n===============================\n[0,0,0,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null]"
                    },
                    {
                        "username": "user4750s",
                        "content": "even long long works fine."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "It\\'s a life (streak) savior comment"
                    },
                    {
                        "username": "user5400vw",
                        "content": "this solution doesn\\'t use unsigned https://leetcode.com/problems/maximum-width-of-binary-tree/solutions/3436483/c-bfs-approach-with-explanation-simple-solution/"
                    },
                    {
                        "username": "andrew99154",
                        "content": "It\\'s helpful for C++ programmers, thanks a lot."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@cskrisz](/cskrisz)  64-bit unsigned int, I think!"
                    },
                    {
                        "username": "cskrisz",
                        "content": "The key is that it\\'s unsigned. You can use `unsigned int` too. `unsigned long long` still can\\'t represent all the indices, but it wraps around without undefined behavior, and then the subtraction works too."
                    },
                    {
                        "username": "anwendeng",
                        "content": "C++ solution must use unsigned long long https://leetcode.com/problems/maximum-width-of-binary-tree/solutions/3436610/dfs-c-solution-must-use-unsigned-long-long/"
                    },
                    {
                        "username": "jskat",
                        "content": "This question reinforced the idea of reading the whole question prompt. I have such a bad habit of reading the first sentence and then trying to solve immediately"
                    },
                    {
                        "username": "leetdaily11",
                        "content": "was just about to post this in discussion! Need to be patient!"
                    },
                    {
                        "username": "jknagin",
                        "content": "This should be a hard."
                    },
                    {
                        "username": "JoshuaMorris95",
                        "content": "Frustrating challenge as some test cases require the use of BigInt when solving in JavaScript."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yep, starts around case 72"
                    }
                ]
            },
            {
                "id": 1868940,
                "content": [
                    {
                        "username": "mayank17081998",
                        "content": "See these images, you will get every idea..![image](https://assets.leetcode.com/users/images/fd1dd3c6-d121-43f2-a4ce-8bf529f190bd_1645930387.2246904.png)\\n![image](https://assets.leetcode.com/users/images/3ef66bd5-c49f-4fe3-8fb8-da76ada7136d_1645930439.4141164.png)\\n![image](https://assets.leetcode.com/users/images/311933bc-6041-497e-9ff4-a9af99dd2aa2_1645930452.510014.png)\\n![image](https://assets.leetcode.com/users/images/f28cd784-ae35-4c75-9e9b-0668b1168e0b_1645930452.716098.png)\\n![image](https://assets.leetcode.com/users/images/33142dc2-f781-4403-b872-88b3eb4d792d_1645930458.9626606.png)\\n\\n\\nhttps://www.linkedin.com/posts/mayank-singh-1004981a4_maximum-width-of-binary-tree-ugcPost-6903531275865702400-t3f0\\n\\n\\n"
                    },
                    {
                        "username": "jotho_",
                        "content": "[@Hsiao-Chien-Ti](/Hsiao-Chien-Ti) I think because the maximum difference is guaranteed to fit in an int, then the max can never overflow twice before the min also overflows.  I used DFS as well"
                    },
                    {
                        "username": "Hsiao-Chien-Ti",
                        "content": "Hi [@Mayank Singh](/mayank17081998) Why won\\'t you get overflow by storing a long long type (long long)currentNo*2+1 into a int type pair in queue? I wrote a dfs version with similar concepts as yours, but I am suffering from overflow now. I print the currentNo of yours out, and found that there are some negative numbers, which I guess is overflow."
                    },
                    {
                        "username": "mohak_gaur",
                        "content": "Why have you written this line inside the for loop...\\nrightMostNodeNo = max(rightMostNodeNo, rootNode.first);\\n\\nyou can simply replace it with...\\nrightMostNodeNo = rootNode.first;\\n\\ni submitted with the above one and it was accepted."
                    },
                    {
                        "username": "pilaniya",
                        "content": "Maximum width of above test case should be 6 but expected output is 8. Or am I doing this wrong?"
                    },
                    {
                        "username": "rajveer_09",
                        "content": "You are doing \"SOMETHING\" wrong."
                    },
                    {
                        "username": "Anupkrpal",
                        "content": "it should be 8\\n"
                    },
                    {
                        "username": "amanchandna",
                        "content": "![image.png](https://assets.leetcode.com/users/images/bc506e3e-0ddf-48e9-9a3e-3d345bfb7ebe_1681964515.560179.png)"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Looks easy, but very tricky"
                    },
                    {
                        "username": "pokaChika",
                        "content": "Hint: If Parents index is n left child is 2*n and right child is 2*n+1. Think along these lines\\n"
                    },
                    {
                        "username": "sk4142",
                        "content": "Extremely good hint"
                    },
                    {
                        "username": "Sudhanshu145",
                        "content": "thanks\\n"
                    },
                    {
                        "username": "thephilosoft",
                        "content": "It is a good idea to test your solution with this input\\n\\n```\\n[-64,12,18,-4,-53,null,76,null,-51,null,null,-93,3,null,-31,47,null,3,53,-81,33,4,null,-51,-44,-60,11,null,null,null,null,78,null,-35,-64,26,-81,-31,27,60,74,null,null,8,-38,47,12,-24,null,-59,-49,-11,-51,67,null,null,null,null,null,null,null,-67,null,-37,-19,10,-55,72,null,null,null,-70,17,-4,null,null,null,null,null,null,null,3,80,44,-88,-91,null,48,-90,-30,null,null,90,-34,37,null,null,73,-38,-31,-85,-31,-96,null,null,-18,67,34,72,null,-17,-77,null,56,-65,-88,-53,null,null,null,-33,86,null,81,-42,null,null,98,-40,70,-26,24,null,null,null,null,92,72,-27,null,null,null,null,null,null,-67,null,null,null,null,null,null,null,-54,-66,-36,null,-72,null,null,43,null,null,null,-92,-1,-98,null,null,null,null,null,null,null,39,-84,null,null,null,null,null,null,null,null,null,null,null,null,null,-93,null,null,null,98]\\n```\\n\\nThe expected answer is `169`"
                    },
                    {
                        "username": "anwendeng",
                        "content": "C++ solution must use unsigned long long !!! Then every thing goes well.\n===============================\noverflow ! 72 / 114 testcases passed\nLine 19: Char 34: runtime error: signed integer overflow: 9223372036854775807 * 2 cannot be represented in type 'long long' (solution.cpp)\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:28:34\n===============================\n[0,0,0,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null]"
                    },
                    {
                        "username": "user4750s",
                        "content": "even long long works fine."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "It\\'s a life (streak) savior comment"
                    },
                    {
                        "username": "user5400vw",
                        "content": "this solution doesn\\'t use unsigned https://leetcode.com/problems/maximum-width-of-binary-tree/solutions/3436483/c-bfs-approach-with-explanation-simple-solution/"
                    },
                    {
                        "username": "andrew99154",
                        "content": "It\\'s helpful for C++ programmers, thanks a lot."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@cskrisz](/cskrisz)  64-bit unsigned int, I think!"
                    },
                    {
                        "username": "cskrisz",
                        "content": "The key is that it\\'s unsigned. You can use `unsigned int` too. `unsigned long long` still can\\'t represent all the indices, but it wraps around without undefined behavior, and then the subtraction works too."
                    },
                    {
                        "username": "anwendeng",
                        "content": "C++ solution must use unsigned long long https://leetcode.com/problems/maximum-width-of-binary-tree/solutions/3436610/dfs-c-solution-must-use-unsigned-long-long/"
                    },
                    {
                        "username": "jskat",
                        "content": "This question reinforced the idea of reading the whole question prompt. I have such a bad habit of reading the first sentence and then trying to solve immediately"
                    },
                    {
                        "username": "leetdaily11",
                        "content": "was just about to post this in discussion! Need to be patient!"
                    },
                    {
                        "username": "jknagin",
                        "content": "This should be a hard."
                    },
                    {
                        "username": "JoshuaMorris95",
                        "content": "Frustrating challenge as some test cases require the use of BigInt when solving in JavaScript."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yep, starts around case 72"
                    }
                ]
            },
            {
                "id": 1869064,
                "content": [
                    {
                        "username": "mayank17081998",
                        "content": "See these images, you will get every idea..![image](https://assets.leetcode.com/users/images/fd1dd3c6-d121-43f2-a4ce-8bf529f190bd_1645930387.2246904.png)\\n![image](https://assets.leetcode.com/users/images/3ef66bd5-c49f-4fe3-8fb8-da76ada7136d_1645930439.4141164.png)\\n![image](https://assets.leetcode.com/users/images/311933bc-6041-497e-9ff4-a9af99dd2aa2_1645930452.510014.png)\\n![image](https://assets.leetcode.com/users/images/f28cd784-ae35-4c75-9e9b-0668b1168e0b_1645930452.716098.png)\\n![image](https://assets.leetcode.com/users/images/33142dc2-f781-4403-b872-88b3eb4d792d_1645930458.9626606.png)\\n\\n\\nhttps://www.linkedin.com/posts/mayank-singh-1004981a4_maximum-width-of-binary-tree-ugcPost-6903531275865702400-t3f0\\n\\n\\n"
                    },
                    {
                        "username": "jotho_",
                        "content": "[@Hsiao-Chien-Ti](/Hsiao-Chien-Ti) I think because the maximum difference is guaranteed to fit in an int, then the max can never overflow twice before the min also overflows.  I used DFS as well"
                    },
                    {
                        "username": "Hsiao-Chien-Ti",
                        "content": "Hi [@Mayank Singh](/mayank17081998) Why won\\'t you get overflow by storing a long long type (long long)currentNo*2+1 into a int type pair in queue? I wrote a dfs version with similar concepts as yours, but I am suffering from overflow now. I print the currentNo of yours out, and found that there are some negative numbers, which I guess is overflow."
                    },
                    {
                        "username": "mohak_gaur",
                        "content": "Why have you written this line inside the for loop...\\nrightMostNodeNo = max(rightMostNodeNo, rootNode.first);\\n\\nyou can simply replace it with...\\nrightMostNodeNo = rootNode.first;\\n\\ni submitted with the above one and it was accepted."
                    },
                    {
                        "username": "pilaniya",
                        "content": "Maximum width of above test case should be 6 but expected output is 8. Or am I doing this wrong?"
                    },
                    {
                        "username": "rajveer_09",
                        "content": "You are doing \"SOMETHING\" wrong."
                    },
                    {
                        "username": "Anupkrpal",
                        "content": "it should be 8\\n"
                    },
                    {
                        "username": "amanchandna",
                        "content": "![image.png](https://assets.leetcode.com/users/images/bc506e3e-0ddf-48e9-9a3e-3d345bfb7ebe_1681964515.560179.png)"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Looks easy, but very tricky"
                    },
                    {
                        "username": "pokaChika",
                        "content": "Hint: If Parents index is n left child is 2*n and right child is 2*n+1. Think along these lines\\n"
                    },
                    {
                        "username": "sk4142",
                        "content": "Extremely good hint"
                    },
                    {
                        "username": "Sudhanshu145",
                        "content": "thanks\\n"
                    },
                    {
                        "username": "thephilosoft",
                        "content": "It is a good idea to test your solution with this input\\n\\n```\\n[-64,12,18,-4,-53,null,76,null,-51,null,null,-93,3,null,-31,47,null,3,53,-81,33,4,null,-51,-44,-60,11,null,null,null,null,78,null,-35,-64,26,-81,-31,27,60,74,null,null,8,-38,47,12,-24,null,-59,-49,-11,-51,67,null,null,null,null,null,null,null,-67,null,-37,-19,10,-55,72,null,null,null,-70,17,-4,null,null,null,null,null,null,null,3,80,44,-88,-91,null,48,-90,-30,null,null,90,-34,37,null,null,73,-38,-31,-85,-31,-96,null,null,-18,67,34,72,null,-17,-77,null,56,-65,-88,-53,null,null,null,-33,86,null,81,-42,null,null,98,-40,70,-26,24,null,null,null,null,92,72,-27,null,null,null,null,null,null,-67,null,null,null,null,null,null,null,-54,-66,-36,null,-72,null,null,43,null,null,null,-92,-1,-98,null,null,null,null,null,null,null,39,-84,null,null,null,null,null,null,null,null,null,null,null,null,null,-93,null,null,null,98]\\n```\\n\\nThe expected answer is `169`"
                    },
                    {
                        "username": "anwendeng",
                        "content": "C++ solution must use unsigned long long !!! Then every thing goes well.\n===============================\noverflow ! 72 / 114 testcases passed\nLine 19: Char 34: runtime error: signed integer overflow: 9223372036854775807 * 2 cannot be represented in type 'long long' (solution.cpp)\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:28:34\n===============================\n[0,0,0,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null]"
                    },
                    {
                        "username": "user4750s",
                        "content": "even long long works fine."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "It\\'s a life (streak) savior comment"
                    },
                    {
                        "username": "user5400vw",
                        "content": "this solution doesn\\'t use unsigned https://leetcode.com/problems/maximum-width-of-binary-tree/solutions/3436483/c-bfs-approach-with-explanation-simple-solution/"
                    },
                    {
                        "username": "andrew99154",
                        "content": "It\\'s helpful for C++ programmers, thanks a lot."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@cskrisz](/cskrisz)  64-bit unsigned int, I think!"
                    },
                    {
                        "username": "cskrisz",
                        "content": "The key is that it\\'s unsigned. You can use `unsigned int` too. `unsigned long long` still can\\'t represent all the indices, but it wraps around without undefined behavior, and then the subtraction works too."
                    },
                    {
                        "username": "anwendeng",
                        "content": "C++ solution must use unsigned long long https://leetcode.com/problems/maximum-width-of-binary-tree/solutions/3436610/dfs-c-solution-must-use-unsigned-long-long/"
                    },
                    {
                        "username": "jskat",
                        "content": "This question reinforced the idea of reading the whole question prompt. I have such a bad habit of reading the first sentence and then trying to solve immediately"
                    },
                    {
                        "username": "leetdaily11",
                        "content": "was just about to post this in discussion! Need to be patient!"
                    },
                    {
                        "username": "jknagin",
                        "content": "This should be a hard."
                    },
                    {
                        "username": "JoshuaMorris95",
                        "content": "Frustrating challenge as some test cases require the use of BigInt when solving in JavaScript."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yep, starts around case 72"
                    }
                ]
            },
            {
                "id": 1869005,
                "content": [
                    {
                        "username": "mayank17081998",
                        "content": "See these images, you will get every idea..![image](https://assets.leetcode.com/users/images/fd1dd3c6-d121-43f2-a4ce-8bf529f190bd_1645930387.2246904.png)\\n![image](https://assets.leetcode.com/users/images/3ef66bd5-c49f-4fe3-8fb8-da76ada7136d_1645930439.4141164.png)\\n![image](https://assets.leetcode.com/users/images/311933bc-6041-497e-9ff4-a9af99dd2aa2_1645930452.510014.png)\\n![image](https://assets.leetcode.com/users/images/f28cd784-ae35-4c75-9e9b-0668b1168e0b_1645930452.716098.png)\\n![image](https://assets.leetcode.com/users/images/33142dc2-f781-4403-b872-88b3eb4d792d_1645930458.9626606.png)\\n\\n\\nhttps://www.linkedin.com/posts/mayank-singh-1004981a4_maximum-width-of-binary-tree-ugcPost-6903531275865702400-t3f0\\n\\n\\n"
                    },
                    {
                        "username": "jotho_",
                        "content": "[@Hsiao-Chien-Ti](/Hsiao-Chien-Ti) I think because the maximum difference is guaranteed to fit in an int, then the max can never overflow twice before the min also overflows.  I used DFS as well"
                    },
                    {
                        "username": "Hsiao-Chien-Ti",
                        "content": "Hi [@Mayank Singh](/mayank17081998) Why won\\'t you get overflow by storing a long long type (long long)currentNo*2+1 into a int type pair in queue? I wrote a dfs version with similar concepts as yours, but I am suffering from overflow now. I print the currentNo of yours out, and found that there are some negative numbers, which I guess is overflow."
                    },
                    {
                        "username": "mohak_gaur",
                        "content": "Why have you written this line inside the for loop...\\nrightMostNodeNo = max(rightMostNodeNo, rootNode.first);\\n\\nyou can simply replace it with...\\nrightMostNodeNo = rootNode.first;\\n\\ni submitted with the above one and it was accepted."
                    },
                    {
                        "username": "pilaniya",
                        "content": "Maximum width of above test case should be 6 but expected output is 8. Or am I doing this wrong?"
                    },
                    {
                        "username": "rajveer_09",
                        "content": "You are doing \"SOMETHING\" wrong."
                    },
                    {
                        "username": "Anupkrpal",
                        "content": "it should be 8\\n"
                    },
                    {
                        "username": "amanchandna",
                        "content": "![image.png](https://assets.leetcode.com/users/images/bc506e3e-0ddf-48e9-9a3e-3d345bfb7ebe_1681964515.560179.png)"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Looks easy, but very tricky"
                    },
                    {
                        "username": "pokaChika",
                        "content": "Hint: If Parents index is n left child is 2*n and right child is 2*n+1. Think along these lines\\n"
                    },
                    {
                        "username": "sk4142",
                        "content": "Extremely good hint"
                    },
                    {
                        "username": "Sudhanshu145",
                        "content": "thanks\\n"
                    },
                    {
                        "username": "thephilosoft",
                        "content": "It is a good idea to test your solution with this input\\n\\n```\\n[-64,12,18,-4,-53,null,76,null,-51,null,null,-93,3,null,-31,47,null,3,53,-81,33,4,null,-51,-44,-60,11,null,null,null,null,78,null,-35,-64,26,-81,-31,27,60,74,null,null,8,-38,47,12,-24,null,-59,-49,-11,-51,67,null,null,null,null,null,null,null,-67,null,-37,-19,10,-55,72,null,null,null,-70,17,-4,null,null,null,null,null,null,null,3,80,44,-88,-91,null,48,-90,-30,null,null,90,-34,37,null,null,73,-38,-31,-85,-31,-96,null,null,-18,67,34,72,null,-17,-77,null,56,-65,-88,-53,null,null,null,-33,86,null,81,-42,null,null,98,-40,70,-26,24,null,null,null,null,92,72,-27,null,null,null,null,null,null,-67,null,null,null,null,null,null,null,-54,-66,-36,null,-72,null,null,43,null,null,null,-92,-1,-98,null,null,null,null,null,null,null,39,-84,null,null,null,null,null,null,null,null,null,null,null,null,null,-93,null,null,null,98]\\n```\\n\\nThe expected answer is `169`"
                    },
                    {
                        "username": "anwendeng",
                        "content": "C++ solution must use unsigned long long !!! Then every thing goes well.\n===============================\noverflow ! 72 / 114 testcases passed\nLine 19: Char 34: runtime error: signed integer overflow: 9223372036854775807 * 2 cannot be represented in type 'long long' (solution.cpp)\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:28:34\n===============================\n[0,0,0,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null]"
                    },
                    {
                        "username": "user4750s",
                        "content": "even long long works fine."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "It\\'s a life (streak) savior comment"
                    },
                    {
                        "username": "user5400vw",
                        "content": "this solution doesn\\'t use unsigned https://leetcode.com/problems/maximum-width-of-binary-tree/solutions/3436483/c-bfs-approach-with-explanation-simple-solution/"
                    },
                    {
                        "username": "andrew99154",
                        "content": "It\\'s helpful for C++ programmers, thanks a lot."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@cskrisz](/cskrisz)  64-bit unsigned int, I think!"
                    },
                    {
                        "username": "cskrisz",
                        "content": "The key is that it\\'s unsigned. You can use `unsigned int` too. `unsigned long long` still can\\'t represent all the indices, but it wraps around without undefined behavior, and then the subtraction works too."
                    },
                    {
                        "username": "anwendeng",
                        "content": "C++ solution must use unsigned long long https://leetcode.com/problems/maximum-width-of-binary-tree/solutions/3436610/dfs-c-solution-must-use-unsigned-long-long/"
                    },
                    {
                        "username": "jskat",
                        "content": "This question reinforced the idea of reading the whole question prompt. I have such a bad habit of reading the first sentence and then trying to solve immediately"
                    },
                    {
                        "username": "leetdaily11",
                        "content": "was just about to post this in discussion! Need to be patient!"
                    },
                    {
                        "username": "jknagin",
                        "content": "This should be a hard."
                    },
                    {
                        "username": "JoshuaMorris95",
                        "content": "Frustrating challenge as some test cases require the use of BigInt when solving in JavaScript."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yep, starts around case 72"
                    }
                ]
            },
            {
                "id": 1868877,
                "content": [
                    {
                        "username": "mayank17081998",
                        "content": "See these images, you will get every idea..![image](https://assets.leetcode.com/users/images/fd1dd3c6-d121-43f2-a4ce-8bf529f190bd_1645930387.2246904.png)\\n![image](https://assets.leetcode.com/users/images/3ef66bd5-c49f-4fe3-8fb8-da76ada7136d_1645930439.4141164.png)\\n![image](https://assets.leetcode.com/users/images/311933bc-6041-497e-9ff4-a9af99dd2aa2_1645930452.510014.png)\\n![image](https://assets.leetcode.com/users/images/f28cd784-ae35-4c75-9e9b-0668b1168e0b_1645930452.716098.png)\\n![image](https://assets.leetcode.com/users/images/33142dc2-f781-4403-b872-88b3eb4d792d_1645930458.9626606.png)\\n\\n\\nhttps://www.linkedin.com/posts/mayank-singh-1004981a4_maximum-width-of-binary-tree-ugcPost-6903531275865702400-t3f0\\n\\n\\n"
                    },
                    {
                        "username": "jotho_",
                        "content": "[@Hsiao-Chien-Ti](/Hsiao-Chien-Ti) I think because the maximum difference is guaranteed to fit in an int, then the max can never overflow twice before the min also overflows.  I used DFS as well"
                    },
                    {
                        "username": "Hsiao-Chien-Ti",
                        "content": "Hi [@Mayank Singh](/mayank17081998) Why won\\'t you get overflow by storing a long long type (long long)currentNo*2+1 into a int type pair in queue? I wrote a dfs version with similar concepts as yours, but I am suffering from overflow now. I print the currentNo of yours out, and found that there are some negative numbers, which I guess is overflow."
                    },
                    {
                        "username": "mohak_gaur",
                        "content": "Why have you written this line inside the for loop...\\nrightMostNodeNo = max(rightMostNodeNo, rootNode.first);\\n\\nyou can simply replace it with...\\nrightMostNodeNo = rootNode.first;\\n\\ni submitted with the above one and it was accepted."
                    },
                    {
                        "username": "pilaniya",
                        "content": "Maximum width of above test case should be 6 but expected output is 8. Or am I doing this wrong?"
                    },
                    {
                        "username": "rajveer_09",
                        "content": "You are doing \"SOMETHING\" wrong."
                    },
                    {
                        "username": "Anupkrpal",
                        "content": "it should be 8\\n"
                    },
                    {
                        "username": "amanchandna",
                        "content": "![image.png](https://assets.leetcode.com/users/images/bc506e3e-0ddf-48e9-9a3e-3d345bfb7ebe_1681964515.560179.png)"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Looks easy, but very tricky"
                    },
                    {
                        "username": "pokaChika",
                        "content": "Hint: If Parents index is n left child is 2*n and right child is 2*n+1. Think along these lines\\n"
                    },
                    {
                        "username": "sk4142",
                        "content": "Extremely good hint"
                    },
                    {
                        "username": "Sudhanshu145",
                        "content": "thanks\\n"
                    },
                    {
                        "username": "thephilosoft",
                        "content": "It is a good idea to test your solution with this input\\n\\n```\\n[-64,12,18,-4,-53,null,76,null,-51,null,null,-93,3,null,-31,47,null,3,53,-81,33,4,null,-51,-44,-60,11,null,null,null,null,78,null,-35,-64,26,-81,-31,27,60,74,null,null,8,-38,47,12,-24,null,-59,-49,-11,-51,67,null,null,null,null,null,null,null,-67,null,-37,-19,10,-55,72,null,null,null,-70,17,-4,null,null,null,null,null,null,null,3,80,44,-88,-91,null,48,-90,-30,null,null,90,-34,37,null,null,73,-38,-31,-85,-31,-96,null,null,-18,67,34,72,null,-17,-77,null,56,-65,-88,-53,null,null,null,-33,86,null,81,-42,null,null,98,-40,70,-26,24,null,null,null,null,92,72,-27,null,null,null,null,null,null,-67,null,null,null,null,null,null,null,-54,-66,-36,null,-72,null,null,43,null,null,null,-92,-1,-98,null,null,null,null,null,null,null,39,-84,null,null,null,null,null,null,null,null,null,null,null,null,null,-93,null,null,null,98]\\n```\\n\\nThe expected answer is `169`"
                    },
                    {
                        "username": "anwendeng",
                        "content": "C++ solution must use unsigned long long !!! Then every thing goes well.\n===============================\noverflow ! 72 / 114 testcases passed\nLine 19: Char 34: runtime error: signed integer overflow: 9223372036854775807 * 2 cannot be represented in type 'long long' (solution.cpp)\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:28:34\n===============================\n[0,0,0,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null]"
                    },
                    {
                        "username": "user4750s",
                        "content": "even long long works fine."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "It\\'s a life (streak) savior comment"
                    },
                    {
                        "username": "user5400vw",
                        "content": "this solution doesn\\'t use unsigned https://leetcode.com/problems/maximum-width-of-binary-tree/solutions/3436483/c-bfs-approach-with-explanation-simple-solution/"
                    },
                    {
                        "username": "andrew99154",
                        "content": "It\\'s helpful for C++ programmers, thanks a lot."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@cskrisz](/cskrisz)  64-bit unsigned int, I think!"
                    },
                    {
                        "username": "cskrisz",
                        "content": "The key is that it\\'s unsigned. You can use `unsigned int` too. `unsigned long long` still can\\'t represent all the indices, but it wraps around without undefined behavior, and then the subtraction works too."
                    },
                    {
                        "username": "anwendeng",
                        "content": "C++ solution must use unsigned long long https://leetcode.com/problems/maximum-width-of-binary-tree/solutions/3436610/dfs-c-solution-must-use-unsigned-long-long/"
                    },
                    {
                        "username": "jskat",
                        "content": "This question reinforced the idea of reading the whole question prompt. I have such a bad habit of reading the first sentence and then trying to solve immediately"
                    },
                    {
                        "username": "leetdaily11",
                        "content": "was just about to post this in discussion! Need to be patient!"
                    },
                    {
                        "username": "jknagin",
                        "content": "This should be a hard."
                    },
                    {
                        "username": "JoshuaMorris95",
                        "content": "Frustrating challenge as some test cases require the use of BigInt when solving in JavaScript."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yep, starts around case 72"
                    }
                ]
            },
            {
                "id": 1868851,
                "content": [
                    {
                        "username": "mayank17081998",
                        "content": "See these images, you will get every idea..![image](https://assets.leetcode.com/users/images/fd1dd3c6-d121-43f2-a4ce-8bf529f190bd_1645930387.2246904.png)\\n![image](https://assets.leetcode.com/users/images/3ef66bd5-c49f-4fe3-8fb8-da76ada7136d_1645930439.4141164.png)\\n![image](https://assets.leetcode.com/users/images/311933bc-6041-497e-9ff4-a9af99dd2aa2_1645930452.510014.png)\\n![image](https://assets.leetcode.com/users/images/f28cd784-ae35-4c75-9e9b-0668b1168e0b_1645930452.716098.png)\\n![image](https://assets.leetcode.com/users/images/33142dc2-f781-4403-b872-88b3eb4d792d_1645930458.9626606.png)\\n\\n\\nhttps://www.linkedin.com/posts/mayank-singh-1004981a4_maximum-width-of-binary-tree-ugcPost-6903531275865702400-t3f0\\n\\n\\n"
                    },
                    {
                        "username": "jotho_",
                        "content": "[@Hsiao-Chien-Ti](/Hsiao-Chien-Ti) I think because the maximum difference is guaranteed to fit in an int, then the max can never overflow twice before the min also overflows.  I used DFS as well"
                    },
                    {
                        "username": "Hsiao-Chien-Ti",
                        "content": "Hi [@Mayank Singh](/mayank17081998) Why won\\'t you get overflow by storing a long long type (long long)currentNo*2+1 into a int type pair in queue? I wrote a dfs version with similar concepts as yours, but I am suffering from overflow now. I print the currentNo of yours out, and found that there are some negative numbers, which I guess is overflow."
                    },
                    {
                        "username": "mohak_gaur",
                        "content": "Why have you written this line inside the for loop...\\nrightMostNodeNo = max(rightMostNodeNo, rootNode.first);\\n\\nyou can simply replace it with...\\nrightMostNodeNo = rootNode.first;\\n\\ni submitted with the above one and it was accepted."
                    },
                    {
                        "username": "pilaniya",
                        "content": "Maximum width of above test case should be 6 but expected output is 8. Or am I doing this wrong?"
                    },
                    {
                        "username": "rajveer_09",
                        "content": "You are doing \"SOMETHING\" wrong."
                    },
                    {
                        "username": "Anupkrpal",
                        "content": "it should be 8\\n"
                    },
                    {
                        "username": "amanchandna",
                        "content": "![image.png](https://assets.leetcode.com/users/images/bc506e3e-0ddf-48e9-9a3e-3d345bfb7ebe_1681964515.560179.png)"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Looks easy, but very tricky"
                    },
                    {
                        "username": "pokaChika",
                        "content": "Hint: If Parents index is n left child is 2*n and right child is 2*n+1. Think along these lines\\n"
                    },
                    {
                        "username": "sk4142",
                        "content": "Extremely good hint"
                    },
                    {
                        "username": "Sudhanshu145",
                        "content": "thanks\\n"
                    },
                    {
                        "username": "thephilosoft",
                        "content": "It is a good idea to test your solution with this input\\n\\n```\\n[-64,12,18,-4,-53,null,76,null,-51,null,null,-93,3,null,-31,47,null,3,53,-81,33,4,null,-51,-44,-60,11,null,null,null,null,78,null,-35,-64,26,-81,-31,27,60,74,null,null,8,-38,47,12,-24,null,-59,-49,-11,-51,67,null,null,null,null,null,null,null,-67,null,-37,-19,10,-55,72,null,null,null,-70,17,-4,null,null,null,null,null,null,null,3,80,44,-88,-91,null,48,-90,-30,null,null,90,-34,37,null,null,73,-38,-31,-85,-31,-96,null,null,-18,67,34,72,null,-17,-77,null,56,-65,-88,-53,null,null,null,-33,86,null,81,-42,null,null,98,-40,70,-26,24,null,null,null,null,92,72,-27,null,null,null,null,null,null,-67,null,null,null,null,null,null,null,-54,-66,-36,null,-72,null,null,43,null,null,null,-92,-1,-98,null,null,null,null,null,null,null,39,-84,null,null,null,null,null,null,null,null,null,null,null,null,null,-93,null,null,null,98]\\n```\\n\\nThe expected answer is `169`"
                    },
                    {
                        "username": "anwendeng",
                        "content": "C++ solution must use unsigned long long !!! Then every thing goes well.\n===============================\noverflow ! 72 / 114 testcases passed\nLine 19: Char 34: runtime error: signed integer overflow: 9223372036854775807 * 2 cannot be represented in type 'long long' (solution.cpp)\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:28:34\n===============================\n[0,0,0,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null]"
                    },
                    {
                        "username": "user4750s",
                        "content": "even long long works fine."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "It\\'s a life (streak) savior comment"
                    },
                    {
                        "username": "user5400vw",
                        "content": "this solution doesn\\'t use unsigned https://leetcode.com/problems/maximum-width-of-binary-tree/solutions/3436483/c-bfs-approach-with-explanation-simple-solution/"
                    },
                    {
                        "username": "andrew99154",
                        "content": "It\\'s helpful for C++ programmers, thanks a lot."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@cskrisz](/cskrisz)  64-bit unsigned int, I think!"
                    },
                    {
                        "username": "cskrisz",
                        "content": "The key is that it\\'s unsigned. You can use `unsigned int` too. `unsigned long long` still can\\'t represent all the indices, but it wraps around without undefined behavior, and then the subtraction works too."
                    },
                    {
                        "username": "anwendeng",
                        "content": "C++ solution must use unsigned long long https://leetcode.com/problems/maximum-width-of-binary-tree/solutions/3436610/dfs-c-solution-must-use-unsigned-long-long/"
                    },
                    {
                        "username": "jskat",
                        "content": "This question reinforced the idea of reading the whole question prompt. I have such a bad habit of reading the first sentence and then trying to solve immediately"
                    },
                    {
                        "username": "leetdaily11",
                        "content": "was just about to post this in discussion! Need to be patient!"
                    },
                    {
                        "username": "jknagin",
                        "content": "This should be a hard."
                    },
                    {
                        "username": "JoshuaMorris95",
                        "content": "Frustrating challenge as some test cases require the use of BigInt when solving in JavaScript."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yep, starts around case 72"
                    }
                ]
            },
            {
                "id": 1868994,
                "content": [
                    {
                        "username": "mayank17081998",
                        "content": "See these images, you will get every idea..![image](https://assets.leetcode.com/users/images/fd1dd3c6-d121-43f2-a4ce-8bf529f190bd_1645930387.2246904.png)\\n![image](https://assets.leetcode.com/users/images/3ef66bd5-c49f-4fe3-8fb8-da76ada7136d_1645930439.4141164.png)\\n![image](https://assets.leetcode.com/users/images/311933bc-6041-497e-9ff4-a9af99dd2aa2_1645930452.510014.png)\\n![image](https://assets.leetcode.com/users/images/f28cd784-ae35-4c75-9e9b-0668b1168e0b_1645930452.716098.png)\\n![image](https://assets.leetcode.com/users/images/33142dc2-f781-4403-b872-88b3eb4d792d_1645930458.9626606.png)\\n\\n\\nhttps://www.linkedin.com/posts/mayank-singh-1004981a4_maximum-width-of-binary-tree-ugcPost-6903531275865702400-t3f0\\n\\n\\n"
                    },
                    {
                        "username": "jotho_",
                        "content": "[@Hsiao-Chien-Ti](/Hsiao-Chien-Ti) I think because the maximum difference is guaranteed to fit in an int, then the max can never overflow twice before the min also overflows.  I used DFS as well"
                    },
                    {
                        "username": "Hsiao-Chien-Ti",
                        "content": "Hi [@Mayank Singh](/mayank17081998) Why won\\'t you get overflow by storing a long long type (long long)currentNo*2+1 into a int type pair in queue? I wrote a dfs version with similar concepts as yours, but I am suffering from overflow now. I print the currentNo of yours out, and found that there are some negative numbers, which I guess is overflow."
                    },
                    {
                        "username": "mohak_gaur",
                        "content": "Why have you written this line inside the for loop...\\nrightMostNodeNo = max(rightMostNodeNo, rootNode.first);\\n\\nyou can simply replace it with...\\nrightMostNodeNo = rootNode.first;\\n\\ni submitted with the above one and it was accepted."
                    },
                    {
                        "username": "pilaniya",
                        "content": "Maximum width of above test case should be 6 but expected output is 8. Or am I doing this wrong?"
                    },
                    {
                        "username": "rajveer_09",
                        "content": "You are doing \"SOMETHING\" wrong."
                    },
                    {
                        "username": "Anupkrpal",
                        "content": "it should be 8\\n"
                    },
                    {
                        "username": "amanchandna",
                        "content": "![image.png](https://assets.leetcode.com/users/images/bc506e3e-0ddf-48e9-9a3e-3d345bfb7ebe_1681964515.560179.png)"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Looks easy, but very tricky"
                    },
                    {
                        "username": "pokaChika",
                        "content": "Hint: If Parents index is n left child is 2*n and right child is 2*n+1. Think along these lines\\n"
                    },
                    {
                        "username": "sk4142",
                        "content": "Extremely good hint"
                    },
                    {
                        "username": "Sudhanshu145",
                        "content": "thanks\\n"
                    },
                    {
                        "username": "thephilosoft",
                        "content": "It is a good idea to test your solution with this input\\n\\n```\\n[-64,12,18,-4,-53,null,76,null,-51,null,null,-93,3,null,-31,47,null,3,53,-81,33,4,null,-51,-44,-60,11,null,null,null,null,78,null,-35,-64,26,-81,-31,27,60,74,null,null,8,-38,47,12,-24,null,-59,-49,-11,-51,67,null,null,null,null,null,null,null,-67,null,-37,-19,10,-55,72,null,null,null,-70,17,-4,null,null,null,null,null,null,null,3,80,44,-88,-91,null,48,-90,-30,null,null,90,-34,37,null,null,73,-38,-31,-85,-31,-96,null,null,-18,67,34,72,null,-17,-77,null,56,-65,-88,-53,null,null,null,-33,86,null,81,-42,null,null,98,-40,70,-26,24,null,null,null,null,92,72,-27,null,null,null,null,null,null,-67,null,null,null,null,null,null,null,-54,-66,-36,null,-72,null,null,43,null,null,null,-92,-1,-98,null,null,null,null,null,null,null,39,-84,null,null,null,null,null,null,null,null,null,null,null,null,null,-93,null,null,null,98]\\n```\\n\\nThe expected answer is `169`"
                    },
                    {
                        "username": "anwendeng",
                        "content": "C++ solution must use unsigned long long !!! Then every thing goes well.\n===============================\noverflow ! 72 / 114 testcases passed\nLine 19: Char 34: runtime error: signed integer overflow: 9223372036854775807 * 2 cannot be represented in type 'long long' (solution.cpp)\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:28:34\n===============================\n[0,0,0,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null]"
                    },
                    {
                        "username": "user4750s",
                        "content": "even long long works fine."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "It\\'s a life (streak) savior comment"
                    },
                    {
                        "username": "user5400vw",
                        "content": "this solution doesn\\'t use unsigned https://leetcode.com/problems/maximum-width-of-binary-tree/solutions/3436483/c-bfs-approach-with-explanation-simple-solution/"
                    },
                    {
                        "username": "andrew99154",
                        "content": "It\\'s helpful for C++ programmers, thanks a lot."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@cskrisz](/cskrisz)  64-bit unsigned int, I think!"
                    },
                    {
                        "username": "cskrisz",
                        "content": "The key is that it\\'s unsigned. You can use `unsigned int` too. `unsigned long long` still can\\'t represent all the indices, but it wraps around without undefined behavior, and then the subtraction works too."
                    },
                    {
                        "username": "anwendeng",
                        "content": "C++ solution must use unsigned long long https://leetcode.com/problems/maximum-width-of-binary-tree/solutions/3436610/dfs-c-solution-must-use-unsigned-long-long/"
                    },
                    {
                        "username": "jskat",
                        "content": "This question reinforced the idea of reading the whole question prompt. I have such a bad habit of reading the first sentence and then trying to solve immediately"
                    },
                    {
                        "username": "leetdaily11",
                        "content": "was just about to post this in discussion! Need to be patient!"
                    },
                    {
                        "username": "jknagin",
                        "content": "This should be a hard."
                    },
                    {
                        "username": "JoshuaMorris95",
                        "content": "Frustrating challenge as some test cases require the use of BigInt when solving in JavaScript."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yep, starts around case 72"
                    }
                ]
            },
            {
                "id": 1770040,
                "content": [
                    {
                        "username": "mayank17081998",
                        "content": "See these images, you will get every idea..![image](https://assets.leetcode.com/users/images/fd1dd3c6-d121-43f2-a4ce-8bf529f190bd_1645930387.2246904.png)\\n![image](https://assets.leetcode.com/users/images/3ef66bd5-c49f-4fe3-8fb8-da76ada7136d_1645930439.4141164.png)\\n![image](https://assets.leetcode.com/users/images/311933bc-6041-497e-9ff4-a9af99dd2aa2_1645930452.510014.png)\\n![image](https://assets.leetcode.com/users/images/f28cd784-ae35-4c75-9e9b-0668b1168e0b_1645930452.716098.png)\\n![image](https://assets.leetcode.com/users/images/33142dc2-f781-4403-b872-88b3eb4d792d_1645930458.9626606.png)\\n\\n\\nhttps://www.linkedin.com/posts/mayank-singh-1004981a4_maximum-width-of-binary-tree-ugcPost-6903531275865702400-t3f0\\n\\n\\n"
                    },
                    {
                        "username": "jotho_",
                        "content": "[@Hsiao-Chien-Ti](/Hsiao-Chien-Ti) I think because the maximum difference is guaranteed to fit in an int, then the max can never overflow twice before the min also overflows.  I used DFS as well"
                    },
                    {
                        "username": "Hsiao-Chien-Ti",
                        "content": "Hi [@Mayank Singh](/mayank17081998) Why won\\'t you get overflow by storing a long long type (long long)currentNo*2+1 into a int type pair in queue? I wrote a dfs version with similar concepts as yours, but I am suffering from overflow now. I print the currentNo of yours out, and found that there are some negative numbers, which I guess is overflow."
                    },
                    {
                        "username": "mohak_gaur",
                        "content": "Why have you written this line inside the for loop...\\nrightMostNodeNo = max(rightMostNodeNo, rootNode.first);\\n\\nyou can simply replace it with...\\nrightMostNodeNo = rootNode.first;\\n\\ni submitted with the above one and it was accepted."
                    },
                    {
                        "username": "pilaniya",
                        "content": "Maximum width of above test case should be 6 but expected output is 8. Or am I doing this wrong?"
                    },
                    {
                        "username": "rajveer_09",
                        "content": "You are doing \"SOMETHING\" wrong."
                    },
                    {
                        "username": "Anupkrpal",
                        "content": "it should be 8\\n"
                    },
                    {
                        "username": "amanchandna",
                        "content": "![image.png](https://assets.leetcode.com/users/images/bc506e3e-0ddf-48e9-9a3e-3d345bfb7ebe_1681964515.560179.png)"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Looks easy, but very tricky"
                    },
                    {
                        "username": "pokaChika",
                        "content": "Hint: If Parents index is n left child is 2*n and right child is 2*n+1. Think along these lines\\n"
                    },
                    {
                        "username": "sk4142",
                        "content": "Extremely good hint"
                    },
                    {
                        "username": "Sudhanshu145",
                        "content": "thanks\\n"
                    },
                    {
                        "username": "thephilosoft",
                        "content": "It is a good idea to test your solution with this input\\n\\n```\\n[-64,12,18,-4,-53,null,76,null,-51,null,null,-93,3,null,-31,47,null,3,53,-81,33,4,null,-51,-44,-60,11,null,null,null,null,78,null,-35,-64,26,-81,-31,27,60,74,null,null,8,-38,47,12,-24,null,-59,-49,-11,-51,67,null,null,null,null,null,null,null,-67,null,-37,-19,10,-55,72,null,null,null,-70,17,-4,null,null,null,null,null,null,null,3,80,44,-88,-91,null,48,-90,-30,null,null,90,-34,37,null,null,73,-38,-31,-85,-31,-96,null,null,-18,67,34,72,null,-17,-77,null,56,-65,-88,-53,null,null,null,-33,86,null,81,-42,null,null,98,-40,70,-26,24,null,null,null,null,92,72,-27,null,null,null,null,null,null,-67,null,null,null,null,null,null,null,-54,-66,-36,null,-72,null,null,43,null,null,null,-92,-1,-98,null,null,null,null,null,null,null,39,-84,null,null,null,null,null,null,null,null,null,null,null,null,null,-93,null,null,null,98]\\n```\\n\\nThe expected answer is `169`"
                    },
                    {
                        "username": "anwendeng",
                        "content": "C++ solution must use unsigned long long !!! Then every thing goes well.\n===============================\noverflow ! 72 / 114 testcases passed\nLine 19: Char 34: runtime error: signed integer overflow: 9223372036854775807 * 2 cannot be represented in type 'long long' (solution.cpp)\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:28:34\n===============================\n[0,0,0,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null]"
                    },
                    {
                        "username": "user4750s",
                        "content": "even long long works fine."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "It\\'s a life (streak) savior comment"
                    },
                    {
                        "username": "user5400vw",
                        "content": "this solution doesn\\'t use unsigned https://leetcode.com/problems/maximum-width-of-binary-tree/solutions/3436483/c-bfs-approach-with-explanation-simple-solution/"
                    },
                    {
                        "username": "andrew99154",
                        "content": "It\\'s helpful for C++ programmers, thanks a lot."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@cskrisz](/cskrisz)  64-bit unsigned int, I think!"
                    },
                    {
                        "username": "cskrisz",
                        "content": "The key is that it\\'s unsigned. You can use `unsigned int` too. `unsigned long long` still can\\'t represent all the indices, but it wraps around without undefined behavior, and then the subtraction works too."
                    },
                    {
                        "username": "anwendeng",
                        "content": "C++ solution must use unsigned long long https://leetcode.com/problems/maximum-width-of-binary-tree/solutions/3436610/dfs-c-solution-must-use-unsigned-long-long/"
                    },
                    {
                        "username": "jskat",
                        "content": "This question reinforced the idea of reading the whole question prompt. I have such a bad habit of reading the first sentence and then trying to solve immediately"
                    },
                    {
                        "username": "leetdaily11",
                        "content": "was just about to post this in discussion! Need to be patient!"
                    },
                    {
                        "username": "jknagin",
                        "content": "This should be a hard."
                    },
                    {
                        "username": "JoshuaMorris95",
                        "content": "Frustrating challenge as some test cases require the use of BigInt when solving in JavaScript."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yep, starts around case 72"
                    }
                ]
            },
            {
                "id": 1722810,
                "content": [
                    {
                        "username": "mayank17081998",
                        "content": "See these images, you will get every idea..![image](https://assets.leetcode.com/users/images/fd1dd3c6-d121-43f2-a4ce-8bf529f190bd_1645930387.2246904.png)\\n![image](https://assets.leetcode.com/users/images/3ef66bd5-c49f-4fe3-8fb8-da76ada7136d_1645930439.4141164.png)\\n![image](https://assets.leetcode.com/users/images/311933bc-6041-497e-9ff4-a9af99dd2aa2_1645930452.510014.png)\\n![image](https://assets.leetcode.com/users/images/f28cd784-ae35-4c75-9e9b-0668b1168e0b_1645930452.716098.png)\\n![image](https://assets.leetcode.com/users/images/33142dc2-f781-4403-b872-88b3eb4d792d_1645930458.9626606.png)\\n\\n\\nhttps://www.linkedin.com/posts/mayank-singh-1004981a4_maximum-width-of-binary-tree-ugcPost-6903531275865702400-t3f0\\n\\n\\n"
                    },
                    {
                        "username": "jotho_",
                        "content": "[@Hsiao-Chien-Ti](/Hsiao-Chien-Ti) I think because the maximum difference is guaranteed to fit in an int, then the max can never overflow twice before the min also overflows.  I used DFS as well"
                    },
                    {
                        "username": "Hsiao-Chien-Ti",
                        "content": "Hi [@Mayank Singh](/mayank17081998) Why won\\'t you get overflow by storing a long long type (long long)currentNo*2+1 into a int type pair in queue? I wrote a dfs version with similar concepts as yours, but I am suffering from overflow now. I print the currentNo of yours out, and found that there are some negative numbers, which I guess is overflow."
                    },
                    {
                        "username": "mohak_gaur",
                        "content": "Why have you written this line inside the for loop...\\nrightMostNodeNo = max(rightMostNodeNo, rootNode.first);\\n\\nyou can simply replace it with...\\nrightMostNodeNo = rootNode.first;\\n\\ni submitted with the above one and it was accepted."
                    },
                    {
                        "username": "pilaniya",
                        "content": "Maximum width of above test case should be 6 but expected output is 8. Or am I doing this wrong?"
                    },
                    {
                        "username": "rajveer_09",
                        "content": "You are doing \"SOMETHING\" wrong."
                    },
                    {
                        "username": "Anupkrpal",
                        "content": "it should be 8\\n"
                    },
                    {
                        "username": "amanchandna",
                        "content": "![image.png](https://assets.leetcode.com/users/images/bc506e3e-0ddf-48e9-9a3e-3d345bfb7ebe_1681964515.560179.png)"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Looks easy, but very tricky"
                    },
                    {
                        "username": "pokaChika",
                        "content": "Hint: If Parents index is n left child is 2*n and right child is 2*n+1. Think along these lines\\n"
                    },
                    {
                        "username": "sk4142",
                        "content": "Extremely good hint"
                    },
                    {
                        "username": "Sudhanshu145",
                        "content": "thanks\\n"
                    },
                    {
                        "username": "thephilosoft",
                        "content": "It is a good idea to test your solution with this input\\n\\n```\\n[-64,12,18,-4,-53,null,76,null,-51,null,null,-93,3,null,-31,47,null,3,53,-81,33,4,null,-51,-44,-60,11,null,null,null,null,78,null,-35,-64,26,-81,-31,27,60,74,null,null,8,-38,47,12,-24,null,-59,-49,-11,-51,67,null,null,null,null,null,null,null,-67,null,-37,-19,10,-55,72,null,null,null,-70,17,-4,null,null,null,null,null,null,null,3,80,44,-88,-91,null,48,-90,-30,null,null,90,-34,37,null,null,73,-38,-31,-85,-31,-96,null,null,-18,67,34,72,null,-17,-77,null,56,-65,-88,-53,null,null,null,-33,86,null,81,-42,null,null,98,-40,70,-26,24,null,null,null,null,92,72,-27,null,null,null,null,null,null,-67,null,null,null,null,null,null,null,-54,-66,-36,null,-72,null,null,43,null,null,null,-92,-1,-98,null,null,null,null,null,null,null,39,-84,null,null,null,null,null,null,null,null,null,null,null,null,null,-93,null,null,null,98]\\n```\\n\\nThe expected answer is `169`"
                    },
                    {
                        "username": "anwendeng",
                        "content": "C++ solution must use unsigned long long !!! Then every thing goes well.\n===============================\noverflow ! 72 / 114 testcases passed\nLine 19: Char 34: runtime error: signed integer overflow: 9223372036854775807 * 2 cannot be represented in type 'long long' (solution.cpp)\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:28:34\n===============================\n[0,0,0,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null]"
                    },
                    {
                        "username": "user4750s",
                        "content": "even long long works fine."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "It\\'s a life (streak) savior comment"
                    },
                    {
                        "username": "user5400vw",
                        "content": "this solution doesn\\'t use unsigned https://leetcode.com/problems/maximum-width-of-binary-tree/solutions/3436483/c-bfs-approach-with-explanation-simple-solution/"
                    },
                    {
                        "username": "andrew99154",
                        "content": "It\\'s helpful for C++ programmers, thanks a lot."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@cskrisz](/cskrisz)  64-bit unsigned int, I think!"
                    },
                    {
                        "username": "cskrisz",
                        "content": "The key is that it\\'s unsigned. You can use `unsigned int` too. `unsigned long long` still can\\'t represent all the indices, but it wraps around without undefined behavior, and then the subtraction works too."
                    },
                    {
                        "username": "anwendeng",
                        "content": "C++ solution must use unsigned long long https://leetcode.com/problems/maximum-width-of-binary-tree/solutions/3436610/dfs-c-solution-must-use-unsigned-long-long/"
                    },
                    {
                        "username": "jskat",
                        "content": "This question reinforced the idea of reading the whole question prompt. I have such a bad habit of reading the first sentence and then trying to solve immediately"
                    },
                    {
                        "username": "leetdaily11",
                        "content": "was just about to post this in discussion! Need to be patient!"
                    },
                    {
                        "username": "jknagin",
                        "content": "This should be a hard."
                    },
                    {
                        "username": "JoshuaMorris95",
                        "content": "Frustrating challenge as some test cases require the use of BigInt when solving in JavaScript."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yep, starts around case 72"
                    }
                ]
            },
            {
                "id": 1565112,
                "content": [
                    {
                        "username": "mayank17081998",
                        "content": "See these images, you will get every idea..![image](https://assets.leetcode.com/users/images/fd1dd3c6-d121-43f2-a4ce-8bf529f190bd_1645930387.2246904.png)\\n![image](https://assets.leetcode.com/users/images/3ef66bd5-c49f-4fe3-8fb8-da76ada7136d_1645930439.4141164.png)\\n![image](https://assets.leetcode.com/users/images/311933bc-6041-497e-9ff4-a9af99dd2aa2_1645930452.510014.png)\\n![image](https://assets.leetcode.com/users/images/f28cd784-ae35-4c75-9e9b-0668b1168e0b_1645930452.716098.png)\\n![image](https://assets.leetcode.com/users/images/33142dc2-f781-4403-b872-88b3eb4d792d_1645930458.9626606.png)\\n\\n\\nhttps://www.linkedin.com/posts/mayank-singh-1004981a4_maximum-width-of-binary-tree-ugcPost-6903531275865702400-t3f0\\n\\n\\n"
                    },
                    {
                        "username": "jotho_",
                        "content": "[@Hsiao-Chien-Ti](/Hsiao-Chien-Ti) I think because the maximum difference is guaranteed to fit in an int, then the max can never overflow twice before the min also overflows.  I used DFS as well"
                    },
                    {
                        "username": "Hsiao-Chien-Ti",
                        "content": "Hi [@Mayank Singh](/mayank17081998) Why won\\'t you get overflow by storing a long long type (long long)currentNo*2+1 into a int type pair in queue? I wrote a dfs version with similar concepts as yours, but I am suffering from overflow now. I print the currentNo of yours out, and found that there are some negative numbers, which I guess is overflow."
                    },
                    {
                        "username": "mohak_gaur",
                        "content": "Why have you written this line inside the for loop...\\nrightMostNodeNo = max(rightMostNodeNo, rootNode.first);\\n\\nyou can simply replace it with...\\nrightMostNodeNo = rootNode.first;\\n\\ni submitted with the above one and it was accepted."
                    },
                    {
                        "username": "pilaniya",
                        "content": "Maximum width of above test case should be 6 but expected output is 8. Or am I doing this wrong?"
                    },
                    {
                        "username": "rajveer_09",
                        "content": "You are doing \"SOMETHING\" wrong."
                    },
                    {
                        "username": "Anupkrpal",
                        "content": "it should be 8\\n"
                    },
                    {
                        "username": "amanchandna",
                        "content": "![image.png](https://assets.leetcode.com/users/images/bc506e3e-0ddf-48e9-9a3e-3d345bfb7ebe_1681964515.560179.png)"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Looks easy, but very tricky"
                    },
                    {
                        "username": "pokaChika",
                        "content": "Hint: If Parents index is n left child is 2*n and right child is 2*n+1. Think along these lines\\n"
                    },
                    {
                        "username": "sk4142",
                        "content": "Extremely good hint"
                    },
                    {
                        "username": "Sudhanshu145",
                        "content": "thanks\\n"
                    },
                    {
                        "username": "thephilosoft",
                        "content": "It is a good idea to test your solution with this input\\n\\n```\\n[-64,12,18,-4,-53,null,76,null,-51,null,null,-93,3,null,-31,47,null,3,53,-81,33,4,null,-51,-44,-60,11,null,null,null,null,78,null,-35,-64,26,-81,-31,27,60,74,null,null,8,-38,47,12,-24,null,-59,-49,-11,-51,67,null,null,null,null,null,null,null,-67,null,-37,-19,10,-55,72,null,null,null,-70,17,-4,null,null,null,null,null,null,null,3,80,44,-88,-91,null,48,-90,-30,null,null,90,-34,37,null,null,73,-38,-31,-85,-31,-96,null,null,-18,67,34,72,null,-17,-77,null,56,-65,-88,-53,null,null,null,-33,86,null,81,-42,null,null,98,-40,70,-26,24,null,null,null,null,92,72,-27,null,null,null,null,null,null,-67,null,null,null,null,null,null,null,-54,-66,-36,null,-72,null,null,43,null,null,null,-92,-1,-98,null,null,null,null,null,null,null,39,-84,null,null,null,null,null,null,null,null,null,null,null,null,null,-93,null,null,null,98]\\n```\\n\\nThe expected answer is `169`"
                    },
                    {
                        "username": "anwendeng",
                        "content": "C++ solution must use unsigned long long !!! Then every thing goes well.\n===============================\noverflow ! 72 / 114 testcases passed\nLine 19: Char 34: runtime error: signed integer overflow: 9223372036854775807 * 2 cannot be represented in type 'long long' (solution.cpp)\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:28:34\n===============================\n[0,0,0,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null]"
                    },
                    {
                        "username": "user4750s",
                        "content": "even long long works fine."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "It\\'s a life (streak) savior comment"
                    },
                    {
                        "username": "user5400vw",
                        "content": "this solution doesn\\'t use unsigned https://leetcode.com/problems/maximum-width-of-binary-tree/solutions/3436483/c-bfs-approach-with-explanation-simple-solution/"
                    },
                    {
                        "username": "andrew99154",
                        "content": "It\\'s helpful for C++ programmers, thanks a lot."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@cskrisz](/cskrisz)  64-bit unsigned int, I think!"
                    },
                    {
                        "username": "cskrisz",
                        "content": "The key is that it\\'s unsigned. You can use `unsigned int` too. `unsigned long long` still can\\'t represent all the indices, but it wraps around without undefined behavior, and then the subtraction works too."
                    },
                    {
                        "username": "anwendeng",
                        "content": "C++ solution must use unsigned long long https://leetcode.com/problems/maximum-width-of-binary-tree/solutions/3436610/dfs-c-solution-must-use-unsigned-long-long/"
                    },
                    {
                        "username": "jskat",
                        "content": "This question reinforced the idea of reading the whole question prompt. I have such a bad habit of reading the first sentence and then trying to solve immediately"
                    },
                    {
                        "username": "leetdaily11",
                        "content": "was just about to post this in discussion! Need to be patient!"
                    },
                    {
                        "username": "jknagin",
                        "content": "This should be a hard."
                    },
                    {
                        "username": "JoshuaMorris95",
                        "content": "Frustrating challenge as some test cases require the use of BigInt when solving in JavaScript."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yep, starts around case 72"
                    }
                ]
            },
            {
                "id": 1565320,
                "content": [
                    {
                        "username": "mayank17081998",
                        "content": "See these images, you will get every idea..![image](https://assets.leetcode.com/users/images/fd1dd3c6-d121-43f2-a4ce-8bf529f190bd_1645930387.2246904.png)\\n![image](https://assets.leetcode.com/users/images/3ef66bd5-c49f-4fe3-8fb8-da76ada7136d_1645930439.4141164.png)\\n![image](https://assets.leetcode.com/users/images/311933bc-6041-497e-9ff4-a9af99dd2aa2_1645930452.510014.png)\\n![image](https://assets.leetcode.com/users/images/f28cd784-ae35-4c75-9e9b-0668b1168e0b_1645930452.716098.png)\\n![image](https://assets.leetcode.com/users/images/33142dc2-f781-4403-b872-88b3eb4d792d_1645930458.9626606.png)\\n\\n\\nhttps://www.linkedin.com/posts/mayank-singh-1004981a4_maximum-width-of-binary-tree-ugcPost-6903531275865702400-t3f0\\n\\n\\n"
                    },
                    {
                        "username": "jotho_",
                        "content": "[@Hsiao-Chien-Ti](/Hsiao-Chien-Ti) I think because the maximum difference is guaranteed to fit in an int, then the max can never overflow twice before the min also overflows.  I used DFS as well"
                    },
                    {
                        "username": "Hsiao-Chien-Ti",
                        "content": "Hi [@Mayank Singh](/mayank17081998) Why won\\'t you get overflow by storing a long long type (long long)currentNo*2+1 into a int type pair in queue? I wrote a dfs version with similar concepts as yours, but I am suffering from overflow now. I print the currentNo of yours out, and found that there are some negative numbers, which I guess is overflow."
                    },
                    {
                        "username": "mohak_gaur",
                        "content": "Why have you written this line inside the for loop...\\nrightMostNodeNo = max(rightMostNodeNo, rootNode.first);\\n\\nyou can simply replace it with...\\nrightMostNodeNo = rootNode.first;\\n\\ni submitted with the above one and it was accepted."
                    },
                    {
                        "username": "pilaniya",
                        "content": "Maximum width of above test case should be 6 but expected output is 8. Or am I doing this wrong?"
                    },
                    {
                        "username": "rajveer_09",
                        "content": "You are doing \"SOMETHING\" wrong."
                    },
                    {
                        "username": "Anupkrpal",
                        "content": "it should be 8\\n"
                    },
                    {
                        "username": "amanchandna",
                        "content": "![image.png](https://assets.leetcode.com/users/images/bc506e3e-0ddf-48e9-9a3e-3d345bfb7ebe_1681964515.560179.png)"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Looks easy, but very tricky"
                    },
                    {
                        "username": "pokaChika",
                        "content": "Hint: If Parents index is n left child is 2*n and right child is 2*n+1. Think along these lines\\n"
                    },
                    {
                        "username": "sk4142",
                        "content": "Extremely good hint"
                    },
                    {
                        "username": "Sudhanshu145",
                        "content": "thanks\\n"
                    },
                    {
                        "username": "thephilosoft",
                        "content": "It is a good idea to test your solution with this input\\n\\n```\\n[-64,12,18,-4,-53,null,76,null,-51,null,null,-93,3,null,-31,47,null,3,53,-81,33,4,null,-51,-44,-60,11,null,null,null,null,78,null,-35,-64,26,-81,-31,27,60,74,null,null,8,-38,47,12,-24,null,-59,-49,-11,-51,67,null,null,null,null,null,null,null,-67,null,-37,-19,10,-55,72,null,null,null,-70,17,-4,null,null,null,null,null,null,null,3,80,44,-88,-91,null,48,-90,-30,null,null,90,-34,37,null,null,73,-38,-31,-85,-31,-96,null,null,-18,67,34,72,null,-17,-77,null,56,-65,-88,-53,null,null,null,-33,86,null,81,-42,null,null,98,-40,70,-26,24,null,null,null,null,92,72,-27,null,null,null,null,null,null,-67,null,null,null,null,null,null,null,-54,-66,-36,null,-72,null,null,43,null,null,null,-92,-1,-98,null,null,null,null,null,null,null,39,-84,null,null,null,null,null,null,null,null,null,null,null,null,null,-93,null,null,null,98]\\n```\\n\\nThe expected answer is `169`"
                    },
                    {
                        "username": "anwendeng",
                        "content": "C++ solution must use unsigned long long !!! Then every thing goes well.\n===============================\noverflow ! 72 / 114 testcases passed\nLine 19: Char 34: runtime error: signed integer overflow: 9223372036854775807 * 2 cannot be represented in type 'long long' (solution.cpp)\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:28:34\n===============================\n[0,0,0,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null]"
                    },
                    {
                        "username": "user4750s",
                        "content": "even long long works fine."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "It\\'s a life (streak) savior comment"
                    },
                    {
                        "username": "user5400vw",
                        "content": "this solution doesn\\'t use unsigned https://leetcode.com/problems/maximum-width-of-binary-tree/solutions/3436483/c-bfs-approach-with-explanation-simple-solution/"
                    },
                    {
                        "username": "andrew99154",
                        "content": "It\\'s helpful for C++ programmers, thanks a lot."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@cskrisz](/cskrisz)  64-bit unsigned int, I think!"
                    },
                    {
                        "username": "cskrisz",
                        "content": "The key is that it\\'s unsigned. You can use `unsigned int` too. `unsigned long long` still can\\'t represent all the indices, but it wraps around without undefined behavior, and then the subtraction works too."
                    },
                    {
                        "username": "anwendeng",
                        "content": "C++ solution must use unsigned long long https://leetcode.com/problems/maximum-width-of-binary-tree/solutions/3436610/dfs-c-solution-must-use-unsigned-long-long/"
                    },
                    {
                        "username": "jskat",
                        "content": "This question reinforced the idea of reading the whole question prompt. I have such a bad habit of reading the first sentence and then trying to solve immediately"
                    },
                    {
                        "username": "leetdaily11",
                        "content": "was just about to post this in discussion! Need to be patient!"
                    },
                    {
                        "username": "jknagin",
                        "content": "This should be a hard."
                    },
                    {
                        "username": "JoshuaMorris95",
                        "content": "Frustrating challenge as some test cases require the use of BigInt when solving in JavaScript."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yep, starts around case 72"
                    }
                ]
            },
            {
                "id": 1868940,
                "content": [
                    {
                        "username": "mayank17081998",
                        "content": "See these images, you will get every idea..![image](https://assets.leetcode.com/users/images/fd1dd3c6-d121-43f2-a4ce-8bf529f190bd_1645930387.2246904.png)\\n![image](https://assets.leetcode.com/users/images/3ef66bd5-c49f-4fe3-8fb8-da76ada7136d_1645930439.4141164.png)\\n![image](https://assets.leetcode.com/users/images/311933bc-6041-497e-9ff4-a9af99dd2aa2_1645930452.510014.png)\\n![image](https://assets.leetcode.com/users/images/f28cd784-ae35-4c75-9e9b-0668b1168e0b_1645930452.716098.png)\\n![image](https://assets.leetcode.com/users/images/33142dc2-f781-4403-b872-88b3eb4d792d_1645930458.9626606.png)\\n\\n\\nhttps://www.linkedin.com/posts/mayank-singh-1004981a4_maximum-width-of-binary-tree-ugcPost-6903531275865702400-t3f0\\n\\n\\n"
                    },
                    {
                        "username": "jotho_",
                        "content": "[@Hsiao-Chien-Ti](/Hsiao-Chien-Ti) I think because the maximum difference is guaranteed to fit in an int, then the max can never overflow twice before the min also overflows.  I used DFS as well"
                    },
                    {
                        "username": "Hsiao-Chien-Ti",
                        "content": "Hi [@Mayank Singh](/mayank17081998) Why won\\'t you get overflow by storing a long long type (long long)currentNo*2+1 into a int type pair in queue? I wrote a dfs version with similar concepts as yours, but I am suffering from overflow now. I print the currentNo of yours out, and found that there are some negative numbers, which I guess is overflow."
                    },
                    {
                        "username": "mohak_gaur",
                        "content": "Why have you written this line inside the for loop...\\nrightMostNodeNo = max(rightMostNodeNo, rootNode.first);\\n\\nyou can simply replace it with...\\nrightMostNodeNo = rootNode.first;\\n\\ni submitted with the above one and it was accepted."
                    },
                    {
                        "username": "pilaniya",
                        "content": "Maximum width of above test case should be 6 but expected output is 8. Or am I doing this wrong?"
                    },
                    {
                        "username": "rajveer_09",
                        "content": "You are doing \"SOMETHING\" wrong."
                    },
                    {
                        "username": "Anupkrpal",
                        "content": "it should be 8\\n"
                    },
                    {
                        "username": "amanchandna",
                        "content": "![image.png](https://assets.leetcode.com/users/images/bc506e3e-0ddf-48e9-9a3e-3d345bfb7ebe_1681964515.560179.png)"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Looks easy, but very tricky"
                    },
                    {
                        "username": "pokaChika",
                        "content": "Hint: If Parents index is n left child is 2*n and right child is 2*n+1. Think along these lines\\n"
                    },
                    {
                        "username": "sk4142",
                        "content": "Extremely good hint"
                    },
                    {
                        "username": "Sudhanshu145",
                        "content": "thanks\\n"
                    },
                    {
                        "username": "thephilosoft",
                        "content": "It is a good idea to test your solution with this input\\n\\n```\\n[-64,12,18,-4,-53,null,76,null,-51,null,null,-93,3,null,-31,47,null,3,53,-81,33,4,null,-51,-44,-60,11,null,null,null,null,78,null,-35,-64,26,-81,-31,27,60,74,null,null,8,-38,47,12,-24,null,-59,-49,-11,-51,67,null,null,null,null,null,null,null,-67,null,-37,-19,10,-55,72,null,null,null,-70,17,-4,null,null,null,null,null,null,null,3,80,44,-88,-91,null,48,-90,-30,null,null,90,-34,37,null,null,73,-38,-31,-85,-31,-96,null,null,-18,67,34,72,null,-17,-77,null,56,-65,-88,-53,null,null,null,-33,86,null,81,-42,null,null,98,-40,70,-26,24,null,null,null,null,92,72,-27,null,null,null,null,null,null,-67,null,null,null,null,null,null,null,-54,-66,-36,null,-72,null,null,43,null,null,null,-92,-1,-98,null,null,null,null,null,null,null,39,-84,null,null,null,null,null,null,null,null,null,null,null,null,null,-93,null,null,null,98]\\n```\\n\\nThe expected answer is `169`"
                    },
                    {
                        "username": "anwendeng",
                        "content": "C++ solution must use unsigned long long !!! Then every thing goes well.\n===============================\noverflow ! 72 / 114 testcases passed\nLine 19: Char 34: runtime error: signed integer overflow: 9223372036854775807 * 2 cannot be represented in type 'long long' (solution.cpp)\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:28:34\n===============================\n[0,0,0,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null]"
                    },
                    {
                        "username": "user4750s",
                        "content": "even long long works fine."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "It\\'s a life (streak) savior comment"
                    },
                    {
                        "username": "user5400vw",
                        "content": "this solution doesn\\'t use unsigned https://leetcode.com/problems/maximum-width-of-binary-tree/solutions/3436483/c-bfs-approach-with-explanation-simple-solution/"
                    },
                    {
                        "username": "andrew99154",
                        "content": "It\\'s helpful for C++ programmers, thanks a lot."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@cskrisz](/cskrisz)  64-bit unsigned int, I think!"
                    },
                    {
                        "username": "cskrisz",
                        "content": "The key is that it\\'s unsigned. You can use `unsigned int` too. `unsigned long long` still can\\'t represent all the indices, but it wraps around without undefined behavior, and then the subtraction works too."
                    },
                    {
                        "username": "anwendeng",
                        "content": "C++ solution must use unsigned long long https://leetcode.com/problems/maximum-width-of-binary-tree/solutions/3436610/dfs-c-solution-must-use-unsigned-long-long/"
                    },
                    {
                        "username": "jskat",
                        "content": "This question reinforced the idea of reading the whole question prompt. I have such a bad habit of reading the first sentence and then trying to solve immediately"
                    },
                    {
                        "username": "leetdaily11",
                        "content": "was just about to post this in discussion! Need to be patient!"
                    },
                    {
                        "username": "jknagin",
                        "content": "This should be a hard."
                    },
                    {
                        "username": "JoshuaMorris95",
                        "content": "Frustrating challenge as some test cases require the use of BigInt when solving in JavaScript."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yep, starts around case 72"
                    }
                ]
            },
            {
                "id": 1869064,
                "content": [
                    {
                        "username": "mayank17081998",
                        "content": "See these images, you will get every idea..![image](https://assets.leetcode.com/users/images/fd1dd3c6-d121-43f2-a4ce-8bf529f190bd_1645930387.2246904.png)\\n![image](https://assets.leetcode.com/users/images/3ef66bd5-c49f-4fe3-8fb8-da76ada7136d_1645930439.4141164.png)\\n![image](https://assets.leetcode.com/users/images/311933bc-6041-497e-9ff4-a9af99dd2aa2_1645930452.510014.png)\\n![image](https://assets.leetcode.com/users/images/f28cd784-ae35-4c75-9e9b-0668b1168e0b_1645930452.716098.png)\\n![image](https://assets.leetcode.com/users/images/33142dc2-f781-4403-b872-88b3eb4d792d_1645930458.9626606.png)\\n\\n\\nhttps://www.linkedin.com/posts/mayank-singh-1004981a4_maximum-width-of-binary-tree-ugcPost-6903531275865702400-t3f0\\n\\n\\n"
                    },
                    {
                        "username": "jotho_",
                        "content": "[@Hsiao-Chien-Ti](/Hsiao-Chien-Ti) I think because the maximum difference is guaranteed to fit in an int, then the max can never overflow twice before the min also overflows.  I used DFS as well"
                    },
                    {
                        "username": "Hsiao-Chien-Ti",
                        "content": "Hi [@Mayank Singh](/mayank17081998) Why won\\'t you get overflow by storing a long long type (long long)currentNo*2+1 into a int type pair in queue? I wrote a dfs version with similar concepts as yours, but I am suffering from overflow now. I print the currentNo of yours out, and found that there are some negative numbers, which I guess is overflow."
                    },
                    {
                        "username": "mohak_gaur",
                        "content": "Why have you written this line inside the for loop...\\nrightMostNodeNo = max(rightMostNodeNo, rootNode.first);\\n\\nyou can simply replace it with...\\nrightMostNodeNo = rootNode.first;\\n\\ni submitted with the above one and it was accepted."
                    },
                    {
                        "username": "pilaniya",
                        "content": "Maximum width of above test case should be 6 but expected output is 8. Or am I doing this wrong?"
                    },
                    {
                        "username": "rajveer_09",
                        "content": "You are doing \"SOMETHING\" wrong."
                    },
                    {
                        "username": "Anupkrpal",
                        "content": "it should be 8\\n"
                    },
                    {
                        "username": "amanchandna",
                        "content": "![image.png](https://assets.leetcode.com/users/images/bc506e3e-0ddf-48e9-9a3e-3d345bfb7ebe_1681964515.560179.png)"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Looks easy, but very tricky"
                    },
                    {
                        "username": "pokaChika",
                        "content": "Hint: If Parents index is n left child is 2*n and right child is 2*n+1. Think along these lines\\n"
                    },
                    {
                        "username": "sk4142",
                        "content": "Extremely good hint"
                    },
                    {
                        "username": "Sudhanshu145",
                        "content": "thanks\\n"
                    },
                    {
                        "username": "thephilosoft",
                        "content": "It is a good idea to test your solution with this input\\n\\n```\\n[-64,12,18,-4,-53,null,76,null,-51,null,null,-93,3,null,-31,47,null,3,53,-81,33,4,null,-51,-44,-60,11,null,null,null,null,78,null,-35,-64,26,-81,-31,27,60,74,null,null,8,-38,47,12,-24,null,-59,-49,-11,-51,67,null,null,null,null,null,null,null,-67,null,-37,-19,10,-55,72,null,null,null,-70,17,-4,null,null,null,null,null,null,null,3,80,44,-88,-91,null,48,-90,-30,null,null,90,-34,37,null,null,73,-38,-31,-85,-31,-96,null,null,-18,67,34,72,null,-17,-77,null,56,-65,-88,-53,null,null,null,-33,86,null,81,-42,null,null,98,-40,70,-26,24,null,null,null,null,92,72,-27,null,null,null,null,null,null,-67,null,null,null,null,null,null,null,-54,-66,-36,null,-72,null,null,43,null,null,null,-92,-1,-98,null,null,null,null,null,null,null,39,-84,null,null,null,null,null,null,null,null,null,null,null,null,null,-93,null,null,null,98]\\n```\\n\\nThe expected answer is `169`"
                    },
                    {
                        "username": "anwendeng",
                        "content": "C++ solution must use unsigned long long !!! Then every thing goes well.\n===============================\noverflow ! 72 / 114 testcases passed\nLine 19: Char 34: runtime error: signed integer overflow: 9223372036854775807 * 2 cannot be represented in type 'long long' (solution.cpp)\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:28:34\n===============================\n[0,0,0,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null]"
                    },
                    {
                        "username": "user4750s",
                        "content": "even long long works fine."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "It\\'s a life (streak) savior comment"
                    },
                    {
                        "username": "user5400vw",
                        "content": "this solution doesn\\'t use unsigned https://leetcode.com/problems/maximum-width-of-binary-tree/solutions/3436483/c-bfs-approach-with-explanation-simple-solution/"
                    },
                    {
                        "username": "andrew99154",
                        "content": "It\\'s helpful for C++ programmers, thanks a lot."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@cskrisz](/cskrisz)  64-bit unsigned int, I think!"
                    },
                    {
                        "username": "cskrisz",
                        "content": "The key is that it\\'s unsigned. You can use `unsigned int` too. `unsigned long long` still can\\'t represent all the indices, but it wraps around without undefined behavior, and then the subtraction works too."
                    },
                    {
                        "username": "anwendeng",
                        "content": "C++ solution must use unsigned long long https://leetcode.com/problems/maximum-width-of-binary-tree/solutions/3436610/dfs-c-solution-must-use-unsigned-long-long/"
                    },
                    {
                        "username": "jskat",
                        "content": "This question reinforced the idea of reading the whole question prompt. I have such a bad habit of reading the first sentence and then trying to solve immediately"
                    },
                    {
                        "username": "leetdaily11",
                        "content": "was just about to post this in discussion! Need to be patient!"
                    },
                    {
                        "username": "jknagin",
                        "content": "This should be a hard."
                    },
                    {
                        "username": "JoshuaMorris95",
                        "content": "Frustrating challenge as some test cases require the use of BigInt when solving in JavaScript."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yep, starts around case 72"
                    }
                ]
            },
            {
                "id": 1869005,
                "content": [
                    {
                        "username": "mayank17081998",
                        "content": "See these images, you will get every idea..![image](https://assets.leetcode.com/users/images/fd1dd3c6-d121-43f2-a4ce-8bf529f190bd_1645930387.2246904.png)\\n![image](https://assets.leetcode.com/users/images/3ef66bd5-c49f-4fe3-8fb8-da76ada7136d_1645930439.4141164.png)\\n![image](https://assets.leetcode.com/users/images/311933bc-6041-497e-9ff4-a9af99dd2aa2_1645930452.510014.png)\\n![image](https://assets.leetcode.com/users/images/f28cd784-ae35-4c75-9e9b-0668b1168e0b_1645930452.716098.png)\\n![image](https://assets.leetcode.com/users/images/33142dc2-f781-4403-b872-88b3eb4d792d_1645930458.9626606.png)\\n\\n\\nhttps://www.linkedin.com/posts/mayank-singh-1004981a4_maximum-width-of-binary-tree-ugcPost-6903531275865702400-t3f0\\n\\n\\n"
                    },
                    {
                        "username": "jotho_",
                        "content": "[@Hsiao-Chien-Ti](/Hsiao-Chien-Ti) I think because the maximum difference is guaranteed to fit in an int, then the max can never overflow twice before the min also overflows.  I used DFS as well"
                    },
                    {
                        "username": "Hsiao-Chien-Ti",
                        "content": "Hi [@Mayank Singh](/mayank17081998) Why won\\'t you get overflow by storing a long long type (long long)currentNo*2+1 into a int type pair in queue? I wrote a dfs version with similar concepts as yours, but I am suffering from overflow now. I print the currentNo of yours out, and found that there are some negative numbers, which I guess is overflow."
                    },
                    {
                        "username": "mohak_gaur",
                        "content": "Why have you written this line inside the for loop...\\nrightMostNodeNo = max(rightMostNodeNo, rootNode.first);\\n\\nyou can simply replace it with...\\nrightMostNodeNo = rootNode.first;\\n\\ni submitted with the above one and it was accepted."
                    },
                    {
                        "username": "pilaniya",
                        "content": "Maximum width of above test case should be 6 but expected output is 8. Or am I doing this wrong?"
                    },
                    {
                        "username": "rajveer_09",
                        "content": "You are doing \"SOMETHING\" wrong."
                    },
                    {
                        "username": "Anupkrpal",
                        "content": "it should be 8\\n"
                    },
                    {
                        "username": "amanchandna",
                        "content": "![image.png](https://assets.leetcode.com/users/images/bc506e3e-0ddf-48e9-9a3e-3d345bfb7ebe_1681964515.560179.png)"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Looks easy, but very tricky"
                    },
                    {
                        "username": "pokaChika",
                        "content": "Hint: If Parents index is n left child is 2*n and right child is 2*n+1. Think along these lines\\n"
                    },
                    {
                        "username": "sk4142",
                        "content": "Extremely good hint"
                    },
                    {
                        "username": "Sudhanshu145",
                        "content": "thanks\\n"
                    },
                    {
                        "username": "thephilosoft",
                        "content": "It is a good idea to test your solution with this input\\n\\n```\\n[-64,12,18,-4,-53,null,76,null,-51,null,null,-93,3,null,-31,47,null,3,53,-81,33,4,null,-51,-44,-60,11,null,null,null,null,78,null,-35,-64,26,-81,-31,27,60,74,null,null,8,-38,47,12,-24,null,-59,-49,-11,-51,67,null,null,null,null,null,null,null,-67,null,-37,-19,10,-55,72,null,null,null,-70,17,-4,null,null,null,null,null,null,null,3,80,44,-88,-91,null,48,-90,-30,null,null,90,-34,37,null,null,73,-38,-31,-85,-31,-96,null,null,-18,67,34,72,null,-17,-77,null,56,-65,-88,-53,null,null,null,-33,86,null,81,-42,null,null,98,-40,70,-26,24,null,null,null,null,92,72,-27,null,null,null,null,null,null,-67,null,null,null,null,null,null,null,-54,-66,-36,null,-72,null,null,43,null,null,null,-92,-1,-98,null,null,null,null,null,null,null,39,-84,null,null,null,null,null,null,null,null,null,null,null,null,null,-93,null,null,null,98]\\n```\\n\\nThe expected answer is `169`"
                    },
                    {
                        "username": "anwendeng",
                        "content": "C++ solution must use unsigned long long !!! Then every thing goes well.\n===============================\noverflow ! 72 / 114 testcases passed\nLine 19: Char 34: runtime error: signed integer overflow: 9223372036854775807 * 2 cannot be represented in type 'long long' (solution.cpp)\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:28:34\n===============================\n[0,0,0,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null]"
                    },
                    {
                        "username": "user4750s",
                        "content": "even long long works fine."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "It\\'s a life (streak) savior comment"
                    },
                    {
                        "username": "user5400vw",
                        "content": "this solution doesn\\'t use unsigned https://leetcode.com/problems/maximum-width-of-binary-tree/solutions/3436483/c-bfs-approach-with-explanation-simple-solution/"
                    },
                    {
                        "username": "andrew99154",
                        "content": "It\\'s helpful for C++ programmers, thanks a lot."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@cskrisz](/cskrisz)  64-bit unsigned int, I think!"
                    },
                    {
                        "username": "cskrisz",
                        "content": "The key is that it\\'s unsigned. You can use `unsigned int` too. `unsigned long long` still can\\'t represent all the indices, but it wraps around without undefined behavior, and then the subtraction works too."
                    },
                    {
                        "username": "anwendeng",
                        "content": "C++ solution must use unsigned long long https://leetcode.com/problems/maximum-width-of-binary-tree/solutions/3436610/dfs-c-solution-must-use-unsigned-long-long/"
                    },
                    {
                        "username": "jskat",
                        "content": "This question reinforced the idea of reading the whole question prompt. I have such a bad habit of reading the first sentence and then trying to solve immediately"
                    },
                    {
                        "username": "leetdaily11",
                        "content": "was just about to post this in discussion! Need to be patient!"
                    },
                    {
                        "username": "jknagin",
                        "content": "This should be a hard."
                    },
                    {
                        "username": "JoshuaMorris95",
                        "content": "Frustrating challenge as some test cases require the use of BigInt when solving in JavaScript."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yep, starts around case 72"
                    }
                ]
            },
            {
                "id": 1868877,
                "content": [
                    {
                        "username": "mayank17081998",
                        "content": "See these images, you will get every idea..![image](https://assets.leetcode.com/users/images/fd1dd3c6-d121-43f2-a4ce-8bf529f190bd_1645930387.2246904.png)\\n![image](https://assets.leetcode.com/users/images/3ef66bd5-c49f-4fe3-8fb8-da76ada7136d_1645930439.4141164.png)\\n![image](https://assets.leetcode.com/users/images/311933bc-6041-497e-9ff4-a9af99dd2aa2_1645930452.510014.png)\\n![image](https://assets.leetcode.com/users/images/f28cd784-ae35-4c75-9e9b-0668b1168e0b_1645930452.716098.png)\\n![image](https://assets.leetcode.com/users/images/33142dc2-f781-4403-b872-88b3eb4d792d_1645930458.9626606.png)\\n\\n\\nhttps://www.linkedin.com/posts/mayank-singh-1004981a4_maximum-width-of-binary-tree-ugcPost-6903531275865702400-t3f0\\n\\n\\n"
                    },
                    {
                        "username": "jotho_",
                        "content": "[@Hsiao-Chien-Ti](/Hsiao-Chien-Ti) I think because the maximum difference is guaranteed to fit in an int, then the max can never overflow twice before the min also overflows.  I used DFS as well"
                    },
                    {
                        "username": "Hsiao-Chien-Ti",
                        "content": "Hi [@Mayank Singh](/mayank17081998) Why won\\'t you get overflow by storing a long long type (long long)currentNo*2+1 into a int type pair in queue? I wrote a dfs version with similar concepts as yours, but I am suffering from overflow now. I print the currentNo of yours out, and found that there are some negative numbers, which I guess is overflow."
                    },
                    {
                        "username": "mohak_gaur",
                        "content": "Why have you written this line inside the for loop...\\nrightMostNodeNo = max(rightMostNodeNo, rootNode.first);\\n\\nyou can simply replace it with...\\nrightMostNodeNo = rootNode.first;\\n\\ni submitted with the above one and it was accepted."
                    },
                    {
                        "username": "pilaniya",
                        "content": "Maximum width of above test case should be 6 but expected output is 8. Or am I doing this wrong?"
                    },
                    {
                        "username": "rajveer_09",
                        "content": "You are doing \"SOMETHING\" wrong."
                    },
                    {
                        "username": "Anupkrpal",
                        "content": "it should be 8\\n"
                    },
                    {
                        "username": "amanchandna",
                        "content": "![image.png](https://assets.leetcode.com/users/images/bc506e3e-0ddf-48e9-9a3e-3d345bfb7ebe_1681964515.560179.png)"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Looks easy, but very tricky"
                    },
                    {
                        "username": "pokaChika",
                        "content": "Hint: If Parents index is n left child is 2*n and right child is 2*n+1. Think along these lines\\n"
                    },
                    {
                        "username": "sk4142",
                        "content": "Extremely good hint"
                    },
                    {
                        "username": "Sudhanshu145",
                        "content": "thanks\\n"
                    },
                    {
                        "username": "thephilosoft",
                        "content": "It is a good idea to test your solution with this input\\n\\n```\\n[-64,12,18,-4,-53,null,76,null,-51,null,null,-93,3,null,-31,47,null,3,53,-81,33,4,null,-51,-44,-60,11,null,null,null,null,78,null,-35,-64,26,-81,-31,27,60,74,null,null,8,-38,47,12,-24,null,-59,-49,-11,-51,67,null,null,null,null,null,null,null,-67,null,-37,-19,10,-55,72,null,null,null,-70,17,-4,null,null,null,null,null,null,null,3,80,44,-88,-91,null,48,-90,-30,null,null,90,-34,37,null,null,73,-38,-31,-85,-31,-96,null,null,-18,67,34,72,null,-17,-77,null,56,-65,-88,-53,null,null,null,-33,86,null,81,-42,null,null,98,-40,70,-26,24,null,null,null,null,92,72,-27,null,null,null,null,null,null,-67,null,null,null,null,null,null,null,-54,-66,-36,null,-72,null,null,43,null,null,null,-92,-1,-98,null,null,null,null,null,null,null,39,-84,null,null,null,null,null,null,null,null,null,null,null,null,null,-93,null,null,null,98]\\n```\\n\\nThe expected answer is `169`"
                    },
                    {
                        "username": "anwendeng",
                        "content": "C++ solution must use unsigned long long !!! Then every thing goes well.\n===============================\noverflow ! 72 / 114 testcases passed\nLine 19: Char 34: runtime error: signed integer overflow: 9223372036854775807 * 2 cannot be represented in type 'long long' (solution.cpp)\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:28:34\n===============================\n[0,0,0,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null]"
                    },
                    {
                        "username": "user4750s",
                        "content": "even long long works fine."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "It\\'s a life (streak) savior comment"
                    },
                    {
                        "username": "user5400vw",
                        "content": "this solution doesn\\'t use unsigned https://leetcode.com/problems/maximum-width-of-binary-tree/solutions/3436483/c-bfs-approach-with-explanation-simple-solution/"
                    },
                    {
                        "username": "andrew99154",
                        "content": "It\\'s helpful for C++ programmers, thanks a lot."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@cskrisz](/cskrisz)  64-bit unsigned int, I think!"
                    },
                    {
                        "username": "cskrisz",
                        "content": "The key is that it\\'s unsigned. You can use `unsigned int` too. `unsigned long long` still can\\'t represent all the indices, but it wraps around without undefined behavior, and then the subtraction works too."
                    },
                    {
                        "username": "anwendeng",
                        "content": "C++ solution must use unsigned long long https://leetcode.com/problems/maximum-width-of-binary-tree/solutions/3436610/dfs-c-solution-must-use-unsigned-long-long/"
                    },
                    {
                        "username": "jskat",
                        "content": "This question reinforced the idea of reading the whole question prompt. I have such a bad habit of reading the first sentence and then trying to solve immediately"
                    },
                    {
                        "username": "leetdaily11",
                        "content": "was just about to post this in discussion! Need to be patient!"
                    },
                    {
                        "username": "jknagin",
                        "content": "This should be a hard."
                    },
                    {
                        "username": "JoshuaMorris95",
                        "content": "Frustrating challenge as some test cases require the use of BigInt when solving in JavaScript."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yep, starts around case 72"
                    }
                ]
            },
            {
                "id": 1868851,
                "content": [
                    {
                        "username": "mayank17081998",
                        "content": "See these images, you will get every idea..![image](https://assets.leetcode.com/users/images/fd1dd3c6-d121-43f2-a4ce-8bf529f190bd_1645930387.2246904.png)\\n![image](https://assets.leetcode.com/users/images/3ef66bd5-c49f-4fe3-8fb8-da76ada7136d_1645930439.4141164.png)\\n![image](https://assets.leetcode.com/users/images/311933bc-6041-497e-9ff4-a9af99dd2aa2_1645930452.510014.png)\\n![image](https://assets.leetcode.com/users/images/f28cd784-ae35-4c75-9e9b-0668b1168e0b_1645930452.716098.png)\\n![image](https://assets.leetcode.com/users/images/33142dc2-f781-4403-b872-88b3eb4d792d_1645930458.9626606.png)\\n\\n\\nhttps://www.linkedin.com/posts/mayank-singh-1004981a4_maximum-width-of-binary-tree-ugcPost-6903531275865702400-t3f0\\n\\n\\n"
                    },
                    {
                        "username": "jotho_",
                        "content": "[@Hsiao-Chien-Ti](/Hsiao-Chien-Ti) I think because the maximum difference is guaranteed to fit in an int, then the max can never overflow twice before the min also overflows.  I used DFS as well"
                    },
                    {
                        "username": "Hsiao-Chien-Ti",
                        "content": "Hi [@Mayank Singh](/mayank17081998) Why won\\'t you get overflow by storing a long long type (long long)currentNo*2+1 into a int type pair in queue? I wrote a dfs version with similar concepts as yours, but I am suffering from overflow now. I print the currentNo of yours out, and found that there are some negative numbers, which I guess is overflow."
                    },
                    {
                        "username": "mohak_gaur",
                        "content": "Why have you written this line inside the for loop...\\nrightMostNodeNo = max(rightMostNodeNo, rootNode.first);\\n\\nyou can simply replace it with...\\nrightMostNodeNo = rootNode.first;\\n\\ni submitted with the above one and it was accepted."
                    },
                    {
                        "username": "pilaniya",
                        "content": "Maximum width of above test case should be 6 but expected output is 8. Or am I doing this wrong?"
                    },
                    {
                        "username": "rajveer_09",
                        "content": "You are doing \"SOMETHING\" wrong."
                    },
                    {
                        "username": "Anupkrpal",
                        "content": "it should be 8\\n"
                    },
                    {
                        "username": "amanchandna",
                        "content": "![image.png](https://assets.leetcode.com/users/images/bc506e3e-0ddf-48e9-9a3e-3d345bfb7ebe_1681964515.560179.png)"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Looks easy, but very tricky"
                    },
                    {
                        "username": "pokaChika",
                        "content": "Hint: If Parents index is n left child is 2*n and right child is 2*n+1. Think along these lines\\n"
                    },
                    {
                        "username": "sk4142",
                        "content": "Extremely good hint"
                    },
                    {
                        "username": "Sudhanshu145",
                        "content": "thanks\\n"
                    },
                    {
                        "username": "thephilosoft",
                        "content": "It is a good idea to test your solution with this input\\n\\n```\\n[-64,12,18,-4,-53,null,76,null,-51,null,null,-93,3,null,-31,47,null,3,53,-81,33,4,null,-51,-44,-60,11,null,null,null,null,78,null,-35,-64,26,-81,-31,27,60,74,null,null,8,-38,47,12,-24,null,-59,-49,-11,-51,67,null,null,null,null,null,null,null,-67,null,-37,-19,10,-55,72,null,null,null,-70,17,-4,null,null,null,null,null,null,null,3,80,44,-88,-91,null,48,-90,-30,null,null,90,-34,37,null,null,73,-38,-31,-85,-31,-96,null,null,-18,67,34,72,null,-17,-77,null,56,-65,-88,-53,null,null,null,-33,86,null,81,-42,null,null,98,-40,70,-26,24,null,null,null,null,92,72,-27,null,null,null,null,null,null,-67,null,null,null,null,null,null,null,-54,-66,-36,null,-72,null,null,43,null,null,null,-92,-1,-98,null,null,null,null,null,null,null,39,-84,null,null,null,null,null,null,null,null,null,null,null,null,null,-93,null,null,null,98]\\n```\\n\\nThe expected answer is `169`"
                    },
                    {
                        "username": "anwendeng",
                        "content": "C++ solution must use unsigned long long !!! Then every thing goes well.\n===============================\noverflow ! 72 / 114 testcases passed\nLine 19: Char 34: runtime error: signed integer overflow: 9223372036854775807 * 2 cannot be represented in type 'long long' (solution.cpp)\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:28:34\n===============================\n[0,0,0,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null]"
                    },
                    {
                        "username": "user4750s",
                        "content": "even long long works fine."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "It\\'s a life (streak) savior comment"
                    },
                    {
                        "username": "user5400vw",
                        "content": "this solution doesn\\'t use unsigned https://leetcode.com/problems/maximum-width-of-binary-tree/solutions/3436483/c-bfs-approach-with-explanation-simple-solution/"
                    },
                    {
                        "username": "andrew99154",
                        "content": "It\\'s helpful for C++ programmers, thanks a lot."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@cskrisz](/cskrisz)  64-bit unsigned int, I think!"
                    },
                    {
                        "username": "cskrisz",
                        "content": "The key is that it\\'s unsigned. You can use `unsigned int` too. `unsigned long long` still can\\'t represent all the indices, but it wraps around without undefined behavior, and then the subtraction works too."
                    },
                    {
                        "username": "anwendeng",
                        "content": "C++ solution must use unsigned long long https://leetcode.com/problems/maximum-width-of-binary-tree/solutions/3436610/dfs-c-solution-must-use-unsigned-long-long/"
                    },
                    {
                        "username": "jskat",
                        "content": "This question reinforced the idea of reading the whole question prompt. I have such a bad habit of reading the first sentence and then trying to solve immediately"
                    },
                    {
                        "username": "leetdaily11",
                        "content": "was just about to post this in discussion! Need to be patient!"
                    },
                    {
                        "username": "jknagin",
                        "content": "This should be a hard."
                    },
                    {
                        "username": "JoshuaMorris95",
                        "content": "Frustrating challenge as some test cases require the use of BigInt when solving in JavaScript."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yep, starts around case 72"
                    }
                ]
            },
            {
                "id": 1868994,
                "content": [
                    {
                        "username": "mayank17081998",
                        "content": "See these images, you will get every idea..![image](https://assets.leetcode.com/users/images/fd1dd3c6-d121-43f2-a4ce-8bf529f190bd_1645930387.2246904.png)\\n![image](https://assets.leetcode.com/users/images/3ef66bd5-c49f-4fe3-8fb8-da76ada7136d_1645930439.4141164.png)\\n![image](https://assets.leetcode.com/users/images/311933bc-6041-497e-9ff4-a9af99dd2aa2_1645930452.510014.png)\\n![image](https://assets.leetcode.com/users/images/f28cd784-ae35-4c75-9e9b-0668b1168e0b_1645930452.716098.png)\\n![image](https://assets.leetcode.com/users/images/33142dc2-f781-4403-b872-88b3eb4d792d_1645930458.9626606.png)\\n\\n\\nhttps://www.linkedin.com/posts/mayank-singh-1004981a4_maximum-width-of-binary-tree-ugcPost-6903531275865702400-t3f0\\n\\n\\n"
                    },
                    {
                        "username": "jotho_",
                        "content": "[@Hsiao-Chien-Ti](/Hsiao-Chien-Ti) I think because the maximum difference is guaranteed to fit in an int, then the max can never overflow twice before the min also overflows.  I used DFS as well"
                    },
                    {
                        "username": "Hsiao-Chien-Ti",
                        "content": "Hi [@Mayank Singh](/mayank17081998) Why won\\'t you get overflow by storing a long long type (long long)currentNo*2+1 into a int type pair in queue? I wrote a dfs version with similar concepts as yours, but I am suffering from overflow now. I print the currentNo of yours out, and found that there are some negative numbers, which I guess is overflow."
                    },
                    {
                        "username": "mohak_gaur",
                        "content": "Why have you written this line inside the for loop...\\nrightMostNodeNo = max(rightMostNodeNo, rootNode.first);\\n\\nyou can simply replace it with...\\nrightMostNodeNo = rootNode.first;\\n\\ni submitted with the above one and it was accepted."
                    },
                    {
                        "username": "pilaniya",
                        "content": "Maximum width of above test case should be 6 but expected output is 8. Or am I doing this wrong?"
                    },
                    {
                        "username": "rajveer_09",
                        "content": "You are doing \"SOMETHING\" wrong."
                    },
                    {
                        "username": "Anupkrpal",
                        "content": "it should be 8\\n"
                    },
                    {
                        "username": "amanchandna",
                        "content": "![image.png](https://assets.leetcode.com/users/images/bc506e3e-0ddf-48e9-9a3e-3d345bfb7ebe_1681964515.560179.png)"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Looks easy, but very tricky"
                    },
                    {
                        "username": "pokaChika",
                        "content": "Hint: If Parents index is n left child is 2*n and right child is 2*n+1. Think along these lines\\n"
                    },
                    {
                        "username": "sk4142",
                        "content": "Extremely good hint"
                    },
                    {
                        "username": "Sudhanshu145",
                        "content": "thanks\\n"
                    },
                    {
                        "username": "thephilosoft",
                        "content": "It is a good idea to test your solution with this input\\n\\n```\\n[-64,12,18,-4,-53,null,76,null,-51,null,null,-93,3,null,-31,47,null,3,53,-81,33,4,null,-51,-44,-60,11,null,null,null,null,78,null,-35,-64,26,-81,-31,27,60,74,null,null,8,-38,47,12,-24,null,-59,-49,-11,-51,67,null,null,null,null,null,null,null,-67,null,-37,-19,10,-55,72,null,null,null,-70,17,-4,null,null,null,null,null,null,null,3,80,44,-88,-91,null,48,-90,-30,null,null,90,-34,37,null,null,73,-38,-31,-85,-31,-96,null,null,-18,67,34,72,null,-17,-77,null,56,-65,-88,-53,null,null,null,-33,86,null,81,-42,null,null,98,-40,70,-26,24,null,null,null,null,92,72,-27,null,null,null,null,null,null,-67,null,null,null,null,null,null,null,-54,-66,-36,null,-72,null,null,43,null,null,null,-92,-1,-98,null,null,null,null,null,null,null,39,-84,null,null,null,null,null,null,null,null,null,null,null,null,null,-93,null,null,null,98]\\n```\\n\\nThe expected answer is `169`"
                    },
                    {
                        "username": "anwendeng",
                        "content": "C++ solution must use unsigned long long !!! Then every thing goes well.\n===============================\noverflow ! 72 / 114 testcases passed\nLine 19: Char 34: runtime error: signed integer overflow: 9223372036854775807 * 2 cannot be represented in type 'long long' (solution.cpp)\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:28:34\n===============================\n[0,0,0,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null]"
                    },
                    {
                        "username": "user4750s",
                        "content": "even long long works fine."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "It\\'s a life (streak) savior comment"
                    },
                    {
                        "username": "user5400vw",
                        "content": "this solution doesn\\'t use unsigned https://leetcode.com/problems/maximum-width-of-binary-tree/solutions/3436483/c-bfs-approach-with-explanation-simple-solution/"
                    },
                    {
                        "username": "andrew99154",
                        "content": "It\\'s helpful for C++ programmers, thanks a lot."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@cskrisz](/cskrisz)  64-bit unsigned int, I think!"
                    },
                    {
                        "username": "cskrisz",
                        "content": "The key is that it\\'s unsigned. You can use `unsigned int` too. `unsigned long long` still can\\'t represent all the indices, but it wraps around without undefined behavior, and then the subtraction works too."
                    },
                    {
                        "username": "anwendeng",
                        "content": "C++ solution must use unsigned long long https://leetcode.com/problems/maximum-width-of-binary-tree/solutions/3436610/dfs-c-solution-must-use-unsigned-long-long/"
                    },
                    {
                        "username": "jskat",
                        "content": "This question reinforced the idea of reading the whole question prompt. I have such a bad habit of reading the first sentence and then trying to solve immediately"
                    },
                    {
                        "username": "leetdaily11",
                        "content": "was just about to post this in discussion! Need to be patient!"
                    },
                    {
                        "username": "jknagin",
                        "content": "This should be a hard."
                    },
                    {
                        "username": "JoshuaMorris95",
                        "content": "Frustrating challenge as some test cases require the use of BigInt when solving in JavaScript."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yep, starts around case 72"
                    }
                ]
            },
            {
                "id": 1770040,
                "content": [
                    {
                        "username": "mayank17081998",
                        "content": "See these images, you will get every idea..![image](https://assets.leetcode.com/users/images/fd1dd3c6-d121-43f2-a4ce-8bf529f190bd_1645930387.2246904.png)\\n![image](https://assets.leetcode.com/users/images/3ef66bd5-c49f-4fe3-8fb8-da76ada7136d_1645930439.4141164.png)\\n![image](https://assets.leetcode.com/users/images/311933bc-6041-497e-9ff4-a9af99dd2aa2_1645930452.510014.png)\\n![image](https://assets.leetcode.com/users/images/f28cd784-ae35-4c75-9e9b-0668b1168e0b_1645930452.716098.png)\\n![image](https://assets.leetcode.com/users/images/33142dc2-f781-4403-b872-88b3eb4d792d_1645930458.9626606.png)\\n\\n\\nhttps://www.linkedin.com/posts/mayank-singh-1004981a4_maximum-width-of-binary-tree-ugcPost-6903531275865702400-t3f0\\n\\n\\n"
                    },
                    {
                        "username": "jotho_",
                        "content": "[@Hsiao-Chien-Ti](/Hsiao-Chien-Ti) I think because the maximum difference is guaranteed to fit in an int, then the max can never overflow twice before the min also overflows.  I used DFS as well"
                    },
                    {
                        "username": "Hsiao-Chien-Ti",
                        "content": "Hi [@Mayank Singh](/mayank17081998) Why won\\'t you get overflow by storing a long long type (long long)currentNo*2+1 into a int type pair in queue? I wrote a dfs version with similar concepts as yours, but I am suffering from overflow now. I print the currentNo of yours out, and found that there are some negative numbers, which I guess is overflow."
                    },
                    {
                        "username": "mohak_gaur",
                        "content": "Why have you written this line inside the for loop...\\nrightMostNodeNo = max(rightMostNodeNo, rootNode.first);\\n\\nyou can simply replace it with...\\nrightMostNodeNo = rootNode.first;\\n\\ni submitted with the above one and it was accepted."
                    },
                    {
                        "username": "pilaniya",
                        "content": "Maximum width of above test case should be 6 but expected output is 8. Or am I doing this wrong?"
                    },
                    {
                        "username": "rajveer_09",
                        "content": "You are doing \"SOMETHING\" wrong."
                    },
                    {
                        "username": "Anupkrpal",
                        "content": "it should be 8\\n"
                    },
                    {
                        "username": "amanchandna",
                        "content": "![image.png](https://assets.leetcode.com/users/images/bc506e3e-0ddf-48e9-9a3e-3d345bfb7ebe_1681964515.560179.png)"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Looks easy, but very tricky"
                    },
                    {
                        "username": "pokaChika",
                        "content": "Hint: If Parents index is n left child is 2*n and right child is 2*n+1. Think along these lines\\n"
                    },
                    {
                        "username": "sk4142",
                        "content": "Extremely good hint"
                    },
                    {
                        "username": "Sudhanshu145",
                        "content": "thanks\\n"
                    },
                    {
                        "username": "thephilosoft",
                        "content": "It is a good idea to test your solution with this input\\n\\n```\\n[-64,12,18,-4,-53,null,76,null,-51,null,null,-93,3,null,-31,47,null,3,53,-81,33,4,null,-51,-44,-60,11,null,null,null,null,78,null,-35,-64,26,-81,-31,27,60,74,null,null,8,-38,47,12,-24,null,-59,-49,-11,-51,67,null,null,null,null,null,null,null,-67,null,-37,-19,10,-55,72,null,null,null,-70,17,-4,null,null,null,null,null,null,null,3,80,44,-88,-91,null,48,-90,-30,null,null,90,-34,37,null,null,73,-38,-31,-85,-31,-96,null,null,-18,67,34,72,null,-17,-77,null,56,-65,-88,-53,null,null,null,-33,86,null,81,-42,null,null,98,-40,70,-26,24,null,null,null,null,92,72,-27,null,null,null,null,null,null,-67,null,null,null,null,null,null,null,-54,-66,-36,null,-72,null,null,43,null,null,null,-92,-1,-98,null,null,null,null,null,null,null,39,-84,null,null,null,null,null,null,null,null,null,null,null,null,null,-93,null,null,null,98]\\n```\\n\\nThe expected answer is `169`"
                    },
                    {
                        "username": "anwendeng",
                        "content": "C++ solution must use unsigned long long !!! Then every thing goes well.\n===============================\noverflow ! 72 / 114 testcases passed\nLine 19: Char 34: runtime error: signed integer overflow: 9223372036854775807 * 2 cannot be represented in type 'long long' (solution.cpp)\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:28:34\n===============================\n[0,0,0,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null]"
                    },
                    {
                        "username": "user4750s",
                        "content": "even long long works fine."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "It\\'s a life (streak) savior comment"
                    },
                    {
                        "username": "user5400vw",
                        "content": "this solution doesn\\'t use unsigned https://leetcode.com/problems/maximum-width-of-binary-tree/solutions/3436483/c-bfs-approach-with-explanation-simple-solution/"
                    },
                    {
                        "username": "andrew99154",
                        "content": "It\\'s helpful for C++ programmers, thanks a lot."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@cskrisz](/cskrisz)  64-bit unsigned int, I think!"
                    },
                    {
                        "username": "cskrisz",
                        "content": "The key is that it\\'s unsigned. You can use `unsigned int` too. `unsigned long long` still can\\'t represent all the indices, but it wraps around without undefined behavior, and then the subtraction works too."
                    },
                    {
                        "username": "anwendeng",
                        "content": "C++ solution must use unsigned long long https://leetcode.com/problems/maximum-width-of-binary-tree/solutions/3436610/dfs-c-solution-must-use-unsigned-long-long/"
                    },
                    {
                        "username": "jskat",
                        "content": "This question reinforced the idea of reading the whole question prompt. I have such a bad habit of reading the first sentence and then trying to solve immediately"
                    },
                    {
                        "username": "leetdaily11",
                        "content": "was just about to post this in discussion! Need to be patient!"
                    },
                    {
                        "username": "jknagin",
                        "content": "This should be a hard."
                    },
                    {
                        "username": "JoshuaMorris95",
                        "content": "Frustrating challenge as some test cases require the use of BigInt when solving in JavaScript."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yep, starts around case 72"
                    }
                ]
            },
            {
                "id": 1722810,
                "content": [
                    {
                        "username": "mayank17081998",
                        "content": "See these images, you will get every idea..![image](https://assets.leetcode.com/users/images/fd1dd3c6-d121-43f2-a4ce-8bf529f190bd_1645930387.2246904.png)\\n![image](https://assets.leetcode.com/users/images/3ef66bd5-c49f-4fe3-8fb8-da76ada7136d_1645930439.4141164.png)\\n![image](https://assets.leetcode.com/users/images/311933bc-6041-497e-9ff4-a9af99dd2aa2_1645930452.510014.png)\\n![image](https://assets.leetcode.com/users/images/f28cd784-ae35-4c75-9e9b-0668b1168e0b_1645930452.716098.png)\\n![image](https://assets.leetcode.com/users/images/33142dc2-f781-4403-b872-88b3eb4d792d_1645930458.9626606.png)\\n\\n\\nhttps://www.linkedin.com/posts/mayank-singh-1004981a4_maximum-width-of-binary-tree-ugcPost-6903531275865702400-t3f0\\n\\n\\n"
                    },
                    {
                        "username": "jotho_",
                        "content": "[@Hsiao-Chien-Ti](/Hsiao-Chien-Ti) I think because the maximum difference is guaranteed to fit in an int, then the max can never overflow twice before the min also overflows.  I used DFS as well"
                    },
                    {
                        "username": "Hsiao-Chien-Ti",
                        "content": "Hi [@Mayank Singh](/mayank17081998) Why won\\'t you get overflow by storing a long long type (long long)currentNo*2+1 into a int type pair in queue? I wrote a dfs version with similar concepts as yours, but I am suffering from overflow now. I print the currentNo of yours out, and found that there are some negative numbers, which I guess is overflow."
                    },
                    {
                        "username": "mohak_gaur",
                        "content": "Why have you written this line inside the for loop...\\nrightMostNodeNo = max(rightMostNodeNo, rootNode.first);\\n\\nyou can simply replace it with...\\nrightMostNodeNo = rootNode.first;\\n\\ni submitted with the above one and it was accepted."
                    },
                    {
                        "username": "pilaniya",
                        "content": "Maximum width of above test case should be 6 but expected output is 8. Or am I doing this wrong?"
                    },
                    {
                        "username": "rajveer_09",
                        "content": "You are doing \"SOMETHING\" wrong."
                    },
                    {
                        "username": "Anupkrpal",
                        "content": "it should be 8\\n"
                    },
                    {
                        "username": "amanchandna",
                        "content": "![image.png](https://assets.leetcode.com/users/images/bc506e3e-0ddf-48e9-9a3e-3d345bfb7ebe_1681964515.560179.png)"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Looks easy, but very tricky"
                    },
                    {
                        "username": "pokaChika",
                        "content": "Hint: If Parents index is n left child is 2*n and right child is 2*n+1. Think along these lines\\n"
                    },
                    {
                        "username": "sk4142",
                        "content": "Extremely good hint"
                    },
                    {
                        "username": "Sudhanshu145",
                        "content": "thanks\\n"
                    },
                    {
                        "username": "thephilosoft",
                        "content": "It is a good idea to test your solution with this input\\n\\n```\\n[-64,12,18,-4,-53,null,76,null,-51,null,null,-93,3,null,-31,47,null,3,53,-81,33,4,null,-51,-44,-60,11,null,null,null,null,78,null,-35,-64,26,-81,-31,27,60,74,null,null,8,-38,47,12,-24,null,-59,-49,-11,-51,67,null,null,null,null,null,null,null,-67,null,-37,-19,10,-55,72,null,null,null,-70,17,-4,null,null,null,null,null,null,null,3,80,44,-88,-91,null,48,-90,-30,null,null,90,-34,37,null,null,73,-38,-31,-85,-31,-96,null,null,-18,67,34,72,null,-17,-77,null,56,-65,-88,-53,null,null,null,-33,86,null,81,-42,null,null,98,-40,70,-26,24,null,null,null,null,92,72,-27,null,null,null,null,null,null,-67,null,null,null,null,null,null,null,-54,-66,-36,null,-72,null,null,43,null,null,null,-92,-1,-98,null,null,null,null,null,null,null,39,-84,null,null,null,null,null,null,null,null,null,null,null,null,null,-93,null,null,null,98]\\n```\\n\\nThe expected answer is `169`"
                    },
                    {
                        "username": "anwendeng",
                        "content": "C++ solution must use unsigned long long !!! Then every thing goes well.\n===============================\noverflow ! 72 / 114 testcases passed\nLine 19: Char 34: runtime error: signed integer overflow: 9223372036854775807 * 2 cannot be represented in type 'long long' (solution.cpp)\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:28:34\n===============================\n[0,0,0,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null]"
                    },
                    {
                        "username": "user4750s",
                        "content": "even long long works fine."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "It\\'s a life (streak) savior comment"
                    },
                    {
                        "username": "user5400vw",
                        "content": "this solution doesn\\'t use unsigned https://leetcode.com/problems/maximum-width-of-binary-tree/solutions/3436483/c-bfs-approach-with-explanation-simple-solution/"
                    },
                    {
                        "username": "andrew99154",
                        "content": "It\\'s helpful for C++ programmers, thanks a lot."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@cskrisz](/cskrisz)  64-bit unsigned int, I think!"
                    },
                    {
                        "username": "cskrisz",
                        "content": "The key is that it\\'s unsigned. You can use `unsigned int` too. `unsigned long long` still can\\'t represent all the indices, but it wraps around without undefined behavior, and then the subtraction works too."
                    },
                    {
                        "username": "anwendeng",
                        "content": "C++ solution must use unsigned long long https://leetcode.com/problems/maximum-width-of-binary-tree/solutions/3436610/dfs-c-solution-must-use-unsigned-long-long/"
                    },
                    {
                        "username": "jskat",
                        "content": "This question reinforced the idea of reading the whole question prompt. I have such a bad habit of reading the first sentence and then trying to solve immediately"
                    },
                    {
                        "username": "leetdaily11",
                        "content": "was just about to post this in discussion! Need to be patient!"
                    },
                    {
                        "username": "jknagin",
                        "content": "This should be a hard."
                    },
                    {
                        "username": "JoshuaMorris95",
                        "content": "Frustrating challenge as some test cases require the use of BigInt when solving in JavaScript."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yep, starts around case 72"
                    }
                ]
            },
            {
                "id": 1567711,
                "content": [
                    {
                        "username": "timhuang1018",
                        "content": "I misunderstood the definition of \"width\" \\nI thought it\\'s like \\n[1,2,3] => width of second level is 2 because we can assume if root at 0 , left child is -1, right is 1\\nthat\\'s why we get width = right - left => 1-(-1) = 2 \\nand so on, then [1,3,2,5,null,null,9,6,null,null,7] have biggest width at level 4 , and the width should be 6? \\nBut the answer is 8\\nCould anyone help to explain why ?"
                    },
                    {
                        "username": "jperrin36",
                        "content": "[@rohit_adithya](/rohit_adithya) but test case says answer is 7 not 8"
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "we should also consider the null pointers in between the end nodes as,\n>                           1                                                 :`width=1`\n>               3                                  2                          :`width=2`\n>         5             null              null            9                 :`width=4`\n>     6   null      null  null      null  null     null  7              :`width=8`"
                    },
                    {
                        "username": "2503praveen",
                        "content": "[1,3,2,null,null,null,5]  . Adding this example will give more clarification of the problem"
                    },
                    {
                        "username": "alprose11",
                        "content": "how it\\'s width is 2 ?\\nit has null in level 3"
                    },
                    {
                        "username": "arghyadas",
                        "content": "The question is poorly written and explained."
                    },
                    {
                        "username": "jolswlf",
                        "content": "I think it\\'s explained just fine "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 27.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/maximum-width-of-binary-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** BFS Traversal\n\n  \n**Approach 2:** DFS Traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "ltbtb_rise",
                        "content": "what is the range of `long long` for c++ compiler here on LT?\\n\\nand what is that of `unsigned int`?"
                    },
                    {
                        "username": "mylemoncake",
                        "content": "What does it mean that \"The binary tree has the same structure as a full binary tree, but some nodes are null.\"?\\nIsn't it the same as \"any binary tree\"?"
                    },
                    {
                        "username": "hosua",
                        "content": "Integer overflow aspect of this problem is obnoxious, please remove TC 113."
                    },
                    {
                        "username": "Meher6124",
                        "content": "use unsigned long long"
                    },
                    {
                        "username": "danlamgcm",
                        "content": "In my code, I will be traversing the tree using a BFS and I will be adjusting the values inside the TreeNode to fit their indexing in their heap depth. With the correct indexing, I can simply look at the very last node in a given depth to find that depth\\'s width.\\n\\nThis is done by looking at the parent node\\'s value to help determine the child node\\'s position in their depth\\'s index.\\nLeft Child = Parent * 2 - 1;\\nRight Child = Parent * 2;\\n*This assumes that you made the root value equal to one to work with the rest of the tree\\n\\nWhile this does good work, it unfortunately breaks when the depth of the rightmost side of the tree becomes very long since it\\'s indexing value exponentially increases. (2 * 2 * 2 * 2 * 2 * 2 ...)\\n\\nSo to handle this, you must find the value of the first node in a given depth using the above method. Then you can continue on that depth as normal but you subtract each calculated index by the first node\\'s value - 1. (subtract 1 to let the first node\\'s index value still be 1 instead of 0)\\n\\nexample:\\n![image](https://assets.leetcode.com/users/images/9960063d-4af3-4561-b83e-4e7f16173af8_1614995126.5425637.png)\\n\\n\\n"
                    },
                    {
                        "username": "jolswlf",
                        "content": "Beautiful problem in my opinion, I don\\'t get why it has almost 1k dislikes. \\n\\nHint: use a queue ;)"
                    },
                    {
                        "username": "jolswlf",
                        "content": "[@Mister_CK](/Mister_CK) oh well I didn\\'t even think about that since it\\'s not a problem in my language but I can definitely see how that could make the problem unenjoyable"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "for me it\\'s the fact that I have to use bigInt, in all the problems I\\'ve solved I never had to use it, and it doesn\\'t add anything to the problem, just makes my code fail at testcase 110 and adds another 10 minutes to fix that edge case"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\nBFS in the following order:\\n![](https://leetcode.com/problems/maximum-width-of-binary-tree/Figures/662/662_bfs_traversal.png)"
                    }
                ]
            },
            {
                "id": 1574535,
                "content": [
                    {
                        "username": "timhuang1018",
                        "content": "I misunderstood the definition of \"width\" \\nI thought it\\'s like \\n[1,2,3] => width of second level is 2 because we can assume if root at 0 , left child is -1, right is 1\\nthat\\'s why we get width = right - left => 1-(-1) = 2 \\nand so on, then [1,3,2,5,null,null,9,6,null,null,7] have biggest width at level 4 , and the width should be 6? \\nBut the answer is 8\\nCould anyone help to explain why ?"
                    },
                    {
                        "username": "jperrin36",
                        "content": "[@rohit_adithya](/rohit_adithya) but test case says answer is 7 not 8"
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "we should also consider the null pointers in between the end nodes as,\n>                           1                                                 :`width=1`\n>               3                                  2                          :`width=2`\n>         5             null              null            9                 :`width=4`\n>     6   null      null  null      null  null     null  7              :`width=8`"
                    },
                    {
                        "username": "2503praveen",
                        "content": "[1,3,2,null,null,null,5]  . Adding this example will give more clarification of the problem"
                    },
                    {
                        "username": "alprose11",
                        "content": "how it\\'s width is 2 ?\\nit has null in level 3"
                    },
                    {
                        "username": "arghyadas",
                        "content": "The question is poorly written and explained."
                    },
                    {
                        "username": "jolswlf",
                        "content": "I think it\\'s explained just fine "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 27.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/maximum-width-of-binary-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** BFS Traversal\n\n  \n**Approach 2:** DFS Traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "ltbtb_rise",
                        "content": "what is the range of `long long` for c++ compiler here on LT?\\n\\nand what is that of `unsigned int`?"
                    },
                    {
                        "username": "mylemoncake",
                        "content": "What does it mean that \"The binary tree has the same structure as a full binary tree, but some nodes are null.\"?\\nIsn't it the same as \"any binary tree\"?"
                    },
                    {
                        "username": "hosua",
                        "content": "Integer overflow aspect of this problem is obnoxious, please remove TC 113."
                    },
                    {
                        "username": "Meher6124",
                        "content": "use unsigned long long"
                    },
                    {
                        "username": "danlamgcm",
                        "content": "In my code, I will be traversing the tree using a BFS and I will be adjusting the values inside the TreeNode to fit their indexing in their heap depth. With the correct indexing, I can simply look at the very last node in a given depth to find that depth\\'s width.\\n\\nThis is done by looking at the parent node\\'s value to help determine the child node\\'s position in their depth\\'s index.\\nLeft Child = Parent * 2 - 1;\\nRight Child = Parent * 2;\\n*This assumes that you made the root value equal to one to work with the rest of the tree\\n\\nWhile this does good work, it unfortunately breaks when the depth of the rightmost side of the tree becomes very long since it\\'s indexing value exponentially increases. (2 * 2 * 2 * 2 * 2 * 2 ...)\\n\\nSo to handle this, you must find the value of the first node in a given depth using the above method. Then you can continue on that depth as normal but you subtract each calculated index by the first node\\'s value - 1. (subtract 1 to let the first node\\'s index value still be 1 instead of 0)\\n\\nexample:\\n![image](https://assets.leetcode.com/users/images/9960063d-4af3-4561-b83e-4e7f16173af8_1614995126.5425637.png)\\n\\n\\n"
                    },
                    {
                        "username": "jolswlf",
                        "content": "Beautiful problem in my opinion, I don\\'t get why it has almost 1k dislikes. \\n\\nHint: use a queue ;)"
                    },
                    {
                        "username": "jolswlf",
                        "content": "[@Mister_CK](/Mister_CK) oh well I didn\\'t even think about that since it\\'s not a problem in my language but I can definitely see how that could make the problem unenjoyable"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "for me it\\'s the fact that I have to use bigInt, in all the problems I\\'ve solved I never had to use it, and it doesn\\'t add anything to the problem, just makes my code fail at testcase 110 and adds another 10 minutes to fix that edge case"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\nBFS in the following order:\\n![](https://leetcode.com/problems/maximum-width-of-binary-tree/Figures/662/662_bfs_traversal.png)"
                    }
                ]
            },
            {
                "id": 1869015,
                "content": [
                    {
                        "username": "timhuang1018",
                        "content": "I misunderstood the definition of \"width\" \\nI thought it\\'s like \\n[1,2,3] => width of second level is 2 because we can assume if root at 0 , left child is -1, right is 1\\nthat\\'s why we get width = right - left => 1-(-1) = 2 \\nand so on, then [1,3,2,5,null,null,9,6,null,null,7] have biggest width at level 4 , and the width should be 6? \\nBut the answer is 8\\nCould anyone help to explain why ?"
                    },
                    {
                        "username": "jperrin36",
                        "content": "[@rohit_adithya](/rohit_adithya) but test case says answer is 7 not 8"
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "we should also consider the null pointers in between the end nodes as,\n>                           1                                                 :`width=1`\n>               3                                  2                          :`width=2`\n>         5             null              null            9                 :`width=4`\n>     6   null      null  null      null  null     null  7              :`width=8`"
                    },
                    {
                        "username": "2503praveen",
                        "content": "[1,3,2,null,null,null,5]  . Adding this example will give more clarification of the problem"
                    },
                    {
                        "username": "alprose11",
                        "content": "how it\\'s width is 2 ?\\nit has null in level 3"
                    },
                    {
                        "username": "arghyadas",
                        "content": "The question is poorly written and explained."
                    },
                    {
                        "username": "jolswlf",
                        "content": "I think it\\'s explained just fine "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 27.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/maximum-width-of-binary-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** BFS Traversal\n\n  \n**Approach 2:** DFS Traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "ltbtb_rise",
                        "content": "what is the range of `long long` for c++ compiler here on LT?\\n\\nand what is that of `unsigned int`?"
                    },
                    {
                        "username": "mylemoncake",
                        "content": "What does it mean that \"The binary tree has the same structure as a full binary tree, but some nodes are null.\"?\\nIsn't it the same as \"any binary tree\"?"
                    },
                    {
                        "username": "hosua",
                        "content": "Integer overflow aspect of this problem is obnoxious, please remove TC 113."
                    },
                    {
                        "username": "Meher6124",
                        "content": "use unsigned long long"
                    },
                    {
                        "username": "danlamgcm",
                        "content": "In my code, I will be traversing the tree using a BFS and I will be adjusting the values inside the TreeNode to fit their indexing in their heap depth. With the correct indexing, I can simply look at the very last node in a given depth to find that depth\\'s width.\\n\\nThis is done by looking at the parent node\\'s value to help determine the child node\\'s position in their depth\\'s index.\\nLeft Child = Parent * 2 - 1;\\nRight Child = Parent * 2;\\n*This assumes that you made the root value equal to one to work with the rest of the tree\\n\\nWhile this does good work, it unfortunately breaks when the depth of the rightmost side of the tree becomes very long since it\\'s indexing value exponentially increases. (2 * 2 * 2 * 2 * 2 * 2 ...)\\n\\nSo to handle this, you must find the value of the first node in a given depth using the above method. Then you can continue on that depth as normal but you subtract each calculated index by the first node\\'s value - 1. (subtract 1 to let the first node\\'s index value still be 1 instead of 0)\\n\\nexample:\\n![image](https://assets.leetcode.com/users/images/9960063d-4af3-4561-b83e-4e7f16173af8_1614995126.5425637.png)\\n\\n\\n"
                    },
                    {
                        "username": "jolswlf",
                        "content": "Beautiful problem in my opinion, I don\\'t get why it has almost 1k dislikes. \\n\\nHint: use a queue ;)"
                    },
                    {
                        "username": "jolswlf",
                        "content": "[@Mister_CK](/Mister_CK) oh well I didn\\'t even think about that since it\\'s not a problem in my language but I can definitely see how that could make the problem unenjoyable"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "for me it\\'s the fact that I have to use bigInt, in all the problems I\\'ve solved I never had to use it, and it doesn\\'t add anything to the problem, just makes my code fail at testcase 110 and adds another 10 minutes to fix that edge case"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\nBFS in the following order:\\n![](https://leetcode.com/problems/maximum-width-of-binary-tree/Figures/662/662_bfs_traversal.png)"
                    }
                ]
            },
            {
                "id": 1567732,
                "content": [
                    {
                        "username": "timhuang1018",
                        "content": "I misunderstood the definition of \"width\" \\nI thought it\\'s like \\n[1,2,3] => width of second level is 2 because we can assume if root at 0 , left child is -1, right is 1\\nthat\\'s why we get width = right - left => 1-(-1) = 2 \\nand so on, then [1,3,2,5,null,null,9,6,null,null,7] have biggest width at level 4 , and the width should be 6? \\nBut the answer is 8\\nCould anyone help to explain why ?"
                    },
                    {
                        "username": "jperrin36",
                        "content": "[@rohit_adithya](/rohit_adithya) but test case says answer is 7 not 8"
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "we should also consider the null pointers in between the end nodes as,\n>                           1                                                 :`width=1`\n>               3                                  2                          :`width=2`\n>         5             null              null            9                 :`width=4`\n>     6   null      null  null      null  null     null  7              :`width=8`"
                    },
                    {
                        "username": "2503praveen",
                        "content": "[1,3,2,null,null,null,5]  . Adding this example will give more clarification of the problem"
                    },
                    {
                        "username": "alprose11",
                        "content": "how it\\'s width is 2 ?\\nit has null in level 3"
                    },
                    {
                        "username": "arghyadas",
                        "content": "The question is poorly written and explained."
                    },
                    {
                        "username": "jolswlf",
                        "content": "I think it\\'s explained just fine "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 27.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/maximum-width-of-binary-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** BFS Traversal\n\n  \n**Approach 2:** DFS Traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "ltbtb_rise",
                        "content": "what is the range of `long long` for c++ compiler here on LT?\\n\\nand what is that of `unsigned int`?"
                    },
                    {
                        "username": "mylemoncake",
                        "content": "What does it mean that \"The binary tree has the same structure as a full binary tree, but some nodes are null.\"?\\nIsn't it the same as \"any binary tree\"?"
                    },
                    {
                        "username": "hosua",
                        "content": "Integer overflow aspect of this problem is obnoxious, please remove TC 113."
                    },
                    {
                        "username": "Meher6124",
                        "content": "use unsigned long long"
                    },
                    {
                        "username": "danlamgcm",
                        "content": "In my code, I will be traversing the tree using a BFS and I will be adjusting the values inside the TreeNode to fit their indexing in their heap depth. With the correct indexing, I can simply look at the very last node in a given depth to find that depth\\'s width.\\n\\nThis is done by looking at the parent node\\'s value to help determine the child node\\'s position in their depth\\'s index.\\nLeft Child = Parent * 2 - 1;\\nRight Child = Parent * 2;\\n*This assumes that you made the root value equal to one to work with the rest of the tree\\n\\nWhile this does good work, it unfortunately breaks when the depth of the rightmost side of the tree becomes very long since it\\'s indexing value exponentially increases. (2 * 2 * 2 * 2 * 2 * 2 ...)\\n\\nSo to handle this, you must find the value of the first node in a given depth using the above method. Then you can continue on that depth as normal but you subtract each calculated index by the first node\\'s value - 1. (subtract 1 to let the first node\\'s index value still be 1 instead of 0)\\n\\nexample:\\n![image](https://assets.leetcode.com/users/images/9960063d-4af3-4561-b83e-4e7f16173af8_1614995126.5425637.png)\\n\\n\\n"
                    },
                    {
                        "username": "jolswlf",
                        "content": "Beautiful problem in my opinion, I don\\'t get why it has almost 1k dislikes. \\n\\nHint: use a queue ;)"
                    },
                    {
                        "username": "jolswlf",
                        "content": "[@Mister_CK](/Mister_CK) oh well I didn\\'t even think about that since it\\'s not a problem in my language but I can definitely see how that could make the problem unenjoyable"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "for me it\\'s the fact that I have to use bigInt, in all the problems I\\'ve solved I never had to use it, and it doesn\\'t add anything to the problem, just makes my code fail at testcase 110 and adds another 10 minutes to fix that edge case"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\nBFS in the following order:\\n![](https://leetcode.com/problems/maximum-width-of-binary-tree/Figures/662/662_bfs_traversal.png)"
                    }
                ]
            },
            {
                "id": 1570124,
                "content": [
                    {
                        "username": "timhuang1018",
                        "content": "I misunderstood the definition of \"width\" \\nI thought it\\'s like \\n[1,2,3] => width of second level is 2 because we can assume if root at 0 , left child is -1, right is 1\\nthat\\'s why we get width = right - left => 1-(-1) = 2 \\nand so on, then [1,3,2,5,null,null,9,6,null,null,7] have biggest width at level 4 , and the width should be 6? \\nBut the answer is 8\\nCould anyone help to explain why ?"
                    },
                    {
                        "username": "jperrin36",
                        "content": "[@rohit_adithya](/rohit_adithya) but test case says answer is 7 not 8"
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "we should also consider the null pointers in between the end nodes as,\n>                           1                                                 :`width=1`\n>               3                                  2                          :`width=2`\n>         5             null              null            9                 :`width=4`\n>     6   null      null  null      null  null     null  7              :`width=8`"
                    },
                    {
                        "username": "2503praveen",
                        "content": "[1,3,2,null,null,null,5]  . Adding this example will give more clarification of the problem"
                    },
                    {
                        "username": "alprose11",
                        "content": "how it\\'s width is 2 ?\\nit has null in level 3"
                    },
                    {
                        "username": "arghyadas",
                        "content": "The question is poorly written and explained."
                    },
                    {
                        "username": "jolswlf",
                        "content": "I think it\\'s explained just fine "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 27.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/maximum-width-of-binary-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** BFS Traversal\n\n  \n**Approach 2:** DFS Traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "ltbtb_rise",
                        "content": "what is the range of `long long` for c++ compiler here on LT?\\n\\nand what is that of `unsigned int`?"
                    },
                    {
                        "username": "mylemoncake",
                        "content": "What does it mean that \"The binary tree has the same structure as a full binary tree, but some nodes are null.\"?\\nIsn't it the same as \"any binary tree\"?"
                    },
                    {
                        "username": "hosua",
                        "content": "Integer overflow aspect of this problem is obnoxious, please remove TC 113."
                    },
                    {
                        "username": "Meher6124",
                        "content": "use unsigned long long"
                    },
                    {
                        "username": "danlamgcm",
                        "content": "In my code, I will be traversing the tree using a BFS and I will be adjusting the values inside the TreeNode to fit their indexing in their heap depth. With the correct indexing, I can simply look at the very last node in a given depth to find that depth\\'s width.\\n\\nThis is done by looking at the parent node\\'s value to help determine the child node\\'s position in their depth\\'s index.\\nLeft Child = Parent * 2 - 1;\\nRight Child = Parent * 2;\\n*This assumes that you made the root value equal to one to work with the rest of the tree\\n\\nWhile this does good work, it unfortunately breaks when the depth of the rightmost side of the tree becomes very long since it\\'s indexing value exponentially increases. (2 * 2 * 2 * 2 * 2 * 2 ...)\\n\\nSo to handle this, you must find the value of the first node in a given depth using the above method. Then you can continue on that depth as normal but you subtract each calculated index by the first node\\'s value - 1. (subtract 1 to let the first node\\'s index value still be 1 instead of 0)\\n\\nexample:\\n![image](https://assets.leetcode.com/users/images/9960063d-4af3-4561-b83e-4e7f16173af8_1614995126.5425637.png)\\n\\n\\n"
                    },
                    {
                        "username": "jolswlf",
                        "content": "Beautiful problem in my opinion, I don\\'t get why it has almost 1k dislikes. \\n\\nHint: use a queue ;)"
                    },
                    {
                        "username": "jolswlf",
                        "content": "[@Mister_CK](/Mister_CK) oh well I didn\\'t even think about that since it\\'s not a problem in my language but I can definitely see how that could make the problem unenjoyable"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "for me it\\'s the fact that I have to use bigInt, in all the problems I\\'ve solved I never had to use it, and it doesn\\'t add anything to the problem, just makes my code fail at testcase 110 and adds another 10 minutes to fix that edge case"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\nBFS in the following order:\\n![](https://leetcode.com/problems/maximum-width-of-binary-tree/Figures/662/662_bfs_traversal.png)"
                    }
                ]
            },
            {
                "id": 1567279,
                "content": [
                    {
                        "username": "timhuang1018",
                        "content": "I misunderstood the definition of \"width\" \\nI thought it\\'s like \\n[1,2,3] => width of second level is 2 because we can assume if root at 0 , left child is -1, right is 1\\nthat\\'s why we get width = right - left => 1-(-1) = 2 \\nand so on, then [1,3,2,5,null,null,9,6,null,null,7] have biggest width at level 4 , and the width should be 6? \\nBut the answer is 8\\nCould anyone help to explain why ?"
                    },
                    {
                        "username": "jperrin36",
                        "content": "[@rohit_adithya](/rohit_adithya) but test case says answer is 7 not 8"
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "we should also consider the null pointers in between the end nodes as,\n>                           1                                                 :`width=1`\n>               3                                  2                          :`width=2`\n>         5             null              null            9                 :`width=4`\n>     6   null      null  null      null  null     null  7              :`width=8`"
                    },
                    {
                        "username": "2503praveen",
                        "content": "[1,3,2,null,null,null,5]  . Adding this example will give more clarification of the problem"
                    },
                    {
                        "username": "alprose11",
                        "content": "how it\\'s width is 2 ?\\nit has null in level 3"
                    },
                    {
                        "username": "arghyadas",
                        "content": "The question is poorly written and explained."
                    },
                    {
                        "username": "jolswlf",
                        "content": "I think it\\'s explained just fine "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 27.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/maximum-width-of-binary-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** BFS Traversal\n\n  \n**Approach 2:** DFS Traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "ltbtb_rise",
                        "content": "what is the range of `long long` for c++ compiler here on LT?\\n\\nand what is that of `unsigned int`?"
                    },
                    {
                        "username": "mylemoncake",
                        "content": "What does it mean that \"The binary tree has the same structure as a full binary tree, but some nodes are null.\"?\\nIsn't it the same as \"any binary tree\"?"
                    },
                    {
                        "username": "hosua",
                        "content": "Integer overflow aspect of this problem is obnoxious, please remove TC 113."
                    },
                    {
                        "username": "Meher6124",
                        "content": "use unsigned long long"
                    },
                    {
                        "username": "danlamgcm",
                        "content": "In my code, I will be traversing the tree using a BFS and I will be adjusting the values inside the TreeNode to fit their indexing in their heap depth. With the correct indexing, I can simply look at the very last node in a given depth to find that depth\\'s width.\\n\\nThis is done by looking at the parent node\\'s value to help determine the child node\\'s position in their depth\\'s index.\\nLeft Child = Parent * 2 - 1;\\nRight Child = Parent * 2;\\n*This assumes that you made the root value equal to one to work with the rest of the tree\\n\\nWhile this does good work, it unfortunately breaks when the depth of the rightmost side of the tree becomes very long since it\\'s indexing value exponentially increases. (2 * 2 * 2 * 2 * 2 * 2 ...)\\n\\nSo to handle this, you must find the value of the first node in a given depth using the above method. Then you can continue on that depth as normal but you subtract each calculated index by the first node\\'s value - 1. (subtract 1 to let the first node\\'s index value still be 1 instead of 0)\\n\\nexample:\\n![image](https://assets.leetcode.com/users/images/9960063d-4af3-4561-b83e-4e7f16173af8_1614995126.5425637.png)\\n\\n\\n"
                    },
                    {
                        "username": "jolswlf",
                        "content": "Beautiful problem in my opinion, I don\\'t get why it has almost 1k dislikes. \\n\\nHint: use a queue ;)"
                    },
                    {
                        "username": "jolswlf",
                        "content": "[@Mister_CK](/Mister_CK) oh well I didn\\'t even think about that since it\\'s not a problem in my language but I can definitely see how that could make the problem unenjoyable"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "for me it\\'s the fact that I have to use bigInt, in all the problems I\\'ve solved I never had to use it, and it doesn\\'t add anything to the problem, just makes my code fail at testcase 110 and adds another 10 minutes to fix that edge case"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\nBFS in the following order:\\n![](https://leetcode.com/problems/maximum-width-of-binary-tree/Figures/662/662_bfs_traversal.png)"
                    }
                ]
            },
            {
                "id": 1869585,
                "content": [
                    {
                        "username": "timhuang1018",
                        "content": "I misunderstood the definition of \"width\" \\nI thought it\\'s like \\n[1,2,3] => width of second level is 2 because we can assume if root at 0 , left child is -1, right is 1\\nthat\\'s why we get width = right - left => 1-(-1) = 2 \\nand so on, then [1,3,2,5,null,null,9,6,null,null,7] have biggest width at level 4 , and the width should be 6? \\nBut the answer is 8\\nCould anyone help to explain why ?"
                    },
                    {
                        "username": "jperrin36",
                        "content": "[@rohit_adithya](/rohit_adithya) but test case says answer is 7 not 8"
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "we should also consider the null pointers in between the end nodes as,\n>                           1                                                 :`width=1`\n>               3                                  2                          :`width=2`\n>         5             null              null            9                 :`width=4`\n>     6   null      null  null      null  null     null  7              :`width=8`"
                    },
                    {
                        "username": "2503praveen",
                        "content": "[1,3,2,null,null,null,5]  . Adding this example will give more clarification of the problem"
                    },
                    {
                        "username": "alprose11",
                        "content": "how it\\'s width is 2 ?\\nit has null in level 3"
                    },
                    {
                        "username": "arghyadas",
                        "content": "The question is poorly written and explained."
                    },
                    {
                        "username": "jolswlf",
                        "content": "I think it\\'s explained just fine "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 27.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/maximum-width-of-binary-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** BFS Traversal\n\n  \n**Approach 2:** DFS Traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "ltbtb_rise",
                        "content": "what is the range of `long long` for c++ compiler here on LT?\\n\\nand what is that of `unsigned int`?"
                    },
                    {
                        "username": "mylemoncake",
                        "content": "What does it mean that \"The binary tree has the same structure as a full binary tree, but some nodes are null.\"?\\nIsn't it the same as \"any binary tree\"?"
                    },
                    {
                        "username": "hosua",
                        "content": "Integer overflow aspect of this problem is obnoxious, please remove TC 113."
                    },
                    {
                        "username": "Meher6124",
                        "content": "use unsigned long long"
                    },
                    {
                        "username": "danlamgcm",
                        "content": "In my code, I will be traversing the tree using a BFS and I will be adjusting the values inside the TreeNode to fit their indexing in their heap depth. With the correct indexing, I can simply look at the very last node in a given depth to find that depth\\'s width.\\n\\nThis is done by looking at the parent node\\'s value to help determine the child node\\'s position in their depth\\'s index.\\nLeft Child = Parent * 2 - 1;\\nRight Child = Parent * 2;\\n*This assumes that you made the root value equal to one to work with the rest of the tree\\n\\nWhile this does good work, it unfortunately breaks when the depth of the rightmost side of the tree becomes very long since it\\'s indexing value exponentially increases. (2 * 2 * 2 * 2 * 2 * 2 ...)\\n\\nSo to handle this, you must find the value of the first node in a given depth using the above method. Then you can continue on that depth as normal but you subtract each calculated index by the first node\\'s value - 1. (subtract 1 to let the first node\\'s index value still be 1 instead of 0)\\n\\nexample:\\n![image](https://assets.leetcode.com/users/images/9960063d-4af3-4561-b83e-4e7f16173af8_1614995126.5425637.png)\\n\\n\\n"
                    },
                    {
                        "username": "jolswlf",
                        "content": "Beautiful problem in my opinion, I don\\'t get why it has almost 1k dislikes. \\n\\nHint: use a queue ;)"
                    },
                    {
                        "username": "jolswlf",
                        "content": "[@Mister_CK](/Mister_CK) oh well I didn\\'t even think about that since it\\'s not a problem in my language but I can definitely see how that could make the problem unenjoyable"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "for me it\\'s the fact that I have to use bigInt, in all the problems I\\'ve solved I never had to use it, and it doesn\\'t add anything to the problem, just makes my code fail at testcase 110 and adds another 10 minutes to fix that edge case"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\nBFS in the following order:\\n![](https://leetcode.com/problems/maximum-width-of-binary-tree/Figures/662/662_bfs_traversal.png)"
                    }
                ]
            },
            {
                "id": 1570351,
                "content": [
                    {
                        "username": "timhuang1018",
                        "content": "I misunderstood the definition of \"width\" \\nI thought it\\'s like \\n[1,2,3] => width of second level is 2 because we can assume if root at 0 , left child is -1, right is 1\\nthat\\'s why we get width = right - left => 1-(-1) = 2 \\nand so on, then [1,3,2,5,null,null,9,6,null,null,7] have biggest width at level 4 , and the width should be 6? \\nBut the answer is 8\\nCould anyone help to explain why ?"
                    },
                    {
                        "username": "jperrin36",
                        "content": "[@rohit_adithya](/rohit_adithya) but test case says answer is 7 not 8"
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "we should also consider the null pointers in between the end nodes as,\n>                           1                                                 :`width=1`\n>               3                                  2                          :`width=2`\n>         5             null              null            9                 :`width=4`\n>     6   null      null  null      null  null     null  7              :`width=8`"
                    },
                    {
                        "username": "2503praveen",
                        "content": "[1,3,2,null,null,null,5]  . Adding this example will give more clarification of the problem"
                    },
                    {
                        "username": "alprose11",
                        "content": "how it\\'s width is 2 ?\\nit has null in level 3"
                    },
                    {
                        "username": "arghyadas",
                        "content": "The question is poorly written and explained."
                    },
                    {
                        "username": "jolswlf",
                        "content": "I think it\\'s explained just fine "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 27.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/maximum-width-of-binary-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** BFS Traversal\n\n  \n**Approach 2:** DFS Traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "ltbtb_rise",
                        "content": "what is the range of `long long` for c++ compiler here on LT?\\n\\nand what is that of `unsigned int`?"
                    },
                    {
                        "username": "mylemoncake",
                        "content": "What does it mean that \"The binary tree has the same structure as a full binary tree, but some nodes are null.\"?\\nIsn't it the same as \"any binary tree\"?"
                    },
                    {
                        "username": "hosua",
                        "content": "Integer overflow aspect of this problem is obnoxious, please remove TC 113."
                    },
                    {
                        "username": "Meher6124",
                        "content": "use unsigned long long"
                    },
                    {
                        "username": "danlamgcm",
                        "content": "In my code, I will be traversing the tree using a BFS and I will be adjusting the values inside the TreeNode to fit their indexing in their heap depth. With the correct indexing, I can simply look at the very last node in a given depth to find that depth\\'s width.\\n\\nThis is done by looking at the parent node\\'s value to help determine the child node\\'s position in their depth\\'s index.\\nLeft Child = Parent * 2 - 1;\\nRight Child = Parent * 2;\\n*This assumes that you made the root value equal to one to work with the rest of the tree\\n\\nWhile this does good work, it unfortunately breaks when the depth of the rightmost side of the tree becomes very long since it\\'s indexing value exponentially increases. (2 * 2 * 2 * 2 * 2 * 2 ...)\\n\\nSo to handle this, you must find the value of the first node in a given depth using the above method. Then you can continue on that depth as normal but you subtract each calculated index by the first node\\'s value - 1. (subtract 1 to let the first node\\'s index value still be 1 instead of 0)\\n\\nexample:\\n![image](https://assets.leetcode.com/users/images/9960063d-4af3-4561-b83e-4e7f16173af8_1614995126.5425637.png)\\n\\n\\n"
                    },
                    {
                        "username": "jolswlf",
                        "content": "Beautiful problem in my opinion, I don\\'t get why it has almost 1k dislikes. \\n\\nHint: use a queue ;)"
                    },
                    {
                        "username": "jolswlf",
                        "content": "[@Mister_CK](/Mister_CK) oh well I didn\\'t even think about that since it\\'s not a problem in my language but I can definitely see how that could make the problem unenjoyable"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "for me it\\'s the fact that I have to use bigInt, in all the problems I\\'ve solved I never had to use it, and it doesn\\'t add anything to the problem, just makes my code fail at testcase 110 and adds another 10 minutes to fix that edge case"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\nBFS in the following order:\\n![](https://leetcode.com/problems/maximum-width-of-binary-tree/Figures/662/662_bfs_traversal.png)"
                    }
                ]
            },
            {
                "id": 1869030,
                "content": [
                    {
                        "username": "timhuang1018",
                        "content": "I misunderstood the definition of \"width\" \\nI thought it\\'s like \\n[1,2,3] => width of second level is 2 because we can assume if root at 0 , left child is -1, right is 1\\nthat\\'s why we get width = right - left => 1-(-1) = 2 \\nand so on, then [1,3,2,5,null,null,9,6,null,null,7] have biggest width at level 4 , and the width should be 6? \\nBut the answer is 8\\nCould anyone help to explain why ?"
                    },
                    {
                        "username": "jperrin36",
                        "content": "[@rohit_adithya](/rohit_adithya) but test case says answer is 7 not 8"
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "we should also consider the null pointers in between the end nodes as,\n>                           1                                                 :`width=1`\n>               3                                  2                          :`width=2`\n>         5             null              null            9                 :`width=4`\n>     6   null      null  null      null  null     null  7              :`width=8`"
                    },
                    {
                        "username": "2503praveen",
                        "content": "[1,3,2,null,null,null,5]  . Adding this example will give more clarification of the problem"
                    },
                    {
                        "username": "alprose11",
                        "content": "how it\\'s width is 2 ?\\nit has null in level 3"
                    },
                    {
                        "username": "arghyadas",
                        "content": "The question is poorly written and explained."
                    },
                    {
                        "username": "jolswlf",
                        "content": "I think it\\'s explained just fine "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 27.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/maximum-width-of-binary-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** BFS Traversal\n\n  \n**Approach 2:** DFS Traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "ltbtb_rise",
                        "content": "what is the range of `long long` for c++ compiler here on LT?\\n\\nand what is that of `unsigned int`?"
                    },
                    {
                        "username": "mylemoncake",
                        "content": "What does it mean that \"The binary tree has the same structure as a full binary tree, but some nodes are null.\"?\\nIsn't it the same as \"any binary tree\"?"
                    },
                    {
                        "username": "hosua",
                        "content": "Integer overflow aspect of this problem is obnoxious, please remove TC 113."
                    },
                    {
                        "username": "Meher6124",
                        "content": "use unsigned long long"
                    },
                    {
                        "username": "danlamgcm",
                        "content": "In my code, I will be traversing the tree using a BFS and I will be adjusting the values inside the TreeNode to fit their indexing in their heap depth. With the correct indexing, I can simply look at the very last node in a given depth to find that depth\\'s width.\\n\\nThis is done by looking at the parent node\\'s value to help determine the child node\\'s position in their depth\\'s index.\\nLeft Child = Parent * 2 - 1;\\nRight Child = Parent * 2;\\n*This assumes that you made the root value equal to one to work with the rest of the tree\\n\\nWhile this does good work, it unfortunately breaks when the depth of the rightmost side of the tree becomes very long since it\\'s indexing value exponentially increases. (2 * 2 * 2 * 2 * 2 * 2 ...)\\n\\nSo to handle this, you must find the value of the first node in a given depth using the above method. Then you can continue on that depth as normal but you subtract each calculated index by the first node\\'s value - 1. (subtract 1 to let the first node\\'s index value still be 1 instead of 0)\\n\\nexample:\\n![image](https://assets.leetcode.com/users/images/9960063d-4af3-4561-b83e-4e7f16173af8_1614995126.5425637.png)\\n\\n\\n"
                    },
                    {
                        "username": "jolswlf",
                        "content": "Beautiful problem in my opinion, I don\\'t get why it has almost 1k dislikes. \\n\\nHint: use a queue ;)"
                    },
                    {
                        "username": "jolswlf",
                        "content": "[@Mister_CK](/Mister_CK) oh well I didn\\'t even think about that since it\\'s not a problem in my language but I can definitely see how that could make the problem unenjoyable"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "for me it\\'s the fact that I have to use bigInt, in all the problems I\\'ve solved I never had to use it, and it doesn\\'t add anything to the problem, just makes my code fail at testcase 110 and adds another 10 minutes to fix that edge case"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\nBFS in the following order:\\n![](https://leetcode.com/problems/maximum-width-of-binary-tree/Figures/662/662_bfs_traversal.png)"
                    }
                ]
            },
            {
                "id": 1868858,
                "content": [
                    {
                        "username": "timhuang1018",
                        "content": "I misunderstood the definition of \"width\" \\nI thought it\\'s like \\n[1,2,3] => width of second level is 2 because we can assume if root at 0 , left child is -1, right is 1\\nthat\\'s why we get width = right - left => 1-(-1) = 2 \\nand so on, then [1,3,2,5,null,null,9,6,null,null,7] have biggest width at level 4 , and the width should be 6? \\nBut the answer is 8\\nCould anyone help to explain why ?"
                    },
                    {
                        "username": "jperrin36",
                        "content": "[@rohit_adithya](/rohit_adithya) but test case says answer is 7 not 8"
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "we should also consider the null pointers in between the end nodes as,\n>                           1                                                 :`width=1`\n>               3                                  2                          :`width=2`\n>         5             null              null            9                 :`width=4`\n>     6   null      null  null      null  null     null  7              :`width=8`"
                    },
                    {
                        "username": "2503praveen",
                        "content": "[1,3,2,null,null,null,5]  . Adding this example will give more clarification of the problem"
                    },
                    {
                        "username": "alprose11",
                        "content": "how it\\'s width is 2 ?\\nit has null in level 3"
                    },
                    {
                        "username": "arghyadas",
                        "content": "The question is poorly written and explained."
                    },
                    {
                        "username": "jolswlf",
                        "content": "I think it\\'s explained just fine "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 27.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/maximum-width-of-binary-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** BFS Traversal\n\n  \n**Approach 2:** DFS Traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "ltbtb_rise",
                        "content": "what is the range of `long long` for c++ compiler here on LT?\\n\\nand what is that of `unsigned int`?"
                    },
                    {
                        "username": "mylemoncake",
                        "content": "What does it mean that \"The binary tree has the same structure as a full binary tree, but some nodes are null.\"?\\nIsn't it the same as \"any binary tree\"?"
                    },
                    {
                        "username": "hosua",
                        "content": "Integer overflow aspect of this problem is obnoxious, please remove TC 113."
                    },
                    {
                        "username": "Meher6124",
                        "content": "use unsigned long long"
                    },
                    {
                        "username": "danlamgcm",
                        "content": "In my code, I will be traversing the tree using a BFS and I will be adjusting the values inside the TreeNode to fit their indexing in their heap depth. With the correct indexing, I can simply look at the very last node in a given depth to find that depth\\'s width.\\n\\nThis is done by looking at the parent node\\'s value to help determine the child node\\'s position in their depth\\'s index.\\nLeft Child = Parent * 2 - 1;\\nRight Child = Parent * 2;\\n*This assumes that you made the root value equal to one to work with the rest of the tree\\n\\nWhile this does good work, it unfortunately breaks when the depth of the rightmost side of the tree becomes very long since it\\'s indexing value exponentially increases. (2 * 2 * 2 * 2 * 2 * 2 ...)\\n\\nSo to handle this, you must find the value of the first node in a given depth using the above method. Then you can continue on that depth as normal but you subtract each calculated index by the first node\\'s value - 1. (subtract 1 to let the first node\\'s index value still be 1 instead of 0)\\n\\nexample:\\n![image](https://assets.leetcode.com/users/images/9960063d-4af3-4561-b83e-4e7f16173af8_1614995126.5425637.png)\\n\\n\\n"
                    },
                    {
                        "username": "jolswlf",
                        "content": "Beautiful problem in my opinion, I don\\'t get why it has almost 1k dislikes. \\n\\nHint: use a queue ;)"
                    },
                    {
                        "username": "jolswlf",
                        "content": "[@Mister_CK](/Mister_CK) oh well I didn\\'t even think about that since it\\'s not a problem in my language but I can definitely see how that could make the problem unenjoyable"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "for me it\\'s the fact that I have to use bigInt, in all the problems I\\'ve solved I never had to use it, and it doesn\\'t add anything to the problem, just makes my code fail at testcase 110 and adds another 10 minutes to fix that edge case"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\nBFS in the following order:\\n![](https://leetcode.com/problems/maximum-width-of-binary-tree/Figures/662/662_bfs_traversal.png)"
                    }
                ]
            },
            {
                "id": 1869446,
                "content": [
                    {
                        "username": "drat",
                        "content": "My solution fails at this particular testcase , any help why? \\ntest case - [-64,12,18,-4,-53,null,76,null,-51,null,null,-93,3,null,-31,47,null,3,53,-81,33,4,null,-51,-44,-60,11,null,null,null,null,78,null,-35,-64,26,-81,-31,27,60,74,null,null,8,-38,47,12,-24,null,-59,-49,-11,-51,67,null,null,null,null,null,null,null,-67,null,-37,-19,10,-55,72,null,null,null,-70,17,-4,null,null,null,null,null,null,null,3,80,44,-88,-91,null,48,-90,-30,null,null,90,-34,37,null,null,73,-38,-31,-85,-31,-96,null,null,-18,67,34,72,null,-17,-77,null,56,-65,-88,-53,null,null,null,-33,86,null,81,-42,null,null,98,-40,70,-26,24,null,null,null,null,92,72,-27,null,null,null,null,null,null,-67,null,null,null,null,null,null,null,-54,-66,-36,null,-72,null,null,43,null,null,null,-92,-1,-98,null,null,null,null,null,null,null,39,-84,null,null,null,null,null,null,null,null,null,null,null,null,null,-93,null,null,null,98]\\n\\n`class Solution {\\n    public int widthOfBinaryTree(TreeNode root) {\\n        int width = 0;\\n        Queue<Pair<TreeNode, Integer>> q = new LinkedList<>();\\n        if(root!=null) q.add(new Pair(root, 1));\\n\\n        while(!q.isEmpty()){\\n            int n = q.size();\\n            int min=5000, max=0;\\n            while(n-- > 0){\\n                Pair<TreeNode, Integer> p = q.poll();\\n                TreeNode cur = p.getKey();\\n                int pos = p.getValue(); \\n                min = Math.min(min, pos);\\n                max = Math.max(max, pos);\\n\\n                if(cur.left!=null) q.add(new Pair(cur.left, pos*2));\\n                if(cur.right!=null) q.add(new Pair(cur.right, pos*2+1));\\n            }\\n\\n            width = Math.max(width, max-min+1);\\n\\n        }\\n\\n        return width;\\n\\n    }\\n}`"
                    },
                    {
                        "username": "shreedpathaks",
                        "content": "Try with  Deque, apply bfs and check for size between two non-null nodes, return the maximum ans;\\nremove all null nodes from front till first non-null node and similarly from back, (remove all null nodes from front till first non-null node).\\ncompare the size with ans, and return max,\\ntho this approach  has TLE but u will get more clearity from this ."
                    },
                    {
                        "username": "aitachii",
                        "content": "The width of a level is the number of non-null nodes + the null nodes inbetween the non-null nodes.\nFor example 1:\nLevel 1: [1]\nhas width 1\nLevel 2: [3, 2]\nhas width 2 \nLevel 3: [5,3,X,9]\nhas width 4\n\nExample 2:\n[1] has width 1\n[3,2] has width 2\n[5,X,X,9] has width 4\n[6,X,X,X,X,X,7,X] has width 7, [6,X,X,X,X,X,7]\n\nExample 3:\n[1] has width 1\n[3,2] has width 2\n[5,X,X,X] has width 1, [5]\n\nMore examples (some random levels):\n[X,1,X,5,X] has width 3, [1,X,5]\n[X,X,1,X,X,X] has width 1, [1]\n[X,1,X,X,5,X,X,9] has width 7, [1,X,X,5,X,X,9]\n\nThe testcases can cause overflow so think of a way to solve this without counting all the nodes(both null and non-null) in a level."
                    },
                    {
                        "username": "jpvarbed",
                        "content": "Please put a note for javascript/typescript users that you need to wrap in bigint"
                    },
                    {
                        "username": "bjiang78",
                        "content": "In a full binary tree, the index calculation of left child and right child is:\n- left child index = parent index * 2 + 1\n- right child index = parent index * 2 + 2\n\nSo the basic idea is to use a queue to traverse the tree level by level, and record the difference between the most left node's index and the most right node's index, and update the max index distance for each layer.\n\nThe problem is, even with a tree with only 3000 nodes, the index difference may overflow in a int32 integer (up to 2^3000 when all the nodes are on a parent-child chain). To address this problem, one way is to use long long type. But it's not easy to scale up to a tree with more nodes. Note that the absolute value of a node's index is not important. What matters is the distance from the left most node to the right most node. So for each layer, we can reduce the index value by starting the left most node's index from 0. With this second approach, we can handle a tree up to 2,147,483,647 layers just with int32 type.\n\nC# code:\n```csharp\n    public int WidthOfBinaryTree(TreeNode root) {\n        if (root == null)\n            return 0;\n        var max = 1;\n        var queue = new Queue<(TreeNode, int)>();\n        queue.Enqueue((root, 0));\n        var first = -1;\n        var last = 0;\n        var offset = 0;\n        while (queue.Count > 0)\n        {\n            var total = queue.Count;\n            for (var i = 0; i < total; i++)\n            {\n                var cur = queue.Dequeue();\n                var node = cur.Item1;\n                var idx = cur.Item2;\n                if (first < 0)\n                {\n                    offset = idx;\n                    first = 0;\n                }\n                last = idx - offset;\n\n                if (node.left != null)\n                    queue.Enqueue((node.left, last * 2 + 1));\n\n                if (node.right != null)\n                    queue.Enqueue((node.right, last * 2 + 2));\n            }\n\n            max = Math.Max(max, last - first + 1);\n            first = -1;\n            last = 0;\n        }\n        return max;\n   }\n```"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "It's weird that almost all posted solutions don't use that trick and have been submitted like an hour ago.. How come they don't fail on last test case?\nThanks for the tip!\n"
                    },
                    {
                        "username": "CHENGALLA",
                        "content": "![image](https://assets.leetcode.com/users/images/a9135f89-6e48-41b9-bf58-7ade7abc286d_1628084581.6159878.png)\\n"
                    },
                    {
                        "username": "ajz01",
                        "content": "How is the answer to this 8? There appears to be at most 4 nodes on any level (level 3 and 4 have four nodes counting the null nodes).\\n\\n[1,1,1,1,null,null,1,1,null,null,1]"
                    },
                    {
                        "username": "Maang-io",
                        "content": "seems like a tree week :-)"
                    },
                    {
                        "username": "saketthavanani",
                        "content": "![image](https://assets.leetcode.com/users/images/86bc25a0-030e-4113-a7a4-2d0ebce65ce9_1605080710.8836358.png)\\n"
                    },
                    {
                        "username": "user4796V",
                        "content": "what a waste of fucking time"
                    }
                ]
            },
            {
                "id": 1869383,
                "content": [
                    {
                        "username": "drat",
                        "content": "My solution fails at this particular testcase , any help why? \\ntest case - [-64,12,18,-4,-53,null,76,null,-51,null,null,-93,3,null,-31,47,null,3,53,-81,33,4,null,-51,-44,-60,11,null,null,null,null,78,null,-35,-64,26,-81,-31,27,60,74,null,null,8,-38,47,12,-24,null,-59,-49,-11,-51,67,null,null,null,null,null,null,null,-67,null,-37,-19,10,-55,72,null,null,null,-70,17,-4,null,null,null,null,null,null,null,3,80,44,-88,-91,null,48,-90,-30,null,null,90,-34,37,null,null,73,-38,-31,-85,-31,-96,null,null,-18,67,34,72,null,-17,-77,null,56,-65,-88,-53,null,null,null,-33,86,null,81,-42,null,null,98,-40,70,-26,24,null,null,null,null,92,72,-27,null,null,null,null,null,null,-67,null,null,null,null,null,null,null,-54,-66,-36,null,-72,null,null,43,null,null,null,-92,-1,-98,null,null,null,null,null,null,null,39,-84,null,null,null,null,null,null,null,null,null,null,null,null,null,-93,null,null,null,98]\\n\\n`class Solution {\\n    public int widthOfBinaryTree(TreeNode root) {\\n        int width = 0;\\n        Queue<Pair<TreeNode, Integer>> q = new LinkedList<>();\\n        if(root!=null) q.add(new Pair(root, 1));\\n\\n        while(!q.isEmpty()){\\n            int n = q.size();\\n            int min=5000, max=0;\\n            while(n-- > 0){\\n                Pair<TreeNode, Integer> p = q.poll();\\n                TreeNode cur = p.getKey();\\n                int pos = p.getValue(); \\n                min = Math.min(min, pos);\\n                max = Math.max(max, pos);\\n\\n                if(cur.left!=null) q.add(new Pair(cur.left, pos*2));\\n                if(cur.right!=null) q.add(new Pair(cur.right, pos*2+1));\\n            }\\n\\n            width = Math.max(width, max-min+1);\\n\\n        }\\n\\n        return width;\\n\\n    }\\n}`"
                    },
                    {
                        "username": "shreedpathaks",
                        "content": "Try with  Deque, apply bfs and check for size between two non-null nodes, return the maximum ans;\\nremove all null nodes from front till first non-null node and similarly from back, (remove all null nodes from front till first non-null node).\\ncompare the size with ans, and return max,\\ntho this approach  has TLE but u will get more clearity from this ."
                    },
                    {
                        "username": "aitachii",
                        "content": "The width of a level is the number of non-null nodes + the null nodes inbetween the non-null nodes.\nFor example 1:\nLevel 1: [1]\nhas width 1\nLevel 2: [3, 2]\nhas width 2 \nLevel 3: [5,3,X,9]\nhas width 4\n\nExample 2:\n[1] has width 1\n[3,2] has width 2\n[5,X,X,9] has width 4\n[6,X,X,X,X,X,7,X] has width 7, [6,X,X,X,X,X,7]\n\nExample 3:\n[1] has width 1\n[3,2] has width 2\n[5,X,X,X] has width 1, [5]\n\nMore examples (some random levels):\n[X,1,X,5,X] has width 3, [1,X,5]\n[X,X,1,X,X,X] has width 1, [1]\n[X,1,X,X,5,X,X,9] has width 7, [1,X,X,5,X,X,9]\n\nThe testcases can cause overflow so think of a way to solve this without counting all the nodes(both null and non-null) in a level."
                    },
                    {
                        "username": "jpvarbed",
                        "content": "Please put a note for javascript/typescript users that you need to wrap in bigint"
                    },
                    {
                        "username": "bjiang78",
                        "content": "In a full binary tree, the index calculation of left child and right child is:\n- left child index = parent index * 2 + 1\n- right child index = parent index * 2 + 2\n\nSo the basic idea is to use a queue to traverse the tree level by level, and record the difference between the most left node's index and the most right node's index, and update the max index distance for each layer.\n\nThe problem is, even with a tree with only 3000 nodes, the index difference may overflow in a int32 integer (up to 2^3000 when all the nodes are on a parent-child chain). To address this problem, one way is to use long long type. But it's not easy to scale up to a tree with more nodes. Note that the absolute value of a node's index is not important. What matters is the distance from the left most node to the right most node. So for each layer, we can reduce the index value by starting the left most node's index from 0. With this second approach, we can handle a tree up to 2,147,483,647 layers just with int32 type.\n\nC# code:\n```csharp\n    public int WidthOfBinaryTree(TreeNode root) {\n        if (root == null)\n            return 0;\n        var max = 1;\n        var queue = new Queue<(TreeNode, int)>();\n        queue.Enqueue((root, 0));\n        var first = -1;\n        var last = 0;\n        var offset = 0;\n        while (queue.Count > 0)\n        {\n            var total = queue.Count;\n            for (var i = 0; i < total; i++)\n            {\n                var cur = queue.Dequeue();\n                var node = cur.Item1;\n                var idx = cur.Item2;\n                if (first < 0)\n                {\n                    offset = idx;\n                    first = 0;\n                }\n                last = idx - offset;\n\n                if (node.left != null)\n                    queue.Enqueue((node.left, last * 2 + 1));\n\n                if (node.right != null)\n                    queue.Enqueue((node.right, last * 2 + 2));\n            }\n\n            max = Math.Max(max, last - first + 1);\n            first = -1;\n            last = 0;\n        }\n        return max;\n   }\n```"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "It's weird that almost all posted solutions don't use that trick and have been submitted like an hour ago.. How come they don't fail on last test case?\nThanks for the tip!\n"
                    },
                    {
                        "username": "CHENGALLA",
                        "content": "![image](https://assets.leetcode.com/users/images/a9135f89-6e48-41b9-bf58-7ade7abc286d_1628084581.6159878.png)\\n"
                    },
                    {
                        "username": "ajz01",
                        "content": "How is the answer to this 8? There appears to be at most 4 nodes on any level (level 3 and 4 have four nodes counting the null nodes).\\n\\n[1,1,1,1,null,null,1,1,null,null,1]"
                    },
                    {
                        "username": "Maang-io",
                        "content": "seems like a tree week :-)"
                    },
                    {
                        "username": "saketthavanani",
                        "content": "![image](https://assets.leetcode.com/users/images/86bc25a0-030e-4113-a7a4-2d0ebce65ce9_1605080710.8836358.png)\\n"
                    },
                    {
                        "username": "user4796V",
                        "content": "what a waste of fucking time"
                    }
                ]
            },
            {
                "id": 1868889,
                "content": [
                    {
                        "username": "drat",
                        "content": "My solution fails at this particular testcase , any help why? \\ntest case - [-64,12,18,-4,-53,null,76,null,-51,null,null,-93,3,null,-31,47,null,3,53,-81,33,4,null,-51,-44,-60,11,null,null,null,null,78,null,-35,-64,26,-81,-31,27,60,74,null,null,8,-38,47,12,-24,null,-59,-49,-11,-51,67,null,null,null,null,null,null,null,-67,null,-37,-19,10,-55,72,null,null,null,-70,17,-4,null,null,null,null,null,null,null,3,80,44,-88,-91,null,48,-90,-30,null,null,90,-34,37,null,null,73,-38,-31,-85,-31,-96,null,null,-18,67,34,72,null,-17,-77,null,56,-65,-88,-53,null,null,null,-33,86,null,81,-42,null,null,98,-40,70,-26,24,null,null,null,null,92,72,-27,null,null,null,null,null,null,-67,null,null,null,null,null,null,null,-54,-66,-36,null,-72,null,null,43,null,null,null,-92,-1,-98,null,null,null,null,null,null,null,39,-84,null,null,null,null,null,null,null,null,null,null,null,null,null,-93,null,null,null,98]\\n\\n`class Solution {\\n    public int widthOfBinaryTree(TreeNode root) {\\n        int width = 0;\\n        Queue<Pair<TreeNode, Integer>> q = new LinkedList<>();\\n        if(root!=null) q.add(new Pair(root, 1));\\n\\n        while(!q.isEmpty()){\\n            int n = q.size();\\n            int min=5000, max=0;\\n            while(n-- > 0){\\n                Pair<TreeNode, Integer> p = q.poll();\\n                TreeNode cur = p.getKey();\\n                int pos = p.getValue(); \\n                min = Math.min(min, pos);\\n                max = Math.max(max, pos);\\n\\n                if(cur.left!=null) q.add(new Pair(cur.left, pos*2));\\n                if(cur.right!=null) q.add(new Pair(cur.right, pos*2+1));\\n            }\\n\\n            width = Math.max(width, max-min+1);\\n\\n        }\\n\\n        return width;\\n\\n    }\\n}`"
                    },
                    {
                        "username": "shreedpathaks",
                        "content": "Try with  Deque, apply bfs and check for size between two non-null nodes, return the maximum ans;\\nremove all null nodes from front till first non-null node and similarly from back, (remove all null nodes from front till first non-null node).\\ncompare the size with ans, and return max,\\ntho this approach  has TLE but u will get more clearity from this ."
                    },
                    {
                        "username": "aitachii",
                        "content": "The width of a level is the number of non-null nodes + the null nodes inbetween the non-null nodes.\nFor example 1:\nLevel 1: [1]\nhas width 1\nLevel 2: [3, 2]\nhas width 2 \nLevel 3: [5,3,X,9]\nhas width 4\n\nExample 2:\n[1] has width 1\n[3,2] has width 2\n[5,X,X,9] has width 4\n[6,X,X,X,X,X,7,X] has width 7, [6,X,X,X,X,X,7]\n\nExample 3:\n[1] has width 1\n[3,2] has width 2\n[5,X,X,X] has width 1, [5]\n\nMore examples (some random levels):\n[X,1,X,5,X] has width 3, [1,X,5]\n[X,X,1,X,X,X] has width 1, [1]\n[X,1,X,X,5,X,X,9] has width 7, [1,X,X,5,X,X,9]\n\nThe testcases can cause overflow so think of a way to solve this without counting all the nodes(both null and non-null) in a level."
                    },
                    {
                        "username": "jpvarbed",
                        "content": "Please put a note for javascript/typescript users that you need to wrap in bigint"
                    },
                    {
                        "username": "bjiang78",
                        "content": "In a full binary tree, the index calculation of left child and right child is:\n- left child index = parent index * 2 + 1\n- right child index = parent index * 2 + 2\n\nSo the basic idea is to use a queue to traverse the tree level by level, and record the difference between the most left node's index and the most right node's index, and update the max index distance for each layer.\n\nThe problem is, even with a tree with only 3000 nodes, the index difference may overflow in a int32 integer (up to 2^3000 when all the nodes are on a parent-child chain). To address this problem, one way is to use long long type. But it's not easy to scale up to a tree with more nodes. Note that the absolute value of a node's index is not important. What matters is the distance from the left most node to the right most node. So for each layer, we can reduce the index value by starting the left most node's index from 0. With this second approach, we can handle a tree up to 2,147,483,647 layers just with int32 type.\n\nC# code:\n```csharp\n    public int WidthOfBinaryTree(TreeNode root) {\n        if (root == null)\n            return 0;\n        var max = 1;\n        var queue = new Queue<(TreeNode, int)>();\n        queue.Enqueue((root, 0));\n        var first = -1;\n        var last = 0;\n        var offset = 0;\n        while (queue.Count > 0)\n        {\n            var total = queue.Count;\n            for (var i = 0; i < total; i++)\n            {\n                var cur = queue.Dequeue();\n                var node = cur.Item1;\n                var idx = cur.Item2;\n                if (first < 0)\n                {\n                    offset = idx;\n                    first = 0;\n                }\n                last = idx - offset;\n\n                if (node.left != null)\n                    queue.Enqueue((node.left, last * 2 + 1));\n\n                if (node.right != null)\n                    queue.Enqueue((node.right, last * 2 + 2));\n            }\n\n            max = Math.Max(max, last - first + 1);\n            first = -1;\n            last = 0;\n        }\n        return max;\n   }\n```"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "It's weird that almost all posted solutions don't use that trick and have been submitted like an hour ago.. How come they don't fail on last test case?\nThanks for the tip!\n"
                    },
                    {
                        "username": "CHENGALLA",
                        "content": "![image](https://assets.leetcode.com/users/images/a9135f89-6e48-41b9-bf58-7ade7abc286d_1628084581.6159878.png)\\n"
                    },
                    {
                        "username": "ajz01",
                        "content": "How is the answer to this 8? There appears to be at most 4 nodes on any level (level 3 and 4 have four nodes counting the null nodes).\\n\\n[1,1,1,1,null,null,1,1,null,null,1]"
                    },
                    {
                        "username": "Maang-io",
                        "content": "seems like a tree week :-)"
                    },
                    {
                        "username": "saketthavanani",
                        "content": "![image](https://assets.leetcode.com/users/images/86bc25a0-030e-4113-a7a4-2d0ebce65ce9_1605080710.8836358.png)\\n"
                    },
                    {
                        "username": "user4796V",
                        "content": "what a waste of fucking time"
                    }
                ]
            },
            {
                "id": 1865795,
                "content": [
                    {
                        "username": "drat",
                        "content": "My solution fails at this particular testcase , any help why? \\ntest case - [-64,12,18,-4,-53,null,76,null,-51,null,null,-93,3,null,-31,47,null,3,53,-81,33,4,null,-51,-44,-60,11,null,null,null,null,78,null,-35,-64,26,-81,-31,27,60,74,null,null,8,-38,47,12,-24,null,-59,-49,-11,-51,67,null,null,null,null,null,null,null,-67,null,-37,-19,10,-55,72,null,null,null,-70,17,-4,null,null,null,null,null,null,null,3,80,44,-88,-91,null,48,-90,-30,null,null,90,-34,37,null,null,73,-38,-31,-85,-31,-96,null,null,-18,67,34,72,null,-17,-77,null,56,-65,-88,-53,null,null,null,-33,86,null,81,-42,null,null,98,-40,70,-26,24,null,null,null,null,92,72,-27,null,null,null,null,null,null,-67,null,null,null,null,null,null,null,-54,-66,-36,null,-72,null,null,43,null,null,null,-92,-1,-98,null,null,null,null,null,null,null,39,-84,null,null,null,null,null,null,null,null,null,null,null,null,null,-93,null,null,null,98]\\n\\n`class Solution {\\n    public int widthOfBinaryTree(TreeNode root) {\\n        int width = 0;\\n        Queue<Pair<TreeNode, Integer>> q = new LinkedList<>();\\n        if(root!=null) q.add(new Pair(root, 1));\\n\\n        while(!q.isEmpty()){\\n            int n = q.size();\\n            int min=5000, max=0;\\n            while(n-- > 0){\\n                Pair<TreeNode, Integer> p = q.poll();\\n                TreeNode cur = p.getKey();\\n                int pos = p.getValue(); \\n                min = Math.min(min, pos);\\n                max = Math.max(max, pos);\\n\\n                if(cur.left!=null) q.add(new Pair(cur.left, pos*2));\\n                if(cur.right!=null) q.add(new Pair(cur.right, pos*2+1));\\n            }\\n\\n            width = Math.max(width, max-min+1);\\n\\n        }\\n\\n        return width;\\n\\n    }\\n}`"
                    },
                    {
                        "username": "shreedpathaks",
                        "content": "Try with  Deque, apply bfs and check for size between two non-null nodes, return the maximum ans;\\nremove all null nodes from front till first non-null node and similarly from back, (remove all null nodes from front till first non-null node).\\ncompare the size with ans, and return max,\\ntho this approach  has TLE but u will get more clearity from this ."
                    },
                    {
                        "username": "aitachii",
                        "content": "The width of a level is the number of non-null nodes + the null nodes inbetween the non-null nodes.\nFor example 1:\nLevel 1: [1]\nhas width 1\nLevel 2: [3, 2]\nhas width 2 \nLevel 3: [5,3,X,9]\nhas width 4\n\nExample 2:\n[1] has width 1\n[3,2] has width 2\n[5,X,X,9] has width 4\n[6,X,X,X,X,X,7,X] has width 7, [6,X,X,X,X,X,7]\n\nExample 3:\n[1] has width 1\n[3,2] has width 2\n[5,X,X,X] has width 1, [5]\n\nMore examples (some random levels):\n[X,1,X,5,X] has width 3, [1,X,5]\n[X,X,1,X,X,X] has width 1, [1]\n[X,1,X,X,5,X,X,9] has width 7, [1,X,X,5,X,X,9]\n\nThe testcases can cause overflow so think of a way to solve this without counting all the nodes(both null and non-null) in a level."
                    },
                    {
                        "username": "jpvarbed",
                        "content": "Please put a note for javascript/typescript users that you need to wrap in bigint"
                    },
                    {
                        "username": "bjiang78",
                        "content": "In a full binary tree, the index calculation of left child and right child is:\n- left child index = parent index * 2 + 1\n- right child index = parent index * 2 + 2\n\nSo the basic idea is to use a queue to traverse the tree level by level, and record the difference between the most left node's index and the most right node's index, and update the max index distance for each layer.\n\nThe problem is, even with a tree with only 3000 nodes, the index difference may overflow in a int32 integer (up to 2^3000 when all the nodes are on a parent-child chain). To address this problem, one way is to use long long type. But it's not easy to scale up to a tree with more nodes. Note that the absolute value of a node's index is not important. What matters is the distance from the left most node to the right most node. So for each layer, we can reduce the index value by starting the left most node's index from 0. With this second approach, we can handle a tree up to 2,147,483,647 layers just with int32 type.\n\nC# code:\n```csharp\n    public int WidthOfBinaryTree(TreeNode root) {\n        if (root == null)\n            return 0;\n        var max = 1;\n        var queue = new Queue<(TreeNode, int)>();\n        queue.Enqueue((root, 0));\n        var first = -1;\n        var last = 0;\n        var offset = 0;\n        while (queue.Count > 0)\n        {\n            var total = queue.Count;\n            for (var i = 0; i < total; i++)\n            {\n                var cur = queue.Dequeue();\n                var node = cur.Item1;\n                var idx = cur.Item2;\n                if (first < 0)\n                {\n                    offset = idx;\n                    first = 0;\n                }\n                last = idx - offset;\n\n                if (node.left != null)\n                    queue.Enqueue((node.left, last * 2 + 1));\n\n                if (node.right != null)\n                    queue.Enqueue((node.right, last * 2 + 2));\n            }\n\n            max = Math.Max(max, last - first + 1);\n            first = -1;\n            last = 0;\n        }\n        return max;\n   }\n```"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "It's weird that almost all posted solutions don't use that trick and have been submitted like an hour ago.. How come they don't fail on last test case?\nThanks for the tip!\n"
                    },
                    {
                        "username": "CHENGALLA",
                        "content": "![image](https://assets.leetcode.com/users/images/a9135f89-6e48-41b9-bf58-7ade7abc286d_1628084581.6159878.png)\\n"
                    },
                    {
                        "username": "ajz01",
                        "content": "How is the answer to this 8? There appears to be at most 4 nodes on any level (level 3 and 4 have four nodes counting the null nodes).\\n\\n[1,1,1,1,null,null,1,1,null,null,1]"
                    },
                    {
                        "username": "Maang-io",
                        "content": "seems like a tree week :-)"
                    },
                    {
                        "username": "saketthavanani",
                        "content": "![image](https://assets.leetcode.com/users/images/86bc25a0-030e-4113-a7a4-2d0ebce65ce9_1605080710.8836358.png)\\n"
                    },
                    {
                        "username": "user4796V",
                        "content": "what a waste of fucking time"
                    }
                ]
            },
            {
                "id": 1625071,
                "content": [
                    {
                        "username": "drat",
                        "content": "My solution fails at this particular testcase , any help why? \\ntest case - [-64,12,18,-4,-53,null,76,null,-51,null,null,-93,3,null,-31,47,null,3,53,-81,33,4,null,-51,-44,-60,11,null,null,null,null,78,null,-35,-64,26,-81,-31,27,60,74,null,null,8,-38,47,12,-24,null,-59,-49,-11,-51,67,null,null,null,null,null,null,null,-67,null,-37,-19,10,-55,72,null,null,null,-70,17,-4,null,null,null,null,null,null,null,3,80,44,-88,-91,null,48,-90,-30,null,null,90,-34,37,null,null,73,-38,-31,-85,-31,-96,null,null,-18,67,34,72,null,-17,-77,null,56,-65,-88,-53,null,null,null,-33,86,null,81,-42,null,null,98,-40,70,-26,24,null,null,null,null,92,72,-27,null,null,null,null,null,null,-67,null,null,null,null,null,null,null,-54,-66,-36,null,-72,null,null,43,null,null,null,-92,-1,-98,null,null,null,null,null,null,null,39,-84,null,null,null,null,null,null,null,null,null,null,null,null,null,-93,null,null,null,98]\\n\\n`class Solution {\\n    public int widthOfBinaryTree(TreeNode root) {\\n        int width = 0;\\n        Queue<Pair<TreeNode, Integer>> q = new LinkedList<>();\\n        if(root!=null) q.add(new Pair(root, 1));\\n\\n        while(!q.isEmpty()){\\n            int n = q.size();\\n            int min=5000, max=0;\\n            while(n-- > 0){\\n                Pair<TreeNode, Integer> p = q.poll();\\n                TreeNode cur = p.getKey();\\n                int pos = p.getValue(); \\n                min = Math.min(min, pos);\\n                max = Math.max(max, pos);\\n\\n                if(cur.left!=null) q.add(new Pair(cur.left, pos*2));\\n                if(cur.right!=null) q.add(new Pair(cur.right, pos*2+1));\\n            }\\n\\n            width = Math.max(width, max-min+1);\\n\\n        }\\n\\n        return width;\\n\\n    }\\n}`"
                    },
                    {
                        "username": "shreedpathaks",
                        "content": "Try with  Deque, apply bfs and check for size between two non-null nodes, return the maximum ans;\\nremove all null nodes from front till first non-null node and similarly from back, (remove all null nodes from front till first non-null node).\\ncompare the size with ans, and return max,\\ntho this approach  has TLE but u will get more clearity from this ."
                    },
                    {
                        "username": "aitachii",
                        "content": "The width of a level is the number of non-null nodes + the null nodes inbetween the non-null nodes.\nFor example 1:\nLevel 1: [1]\nhas width 1\nLevel 2: [3, 2]\nhas width 2 \nLevel 3: [5,3,X,9]\nhas width 4\n\nExample 2:\n[1] has width 1\n[3,2] has width 2\n[5,X,X,9] has width 4\n[6,X,X,X,X,X,7,X] has width 7, [6,X,X,X,X,X,7]\n\nExample 3:\n[1] has width 1\n[3,2] has width 2\n[5,X,X,X] has width 1, [5]\n\nMore examples (some random levels):\n[X,1,X,5,X] has width 3, [1,X,5]\n[X,X,1,X,X,X] has width 1, [1]\n[X,1,X,X,5,X,X,9] has width 7, [1,X,X,5,X,X,9]\n\nThe testcases can cause overflow so think of a way to solve this without counting all the nodes(both null and non-null) in a level."
                    },
                    {
                        "username": "jpvarbed",
                        "content": "Please put a note for javascript/typescript users that you need to wrap in bigint"
                    },
                    {
                        "username": "bjiang78",
                        "content": "In a full binary tree, the index calculation of left child and right child is:\n- left child index = parent index * 2 + 1\n- right child index = parent index * 2 + 2\n\nSo the basic idea is to use a queue to traverse the tree level by level, and record the difference between the most left node's index and the most right node's index, and update the max index distance for each layer.\n\nThe problem is, even with a tree with only 3000 nodes, the index difference may overflow in a int32 integer (up to 2^3000 when all the nodes are on a parent-child chain). To address this problem, one way is to use long long type. But it's not easy to scale up to a tree with more nodes. Note that the absolute value of a node's index is not important. What matters is the distance from the left most node to the right most node. So for each layer, we can reduce the index value by starting the left most node's index from 0. With this second approach, we can handle a tree up to 2,147,483,647 layers just with int32 type.\n\nC# code:\n```csharp\n    public int WidthOfBinaryTree(TreeNode root) {\n        if (root == null)\n            return 0;\n        var max = 1;\n        var queue = new Queue<(TreeNode, int)>();\n        queue.Enqueue((root, 0));\n        var first = -1;\n        var last = 0;\n        var offset = 0;\n        while (queue.Count > 0)\n        {\n            var total = queue.Count;\n            for (var i = 0; i < total; i++)\n            {\n                var cur = queue.Dequeue();\n                var node = cur.Item1;\n                var idx = cur.Item2;\n                if (first < 0)\n                {\n                    offset = idx;\n                    first = 0;\n                }\n                last = idx - offset;\n\n                if (node.left != null)\n                    queue.Enqueue((node.left, last * 2 + 1));\n\n                if (node.right != null)\n                    queue.Enqueue((node.right, last * 2 + 2));\n            }\n\n            max = Math.Max(max, last - first + 1);\n            first = -1;\n            last = 0;\n        }\n        return max;\n   }\n```"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "It's weird that almost all posted solutions don't use that trick and have been submitted like an hour ago.. How come they don't fail on last test case?\nThanks for the tip!\n"
                    },
                    {
                        "username": "CHENGALLA",
                        "content": "![image](https://assets.leetcode.com/users/images/a9135f89-6e48-41b9-bf58-7ade7abc286d_1628084581.6159878.png)\\n"
                    },
                    {
                        "username": "ajz01",
                        "content": "How is the answer to this 8? There appears to be at most 4 nodes on any level (level 3 and 4 have four nodes counting the null nodes).\\n\\n[1,1,1,1,null,null,1,1,null,null,1]"
                    },
                    {
                        "username": "Maang-io",
                        "content": "seems like a tree week :-)"
                    },
                    {
                        "username": "saketthavanani",
                        "content": "![image](https://assets.leetcode.com/users/images/86bc25a0-030e-4113-a7a4-2d0ebce65ce9_1605080710.8836358.png)\\n"
                    },
                    {
                        "username": "user4796V",
                        "content": "what a waste of fucking time"
                    }
                ]
            },
            {
                "id": 1575611,
                "content": [
                    {
                        "username": "drat",
                        "content": "My solution fails at this particular testcase , any help why? \\ntest case - [-64,12,18,-4,-53,null,76,null,-51,null,null,-93,3,null,-31,47,null,3,53,-81,33,4,null,-51,-44,-60,11,null,null,null,null,78,null,-35,-64,26,-81,-31,27,60,74,null,null,8,-38,47,12,-24,null,-59,-49,-11,-51,67,null,null,null,null,null,null,null,-67,null,-37,-19,10,-55,72,null,null,null,-70,17,-4,null,null,null,null,null,null,null,3,80,44,-88,-91,null,48,-90,-30,null,null,90,-34,37,null,null,73,-38,-31,-85,-31,-96,null,null,-18,67,34,72,null,-17,-77,null,56,-65,-88,-53,null,null,null,-33,86,null,81,-42,null,null,98,-40,70,-26,24,null,null,null,null,92,72,-27,null,null,null,null,null,null,-67,null,null,null,null,null,null,null,-54,-66,-36,null,-72,null,null,43,null,null,null,-92,-1,-98,null,null,null,null,null,null,null,39,-84,null,null,null,null,null,null,null,null,null,null,null,null,null,-93,null,null,null,98]\\n\\n`class Solution {\\n    public int widthOfBinaryTree(TreeNode root) {\\n        int width = 0;\\n        Queue<Pair<TreeNode, Integer>> q = new LinkedList<>();\\n        if(root!=null) q.add(new Pair(root, 1));\\n\\n        while(!q.isEmpty()){\\n            int n = q.size();\\n            int min=5000, max=0;\\n            while(n-- > 0){\\n                Pair<TreeNode, Integer> p = q.poll();\\n                TreeNode cur = p.getKey();\\n                int pos = p.getValue(); \\n                min = Math.min(min, pos);\\n                max = Math.max(max, pos);\\n\\n                if(cur.left!=null) q.add(new Pair(cur.left, pos*2));\\n                if(cur.right!=null) q.add(new Pair(cur.right, pos*2+1));\\n            }\\n\\n            width = Math.max(width, max-min+1);\\n\\n        }\\n\\n        return width;\\n\\n    }\\n}`"
                    },
                    {
                        "username": "shreedpathaks",
                        "content": "Try with  Deque, apply bfs and check for size between two non-null nodes, return the maximum ans;\\nremove all null nodes from front till first non-null node and similarly from back, (remove all null nodes from front till first non-null node).\\ncompare the size with ans, and return max,\\ntho this approach  has TLE but u will get more clearity from this ."
                    },
                    {
                        "username": "aitachii",
                        "content": "The width of a level is the number of non-null nodes + the null nodes inbetween the non-null nodes.\nFor example 1:\nLevel 1: [1]\nhas width 1\nLevel 2: [3, 2]\nhas width 2 \nLevel 3: [5,3,X,9]\nhas width 4\n\nExample 2:\n[1] has width 1\n[3,2] has width 2\n[5,X,X,9] has width 4\n[6,X,X,X,X,X,7,X] has width 7, [6,X,X,X,X,X,7]\n\nExample 3:\n[1] has width 1\n[3,2] has width 2\n[5,X,X,X] has width 1, [5]\n\nMore examples (some random levels):\n[X,1,X,5,X] has width 3, [1,X,5]\n[X,X,1,X,X,X] has width 1, [1]\n[X,1,X,X,5,X,X,9] has width 7, [1,X,X,5,X,X,9]\n\nThe testcases can cause overflow so think of a way to solve this without counting all the nodes(both null and non-null) in a level."
                    },
                    {
                        "username": "jpvarbed",
                        "content": "Please put a note for javascript/typescript users that you need to wrap in bigint"
                    },
                    {
                        "username": "bjiang78",
                        "content": "In a full binary tree, the index calculation of left child and right child is:\n- left child index = parent index * 2 + 1\n- right child index = parent index * 2 + 2\n\nSo the basic idea is to use a queue to traverse the tree level by level, and record the difference between the most left node's index and the most right node's index, and update the max index distance for each layer.\n\nThe problem is, even with a tree with only 3000 nodes, the index difference may overflow in a int32 integer (up to 2^3000 when all the nodes are on a parent-child chain). To address this problem, one way is to use long long type. But it's not easy to scale up to a tree with more nodes. Note that the absolute value of a node's index is not important. What matters is the distance from the left most node to the right most node. So for each layer, we can reduce the index value by starting the left most node's index from 0. With this second approach, we can handle a tree up to 2,147,483,647 layers just with int32 type.\n\nC# code:\n```csharp\n    public int WidthOfBinaryTree(TreeNode root) {\n        if (root == null)\n            return 0;\n        var max = 1;\n        var queue = new Queue<(TreeNode, int)>();\n        queue.Enqueue((root, 0));\n        var first = -1;\n        var last = 0;\n        var offset = 0;\n        while (queue.Count > 0)\n        {\n            var total = queue.Count;\n            for (var i = 0; i < total; i++)\n            {\n                var cur = queue.Dequeue();\n                var node = cur.Item1;\n                var idx = cur.Item2;\n                if (first < 0)\n                {\n                    offset = idx;\n                    first = 0;\n                }\n                last = idx - offset;\n\n                if (node.left != null)\n                    queue.Enqueue((node.left, last * 2 + 1));\n\n                if (node.right != null)\n                    queue.Enqueue((node.right, last * 2 + 2));\n            }\n\n            max = Math.Max(max, last - first + 1);\n            first = -1;\n            last = 0;\n        }\n        return max;\n   }\n```"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "It's weird that almost all posted solutions don't use that trick and have been submitted like an hour ago.. How come they don't fail on last test case?\nThanks for the tip!\n"
                    },
                    {
                        "username": "CHENGALLA",
                        "content": "![image](https://assets.leetcode.com/users/images/a9135f89-6e48-41b9-bf58-7ade7abc286d_1628084581.6159878.png)\\n"
                    },
                    {
                        "username": "ajz01",
                        "content": "How is the answer to this 8? There appears to be at most 4 nodes on any level (level 3 and 4 have four nodes counting the null nodes).\\n\\n[1,1,1,1,null,null,1,1,null,null,1]"
                    },
                    {
                        "username": "Maang-io",
                        "content": "seems like a tree week :-)"
                    },
                    {
                        "username": "saketthavanani",
                        "content": "![image](https://assets.leetcode.com/users/images/86bc25a0-030e-4113-a7a4-2d0ebce65ce9_1605080710.8836358.png)\\n"
                    },
                    {
                        "username": "user4796V",
                        "content": "what a waste of fucking time"
                    }
                ]
            },
            {
                "id": 1574254,
                "content": [
                    {
                        "username": "drat",
                        "content": "My solution fails at this particular testcase , any help why? \\ntest case - [-64,12,18,-4,-53,null,76,null,-51,null,null,-93,3,null,-31,47,null,3,53,-81,33,4,null,-51,-44,-60,11,null,null,null,null,78,null,-35,-64,26,-81,-31,27,60,74,null,null,8,-38,47,12,-24,null,-59,-49,-11,-51,67,null,null,null,null,null,null,null,-67,null,-37,-19,10,-55,72,null,null,null,-70,17,-4,null,null,null,null,null,null,null,3,80,44,-88,-91,null,48,-90,-30,null,null,90,-34,37,null,null,73,-38,-31,-85,-31,-96,null,null,-18,67,34,72,null,-17,-77,null,56,-65,-88,-53,null,null,null,-33,86,null,81,-42,null,null,98,-40,70,-26,24,null,null,null,null,92,72,-27,null,null,null,null,null,null,-67,null,null,null,null,null,null,null,-54,-66,-36,null,-72,null,null,43,null,null,null,-92,-1,-98,null,null,null,null,null,null,null,39,-84,null,null,null,null,null,null,null,null,null,null,null,null,null,-93,null,null,null,98]\\n\\n`class Solution {\\n    public int widthOfBinaryTree(TreeNode root) {\\n        int width = 0;\\n        Queue<Pair<TreeNode, Integer>> q = new LinkedList<>();\\n        if(root!=null) q.add(new Pair(root, 1));\\n\\n        while(!q.isEmpty()){\\n            int n = q.size();\\n            int min=5000, max=0;\\n            while(n-- > 0){\\n                Pair<TreeNode, Integer> p = q.poll();\\n                TreeNode cur = p.getKey();\\n                int pos = p.getValue(); \\n                min = Math.min(min, pos);\\n                max = Math.max(max, pos);\\n\\n                if(cur.left!=null) q.add(new Pair(cur.left, pos*2));\\n                if(cur.right!=null) q.add(new Pair(cur.right, pos*2+1));\\n            }\\n\\n            width = Math.max(width, max-min+1);\\n\\n        }\\n\\n        return width;\\n\\n    }\\n}`"
                    },
                    {
                        "username": "shreedpathaks",
                        "content": "Try with  Deque, apply bfs and check for size between two non-null nodes, return the maximum ans;\\nremove all null nodes from front till first non-null node and similarly from back, (remove all null nodes from front till first non-null node).\\ncompare the size with ans, and return max,\\ntho this approach  has TLE but u will get more clearity from this ."
                    },
                    {
                        "username": "aitachii",
                        "content": "The width of a level is the number of non-null nodes + the null nodes inbetween the non-null nodes.\nFor example 1:\nLevel 1: [1]\nhas width 1\nLevel 2: [3, 2]\nhas width 2 \nLevel 3: [5,3,X,9]\nhas width 4\n\nExample 2:\n[1] has width 1\n[3,2] has width 2\n[5,X,X,9] has width 4\n[6,X,X,X,X,X,7,X] has width 7, [6,X,X,X,X,X,7]\n\nExample 3:\n[1] has width 1\n[3,2] has width 2\n[5,X,X,X] has width 1, [5]\n\nMore examples (some random levels):\n[X,1,X,5,X] has width 3, [1,X,5]\n[X,X,1,X,X,X] has width 1, [1]\n[X,1,X,X,5,X,X,9] has width 7, [1,X,X,5,X,X,9]\n\nThe testcases can cause overflow so think of a way to solve this without counting all the nodes(both null and non-null) in a level."
                    },
                    {
                        "username": "jpvarbed",
                        "content": "Please put a note for javascript/typescript users that you need to wrap in bigint"
                    },
                    {
                        "username": "bjiang78",
                        "content": "In a full binary tree, the index calculation of left child and right child is:\n- left child index = parent index * 2 + 1\n- right child index = parent index * 2 + 2\n\nSo the basic idea is to use a queue to traverse the tree level by level, and record the difference between the most left node's index and the most right node's index, and update the max index distance for each layer.\n\nThe problem is, even with a tree with only 3000 nodes, the index difference may overflow in a int32 integer (up to 2^3000 when all the nodes are on a parent-child chain). To address this problem, one way is to use long long type. But it's not easy to scale up to a tree with more nodes. Note that the absolute value of a node's index is not important. What matters is the distance from the left most node to the right most node. So for each layer, we can reduce the index value by starting the left most node's index from 0. With this second approach, we can handle a tree up to 2,147,483,647 layers just with int32 type.\n\nC# code:\n```csharp\n    public int WidthOfBinaryTree(TreeNode root) {\n        if (root == null)\n            return 0;\n        var max = 1;\n        var queue = new Queue<(TreeNode, int)>();\n        queue.Enqueue((root, 0));\n        var first = -1;\n        var last = 0;\n        var offset = 0;\n        while (queue.Count > 0)\n        {\n            var total = queue.Count;\n            for (var i = 0; i < total; i++)\n            {\n                var cur = queue.Dequeue();\n                var node = cur.Item1;\n                var idx = cur.Item2;\n                if (first < 0)\n                {\n                    offset = idx;\n                    first = 0;\n                }\n                last = idx - offset;\n\n                if (node.left != null)\n                    queue.Enqueue((node.left, last * 2 + 1));\n\n                if (node.right != null)\n                    queue.Enqueue((node.right, last * 2 + 2));\n            }\n\n            max = Math.Max(max, last - first + 1);\n            first = -1;\n            last = 0;\n        }\n        return max;\n   }\n```"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "It's weird that almost all posted solutions don't use that trick and have been submitted like an hour ago.. How come they don't fail on last test case?\nThanks for the tip!\n"
                    },
                    {
                        "username": "CHENGALLA",
                        "content": "![image](https://assets.leetcode.com/users/images/a9135f89-6e48-41b9-bf58-7ade7abc286d_1628084581.6159878.png)\\n"
                    },
                    {
                        "username": "ajz01",
                        "content": "How is the answer to this 8? There appears to be at most 4 nodes on any level (level 3 and 4 have four nodes counting the null nodes).\\n\\n[1,1,1,1,null,null,1,1,null,null,1]"
                    },
                    {
                        "username": "Maang-io",
                        "content": "seems like a tree week :-)"
                    },
                    {
                        "username": "saketthavanani",
                        "content": "![image](https://assets.leetcode.com/users/images/86bc25a0-030e-4113-a7a4-2d0ebce65ce9_1605080710.8836358.png)\\n"
                    },
                    {
                        "username": "user4796V",
                        "content": "what a waste of fucking time"
                    }
                ]
            },
            {
                "id": 1868813,
                "content": [
                    {
                        "username": "drat",
                        "content": "My solution fails at this particular testcase , any help why? \\ntest case - [-64,12,18,-4,-53,null,76,null,-51,null,null,-93,3,null,-31,47,null,3,53,-81,33,4,null,-51,-44,-60,11,null,null,null,null,78,null,-35,-64,26,-81,-31,27,60,74,null,null,8,-38,47,12,-24,null,-59,-49,-11,-51,67,null,null,null,null,null,null,null,-67,null,-37,-19,10,-55,72,null,null,null,-70,17,-4,null,null,null,null,null,null,null,3,80,44,-88,-91,null,48,-90,-30,null,null,90,-34,37,null,null,73,-38,-31,-85,-31,-96,null,null,-18,67,34,72,null,-17,-77,null,56,-65,-88,-53,null,null,null,-33,86,null,81,-42,null,null,98,-40,70,-26,24,null,null,null,null,92,72,-27,null,null,null,null,null,null,-67,null,null,null,null,null,null,null,-54,-66,-36,null,-72,null,null,43,null,null,null,-92,-1,-98,null,null,null,null,null,null,null,39,-84,null,null,null,null,null,null,null,null,null,null,null,null,null,-93,null,null,null,98]\\n\\n`class Solution {\\n    public int widthOfBinaryTree(TreeNode root) {\\n        int width = 0;\\n        Queue<Pair<TreeNode, Integer>> q = new LinkedList<>();\\n        if(root!=null) q.add(new Pair(root, 1));\\n\\n        while(!q.isEmpty()){\\n            int n = q.size();\\n            int min=5000, max=0;\\n            while(n-- > 0){\\n                Pair<TreeNode, Integer> p = q.poll();\\n                TreeNode cur = p.getKey();\\n                int pos = p.getValue(); \\n                min = Math.min(min, pos);\\n                max = Math.max(max, pos);\\n\\n                if(cur.left!=null) q.add(new Pair(cur.left, pos*2));\\n                if(cur.right!=null) q.add(new Pair(cur.right, pos*2+1));\\n            }\\n\\n            width = Math.max(width, max-min+1);\\n\\n        }\\n\\n        return width;\\n\\n    }\\n}`"
                    },
                    {
                        "username": "shreedpathaks",
                        "content": "Try with  Deque, apply bfs and check for size between two non-null nodes, return the maximum ans;\\nremove all null nodes from front till first non-null node and similarly from back, (remove all null nodes from front till first non-null node).\\ncompare the size with ans, and return max,\\ntho this approach  has TLE but u will get more clearity from this ."
                    },
                    {
                        "username": "aitachii",
                        "content": "The width of a level is the number of non-null nodes + the null nodes inbetween the non-null nodes.\nFor example 1:\nLevel 1: [1]\nhas width 1\nLevel 2: [3, 2]\nhas width 2 \nLevel 3: [5,3,X,9]\nhas width 4\n\nExample 2:\n[1] has width 1\n[3,2] has width 2\n[5,X,X,9] has width 4\n[6,X,X,X,X,X,7,X] has width 7, [6,X,X,X,X,X,7]\n\nExample 3:\n[1] has width 1\n[3,2] has width 2\n[5,X,X,X] has width 1, [5]\n\nMore examples (some random levels):\n[X,1,X,5,X] has width 3, [1,X,5]\n[X,X,1,X,X,X] has width 1, [1]\n[X,1,X,X,5,X,X,9] has width 7, [1,X,X,5,X,X,9]\n\nThe testcases can cause overflow so think of a way to solve this without counting all the nodes(both null and non-null) in a level."
                    },
                    {
                        "username": "jpvarbed",
                        "content": "Please put a note for javascript/typescript users that you need to wrap in bigint"
                    },
                    {
                        "username": "bjiang78",
                        "content": "In a full binary tree, the index calculation of left child and right child is:\n- left child index = parent index * 2 + 1\n- right child index = parent index * 2 + 2\n\nSo the basic idea is to use a queue to traverse the tree level by level, and record the difference between the most left node's index and the most right node's index, and update the max index distance for each layer.\n\nThe problem is, even with a tree with only 3000 nodes, the index difference may overflow in a int32 integer (up to 2^3000 when all the nodes are on a parent-child chain). To address this problem, one way is to use long long type. But it's not easy to scale up to a tree with more nodes. Note that the absolute value of a node's index is not important. What matters is the distance from the left most node to the right most node. So for each layer, we can reduce the index value by starting the left most node's index from 0. With this second approach, we can handle a tree up to 2,147,483,647 layers just with int32 type.\n\nC# code:\n```csharp\n    public int WidthOfBinaryTree(TreeNode root) {\n        if (root == null)\n            return 0;\n        var max = 1;\n        var queue = new Queue<(TreeNode, int)>();\n        queue.Enqueue((root, 0));\n        var first = -1;\n        var last = 0;\n        var offset = 0;\n        while (queue.Count > 0)\n        {\n            var total = queue.Count;\n            for (var i = 0; i < total; i++)\n            {\n                var cur = queue.Dequeue();\n                var node = cur.Item1;\n                var idx = cur.Item2;\n                if (first < 0)\n                {\n                    offset = idx;\n                    first = 0;\n                }\n                last = idx - offset;\n\n                if (node.left != null)\n                    queue.Enqueue((node.left, last * 2 + 1));\n\n                if (node.right != null)\n                    queue.Enqueue((node.right, last * 2 + 2));\n            }\n\n            max = Math.Max(max, last - first + 1);\n            first = -1;\n            last = 0;\n        }\n        return max;\n   }\n```"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "It's weird that almost all posted solutions don't use that trick and have been submitted like an hour ago.. How come they don't fail on last test case?\nThanks for the tip!\n"
                    },
                    {
                        "username": "CHENGALLA",
                        "content": "![image](https://assets.leetcode.com/users/images/a9135f89-6e48-41b9-bf58-7ade7abc286d_1628084581.6159878.png)\\n"
                    },
                    {
                        "username": "ajz01",
                        "content": "How is the answer to this 8? There appears to be at most 4 nodes on any level (level 3 and 4 have four nodes counting the null nodes).\\n\\n[1,1,1,1,null,null,1,1,null,null,1]"
                    },
                    {
                        "username": "Maang-io",
                        "content": "seems like a tree week :-)"
                    },
                    {
                        "username": "saketthavanani",
                        "content": "![image](https://assets.leetcode.com/users/images/86bc25a0-030e-4113-a7a4-2d0ebce65ce9_1605080710.8836358.png)\\n"
                    },
                    {
                        "username": "user4796V",
                        "content": "what a waste of fucking time"
                    }
                ]
            },
            {
                "id": 1574593,
                "content": [
                    {
                        "username": "drat",
                        "content": "My solution fails at this particular testcase , any help why? \\ntest case - [-64,12,18,-4,-53,null,76,null,-51,null,null,-93,3,null,-31,47,null,3,53,-81,33,4,null,-51,-44,-60,11,null,null,null,null,78,null,-35,-64,26,-81,-31,27,60,74,null,null,8,-38,47,12,-24,null,-59,-49,-11,-51,67,null,null,null,null,null,null,null,-67,null,-37,-19,10,-55,72,null,null,null,-70,17,-4,null,null,null,null,null,null,null,3,80,44,-88,-91,null,48,-90,-30,null,null,90,-34,37,null,null,73,-38,-31,-85,-31,-96,null,null,-18,67,34,72,null,-17,-77,null,56,-65,-88,-53,null,null,null,-33,86,null,81,-42,null,null,98,-40,70,-26,24,null,null,null,null,92,72,-27,null,null,null,null,null,null,-67,null,null,null,null,null,null,null,-54,-66,-36,null,-72,null,null,43,null,null,null,-92,-1,-98,null,null,null,null,null,null,null,39,-84,null,null,null,null,null,null,null,null,null,null,null,null,null,-93,null,null,null,98]\\n\\n`class Solution {\\n    public int widthOfBinaryTree(TreeNode root) {\\n        int width = 0;\\n        Queue<Pair<TreeNode, Integer>> q = new LinkedList<>();\\n        if(root!=null) q.add(new Pair(root, 1));\\n\\n        while(!q.isEmpty()){\\n            int n = q.size();\\n            int min=5000, max=0;\\n            while(n-- > 0){\\n                Pair<TreeNode, Integer> p = q.poll();\\n                TreeNode cur = p.getKey();\\n                int pos = p.getValue(); \\n                min = Math.min(min, pos);\\n                max = Math.max(max, pos);\\n\\n                if(cur.left!=null) q.add(new Pair(cur.left, pos*2));\\n                if(cur.right!=null) q.add(new Pair(cur.right, pos*2+1));\\n            }\\n\\n            width = Math.max(width, max-min+1);\\n\\n        }\\n\\n        return width;\\n\\n    }\\n}`"
                    },
                    {
                        "username": "shreedpathaks",
                        "content": "Try with  Deque, apply bfs and check for size between two non-null nodes, return the maximum ans;\\nremove all null nodes from front till first non-null node and similarly from back, (remove all null nodes from front till first non-null node).\\ncompare the size with ans, and return max,\\ntho this approach  has TLE but u will get more clearity from this ."
                    },
                    {
                        "username": "aitachii",
                        "content": "The width of a level is the number of non-null nodes + the null nodes inbetween the non-null nodes.\nFor example 1:\nLevel 1: [1]\nhas width 1\nLevel 2: [3, 2]\nhas width 2 \nLevel 3: [5,3,X,9]\nhas width 4\n\nExample 2:\n[1] has width 1\n[3,2] has width 2\n[5,X,X,9] has width 4\n[6,X,X,X,X,X,7,X] has width 7, [6,X,X,X,X,X,7]\n\nExample 3:\n[1] has width 1\n[3,2] has width 2\n[5,X,X,X] has width 1, [5]\n\nMore examples (some random levels):\n[X,1,X,5,X] has width 3, [1,X,5]\n[X,X,1,X,X,X] has width 1, [1]\n[X,1,X,X,5,X,X,9] has width 7, [1,X,X,5,X,X,9]\n\nThe testcases can cause overflow so think of a way to solve this without counting all the nodes(both null and non-null) in a level."
                    },
                    {
                        "username": "jpvarbed",
                        "content": "Please put a note for javascript/typescript users that you need to wrap in bigint"
                    },
                    {
                        "username": "bjiang78",
                        "content": "In a full binary tree, the index calculation of left child and right child is:\n- left child index = parent index * 2 + 1\n- right child index = parent index * 2 + 2\n\nSo the basic idea is to use a queue to traverse the tree level by level, and record the difference between the most left node's index and the most right node's index, and update the max index distance for each layer.\n\nThe problem is, even with a tree with only 3000 nodes, the index difference may overflow in a int32 integer (up to 2^3000 when all the nodes are on a parent-child chain). To address this problem, one way is to use long long type. But it's not easy to scale up to a tree with more nodes. Note that the absolute value of a node's index is not important. What matters is the distance from the left most node to the right most node. So for each layer, we can reduce the index value by starting the left most node's index from 0. With this second approach, we can handle a tree up to 2,147,483,647 layers just with int32 type.\n\nC# code:\n```csharp\n    public int WidthOfBinaryTree(TreeNode root) {\n        if (root == null)\n            return 0;\n        var max = 1;\n        var queue = new Queue<(TreeNode, int)>();\n        queue.Enqueue((root, 0));\n        var first = -1;\n        var last = 0;\n        var offset = 0;\n        while (queue.Count > 0)\n        {\n            var total = queue.Count;\n            for (var i = 0; i < total; i++)\n            {\n                var cur = queue.Dequeue();\n                var node = cur.Item1;\n                var idx = cur.Item2;\n                if (first < 0)\n                {\n                    offset = idx;\n                    first = 0;\n                }\n                last = idx - offset;\n\n                if (node.left != null)\n                    queue.Enqueue((node.left, last * 2 + 1));\n\n                if (node.right != null)\n                    queue.Enqueue((node.right, last * 2 + 2));\n            }\n\n            max = Math.Max(max, last - first + 1);\n            first = -1;\n            last = 0;\n        }\n        return max;\n   }\n```"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "It's weird that almost all posted solutions don't use that trick and have been submitted like an hour ago.. How come they don't fail on last test case?\nThanks for the tip!\n"
                    },
                    {
                        "username": "CHENGALLA",
                        "content": "![image](https://assets.leetcode.com/users/images/a9135f89-6e48-41b9-bf58-7ade7abc286d_1628084581.6159878.png)\\n"
                    },
                    {
                        "username": "ajz01",
                        "content": "How is the answer to this 8? There appears to be at most 4 nodes on any level (level 3 and 4 have four nodes counting the null nodes).\\n\\n[1,1,1,1,null,null,1,1,null,null,1]"
                    },
                    {
                        "username": "Maang-io",
                        "content": "seems like a tree week :-)"
                    },
                    {
                        "username": "saketthavanani",
                        "content": "![image](https://assets.leetcode.com/users/images/86bc25a0-030e-4113-a7a4-2d0ebce65ce9_1605080710.8836358.png)\\n"
                    },
                    {
                        "username": "user4796V",
                        "content": "what a waste of fucking time"
                    }
                ]
            },
            {
                "id": 2059846,
                "content": [
                    {
                        "username": "drat",
                        "content": "My solution fails at this particular testcase , any help why? \\ntest case - [-64,12,18,-4,-53,null,76,null,-51,null,null,-93,3,null,-31,47,null,3,53,-81,33,4,null,-51,-44,-60,11,null,null,null,null,78,null,-35,-64,26,-81,-31,27,60,74,null,null,8,-38,47,12,-24,null,-59,-49,-11,-51,67,null,null,null,null,null,null,null,-67,null,-37,-19,10,-55,72,null,null,null,-70,17,-4,null,null,null,null,null,null,null,3,80,44,-88,-91,null,48,-90,-30,null,null,90,-34,37,null,null,73,-38,-31,-85,-31,-96,null,null,-18,67,34,72,null,-17,-77,null,56,-65,-88,-53,null,null,null,-33,86,null,81,-42,null,null,98,-40,70,-26,24,null,null,null,null,92,72,-27,null,null,null,null,null,null,-67,null,null,null,null,null,null,null,-54,-66,-36,null,-72,null,null,43,null,null,null,-92,-1,-98,null,null,null,null,null,null,null,39,-84,null,null,null,null,null,null,null,null,null,null,null,null,null,-93,null,null,null,98]\\n\\n`class Solution {\\n    public int widthOfBinaryTree(TreeNode root) {\\n        int width = 0;\\n        Queue<Pair<TreeNode, Integer>> q = new LinkedList<>();\\n        if(root!=null) q.add(new Pair(root, 1));\\n\\n        while(!q.isEmpty()){\\n            int n = q.size();\\n            int min=5000, max=0;\\n            while(n-- > 0){\\n                Pair<TreeNode, Integer> p = q.poll();\\n                TreeNode cur = p.getKey();\\n                int pos = p.getValue(); \\n                min = Math.min(min, pos);\\n                max = Math.max(max, pos);\\n\\n                if(cur.left!=null) q.add(new Pair(cur.left, pos*2));\\n                if(cur.right!=null) q.add(new Pair(cur.right, pos*2+1));\\n            }\\n\\n            width = Math.max(width, max-min+1);\\n\\n        }\\n\\n        return width;\\n\\n    }\\n}`"
                    },
                    {
                        "username": "shreedpathaks",
                        "content": "Try with  Deque, apply bfs and check for size between two non-null nodes, return the maximum ans;\\nremove all null nodes from front till first non-null node and similarly from back, (remove all null nodes from front till first non-null node).\\ncompare the size with ans, and return max,\\ntho this approach  has TLE but u will get more clearity from this ."
                    },
                    {
                        "username": "aitachii",
                        "content": "The width of a level is the number of non-null nodes + the null nodes inbetween the non-null nodes.\nFor example 1:\nLevel 1: [1]\nhas width 1\nLevel 2: [3, 2]\nhas width 2 \nLevel 3: [5,3,X,9]\nhas width 4\n\nExample 2:\n[1] has width 1\n[3,2] has width 2\n[5,X,X,9] has width 4\n[6,X,X,X,X,X,7,X] has width 7, [6,X,X,X,X,X,7]\n\nExample 3:\n[1] has width 1\n[3,2] has width 2\n[5,X,X,X] has width 1, [5]\n\nMore examples (some random levels):\n[X,1,X,5,X] has width 3, [1,X,5]\n[X,X,1,X,X,X] has width 1, [1]\n[X,1,X,X,5,X,X,9] has width 7, [1,X,X,5,X,X,9]\n\nThe testcases can cause overflow so think of a way to solve this without counting all the nodes(both null and non-null) in a level."
                    },
                    {
                        "username": "jpvarbed",
                        "content": "Please put a note for javascript/typescript users that you need to wrap in bigint"
                    },
                    {
                        "username": "bjiang78",
                        "content": "In a full binary tree, the index calculation of left child and right child is:\n- left child index = parent index * 2 + 1\n- right child index = parent index * 2 + 2\n\nSo the basic idea is to use a queue to traverse the tree level by level, and record the difference between the most left node's index and the most right node's index, and update the max index distance for each layer.\n\nThe problem is, even with a tree with only 3000 nodes, the index difference may overflow in a int32 integer (up to 2^3000 when all the nodes are on a parent-child chain). To address this problem, one way is to use long long type. But it's not easy to scale up to a tree with more nodes. Note that the absolute value of a node's index is not important. What matters is the distance from the left most node to the right most node. So for each layer, we can reduce the index value by starting the left most node's index from 0. With this second approach, we can handle a tree up to 2,147,483,647 layers just with int32 type.\n\nC# code:\n```csharp\n    public int WidthOfBinaryTree(TreeNode root) {\n        if (root == null)\n            return 0;\n        var max = 1;\n        var queue = new Queue<(TreeNode, int)>();\n        queue.Enqueue((root, 0));\n        var first = -1;\n        var last = 0;\n        var offset = 0;\n        while (queue.Count > 0)\n        {\n            var total = queue.Count;\n            for (var i = 0; i < total; i++)\n            {\n                var cur = queue.Dequeue();\n                var node = cur.Item1;\n                var idx = cur.Item2;\n                if (first < 0)\n                {\n                    offset = idx;\n                    first = 0;\n                }\n                last = idx - offset;\n\n                if (node.left != null)\n                    queue.Enqueue((node.left, last * 2 + 1));\n\n                if (node.right != null)\n                    queue.Enqueue((node.right, last * 2 + 2));\n            }\n\n            max = Math.Max(max, last - first + 1);\n            first = -1;\n            last = 0;\n        }\n        return max;\n   }\n```"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "It's weird that almost all posted solutions don't use that trick and have been submitted like an hour ago.. How come they don't fail on last test case?\nThanks for the tip!\n"
                    },
                    {
                        "username": "CHENGALLA",
                        "content": "![image](https://assets.leetcode.com/users/images/a9135f89-6e48-41b9-bf58-7ade7abc286d_1628084581.6159878.png)\\n"
                    },
                    {
                        "username": "ajz01",
                        "content": "How is the answer to this 8? There appears to be at most 4 nodes on any level (level 3 and 4 have four nodes counting the null nodes).\\n\\n[1,1,1,1,null,null,1,1,null,null,1]"
                    },
                    {
                        "username": "Maang-io",
                        "content": "seems like a tree week :-)"
                    },
                    {
                        "username": "saketthavanani",
                        "content": "![image](https://assets.leetcode.com/users/images/86bc25a0-030e-4113-a7a4-2d0ebce65ce9_1605080710.8836358.png)\\n"
                    },
                    {
                        "username": "user4796V",
                        "content": "what a waste of fucking time"
                    }
                ]
            },
            {
                "id": 2059751,
                "content": [
                    {
                        "username": "user4796V",
                        "content": "if there is a restriction on memory usage you should mention it in the constaints section!!"
                    },
                    {
                        "username": "androidcarson",
                        "content": "should be called max width of the chunks of memory the tree is arbitrarily represented in since the tree itself has nodes that are visually represented next to eachother yet they have a massive width; but i digress"
                    },
                    {
                        "username": "sk4142",
                        "content": "Hint: Try problem 102 first "
                    },
                    {
                        "username": "abhinabroy",
                        "content": "I would be completely blank if this question comes in an interview. These are the type of question which look like you have practiced these questions all your life, but still fail to implement. \\nHow would you tackle if this question comes in your interview?"
                    },
                    {
                        "username": "user8272RT",
                        "content": "BFS did the trick!"
                    },
                    {
                        "username": "sarthakkharabanda",
                        "content": "So basically level order traversal but the index of the nodes would be based on what if this was a complete binary tree"
                    },
                    {
                        "username": "Moore-Z",
                        "content": "some of the test case are not make any sense, it is impossible for people to debug it at all. "
                    },
                    {
                        "username": "Satyampatel802212",
                        "content": "I got TLE for using level order traversal"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "follow this .\\n\\nhttps://leetcode.com/problems/maximum-width-of-binary-tree/description/comments/1950802"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "C++ Level order Traversal (BFS). Easy\\n# Intuition\\nint ind=q.front().second-currLow; in this line to safe it from overflow.\\n\\n# Approach\\n\\n1. Start by checking if the given binary tree is empty (root is null). If it is, return 0 since there are no nodes in the tree.\\n\\n2. Create a queue to perform level-order traversal of the binary tree. Each element in the queue is a pair consisting of a tree node and its corresponding index.\\n\\n3. Push the root node of the binary tree along with index 1 into the queue.\\n\\n4. Initialize a variable \"ans\" to store the maximum width of the binary tree. Set it to INT_MIN initially.\\n\\n5. Enter a loop that continues until the queue becomes empty. Inside the loop:\\n\\n   a. Get the current size of the queue and initialize variables \"low\" and \"high\" to store the lowest and highest indices of nodes at the current level, respectively. Also, store the index of the first node in the current level as \"currLow\".\\n   \\n   b. Iterate over each node in the current level (size number of times):\\n   \\n      - Dequeue the front node and its corresponding index from the queue.\\n      \\n      - If it\\'s the first node in the current level, update \"low\" to the current index.\\n      \\n      - If it\\'s the last node in the current level, update \"high\" to the current index.\\n      \\n      - Enqueue the left and right child of the current node, if they exist, along with their corresponding indices. The left child\\'s index is calculated as 2*ind + 1, and the right child\\'s index is calculated as 2*ind + 2.\\n      \\n   c. Calculate the width of the current level by subtracting \"low\" from \"high\" and adding 1. Update \"ans\" with the maximum width seen so far.\\n   \\n6. Once the queue is empty and the traversal is complete, return the maximum width stored in \"ans\".\\n\\n-------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n) n=number of nodes.\\n\\n- Space complexity:\\nS.C=O(n) n=number of nodes.\\n---------------------------------\\n\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/maximum-width-of-binary-tree/solutions/3701548/c-level-order-traversal-bfs-easy/"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Prefer type long so it will not overflow"
                    }
                ]
            },
            {
                "id": 2040068,
                "content": [
                    {
                        "username": "user4796V",
                        "content": "if there is a restriction on memory usage you should mention it in the constaints section!!"
                    },
                    {
                        "username": "androidcarson",
                        "content": "should be called max width of the chunks of memory the tree is arbitrarily represented in since the tree itself has nodes that are visually represented next to eachother yet they have a massive width; but i digress"
                    },
                    {
                        "username": "sk4142",
                        "content": "Hint: Try problem 102 first "
                    },
                    {
                        "username": "abhinabroy",
                        "content": "I would be completely blank if this question comes in an interview. These are the type of question which look like you have practiced these questions all your life, but still fail to implement. \\nHow would you tackle if this question comes in your interview?"
                    },
                    {
                        "username": "user8272RT",
                        "content": "BFS did the trick!"
                    },
                    {
                        "username": "sarthakkharabanda",
                        "content": "So basically level order traversal but the index of the nodes would be based on what if this was a complete binary tree"
                    },
                    {
                        "username": "Moore-Z",
                        "content": "some of the test case are not make any sense, it is impossible for people to debug it at all. "
                    },
                    {
                        "username": "Satyampatel802212",
                        "content": "I got TLE for using level order traversal"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "follow this .\\n\\nhttps://leetcode.com/problems/maximum-width-of-binary-tree/description/comments/1950802"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "C++ Level order Traversal (BFS). Easy\\n# Intuition\\nint ind=q.front().second-currLow; in this line to safe it from overflow.\\n\\n# Approach\\n\\n1. Start by checking if the given binary tree is empty (root is null). If it is, return 0 since there are no nodes in the tree.\\n\\n2. Create a queue to perform level-order traversal of the binary tree. Each element in the queue is a pair consisting of a tree node and its corresponding index.\\n\\n3. Push the root node of the binary tree along with index 1 into the queue.\\n\\n4. Initialize a variable \"ans\" to store the maximum width of the binary tree. Set it to INT_MIN initially.\\n\\n5. Enter a loop that continues until the queue becomes empty. Inside the loop:\\n\\n   a. Get the current size of the queue and initialize variables \"low\" and \"high\" to store the lowest and highest indices of nodes at the current level, respectively. Also, store the index of the first node in the current level as \"currLow\".\\n   \\n   b. Iterate over each node in the current level (size number of times):\\n   \\n      - Dequeue the front node and its corresponding index from the queue.\\n      \\n      - If it\\'s the first node in the current level, update \"low\" to the current index.\\n      \\n      - If it\\'s the last node in the current level, update \"high\" to the current index.\\n      \\n      - Enqueue the left and right child of the current node, if they exist, along with their corresponding indices. The left child\\'s index is calculated as 2*ind + 1, and the right child\\'s index is calculated as 2*ind + 2.\\n      \\n   c. Calculate the width of the current level by subtracting \"low\" from \"high\" and adding 1. Update \"ans\" with the maximum width seen so far.\\n   \\n6. Once the queue is empty and the traversal is complete, return the maximum width stored in \"ans\".\\n\\n-------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n) n=number of nodes.\\n\\n- Space complexity:\\nS.C=O(n) n=number of nodes.\\n---------------------------------\\n\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/maximum-width-of-binary-tree/solutions/3701548/c-level-order-traversal-bfs-easy/"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Prefer type long so it will not overflow"
                    }
                ]
            },
            {
                "id": 2038794,
                "content": [
                    {
                        "username": "user4796V",
                        "content": "if there is a restriction on memory usage you should mention it in the constaints section!!"
                    },
                    {
                        "username": "androidcarson",
                        "content": "should be called max width of the chunks of memory the tree is arbitrarily represented in since the tree itself has nodes that are visually represented next to eachother yet they have a massive width; but i digress"
                    },
                    {
                        "username": "sk4142",
                        "content": "Hint: Try problem 102 first "
                    },
                    {
                        "username": "abhinabroy",
                        "content": "I would be completely blank if this question comes in an interview. These are the type of question which look like you have practiced these questions all your life, but still fail to implement. \\nHow would you tackle if this question comes in your interview?"
                    },
                    {
                        "username": "user8272RT",
                        "content": "BFS did the trick!"
                    },
                    {
                        "username": "sarthakkharabanda",
                        "content": "So basically level order traversal but the index of the nodes would be based on what if this was a complete binary tree"
                    },
                    {
                        "username": "Moore-Z",
                        "content": "some of the test case are not make any sense, it is impossible for people to debug it at all. "
                    },
                    {
                        "username": "Satyampatel802212",
                        "content": "I got TLE for using level order traversal"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "follow this .\\n\\nhttps://leetcode.com/problems/maximum-width-of-binary-tree/description/comments/1950802"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "C++ Level order Traversal (BFS). Easy\\n# Intuition\\nint ind=q.front().second-currLow; in this line to safe it from overflow.\\n\\n# Approach\\n\\n1. Start by checking if the given binary tree is empty (root is null). If it is, return 0 since there are no nodes in the tree.\\n\\n2. Create a queue to perform level-order traversal of the binary tree. Each element in the queue is a pair consisting of a tree node and its corresponding index.\\n\\n3. Push the root node of the binary tree along with index 1 into the queue.\\n\\n4. Initialize a variable \"ans\" to store the maximum width of the binary tree. Set it to INT_MIN initially.\\n\\n5. Enter a loop that continues until the queue becomes empty. Inside the loop:\\n\\n   a. Get the current size of the queue and initialize variables \"low\" and \"high\" to store the lowest and highest indices of nodes at the current level, respectively. Also, store the index of the first node in the current level as \"currLow\".\\n   \\n   b. Iterate over each node in the current level (size number of times):\\n   \\n      - Dequeue the front node and its corresponding index from the queue.\\n      \\n      - If it\\'s the first node in the current level, update \"low\" to the current index.\\n      \\n      - If it\\'s the last node in the current level, update \"high\" to the current index.\\n      \\n      - Enqueue the left and right child of the current node, if they exist, along with their corresponding indices. The left child\\'s index is calculated as 2*ind + 1, and the right child\\'s index is calculated as 2*ind + 2.\\n      \\n   c. Calculate the width of the current level by subtracting \"low\" from \"high\" and adding 1. Update \"ans\" with the maximum width seen so far.\\n   \\n6. Once the queue is empty and the traversal is complete, return the maximum width stored in \"ans\".\\n\\n-------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n) n=number of nodes.\\n\\n- Space complexity:\\nS.C=O(n) n=number of nodes.\\n---------------------------------\\n\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/maximum-width-of-binary-tree/solutions/3701548/c-level-order-traversal-bfs-easy/"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Prefer type long so it will not overflow"
                    }
                ]
            },
            {
                "id": 2024973,
                "content": [
                    {
                        "username": "user4796V",
                        "content": "if there is a restriction on memory usage you should mention it in the constaints section!!"
                    },
                    {
                        "username": "androidcarson",
                        "content": "should be called max width of the chunks of memory the tree is arbitrarily represented in since the tree itself has nodes that are visually represented next to eachother yet they have a massive width; but i digress"
                    },
                    {
                        "username": "sk4142",
                        "content": "Hint: Try problem 102 first "
                    },
                    {
                        "username": "abhinabroy",
                        "content": "I would be completely blank if this question comes in an interview. These are the type of question which look like you have practiced these questions all your life, but still fail to implement. \\nHow would you tackle if this question comes in your interview?"
                    },
                    {
                        "username": "user8272RT",
                        "content": "BFS did the trick!"
                    },
                    {
                        "username": "sarthakkharabanda",
                        "content": "So basically level order traversal but the index of the nodes would be based on what if this was a complete binary tree"
                    },
                    {
                        "username": "Moore-Z",
                        "content": "some of the test case are not make any sense, it is impossible for people to debug it at all. "
                    },
                    {
                        "username": "Satyampatel802212",
                        "content": "I got TLE for using level order traversal"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "follow this .\\n\\nhttps://leetcode.com/problems/maximum-width-of-binary-tree/description/comments/1950802"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "C++ Level order Traversal (BFS). Easy\\n# Intuition\\nint ind=q.front().second-currLow; in this line to safe it from overflow.\\n\\n# Approach\\n\\n1. Start by checking if the given binary tree is empty (root is null). If it is, return 0 since there are no nodes in the tree.\\n\\n2. Create a queue to perform level-order traversal of the binary tree. Each element in the queue is a pair consisting of a tree node and its corresponding index.\\n\\n3. Push the root node of the binary tree along with index 1 into the queue.\\n\\n4. Initialize a variable \"ans\" to store the maximum width of the binary tree. Set it to INT_MIN initially.\\n\\n5. Enter a loop that continues until the queue becomes empty. Inside the loop:\\n\\n   a. Get the current size of the queue and initialize variables \"low\" and \"high\" to store the lowest and highest indices of nodes at the current level, respectively. Also, store the index of the first node in the current level as \"currLow\".\\n   \\n   b. Iterate over each node in the current level (size number of times):\\n   \\n      - Dequeue the front node and its corresponding index from the queue.\\n      \\n      - If it\\'s the first node in the current level, update \"low\" to the current index.\\n      \\n      - If it\\'s the last node in the current level, update \"high\" to the current index.\\n      \\n      - Enqueue the left and right child of the current node, if they exist, along with their corresponding indices. The left child\\'s index is calculated as 2*ind + 1, and the right child\\'s index is calculated as 2*ind + 2.\\n      \\n   c. Calculate the width of the current level by subtracting \"low\" from \"high\" and adding 1. Update \"ans\" with the maximum width seen so far.\\n   \\n6. Once the queue is empty and the traversal is complete, return the maximum width stored in \"ans\".\\n\\n-------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n) n=number of nodes.\\n\\n- Space complexity:\\nS.C=O(n) n=number of nodes.\\n---------------------------------\\n\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/maximum-width-of-binary-tree/solutions/3701548/c-level-order-traversal-bfs-easy/"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Prefer type long so it will not overflow"
                    }
                ]
            },
            {
                "id": 2019496,
                "content": [
                    {
                        "username": "user4796V",
                        "content": "if there is a restriction on memory usage you should mention it in the constaints section!!"
                    },
                    {
                        "username": "androidcarson",
                        "content": "should be called max width of the chunks of memory the tree is arbitrarily represented in since the tree itself has nodes that are visually represented next to eachother yet they have a massive width; but i digress"
                    },
                    {
                        "username": "sk4142",
                        "content": "Hint: Try problem 102 first "
                    },
                    {
                        "username": "abhinabroy",
                        "content": "I would be completely blank if this question comes in an interview. These are the type of question which look like you have practiced these questions all your life, but still fail to implement. \\nHow would you tackle if this question comes in your interview?"
                    },
                    {
                        "username": "user8272RT",
                        "content": "BFS did the trick!"
                    },
                    {
                        "username": "sarthakkharabanda",
                        "content": "So basically level order traversal but the index of the nodes would be based on what if this was a complete binary tree"
                    },
                    {
                        "username": "Moore-Z",
                        "content": "some of the test case are not make any sense, it is impossible for people to debug it at all. "
                    },
                    {
                        "username": "Satyampatel802212",
                        "content": "I got TLE for using level order traversal"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "follow this .\\n\\nhttps://leetcode.com/problems/maximum-width-of-binary-tree/description/comments/1950802"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "C++ Level order Traversal (BFS). Easy\\n# Intuition\\nint ind=q.front().second-currLow; in this line to safe it from overflow.\\n\\n# Approach\\n\\n1. Start by checking if the given binary tree is empty (root is null). If it is, return 0 since there are no nodes in the tree.\\n\\n2. Create a queue to perform level-order traversal of the binary tree. Each element in the queue is a pair consisting of a tree node and its corresponding index.\\n\\n3. Push the root node of the binary tree along with index 1 into the queue.\\n\\n4. Initialize a variable \"ans\" to store the maximum width of the binary tree. Set it to INT_MIN initially.\\n\\n5. Enter a loop that continues until the queue becomes empty. Inside the loop:\\n\\n   a. Get the current size of the queue and initialize variables \"low\" and \"high\" to store the lowest and highest indices of nodes at the current level, respectively. Also, store the index of the first node in the current level as \"currLow\".\\n   \\n   b. Iterate over each node in the current level (size number of times):\\n   \\n      - Dequeue the front node and its corresponding index from the queue.\\n      \\n      - If it\\'s the first node in the current level, update \"low\" to the current index.\\n      \\n      - If it\\'s the last node in the current level, update \"high\" to the current index.\\n      \\n      - Enqueue the left and right child of the current node, if they exist, along with their corresponding indices. The left child\\'s index is calculated as 2*ind + 1, and the right child\\'s index is calculated as 2*ind + 2.\\n      \\n   c. Calculate the width of the current level by subtracting \"low\" from \"high\" and adding 1. Update \"ans\" with the maximum width seen so far.\\n   \\n6. Once the queue is empty and the traversal is complete, return the maximum width stored in \"ans\".\\n\\n-------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n) n=number of nodes.\\n\\n- Space complexity:\\nS.C=O(n) n=number of nodes.\\n---------------------------------\\n\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/maximum-width-of-binary-tree/solutions/3701548/c-level-order-traversal-bfs-easy/"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Prefer type long so it will not overflow"
                    }
                ]
            },
            {
                "id": 2016466,
                "content": [
                    {
                        "username": "user4796V",
                        "content": "if there is a restriction on memory usage you should mention it in the constaints section!!"
                    },
                    {
                        "username": "androidcarson",
                        "content": "should be called max width of the chunks of memory the tree is arbitrarily represented in since the tree itself has nodes that are visually represented next to eachother yet they have a massive width; but i digress"
                    },
                    {
                        "username": "sk4142",
                        "content": "Hint: Try problem 102 first "
                    },
                    {
                        "username": "abhinabroy",
                        "content": "I would be completely blank if this question comes in an interview. These are the type of question which look like you have practiced these questions all your life, but still fail to implement. \\nHow would you tackle if this question comes in your interview?"
                    },
                    {
                        "username": "user8272RT",
                        "content": "BFS did the trick!"
                    },
                    {
                        "username": "sarthakkharabanda",
                        "content": "So basically level order traversal but the index of the nodes would be based on what if this was a complete binary tree"
                    },
                    {
                        "username": "Moore-Z",
                        "content": "some of the test case are not make any sense, it is impossible for people to debug it at all. "
                    },
                    {
                        "username": "Satyampatel802212",
                        "content": "I got TLE for using level order traversal"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "follow this .\\n\\nhttps://leetcode.com/problems/maximum-width-of-binary-tree/description/comments/1950802"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "C++ Level order Traversal (BFS). Easy\\n# Intuition\\nint ind=q.front().second-currLow; in this line to safe it from overflow.\\n\\n# Approach\\n\\n1. Start by checking if the given binary tree is empty (root is null). If it is, return 0 since there are no nodes in the tree.\\n\\n2. Create a queue to perform level-order traversal of the binary tree. Each element in the queue is a pair consisting of a tree node and its corresponding index.\\n\\n3. Push the root node of the binary tree along with index 1 into the queue.\\n\\n4. Initialize a variable \"ans\" to store the maximum width of the binary tree. Set it to INT_MIN initially.\\n\\n5. Enter a loop that continues until the queue becomes empty. Inside the loop:\\n\\n   a. Get the current size of the queue and initialize variables \"low\" and \"high\" to store the lowest and highest indices of nodes at the current level, respectively. Also, store the index of the first node in the current level as \"currLow\".\\n   \\n   b. Iterate over each node in the current level (size number of times):\\n   \\n      - Dequeue the front node and its corresponding index from the queue.\\n      \\n      - If it\\'s the first node in the current level, update \"low\" to the current index.\\n      \\n      - If it\\'s the last node in the current level, update \"high\" to the current index.\\n      \\n      - Enqueue the left and right child of the current node, if they exist, along with their corresponding indices. The left child\\'s index is calculated as 2*ind + 1, and the right child\\'s index is calculated as 2*ind + 2.\\n      \\n   c. Calculate the width of the current level by subtracting \"low\" from \"high\" and adding 1. Update \"ans\" with the maximum width seen so far.\\n   \\n6. Once the queue is empty and the traversal is complete, return the maximum width stored in \"ans\".\\n\\n-------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n) n=number of nodes.\\n\\n- Space complexity:\\nS.C=O(n) n=number of nodes.\\n---------------------------------\\n\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/maximum-width-of-binary-tree/solutions/3701548/c-level-order-traversal-bfs-easy/"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Prefer type long so it will not overflow"
                    }
                ]
            },
            {
                "id": 1959331,
                "content": [
                    {
                        "username": "user4796V",
                        "content": "if there is a restriction on memory usage you should mention it in the constaints section!!"
                    },
                    {
                        "username": "androidcarson",
                        "content": "should be called max width of the chunks of memory the tree is arbitrarily represented in since the tree itself has nodes that are visually represented next to eachother yet they have a massive width; but i digress"
                    },
                    {
                        "username": "sk4142",
                        "content": "Hint: Try problem 102 first "
                    },
                    {
                        "username": "abhinabroy",
                        "content": "I would be completely blank if this question comes in an interview. These are the type of question which look like you have practiced these questions all your life, but still fail to implement. \\nHow would you tackle if this question comes in your interview?"
                    },
                    {
                        "username": "user8272RT",
                        "content": "BFS did the trick!"
                    },
                    {
                        "username": "sarthakkharabanda",
                        "content": "So basically level order traversal but the index of the nodes would be based on what if this was a complete binary tree"
                    },
                    {
                        "username": "Moore-Z",
                        "content": "some of the test case are not make any sense, it is impossible for people to debug it at all. "
                    },
                    {
                        "username": "Satyampatel802212",
                        "content": "I got TLE for using level order traversal"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "follow this .\\n\\nhttps://leetcode.com/problems/maximum-width-of-binary-tree/description/comments/1950802"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "C++ Level order Traversal (BFS). Easy\\n# Intuition\\nint ind=q.front().second-currLow; in this line to safe it from overflow.\\n\\n# Approach\\n\\n1. Start by checking if the given binary tree is empty (root is null). If it is, return 0 since there are no nodes in the tree.\\n\\n2. Create a queue to perform level-order traversal of the binary tree. Each element in the queue is a pair consisting of a tree node and its corresponding index.\\n\\n3. Push the root node of the binary tree along with index 1 into the queue.\\n\\n4. Initialize a variable \"ans\" to store the maximum width of the binary tree. Set it to INT_MIN initially.\\n\\n5. Enter a loop that continues until the queue becomes empty. Inside the loop:\\n\\n   a. Get the current size of the queue and initialize variables \"low\" and \"high\" to store the lowest and highest indices of nodes at the current level, respectively. Also, store the index of the first node in the current level as \"currLow\".\\n   \\n   b. Iterate over each node in the current level (size number of times):\\n   \\n      - Dequeue the front node and its corresponding index from the queue.\\n      \\n      - If it\\'s the first node in the current level, update \"low\" to the current index.\\n      \\n      - If it\\'s the last node in the current level, update \"high\" to the current index.\\n      \\n      - Enqueue the left and right child of the current node, if they exist, along with their corresponding indices. The left child\\'s index is calculated as 2*ind + 1, and the right child\\'s index is calculated as 2*ind + 2.\\n      \\n   c. Calculate the width of the current level by subtracting \"low\" from \"high\" and adding 1. Update \"ans\" with the maximum width seen so far.\\n   \\n6. Once the queue is empty and the traversal is complete, return the maximum width stored in \"ans\".\\n\\n-------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n) n=number of nodes.\\n\\n- Space complexity:\\nS.C=O(n) n=number of nodes.\\n---------------------------------\\n\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/maximum-width-of-binary-tree/solutions/3701548/c-level-order-traversal-bfs-easy/"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Prefer type long so it will not overflow"
                    }
                ]
            },
            {
                "id": 1950809,
                "content": [
                    {
                        "username": "user4796V",
                        "content": "if there is a restriction on memory usage you should mention it in the constaints section!!"
                    },
                    {
                        "username": "androidcarson",
                        "content": "should be called max width of the chunks of memory the tree is arbitrarily represented in since the tree itself has nodes that are visually represented next to eachother yet they have a massive width; but i digress"
                    },
                    {
                        "username": "sk4142",
                        "content": "Hint: Try problem 102 first "
                    },
                    {
                        "username": "abhinabroy",
                        "content": "I would be completely blank if this question comes in an interview. These are the type of question which look like you have practiced these questions all your life, but still fail to implement. \\nHow would you tackle if this question comes in your interview?"
                    },
                    {
                        "username": "user8272RT",
                        "content": "BFS did the trick!"
                    },
                    {
                        "username": "sarthakkharabanda",
                        "content": "So basically level order traversal but the index of the nodes would be based on what if this was a complete binary tree"
                    },
                    {
                        "username": "Moore-Z",
                        "content": "some of the test case are not make any sense, it is impossible for people to debug it at all. "
                    },
                    {
                        "username": "Satyampatel802212",
                        "content": "I got TLE for using level order traversal"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "follow this .\\n\\nhttps://leetcode.com/problems/maximum-width-of-binary-tree/description/comments/1950802"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "C++ Level order Traversal (BFS). Easy\\n# Intuition\\nint ind=q.front().second-currLow; in this line to safe it from overflow.\\n\\n# Approach\\n\\n1. Start by checking if the given binary tree is empty (root is null). If it is, return 0 since there are no nodes in the tree.\\n\\n2. Create a queue to perform level-order traversal of the binary tree. Each element in the queue is a pair consisting of a tree node and its corresponding index.\\n\\n3. Push the root node of the binary tree along with index 1 into the queue.\\n\\n4. Initialize a variable \"ans\" to store the maximum width of the binary tree. Set it to INT_MIN initially.\\n\\n5. Enter a loop that continues until the queue becomes empty. Inside the loop:\\n\\n   a. Get the current size of the queue and initialize variables \"low\" and \"high\" to store the lowest and highest indices of nodes at the current level, respectively. Also, store the index of the first node in the current level as \"currLow\".\\n   \\n   b. Iterate over each node in the current level (size number of times):\\n   \\n      - Dequeue the front node and its corresponding index from the queue.\\n      \\n      - If it\\'s the first node in the current level, update \"low\" to the current index.\\n      \\n      - If it\\'s the last node in the current level, update \"high\" to the current index.\\n      \\n      - Enqueue the left and right child of the current node, if they exist, along with their corresponding indices. The left child\\'s index is calculated as 2*ind + 1, and the right child\\'s index is calculated as 2*ind + 2.\\n      \\n   c. Calculate the width of the current level by subtracting \"low\" from \"high\" and adding 1. Update \"ans\" with the maximum width seen so far.\\n   \\n6. Once the queue is empty and the traversal is complete, return the maximum width stored in \"ans\".\\n\\n-------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n) n=number of nodes.\\n\\n- Space complexity:\\nS.C=O(n) n=number of nodes.\\n---------------------------------\\n\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/maximum-width-of-binary-tree/solutions/3701548/c-level-order-traversal-bfs-easy/"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Prefer type long so it will not overflow"
                    }
                ]
            },
            {
                "id": 1950802,
                "content": [
                    {
                        "username": "user4796V",
                        "content": "if there is a restriction on memory usage you should mention it in the constaints section!!"
                    },
                    {
                        "username": "androidcarson",
                        "content": "should be called max width of the chunks of memory the tree is arbitrarily represented in since the tree itself has nodes that are visually represented next to eachother yet they have a massive width; but i digress"
                    },
                    {
                        "username": "sk4142",
                        "content": "Hint: Try problem 102 first "
                    },
                    {
                        "username": "abhinabroy",
                        "content": "I would be completely blank if this question comes in an interview. These are the type of question which look like you have practiced these questions all your life, but still fail to implement. \\nHow would you tackle if this question comes in your interview?"
                    },
                    {
                        "username": "user8272RT",
                        "content": "BFS did the trick!"
                    },
                    {
                        "username": "sarthakkharabanda",
                        "content": "So basically level order traversal but the index of the nodes would be based on what if this was a complete binary tree"
                    },
                    {
                        "username": "Moore-Z",
                        "content": "some of the test case are not make any sense, it is impossible for people to debug it at all. "
                    },
                    {
                        "username": "Satyampatel802212",
                        "content": "I got TLE for using level order traversal"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "follow this .\\n\\nhttps://leetcode.com/problems/maximum-width-of-binary-tree/description/comments/1950802"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "C++ Level order Traversal (BFS). Easy\\n# Intuition\\nint ind=q.front().second-currLow; in this line to safe it from overflow.\\n\\n# Approach\\n\\n1. Start by checking if the given binary tree is empty (root is null). If it is, return 0 since there are no nodes in the tree.\\n\\n2. Create a queue to perform level-order traversal of the binary tree. Each element in the queue is a pair consisting of a tree node and its corresponding index.\\n\\n3. Push the root node of the binary tree along with index 1 into the queue.\\n\\n4. Initialize a variable \"ans\" to store the maximum width of the binary tree. Set it to INT_MIN initially.\\n\\n5. Enter a loop that continues until the queue becomes empty. Inside the loop:\\n\\n   a. Get the current size of the queue and initialize variables \"low\" and \"high\" to store the lowest and highest indices of nodes at the current level, respectively. Also, store the index of the first node in the current level as \"currLow\".\\n   \\n   b. Iterate over each node in the current level (size number of times):\\n   \\n      - Dequeue the front node and its corresponding index from the queue.\\n      \\n      - If it\\'s the first node in the current level, update \"low\" to the current index.\\n      \\n      - If it\\'s the last node in the current level, update \"high\" to the current index.\\n      \\n      - Enqueue the left and right child of the current node, if they exist, along with their corresponding indices. The left child\\'s index is calculated as 2*ind + 1, and the right child\\'s index is calculated as 2*ind + 2.\\n      \\n   c. Calculate the width of the current level by subtracting \"low\" from \"high\" and adding 1. Update \"ans\" with the maximum width seen so far.\\n   \\n6. Once the queue is empty and the traversal is complete, return the maximum width stored in \"ans\".\\n\\n-------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n) n=number of nodes.\\n\\n- Space complexity:\\nS.C=O(n) n=number of nodes.\\n---------------------------------\\n\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/maximum-width-of-binary-tree/solutions/3701548/c-level-order-traversal-bfs-easy/"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Prefer type long so it will not overflow"
                    }
                ]
            },
            {
                "id": 1930403,
                "content": [
                    {
                        "username": "user4796V",
                        "content": "if there is a restriction on memory usage you should mention it in the constaints section!!"
                    },
                    {
                        "username": "androidcarson",
                        "content": "should be called max width of the chunks of memory the tree is arbitrarily represented in since the tree itself has nodes that are visually represented next to eachother yet they have a massive width; but i digress"
                    },
                    {
                        "username": "sk4142",
                        "content": "Hint: Try problem 102 first "
                    },
                    {
                        "username": "abhinabroy",
                        "content": "I would be completely blank if this question comes in an interview. These are the type of question which look like you have practiced these questions all your life, but still fail to implement. \\nHow would you tackle if this question comes in your interview?"
                    },
                    {
                        "username": "user8272RT",
                        "content": "BFS did the trick!"
                    },
                    {
                        "username": "sarthakkharabanda",
                        "content": "So basically level order traversal but the index of the nodes would be based on what if this was a complete binary tree"
                    },
                    {
                        "username": "Moore-Z",
                        "content": "some of the test case are not make any sense, it is impossible for people to debug it at all. "
                    },
                    {
                        "username": "Satyampatel802212",
                        "content": "I got TLE for using level order traversal"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "follow this .\\n\\nhttps://leetcode.com/problems/maximum-width-of-binary-tree/description/comments/1950802"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "C++ Level order Traversal (BFS). Easy\\n# Intuition\\nint ind=q.front().second-currLow; in this line to safe it from overflow.\\n\\n# Approach\\n\\n1. Start by checking if the given binary tree is empty (root is null). If it is, return 0 since there are no nodes in the tree.\\n\\n2. Create a queue to perform level-order traversal of the binary tree. Each element in the queue is a pair consisting of a tree node and its corresponding index.\\n\\n3. Push the root node of the binary tree along with index 1 into the queue.\\n\\n4. Initialize a variable \"ans\" to store the maximum width of the binary tree. Set it to INT_MIN initially.\\n\\n5. Enter a loop that continues until the queue becomes empty. Inside the loop:\\n\\n   a. Get the current size of the queue and initialize variables \"low\" and \"high\" to store the lowest and highest indices of nodes at the current level, respectively. Also, store the index of the first node in the current level as \"currLow\".\\n   \\n   b. Iterate over each node in the current level (size number of times):\\n   \\n      - Dequeue the front node and its corresponding index from the queue.\\n      \\n      - If it\\'s the first node in the current level, update \"low\" to the current index.\\n      \\n      - If it\\'s the last node in the current level, update \"high\" to the current index.\\n      \\n      - Enqueue the left and right child of the current node, if they exist, along with their corresponding indices. The left child\\'s index is calculated as 2*ind + 1, and the right child\\'s index is calculated as 2*ind + 2.\\n      \\n   c. Calculate the width of the current level by subtracting \"low\" from \"high\" and adding 1. Update \"ans\" with the maximum width seen so far.\\n   \\n6. Once the queue is empty and the traversal is complete, return the maximum width stored in \"ans\".\\n\\n-------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n) n=number of nodes.\\n\\n- Space complexity:\\nS.C=O(n) n=number of nodes.\\n---------------------------------\\n\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/maximum-width-of-binary-tree/solutions/3701548/c-level-order-traversal-bfs-easy/"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Prefer type long so it will not overflow"
                    }
                ]
            },
            {
                "id": 1929623,
                "content": [
                    {
                        "username": "raiabhinavprakash",
                        "content": "This code is giving wrong answer at 101/114 test case. Can anybody pointout possible mistakes in it?\\n````\\nint widthOfBinaryTree(TreeNode* root) {\\n        long long int ans = 1, c = 1;\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        while(q.size())\\n        {\\n            int k = q.size();\\n            vector<int>v;\\n            for(int i = 0; i<k; i++)\\n            {\\n                auto a = q.front();\\n                q.pop();\\n                if(a->left)\\n                {\\n                    q.push(a->left);\\n                    v.push_back(a->left->val);\\n                }\\n                else v.push_back(-101);\\n                if(a->right)\\n                {\\n                    q.push(a->right);\\n                    v.push_back(a->right->val);\\n                }\\n                else v.push_back(-101);\\n            }\\n            if(!q.size()) break;\\n            c *= 2;\\n            long long i = 0, j = v.size()-1;\\n            while(i<=j && v[i] == -101) {i++; c--;}\\n            while(j>=i && v[j] == -101) {j--; c--;}\\n            ans = max(ans, c);\\n        }\\n        return ans;\\n    }\\n````"
                    },
                    {
                        "username": "akku18tiwari",
                        "content": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\n\n\nclass Solution {\n  public: int widthOfBinaryTree(TreeNode * root) {\n    if (root == NULL) return 0;\n    queue < TreeNode * > q;\n    q.push(root);\n    int mx = -1;\n    int f = 0;\n    while (!q.empty()) {\n      int n = q.size();\n      vector < int > level;\n      int l = -1, r = -1, c = -1;\n      for (int i = 0; i < n; i++) {\n        TreeNode * at = new TreeNode(1729);\n        // TreeNode* www = &at;\n        TreeNode * node = q.front();\n        q.pop();\n        if (node -> left == NULL) {\n          q.push(at);\n        } else\n          q.push(node -> left);\n\n        if (node -> right == NULL) {\n          q.push(at);\n        } else\n          q.push(node -> right);\n        c++;\n        if (l == -1 && node -> val != 1729) {\n          l = c;\n        }\n        if (node -> val != 1729) {\n          r = c;\n        }\n        // level.push_back(node->val);\n      }\n      if (l == -1 && r == -1) {\n        break;\n      }\n      mx = max(mx, r - l + 1);\n    }\n    return mx;\n  }\n};\n\n\n\n\nI am getting MLE for this testcase\n\n[0,0,0,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null]\n\n\nI am not sure why. The only large space that can possibly  be taken by in my code is by queue. This testcase has approx 300 nodes each of type TreeNode* (4 bytes I assume). Thus in total the queue size would be approx 1200 (close to 1MB) . MAX size allowed is 100MB in leetcode, hence i am confused.\n\nKindly someone explain \nPS: I am new to the leetcode discussion so please ignore the bad formatting of code\nTIA\n\n\n\n\n\n\n"
                    },
                    {
                        "username": "paullam328",
                        "content": "For those who\\'s having integer overflow problem in JavaScript, check out BigInt type"
                    },
                    {
                        "username": "Priya_G0rg",
                        "content": "TLE \\n[1,1,1,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,null,1,1,null,1,null,1,null,1,null,1,null]\\nExpected ans: 2147483645\\n\\nSomebody please how this ans is achieved and where can I might have removed TLE? Bcoz each level only traversing the required nodes from the leftmost to rightmost non-null nodes?"
                    },
                    {
                        "username": "paullam328",
                        "content": "If you\\'re traversing ONLY the nodes in the tree, this isn\\'t supposed to raise TLE."
                    },
                    {
                        "username": "ayushinsingh",
                        "content": "index can be greater than 32 bit signed integer but answer is within 32 bit signed integer."
                    },
                    {
                        "username": "VladimirKataev",
                        "content": "I think a \"Think about heap indexing\" hint would be very appropriate."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Please remove the last few testCases so that this doesn\\'t require BigInt in JS, or mention it in the question, but this is a really annoying way to fail at the last few testCases, never had to use it before (so at least I learned something new though)"
                    },
                    {
                        "username": "mayankesh",
                        "content": "Can We get depth of tree as d and answer will be 2^d -1 as it will be full tree. Is it wrong assumption, if yes,can some one give example?"
                    },
                    {
                        "username": "_aka5h",
                        "content": "In case of skewed tree, we might have a node which will be represented by 2 ^ 3000. How to deal with that thing here?"
                    },
                    {
                        "username": "Rowansdabomb",
                        "content": "[@_aka5h](/_aka5h) I should have mentioned this is assuming you are using BFS. \n\nAssuming you are using BFS, what can you use about the order of of the nodes X+N, and 2*X+N to correctly get the width knowing these values may have been modded by X? \n\nWhat width would expect in this case? why?"
                    },
                    {
                        "username": "_aka5h",
                        "content": "[@Rowansdabomb](/Rowansdabomb) I don\\'t think taking modulo would be any helpful in this case. Because, lets say you decided to mod with X.\\n\\nAnd there is a level with only 2 nodes represented by X + N and 2 * X + N where (N < X), taking modulo here will make both of them equal to N which will definitely lead to unexpected answer.\\n\\nThe only reason why the approach work even without taking modulo is because testcases aren\\'t designed that way to have a node represented by a value greater than 2 ^ 64, which I think is misleading since it is clearly mentioned in constraints that the tree can have atmost 3000 nodes."
                    },
                    {
                        "username": "Rowansdabomb",
                        "content": "> It is guaranteed that the answer will in the range of a 32-bit signed integer.\\n\\nMy hints would be:\\n- use the modulus for large values\\n- note any special cases when computing the width with values that were modded\\n\\n"
                    },
                    {
                        "username": "Rowansdabomb",
                        "content": "These were the observations necessary for me to solve.\n\nObservation 1:\nThe question is about max widths, which suggests BFS.\n\nObservation 2: (This is the big one)\nLet each row of a full binary tree be indexed from 0.\nFor a node at index i:\n  - the index of it's left child will be 2*i \n  - the index of it's right child will be 2*i + 1\nLook at the diagram below to convince yourself this is true.\n\n``` \n         0            // 0\n    0          1      // 2*0, 2*0 + 1\n 0     1    2     3   // 2*0, 2*0 + 1, 2*1, 2*1+1\n0 1   2 3  4 5   6 7  // etc..\n```\n\nObservation 3:\nMax nodes of 3000 means a max depth of 3000, which means a max index range of 0->2^3000 (way too large to store in an int).\nHowever; we know the maximum possible width is 2^32."
                    }
                ]
            },
            {
                "id": 1911284,
                "content": [
                    {
                        "username": "raiabhinavprakash",
                        "content": "This code is giving wrong answer at 101/114 test case. Can anybody pointout possible mistakes in it?\\n````\\nint widthOfBinaryTree(TreeNode* root) {\\n        long long int ans = 1, c = 1;\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        while(q.size())\\n        {\\n            int k = q.size();\\n            vector<int>v;\\n            for(int i = 0; i<k; i++)\\n            {\\n                auto a = q.front();\\n                q.pop();\\n                if(a->left)\\n                {\\n                    q.push(a->left);\\n                    v.push_back(a->left->val);\\n                }\\n                else v.push_back(-101);\\n                if(a->right)\\n                {\\n                    q.push(a->right);\\n                    v.push_back(a->right->val);\\n                }\\n                else v.push_back(-101);\\n            }\\n            if(!q.size()) break;\\n            c *= 2;\\n            long long i = 0, j = v.size()-1;\\n            while(i<=j && v[i] == -101) {i++; c--;}\\n            while(j>=i && v[j] == -101) {j--; c--;}\\n            ans = max(ans, c);\\n        }\\n        return ans;\\n    }\\n````"
                    },
                    {
                        "username": "akku18tiwari",
                        "content": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\n\n\nclass Solution {\n  public: int widthOfBinaryTree(TreeNode * root) {\n    if (root == NULL) return 0;\n    queue < TreeNode * > q;\n    q.push(root);\n    int mx = -1;\n    int f = 0;\n    while (!q.empty()) {\n      int n = q.size();\n      vector < int > level;\n      int l = -1, r = -1, c = -1;\n      for (int i = 0; i < n; i++) {\n        TreeNode * at = new TreeNode(1729);\n        // TreeNode* www = &at;\n        TreeNode * node = q.front();\n        q.pop();\n        if (node -> left == NULL) {\n          q.push(at);\n        } else\n          q.push(node -> left);\n\n        if (node -> right == NULL) {\n          q.push(at);\n        } else\n          q.push(node -> right);\n        c++;\n        if (l == -1 && node -> val != 1729) {\n          l = c;\n        }\n        if (node -> val != 1729) {\n          r = c;\n        }\n        // level.push_back(node->val);\n      }\n      if (l == -1 && r == -1) {\n        break;\n      }\n      mx = max(mx, r - l + 1);\n    }\n    return mx;\n  }\n};\n\n\n\n\nI am getting MLE for this testcase\n\n[0,0,0,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null]\n\n\nI am not sure why. The only large space that can possibly  be taken by in my code is by queue. This testcase has approx 300 nodes each of type TreeNode* (4 bytes I assume). Thus in total the queue size would be approx 1200 (close to 1MB) . MAX size allowed is 100MB in leetcode, hence i am confused.\n\nKindly someone explain \nPS: I am new to the leetcode discussion so please ignore the bad formatting of code\nTIA\n\n\n\n\n\n\n"
                    },
                    {
                        "username": "paullam328",
                        "content": "For those who\\'s having integer overflow problem in JavaScript, check out BigInt type"
                    },
                    {
                        "username": "Priya_G0rg",
                        "content": "TLE \\n[1,1,1,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,null,1,1,null,1,null,1,null,1,null,1,null]\\nExpected ans: 2147483645\\n\\nSomebody please how this ans is achieved and where can I might have removed TLE? Bcoz each level only traversing the required nodes from the leftmost to rightmost non-null nodes?"
                    },
                    {
                        "username": "paullam328",
                        "content": "If you\\'re traversing ONLY the nodes in the tree, this isn\\'t supposed to raise TLE."
                    },
                    {
                        "username": "ayushinsingh",
                        "content": "index can be greater than 32 bit signed integer but answer is within 32 bit signed integer."
                    },
                    {
                        "username": "VladimirKataev",
                        "content": "I think a \"Think about heap indexing\" hint would be very appropriate."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Please remove the last few testCases so that this doesn\\'t require BigInt in JS, or mention it in the question, but this is a really annoying way to fail at the last few testCases, never had to use it before (so at least I learned something new though)"
                    },
                    {
                        "username": "mayankesh",
                        "content": "Can We get depth of tree as d and answer will be 2^d -1 as it will be full tree. Is it wrong assumption, if yes,can some one give example?"
                    },
                    {
                        "username": "_aka5h",
                        "content": "In case of skewed tree, we might have a node which will be represented by 2 ^ 3000. How to deal with that thing here?"
                    },
                    {
                        "username": "Rowansdabomb",
                        "content": "[@_aka5h](/_aka5h) I should have mentioned this is assuming you are using BFS. \n\nAssuming you are using BFS, what can you use about the order of of the nodes X+N, and 2*X+N to correctly get the width knowing these values may have been modded by X? \n\nWhat width would expect in this case? why?"
                    },
                    {
                        "username": "_aka5h",
                        "content": "[@Rowansdabomb](/Rowansdabomb) I don\\'t think taking modulo would be any helpful in this case. Because, lets say you decided to mod with X.\\n\\nAnd there is a level with only 2 nodes represented by X + N and 2 * X + N where (N < X), taking modulo here will make both of them equal to N which will definitely lead to unexpected answer.\\n\\nThe only reason why the approach work even without taking modulo is because testcases aren\\'t designed that way to have a node represented by a value greater than 2 ^ 64, which I think is misleading since it is clearly mentioned in constraints that the tree can have atmost 3000 nodes."
                    },
                    {
                        "username": "Rowansdabomb",
                        "content": "> It is guaranteed that the answer will in the range of a 32-bit signed integer.\\n\\nMy hints would be:\\n- use the modulus for large values\\n- note any special cases when computing the width with values that were modded\\n\\n"
                    },
                    {
                        "username": "Rowansdabomb",
                        "content": "These were the observations necessary for me to solve.\n\nObservation 1:\nThe question is about max widths, which suggests BFS.\n\nObservation 2: (This is the big one)\nLet each row of a full binary tree be indexed from 0.\nFor a node at index i:\n  - the index of it's left child will be 2*i \n  - the index of it's right child will be 2*i + 1\nLook at the diagram below to convince yourself this is true.\n\n``` \n         0            // 0\n    0          1      // 2*0, 2*0 + 1\n 0     1    2     3   // 2*0, 2*0 + 1, 2*1, 2*1+1\n0 1   2 3  4 5   6 7  // etc..\n```\n\nObservation 3:\nMax nodes of 3000 means a max depth of 3000, which means a max index range of 0->2^3000 (way too large to store in an int).\nHowever; we know the maximum possible width is 2^32."
                    }
                ]
            },
            {
                "id": 1887700,
                "content": [
                    {
                        "username": "raiabhinavprakash",
                        "content": "This code is giving wrong answer at 101/114 test case. Can anybody pointout possible mistakes in it?\\n````\\nint widthOfBinaryTree(TreeNode* root) {\\n        long long int ans = 1, c = 1;\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        while(q.size())\\n        {\\n            int k = q.size();\\n            vector<int>v;\\n            for(int i = 0; i<k; i++)\\n            {\\n                auto a = q.front();\\n                q.pop();\\n                if(a->left)\\n                {\\n                    q.push(a->left);\\n                    v.push_back(a->left->val);\\n                }\\n                else v.push_back(-101);\\n                if(a->right)\\n                {\\n                    q.push(a->right);\\n                    v.push_back(a->right->val);\\n                }\\n                else v.push_back(-101);\\n            }\\n            if(!q.size()) break;\\n            c *= 2;\\n            long long i = 0, j = v.size()-1;\\n            while(i<=j && v[i] == -101) {i++; c--;}\\n            while(j>=i && v[j] == -101) {j--; c--;}\\n            ans = max(ans, c);\\n        }\\n        return ans;\\n    }\\n````"
                    },
                    {
                        "username": "akku18tiwari",
                        "content": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\n\n\nclass Solution {\n  public: int widthOfBinaryTree(TreeNode * root) {\n    if (root == NULL) return 0;\n    queue < TreeNode * > q;\n    q.push(root);\n    int mx = -1;\n    int f = 0;\n    while (!q.empty()) {\n      int n = q.size();\n      vector < int > level;\n      int l = -1, r = -1, c = -1;\n      for (int i = 0; i < n; i++) {\n        TreeNode * at = new TreeNode(1729);\n        // TreeNode* www = &at;\n        TreeNode * node = q.front();\n        q.pop();\n        if (node -> left == NULL) {\n          q.push(at);\n        } else\n          q.push(node -> left);\n\n        if (node -> right == NULL) {\n          q.push(at);\n        } else\n          q.push(node -> right);\n        c++;\n        if (l == -1 && node -> val != 1729) {\n          l = c;\n        }\n        if (node -> val != 1729) {\n          r = c;\n        }\n        // level.push_back(node->val);\n      }\n      if (l == -1 && r == -1) {\n        break;\n      }\n      mx = max(mx, r - l + 1);\n    }\n    return mx;\n  }\n};\n\n\n\n\nI am getting MLE for this testcase\n\n[0,0,0,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null]\n\n\nI am not sure why. The only large space that can possibly  be taken by in my code is by queue. This testcase has approx 300 nodes each of type TreeNode* (4 bytes I assume). Thus in total the queue size would be approx 1200 (close to 1MB) . MAX size allowed is 100MB in leetcode, hence i am confused.\n\nKindly someone explain \nPS: I am new to the leetcode discussion so please ignore the bad formatting of code\nTIA\n\n\n\n\n\n\n"
                    },
                    {
                        "username": "paullam328",
                        "content": "For those who\\'s having integer overflow problem in JavaScript, check out BigInt type"
                    },
                    {
                        "username": "Priya_G0rg",
                        "content": "TLE \\n[1,1,1,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,null,1,1,null,1,null,1,null,1,null,1,null]\\nExpected ans: 2147483645\\n\\nSomebody please how this ans is achieved and where can I might have removed TLE? Bcoz each level only traversing the required nodes from the leftmost to rightmost non-null nodes?"
                    },
                    {
                        "username": "paullam328",
                        "content": "If you\\'re traversing ONLY the nodes in the tree, this isn\\'t supposed to raise TLE."
                    },
                    {
                        "username": "ayushinsingh",
                        "content": "index can be greater than 32 bit signed integer but answer is within 32 bit signed integer."
                    },
                    {
                        "username": "VladimirKataev",
                        "content": "I think a \"Think about heap indexing\" hint would be very appropriate."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Please remove the last few testCases so that this doesn\\'t require BigInt in JS, or mention it in the question, but this is a really annoying way to fail at the last few testCases, never had to use it before (so at least I learned something new though)"
                    },
                    {
                        "username": "mayankesh",
                        "content": "Can We get depth of tree as d and answer will be 2^d -1 as it will be full tree. Is it wrong assumption, if yes,can some one give example?"
                    },
                    {
                        "username": "_aka5h",
                        "content": "In case of skewed tree, we might have a node which will be represented by 2 ^ 3000. How to deal with that thing here?"
                    },
                    {
                        "username": "Rowansdabomb",
                        "content": "[@_aka5h](/_aka5h) I should have mentioned this is assuming you are using BFS. \n\nAssuming you are using BFS, what can you use about the order of of the nodes X+N, and 2*X+N to correctly get the width knowing these values may have been modded by X? \n\nWhat width would expect in this case? why?"
                    },
                    {
                        "username": "_aka5h",
                        "content": "[@Rowansdabomb](/Rowansdabomb) I don\\'t think taking modulo would be any helpful in this case. Because, lets say you decided to mod with X.\\n\\nAnd there is a level with only 2 nodes represented by X + N and 2 * X + N where (N < X), taking modulo here will make both of them equal to N which will definitely lead to unexpected answer.\\n\\nThe only reason why the approach work even without taking modulo is because testcases aren\\'t designed that way to have a node represented by a value greater than 2 ^ 64, which I think is misleading since it is clearly mentioned in constraints that the tree can have atmost 3000 nodes."
                    },
                    {
                        "username": "Rowansdabomb",
                        "content": "> It is guaranteed that the answer will in the range of a 32-bit signed integer.\\n\\nMy hints would be:\\n- use the modulus for large values\\n- note any special cases when computing the width with values that were modded\\n\\n"
                    },
                    {
                        "username": "Rowansdabomb",
                        "content": "These were the observations necessary for me to solve.\n\nObservation 1:\nThe question is about max widths, which suggests BFS.\n\nObservation 2: (This is the big one)\nLet each row of a full binary tree be indexed from 0.\nFor a node at index i:\n  - the index of it's left child will be 2*i \n  - the index of it's right child will be 2*i + 1\nLook at the diagram below to convince yourself this is true.\n\n``` \n         0            // 0\n    0          1      // 2*0, 2*0 + 1\n 0     1    2     3   // 2*0, 2*0 + 1, 2*1, 2*1+1\n0 1   2 3  4 5   6 7  // etc..\n```\n\nObservation 3:\nMax nodes of 3000 means a max depth of 3000, which means a max index range of 0->2^3000 (way too large to store in an int).\nHowever; we know the maximum possible width is 2^32."
                    }
                ]
            },
            {
                "id": 1873598,
                "content": [
                    {
                        "username": "raiabhinavprakash",
                        "content": "This code is giving wrong answer at 101/114 test case. Can anybody pointout possible mistakes in it?\\n````\\nint widthOfBinaryTree(TreeNode* root) {\\n        long long int ans = 1, c = 1;\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        while(q.size())\\n        {\\n            int k = q.size();\\n            vector<int>v;\\n            for(int i = 0; i<k; i++)\\n            {\\n                auto a = q.front();\\n                q.pop();\\n                if(a->left)\\n                {\\n                    q.push(a->left);\\n                    v.push_back(a->left->val);\\n                }\\n                else v.push_back(-101);\\n                if(a->right)\\n                {\\n                    q.push(a->right);\\n                    v.push_back(a->right->val);\\n                }\\n                else v.push_back(-101);\\n            }\\n            if(!q.size()) break;\\n            c *= 2;\\n            long long i = 0, j = v.size()-1;\\n            while(i<=j && v[i] == -101) {i++; c--;}\\n            while(j>=i && v[j] == -101) {j--; c--;}\\n            ans = max(ans, c);\\n        }\\n        return ans;\\n    }\\n````"
                    },
                    {
                        "username": "akku18tiwari",
                        "content": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\n\n\nclass Solution {\n  public: int widthOfBinaryTree(TreeNode * root) {\n    if (root == NULL) return 0;\n    queue < TreeNode * > q;\n    q.push(root);\n    int mx = -1;\n    int f = 0;\n    while (!q.empty()) {\n      int n = q.size();\n      vector < int > level;\n      int l = -1, r = -1, c = -1;\n      for (int i = 0; i < n; i++) {\n        TreeNode * at = new TreeNode(1729);\n        // TreeNode* www = &at;\n        TreeNode * node = q.front();\n        q.pop();\n        if (node -> left == NULL) {\n          q.push(at);\n        } else\n          q.push(node -> left);\n\n        if (node -> right == NULL) {\n          q.push(at);\n        } else\n          q.push(node -> right);\n        c++;\n        if (l == -1 && node -> val != 1729) {\n          l = c;\n        }\n        if (node -> val != 1729) {\n          r = c;\n        }\n        // level.push_back(node->val);\n      }\n      if (l == -1 && r == -1) {\n        break;\n      }\n      mx = max(mx, r - l + 1);\n    }\n    return mx;\n  }\n};\n\n\n\n\nI am getting MLE for this testcase\n\n[0,0,0,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null]\n\n\nI am not sure why. The only large space that can possibly  be taken by in my code is by queue. This testcase has approx 300 nodes each of type TreeNode* (4 bytes I assume). Thus in total the queue size would be approx 1200 (close to 1MB) . MAX size allowed is 100MB in leetcode, hence i am confused.\n\nKindly someone explain \nPS: I am new to the leetcode discussion so please ignore the bad formatting of code\nTIA\n\n\n\n\n\n\n"
                    },
                    {
                        "username": "paullam328",
                        "content": "For those who\\'s having integer overflow problem in JavaScript, check out BigInt type"
                    },
                    {
                        "username": "Priya_G0rg",
                        "content": "TLE \\n[1,1,1,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,null,1,1,null,1,null,1,null,1,null,1,null]\\nExpected ans: 2147483645\\n\\nSomebody please how this ans is achieved and where can I might have removed TLE? Bcoz each level only traversing the required nodes from the leftmost to rightmost non-null nodes?"
                    },
                    {
                        "username": "paullam328",
                        "content": "If you\\'re traversing ONLY the nodes in the tree, this isn\\'t supposed to raise TLE."
                    },
                    {
                        "username": "ayushinsingh",
                        "content": "index can be greater than 32 bit signed integer but answer is within 32 bit signed integer."
                    },
                    {
                        "username": "VladimirKataev",
                        "content": "I think a \"Think about heap indexing\" hint would be very appropriate."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Please remove the last few testCases so that this doesn\\'t require BigInt in JS, or mention it in the question, but this is a really annoying way to fail at the last few testCases, never had to use it before (so at least I learned something new though)"
                    },
                    {
                        "username": "mayankesh",
                        "content": "Can We get depth of tree as d and answer will be 2^d -1 as it will be full tree. Is it wrong assumption, if yes,can some one give example?"
                    },
                    {
                        "username": "_aka5h",
                        "content": "In case of skewed tree, we might have a node which will be represented by 2 ^ 3000. How to deal with that thing here?"
                    },
                    {
                        "username": "Rowansdabomb",
                        "content": "[@_aka5h](/_aka5h) I should have mentioned this is assuming you are using BFS. \n\nAssuming you are using BFS, what can you use about the order of of the nodes X+N, and 2*X+N to correctly get the width knowing these values may have been modded by X? \n\nWhat width would expect in this case? why?"
                    },
                    {
                        "username": "_aka5h",
                        "content": "[@Rowansdabomb](/Rowansdabomb) I don\\'t think taking modulo would be any helpful in this case. Because, lets say you decided to mod with X.\\n\\nAnd there is a level with only 2 nodes represented by X + N and 2 * X + N where (N < X), taking modulo here will make both of them equal to N which will definitely lead to unexpected answer.\\n\\nThe only reason why the approach work even without taking modulo is because testcases aren\\'t designed that way to have a node represented by a value greater than 2 ^ 64, which I think is misleading since it is clearly mentioned in constraints that the tree can have atmost 3000 nodes."
                    },
                    {
                        "username": "Rowansdabomb",
                        "content": "> It is guaranteed that the answer will in the range of a 32-bit signed integer.\\n\\nMy hints would be:\\n- use the modulus for large values\\n- note any special cases when computing the width with values that were modded\\n\\n"
                    },
                    {
                        "username": "Rowansdabomb",
                        "content": "These were the observations necessary for me to solve.\n\nObservation 1:\nThe question is about max widths, which suggests BFS.\n\nObservation 2: (This is the big one)\nLet each row of a full binary tree be indexed from 0.\nFor a node at index i:\n  - the index of it's left child will be 2*i \n  - the index of it's right child will be 2*i + 1\nLook at the diagram below to convince yourself this is true.\n\n``` \n         0            // 0\n    0          1      // 2*0, 2*0 + 1\n 0     1    2     3   // 2*0, 2*0 + 1, 2*1, 2*1+1\n0 1   2 3  4 5   6 7  // etc..\n```\n\nObservation 3:\nMax nodes of 3000 means a max depth of 3000, which means a max index range of 0->2^3000 (way too large to store in an int).\nHowever; we know the maximum possible width is 2^32."
                    }
                ]
            },
            {
                "id": 1870712,
                "content": [
                    {
                        "username": "raiabhinavprakash",
                        "content": "This code is giving wrong answer at 101/114 test case. Can anybody pointout possible mistakes in it?\\n````\\nint widthOfBinaryTree(TreeNode* root) {\\n        long long int ans = 1, c = 1;\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        while(q.size())\\n        {\\n            int k = q.size();\\n            vector<int>v;\\n            for(int i = 0; i<k; i++)\\n            {\\n                auto a = q.front();\\n                q.pop();\\n                if(a->left)\\n                {\\n                    q.push(a->left);\\n                    v.push_back(a->left->val);\\n                }\\n                else v.push_back(-101);\\n                if(a->right)\\n                {\\n                    q.push(a->right);\\n                    v.push_back(a->right->val);\\n                }\\n                else v.push_back(-101);\\n            }\\n            if(!q.size()) break;\\n            c *= 2;\\n            long long i = 0, j = v.size()-1;\\n            while(i<=j && v[i] == -101) {i++; c--;}\\n            while(j>=i && v[j] == -101) {j--; c--;}\\n            ans = max(ans, c);\\n        }\\n        return ans;\\n    }\\n````"
                    },
                    {
                        "username": "akku18tiwari",
                        "content": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\n\n\nclass Solution {\n  public: int widthOfBinaryTree(TreeNode * root) {\n    if (root == NULL) return 0;\n    queue < TreeNode * > q;\n    q.push(root);\n    int mx = -1;\n    int f = 0;\n    while (!q.empty()) {\n      int n = q.size();\n      vector < int > level;\n      int l = -1, r = -1, c = -1;\n      for (int i = 0; i < n; i++) {\n        TreeNode * at = new TreeNode(1729);\n        // TreeNode* www = &at;\n        TreeNode * node = q.front();\n        q.pop();\n        if (node -> left == NULL) {\n          q.push(at);\n        } else\n          q.push(node -> left);\n\n        if (node -> right == NULL) {\n          q.push(at);\n        } else\n          q.push(node -> right);\n        c++;\n        if (l == -1 && node -> val != 1729) {\n          l = c;\n        }\n        if (node -> val != 1729) {\n          r = c;\n        }\n        // level.push_back(node->val);\n      }\n      if (l == -1 && r == -1) {\n        break;\n      }\n      mx = max(mx, r - l + 1);\n    }\n    return mx;\n  }\n};\n\n\n\n\nI am getting MLE for this testcase\n\n[0,0,0,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null]\n\n\nI am not sure why. The only large space that can possibly  be taken by in my code is by queue. This testcase has approx 300 nodes each of type TreeNode* (4 bytes I assume). Thus in total the queue size would be approx 1200 (close to 1MB) . MAX size allowed is 100MB in leetcode, hence i am confused.\n\nKindly someone explain \nPS: I am new to the leetcode discussion so please ignore the bad formatting of code\nTIA\n\n\n\n\n\n\n"
                    },
                    {
                        "username": "paullam328",
                        "content": "For those who\\'s having integer overflow problem in JavaScript, check out BigInt type"
                    },
                    {
                        "username": "Priya_G0rg",
                        "content": "TLE \\n[1,1,1,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,null,1,1,null,1,null,1,null,1,null,1,null]\\nExpected ans: 2147483645\\n\\nSomebody please how this ans is achieved and where can I might have removed TLE? Bcoz each level only traversing the required nodes from the leftmost to rightmost non-null nodes?"
                    },
                    {
                        "username": "paullam328",
                        "content": "If you\\'re traversing ONLY the nodes in the tree, this isn\\'t supposed to raise TLE."
                    },
                    {
                        "username": "ayushinsingh",
                        "content": "index can be greater than 32 bit signed integer but answer is within 32 bit signed integer."
                    },
                    {
                        "username": "VladimirKataev",
                        "content": "I think a \"Think about heap indexing\" hint would be very appropriate."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Please remove the last few testCases so that this doesn\\'t require BigInt in JS, or mention it in the question, but this is a really annoying way to fail at the last few testCases, never had to use it before (so at least I learned something new though)"
                    },
                    {
                        "username": "mayankesh",
                        "content": "Can We get depth of tree as d and answer will be 2^d -1 as it will be full tree. Is it wrong assumption, if yes,can some one give example?"
                    },
                    {
                        "username": "_aka5h",
                        "content": "In case of skewed tree, we might have a node which will be represented by 2 ^ 3000. How to deal with that thing here?"
                    },
                    {
                        "username": "Rowansdabomb",
                        "content": "[@_aka5h](/_aka5h) I should have mentioned this is assuming you are using BFS. \n\nAssuming you are using BFS, what can you use about the order of of the nodes X+N, and 2*X+N to correctly get the width knowing these values may have been modded by X? \n\nWhat width would expect in this case? why?"
                    },
                    {
                        "username": "_aka5h",
                        "content": "[@Rowansdabomb](/Rowansdabomb) I don\\'t think taking modulo would be any helpful in this case. Because, lets say you decided to mod with X.\\n\\nAnd there is a level with only 2 nodes represented by X + N and 2 * X + N where (N < X), taking modulo here will make both of them equal to N which will definitely lead to unexpected answer.\\n\\nThe only reason why the approach work even without taking modulo is because testcases aren\\'t designed that way to have a node represented by a value greater than 2 ^ 64, which I think is misleading since it is clearly mentioned in constraints that the tree can have atmost 3000 nodes."
                    },
                    {
                        "username": "Rowansdabomb",
                        "content": "> It is guaranteed that the answer will in the range of a 32-bit signed integer.\\n\\nMy hints would be:\\n- use the modulus for large values\\n- note any special cases when computing the width with values that were modded\\n\\n"
                    },
                    {
                        "username": "Rowansdabomb",
                        "content": "These were the observations necessary for me to solve.\n\nObservation 1:\nThe question is about max widths, which suggests BFS.\n\nObservation 2: (This is the big one)\nLet each row of a full binary tree be indexed from 0.\nFor a node at index i:\n  - the index of it's left child will be 2*i \n  - the index of it's right child will be 2*i + 1\nLook at the diagram below to convince yourself this is true.\n\n``` \n         0            // 0\n    0          1      // 2*0, 2*0 + 1\n 0     1    2     3   // 2*0, 2*0 + 1, 2*1, 2*1+1\n0 1   2 3  4 5   6 7  // etc..\n```\n\nObservation 3:\nMax nodes of 3000 means a max depth of 3000, which means a max index range of 0->2^3000 (way too large to store in an int).\nHowever; we know the maximum possible width is 2^32."
                    }
                ]
            },
            {
                "id": 1869639,
                "content": [
                    {
                        "username": "raiabhinavprakash",
                        "content": "This code is giving wrong answer at 101/114 test case. Can anybody pointout possible mistakes in it?\\n````\\nint widthOfBinaryTree(TreeNode* root) {\\n        long long int ans = 1, c = 1;\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        while(q.size())\\n        {\\n            int k = q.size();\\n            vector<int>v;\\n            for(int i = 0; i<k; i++)\\n            {\\n                auto a = q.front();\\n                q.pop();\\n                if(a->left)\\n                {\\n                    q.push(a->left);\\n                    v.push_back(a->left->val);\\n                }\\n                else v.push_back(-101);\\n                if(a->right)\\n                {\\n                    q.push(a->right);\\n                    v.push_back(a->right->val);\\n                }\\n                else v.push_back(-101);\\n            }\\n            if(!q.size()) break;\\n            c *= 2;\\n            long long i = 0, j = v.size()-1;\\n            while(i<=j && v[i] == -101) {i++; c--;}\\n            while(j>=i && v[j] == -101) {j--; c--;}\\n            ans = max(ans, c);\\n        }\\n        return ans;\\n    }\\n````"
                    },
                    {
                        "username": "akku18tiwari",
                        "content": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\n\n\nclass Solution {\n  public: int widthOfBinaryTree(TreeNode * root) {\n    if (root == NULL) return 0;\n    queue < TreeNode * > q;\n    q.push(root);\n    int mx = -1;\n    int f = 0;\n    while (!q.empty()) {\n      int n = q.size();\n      vector < int > level;\n      int l = -1, r = -1, c = -1;\n      for (int i = 0; i < n; i++) {\n        TreeNode * at = new TreeNode(1729);\n        // TreeNode* www = &at;\n        TreeNode * node = q.front();\n        q.pop();\n        if (node -> left == NULL) {\n          q.push(at);\n        } else\n          q.push(node -> left);\n\n        if (node -> right == NULL) {\n          q.push(at);\n        } else\n          q.push(node -> right);\n        c++;\n        if (l == -1 && node -> val != 1729) {\n          l = c;\n        }\n        if (node -> val != 1729) {\n          r = c;\n        }\n        // level.push_back(node->val);\n      }\n      if (l == -1 && r == -1) {\n        break;\n      }\n      mx = max(mx, r - l + 1);\n    }\n    return mx;\n  }\n};\n\n\n\n\nI am getting MLE for this testcase\n\n[0,0,0,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null]\n\n\nI am not sure why. The only large space that can possibly  be taken by in my code is by queue. This testcase has approx 300 nodes each of type TreeNode* (4 bytes I assume). Thus in total the queue size would be approx 1200 (close to 1MB) . MAX size allowed is 100MB in leetcode, hence i am confused.\n\nKindly someone explain \nPS: I am new to the leetcode discussion so please ignore the bad formatting of code\nTIA\n\n\n\n\n\n\n"
                    },
                    {
                        "username": "paullam328",
                        "content": "For those who\\'s having integer overflow problem in JavaScript, check out BigInt type"
                    },
                    {
                        "username": "Priya_G0rg",
                        "content": "TLE \\n[1,1,1,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,null,1,1,null,1,null,1,null,1,null,1,null]\\nExpected ans: 2147483645\\n\\nSomebody please how this ans is achieved and where can I might have removed TLE? Bcoz each level only traversing the required nodes from the leftmost to rightmost non-null nodes?"
                    },
                    {
                        "username": "paullam328",
                        "content": "If you\\'re traversing ONLY the nodes in the tree, this isn\\'t supposed to raise TLE."
                    },
                    {
                        "username": "ayushinsingh",
                        "content": "index can be greater than 32 bit signed integer but answer is within 32 bit signed integer."
                    },
                    {
                        "username": "VladimirKataev",
                        "content": "I think a \"Think about heap indexing\" hint would be very appropriate."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Please remove the last few testCases so that this doesn\\'t require BigInt in JS, or mention it in the question, but this is a really annoying way to fail at the last few testCases, never had to use it before (so at least I learned something new though)"
                    },
                    {
                        "username": "mayankesh",
                        "content": "Can We get depth of tree as d and answer will be 2^d -1 as it will be full tree. Is it wrong assumption, if yes,can some one give example?"
                    },
                    {
                        "username": "_aka5h",
                        "content": "In case of skewed tree, we might have a node which will be represented by 2 ^ 3000. How to deal with that thing here?"
                    },
                    {
                        "username": "Rowansdabomb",
                        "content": "[@_aka5h](/_aka5h) I should have mentioned this is assuming you are using BFS. \n\nAssuming you are using BFS, what can you use about the order of of the nodes X+N, and 2*X+N to correctly get the width knowing these values may have been modded by X? \n\nWhat width would expect in this case? why?"
                    },
                    {
                        "username": "_aka5h",
                        "content": "[@Rowansdabomb](/Rowansdabomb) I don\\'t think taking modulo would be any helpful in this case. Because, lets say you decided to mod with X.\\n\\nAnd there is a level with only 2 nodes represented by X + N and 2 * X + N where (N < X), taking modulo here will make both of them equal to N which will definitely lead to unexpected answer.\\n\\nThe only reason why the approach work even without taking modulo is because testcases aren\\'t designed that way to have a node represented by a value greater than 2 ^ 64, which I think is misleading since it is clearly mentioned in constraints that the tree can have atmost 3000 nodes."
                    },
                    {
                        "username": "Rowansdabomb",
                        "content": "> It is guaranteed that the answer will in the range of a 32-bit signed integer.\\n\\nMy hints would be:\\n- use the modulus for large values\\n- note any special cases when computing the width with values that were modded\\n\\n"
                    },
                    {
                        "username": "Rowansdabomb",
                        "content": "These were the observations necessary for me to solve.\n\nObservation 1:\nThe question is about max widths, which suggests BFS.\n\nObservation 2: (This is the big one)\nLet each row of a full binary tree be indexed from 0.\nFor a node at index i:\n  - the index of it's left child will be 2*i \n  - the index of it's right child will be 2*i + 1\nLook at the diagram below to convince yourself this is true.\n\n``` \n         0            // 0\n    0          1      // 2*0, 2*0 + 1\n 0     1    2     3   // 2*0, 2*0 + 1, 2*1, 2*1+1\n0 1   2 3  4 5   6 7  // etc..\n```\n\nObservation 3:\nMax nodes of 3000 means a max depth of 3000, which means a max index range of 0->2^3000 (way too large to store in an int).\nHowever; we know the maximum possible width is 2^32."
                    }
                ]
            },
            {
                "id": 1869598,
                "content": [
                    {
                        "username": "raiabhinavprakash",
                        "content": "This code is giving wrong answer at 101/114 test case. Can anybody pointout possible mistakes in it?\\n````\\nint widthOfBinaryTree(TreeNode* root) {\\n        long long int ans = 1, c = 1;\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        while(q.size())\\n        {\\n            int k = q.size();\\n            vector<int>v;\\n            for(int i = 0; i<k; i++)\\n            {\\n                auto a = q.front();\\n                q.pop();\\n                if(a->left)\\n                {\\n                    q.push(a->left);\\n                    v.push_back(a->left->val);\\n                }\\n                else v.push_back(-101);\\n                if(a->right)\\n                {\\n                    q.push(a->right);\\n                    v.push_back(a->right->val);\\n                }\\n                else v.push_back(-101);\\n            }\\n            if(!q.size()) break;\\n            c *= 2;\\n            long long i = 0, j = v.size()-1;\\n            while(i<=j && v[i] == -101) {i++; c--;}\\n            while(j>=i && v[j] == -101) {j--; c--;}\\n            ans = max(ans, c);\\n        }\\n        return ans;\\n    }\\n````"
                    },
                    {
                        "username": "akku18tiwari",
                        "content": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\n\n\nclass Solution {\n  public: int widthOfBinaryTree(TreeNode * root) {\n    if (root == NULL) return 0;\n    queue < TreeNode * > q;\n    q.push(root);\n    int mx = -1;\n    int f = 0;\n    while (!q.empty()) {\n      int n = q.size();\n      vector < int > level;\n      int l = -1, r = -1, c = -1;\n      for (int i = 0; i < n; i++) {\n        TreeNode * at = new TreeNode(1729);\n        // TreeNode* www = &at;\n        TreeNode * node = q.front();\n        q.pop();\n        if (node -> left == NULL) {\n          q.push(at);\n        } else\n          q.push(node -> left);\n\n        if (node -> right == NULL) {\n          q.push(at);\n        } else\n          q.push(node -> right);\n        c++;\n        if (l == -1 && node -> val != 1729) {\n          l = c;\n        }\n        if (node -> val != 1729) {\n          r = c;\n        }\n        // level.push_back(node->val);\n      }\n      if (l == -1 && r == -1) {\n        break;\n      }\n      mx = max(mx, r - l + 1);\n    }\n    return mx;\n  }\n};\n\n\n\n\nI am getting MLE for this testcase\n\n[0,0,0,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null]\n\n\nI am not sure why. The only large space that can possibly  be taken by in my code is by queue. This testcase has approx 300 nodes each of type TreeNode* (4 bytes I assume). Thus in total the queue size would be approx 1200 (close to 1MB) . MAX size allowed is 100MB in leetcode, hence i am confused.\n\nKindly someone explain \nPS: I am new to the leetcode discussion so please ignore the bad formatting of code\nTIA\n\n\n\n\n\n\n"
                    },
                    {
                        "username": "paullam328",
                        "content": "For those who\\'s having integer overflow problem in JavaScript, check out BigInt type"
                    },
                    {
                        "username": "Priya_G0rg",
                        "content": "TLE \\n[1,1,1,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,null,1,1,null,1,null,1,null,1,null,1,null]\\nExpected ans: 2147483645\\n\\nSomebody please how this ans is achieved and where can I might have removed TLE? Bcoz each level only traversing the required nodes from the leftmost to rightmost non-null nodes?"
                    },
                    {
                        "username": "paullam328",
                        "content": "If you\\'re traversing ONLY the nodes in the tree, this isn\\'t supposed to raise TLE."
                    },
                    {
                        "username": "ayushinsingh",
                        "content": "index can be greater than 32 bit signed integer but answer is within 32 bit signed integer."
                    },
                    {
                        "username": "VladimirKataev",
                        "content": "I think a \"Think about heap indexing\" hint would be very appropriate."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Please remove the last few testCases so that this doesn\\'t require BigInt in JS, or mention it in the question, but this is a really annoying way to fail at the last few testCases, never had to use it before (so at least I learned something new though)"
                    },
                    {
                        "username": "mayankesh",
                        "content": "Can We get depth of tree as d and answer will be 2^d -1 as it will be full tree. Is it wrong assumption, if yes,can some one give example?"
                    },
                    {
                        "username": "_aka5h",
                        "content": "In case of skewed tree, we might have a node which will be represented by 2 ^ 3000. How to deal with that thing here?"
                    },
                    {
                        "username": "Rowansdabomb",
                        "content": "[@_aka5h](/_aka5h) I should have mentioned this is assuming you are using BFS. \n\nAssuming you are using BFS, what can you use about the order of of the nodes X+N, and 2*X+N to correctly get the width knowing these values may have been modded by X? \n\nWhat width would expect in this case? why?"
                    },
                    {
                        "username": "_aka5h",
                        "content": "[@Rowansdabomb](/Rowansdabomb) I don\\'t think taking modulo would be any helpful in this case. Because, lets say you decided to mod with X.\\n\\nAnd there is a level with only 2 nodes represented by X + N and 2 * X + N where (N < X), taking modulo here will make both of them equal to N which will definitely lead to unexpected answer.\\n\\nThe only reason why the approach work even without taking modulo is because testcases aren\\'t designed that way to have a node represented by a value greater than 2 ^ 64, which I think is misleading since it is clearly mentioned in constraints that the tree can have atmost 3000 nodes."
                    },
                    {
                        "username": "Rowansdabomb",
                        "content": "> It is guaranteed that the answer will in the range of a 32-bit signed integer.\\n\\nMy hints would be:\\n- use the modulus for large values\\n- note any special cases when computing the width with values that were modded\\n\\n"
                    },
                    {
                        "username": "Rowansdabomb",
                        "content": "These were the observations necessary for me to solve.\n\nObservation 1:\nThe question is about max widths, which suggests BFS.\n\nObservation 2: (This is the big one)\nLet each row of a full binary tree be indexed from 0.\nFor a node at index i:\n  - the index of it's left child will be 2*i \n  - the index of it's right child will be 2*i + 1\nLook at the diagram below to convince yourself this is true.\n\n``` \n         0            // 0\n    0          1      // 2*0, 2*0 + 1\n 0     1    2     3   // 2*0, 2*0 + 1, 2*1, 2*1+1\n0 1   2 3  4 5   6 7  // etc..\n```\n\nObservation 3:\nMax nodes of 3000 means a max depth of 3000, which means a max index range of 0->2^3000 (way too large to store in an int).\nHowever; we know the maximum possible width is 2^32."
                    }
                ]
            },
            {
                "id": 1869506,
                "content": [
                    {
                        "username": "raiabhinavprakash",
                        "content": "This code is giving wrong answer at 101/114 test case. Can anybody pointout possible mistakes in it?\\n````\\nint widthOfBinaryTree(TreeNode* root) {\\n        long long int ans = 1, c = 1;\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        while(q.size())\\n        {\\n            int k = q.size();\\n            vector<int>v;\\n            for(int i = 0; i<k; i++)\\n            {\\n                auto a = q.front();\\n                q.pop();\\n                if(a->left)\\n                {\\n                    q.push(a->left);\\n                    v.push_back(a->left->val);\\n                }\\n                else v.push_back(-101);\\n                if(a->right)\\n                {\\n                    q.push(a->right);\\n                    v.push_back(a->right->val);\\n                }\\n                else v.push_back(-101);\\n            }\\n            if(!q.size()) break;\\n            c *= 2;\\n            long long i = 0, j = v.size()-1;\\n            while(i<=j && v[i] == -101) {i++; c--;}\\n            while(j>=i && v[j] == -101) {j--; c--;}\\n            ans = max(ans, c);\\n        }\\n        return ans;\\n    }\\n````"
                    },
                    {
                        "username": "akku18tiwari",
                        "content": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\n\n\nclass Solution {\n  public: int widthOfBinaryTree(TreeNode * root) {\n    if (root == NULL) return 0;\n    queue < TreeNode * > q;\n    q.push(root);\n    int mx = -1;\n    int f = 0;\n    while (!q.empty()) {\n      int n = q.size();\n      vector < int > level;\n      int l = -1, r = -1, c = -1;\n      for (int i = 0; i < n; i++) {\n        TreeNode * at = new TreeNode(1729);\n        // TreeNode* www = &at;\n        TreeNode * node = q.front();\n        q.pop();\n        if (node -> left == NULL) {\n          q.push(at);\n        } else\n          q.push(node -> left);\n\n        if (node -> right == NULL) {\n          q.push(at);\n        } else\n          q.push(node -> right);\n        c++;\n        if (l == -1 && node -> val != 1729) {\n          l = c;\n        }\n        if (node -> val != 1729) {\n          r = c;\n        }\n        // level.push_back(node->val);\n      }\n      if (l == -1 && r == -1) {\n        break;\n      }\n      mx = max(mx, r - l + 1);\n    }\n    return mx;\n  }\n};\n\n\n\n\nI am getting MLE for this testcase\n\n[0,0,0,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null]\n\n\nI am not sure why. The only large space that can possibly  be taken by in my code is by queue. This testcase has approx 300 nodes each of type TreeNode* (4 bytes I assume). Thus in total the queue size would be approx 1200 (close to 1MB) . MAX size allowed is 100MB in leetcode, hence i am confused.\n\nKindly someone explain \nPS: I am new to the leetcode discussion so please ignore the bad formatting of code\nTIA\n\n\n\n\n\n\n"
                    },
                    {
                        "username": "paullam328",
                        "content": "For those who\\'s having integer overflow problem in JavaScript, check out BigInt type"
                    },
                    {
                        "username": "Priya_G0rg",
                        "content": "TLE \\n[1,1,1,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,null,1,1,null,1,null,1,null,1,null,1,null]\\nExpected ans: 2147483645\\n\\nSomebody please how this ans is achieved and where can I might have removed TLE? Bcoz each level only traversing the required nodes from the leftmost to rightmost non-null nodes?"
                    },
                    {
                        "username": "paullam328",
                        "content": "If you\\'re traversing ONLY the nodes in the tree, this isn\\'t supposed to raise TLE."
                    },
                    {
                        "username": "ayushinsingh",
                        "content": "index can be greater than 32 bit signed integer but answer is within 32 bit signed integer."
                    },
                    {
                        "username": "VladimirKataev",
                        "content": "I think a \"Think about heap indexing\" hint would be very appropriate."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Please remove the last few testCases so that this doesn\\'t require BigInt in JS, or mention it in the question, but this is a really annoying way to fail at the last few testCases, never had to use it before (so at least I learned something new though)"
                    },
                    {
                        "username": "mayankesh",
                        "content": "Can We get depth of tree as d and answer will be 2^d -1 as it will be full tree. Is it wrong assumption, if yes,can some one give example?"
                    },
                    {
                        "username": "_aka5h",
                        "content": "In case of skewed tree, we might have a node which will be represented by 2 ^ 3000. How to deal with that thing here?"
                    },
                    {
                        "username": "Rowansdabomb",
                        "content": "[@_aka5h](/_aka5h) I should have mentioned this is assuming you are using BFS. \n\nAssuming you are using BFS, what can you use about the order of of the nodes X+N, and 2*X+N to correctly get the width knowing these values may have been modded by X? \n\nWhat width would expect in this case? why?"
                    },
                    {
                        "username": "_aka5h",
                        "content": "[@Rowansdabomb](/Rowansdabomb) I don\\'t think taking modulo would be any helpful in this case. Because, lets say you decided to mod with X.\\n\\nAnd there is a level with only 2 nodes represented by X + N and 2 * X + N where (N < X), taking modulo here will make both of them equal to N which will definitely lead to unexpected answer.\\n\\nThe only reason why the approach work even without taking modulo is because testcases aren\\'t designed that way to have a node represented by a value greater than 2 ^ 64, which I think is misleading since it is clearly mentioned in constraints that the tree can have atmost 3000 nodes."
                    },
                    {
                        "username": "Rowansdabomb",
                        "content": "> It is guaranteed that the answer will in the range of a 32-bit signed integer.\\n\\nMy hints would be:\\n- use the modulus for large values\\n- note any special cases when computing the width with values that were modded\\n\\n"
                    },
                    {
                        "username": "Rowansdabomb",
                        "content": "These were the observations necessary for me to solve.\n\nObservation 1:\nThe question is about max widths, which suggests BFS.\n\nObservation 2: (This is the big one)\nLet each row of a full binary tree be indexed from 0.\nFor a node at index i:\n  - the index of it's left child will be 2*i \n  - the index of it's right child will be 2*i + 1\nLook at the diagram below to convince yourself this is true.\n\n``` \n         0            // 0\n    0          1      // 2*0, 2*0 + 1\n 0     1    2     3   // 2*0, 2*0 + 1, 2*1, 2*1+1\n0 1   2 3  4 5   6 7  // etc..\n```\n\nObservation 3:\nMax nodes of 3000 means a max depth of 3000, which means a max index range of 0->2^3000 (way too large to store in an int).\nHowever; we know the maximum possible width is 2^32."
                    }
                ]
            },
            {
                "id": 1869488,
                "content": [
                    {
                        "username": "raiabhinavprakash",
                        "content": "This code is giving wrong answer at 101/114 test case. Can anybody pointout possible mistakes in it?\\n````\\nint widthOfBinaryTree(TreeNode* root) {\\n        long long int ans = 1, c = 1;\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        while(q.size())\\n        {\\n            int k = q.size();\\n            vector<int>v;\\n            for(int i = 0; i<k; i++)\\n            {\\n                auto a = q.front();\\n                q.pop();\\n                if(a->left)\\n                {\\n                    q.push(a->left);\\n                    v.push_back(a->left->val);\\n                }\\n                else v.push_back(-101);\\n                if(a->right)\\n                {\\n                    q.push(a->right);\\n                    v.push_back(a->right->val);\\n                }\\n                else v.push_back(-101);\\n            }\\n            if(!q.size()) break;\\n            c *= 2;\\n            long long i = 0, j = v.size()-1;\\n            while(i<=j && v[i] == -101) {i++; c--;}\\n            while(j>=i && v[j] == -101) {j--; c--;}\\n            ans = max(ans, c);\\n        }\\n        return ans;\\n    }\\n````"
                    },
                    {
                        "username": "akku18tiwari",
                        "content": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\n\n\nclass Solution {\n  public: int widthOfBinaryTree(TreeNode * root) {\n    if (root == NULL) return 0;\n    queue < TreeNode * > q;\n    q.push(root);\n    int mx = -1;\n    int f = 0;\n    while (!q.empty()) {\n      int n = q.size();\n      vector < int > level;\n      int l = -1, r = -1, c = -1;\n      for (int i = 0; i < n; i++) {\n        TreeNode * at = new TreeNode(1729);\n        // TreeNode* www = &at;\n        TreeNode * node = q.front();\n        q.pop();\n        if (node -> left == NULL) {\n          q.push(at);\n        } else\n          q.push(node -> left);\n\n        if (node -> right == NULL) {\n          q.push(at);\n        } else\n          q.push(node -> right);\n        c++;\n        if (l == -1 && node -> val != 1729) {\n          l = c;\n        }\n        if (node -> val != 1729) {\n          r = c;\n        }\n        // level.push_back(node->val);\n      }\n      if (l == -1 && r == -1) {\n        break;\n      }\n      mx = max(mx, r - l + 1);\n    }\n    return mx;\n  }\n};\n\n\n\n\nI am getting MLE for this testcase\n\n[0,0,0,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null]\n\n\nI am not sure why. The only large space that can possibly  be taken by in my code is by queue. This testcase has approx 300 nodes each of type TreeNode* (4 bytes I assume). Thus in total the queue size would be approx 1200 (close to 1MB) . MAX size allowed is 100MB in leetcode, hence i am confused.\n\nKindly someone explain \nPS: I am new to the leetcode discussion so please ignore the bad formatting of code\nTIA\n\n\n\n\n\n\n"
                    },
                    {
                        "username": "paullam328",
                        "content": "For those who\\'s having integer overflow problem in JavaScript, check out BigInt type"
                    },
                    {
                        "username": "Priya_G0rg",
                        "content": "TLE \\n[1,1,1,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,null,1,1,null,1,null,1,null,1,null,1,null]\\nExpected ans: 2147483645\\n\\nSomebody please how this ans is achieved and where can I might have removed TLE? Bcoz each level only traversing the required nodes from the leftmost to rightmost non-null nodes?"
                    },
                    {
                        "username": "paullam328",
                        "content": "If you\\'re traversing ONLY the nodes in the tree, this isn\\'t supposed to raise TLE."
                    },
                    {
                        "username": "ayushinsingh",
                        "content": "index can be greater than 32 bit signed integer but answer is within 32 bit signed integer."
                    },
                    {
                        "username": "VladimirKataev",
                        "content": "I think a \"Think about heap indexing\" hint would be very appropriate."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Please remove the last few testCases so that this doesn\\'t require BigInt in JS, or mention it in the question, but this is a really annoying way to fail at the last few testCases, never had to use it before (so at least I learned something new though)"
                    },
                    {
                        "username": "mayankesh",
                        "content": "Can We get depth of tree as d and answer will be 2^d -1 as it will be full tree. Is it wrong assumption, if yes,can some one give example?"
                    },
                    {
                        "username": "_aka5h",
                        "content": "In case of skewed tree, we might have a node which will be represented by 2 ^ 3000. How to deal with that thing here?"
                    },
                    {
                        "username": "Rowansdabomb",
                        "content": "[@_aka5h](/_aka5h) I should have mentioned this is assuming you are using BFS. \n\nAssuming you are using BFS, what can you use about the order of of the nodes X+N, and 2*X+N to correctly get the width knowing these values may have been modded by X? \n\nWhat width would expect in this case? why?"
                    },
                    {
                        "username": "_aka5h",
                        "content": "[@Rowansdabomb](/Rowansdabomb) I don\\'t think taking modulo would be any helpful in this case. Because, lets say you decided to mod with X.\\n\\nAnd there is a level with only 2 nodes represented by X + N and 2 * X + N where (N < X), taking modulo here will make both of them equal to N which will definitely lead to unexpected answer.\\n\\nThe only reason why the approach work even without taking modulo is because testcases aren\\'t designed that way to have a node represented by a value greater than 2 ^ 64, which I think is misleading since it is clearly mentioned in constraints that the tree can have atmost 3000 nodes."
                    },
                    {
                        "username": "Rowansdabomb",
                        "content": "> It is guaranteed that the answer will in the range of a 32-bit signed integer.\\n\\nMy hints would be:\\n- use the modulus for large values\\n- note any special cases when computing the width with values that were modded\\n\\n"
                    },
                    {
                        "username": "Rowansdabomb",
                        "content": "These were the observations necessary for me to solve.\n\nObservation 1:\nThe question is about max widths, which suggests BFS.\n\nObservation 2: (This is the big one)\nLet each row of a full binary tree be indexed from 0.\nFor a node at index i:\n  - the index of it's left child will be 2*i \n  - the index of it's right child will be 2*i + 1\nLook at the diagram below to convince yourself this is true.\n\n``` \n         0            // 0\n    0          1      // 2*0, 2*0 + 1\n 0     1    2     3   // 2*0, 2*0 + 1, 2*1, 2*1+1\n0 1   2 3  4 5   6 7  // etc..\n```\n\nObservation 3:\nMax nodes of 3000 means a max depth of 3000, which means a max index range of 0->2^3000 (way too large to store in an int).\nHowever; we know the maximum possible width is 2^32."
                    }
                ]
            },
            {
                "id": 1869434,
                "content": [
                    {
                        "username": "raiabhinavprakash",
                        "content": "This code is giving wrong answer at 101/114 test case. Can anybody pointout possible mistakes in it?\\n````\\nint widthOfBinaryTree(TreeNode* root) {\\n        long long int ans = 1, c = 1;\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        while(q.size())\\n        {\\n            int k = q.size();\\n            vector<int>v;\\n            for(int i = 0; i<k; i++)\\n            {\\n                auto a = q.front();\\n                q.pop();\\n                if(a->left)\\n                {\\n                    q.push(a->left);\\n                    v.push_back(a->left->val);\\n                }\\n                else v.push_back(-101);\\n                if(a->right)\\n                {\\n                    q.push(a->right);\\n                    v.push_back(a->right->val);\\n                }\\n                else v.push_back(-101);\\n            }\\n            if(!q.size()) break;\\n            c *= 2;\\n            long long i = 0, j = v.size()-1;\\n            while(i<=j && v[i] == -101) {i++; c--;}\\n            while(j>=i && v[j] == -101) {j--; c--;}\\n            ans = max(ans, c);\\n        }\\n        return ans;\\n    }\\n````"
                    },
                    {
                        "username": "akku18tiwari",
                        "content": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\n\n\nclass Solution {\n  public: int widthOfBinaryTree(TreeNode * root) {\n    if (root == NULL) return 0;\n    queue < TreeNode * > q;\n    q.push(root);\n    int mx = -1;\n    int f = 0;\n    while (!q.empty()) {\n      int n = q.size();\n      vector < int > level;\n      int l = -1, r = -1, c = -1;\n      for (int i = 0; i < n; i++) {\n        TreeNode * at = new TreeNode(1729);\n        // TreeNode* www = &at;\n        TreeNode * node = q.front();\n        q.pop();\n        if (node -> left == NULL) {\n          q.push(at);\n        } else\n          q.push(node -> left);\n\n        if (node -> right == NULL) {\n          q.push(at);\n        } else\n          q.push(node -> right);\n        c++;\n        if (l == -1 && node -> val != 1729) {\n          l = c;\n        }\n        if (node -> val != 1729) {\n          r = c;\n        }\n        // level.push_back(node->val);\n      }\n      if (l == -1 && r == -1) {\n        break;\n      }\n      mx = max(mx, r - l + 1);\n    }\n    return mx;\n  }\n};\n\n\n\n\nI am getting MLE for this testcase\n\n[0,0,0,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null]\n\n\nI am not sure why. The only large space that can possibly  be taken by in my code is by queue. This testcase has approx 300 nodes each of type TreeNode* (4 bytes I assume). Thus in total the queue size would be approx 1200 (close to 1MB) . MAX size allowed is 100MB in leetcode, hence i am confused.\n\nKindly someone explain \nPS: I am new to the leetcode discussion so please ignore the bad formatting of code\nTIA\n\n\n\n\n\n\n"
                    },
                    {
                        "username": "paullam328",
                        "content": "For those who\\'s having integer overflow problem in JavaScript, check out BigInt type"
                    },
                    {
                        "username": "Priya_G0rg",
                        "content": "TLE \\n[1,1,1,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,null,1,1,null,1,null,1,null,1,null,1,null]\\nExpected ans: 2147483645\\n\\nSomebody please how this ans is achieved and where can I might have removed TLE? Bcoz each level only traversing the required nodes from the leftmost to rightmost non-null nodes?"
                    },
                    {
                        "username": "paullam328",
                        "content": "If you\\'re traversing ONLY the nodes in the tree, this isn\\'t supposed to raise TLE."
                    },
                    {
                        "username": "ayushinsingh",
                        "content": "index can be greater than 32 bit signed integer but answer is within 32 bit signed integer."
                    },
                    {
                        "username": "VladimirKataev",
                        "content": "I think a \"Think about heap indexing\" hint would be very appropriate."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Please remove the last few testCases so that this doesn\\'t require BigInt in JS, or mention it in the question, but this is a really annoying way to fail at the last few testCases, never had to use it before (so at least I learned something new though)"
                    },
                    {
                        "username": "mayankesh",
                        "content": "Can We get depth of tree as d and answer will be 2^d -1 as it will be full tree. Is it wrong assumption, if yes,can some one give example?"
                    },
                    {
                        "username": "_aka5h",
                        "content": "In case of skewed tree, we might have a node which will be represented by 2 ^ 3000. How to deal with that thing here?"
                    },
                    {
                        "username": "Rowansdabomb",
                        "content": "[@_aka5h](/_aka5h) I should have mentioned this is assuming you are using BFS. \n\nAssuming you are using BFS, what can you use about the order of of the nodes X+N, and 2*X+N to correctly get the width knowing these values may have been modded by X? \n\nWhat width would expect in this case? why?"
                    },
                    {
                        "username": "_aka5h",
                        "content": "[@Rowansdabomb](/Rowansdabomb) I don\\'t think taking modulo would be any helpful in this case. Because, lets say you decided to mod with X.\\n\\nAnd there is a level with only 2 nodes represented by X + N and 2 * X + N where (N < X), taking modulo here will make both of them equal to N which will definitely lead to unexpected answer.\\n\\nThe only reason why the approach work even without taking modulo is because testcases aren\\'t designed that way to have a node represented by a value greater than 2 ^ 64, which I think is misleading since it is clearly mentioned in constraints that the tree can have atmost 3000 nodes."
                    },
                    {
                        "username": "Rowansdabomb",
                        "content": "> It is guaranteed that the answer will in the range of a 32-bit signed integer.\\n\\nMy hints would be:\\n- use the modulus for large values\\n- note any special cases when computing the width with values that were modded\\n\\n"
                    },
                    {
                        "username": "Rowansdabomb",
                        "content": "These were the observations necessary for me to solve.\n\nObservation 1:\nThe question is about max widths, which suggests BFS.\n\nObservation 2: (This is the big one)\nLet each row of a full binary tree be indexed from 0.\nFor a node at index i:\n  - the index of it's left child will be 2*i \n  - the index of it's right child will be 2*i + 1\nLook at the diagram below to convince yourself this is true.\n\n``` \n         0            // 0\n    0          1      // 2*0, 2*0 + 1\n 0     1    2     3   // 2*0, 2*0 + 1, 2*1, 2*1+1\n0 1   2 3  4 5   6 7  // etc..\n```\n\nObservation 3:\nMax nodes of 3000 means a max depth of 3000, which means a max index range of 0->2^3000 (way too large to store in an int).\nHowever; we know the maximum possible width is 2^32."
                    }
                ]
            },
            {
                "id": 1869368,
                "content": [
                    {
                        "username": "namandt",
                        "content": "Nice challenge, liked solving it!"
                    },
                    {
                        "username": "halfengineer",
                        "content": "Can anybody please explain this why in cpp we are using longloong 2LL while inserting and in java simply 2*index is working..Thanks"
                    },
                    {
                        "username": "CoderVinit28",
                        "content": "Using DFS\\n```\\nclass Solution {\\npublic:\\n    long long leftMost[3001], rightMost[3001], ans;\\n\\n    int widthOfBinaryTree(TreeNode* root) {\\n        memset(leftMost, -1, sizeof(leftMost));\\n        memset(rightMost, -1, sizeof(rightMost));\\n        ans = 0;\\n        DFS(root, 0, 0);\\n        return ans;\\n    }\\n\\n    void DFS(TreeNode *node, int level, long long idx){\\n        leftMost[level] = leftMost[level]!=-1? min(leftMost[level], idx) : idx;\\n        rightMost[level] = rightMost[level]!=-1? max(rightMost[level], idx) : idx;\\n        \\n        ans = max(ans, (rightMost[level] - leftMost[level] + 1));\\n        if( node->left != NULL ) DFS(node->left, level+1, idx*2);\\n        if( node->right != NULL ) DFS(node->right, level+1, idx*2+1);\\n    }\\n};\\n```\\n\\nUsing BFS\\n```\\nclass Solution {\\npublic:\\n\\n    int widthOfBinaryTree(TreeNode* root) {\\n        \\n        queue<pair<TreeNode*, int>> q;\\n        long maxWidth = 1, size, left, right; \\n        q.push( {root, 0} );\\n        \\n        while( q.empty() == false ){\\n            \\n            size = q.size(), left = q.front().second, right = q.back().second;\\n            maxWidth = max(maxWidth, (right-left)+1);\\n            \\n            while( size ){\\n                \\n                auto p = q.front();\\n                long idx = p.second;\\n                q.pop();\\n            \\n                if( p.first->left != NULL ) q.push( {p.first->left, idx*2+1 } );\\n                \\n                if( p.first->right != NULL ) q.push( {p.first->right, idx*2+2 } );\\n                \\n                size -= 1;\\n            }\\n        }\\n        \\n        return maxWidth;\\n    }\\n};\\n```\\n\\nWhy the code is not getting accepted when going with DFS approach?\\n*Note: Code using BFS is accepted."
                    },
                    {
                        "username": "ArpitKrishna98",
                        "content": "left = 2*parent -1\\nright = 2*parent\\n\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def widthOfBinaryTree(self, root: Optional[TreeNode]) -> int:\\n        queue=[]\\n        maxw=1\\n        queue.append([root,1])\\n        while queue:\\n            for i in range(len(queue)):\\n                t=queue.pop(0)\\n                if t[0].left:\\n                    queue.append([t[0].left,2*t[1]-1])\\n                if t[0].right:\\n                    queue.append([t[0].right,2*t[1]])\\n            if not(queue):\\n                break\\n            maxw=max(maxw,queue[-1][1]-queue[0][1]+1)\\n        return maxw"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "It\\'s one of the best problems to practice BFS on tree."
                    },
                    {
                        "username": "user6694qk",
                        "content": "please can anyone explain the difference between these two solutions written in c++ :\\n\\nthis one is accepted:\\n\\nint widthOfBinaryTree(TreeNode* root) {\\n        queue<pair<int, TreeNode*>> q;\\n        q.push({0, root});\\n        int ans = INT_MIN;\\n        while(!q.empty()) {\\n            auto rootNode = q.front();\\n            int leftMostNodeNo = rootNode.first;\\n            int rightMostNodeNo = INT_MIN;\\n            int size = q.size();\\n            for(int i=0;i<size;i++) {\\n                pair<long long, TreeNode*> curr = q.front();\\n                q.pop();\\n                TreeNode* node = curr.second;\\n                long long currNodeNo = curr.first;\\n                rightMostNodeNo = curr.first;\\n                if(node->left != NULL) q.push({currNodeNo * 2 + 1, node->left});\\n                if(node->right != NULL) q.push({currNodeNo * 2 + 2, node->right});\\n            }\\n            ans = max(ans, rightMostNodeNo - leftMostNodeNo + 1);\\n        }\\n        return ans;\\n    }\\n\\n\\nthis one gives run time error:\\n\\nint widthOfBinaryTree(TreeNode* root) {\\n        queue<pair<long long, TreeNode*>> q;\\n        q.push({0, root});\\n        int ans = INT_MIN;\\n        while(!q.empty()) {\\n            auto rootNode = q.front();\\n            int leftMostNodeNo = rootNode.first;\\n            int rightMostNodeNo = INT_MIN;\\n            int size = q.size();\\n            for(int i=0;i<size;i++) {\\n                pair<long long, TreeNode*> curr = q.front();\\n                q.pop();\\n                TreeNode* node = curr.second;\\n                long long currNodeNo = curr.first;\\n                rightMostNodeNo = curr.first;\\n                if(node->left != NULL) q.push({currNodeNo * 2 + 1, node->left});\\n                if(node->right != NULL) q.push({currNodeNo * 2 + 2, node->right});\\n            }\\n            ans = max(ans, rightMostNodeNo - leftMostNodeNo + 1);\\n        }\\n        return ans;\\n    }\\n\\n\\nthe only difference between them is in the first solution(accepted) i used \\n`queue<pair<int, TreeNode*>> q;`\\nbut in the second one(not accepted) i used `queue<pair<long long, TreeNode*>> q;`"
                    },
                    {
                        "username": "Samarth_Dengre",
                        "content": "Can anyone tell me the problem with this solution? I am getting 3 on the last test case and the answer is 4.\\n```\\nclass Solution {\\npublic:\\n    unsigned long long ans = 1;\\n    int widthOfBinaryTree(TreeNode* root) {\\n        map<int, pair<unsigned long long, unsigned long long>> dist;\\n        getWidth(root, dist, 1, 1);\\n        return ans;\\n    }\\n\\n    void getWidth(TreeNode* root, map<int, pair<unsigned long long, unsigned long long>>& dist, int level, unsigned long long ind){\\n        if(root == NULL)    return;\\n\\n        if(dist.count(level)){\\n            dist[level].first = min(dist[level].first, ind);\\n            dist[level].second = max(dist[level].second, ind);\\n            ans = max(ans, dist[level].second-dist[level].first+1);\\n        }else{\\n            dist[level].first = ind;\\n            dist[level].second = ind;\\n        }\\n\\n        getWidth(root->left, dist, level+1, ind*2-1);\\n        getWidth(root->right, dist, level+1, ind*2);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "I\\'m concerned about how the binary tree forms. Why does the tree structure form like this? For instance, with the input [1,3,2,5,3,null,9], we first encounter 1, which is then set as the root. Then comes 3. Why isn\\'t it placed on the right? How is the tree structure formed in the question?"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I think, the tree structure such as [1,3,2,5,3,null, 9] is displayed by way of level order, it is default in leetcode."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "In a certain layer, the width between two ended nodes a and b, can be calculated by recursion process, shown as below:\\nwidth(a, b) = 2 * width(parent[a], parent[b]) - (a is right child) - (b is left child)\\nI think the way can be better, it can avoid processing super big value."
                    },
                    {
                        "username": "KhacLong",
                        "content": "what if each level contains a node, and this node is rightmost?"
                    },
                    {
                        "username": "jolswlf",
                        "content": "If each level only contains a node that node will be both the leftmost and rightmost of that level. "
                    }
                ]
            },
            {
                "id": 1869317,
                "content": [
                    {
                        "username": "namandt",
                        "content": "Nice challenge, liked solving it!"
                    },
                    {
                        "username": "halfengineer",
                        "content": "Can anybody please explain this why in cpp we are using longloong 2LL while inserting and in java simply 2*index is working..Thanks"
                    },
                    {
                        "username": "CoderVinit28",
                        "content": "Using DFS\\n```\\nclass Solution {\\npublic:\\n    long long leftMost[3001], rightMost[3001], ans;\\n\\n    int widthOfBinaryTree(TreeNode* root) {\\n        memset(leftMost, -1, sizeof(leftMost));\\n        memset(rightMost, -1, sizeof(rightMost));\\n        ans = 0;\\n        DFS(root, 0, 0);\\n        return ans;\\n    }\\n\\n    void DFS(TreeNode *node, int level, long long idx){\\n        leftMost[level] = leftMost[level]!=-1? min(leftMost[level], idx) : idx;\\n        rightMost[level] = rightMost[level]!=-1? max(rightMost[level], idx) : idx;\\n        \\n        ans = max(ans, (rightMost[level] - leftMost[level] + 1));\\n        if( node->left != NULL ) DFS(node->left, level+1, idx*2);\\n        if( node->right != NULL ) DFS(node->right, level+1, idx*2+1);\\n    }\\n};\\n```\\n\\nUsing BFS\\n```\\nclass Solution {\\npublic:\\n\\n    int widthOfBinaryTree(TreeNode* root) {\\n        \\n        queue<pair<TreeNode*, int>> q;\\n        long maxWidth = 1, size, left, right; \\n        q.push( {root, 0} );\\n        \\n        while( q.empty() == false ){\\n            \\n            size = q.size(), left = q.front().second, right = q.back().second;\\n            maxWidth = max(maxWidth, (right-left)+1);\\n            \\n            while( size ){\\n                \\n                auto p = q.front();\\n                long idx = p.second;\\n                q.pop();\\n            \\n                if( p.first->left != NULL ) q.push( {p.first->left, idx*2+1 } );\\n                \\n                if( p.first->right != NULL ) q.push( {p.first->right, idx*2+2 } );\\n                \\n                size -= 1;\\n            }\\n        }\\n        \\n        return maxWidth;\\n    }\\n};\\n```\\n\\nWhy the code is not getting accepted when going with DFS approach?\\n*Note: Code using BFS is accepted."
                    },
                    {
                        "username": "ArpitKrishna98",
                        "content": "left = 2*parent -1\\nright = 2*parent\\n\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def widthOfBinaryTree(self, root: Optional[TreeNode]) -> int:\\n        queue=[]\\n        maxw=1\\n        queue.append([root,1])\\n        while queue:\\n            for i in range(len(queue)):\\n                t=queue.pop(0)\\n                if t[0].left:\\n                    queue.append([t[0].left,2*t[1]-1])\\n                if t[0].right:\\n                    queue.append([t[0].right,2*t[1]])\\n            if not(queue):\\n                break\\n            maxw=max(maxw,queue[-1][1]-queue[0][1]+1)\\n        return maxw"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "It\\'s one of the best problems to practice BFS on tree."
                    },
                    {
                        "username": "user6694qk",
                        "content": "please can anyone explain the difference between these two solutions written in c++ :\\n\\nthis one is accepted:\\n\\nint widthOfBinaryTree(TreeNode* root) {\\n        queue<pair<int, TreeNode*>> q;\\n        q.push({0, root});\\n        int ans = INT_MIN;\\n        while(!q.empty()) {\\n            auto rootNode = q.front();\\n            int leftMostNodeNo = rootNode.first;\\n            int rightMostNodeNo = INT_MIN;\\n            int size = q.size();\\n            for(int i=0;i<size;i++) {\\n                pair<long long, TreeNode*> curr = q.front();\\n                q.pop();\\n                TreeNode* node = curr.second;\\n                long long currNodeNo = curr.first;\\n                rightMostNodeNo = curr.first;\\n                if(node->left != NULL) q.push({currNodeNo * 2 + 1, node->left});\\n                if(node->right != NULL) q.push({currNodeNo * 2 + 2, node->right});\\n            }\\n            ans = max(ans, rightMostNodeNo - leftMostNodeNo + 1);\\n        }\\n        return ans;\\n    }\\n\\n\\nthis one gives run time error:\\n\\nint widthOfBinaryTree(TreeNode* root) {\\n        queue<pair<long long, TreeNode*>> q;\\n        q.push({0, root});\\n        int ans = INT_MIN;\\n        while(!q.empty()) {\\n            auto rootNode = q.front();\\n            int leftMostNodeNo = rootNode.first;\\n            int rightMostNodeNo = INT_MIN;\\n            int size = q.size();\\n            for(int i=0;i<size;i++) {\\n                pair<long long, TreeNode*> curr = q.front();\\n                q.pop();\\n                TreeNode* node = curr.second;\\n                long long currNodeNo = curr.first;\\n                rightMostNodeNo = curr.first;\\n                if(node->left != NULL) q.push({currNodeNo * 2 + 1, node->left});\\n                if(node->right != NULL) q.push({currNodeNo * 2 + 2, node->right});\\n            }\\n            ans = max(ans, rightMostNodeNo - leftMostNodeNo + 1);\\n        }\\n        return ans;\\n    }\\n\\n\\nthe only difference between them is in the first solution(accepted) i used \\n`queue<pair<int, TreeNode*>> q;`\\nbut in the second one(not accepted) i used `queue<pair<long long, TreeNode*>> q;`"
                    },
                    {
                        "username": "Samarth_Dengre",
                        "content": "Can anyone tell me the problem with this solution? I am getting 3 on the last test case and the answer is 4.\\n```\\nclass Solution {\\npublic:\\n    unsigned long long ans = 1;\\n    int widthOfBinaryTree(TreeNode* root) {\\n        map<int, pair<unsigned long long, unsigned long long>> dist;\\n        getWidth(root, dist, 1, 1);\\n        return ans;\\n    }\\n\\n    void getWidth(TreeNode* root, map<int, pair<unsigned long long, unsigned long long>>& dist, int level, unsigned long long ind){\\n        if(root == NULL)    return;\\n\\n        if(dist.count(level)){\\n            dist[level].first = min(dist[level].first, ind);\\n            dist[level].second = max(dist[level].second, ind);\\n            ans = max(ans, dist[level].second-dist[level].first+1);\\n        }else{\\n            dist[level].first = ind;\\n            dist[level].second = ind;\\n        }\\n\\n        getWidth(root->left, dist, level+1, ind*2-1);\\n        getWidth(root->right, dist, level+1, ind*2);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "I\\'m concerned about how the binary tree forms. Why does the tree structure form like this? For instance, with the input [1,3,2,5,3,null,9], we first encounter 1, which is then set as the root. Then comes 3. Why isn\\'t it placed on the right? How is the tree structure formed in the question?"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I think, the tree structure such as [1,3,2,5,3,null, 9] is displayed by way of level order, it is default in leetcode."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "In a certain layer, the width between two ended nodes a and b, can be calculated by recursion process, shown as below:\\nwidth(a, b) = 2 * width(parent[a], parent[b]) - (a is right child) - (b is left child)\\nI think the way can be better, it can avoid processing super big value."
                    },
                    {
                        "username": "KhacLong",
                        "content": "what if each level contains a node, and this node is rightmost?"
                    },
                    {
                        "username": "jolswlf",
                        "content": "If each level only contains a node that node will be both the leftmost and rightmost of that level. "
                    }
                ]
            },
            {
                "id": 1869280,
                "content": [
                    {
                        "username": "namandt",
                        "content": "Nice challenge, liked solving it!"
                    },
                    {
                        "username": "halfengineer",
                        "content": "Can anybody please explain this why in cpp we are using longloong 2LL while inserting and in java simply 2*index is working..Thanks"
                    },
                    {
                        "username": "CoderVinit28",
                        "content": "Using DFS\\n```\\nclass Solution {\\npublic:\\n    long long leftMost[3001], rightMost[3001], ans;\\n\\n    int widthOfBinaryTree(TreeNode* root) {\\n        memset(leftMost, -1, sizeof(leftMost));\\n        memset(rightMost, -1, sizeof(rightMost));\\n        ans = 0;\\n        DFS(root, 0, 0);\\n        return ans;\\n    }\\n\\n    void DFS(TreeNode *node, int level, long long idx){\\n        leftMost[level] = leftMost[level]!=-1? min(leftMost[level], idx) : idx;\\n        rightMost[level] = rightMost[level]!=-1? max(rightMost[level], idx) : idx;\\n        \\n        ans = max(ans, (rightMost[level] - leftMost[level] + 1));\\n        if( node->left != NULL ) DFS(node->left, level+1, idx*2);\\n        if( node->right != NULL ) DFS(node->right, level+1, idx*2+1);\\n    }\\n};\\n```\\n\\nUsing BFS\\n```\\nclass Solution {\\npublic:\\n\\n    int widthOfBinaryTree(TreeNode* root) {\\n        \\n        queue<pair<TreeNode*, int>> q;\\n        long maxWidth = 1, size, left, right; \\n        q.push( {root, 0} );\\n        \\n        while( q.empty() == false ){\\n            \\n            size = q.size(), left = q.front().second, right = q.back().second;\\n            maxWidth = max(maxWidth, (right-left)+1);\\n            \\n            while( size ){\\n                \\n                auto p = q.front();\\n                long idx = p.second;\\n                q.pop();\\n            \\n                if( p.first->left != NULL ) q.push( {p.first->left, idx*2+1 } );\\n                \\n                if( p.first->right != NULL ) q.push( {p.first->right, idx*2+2 } );\\n                \\n                size -= 1;\\n            }\\n        }\\n        \\n        return maxWidth;\\n    }\\n};\\n```\\n\\nWhy the code is not getting accepted when going with DFS approach?\\n*Note: Code using BFS is accepted."
                    },
                    {
                        "username": "ArpitKrishna98",
                        "content": "left = 2*parent -1\\nright = 2*parent\\n\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def widthOfBinaryTree(self, root: Optional[TreeNode]) -> int:\\n        queue=[]\\n        maxw=1\\n        queue.append([root,1])\\n        while queue:\\n            for i in range(len(queue)):\\n                t=queue.pop(0)\\n                if t[0].left:\\n                    queue.append([t[0].left,2*t[1]-1])\\n                if t[0].right:\\n                    queue.append([t[0].right,2*t[1]])\\n            if not(queue):\\n                break\\n            maxw=max(maxw,queue[-1][1]-queue[0][1]+1)\\n        return maxw"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "It\\'s one of the best problems to practice BFS on tree."
                    },
                    {
                        "username": "user6694qk",
                        "content": "please can anyone explain the difference between these two solutions written in c++ :\\n\\nthis one is accepted:\\n\\nint widthOfBinaryTree(TreeNode* root) {\\n        queue<pair<int, TreeNode*>> q;\\n        q.push({0, root});\\n        int ans = INT_MIN;\\n        while(!q.empty()) {\\n            auto rootNode = q.front();\\n            int leftMostNodeNo = rootNode.first;\\n            int rightMostNodeNo = INT_MIN;\\n            int size = q.size();\\n            for(int i=0;i<size;i++) {\\n                pair<long long, TreeNode*> curr = q.front();\\n                q.pop();\\n                TreeNode* node = curr.second;\\n                long long currNodeNo = curr.first;\\n                rightMostNodeNo = curr.first;\\n                if(node->left != NULL) q.push({currNodeNo * 2 + 1, node->left});\\n                if(node->right != NULL) q.push({currNodeNo * 2 + 2, node->right});\\n            }\\n            ans = max(ans, rightMostNodeNo - leftMostNodeNo + 1);\\n        }\\n        return ans;\\n    }\\n\\n\\nthis one gives run time error:\\n\\nint widthOfBinaryTree(TreeNode* root) {\\n        queue<pair<long long, TreeNode*>> q;\\n        q.push({0, root});\\n        int ans = INT_MIN;\\n        while(!q.empty()) {\\n            auto rootNode = q.front();\\n            int leftMostNodeNo = rootNode.first;\\n            int rightMostNodeNo = INT_MIN;\\n            int size = q.size();\\n            for(int i=0;i<size;i++) {\\n                pair<long long, TreeNode*> curr = q.front();\\n                q.pop();\\n                TreeNode* node = curr.second;\\n                long long currNodeNo = curr.first;\\n                rightMostNodeNo = curr.first;\\n                if(node->left != NULL) q.push({currNodeNo * 2 + 1, node->left});\\n                if(node->right != NULL) q.push({currNodeNo * 2 + 2, node->right});\\n            }\\n            ans = max(ans, rightMostNodeNo - leftMostNodeNo + 1);\\n        }\\n        return ans;\\n    }\\n\\n\\nthe only difference between them is in the first solution(accepted) i used \\n`queue<pair<int, TreeNode*>> q;`\\nbut in the second one(not accepted) i used `queue<pair<long long, TreeNode*>> q;`"
                    },
                    {
                        "username": "Samarth_Dengre",
                        "content": "Can anyone tell me the problem with this solution? I am getting 3 on the last test case and the answer is 4.\\n```\\nclass Solution {\\npublic:\\n    unsigned long long ans = 1;\\n    int widthOfBinaryTree(TreeNode* root) {\\n        map<int, pair<unsigned long long, unsigned long long>> dist;\\n        getWidth(root, dist, 1, 1);\\n        return ans;\\n    }\\n\\n    void getWidth(TreeNode* root, map<int, pair<unsigned long long, unsigned long long>>& dist, int level, unsigned long long ind){\\n        if(root == NULL)    return;\\n\\n        if(dist.count(level)){\\n            dist[level].first = min(dist[level].first, ind);\\n            dist[level].second = max(dist[level].second, ind);\\n            ans = max(ans, dist[level].second-dist[level].first+1);\\n        }else{\\n            dist[level].first = ind;\\n            dist[level].second = ind;\\n        }\\n\\n        getWidth(root->left, dist, level+1, ind*2-1);\\n        getWidth(root->right, dist, level+1, ind*2);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "I\\'m concerned about how the binary tree forms. Why does the tree structure form like this? For instance, with the input [1,3,2,5,3,null,9], we first encounter 1, which is then set as the root. Then comes 3. Why isn\\'t it placed on the right? How is the tree structure formed in the question?"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I think, the tree structure such as [1,3,2,5,3,null, 9] is displayed by way of level order, it is default in leetcode."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "In a certain layer, the width between two ended nodes a and b, can be calculated by recursion process, shown as below:\\nwidth(a, b) = 2 * width(parent[a], parent[b]) - (a is right child) - (b is left child)\\nI think the way can be better, it can avoid processing super big value."
                    },
                    {
                        "username": "KhacLong",
                        "content": "what if each level contains a node, and this node is rightmost?"
                    },
                    {
                        "username": "jolswlf",
                        "content": "If each level only contains a node that node will be both the leftmost and rightmost of that level. "
                    }
                ]
            },
            {
                "id": 1869243,
                "content": [
                    {
                        "username": "namandt",
                        "content": "Nice challenge, liked solving it!"
                    },
                    {
                        "username": "halfengineer",
                        "content": "Can anybody please explain this why in cpp we are using longloong 2LL while inserting and in java simply 2*index is working..Thanks"
                    },
                    {
                        "username": "CoderVinit28",
                        "content": "Using DFS\\n```\\nclass Solution {\\npublic:\\n    long long leftMost[3001], rightMost[3001], ans;\\n\\n    int widthOfBinaryTree(TreeNode* root) {\\n        memset(leftMost, -1, sizeof(leftMost));\\n        memset(rightMost, -1, sizeof(rightMost));\\n        ans = 0;\\n        DFS(root, 0, 0);\\n        return ans;\\n    }\\n\\n    void DFS(TreeNode *node, int level, long long idx){\\n        leftMost[level] = leftMost[level]!=-1? min(leftMost[level], idx) : idx;\\n        rightMost[level] = rightMost[level]!=-1? max(rightMost[level], idx) : idx;\\n        \\n        ans = max(ans, (rightMost[level] - leftMost[level] + 1));\\n        if( node->left != NULL ) DFS(node->left, level+1, idx*2);\\n        if( node->right != NULL ) DFS(node->right, level+1, idx*2+1);\\n    }\\n};\\n```\\n\\nUsing BFS\\n```\\nclass Solution {\\npublic:\\n\\n    int widthOfBinaryTree(TreeNode* root) {\\n        \\n        queue<pair<TreeNode*, int>> q;\\n        long maxWidth = 1, size, left, right; \\n        q.push( {root, 0} );\\n        \\n        while( q.empty() == false ){\\n            \\n            size = q.size(), left = q.front().second, right = q.back().second;\\n            maxWidth = max(maxWidth, (right-left)+1);\\n            \\n            while( size ){\\n                \\n                auto p = q.front();\\n                long idx = p.second;\\n                q.pop();\\n            \\n                if( p.first->left != NULL ) q.push( {p.first->left, idx*2+1 } );\\n                \\n                if( p.first->right != NULL ) q.push( {p.first->right, idx*2+2 } );\\n                \\n                size -= 1;\\n            }\\n        }\\n        \\n        return maxWidth;\\n    }\\n};\\n```\\n\\nWhy the code is not getting accepted when going with DFS approach?\\n*Note: Code using BFS is accepted."
                    },
                    {
                        "username": "ArpitKrishna98",
                        "content": "left = 2*parent -1\\nright = 2*parent\\n\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def widthOfBinaryTree(self, root: Optional[TreeNode]) -> int:\\n        queue=[]\\n        maxw=1\\n        queue.append([root,1])\\n        while queue:\\n            for i in range(len(queue)):\\n                t=queue.pop(0)\\n                if t[0].left:\\n                    queue.append([t[0].left,2*t[1]-1])\\n                if t[0].right:\\n                    queue.append([t[0].right,2*t[1]])\\n            if not(queue):\\n                break\\n            maxw=max(maxw,queue[-1][1]-queue[0][1]+1)\\n        return maxw"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "It\\'s one of the best problems to practice BFS on tree."
                    },
                    {
                        "username": "user6694qk",
                        "content": "please can anyone explain the difference between these two solutions written in c++ :\\n\\nthis one is accepted:\\n\\nint widthOfBinaryTree(TreeNode* root) {\\n        queue<pair<int, TreeNode*>> q;\\n        q.push({0, root});\\n        int ans = INT_MIN;\\n        while(!q.empty()) {\\n            auto rootNode = q.front();\\n            int leftMostNodeNo = rootNode.first;\\n            int rightMostNodeNo = INT_MIN;\\n            int size = q.size();\\n            for(int i=0;i<size;i++) {\\n                pair<long long, TreeNode*> curr = q.front();\\n                q.pop();\\n                TreeNode* node = curr.second;\\n                long long currNodeNo = curr.first;\\n                rightMostNodeNo = curr.first;\\n                if(node->left != NULL) q.push({currNodeNo * 2 + 1, node->left});\\n                if(node->right != NULL) q.push({currNodeNo * 2 + 2, node->right});\\n            }\\n            ans = max(ans, rightMostNodeNo - leftMostNodeNo + 1);\\n        }\\n        return ans;\\n    }\\n\\n\\nthis one gives run time error:\\n\\nint widthOfBinaryTree(TreeNode* root) {\\n        queue<pair<long long, TreeNode*>> q;\\n        q.push({0, root});\\n        int ans = INT_MIN;\\n        while(!q.empty()) {\\n            auto rootNode = q.front();\\n            int leftMostNodeNo = rootNode.first;\\n            int rightMostNodeNo = INT_MIN;\\n            int size = q.size();\\n            for(int i=0;i<size;i++) {\\n                pair<long long, TreeNode*> curr = q.front();\\n                q.pop();\\n                TreeNode* node = curr.second;\\n                long long currNodeNo = curr.first;\\n                rightMostNodeNo = curr.first;\\n                if(node->left != NULL) q.push({currNodeNo * 2 + 1, node->left});\\n                if(node->right != NULL) q.push({currNodeNo * 2 + 2, node->right});\\n            }\\n            ans = max(ans, rightMostNodeNo - leftMostNodeNo + 1);\\n        }\\n        return ans;\\n    }\\n\\n\\nthe only difference between them is in the first solution(accepted) i used \\n`queue<pair<int, TreeNode*>> q;`\\nbut in the second one(not accepted) i used `queue<pair<long long, TreeNode*>> q;`"
                    },
                    {
                        "username": "Samarth_Dengre",
                        "content": "Can anyone tell me the problem with this solution? I am getting 3 on the last test case and the answer is 4.\\n```\\nclass Solution {\\npublic:\\n    unsigned long long ans = 1;\\n    int widthOfBinaryTree(TreeNode* root) {\\n        map<int, pair<unsigned long long, unsigned long long>> dist;\\n        getWidth(root, dist, 1, 1);\\n        return ans;\\n    }\\n\\n    void getWidth(TreeNode* root, map<int, pair<unsigned long long, unsigned long long>>& dist, int level, unsigned long long ind){\\n        if(root == NULL)    return;\\n\\n        if(dist.count(level)){\\n            dist[level].first = min(dist[level].first, ind);\\n            dist[level].second = max(dist[level].second, ind);\\n            ans = max(ans, dist[level].second-dist[level].first+1);\\n        }else{\\n            dist[level].first = ind;\\n            dist[level].second = ind;\\n        }\\n\\n        getWidth(root->left, dist, level+1, ind*2-1);\\n        getWidth(root->right, dist, level+1, ind*2);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "I\\'m concerned about how the binary tree forms. Why does the tree structure form like this? For instance, with the input [1,3,2,5,3,null,9], we first encounter 1, which is then set as the root. Then comes 3. Why isn\\'t it placed on the right? How is the tree structure formed in the question?"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I think, the tree structure such as [1,3,2,5,3,null, 9] is displayed by way of level order, it is default in leetcode."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "In a certain layer, the width between two ended nodes a and b, can be calculated by recursion process, shown as below:\\nwidth(a, b) = 2 * width(parent[a], parent[b]) - (a is right child) - (b is left child)\\nI think the way can be better, it can avoid processing super big value."
                    },
                    {
                        "username": "KhacLong",
                        "content": "what if each level contains a node, and this node is rightmost?"
                    },
                    {
                        "username": "jolswlf",
                        "content": "If each level only contains a node that node will be both the leftmost and rightmost of that level. "
                    }
                ]
            },
            {
                "id": 1869199,
                "content": [
                    {
                        "username": "namandt",
                        "content": "Nice challenge, liked solving it!"
                    },
                    {
                        "username": "halfengineer",
                        "content": "Can anybody please explain this why in cpp we are using longloong 2LL while inserting and in java simply 2*index is working..Thanks"
                    },
                    {
                        "username": "CoderVinit28",
                        "content": "Using DFS\\n```\\nclass Solution {\\npublic:\\n    long long leftMost[3001], rightMost[3001], ans;\\n\\n    int widthOfBinaryTree(TreeNode* root) {\\n        memset(leftMost, -1, sizeof(leftMost));\\n        memset(rightMost, -1, sizeof(rightMost));\\n        ans = 0;\\n        DFS(root, 0, 0);\\n        return ans;\\n    }\\n\\n    void DFS(TreeNode *node, int level, long long idx){\\n        leftMost[level] = leftMost[level]!=-1? min(leftMost[level], idx) : idx;\\n        rightMost[level] = rightMost[level]!=-1? max(rightMost[level], idx) : idx;\\n        \\n        ans = max(ans, (rightMost[level] - leftMost[level] + 1));\\n        if( node->left != NULL ) DFS(node->left, level+1, idx*2);\\n        if( node->right != NULL ) DFS(node->right, level+1, idx*2+1);\\n    }\\n};\\n```\\n\\nUsing BFS\\n```\\nclass Solution {\\npublic:\\n\\n    int widthOfBinaryTree(TreeNode* root) {\\n        \\n        queue<pair<TreeNode*, int>> q;\\n        long maxWidth = 1, size, left, right; \\n        q.push( {root, 0} );\\n        \\n        while( q.empty() == false ){\\n            \\n            size = q.size(), left = q.front().second, right = q.back().second;\\n            maxWidth = max(maxWidth, (right-left)+1);\\n            \\n            while( size ){\\n                \\n                auto p = q.front();\\n                long idx = p.second;\\n                q.pop();\\n            \\n                if( p.first->left != NULL ) q.push( {p.first->left, idx*2+1 } );\\n                \\n                if( p.first->right != NULL ) q.push( {p.first->right, idx*2+2 } );\\n                \\n                size -= 1;\\n            }\\n        }\\n        \\n        return maxWidth;\\n    }\\n};\\n```\\n\\nWhy the code is not getting accepted when going with DFS approach?\\n*Note: Code using BFS is accepted."
                    },
                    {
                        "username": "ArpitKrishna98",
                        "content": "left = 2*parent -1\\nright = 2*parent\\n\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def widthOfBinaryTree(self, root: Optional[TreeNode]) -> int:\\n        queue=[]\\n        maxw=1\\n        queue.append([root,1])\\n        while queue:\\n            for i in range(len(queue)):\\n                t=queue.pop(0)\\n                if t[0].left:\\n                    queue.append([t[0].left,2*t[1]-1])\\n                if t[0].right:\\n                    queue.append([t[0].right,2*t[1]])\\n            if not(queue):\\n                break\\n            maxw=max(maxw,queue[-1][1]-queue[0][1]+1)\\n        return maxw"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "It\\'s one of the best problems to practice BFS on tree."
                    },
                    {
                        "username": "user6694qk",
                        "content": "please can anyone explain the difference between these two solutions written in c++ :\\n\\nthis one is accepted:\\n\\nint widthOfBinaryTree(TreeNode* root) {\\n        queue<pair<int, TreeNode*>> q;\\n        q.push({0, root});\\n        int ans = INT_MIN;\\n        while(!q.empty()) {\\n            auto rootNode = q.front();\\n            int leftMostNodeNo = rootNode.first;\\n            int rightMostNodeNo = INT_MIN;\\n            int size = q.size();\\n            for(int i=0;i<size;i++) {\\n                pair<long long, TreeNode*> curr = q.front();\\n                q.pop();\\n                TreeNode* node = curr.second;\\n                long long currNodeNo = curr.first;\\n                rightMostNodeNo = curr.first;\\n                if(node->left != NULL) q.push({currNodeNo * 2 + 1, node->left});\\n                if(node->right != NULL) q.push({currNodeNo * 2 + 2, node->right});\\n            }\\n            ans = max(ans, rightMostNodeNo - leftMostNodeNo + 1);\\n        }\\n        return ans;\\n    }\\n\\n\\nthis one gives run time error:\\n\\nint widthOfBinaryTree(TreeNode* root) {\\n        queue<pair<long long, TreeNode*>> q;\\n        q.push({0, root});\\n        int ans = INT_MIN;\\n        while(!q.empty()) {\\n            auto rootNode = q.front();\\n            int leftMostNodeNo = rootNode.first;\\n            int rightMostNodeNo = INT_MIN;\\n            int size = q.size();\\n            for(int i=0;i<size;i++) {\\n                pair<long long, TreeNode*> curr = q.front();\\n                q.pop();\\n                TreeNode* node = curr.second;\\n                long long currNodeNo = curr.first;\\n                rightMostNodeNo = curr.first;\\n                if(node->left != NULL) q.push({currNodeNo * 2 + 1, node->left});\\n                if(node->right != NULL) q.push({currNodeNo * 2 + 2, node->right});\\n            }\\n            ans = max(ans, rightMostNodeNo - leftMostNodeNo + 1);\\n        }\\n        return ans;\\n    }\\n\\n\\nthe only difference between them is in the first solution(accepted) i used \\n`queue<pair<int, TreeNode*>> q;`\\nbut in the second one(not accepted) i used `queue<pair<long long, TreeNode*>> q;`"
                    },
                    {
                        "username": "Samarth_Dengre",
                        "content": "Can anyone tell me the problem with this solution? I am getting 3 on the last test case and the answer is 4.\\n```\\nclass Solution {\\npublic:\\n    unsigned long long ans = 1;\\n    int widthOfBinaryTree(TreeNode* root) {\\n        map<int, pair<unsigned long long, unsigned long long>> dist;\\n        getWidth(root, dist, 1, 1);\\n        return ans;\\n    }\\n\\n    void getWidth(TreeNode* root, map<int, pair<unsigned long long, unsigned long long>>& dist, int level, unsigned long long ind){\\n        if(root == NULL)    return;\\n\\n        if(dist.count(level)){\\n            dist[level].first = min(dist[level].first, ind);\\n            dist[level].second = max(dist[level].second, ind);\\n            ans = max(ans, dist[level].second-dist[level].first+1);\\n        }else{\\n            dist[level].first = ind;\\n            dist[level].second = ind;\\n        }\\n\\n        getWidth(root->left, dist, level+1, ind*2-1);\\n        getWidth(root->right, dist, level+1, ind*2);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "I\\'m concerned about how the binary tree forms. Why does the tree structure form like this? For instance, with the input [1,3,2,5,3,null,9], we first encounter 1, which is then set as the root. Then comes 3. Why isn\\'t it placed on the right? How is the tree structure formed in the question?"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I think, the tree structure such as [1,3,2,5,3,null, 9] is displayed by way of level order, it is default in leetcode."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "In a certain layer, the width between two ended nodes a and b, can be calculated by recursion process, shown as below:\\nwidth(a, b) = 2 * width(parent[a], parent[b]) - (a is right child) - (b is left child)\\nI think the way can be better, it can avoid processing super big value."
                    },
                    {
                        "username": "KhacLong",
                        "content": "what if each level contains a node, and this node is rightmost?"
                    },
                    {
                        "username": "jolswlf",
                        "content": "If each level only contains a node that node will be both the leftmost and rightmost of that level. "
                    }
                ]
            },
            {
                "id": 1869190,
                "content": [
                    {
                        "username": "namandt",
                        "content": "Nice challenge, liked solving it!"
                    },
                    {
                        "username": "halfengineer",
                        "content": "Can anybody please explain this why in cpp we are using longloong 2LL while inserting and in java simply 2*index is working..Thanks"
                    },
                    {
                        "username": "CoderVinit28",
                        "content": "Using DFS\\n```\\nclass Solution {\\npublic:\\n    long long leftMost[3001], rightMost[3001], ans;\\n\\n    int widthOfBinaryTree(TreeNode* root) {\\n        memset(leftMost, -1, sizeof(leftMost));\\n        memset(rightMost, -1, sizeof(rightMost));\\n        ans = 0;\\n        DFS(root, 0, 0);\\n        return ans;\\n    }\\n\\n    void DFS(TreeNode *node, int level, long long idx){\\n        leftMost[level] = leftMost[level]!=-1? min(leftMost[level], idx) : idx;\\n        rightMost[level] = rightMost[level]!=-1? max(rightMost[level], idx) : idx;\\n        \\n        ans = max(ans, (rightMost[level] - leftMost[level] + 1));\\n        if( node->left != NULL ) DFS(node->left, level+1, idx*2);\\n        if( node->right != NULL ) DFS(node->right, level+1, idx*2+1);\\n    }\\n};\\n```\\n\\nUsing BFS\\n```\\nclass Solution {\\npublic:\\n\\n    int widthOfBinaryTree(TreeNode* root) {\\n        \\n        queue<pair<TreeNode*, int>> q;\\n        long maxWidth = 1, size, left, right; \\n        q.push( {root, 0} );\\n        \\n        while( q.empty() == false ){\\n            \\n            size = q.size(), left = q.front().second, right = q.back().second;\\n            maxWidth = max(maxWidth, (right-left)+1);\\n            \\n            while( size ){\\n                \\n                auto p = q.front();\\n                long idx = p.second;\\n                q.pop();\\n            \\n                if( p.first->left != NULL ) q.push( {p.first->left, idx*2+1 } );\\n                \\n                if( p.first->right != NULL ) q.push( {p.first->right, idx*2+2 } );\\n                \\n                size -= 1;\\n            }\\n        }\\n        \\n        return maxWidth;\\n    }\\n};\\n```\\n\\nWhy the code is not getting accepted when going with DFS approach?\\n*Note: Code using BFS is accepted."
                    },
                    {
                        "username": "ArpitKrishna98",
                        "content": "left = 2*parent -1\\nright = 2*parent\\n\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def widthOfBinaryTree(self, root: Optional[TreeNode]) -> int:\\n        queue=[]\\n        maxw=1\\n        queue.append([root,1])\\n        while queue:\\n            for i in range(len(queue)):\\n                t=queue.pop(0)\\n                if t[0].left:\\n                    queue.append([t[0].left,2*t[1]-1])\\n                if t[0].right:\\n                    queue.append([t[0].right,2*t[1]])\\n            if not(queue):\\n                break\\n            maxw=max(maxw,queue[-1][1]-queue[0][1]+1)\\n        return maxw"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "It\\'s one of the best problems to practice BFS on tree."
                    },
                    {
                        "username": "user6694qk",
                        "content": "please can anyone explain the difference between these two solutions written in c++ :\\n\\nthis one is accepted:\\n\\nint widthOfBinaryTree(TreeNode* root) {\\n        queue<pair<int, TreeNode*>> q;\\n        q.push({0, root});\\n        int ans = INT_MIN;\\n        while(!q.empty()) {\\n            auto rootNode = q.front();\\n            int leftMostNodeNo = rootNode.first;\\n            int rightMostNodeNo = INT_MIN;\\n            int size = q.size();\\n            for(int i=0;i<size;i++) {\\n                pair<long long, TreeNode*> curr = q.front();\\n                q.pop();\\n                TreeNode* node = curr.second;\\n                long long currNodeNo = curr.first;\\n                rightMostNodeNo = curr.first;\\n                if(node->left != NULL) q.push({currNodeNo * 2 + 1, node->left});\\n                if(node->right != NULL) q.push({currNodeNo * 2 + 2, node->right});\\n            }\\n            ans = max(ans, rightMostNodeNo - leftMostNodeNo + 1);\\n        }\\n        return ans;\\n    }\\n\\n\\nthis one gives run time error:\\n\\nint widthOfBinaryTree(TreeNode* root) {\\n        queue<pair<long long, TreeNode*>> q;\\n        q.push({0, root});\\n        int ans = INT_MIN;\\n        while(!q.empty()) {\\n            auto rootNode = q.front();\\n            int leftMostNodeNo = rootNode.first;\\n            int rightMostNodeNo = INT_MIN;\\n            int size = q.size();\\n            for(int i=0;i<size;i++) {\\n                pair<long long, TreeNode*> curr = q.front();\\n                q.pop();\\n                TreeNode* node = curr.second;\\n                long long currNodeNo = curr.first;\\n                rightMostNodeNo = curr.first;\\n                if(node->left != NULL) q.push({currNodeNo * 2 + 1, node->left});\\n                if(node->right != NULL) q.push({currNodeNo * 2 + 2, node->right});\\n            }\\n            ans = max(ans, rightMostNodeNo - leftMostNodeNo + 1);\\n        }\\n        return ans;\\n    }\\n\\n\\nthe only difference between them is in the first solution(accepted) i used \\n`queue<pair<int, TreeNode*>> q;`\\nbut in the second one(not accepted) i used `queue<pair<long long, TreeNode*>> q;`"
                    },
                    {
                        "username": "Samarth_Dengre",
                        "content": "Can anyone tell me the problem with this solution? I am getting 3 on the last test case and the answer is 4.\\n```\\nclass Solution {\\npublic:\\n    unsigned long long ans = 1;\\n    int widthOfBinaryTree(TreeNode* root) {\\n        map<int, pair<unsigned long long, unsigned long long>> dist;\\n        getWidth(root, dist, 1, 1);\\n        return ans;\\n    }\\n\\n    void getWidth(TreeNode* root, map<int, pair<unsigned long long, unsigned long long>>& dist, int level, unsigned long long ind){\\n        if(root == NULL)    return;\\n\\n        if(dist.count(level)){\\n            dist[level].first = min(dist[level].first, ind);\\n            dist[level].second = max(dist[level].second, ind);\\n            ans = max(ans, dist[level].second-dist[level].first+1);\\n        }else{\\n            dist[level].first = ind;\\n            dist[level].second = ind;\\n        }\\n\\n        getWidth(root->left, dist, level+1, ind*2-1);\\n        getWidth(root->right, dist, level+1, ind*2);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "I\\'m concerned about how the binary tree forms. Why does the tree structure form like this? For instance, with the input [1,3,2,5,3,null,9], we first encounter 1, which is then set as the root. Then comes 3. Why isn\\'t it placed on the right? How is the tree structure formed in the question?"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I think, the tree structure such as [1,3,2,5,3,null, 9] is displayed by way of level order, it is default in leetcode."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "In a certain layer, the width between two ended nodes a and b, can be calculated by recursion process, shown as below:\\nwidth(a, b) = 2 * width(parent[a], parent[b]) - (a is right child) - (b is left child)\\nI think the way can be better, it can avoid processing super big value."
                    },
                    {
                        "username": "KhacLong",
                        "content": "what if each level contains a node, and this node is rightmost?"
                    },
                    {
                        "username": "jolswlf",
                        "content": "If each level only contains a node that node will be both the leftmost and rightmost of that level. "
                    }
                ]
            },
            {
                "id": 1869159,
                "content": [
                    {
                        "username": "namandt",
                        "content": "Nice challenge, liked solving it!"
                    },
                    {
                        "username": "halfengineer",
                        "content": "Can anybody please explain this why in cpp we are using longloong 2LL while inserting and in java simply 2*index is working..Thanks"
                    },
                    {
                        "username": "CoderVinit28",
                        "content": "Using DFS\\n```\\nclass Solution {\\npublic:\\n    long long leftMost[3001], rightMost[3001], ans;\\n\\n    int widthOfBinaryTree(TreeNode* root) {\\n        memset(leftMost, -1, sizeof(leftMost));\\n        memset(rightMost, -1, sizeof(rightMost));\\n        ans = 0;\\n        DFS(root, 0, 0);\\n        return ans;\\n    }\\n\\n    void DFS(TreeNode *node, int level, long long idx){\\n        leftMost[level] = leftMost[level]!=-1? min(leftMost[level], idx) : idx;\\n        rightMost[level] = rightMost[level]!=-1? max(rightMost[level], idx) : idx;\\n        \\n        ans = max(ans, (rightMost[level] - leftMost[level] + 1));\\n        if( node->left != NULL ) DFS(node->left, level+1, idx*2);\\n        if( node->right != NULL ) DFS(node->right, level+1, idx*2+1);\\n    }\\n};\\n```\\n\\nUsing BFS\\n```\\nclass Solution {\\npublic:\\n\\n    int widthOfBinaryTree(TreeNode* root) {\\n        \\n        queue<pair<TreeNode*, int>> q;\\n        long maxWidth = 1, size, left, right; \\n        q.push( {root, 0} );\\n        \\n        while( q.empty() == false ){\\n            \\n            size = q.size(), left = q.front().second, right = q.back().second;\\n            maxWidth = max(maxWidth, (right-left)+1);\\n            \\n            while( size ){\\n                \\n                auto p = q.front();\\n                long idx = p.second;\\n                q.pop();\\n            \\n                if( p.first->left != NULL ) q.push( {p.first->left, idx*2+1 } );\\n                \\n                if( p.first->right != NULL ) q.push( {p.first->right, idx*2+2 } );\\n                \\n                size -= 1;\\n            }\\n        }\\n        \\n        return maxWidth;\\n    }\\n};\\n```\\n\\nWhy the code is not getting accepted when going with DFS approach?\\n*Note: Code using BFS is accepted."
                    },
                    {
                        "username": "ArpitKrishna98",
                        "content": "left = 2*parent -1\\nright = 2*parent\\n\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def widthOfBinaryTree(self, root: Optional[TreeNode]) -> int:\\n        queue=[]\\n        maxw=1\\n        queue.append([root,1])\\n        while queue:\\n            for i in range(len(queue)):\\n                t=queue.pop(0)\\n                if t[0].left:\\n                    queue.append([t[0].left,2*t[1]-1])\\n                if t[0].right:\\n                    queue.append([t[0].right,2*t[1]])\\n            if not(queue):\\n                break\\n            maxw=max(maxw,queue[-1][1]-queue[0][1]+1)\\n        return maxw"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "It\\'s one of the best problems to practice BFS on tree."
                    },
                    {
                        "username": "user6694qk",
                        "content": "please can anyone explain the difference between these two solutions written in c++ :\\n\\nthis one is accepted:\\n\\nint widthOfBinaryTree(TreeNode* root) {\\n        queue<pair<int, TreeNode*>> q;\\n        q.push({0, root});\\n        int ans = INT_MIN;\\n        while(!q.empty()) {\\n            auto rootNode = q.front();\\n            int leftMostNodeNo = rootNode.first;\\n            int rightMostNodeNo = INT_MIN;\\n            int size = q.size();\\n            for(int i=0;i<size;i++) {\\n                pair<long long, TreeNode*> curr = q.front();\\n                q.pop();\\n                TreeNode* node = curr.second;\\n                long long currNodeNo = curr.first;\\n                rightMostNodeNo = curr.first;\\n                if(node->left != NULL) q.push({currNodeNo * 2 + 1, node->left});\\n                if(node->right != NULL) q.push({currNodeNo * 2 + 2, node->right});\\n            }\\n            ans = max(ans, rightMostNodeNo - leftMostNodeNo + 1);\\n        }\\n        return ans;\\n    }\\n\\n\\nthis one gives run time error:\\n\\nint widthOfBinaryTree(TreeNode* root) {\\n        queue<pair<long long, TreeNode*>> q;\\n        q.push({0, root});\\n        int ans = INT_MIN;\\n        while(!q.empty()) {\\n            auto rootNode = q.front();\\n            int leftMostNodeNo = rootNode.first;\\n            int rightMostNodeNo = INT_MIN;\\n            int size = q.size();\\n            for(int i=0;i<size;i++) {\\n                pair<long long, TreeNode*> curr = q.front();\\n                q.pop();\\n                TreeNode* node = curr.second;\\n                long long currNodeNo = curr.first;\\n                rightMostNodeNo = curr.first;\\n                if(node->left != NULL) q.push({currNodeNo * 2 + 1, node->left});\\n                if(node->right != NULL) q.push({currNodeNo * 2 + 2, node->right});\\n            }\\n            ans = max(ans, rightMostNodeNo - leftMostNodeNo + 1);\\n        }\\n        return ans;\\n    }\\n\\n\\nthe only difference between them is in the first solution(accepted) i used \\n`queue<pair<int, TreeNode*>> q;`\\nbut in the second one(not accepted) i used `queue<pair<long long, TreeNode*>> q;`"
                    },
                    {
                        "username": "Samarth_Dengre",
                        "content": "Can anyone tell me the problem with this solution? I am getting 3 on the last test case and the answer is 4.\\n```\\nclass Solution {\\npublic:\\n    unsigned long long ans = 1;\\n    int widthOfBinaryTree(TreeNode* root) {\\n        map<int, pair<unsigned long long, unsigned long long>> dist;\\n        getWidth(root, dist, 1, 1);\\n        return ans;\\n    }\\n\\n    void getWidth(TreeNode* root, map<int, pair<unsigned long long, unsigned long long>>& dist, int level, unsigned long long ind){\\n        if(root == NULL)    return;\\n\\n        if(dist.count(level)){\\n            dist[level].first = min(dist[level].first, ind);\\n            dist[level].second = max(dist[level].second, ind);\\n            ans = max(ans, dist[level].second-dist[level].first+1);\\n        }else{\\n            dist[level].first = ind;\\n            dist[level].second = ind;\\n        }\\n\\n        getWidth(root->left, dist, level+1, ind*2-1);\\n        getWidth(root->right, dist, level+1, ind*2);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "I\\'m concerned about how the binary tree forms. Why does the tree structure form like this? For instance, with the input [1,3,2,5,3,null,9], we first encounter 1, which is then set as the root. Then comes 3. Why isn\\'t it placed on the right? How is the tree structure formed in the question?"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I think, the tree structure such as [1,3,2,5,3,null, 9] is displayed by way of level order, it is default in leetcode."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "In a certain layer, the width between two ended nodes a and b, can be calculated by recursion process, shown as below:\\nwidth(a, b) = 2 * width(parent[a], parent[b]) - (a is right child) - (b is left child)\\nI think the way can be better, it can avoid processing super big value."
                    },
                    {
                        "username": "KhacLong",
                        "content": "what if each level contains a node, and this node is rightmost?"
                    },
                    {
                        "username": "jolswlf",
                        "content": "If each level only contains a node that node will be both the leftmost and rightmost of that level. "
                    }
                ]
            },
            {
                "id": 1869143,
                "content": [
                    {
                        "username": "namandt",
                        "content": "Nice challenge, liked solving it!"
                    },
                    {
                        "username": "halfengineer",
                        "content": "Can anybody please explain this why in cpp we are using longloong 2LL while inserting and in java simply 2*index is working..Thanks"
                    },
                    {
                        "username": "CoderVinit28",
                        "content": "Using DFS\\n```\\nclass Solution {\\npublic:\\n    long long leftMost[3001], rightMost[3001], ans;\\n\\n    int widthOfBinaryTree(TreeNode* root) {\\n        memset(leftMost, -1, sizeof(leftMost));\\n        memset(rightMost, -1, sizeof(rightMost));\\n        ans = 0;\\n        DFS(root, 0, 0);\\n        return ans;\\n    }\\n\\n    void DFS(TreeNode *node, int level, long long idx){\\n        leftMost[level] = leftMost[level]!=-1? min(leftMost[level], idx) : idx;\\n        rightMost[level] = rightMost[level]!=-1? max(rightMost[level], idx) : idx;\\n        \\n        ans = max(ans, (rightMost[level] - leftMost[level] + 1));\\n        if( node->left != NULL ) DFS(node->left, level+1, idx*2);\\n        if( node->right != NULL ) DFS(node->right, level+1, idx*2+1);\\n    }\\n};\\n```\\n\\nUsing BFS\\n```\\nclass Solution {\\npublic:\\n\\n    int widthOfBinaryTree(TreeNode* root) {\\n        \\n        queue<pair<TreeNode*, int>> q;\\n        long maxWidth = 1, size, left, right; \\n        q.push( {root, 0} );\\n        \\n        while( q.empty() == false ){\\n            \\n            size = q.size(), left = q.front().second, right = q.back().second;\\n            maxWidth = max(maxWidth, (right-left)+1);\\n            \\n            while( size ){\\n                \\n                auto p = q.front();\\n                long idx = p.second;\\n                q.pop();\\n            \\n                if( p.first->left != NULL ) q.push( {p.first->left, idx*2+1 } );\\n                \\n                if( p.first->right != NULL ) q.push( {p.first->right, idx*2+2 } );\\n                \\n                size -= 1;\\n            }\\n        }\\n        \\n        return maxWidth;\\n    }\\n};\\n```\\n\\nWhy the code is not getting accepted when going with DFS approach?\\n*Note: Code using BFS is accepted."
                    },
                    {
                        "username": "ArpitKrishna98",
                        "content": "left = 2*parent -1\\nright = 2*parent\\n\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def widthOfBinaryTree(self, root: Optional[TreeNode]) -> int:\\n        queue=[]\\n        maxw=1\\n        queue.append([root,1])\\n        while queue:\\n            for i in range(len(queue)):\\n                t=queue.pop(0)\\n                if t[0].left:\\n                    queue.append([t[0].left,2*t[1]-1])\\n                if t[0].right:\\n                    queue.append([t[0].right,2*t[1]])\\n            if not(queue):\\n                break\\n            maxw=max(maxw,queue[-1][1]-queue[0][1]+1)\\n        return maxw"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "It\\'s one of the best problems to practice BFS on tree."
                    },
                    {
                        "username": "user6694qk",
                        "content": "please can anyone explain the difference between these two solutions written in c++ :\\n\\nthis one is accepted:\\n\\nint widthOfBinaryTree(TreeNode* root) {\\n        queue<pair<int, TreeNode*>> q;\\n        q.push({0, root});\\n        int ans = INT_MIN;\\n        while(!q.empty()) {\\n            auto rootNode = q.front();\\n            int leftMostNodeNo = rootNode.first;\\n            int rightMostNodeNo = INT_MIN;\\n            int size = q.size();\\n            for(int i=0;i<size;i++) {\\n                pair<long long, TreeNode*> curr = q.front();\\n                q.pop();\\n                TreeNode* node = curr.second;\\n                long long currNodeNo = curr.first;\\n                rightMostNodeNo = curr.first;\\n                if(node->left != NULL) q.push({currNodeNo * 2 + 1, node->left});\\n                if(node->right != NULL) q.push({currNodeNo * 2 + 2, node->right});\\n            }\\n            ans = max(ans, rightMostNodeNo - leftMostNodeNo + 1);\\n        }\\n        return ans;\\n    }\\n\\n\\nthis one gives run time error:\\n\\nint widthOfBinaryTree(TreeNode* root) {\\n        queue<pair<long long, TreeNode*>> q;\\n        q.push({0, root});\\n        int ans = INT_MIN;\\n        while(!q.empty()) {\\n            auto rootNode = q.front();\\n            int leftMostNodeNo = rootNode.first;\\n            int rightMostNodeNo = INT_MIN;\\n            int size = q.size();\\n            for(int i=0;i<size;i++) {\\n                pair<long long, TreeNode*> curr = q.front();\\n                q.pop();\\n                TreeNode* node = curr.second;\\n                long long currNodeNo = curr.first;\\n                rightMostNodeNo = curr.first;\\n                if(node->left != NULL) q.push({currNodeNo * 2 + 1, node->left});\\n                if(node->right != NULL) q.push({currNodeNo * 2 + 2, node->right});\\n            }\\n            ans = max(ans, rightMostNodeNo - leftMostNodeNo + 1);\\n        }\\n        return ans;\\n    }\\n\\n\\nthe only difference between them is in the first solution(accepted) i used \\n`queue<pair<int, TreeNode*>> q;`\\nbut in the second one(not accepted) i used `queue<pair<long long, TreeNode*>> q;`"
                    },
                    {
                        "username": "Samarth_Dengre",
                        "content": "Can anyone tell me the problem with this solution? I am getting 3 on the last test case and the answer is 4.\\n```\\nclass Solution {\\npublic:\\n    unsigned long long ans = 1;\\n    int widthOfBinaryTree(TreeNode* root) {\\n        map<int, pair<unsigned long long, unsigned long long>> dist;\\n        getWidth(root, dist, 1, 1);\\n        return ans;\\n    }\\n\\n    void getWidth(TreeNode* root, map<int, pair<unsigned long long, unsigned long long>>& dist, int level, unsigned long long ind){\\n        if(root == NULL)    return;\\n\\n        if(dist.count(level)){\\n            dist[level].first = min(dist[level].first, ind);\\n            dist[level].second = max(dist[level].second, ind);\\n            ans = max(ans, dist[level].second-dist[level].first+1);\\n        }else{\\n            dist[level].first = ind;\\n            dist[level].second = ind;\\n        }\\n\\n        getWidth(root->left, dist, level+1, ind*2-1);\\n        getWidth(root->right, dist, level+1, ind*2);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "I\\'m concerned about how the binary tree forms. Why does the tree structure form like this? For instance, with the input [1,3,2,5,3,null,9], we first encounter 1, which is then set as the root. Then comes 3. Why isn\\'t it placed on the right? How is the tree structure formed in the question?"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I think, the tree structure such as [1,3,2,5,3,null, 9] is displayed by way of level order, it is default in leetcode."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "In a certain layer, the width between two ended nodes a and b, can be calculated by recursion process, shown as below:\\nwidth(a, b) = 2 * width(parent[a], parent[b]) - (a is right child) - (b is left child)\\nI think the way can be better, it can avoid processing super big value."
                    },
                    {
                        "username": "KhacLong",
                        "content": "what if each level contains a node, and this node is rightmost?"
                    },
                    {
                        "username": "jolswlf",
                        "content": "If each level only contains a node that node will be both the leftmost and rightmost of that level. "
                    }
                ]
            },
            {
                "id": 1869141,
                "content": [
                    {
                        "username": "namandt",
                        "content": "Nice challenge, liked solving it!"
                    },
                    {
                        "username": "halfengineer",
                        "content": "Can anybody please explain this why in cpp we are using longloong 2LL while inserting and in java simply 2*index is working..Thanks"
                    },
                    {
                        "username": "CoderVinit28",
                        "content": "Using DFS\\n```\\nclass Solution {\\npublic:\\n    long long leftMost[3001], rightMost[3001], ans;\\n\\n    int widthOfBinaryTree(TreeNode* root) {\\n        memset(leftMost, -1, sizeof(leftMost));\\n        memset(rightMost, -1, sizeof(rightMost));\\n        ans = 0;\\n        DFS(root, 0, 0);\\n        return ans;\\n    }\\n\\n    void DFS(TreeNode *node, int level, long long idx){\\n        leftMost[level] = leftMost[level]!=-1? min(leftMost[level], idx) : idx;\\n        rightMost[level] = rightMost[level]!=-1? max(rightMost[level], idx) : idx;\\n        \\n        ans = max(ans, (rightMost[level] - leftMost[level] + 1));\\n        if( node->left != NULL ) DFS(node->left, level+1, idx*2);\\n        if( node->right != NULL ) DFS(node->right, level+1, idx*2+1);\\n    }\\n};\\n```\\n\\nUsing BFS\\n```\\nclass Solution {\\npublic:\\n\\n    int widthOfBinaryTree(TreeNode* root) {\\n        \\n        queue<pair<TreeNode*, int>> q;\\n        long maxWidth = 1, size, left, right; \\n        q.push( {root, 0} );\\n        \\n        while( q.empty() == false ){\\n            \\n            size = q.size(), left = q.front().second, right = q.back().second;\\n            maxWidth = max(maxWidth, (right-left)+1);\\n            \\n            while( size ){\\n                \\n                auto p = q.front();\\n                long idx = p.second;\\n                q.pop();\\n            \\n                if( p.first->left != NULL ) q.push( {p.first->left, idx*2+1 } );\\n                \\n                if( p.first->right != NULL ) q.push( {p.first->right, idx*2+2 } );\\n                \\n                size -= 1;\\n            }\\n        }\\n        \\n        return maxWidth;\\n    }\\n};\\n```\\n\\nWhy the code is not getting accepted when going with DFS approach?\\n*Note: Code using BFS is accepted."
                    },
                    {
                        "username": "ArpitKrishna98",
                        "content": "left = 2*parent -1\\nright = 2*parent\\n\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def widthOfBinaryTree(self, root: Optional[TreeNode]) -> int:\\n        queue=[]\\n        maxw=1\\n        queue.append([root,1])\\n        while queue:\\n            for i in range(len(queue)):\\n                t=queue.pop(0)\\n                if t[0].left:\\n                    queue.append([t[0].left,2*t[1]-1])\\n                if t[0].right:\\n                    queue.append([t[0].right,2*t[1]])\\n            if not(queue):\\n                break\\n            maxw=max(maxw,queue[-1][1]-queue[0][1]+1)\\n        return maxw"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "It\\'s one of the best problems to practice BFS on tree."
                    },
                    {
                        "username": "user6694qk",
                        "content": "please can anyone explain the difference between these two solutions written in c++ :\\n\\nthis one is accepted:\\n\\nint widthOfBinaryTree(TreeNode* root) {\\n        queue<pair<int, TreeNode*>> q;\\n        q.push({0, root});\\n        int ans = INT_MIN;\\n        while(!q.empty()) {\\n            auto rootNode = q.front();\\n            int leftMostNodeNo = rootNode.first;\\n            int rightMostNodeNo = INT_MIN;\\n            int size = q.size();\\n            for(int i=0;i<size;i++) {\\n                pair<long long, TreeNode*> curr = q.front();\\n                q.pop();\\n                TreeNode* node = curr.second;\\n                long long currNodeNo = curr.first;\\n                rightMostNodeNo = curr.first;\\n                if(node->left != NULL) q.push({currNodeNo * 2 + 1, node->left});\\n                if(node->right != NULL) q.push({currNodeNo * 2 + 2, node->right});\\n            }\\n            ans = max(ans, rightMostNodeNo - leftMostNodeNo + 1);\\n        }\\n        return ans;\\n    }\\n\\n\\nthis one gives run time error:\\n\\nint widthOfBinaryTree(TreeNode* root) {\\n        queue<pair<long long, TreeNode*>> q;\\n        q.push({0, root});\\n        int ans = INT_MIN;\\n        while(!q.empty()) {\\n            auto rootNode = q.front();\\n            int leftMostNodeNo = rootNode.first;\\n            int rightMostNodeNo = INT_MIN;\\n            int size = q.size();\\n            for(int i=0;i<size;i++) {\\n                pair<long long, TreeNode*> curr = q.front();\\n                q.pop();\\n                TreeNode* node = curr.second;\\n                long long currNodeNo = curr.first;\\n                rightMostNodeNo = curr.first;\\n                if(node->left != NULL) q.push({currNodeNo * 2 + 1, node->left});\\n                if(node->right != NULL) q.push({currNodeNo * 2 + 2, node->right});\\n            }\\n            ans = max(ans, rightMostNodeNo - leftMostNodeNo + 1);\\n        }\\n        return ans;\\n    }\\n\\n\\nthe only difference between them is in the first solution(accepted) i used \\n`queue<pair<int, TreeNode*>> q;`\\nbut in the second one(not accepted) i used `queue<pair<long long, TreeNode*>> q;`"
                    },
                    {
                        "username": "Samarth_Dengre",
                        "content": "Can anyone tell me the problem with this solution? I am getting 3 on the last test case and the answer is 4.\\n```\\nclass Solution {\\npublic:\\n    unsigned long long ans = 1;\\n    int widthOfBinaryTree(TreeNode* root) {\\n        map<int, pair<unsigned long long, unsigned long long>> dist;\\n        getWidth(root, dist, 1, 1);\\n        return ans;\\n    }\\n\\n    void getWidth(TreeNode* root, map<int, pair<unsigned long long, unsigned long long>>& dist, int level, unsigned long long ind){\\n        if(root == NULL)    return;\\n\\n        if(dist.count(level)){\\n            dist[level].first = min(dist[level].first, ind);\\n            dist[level].second = max(dist[level].second, ind);\\n            ans = max(ans, dist[level].second-dist[level].first+1);\\n        }else{\\n            dist[level].first = ind;\\n            dist[level].second = ind;\\n        }\\n\\n        getWidth(root->left, dist, level+1, ind*2-1);\\n        getWidth(root->right, dist, level+1, ind*2);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "I\\'m concerned about how the binary tree forms. Why does the tree structure form like this? For instance, with the input [1,3,2,5,3,null,9], we first encounter 1, which is then set as the root. Then comes 3. Why isn\\'t it placed on the right? How is the tree structure formed in the question?"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I think, the tree structure such as [1,3,2,5,3,null, 9] is displayed by way of level order, it is default in leetcode."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "In a certain layer, the width between two ended nodes a and b, can be calculated by recursion process, shown as below:\\nwidth(a, b) = 2 * width(parent[a], parent[b]) - (a is right child) - (b is left child)\\nI think the way can be better, it can avoid processing super big value."
                    },
                    {
                        "username": "KhacLong",
                        "content": "what if each level contains a node, and this node is rightmost?"
                    },
                    {
                        "username": "jolswlf",
                        "content": "If each level only contains a node that node will be both the leftmost and rightmost of that level. "
                    }
                ]
            },
            {
                "id": 1869133,
                "content": [
                    {
                        "username": "namandt",
                        "content": "Nice challenge, liked solving it!"
                    },
                    {
                        "username": "halfengineer",
                        "content": "Can anybody please explain this why in cpp we are using longloong 2LL while inserting and in java simply 2*index is working..Thanks"
                    },
                    {
                        "username": "CoderVinit28",
                        "content": "Using DFS\\n```\\nclass Solution {\\npublic:\\n    long long leftMost[3001], rightMost[3001], ans;\\n\\n    int widthOfBinaryTree(TreeNode* root) {\\n        memset(leftMost, -1, sizeof(leftMost));\\n        memset(rightMost, -1, sizeof(rightMost));\\n        ans = 0;\\n        DFS(root, 0, 0);\\n        return ans;\\n    }\\n\\n    void DFS(TreeNode *node, int level, long long idx){\\n        leftMost[level] = leftMost[level]!=-1? min(leftMost[level], idx) : idx;\\n        rightMost[level] = rightMost[level]!=-1? max(rightMost[level], idx) : idx;\\n        \\n        ans = max(ans, (rightMost[level] - leftMost[level] + 1));\\n        if( node->left != NULL ) DFS(node->left, level+1, idx*2);\\n        if( node->right != NULL ) DFS(node->right, level+1, idx*2+1);\\n    }\\n};\\n```\\n\\nUsing BFS\\n```\\nclass Solution {\\npublic:\\n\\n    int widthOfBinaryTree(TreeNode* root) {\\n        \\n        queue<pair<TreeNode*, int>> q;\\n        long maxWidth = 1, size, left, right; \\n        q.push( {root, 0} );\\n        \\n        while( q.empty() == false ){\\n            \\n            size = q.size(), left = q.front().second, right = q.back().second;\\n            maxWidth = max(maxWidth, (right-left)+1);\\n            \\n            while( size ){\\n                \\n                auto p = q.front();\\n                long idx = p.second;\\n                q.pop();\\n            \\n                if( p.first->left != NULL ) q.push( {p.first->left, idx*2+1 } );\\n                \\n                if( p.first->right != NULL ) q.push( {p.first->right, idx*2+2 } );\\n                \\n                size -= 1;\\n            }\\n        }\\n        \\n        return maxWidth;\\n    }\\n};\\n```\\n\\nWhy the code is not getting accepted when going with DFS approach?\\n*Note: Code using BFS is accepted."
                    },
                    {
                        "username": "ArpitKrishna98",
                        "content": "left = 2*parent -1\\nright = 2*parent\\n\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def widthOfBinaryTree(self, root: Optional[TreeNode]) -> int:\\n        queue=[]\\n        maxw=1\\n        queue.append([root,1])\\n        while queue:\\n            for i in range(len(queue)):\\n                t=queue.pop(0)\\n                if t[0].left:\\n                    queue.append([t[0].left,2*t[1]-1])\\n                if t[0].right:\\n                    queue.append([t[0].right,2*t[1]])\\n            if not(queue):\\n                break\\n            maxw=max(maxw,queue[-1][1]-queue[0][1]+1)\\n        return maxw"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "It\\'s one of the best problems to practice BFS on tree."
                    },
                    {
                        "username": "user6694qk",
                        "content": "please can anyone explain the difference between these two solutions written in c++ :\\n\\nthis one is accepted:\\n\\nint widthOfBinaryTree(TreeNode* root) {\\n        queue<pair<int, TreeNode*>> q;\\n        q.push({0, root});\\n        int ans = INT_MIN;\\n        while(!q.empty()) {\\n            auto rootNode = q.front();\\n            int leftMostNodeNo = rootNode.first;\\n            int rightMostNodeNo = INT_MIN;\\n            int size = q.size();\\n            for(int i=0;i<size;i++) {\\n                pair<long long, TreeNode*> curr = q.front();\\n                q.pop();\\n                TreeNode* node = curr.second;\\n                long long currNodeNo = curr.first;\\n                rightMostNodeNo = curr.first;\\n                if(node->left != NULL) q.push({currNodeNo * 2 + 1, node->left});\\n                if(node->right != NULL) q.push({currNodeNo * 2 + 2, node->right});\\n            }\\n            ans = max(ans, rightMostNodeNo - leftMostNodeNo + 1);\\n        }\\n        return ans;\\n    }\\n\\n\\nthis one gives run time error:\\n\\nint widthOfBinaryTree(TreeNode* root) {\\n        queue<pair<long long, TreeNode*>> q;\\n        q.push({0, root});\\n        int ans = INT_MIN;\\n        while(!q.empty()) {\\n            auto rootNode = q.front();\\n            int leftMostNodeNo = rootNode.first;\\n            int rightMostNodeNo = INT_MIN;\\n            int size = q.size();\\n            for(int i=0;i<size;i++) {\\n                pair<long long, TreeNode*> curr = q.front();\\n                q.pop();\\n                TreeNode* node = curr.second;\\n                long long currNodeNo = curr.first;\\n                rightMostNodeNo = curr.first;\\n                if(node->left != NULL) q.push({currNodeNo * 2 + 1, node->left});\\n                if(node->right != NULL) q.push({currNodeNo * 2 + 2, node->right});\\n            }\\n            ans = max(ans, rightMostNodeNo - leftMostNodeNo + 1);\\n        }\\n        return ans;\\n    }\\n\\n\\nthe only difference between them is in the first solution(accepted) i used \\n`queue<pair<int, TreeNode*>> q;`\\nbut in the second one(not accepted) i used `queue<pair<long long, TreeNode*>> q;`"
                    },
                    {
                        "username": "Samarth_Dengre",
                        "content": "Can anyone tell me the problem with this solution? I am getting 3 on the last test case and the answer is 4.\\n```\\nclass Solution {\\npublic:\\n    unsigned long long ans = 1;\\n    int widthOfBinaryTree(TreeNode* root) {\\n        map<int, pair<unsigned long long, unsigned long long>> dist;\\n        getWidth(root, dist, 1, 1);\\n        return ans;\\n    }\\n\\n    void getWidth(TreeNode* root, map<int, pair<unsigned long long, unsigned long long>>& dist, int level, unsigned long long ind){\\n        if(root == NULL)    return;\\n\\n        if(dist.count(level)){\\n            dist[level].first = min(dist[level].first, ind);\\n            dist[level].second = max(dist[level].second, ind);\\n            ans = max(ans, dist[level].second-dist[level].first+1);\\n        }else{\\n            dist[level].first = ind;\\n            dist[level].second = ind;\\n        }\\n\\n        getWidth(root->left, dist, level+1, ind*2-1);\\n        getWidth(root->right, dist, level+1, ind*2);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "I\\'m concerned about how the binary tree forms. Why does the tree structure form like this? For instance, with the input [1,3,2,5,3,null,9], we first encounter 1, which is then set as the root. Then comes 3. Why isn\\'t it placed on the right? How is the tree structure formed in the question?"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I think, the tree structure such as [1,3,2,5,3,null, 9] is displayed by way of level order, it is default in leetcode."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "In a certain layer, the width between two ended nodes a and b, can be calculated by recursion process, shown as below:\\nwidth(a, b) = 2 * width(parent[a], parent[b]) - (a is right child) - (b is left child)\\nI think the way can be better, it can avoid processing super big value."
                    },
                    {
                        "username": "KhacLong",
                        "content": "what if each level contains a node, and this node is rightmost?"
                    },
                    {
                        "username": "jolswlf",
                        "content": "If each level only contains a node that node will be both the leftmost and rightmost of that level. "
                    }
                ]
            },
            {
                "id": 1869076,
                "content": [
                    {
                        "username": "19020442",
                        "content": "who can image the final testcase , pless :((?"
                    },
                    {
                        "username": "halfengineer",
                        "content": "Not tle this time getting memory limit exceeded for higher test case\\uD83D\\uDE25"
                    },
                    {
                        "username": "aman3091",
                        "content": "can anyone help me. i am getting error\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int widthOfBinaryTree(TreeNode* root) {\\n        if(root==NULL){\\n            return 0;\\n        }\\n        int ans=0;\\n        queue<pair<TreeNode*,int>>q;\\n        q.push({root,0});\\n        while(!q.empty()){\\n            int size=q.size();\\n            int mmin=q.front().second;\\n            int first,last;\\n            for(int i=0;i<size;i++){\\n                int curr_id=q.front().second-mmin;\\n                auto p=q.front().first;\\n                q.pop();\\n                if(i==0){\\n                    first=curr_id;\\n                }\\n                if(i==size-1){\\n                    last=curr_id;\\n                }\\n                if(p->left!=NULL){\\n                    q.push({p->left,curr_id*2+1});\\n                }\\n                if(p->right!=NULL){\\n                    q.push({p->right,curr_id*2+2});\\n                }\\n            }\\n            ans=max(ans,last-first+1);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Wetooa",
                        "content": "sorry if this might be stupid but is there a way we can get a variable that stores a bigger number than long long? I\\'ve switched from python to c++ and this number limit error has been bugging me the f out. or should I just make code that reduces these big numbers?"
                    },
                    {
                        "username": "AKK_16",
                        "content": "Using recursion and C++\n\nclass Solution {\npublic:\n\n    unordered_map<int , pair<unsigned long long int,unsigned long long int> > mp;\n    void fn(TreeNode* ptr,int l,unsigned long long int i)\n    {\n        if(ptr==nullptr) return;\n        if(mp.count(l)==0)\n        {\n            mp[l].first = i;\n            mp[l].second = i;\n        }\n        else \n        {\n            mp[l].first = max(mp[l].first,i);\n            mp[l].second = min(mp[l].second,i);\n        }\n        \n        if(ptr->left)\n        {\n            fn(ptr->left,l+1,i*2+1);\n        }\n\n        if(ptr->right)\n        {\n            fn(ptr->right,l+1,i*2+2);\n        }\n\n    }\n    int widthOfBinaryTree(TreeNode* root) {\n        if(root==nullptr) return 0;\n        fn(root,0,1);\n        int ans=1;\n        for(auto &i:mp)\n        {\n            int x = i.second.first-i.second.second+1;\n            ans=max(ans,x);\n        }\n\n        return ans;\n    }\n};"
                    },
                    {
                        "username": "galster",
                        "content": "This question has a bug.\\nWhen you try to run any of the C++ solutions using DFS and with the *2, *2 + 1 solution you get an integer overflow. I\\'ve tested multiple C++ solutions posted here and they all seem to have the same issue. For some unexplained reason Java solutions pass it."
                    },
                    {
                        "username": "suf01",
                        "content": "dude this is soo weird, please anyone help me out\n\nso theres this one code which passed all the test cases\n\nint widthOfBinaryTree(TreeNode* root) {\n        long ans = 0;\n        \n        if(root == NULL){\n            return ans;\n        }\n        \n        queue<pair<TreeNode*, long> > q;\n        q.push({root, 0});\n        \n        while(!q.empty()){\n            int n = q.size();\n            \n            long start = q.front().second;\n            long end = q.back().second;\n            \n            ans = max(ans, end-start+1);\n            \n            for(int i = 0; i < n; i++){\n                pair<TreeNode*, int> item = q.front();\n                \n                TreeNode* temp = item.first;\n                long prev_index = item.second;\n                \n                if(temp->left!=NULL) q.push({temp->left, prev_index*2+1});\n                if(temp->right!=NULL) q.push({temp->right, prev_index*2+2});\n                \n                q.pop();\n            }\n        }\n        \n        return ans;\n    }\n\nand then theres this another code which i wrote following the same approach but this time its giving run time error, i checked these two codes for hours and haven't been able to figure out why, its driving me crazy please help me out\n\nint widthOfBinaryTree(TreeNode* root) {\n        long long ans = 0;\n        if(root == NULL){\n            return ans;\n        }\n\n        queue<pair<TreeNode*, long long> > q;\n        q.push({root, 0});\n\n        while(!q.empty()){\n            long long n = q.size();\n\n            long long start = q.front().second;\n            long long end = q.back().second;\n\n            ans = max(ans, end-start+1);\n            for(int i = 0; i < n; i++){\n                TreeNode* temp = q.front().first;\n                long long index = q.front().second;\n                q.pop();\n \n                if(temp->left) q.push({temp->left, 2*index+1});\n                if(temp->right) q.push({temp->right, 2*index+2});\n            }\n        }\n        return ans;\n    }"
                    },
                    {
                        "username": "pxlcode",
                        "content": "Unsigned 32 bit integer works for C++ without overflow"
                    },
                    {
                        "username": "saintmeteo",
                        "content": "hey can you please how can i initialize unsigned 32 bit integer in cpp? or can you share your code ?"
                    },
                    {
                        "username": "aman3091",
                        "content": "Can anyone help me to correct my code.\\nclass Solution {\\npublic:\\n    int widthOfBinaryTree(TreeNode* root) {\\n        if(!root){\\n            return 0;\\n        }\\n        int ans=0;\\n        queue<pair<TreeNode*,int>>q;\\n        q.push({root,0});\\n        while(!q.empty()){\\n            int size=q.size();\\n            int mmin=q.front().second;\\n            int first,last;\\n             for(int i=0;i<size;i++){\\n                 int curr_id=q.front().second-mmin;\\n                 TreeNode* node=q.front().first;\\n                 q.pop();\\n                 if(i==0){\\n                     first=curr_id;\\n                 }\\n                 if(i==size-1){\\n                     last=curr_id;\\n                 }\\n                 if(node->left){\\n                     q.push({node->left,curr_id*2+1});\\n                 }\\n                 if(node->right){\\n                     q.push({node->right,curr_id*2+2});\\n                 }\\n             \\n             }\\n                 ans=max(ans,last-first+1);\\n        }\\n        return ans;\\n\\n    }\\n};"
                    },
                    {
                        "username": "ankitmishra2108",
                        "content": "class Solution {\\npublic:\\n    int widthOfBinaryTree(TreeNode* root) {\\n        int ans = 0;\\n        if(root == NULL){\\n            return ans;\\n        }\\n        queue<pair<TreeNode*, long>> q;\\n        q.push({root, 0});\\n\\n        while(!q.empty()){\\n            long size = q.size();\\n            long min = q.front().second;\\n            int first, last;\\n            for(int i = 0; i < size; i++){\\n                TreeNode* node = q.front().first;\\n                long index = q.front().second-min;\\n                q.pop();\\n\\n                if(i == 0){\\n                    first = index;\\n                }\\n                if(i == size-1){\\n                    last = index;\\n                }\\n                if(node->left != NULL){\\n                    q.push({node->left, index*2+1});\\n                }\\n                if(node->right != NULL){\\n                    q.push({node->right, index*2+2});\\n                }\\n            }\\n            ans = max(ans, (last-first)+1);\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1868923,
                "content": [
                    {
                        "username": "19020442",
                        "content": "who can image the final testcase , pless :((?"
                    },
                    {
                        "username": "halfengineer",
                        "content": "Not tle this time getting memory limit exceeded for higher test case\\uD83D\\uDE25"
                    },
                    {
                        "username": "aman3091",
                        "content": "can anyone help me. i am getting error\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int widthOfBinaryTree(TreeNode* root) {\\n        if(root==NULL){\\n            return 0;\\n        }\\n        int ans=0;\\n        queue<pair<TreeNode*,int>>q;\\n        q.push({root,0});\\n        while(!q.empty()){\\n            int size=q.size();\\n            int mmin=q.front().second;\\n            int first,last;\\n            for(int i=0;i<size;i++){\\n                int curr_id=q.front().second-mmin;\\n                auto p=q.front().first;\\n                q.pop();\\n                if(i==0){\\n                    first=curr_id;\\n                }\\n                if(i==size-1){\\n                    last=curr_id;\\n                }\\n                if(p->left!=NULL){\\n                    q.push({p->left,curr_id*2+1});\\n                }\\n                if(p->right!=NULL){\\n                    q.push({p->right,curr_id*2+2});\\n                }\\n            }\\n            ans=max(ans,last-first+1);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Wetooa",
                        "content": "sorry if this might be stupid but is there a way we can get a variable that stores a bigger number than long long? I\\'ve switched from python to c++ and this number limit error has been bugging me the f out. or should I just make code that reduces these big numbers?"
                    },
                    {
                        "username": "AKK_16",
                        "content": "Using recursion and C++\n\nclass Solution {\npublic:\n\n    unordered_map<int , pair<unsigned long long int,unsigned long long int> > mp;\n    void fn(TreeNode* ptr,int l,unsigned long long int i)\n    {\n        if(ptr==nullptr) return;\n        if(mp.count(l)==0)\n        {\n            mp[l].first = i;\n            mp[l].second = i;\n        }\n        else \n        {\n            mp[l].first = max(mp[l].first,i);\n            mp[l].second = min(mp[l].second,i);\n        }\n        \n        if(ptr->left)\n        {\n            fn(ptr->left,l+1,i*2+1);\n        }\n\n        if(ptr->right)\n        {\n            fn(ptr->right,l+1,i*2+2);\n        }\n\n    }\n    int widthOfBinaryTree(TreeNode* root) {\n        if(root==nullptr) return 0;\n        fn(root,0,1);\n        int ans=1;\n        for(auto &i:mp)\n        {\n            int x = i.second.first-i.second.second+1;\n            ans=max(ans,x);\n        }\n\n        return ans;\n    }\n};"
                    },
                    {
                        "username": "galster",
                        "content": "This question has a bug.\\nWhen you try to run any of the C++ solutions using DFS and with the *2, *2 + 1 solution you get an integer overflow. I\\'ve tested multiple C++ solutions posted here and they all seem to have the same issue. For some unexplained reason Java solutions pass it."
                    },
                    {
                        "username": "suf01",
                        "content": "dude this is soo weird, please anyone help me out\n\nso theres this one code which passed all the test cases\n\nint widthOfBinaryTree(TreeNode* root) {\n        long ans = 0;\n        \n        if(root == NULL){\n            return ans;\n        }\n        \n        queue<pair<TreeNode*, long> > q;\n        q.push({root, 0});\n        \n        while(!q.empty()){\n            int n = q.size();\n            \n            long start = q.front().second;\n            long end = q.back().second;\n            \n            ans = max(ans, end-start+1);\n            \n            for(int i = 0; i < n; i++){\n                pair<TreeNode*, int> item = q.front();\n                \n                TreeNode* temp = item.first;\n                long prev_index = item.second;\n                \n                if(temp->left!=NULL) q.push({temp->left, prev_index*2+1});\n                if(temp->right!=NULL) q.push({temp->right, prev_index*2+2});\n                \n                q.pop();\n            }\n        }\n        \n        return ans;\n    }\n\nand then theres this another code which i wrote following the same approach but this time its giving run time error, i checked these two codes for hours and haven't been able to figure out why, its driving me crazy please help me out\n\nint widthOfBinaryTree(TreeNode* root) {\n        long long ans = 0;\n        if(root == NULL){\n            return ans;\n        }\n\n        queue<pair<TreeNode*, long long> > q;\n        q.push({root, 0});\n\n        while(!q.empty()){\n            long long n = q.size();\n\n            long long start = q.front().second;\n            long long end = q.back().second;\n\n            ans = max(ans, end-start+1);\n            for(int i = 0; i < n; i++){\n                TreeNode* temp = q.front().first;\n                long long index = q.front().second;\n                q.pop();\n \n                if(temp->left) q.push({temp->left, 2*index+1});\n                if(temp->right) q.push({temp->right, 2*index+2});\n            }\n        }\n        return ans;\n    }"
                    },
                    {
                        "username": "pxlcode",
                        "content": "Unsigned 32 bit integer works for C++ without overflow"
                    },
                    {
                        "username": "saintmeteo",
                        "content": "hey can you please how can i initialize unsigned 32 bit integer in cpp? or can you share your code ?"
                    },
                    {
                        "username": "aman3091",
                        "content": "Can anyone help me to correct my code.\\nclass Solution {\\npublic:\\n    int widthOfBinaryTree(TreeNode* root) {\\n        if(!root){\\n            return 0;\\n        }\\n        int ans=0;\\n        queue<pair<TreeNode*,int>>q;\\n        q.push({root,0});\\n        while(!q.empty()){\\n            int size=q.size();\\n            int mmin=q.front().second;\\n            int first,last;\\n             for(int i=0;i<size;i++){\\n                 int curr_id=q.front().second-mmin;\\n                 TreeNode* node=q.front().first;\\n                 q.pop();\\n                 if(i==0){\\n                     first=curr_id;\\n                 }\\n                 if(i==size-1){\\n                     last=curr_id;\\n                 }\\n                 if(node->left){\\n                     q.push({node->left,curr_id*2+1});\\n                 }\\n                 if(node->right){\\n                     q.push({node->right,curr_id*2+2});\\n                 }\\n             \\n             }\\n                 ans=max(ans,last-first+1);\\n        }\\n        return ans;\\n\\n    }\\n};"
                    },
                    {
                        "username": "ankitmishra2108",
                        "content": "class Solution {\\npublic:\\n    int widthOfBinaryTree(TreeNode* root) {\\n        int ans = 0;\\n        if(root == NULL){\\n            return ans;\\n        }\\n        queue<pair<TreeNode*, long>> q;\\n        q.push({root, 0});\\n\\n        while(!q.empty()){\\n            long size = q.size();\\n            long min = q.front().second;\\n            int first, last;\\n            for(int i = 0; i < size; i++){\\n                TreeNode* node = q.front().first;\\n                long index = q.front().second-min;\\n                q.pop();\\n\\n                if(i == 0){\\n                    first = index;\\n                }\\n                if(i == size-1){\\n                    last = index;\\n                }\\n                if(node->left != NULL){\\n                    q.push({node->left, index*2+1});\\n                }\\n                if(node->right != NULL){\\n                    q.push({node->right, index*2+2});\\n                }\\n            }\\n            ans = max(ans, (last-first)+1);\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1856453,
                "content": [
                    {
                        "username": "19020442",
                        "content": "who can image the final testcase , pless :((?"
                    },
                    {
                        "username": "halfengineer",
                        "content": "Not tle this time getting memory limit exceeded for higher test case\\uD83D\\uDE25"
                    },
                    {
                        "username": "aman3091",
                        "content": "can anyone help me. i am getting error\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int widthOfBinaryTree(TreeNode* root) {\\n        if(root==NULL){\\n            return 0;\\n        }\\n        int ans=0;\\n        queue<pair<TreeNode*,int>>q;\\n        q.push({root,0});\\n        while(!q.empty()){\\n            int size=q.size();\\n            int mmin=q.front().second;\\n            int first,last;\\n            for(int i=0;i<size;i++){\\n                int curr_id=q.front().second-mmin;\\n                auto p=q.front().first;\\n                q.pop();\\n                if(i==0){\\n                    first=curr_id;\\n                }\\n                if(i==size-1){\\n                    last=curr_id;\\n                }\\n                if(p->left!=NULL){\\n                    q.push({p->left,curr_id*2+1});\\n                }\\n                if(p->right!=NULL){\\n                    q.push({p->right,curr_id*2+2});\\n                }\\n            }\\n            ans=max(ans,last-first+1);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Wetooa",
                        "content": "sorry if this might be stupid but is there a way we can get a variable that stores a bigger number than long long? I\\'ve switched from python to c++ and this number limit error has been bugging me the f out. or should I just make code that reduces these big numbers?"
                    },
                    {
                        "username": "AKK_16",
                        "content": "Using recursion and C++\n\nclass Solution {\npublic:\n\n    unordered_map<int , pair<unsigned long long int,unsigned long long int> > mp;\n    void fn(TreeNode* ptr,int l,unsigned long long int i)\n    {\n        if(ptr==nullptr) return;\n        if(mp.count(l)==0)\n        {\n            mp[l].first = i;\n            mp[l].second = i;\n        }\n        else \n        {\n            mp[l].first = max(mp[l].first,i);\n            mp[l].second = min(mp[l].second,i);\n        }\n        \n        if(ptr->left)\n        {\n            fn(ptr->left,l+1,i*2+1);\n        }\n\n        if(ptr->right)\n        {\n            fn(ptr->right,l+1,i*2+2);\n        }\n\n    }\n    int widthOfBinaryTree(TreeNode* root) {\n        if(root==nullptr) return 0;\n        fn(root,0,1);\n        int ans=1;\n        for(auto &i:mp)\n        {\n            int x = i.second.first-i.second.second+1;\n            ans=max(ans,x);\n        }\n\n        return ans;\n    }\n};"
                    },
                    {
                        "username": "galster",
                        "content": "This question has a bug.\\nWhen you try to run any of the C++ solutions using DFS and with the *2, *2 + 1 solution you get an integer overflow. I\\'ve tested multiple C++ solutions posted here and they all seem to have the same issue. For some unexplained reason Java solutions pass it."
                    },
                    {
                        "username": "suf01",
                        "content": "dude this is soo weird, please anyone help me out\n\nso theres this one code which passed all the test cases\n\nint widthOfBinaryTree(TreeNode* root) {\n        long ans = 0;\n        \n        if(root == NULL){\n            return ans;\n        }\n        \n        queue<pair<TreeNode*, long> > q;\n        q.push({root, 0});\n        \n        while(!q.empty()){\n            int n = q.size();\n            \n            long start = q.front().second;\n            long end = q.back().second;\n            \n            ans = max(ans, end-start+1);\n            \n            for(int i = 0; i < n; i++){\n                pair<TreeNode*, int> item = q.front();\n                \n                TreeNode* temp = item.first;\n                long prev_index = item.second;\n                \n                if(temp->left!=NULL) q.push({temp->left, prev_index*2+1});\n                if(temp->right!=NULL) q.push({temp->right, prev_index*2+2});\n                \n                q.pop();\n            }\n        }\n        \n        return ans;\n    }\n\nand then theres this another code which i wrote following the same approach but this time its giving run time error, i checked these two codes for hours and haven't been able to figure out why, its driving me crazy please help me out\n\nint widthOfBinaryTree(TreeNode* root) {\n        long long ans = 0;\n        if(root == NULL){\n            return ans;\n        }\n\n        queue<pair<TreeNode*, long long> > q;\n        q.push({root, 0});\n\n        while(!q.empty()){\n            long long n = q.size();\n\n            long long start = q.front().second;\n            long long end = q.back().second;\n\n            ans = max(ans, end-start+1);\n            for(int i = 0; i < n; i++){\n                TreeNode* temp = q.front().first;\n                long long index = q.front().second;\n                q.pop();\n \n                if(temp->left) q.push({temp->left, 2*index+1});\n                if(temp->right) q.push({temp->right, 2*index+2});\n            }\n        }\n        return ans;\n    }"
                    },
                    {
                        "username": "pxlcode",
                        "content": "Unsigned 32 bit integer works for C++ without overflow"
                    },
                    {
                        "username": "saintmeteo",
                        "content": "hey can you please how can i initialize unsigned 32 bit integer in cpp? or can you share your code ?"
                    },
                    {
                        "username": "aman3091",
                        "content": "Can anyone help me to correct my code.\\nclass Solution {\\npublic:\\n    int widthOfBinaryTree(TreeNode* root) {\\n        if(!root){\\n            return 0;\\n        }\\n        int ans=0;\\n        queue<pair<TreeNode*,int>>q;\\n        q.push({root,0});\\n        while(!q.empty()){\\n            int size=q.size();\\n            int mmin=q.front().second;\\n            int first,last;\\n             for(int i=0;i<size;i++){\\n                 int curr_id=q.front().second-mmin;\\n                 TreeNode* node=q.front().first;\\n                 q.pop();\\n                 if(i==0){\\n                     first=curr_id;\\n                 }\\n                 if(i==size-1){\\n                     last=curr_id;\\n                 }\\n                 if(node->left){\\n                     q.push({node->left,curr_id*2+1});\\n                 }\\n                 if(node->right){\\n                     q.push({node->right,curr_id*2+2});\\n                 }\\n             \\n             }\\n                 ans=max(ans,last-first+1);\\n        }\\n        return ans;\\n\\n    }\\n};"
                    },
                    {
                        "username": "ankitmishra2108",
                        "content": "class Solution {\\npublic:\\n    int widthOfBinaryTree(TreeNode* root) {\\n        int ans = 0;\\n        if(root == NULL){\\n            return ans;\\n        }\\n        queue<pair<TreeNode*, long>> q;\\n        q.push({root, 0});\\n\\n        while(!q.empty()){\\n            long size = q.size();\\n            long min = q.front().second;\\n            int first, last;\\n            for(int i = 0; i < size; i++){\\n                TreeNode* node = q.front().first;\\n                long index = q.front().second-min;\\n                q.pop();\\n\\n                if(i == 0){\\n                    first = index;\\n                }\\n                if(i == size-1){\\n                    last = index;\\n                }\\n                if(node->left != NULL){\\n                    q.push({node->left, index*2+1});\\n                }\\n                if(node->right != NULL){\\n                    q.push({node->right, index*2+2});\\n                }\\n            }\\n            ans = max(ans, (last-first)+1);\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1812291,
                "content": [
                    {
                        "username": "19020442",
                        "content": "who can image the final testcase , pless :((?"
                    },
                    {
                        "username": "halfengineer",
                        "content": "Not tle this time getting memory limit exceeded for higher test case\\uD83D\\uDE25"
                    },
                    {
                        "username": "aman3091",
                        "content": "can anyone help me. i am getting error\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int widthOfBinaryTree(TreeNode* root) {\\n        if(root==NULL){\\n            return 0;\\n        }\\n        int ans=0;\\n        queue<pair<TreeNode*,int>>q;\\n        q.push({root,0});\\n        while(!q.empty()){\\n            int size=q.size();\\n            int mmin=q.front().second;\\n            int first,last;\\n            for(int i=0;i<size;i++){\\n                int curr_id=q.front().second-mmin;\\n                auto p=q.front().first;\\n                q.pop();\\n                if(i==0){\\n                    first=curr_id;\\n                }\\n                if(i==size-1){\\n                    last=curr_id;\\n                }\\n                if(p->left!=NULL){\\n                    q.push({p->left,curr_id*2+1});\\n                }\\n                if(p->right!=NULL){\\n                    q.push({p->right,curr_id*2+2});\\n                }\\n            }\\n            ans=max(ans,last-first+1);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Wetooa",
                        "content": "sorry if this might be stupid but is there a way we can get a variable that stores a bigger number than long long? I\\'ve switched from python to c++ and this number limit error has been bugging me the f out. or should I just make code that reduces these big numbers?"
                    },
                    {
                        "username": "AKK_16",
                        "content": "Using recursion and C++\n\nclass Solution {\npublic:\n\n    unordered_map<int , pair<unsigned long long int,unsigned long long int> > mp;\n    void fn(TreeNode* ptr,int l,unsigned long long int i)\n    {\n        if(ptr==nullptr) return;\n        if(mp.count(l)==0)\n        {\n            mp[l].first = i;\n            mp[l].second = i;\n        }\n        else \n        {\n            mp[l].first = max(mp[l].first,i);\n            mp[l].second = min(mp[l].second,i);\n        }\n        \n        if(ptr->left)\n        {\n            fn(ptr->left,l+1,i*2+1);\n        }\n\n        if(ptr->right)\n        {\n            fn(ptr->right,l+1,i*2+2);\n        }\n\n    }\n    int widthOfBinaryTree(TreeNode* root) {\n        if(root==nullptr) return 0;\n        fn(root,0,1);\n        int ans=1;\n        for(auto &i:mp)\n        {\n            int x = i.second.first-i.second.second+1;\n            ans=max(ans,x);\n        }\n\n        return ans;\n    }\n};"
                    },
                    {
                        "username": "galster",
                        "content": "This question has a bug.\\nWhen you try to run any of the C++ solutions using DFS and with the *2, *2 + 1 solution you get an integer overflow. I\\'ve tested multiple C++ solutions posted here and they all seem to have the same issue. For some unexplained reason Java solutions pass it."
                    },
                    {
                        "username": "suf01",
                        "content": "dude this is soo weird, please anyone help me out\n\nso theres this one code which passed all the test cases\n\nint widthOfBinaryTree(TreeNode* root) {\n        long ans = 0;\n        \n        if(root == NULL){\n            return ans;\n        }\n        \n        queue<pair<TreeNode*, long> > q;\n        q.push({root, 0});\n        \n        while(!q.empty()){\n            int n = q.size();\n            \n            long start = q.front().second;\n            long end = q.back().second;\n            \n            ans = max(ans, end-start+1);\n            \n            for(int i = 0; i < n; i++){\n                pair<TreeNode*, int> item = q.front();\n                \n                TreeNode* temp = item.first;\n                long prev_index = item.second;\n                \n                if(temp->left!=NULL) q.push({temp->left, prev_index*2+1});\n                if(temp->right!=NULL) q.push({temp->right, prev_index*2+2});\n                \n                q.pop();\n            }\n        }\n        \n        return ans;\n    }\n\nand then theres this another code which i wrote following the same approach but this time its giving run time error, i checked these two codes for hours and haven't been able to figure out why, its driving me crazy please help me out\n\nint widthOfBinaryTree(TreeNode* root) {\n        long long ans = 0;\n        if(root == NULL){\n            return ans;\n        }\n\n        queue<pair<TreeNode*, long long> > q;\n        q.push({root, 0});\n\n        while(!q.empty()){\n            long long n = q.size();\n\n            long long start = q.front().second;\n            long long end = q.back().second;\n\n            ans = max(ans, end-start+1);\n            for(int i = 0; i < n; i++){\n                TreeNode* temp = q.front().first;\n                long long index = q.front().second;\n                q.pop();\n \n                if(temp->left) q.push({temp->left, 2*index+1});\n                if(temp->right) q.push({temp->right, 2*index+2});\n            }\n        }\n        return ans;\n    }"
                    },
                    {
                        "username": "pxlcode",
                        "content": "Unsigned 32 bit integer works for C++ without overflow"
                    },
                    {
                        "username": "saintmeteo",
                        "content": "hey can you please how can i initialize unsigned 32 bit integer in cpp? or can you share your code ?"
                    },
                    {
                        "username": "aman3091",
                        "content": "Can anyone help me to correct my code.\\nclass Solution {\\npublic:\\n    int widthOfBinaryTree(TreeNode* root) {\\n        if(!root){\\n            return 0;\\n        }\\n        int ans=0;\\n        queue<pair<TreeNode*,int>>q;\\n        q.push({root,0});\\n        while(!q.empty()){\\n            int size=q.size();\\n            int mmin=q.front().second;\\n            int first,last;\\n             for(int i=0;i<size;i++){\\n                 int curr_id=q.front().second-mmin;\\n                 TreeNode* node=q.front().first;\\n                 q.pop();\\n                 if(i==0){\\n                     first=curr_id;\\n                 }\\n                 if(i==size-1){\\n                     last=curr_id;\\n                 }\\n                 if(node->left){\\n                     q.push({node->left,curr_id*2+1});\\n                 }\\n                 if(node->right){\\n                     q.push({node->right,curr_id*2+2});\\n                 }\\n             \\n             }\\n                 ans=max(ans,last-first+1);\\n        }\\n        return ans;\\n\\n    }\\n};"
                    },
                    {
                        "username": "ankitmishra2108",
                        "content": "class Solution {\\npublic:\\n    int widthOfBinaryTree(TreeNode* root) {\\n        int ans = 0;\\n        if(root == NULL){\\n            return ans;\\n        }\\n        queue<pair<TreeNode*, long>> q;\\n        q.push({root, 0});\\n\\n        while(!q.empty()){\\n            long size = q.size();\\n            long min = q.front().second;\\n            int first, last;\\n            for(int i = 0; i < size; i++){\\n                TreeNode* node = q.front().first;\\n                long index = q.front().second-min;\\n                q.pop();\\n\\n                if(i == 0){\\n                    first = index;\\n                }\\n                if(i == size-1){\\n                    last = index;\\n                }\\n                if(node->left != NULL){\\n                    q.push({node->left, index*2+1});\\n                }\\n                if(node->right != NULL){\\n                    q.push({node->right, index*2+2});\\n                }\\n            }\\n            ans = max(ans, (last-first)+1);\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1790431,
                "content": [
                    {
                        "username": "19020442",
                        "content": "who can image the final testcase , pless :((?"
                    },
                    {
                        "username": "halfengineer",
                        "content": "Not tle this time getting memory limit exceeded for higher test case\\uD83D\\uDE25"
                    },
                    {
                        "username": "aman3091",
                        "content": "can anyone help me. i am getting error\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int widthOfBinaryTree(TreeNode* root) {\\n        if(root==NULL){\\n            return 0;\\n        }\\n        int ans=0;\\n        queue<pair<TreeNode*,int>>q;\\n        q.push({root,0});\\n        while(!q.empty()){\\n            int size=q.size();\\n            int mmin=q.front().second;\\n            int first,last;\\n            for(int i=0;i<size;i++){\\n                int curr_id=q.front().second-mmin;\\n                auto p=q.front().first;\\n                q.pop();\\n                if(i==0){\\n                    first=curr_id;\\n                }\\n                if(i==size-1){\\n                    last=curr_id;\\n                }\\n                if(p->left!=NULL){\\n                    q.push({p->left,curr_id*2+1});\\n                }\\n                if(p->right!=NULL){\\n                    q.push({p->right,curr_id*2+2});\\n                }\\n            }\\n            ans=max(ans,last-first+1);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Wetooa",
                        "content": "sorry if this might be stupid but is there a way we can get a variable that stores a bigger number than long long? I\\'ve switched from python to c++ and this number limit error has been bugging me the f out. or should I just make code that reduces these big numbers?"
                    },
                    {
                        "username": "AKK_16",
                        "content": "Using recursion and C++\n\nclass Solution {\npublic:\n\n    unordered_map<int , pair<unsigned long long int,unsigned long long int> > mp;\n    void fn(TreeNode* ptr,int l,unsigned long long int i)\n    {\n        if(ptr==nullptr) return;\n        if(mp.count(l)==0)\n        {\n            mp[l].first = i;\n            mp[l].second = i;\n        }\n        else \n        {\n            mp[l].first = max(mp[l].first,i);\n            mp[l].second = min(mp[l].second,i);\n        }\n        \n        if(ptr->left)\n        {\n            fn(ptr->left,l+1,i*2+1);\n        }\n\n        if(ptr->right)\n        {\n            fn(ptr->right,l+1,i*2+2);\n        }\n\n    }\n    int widthOfBinaryTree(TreeNode* root) {\n        if(root==nullptr) return 0;\n        fn(root,0,1);\n        int ans=1;\n        for(auto &i:mp)\n        {\n            int x = i.second.first-i.second.second+1;\n            ans=max(ans,x);\n        }\n\n        return ans;\n    }\n};"
                    },
                    {
                        "username": "galster",
                        "content": "This question has a bug.\\nWhen you try to run any of the C++ solutions using DFS and with the *2, *2 + 1 solution you get an integer overflow. I\\'ve tested multiple C++ solutions posted here and they all seem to have the same issue. For some unexplained reason Java solutions pass it."
                    },
                    {
                        "username": "suf01",
                        "content": "dude this is soo weird, please anyone help me out\n\nso theres this one code which passed all the test cases\n\nint widthOfBinaryTree(TreeNode* root) {\n        long ans = 0;\n        \n        if(root == NULL){\n            return ans;\n        }\n        \n        queue<pair<TreeNode*, long> > q;\n        q.push({root, 0});\n        \n        while(!q.empty()){\n            int n = q.size();\n            \n            long start = q.front().second;\n            long end = q.back().second;\n            \n            ans = max(ans, end-start+1);\n            \n            for(int i = 0; i < n; i++){\n                pair<TreeNode*, int> item = q.front();\n                \n                TreeNode* temp = item.first;\n                long prev_index = item.second;\n                \n                if(temp->left!=NULL) q.push({temp->left, prev_index*2+1});\n                if(temp->right!=NULL) q.push({temp->right, prev_index*2+2});\n                \n                q.pop();\n            }\n        }\n        \n        return ans;\n    }\n\nand then theres this another code which i wrote following the same approach but this time its giving run time error, i checked these two codes for hours and haven't been able to figure out why, its driving me crazy please help me out\n\nint widthOfBinaryTree(TreeNode* root) {\n        long long ans = 0;\n        if(root == NULL){\n            return ans;\n        }\n\n        queue<pair<TreeNode*, long long> > q;\n        q.push({root, 0});\n\n        while(!q.empty()){\n            long long n = q.size();\n\n            long long start = q.front().second;\n            long long end = q.back().second;\n\n            ans = max(ans, end-start+1);\n            for(int i = 0; i < n; i++){\n                TreeNode* temp = q.front().first;\n                long long index = q.front().second;\n                q.pop();\n \n                if(temp->left) q.push({temp->left, 2*index+1});\n                if(temp->right) q.push({temp->right, 2*index+2});\n            }\n        }\n        return ans;\n    }"
                    },
                    {
                        "username": "pxlcode",
                        "content": "Unsigned 32 bit integer works for C++ without overflow"
                    },
                    {
                        "username": "saintmeteo",
                        "content": "hey can you please how can i initialize unsigned 32 bit integer in cpp? or can you share your code ?"
                    },
                    {
                        "username": "aman3091",
                        "content": "Can anyone help me to correct my code.\\nclass Solution {\\npublic:\\n    int widthOfBinaryTree(TreeNode* root) {\\n        if(!root){\\n            return 0;\\n        }\\n        int ans=0;\\n        queue<pair<TreeNode*,int>>q;\\n        q.push({root,0});\\n        while(!q.empty()){\\n            int size=q.size();\\n            int mmin=q.front().second;\\n            int first,last;\\n             for(int i=0;i<size;i++){\\n                 int curr_id=q.front().second-mmin;\\n                 TreeNode* node=q.front().first;\\n                 q.pop();\\n                 if(i==0){\\n                     first=curr_id;\\n                 }\\n                 if(i==size-1){\\n                     last=curr_id;\\n                 }\\n                 if(node->left){\\n                     q.push({node->left,curr_id*2+1});\\n                 }\\n                 if(node->right){\\n                     q.push({node->right,curr_id*2+2});\\n                 }\\n             \\n             }\\n                 ans=max(ans,last-first+1);\\n        }\\n        return ans;\\n\\n    }\\n};"
                    },
                    {
                        "username": "ankitmishra2108",
                        "content": "class Solution {\\npublic:\\n    int widthOfBinaryTree(TreeNode* root) {\\n        int ans = 0;\\n        if(root == NULL){\\n            return ans;\\n        }\\n        queue<pair<TreeNode*, long>> q;\\n        q.push({root, 0});\\n\\n        while(!q.empty()){\\n            long size = q.size();\\n            long min = q.front().second;\\n            int first, last;\\n            for(int i = 0; i < size; i++){\\n                TreeNode* node = q.front().first;\\n                long index = q.front().second-min;\\n                q.pop();\\n\\n                if(i == 0){\\n                    first = index;\\n                }\\n                if(i == size-1){\\n                    last = index;\\n                }\\n                if(node->left != NULL){\\n                    q.push({node->left, index*2+1});\\n                }\\n                if(node->right != NULL){\\n                    q.push({node->right, index*2+2});\\n                }\\n            }\\n            ans = max(ans, (last-first)+1);\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1776122,
                "content": [
                    {
                        "username": "19020442",
                        "content": "who can image the final testcase , pless :((?"
                    },
                    {
                        "username": "halfengineer",
                        "content": "Not tle this time getting memory limit exceeded for higher test case\\uD83D\\uDE25"
                    },
                    {
                        "username": "aman3091",
                        "content": "can anyone help me. i am getting error\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int widthOfBinaryTree(TreeNode* root) {\\n        if(root==NULL){\\n            return 0;\\n        }\\n        int ans=0;\\n        queue<pair<TreeNode*,int>>q;\\n        q.push({root,0});\\n        while(!q.empty()){\\n            int size=q.size();\\n            int mmin=q.front().second;\\n            int first,last;\\n            for(int i=0;i<size;i++){\\n                int curr_id=q.front().second-mmin;\\n                auto p=q.front().first;\\n                q.pop();\\n                if(i==0){\\n                    first=curr_id;\\n                }\\n                if(i==size-1){\\n                    last=curr_id;\\n                }\\n                if(p->left!=NULL){\\n                    q.push({p->left,curr_id*2+1});\\n                }\\n                if(p->right!=NULL){\\n                    q.push({p->right,curr_id*2+2});\\n                }\\n            }\\n            ans=max(ans,last-first+1);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Wetooa",
                        "content": "sorry if this might be stupid but is there a way we can get a variable that stores a bigger number than long long? I\\'ve switched from python to c++ and this number limit error has been bugging me the f out. or should I just make code that reduces these big numbers?"
                    },
                    {
                        "username": "AKK_16",
                        "content": "Using recursion and C++\n\nclass Solution {\npublic:\n\n    unordered_map<int , pair<unsigned long long int,unsigned long long int> > mp;\n    void fn(TreeNode* ptr,int l,unsigned long long int i)\n    {\n        if(ptr==nullptr) return;\n        if(mp.count(l)==0)\n        {\n            mp[l].first = i;\n            mp[l].second = i;\n        }\n        else \n        {\n            mp[l].first = max(mp[l].first,i);\n            mp[l].second = min(mp[l].second,i);\n        }\n        \n        if(ptr->left)\n        {\n            fn(ptr->left,l+1,i*2+1);\n        }\n\n        if(ptr->right)\n        {\n            fn(ptr->right,l+1,i*2+2);\n        }\n\n    }\n    int widthOfBinaryTree(TreeNode* root) {\n        if(root==nullptr) return 0;\n        fn(root,0,1);\n        int ans=1;\n        for(auto &i:mp)\n        {\n            int x = i.second.first-i.second.second+1;\n            ans=max(ans,x);\n        }\n\n        return ans;\n    }\n};"
                    },
                    {
                        "username": "galster",
                        "content": "This question has a bug.\\nWhen you try to run any of the C++ solutions using DFS and with the *2, *2 + 1 solution you get an integer overflow. I\\'ve tested multiple C++ solutions posted here and they all seem to have the same issue. For some unexplained reason Java solutions pass it."
                    },
                    {
                        "username": "suf01",
                        "content": "dude this is soo weird, please anyone help me out\n\nso theres this one code which passed all the test cases\n\nint widthOfBinaryTree(TreeNode* root) {\n        long ans = 0;\n        \n        if(root == NULL){\n            return ans;\n        }\n        \n        queue<pair<TreeNode*, long> > q;\n        q.push({root, 0});\n        \n        while(!q.empty()){\n            int n = q.size();\n            \n            long start = q.front().second;\n            long end = q.back().second;\n            \n            ans = max(ans, end-start+1);\n            \n            for(int i = 0; i < n; i++){\n                pair<TreeNode*, int> item = q.front();\n                \n                TreeNode* temp = item.first;\n                long prev_index = item.second;\n                \n                if(temp->left!=NULL) q.push({temp->left, prev_index*2+1});\n                if(temp->right!=NULL) q.push({temp->right, prev_index*2+2});\n                \n                q.pop();\n            }\n        }\n        \n        return ans;\n    }\n\nand then theres this another code which i wrote following the same approach but this time its giving run time error, i checked these two codes for hours and haven't been able to figure out why, its driving me crazy please help me out\n\nint widthOfBinaryTree(TreeNode* root) {\n        long long ans = 0;\n        if(root == NULL){\n            return ans;\n        }\n\n        queue<pair<TreeNode*, long long> > q;\n        q.push({root, 0});\n\n        while(!q.empty()){\n            long long n = q.size();\n\n            long long start = q.front().second;\n            long long end = q.back().second;\n\n            ans = max(ans, end-start+1);\n            for(int i = 0; i < n; i++){\n                TreeNode* temp = q.front().first;\n                long long index = q.front().second;\n                q.pop();\n \n                if(temp->left) q.push({temp->left, 2*index+1});\n                if(temp->right) q.push({temp->right, 2*index+2});\n            }\n        }\n        return ans;\n    }"
                    },
                    {
                        "username": "pxlcode",
                        "content": "Unsigned 32 bit integer works for C++ without overflow"
                    },
                    {
                        "username": "saintmeteo",
                        "content": "hey can you please how can i initialize unsigned 32 bit integer in cpp? or can you share your code ?"
                    },
                    {
                        "username": "aman3091",
                        "content": "Can anyone help me to correct my code.\\nclass Solution {\\npublic:\\n    int widthOfBinaryTree(TreeNode* root) {\\n        if(!root){\\n            return 0;\\n        }\\n        int ans=0;\\n        queue<pair<TreeNode*,int>>q;\\n        q.push({root,0});\\n        while(!q.empty()){\\n            int size=q.size();\\n            int mmin=q.front().second;\\n            int first,last;\\n             for(int i=0;i<size;i++){\\n                 int curr_id=q.front().second-mmin;\\n                 TreeNode* node=q.front().first;\\n                 q.pop();\\n                 if(i==0){\\n                     first=curr_id;\\n                 }\\n                 if(i==size-1){\\n                     last=curr_id;\\n                 }\\n                 if(node->left){\\n                     q.push({node->left,curr_id*2+1});\\n                 }\\n                 if(node->right){\\n                     q.push({node->right,curr_id*2+2});\\n                 }\\n             \\n             }\\n                 ans=max(ans,last-first+1);\\n        }\\n        return ans;\\n\\n    }\\n};"
                    },
                    {
                        "username": "ankitmishra2108",
                        "content": "class Solution {\\npublic:\\n    int widthOfBinaryTree(TreeNode* root) {\\n        int ans = 0;\\n        if(root == NULL){\\n            return ans;\\n        }\\n        queue<pair<TreeNode*, long>> q;\\n        q.push({root, 0});\\n\\n        while(!q.empty()){\\n            long size = q.size();\\n            long min = q.front().second;\\n            int first, last;\\n            for(int i = 0; i < size; i++){\\n                TreeNode* node = q.front().first;\\n                long index = q.front().second-min;\\n                q.pop();\\n\\n                if(i == 0){\\n                    first = index;\\n                }\\n                if(i == size-1){\\n                    last = index;\\n                }\\n                if(node->left != NULL){\\n                    q.push({node->left, index*2+1});\\n                }\\n                if(node->right != NULL){\\n                    q.push({node->right, index*2+2});\\n                }\\n            }\\n            ans = max(ans, (last-first)+1);\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1717538,
                "content": [
                    {
                        "username": "19020442",
                        "content": "who can image the final testcase , pless :((?"
                    },
                    {
                        "username": "halfengineer",
                        "content": "Not tle this time getting memory limit exceeded for higher test case\\uD83D\\uDE25"
                    },
                    {
                        "username": "aman3091",
                        "content": "can anyone help me. i am getting error\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int widthOfBinaryTree(TreeNode* root) {\\n        if(root==NULL){\\n            return 0;\\n        }\\n        int ans=0;\\n        queue<pair<TreeNode*,int>>q;\\n        q.push({root,0});\\n        while(!q.empty()){\\n            int size=q.size();\\n            int mmin=q.front().second;\\n            int first,last;\\n            for(int i=0;i<size;i++){\\n                int curr_id=q.front().second-mmin;\\n                auto p=q.front().first;\\n                q.pop();\\n                if(i==0){\\n                    first=curr_id;\\n                }\\n                if(i==size-1){\\n                    last=curr_id;\\n                }\\n                if(p->left!=NULL){\\n                    q.push({p->left,curr_id*2+1});\\n                }\\n                if(p->right!=NULL){\\n                    q.push({p->right,curr_id*2+2});\\n                }\\n            }\\n            ans=max(ans,last-first+1);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Wetooa",
                        "content": "sorry if this might be stupid but is there a way we can get a variable that stores a bigger number than long long? I\\'ve switched from python to c++ and this number limit error has been bugging me the f out. or should I just make code that reduces these big numbers?"
                    },
                    {
                        "username": "AKK_16",
                        "content": "Using recursion and C++\n\nclass Solution {\npublic:\n\n    unordered_map<int , pair<unsigned long long int,unsigned long long int> > mp;\n    void fn(TreeNode* ptr,int l,unsigned long long int i)\n    {\n        if(ptr==nullptr) return;\n        if(mp.count(l)==0)\n        {\n            mp[l].first = i;\n            mp[l].second = i;\n        }\n        else \n        {\n            mp[l].first = max(mp[l].first,i);\n            mp[l].second = min(mp[l].second,i);\n        }\n        \n        if(ptr->left)\n        {\n            fn(ptr->left,l+1,i*2+1);\n        }\n\n        if(ptr->right)\n        {\n            fn(ptr->right,l+1,i*2+2);\n        }\n\n    }\n    int widthOfBinaryTree(TreeNode* root) {\n        if(root==nullptr) return 0;\n        fn(root,0,1);\n        int ans=1;\n        for(auto &i:mp)\n        {\n            int x = i.second.first-i.second.second+1;\n            ans=max(ans,x);\n        }\n\n        return ans;\n    }\n};"
                    },
                    {
                        "username": "galster",
                        "content": "This question has a bug.\\nWhen you try to run any of the C++ solutions using DFS and with the *2, *2 + 1 solution you get an integer overflow. I\\'ve tested multiple C++ solutions posted here and they all seem to have the same issue. For some unexplained reason Java solutions pass it."
                    },
                    {
                        "username": "suf01",
                        "content": "dude this is soo weird, please anyone help me out\n\nso theres this one code which passed all the test cases\n\nint widthOfBinaryTree(TreeNode* root) {\n        long ans = 0;\n        \n        if(root == NULL){\n            return ans;\n        }\n        \n        queue<pair<TreeNode*, long> > q;\n        q.push({root, 0});\n        \n        while(!q.empty()){\n            int n = q.size();\n            \n            long start = q.front().second;\n            long end = q.back().second;\n            \n            ans = max(ans, end-start+1);\n            \n            for(int i = 0; i < n; i++){\n                pair<TreeNode*, int> item = q.front();\n                \n                TreeNode* temp = item.first;\n                long prev_index = item.second;\n                \n                if(temp->left!=NULL) q.push({temp->left, prev_index*2+1});\n                if(temp->right!=NULL) q.push({temp->right, prev_index*2+2});\n                \n                q.pop();\n            }\n        }\n        \n        return ans;\n    }\n\nand then theres this another code which i wrote following the same approach but this time its giving run time error, i checked these two codes for hours and haven't been able to figure out why, its driving me crazy please help me out\n\nint widthOfBinaryTree(TreeNode* root) {\n        long long ans = 0;\n        if(root == NULL){\n            return ans;\n        }\n\n        queue<pair<TreeNode*, long long> > q;\n        q.push({root, 0});\n\n        while(!q.empty()){\n            long long n = q.size();\n\n            long long start = q.front().second;\n            long long end = q.back().second;\n\n            ans = max(ans, end-start+1);\n            for(int i = 0; i < n; i++){\n                TreeNode* temp = q.front().first;\n                long long index = q.front().second;\n                q.pop();\n \n                if(temp->left) q.push({temp->left, 2*index+1});\n                if(temp->right) q.push({temp->right, 2*index+2});\n            }\n        }\n        return ans;\n    }"
                    },
                    {
                        "username": "pxlcode",
                        "content": "Unsigned 32 bit integer works for C++ without overflow"
                    },
                    {
                        "username": "saintmeteo",
                        "content": "hey can you please how can i initialize unsigned 32 bit integer in cpp? or can you share your code ?"
                    },
                    {
                        "username": "aman3091",
                        "content": "Can anyone help me to correct my code.\\nclass Solution {\\npublic:\\n    int widthOfBinaryTree(TreeNode* root) {\\n        if(!root){\\n            return 0;\\n        }\\n        int ans=0;\\n        queue<pair<TreeNode*,int>>q;\\n        q.push({root,0});\\n        while(!q.empty()){\\n            int size=q.size();\\n            int mmin=q.front().second;\\n            int first,last;\\n             for(int i=0;i<size;i++){\\n                 int curr_id=q.front().second-mmin;\\n                 TreeNode* node=q.front().first;\\n                 q.pop();\\n                 if(i==0){\\n                     first=curr_id;\\n                 }\\n                 if(i==size-1){\\n                     last=curr_id;\\n                 }\\n                 if(node->left){\\n                     q.push({node->left,curr_id*2+1});\\n                 }\\n                 if(node->right){\\n                     q.push({node->right,curr_id*2+2});\\n                 }\\n             \\n             }\\n                 ans=max(ans,last-first+1);\\n        }\\n        return ans;\\n\\n    }\\n};"
                    },
                    {
                        "username": "ankitmishra2108",
                        "content": "class Solution {\\npublic:\\n    int widthOfBinaryTree(TreeNode* root) {\\n        int ans = 0;\\n        if(root == NULL){\\n            return ans;\\n        }\\n        queue<pair<TreeNode*, long>> q;\\n        q.push({root, 0});\\n\\n        while(!q.empty()){\\n            long size = q.size();\\n            long min = q.front().second;\\n            int first, last;\\n            for(int i = 0; i < size; i++){\\n                TreeNode* node = q.front().first;\\n                long index = q.front().second-min;\\n                q.pop();\\n\\n                if(i == 0){\\n                    first = index;\\n                }\\n                if(i == size-1){\\n                    last = index;\\n                }\\n                if(node->left != NULL){\\n                    q.push({node->left, index*2+1});\\n                }\\n                if(node->right != NULL){\\n                    q.push({node->right, index*2+2});\\n                }\\n            }\\n            ans = max(ans, (last-first)+1);\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1679727,
                "content": [
                    {
                        "username": "19020442",
                        "content": "who can image the final testcase , pless :((?"
                    },
                    {
                        "username": "halfengineer",
                        "content": "Not tle this time getting memory limit exceeded for higher test case\\uD83D\\uDE25"
                    },
                    {
                        "username": "aman3091",
                        "content": "can anyone help me. i am getting error\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int widthOfBinaryTree(TreeNode* root) {\\n        if(root==NULL){\\n            return 0;\\n        }\\n        int ans=0;\\n        queue<pair<TreeNode*,int>>q;\\n        q.push({root,0});\\n        while(!q.empty()){\\n            int size=q.size();\\n            int mmin=q.front().second;\\n            int first,last;\\n            for(int i=0;i<size;i++){\\n                int curr_id=q.front().second-mmin;\\n                auto p=q.front().first;\\n                q.pop();\\n                if(i==0){\\n                    first=curr_id;\\n                }\\n                if(i==size-1){\\n                    last=curr_id;\\n                }\\n                if(p->left!=NULL){\\n                    q.push({p->left,curr_id*2+1});\\n                }\\n                if(p->right!=NULL){\\n                    q.push({p->right,curr_id*2+2});\\n                }\\n            }\\n            ans=max(ans,last-first+1);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Wetooa",
                        "content": "sorry if this might be stupid but is there a way we can get a variable that stores a bigger number than long long? I\\'ve switched from python to c++ and this number limit error has been bugging me the f out. or should I just make code that reduces these big numbers?"
                    },
                    {
                        "username": "AKK_16",
                        "content": "Using recursion and C++\n\nclass Solution {\npublic:\n\n    unordered_map<int , pair<unsigned long long int,unsigned long long int> > mp;\n    void fn(TreeNode* ptr,int l,unsigned long long int i)\n    {\n        if(ptr==nullptr) return;\n        if(mp.count(l)==0)\n        {\n            mp[l].first = i;\n            mp[l].second = i;\n        }\n        else \n        {\n            mp[l].first = max(mp[l].first,i);\n            mp[l].second = min(mp[l].second,i);\n        }\n        \n        if(ptr->left)\n        {\n            fn(ptr->left,l+1,i*2+1);\n        }\n\n        if(ptr->right)\n        {\n            fn(ptr->right,l+1,i*2+2);\n        }\n\n    }\n    int widthOfBinaryTree(TreeNode* root) {\n        if(root==nullptr) return 0;\n        fn(root,0,1);\n        int ans=1;\n        for(auto &i:mp)\n        {\n            int x = i.second.first-i.second.second+1;\n            ans=max(ans,x);\n        }\n\n        return ans;\n    }\n};"
                    },
                    {
                        "username": "galster",
                        "content": "This question has a bug.\\nWhen you try to run any of the C++ solutions using DFS and with the *2, *2 + 1 solution you get an integer overflow. I\\'ve tested multiple C++ solutions posted here and they all seem to have the same issue. For some unexplained reason Java solutions pass it."
                    },
                    {
                        "username": "suf01",
                        "content": "dude this is soo weird, please anyone help me out\n\nso theres this one code which passed all the test cases\n\nint widthOfBinaryTree(TreeNode* root) {\n        long ans = 0;\n        \n        if(root == NULL){\n            return ans;\n        }\n        \n        queue<pair<TreeNode*, long> > q;\n        q.push({root, 0});\n        \n        while(!q.empty()){\n            int n = q.size();\n            \n            long start = q.front().second;\n            long end = q.back().second;\n            \n            ans = max(ans, end-start+1);\n            \n            for(int i = 0; i < n; i++){\n                pair<TreeNode*, int> item = q.front();\n                \n                TreeNode* temp = item.first;\n                long prev_index = item.second;\n                \n                if(temp->left!=NULL) q.push({temp->left, prev_index*2+1});\n                if(temp->right!=NULL) q.push({temp->right, prev_index*2+2});\n                \n                q.pop();\n            }\n        }\n        \n        return ans;\n    }\n\nand then theres this another code which i wrote following the same approach but this time its giving run time error, i checked these two codes for hours and haven't been able to figure out why, its driving me crazy please help me out\n\nint widthOfBinaryTree(TreeNode* root) {\n        long long ans = 0;\n        if(root == NULL){\n            return ans;\n        }\n\n        queue<pair<TreeNode*, long long> > q;\n        q.push({root, 0});\n\n        while(!q.empty()){\n            long long n = q.size();\n\n            long long start = q.front().second;\n            long long end = q.back().second;\n\n            ans = max(ans, end-start+1);\n            for(int i = 0; i < n; i++){\n                TreeNode* temp = q.front().first;\n                long long index = q.front().second;\n                q.pop();\n \n                if(temp->left) q.push({temp->left, 2*index+1});\n                if(temp->right) q.push({temp->right, 2*index+2});\n            }\n        }\n        return ans;\n    }"
                    },
                    {
                        "username": "pxlcode",
                        "content": "Unsigned 32 bit integer works for C++ without overflow"
                    },
                    {
                        "username": "saintmeteo",
                        "content": "hey can you please how can i initialize unsigned 32 bit integer in cpp? or can you share your code ?"
                    },
                    {
                        "username": "aman3091",
                        "content": "Can anyone help me to correct my code.\\nclass Solution {\\npublic:\\n    int widthOfBinaryTree(TreeNode* root) {\\n        if(!root){\\n            return 0;\\n        }\\n        int ans=0;\\n        queue<pair<TreeNode*,int>>q;\\n        q.push({root,0});\\n        while(!q.empty()){\\n            int size=q.size();\\n            int mmin=q.front().second;\\n            int first,last;\\n             for(int i=0;i<size;i++){\\n                 int curr_id=q.front().second-mmin;\\n                 TreeNode* node=q.front().first;\\n                 q.pop();\\n                 if(i==0){\\n                     first=curr_id;\\n                 }\\n                 if(i==size-1){\\n                     last=curr_id;\\n                 }\\n                 if(node->left){\\n                     q.push({node->left,curr_id*2+1});\\n                 }\\n                 if(node->right){\\n                     q.push({node->right,curr_id*2+2});\\n                 }\\n             \\n             }\\n                 ans=max(ans,last-first+1);\\n        }\\n        return ans;\\n\\n    }\\n};"
                    },
                    {
                        "username": "ankitmishra2108",
                        "content": "class Solution {\\npublic:\\n    int widthOfBinaryTree(TreeNode* root) {\\n        int ans = 0;\\n        if(root == NULL){\\n            return ans;\\n        }\\n        queue<pair<TreeNode*, long>> q;\\n        q.push({root, 0});\\n\\n        while(!q.empty()){\\n            long size = q.size();\\n            long min = q.front().second;\\n            int first, last;\\n            for(int i = 0; i < size; i++){\\n                TreeNode* node = q.front().first;\\n                long index = q.front().second-min;\\n                q.pop();\\n\\n                if(i == 0){\\n                    first = index;\\n                }\\n                if(i == size-1){\\n                    last = index;\\n                }\\n                if(node->left != NULL){\\n                    q.push({node->left, index*2+1});\\n                }\\n                if(node->right != NULL){\\n                    q.push({node->right, index*2+2});\\n                }\\n            }\\n            ans = max(ans, (last-first)+1);\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1676052,
                "content": [
                    {
                        "username": "19020442",
                        "content": "who can image the final testcase , pless :((?"
                    },
                    {
                        "username": "halfengineer",
                        "content": "Not tle this time getting memory limit exceeded for higher test case\\uD83D\\uDE25"
                    },
                    {
                        "username": "aman3091",
                        "content": "can anyone help me. i am getting error\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int widthOfBinaryTree(TreeNode* root) {\\n        if(root==NULL){\\n            return 0;\\n        }\\n        int ans=0;\\n        queue<pair<TreeNode*,int>>q;\\n        q.push({root,0});\\n        while(!q.empty()){\\n            int size=q.size();\\n            int mmin=q.front().second;\\n            int first,last;\\n            for(int i=0;i<size;i++){\\n                int curr_id=q.front().second-mmin;\\n                auto p=q.front().first;\\n                q.pop();\\n                if(i==0){\\n                    first=curr_id;\\n                }\\n                if(i==size-1){\\n                    last=curr_id;\\n                }\\n                if(p->left!=NULL){\\n                    q.push({p->left,curr_id*2+1});\\n                }\\n                if(p->right!=NULL){\\n                    q.push({p->right,curr_id*2+2});\\n                }\\n            }\\n            ans=max(ans,last-first+1);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Wetooa",
                        "content": "sorry if this might be stupid but is there a way we can get a variable that stores a bigger number than long long? I\\'ve switched from python to c++ and this number limit error has been bugging me the f out. or should I just make code that reduces these big numbers?"
                    },
                    {
                        "username": "AKK_16",
                        "content": "Using recursion and C++\n\nclass Solution {\npublic:\n\n    unordered_map<int , pair<unsigned long long int,unsigned long long int> > mp;\n    void fn(TreeNode* ptr,int l,unsigned long long int i)\n    {\n        if(ptr==nullptr) return;\n        if(mp.count(l)==0)\n        {\n            mp[l].first = i;\n            mp[l].second = i;\n        }\n        else \n        {\n            mp[l].first = max(mp[l].first,i);\n            mp[l].second = min(mp[l].second,i);\n        }\n        \n        if(ptr->left)\n        {\n            fn(ptr->left,l+1,i*2+1);\n        }\n\n        if(ptr->right)\n        {\n            fn(ptr->right,l+1,i*2+2);\n        }\n\n    }\n    int widthOfBinaryTree(TreeNode* root) {\n        if(root==nullptr) return 0;\n        fn(root,0,1);\n        int ans=1;\n        for(auto &i:mp)\n        {\n            int x = i.second.first-i.second.second+1;\n            ans=max(ans,x);\n        }\n\n        return ans;\n    }\n};"
                    },
                    {
                        "username": "galster",
                        "content": "This question has a bug.\\nWhen you try to run any of the C++ solutions using DFS and with the *2, *2 + 1 solution you get an integer overflow. I\\'ve tested multiple C++ solutions posted here and they all seem to have the same issue. For some unexplained reason Java solutions pass it."
                    },
                    {
                        "username": "suf01",
                        "content": "dude this is soo weird, please anyone help me out\n\nso theres this one code which passed all the test cases\n\nint widthOfBinaryTree(TreeNode* root) {\n        long ans = 0;\n        \n        if(root == NULL){\n            return ans;\n        }\n        \n        queue<pair<TreeNode*, long> > q;\n        q.push({root, 0});\n        \n        while(!q.empty()){\n            int n = q.size();\n            \n            long start = q.front().second;\n            long end = q.back().second;\n            \n            ans = max(ans, end-start+1);\n            \n            for(int i = 0; i < n; i++){\n                pair<TreeNode*, int> item = q.front();\n                \n                TreeNode* temp = item.first;\n                long prev_index = item.second;\n                \n                if(temp->left!=NULL) q.push({temp->left, prev_index*2+1});\n                if(temp->right!=NULL) q.push({temp->right, prev_index*2+2});\n                \n                q.pop();\n            }\n        }\n        \n        return ans;\n    }\n\nand then theres this another code which i wrote following the same approach but this time its giving run time error, i checked these two codes for hours and haven't been able to figure out why, its driving me crazy please help me out\n\nint widthOfBinaryTree(TreeNode* root) {\n        long long ans = 0;\n        if(root == NULL){\n            return ans;\n        }\n\n        queue<pair<TreeNode*, long long> > q;\n        q.push({root, 0});\n\n        while(!q.empty()){\n            long long n = q.size();\n\n            long long start = q.front().second;\n            long long end = q.back().second;\n\n            ans = max(ans, end-start+1);\n            for(int i = 0; i < n; i++){\n                TreeNode* temp = q.front().first;\n                long long index = q.front().second;\n                q.pop();\n \n                if(temp->left) q.push({temp->left, 2*index+1});\n                if(temp->right) q.push({temp->right, 2*index+2});\n            }\n        }\n        return ans;\n    }"
                    },
                    {
                        "username": "pxlcode",
                        "content": "Unsigned 32 bit integer works for C++ without overflow"
                    },
                    {
                        "username": "saintmeteo",
                        "content": "hey can you please how can i initialize unsigned 32 bit integer in cpp? or can you share your code ?"
                    },
                    {
                        "username": "aman3091",
                        "content": "Can anyone help me to correct my code.\\nclass Solution {\\npublic:\\n    int widthOfBinaryTree(TreeNode* root) {\\n        if(!root){\\n            return 0;\\n        }\\n        int ans=0;\\n        queue<pair<TreeNode*,int>>q;\\n        q.push({root,0});\\n        while(!q.empty()){\\n            int size=q.size();\\n            int mmin=q.front().second;\\n            int first,last;\\n             for(int i=0;i<size;i++){\\n                 int curr_id=q.front().second-mmin;\\n                 TreeNode* node=q.front().first;\\n                 q.pop();\\n                 if(i==0){\\n                     first=curr_id;\\n                 }\\n                 if(i==size-1){\\n                     last=curr_id;\\n                 }\\n                 if(node->left){\\n                     q.push({node->left,curr_id*2+1});\\n                 }\\n                 if(node->right){\\n                     q.push({node->right,curr_id*2+2});\\n                 }\\n             \\n             }\\n                 ans=max(ans,last-first+1);\\n        }\\n        return ans;\\n\\n    }\\n};"
                    },
                    {
                        "username": "ankitmishra2108",
                        "content": "class Solution {\\npublic:\\n    int widthOfBinaryTree(TreeNode* root) {\\n        int ans = 0;\\n        if(root == NULL){\\n            return ans;\\n        }\\n        queue<pair<TreeNode*, long>> q;\\n        q.push({root, 0});\\n\\n        while(!q.empty()){\\n            long size = q.size();\\n            long min = q.front().second;\\n            int first, last;\\n            for(int i = 0; i < size; i++){\\n                TreeNode* node = q.front().first;\\n                long index = q.front().second-min;\\n                q.pop();\\n\\n                if(i == 0){\\n                    first = index;\\n                }\\n                if(i == size-1){\\n                    last = index;\\n                }\\n                if(node->left != NULL){\\n                    q.push({node->left, index*2+1});\\n                }\\n                if(node->right != NULL){\\n                    q.push({node->right, index*2+2});\\n                }\\n            }\\n            ans = max(ans, (last-first)+1);\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1645263,
                "content": [
                    {
                        "username": "19020442",
                        "content": "who can image the final testcase , pless :((?"
                    },
                    {
                        "username": "halfengineer",
                        "content": "Not tle this time getting memory limit exceeded for higher test case\\uD83D\\uDE25"
                    },
                    {
                        "username": "aman3091",
                        "content": "can anyone help me. i am getting error\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int widthOfBinaryTree(TreeNode* root) {\\n        if(root==NULL){\\n            return 0;\\n        }\\n        int ans=0;\\n        queue<pair<TreeNode*,int>>q;\\n        q.push({root,0});\\n        while(!q.empty()){\\n            int size=q.size();\\n            int mmin=q.front().second;\\n            int first,last;\\n            for(int i=0;i<size;i++){\\n                int curr_id=q.front().second-mmin;\\n                auto p=q.front().first;\\n                q.pop();\\n                if(i==0){\\n                    first=curr_id;\\n                }\\n                if(i==size-1){\\n                    last=curr_id;\\n                }\\n                if(p->left!=NULL){\\n                    q.push({p->left,curr_id*2+1});\\n                }\\n                if(p->right!=NULL){\\n                    q.push({p->right,curr_id*2+2});\\n                }\\n            }\\n            ans=max(ans,last-first+1);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Wetooa",
                        "content": "sorry if this might be stupid but is there a way we can get a variable that stores a bigger number than long long? I\\'ve switched from python to c++ and this number limit error has been bugging me the f out. or should I just make code that reduces these big numbers?"
                    },
                    {
                        "username": "AKK_16",
                        "content": "Using recursion and C++\n\nclass Solution {\npublic:\n\n    unordered_map<int , pair<unsigned long long int,unsigned long long int> > mp;\n    void fn(TreeNode* ptr,int l,unsigned long long int i)\n    {\n        if(ptr==nullptr) return;\n        if(mp.count(l)==0)\n        {\n            mp[l].first = i;\n            mp[l].second = i;\n        }\n        else \n        {\n            mp[l].first = max(mp[l].first,i);\n            mp[l].second = min(mp[l].second,i);\n        }\n        \n        if(ptr->left)\n        {\n            fn(ptr->left,l+1,i*2+1);\n        }\n\n        if(ptr->right)\n        {\n            fn(ptr->right,l+1,i*2+2);\n        }\n\n    }\n    int widthOfBinaryTree(TreeNode* root) {\n        if(root==nullptr) return 0;\n        fn(root,0,1);\n        int ans=1;\n        for(auto &i:mp)\n        {\n            int x = i.second.first-i.second.second+1;\n            ans=max(ans,x);\n        }\n\n        return ans;\n    }\n};"
                    },
                    {
                        "username": "galster",
                        "content": "This question has a bug.\\nWhen you try to run any of the C++ solutions using DFS and with the *2, *2 + 1 solution you get an integer overflow. I\\'ve tested multiple C++ solutions posted here and they all seem to have the same issue. For some unexplained reason Java solutions pass it."
                    },
                    {
                        "username": "suf01",
                        "content": "dude this is soo weird, please anyone help me out\n\nso theres this one code which passed all the test cases\n\nint widthOfBinaryTree(TreeNode* root) {\n        long ans = 0;\n        \n        if(root == NULL){\n            return ans;\n        }\n        \n        queue<pair<TreeNode*, long> > q;\n        q.push({root, 0});\n        \n        while(!q.empty()){\n            int n = q.size();\n            \n            long start = q.front().second;\n            long end = q.back().second;\n            \n            ans = max(ans, end-start+1);\n            \n            for(int i = 0; i < n; i++){\n                pair<TreeNode*, int> item = q.front();\n                \n                TreeNode* temp = item.first;\n                long prev_index = item.second;\n                \n                if(temp->left!=NULL) q.push({temp->left, prev_index*2+1});\n                if(temp->right!=NULL) q.push({temp->right, prev_index*2+2});\n                \n                q.pop();\n            }\n        }\n        \n        return ans;\n    }\n\nand then theres this another code which i wrote following the same approach but this time its giving run time error, i checked these two codes for hours and haven't been able to figure out why, its driving me crazy please help me out\n\nint widthOfBinaryTree(TreeNode* root) {\n        long long ans = 0;\n        if(root == NULL){\n            return ans;\n        }\n\n        queue<pair<TreeNode*, long long> > q;\n        q.push({root, 0});\n\n        while(!q.empty()){\n            long long n = q.size();\n\n            long long start = q.front().second;\n            long long end = q.back().second;\n\n            ans = max(ans, end-start+1);\n            for(int i = 0; i < n; i++){\n                TreeNode* temp = q.front().first;\n                long long index = q.front().second;\n                q.pop();\n \n                if(temp->left) q.push({temp->left, 2*index+1});\n                if(temp->right) q.push({temp->right, 2*index+2});\n            }\n        }\n        return ans;\n    }"
                    },
                    {
                        "username": "pxlcode",
                        "content": "Unsigned 32 bit integer works for C++ without overflow"
                    },
                    {
                        "username": "saintmeteo",
                        "content": "hey can you please how can i initialize unsigned 32 bit integer in cpp? or can you share your code ?"
                    },
                    {
                        "username": "aman3091",
                        "content": "Can anyone help me to correct my code.\\nclass Solution {\\npublic:\\n    int widthOfBinaryTree(TreeNode* root) {\\n        if(!root){\\n            return 0;\\n        }\\n        int ans=0;\\n        queue<pair<TreeNode*,int>>q;\\n        q.push({root,0});\\n        while(!q.empty()){\\n            int size=q.size();\\n            int mmin=q.front().second;\\n            int first,last;\\n             for(int i=0;i<size;i++){\\n                 int curr_id=q.front().second-mmin;\\n                 TreeNode* node=q.front().first;\\n                 q.pop();\\n                 if(i==0){\\n                     first=curr_id;\\n                 }\\n                 if(i==size-1){\\n                     last=curr_id;\\n                 }\\n                 if(node->left){\\n                     q.push({node->left,curr_id*2+1});\\n                 }\\n                 if(node->right){\\n                     q.push({node->right,curr_id*2+2});\\n                 }\\n             \\n             }\\n                 ans=max(ans,last-first+1);\\n        }\\n        return ans;\\n\\n    }\\n};"
                    },
                    {
                        "username": "ankitmishra2108",
                        "content": "class Solution {\\npublic:\\n    int widthOfBinaryTree(TreeNode* root) {\\n        int ans = 0;\\n        if(root == NULL){\\n            return ans;\\n        }\\n        queue<pair<TreeNode*, long>> q;\\n        q.push({root, 0});\\n\\n        while(!q.empty()){\\n            long size = q.size();\\n            long min = q.front().second;\\n            int first, last;\\n            for(int i = 0; i < size; i++){\\n                TreeNode* node = q.front().first;\\n                long index = q.front().second-min;\\n                q.pop();\\n\\n                if(i == 0){\\n                    first = index;\\n                }\\n                if(i == size-1){\\n                    last = index;\\n                }\\n                if(node->left != NULL){\\n                    q.push({node->left, index*2+1});\\n                }\\n                if(node->right != NULL){\\n                    q.push({node->right, index*2+2});\\n                }\\n            }\\n            ans = max(ans, (last-first)+1);\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            }
        ]
    }
]