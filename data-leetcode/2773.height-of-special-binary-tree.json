[
    {
        "title": "Apply Operations to Make All Array Elements Equal to Zero",
        "question_content": "You are given a 0-indexed integer array nums and a positive integer k.\nYou can apply the following operation on the array any number of times:\n\n\tChoose any subarray of size k from the array and decrease all its elements by 1.\n\nReturn true if you can make all the array elements equal to 0, or false otherwise.\nA subarray is a contiguous non-empty part of an array.\n&nbsp;\nExample 1:\n\nInput: nums = [2,2,3,1,1,0], k = 3\nOutput: true\nExplanation: We can do the following operations:\n- Choose the subarray [2,2,3]. The resulting array will be nums = [1,1,2,1,1,0].\n- Choose the subarray [2,1,1]. The resulting array will be nums = [1,1,1,0,0,0].\n- Choose the subarray [1,1,1]. The resulting array will be nums = [0,0,0,0,0,0].\n\nExample 2:\n\nInput: nums = [1,3,1,1], k = 2\nOutput: false\nExplanation: It is not possible to make all the array elements equal to 0.\n\n&nbsp;\nConstraints:\n\n\t1 <= k <= nums.length <= 105\n\t0 <= nums[i] <= 106",
        "solutions": [
            {
                "id": 3739101,
                "title": "java-c-python-greedy-sliding-window",
                "content": "# **Intuition**\\nFor the first `A[i] > 0`,\\nwe need to select the array `A[i],A[i+1]..A[i+k-1]`\\nand decrease all these elements by `A[i]`.\\n<br>\\n\\n# **Explanation**\\nThe subarray deleted starting at `A[i]`,\\nwill affect the `A[i+1], A[i+2], ...A[i+k-1]`.\\n\\nSo we can use `cur` to record the sum of previous `k - 1` elements,\\nwhere `cur = A[i - 1] + A[i - 2] + A[i - k + 1]`.\\n\\nSo there is a sense of sliding window here,\\nwith window size of `k`.\\n\\nNow to solve this problem,\\nwe iterate `A[i]`,\\nand compare `A[i]` with `cur`.\\n\\n\\nIf `cur > A[i]`,\\nit means A[i] will be over-decreased to negative,\\nreturn `false`.\\nFor example,\\n`A = [2,1]` and `k = 2` will return `false`.\\n\\nIf `cur <= A[i]`,\\n`A[i]` will be decresed `cur` times,\\nso `A[i] -= cur`,\\nthen still need to decrese `A[i]` times,\\nso `cur += A[i]`.\\n\\nWe continue doing this for all `A[i]`,\\nand finally we check if `cur == 0`.\\nFor example,\\n`A = [0,0,1]` and `k = 2` will return `false`.\\n<br>\\n\\n# **Complexity**\\nTime `O(n)`\\nSpace `O(1)`, needs `O(k)` if not change the input `A`\\n<br>\\n\\n**Java**\\n```java\\n    public boolean checkArray(int[] A, int k) {\\n        int cur = 0, n = A.length;\\n        for (int i = 0; i < n; ++i) {\\n            if (cur > A[i])\\n                return false;\\n            A[i] -= cur;\\n            cur += A[i];\\n            if (i >= k - 1)\\n                cur -= A[i - k + 1];\\n        }\\n        return cur == 0;\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    bool checkArray(vector<int>& A, int k) {\\n        int cur = 0, n = A.size();\\n        for (int i = 0; i < n; ++i) {\\n            if (cur > A[i])\\n                return false;\\n            A[i] -= cur;\\n            cur += A[i];\\n            if (i >= k - 1)\\n                cur -= A[i - k + 1];\\n        }\\n        return cur == 0;\\n    }\\n```\\n\\n**Python**\\n```py\\n    def checkArray(self, A: List[int], k: int) -> bool:\\n        cur = 0\\n        for i, a in enumerate(A):\\n            if cur > a:\\n                return False\\n            A[i], cur = a - cur, a\\n            if i >= k - 1:\\n                cur -= A[i - k + 1]\\n        return cur == 0\\n```\\n<br>\\n\\n\\n# More Similar Sliding Window Problems\\nHere are some similar sliding window problems.\\nAlso find more explanations and discussion.\\nGood luck and have fun.\\n\\n- 2730. [Find the Longest Semi-Repetitive Substring](https://leetcode.com/problems/find-the-longest-semi-repetitive-substring/discuss/3629621/JavaC%2B%2BPython-Sliding-Window)\\n- 2555. [Maximize Win From Two Segments](https://leetcode.com/problems/maximize-win-from-two-segments/discuss/3141449/JavaC%2B%2BPython-DP-%2B-Sliding-Segment-O(n))\\n- 2537. [Count the Number of Good Subarrays](https://leetcode.com/problems/count-the-number-of-good-subarrays/discuss/3052559/C%2B%2BPython-Sliding-Window)\\n- 2401. [Longest Nice Subarray](https://leetcode.com/problems/longest-nice-subarray/discuss/2527496/Python-Sliding-Window)\\n- 2398. [Maximum Number of Robots Within Budget](https://leetcode.com/problems/maximum-number-of-robots-within-budget/discuss/2524838/Python-Sliding-Window-O(n))\\n- 1838. [Frequency of the Most Frequent Element](https://leetcode.com/problems/frequency-of-the-most-frequent-element/discuss/1175090/JavaC%2B%2BPython-Sliding-Window)\\n- 1493. [Longest Subarray of 1\\'s After Deleting One Element](https://leetcode.com/problems/longest-subarray-of-1s-after-deleting-one-element/discuss/708112/JavaC%2B%2BPython-Sliding-Window-at-most-one-0)\\n- 1425. [Constrained Subsequence Sum](https://leetcode.com/problems/constrained-subsequence-sum/discuss/597751/JavaC++Python-O(N)-Decreasing-Deque)\\n- 1358. [Number of Substrings Containing All Three Characters](https://leetcode.com/problems/number-of-substrings-containing-all-three-characters/discuss/516977/JavaC++Python-Easy-and-Concise)\\n- 1248. [Count Number of Nice Subarrays](https://leetcode.com/problems/count-number-of-nice-subarrays/discuss/419378/JavaC%2B%2BPython-Sliding-Window-atMost(K)-atMost(K-1))\\n- 1234. [Replace the Substring for Balanced String](https://leetcode.com/problems/replace-the-substring-for-balanced-string/discuss/408978/javacpython-sliding-window/)\\n- 1004. [Max Consecutive Ones III](https://leetcode.com/problems/max-consecutive-ones-iii/discuss/247564/JavaC%2B%2BPython-Sliding-Window)\\n-  930. [Binary Subarrays With Sum](https://leetcode.com/problems/binary-subarrays-with-sum/discuss/186683/)\\n-  992. [Subarrays with K Different Integers](https://leetcode.com/problems/subarrays-with-k-different-integers/discuss/523136/JavaC%2B%2BPython-Sliding-Window)\\n-  904. [Fruit Into Baskets](https://leetcode.com/problems/fruit-into-baskets/discuss/170740/Sliding-Window-for-K-Elements)\\n-  862. [Shortest Subarray with Sum at Least K](https://leetcode.com/problems/shortest-subarray-with-sum-at-least-k/discuss/143726/C%2B%2BJavaPython-O(N)-Using-Deque)\\n-  209. [Minimum Size Subarray Sum](https://leetcode.com/problems/minimum-size-subarray-sum/discuss/433123/JavaC++Python-Sliding-Window)\\n<br>\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    public boolean checkArray(int[] A, int k) {\\n        int cur = 0, n = A.length;\\n        for (int i = 0; i < n; ++i) {\\n            if (cur > A[i])\\n                return false;\\n            A[i] -= cur;\\n            cur += A[i];\\n            if (i >= k - 1)\\n                cur -= A[i - k + 1];\\n        }\\n        return cur == 0;\\n    }\\n```\n```cpp\\n    bool checkArray(vector<int>& A, int k) {\\n        int cur = 0, n = A.size();\\n        for (int i = 0; i < n; ++i) {\\n            if (cur > A[i])\\n                return false;\\n            A[i] -= cur;\\n            cur += A[i];\\n            if (i >= k - 1)\\n                cur -= A[i - k + 1];\\n        }\\n        return cur == 0;\\n    }\\n```\n```py\\n    def checkArray(self, A: List[int], k: int) -> bool:\\n        cur = 0\\n        for i, a in enumerate(A):\\n            if cur > a:\\n                return False\\n            A[i], cur = a - cur, a\\n            if i >= k - 1:\\n                cur -= A[i - k + 1]\\n        return cur == 0\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3738988,
                "title": "1-1-trick-c-python-javascript-and-extra-segment-tree-bit-solution",
                "content": "# Approach\\nLet\\'s look for the first non-zero value from left to right, let\\'s call the index $i$, since it is the first one if we use a window starting at a lower index than $i$ we will affect some zero values and transform them into negative which is not valid, and a window starting greater than $i$ cannot help either since they left $nums[i] \\\\neq 0$ so the only option is to apply exactly $nums[i]$ operations with a window starting at $i$, however when we apply these operations we will also affect the indices in the range $[i,(i+k)-1]$ so we need to update efficiently. \\n\\nAfter the updates we move to the next non-zero element and repeat the algorithm, checking for negative values. \\n\\nHow to do this efficiently? For advanced users perhaps a segment tree may come to mind, but we can apply the +1,-1 trick. \\n\\nThe trick is to take an array of prefix sums, in which we can apply updates in ranges, let\\'s see an example to understand it well. \\n\\n$prefix = [0,0,0,0,0,0,0,0,0,0]$\\n\\n\\nfirst we start with an array of prefixes for each index in zeros,for a range update for example $l = 1,r = 4$ we will update the prefix array with $prefix[l]++$ and $prefix[r+1]--$ in our example the array would look like this.\\n$prefix = [0,1,0,0,0,0,-1,0]$ \\n\\nBut how is this useful?, once we do all the updates (it is necessary to have all the updates before the queries) if we get the prefix sums for each index we can know for each one how much it increased/decreased taking into account all the updates that affected that index, leaving the example as follows. \\n$prefix\\\\_sum = [0,1,1,1,1,1,0,0]$ \\n\\nWe can see that the prefix sums perfectly describe the update $l = 1,r = 4$.\\n\\nNow for our problem we can apply as we go along, note that we iterate from left to right and apply some update starting exactly at $i$ and affect only later elements so all possible updates affecting the index $i$ already happened so as we go along doing the checks we can know how much the previous updates modified the current element.\\n\\n# Complexity\\n- Time complexity:\\n$O(n)$\\n\\n```c++ []\\nclass Solution {\\npublic:\\n    bool checkArray(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        \\n        vector<long long> pref(n+1,0);\\n        long long ac = 0;\\n        \\n        for(int i = 0;i<n;i++){\\n            ac-=pref[i];\\n            nums[i]-=ac;\\n            \\n            if(nums[i]<0) return false;\\n            if(i+k<=n){   \\n                ac+=nums[i];\\n                pref[i+k]+=nums[i];\\n                nums[i] = 0;\\n            }\\n            else if(nums[i]>0)return false;\\n        }\\n        return true;\\n    }\\n};\\n```\\n\\n```javascript []\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {boolean}\\n */\\nvar checkArray = function(nums, k) {\\n    let n = nums.length\\n    let pref = Array(n+1).fill(0)\\n    let ac = 0\\n    for(let [i, val] of nums.entries()){\\n        ac-=pref[i]\\n        val-=ac\\n        console.log(val,i)\\n\\n        if(val<0)return false\\n        if(i+k<=n){\\n            ac+=val\\n            pref[i+k]+=val\\n            val = 0\\n        }\\n        else if(val>0)return false\\n    }\\n\\n    return true\\n};\\n```\\n```python []\\nclass Solution:\\n    def checkArray(self, nums: List[int], k: int) -> bool:\\n        n = len(nums)\\n        pref = [0]*(n+1)\\n        ac = 0\\n        for i in range(0,n):\\n            ac-=pref[i]\\n            nums[i]-=ac\\n\\n            if nums[i]<0:\\n                return False\\n            if i+k<=n:\\n                ac+=nums[i]\\n                pref[i+k]+=nums[i]\\n                nums[i] = 0\\n            elif nums[i]>0:\\n                return False\\n\\n        return True\\n            \\n```\\nExtra solution using segment tree for the updates in range\\n$O(nlog(n))$\\n# Code\\n```c++\\n  class Solution {\\npublic:\\n    vector<long long> st,lazy;\\n    int n;\\n    void propagate(int v,int l,int r){\\n        if(lazy[v]==0)return ;\\n        st[v] += ((r-l)+1)*lazy[v];\\n\\n        if(l!=r){\\n            lazy[v<<1]+=lazy[v];\\n            lazy[v<<1|1]+=lazy[v];\\n        }\\n        lazy[v] = 0;\\n    }\\n\\n    void update(int l,int r,int val,int v ,int sl,int sr){\\n        propagate(v,sl,sr);\\n        if(sl>r || sr<l)return ;\\n        if(sl>=l && sr<=r){\\n            lazy[v]+=val;\\n            propagate(v,sl,sr);\\n            return ;\\n        }\\n        int m = (sl+sr)>>1;\\n        update(l,r,val,v<<1,sl,m);\\n        update(l,r,val,v<<1|1,m+1,sr);\\n    }\\n\\n    long long query(int l,int r,int v,int sl,int sr ){\\n        propagate(v,sl,sr);\\n        if(sl>r || sr<l)return 0;\\n        if(sl>=l && sr<=r)return st[v];\\n\\n        int m = (sl+sr)>>1;\\n        return query(l,r,v<<1,sl,m)+query(l,r,v<<1|1,m+1,sr);\\n    }\\n\\n    void update(int l,int r,int val){\\n        update(l,r,val,1,0,n-1);\\n    }\\n\\n    long long query(int l,int r){\\n        return query(l,r,1,0,n-1);\\n    }\\n\\n    bool checkArray(vector<int>& nums, int k) {\\n        n=nums.size();\\n        st.resize(4*n);\\n        lazy.resize(4*n);\\n        \\n        for(int i = 0;i<n;i++)update(i,i,nums[i]);\\n\\n        for(int i=0;i<n;i++){\\n            int x = query(i,i);\\n            if(x>0 && i+k<=n)\\n                update(i,(i+k)-1,-x);            \\n            if(query(i,i)!=0) return false;\\n        }\\n        return true;\\n    }\\n};\\n```\\n# Fenwick tree / BIT solution\\nAnd finally a solution with fenwick tree also called Binary Index Tree, this solution is interesting because the BIT is much easier to code, but the most important thing is that it also uses the trik +1/-1 \\uD83E\\uDD2F. \\n\\nDepending on where you learn the BIT structure you may not know that the fenwick tree can also deal with updates in ranges and not with a complex lazy propagation like the segment tree, in fact if you understand the structure well you can see the BIT as a prefix sum on steroids, basically it is a clever way to build ranges based on the binary representation of some index in such a way that those ranges help you to get the prefix sum up to an index, evidently with the ability to update when desired.\\n\\nSo since the BIT updates a particular values based on a particular index, at first the update in range is not possible ***(since the combination of the ranges needed for all the indexes in the range cannot be achieved in logarithmic time, so it will degenerate into an O(n) update in the worst case using the basic update)***, but since with that structure you can also get the prefix sums you can apply the trick and be able to update a range but sacrificing the query in range just make $update(l,val)$ and $update(r+1,-val)$.\\n\\nWhy if you want to have updates in ranges you can not get the query in range? ***(actually it is possible but I never learned it as it doesn\\'t seem very useful, in that case I better use a segment tree)*** this is because the information in the indexes by itself no longer represents the prefix sums but represents a kind of accumulated change for each prefix. in a common BIT to get the query in range you have something like $query(r)-query(l-1)$ ,you subtract the prefix that you don\\'t need, but when you use the update in range the information is not what we think, now we have some information from the end of the ranges that we need to subtract so you need the full prefix information to get the correct value, therefore if you subtract some prefix you will have incomplete information (like we do in the query in range) and the result will be wrong.\\n\\nAlthough I will not explain in depth the BIT or the segment tree, I hope it will be useful or that you will learn something new, maybe in another problem I will write more in depth about these structures \\uD83D\\uDE09.\\n\\n```c++\\nclass Solution {\\npublic:\\n    \\n    vector<int> bit;\\n    void add(int idx,int val){\\n        for(++idx;idx<bit.size();idx+= idx&-idx)bit[idx]+=val;\\n    }\\n\\n    void add(int l,int r,int val){\\n        add(l,val);\\n        add(r+1,-val);\\n    }\\n\\n    int sum(int idx){\\n        int res = 0;\\n        for(++idx;idx>0;idx-=idx&-idx)res+=bit[idx];\\n        return res;\\n    }\\n\\n    bool checkArray(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        bit.resize(n+1);\\n        \\n        for(int i = 0;i<n;i++)add(i,i,nums[i]);\\n\\n        for(int i=0;i<n;i++){\\n            int x = sum(i);\\n            if(x>0 && i+k<=n)\\n                add(i,(i+k)-1,-x);            \\n            if(sum(i)!=0) return false;\\n        }\\n        return true;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Python3",
                    "JavaScript",
                    "Binary Indexed Tree",
                    "Segment Tree"
                ],
                "code": "```c++ []\\nclass Solution {\\npublic:\\n    bool checkArray(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        \\n        vector<long long> pref(n+1,0);\\n        long long ac = 0;\\n        \\n        for(int i = 0;i<n;i++){\\n            ac-=pref[i];\\n            nums[i]-=ac;\\n            \\n            if(nums[i]<0) return false;\\n            if(i+k<=n){   \\n                ac+=nums[i];\\n                pref[i+k]+=nums[i];\\n                nums[i] = 0;\\n            }\\n            else if(nums[i]>0)return false;\\n        }\\n        return true;\\n    }\\n};\\n```\n```javascript []\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {boolean}\\n */\\nvar checkArray = function(nums, k) {\\n    let n = nums.length\\n    let pref = Array(n+1).fill(0)\\n    let ac = 0\\n    for(let [i, val] of nums.entries()){\\n        ac-=pref[i]\\n        val-=ac\\n        console.log(val,i)\\n\\n        if(val<0)return false\\n        if(i+k<=n){\\n            ac+=val\\n            pref[i+k]+=val\\n            val = 0\\n        }\\n        else if(val>0)return false\\n    }\\n\\n    return true\\n};\\n```\n```python []\\nclass Solution:\\n    def checkArray(self, nums: List[int], k: int) -> bool:\\n        n = len(nums)\\n        pref = [0]*(n+1)\\n        ac = 0\\n        for i in range(0,n):\\n            ac-=pref[i]\\n            nums[i]-=ac\\n\\n            if nums[i]<0:\\n                return False\\n            if i+k<=n:\\n                ac+=nums[i]\\n                pref[i+k]+=nums[i]\\n                nums[i] = 0\\n            elif nums[i]>0:\\n                return False\\n\\n        return True\\n            \\n```\n```c++\\n  class Solution {\\npublic:\\n    vector<long long> st,lazy;\\n    int n;\\n    void propagate(int v,int l,int r){\\n        if(lazy[v]==0)return ;\\n        st[v] += ((r-l)+1)*lazy[v];\\n\\n        if(l!=r){\\n            lazy[v<<1]+=lazy[v];\\n            lazy[v<<1|1]+=lazy[v];\\n        }\\n        lazy[v] = 0;\\n    }\\n\\n    void update(int l,int r,int val,int v ,int sl,int sr){\\n        propagate(v,sl,sr);\\n        if(sl>r || sr<l)return ;\\n        if(sl>=l && sr<=r){\\n            lazy[v]+=val;\\n            propagate(v,sl,sr);\\n            return ;\\n        }\\n        int m = (sl+sr)>>1;\\n        update(l,r,val,v<<1,sl,m);\\n        update(l,r,val,v<<1|1,m+1,sr);\\n    }\\n\\n    long long query(int l,int r,int v,int sl,int sr ){\\n        propagate(v,sl,sr);\\n        if(sl>r || sr<l)return 0;\\n        if(sl>=l && sr<=r)return st[v];\\n\\n        int m = (sl+sr)>>1;\\n        return query(l,r,v<<1,sl,m)+query(l,r,v<<1|1,m+1,sr);\\n    }\\n\\n    void update(int l,int r,int val){\\n        update(l,r,val,1,0,n-1);\\n    }\\n\\n    long long query(int l,int r){\\n        return query(l,r,1,0,n-1);\\n    }\\n\\n    bool checkArray(vector<int>& nums, int k) {\\n        n=nums.size();\\n        st.resize(4*n);\\n        lazy.resize(4*n);\\n        \\n        for(int i = 0;i<n;i++)update(i,i,nums[i]);\\n\\n        for(int i=0;i<n;i++){\\n            int x = query(i,i);\\n            if(x>0 && i+k<=n)\\n                update(i,(i+k)-1,-x);            \\n            if(query(i,i)!=0) return false;\\n        }\\n        return true;\\n    }\\n};\\n```\n```c++\\nclass Solution {\\npublic:\\n    \\n    vector<int> bit;\\n    void add(int idx,int val){\\n        for(++idx;idx<bit.size();idx+= idx&-idx)bit[idx]+=val;\\n    }\\n\\n    void add(int l,int r,int val){\\n        add(l,val);\\n        add(r+1,-val);\\n    }\\n\\n    int sum(int idx){\\n        int res = 0;\\n        for(++idx;idx>0;idx-=idx&-idx)res+=bit[idx];\\n        return res;\\n    }\\n\\n    bool checkArray(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        bit.resize(n+1);\\n        \\n        for(int i = 0;i<n;i++)add(i,i,nums[i]);\\n\\n        for(int i=0;i<n;i++){\\n            int x = sum(i);\\n            if(x>0 && i+k<=n)\\n                add(i,(i+k)-1,-x);            \\n            if(sum(i)!=0) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3738970,
                "title": "c-simple-solution-range-prefix-sum",
                "content": "# Approach : Range Prefix Sum\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkArray(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        if(n==1) return true;\\n        \\n        vector<int> temp(n,0);\\n        int i=0;\\n        temp[i]=nums[i];\\n        if(k<n) temp[k]=-nums[i];\\n\\n        // i will be 1 even if first condition is false\\n        for(i=1;i<n-k+1;i++) { \\n            temp[i]+=temp[i-1];\\n            \\n            if(temp[i]>nums[i]) return false;\\n\\n            int x = nums[i]-temp[i];\\n            temp[i]+=x;\\n            if(i+k<n) temp[i+k]-=x;\\n            else { i++; break; } // Last Window\\n        }\\n        // Checking if Last Window element is equals to our temp array element or not\\n        while(i<n) {\\n            temp[i]+=temp[i-1];\\n            if(temp[i]!=nums[i]) return false;\\n            i++;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkArray(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        if(n==1) return true;\\n        \\n        vector<int> temp(n,0);\\n        int i=0;\\n        temp[i]=nums[i];\\n        if(k<n) temp[k]=-nums[i];\\n\\n        // i will be 1 even if first condition is false\\n        for(i=1;i<n-k+1;i++) { \\n            temp[i]+=temp[i-1];\\n            \\n            if(temp[i]>nums[i]) return false;\\n\\n            int x = nums[i]-temp[i];\\n            temp[i]+=x;\\n            if(i+k<n) temp[i+k]-=x;\\n            else { i++; break; } // Last Window\\n        }\\n        // Checking if Last Window element is equals to our temp array element or not\\n        while(i<n) {\\n            temp[i]+=temp[i-1];\\n            if(temp[i]!=nums[i]) return false;\\n            i++;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3744509,
                "title": "c-sliding-window-technique-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n When I am at the start position of current window, my goal will be to make this first element zero so that i can go for next window (window size will be of length k). Now, let first element of this current window is ***sub*** then I will subtract \\'sub\\' from each element of this current window & will move to next window.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Move ahead in the array till we don\\'t encounter any non-zero number.\\n2. Let *i* is the index of first non-zero element. So, my window will start from *i* to *(i+k)* positions. My goal is to make nums[i]=0. For this, I will subtract nums[i] from each element in the window.\\n3. If in the current window, any element < nums[i] then I can not apply operation on k elements simultaneously & hence return false otherwise subtract nums[i].\\n4. Now, do i++ & move ahead.\\n5. If you are able to successfully complete the traversal, return true\\n6. In the starting, I have reversed the array. Without reversing also, the solution will run fine but will give TLE when initial elements are much much smaller than upcoming elements. This is because we are subtracting, say 1 from 1e5.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkArray(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        int i=0;\\n        if(nums[0]<nums[n-1])\\n        reverse(nums.begin(),nums.end());\\n        \\n        while(i<n){\\n            while(i<n){\\n            if(nums[i]==0)\\n                i++;\\n            else\\n                break;\\n        }\\n        \\n        if(i==n)\\n            return true;\\n            \\n            int sub=nums[i];\\n            for(int count=0; count<k; count++){\\n                if((i+count)>=n || nums[i+count]<sub)\\n                    return false;\\n                nums[i+count]-=sub;\\n            }\\n                i++;\\n        }\\n        return true;\\n    }\\n};\\n\\n---\\n\\n**Please upvote if you find the solution to be helpful**\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    bool checkArray(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        int i=0;\\n        if(nums[0]<nums[n-1])\\n        reverse(nums.begin(),nums.end());\\n        \\n        while(i<n){\\n            while(i<n){\\n            if(nums[i]==0)\\n                i++;\\n            else\\n                break;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3740187,
                "title": "explained-using-vector-priority-queue-simple-easy-to-understand-solution",
                "content": "\\n# Approach\\nBasically, here the catch is - that we consider that it possible to do this operation. So first elements need to be subtracted from first k elements, while doing so when ever then element is not zero then add it to your subtraction value and keep subtracting. After k elements the subtraction need to reduce by num[i-k] vlues as we don\\'t hv to subtract any more.\\n\\nInitially thought to do this using priority queue and later realised that the removal after kth element is sequential can be achieved using simple vector.\\n\\nFurther when checked out the solutions, found that the same input array can be used to and no extra vector required. Here is solution to this : \\nhttps://leetcode.com/problems/apply-operations-to-make-all-array-elements-equal-to-zero/solutions/3739101/java-c-python-greedy-sliding-window/\\n\\n\\n# Solution 1:\\n```\\nbool checkArray(vector<int>& nums, int k) {\\n    auto comp = [](const pair<int, int>& a, const pair<int,int>& b){\\n        return a.first > b.first;  \\n    };\\n    priority_queue<pair<int, int>, vector<pair<int, int>>, decltype(comp)> pq(comp);\\n    int sub = 0;\\n    for(int i = 0; i < nums.size(); ++i){\\n        while(!pq.empty() && pq.top().first <= i) { sub -= pq.top().second; pq.pop(); }\\n        nums[i] -= sub;\\n        sub += nums[i];\\n        pq.push({i+k, nums[i]});\\n        if(nums[i] < 0) return false;\\n    }\\n    if(!pq.empty()) { sub -= pq.top().second; }\\n    if(sub) return false;\\n    return true;\\n}\\n```\\n\\n# Solution 2:\\n\\n```\\nbool checkArray(vector<int>& nums, int k) {\\n    vector<pair<int,int>> store;\\n    int sub = 0, ind = 0;\\n    for(int i = 0; i < nums.size(); ++i){\\n        while(ind < store.size() && store[ind].first <= i) { sub -= store[ind].second; ind++; }\\n        nums[i] -= sub;\\n        sub += nums[i];\\n        store.push_back({i+k, nums[i]});\\n        if(nums[i] < 0) return false;\\n    }\\n    if(ind < store.size()) { sub -= store[ind].second; }\\n    if(sub) return false;\\n    return true;\\n}\\n```\\n\\n<b>Here is an article of my last interview experience - A Journey to FAANG Company, I recomand you to go through this to know which all resources I have used & how I cracked interview at Amazon:\\nhttps://leetcode.com/discuss/interview-experience/3171859/Journey-to-a-FAANG-Company-Amazon-or-SDE2-(L5)-or-Bangalore-or-Oct-2022-Accepted",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nbool checkArray(vector<int>& nums, int k) {\\n    auto comp = [](const pair<int, int>& a, const pair<int,int>& b){\\n        return a.first > b.first;  \\n    };\\n    priority_queue<pair<int, int>, vector<pair<int, int>>, decltype(comp)> pq(comp);\\n    int sub = 0;\\n    for(int i = 0; i < nums.size(); ++i){\\n        while(!pq.empty() && pq.top().first <= i) { sub -= pq.top().second; pq.pop(); }\\n        nums[i] -= sub;\\n        sub += nums[i];\\n        pq.push({i+k, nums[i]});\\n        if(nums[i] < 0) return false;\\n    }\\n    if(!pq.empty()) { sub -= pq.top().second; }\\n    if(sub) return false;\\n    return true;\\n}\\n```\n```\\nbool checkArray(vector<int>& nums, int k) {\\n    vector<pair<int,int>> store;\\n    int sub = 0, ind = 0;\\n    for(int i = 0; i < nums.size(); ++i){\\n        while(ind < store.size() && store[ind].first <= i) { sub -= store[ind].second; ind++; }\\n        nums[i] -= sub;\\n        sub += nums[i];\\n        store.push_back({i+k, nums[i]});\\n        if(nums[i] < 0) return false;\\n    }\\n    if(ind < store.size()) { sub -= store[ind].second; }\\n    if(sub) return false;\\n    return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3743951,
                "title": "line-by-line-explained-short-simple-c-solution",
                "content": "# Intuition\\nWindow size is k .\\nWe don\\'t care how many times we have to apply operations.\\n \\nWe just care about whether it is possible to convert all elements to 0 or not.\\n\\nSo for example :\\n2 2 3 1 1 taking k = 3 and window starting at index 0  we can get \\n0 0 1 1 1 by applying some number of operations (we dont care about number of operations)\\n\\ncontinue applying operations we get all 0s.\\n\\n**So we can Conclude**\\nEvery element at index i is influenced by elements at \\n**i - 1 , i - 2 , i - 3 , ... , i - (k-1)**.\\n\\n\\n# Approach\\nKeep a prefixSum variable that has contribution from  **i - 1 , i - 2 , i - 3 , ... , i - (k-1)** elements .\\n\\nEvery element will contribute **nums[ i ] - (current prefixSum value)**  for the next k - 1 elements . \\n\\nThus keeping contrubution of every element in mind we will calculate the next prefixSum\\n\\n# Complexity\\n- Time complexity:\\n $$O(n)$$ \\n\\n- Space complexity:\\n$$O(n)$$  just for storing the contribution of each elements\\nYou can optimize it by using the nums array instead.\\n\\n# Cleaner Code\\n```\\nclass Solution {\\npublic:\\n    bool checkArray(vector<int>& nums, int k) {\\n        int prefixsumk = 0;\\n        int n = nums.size();\\n        vector<int> contribution(n,0);\\n        for(int i=0;i<n; i++){\\n            if(prefixsumk > nums[i])\\n                return false;\\n            contribution[i] = nums[i] - prefixsumk;\\n            prefixsumk = prefixsumk + contribution[i];\\n            if(i>=k-1)\\n                prefixsumk-= contribution[i-k+1];\\n        }\\n        return prefixsumk == 0;\\n    }\\n};\\n```\\n\\n\\n# Code with comments explaining line by line\\n```\\nclass Solution {\\npublic:\\n    bool checkArray(vector<int>& nums, int k) {\\n\\n// stores contribution of previous k-1 elements\\n        int prefixsumk = 0;\\n\\n        int n = nums.size();\\n// stores contribution for every element \\n        vector<int> contribution(n,0);\\n\\n// for first element contribution is 0 since there are no element b4 it\\n        for(int i=0;i<n; i++){\\n// if we have prefixsum greater than current element that means after subtracting\\n// (performing operations) we will get negative number rather than 0 .\\n            if(prefixsumk > nums[i])\\n                return false;\\n// the current element will contribute value = what is left \\n// after performing operations on previous windows of size k.\\n            contribution[i] = nums[i] - prefixsumk;\\n\\n// calculate prefix sum for next element \\n// for that we need to add contribution of current element \\n            prefixsumk = prefixsumk + contribution[i];\\n\\n// and subtract contribution of i-(k-1) th element before it if it exists\\n            if(i>=k-1)\\n                prefixsumk-= contribution[i-k+1];\\n        }\\n// At the end of all operations there are no elements left so last contribution\\n// should be 0 otherwise we will be left with some numbers at end that were not converted to 0 .\\n        return prefixsumk == 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkArray(vector<int>& nums, int k) {\\n        int prefixsumk = 0;\\n        int n = nums.size();\\n        vector<int> contribution(n,0);\\n        for(int i=0;i<n; i++){\\n            if(prefixsumk > nums[i])\\n                return false;\\n            contribution[i] = nums[i] - prefixsumk;\\n            prefixsumk = prefixsumk + contribution[i];\\n            if(i>=k-1)\\n                prefixsumk-= contribution[i-k+1];\\n        }\\n        return prefixsumk == 0;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool checkArray(vector<int>& nums, int k) {\\n\\n// stores contribution of previous k-1 elements\\n        int prefixsumk = 0;\\n\\n        int n = nums.size();\\n// stores contribution for every element \\n        vector<int> contribution(n,0);\\n\\n// for first element contribution is 0 since there are no element b4 it\\n        for(int i=0;i<n; i++){\\n// if we have prefixsum greater than current element that means after subtracting\\n// (performing operations) we will get negative number rather than 0 .\\n            if(prefixsumk > nums[i])\\n                return false;\\n// the current element will contribute value = what is left \\n// after performing operations on previous windows of size k.\\n            contribution[i] = nums[i] - prefixsumk;\\n\\n// calculate prefix sum for next element \\n// for that we need to add contribution of current element \\n            prefixsumk = prefixsumk + contribution[i];\\n\\n// and subtract contribution of i-(k-1) th element before it if it exists\\n            if(i>=k-1)\\n                prefixsumk-= contribution[i-k+1];\\n        }\\n// At the end of all operations there are no elements left so last contribution\\n// should be 0 otherwise we will be left with some numbers at end that were not converted to 0 .\\n        return prefixsumk == 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3739081,
                "title": "using-queue-simple-c-o-n",
                "content": "# Intuition\\nmaking all element 0 while moving from left`(from 0 to n-k)` because there is only one way to make leftmost element zero which is decrement the first window.\\n\\n# Approach\\n- we will use a queue of size `k`  and var `d` to keep track `no of decrements` on index `i` from previous windows. \\n- where `q.front()` will give the `no of decrements` performed at window starting from `i-k`.\\n- `d` - total no of decrements performed in all prev k windows starting from `i-k,i-k+1.. ,i-1`.\\n- `d = d - q.front()` - no of decrements on index `i` from previous windows. \\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkArray(vector<int>& nums, int k) {\\n        \\n        queue<int> q;\\n        \\n        for(int i=0;i<k;i++)\\n        q.push(0);\\n\\n        \\n        int d = 0;\\n        \\n        for(int i=0;i<nums.size();i++){\\n            d = d - q.front();\\n            q.pop();\\n            if(nums[i]-d <0)return false;\\n            \\n            if(i>nums.size()-k){\\n                if(nums[i]-d != 0)return false;\\n                continue;\\n            }\\n            q.push(nums[i]-d);\\n            d += nums[i]-d;\\n\\n            \\n        }\\n        \\n        \\n        \\n        \\n        return true;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkArray(vector<int>& nums, int k) {\\n        \\n        queue<int> q;\\n        \\n        for(int i=0;i<k;i++)\\n        q.push(0);\\n\\n        \\n        int d = 0;\\n        \\n        for(int i=0;i<nums.size();i++){\\n            d = d - q.front();\\n            q.pop();\\n            if(nums[i]-d <0)return false;\\n            \\n            if(i>nums.size()-k){\\n                if(nums[i]-d != 0)return false;\\n                continue;\\n            }\\n            q.push(nums[i]-d);\\n            d += nums[i]-d;\\n\\n            \\n        }\\n        \\n        \\n        \\n        \\n        return true;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3739051,
                "title": "python3-prefix-sum",
                "content": "\\n```\\nclass Solution:\\n    def checkArray(self, nums: List[int], k: int) -> bool:\\n        for i, x in enumerate(nums): \\n            if i >= k: nums[i] += nums[i-k]\\n            if i and nums[i-1] > nums[i]: return False \\n        return all(nums[~i] == nums[-1] for i in range(k))\\n```",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "C"
                ],
                "code": "```\\nclass Solution:\\n    def checkArray(self, nums: List[int], k: int) -> bool:\\n        for i, x in enumerate(nums): \\n            if i >= k: nums[i] += nums[i-k]\\n            if i and nums[i-1] > nums[i]: return False \\n        return all(nums[~i] == nums[-1] for i in range(k))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3739000,
                "title": "simple-c-solution-sliding-window",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkArray(vector<int>& nums, int k) \\n    {\\n        int n = nums.size();\\n        int sum = 0;\\n        vector<pair<int, int>> v;\\n        int j = 0;\\n        for(int i=0; i<n; i++) \\n        {\\n            while(j<v.size() && i-v[j].first>=k) \\n            {\\n                sum -= v[j].second;\\n                j++;\\n            }\\n            if(nums[i]<sum) \\n            {\\n                return false;\\n            }\\n            nums[i] -= sum;\\n            if(nums[i]>0) \\n            {\\n                v.push_back({i, nums[i]});\\n                int temp = nums[i];\\n                nums[i] = 0;\\n                sum += temp;\\n            }\\n        }\\n        while (j<v.size() && n-v[j].first>=k) \\n        {\\n            j++;\\n        }\\n        int mx=-1e9;\\n        for(int x: nums) mx=max(mx, x);\\n        return mx==0 && j==v.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkArray(vector<int>& nums, int k) \\n    {\\n        int n = nums.size();\\n        int sum = 0;\\n        vector<pair<int, int>> v;\\n        int j = 0;\\n        for(int i=0; i<n; i++) \\n        {\\n            while(j<v.size() && i-v[j].first>=k) \\n            {\\n                sum -= v[j].second;\\n                j++;\\n            }\\n            if(nums[i]<sum) \\n            {\\n                return false;\\n            }\\n            nums[i] -= sum;\\n            if(nums[i]>0) \\n            {\\n                v.push_back({i, nums[i]});\\n                int temp = nums[i];\\n                nums[i] = 0;\\n                sum += temp;\\n            }\\n        }\\n        while (j<v.size() && n-v[j].first>=k) \\n        {\\n            j++;\\n        }\\n        int mx=-1e9;\\n        for(int x: nums) mx=max(mx, x);\\n        return mx==0 && j==v.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3738984,
                "title": "python3-sweep-line-range-addition-clean-concise",
                "content": "# Approach\\nThink about the problem **reversely**.\\n\\n1. We start from an array `arr` with a same length as `nums` and all elements being 0.\\n2. Now, we scan each element from left to right, using the \"Range Addition\" way ([LC 370. Range Addition](https://leetcode.com/problems/range-addition/)).\\n3. If the value of current element (i.e. `arr[i]`) is greater than `nums[i]`, we can already return `False`.\\n4. Otherwise, if the value of current element (i.e. `arr[i]`) is less than `nums[i]`, we then add the difference `diff` between the two elements to `arr[i]`, and subtract `diff` at `arr[i + k]`.\\n5. One caveat is that in Step 4, if the remaining subarray length starting from index `i` to the end of array (i.e. index `n - 1`) is strictly less than `k`, meaning that we cannot fulfill the condition. In this case, we also need to return `False`.\\n6. Return `True` if we arrive at the end of the array.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def checkArray(self, nums: List[int], k: int) -> bool:\\n        n = len(nums)\\n        arr = [0] * n\\n        for i in range(n):\\n            if i > 0:\\n                arr[i] += arr[i - 1]\\n            if arr[i] == nums[i]:\\n                continue\\n            elif arr[i] > nums[i]:\\n                return False\\n            elif n - i < k:\\n                return False\\n            diff = nums[i] - arr[i]\\n            arr[i] += diff\\n            if i + k < n:\\n                arr[i + k] -= diff\\n        return True\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def checkArray(self, nums: List[int], k: int) -> bool:\\n        n = len(nums)\\n        arr = [0] * n\\n        for i in range(n):\\n            if i > 0:\\n                arr[i] += arr[i - 1]\\n            if arr[i] == nums[i]:\\n                continue\\n            elif arr[i] > nums[i]:\\n                return False\\n            elif n - i < k:\\n                return False\\n            diff = nums[i] - arr[i]\\n            arr[i] += diff\\n            if i + k < n:\\n                arr[i + k] -= diff\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3740253,
                "title": "2-approaches-1-prefix-sum-range-update-2-segment-tree",
                "content": "### DO UPVOTE if you find it useful!!\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code : Prefix Sum\\n```\\nclass Solution {\\npublic:\\n    bool checkArray(vector<int>& nums, int k){\\n        int n=nums.size();\\n        vector<int> d(n+1,0);\\n        for(int i=0 ; i<n ; i++){\\n            if(i>0){\\n                d[i]+=d[i-1];\\n            }\\n            int diff=nums[i]-d[i];\\n            if(diff<0){\\n                return false;\\n            }\\n            if(i+k>n){\\n                if(diff!=0){\\n                    return false;\\n                }\\n                else{\\n                    continue;\\n                }\\n            }\\n            d[i]+=diff;\\n            d[i+k]-=diff;\\n        }\\n        return true;\\n    }\\n};\\n```\\n------------------------\\n# Complexity\\n- Time complexity:O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code : Segment Tree\\n```\\nclass SGTree_lazy{\\n  vector<long long> seg;\\n  vector<long long> lazy;\\n  public : \\n  SGTree_lazy(int n){\\n    seg.resize(4*n+1,0);\\n    lazy.resize(4*n+1,0);\\n  }\\n\\n  void build(long long idx,long long low,long long high,vector<int> &arr){\\n    if(low==high){\\n      seg[idx]=arr[low];\\n      return;\\n    }\\n\\n    int mid=low+((high-low)/2);\\n    build(2*idx+1,low,mid,arr);\\n    build(2*idx+2,mid+1,high,arr);\\n    seg[idx]=(seg[2*idx+1]+seg[2*idx+2]);\\n  }\\n\\n  void update(long long idx,long long low,long long high,int l,int r,long long val){\\n    //lazy propagation\\n    if(lazy[idx]!=0){\\n      seg[idx]+=(high-low+1)*lazy[idx];\\n      if(low!=high){\\n        lazy[2*idx+1]+=lazy[idx];\\n        lazy[2*idx+2]+=lazy[idx];\\n      }\\n      lazy[idx]=0;\\n    }\\n\\n    //no overlap\\n    if(l>high || r<low){\\n      return;\\n    }\\n\\n\\n    //complete overlap\\n    if(low>=l && high<=r){\\n      seg[idx]+=(high-low+1)*val;\\n      if(low!=high){\\n        lazy[2*idx+1]+=val;\\n        lazy[2*idx+2]+=val;\\n      }\\n      return ;\\n    }\\n\\n    //partial overlap\\n    long long mid=low+((high-low)/2);\\n    update(2*idx+1,low,mid,l,r,val);\\n    update(2*idx+2,mid+1,high,l,r,val);\\n    seg[idx]=(seg[2*idx+1]+seg[2*idx+2]);\\n  }\\n\\n  long long query(long long idx,long long low,long long high , int l,int r){\\n    //lazy propagation\\n    if(lazy[idx]!=0){\\n      seg[idx]+=(high-low+1)*lazy[idx];\\n      if(low!=high){\\n        lazy[2*idx+1]+=lazy[idx];\\n        lazy[2*idx+2]+=lazy[idx];\\n      }\\n      lazy[idx]=0;\\n    }\\n\\n    // no overlap\\n    if(high<l || low>r){\\n      return 0;\\n    }\\n\\n    //complete overlap\\n    if(low>=l && high<=r){\\n      return seg[idx];\\n    }\\n\\n    //partial overlap\\n    long long mid=low+((high-low)/2);\\n    long long left=query(2*idx+1,low,mid,l,r);\\n    long long right=query(2*idx+2,mid+1,high,l,r);\\n\\n    return (left+right);\\n  }\\n};\\n\\nclass Solution {\\npublic:\\n    bool checkArray(vector<int>& nums, int k){\\n        int n=nums.size();\\n        SGTree_lazy sg(n);\\n        sg.build(0,0,n-1,nums);\\n        long long sum=sg.query(0,0,(n-1),0,n-1);\\n        if((sum%k)!=0){\\n            return false;\\n        }\\n        for(int i=0 ; i<n ; i++){\\n            int curr=sg.query(0,0,n-1,i,i);\\n            if(curr<0){\\n                return false;\\n            }\\n            if(curr==0){\\n                continue;\\n            }\\n            if((i+k-1)<=n-1){\\n                sg.update(0,0,n-1,i,i+k-1,(-1)*curr);\\n            }\\n            else{\\n                if(curr!=0){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Segment Tree",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkArray(vector<int>& nums, int k){\\n        int n=nums.size();\\n        vector<int> d(n+1,0);\\n        for(int i=0 ; i<n ; i++){\\n            if(i>0){\\n                d[i]+=d[i-1];\\n            }\\n            int diff=nums[i]-d[i];\\n            if(diff<0){\\n                return false;\\n            }\\n            if(i+k>n){\\n                if(diff!=0){\\n                    return false;\\n                }\\n                else{\\n                    continue;\\n                }\\n            }\\n            d[i]+=diff;\\n            d[i+k]-=diff;\\n        }\\n        return true;\\n    }\\n};\\n```\n```\\nclass SGTree_lazy{\\n  vector<long long> seg;\\n  vector<long long> lazy;\\n  public : \\n  SGTree_lazy(int n){\\n    seg.resize(4*n+1,0);\\n    lazy.resize(4*n+1,0);\\n  }\\n\\n  void build(long long idx,long long low,long long high,vector<int> &arr){\\n    if(low==high){\\n      seg[idx]=arr[low];\\n      return;\\n    }\\n\\n    int mid=low+((high-low)/2);\\n    build(2*idx+1,low,mid,arr);\\n    build(2*idx+2,mid+1,high,arr);\\n    seg[idx]=(seg[2*idx+1]+seg[2*idx+2]);\\n  }\\n\\n  void update(long long idx,long long low,long long high,int l,int r,long long val){\\n    //lazy propagation\\n    if(lazy[idx]!=0){\\n      seg[idx]+=(high-low+1)*lazy[idx];\\n      if(low!=high){\\n        lazy[2*idx+1]+=lazy[idx];\\n        lazy[2*idx+2]+=lazy[idx];\\n      }\\n      lazy[idx]=0;\\n    }\\n\\n    //no overlap\\n    if(l>high || r<low){\\n      return;\\n    }\\n\\n\\n    //complete overlap\\n    if(low>=l && high<=r){\\n      seg[idx]+=(high-low+1)*val;\\n      if(low!=high){\\n        lazy[2*idx+1]+=val;\\n        lazy[2*idx+2]+=val;\\n      }\\n      return ;\\n    }\\n\\n    //partial overlap\\n    long long mid=low+((high-low)/2);\\n    update(2*idx+1,low,mid,l,r,val);\\n    update(2*idx+2,mid+1,high,l,r,val);\\n    seg[idx]=(seg[2*idx+1]+seg[2*idx+2]);\\n  }\\n\\n  long long query(long long idx,long long low,long long high , int l,int r){\\n    //lazy propagation\\n    if(lazy[idx]!=0){\\n      seg[idx]+=(high-low+1)*lazy[idx];\\n      if(low!=high){\\n        lazy[2*idx+1]+=lazy[idx];\\n        lazy[2*idx+2]+=lazy[idx];\\n      }\\n      lazy[idx]=0;\\n    }\\n\\n    // no overlap\\n    if(high<l || low>r){\\n      return 0;\\n    }\\n\\n    //complete overlap\\n    if(low>=l && high<=r){\\n      return seg[idx];\\n    }\\n\\n    //partial overlap\\n    long long mid=low+((high-low)/2);\\n    long long left=query(2*idx+1,low,mid,l,r);\\n    long long right=query(2*idx+2,mid+1,high,l,r);\\n\\n    return (left+right);\\n  }\\n};\\n\\nclass Solution {\\npublic:\\n    bool checkArray(vector<int>& nums, int k){\\n        int n=nums.size();\\n        SGTree_lazy sg(n);\\n        sg.build(0,0,n-1,nums);\\n        long long sum=sg.query(0,0,(n-1),0,n-1);\\n        if((sum%k)!=0){\\n            return false;\\n        }\\n        for(int i=0 ; i<n ; i++){\\n            int curr=sg.query(0,0,n-1,i,i);\\n            if(curr<0){\\n                return false;\\n            }\\n            if(curr==0){\\n                continue;\\n            }\\n            if((i+k-1)<=n-1){\\n                sg.update(0,0,n-1,i,i+k-1,(-1)*curr);\\n            }\\n            else{\\n                if(curr!=0){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3739895,
                "title": "java-simple-solution-sliding-window",
                "content": "# Intuition  | [JAVA] | Simple Solution | Sliding Window\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach : Sliding Window\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n*k)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean checkArray(int[] nums, int k) {\\n        int n = nums.length; //size of array\\n        int c = 0;\\n        for (int i = 0; i <= n-k; i++) { //iterating through array\\n            if(nums[i] == 0) continue; //no operation performed\\n            if(nums[i] < 0) return false; //negative value\\n            if(nums[i] > 0) c = nums[i]; //save the value for operation\\n            for(int j = i;j <i+k;j++) nums[j]-= c; //perfoming the operation\\n         }\\n        for (int i = n-k; i < n; i++) { //checking for values\\n            if (nums[i] != 0) {\\n                return false; //elements not zero after perfoming max operations\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkArray(int[] nums, int k) {\\n        int n = nums.length; //size of array\\n        int c = 0;\\n        for (int i = 0; i <= n-k; i++) { //iterating through array\\n            if(nums[i] == 0) continue; //no operation performed\\n            if(nums[i] < 0) return false; //negative value\\n            if(nums[i] > 0) c = nums[i]; //save the value for operation\\n            for(int j = i;j <i+k;j++) nums[j]-= c; //perfoming the operation\\n         }\\n        for (int i = n-k; i < n; i++) { //checking for values\\n            if (nums[i] != 0) {\\n                return false; //elements not zero after perfoming max operations\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3739598,
                "title": "python3-1-1-trick",
                "content": "We can encode subarrays `[w, w, ..., w]` of length `K` via two events: an event at position `i` of weight `+w`, and an event at position `i + K` of weight `-w`.\\n\\nMaintain a `brush` weight that will paint infinitely to the right, eg. `brush = 2` will write `[2, 2, 2, ...]` forever.\\n\\nNow for example, when `brush = 2` and `A[i] = 5`, it means that we must place a new subarray `[3, 3, ...]`, so `brush += 3` and `events[i + K] -= 3`.\\n\\n# Code\\n```\\nclass Solution:\\n    def checkArray(self, A: List[int], K: int) -> bool:\\n        N = len(A)\\n        events = [0] * (N + K)  # events[i] tells us how much to adjust brush\\n        \\n        brush = 0\\n        for i in range(N):\\n            brush += events[i]  # adjust the brush\\n            A[i] -= brush  # A[i] got painted by brush\\n            if A[i] < 0:  # painted too much\\n                return False\\n            if A[i] and i > N - K:  # new subarrays must be K length\\n                return False\\n            brush += A[i]  # add new brush stroke of weight A[i]\\n            events[i + K] -= A[i]  # record event to downweight brush by A[i] later\\n        \\n        return True\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def checkArray(self, A: List[int], K: int) -> bool:\\n        N = len(A)\\n        events = [0] * (N + K)  # events[i] tells us how much to adjust brush\\n        \\n        brush = 0\\n        for i in range(N):\\n            brush += events[i]  # adjust the brush\\n            A[i] -= brush  # A[i] got painted by brush\\n            if A[i] < 0:  # painted too much\\n                return False\\n            if A[i] and i > N - K:  # new subarrays must be K length\\n                return False\\n            brush += A[i]  # add new brush stroke of weight A[i]\\n            events[i + K] -= A[i]  # record event to downweight brush by A[i] later\\n        \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3739045,
                "title": "difference-array-o-n-tc-and-sc-simple-approach",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkArray(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int> diff(n+1, 0);\\n        \\n        diff[0] += nums[0];\\n        diff[k] -= nums[0];\\n        \\n        for(int i=1; i<n; i++) {\\n            diff[i] += diff[i-1];\\n            \\n            if(diff[i] == nums[i]) continue;\\n            \\n            if(diff[i] > nums[i] or i+k-1 >= n) return false;\\n            \\n            int d = nums[i] - diff[i];\\n            \\n            diff[i] += d;\\n            diff[i+k] -= d;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkArray(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int> diff(n+1, 0);\\n        \\n        diff[0] += nums[0];\\n        diff[k] -= nums[0];\\n        \\n        for(int i=1; i<n; i++) {\\n            diff[i] += diff[i-1];\\n            \\n            if(diff[i] == nums[i]) continue;\\n            \\n            if(diff[i] > nums[i] or i+k-1 >= n) return false;\\n            \\n            int d = nums[i] - diff[i];\\n            \\n            diff[i] += d;\\n            diff[i+k] -= d;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3743545,
                "title": "c-sliding-window-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkArray(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        int sum=0;\\n        if(k==1) return true;\\n        for(int i=0;i<n;i++){\\n            if(i>=k) sum-=nums[i-k];\\n            nums[i]-=sum;\\n            sum+=nums[i];\\n            if(nums[i]<0) return false;\\n        }\\n        return nums[n-1]==0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkArray(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        int sum=0;\\n        if(k==1) return true;\\n        for(int i=0;i<n;i++){\\n            if(i>=k) sum-=nums[i-k];\\n            nums[i]-=sum;\\n            sum+=nums[i];\\n            if(nums[i]<0) return false;\\n        }\\n        return nums[n-1]==0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3740222,
                "title": "c-bruteforce-solution-got-accepted",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkArray(vector<int>& arr, int k) {\\n        if (arr.back() > arr.front()) {\\n            reverse(arr.begin(), arr.end());\\n        }\\n        int n = arr.size();\\n        for (int i = 0; i + k <= n; ) {\\n            int mn = INT_MAX;\\n            for (int j = i; j - i + 1 <= k; j++) {\\n                mn = min(arr[j], mn);\\n            }\\n            \\n            for (int j = i; j - i + 1 <= k; j++) {\\n                arr[j] -= mn;\\n            }\\n\\n            int l = i;\\n            for (int j = i; j - i + 1 <= k; j++) {\\n                if (arr[j] == 0) {\\n                    l++;\\n                }\\n                else {\\n                    break;\\n                }\\n            }\\n            \\n            if (l == i) {\\n                return false;\\n            }\\n            i = l;\\n        }\\n        \\n        int ok = 1;\\n        for (int i : arr) {\\n            ok &= i == 0;\\n        }\\n        return ok;\\n    }\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/7ed436c5-6b5a-4210-bf9d-c00a21ad02bb_1688896086.8668668.png)\\n\\n\\nTest cases couldn\\'t have been more weak!!",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkArray(vector<int>& arr, int k) {\\n        if (arr.back() > arr.front()) {\\n            reverse(arr.begin(), arr.end());\\n        }\\n        int n = arr.size();\\n        for (int i = 0; i + k <= n; ) {\\n            int mn = INT_MAX;\\n            for (int j = i; j - i + 1 <= k; j++) {\\n                mn = min(arr[j], mn);\\n            }\\n            \\n            for (int j = i; j - i + 1 <= k; j++) {\\n                arr[j] -= mn;\\n            }\\n\\n            int l = i;\\n            for (int j = i; j - i + 1 <= k; j++) {\\n                if (arr[j] == 0) {\\n                    l++;\\n                }\\n                else {\\n                    break;\\n                }\\n            }\\n            \\n            if (l == i) {\\n                return false;\\n            }\\n            i = l;\\n        }\\n        \\n        int ok = 1;\\n        for (int i : arr) {\\n            ok &= i == 0;\\n        }\\n        return ok;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3739024,
                "title": "c-easy-solution-best-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkArray(vector<int>& nums, int k) \\n    {\\n        int n = nums.size();\\n        int sum = 0;\\n        vector<pair<int, int>> v; // idx, val\\n        int j = 0;\\n        for(int i=0; i<n; i++) \\n        {\\n            while(j<v.size() && i-v[j].first>=k) \\n            {\\n                sum -= v[j].second;\\n                j++;\\n            }\\n            if(nums[i]<sum) \\n            {\\n                return false;\\n            }\\n            nums[i] -= sum;\\n            if(nums[i]>0) \\n            {\\n                v.push_back({i, nums[i]});\\n                int val = nums[i];\\n                nums[i] = 0;\\n                sum += val;\\n            }\\n        }\\n        while (j<v.size() && n-v[j].first>=k) \\n        {\\n            j++;\\n        }\\n        if(j!=v.size()) return false;\\n        int mx=-1e9;\\n        for(int x: nums) mx=max(mx, x);\\n        return mx==0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkArray(vector<int>& nums, int k) \\n    {\\n        int n = nums.size();\\n        int sum = 0;\\n        vector<pair<int, int>> v; // idx, val\\n        int j = 0;\\n        for(int i=0; i<n; i++) \\n        {\\n            while(j<v.size() && i-v[j].first>=k) \\n            {\\n                sum -= v[j].second;\\n                j++;\\n            }\\n            if(nums[i]<sum) \\n            {\\n                return false;\\n            }\\n            nums[i] -= sum;\\n            if(nums[i]>0) \\n            {\\n                v.push_back({i, nums[i]});\\n                int val = nums[i];\\n                nums[i] = 0;\\n                sum += val;\\n            }\\n        }\\n        while (j<v.size() && n-v[j].first>=k) \\n        {\\n            j++;\\n        }\\n        if(j!=v.size()) return false;\\n        int mx=-1e9;\\n        for(int x: nums) mx=max(mx, x);\\n        return mx==0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3743540,
                "title": "java-o-n-beats-100-sliding-window-visual-model",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis question reminds me of this visual model\\n![Screenshot 2023-07-09 at 8.50.09 PM.png](https://assets.leetcode.com/users/images/bdb18ebc-676d-495a-9d0f-ec8d264e21cc_1688961035.5830061.png)\\n\\nA certain number of lego bars (length of `k`, here `k = 4`) stacking up, and `nums[i]` is their thickness at `i`. So the goal is to validate `nums` indicates the correct values.\\n \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nLet\\'s assume `increment[i]` is the number of bars added at index `i`, `increment[i]` will only last till `i + k - 1`, which is the right end of the bars that are added at `i`. `increment[i]` will no longer contribute to the next iteration, so we\\'ll have to deduct `increment[i]` when we reach the bars\\' right ends.\\n\\nBefore index `0`, `increment = 0`\\n\\nLet\\'s reuse `nums[i]` to store `increment[i]`: that\\'s why we have `nums[i] -= increment`, and then add the difference to `increment` and carry it over to the next iteration. In the meantime, deduct `increment[i - k + 1]` because it won\\'t contribute to the next iteration.\\n\\nAt the end of the array, we should reach the right end of all the remaining bars. So `increment` has to fall back to `0` after all the iterations are done.  \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean checkArray(int[] nums, int k) {\\n        int increment = 0;\\n        for(int i = 0; i < nums.length; i++) {\\n            if(increment > nums[i])\\n                return false;\\n            nums[i] -= increment; // calculate increment[i]\\n            increment += nums[i];\\n            if(i - k + 1 >= 0) {\\n                increment -= nums[i - k + 1]; // remove increment[i - k + 1]\\n            }\\n        }\\n        return increment == 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkArray(int[] nums, int k) {\\n        int increment = 0;\\n        for(int i = 0; i < nums.length; i++) {\\n            if(increment > nums[i])\\n                return false;\\n            nums[i] -= increment; // calculate increment[i]\\n            increment += nums[i];\\n            if(i - k + 1 >= 0) {\\n                increment -= nums[i - k + 1]; // remove increment[i - k + 1]\\n            }\\n        }\\n        return increment == 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3742507,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def checkArray(self, nums: List[int], k: int) -> bool:\\n        curr=0\\n        for i,a in enumerate(nums):\\n            if curr>a:\\n                return False\\n\\n            nums[i],curr=a-curr,a\\n            if i>=k-1:\\n                curr-=nums[i-k+1]\\n\\n        return curr==0            \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def checkArray(self, nums: List[int], k: int) -> bool:\\n        curr=0\\n        for i,a in enumerate(nums):\\n            if curr>a:\\n                return False\\n\\n            nums[i],curr=a-curr,a\\n            if i>=k-1:\\n                curr-=nums[i-k+1]\\n\\n        return curr==0            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3739654,
                "title": "python3-solve-system-of-equations",
                "content": "Let\\'s say we add a subarray of weight $$B_i$$ at positions $$[i, i+1, ..., i+K-1]$$.  This means:\\n\\n$$\\nA_0 = B_0\\\\\\\\\\nA_1 = B_0 + B_1\\\\\\\\\\n...,\\\\\\\\\\nA_{K-1} = B_0 + ... + B_{K-1}\\\\\\\\\\nA_K = B_1 + ... + B_K\\\\\\\\\\nA_{K+1} = B_2 + ... + B_{K+1}\\\\\\\\\\n...\\n$$\\n\\nWe can solve these equations for B.  Let P be the prefix sum of B (`P[i] = sum(B[:i])`).  Then $$A_i = B_i - (B_{i-1} + ... + B_{i-(K-1)}) = B_i - (P_i - P_{i-(K-1)})$$, where $$B_{-1}$$, $$B_{-2}$$ etc. are regarded as zero.\\n\\nAt the end, $$B_i \\\\geq 0$$ [all subarrays must have non-negative weight] and $$B_j = 0$$ (for $$j > N - K$$) [subarrays can\\'t start after position `N - K`] correspond to the legal choices.\\n\\n# Code\\n```\\nclass Solution:\\n    def checkArray(self, A: List[int], K: int) -> bool:\\n        N = len(A)\\n        B = []\\n        P = [0]\\n        for i, x in enumerate(A):\\n            b = x - (P[i] - P[max(0, i - K + 1)])\\n            B.append(b)\\n            P.append(P[-1] + b)\\n\\n        return all(b >= 0 for b in B) and not any(B[~i] for i in range(K - 1))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def checkArray(self, A: List[int], K: int) -> bool:\\n        N = len(A)\\n        B = []\\n        P = [0]\\n        for i, x in enumerate(A):\\n            b = x - (P[i] - P[max(0, i - K + 1)])\\n            B.append(b)\\n            P.append(P[-1] + b)\\n\\n        return all(b >= 0 for b in B) and not any(B[~i] for i in range(K - 1))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3739275,
                "title": "python-greedy-o-n",
                "content": "1. `h` = the least number we need so far..\\n`arr[i]` = the number needed to subtract from `h` at index `i`.\\n2. At index `i`, first we subtract `arr[i]` from `h`, then compare `n=nums[i]` with `h`.\\nIf `n > h`, save `n-h` in `arr[i+k]` and raise `h` to `n`;\\nIf `n < h`, contradiction occurs, so we return `False`.\\nIf `n == h`, just continue.\\n```\\nclass Solution:\\n    def checkArray(self, nums: List[int], k: int) -> bool:\\n        arr = [0]*(len(nums)+1)\\n        h = 0\\n        for i, n in enumerate(nums):\\n            h -= arr[i]\\n            if n > h:\\n                if i+k > len(nums):\\n                    return False\\n                arr[i+k] = n-h\\n                h = n\\n            elif n < h:\\n                return False\\n        return True",
                "solutionTags": [
                    "Python3"
                ],
                "code": "1. `h` = the least number we need so far..\\n`arr[i]` = the number needed to subtract from `h` at index `i`.\\n2. At index `i`, first we subtract `arr[i]` from `h`, then compare `n=nums[i]` with `h`.\\nIf `n > h`, save `n-h` in `arr[i+k]` and raise `h` to `n`;\\nIf `n < h`, contradiction occurs, so we return `False`.\\nIf `n == h`, just continue.\\n```\\nclass Solution:\\n    def checkArray(self, nums: List[int], k: int) -> bool:\\n        arr = [0]*(len(nums)+1)\\n        h = 0\\n        for i, n in enumerate(nums):\\n            h -= arr[i]\\n            if n > h:\\n                if i+k > len(nums):\\n                    return False\\n                arr[i+k] = n-h\\n                h = n\\n            elif n < h:\\n                return False\\n        return True",
                "codeTag": "Java"
            },
            {
                "id": 3892358,
                "title": "apply-operations-to-make-all-array-elements-equal-to-zero-java-easy-to-understand-o-n-k",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean checkArray(int[] nums, int k) {\\n        int n=nums.length;\\n        for(int i=0;i<n;i++){\\n            if(i>n-k && nums[i]!=0){\\n                return false;\\n            }\\n\\n            if(nums[i]==0)continue;\\n\\n            int dec=nums[i];\\n\\n            for(int j=0;j<k;j++){\\n                nums[i+j]-=dec;\\n\\n                if(nums[i+j]<0){\\n                    return false;\\n                }\\n            }\\n\\n            // System.out.println(Arrays.toString(nums));\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkArray(int[] nums, int k) {\\n        int n=nums.length;\\n        for(int i=0;i<n;i++){\\n            if(i>n-k && nums[i]!=0){\\n                return false;\\n            }\\n\\n            if(nums[i]==0)continue;\\n\\n            int dec=nums[i];\\n\\n            for(int j=0;j<k;j++){\\n                nums[i+j]-=dec;\\n\\n                if(nums[i+j]<0){\\n                    return false;\\n                }\\n            }\\n\\n            // System.out.println(Arrays.toString(nums));\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3789747,
                "title": "python-keep-tracking-the-operation-count-that-makes-each-element-zero",
                "content": "The problem asks to make the entrie array zero. However, every operation is apply on a subarray with length k.\\n\\nAn intuitive way is substract each element in a subarray with the value that makes the first element zero. Next, we move to the second element, if the value of the second element is still possitive, we apply the same operations to the next k elements. In the case that there is an element with value less than zero after the process, we know that we cannot make the entire array to be zero.\\n\\nHowever, the above process requires O(n^2) time. What we can do to improve the algorithm is use one array to keep tracking the value we need to substract for each window k, so that we can use O(1) to find the value that need to be substracted for each element.\\n\\nsee the details below:\\n\\n```\\nclass Solution:\\n    def checkArray(self, nums: List[int], k: int) -> bool:\\n        # 1 <= k <= nums.length <= 10^5\\n        # 0 <= nums[i] <= 10^6\\n        len_n = len(nums)\\n\\n        if k == 1:\\n            return True\\n\\n        # recording the running diff that applied to make the first element of\\n        # each subarray starting at index i to be zero\\n        running_diff = [0] * len_n\\n        current_diff = 0\\n\\n        idx = 0\\n        while idx <= len_n - k:\\n            if idx - k >= 0:\\n                current_diff -= running_diff[idx - k]\\n            if current_diff > nums[idx]:\\n                return False\\n            else:\\n                running_diff[idx] = nums[idx] - current_diff\\n                current_diff += running_diff[idx]\\n            #print(idx, current_diff, running_diff)\\n            idx += 1\\n\\n        # for the last subarray ending at len_n - 1\\n        while idx < len_n:\\n            current_diff -= running_diff[idx - k]\\n            print(idx, current_diff)\\n            if current_diff != nums[idx]:\\n                return False\\n            idx += 1\\n\\n        return True\\n```",
                "solutionTags": [
                    "Python3",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def checkArray(self, nums: List[int], k: int) -> bool:\\n        # 1 <= k <= nums.length <= 10^5\\n        # 0 <= nums[i] <= 10^6\\n        len_n = len(nums)\\n\\n        if k == 1:\\n            return True\\n\\n        # recording the running diff that applied to make the first element of\\n        # each subarray starting at index i to be zero\\n        running_diff = [0] * len_n\\n        current_diff = 0\\n\\n        idx = 0\\n        while idx <= len_n - k:\\n            if idx - k >= 0:\\n                current_diff -= running_diff[idx - k]\\n            if current_diff > nums[idx]:\\n                return False\\n            else:\\n                running_diff[idx] = nums[idx] - current_diff\\n                current_diff += running_diff[idx]\\n            #print(idx, current_diff, running_diff)\\n            idx += 1\\n\\n        # for the last subarray ending at len_n - 1\\n        while idx < len_n:\\n            current_diff -= running_diff[idx - k]\\n            print(idx, current_diff)\\n            if current_diff != nums[idx]:\\n                return False\\n            idx += 1\\n\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3769540,
                "title": "c-easy-beats-99-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkArray(vector<int>& nums, int k) {\\n      auto const n = static_cast<int>(std::size(nums));\\n\\n\\t\\tauto current = 0;\\n\\t\\tfor (auto i = 0; i != n; ++i)\\n\\t\\t{\\n\\t\\t\\tif (current > nums[i]) { return false; }\\n\\n\\t\\t\\tnums[i] -= current;\\n\\t\\t\\tcurrent += nums[i];\\n\\t\\t\\tif (i >= k - 1) { current -= nums[i - k + 1]; }\\n\\t\\t}\\n\\n\\t\\treturn current == 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkArray(vector<int>& nums, int k) {\\n      auto const n = static_cast<int>(std::size(nums));\\n\\n\\t\\tauto current = 0;\\n\\t\\tfor (auto i = 0; i != n; ++i)\\n\\t\\t{\\n\\t\\t\\tif (current > nums[i]) { return false; }\\n\\n\\t\\t\\tnums[i] -= current;\\n\\t\\t\\tcurrent += nums[i];\\n\\t\\t\\tif (i >= k - 1) { current -= nums[i - k + 1]; }\\n\\t\\t}\\n\\n\\t\\treturn current == 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3746586,
                "title": "greedy-using-sliding-window-and-deque",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor each window of size k ,the minimum element in that window should be greater than the first element. Also in the last element of next window add first element of current window.\\nInstead of substracting in current window I am changing next window.\\nAt last all elements should be equal of last window.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkArray(vector<int>& nums, int k) {\\n        if(k==1) return 1;\\n\\n        int n = nums.size();\\n        deque<pair<int,int>> dq;\\n        int i=0;\\n        for(;i<k;i++){\\n            dq.push_back({nums[i],i});\\n            while(dq.front().first>nums[i]) dq.pop_front();\\n        }\\n        if(dq.front().first<nums[0]) return 0;\\n\\n        for(;i<n;i++){\\n            nums[i]+=nums[i-k];\\n            dq.push_back({nums[i],i});\\n            if(dq.front().second==i-k) dq.pop_front();\\n            while(dq.front().first>nums[i]) dq.pop_front();\\n            if(dq.front().first<nums[i-k+1]) return 0;\\n        }\\n\\n        for(int i=0;i<k-1;i++){\\n            if(nums[n-1-i]!=nums[n-2-i]) return 0;\\n        }\\n        return 1;\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkArray(vector<int>& nums, int k) {\\n        if(k==1) return 1;\\n\\n        int n = nums.size();\\n        deque<pair<int,int>> dq;\\n        int i=0;\\n        for(;i<k;i++){\\n            dq.push_back({nums[i],i});\\n            while(dq.front().first>nums[i]) dq.pop_front();\\n        }\\n        if(dq.front().first<nums[0]) return 0;\\n\\n        for(;i<n;i++){\\n            nums[i]+=nums[i-k];\\n            dq.push_back({nums[i],i});\\n            if(dq.front().second==i-k) dq.pop_front();\\n            while(dq.front().first>nums[i]) dq.pop_front();\\n            if(dq.front().first<nums[i-k+1]) return 0;\\n        }\\n\\n        for(int i=0;i<k-1;i++){\\n            if(nums[n-1-i]!=nums[n-2-i]) return 0;\\n        }\\n        return 1;\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3744470,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkArray(vector<int>& nums, int k) {\\n        int n= nums.size();\\n        int a=0,b=0;\\n        vector<pair<int,int>>vec;\\n        for(int i=0;i<n;i++){\\n            while(b<vec.size() && i-vec[b].first>=k){\\n                a-=vec[b].second;   \\n                b++;\\n            }\\n            if(nums[i]<a) return false;\\n            \\n            nums[i]-=a;\\n            if(nums[i]){\\n                vec.push_back({i,nums[i]});\\n                int temp= nums[i];\\n                nums[i]=0;\\n                a+=temp;\\n            }\\n        }\\n        \\n        while(vec.size() && b<vec.size() && n-vec[b].first>=k){\\n            b++;\\n        }\\n        return *max_element(nums.begin(),nums.end())==0 && b==vec.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkArray(vector<int>& nums, int k) {\\n        int n= nums.size();\\n        int a=0,b=0;\\n        vector<pair<int,int>>vec;\\n        for(int i=0;i<n;i++){\\n            while(b<vec.size() && i-vec[b].first>=k){\\n                a-=vec[b].second;   \\n                b++;\\n            }\\n            if(nums[i]<a) return false;\\n            \\n            nums[i]-=a;\\n            if(nums[i]){\\n                vec.push_back({i,nums[i]});\\n                int temp= nums[i];\\n                nums[i]=0;\\n                a+=temp;\\n            }\\n        }\\n        \\n        while(vec.size() && b<vec.size() && n-vec[b].first>=k){\\n            b++;\\n        }\\n        return *max_element(nums.begin(),nums.end())==0 && b==vec.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3743200,
                "title": "easiest-solution-intuition-explained-o-n-faster-than-100-c-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nDon\\'t think that you want to do something on the range, think that you just want to make the current element 0. Ofcourse it will take `nums[i]` operations to make `nums[i] = 0`. But is your current `nums[i]` same as the original `nums[i]`? No. It must have been edited by the previous k - 1 elements. When you were trying to make them 0, they must have changed the current element. But changed by how much? Decreased by how much?\\n\\nA single element(in the previous `k - 1` elements) would decrease the current element by the amount - the changed value you encountered when you visited that element. The number of operations it took you to make that `element = 0` when you were standing at that element. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nFrom the above intuition, we can develop a solution:\\n1. Get the latest changed value of the current element. It should be the `sum` of previous `k - 1` elements (not the original, the changed values that you encountered).\\n2. If the new value comes out to be less than `0`, that means previous `k - 1` elements changed the current element more than they should have.\\n3. Now for the next number, add the current new value to `cursum` and delete the `(k - 1)th` element from the `cursum`.\\n4. That\\'s all. Think of the edge case yourself. \\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```cpp []\\nclass Solution {\\npublic:\\n    bool checkArray(vector<int>& nums, int k) {\\n\\n        if (k == 1) return true;\\n\\n        int curSum = 0;\\n        int n = nums.size();\\n\\n        for (int i = 0; i < n; i++) {\\n            nums[i] -= curSum; // get the latest value of the current element \\n            if (nums[i] < 0) return false; // previous k - 1 elements decreased the current element more than they should\\n            // update the cursum by adding the current element, and deleting the k - 1 th element\\n            curSum += nums[i];\\n            if (i - (k - 1) >= 0) curSum -= nums[i - (k - 1)];\\n        }\\n\\n        return nums[n - 1] == 0;\\n    }\\n};\\n```\\n```java []\\nclass Solution {\\n    public boolean checkArray(int[] nums, int k) {\\n        if (k == 1) return true;\\n\\n        int curSum = 0;\\n        int n = nums.length;\\n\\n        for (int i = 0; i < n; i++) {\\n            nums[i] -= curSum; // get the latest value of the current element \\n            if (nums[i] < 0) return false; // previous k - 1 elements decreased the current element more than they should\\n            // update the cursum by adding the current element, and deleting the k - 1 th element\\n            curSum += nums[i];\\n            if (i - (k - 1) >= 0) curSum -= nums[i - (k - 1)];\\n        }\\n\\n        return nums[n - 1] == 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```cpp []\\nclass Solution {\\npublic:\\n    bool checkArray(vector<int>& nums, int k) {\\n\\n        if (k == 1) return true;\\n\\n        int curSum = 0;\\n        int n = nums.size();\\n\\n        for (int i = 0; i < n; i++) {\\n            nums[i] -= curSum; // get the latest value of the current element \\n            if (nums[i] < 0) return false; // previous k - 1 elements decreased the current element more than they should\\n            // update the cursum by adding the current element, and deleting the k - 1 th element\\n            curSum += nums[i];\\n            if (i - (k - 1) >= 0) curSum -= nums[i - (k - 1)];\\n        }\\n\\n        return nums[n - 1] == 0;\\n    }\\n};\\n```\n```java []\\nclass Solution {\\n    public boolean checkArray(int[] nums, int k) {\\n        if (k == 1) return true;\\n\\n        int curSum = 0;\\n        int n = nums.length;\\n\\n        for (int i = 0; i < n; i++) {\\n            nums[i] -= curSum; // get the latest value of the current element \\n            if (nums[i] < 0) return false; // previous k - 1 elements decreased the current element more than they should\\n            // update the cursum by adding the current element, and deleting the k - 1 th element\\n            curSum += nums[i];\\n            if (i - (k - 1) >= 0) curSum -= nums[i - (k - 1)];\\n        }\\n\\n        return nums[n - 1] == 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3742529,
                "title": "python-simple-maths",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def checkArray(self, nums, k):\\n        n, val, ans = len(nums), True, [0]*k\\n\\n        for i in range(n):\\n            ans[i%k] += nums[i]\\n\\n        for i in range(1,k):\\n            if ans[i] != ans[0]:\\n                val = False\\n                break\\n\\n        return val\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def checkArray(self, nums, k):\\n        n, val, ans = len(nums), True, [0]*k\\n\\n        for i in range(n):\\n            ans[i%k] += nums[i]\\n\\n        for i in range(1,k):\\n            if ans[i] != ans[0]:\\n                val = False\\n                break\\n\\n        return val\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3742470,
                "title": "sweep-line",
                "content": "# Code\\n```\\nclass Solution {\\n  bool checkArray(List<int> nums, int k) {\\n    final sweep = List.filled(nums.length, 0);\\n    int prev_sweep_sum = 0;\\n    for (int i = 0; i < nums.length; i++) {\\n      sweep[i] += prev_sweep_sum;\\n\\n      if (nums[i] + sweep[i] != 0) {\\n        if (nums.length - i < k) return false;\\n\\n        if (nums[i] + sweep[i] < 0) return false;\\n        final int change = nums[i] + sweep[i];\\n        sweep[i] -= change;\\n        if (i + k < nums.length)\\n          sweep[i + k] += change;\\n      }\\n\\n      prev_sweep_sum = sweep[i];\\n    }\\n    return true;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  bool checkArray(List<int> nums, int k) {\\n    final sweep = List.filled(nums.length, 0);\\n    int prev_sweep_sum = 0;\\n    for (int i = 0; i < nums.length; i++) {\\n      sweep[i] += prev_sweep_sum;\\n\\n      if (nums[i] + sweep[i] != 0) {\\n        if (nums.length - i < k) return false;\\n\\n        if (nums[i] + sweep[i] < 0) return false;\\n        final int change = nums[i] + sweep[i];\\n        sweep[i] -= change;\\n        if (i + k < nums.length)\\n          sweep[i + k] += change;\\n      }\\n\\n      prev_sweep_sum = sweep[i];\\n    }\\n    return true;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3741560,
                "title": "simple-answer-good-for-beginners-c-java",
                "content": "C++\\n```\\nclass Solution {\\npublic:\\n    bool checkArray(vector<int>& nums, int k) {\\n        int n = nums.size(), s = 0,j = 0;\\n        deque<pair<int, int>> q;\\n        for (int i = 0; i < n; ++i) {\\n            while (!q.empty() && i - q.front().first >= k) {\\n                s -= q.front().second;\\n                q.pop_front();\\n            }\\n            if (nums[i] < s)\\n                return false;\\n            nums[i] -= s;\\n            if (nums[i]) {\\n                int v = nums[i];\\n                nums[i] = 0;\\n                s += v;\\n                q.push_back({ i, v });\\n            }\\n            while (!q.empty() && i - q.back().first >= k - 1) {\\n                s -= q.back().second;\\n                q.pop_back();\\n            }\\n        }\\n        return q.empty();\\n    }\\n};\\n```\\nJava\\n```\\nclass Solution {\\n    public boolean checkArray(int[] nums, int k) {\\n        int n = nums.length;\\n        int s = 0;\\n        int j = 0;\\n        Deque<Pair<Integer, Integer>> q = new ArrayDeque<>();\\n        for (int i = 0; i < n; ++i) {\\n            while (!q.isEmpty() && i - q.peekFirst().getKey() >= k) {\\n                s -= q.peekFirst().getValue();\\n                q.pollFirst();\\n            }\\n            if (nums[i] < s) \\n                return false;\\n            nums[i] -= s;\\n            if (nums[i] != 0) {\\n                int v = nums[i];\\n                nums[i] = 0;\\n                s += v;\\n                q.offerLast(new Pair<>(i, v));\\n            }\\n            while (!q.isEmpty() && i - q.peekLast().getKey() >= k - 1) {\\n                s -= q.peekLast().getValue();\\n                q.pollLast();\\n            }\\n        }\\n        return q.isEmpty();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkArray(vector<int>& nums, int k) {\\n        int n = nums.size(), s = 0,j = 0;\\n        deque<pair<int, int>> q;\\n        for (int i = 0; i < n; ++i) {\\n            while (!q.empty() && i - q.front().first >= k) {\\n                s -= q.front().second;\\n                q.pop_front();\\n            }\\n            if (nums[i] < s)\\n                return false;\\n            nums[i] -= s;\\n            if (nums[i]) {\\n                int v = nums[i];\\n                nums[i] = 0;\\n                s += v;\\n                q.push_back({ i, v });\\n            }\\n            while (!q.empty() && i - q.back().first >= k - 1) {\\n                s -= q.back().second;\\n                q.pop_back();\\n            }\\n        }\\n        return q.empty();\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public boolean checkArray(int[] nums, int k) {\\n        int n = nums.length;\\n        int s = 0;\\n        int j = 0;\\n        Deque<Pair<Integer, Integer>> q = new ArrayDeque<>();\\n        for (int i = 0; i < n; ++i) {\\n            while (!q.isEmpty() && i - q.peekFirst().getKey() >= k) {\\n                s -= q.peekFirst().getValue();\\n                q.pollFirst();\\n            }\\n            if (nums[i] < s) \\n                return false;\\n            nums[i] -= s;\\n            if (nums[i] != 0) {\\n                int v = nums[i];\\n                nums[i] = 0;\\n                s += v;\\n                q.offerLast(new Pair<>(i, v));\\n            }\\n            while (!q.isEmpty() && i - q.peekLast().getKey() >= k - 1) {\\n                s -= q.peekLast().getValue();\\n                q.pollLast();\\n            }\\n        }\\n        return q.isEmpty();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3739328,
                "title": "prefix-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nEach element at ith index can update elements till i+k-1 index elements ahead(as at each index i we make its element 0, so don\\'t need to worry about previous elements) of it so we can use prefix sum.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nJust Apply prefix sum on range (i+0,i+1,...,i+k-1) taking care of edge cases and check whether all elements become 0 or not. Check out code for better understanding.\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkArray(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<long long> pre(n+2,0);\\n        for(int i=1;i<=n;i++){\\n            pre[i]+=pre[i-1];\\n            int val=nums[i-1];\\n            val+=pre[i];\\n            // as negative val(means element<0) can\\'t update elements ahead\\n            if(i<=(n-k+1)&&val>0){\\n                pre[i]-=val;\\n                pre[i+k]+=val;\\n            }\\n        }\\n       \\n        for(int i=0;i<n;++i){\\n            nums[i]+=pre[i+1];\\n            if(nums[i]!=0) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkArray(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<long long> pre(n+2,0);\\n        for(int i=1;i<=n;i++){\\n            pre[i]+=pre[i-1];\\n            int val=nums[i-1];\\n            val+=pre[i];\\n            // as negative val(means element<0) can\\'t update elements ahead\\n            if(i<=(n-k+1)&&val>0){\\n                pre[i]-=val;\\n                pre[i+k]+=val;\\n            }\\n        }\\n       \\n        for(int i=0;i<n;++i){\\n            nums[i]+=pre[i+1];\\n            if(nums[i]!=0) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3739277,
                "title": "c-simple-greedy-two-pointers",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkArray(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        int i=0, j=n-1;\\n        while(i <= j){\\n            while(i<=j && nums[i]==0) i++;\\n            while(i<=j && nums[j]==0) j--;\\n            if(i>j) return true;\\n            if(j-i < k-1) return false;\\n            if(nums[i] >= nums[j]){\\n                for(int x=i+1; x<i+k; x++){\\n                    if(nums[x] < nums[i]) return false;\\n                    nums[x] -= nums[i];\\n                }\\n                nums[i] = 0;\\n            } else {\\n                for(int x=j-1; x>j-k; x--){\\n                    if(nums[x] < nums[j]) return false;\\n                    nums[x] -= nums[j];\\n                }\\n                nums[j] = 0;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkArray(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        int i=0, j=n-1;\\n        while(i <= j){\\n            while(i<=j && nums[i]==0) i++;\\n            while(i<=j && nums[j]==0) j--;\\n            if(i>j) return true;\\n            if(j-i < k-1) return false;\\n            if(nums[i] >= nums[j]){\\n                for(int x=i+1; x<i+k; x++){\\n                    if(nums[x] < nums[i]) return false;\\n                    nums[x] -= nums[i];\\n                }\\n                nums[i] = 0;\\n            } else {\\n                for(int x=j-1; x>j-k; x--){\\n                    if(nums[x] < nums[j]) return false;\\n                    nums[x] -= nums[j];\\n                }\\n                nums[j] = 0;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3739242,
                "title": "using-queue-approach-c-solution",
                "content": "# Intuition\\nThe very first & simple intuition is to store the position up to which deletions are being made and update the delete sum with `nums` array to ensure the elements become zero.\\n\\n# Approach\\nI used a `queue` to store deleted elements and a vector `del` to keep track of their positions. Starting from index `0`, I push elements greater than 0 into the queue, since we need to delete them to make those 0. I update the delete sum `sum` by adding the element, and I also update the `del` array with the last delete mark, which is `(i+k-1)`. This process is repeated iteratively. If subtraction from `nums` is not possible during the iteration, the loop is exited.\\n\\nIn the end, we will check whether it is possible to make all elements zero or not.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkArray(vector<int>& nums, int k) {\\n        if (k == 1)\\n            return true;\\n\\n        int n = nums.size(), sum = nums[0];\\n        \\n        vector<int> del(n + 1, 0); \\n        queue<int> q;\\n        \\n        q.push(nums[0]);\\n        nums[0] = 0;\\n        del[k - 1] = 1;\\n        \\n        for (int i = 1; i < n; ++i) {\\n            if (sum >= 0)\\n                nums[i] -= sum;\\n            else\\n                break;\\n\\n            if (nums[i] > 0 && i <= n - k) {\\n                q.push(nums[i]);\\n                sum += nums[i];\\n                nums[i] = 0;\\n                del[i + k - 1] = 1;\\n            }\\n            \\n            if (del[i] == 1) {\\n                sum -= q.front();\\n                q.pop();\\n            }\\n        }\\n        \\n        for (auto i : nums) {\\n            if (i != 0)\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkArray(vector<int>& nums, int k) {\\n        if (k == 1)\\n            return true;\\n\\n        int n = nums.size(), sum = nums[0];\\n        \\n        vector<int> del(n + 1, 0); \\n        queue<int> q;\\n        \\n        q.push(nums[0]);\\n        nums[0] = 0;\\n        del[k - 1] = 1;\\n        \\n        for (int i = 1; i < n; ++i) {\\n            if (sum >= 0)\\n                nums[i] -= sum;\\n            else\\n                break;\\n\\n            if (nums[i] > 0 && i <= n - k) {\\n                q.push(nums[i]);\\n                sum += nums[i];\\n                nums[i] = 0;\\n                del[i + k - 1] = 1;\\n            }\\n            \\n            if (del[i] == 1) {\\n                sum -= q.front();\\n                q.pop();\\n            }\\n        }\\n        \\n        for (auto i : nums) {\\n            if (i != 0)\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3739201,
                "title": "video-explanation-2-approaches-range-query-and-prefix-sum",
                "content": "# Explanation\\n\\n[Click here for the video](https://youtu.be/uPNVi4IG7NI)\\n\\n# Code\\n```\\ntypedef long long int ll;\\n\\nclass Solution {\\npublic:\\n    bool checkArray(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        \\n        vector<ll> arr(n, 0);\\n        ll prefix_sum = 0;\\n        \\n        for (int j = 0; j < n; j ++) {\\n            prefix_sum += arr[j];\\n            nums[j] += prefix_sum;\\n            \\n            if (nums[j] < 0) return false;\\n            if (nums[j] == 0) continue;\\n            if ((j + k) > n) return false;\\n            \\n            prefix_sum -= nums[j];\\n            if (j+k < n) arr[j+k] += nums[j];\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\ntypedef long long int ll;\\n\\nclass Solution {\\npublic:\\n    bool checkArray(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        \\n        vector<ll> arr(n, 0);\\n        ll prefix_sum = 0;\\n        \\n        for (int j = 0; j < n; j ++) {\\n            prefix_sum += arr[j];\\n            nums[j] += prefix_sum;\\n            \\n            if (nums[j] < 0) return false;\\n            if (nums[j] == 0) continue;\\n            if ((j + k) > n) return false;\\n            \\n            prefix_sum -= nums[j];\\n            if (j+k < n) arr[j+k] += nums[j];\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4054786,
                "title": "o-n-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst, instead of trying to make the array zero. try to build the array from all zeros. \\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nbase cases are trivial.\\nfor this we are gonna take a index i and every k-length subarray which starts from i is going to be increased by some value. We find this value from the original array and check if it is valid or not.\\nExplained in the code with comments.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkArray(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        if(k==1){\\n            return true;\\n        }\\n        if(n==k){\\n            for(int i=0;i<n-1;i++){\\n                if(nums[i]!=nums[i+1]){\\n                    return false;\\n                }\\n            }\\n            return true;\\n        }\\n        vector<int> v1(n,0); \\n        // starting at i to i+k-1. all elements in that\\n        // k-length window are increased by v1[i];\\n        // nums[i] = sum(v[j]) for j=i;j>i-k;j--;\\n        int m1 = n-k+1; // total length of k subarrays possible.\\n        // for i >= m1 v1[i] =0; this isn\\'t possible.\\n        int m2 = min(m1,k); \\n        // number of k-subarrays which include the first \\n        // element. for this we can get the raise by difference \\n        // between i and i-1th element. \\n        v1[0] = nums[0];\\n        for(int i=1;i<m2;i++){\\n            v1[i] = nums[i] - nums[i-1];\\n            // cout << i << \" \" << v1[i] << endl;\\n            if(v1[i] < 0) return false;\\n        }\\n        if(m1>k){\\n            for(int i=k;i<n-k+1;i++){\\n                v1[i] = nums[i] - nums[i-1] + v1[i-k]; \\n                // increase what\\'s been subtracted extra.\\n                // cout << i << \" \" << v1[i] << endl;\\n                if(v1[i] < 0) return false;\\n            }\\n        }\\n        int tmp = 0,tmp2;\\n        for(int i=max(0,n-2*k+2);i<=n-k+1;i++){\\n                tmp += v1[i];\\n        }\\n        // cout << tmp << endl;\\n        // for the tail elements, which cannot have k-subarray starting from the \\n        // current element. check whether the sums add up based on from previous \\n        // increments.\\n        for(int i=n-k+1;i<n;i++){\\n            // cout<< i << \" - \" << tmp << endl;\\n            if(tmp != nums[i]){\\n                return false;\\n            }\\n            tmp2 = ((i-k+1)<0)?0:v1[i-k+1];\\n            tmp -= tmp2;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkArray(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        if(k==1){\\n            return true;\\n        }\\n        if(n==k){\\n            for(int i=0;i<n-1;i++){\\n                if(nums[i]!=nums[i+1]){\\n                    return false;\\n                }\\n            }\\n            return true;\\n        }\\n        vector<int> v1(n,0); \\n        // starting at i to i+k-1. all elements in that\\n        // k-length window are increased by v1[i];\\n        // nums[i] = sum(v[j]) for j=i;j>i-k;j--;\\n        int m1 = n-k+1; // total length of k subarrays possible.\\n        // for i >= m1 v1[i] =0; this isn\\'t possible.\\n        int m2 = min(m1,k); \\n        // number of k-subarrays which include the first \\n        // element. for this we can get the raise by difference \\n        // between i and i-1th element. \\n        v1[0] = nums[0];\\n        for(int i=1;i<m2;i++){\\n            v1[i] = nums[i] - nums[i-1];\\n            // cout << i << \" \" << v1[i] << endl;\\n            if(v1[i] < 0) return false;\\n        }\\n        if(m1>k){\\n            for(int i=k;i<n-k+1;i++){\\n                v1[i] = nums[i] - nums[i-1] + v1[i-k]; \\n                // increase what\\'s been subtracted extra.\\n                // cout << i << \" \" << v1[i] << endl;\\n                if(v1[i] < 0) return false;\\n            }\\n        }\\n        int tmp = 0,tmp2;\\n        for(int i=max(0,n-2*k+2);i<=n-k+1;i++){\\n                tmp += v1[i];\\n        }\\n        // cout << tmp << endl;\\n        // for the tail elements, which cannot have k-subarray starting from the \\n        // current element. check whether the sums add up based on from previous \\n        // increments.\\n        for(int i=n-k+1;i<n;i++){\\n            // cout<< i << \" - \" << tmp << endl;\\n            if(tmp != nums[i]){\\n                return false;\\n            }\\n            tmp2 = ((i-k+1)<0)?0:v1[i-k+1];\\n            tmp -= tmp2;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4047823,
                "title": "not-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nno explanation , not easy solution \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nprefix sum \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkArray(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int> v(n+1,0);\\n        for(int i=0;i<n;i++){\\n            if(i==0){\\n                if(nums[i]==0) continue;\\n                v[i] = -1*nums[i];\\n                if(i+k<=n){\\n                    v[i+k] = nums[i];\\n                }\\n            }else{\\n                v[i] = v[i]+v[i-1];\\n            }\\n            int x = nums[i]+v[i];\\n            if(x<0) return false;\\n            else if(x>0){\\n                v[i] = v[i] + (-1*x);\\n                if(i+k<=n){\\n                    v[i+k] = v[i+k]+x;\\n                }\\n            }\\n        }\\n        if(v[n]+v[n-1]<0) return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkArray(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int> v(n+1,0);\\n        for(int i=0;i<n;i++){\\n            if(i==0){\\n                if(nums[i]==0) continue;\\n                v[i] = -1*nums[i];\\n                if(i+k<=n){\\n                    v[i+k] = nums[i];\\n                }\\n            }else{\\n                v[i] = v[i]+v[i-1];\\n            }\\n            int x = nums[i]+v[i];\\n            if(x<0) return false;\\n            else if(x>0){\\n                v[i] = v[i] + (-1*x);\\n                if(i+k<=n){\\n                    v[i+k] = v[i+k]+x;\\n                }\\n            }\\n        }\\n        if(v[n]+v[n-1]<0) return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3988583,
                "title": "sliding-window-array-java-o-n-video-tutorial",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n* Apply Operation from one end (here from start) \\n* At ith index , choose K size subarray and decrease the all elements by ith index value. \\n\\n# Video Tutorial (For all)\\nhttps://youtu.be/uAqmYIwCudY\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    public boolean checkArray(int[] nums, int k) {\\n        int last = 0;\\n        int n = nums.length;\\n        int[] updateValue = new int[n];\\n\\n        for (int i=0; i<n; ++i) {\\n            int curr = nums[i] + last + updateValue[i];\\n            if (curr < 0) {\\n                return false;\\n            }\\n            if (i+k < n) {\\n                updateValue[i+k] += curr;\\n            } else if (i+k > n && curr > 0) {\\n                return false;\\n            }\\n            last += updateValue[i] - curr;\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    public boolean checkArray(int[] nums, int k) {\\n        int last = 0;\\n        int n = nums.length;\\n        int[] updateValue = new int[n];\\n\\n        for (int i=0; i<n; ++i) {\\n            int curr = nums[i] + last + updateValue[i];\\n            if (curr < 0) {\\n                return false;\\n            }\\n            if (i+k < n) {\\n                updateValue[i+k] += curr;\\n            } else if (i+k > n && curr > 0) {\\n                return false;\\n            }\\n            last += updateValue[i] - curr;\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3920472,
                "title": "simple-one-iteration-solution-without-sliding-window-python-3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def checkArray(self, nums: List[int], k: int) -> bool:\\n        for i in range(0, len(nums)-k):\\n            nums[i+k] += nums[i]\\n        for i in range(0, len(nums)-1):\\n            if nums[i]>nums[i+1]:\\n                return False\\n            if i>= len(nums)-k and nums[i] != nums[i+1]:\\n                return False\\n        return True\\n        \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def checkArray(self, nums: List[int], k: int) -> bool:\\n        for i in range(0, len(nums)-k):\\n            nums[i+k] += nums[i]\\n        for i in range(0, len(nums)-1):\\n            if nums[i]>nums[i+1]:\\n                return False\\n            if i>= len(nums)-k and nums[i] != nums[i+1]:\\n                return False\\n        return True\\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3920471,
                "title": "simple-one-iteration-solution-without-sliding-window-python-3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def checkArray(self, nums: List[int], k: int) -> bool:\\n        for i in range(0, len(nums)-k):\\n            nums[i+k] += nums[i]\\n        for i in range(0, len(nums)-1):\\n            if nums[i]>nums[i+1]:\\n                return False\\n            if i>= len(nums)-k and nums[i] != nums[i+1]:\\n                return False\\n        return True\\n        \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def checkArray(self, nums: List[int], k: int) -> bool:\\n        for i in range(0, len(nums)-k):\\n            nums[i+k] += nums[i]\\n        for i in range(0, len(nums)-1):\\n            if nums[i]>nums[i+1]:\\n                return False\\n            if i>= len(nums)-k and nums[i] != nums[i+1]:\\n                return False\\n        return True\\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3844631,
                "title": "c-o-n-space-o-k-time-beats-99-93",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkArray(vector<int>& nums, int k) {\\n        if (k==1) return true;\\n\\n        auto n = nums.size();\\n        vector<int> removed(k); // Stores the amount which was already removed\\n        \\n        int l = 0;\\n        removed[0] = -nums[0];\\n        for (auto l=1 ; l<n ; l++) {\\n            removed[l%k] += nums[l-1];\\n            if (nums[l]<removed[l%k]) {\\n                return false;\\n            }\\n            removed[l%k] -= nums[l];\\n        }\\n        removed[n%k] += nums[n-1];\\n\\n        for (auto i=0 ; i<k ; i++) {\\n            if (removed[i]!=0) return false;\\n        }\\n\\n        return true;\\n    }\\n};\\n```\\n\\n# Results\\n\\n![image.png](https://assets.leetcode.com/users/images/899ecaf7-e47e-4377-b93b-aec497dc79d2_1690831100.9140112.png)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkArray(vector<int>& nums, int k) {\\n        if (k==1) return true;\\n\\n        auto n = nums.size();\\n        vector<int> removed(k); // Stores the amount which was already removed\\n        \\n        int l = 0;\\n        removed[0] = -nums[0];\\n        for (auto l=1 ; l<n ; l++) {\\n            removed[l%k] += nums[l-1];\\n            if (nums[l]<removed[l%k]) {\\n                return false;\\n            }\\n            removed[l%k] -= nums[l];\\n        }\\n        removed[n%k] += nums[n-1];\\n\\n        for (auto i=0 ; i<k ; i++) {\\n            if (removed[i]!=0) return false;\\n        }\\n\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3835823,
                "title": "javascript-brute-force-spaghetti-o-kn-time",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {boolean}\\n */\\nvar checkArray = function(nums, k) {\\n  const len = nums.length;\\n  if (len === 1) return true;\\n  let max = -Infinity;\\n  for (let i = 0; i < len; i++) {\\n    if (i <= len - k) {\\n      if (nums[i] === 0) continue;\\n      const currentMin = min(nums, i, i + k);\\n      if (currentMin) {\\n        for (let j = i; j < i+k; j++) {\\n          nums[j] -= currentMin;\\n        }\\n      }\\n    }\\n    max = Math.max(max, nums[i]);\\n  }\\n  return max === 0;\\n};\\n\\nfunction min(arr, start, end) {\\n  if (arr[end - 1] === undefined) return 0;\\n  let result = Infinity;\\n  for (let i = start; i < end; i++) {\\n    if (arr[i] < result) result = arr[i];\\n  }\\n  return result;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {boolean}\\n */\\nvar checkArray = function(nums, k) {\\n  const len = nums.length;\\n  if (len === 1) return true;\\n  let max = -Infinity;\\n  for (let i = 0; i < len; i++) {\\n    if (i <= len - k) {\\n      if (nums[i] === 0) continue;\\n      const currentMin = min(nums, i, i + k);\\n      if (currentMin) {\\n        for (let j = i; j < i+k; j++) {\\n          nums[j] -= currentMin;\\n        }\\n      }\\n    }\\n    max = Math.max(max, nums[i]);\\n  }\\n  return max === 0;\\n};\\n\\nfunction min(arr, start, end) {\\n  if (arr[end - 1] === undefined) return 0;\\n  let result = Infinity;\\n  for (let i = start; i < end; i++) {\\n    if (arr[i] < result) result = arr[i];\\n  }\\n  return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3832242,
                "title": "simple-c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkArray(vector<int>& nums, int k) {\\n        int curr=0;\\n        if(k==1){\\n           return true;\\n        }\\n        int n=nums.size();\\n        for(int i=0;i<k;i++){\\n            if(nums[i]<nums[0]){\\n                return false;\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n         \\n            if(i-k>=0){\\n             curr-=nums[i-k];\\n            }\\n            if(nums[i]<curr){\\n                return false;\\n            }\\n            if(i==(n-1)){\\n                if(nums[i]!=curr){\\n                    return false;\\n                }\\n            }\\n            nums[i]-=curr;\\n            curr+=nums[i];\\n\\n         \\n        }\\n     \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkArray(vector<int>& nums, int k) {\\n        int curr=0;\\n        if(k==1){\\n           return true;\\n        }\\n        int n=nums.size();\\n        for(int i=0;i<k;i++){\\n            if(nums[i]<nums[0]){\\n                return false;\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n         \\n            if(i-k>=0){\\n             curr-=nums[i-k];\\n            }\\n            if(nums[i]<curr){\\n                return false;\\n            }\\n            if(i==(n-1)){\\n                if(nums[i]!=curr){\\n                    return false;\\n                }\\n            }\\n            nums[i]-=curr;\\n            curr+=nums[i];\\n\\n         \\n        }\\n     \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3800264,
                "title": "c-time-o-n-space-o-1-with-explanation",
                "content": "# Intuition\\n1) Slide the window from left to right, keeping track of the accumulated decrease value of the k - 1 previous windows (`dec`).\\n2) `i` is the *left* side of the window, hense this is the last chance of decrease the current element to 0 (since all other windows containing `nums[i]` have already been processed). The proof would be nums[0], which only partakes in 1 window => we start from it and work our way to the right so:\\n* if `nums[i] - dec < 0`, we cannot fulfill the requirement, as any value < dec will leave some of the previous elements positive\\n* if  `nums[i] - dec > 0` in the RIGHTMOST window, we also return false, as we can no longer accumulate `dec` due to lack of windows to the right, and we `dec` to decrease all elements in the rightmost windows to 0.\\n\\n# Complexity\\n- Time complexity: O(N)\\n- Space complexity: O(1)\\n```\\nclass Solution {\\npublic:\\n    bool checkArray(vector<int>& nums, int k) \\n    {\\n        int dec{ 0 };\\n        for (size_t i{ 0 }; i < nums.size(); ++i)\\n        {\\n            if (i >= k)\\n                dec -= nums[i - k];\\n\\n            nums[i] -= dec;\\n            if (nums[i] < 0)\\n                return false;\\n\\n            if (i + k <= nums.size())\\n                dec += nums[i];\\n            else if (nums[i] != 0)\\n                return false;\\n        }\\n\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkArray(vector<int>& nums, int k) \\n    {\\n        int dec{ 0 };\\n        for (size_t i{ 0 }; i < nums.size(); ++i)\\n        {\\n            if (i >= k)\\n                dec -= nums[i - k];\\n\\n            nums[i] -= dec;\\n            if (nums[i] < 0)\\n                return false;\\n\\n            if (i + k <= nums.size())\\n                dec += nums[i];\\n            else if (nums[i] != 0)\\n                return false;\\n        }\\n\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3799199,
                "title": "c-prefix-sum",
                "content": "# Approach\\nPefix sum. \\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkArray(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        int i=0;\\n        int j=1;\\n        vector<int> arr(n+2);\\n        while(i<nums.size()) {\\n            if(i!=0)arr[i]+=arr[i-1];\\n            if(nums[i]<arr[i])return false;\\n            if(nums[i]==arr[i]) {i++; continue;}\\n            int p = nums[i]-arr[i];\\n            if(i+k>n)return false;\\n            arr[i]+=p;\\n            arr[i+k]-=p;\\n            i++;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkArray(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        int i=0;\\n        int j=1;\\n        vector<int> arr(n+2);\\n        while(i<nums.size()) {\\n            if(i!=0)arr[i]+=arr[i-1];\\n            if(nums[i]<arr[i])return false;\\n            if(nums[i]==arr[i]) {i++; continue;}\\n            int p = nums[i]-arr[i];\\n            if(i+k>n)return false;\\n            arr[i]+=p;\\n            arr[i+k]-=p;\\n            i++;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3798365,
                "title": "easy-solution",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    bool check(vector<int> &nums,int k)\\n    {\\n        if(nums.size()==1 || k==1)\\n            return 1;\\n        queue<int>q;\\n        int sum=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums.size()-1==i)\\n            {\\n                if(sum!=nums[i])\\n                    return 0;\\n                \\n            }\\n            if(sum>nums[i])\\n                return 0;\\n            else\\n                nums[i]-=sum;\\n            q.push(nums[i]);\\n            sum+=nums[i];\\n            if(q.size()==k)\\n            {\\n                sum-=q.front();\\n                q.pop();\\n            }\\n        }\\n        return 1;\\n    }\\n    bool checkArray(vector<int>& nums, int k) {\\n       int a=check(nums,k);\\n        return a;\\n        \\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(vector<int> &nums,int k)\\n    {\\n        if(nums.size()==1 || k==1)\\n            return 1;\\n        queue<int>q;\\n        int sum=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums.size()-1==i)\\n            {\\n                if(sum!=nums[i])\\n                    return 0;\\n                \\n            }\\n            if(sum>nums[i])\\n                return 0;\\n            else\\n                nums[i]-=sum;\\n            q.push(nums[i]);\\n            sum+=nums[i];\\n            if(q.size()==k)\\n            {\\n                sum-=q.front();\\n                q.pop();\\n            }\\n        }\\n        return 1;\\n    }\\n    bool checkArray(vector<int>& nums, int k) {\\n       int a=check(nums,k);\\n        return a;\\n        \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3794594,
                "title": "best-explanation-so-far",
                "content": "If you on my level of IQ, you probably find this helpful. All solutions for this problems which people mention (Prefix Sub/Queue, Backtrack tracking) are based on the next idea. \\n\\n\\nStarting at some index and moving to the right: \\n- When you see any number(let\\'s say N) greater than 0, **the only one way where solution exist is to decrese this number to 0** (by subtracting N). \\n- When subtracting by N, you need to ensure that all rightmost element in window can be subtracted by N as well (not leading to negative number)\\n\\n\\n*It\\'s natural to think that order, where you start decreseasing the window - matters (Example 3 below). However solution for the problems is based on different intuition.*\\n\\n```\\n[2,2,3,1,1,0] k=3\\n\\tIndex 0. From this index subtract Number 2 from all numbers from the Index till Index + Window\\n\\t\\tResult: [0,0,1,1,1,0]\\n\\tIndex 1 (No Changes) \\n\\t\\tResult: [0,0,1,1,1,0]\\n\\tIndex 2 From this index subtract Number 1 from all numbers from the Index till Index + Window\\n\\t\\tResult [0,0,0,0,0,0]\\n\\t....\\n\\n[1,2,3,2,1,0] k=3\\n\\tIndex 0: From this index subtract Number 1 from all numbers from the Index till Index + Window\\n\\t\\tResult: [0,1,2,2,1,0]\\n\\tIndex 1: From this index subtract Number 1 from all numbers from the Index till Index + Window\\n\\t\\tResult: [0,0,1,1,1,0]\\n\\tIndex 2: From this index subtract Number 1 from all numbers from the Index till Index + Window\\n\\t\\tResult [0,0,0,0,0,0]\\n\\t....\\n\\n\\n[1,1,3,3,3,1]\\n\\tIndex 0: From this index subtract Number 1 from all numbers from the Index till Index + Window\\n\\t\\tResult: [0,0,2,3,3,1]\\n\\tIndex 1: (No Changes)\\n\\tIndex 2: From this index subtract Number 2 from all numbers from the Index till Index + Window\\n\\t\\tResult: [0,0,0,1,1,1]\\n\\t....\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```\\n[2,2,3,1,1,0] k=3\\n\\tIndex 0. From this index subtract Number 2 from all numbers from the Index till Index + Window\\n\\t\\tResult: [0,0,1,1,1,0]\\n\\tIndex 1 (No Changes) \\n\\t\\tResult: [0,0,1,1,1,0]\\n\\tIndex 2 From this index subtract Number 1 from all numbers from the Index till Index + Window\\n\\t\\tResult [0,0,0,0,0,0]\\n\\t....\\n\\n[1,2,3,2,1,0] k=3\\n\\tIndex 0: From this index subtract Number 1 from all numbers from the Index till Index + Window\\n\\t\\tResult: [0,1,2,2,1,0]\\n\\tIndex 1: From this index subtract Number 1 from all numbers from the Index till Index + Window\\n\\t\\tResult: [0,0,1,1,1,0]\\n\\tIndex 2: From this index subtract Number 1 from all numbers from the Index till Index + Window\\n\\t\\tResult [0,0,0,0,0,0]\\n\\t....\\n\\n\\n[1,1,3,3,3,1]\\n\\tIndex 0: From this index subtract Number 1 from all numbers from the Index till Index + Window\\n\\t\\tResult: [0,0,2,3,3,1]\\n\\tIndex 1: (No Changes)\\n\\tIndex 2: From this index subtract Number 2 from all numbers from the Index till Index + Window\\n\\t\\tResult: [0,0,0,1,1,1]\\n\\t....\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3786231,
                "title": "new-concept-sliding-window-impact-preserve-learn-new-today",
                "content": "# Intuition # Approach\\n// used the approach to start from each window of size k and then subtracting each element from the starting element of each window \\n// if any element is negative then return false\\n// but this O(n*k-1) times and this create time limit excedded\\n// to make it optimal ---> I tried this approach\\n\\n// very well expalained in detail\\n// imagine you are standing in the middle of the array \\n// and we are  decreasing each elememt of window k with starting element of window ---> starting from left and approaching you    [2,2,3,1,1,0] \\n// so sum = impact  ****** \\n// so the impact on the element i am standing is the sum of all k-1 previous elements\\n// so to bear that impact \\n// element must be greater than that impact first of all----> ( first if condition )\\n// if it is greater so element becomes now --->  (nums[i]) - impact(sum) \\n// now create your own imapact which is equal to your own value \\n// and adding that impact in sum\\n// if an case that the impact of previous k element is loosed so decrease that impact from sum \\n    // sum -=nums[i-k+1];\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkArray(vector<int>& nums, int k) {\\n        int sum = 0;  // impact\\n        for(int i = 0;i<nums.size();++i)\\n        {\\n            if(sum > nums[i])\\n                return false;\\n            \\n            nums[i] -= sum;\\n            sum += nums[i];\\n\\n            if(i >= k-1)\\n                sum -= nums[i-k+1];\\n        }\\n        return sum == 0;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkArray(vector<int>& nums, int k) {\\n        int sum = 0;  // impact\\n        for(int i = 0;i<nums.size();++i)\\n        {\\n            if(sum > nums[i])\\n                return false;\\n            \\n            nums[i] -= sum;\\n            sum += nums[i];\\n\\n            if(i >= k-1)\\n                sum -= nums[i-k+1];\\n        }\\n        return sum == 0;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3786104,
                "title": "sliding-window-protocol-prefix-sum-commented-code",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n\\n    // prefix sum + sliding window\\n    bool checkArray(vector<int>& nums, int k) {\\n        int n = nums.size();\\n\\n        // temp = value that is to be decreased from the current element and next k-1 elements to make  \\n        // current element 0.\\n        int temp = 0;\\n        for(int i=0 ; i<n ; i++){\\n            // if temp > nums[i] that means nums[i] will get descreased to negative, hence return fasle.\\n            if(nums[i] < temp){\\n                return false;\\n            }\\n            // else nums[i] will get decreased by temp.\\n            nums[i] -= temp;\\n            // still nums[i]!=0 then add it to temp for future.\\n            if(nums[i]!=0){\\n                temp += nums[i];\\n            }\\n            // slide the window to next k elements.\\n            if(i+1>=k){\\n                temp-=nums[i+1-k];\\n            }\\n        }\\n        // if temp == 0 , that means there is no element left to be decreased to 0\\n        if(temp!=0){\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    // prefix sum + sliding window\\n    bool checkArray(vector<int>& nums, int k) {\\n        int n = nums.size();\\n\\n        // temp = value that is to be decreased from the current element and next k-1 elements to make  \\n        // current element 0.\\n        int temp = 0;\\n        for(int i=0 ; i<n ; i++){\\n            // if temp > nums[i] that means nums[i] will get descreased to negative, hence return fasle.\\n            if(nums[i] < temp){\\n                return false;\\n            }\\n            // else nums[i] will get decreased by temp.\\n            nums[i] -= temp;\\n            // still nums[i]!=0 then add it to temp for future.\\n            if(nums[i]!=0){\\n                temp += nums[i];\\n            }\\n            // slide the window to next k elements.\\n            if(i+1>=k){\\n                temp-=nums[i+1-k];\\n            }\\n        }\\n        // if temp == 0 , that means there is no element left to be decreased to 0\\n        if(temp!=0){\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3779745,
                "title": "array-prefixsum",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public boolean checkArray(int[] nums, int k) {\\n        int len = nums.length;\\n        long[] arr = new long[len];\\n        long prefixSum = 0;\\n        for (int j = 0; j < len; j++) {\\n            prefixSum += arr[j];\\n            nums[j] += prefixSum;\\n            if (nums[j] < 0) return false;\\n            if (nums[j] == 0) continue;\\n            if ((j + k) > len) return false;\\n            prefixSum -= nums[j];\\n            if (j + k < len) arr[j + k] += nums[j];\\n        }\\n        return true;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkArray(int[] nums, int k) {\\n        int len = nums.length;\\n        long[] arr = new long[len];\\n        long prefixSum = 0;\\n        for (int j = 0; j < len; j++) {\\n            prefixSum += arr[j];\\n            nums[j] += prefixSum;\\n            if (nums[j] < 0) return false;\\n            if (nums[j] == 0) continue;\\n            if ((j + k) > len) return false;\\n            prefixSum -= nums[j];\\n            if (j + k < len) arr[j + k] += nums[j];\\n        }\\n        return true;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3777997,
                "title": "short-and-easy-to-understand-code-using-prefix-array-o-n-c",
                "content": "\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#include <bits/stdc++.h>\\n\\n#define all(v) v.begin(), v.end()\\n\\nclass Solution {\\npublic:\\n    bool checkArray(vector<int>& a, int k) {\\n        int n=a.size();\\n        vector<int> pf(n);\\n        for(int i=0; i<n; ++i){\\n            if(i!=0) pf[i] += pf[i-1], a[i] += pf[i];\\n            if(a[i] > 0) {\\n                if(i+k-1<n){\\n                    pf[i] -= a[i];\\n                    if(i+k<n) pf[i+k] += a[i];\\n                    a[i] = 0;\\n                }\\n                else return false;\\n            }\\n            else if(a[i] < 0) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include <bits/stdc++.h>\\n\\n#define all(v) v.begin(), v.end()\\n\\nclass Solution {\\npublic:\\n    bool checkArray(vector<int>& a, int k) {\\n        int n=a.size();\\n        vector<int> pf(n);\\n        for(int i=0; i<n; ++i){\\n            if(i!=0) pf[i] += pf[i-1], a[i] += pf[i];\\n            if(a[i] > 0) {\\n                if(i+k-1<n){\\n                    pf[i] -= a[i];\\n                    if(i+k<n) pf[i+k] += a[i];\\n                    a[i] = 0;\\n                }\\n                else return false;\\n            }\\n            else if(a[i] < 0) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3771720,
                "title": "c-segment-tree-o-nlogn-prefix-sum-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    //*supports range addition\\nclass SegmentTree\\n{\\n    class Node\\n    {\\n    public:\\n        long long val; //*value of the node\\n        long long addVal; //*value to be added to the range (range update) -> Lazy Propagation\\n\\n        Node *left, *right; //*left child and right child\\n        int low, high; //*this node stores the value of arr[low...high]\\n\\n    public:\\n        Node(int val = -1, Node *left = nullptr, Node *right = nullptr, int low = -1, int high = -1) \\n            : val(val), addVal(0), left(left), right(right), low(low), high(high)\\n        {}\\n    };\\n\\n\\nprivate:\\n    //*root of the segment tree\\n    Node *root;\\n\\n    //*mutable array reference (SegmentTree Object will not modify the arr)\\n    const vector<long long> &arr;\\n    \\n    //*size of the array\\n    int n;\\n\\n    //*combine function\\n    std::function<int(int,int)> combine;\\n\\n\\npublic:\\n    SegmentTree(const vector<long long> &arr, const std::function<int(int,int)>& combine) : arr(arr), combine(combine)\\n    {\\n        n = arr.size();\\n        root = buildTree(0, n-1);\\n    }\\n\\n\\n\\n    //*returns the range query value of arr[queryLow, queryHigh]\\n    int rangeQuery(int queryLow, int queryHigh)\\n    {\\n        return rangeQueryHelper(root, queryLow, queryHigh);\\n    }\\n\\n    //*changes the value of arr[pos] to newVal\\n    void update(int pos, int newVal)\\n    {\\n        updateHelper(root, pos, newVal);\\n    }\\n\\n    //*adds the <val> to all element in the range arr[qlow...qhigh]\\n    void rangeAddition(int qlow, int qhigh, int val)\\n    {\\n        rangeAdditionHelper(root, qlow, qhigh, val);\\n    }\\n\\nprivate:\\n\\n\\n    // //*TODO: pass the combine() function to the constructor\\n    // //*combines the values of 2 segments \\n    // int combine(int val1, int val2)\\n    // {\\n    //     return min(val1, val2);\\n    // } \\n\\n\\n\\n    //*builds segment tree for arr[low...high] and returns the root of the tree\\n    Node *buildTree(int low, int high)\\n    {\\n        Node *root = new Node();\\n        root->low = low;\\n        root->high = high;\\n\\n        //*for leaf node\\n        if(low == high)\\n        {\\n            //*TODO: write function for leaf values\\n            root->val = arr[low];\\n            return root;\\n        }\\n\\n        int mid = low + (high - low)/2;\\n        root->left = buildTree(low, mid);\\n        root->right = buildTree(mid+1, high);\\n\\n        //*get the value of current node by combining values of left and right child\\n        root->val = combine(root->left->val, root->right->val);\\n\\n        return root;\\n    }\\n\\n\\n    //*rangeQueryHelper(qlow, qhigh) = returns the value of the range query [qlow, qhigh] from the segment tree rooted at <root> \\n    long long rangeQueryHelper(Node* root, int qlow, int qhigh)\\n    {\\n        //*if current tree segment is outside query segment\\n        if(root->low > qhigh || root->high < qlow)\\n            return LONG_LONG_MIN;\\n\\n        long long res = 0;\\n\\n        //*leaf node, or, if tree segment equals query segment\\n        if(root->low == root->high || (root->low == qlow && root->high == qhigh))\\n            res = root->val;\\n        else\\n        {\\n            int mid = root->low + (root->high - root->low)/2;\\n\\n            //*if query segment lies in one of the 2 children\\n            if(qhigh <= mid)\\n                res = rangeQueryHelper(root->left, qlow, qhigh);\\n            else if(qlow >= mid+1)\\n                res = rangeQueryHelper(root->right, qlow, qhigh);\\n\\n            //*else if the 2 children segments overlap with the query segment, then answer is to be combined from both subtrees\\n            else //*if(qlow <= mid && qhigh >= mid+1)\\n            {\\n                long long leftVal = rangeQueryHelper(root->left, qlow, mid);\\n                long long rightVal = rangeQueryHelper(root->right, mid+1, qhigh);\\n                \\n                if(leftVal == LONG_LONG_MIN || rightVal == LONG_LONG_MIN)\\n                    return LONG_LONG_MIN;\\n                    \\n                res = combine(leftVal, rightVal);\\n            }\\n        }\\n\\n        //*add the value to be added to the range [Lazy Propagation]\\n        if(root->addVal != 0)\\n            res += (qhigh - qlow + 1) * root->addVal;\\n\\n        return res;\\n    }\\n\\n \\n\\n    //*updates the value of arr[pos] to newVal, in the segment tree rooted at <root>\\n    void updateHelper(Node *root, int pos, long long newVal)\\n    {\\n        //*for leaf \\n        if(root->low == root->high)\\n        {\\n            root->val = newVal;\\n            return;\\n        }\\n\\n        //*update that subtree, in which the arr[pos] exists\\n        int mid = root->low + (root->high - root->low)/2;\\n        if(pos <= mid)\\n            updateHelper(root->left, pos, newVal);\\n        else\\n            updateHelper(root->right, pos, newVal);\\n\\n        //*update the value of the current node\\n        root->val = combine(root->left->val, root->right->val);        \\n    }\\n\\n\\n    //*rangeAddition(root, qlow, qhigh, val) -> \\n    //*adds <val> to all elements in the range arr[qlow...qhigh] in the segment tree rooted at <root> \\n    void rangeAdditionHelper(Node *root, int qlow, int qhigh, long long val)\\n    {\\n        //*leaf node, or, if tree segment equals query segment\\n        if(root->low == root->high || (root->low == qlow && root->high == qhigh))\\n        {\\n            root->addVal += val;\\n            return;\\n        }\\n\\n        int mid = root->low + (root->high - root->low)/2;\\n        if(qhigh <= mid)\\n            rangeAdditionHelper(root->left, qlow, qhigh, val);\\n        else if(qlow >= mid+1)\\n            rangeAdditionHelper(root->right, qlow, qhigh, val);\\n\\n        //*else if the 2 children segments overlap with the query segment,\\n        else //*if(qlow <= mid && qhigh >= mid+1)\\n        {\\n            rangeAdditionHelper(root->left, qlow, mid, val);\\n            rangeAdditionHelper(root->right, mid+1, qhigh, val);\\n        }\\n    } \\n\\n};\\n\\n\\n    static long long sum(long long val1, long long val2)\\n    {\\n        return val1 + val2;\\n    }\\n\\npublic:\\n    bool checkArray(vector<int>& arr, int k) {\\n        int n = arr.size();\\n        \\n        if(k == 1)\\n            return true;\\n        \\n        \\n\\n        //*==========================METHOD 0: BRUTE FORCE=======================================\\n        // for(int i = 0; i<n; i++)\\n        // {\\n        //     int x = a[i];\\n\\n        //     if((x<0) || (x > 0 && i+k-1 >= n))\\n        //         return false;\\n\\n        //     //update the range arr[i...(i+k-1)]\\n        //     for(int j = i; j<= i+k-1; j++)\\n        //         arr[j] -= x;\\n        // }\\n\\n\\n\\n\\n\\n        // //*=============== Metdho 1: IMPROVE THE RANGE UPDATE USING SEGMENT TREE================================\\n        // vector<long long> a(n);\\n        // for(int i = 0; i<n; i++)\\n        //     a[i] = arr[i];\\n\\n        // SegmentTree st(a, sum);\\n        \\n        // for(int i = 0; i<n; i++)\\n        // {\\n        //     int x = st.rangeQuery(i,i); //x = a[i]\\n        //     // cout<<\"i = \"<<i<<\", x = \"<<x<<endl;\\n\\n        //     if((x<0) || (x > 0 && i+k-1 >= n))\\n        //         return false;\\n\\n        //     st.rangeAddition(i, i+k-1, -x);\\n        // }\\n\\n\\n\\n\\n\\n\\n        //*=====================Method 2: improve the range update using prefix sum==========================\\n        //* similiar to : https://leetcode.com/problems/shifting-letters-ii/\\n        vector<int> aux(n, 0);\\n        int change = 0; //prefix sum of aux[i]\\n        for(int i = 0; i<n; i++)\\n        {\\n            change += aux[i];\\n            int x = arr[i] + change;\\n\\n            if((x<0) || (x > 0 && i+k-1 >= n))\\n                return false;\\n\\n            \\n            //update the range arr[i...(i+k-1)]\\n            change += (-x);\\n            if(i+k < n)\\n                aux[i+k] -= (-x);\\n\\n        }\\n\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    //*supports range addition\\nclass SegmentTree\\n{\\n    class Node\\n    {\\n    public:\\n        long long val; //*value of the node\\n        long long addVal; //*value to be added to the range (range update) -> Lazy Propagation\\n\\n        Node *left, *right; //*left child and right child\\n        int low, high; //*this node stores the value of arr[low...high]\\n\\n    public:\\n        Node(int val = -1, Node *left = nullptr, Node *right = nullptr, int low = -1, int high = -1) \\n            : val(val), addVal(0), left(left), right(right), low(low), high(high)\\n        {}\\n    };\\n\\n\\nprivate:\\n    //*root of the segment tree\\n    Node *root;\\n\\n    //*mutable array reference (SegmentTree Object will not modify the arr)\\n    const vector<long long> &arr;\\n    \\n    //*size of the array\\n    int n;\\n\\n    //*combine function\\n    std::function<int(int,int)> combine;\\n\\n\\npublic:\\n    SegmentTree(const vector<long long> &arr, const std::function<int(int,int)>& combine) : arr(arr), combine(combine)\\n    {\\n        n = arr.size();\\n        root = buildTree(0, n-1);\\n    }\\n\\n\\n\\n    //*returns the range query value of arr[queryLow, queryHigh]\\n    int rangeQuery(int queryLow, int queryHigh)\\n    {\\n        return rangeQueryHelper(root, queryLow, queryHigh);\\n    }\\n\\n    //*changes the value of arr[pos] to newVal\\n    void update(int pos, int newVal)\\n    {\\n        updateHelper(root, pos, newVal);\\n    }\\n\\n    //*adds the <val> to all element in the range arr[qlow...qhigh]\\n    void rangeAddition(int qlow, int qhigh, int val)\\n    {\\n        rangeAdditionHelper(root, qlow, qhigh, val);\\n    }\\n\\nprivate:\\n\\n\\n    // //*TODO: pass the combine() function to the constructor\\n    // //*combines the values of 2 segments \\n    // int combine(int val1, int val2)\\n    // {\\n    //     return min(val1, val2);\\n    // } \\n\\n\\n\\n    //*builds segment tree for arr[low...high] and returns the root of the tree\\n    Node *buildTree(int low, int high)\\n    {\\n        Node *root = new Node();\\n        root->low = low;\\n        root->high = high;\\n\\n        //*for leaf node\\n        if(low == high)\\n        {\\n            //*TODO: write function for leaf values\\n            root->val = arr[low];\\n            return root;\\n        }\\n\\n        int mid = low + (high - low)/2;\\n        root->left = buildTree(low, mid);\\n        root->right = buildTree(mid+1, high);\\n\\n        //*get the value of current node by combining values of left and right child\\n        root->val = combine(root->left->val, root->right->val);\\n\\n        return root;\\n    }\\n\\n\\n    //*rangeQueryHelper(qlow, qhigh) = returns the value of the range query [qlow, qhigh] from the segment tree rooted at <root> \\n    long long rangeQueryHelper(Node* root, int qlow, int qhigh)\\n    {\\n        //*if current tree segment is outside query segment\\n        if(root->low > qhigh || root->high < qlow)\\n            return LONG_LONG_MIN;\\n\\n        long long res = 0;\\n\\n        //*leaf node, or, if tree segment equals query segment\\n        if(root->low == root->high || (root->low == qlow && root->high == qhigh))\\n            res = root->val;\\n        else\\n        {\\n            int mid = root->low + (root->high - root->low)/2;\\n\\n            //*if query segment lies in one of the 2 children\\n            if(qhigh <= mid)\\n                res = rangeQueryHelper(root->left, qlow, qhigh);\\n            else if(qlow >= mid+1)\\n                res = rangeQueryHelper(root->right, qlow, qhigh);\\n\\n            //*else if the 2 children segments overlap with the query segment, then answer is to be combined from both subtrees\\n            else //*if(qlow <= mid && qhigh >= mid+1)\\n            {\\n                long long leftVal = rangeQueryHelper(root->left, qlow, mid);\\n                long long rightVal = rangeQueryHelper(root->right, mid+1, qhigh);\\n                \\n                if(leftVal == LONG_LONG_MIN || rightVal == LONG_LONG_MIN)\\n                    return LONG_LONG_MIN;\\n                    \\n                res = combine(leftVal, rightVal);\\n            }\\n        }\\n\\n        //*add the value to be added to the range [Lazy Propagation]\\n        if(root->addVal != 0)\\n            res += (qhigh - qlow + 1) * root->addVal;\\n\\n        return res;\\n    }\\n\\n \\n\\n    //*updates the value of arr[pos] to newVal, in the segment tree rooted at <root>\\n    void updateHelper(Node *root, int pos, long long newVal)\\n    {\\n        //*for leaf \\n        if(root->low == root->high)\\n        {\\n            root->val = newVal;\\n            return;\\n        }\\n\\n        //*update that subtree, in which the arr[pos] exists\\n        int mid = root->low + (root->high - root->low)/2;\\n        if(pos <= mid)\\n            updateHelper(root->left, pos, newVal);\\n        else\\n            updateHelper(root->right, pos, newVal);\\n\\n        //*update the value of the current node\\n        root->val = combine(root->left->val, root->right->val);        \\n    }\\n\\n\\n    //*rangeAddition(root, qlow, qhigh, val) -> \\n    //*adds <val> to all elements in the range arr[qlow...qhigh] in the segment tree rooted at <root> \\n    void rangeAdditionHelper(Node *root, int qlow, int qhigh, long long val)\\n    {\\n        //*leaf node, or, if tree segment equals query segment\\n        if(root->low == root->high || (root->low == qlow && root->high == qhigh))\\n        {\\n            root->addVal += val;\\n            return;\\n        }\\n\\n        int mid = root->low + (root->high - root->low)/2;\\n        if(qhigh <= mid)\\n            rangeAdditionHelper(root->left, qlow, qhigh, val);\\n        else if(qlow >= mid+1)\\n            rangeAdditionHelper(root->right, qlow, qhigh, val);\\n\\n        //*else if the 2 children segments overlap with the query segment,\\n        else //*if(qlow <= mid && qhigh >= mid+1)\\n        {\\n            rangeAdditionHelper(root->left, qlow, mid, val);\\n            rangeAdditionHelper(root->right, mid+1, qhigh, val);\\n        }\\n    } \\n\\n};\\n\\n\\n    static long long sum(long long val1, long long val2)\\n    {\\n        return val1 + val2;\\n    }\\n\\npublic:\\n    bool checkArray(vector<int>& arr, int k) {\\n        int n = arr.size();\\n        \\n        if(k == 1)\\n            return true;\\n        \\n        \\n\\n        //*==========================METHOD 0: BRUTE FORCE=======================================\\n        // for(int i = 0; i<n; i++)\\n        // {\\n        //     int x = a[i];\\n\\n        //     if((x<0) || (x > 0 && i+k-1 >= n))\\n        //         return false;\\n\\n        //     //update the range arr[i...(i+k-1)]\\n        //     for(int j = i; j<= i+k-1; j++)\\n        //         arr[j] -= x;\\n        // }\\n\\n\\n\\n\\n\\n        // //*=============== Metdho 1: IMPROVE THE RANGE UPDATE USING SEGMENT TREE================================\\n        // vector<long long> a(n);\\n        // for(int i = 0; i<n; i++)\\n        //     a[i] = arr[i];\\n\\n        // SegmentTree st(a, sum);\\n        \\n        // for(int i = 0; i<n; i++)\\n        // {\\n        //     int x = st.rangeQuery(i,i); //x = a[i]\\n        //     // cout<<\"i = \"<<i<<\", x = \"<<x<<endl;\\n\\n        //     if((x<0) || (x > 0 && i+k-1 >= n))\\n        //         return false;\\n\\n        //     st.rangeAddition(i, i+k-1, -x);\\n        // }\\n\\n\\n\\n\\n\\n\\n        //*=====================Method 2: improve the range update using prefix sum==========================\\n        //* similiar to : https://leetcode.com/problems/shifting-letters-ii/\\n        vector<int> aux(n, 0);\\n        int change = 0; //prefix sum of aux[i]\\n        for(int i = 0; i<n; i++)\\n        {\\n            change += aux[i];\\n            int x = arr[i] + change;\\n\\n            if((x<0) || (x > 0 && i+k-1 >= n))\\n                return false;\\n\\n            \\n            //update the range arr[i...(i+k-1)]\\n            change += (-x);\\n            if(i+k < n)\\n                aux[i+k] -= (-x);\\n\\n        }\\n\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3769979,
                "title": "o-n-sliding-window",
                "content": "```\\nclass Solution:\\n    # Time: O(n) | Space: O(n)\\n    def checkArray(self, nums: List[int], k: int) -> bool:\\n        n = len(nums)\\n        deltas = [0] * n\\n        decreased = 0\\n        for i in range(n):\\n            decreased -= deltas[i] # Remove the outdated window\\n            actual = nums[i] - decreased \\n            if actual < 0 or (actual > 0 and i + k - 1 >= n):\\n                return False\\n            decreased += actual\\n            if i + k < n:\\n                deltas[i + k] += actual\\n        return True       \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    # Time: O(n) | Space: O(n)\\n    def checkArray(self, nums: List[int], k: int) -> bool:\\n        n = len(nums)\\n        deltas = [0] * n\\n        decreased = 0\\n        for i in range(n):\\n            decreased -= deltas[i] # Remove the outdated window\\n            actual = nums[i] - decreased \\n            if actual < 0 or (actual > 0 and i + k - 1 >= n):\\n                return False\\n            decreased += actual\\n            if i + k < n:\\n                deltas[i + k] += actual\\n        return True       \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3768518,
                "title": "easy-to-understand-bruteforc-y-but-it-passes",
                "content": "# Intuition\\nIntuition here is that the subarray of size k should be either flat or increasing, ie not decreasing.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nif subarray is not decreasing, reduce each element by the first element in this subarray (ie, the smallest element since it is decreasing). Advance to the next non zero element and start from it and move k steps forward reducing each el by the val of the start of this subarray element.\\n\\n# Complexity\\n- Time complexity:\\nO(n * k) where n is the number of elements in the nums array, and m is the number of elements in the subarray of max size being k.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- constant space complexity, since we only store primitive values\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {boolean}\\n */\\nvar checkArray = function(nums, k) {\\n    const n = nums.length;\\n    let i = 0\\n\\n    while (i < n) {\\n        let cnt = 0, r = i, num = nums[i];\\n        while (cnt < k && r < n) {\\n            if (r > 0 && nums[r] < nums[r-1]) return false;\\n            cnt++;\\n            nums[r]-=num;\\n            r++;\\n        }\\n        let j = i;\\n        while (nums[j] === 0) j++;\\n        i = j;\\n        if (i < n && n - i < k) return false;\\n    }\\n\\n    return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {boolean}\\n */\\nvar checkArray = function(nums, k) {\\n    const n = nums.length;\\n    let i = 0\\n\\n    while (i < n) {\\n        let cnt = 0, r = i, num = nums[i];\\n        while (cnt < k && r < n) {\\n            if (r > 0 && nums[r] < nums[r-1]) return false;\\n            cnt++;\\n            nums[r]-=num;\\n            r++;\\n        }\\n        let j = i;\\n        while (nums[j] === 0) j++;\\n        i = j;\\n        if (i < n && n - i < k) return false;\\n    }\\n\\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3767880,
                "title": "operations-solution",
                "content": "# Approach 1 - Double Loops\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nNote that the order in which subarrays receive operations does not matter. All that matters is which subarrays are chosen and how many times they receive the decrement operation. With order not affecting the solution, it makes sense to process the subarrays from left to the right for convenience.\\n\\nThe idea is to turn the elements into zero from left to right. Have `i` iterate over range `0 <= i < nums.length`. When `i <= nums.length-k`, it is the leftmost element of subarray `nums[i:i+k-1]`. Examine `nums[i]`: \\n- If `nums[i] = 0`, visit the next subarray\\n- If `nums[i] > 0`, apply the operation to the subarray `nums[i]` times. This can be done by using a second loop to subtract `nums[i]` from elements `i` to `i+k-1`.\\n- If `nums[i] < 0`, return false. It is not possible to make elements to the left of `i` zero without making `nums[i]` negative.\\n\\nWhen `i > nums.length-k`, it is not the the leftmost element of a `k` length subarray which means no more operations should be made. For those `i`, simply check if `nums[i] = 0`. If `nums[i]` is nonzero return false. If all values `i` finish processing, it means the operations transformed the elements into zero without a hitch. Return true at the end of the code! \\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    bool checkArray(vector<int>& nums, const int& k) {\\n        for (int i = 0; i < nums.size(); i++) {\\n            if (nums[i] == 0) {\\n                continue;\\n            }\\n            if (nums[i] < 0) {\\n                return false;\\n            }\\n            if (i > nums.size() - k && nums[i] != 0) {\\n                return false;\\n            }\\n\\n            const int operations = nums[i];\\n\\n            for (int j = i; j < i+k; j++) {\\n                nums[j] -= operations;\\n            }\\n        }\\n\\n        return true;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public boolean checkArray(int[] nums, int k) {\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == 0) {\\n                continue;\\n            }\\n            if (nums[i] < 0) {\\n                return false;\\n            }\\n            if (i > nums.length - k && nums[i] != 0) {\\n                return false;\\n            }\\n\\n            final int operations = nums[i];\\n\\n            for (int j = i; j < i+k; j++) {\\n                nums[j] -= operations;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```\\n```Python3 []\\nclass Solution:\\n    def checkArray(self, nums: List[int], k: int) -> bool:\\n        for i in range(len(nums)):\\n            if nums[i] == 0:\\n                continue\\n            if nums[i] < 0:\\n                return False\\n            if i > len(nums) - k and nums[i] != 0:\\n                return False\\n\\n            operations = nums[i]\\n\\n            for j in range(i, i+k):\\n                nums[j] -= operations\\n        \\n        return True\\n```\\n\\n# Complexity\\n\\nLet $$n$$ be the length of `nums`\\n- Time complexity: $$O(n\\\\cdot{k})$$\\n    - All $$n$$ elements of `nums` are visited\\n    - For each `i`, up to $$k$$ subarray elements undergo subtraction\\n    - Total time is $$n\\\\cdot{O(k)=O(n\\\\cdot{k})}$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n    - All the primitive variables take up constant space\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Approach 2 - Queue\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nInsteading of subtracting from `nums` in chunks of `k`, it is possible to subtract once per element. This can be done using a queue.\\n\\nLet `opQueue` be a queue that stores the number of operations used in each of the previous `k-1` subarrays. Let\\'s look at Example 1 for an idea of what the queue should look like:\\n```\\nnums = [2,2,3,1,1,0], k = 3\\nopQueue = {}      nums = [(2),2,3,1,1,0]\\nopQueue = {2}     nums = [0,(0),1,1,1,0] \\nopQueue = {2,0}   nums = [0,0,(1),1,1,0]\\nopQueue = {0,1}   nums = [0,0,0,(0),0,0]\\nopQueue = {1,0}   nums = [0,0,0,0,(0),0]\\nopQueue = {0,0}   nums = [0,0,0,0,0,(0)]\\n```` \\nThe queue keeps track of subtractions to the current element contributed by previous subarrays. Let `operations` be the sum of the elements of `opQueue`. Through smart use of `opQueue` and `operations`, it becomes possible to quickly update an element to incorporate previous subtractions. When visiting element `i` for the first time, simply subtract `operations` from `nums[i]`. From there compare `nums[i]` to `0` like in the previous approach. Update `opQueue` and `operations` by appending and adding `nums[i]` respectively. Remove data no longer relevant to the current index by popping it from the queue and subtracting it from `operations`.\\n\\n# Algorithm\\n1. Set `operations = 0` and `opQueue` to empty queue\\n2. For `i` in range `0 <= i < nums.length`:\\n    - If `i >= k`, subtract head of `opQueue` from `operations`, then pop element from queue\\n    - Subtract `operations` from `nums[i]`\\n    - If `nums[i] < 0` return false\\n    - if `i > nums.length - k` AND `nums[i] != 0` return false\\n    - Push `nums[i]` into `opQueue` and add `nums[i]` to `operations`\\n3. Once loop finishes return true\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    bool checkArray(vector<int>& nums, const int& k) {\\n        int operations = 0;\\n        queue<int> opQueue;\\n        \\n        for (int i = 0; i < nums.size(); i++) {\\n            if (i >= k) {\\n                operations -= opQueue.front();\\n                opQueue.pop();\\n            }\\n\\n            nums[i] -= operations;\\n            \\n            if (nums[i] < 0) {\\n                return false;\\n            }\\n            if (i > nums.size() - k && nums[i] != 0) {\\n                return false;\\n            }\\n            \\n            opQueue.push(nums[i]);\\n            operations += nums[i];\\n            nums[i] = 0;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public boolean checkArray(int[] nums, int k) {\\n        int operations = 0;\\n        final Queue<Integer> opQueue = new LinkedList<Integer> ();\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            if (i >= k) {\\n                operations -= opQueue.remove();\\n            }\\n\\n            nums[i] -= operations;\\n            \\n            if (nums[i] < 0) {\\n                return false;\\n            }\\n            if (i > nums.length - k && nums[i] != 0) {\\n                return false;\\n            }\\n            \\n            opQueue.add(nums[i]);\\n            operations += nums[i];\\n            nums[i] = 0;\\n        }\\n        \\n        return true;\\n    }\\n}\\n```\\n```Python3 []\\nclass Solution:\\n    def checkArray(self, nums: List[int], k: int) -> bool:\\n        operations = 0\\n        opQueue = deque()\\n        \\n        for i in range(len(nums)):\\n            if i >= k:\\n                operations -= opQueue.popleft()\\n\\n            nums[i] -= operations\\n            \\n            if nums[i] < 0:\\n                return False\\n            if i > len(nums) - k and nums[i] != 0:\\n                return False\\n            \\n            opQueue.append(nums[i])\\n            operations += nums[i]\\n            nums[i] = 0\\n        \\n        return True\\n```\\n\\n# Complexity\\n\\nLet $$n$$ be the length of `nums`\\n- Time complexity: $$O(n)$$\\n    - All $$n$$ elements of `nums` are visited once\\n    - Add, remove, and peek operations for a queue occur in $$O(1)$$ time\\n    - Total time is $$O(n)\\\\cdot{O(1)}=O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(k)$$\\n    - The queue stores $$O(k-1)$$ elements at most\\n    - Total space is $$O(k-1)=O(k)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Queue"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    bool checkArray(vector<int>& nums, const int& k) {\\n        for (int i = 0; i < nums.size(); i++) {\\n            if (nums[i] == 0) {\\n                continue;\\n            }\\n            if (nums[i] < 0) {\\n                return false;\\n            }\\n            if (i > nums.size() - k && nums[i] != 0) {\\n                return false;\\n            }\\n\\n            const int operations = nums[i];\\n\\n            for (int j = i; j < i+k; j++) {\\n                nums[j] -= operations;\\n            }\\n        }\\n\\n        return true;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public boolean checkArray(int[] nums, int k) {\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == 0) {\\n                continue;\\n            }\\n            if (nums[i] < 0) {\\n                return false;\\n            }\\n            if (i > nums.length - k && nums[i] != 0) {\\n                return false;\\n            }\\n\\n            final int operations = nums[i];\\n\\n            for (int j = i; j < i+k; j++) {\\n                nums[j] -= operations;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```\n```Python3 []\\nclass Solution:\\n    def checkArray(self, nums: List[int], k: int) -> bool:\\n        for i in range(len(nums)):\\n            if nums[i] == 0:\\n                continue\\n            if nums[i] < 0:\\n                return False\\n            if i > len(nums) - k and nums[i] != 0:\\n                return False\\n\\n            operations = nums[i]\\n\\n            for j in range(i, i+k):\\n                nums[j] -= operations\\n        \\n        return True\\n```\n```\\nnums = [2,2,3,1,1,0], k = 3\\nopQueue = {}      nums = [(2),2,3,1,1,0]\\nopQueue = {2}     nums = [0,(0),1,1,1,0] \\nopQueue = {2,0}   nums = [0,0,(1),1,1,0]\\nopQueue = {0,1}   nums = [0,0,0,(0),0,0]\\nopQueue = {1,0}   nums = [0,0,0,0,(0),0]\\nopQueue = {0,0}   nums = [0,0,0,0,0,(0)]\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    bool checkArray(vector<int>& nums, const int& k) {\\n        int operations = 0;\\n        queue<int> opQueue;\\n        \\n        for (int i = 0; i < nums.size(); i++) {\\n            if (i >= k) {\\n                operations -= opQueue.front();\\n                opQueue.pop();\\n            }\\n\\n            nums[i] -= operations;\\n            \\n            if (nums[i] < 0) {\\n                return false;\\n            }\\n            if (i > nums.size() - k && nums[i] != 0) {\\n                return false;\\n            }\\n            \\n            opQueue.push(nums[i]);\\n            operations += nums[i];\\n            nums[i] = 0;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public boolean checkArray(int[] nums, int k) {\\n        int operations = 0;\\n        final Queue<Integer> opQueue = new LinkedList<Integer> ();\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            if (i >= k) {\\n                operations -= opQueue.remove();\\n            }\\n\\n            nums[i] -= operations;\\n            \\n            if (nums[i] < 0) {\\n                return false;\\n            }\\n            if (i > nums.length - k && nums[i] != 0) {\\n                return false;\\n            }\\n            \\n            opQueue.add(nums[i]);\\n            operations += nums[i];\\n            nums[i] = 0;\\n        }\\n        \\n        return true;\\n    }\\n}\\n```\n```Python3 []\\nclass Solution:\\n    def checkArray(self, nums: List[int], k: int) -> bool:\\n        operations = 0\\n        opQueue = deque()\\n        \\n        for i in range(len(nums)):\\n            if i >= k:\\n                operations -= opQueue.popleft()\\n\\n            nums[i] -= operations\\n            \\n            if nums[i] < 0:\\n                return False\\n            if i > len(nums) - k and nums[i] != 0:\\n                return False\\n            \\n            opQueue.append(nums[i])\\n            operations += nums[i]\\n            nums[i] = 0\\n        \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3762249,
                "title": "c-tc-o-n-sc-o-n-very-simple-solution-interval-scanning",
                "content": "# Intuition\\nThis solution is quite similar to the interval scanning technique.\\nWhenever a new subarray of K elements is found, we subtract that subarray value.\\ni.e., subtract the first element\\'s value and add that same element after the k-element subarray is over. We can use a variable to add up all those values.\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkArray(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        \\n        vector<int> d(n+1,0);\\n        \\n        int diff = -nums[0];\\n        d[k] += nums[0];\\n        \\n        for(int i=1;i<n;i++){\\n            diff += d[i];\\n            nums[i]+=diff;\\n            \\n            if(nums[i]<0) \\n                return false;\\n            \\n            if(nums[i] > 0){\\n                if(i+k > n) \\n                    return false;\\n                diff -=nums[i];\\n                d[i+k] += nums[i];\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkArray(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        \\n        vector<int> d(n+1,0);\\n        \\n        int diff = -nums[0];\\n        d[k] += nums[0];\\n        \\n        for(int i=1;i<n;i++){\\n            diff += d[i];\\n            nums[i]+=diff;\\n            \\n            if(nums[i]<0) \\n                return false;\\n            \\n            if(nums[i] > 0){\\n                if(i+k > n) \\n                    return false;\\n                diff -=nums[i];\\n                d[i+k] += nums[i];\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3760383,
                "title": "range-update-trick-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- The main thing to note is that in any winodw of size `k`, if there are numbers of varying values, we have to apply the operation other than in this window as well.\\n- Now, we traverse from the start to the index till which we can apply the operation. Note that if `k` > 1, we cannot apply the operation starting on some indices at the last.\\n- We declare `prev` which tracks the current value by which we are subtracting the elements. In other words, if we apply an operation, we apply it on a range of indices. Thus, we need to know if we are currently in a window in which we have already operated before. If we have, `prev` will give us the value of the number of times we applied the operation, thus giving us the value by which we are subtracting the elements of this window. It is no brainer that we will declare `prev` as 0.\\n- If we get an element greater than `prev`, it means previous operation is not enough to make this value as 0. Thus, we will again apply it specific number of times on a window starting on this index, and updating `prev` as well.\\n- After applying all the operations, we check if all elements are equal to 0. If yes, we return `true`, otherwise `fasle`.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- If we apply every operation in the real time, we will get TLE. Even applying multiple operations on a single window in once, for every particular window, will give us TLE. Thus, we need to apply range-update trick.\\n- We declare `update` vector which will hold the temporary updates.\\n- We declare `prev` as 0. Every time the value of (element - `prev`) is greater than 0, we update the value of `prev` to negative of the difference, to signify that we need to subtract. We update the value of `update` at this index. Also, we update the value at index `current_index + k` to absolute difference (Range-update trick).\\n- Every time we get to an index where we already have a positive value in update, we subtract this value from `prev`, because it means we are out of a particular window.\\n- After iteration, we apply prefix sum on `update` to get our final `update` vector.\\n- Finally, we add `nums` and `update`. If at any index we do not have a 0, it means it is impossible to convert all the values of `nums` to 0, Thus we return `false`, otherwise `true`.\\n\\n# Complexity\\n- Time complexity: $O(N)$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(N)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkArray(vector<int>& nums, int k) {\\n        if(k == 1)\\n            return true;\\n        int n = nums.size(), prev = 0;\\n        vector<int> update(n + 1, 0);\\n        for(int i = 0; i <= n - k; i++)\\n        {\\n            if(update[i] > 0)\\n                prev -= update[i];\\n            if(nums[i] > prev)\\n            {\\n                update[i] += prev - nums[i];\\n                update[i + k] += nums[i] - prev;\\n                prev = nums[i];\\n            }\\n        }\\n        for(int i = 1; i < n; i++)\\n            update[i] += update[i - 1];\\n        for(int i = 0; i < n; i++)\\n            if(nums[i] + update[i])\\n                return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkArray(vector<int>& nums, int k) {\\n        if(k == 1)\\n            return true;\\n        int n = nums.size(), prev = 0;\\n        vector<int> update(n + 1, 0);\\n        for(int i = 0; i <= n - k; i++)\\n        {\\n            if(update[i] > 0)\\n                prev -= update[i];\\n            if(nums[i] > prev)\\n            {\\n                update[i] += prev - nums[i];\\n                update[i + k] += nums[i] - prev;\\n                prev = nums[i];\\n            }\\n        }\\n        for(int i = 1; i < n; i++)\\n            update[i] += update[i - 1];\\n        for(int i = 0; i < n; i++)\\n            if(nums[i] + update[i])\\n                return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3756622,
                "title": "java-operation-order-does-not-matter-exploit-sliding-window-diff-array-trick-for-o-n",
                "content": "# operation order does not matter -> exploit -> sliding window -> diff array trick for O(n)\\n\\nGiven a sequence of operations, you realized that order does not matter: all lead to same success. When something\\'s order does not matter, better exploit it to your advantage by imposing some order that could be helpful. Maybe ascending order by first element of an operation? Now a sense of sliding window with fixed size `k` emerges. Even better, it can be realized that as soon as the window slides, say starting from `i` to `i+1`, you lose any chance of updating `num[i]`. Thus the algorithm: while window slides, keep decrementing until `num[i]` reaches zero. This can be performed by just decreasing `num[i]` for all elements within the window, if `num[i]` initially `> 0`.\\n\\nBut we\\'re still missing a piece of puzzle: keep decreasing all window elements is not good enough. However a nice trick comes to play here, which is suitable whenever you want to increase/decrease a subarray fast: difference array. It works as follows: define `diff[i] = num[i] - num[i-1]`, then a range update (increase/decrease subarray) of `\\u0394`  for `[i..j)` amounts to `diff[i] += \\u0394` and `diff[j] -= \\u0394`. Thus using diff array you do `O(1)` for a range update. Using this trick yields an `O(n)` algorithm.\\n\\n\\n## side note\\n\\n1.  you can use lazy update along with sliding window when implementing. If `num[i-1]` reflects its real, updated value, then `num[i]` can be updated as `num[i-1] + diff[i]`, per `diff[i]` definition.\\n2.  some edge/special cases:\\n    \\n    1.  if `n < k`, no operation can be performed\\n    2.  for `k == 1`, it is always possible. Missing this should be fine as the algorithm should still work in this case, albeit `O(n)` time.\\n    \\n    It might be possible to implement in a way that no need to separate those two cases, but isolating them also feels clear.\\n\\n\\n# \\n\\n    class Solution {\\n    \\tpublic boolean checkArray(int[] nums, int k) {\\n    \\t\\tfinal int n = nums.length;\\n    \\t\\tif (k == 1)\\n    \\t\\t\\treturn true;\\n    \\t\\tif (n-k < 0) {\\n    \\t\\t\\tboolean allZero = true;\\n    \\t\\t\\tfor (int i = 0; i < n; i++) {\\n    \\t\\t\\t\\tif (nums[i] != 0) {\\n    \\t\\t\\t\\t\\tallZero = false;\\n    \\t\\t\\t\\t\\tbreak;\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t}\\n    \\t\\t\\treturn allZero;\\n    \\t\\t}\\n    \\t\\tint[] diff = new int[n];\\n    \\t\\tfor (int i = 1; i < diff.length; i++) {\\n    \\t\\t\\tdiff[i] = nums[i] - nums[i-1];\\n    \\t\\t}\\n    \\t\\tfor (int i = 0; i <= n - k; i++) {\\n    \\t\\t\\tif (i > 0) {\\n    \\t\\t\\t\\tnums[i] = nums[i-1] + diff[i];\\n    \\t\\t\\t}\\n    \\t\\t\\tif (nums[i] < 0) {\\n    \\t\\t\\t\\treturn false;\\n    \\t\\t\\t}\\n    \\t\\t\\tif (i+k < n) {\\n    \\t\\t\\t\\tdiff[i+k] += nums[i];\\n    \\t\\t\\t}\\n    \\t\\t\\tnums[i] = 0;\\n    \\t\\t}\\n    \\n    \\t\\tboolean allZero = true;\\n    \\t\\tfor (int i = n - k + 1; i < n; i++) {\\n    \\t\\t\\tif (diff[i] != 0) {\\n    \\t\\t\\t\\tallZero = false;\\n    \\t\\t\\t\\tbreak;\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\treturn allZero;\\n    \\t}\\n    }\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    \\tpublic boolean checkArray(int[] nums, int k) {\\n    \\t\\tfinal int n = nums.length;\\n    \\t\\tif (k == 1)\\n    \\t\\t\\treturn true;\\n    \\t\\tif (n-k < 0) {\\n    \\t\\t\\tboolean allZero = true;\\n    \\t\\t\\tfor (int i = 0; i < n; i++) {\\n    \\t\\t\\t\\tif (nums[i] != 0) {\\n    \\t\\t\\t\\t\\tallZero = false;\\n    \\t\\t\\t\\t\\tbreak;\\n    \\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3753334,
                "title": "java-time-complexity-o-n-k-space-complexity-o-n",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMaintain future delete number( add extended portion,delete previous kth extended portion )\\n\\nThen, Check last k-1 extended portion \\n \\n\\n# Complexity\\n- Time complexity: $$O(n+k)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean checkArray(int[] n, int k) {\\n        int l=n.length,min=0,v=0 ;\\n        int[] m=new int[l];\\n        \\n        for(int i=0;i<l;i++){\\n            v=n[i]-min;\\n            m[i]=v;\\n            if(v<0) return false;\\n            min+=v;\\n\\n            n[i]-=min;\\n            if(i-k+1>=0){\\n                min-=m[i-k+1];\\n            }\\n        }\\n        for(int i=l-k+1;i<l;i++) if(m[i]!=0) return false;\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkArray(int[] n, int k) {\\n        int l=n.length,min=0,v=0 ;\\n        int[] m=new int[l];\\n        \\n        for(int i=0;i<l;i++){\\n            v=n[i]-min;\\n            m[i]=v;\\n            if(v<0) return false;\\n            min+=v;\\n\\n            n[i]-=min;\\n            if(i-k+1>=0){\\n                min-=m[i-k+1];\\n            }\\n        }\\n        for(int i=l-k+1;i<l;i++) if(m[i]!=0) return false;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3753221,
                "title": "c-video-sliding-window",
                "content": "\\n    class Solution {\\n    public:\\n        bool checkArray(vector<int>& nums, int k) {\\n        \\n        int n = size(nums);\\n        int sub_sum = nums[0];\\n        vector<int> sub{nums[0]};\\n        \\n        for(int i = 1; i <= n - k; ++i) {\\n            if(i - k >= 0) sub_sum -= sub[i-k];\\n            \\n            if(nums[i] < sub_sum) return false;\\n        \\n            sub.push_back(nums[i] - sub_sum);\\n            sub_sum += sub.back();\\n\\n            \\n        }\\n        \\n        for(int i = n - k +1; i < n; ++i) {\\n            \\n            if(i - k >= 0) sub_sum -= sub[i-k];\\n            if(nums[i] != sub_sum) return false;\\n             \\n        }\\n        \\n        return true;\\n            \\n    }\\n    };\\n\\nhttps://youtu.be/_2Mdu5-OxgE\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        bool checkArray(vector<int>& nums, int k) {\\n        \\n        int n = size(nums);\\n        int sub_sum = nums[0];\\n        vector<int> sub{nums[0]}",
                "codeTag": "Java"
            },
            {
                "id": 3753025,
                "title": "python-queue",
                "content": "We can solve by a queue. Increases space complexity since we iterate array of an additional length `k` but keeps the code simpler.\\n\\n```python\\nfrom collections import deque\\nclass Solution(object):\\n    def checkArray(self, nums, k):\\n        opens = deque([])\\n        opens_total = 0\\n        for i, x in enumerate(nums + [0]*k):\\n            while opens and i - opens[0][0] == k:\\n                opens_total -= opens[0][1]\\n                opens.popleft()\\n            now_open = x - opens_total\\n            if now_open < 0:\\n                return False\\n            if now_open > 0:\\n                opens_total += now_open\\n                opens.append((i, now_open))\\n        return True\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nfrom collections import deque\\nclass Solution(object):\\n    def checkArray(self, nums, k):\\n        opens = deque([])\\n        opens_total = 0\\n        for i, x in enumerate(nums + [0]*k):\\n            while opens and i - opens[0][0] == k:\\n                opens_total -= opens[0][1]\\n                opens.popleft()\\n            now_open = x - opens_total\\n            if now_open < 0:\\n                return False\\n            if now_open > 0:\\n                opens_total += now_open\\n                opens.append((i, now_open))\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3752749,
                "title": "simple-and-clean-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSliding window of fixed size\\nFor each index the no. of operation to make it zero = updated no. after making all its prevous k-1 elements to 0.\\n\\nUpdated no.= (Original number)- (operations the previous element suffered) + (No. of operation the previous element taken without including current element in the sliding window)\\n\\nIf operation required at any point is negative then it is impossible to make array equal. \\nThere is also an edge case for last k-1 elements of array, check code for it.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkArray(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int>pre(n);\\n        pre[0]=nums[0];\\n \\n        for(int i=1;i<n;i++){\\n            //calc pre\\n            pre[i]=nums[i]-nums[i-1];\\n            \\n            if(i>=k){\\n                pre[i]+=pre[i-k];\\n            }\\n            if(i+k<=n&&pre[i]<0)return false;\\n            if(i+k>n&&pre[i]!=0)return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkArray(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int>pre(n);\\n        pre[0]=nums[0];\\n \\n        for(int i=1;i<n;i++){\\n            //calc pre\\n            pre[i]=nums[i]-nums[i-1];\\n            \\n            if(i>=k){\\n                pre[i]+=pre[i-k];\\n            }\\n            if(i+k<=n&&pre[i]<0)return false;\\n            if(i+k>n&&pre[i]!=0)return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3752611,
                "title": "clean-range-prefix-sum-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkArray(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int> modify(n+1,0);\\n        modify[0]=nums[0];\\n        modify[k]-=nums[0];\\n        \\n        int running_sum=nums[0];\\n        for(int i=1;i<n;i++){\\n            running_sum+=modify[i];\\n            \\n            if(nums[i]<running_sum) return false;   //nums[i] should be atleast running_sum\\n            \\n            else if(nums[i]==running_sum) continue;\\n            else{\\n                int diff=nums[i]-running_sum;\\n                modify[i]+=diff;\\n                running_sum=nums[i];\\n                if(i+k>n) return false;\\n                modify[i+k]-=diff;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkArray(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int> modify(n+1,0);\\n        modify[0]=nums[0];\\n        modify[k]-=nums[0];\\n        \\n        int running_sum=nums[0];\\n        for(int i=1;i<n;i++){\\n            running_sum+=modify[i];\\n            \\n            if(nums[i]<running_sum) return false;   //nums[i] should be atleast running_sum\\n            \\n            else if(nums[i]==running_sum) continue;\\n            else{\\n                int diff=nums[i]-running_sum;\\n                modify[i]+=diff;\\n                running_sum=nums[i];\\n                if(i+k>n) return false;\\n                modify[i+k]-=diff;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3752530,
                "title": "sliding-window-easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nbool checkArray(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        int sum = 0,left = 0,right =0;\\n\\n        while(right<n){\\n\\n            if (nums[right] < sum) return false;\\n            nums[right] -= sum;\\n            sum += nums[right];\\n\\n            if (right-left+1 >= k){\\n                sum -= nums[left];\\n                left++;\\n            }\\n    \\n            right++;\\n        }\\n\\n        return sum==0;\\n    }\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nbool checkArray(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        int sum = 0,left = 0,right =0;\\n\\n        while(right<n){\\n\\n            if (nums[right] < sum) return false;\\n            nums[right] -= sum;\\n            sum += nums[right];\\n\\n            if (right-left+1 >= k){\\n                sum -= nums[left];\\n                left++;\\n            }\\n    \\n            right++;\\n        }\\n\\n        return sum==0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3752364,
                "title": "prefix-sum-application-red",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkArray(vector<int>& nums, int k)\\n    {\\n        int n=nums.size();\\n        vector<int> temp(n+1,0);\\n        for(int i=0 ; i<n ; i++)\\n        {\\n            if(i>0)\\n            {\\n                temp[i]+=temp[i-1];\\n            }\\n\\n            int diff=nums[i]-temp[i];\\n            if(diff<0)\\n            return false;\\n            \\n            if(i+k>n)\\n            {\\n                if(diff!=0)\\n                {\\n                    return false;\\n                }\\n                else\\n                {\\n                    continue;\\n                }\\n            }\\n            temp[i]+=diff;\\n            temp[i+k]-=diff;\\n        }\\n        return true;\\n    }\\n};\\n\\n```\\n# Movement of Robots (this uses prefix sum to calculate the sum of differences between every pair in O(n))\\n```\\nclass Solution {\\npublic:\\n    int MOD = 1000000007;\\n    int sumDistance(vector<int>& nums, string s, int d) \\n    {\\n        for(int i = 0; i < nums.size(); i++)\\n        {\\n            if(s[i] == \\'R\\') nums[i] += d;\\n            else nums[i] -= d;\\n        }\\n        sort(nums.begin(), nums.end());\\n        long long ans = 0;\\n        long long pref = 0;\\n        long long n = s.length()-1;\\n\\n        for(long long i = 0; i < nums.size(); i++)\\n        {\\n            ans += i * (long long) nums[i] - pref;\\n            ans %= MOD;\\n            pref += nums[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkArray(vector<int>& nums, int k)\\n    {\\n        int n=nums.size();\\n        vector<int> temp(n+1,0);\\n        for(int i=0 ; i<n ; i++)\\n        {\\n            if(i>0)\\n            {\\n                temp[i]+=temp[i-1];\\n            }\\n\\n            int diff=nums[i]-temp[i];\\n            if(diff<0)\\n            return false;\\n            \\n            if(i+k>n)\\n            {\\n                if(diff!=0)\\n                {\\n                    return false;\\n                }\\n                else\\n                {\\n                    continue;\\n                }\\n            }\\n            temp[i]+=diff;\\n            temp[i+k]-=diff;\\n        }\\n        return true;\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int MOD = 1000000007;\\n    int sumDistance(vector<int>& nums, string s, int d) \\n    {\\n        for(int i = 0; i < nums.size(); i++)\\n        {\\n            if(s[i] == \\'R\\') nums[i] += d;\\n            else nums[i] -= d;\\n        }\\n        sort(nums.begin(), nums.end());\\n        long long ans = 0;\\n        long long pref = 0;\\n        long long n = s.length()-1;\\n\\n        for(long long i = 0; i < nums.size(); i++)\\n        {\\n            ans += i * (long long) nums[i] - pref;\\n            ans %= MOD;\\n            pref += nums[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3752347,
                "title": "javascript-sliding-window",
                "content": "# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {boolean}\\n */\\nvar checkArray = function (nums, k) {\\n  let curr = 0;\\n  const n = nums.length;\\n\\n  for (let i = 0; i < n; i++) {\\n    if (nums[i] < curr) return false;\\n    nums[i] -= curr;\\n    curr += nums[i];\\n\\n    if (i + 1 >= k) {\\n      curr -= nums[i - k + 1];\\n    }\\n  }\\n\\n  return curr === 0;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Sliding Window"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {boolean}\\n */\\nvar checkArray = function (nums, k) {\\n  let curr = 0;\\n  const n = nums.length;\\n\\n  for (let i = 0; i < n; i++) {\\n    if (nums[i] < curr) return false;\\n    nums[i] -= curr;\\n    curr += nums[i];\\n\\n    if (i + 1 >= k) {\\n      curr -= nums[i - k + 1];\\n    }\\n  }\\n\\n  return curr === 0;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3752293,
                "title": "c-queue",
                "content": "# Approach\\nqueue to track number which we are derementing\\nOnce queue size is same as k then we remove first element from the queue\\n\\n# Complexity\\n- Time complexity:\\nO(N) -> size of nums\\n\\n- Space complexity:\\nO(k) -> Size of the queue\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkArray(vector<int>& nums, int k) {\\n        queue<int> q;\\n        int t=0;\\n        for (int i=0;i<nums.size();i++){\\n            if (nums[i]-t<0) return false;\\n\\n            if (i+k<=nums.size()){\\n                q.push(nums[i]-t);\\n                t+=q.back();\\n            }\\n            else{\\n                if (nums[i]!=t) return false;\\n            }\\n            \\n            if (q.size()==k || q.size()==nums.size()-i){\\n                t-=q.front();\\n                q.pop();\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkArray(vector<int>& nums, int k) {\\n        queue<int> q;\\n        int t=0;\\n        for (int i=0;i<nums.size();i++){\\n            if (nums[i]-t<0) return false;\\n\\n            if (i+k<=nums.size()){\\n                q.push(nums[i]-t);\\n                t+=q.back();\\n            }\\n            else{\\n                if (nums[i]!=t) return false;\\n            }\\n            \\n            if (q.size()==k || q.size()==nums.size()-i){\\n                t-=q.front();\\n                q.pop();\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3751944,
                "title": "python-6-line-difference-array-solution",
                "content": "```\\ndef checkArray(self, nums: List[int], k: int) -> bool:\\n\\td = [nums[0]]+[nums[i+1]-nums[i] for i in range(len(nums)-1)]+[-nums[-1]]\\n\\tfor i in range(len(d)-k):\\n\\t\\tif d[i]>0:\\n\\t\\t\\td[i+k] += d[i]\\n\\t\\t\\td[i] -= d[i]\\n\\treturn all(x==0 for x in d)\\n```",
                "solutionTags": [],
                "code": "```\\ndef checkArray(self, nums: List[int], k: int) -> bool:\\n\\td = [nums[0]]+[nums[i+1]-nums[i] for i in range(len(nums)-1)]+[-nums[-1]]\\n\\tfor i in range(len(d)-k):\\n\\t\\tif d[i]>0:\\n\\t\\t\\td[i+k] += d[i]\\n\\t\\t\\td[i] -= d[i]\\n\\treturn all(x==0 for x in d)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3751011,
                "title": "c-direct-solution-o-n",
                "content": "# Intuition\\nDecrease the items in the array from the intitial item to the last one.\\n\\n# Approach\\nAdd the currect index:\\n```\\nvar index = 0;\\n```\\nThen in cycle find the 1st non-zero item:\\n```\\nwhile (nums[index] == 0)\\n{\\n    index++;\\n    if (index >= nums.Length) return true;\\n}\\n```\\nand then just to reduse k items starting from `index`:\\n```\\nvar val = nums[index];\\nif (index - 1 + k >= nums.Length) return false;\\nfor (int i = 0; i < k; i++)\\n{\\n    nums[index + i] -= val;\\n    if (nums[index + i] < 0) return false;\\n}\\n```\\nIn this cycle if the item changed to the negative value, return false:\\n```\\nif (nums[index + i] < 0) return false;\\n```\\n\\n# Complexity\\n- Time complexity:\\n$$O(len(nums))$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\npublic class Solution {\\n    public bool CheckArray(int[] nums, int k) {\\n        var index = 0;\\n        while (index < nums.Length)\\n        {\\n            while (nums[index] == 0)\\n            {\\n                index++;\\n                if (index >= nums.Length) return true;\\n            }\\n            var val = nums[index];\\n            if (index - 1 + k >= nums.Length) return false;\\n            for (int i = 0; i < k; i++)\\n            {\\n                nums[index + i] -= val;\\n                if (nums[index + i] < 0) return false;\\n            }\\n            index++;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\nvar index = 0;\\n```\n```\\nwhile (nums[index] == 0)\\n{\\n    index++;\\n    if (index >= nums.Length) return true;\\n}\\n```\n```\\nvar val = nums[index];\\nif (index - 1 + k >= nums.Length) return false;\\nfor (int i = 0; i < k; i++)\\n{\\n    nums[index + i] -= val;\\n    if (nums[index + i] < 0) return false;\\n}\\n```\n```\\nif (nums[index + i] < 0) return false;\\n```\n```\\npublic class Solution {\\n    public bool CheckArray(int[] nums, int k) {\\n        var index = 0;\\n        while (index < nums.Length)\\n        {\\n            while (nums[index] == 0)\\n            {\\n                index++;\\n                if (index >= nums.Length) return true;\\n            }\\n            var val = nums[index];\\n            if (index - 1 + k >= nums.Length) return false;\\n            for (int i = 0; i < k; i++)\\n            {\\n                nums[index + i] -= val;\\n                if (nums[index + i] < 0) return false;\\n            }\\n            index++;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3750943,
                "title": "c-easy-sliding-window-technique",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkArray(vector<int>& nums, int k) {\\n        int n=nums.size(),curr=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(curr>nums[i])\\n            {\\n                return false;\\n            }\\n            nums[i]=nums[i]-curr;\\n            curr=curr+nums[i];\\n            if(i>=k-1)\\n            {\\n                curr=curr-nums[i-k+1];\\n            }\\n        }\\n        if(curr==0)\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkArray(vector<int>& nums, int k) {\\n        int n=nums.size(),curr=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(curr>nums[i])\\n            {\\n                return false;\\n            }\\n            nums[i]=nums[i]-curr;\\n            curr=curr+nums[i];\\n            if(i>=k-1)\\n            {\\n                curr=curr-nums[i-k+1];\\n            }\\n        }\\n        if(curr==0)\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3750574,
                "title": "sliding-window-c",
                "content": "# Intuition\\n \\n\\n# Approach\\n \\n# Complexity\\n O(n*k)\\n\\n- Space complexity:\\n O(1)\\n\\n# Code\\n```\\npublic class Solution {\\n    public bool CheckArray(int[] nums, int k) {\\n        int n = nums.Length;\\n        //sliding window\\n        for(int i=0;i<=n-k;i++)\\n        {\\n            if(nums[i]==0)\\n                continue;\\n            for(int j=i+1;j<i+k;j++)\\n            {\\n                \\n                if(nums[j]<nums[i])\\n                    return false;\\n                else\\n                    nums[j] -= nums[i];\\n            }\\n            nums[i] = 0;\\n        }\\n        \\n       for(int i=n-k;i<n;i++)\\n       {       \\n           if(nums[i]!=0)\\n               return false;\\n       }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public bool CheckArray(int[] nums, int k) {\\n        int n = nums.Length;\\n        //sliding window\\n        for(int i=0;i<=n-k;i++)\\n        {\\n            if(nums[i]==0)\\n                continue;\\n            for(int j=i+1;j<i+k;j++)\\n            {\\n                \\n                if(nums[j]<nums[i])\\n                    return false;\\n                else\\n                    nums[j] -= nums[i];\\n            }\\n            nums[i] = 0;\\n        }\\n        \\n       for(int i=n-k;i<n;i++)\\n       {       \\n           if(nums[i]!=0)\\n               return false;\\n       }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3750151,
                "title": "easy-java-solution-for-beginners-aryan-mittal-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIn this problem, we want to check the impact of each element on the k-1 elements ahead of it or we can say an element can be impacted by k-1 elements before it. Each element nums[i] wants k-1 elements ahead of it to get reduced by nums[i] .If the further elements become negative -> return false . If they do not, decrease their value by nums[i] and add the remaining value to impact they would create on further elements as each element gets impacted and creates an impact also. keep doing this till impact becomes 0 at end of array.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nYou can check out his video for reference:\\nhttps://www.youtube.com/watch?v=gGJhgzIHkCY\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean checkArray(int[] nums, int k) {\\n        int n=nums.length;\\n        int impact=0;\\n        for(int i=0;i<n;i++){\\n            if(impact>nums[i]){\\n                return false;\\n            }\\n            nums[i]-=impact;\\n            impact+=nums[i];\\n            if(i>=k-1){\\n                impact-=nums[i-k+1];\\n            }\\n        }\\n        return impact==0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkArray(int[] nums, int k) {\\n        int n=nums.length;\\n        int impact=0;\\n        for(int i=0;i<n;i++){\\n            if(impact>nums[i]){\\n                return false;\\n            }\\n            nums[i]-=impact;\\n            impact+=nums[i];\\n            if(i>=k-1){\\n                impact-=nums[i-k+1];\\n            }\\n        }\\n        return impact==0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3750007,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkArray(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int> diff(n+1,0);\\n        diff[0]+=nums[0];\\n        diff[k]-=nums[0];\\n\\n        for(int i=1;i<n;i++){\\n            diff[i]+=diff[i-1];\\n            if(diff[i]==nums[i]) continue;\\n            if(diff[i]>nums[i] || i+k-1>=n) return false;\\n\\n            //if(nums[i]>diff[i])\\n            int curdiff=nums[i]-diff[i];\\n            diff[i]+=curdiff;\\n            diff[i+k]-=curdiff;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkArray(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int> diff(n+1,0);\\n        diff[0]+=nums[0];\\n        diff[k]-=nums[0];\\n\\n        for(int i=1;i<n;i++){\\n            diff[i]+=diff[i-1];\\n            if(diff[i]==nums[i]) continue;\\n            if(diff[i]>nums[i] || i+k-1>=n) return false;\\n\\n            //if(nums[i]>diff[i])\\n            int curdiff=nums[i]-diff[i];\\n            diff[i]+=curdiff;\\n            diff[i+k]-=curdiff;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3749416,
                "title": "python3-solution",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def checkArray(self, nums: List[int], k: int) -> bool:\\n        n = len(nums)\\n        minus = 0\\n        addDict = defaultdict(int)\\n        \\n        for i in range(n-k+1):\\n            minus+=addDict[i]\\n            if nums[i]+minus<0:\\n                return False\\n            elif nums[i]+minus>0:\\n                addDict[i+k] = nums[i]+minus\\n                minus-=(nums[i]+minus)\\n\\n        for i in range(n-k+1,n):\\n            minus+=addDict[i]\\n\\n            if nums[i]+minus!=0:\\n                return False\\n            \\n        return True\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def checkArray(self, nums: List[int], k: int) -> bool:\\n        n = len(nums)\\n        minus = 0\\n        addDict = defaultdict(int)\\n        \\n        for i in range(n-k+1):\\n            minus+=addDict[i]\\n            if nums[i]+minus<0:\\n                return False\\n            elif nums[i]+minus>0:\\n                addDict[i+k] = nums[i]+minus\\n                minus-=(nums[i]+minus)\\n\\n        for i in range(n-k+1,n):\\n            minus+=addDict[i]\\n\\n            if nums[i]+minus!=0:\\n                return False\\n            \\n        return True\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3749061,
                "title": "c-easy-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkArray(vector<int>& nums, int k) \\n    {\\n        int n=nums.size();\\n        vector<int>a(n+1,0);\\n        int cur=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            cur-=a[i];\\n            if(nums[i]-cur<0)return false;\\n            nums[i]-=cur;\\n            if(i+k>n&&nums[i]!=0)return false;\\n            if(nums[i]!=0)\\n            {\\n                cur+=nums[i];\\n                a[i+k]=nums[i];\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkArray(vector<int>& nums, int k) \\n    {\\n        int n=nums.size();\\n        vector<int>a(n+1,0);\\n        int cur=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            cur-=a[i];\\n            if(nums[i]-cur<0)return false;\\n            nums[i]-=cur;\\n            if(i+k>n&&nums[i]!=0)return false;\\n            if(nums[i]!=0)\\n            {\\n                cur+=nums[i];\\n                a[i+k]=nums[i];\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3748751,
                "title": "c-python-java-javascript-just-iterate-nums-and-remove",
                "content": "# Intuition\\nNo matter where we start, goal is make all values of nums to 0, \\nso we follow kind of kandane\\'s algorithm start with 0th index\\n\\n# Approach\\n* Initially remove = 0\\n* Iterate entire nums, nums[i] -= remove\\n* If nums[i] is less than 0, which means we cant make into 0, ***return False***\\n* If nums[i] != 0, we still left few values to make 0.\\n* Thats why we use deque q = [ ] # [n, i]\\n* q.append([nums[i], i+k-1]) => {why i+k-1, next is i+k, we should consider cur index also}\\n* If we are at the q[0][1] position, we tally the remove and popleft.\\n* finally q should be empty. \\n\\n# Complexity\\n- Time complexity: O(N)\\n\\n- Space complexity: O(k)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n```Python []\\nclass Solution:\\n    def checkArray(self, nums: List[int], k: int) -> bool:\\n        q = deque([[nums[0], k-1]]) # n, i\\n        remove = q[0][0]\\n        for i, n in enumerate(nums):\\n            nums[i] -= remove\\n            if nums[i] < 0: return False\\n            if nums[i]:\\n                remove += nums[i]\\n                q.append([nums[i], i+k-1])\\n            if q and q[0][1] == i:\\n                remove -= q.popleft()[0]\\n        return len(q) == 0\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    bool checkArray(vector<int>& nums, int k) {\\n        std::deque<std::vector<int>> q;\\n        q.push_back({nums[0], k-1}); // n, i\\n        int remove = q.front()[0];\\n        \\n        for (int i = 0; i < nums.size(); i++) {\\n            nums[i] -= remove;\\n            if (nums[i] < 0)\\n                return false;\\n            if (nums[i]) {\\n                remove += nums[i];\\n                q.push_back({nums[i], i+k-1});\\n            }\\n            if (!q.empty() && q.front()[1] == i) {\\n                remove -= q.front()[0];\\n                q.pop_front();\\n            }\\n        }\\n        \\n        return q.empty();\\n    }\\n};\\n\\n```\\n```Java []\\nclass Solution {\\n    public boolean checkArray(int[] nums, int k) {\\n        Deque<int[]> q = new ArrayDeque<>();\\n        q.add(new int[]{nums[0], k - 1}); // n, i\\n        int remove = q.peek()[0];\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            nums[i] -= remove;\\n            if (nums[i] < 0)\\n                return false;\\n            if (nums[i] > 0) {\\n                remove += nums[i];\\n                q.add(new int[]{nums[i], i + k - 1});\\n            }\\n            if (!q.isEmpty() && q.peek()[1] == i) {\\n                remove -= q.remove()[0];\\n            }\\n        }\\n        return q.isEmpty();\\n    }\\n}\\n```\\n```JavaScript []\\nvar checkArray = function(nums, k) {\\n        const q = [[nums[0], k-1]]; // n, i\\n        let remove = q[0][0];\\n\\n        for (let i = 0; i < nums.length; i++) {\\n            nums[i] -= remove;\\n            if (nums[i] < 0)\\n                return false;\\n            if (nums[i] > 0) {\\n                remove += nums[i];\\n                q.push([nums[i], i+k-1]);\\n            }\\n            if (q.length > 0 && q[0][1] === i) {\\n                remove -= q.shift()[0];\\n            }\\n        }\\n        return q.length === 0;\\n    }\\n```\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```Python []\\nclass Solution:\\n    def checkArray(self, nums: List[int], k: int) -> bool:\\n        q = deque([[nums[0], k-1]]) # n, i\\n        remove = q[0][0]\\n        for i, n in enumerate(nums):\\n            nums[i] -= remove\\n            if nums[i] < 0: return False\\n            if nums[i]:\\n                remove += nums[i]\\n                q.append([nums[i], i+k-1])\\n            if q and q[0][1] == i:\\n                remove -= q.popleft()[0]\\n        return len(q) == 0\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    bool checkArray(vector<int>& nums, int k) {\\n        std::deque<std::vector<int>> q;\\n        q.push_back({nums[0], k-1}); // n, i\\n        int remove = q.front()[0];\\n        \\n        for (int i = 0; i < nums.size(); i++) {\\n            nums[i] -= remove;\\n            if (nums[i] < 0)\\n                return false;\\n            if (nums[i]) {\\n                remove += nums[i];\\n                q.push_back({nums[i], i+k-1});\\n            }\\n            if (!q.empty() && q.front()[1] == i) {\\n                remove -= q.front()[0];\\n                q.pop_front();\\n            }\\n        }\\n        \\n        return q.empty();\\n    }\\n};\\n\\n```\n```Java []\\nclass Solution {\\n    public boolean checkArray(int[] nums, int k) {\\n        Deque<int[]> q = new ArrayDeque<>();\\n        q.add(new int[]{nums[0], k - 1}); // n, i\\n        int remove = q.peek()[0];\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            nums[i] -= remove;\\n            if (nums[i] < 0)\\n                return false;\\n            if (nums[i] > 0) {\\n                remove += nums[i];\\n                q.add(new int[]{nums[i], i + k - 1});\\n            }\\n            if (!q.isEmpty() && q.peek()[1] == i) {\\n                remove -= q.remove()[0];\\n            }\\n        }\\n        return q.isEmpty();\\n    }\\n}\\n```\n```JavaScript []\\nvar checkArray = function(nums, k) {\\n        const q = [[nums[0], k-1]]; // n, i\\n        let remove = q[0][0];\\n\\n        for (let i = 0; i < nums.length; i++) {\\n            nums[i] -= remove;\\n            if (nums[i] < 0)\\n                return false;\\n            if (nums[i] > 0) {\\n                remove += nums[i];\\n                q.push([nums[i], i+k-1]);\\n            }\\n            if (q.length > 0 && q[0][1] === i) {\\n                remove -= q.shift()[0];\\n            }\\n        }\\n        return q.length === 0;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3748218,
                "title": "concise-greedy-o-n-c",
                "content": "# Approach\\nIterate through `nums` in order.\\n\\nFor each index `i` there are 3 options:\\n    1. `nums[i] < 0` : No valid solution -> return false\\n    2. `nums[i] == 0` : Requirements met -> do nothing\\n    3. `nums[i] > 0` : Decrement elements `nums[i ... i+k-1]` by the value of `nums[i]`\\n\\nImplementing $$1$$ and $$2$$ is trivial, but making $$3$$ efficient is harder.\\n\\n**Key intuition:** Don\\'t immediately decrement all `k` elements. Instead keep track of decrement values in a variable, and apply it to each element later.\\n\\nAlso note the special case where index `i+k-1` is out of bounds in `nums`.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkArray(vector<int>& nums, int k) {\\n        int n = nums.size(), decr = 0;\\n\\n        for (int i = 0; i < n; ++i) {\\n            if (i-k >= 0) decr -= nums[i-k];\\n            nums[i] -= decr;\\n            if (nums[i] < 0 || nums[i] && i+k > n) return false;\\n            decr += nums[i];\\n        }\\n\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkArray(vector<int>& nums, int k) {\\n        int n = nums.size(), decr = 0;\\n\\n        for (int i = 0; i < n; ++i) {\\n            if (i-k >= 0) decr -= nums[i-k];\\n            nums[i] -= decr;\\n            if (nums[i] < 0 || nums[i] && i+k > n) return false;\\n            decr += nums[i];\\n        }\\n\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3747388,
                "title": "prefix-sum-java",
                "content": "Java prefix sum solution \\nadd diff at i and remove diff at i+k\\n```\\nclass Solution {\\n    \\n    public boolean checkArray(int[] nums, int k) {\\n        int []prefix = new int[nums.length];\\n        prefix[0] = nums[0];\\n        if(0+k<nums.length){\\n            prefix[0+k] = -nums[0];\\n        }\\n        for(int i = 1;i<nums.length;i++){\\n            \\n            int curValue = prefix[i]+prefix[i-1];\\n           // System.out.println(Arrays.toString(prefix));\\n            if(curValue==nums[i]){\\n                prefix[i]=nums[i];\\n                continue;\\n            }\\n            else if(curValue<nums[i]){\\n                int miss = nums[i]-curValue;\\n                \\n                if(i+k<nums.length){\\n                   \\n                    prefix[i+k] -=miss;\\n                }\\n                else if(i+k>nums.length){\\n                    //System.out.println(nums[i]);\\n                    return false;\\n                }\\n                prefix[i] = nums[i];\\n            }\\n            else{\\n                \\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public boolean checkArray(int[] nums, int k) {\\n        int []prefix = new int[nums.length];\\n        prefix[0] = nums[0];\\n        if(0+k<nums.length){\\n            prefix[0+k] = -nums[0];\\n        }\\n        for(int i = 1;i<nums.length;i++){\\n            \\n            int curValue = prefix[i]+prefix[i-1];\\n           // System.out.println(Arrays.toString(prefix));\\n            if(curValue==nums[i]){\\n                prefix[i]=nums[i];\\n                continue;\\n            }\\n            else if(curValue<nums[i]){\\n                int miss = nums[i]-curValue;\\n                \\n                if(i+k<nums.length){\\n                   \\n                    prefix[i+k] -=miss;\\n                }\\n                else if(i+k>nums.length){\\n                    //System.out.println(nums[i]);\\n                    return false;\\n                }\\n                prefix[i] = nums[i];\\n            }\\n            else{\\n                \\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3746913,
                "title": "c-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWhen subtracting some `delta` from `num[i]` should subtract this `delta` from `nums[i + 1]`, ... `nums[i + k - 1]` as well. We can subtract `delta` from each item while keep tracking when we should stop doing it - `events` queue.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(k)$$\\n\\n# Code\\n```\\npublic class Solution {\\n    public bool CheckArray(int[] nums, int k) {\\n        int delta = 0;\\n\\n        Queue<(int value, int at)> events = new(); \\n\\n        for (int i = 0; i < nums.Length; ++i) {\\n            int value = nums[i] - delta;\\n\\n            if (value < 0)\\n                return false;\\n\\n            if (value > 0) {\\n                delta += value;\\n\\n                events.Enqueue((value, i + k - 1));\\n            }\\n\\n            if (events.Count > 0 && events.Peek().at == i) \\n                delta -= events.Dequeue().value;\\n        }   \\n\\n        return events.Count == 0;         \\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public bool CheckArray(int[] nums, int k) {\\n        int delta = 0;\\n\\n        Queue<(int value, int at)> events = new(); \\n\\n        for (int i = 0; i < nums.Length; ++i) {\\n            int value = nums[i] - delta;\\n\\n            if (value < 0)\\n                return false;\\n\\n            if (value > 0) {\\n                delta += value;\\n\\n                events.Enqueue((value, i + k - 1));\\n            }\\n\\n            if (events.Count > 0 && events.Peek().at == i) \\n                delta -= events.Dequeue().value;\\n        }   \\n\\n        return events.Count == 0;         \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3746382,
                "title": "golang-o-n-solution-double-100",
                "content": "# Complexity\\n- Time complexity: O(n)\\n- Space complexity: O(n)\\n\\n# Code\\n```go\\nfunc checkArray(nums []int, k int) bool {\\n\\tdesc := make([]int, len(nums))\\n\\ttweak := 0\\n\\tfor i := 0; i < len(nums); i++ {\\n\\t\\ttweak += desc[i]\\n\\t\\tv := nums[i] + tweak\\n\\t\\tif v < 0 {\\n\\t\\t\\t// nagative\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t\\tif v == 0 {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\ttweak -= v\\n\\t\\tif i+k-1 >= len(nums) {\\n\\t\\t\\t// tweak index OutOfRange\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t\\tif i+k < len(nums) {\\n\\t\\t\\tdesc[i+k] = v\\n\\t\\t}\\n\\t}\\n\\treturn true\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc checkArray(nums []int, k int) bool {\\n\\tdesc := make([]int, len(nums))\\n\\ttweak := 0\\n\\tfor i := 0; i < len(nums); i++ {\\n\\t\\ttweak += desc[i]\\n\\t\\tv := nums[i] + tweak\\n\\t\\tif v < 0 {\\n\\t\\t\\t// nagative\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t\\tif v == 0 {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\ttweak -= v\\n\\t\\tif i+k-1 >= len(nums) {\\n\\t\\t\\t// tweak index OutOfRange\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t\\tif i+k < len(nums) {\\n\\t\\t\\tdesc[i+k] = v\\n\\t\\t}\\n\\t}\\n\\treturn true\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3746072,
                "title": "o-n-time-o-1-space-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean checkArray(int[] nums, int k) {\\n        int n = nums.length;\\n\\n        for (int i = 0; i <= n - k ; i++) {\\n            if (nums[i] > 0) {\\n                int mn = nums[i];\\n                for (int j = i; j <= i + k - 1; j++) {\\n                    nums[j] -= mn;\\n                    if (nums[j] < 0) return false;\\n                }\\n            }\\n        }\\n\\n        for (int i = n - k + 1; i < n; i++) {\\n            if (nums[i] != 0) return false;\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkArray(int[] nums, int k) {\\n        int n = nums.length;\\n\\n        for (int i = 0; i <= n - k ; i++) {\\n            if (nums[i] > 0) {\\n                int mn = nums[i];\\n                for (int j = i; j <= i + k - 1; j++) {\\n                    nums[j] -= mn;\\n                    if (nums[j] < 0) return false;\\n                }\\n            }\\n        }\\n\\n        for (int i = n - k + 1; i < n; i++) {\\n            if (nums[i] != 0) return false;\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3745399,
                "title": "python-greedy-from-left-or-right-o-n",
                "content": "# Code\\n```\\nclass Solution:\\n    def checkArray(self, nums: List[int], k: int) -> bool:\\n        n = len(nums)\\n        deltas = [0]*n\\n        delta = 0\\n        for i, num in enumerate(nums):\\n            delta += deltas[i]\\n            if num + delta < 0: return False\\n            elif num + delta > 0:\\n                if i <= n-k:\\n                    if i + k < n:\\n                        deltas[i+k] = num + delta\\n                    delta -= num + delta\\n                else:\\n                    return False\\n        return True\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def checkArray(self, nums: List[int], k: int) -> bool:\\n        n = len(nums)\\n        deltas = [0]*n\\n        delta = 0\\n        for i, num in enumerate(nums):\\n            delta += deltas[i]\\n            if num + delta < 0: return False\\n            elif num + delta > 0:\\n                if i <= n-k:\\n                    if i + k < n:\\n                        deltas[i+k] = num + delta\\n                    delta -= num + delta\\n                else:\\n                    return False\\n        return True\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3745334,
                "title": "efficient-solution-one-pass-o-n-time-complexity-with-o-k-memory",
                "content": "# Intuition & Approach\\nSimple idea:\\nConsider for every `i`, we start a deletion operation that corresponds to decrementing subarray starting at `i`. \\n\\nSay, `dec` is how much you should decrement for that particular element. \\nNotice that we can greedily make `dec` into nums[0] so that we can make nums[0] into 0. Then, this `dec` value will decrement other value in the range of [0, k - 1]. However, we should store this value of dec inside of memo so that later on, when we reach `i` > `k`, we can ignore this `nums[0]`\\'s decrement since the deletion operation corresponding to subarray starting at i - k will not be affecting our `ith` element. \\n\\nIntuitively, we would need to have `memo` of size `n` to track how `dec` we do for that element. However, one can quickly notice that we only need to track the previous cycle, i.e. we only need to track at most `k` element before it. So we can use `%` operator. \\n\\nLastly, consider the edge case: we cannot start the deletion operation when `i` > `n - k`. You should. be careful here since I missed it and costs me 1 WA. \\n\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n- Space complexity:\\nO(k)\\n# Code\\nPython \\n```\\nclass Solution:\\n    def checkArray(self, nums: List[int], k: int) -> bool:\\n        n = len(nums)\\n        memo = [0] * k\\n        dec = 0\\n        for i in range(n):\\n            if i >= k:\\n                dec -= memo[i % k]\\n            rem = nums[i] - dec\\n            if i <= n - k:\\n                if rem < 0:\\n                    return False\\n                memo[i % k] = rem\\n                dec += rem\\n            else:\\n                if rem != 0:\\n                    return False\\n        return True\\n```\\n\\nGo \\n```go\\nfunc checkArray(nums []int, k int) bool {\\n    n := len(nums)\\n    memo := make([]int, k) \\n    dec := 0 \\n    for i := 0; i < n; i++ {\\n        if i >= k {\\n            dec -= memo[i % k]\\n        }\\n        rem := nums[i] - dec\\n        if i <= n - k {\\n            if rem < 0 {\\n                return false \\n            }\\n            memo[i % k] = rem \\n            dec += rem \\n        } else {\\n            if rem != 0 {\\n                return false \\n            }\\n        }\\n        \\n    }\\n    return true \\n}\\n```\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Go"
                ],
                "code": "```\\nclass Solution:\\n    def checkArray(self, nums: List[int], k: int) -> bool:\\n        n = len(nums)\\n        memo = [0] * k\\n        dec = 0\\n        for i in range(n):\\n            if i >= k:\\n                dec -= memo[i % k]\\n            rem = nums[i] - dec\\n            if i <= n - k:\\n                if rem < 0:\\n                    return False\\n                memo[i % k] = rem\\n                dec += rem\\n            else:\\n                if rem != 0:\\n                    return False\\n        return True\\n```\n```go\\nfunc checkArray(nums []int, k int) bool {\\n    n := len(nums)\\n    memo := make([]int, k) \\n    dec := 0 \\n    for i := 0; i < n; i++ {\\n        if i >= k {\\n            dec -= memo[i % k]\\n        }\\n        rem := nums[i] - dec\\n        if i <= n - k {\\n            if rem < 0 {\\n                return false \\n            }\\n            memo[i % k] = rem \\n            dec += rem \\n        } else {\\n            if rem != 0 {\\n                return false \\n            }\\n        }\\n        \\n    }\\n    return true \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3745037,
                "title": "prefixsum-greedy-easy-c-code",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n## Please Upvote if u liked my Solution\\uD83E\\uDD17\\n```\\nclass Solution {\\npublic:\\n    bool checkArray(vector<int>& nums, int k) {\\n        if(k == 1)\\n            return true;\\n        int n = nums.size(), sum = 0;\\n        vector<int> prefix(n+1);\\n        for(int i=0;i<n;i++){\\n            sum += prefix[i];\\n            int diff = nums[i] - sum;\\n            if(diff < 0)\\n                return false;\\n            if(diff && i + k > n)\\n                return false;\\n            sum += diff;\\n            if(i + k < n)\\n                prefix[i + k] -= diff;  \\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkArray(vector<int>& nums, int k) {\\n        if(k == 1)\\n            return true;\\n        int n = nums.size(), sum = 0;\\n        vector<int> prefix(n+1);\\n        for(int i=0;i<n;i++){\\n            sum += prefix[i];\\n            int diff = nums[i] - sum;\\n            if(diff < 0)\\n                return false;\\n            if(diff && i + k > n)\\n                return false;\\n            sum += diff;\\n            if(i + k < n)\\n                prefix[i + k] -= diff;  \\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3744589,
                "title": "c-easy-solution-using-segment-tree",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst of all, let us know why this problem is greedy. Because if you take left most element into account then you find that you need to subtract the value of that element from the subarray of length k starting from index 0.\\nIt means we want to to make the elements from the left side zero. For this we need dynamic prefix sum which we can build using segment tree.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n*log(n))$$ : log(n) time to find the sum from the segment tree\\n\\n- Space complexity:\\n$$O(4*n)$$ : For making the segment tree\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    #define MAXI 100010\\n    int tree[4*MAXI];\\n    \\n    void update(int node,int pos,int val,int l,int r){\\n        if(pos < l or pos > r) return;\\n        if(l == r){\\n            tree[node] += val;\\n            return;\\n        }\\n        int mid = (l+r)/2;\\n        update(2*node,pos,val,l,mid);\\n        update(2*node+1,pos,val,mid+1,r);\\n        tree[node] = tree[2*node] + tree[2*node+1];\\n    }\\n    \\n    int query(int node,int st,int en,int l,int r){\\n        if(l > en or r < st) return 0;\\n        if(l >= st and r <= en) return tree[node];\\n        int mid = (l+r)/2;\\n        \\n        int a = query(2*node,st,en,l,mid);\\n        int b = query(2*node+1,st,en,mid+1,r);\\n        return a+b;\\n    }\\n    \\n    bool checkArray(vector<int>& nums, int k) {\\n        bool ans = true;\\n        int n = (int)nums.size();\\n        \\n        for(int i=0;i<=(n-k);i++){\\n            int sum = query(1,0,i,0,n-1);\\n            // cout<<i<<\" \"<<sum<<endl;\\n            if(sum > nums[i]){\\n                ans = false;\\n                break;\\n            }\\n            int diff = nums[i] - sum;\\n            update(1,i,diff,0,n-1);\\n            if(i+k < n){\\n                update(1,i+k,-1*diff,0,n-1);\\n            }\\n        }\\n        for(int i=n-k+1;i<n;i++){\\n            int sum = query(1,0,i,0,n-1);\\n            // cout<<i<<\" \"<<sum<<endl;\\n            if(sum != nums[i]){\\n                ans = false;\\n                break;\\n            }\\n        }\\n        // cout<<\"---------------------------------\"<<endl;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Segment Tree",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define MAXI 100010\\n    int tree[4*MAXI];\\n    \\n    void update(int node,int pos,int val,int l,int r){\\n        if(pos < l or pos > r) return;\\n        if(l == r){\\n            tree[node] += val;\\n            return;\\n        }\\n        int mid = (l+r)/2;\\n        update(2*node,pos,val,l,mid);\\n        update(2*node+1,pos,val,mid+1,r);\\n        tree[node] = tree[2*node] + tree[2*node+1];\\n    }\\n    \\n    int query(int node,int st,int en,int l,int r){\\n        if(l > en or r < st) return 0;\\n        if(l >= st and r <= en) return tree[node];\\n        int mid = (l+r)/2;\\n        \\n        int a = query(2*node,st,en,l,mid);\\n        int b = query(2*node+1,st,en,mid+1,r);\\n        return a+b;\\n    }\\n    \\n    bool checkArray(vector<int>& nums, int k) {\\n        bool ans = true;\\n        int n = (int)nums.size();\\n        \\n        for(int i=0;i<=(n-k);i++){\\n            int sum = query(1,0,i,0,n-1);\\n            // cout<<i<<\" \"<<sum<<endl;\\n            if(sum > nums[i]){\\n                ans = false;\\n                break;\\n            }\\n            int diff = nums[i] - sum;\\n            update(1,i,diff,0,n-1);\\n            if(i+k < n){\\n                update(1,i+k,-1*diff,0,n-1);\\n            }\\n        }\\n        for(int i=n-k+1;i<n;i++){\\n            int sum = query(1,0,i,0,n-1);\\n            // cout<<i<<\" \"<<sum<<endl;\\n            if(sum != nums[i]){\\n                ans = false;\\n                break;\\n            }\\n        }\\n        // cout<<\"---------------------------------\"<<endl;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3744125,
                "title": "deque-and-difference-array",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkArray(vector<int>& nums, int k) {\\n        \\n        int n = nums.size();\\n        int diff[n+k+1];\\n        memset(diff, 0, sizeof diff);\\n        for(int i=0; i<k; i++)nums.push_back(0);\\n        int sum = 0;\\n        deque<int> numQ;\\n\\n        for(int i=0; i<n+k; i++) {\\n            if(!numQ.empty() && numQ.back()+sum > nums[i])return false;\\n            numQ.push_back(nums[i]);\\n            if(numQ.size()==k) {\\n                int front = numQ.front();\\n                numQ.pop_front();\\n                int difference = front+sum;\\n                sum -= difference;\\n                diff[i] += difference;\\n                sum+=diff[i-k+1];\\n            }\\n        }\\n\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkArray(vector<int>& nums, int k) {\\n        \\n        int n = nums.size();\\n        int diff[n+k+1];\\n        memset(diff, 0, sizeof diff);\\n        for(int i=0; i<k; i++)nums.push_back(0);\\n        int sum = 0;\\n        deque<int> numQ;\\n\\n        for(int i=0; i<n+k; i++) {\\n            if(!numQ.empty() && numQ.back()+sum > nums[i])return false;\\n            numQ.push_back(nums[i]);\\n            if(numQ.size()==k) {\\n                int front = numQ.front();\\n                numQ.pop_front();\\n                int difference = front+sum;\\n                sum -= difference;\\n                diff[i] += difference;\\n                sum+=diff[i-k+1];\\n            }\\n        }\\n\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3744059,
                "title": "prefix-sums",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkArray(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int>pre(n+1,0);\\n        pre[0]+=nums[0];\\n        pre[k]-=nums[0];\\n        for(int i=1;i<n;i++){\\n            pre[i]+=pre[i-1];\\n            if(pre[i]==nums[i])continue;\\n            if(pre[i]>nums[i] || i+k-1>=n)return false;\\n            long long diff=nums[i]-pre[i];\\n            pre[i]+=diff;\\n            pre[i+k]-=diff;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkArray(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int>pre(n+1,0);\\n        pre[0]+=nums[0];\\n        pre[k]-=nums[0];\\n        for(int i=1;i<n;i++){\\n            pre[i]+=pre[i-1];\\n            if(pre[i]==nums[i])continue;\\n            if(pre[i]>nums[i] || i+k-1>=n)return false;\\n            long long diff=nums[i]-pre[i];\\n            pre[i]+=diff;\\n            pre[i+k]-=diff;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3743283,
                "title": "short-easy-and-concise-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkArray(vector<int>& arr, int k) {\\n        int n = arr.size();\\n        int subtract = 0;\\n        \\n        for(int i = 0; i<n; i++){\\n            int left = i - k;\\n            if(left >= 0)\\n                subtract -= arr[left];\\n            \\n            arr[i] -= subtract;\\n            \\n            if(arr[i] < 0){\\n                return false;\\n            }\\n            \\n            if(arr[i] > 0){\\n                int right = i + k - 1;\\n                if(right >= n)\\n                    return false;\\n                subtract += arr[i];\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkArray(vector<int>& arr, int k) {\\n        int n = arr.size();\\n        int subtract = 0;\\n        \\n        for(int i = 0; i<n; i++){\\n            int left = i - k;\\n            if(left >= 0)\\n                subtract -= arr[left];\\n            \\n            arr[i] -= subtract;\\n            \\n            if(arr[i] < 0){\\n                return false;\\n            }\\n            \\n            if(arr[i] > 0){\\n                int right = i + k - 1;\\n                if(right >= n)\\n                    return false;\\n                subtract += arr[i];\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3743256,
                "title": "linear-algebra-inverse-a-triangular-matrix",
                "content": "# Intuition\\n\\nSuppose that we can erase the array by using the opration $a_i$ times at position $i$. Then the `nums` is the following sum:\\n$$\\n    \\\\text{nums}_i = \\\\sum_{j=0}^{n-k+1} \\\\sum_{\\\\ell=0}^k a_j\\\\mathbb{1}_{j+\\\\ell=1} = \\\\sum_{j=0\\\\vee i-(k-1)}^{i\\\\wedge(n-(k-1))} a_j, \\\\quad 0\\\\leq i<n\\n$$\\nNow all we have to do is to solve this equation and check that all unknowns $a_j$ are non negative. We can also add some extra $a_j$, $n-(k-1)\\\\leq j< n$. Then the system of equations have a unique solution and the anwer is `True` if all these unknown are non-negative and the last $k-1$ of them are zero. \\n\\nWorking out the equations we get:\\n$$\\n\\\\begin{aligned}\\n    \\\\text{nums}_i &= \\\\sum_{j=0}^i a_j,& 0&\\\\leq i<k\\\\\\\\\\n    \\\\text{nums}_i & = \\\\sum_{j=i-(k-1)}^{i} a_j,& k&\\\\leq i<n\\n\\\\end{aligned}\\n$$\\n\\nThen \\n\\n$$\\n\\\\text{nums}_{i}-\\\\text{nums}_{i-1}=\\n\\\\begin{cases}\\na_i & i<k\\\\\\\\\\na_i - a_{i-k} & k\\\\leq i\\n\\\\end{cases}\\n$$\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIn the code below we overwrite the array `nums`. At the end it contains the vector $a$.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def checkArray(self, nums: List[int], k: int) -> bool:\\n        n = len(nums)\\n        prev_x = 0\\n        for i, x in enumerate(nums):\\n            if i>=k:\\n                prev_x -= nums[i-k]\\n            if (i+k <= n and x < prev_x) or (i+k > n and x!= prev_x):\\n                return False\\n            nums[i] = x-prev_x\\n            prev_x = x\\n        return True\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def checkArray(self, nums: List[int], k: int) -> bool:\\n        n = len(nums)\\n        prev_x = 0\\n        for i, x in enumerate(nums):\\n            if i>=k:\\n                prev_x -= nums[i-k]\\n            if (i+k <= n and x < prev_x) or (i+k > n and x!= prev_x):\\n                return False\\n            nums[i] = x-prev_x\\n            prev_x = x\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3742838,
                "title": "simple-prefix-sum-with-extra-array-for-storage",
                "content": "# Intuition\\nWe definetly should start from the left with first non zero number\\n\\n# Approach\\nLet`s see how it works using example:\\nindex 0: ```[2,2,3,1,1,0], k = 3``` we setting current to 2 and on index 3 we should remove it\\nindex 2: we setting current to 3 (2 + 1) and on index 5 we should remove 1\\nfinal ```indexes``` array: [x,x,x,-2,x,-1]\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {boolean}\\n */\\nvar checkArray = function(nums, k) {\\n    let current = 0;\\n    const indexes = new Array(nums.length);\\n    let diff;\\n\\n    for (let i = 0; i < nums.length; ++i) {\\n      if (indexes[i]) current += indexes[i];\\n      diff = nums[i] - current;\\n      if (diff < 0) return false; // impossible to complete\\n      if (diff > 0) {\\n        current += diff;\\n        if (i + k > nums.length) return false; // failed to remove diff\\n        else indexes[i + k] = -diff;\\n      }\\n    }\\n\\n    return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```[2,2,3,1,1,0], k = 3```\n```indexes```\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {boolean}\\n */\\nvar checkArray = function(nums, k) {\\n    let current = 0;\\n    const indexes = new Array(nums.length);\\n    let diff;\\n\\n    for (let i = 0; i < nums.length; ++i) {\\n      if (indexes[i]) current += indexes[i];\\n      diff = nums[i] - current;\\n      if (diff < 0) return false; // impossible to complete\\n      if (diff > 0) {\\n        current += diff;\\n        if (i + k > nums.length) return false; // failed to remove diff\\n        else indexes[i + k] = -diff;\\n      }\\n    }\\n\\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3742574,
                "title": "rust-prefix-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n# Code\\n```\\nimpl Solution {\\n    pub fn check_array(nums: Vec<i32>, k: i32) -> bool {\\n        let mut nums = nums;\\n        let (n, k) = (nums.len(), k as usize);\\n        let mut update = vec![0; n];\\n        let mut sum = 0;\\n        \\n        for i in 0 .. n {\\n            sum += update[i];\\n            let d = nums[i] + sum;\\n            if d < 0 { return false }\\n            if d > 0 {\\n                if i + k > n { return false }\\n                update[i] -= d;\\n                sum -= d;\\n                if i + k < n { update[i + k] += d; }\\n            }\\n        }\\n        \\n        true\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn check_array(nums: Vec<i32>, k: i32) -> bool {\\n        let mut nums = nums;\\n        let (n, k) = (nums.len(), k as usize);\\n        let mut update = vec![0; n];\\n        let mut sum = 0;\\n        \\n        for i in 0 .. n {\\n            sum += update[i];\\n            let d = nums[i] + sum;\\n            if d < 0 { return false }\\n            if d > 0 {\\n                if i + k > n { return false }\\n                update[i] -= d;\\n                sum -= d;\\n                if i + k < n { update[i + k] += d; }\\n            }\\n        }\\n        \\n        true\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3742427,
                "title": "the-best-solution-to-this-problem",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(k)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkArray(vector<int>& nums, int k) {\\n        vector<int> ans(k,0);\\n        for(int i=0; i<nums.size(); i++) {\\n            ans[i%k]+=v[i];\\n        }\\n        unordered_set<int> s(ans.begin(),ans.end());\\n        return s.size()==1;\\n    }\\n};\\n```\\n\\n# Credits\\nhttps://leetcode.com/problems/apply-operations-to-make-all-array-elements-equal-to-zero/solutions/3742142/intiutive-solution-simply-take-modulus/ \\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkArray(vector<int>& nums, int k) {\\n        vector<int> ans(k,0);\\n        for(int i=0; i<nums.size(); i++) {\\n            ans[i%k]+=v[i];\\n        }\\n        unordered_set<int> s(ans.begin(),ans.end());\\n        return s.size()==1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3742257,
                "title": "using-sweeping-line-reversely",
                "content": "For each operation, we substract 1 from a subarray of length k.\\nLet\\'s think it reversely.\\nThere is a person enter a room at time $t$ and then leave the room at time $t + k$, totally stay in the room for $k$ time units.\\nMost likely we will use sweeping line to handle this kind of problem.\\n\\nThen, here, we use the sweeping line reversly.\\n\\nFor each $nums[i]$, there must have same quantity of person enter the room, and then leave the room at time $i + k$.\\nThen we only have to check that the sweeping line algorithm can indeed run till the end.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    bool checkArray(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int> sweeping(n + 1);\\n        int acc = 0;\\n        \\n        for (int i = 0; i + k <= n; ++i)\\n        {\\n            // update the accumulate value.\\n            // since we can only \\'decrease\\' any number of 1\\'s from nums, \\n            // if the accumulate value is larger than the current nums[i], \\n            // it is impossible to achieve our task.\\n            if (nums[i] < (acc += sweeping[i]))\\n                return false;\\n            \\n            // find the difference between the current nums[i] and the accumulate value, \\n            // this is the number of operations we have to perform on nums[i]...nums[i + k - 1].\\n            int d = nums[i] - acc;\\n            \\n            // update the sweeping line\\n            sweeping[i] += d;\\n            sweeping[i + k] -= d;\\n            \\n            // adjact the accumulate value.\\n            acc += d;\\n        }\\n        \\n        // the last k - 1 elements, \\n        // since we can not perform any operation on this subarray, \\n        // the current number[i] must equal to the accumulate value.\\n        for (int i = n - k + 1; i < n; ++i)\\n            if (nums[i] != (acc += sweeping[i]))\\n                return false;\\n        \\n        // finally, after check every element in nums, the accumulate value must go down to 0.\\n        return (acc += sweeping[n]) == 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    bool checkArray(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int> sweeping(n + 1);\\n        int acc = 0;\\n        \\n        for (int i = 0; i + k <= n; ++i)\\n        {\\n            // update the accumulate value.\\n            // since we can only \\'decrease\\' any number of 1\\'s from nums, \\n            // if the accumulate value is larger than the current nums[i], \\n            // it is impossible to achieve our task.\\n            if (nums[i] < (acc += sweeping[i]))\\n                return false;\\n            \\n            // find the difference between the current nums[i] and the accumulate value, \\n            // this is the number of operations we have to perform on nums[i]...nums[i + k - 1].\\n            int d = nums[i] - acc;\\n            \\n            // update the sweeping line\\n            sweeping[i] += d;\\n            sweeping[i + k] -= d;\\n            \\n            // adjact the accumulate value.\\n            acc += d;\\n        }\\n        \\n        // the last k - 1 elements, \\n        // since we can not perform any operation on this subarray, \\n        // the current number[i] must equal to the accumulate value.\\n        for (int i = n - k + 1; i < n; ++i)\\n            if (nums[i] != (acc += sweeping[i]))\\n                return false;\\n        \\n        // finally, after check every element in nums, the accumulate value must go down to 0.\\n        return (acc += sweeping[n]) == 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3742142,
                "title": "intiutive-solution-simply-take-modulus",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkArray(vector<int>& nums, int k) {\\n        \\n        int n = nums.size();\\n        vector<int> ans(k,0);\\n        for (int i = 0; i < nums.size(); i++)\\n        {\\n            ans[i%k]+=nums[i];\\n        }\\n        int m = ans[0];\\n        for (int i = 0; i < k; i++)\\n        {\\n            if(ans[i] != m)\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkArray(vector<int>& nums, int k) {\\n        \\n        int n = nums.size();\\n        vector<int> ans(k,0);\\n        for (int i = 0; i < nums.size(); i++)\\n        {\\n            ans[i%k]+=nums[i];\\n        }\\n        int m = ans[0];\\n        for (int i = 0; i < k; i++)\\n        {\\n            if(ans[i] != m)\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3741979,
                "title": "easy-cpp-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkArray(vector<int>& nums, int k) {\\n       \\n        int diff=0;\\n        int i=0;\\n        for(i;i<nums.size();i++){\\n         //   cout<<i<<\" \";\\n            if(i>=k)diff-=nums[i-k];\\n            if(i>nums.size()-k and diff-nums[i]!=0)return false;\\n            if(diff>nums[i] )return false;\\n            nums[i]=nums[i]-diff;\\n            if(i<=nums.size()-k)diff+=nums[i];\\n        }\\n       \\n       // 0 2 3 \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkArray(vector<int>& nums, int k) {\\n       \\n        int diff=0;\\n        int i=0;\\n        for(i;i<nums.size();i++){\\n         //   cout<<i<<\" \";\\n            if(i>=k)diff-=nums[i-k];\\n            if(i>nums.size()-k and diff-nums[i]!=0)return false;\\n            if(diff>nums[i] )return false;\\n            nums[i]=nums[i]-diff;\\n            if(i<=nums.size()-k)diff+=nums[i];\\n        }\\n       \\n       // 0 2 3 \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3741513,
                "title": "window-trick",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkArray(vector<int>& nums, int k) \\n    {\\n        int n=nums.size(),sum=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(sum>nums[i])\\n                return 0;\\n            \\n            nums[i]-=sum;\\n            sum+=nums[i];\\n            \\n            if(i>=k-1)\\n                sum-=nums[i-k+1];\\n        }\\n        return (sum==0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkArray(vector<int>& nums, int k) \\n    {\\n        int n=nums.size(),sum=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(sum>nums[i])\\n                return 0;\\n            \\n            nums[i]-=sum;\\n            sum+=nums[i];\\n            \\n            if(i>=k-1)\\n                sum-=nums[i-k+1];\\n        }\\n        return (sum==0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3740775,
                "title": "simplest-two-pointer-prefix-sum-solution-in-c-with-explanation-and-comments",
                "content": "# Approach\\nSo at any point of time if number is less than 0 then answer is -1.\\nAnd if we are standing at ith position then how many operations has performed in this index can be found by prefix array and if still the number is greater than 0 then we have to apply nums[i] times operations so we will add -nums[i] in prefix[i] and add nums[i] to prefix[i + k] so that each and every number from range can be increase via +1/-1 prefix concept.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkArray(vector<int>& nums, int k) {\\n        // inserting any random number to make array 1-base indexing\\n        nums.insert(nums.begin(), -1);\\n        int n = nums.size();\\n        // creating prefix array\\n        vector<int> pre(n + 2, 0);\\n        int i = 1;\\n        while(i < n){\\n            pre[i] += pre[i - 1];\\n            // operations till now\\n            nums[i] += pre[i];\\n            // if less than 0 then we can\\'t do anything\\n            if(nums[i] < 0) return false;\\n            if(nums[i]){\\n                // if we cannot choose any subarray of size k\\n                if(i + k > n) return false;\\n                // we have do nums[i] operation from i to i + k\\n                pre[i] -= nums[i];\\n                pre[i + k] += nums[i];\\n            }\\n            i++;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkArray(vector<int>& nums, int k) {\\n        // inserting any random number to make array 1-base indexing\\n        nums.insert(nums.begin(), -1);\\n        int n = nums.size();\\n        // creating prefix array\\n        vector<int> pre(n + 2, 0);\\n        int i = 1;\\n        while(i < n){\\n            pre[i] += pre[i - 1];\\n            // operations till now\\n            nums[i] += pre[i];\\n            // if less than 0 then we can\\'t do anything\\n            if(nums[i] < 0) return false;\\n            if(nums[i]){\\n                // if we cannot choose any subarray of size k\\n                if(i + k > n) return false;\\n                // we have do nums[i] operation from i to i + k\\n                pre[i] -= nums[i];\\n                pre[i + k] += nums[i];\\n            }\\n            i++;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3740221,
                "title": "c-python-difference-array-solutoin-with-explanation",
                "content": "### difference array\\nEach value of subarrays add or subtract a numbers at the same time, we can use difference array to do this operation.\\n\\n```diff[i]``` is difference value for nums[i],\\n```cur_diff``` is accumulated difference value from ```diff[0]``` to ```diff[i]```.\\n```nums[i] + cur_diff``` is current value of ```nums[i]```.\\nWhen we substract a number ```v``` for each value of subarray ```nums[p...p+k]```(not included p+k),\\n```cur_diff -=v``` and ```diff[p+k]+=v```.\\n\\nWalking through ```nums``` from left to right,\\nwhen we meet a endpoint ```p``` of non-zero subarray,  ```nums[p...p+k] - nums[p]```,\\nif current value ```nums[i]``` is 0, skip it.\\nif current value ```nums[i]``` < 0, return False.\\nif current value ```nums[i]``` > 0, ```nums[i...i+k] - nums[i]```, then  ```nums[i]``` will be 0, if we can not do this operation, return False.\\n\\ntc is O(n), sc is O(n).\\n\\n### python\\n```python\\nclass Solution:\\n    def checkArray(self, nums: List[int], k: int) -> bool:\\n        size = len(nums)\\n\\t\\t\\n\\t\\t# difference array\\n        diff = [0] * (size + 1)\\n\\t\\t\\n        cur_diff = 0 # accumulated difference value from diff[0] to diff[i]\\n\\t\\t\\n\\t\\t# for each value\\n        for i, v in enumerate(nums):\\n\\t\\t\\n\\t\\t\\t# accumulate difference value\\n            cur_diff += diff[i]\\n\\t\\t\\t\\n\\t\\t\\t# curent value of nums[i]\\n            v += cur_diff\\n\\t\\t\\t\\n\\t\\t\\t# curent value is 0, skip it\\n            if v == 0: continue\\n\\t\\t\\t\\n\\t\\t\\t# if curent value < 0, we can not increase value, return false\\n\\t\\t\\t# subarray [i, i+k) substract curent value, if we can not do this operation, return false\\n            elif v < 0 or i + k > size: return False\\n\\t\\t\\t\\n\\t\\t\\t#  subarray [i, i+k) substract current value\\n            cur_diff -= v\\n            diff[i + k] += v\\n        return True\\n```\\n\\n### c++\\n```cpp\\nclass Solution {\\npublic:\\n    bool checkArray(vector<int>& nums, int k) {\\n        int size = nums.size();\\n        vector<int> diff (size + 1);\\n        int cur_diff = 0;\\n        for (int i = 0; i < size; i+=1) {\\n            cur_diff += diff[i];\\n            nums[i] += cur_diff;\\n            if (nums[i] == 0) continue;\\n            else if (nums[i] < 0 || i + k > size) return false;\\n            cur_diff -= nums[i];\\n            diff[i+k] += nums[i];\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Python",
                    "C",
                    "Array"
                ],
                "code": "```diff[i]```\n```cur_diff```\n```diff[0]```\n```diff[i]```\n```nums[i] + cur_diff```\n```nums[i]```\n```v```\n```nums[p...p+k]```\n```cur_diff -=v```\n```diff[p+k]+=v```\n```nums```\n```p```\n```nums[p...p+k] - nums[p]```\n```nums[i]```\n```nums[i]```\n```nums[i]```\n```nums[i...i+k] - nums[i]```\n```nums[i]```\n```python\\nclass Solution:\\n    def checkArray(self, nums: List[int], k: int) -> bool:\\n        size = len(nums)\\n\\t\\t\\n\\t\\t# difference array\\n        diff = [0] * (size + 1)\\n\\t\\t\\n        cur_diff = 0 # accumulated difference value from diff[0] to diff[i]\\n\\t\\t\\n\\t\\t# for each value\\n        for i, v in enumerate(nums):\\n\\t\\t\\n\\t\\t\\t# accumulate difference value\\n            cur_diff += diff[i]\\n\\t\\t\\t\\n\\t\\t\\t# curent value of nums[i]\\n            v += cur_diff\\n\\t\\t\\t\\n\\t\\t\\t# curent value is 0, skip it\\n            if v == 0: continue\\n\\t\\t\\t\\n\\t\\t\\t# if curent value < 0, we can not increase value, return false\\n\\t\\t\\t# subarray [i, i+k) substract curent value, if we can not do this operation, return false\\n            elif v < 0 or i + k > size: return False\\n\\t\\t\\t\\n\\t\\t\\t#  subarray [i, i+k) substract current value\\n            cur_diff -= v\\n            diff[i + k] += v\\n        return True\\n```\n```cpp\\nclass Solution {\\npublic:\\n    bool checkArray(vector<int>& nums, int k) {\\n        int size = nums.size();\\n        vector<int> diff (size + 1);\\n        int cur_diff = 0;\\n        for (int i = 0; i < size; i+=1) {\\n            cur_diff += diff[i];\\n            nums[i] += cur_diff;\\n            if (nums[i] == 0) continue;\\n            else if (nums[i] < 0 || i + k > size) return false;\\n            cur_diff -= nums[i];\\n            diff[i+k] += nums[i];\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3740213,
                "title": "golang-with-step-explanation",
                "content": "\\n# Code\\n```\\nfunc checkArray(nums []int, k int) bool {\\n    n := len(nums) // Get the length of the nums array\\n\\n    // subtractMinValue is a function that subtracts the minimum value in a subarray of length k\\n    subtractMinValue := func(startIndex int) bool {\\n        minVal := nums[startIndex] // Get the minimum value in the subarray starting at startIndex\\n        for j := startIndex; j < startIndex+k; j++ {\\n            nums[j] -= minVal // Subtract the minimum value from each element in the subarray\\n            if nums[j] < 0 {\\n                return false // If any element becomes negative, return false\\n            }\\n        }\\n        return true // If all elements are non-negative after subtraction, return true\\n    }\\n    \\n    // checkRemainingElements is a function that checks if all elements from a given index till the end are zero\\n    checkRemainingElements := func(startIndex int) bool {\\n        for i := startIndex; i < n; i++ {\\n            if nums[i] != 0 {\\n                return false // If any element is non-zero, return false\\n            }\\n        }\\n        return true // If all elements are zero, return true\\n    }\\n\\n    // Iterate through the nums array from index 0 to n-k (inclusive)\\n    for i := 0; i < n-k+1; i++ {\\n        if nums[i] > 0 {\\n            if !subtractMinValue(i) {\\n                return false // If subtracting the minimum value fails, return false\\n            }\\n        }\\n    }\\n\\n    // Check if all remaining elements from index n-k+1 till the end are zero\\n    return checkRemainingElements(n - k + 1)\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc checkArray(nums []int, k int) bool {\\n    n := len(nums) // Get the length of the nums array\\n\\n    // subtractMinValue is a function that subtracts the minimum value in a subarray of length k\\n    subtractMinValue := func(startIndex int) bool {\\n        minVal := nums[startIndex] // Get the minimum value in the subarray starting at startIndex\\n        for j := startIndex; j < startIndex+k; j++ {\\n            nums[j] -= minVal // Subtract the minimum value from each element in the subarray\\n            if nums[j] < 0 {\\n                return false // If any element becomes negative, return false\\n            }\\n        }\\n        return true // If all elements are non-negative after subtraction, return true\\n    }\\n    \\n    // checkRemainingElements is a function that checks if all elements from a given index till the end are zero\\n    checkRemainingElements := func(startIndex int) bool {\\n        for i := startIndex; i < n; i++ {\\n            if nums[i] != 0 {\\n                return false // If any element is non-zero, return false\\n            }\\n        }\\n        return true // If all elements are zero, return true\\n    }\\n\\n    // Iterate through the nums array from index 0 to n-k (inclusive)\\n    for i := 0; i < n-k+1; i++ {\\n        if nums[i] > 0 {\\n            if !subtractMinValue(i) {\\n                return false // If subtracting the minimum value fails, return false\\n            }\\n        }\\n    }\\n\\n    // Check if all remaining elements from index n-k+1 till the end are zero\\n    return checkRemainingElements(n - k + 1)\\n}\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3739996,
                "title": "easy-to-understand-detailed-approach-with-images",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAs we cannot delete each element of subarray one by one because of the constraints we have to find a way to subtract a subarray in one operation.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDeclare a dp array which will store the number which we have to subtract from the element. If after all operation if the dp array is equal to the original array, we will return true, else return false.\\n\\nFirst, we will initialize dp[0] = nums[0], i.e. the no which we will need to subtract and initialize dp[k] = (-nums[0]), as we keep going if dp[i]+dp[i-1] is greater than nums[i], it will mean that we cannot get the answer.\\n\\nEg. - \\nnums = [60,72,87,89,63,52,64,62,31,37,57,83,98,94,92,77,94,91,87,100,91,91,50,26]\\nk = 4\\n\\nThis will be the flow of the dp array - \\n![image.png](https://assets.leetcode.com/users/images/64229320-3ba9-4d12-ac69-e4b14ad20421_1688889191.3657138.png)\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkArray(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        \\n        vector<int> dp(n+1,0);\\n        dp[0] += nums[0];\\n        dp[k] -= nums[0];\\n        for(int i=1;i<n;i++){\\n            if(dp[i-1]+dp[i] == nums[i]){\\n                dp[i] = nums[i];\\n            }else if(dp[i-1]+dp[i] < nums[i]){\\n                if(i+k > n) return false;\\n                else{\\n                    dp[i+k] -= (nums[i]-dp[i-1]-dp[i]);\\n                    dp[i] = nums[i];\\n                }\\n            }else{\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkArray(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        \\n        vector<int> dp(n+1,0);\\n        dp[0] += nums[0];\\n        dp[k] -= nums[0];\\n        for(int i=1;i<n;i++){\\n            if(dp[i-1]+dp[i] == nums[i]){\\n                dp[i] = nums[i];\\n            }else if(dp[i-1]+dp[i] < nums[i]){\\n                if(i+k > n) return false;\\n                else{\\n                    dp[i+k] -= (nums[i]-dp[i-1]-dp[i]);\\n                    dp[i] = nums[i];\\n                }\\n            }else{\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3739595,
                "title": "swift-sliding-window-approach-explained",
                "content": "# Intuition\\n- If there is a winning set of operations, then the order in which these operations are performed does not matter.\\n- The first and last numbers have only one variant of valid subarray that affects them.\\n- More generally, the same can be said for the first and last non-zero nums.\\n- We can reduce nums to zero one-by-one by going from left to right and performing `num[i]` decrease operations on subarray starting at `i`. By virtue of our first statement, if there is a winning set of operations, it can be arranged this way.\\n- If any number will drop below zero due to decrease operation initiated by some of the previous nums, the goal is unachievable.\\n\\n# Approach\\n\\nWe will not straightforwardly perform the \\'decrease by num[i]\\' operation on the whole $k$ nums after each index `i`. Instead, we note that the decrement for a number is only affected by the previous $k-1$ numbs, or, more precisely, accumulated decrement for `num[i]` is $\\\\sum$`num[j]`, where $max(0, i-k) \\\\le j \\\\lt i$, and `num[j]` is the current value at `j` index when we reached `j` in the process, applied its own decrement, and then considered the subarray starting from `j`.\\nWe\\'ll denote this decrement value as `slidingSum` and update it in a sliding window manner, by adding next num value and subtracting the last, $(k+1)$th from head since it drops out of the affecting range. Simply saying, we mantain $k$ size sliding window, keeping track of its sum. This way we know how much to subtract from the each next number.\\n\\n# Complexity\\n- Time complexity: $O(n)$\\n- Space complexity: $O(1)$\\n\\n# Code\\n```\\nclass Solution {\\n    func checkArray(_ nums: [Int], _ k: Int) -> Bool\\n    {\\n        let n = nums.count\\n        if k == 1 { return true }\\n        if k == n { return nums.allSatisfy { $0 == nums[0] } }\\n        \\n        var nums = nums, slidingSum = 0\\n        for i in 0..<n\\n        {\\n            // remove exceeding\\n            if i >= k { slidingSum -= nums[i-k] }\\n\\n            // bringing previous nums to zero causes this num to become negative\\n            if nums[i] < slidingSum { return false }\\n\\n            // apply the accumulated decrement\\n            nums[i] -= slidingSum\\n\\n            // advance, taking into account that for the next k-1 elements, the\\n            // decrement will be increased by the value remained in that num\\n            if i <= n-k { slidingSum += nums[i] }\\n\\n            // our window bumped into right border and now shrinks\\n            // no more operations possible, we just check whether the\\n            // previously arranged ones will bring all the remaining nums to zero\\n            else if nums[i] != 0 { return false }\\n        }\\n        return true\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    func checkArray(_ nums: [Int], _ k: Int) -> Bool\\n    {\\n        let n = nums.count\\n        if k == 1 { return true }\\n        if k == n { return nums.allSatisfy { $0 == nums[0] } }\\n        \\n        var nums = nums, slidingSum = 0\\n        for i in 0..<n\\n        {\\n            // remove exceeding\\n            if i >= k { slidingSum -= nums[i-k] }\\n\\n            // bringing previous nums to zero causes this num to become negative\\n            if nums[i] < slidingSum { return false }\\n\\n            // apply the accumulated decrement\\n            nums[i] -= slidingSum\\n\\n            // advance, taking into account that for the next k-1 elements, the\\n            // decrement will be increased by the value remained in that num\\n            if i <= n-k { slidingSum += nums[i] }\\n\\n            // our window bumped into right border and now shrinks\\n            // no more operations possible, we just check whether the\\n            // previously arranged ones will bring all the remaining nums to zero\\n            else if nums[i] != 0 { return false }\\n        }\\n        return true\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3739524,
                "title": "easy-intuitive-solution-well-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nhttps://youtu.be/lV_9brUikts\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkArray(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int> carriedDiff(n+1,0);\\n        \\n        int cur = 0; \\n        for(int i=0;i<n;i++){\\n            cur+=carriedDiff[i];\\n            if(cur>nums[i]) return false;\\n            \\n            int d = nums[i]-cur;\\n            if(d==0) continue;\\n            if(i+k>n) return false;\\n            \\n            cur+=d;\\n            carriedDiff[i+k]-=d;\\n        }\\n        return true;\\n        \\n    }\\n};\\n\\n// [0,4,2,2,3, 1,1,0,4]\\n      // 4     -4\\n//        2 0 0 -2\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkArray(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int> carriedDiff(n+1,0);\\n        \\n        int cur = 0; \\n        for(int i=0;i<n;i++){\\n            cur+=carriedDiff[i];\\n            if(cur>nums[i]) return false;\\n            \\n            int d = nums[i]-cur;\\n            if(d==0) continue;\\n            if(i+k>n) return false;\\n            \\n            cur+=d;\\n            carriedDiff[i+k]-=d;\\n        }\\n        return true;\\n        \\n    }\\n};\\n\\n// [0,4,2,2,3, 1,1,0,4]\\n      // 4     -4\\n//        2 0 0 -2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3739513,
                "title": "rust-python-linear-time-complexity-with-explanation",
                "content": "# Intuition\\nLets ignore the edge case where `k = 1` because you can always zero out the whole array in this case.\\n\\nLets look at some array `[1,4,4,10,9,6,6,2,3,7,7,5,4]` and `k=4`\\n\\nWe are looking at some position and the only way to zero it out is to subtract the values from it. When you subtract it, you do it for the whole range.\\n\\nSo here are some of the iterations:\\n\\n```\\n[1,4,4,10,9,6,6,2,3,7,7,5,4]\\n[0,3,3, 9,9,6,6,2,3,7,7,5,4]\\n[0,0,0, 6,6,6,6,2,3,7,7,5,4]\\n...\\n```\\nWhen do we stop? If we see that at some position we have a negative value, then we are out of luck and we have to stop (and return false)\\n\\nYou can implement it like this:\\n\\n```\\n  def checkArray_brute(self, nums: List[int], k: int) -> bool:\\n    for i in range(len(nums) - k + 1):\\n      if nums[i] == 0:\\n        continue\\n\\n      for j in range(1, k):\\n        if nums[i + j] < nums[i]:\\n          return False\\n        nums[i + j] -= nums[i]\\n      nums[i] = 0\\n\\n    return sum(nums) == 0\\n```\\n\\nThis implementation is correct, but the problem is that it will run in `O(nk)`. So we need to do something more clever. \\n\\nThere can be many ways to improve it (and some are more brief than this one). The implementation here is mostly shows how you can modify our less efficient solution.\\n\\nThe issue we have is that when we subract values from the range it takes $O(k)$. When we want to add value to the range [i, j] you can store the current increase value and the value at which you should decrease it. \\n\\nso instead of `[. . . x x x x . .]` where x is the value we add to the range, we do `[. . . x . . . -x . .], so we know when to decrease it.\\n\\n\\n\\n# Complexity\\n- Time complexity: $O(n)$\\n- Space complexity: $O(n)$\\n\\n# Code\\n```Rust []\\nimpl Solution {\\n  pub fn check_array(mut nums: Vec<i32>, k: i32) -> bool {\\n    if k == 1 {\\n      return true;\\n    }\\n\\n    let mut curr = 0;\\n    let mut data = vec![0; nums.len() + k as usize];\\n\\n    for i in 0 .. nums.len() {\\n      curr -= data[i];\\n      nums[i] -= curr;\\n      if nums[i] < 0 {\\n        return false;\\n      }\\n\\n      if nums[i] > 0 {\\n        curr += nums[i];\\n        data[i + k as usize] = nums[i];\\n      }\\n    }\\n\\n    let mut res = 0;\\n    for i in data.len() + 1 - k as usize .. data.len() {\\n      res += data[i];\\n    }\\n    return res == 0;\\n  }\\n}\\n```\\n```python []\\nclass Solution:\\n  def checkArray(self, nums: List[int], k: int) -> bool:\\n    if k == 1:\\n      return True\\n\\n    curr, data = 0, [0] * (len(nums) + k)\\n\\n    for i in range(len(nums)):\\n      curr -= data[i]\\n      nums[i] -= curr\\n      if nums[i] < 0:\\n        return False\\n\\n      if nums[i] > 0:\\n        curr += nums[i]\\n        data[i + k] = nums[i]\\n\\n    return sum(data[-k + 1:]) == 0\\n```\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n[1,4,4,10,9,6,6,2,3,7,7,5,4]\\n[0,3,3, 9,9,6,6,2,3,7,7,5,4]\\n[0,0,0, 6,6,6,6,2,3,7,7,5,4]\\n...\\n```\n```\\n  def checkArray_brute(self, nums: List[int], k: int) -> bool:\\n    for i in range(len(nums) - k + 1):\\n      if nums[i] == 0:\\n        continue\\n\\n      for j in range(1, k):\\n        if nums[i + j] < nums[i]:\\n          return False\\n        nums[i + j] -= nums[i]\\n      nums[i] = 0\\n\\n    return sum(nums) == 0\\n```\n```Rust []\\nimpl Solution {\\n  pub fn check_array(mut nums: Vec<i32>, k: i32) -> bool {\\n    if k == 1 {\\n      return true;\\n    }\\n\\n    let mut curr = 0;\\n    let mut data = vec![0; nums.len() + k as usize];\\n\\n    for i in 0 .. nums.len() {\\n      curr -= data[i];\\n      nums[i] -= curr;\\n      if nums[i] < 0 {\\n        return false;\\n      }\\n\\n      if nums[i] > 0 {\\n        curr += nums[i];\\n        data[i + k as usize] = nums[i];\\n      }\\n    }\\n\\n    let mut res = 0;\\n    for i in data.len() + 1 - k as usize .. data.len() {\\n      res += data[i];\\n    }\\n    return res == 0;\\n  }\\n}\\n```\n```python []\\nclass Solution:\\n  def checkArray(self, nums: List[int], k: int) -> bool:\\n    if k == 1:\\n      return True\\n\\n    curr, data = 0, [0] * (len(nums) + k)\\n\\n    for i in range(len(nums)):\\n      curr -= data[i]\\n      nums[i] -= curr\\n      if nums[i] < 0:\\n        return False\\n\\n      if nums[i] > 0:\\n        curr += nums[i]\\n        data[i + k] = nums[i]\\n\\n    return sum(data[-k + 1:]) == 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3739461,
                "title": "c-queue-sliding-window",
                "content": "```\\nclass Solution {\\npublic:\\n  bool checkArray(vector<int>& nums, int k) {\\n    int n = nums.size();\\n    queue<pair<int, int>> q;\\n    q.push({k - 1, nums[0]});\\n    int decSum = nums[0];\\n    for (int i = 1; i < n; ++i) {\\n      auto [idx, dec] = q.front();\\n      if (idx < i) {\\n        q.pop();\\n        decSum -= dec;\\n      }\\n      if (decSum > nums[i]) return false;\\n      if (i + k - 1 < n) {\\n        q.push({i + k - 1, nums[i] - decSum});\\n        decSum += (nums[i] - decSum);\\n      } else {\\n        if (decSum != nums[i]) return false;\\n      }\\n    }\\n    return true;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n  bool checkArray(vector<int>& nums, int k) {\\n    int n = nums.size();\\n    queue<pair<int, int>> q;\\n    q.push({k - 1, nums[0]});\\n    int decSum = nums[0];\\n    for (int i = 1; i < n; ++i) {\\n      auto [idx, dec] = q.front();\\n      if (idx < i) {\\n        q.pop();\\n        decSum -= dec;\\n      }\\n      if (decSum > nums[i]) return false;\\n      if (i + k - 1 < n) {\\n        q.push({i + k - 1, nums[i] - decSum});\\n        decSum += (nums[i] - decSum);\\n      } else {\\n        if (decSum != nums[i]) return false;\\n      }\\n    }\\n    return true;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3739286,
                "title": "c-sliding-window",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkArray(vector<int>& nums, int k) {\\n        \\n        int n=nums.size();\\n        int j=0;\\n         int curr=0;\\n        vector<int>inc(n,0);\\n        for(int i=0;i<n;i++){\\n            \\n            int del=(nums[i]-curr);\\n             curr+=del;\\n            inc[i]=del;  \\n            if(del<0) return 0;\\n            \\n           \\n            \\n            if(i-j==k-1){\\n                 curr-=inc[j] ;\\n                j++;\\n            }\\n            \\n              \\n        }\\n        return curr==0;\\n       \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkArray(vector<int>& nums, int k) {\\n        \\n        int n=nums.size();\\n        int j=0;\\n         int curr=0;\\n        vector<int>inc(n,0);\\n        for(int i=0;i<n;i++){\\n            \\n            int del=(nums[i]-curr);\\n             curr+=del;\\n            inc[i]=del;  \\n            if(del<0) return 0;\\n            \\n           \\n            \\n            if(i-j==k-1){\\n                 curr-=inc[j] ;\\n                j++;\\n            }\\n            \\n              \\n        }\\n        return curr==0;\\n       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3739228,
                "title": "python-3-track-elevations",
                "content": "# Intuition\\nSorting similar to line sweep, use the inverse operation, building nums from all zeros.\\n\\nAt any index `i`, we have a current level `cur`, if cur is less than `nums[i]`, we need to apply the operation `nums[i] - cur` times to the next k locations. Instead of change them literally, we only update the level `cur` and track the end position `i + k`, where we substract `nums[i] - cur`.\\n\\nAny time `cur > nums[i]`, we found an violation since the inverse op can only +1 not -1. Another type of violation is when the end positioon `i + k > n`, i.e. a building block needs to extend passing the last index.\\n\\nMy original was using heap, which is an overkill. Since width of the elevations are all k, i.e. their terminations come in order, a simple array is enough.\\n\\n\\nAlternative O(n) TC and O(1) SC sliding window solution added, which modifies elements to track elevations. Inspired by [lee215](https://leetcode.com/problems/apply-operations-to-make-all-array-elements-equal-to-zero/solutions/3739101/java-c-python-greedy-sliding-window/).\\n\\n# Code\\n```\\nclass Solution:\\n    def checkArray(self, nums: List[int], k: int) -> bool:\\n        n = len(nums)\\n        cur = 0\\n        elv = deque()\\n        for i in range(n):\\n            if elv and i == elv[0][0]:\\n                _, x = elv.popleft()\\n                cur -= x\\n            if cur < nums[i]:\\n                if i + k > n:\\n                    return False\\n                elv += [(i + k, nums[i] - cur)]\\n                cur = nums[i]\\n            elif cur > nums[i]:\\n                return False\\n        return True\\n```\\n\\n```\\nclass Solution:\\n    def checkArray(self, nums: List[int], k: int) -> bool:\\n        cur = 0\\n        nums += [0] # must append a 0, need to check when exiting nums cur reaches back to 0\\n        for i, v in enumerate(nums):\\n            if i >= k:\\n                cur -= nums[i - k] # remove elevation exiting a k block\\n            if cur > v:\\n                return False\\n            nums[i] = v - cur # elevation\\n            cur = v # elevated\\n        return True\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def checkArray(self, nums: List[int], k: int) -> bool:\\n        n = len(nums)\\n        cur = 0\\n        elv = deque()\\n        for i in range(n):\\n            if elv and i == elv[0][0]:\\n                _, x = elv.popleft()\\n                cur -= x\\n            if cur < nums[i]:\\n                if i + k > n:\\n                    return False\\n                elv += [(i + k, nums[i] - cur)]\\n                cur = nums[i]\\n            elif cur > nums[i]:\\n                return False\\n        return True\\n```\n```\\nclass Solution:\\n    def checkArray(self, nums: List[int], k: int) -> bool:\\n        cur = 0\\n        nums += [0] # must append a 0, need to check when exiting nums cur reaches back to 0\\n        for i, v in enumerate(nums):\\n            if i >= k:\\n                cur -= nums[i - k] # remove elevation exiting a k block\\n            if cur > v:\\n                return False\\n            nums[i] = v - cur # elevation\\n            cur = v # elevated\\n        return True\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1962242,
                "content": [
                    {
                        "username": "AkhilPadmanaban123",
                        "content": "Nice question. Todays Contest, I was able to do one question. and this one I did 3/4th. didnt get a small logic. But I am happy that I improved"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "1021/1022 hits hard"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "Even I can feel your pain mate !!"
                    },
                    {
                        "username": "abhishekpradhan931",
                        "content": "+1 brother"
                    },
                    {
                        "username": "katharva01",
                        "content": "passes all testcases 124/124  , but still showing TLE.\\nAnyone knows why ?"
                    },
                    {
                        "username": "ekansh1309",
                        "content": "What if they asked for minimum number of operations required to make array equal to 0?? "
                    },
                    {
                        "username": "ekansh1309",
                        "content": "[@BetoSCL](/BetoSCL)   Let say the question is to find the minimum number of operations required to make array equal to 0. If not possible then return -1."
                    },
                    {
                        "username": "BetoSCL",
                        "content": "There is no minimum, if it is possible, the number of operations is fixed since $k$ is always subtracted from $sum = \\Sigma_{i = 0}^{n-1}nums[i]$ so the number of operations is exactly $\ffrac{sum}{k}$ (sum/k sometimes latex doesn't render in comments), if the operation were to subtract any number $0<x$ in that case there is probably a minimum but I am not sure about that."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "but how did one can conclude \"need to move from left to right \" "
                    },
                    {
                        "username": "SAIVARUN_GAJULA",
                        "content": "you can move from right to left too...it\\'s because you can make the border elements zero only by applying the operation for subarray ending at n-1 nums[n-1] times "
                    },
                    {
                        "username": "sameer89",
                        "content": "It is the greedy approach, We are greedily thinking to elimate the first element in the window and then during sliding we are not thinking about the first element because we already made it zero. "
                    }
                ]
            },
            {
                "id": 1962293,
                "content": [
                    {
                        "username": "AkhilPadmanaban123",
                        "content": "Nice question. Todays Contest, I was able to do one question. and this one I did 3/4th. didnt get a small logic. But I am happy that I improved"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "1021/1022 hits hard"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "Even I can feel your pain mate !!"
                    },
                    {
                        "username": "abhishekpradhan931",
                        "content": "+1 brother"
                    },
                    {
                        "username": "katharva01",
                        "content": "passes all testcases 124/124  , but still showing TLE.\\nAnyone knows why ?"
                    },
                    {
                        "username": "ekansh1309",
                        "content": "What if they asked for minimum number of operations required to make array equal to 0?? "
                    },
                    {
                        "username": "ekansh1309",
                        "content": "[@BetoSCL](/BetoSCL)   Let say the question is to find the minimum number of operations required to make array equal to 0. If not possible then return -1."
                    },
                    {
                        "username": "BetoSCL",
                        "content": "There is no minimum, if it is possible, the number of operations is fixed since $k$ is always subtracted from $sum = \\Sigma_{i = 0}^{n-1}nums[i]$ so the number of operations is exactly $\ffrac{sum}{k}$ (sum/k sometimes latex doesn't render in comments), if the operation were to subtract any number $0<x$ in that case there is probably a minimum but I am not sure about that."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "but how did one can conclude \"need to move from left to right \" "
                    },
                    {
                        "username": "SAIVARUN_GAJULA",
                        "content": "you can move from right to left too...it\\'s because you can make the border elements zero only by applying the operation for subarray ending at n-1 nums[n-1] times "
                    },
                    {
                        "username": "sameer89",
                        "content": "It is the greedy approach, We are greedily thinking to elimate the first element in the window and then during sliding we are not thinking about the first element because we already made it zero. "
                    }
                ]
            },
            {
                "id": 1964283,
                "content": [
                    {
                        "username": "AkhilPadmanaban123",
                        "content": "Nice question. Todays Contest, I was able to do one question. and this one I did 3/4th. didnt get a small logic. But I am happy that I improved"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "1021/1022 hits hard"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "Even I can feel your pain mate !!"
                    },
                    {
                        "username": "abhishekpradhan931",
                        "content": "+1 brother"
                    },
                    {
                        "username": "katharva01",
                        "content": "passes all testcases 124/124  , but still showing TLE.\\nAnyone knows why ?"
                    },
                    {
                        "username": "ekansh1309",
                        "content": "What if they asked for minimum number of operations required to make array equal to 0?? "
                    },
                    {
                        "username": "ekansh1309",
                        "content": "[@BetoSCL](/BetoSCL)   Let say the question is to find the minimum number of operations required to make array equal to 0. If not possible then return -1."
                    },
                    {
                        "username": "BetoSCL",
                        "content": "There is no minimum, if it is possible, the number of operations is fixed since $k$ is always subtracted from $sum = \\Sigma_{i = 0}^{n-1}nums[i]$ so the number of operations is exactly $\ffrac{sum}{k}$ (sum/k sometimes latex doesn't render in comments), if the operation were to subtract any number $0<x$ in that case there is probably a minimum but I am not sure about that."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "but how did one can conclude \"need to move from left to right \" "
                    },
                    {
                        "username": "SAIVARUN_GAJULA",
                        "content": "you can move from right to left too...it\\'s because you can make the border elements zero only by applying the operation for subarray ending at n-1 nums[n-1] times "
                    },
                    {
                        "username": "sameer89",
                        "content": "It is the greedy approach, We are greedily thinking to elimate the first element in the window and then during sliding we are not thinking about the first element because we already made it zero. "
                    }
                ]
            },
            {
                "id": 1963881,
                "content": [
                    {
                        "username": "AkhilPadmanaban123",
                        "content": "Nice question. Todays Contest, I was able to do one question. and this one I did 3/4th. didnt get a small logic. But I am happy that I improved"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "1021/1022 hits hard"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "Even I can feel your pain mate !!"
                    },
                    {
                        "username": "abhishekpradhan931",
                        "content": "+1 brother"
                    },
                    {
                        "username": "katharva01",
                        "content": "passes all testcases 124/124  , but still showing TLE.\\nAnyone knows why ?"
                    },
                    {
                        "username": "ekansh1309",
                        "content": "What if they asked for minimum number of operations required to make array equal to 0?? "
                    },
                    {
                        "username": "ekansh1309",
                        "content": "[@BetoSCL](/BetoSCL)   Let say the question is to find the minimum number of operations required to make array equal to 0. If not possible then return -1."
                    },
                    {
                        "username": "BetoSCL",
                        "content": "There is no minimum, if it is possible, the number of operations is fixed since $k$ is always subtracted from $sum = \\Sigma_{i = 0}^{n-1}nums[i]$ so the number of operations is exactly $\ffrac{sum}{k}$ (sum/k sometimes latex doesn't render in comments), if the operation were to subtract any number $0<x$ in that case there is probably a minimum but I am not sure about that."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "but how did one can conclude \"need to move from left to right \" "
                    },
                    {
                        "username": "SAIVARUN_GAJULA",
                        "content": "you can move from right to left too...it\\'s because you can make the border elements zero only by applying the operation for subarray ending at n-1 nums[n-1] times "
                    },
                    {
                        "username": "sameer89",
                        "content": "It is the greedy approach, We are greedily thinking to elimate the first element in the window and then during sliding we are not thinking about the first element because we already made it zero. "
                    }
                ]
            },
            {
                "id": 1966121,
                "content": [
                    {
                        "username": "AkhilPadmanaban123",
                        "content": "Nice question. Todays Contest, I was able to do one question. and this one I did 3/4th. didnt get a small logic. But I am happy that I improved"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "1021/1022 hits hard"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "Even I can feel your pain mate !!"
                    },
                    {
                        "username": "abhishekpradhan931",
                        "content": "+1 brother"
                    },
                    {
                        "username": "katharva01",
                        "content": "passes all testcases 124/124  , but still showing TLE.\\nAnyone knows why ?"
                    },
                    {
                        "username": "ekansh1309",
                        "content": "What if they asked for minimum number of operations required to make array equal to 0?? "
                    },
                    {
                        "username": "ekansh1309",
                        "content": "[@BetoSCL](/BetoSCL)   Let say the question is to find the minimum number of operations required to make array equal to 0. If not possible then return -1."
                    },
                    {
                        "username": "BetoSCL",
                        "content": "There is no minimum, if it is possible, the number of operations is fixed since $k$ is always subtracted from $sum = \\Sigma_{i = 0}^{n-1}nums[i]$ so the number of operations is exactly $\ffrac{sum}{k}$ (sum/k sometimes latex doesn't render in comments), if the operation were to subtract any number $0<x$ in that case there is probably a minimum but I am not sure about that."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "but how did one can conclude \"need to move from left to right \" "
                    },
                    {
                        "username": "SAIVARUN_GAJULA",
                        "content": "you can move from right to left too...it\\'s because you can make the border elements zero only by applying the operation for subarray ending at n-1 nums[n-1] times "
                    },
                    {
                        "username": "sameer89",
                        "content": "It is the greedy approach, We are greedily thinking to elimate the first element in the window and then during sliding we are not thinking about the first element because we already made it zero. "
                    }
                ]
            }
        ]
    },
    {
        "title": "Height of Special Binary Tree",
        "question_content": null,
        "solutions": [],
        "discussions": []
    }
]