[
    {
        "title": "Partition List",
        "question_content": "Given the head of a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x.\nYou should preserve the original relative order of the nodes in each of the two partitions.\n&nbsp;\nExample 1:\n\nInput: head = [1,4,3,2,5,2], x = 3\nOutput: [1,2,2,4,3,5]\n\nExample 2:\n\nInput: head = [2,1], x = 2\nOutput: [1,2]\n\n&nbsp;\nConstraints:\n\n\tThe number of nodes in the list is in the range [0, 200].\n\t-100 <= Node.val <= 100\n\t-200 <= x <= 200",
        "solutions": [
            {
                "id": 29185,
                "title": "very-concise-one-pass-solution",
                "content": "    ListNode *partition(ListNode *head, int x) {\\n        ListNode node1(0), node2(0);\\n        ListNode *p1 = &node1, *p2 = &node2;\\n        while (head) {\\n            if (head->val < x)\\n                p1 = p1->next = head;\\n            else\\n                p2 = p2->next = head;\\n            head = head->next;\\n        }\\n        p2->next = NULL;\\n        p1->next = node2.next;\\n        return node1.next;\\n    }",
                "solutionTags": [],
                "code": "    ListNode *partition(ListNode *head, int x) {\\n        ListNode node1(0), node2(0);\\n        ListNode *p1 = &node1, *p2 = &node2;\\n        while (head) {\\n            if (head->val < x)\\n                p1 = p1->next = head;\\n            else\\n                p2 = p2->next = head;\\n            head = head->next;\\n        }\\n        p2->next = NULL;\\n        p1->next = node2.next;\\n        return node1.next;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 29183,
                "title": "concise-java-code-with-explanation-one-pass",
                "content": "the basic idea is to maintain two queues, the first one stores all nodes with val less than x , and the second queue stores all the rest nodes. Then concat these two queues. Remember to set the tail of second queue a null next, or u will get TLE.\\n\\n    public ListNode partition(ListNode head, int x) {\\n        ListNode dummy1 = new ListNode(0), dummy2 = new ListNode(0);  //dummy heads of the 1st and 2nd queues\\n        ListNode curr1 = dummy1, curr2 = dummy2;      //current tails of the two queues;\\n        while (head!=null){\\n            if (head.val<x) {\\n                curr1.next = head;\\n                curr1 = head;\\n            }else {\\n                curr2.next = head;\\n                curr2 = head;\\n            }\\n            head = head.next;\\n        }\\n        curr2.next = null;          //important! avoid cycle in linked list. otherwise u will get TLE.\\n        curr1.next = dummy2.next;\\n        return dummy1.next;\\n    }",
                "solutionTags": [],
                "code": "the basic idea is to maintain two queues, the first one stores all nodes with val less than x , and the second queue stores all the rest nodes. Then concat these two queues. Remember to set the tail of second queue a null next, or u will get TLE.\\n\\n    public ListNode partition(ListNode head, int x) {\\n        ListNode dummy1 = new ListNode(0), dummy2 = new ListNode(0);  //dummy heads of the 1st and 2nd queues\\n        ListNode curr1 = dummy1, curr2 = dummy2;      //current tails of the two queues;\\n        while (head!=null){\\n            if (head.val<x) {\\n                curr1.next = head;\\n                curr1 = head;\\n            }else {\\n                curr2.next = head;\\n                curr2 = head;\\n            }\\n            head = head.next;\\n        }\\n        curr2.next = null;          //important! avoid cycle in linked list. otherwise u will get TLE.\\n        curr1.next = dummy2.next;\\n        return dummy1.next;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2315494,
                "title": "java-c-detailed-explanation",
                "content": "So, this problem is super-easy trust me. Only if you know the Basics of LinkedList. \\n```\\nAnyways, Ladies-N-Gentlemen let\\'s understand this problem\\n```\\n\\nLet\\'s understand what  the problem is saying, first of all.\\n> We have given a list and a value **x**, we have to partion the list in such that smaller value then **x** comes to **left** & greater or equals to **right**. \\n\\nSo, to do that. One clear thing is coming up in your mind, Why don\\'t we create **2 sublists**.\\n* **Left dummy linked list**\\n* **Right dummy linked list**\\n\\nI mean yes, we are doing that. You guy\\'s are clever. And if you all have think about this as well, **`Left will have values smaller then x`** & **`Right will have value greater or equal to x`**.\\n\\nSo, let\\'s take an example and solve this problem.\\n\\n```\\nInput: head = [1,4,3,2,5,2], x = 3\\nOutput: [1,2,2,4,3,5]\\n```\\n\\n**Let\\'s understand it visually ;**\\n\\n![image](https://assets.leetcode.com/users/images/e64ba2fb-18b3-461b-bec1-a886109e913b_1658458237.6596422.gif)\\n\\n\\nNow as you can see when we have seperated the list\\'s as per the questions, our final job is to merge them into one list.\\n\\nSo, to do that what we gonna do is, tecnically **`left list`** end i.e. **2** is pointing to **`null`** and **`right list`** end i.e. **5** pointing to **`2`**. But we want **`2`** to point to the beginning of **`right list`** not null.\\nif we do that we will create a infine[never ending] loop. **Let\\'s see what am talking about**\\n\\n![image](https://assets.leetcode.com/users/images/ba24a36f-f73a-4398-95a8-2e21b8198d07_1658459944.800071.gif)\\n\\n\\nTo, solve this issue what we gonna do is, we want the **`right list`** **5** to point to **null** not to **2**. If we do that then, out list will look\\'s like this:\\n![image](https://assets.leetcode.com/users/images/774f4663-93da-40c3-ad95-16b14bd85ad6_1658458969.4673235.png)\\n\\nAnd by doing that we will get our final list, as shown in the question that\\'s what we want.\\n\\nNow, **ladies-n-gentlemen** let\\'s code this solution\\n\\n**Java**\\n```\\nclass Solution {\\n    public ListNode partition(ListNode head, int x) {\\n        ListNode left = new ListNode(0);\\n        ListNode right = new ListNode(0);\\n        \\n        ListNode leftTail = left;\\n        ListNode rightTail = right;\\n        \\n        while(head != null){\\n            if(head.val < x){\\n                leftTail.next = head;\\n                leftTail = leftTail.next;\\n            }\\n            else{\\n                rightTail.next = head;\\n                rightTail = rightTail.next;\\n            }\\n            head = head.next;\\n        }\\n        \\n        leftTail.next = right.next;\\n        rightTail.next = null;\\n        \\n        return left.next;\\n    }\\n}\\n```\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode *left = new ListNode(0);\\n        ListNode *right = new ListNode(0);\\n        \\n        ListNode *leftTail = left;\\n        ListNode *rightTail = right;\\n        \\n        while(head != NULL){\\n            if(head->val < x){\\n                leftTail->next = head;\\n                leftTail = leftTail->next;\\n            }\\n            else{\\n                rightTail->next = head;\\n                rightTail = rightTail->next;\\n            }\\n            head = head->next;\\n        }\\n        \\n        leftTail->next = right->next;\\n        rightTail->next = NULL;\\n        \\n        return left->next;\\n    }\\n};\\n```\\nANALYSIS:-\\n* **Time Complexity :-** **`BigO(N)`**\\n\\n* **Space Complexity :-** **`BigO(1)`**",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\nAnyways, Ladies-N-Gentlemen let\\'s understand this problem\\n```\n```\\nInput: head = [1,4,3,2,5,2], x = 3\\nOutput: [1,2,2,4,3,5]\\n```\n```\\nclass Solution {\\n    public ListNode partition(ListNode head, int x) {\\n        ListNode left = new ListNode(0);\\n        ListNode right = new ListNode(0);\\n        \\n        ListNode leftTail = left;\\n        ListNode rightTail = right;\\n        \\n        while(head != null){\\n            if(head.val < x){\\n                leftTail.next = head;\\n                leftTail = leftTail.next;\\n            }\\n            else{\\n                rightTail.next = head;\\n                rightTail = rightTail.next;\\n            }\\n            head = head.next;\\n        }\\n        \\n        leftTail.next = right.next;\\n        rightTail.next = null;\\n        \\n        return left.next;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode *left = new ListNode(0);\\n        ListNode *right = new ListNode(0);\\n        \\n        ListNode *leftTail = left;\\n        ListNode *rightTail = right;\\n        \\n        while(head != NULL){\\n            if(head->val < x){\\n                leftTail->next = head;\\n                leftTail = leftTail->next;\\n            }\\n            else{\\n                rightTail->next = head;\\n                rightTail = rightTail->next;\\n            }\\n            head = head->next;\\n        }\\n        \\n        leftTail->next = right->next;\\n        rightTail->next = NULL;\\n        \\n        return left->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 29174,
                "title": "python-concise-solution-with-dummy-nodes",
                "content": "        \\n    def partition(self, head, x):\\n        h1 = l1 = ListNode(0)\\n        h2 = l2 = ListNode(0)\\n        while head:\\n            if head.val < x:\\n                l1.next = head\\n                l1 = l1.next\\n            else:\\n                l2.next = head\\n                l2 = l2.next\\n            head = head.next\\n        l2.next = None\\n        l1.next = h2.next\\n        return h1.next",
                "solutionTags": [
                    "Python"
                ],
                "code": "        \\n    def partition(self, head, x):\\n        h1 = l1 = ListNode(0)\\n        h2 = l2 = ListNode(0)\\n        while head:\\n            if head.val < x:\\n                l1.next = head\\n                l1 = l1.next\\n            else:\\n                l2.next = head\\n                l2 = l2.next\\n            head = head.next\\n        l2.next = None\\n        l1.next = h2.next\\n        return h1.next",
                "codeTag": "Python3"
            },
            {
                "id": 3910837,
                "title": "100-two-pointer-video-linked-list-visualization-optimal",
                "content": "# Problem Understanding\\n\\nIn the \"Partition a Linked List Around a Value\" problem, we are provided with the head of a linked list and a value `x`. The task is to rearrange the linked list such that all nodes with values less than `x` come before nodes with values greater than or equal to `x`. A key point is that the original relative order of the nodes in each of the two partitions must be preserved.\\n\\nConsider the linked list `head = [1,4,3,2,5,2]` and `x = 3`. The expected output after partitioning is `[1,2,2,4,3,5]`.\\n\\n---\\n\\n# Live Coding & Logic in Python\\nhttps://youtu.be/q-JTT8Ole6M\\n\\n## Coding in:\\n- [\\uD83D\\uDC0D Python](https://youtu.be/q-JTT8Ole6M)\\n- [\\uD83E\\uDD80 Rust](https://youtu.be/OOw-mP8T2AE)\\n- [\\uD83D\\uDC39 Go](https://youtu.be/d-1OTX26qdo)\\n\\n# Approach: Two Pointer Technique with Dummy Nodes\\n\\nThe idea is to use two pointers (or references) to create two separate linked lists: \\n1. One for nodes with values less than `x`\\n2. Another for nodes with values greater than or equal to `x`\\n\\nAt the end, we can combine the two linked lists to get the desired result.\\n\\n## Key Data Structures:\\n- **Linked List**: We work directly with the given linked list nodes.\\n- **Dummy Nodes**: Two dummy nodes are used to create the starting point for the two partitions.\\n\\n## Step-by-step Breakdown:\\n\\n1. **Initialization**:\\n   - Create two dummy nodes: `before` and `after`.\\n   - Initialize two pointers `before_curr` and `after_curr` at the dummy nodes.\\n   \\n2. **Traversal & Partition**:\\n   - Traverse the linked list with the given `head`.\\n   - For each node, if its value is less than `x`, attach it to the `before` list. Otherwise, attach it to the `after` list.\\n   \\n3. **Merging**:\\n   - After traversing the entire list, append the `after` list to the `before` list to form the partitioned linked list.\\n\\n4. **Result**:\\n   - Return the next node of the `before` dummy node as the new head of the partitioned list.\\n\\n# Example - Visualization:\\nBased on the provided example with the linked list `head = [1,4,3,2,5,2]` and `x = 3`, here\\'s the step-by-step evolution of the `before`, `after`, and `head` lists:\\n\\n![viz_van.png](https://assets.leetcode.com/users/images/a9dac623-2c22-479c-9392-e6b35e3416a5_1692060627.6065295.png)\\n\\n1. After processing node with value `1`:\\n    - `head`: [1, 4, 3, 2, 5, 2]\\n    - `before`: [0, 1]\\n    - `after`: [0]\\n\\n2. After processing node with value `4`:\\n    - `head`: [4, 3, 2, 5, 2]\\n    - `before`: [0, 1]\\n    - `after`: [0, 4]\\n\\n3. After processing node with value `3`:\\n    - `head`: [3, 2, 5, 2]\\n    - `before`: [0, 1]\\n    - `after`: [0, 4, 3]\\n\\n4. After processing node with value `2`:\\n    - `head`: [2, 5, 2]\\n    - `before`: [0, 1, 2]\\n    - `after`: [0, 4, 3]\\n\\n5. After processing node with value `5`:\\n    - `head`: [5, 2]\\n    - `before`: [0, 1, 2]\\n    - `after`: [0, 4, 3, 5]\\n\\n6. After processing node with value `2`:\\n    - `head`: [2]\\n    - `before`: [0, 1, 2, 2]\\n    - `after`: [0, 4, 3, 5]\\n\\nFinally, after merging the `before` and `after` lists, the result is: `[1,2,2,4,3,5]`\\n\\n# Complexity:\\n\\n**Time Complexity:** $$O(n)$$\\n- We traverse the linked list once, making the time complexity linear in the size of the list.\\n\\n**Space Complexity:** $$O(1)$$\\n- We use constant extra space since we are only creating two dummy nodes and reusing the existing nodes in the linked list.\\n\\n# Performance:\\n\\nGiven the constraints, this solution is optimal and will efficiently handle linked lists of size up to 200 nodes.\\n\\n| Language   | Runtime (ms) | Runtime Beat (%) | Memory (MB) | Memory Beat (%) |\\n|------------|--------------|------------------|-------------|-----------------|\\n| **Rust**       | 0            | 100%             | 1.9         | 100%            |\\n| **Go**         | 0            | 100%            | 2.4         | 98.48%          |\\n| **C++**        | 0            | 100%             | 10.2        | 48.14%          |\\n| **Java**       | 0            | 100%             | 40.8        | 83.63%          |\\n| **Python3**    | 32           | 98.81%           | 16.4        | 55.72%          |\\n| **JavaScript** | 45           | 98.36%           | 44.3        | 12.30%          |\\n| **C#**         | 82           | 67.18%           | 39          | 64.10%          |\\n\\n![v2.png](https://assets.leetcode.com/users/images/c524fce6-73ab-41f7-a627-4f18b40fb965_1692069418.268467.png)\\n\\n\\n# Code\\n``` Python []\\nclass Solution:\\n    def partition(self, head: Optional[ListNode], x: int) -> Optional[ListNode]:\\n        before, after = ListNode(0), ListNode(0)\\n        before_curr, after_curr = before, after\\n        \\n        while head:\\n            if head.val < x:\\n                before_curr.next, before_curr = head, head\\n            else:\\n                after_curr.next, after_curr = head, head\\n            head = head.next\\n        \\n        after_curr.next = None\\n        before_curr.next = after.next\\n        \\n        return before.next\\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode before(0), after(0);\\n        ListNode* before_curr = &before;\\n        ListNode* after_curr = &after;\\n        \\n        while(head) {\\n            if(head->val < x) {\\n                before_curr->next = head;\\n                before_curr = head;\\n            } else {\\n                after_curr->next = head;\\n                after_curr = head;\\n            }\\n            head = head->next;\\n        }\\n        \\n        after_curr->next = nullptr;\\n        before_curr->next = after.next;\\n        \\n        return before.next;\\n    }\\n};\\n```\\n``` Rust []\\nimpl Solution {\\n    pub fn partition(mut head: Option<Box<ListNode>>, x: i32) -> Option<Box<ListNode>> {\\n        let mut before = ListNode::new(0);\\n        let mut after = ListNode::new(0);\\n        let mut before_tail = &mut before;\\n        let mut after_tail = &mut after;\\n\\n        while let Some(mut node) = head {\\n            head = node.next.take();\\n            if node.val < x {\\n                before_tail.next = Some(node);\\n                before_tail = before_tail.next.as_mut().unwrap();\\n            } else {\\n                after_tail.next = Some(node);\\n                after_tail = after_tail.next.as_mut().unwrap();\\n            }\\n        }\\n\\n        before_tail.next = after.next.take();\\n\\n        before.next\\n    }\\n}\\n```\\n``` Go []\\nfunc partition(head *ListNode, x int) *ListNode {\\n    before := &ListNode{}\\n    after := &ListNode{}\\n    before_curr := before\\n    after_curr := after\\n    \\n    for head != nil {\\n        if head.Val < x {\\n            before_curr.Next = head\\n            before_curr = before_curr.Next\\n        } else {\\n            after_curr.Next = head\\n            after_curr = after_curr.Next\\n        }\\n        head = head.Next\\n    }\\n    \\n    after_curr.Next = nil\\n    before_curr.Next = after.Next\\n    \\n    return before.Next\\n}\\n```\\n``` Java []\\npublic class Solution {\\n    public ListNode partition(ListNode head, int x) {\\n        ListNode before = new ListNode(0);\\n        ListNode after = new ListNode(0);\\n        ListNode before_curr = before;\\n        ListNode after_curr = after;\\n        \\n        while(head != null) {\\n            if(head.val < x) {\\n                before_curr.next = head;\\n                before_curr = before_curr.next;\\n            } else {\\n                after_curr.next = head;\\n                after_curr = after_curr.next;\\n            }\\n            head = head.next;\\n        }\\n        \\n        after_curr.next = null;\\n        before_curr.next = after.next;\\n        \\n        return before.next;\\n    }\\n}\\n```\\n``` JavaScript []\\nvar partition = function(head, x) {\\n    let before = new ListNode(0);\\n    let after = new ListNode(0);\\n    let before_curr = before;\\n    let after_curr = after;\\n    \\n    while(head !== null) {\\n        if(head.val < x) {\\n            before_curr.next = head;\\n            before_curr = before_curr.next;\\n        } else {\\n            after_curr.next = head;\\n            after_curr = after_curr.next;\\n        }\\n        head = head.next;\\n    }\\n    \\n    after_curr.next = null;\\n    before_curr.next = after.next;\\n    \\n    return before.next;\\n};\\n```\\n``` C# []\\npublic class Solution {\\n    public ListNode Partition(ListNode head, int x) {\\n        ListNode before = new ListNode(0);\\n        ListNode after = new ListNode(0);\\n        ListNode before_curr = before;\\n        ListNode after_curr = after;\\n        \\n        while(head != null) {\\n            if(head.val < x) {\\n                before_curr.next = head;\\n                before_curr = before_curr.next;\\n            } else {\\n                after_curr.next = head;\\n                after_curr = after_curr.next;\\n            }\\n            head = head.next;\\n        }\\n        \\n        after_curr.next = null;\\n        before_curr.next = after.next;\\n        \\n        return before.next;\\n    }\\n}\\n```\\n\\n# Coding in Rust & Go\\n\\nhttps://youtu.be/OOw-mP8T2AE\\nhttps://youtu.be/d-1OTX26qdo\\n\\nThe \"Partition a Linked List Around a Value\" problem exemplifies the elegance of simplicity in coding. Remember, every coding challenge is a gateway to greater understanding and expertise. Embrace each problem, for they refine your skills and mold your coding journey. Stay curious, dive deep, and let your passion for coding guide you to new horizons. \\uD83D\\uDE80\\uD83D\\uDC69\\u200D\\uD83D\\uDCBB\\uD83D\\uDC68\\u200D\\uD83D\\uDCBB\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "C#",
                    "JavaScript",
                    "Go",
                    "Rust",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "``` Python []\\nclass Solution:\\n    def partition(self, head: Optional[ListNode], x: int) -> Optional[ListNode]:\\n        before, after = ListNode(0), ListNode(0)\\n        before_curr, after_curr = before, after\\n        \\n        while head:\\n            if head.val < x:\\n                before_curr.next, before_curr = head, head\\n            else:\\n                after_curr.next, after_curr = head, head\\n            head = head.next\\n        \\n        after_curr.next = None\\n        before_curr.next = after.next\\n        \\n        return before.next\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode before(0), after(0);\\n        ListNode* before_curr = &before;\\n        ListNode* after_curr = &after;\\n        \\n        while(head) {\\n            if(head->val < x) {\\n                before_curr->next = head;\\n                before_curr = head;\\n            } else {\\n                after_curr->next = head;\\n                after_curr = head;\\n            }\\n            head = head->next;\\n        }\\n        \\n        after_curr->next = nullptr;\\n        before_curr->next = after.next;\\n        \\n        return before.next;\\n    }\\n};\\n```\n``` Rust []\\nimpl Solution {\\n    pub fn partition(mut head: Option<Box<ListNode>>, x: i32) -> Option<Box<ListNode>> {\\n        let mut before = ListNode::new(0);\\n        let mut after = ListNode::new(0);\\n        let mut before_tail = &mut before;\\n        let mut after_tail = &mut after;\\n\\n        while let Some(mut node) = head {\\n            head = node.next.take();\\n            if node.val < x {\\n                before_tail.next = Some(node);\\n                before_tail = before_tail.next.as_mut().unwrap();\\n            } else {\\n                after_tail.next = Some(node);\\n                after_tail = after_tail.next.as_mut().unwrap();\\n            }\\n        }\\n\\n        before_tail.next = after.next.take();\\n\\n        before.next\\n    }\\n}\\n```\n``` Go []\\nfunc partition(head *ListNode, x int) *ListNode {\\n    before := &ListNode{}\\n    after := &ListNode{}\\n    before_curr := before\\n    after_curr := after\\n    \\n    for head != nil {\\n        if head.Val < x {\\n            before_curr.Next = head\\n            before_curr = before_curr.Next\\n        } else {\\n            after_curr.Next = head\\n            after_curr = after_curr.Next\\n        }\\n        head = head.Next\\n    }\\n    \\n    after_curr.Next = nil\\n    before_curr.Next = after.Next\\n    \\n    return before.Next\\n}\\n```\n``` Java []\\npublic class Solution {\\n    public ListNode partition(ListNode head, int x) {\\n        ListNode before = new ListNode(0);\\n        ListNode after = new ListNode(0);\\n        ListNode before_curr = before;\\n        ListNode after_curr = after;\\n        \\n        while(head != null) {\\n            if(head.val < x) {\\n                before_curr.next = head;\\n                before_curr = before_curr.next;\\n            } else {\\n                after_curr.next = head;\\n                after_curr = after_curr.next;\\n            }\\n            head = head.next;\\n        }\\n        \\n        after_curr.next = null;\\n        before_curr.next = after.next;\\n        \\n        return before.next;\\n    }\\n}\\n```\n``` JavaScript []\\nvar partition = function(head, x) {\\n    let before = new ListNode(0);\\n    let after = new ListNode(0);\\n    let before_curr = before;\\n    let after_curr = after;\\n    \\n    while(head !== null) {\\n        if(head.val < x) {\\n            before_curr.next = head;\\n            before_curr = before_curr.next;\\n        } else {\\n            after_curr.next = head;\\n            after_curr = after_curr.next;\\n        }\\n        head = head.next;\\n    }\\n    \\n    after_curr.next = null;\\n    before_curr.next = after.next;\\n    \\n    return before.next;\\n};\\n```\n``` C# []\\npublic class Solution {\\n    public ListNode Partition(ListNode head, int x) {\\n        ListNode before = new ListNode(0);\\n        ListNode after = new ListNode(0);\\n        ListNode before_curr = before;\\n        ListNode after_curr = after;\\n        \\n        while(head != null) {\\n            if(head.val < x) {\\n                before_curr.next = head;\\n                before_curr = before_curr.next;\\n            } else {\\n                after_curr.next = head;\\n                after_curr = after_curr.next;\\n            }\\n            head = head.next;\\n        }\\n        \\n        after_curr.next = null;\\n        before_curr.next = after.next;\\n        \\n        return before.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2315305,
                "title": "c-single-pass-o-1-space-explained",
                "content": "**UPVOTE IF HELPFuuL**\\n\\n**O ( N ) space approach**\\n\\nTraverse the list and keep the values in a vector that are smaller than ```key``` provided. Traverse again to find the values greater than or equal to ```key```.\\nMake the list and return it.\\n\\n**O ( 1 ) with TWO PASSES**\\n\\nCreate a node with garbage value. *let say **resultant*** -> This prevents us from checking if ```resultant``` linked list is empty or not.\\n*First-pass* -> Traverse and add all the nodes that are ```smaller``` than ```key``` provided.\\n*Secong-pass* -> Traverse again to add nodes that are ```greater than or equal to``` key provided.\\n```return resultant -> next``` *[ next returned to remove garbage node ]*\\n\\n**O ( 1 ) with SINGLE PASS**\\n\\nCreate two nodes with garbage vales.\\n* ```small``` -> to have nodes with value *less* than ```key```\\n* ```large``` -> to have nodes with value *greater than or equal* to ```key```.\\n\\nNow visit each node :\\n* if node smaller -> add to ```small``` and ```small -> next = NULL```\\n* else -> add to ```large``` and ```large -> next = NULL```\\n\\n*[ We make ```small/large -> next = NULL``` to add only a single node and break further connection, if not done , whole list after head will be added to them ]*\\n\\nAt end join two linked lists *[ remember the garbage nodes ]* ->\\n* make ```small -> next = large_head -> next``` : we appending large_head -> **next** because the first node is garbage.\\n\\nSame way while returning remove garbage node from small and return ```return small_head -> next```.\\n\\n**UPVOTE IF HELPFuuL**\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    ListNode* partition(ListNode* head, int x) {\\n        \\n        ListNode* small = new ListNode(-1);\\n        ListNode* large = new ListNode(-1);\\n        ListNode* small_head = small;\\n        ListNode* large_head = large;\\n        \\n        while (head){\\n            if (head->val < x){\\n                small->next = head;\\n                small = small -> next;\\n                head = head -> next;\\n                small->next = NULL;\\n            }\\n            else{\\n                large->next = head;\\n                large = large -> next;\\n                head = head -> next;\\n                large -> next = NULL;\\n            }\\n        }\\n        small -> next = large_head -> next;\\n\\n        return small_head -> next;\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/8047ec32-ac17-4d62-be57-6af715272f6d_1658453504.0169513.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "```key```\n```key```\n```resultant```\n```smaller```\n```key```\n```greater than or equal to```\n```return resultant -> next```\n```small```\n```key```\n```large```\n```key```\n```small```\n```small -> next = NULL```\n```large```\n```large -> next = NULL```\n```small/large -> next = NULL```\n```small -> next = large_head -> next```\n```return small_head -> next```\n```\\nclass Solution {\\npublic:\\n    \\n    ListNode* partition(ListNode* head, int x) {\\n        \\n        ListNode* small = new ListNode(-1);\\n        ListNode* large = new ListNode(-1);\\n        ListNode* small_head = small;\\n        ListNode* large_head = large;\\n        \\n        while (head){\\n            if (head->val < x){\\n                small->next = head;\\n                small = small -> next;\\n                head = head -> next;\\n                small->next = NULL;\\n            }\\n            else{\\n                large->next = head;\\n                large = large -> next;\\n                head = head -> next;\\n                large -> next = NULL;\\n            }\\n        }\\n        small -> next = large_head -> next;\\n\\n        return small_head -> next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1157797,
                "title": "js-python-java-c-easy-two-lists-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nThe easiest thing to do here is to create separate linked lists for the front and back portions of list we want to return. In order to accomplish that, we should first create some dummy heads (**fdum, bdum**), then create pointers for the current nodes each of the front, back, and main lists (**front, back, curr**).\\n\\nThen we can simply iterate through the main list and stitch together each node to either **front** or **back**, depending on the node\\'s value.\\n\\nOnce we reach the end, we just need to stitch together the two sub-lists, making sure to cap off the end of **back**, and then **return** our new list, minus the dummy head.\\n\\n![Visual 1](https://i.imgur.com/X5semXh.png)\\n\\n---\\n\\n#### ***Implementation:***\\n\\nThere are only minor differences between the code of all four languages.\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **80ms / 40.1MB** (beats 92% / 66%).\\n```javascript\\nvar partition = function(head, x) {\\n    let fdum = new ListNode(0), bdum = new ListNode(0),\\n        front = fdum, back = bdum, curr = head\\n    while (curr) {\\n        if (curr.val < x)front.next = curr, front = curr\\n        else back.next = curr, back = curr\\n        curr = curr.next\\n    }\\n    front.next = bdum.next, back.next = null\\n    return fdum.next\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **24ms / 14.1MB** (beats 99% / 85%).\\n```python\\nclass Solution:\\n    def partition(self, head: ListNode, x: int) -> ListNode:\\n        fdum, bdum = ListNode(0), ListNode(0)\\n        front, back, curr = fdum, bdum, head\\n        while curr:\\n            if curr.val < x:\\n                front.next = curr\\n                front = curr\\n            else:\\n                back.next = curr\\n                back = curr\\n            curr = curr.next\\n        front.next, back.next = bdum.next, None\\n        return fdum.next\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **0ms / 38.2MB** (beats 100% / 69%).\\n```java\\nclass Solution {\\n    public ListNode partition(ListNode head, int x) {\\n        ListNode fdum = new ListNode(0), bdum = new ListNode(0),\\n                 front = fdum, back = bdum, curr = head;\\n        while (curr != null) {\\n            if (curr.val < x) {\\n                front.next = curr;\\n                front = curr;\\n            } else {\\n                back.next = curr;\\n                back = curr;\\n            }\\n            curr = curr.next;\\n        }\\n        front.next = bdum.next;\\n        back.next = null;\\n        return fdum.next;\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **0ms / 10.1MB** (beats 100% / 90%).\\n```c++\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode *fdum = new ListNode(0), *bdum = new ListNode(0),\\n                 *front = fdum, *back = bdum, *curr = head;\\n        while (curr) {\\n            if (curr->val < x) front->next = curr, front = curr;\\n            else back->next = curr, back = curr;\\n            curr = curr->next;\\n        }\\n        front->next = bdum->next, back->next = nullptr;\\n        return fdum->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```javascript\\nvar partition = function(head, x) {\\n    let fdum = new ListNode(0), bdum = new ListNode(0),\\n        front = fdum, back = bdum, curr = head\\n    while (curr) {\\n        if (curr.val < x)front.next = curr, front = curr\\n        else back.next = curr, back = curr\\n        curr = curr.next\\n    }\\n    front.next = bdum.next, back.next = null\\n    return fdum.next\\n};\\n```\n```python\\nclass Solution:\\n    def partition(self, head: ListNode, x: int) -> ListNode:\\n        fdum, bdum = ListNode(0), ListNode(0)\\n        front, back, curr = fdum, bdum, head\\n        while curr:\\n            if curr.val < x:\\n                front.next = curr\\n                front = curr\\n            else:\\n                back.next = curr\\n                back = curr\\n            curr = curr.next\\n        front.next, back.next = bdum.next, None\\n        return fdum.next\\n```\n```java\\nclass Solution {\\n    public ListNode partition(ListNode head, int x) {\\n        ListNode fdum = new ListNode(0), bdum = new ListNode(0),\\n                 front = fdum, back = bdum, curr = head;\\n        while (curr != null) {\\n            if (curr.val < x) {\\n                front.next = curr;\\n                front = curr;\\n            } else {\\n                back.next = curr;\\n                back = curr;\\n            }\\n            curr = curr.next;\\n        }\\n        front.next = bdum.next;\\n        back.next = null;\\n        return fdum.next;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode *fdum = new ListNode(0), *bdum = new ListNode(0),\\n                 *front = fdum, *back = bdum, *curr = head;\\n        while (curr) {\\n            if (curr->val < x) front->next = curr, front = curr;\\n            else back->next = curr, back = curr;\\n            curr = curr->next;\\n        }\\n        front->next = bdum->next, back->next = nullptr;\\n        return fdum->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 29181,
                "title": "10-lines-concise-c-solution",
                "content": "    class Solution {\\n    public:\\n        ListNode* partition(ListNode* head, int x) {\\n            ListNode left(0), right(0);\\n            ListNode *l = &left, *r = &right;\\n\\n            while(head){\\n                ListNode* & ref = head->val < x ? l : r;\\n                ref->next = head;\\n                ref = ref->next;\\n                \\n                head = head->next;\\n            }\\n            l->next = right.next;\\n            r->next = NULL;\\n            return left.next;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        ListNode* partition(ListNode* head, int x) {\\n            ListNode left(0), right(0);\\n            ListNode *l = &left, *r = &right;\\n\\n            while(head){\\n                ListNode* & ref = head->val < x ? l : r;\\n                ref->next = head;\\n                ref = ref->next;\\n                \\n                head = head->next;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1157903,
                "title": "simple-1-pass-partition-w-two-pointers-explained-beats-100",
                "content": "There are a few approach using which this question can be solved. In the simplest solution, we can iterate over the list in the first pass and append all nodes less than `x` and in the second pass append all nodes greater than or equal to `x`.\\n\\nLet\\'s try to solve the problem in one-pass and O(1) Space without making duplicate copies of original nodes.\\n\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution (2-pointer partition)***\\n\\nWe can easily partition the list if we maintain two pointers -\\n* `lesser` - to store all the nodes from original list which are less than `x`.\\n* `greater` - to store all the nodes from original list which are greater than or equal to `x`.\\n\\nWe initialise both of these pointers to temporary / dummy nodes so that we can easily append to them without having to do any extra checks.\\n\\nWe would also need two more variable to store the heads of these pointers - `lesser_head` and `greater_head` which would be required later to join `lesser` to `greater_head` and finally return the head of partition list which would be `lesser_head -> next` (since lesser_head is dummy node, so return its next).\\n\\n```\\n ListNode* partition(ListNode* head, int x) {\\n \\xA0 \\xA0 ListNode *lesser = new ListNode(-1), *greater = new ListNode(-1), *lesser_head = lesser, *greater_head = greater;\\n \\xA0 \\xA0 while(head){\\n \\xA0 \\xA0 \\xA0 \\xA0 if(head -> val < x) \\n                lesser -> next = head, lesser = lesser -> next;\\n \\xA0 \\xA0 \\xA0 \\xA0 else \\n                greater -> next = head, greater = greater -> next;\\n \\xA0 \\xA0 \\xA0 \\xA0 head = head -> next; \\n \\xA0 \\xA0 }\\n \\xA0 \\xA0 greater -> next = NULL;\\n \\xA0 \\xA0 lesser -> next = greater_head -> next;\\n \\xA0 \\xA0 return lesser_head -> next;\\n }\\n```\\n\\n***Time Complexity :*** **`O(N)`**, where `N` is the total number of nodes in original linked list.\\n***Space Complexity :*** **`O(1)`**. Note that we are not making duplicate nodes, just rearranging the original nodes in our partitioned.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n ListNode* partition(ListNode* head, int x) {\\n \\xA0 \\xA0 ListNode *lesser = new ListNode(-1), *greater = new ListNode(-1), *lesser_head = lesser, *greater_head = greater;\\n \\xA0 \\xA0 while(head){\\n \\xA0 \\xA0 \\xA0 \\xA0 if(head -> val < x) \\n                lesser -> next = head, lesser = lesser -> next;\\n \\xA0 \\xA0 \\xA0 \\xA0 else \\n                greater -> next = head, greater = greater -> next;\\n \\xA0 \\xA0 \\xA0 \\xA0 head = head -> next; \\n \\xA0 \\xA0 }\\n \\xA0 \\xA0 greater -> next = NULL;\\n \\xA0 \\xA0 lesser -> next = greater_head -> next;\\n \\xA0 \\xA0 return lesser_head -> next;\\n }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1157788,
                "title": "python-two-pointers-explained",
                "content": "All we need to do is to create two dummy heads for two new lists and then traverse through original list and add elements. On each step we check if value of node is less than `x` or not. If it is less, append it to the end of the first list and move pointer `p1`, so it always points to the end of first list. If it is more than equal than `x`, move second pointer. In the end we have `4` pointers in the following order:  `d1->... -> p1  d2->... ->p2->`, so what we need to do now is to add connection `p1->d2` and also remove connection from `p2`.\\n\\n#### Complexity\\nTime complexity is `O(n)` and space complexity is `O(1)`.\\n\\n#### Code\\n```\\nclass Solution:\\n    def partition(self, head, x):\\n        d1 = ListNode(-1)\\n        d2 = ListNode(-1)\\n        p1, p2 = d1, d2\\n        while head:\\n            if head.val < x:\\n                p1.next = head\\n                p1 = p1.next\\n            else:\\n                p2.next = head\\n                p2 = p2.next\\n            head = head.next\\n            \\n        p1.next = d2.next\\n        p2.next = None\\n        return d1.next\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def partition(self, head, x):\\n        d1 = ListNode(-1)\\n        d2 = ListNode(-1)\\n        p1, p2 = d1, d2\\n        while head:\\n            if head.val < x:\\n                p1.next = head\\n                p1 = p1.next\\n            else:\\n                p2.next = head\\n                p2 = p2.next\\n            head = head.next\\n            \\n        p1.next = d2.next\\n        p2.next = None\\n        return d1.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3911093,
                "title": "commented-code-line-by-line-explained-c-java-python",
                "content": "\\uD83C\\uDDEE\\uD83C\\uDDF3 Happy independence Day \\uD83C\\uDDEE\\uD83C\\uDDF3\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nThis approach uses two separate lists to partition the nodes.\\n\\nFor detailed explanation you can refer to my youtube channel (hindi Language)\\nhttps://youtu.be/WOA1IuoONXc\\n or link in my profile.Here,you can find any solution in playlists monthwise from june 2023 with detailed explanation.i upload daily leetcode solution video with short and precise explanation (5-10) minutes.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n1. Initialize two new linked lists, `less` and `greater`, to hold nodes with values less than `x` and greater than or equal to `x`, respectively.\\n\\n2. Traverse the original linked list, `head`, and for each node:\\n   - If the node\\'s value is less than `x`, append it to the `less` list.\\n   - If the node\\'s value is greater than or equal to `x`, append it to the `greater` list.\\n\\n3. After traversing the original list, attach the `greater` list to the end of the `less` list.\\n\\n4. Set the last node of the `greater` list\\'s `next` pointer to `nullptr` to terminate the list.\\n\\n5. Return the `less` list\\'s head as the result.\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code 1\\n# Creating new instances of Nodes with given value\\n```C++ []\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode* current = head;  // Pointer to traverse the original list\\n        \\n        ListNode* lessDummy = new ListNode(0);    // Dummy node for nodes < x\\n        ListNode* lessTail = lessDummy;           // Tail pointer for less list\\n        \\n        ListNode* greaterDummy = new ListNode(0); // Dummy node for nodes >= x\\n        ListNode* greaterTail = greaterDummy;     // Tail pointer for greater list\\n        \\n        // Traverse the original list\\n        while (current != nullptr) {\\n            if (current->val < x) {\\n                // Append current node to the less list\\n                lessTail->next = new ListNode(current->val);\\n                lessTail = lessTail->next; // Move the tail pointer\\n            } else {\\n                // Append current node to the greater list\\n                greaterTail->next = new ListNode(current->val);\\n                greaterTail = greaterTail->next; // Move the tail pointer\\n            }\\n            current = current->next; // Move to the next node\\n        }\\n        \\n        \\n        // Attach the greater list to the end of the less list\\n        lessTail->next = greaterDummy->next;\\n        \\n        // Return the modified list starting from the first node after the less dummy node\\n        return lessDummy->next;\\n    }\\n};\\n\\n```\\n```java []\\nclass Solution {\\n    public ListNode partition(ListNode head, int x) {\\n        ListNode current = head;  // Pointer to traverse the original list\\n        \\n        ListNode lessDummy = new ListNode(0);    // Dummy node for nodes < x\\n        ListNode lessTail = lessDummy;           // Tail pointer for less list\\n        \\n        ListNode greaterDummy = new ListNode(0); // Dummy node for nodes >= x\\n        ListNode greaterTail = greaterDummy;     // Tail pointer for greater list\\n        \\n        // Traverse the original list\\n        while (current != null) {\\n            if (current.val < x) {\\n                // Append current node to the less list\\n                lessTail.next = new ListNode(current.val);\\n                lessTail = lessTail.next; // Move the tail pointer\\n            } else {\\n                // Append current node to the greater list\\n                greaterTail.next = new ListNode(current.val);\\n                greaterTail = greaterTail.next; // Move the tail pointer\\n            }\\n            current = current.next; // Move to the next node\\n        }\\n        \\n       \\n        \\n        // Attach the greater list to the end of the less list\\n        lessTail.next = greaterDummy.next;\\n        \\n        // Return the modified list starting from the first node after the less dummy node\\n        return lessDummy.next;\\n    }\\n}\\n\\n```\\n```python []\\nclass Solution:\\n    def partition(self, head: ListNode, x: int) -> ListNode:\\n        current = head  # Pointer to traverse the original list\\n        \\n        less_dummy = ListNode(0)    # Dummy node for nodes < x\\n        less_tail = less_dummy           # Tail pointer for less list\\n        \\n        greater_dummy = ListNode(0) # Dummy node for nodes >= x\\n        greater_tail = greater_dummy     # Tail pointer for greater list\\n        \\n        # Traverse the original list\\n        while current:\\n            if current.val < x:\\n                # Append current node to the less list\\n                less_tail.next = ListNode(current.val)\\n                less_tail = less_tail.next  # Move the tail pointer\\n            else:\\n                # Append current node to the greater list\\n                greater_tail.next = ListNode(current.val)\\n                greater_tail = greater_tail.next  # Move the tail pointer\\n            current = current.next  # Move to the next node\\n        \\n        \\n        # Attach the greater list to the end of the less list\\n        less_tail.next = greater_dummy.next\\n        \\n        # Return the modified list starting from the first node after the less dummy node\\n        return less_dummy.next\\n\\n```\\n\\n\\n# Code 2 \\n# Using  same  Nodes.\\n```C++ []\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        // Initialize dummy nodes and tail pointers for less and greater lists\\n        ListNode* lessDummy = new ListNode(0);    // Dummy node for nodes < x\\n        ListNode* lessTail = lessDummy;           // Tail pointer for less list\\n        \\n        ListNode* greaterDummy = new ListNode(0); // Dummy node for nodes >= x\\n        ListNode* greaterTail = greaterDummy;     // Tail pointer for greater list\\n        \\n        ListNode* current = head;  // Current pointer for traversing the original list\\n        \\n        // Traverse the original list\\n        while (current != nullptr) {\\n            if (current->val < x) {\\n                // Append current node to the less list\\n                lessTail->next = current;\\n                lessTail = current; // Move the tail pointer\\n            } else {\\n                // Append current node to the greater list\\n                greaterTail->next = current;\\n                greaterTail = current; // Move the tail pointer\\n            }\\n            current = current->next; // Move to the next node\\n        }\\n        \\n        greaterTail->next = nullptr; // Terminate the greater list\\n        \\n        // Attach the greater list to the end of the less list\\n        lessTail->next = greaterDummy->next;\\n        \\n        // Return the modified list starting from the first node after the less dummy node\\n        return lessDummy->next;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public ListNode partition(ListNode head, int x) {\\n        ListNode lessDummy = new ListNode(0);   // Dummy node for nodes < x\\n        ListNode lessTail = lessDummy;          // Tail pointer for less list\\n        \\n        ListNode greaterDummy = new ListNode(0); // Dummy node for nodes >= x\\n        ListNode greaterTail = greaterDummy;     // Tail pointer for greater list\\n        \\n        ListNode current = head;  // Current pointer for traversing the original list\\n        \\n        // Traverse the original list\\n        while (current != null) {\\n            if (current.val < x) {\\n                // Append current node to the less list\\n                lessTail.next = current;\\n                lessTail = current; // Move the tail pointer\\n            } else {\\n                // Append current node to the greater list\\n                greaterTail.next = current;\\n                greaterTail = current; // Move the tail pointer\\n            }\\n            current = current.next; // Move to the next node\\n        }\\n        \\n        greaterTail.next = null; // Terminate the greater list\\n        \\n        // Attach the greater list to the end of the less list\\n        lessTail.next = greaterDummy.next;\\n        \\n        // Return the modified list starting from the first node after the less dummy node\\n        return lessDummy.next;\\n    }\\n}\\n```\\n```Python3 []\\nclass Solution:\\n    def partition(self, head: ListNode, x: int) -> ListNode:\\n        less_dummy = ListNode(0)   # Dummy node for nodes < x\\n        less_tail = less_dummy     # Tail pointer for less list\\n        \\n        greater_dummy = ListNode(0) # Dummy node for nodes >= x\\n        greater_tail = greater_dummy # Tail pointer for greater list\\n        \\n        current = head  # Current pointer for traversing the original list\\n        \\n        # Traverse the original list\\n        while current:\\n            if current.val < x:\\n                # Append current node to the less list\\n                less_tail.next = current\\n                less_tail = current # Move the tail pointer\\n            else:\\n                # Append current node to the greater list\\n                greater_tail.next = current\\n                greater_tail = current # Move the tail pointer\\n            current = current.next # Move to the next node\\n        \\n        greater_tail.next = None # Terminate the greater list\\n        \\n        # Attach the greater list to the end of the less list\\n        less_tail.next = greater_dummy.next\\n        \\n        # Return the modified list starting from the first node after the less dummy node\\n        return less_dummy.next\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode* current = head;  // Pointer to traverse the original list\\n        \\n        ListNode* lessDummy = new ListNode(0);    // Dummy node for nodes < x\\n        ListNode* lessTail = lessDummy;           // Tail pointer for less list\\n        \\n        ListNode* greaterDummy = new ListNode(0); // Dummy node for nodes >= x\\n        ListNode* greaterTail = greaterDummy;     // Tail pointer for greater list\\n        \\n        // Traverse the original list\\n        while (current != nullptr) {\\n            if (current->val < x) {\\n                // Append current node to the less list\\n                lessTail->next = new ListNode(current->val);\\n                lessTail = lessTail->next; // Move the tail pointer\\n            } else {\\n                // Append current node to the greater list\\n                greaterTail->next = new ListNode(current->val);\\n                greaterTail = greaterTail->next; // Move the tail pointer\\n            }\\n            current = current->next; // Move to the next node\\n        }\\n        \\n        \\n        // Attach the greater list to the end of the less list\\n        lessTail->next = greaterDummy->next;\\n        \\n        // Return the modified list starting from the first node after the less dummy node\\n        return lessDummy->next;\\n    }\\n};\\n\\n```\n```java []\\nclass Solution {\\n    public ListNode partition(ListNode head, int x) {\\n        ListNode current = head;  // Pointer to traverse the original list\\n        \\n        ListNode lessDummy = new ListNode(0);    // Dummy node for nodes < x\\n        ListNode lessTail = lessDummy;           // Tail pointer for less list\\n        \\n        ListNode greaterDummy = new ListNode(0); // Dummy node for nodes >= x\\n        ListNode greaterTail = greaterDummy;     // Tail pointer for greater list\\n        \\n        // Traverse the original list\\n        while (current != null) {\\n            if (current.val < x) {\\n                // Append current node to the less list\\n                lessTail.next = new ListNode(current.val);\\n                lessTail = lessTail.next; // Move the tail pointer\\n            } else {\\n                // Append current node to the greater list\\n                greaterTail.next = new ListNode(current.val);\\n                greaterTail = greaterTail.next; // Move the tail pointer\\n            }\\n            current = current.next; // Move to the next node\\n        }\\n        \\n       \\n        \\n        // Attach the greater list to the end of the less list\\n        lessTail.next = greaterDummy.next;\\n        \\n        // Return the modified list starting from the first node after the less dummy node\\n        return lessDummy.next;\\n    }\\n}\\n\\n```\n```python []\\nclass Solution:\\n    def partition(self, head: ListNode, x: int) -> ListNode:\\n        current = head  # Pointer to traverse the original list\\n        \\n        less_dummy = ListNode(0)    # Dummy node for nodes < x\\n        less_tail = less_dummy           # Tail pointer for less list\\n        \\n        greater_dummy = ListNode(0) # Dummy node for nodes >= x\\n        greater_tail = greater_dummy     # Tail pointer for greater list\\n        \\n        # Traverse the original list\\n        while current:\\n            if current.val < x:\\n                # Append current node to the less list\\n                less_tail.next = ListNode(current.val)\\n                less_tail = less_tail.next  # Move the tail pointer\\n            else:\\n                # Append current node to the greater list\\n                greater_tail.next = ListNode(current.val)\\n                greater_tail = greater_tail.next  # Move the tail pointer\\n            current = current.next  # Move to the next node\\n        \\n        \\n        # Attach the greater list to the end of the less list\\n        less_tail.next = greater_dummy.next\\n        \\n        # Return the modified list starting from the first node after the less dummy node\\n        return less_dummy.next\\n\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        // Initialize dummy nodes and tail pointers for less and greater lists\\n        ListNode* lessDummy = new ListNode(0);    // Dummy node for nodes < x\\n        ListNode* lessTail = lessDummy;           // Tail pointer for less list\\n        \\n        ListNode* greaterDummy = new ListNode(0); // Dummy node for nodes >= x\\n        ListNode* greaterTail = greaterDummy;     // Tail pointer for greater list\\n        \\n        ListNode* current = head;  // Current pointer for traversing the original list\\n        \\n        // Traverse the original list\\n        while (current != nullptr) {\\n            if (current->val < x) {\\n                // Append current node to the less list\\n                lessTail->next = current;\\n                lessTail = current; // Move the tail pointer\\n            } else {\\n                // Append current node to the greater list\\n                greaterTail->next = current;\\n                greaterTail = current; // Move the tail pointer\\n            }\\n            current = current->next; // Move to the next node\\n        }\\n        \\n        greaterTail->next = nullptr; // Terminate the greater list\\n        \\n        // Attach the greater list to the end of the less list\\n        lessTail->next = greaterDummy->next;\\n        \\n        // Return the modified list starting from the first node after the less dummy node\\n        return lessDummy->next;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public ListNode partition(ListNode head, int x) {\\n        ListNode lessDummy = new ListNode(0);   // Dummy node for nodes < x\\n        ListNode lessTail = lessDummy;          // Tail pointer for less list\\n        \\n        ListNode greaterDummy = new ListNode(0); // Dummy node for nodes >= x\\n        ListNode greaterTail = greaterDummy;     // Tail pointer for greater list\\n        \\n        ListNode current = head;  // Current pointer for traversing the original list\\n        \\n        // Traverse the original list\\n        while (current != null) {\\n            if (current.val < x) {\\n                // Append current node to the less list\\n                lessTail.next = current;\\n                lessTail = current; // Move the tail pointer\\n            } else {\\n                // Append current node to the greater list\\n                greaterTail.next = current;\\n                greaterTail = current; // Move the tail pointer\\n            }\\n            current = current.next; // Move to the next node\\n        }\\n        \\n        greaterTail.next = null; // Terminate the greater list\\n        \\n        // Attach the greater list to the end of the less list\\n        lessTail.next = greaterDummy.next;\\n        \\n        // Return the modified list starting from the first node after the less dummy node\\n        return lessDummy.next;\\n    }\\n}\\n```\n```Python3 []\\nclass Solution:\\n    def partition(self, head: ListNode, x: int) -> ListNode:\\n        less_dummy = ListNode(0)   # Dummy node for nodes < x\\n        less_tail = less_dummy     # Tail pointer for less list\\n        \\n        greater_dummy = ListNode(0) # Dummy node for nodes >= x\\n        greater_tail = greater_dummy # Tail pointer for greater list\\n        \\n        current = head  # Current pointer for traversing the original list\\n        \\n        # Traverse the original list\\n        while current:\\n            if current.val < x:\\n                # Append current node to the less list\\n                less_tail.next = current\\n                less_tail = current # Move the tail pointer\\n            else:\\n                # Append current node to the greater list\\n                greater_tail.next = current\\n                greater_tail = current # Move the tail pointer\\n            current = current.next # Move to the next node\\n        \\n        greater_tail.next = None # Terminate the greater list\\n        \\n        # Attach the greater list to the end of the less list\\n        less_tail.next = greater_dummy.next\\n        \\n        # Return the modified list starting from the first node after the less dummy node\\n        return less_dummy.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 29366,
                "title": "concise-and-simple-c-solution",
                "content": "    ListNode *partition(ListNode *head, int x) {\\n            \\n            ListNode *head1 = new ListNode(0);\\n            ListNode *head2 = new ListNode(0);\\n            ListNode *h1 = head1;\\n            ListNode *h2 = head2;\\n            while(head)\\n            {\\n                int v = head->val;\\n                if(v < x)\\n                {\\n                    head1->next = head;\\n                    head1 = head1->next;\\n                } else {\\n                    head2->next = head;\\n                    head2 = head2->next;\\n                }\\n                head = head->next;\\n            }\\n            head2->next = NULL;\\n            head1->next = h2->next;;\\n            return h1->next;\\n        }",
                "solutionTags": [],
                "code": "    ListNode *partition(ListNode *head, int x) {\\n            \\n            ListNode *head1 = new ListNode(0);\\n            ListNode *head2 = new ListNode(0);\\n            ListNode *h1 = head1;\\n            ListNode *h2 = head2;\\n            while(head)\\n            {\\n                int v = head->val;\\n                if(v < x)\\n                {\\n                    head1->next = head;\\n                    head1 = head1->next;\\n                } else {\\n                    head2->next = head;\\n                    head2 = head2->next;\\n                }\\n                head = head->next;\\n            }\\n            head2->next = NULL;\\n            head1->next = h2->next;;\\n            return h1->next;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 193969,
                "title": "java-beats-100-0ms-explanation",
                "content": "The idea is simple - we separately create two parts of new list head(first part) and tail (second part).\\nInitial state is the following:\\n\\n![image](https://assets.leetcode.com/users/olsh/image_1542296729.png)\\n\\nFirstly, let\\'s find appropriate list for first element:\\n\\n![image](https://assets.leetcode.com/users/olsh/image_1542297024.png)\\n\\nIt\\'s less than x -> goes to head:\\n\\n![image](https://assets.leetcode.com/users/olsh/image_1542297092.png)\\n\\nnow:\\n\\n![image](https://assets.leetcode.com/users/olsh/image_1542297208.png)\\n\\nnext element 4 -> goes to tail:\\n\\n![image](https://assets.leetcode.com/users/olsh/image_1542297259.png)\\n\\nEvery time we add new ListNode in the beginning of head or tail:\\n\\n![image](https://assets.leetcode.com/users/olsh/image_1542297352.png)\\n\\nnext:\\n\\n![image](https://assets.leetcode.com/users/olsh/image_1542297386.png)\\n\\nfinally:\\n![image](https://assets.leetcode.com/users/olsh/image_1542297615.png)\\n\\nAs you can notice, both head and tail are in reversed order.\\nThe next step is merging of these lists into result. Firstly, we add every element from tail, and after it - head.\\n\\n![image](https://assets.leetcode.com/users/olsh/image_1542297852.png)\\n\\n\\nThis adding will be in reverse order, and in such way we\\'ll get resulted list in right order:\\n![image](https://assets.leetcode.com/users/olsh/image_1542297890.png)\\nnext:\\n![image](https://assets.leetcode.com/users/olsh/image_1542297926.png)\\n\\nAll elements from tail were added. As you see, now they are in right order:\\n![image](https://assets.leetcode.com/users/olsh/image_1542298024.png)\\n\\nlet\\'s add all head element in the same way:\\n![image](https://assets.leetcode.com/users/olsh/image_1542298146.png)\\n\\n\\ncode:\\n```\\nclass Solution {\\n    public ListNode partition(ListNode head, int x) {\\n        ListNode headCopy=head;\\n        ListNode h=null;\\n        ListNode t=null;\\n        while (headCopy!=null){\\n            ListNode l = new ListNode(headCopy.val);\\n            if (l.val<x){\\n                l.next = h;\\n                h=l;\\n            }\\n            else {\\n                l.next = t;\\n                t=l;\\n            }\\n            headCopy=headCopy.next;\\n        }\\n        head=null;\\n        while (t!=null){\\n            ListNode l = new ListNode(t.val);\\n            l.next=head;\\n            head = l;\\n            t=t.next;\\n        }\\n        while (h!=null){\\n            ListNode l = new ListNode(h.val);\\n            l.next=head;\\n            head = l;\\n            h=h.next;\\n        }\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public ListNode partition(ListNode head, int x) {\\n        ListNode headCopy=head;\\n        ListNode h=null;\\n        ListNode t=null;\\n        while (headCopy!=null){\\n            ListNode l = new ListNode(headCopy.val);\\n            if (l.val<x){\\n                l.next = h;\\n                h=l;\\n            }\\n            else {\\n                l.next = t;\\n                t=l;\\n            }\\n            headCopy=headCopy.next;\\n        }\\n        head=null;\\n        while (t!=null){\\n            ListNode l = new ListNode(t.val);\\n            l.next=head;\\n            head = l;\\n            t=t.next;\\n        }\\n        while (h!=null){\\n            ListNode l = new ListNode(h.val);\\n            l.next=head;\\n            head = l;\\n            h=h.next;\\n        }\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1157800,
                "title": "partition-list-js-python-java-c-easy-two-lists-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nThe easiest thing to do here is to create separate linked lists for the front and back portions of list we want to return. In order to accomplish that, we should first create some dummy heads (**fdum, bdum**), then create pointers for the current nodes each of the front, back, and main lists (**front, back, curr**).\\n\\nThen we can simply iterate through the main list and stitch together each node to either **front** or **back**, depending on the node\\'s value.\\n\\nOnce we reach the end, we just need to stitch together the two sub-lists, making sure to cap off the end of **back**, and then **return** our new list, minus the dummy head.\\n\\n![Visual 1](https://i.imgur.com/X5semXh.png)\\n\\n---\\n\\n#### ***Implementation:***\\n\\nThere are only minor differences between the code of all four languages.\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **80ms / 40.1MB** (beats 92% / 66%).\\n```javascript\\nvar partition = function(head, x) {\\n    let fdum = new ListNode(0), bdum = new ListNode(0),\\n        front = fdum, back = bdum, curr = head\\n    while (curr) {\\n        if (curr.val < x)front.next = curr, front = curr\\n        else back.next = curr, back = curr\\n        curr = curr.next\\n    }\\n    front.next = bdum.next, back.next = null\\n    return fdum.next\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **24ms / 14.1MB** (beats 99% / 85%).\\n```python\\nclass Solution:\\n    def partition(self, head: ListNode, x: int) -> ListNode:\\n        fdum, bdum = ListNode(0), ListNode(0)\\n        front, back, curr = fdum, bdum, head\\n        while curr:\\n            if curr.val < x:\\n                front.next = curr\\n                front = curr\\n            else:\\n                back.next = curr\\n                back = curr\\n            curr = curr.next\\n        front.next, back.next = bdum.next, None\\n        return fdum.next\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **0ms / 38.2MB** (beats 100% / 69%).\\n```java\\nclass Solution {\\n    public ListNode partition(ListNode head, int x) {\\n        ListNode fdum = new ListNode(0), bdum = new ListNode(0),\\n                 front = fdum, back = bdum, curr = head;\\n        while (curr != null) {\\n            if (curr.val < x) {\\n                front.next = curr;\\n                front = curr;\\n            } else {\\n                back.next = curr;\\n                back = curr;\\n            }\\n            curr = curr.next;\\n        }\\n        front.next = bdum.next;\\n        back.next = null;\\n        return fdum.next;\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **0ms / 10.1MB** (beats 100% / 90%).\\n```c++\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode *fdum = new ListNode(0), *bdum = new ListNode(0),\\n                 *front = fdum, *back = bdum, *curr = head;\\n        while (curr) {\\n            if (curr->val < x) front->next = curr, front = curr;\\n            else back->next = curr, back = curr;\\n            curr = curr->next;\\n        }\\n        front->next = bdum->next, back->next = nullptr;\\n        return fdum->next;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nvar partition = function(head, x) {\\n    let fdum = new ListNode(0), bdum = new ListNode(0),\\n        front = fdum, back = bdum, curr = head\\n    while (curr) {\\n        if (curr.val < x)front.next = curr, front = curr\\n        else back.next = curr, back = curr\\n        curr = curr.next\\n    }\\n    front.next = bdum.next, back.next = null\\n    return fdum.next\\n};\\n```\n```python\\nclass Solution:\\n    def partition(self, head: ListNode, x: int) -> ListNode:\\n        fdum, bdum = ListNode(0), ListNode(0)\\n        front, back, curr = fdum, bdum, head\\n        while curr:\\n            if curr.val < x:\\n                front.next = curr\\n                front = curr\\n            else:\\n                back.next = curr\\n                back = curr\\n            curr = curr.next\\n        front.next, back.next = bdum.next, None\\n        return fdum.next\\n```\n```java\\nclass Solution {\\n    public ListNode partition(ListNode head, int x) {\\n        ListNode fdum = new ListNode(0), bdum = new ListNode(0),\\n                 front = fdum, back = bdum, curr = head;\\n        while (curr != null) {\\n            if (curr.val < x) {\\n                front.next = curr;\\n                front = curr;\\n            } else {\\n                back.next = curr;\\n                back = curr;\\n            }\\n            curr = curr.next;\\n        }\\n        front.next = bdum.next;\\n        back.next = null;\\n        return fdum.next;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode *fdum = new ListNode(0), *bdum = new ListNode(0),\\n                 *front = fdum, *back = bdum, *curr = head;\\n        while (curr) {\\n            if (curr->val < x) front->next = curr, front = curr;\\n            else back->next = curr, back = curr;\\n            curr = curr->next;\\n        }\\n        front->next = bdum->next, back->next = nullptr;\\n        return fdum->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3910862,
                "title": "video-ex-amazon-explains-a-solution-with-python-javascript-java-and-c",
                "content": "# Intuition\\nCreate a small list and a big list.\\n\\n---\\n\\n# Solution Video\\n## *** Please upvote for this article. *** \\n# Subscribe to my channel from here. I have 245 videos as of August 15th\\nhttp://www.youtube.com/channel/UC9RMNwYTL3SXCP6ShLWVFww?sub_confirmation=1\\n\\nhttps://youtu.be/rR8weWU-WQM\\n\\n---\\n\\n# Approach\\nThis is based on Python. Other might be different a bit.\\n\\n1. **Initialization**:\\n   - Initialize two dummy nodes: `slist` and `blist`. These will serve as the heads of two separate lists, one for values less than `x` and the other for values greater than or equal to `x`.\\n   - Initialize two pointers `small` and `big` that initially point to the dummy nodes `slist` and `blist`, respectively.\\n\\n2. **Traversing the Linked List**:\\n   - Start traversing the input linked list `head`.\\n   - In each iteration:\\n     - Check if the value of the current node `head.val` is less than `x`.\\n       - If true:\\n         - Connect the current node to the `small.next` and then move the `small` pointer to the newly added node. This effectively appends the current node to the smaller values list.\\n       - If false:\\n         - Connect the current node to the `big.next` and then move the `big` pointer to the newly added node. This effectively appends the current node to the larger values list.\\n\\n3. **Finishing the Partition**:\\n   - Once the traversal is complete, the smaller values list ends with the last node appended to it (pointed to by the `small` pointer), and the larger values list ends with the last node appended to it (pointed to by the `big` pointer).\\n\\n4. **Connecting Lists**:\\n   - Connect the tail of the smaller values list (`small.next`) to the head of the larger values list (`blist.next`), effectively merging the two lists.\\n\\n5. **Finalizing the Larger Values List**:\\n   - Since the larger values list is now connected to the smaller values list, set the `next` pointer of the last node in the larger values list to `None` to prevent any potential circular references in the linked list.\\n\\n6. **Returning the Result**:\\n   - Return the `next` node of the `slist` dummy node, which represents the head of the modified linked list where values less than `x` are on one side and values greater than or equal to `x` are on the other side.\\n\\nThe algorithm efficiently partitions the original linked list into two parts based on the given value `x`. Nodes with values less than `x` are placed on one side, and nodes with values greater than or equal to `x` are placed on the other side, maintaining the relative order of the nodes within each group. The algorithm uses two dummy nodes and two pointers to create and manage the partitioned lists.\\n\\n# Complexity\\n- Time complexity: O(n)\\nThe code iterates through the entire linked list once to partition the nodes into two separate lists based on the value of x.\\n\\n- Space complexity: O(1)\\nThe code uses a constant amount of extra space for the two dummy nodes slist and blist, as well as for the small and big pointers. The additional space used does not scale with the input size (linked list length) but remains constant throughout the execution.\\n\\n```python []\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def partition(self, head: Optional[ListNode], x: int) -> Optional[ListNode]:\\n\\n        slist, blist = ListNode(), ListNode()\\n        small, big = slist, blist # dummy lists\\n\\n        while head:\\n            if head.val < x:\\n                small.next = head\\n                small = small.next\\n            else:\\n                big.next = head\\n                big = big.next\\n\\n            head = head.next\\n\\n        small.next = blist.next\\n        big.next = None # prevent linked list circle\\n\\n        return slist.next\\n```\\n```javascript []\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @param {number} x\\n * @return {ListNode}\\n */\\nvar partition = function(head, x) {\\n    let slist = new ListNode();\\n    let blist = new ListNode();\\n    let small = slist;\\n    let big = blist;\\n\\n    while (head !== null) {\\n        if (head.val < x) {\\n            small.next = head;\\n            small = small.next;\\n        } else {\\n            big.next = head;\\n            big = big.next;\\n        }\\n\\n        head = head.next;\\n    }\\n\\n    small.next = blist.next;\\n    big.next = null;\\n\\n    return slist.next;    \\n};\\n```\\n```java []\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode partition(ListNode head, int x) {\\n        ListNode slist = new ListNode();\\n        ListNode blist = new ListNode();\\n        ListNode small = slist;\\n        ListNode big = blist;\\n\\n        while (head != null) {\\n            if (head.val < x) {\\n                small.next = head;\\n                small = small.next;\\n            } else {\\n                big.next = head;\\n                big = big.next;\\n            }\\n\\n            head = head.next;\\n        }\\n\\n        small.next = blist.next;\\n        big.next = null;\\n\\n        return slist.next;        \\n    }\\n}\\n```\\n```C++ []\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode* slist = new ListNode(0, nullptr);\\n        ListNode* blist = new ListNode(0, nullptr);\\n        ListNode* small = slist;\\n        ListNode* big = blist;\\n\\n        while (head != nullptr) {\\n            if (head->val < x) {\\n                small->next = head;\\n                small = small->next;\\n            } else {\\n                big->next = head;\\n                big = big->next;\\n            }\\n\\n            head = head->next;\\n        }\\n\\n        small->next = blist->next;\\n        big->next = nullptr;\\n\\n        return slist->next;        \\n    }\\n};\\n```\\n\\n### Thank you for reading. Please upvote the article and don\\'t forget to subscribe to my youtube channel!\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "JavaScript"
                ],
                "code": "```python []\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def partition(self, head: Optional[ListNode], x: int) -> Optional[ListNode]:\\n\\n        slist, blist = ListNode(), ListNode()\\n        small, big = slist, blist # dummy lists\\n\\n        while head:\\n            if head.val < x:\\n                small.next = head\\n                small = small.next\\n            else:\\n                big.next = head\\n                big = big.next\\n\\n            head = head.next\\n\\n        small.next = blist.next\\n        big.next = None # prevent linked list circle\\n\\n        return slist.next\\n```\n```javascript []\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @param {number} x\\n * @return {ListNode}\\n */\\nvar partition = function(head, x) {\\n    let slist = new ListNode();\\n    let blist = new ListNode();\\n    let small = slist;\\n    let big = blist;\\n\\n    while (head !== null) {\\n        if (head.val < x) {\\n            small.next = head;\\n            small = small.next;\\n        } else {\\n            big.next = head;\\n            big = big.next;\\n        }\\n\\n        head = head.next;\\n    }\\n\\n    small.next = blist.next;\\n    big.next = null;\\n\\n    return slist.next;    \\n};\\n```\n```java []\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode partition(ListNode head, int x) {\\n        ListNode slist = new ListNode();\\n        ListNode blist = new ListNode();\\n        ListNode small = slist;\\n        ListNode big = blist;\\n\\n        while (head != null) {\\n            if (head.val < x) {\\n                small.next = head;\\n                small = small.next;\\n            } else {\\n                big.next = head;\\n                big = big.next;\\n            }\\n\\n            head = head.next;\\n        }\\n\\n        small.next = blist.next;\\n        big.next = null;\\n\\n        return slist.next;        \\n    }\\n}\\n```\n```C++ []\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode* slist = new ListNode(0, nullptr);\\n        ListNode* blist = new ListNode(0, nullptr);\\n        ListNode* small = slist;\\n        ListNode* big = blist;\\n\\n        while (head != nullptr) {\\n            if (head->val < x) {\\n                small->next = head;\\n                small = small->next;\\n            } else {\\n                big->next = head;\\n                big = big->next;\\n            }\\n\\n            head = head->next;\\n        }\\n\\n        small->next = blist->next;\\n        big->next = nullptr;\\n\\n        return slist->next;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2315385,
                "title": "python-single-pass-o-1-space-explained",
                "content": "**UPVOTE IF HELPFuuL**\\n\\n**O ( N ) space approach**\\n\\nTraverse the list and keep the values in a list that are smaller than ```key``` provided. Traverse again to find the values greater than or equal to ```key```.\\nMake the list and return it.\\n\\n**O ( 1 ) with TWO PASSES**\\n\\nCreate a node with garbage value. *let say **resultant*** -> This prevents us from checking if ```resultant``` linked list is empty or not.\\n*First-pass* -> Traverse and add all the nodes that are ```smaller``` than ```key``` provided.\\n*Secong-pass* -> Traverse again to add nodes that are ```greater than or equal to``` key provided.\\n```return resultant -> next``` *[ next returned to remove garbage node ]*\\n\\n**O ( 1 ) with SINGLE PASS**\\n\\nCreate two nodes with garbage vales.\\n* ```small``` -> to have nodes with value *less* than ```key```\\n* ```large``` -> to have nodes with value *greater than or equal* to ```key```.\\n\\nNow visit each node :\\n* if node smaller -> add to ```small``` and ```small -> next = NULL```\\n* else -> add to ```large``` and ```large -> next = NULL```\\n\\n*[ We make ```small/large -> next = NULL``` to add only a single node and break further connection, if not done , whole list after head will be added to them ]*\\n\\nAt end join two linked lists *[ remember the garbage nodes ]* ->\\n* make ```small -> next = large_head -> next``` : we appending large_head -> **next** because the first node is garbage.\\n\\nSame way while returning remove garbage node from small and return ```return small_head -> next```.\\n\\n**UPVOTE IF HELPFuuL**\\n\\n```\\nclass Solution:\\n    def partition(self, head: Optional[ListNode], x: int) -> Optional[ListNode]:\\n        \\n        small = ListNode(-1)\\n        large = ListNode(-1)\\n        small_head = small\\n        large_head = large\\n        \\n        while head:\\n            \\n            if head.val < x:\\n                small.next = head\\n                head = head.next\\n                small = small.next\\n                small.next = None\\n            \\n            else:\\n                large.next = head\\n                head = head.next\\n                large = large.next\\n                large.next = None\\n        \\n        small.next = large_head.next\\n        \\n        return small_head.next\\n```\\n![image](https://assets.leetcode.com/users/images/5ffb5fcb-e7b7-479e-b3c0-0097cb44c567_1658455850.354948.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "```key```\n```key```\n```resultant```\n```smaller```\n```key```\n```greater than or equal to```\n```return resultant -> next```\n```small```\n```key```\n```large```\n```key```\n```small```\n```small -> next = NULL```\n```large```\n```large -> next = NULL```\n```small/large -> next = NULL```\n```small -> next = large_head -> next```\n```return small_head -> next```\n```\\nclass Solution:\\n    def partition(self, head: Optional[ListNode], x: int) -> Optional[ListNode]:\\n        \\n        small = ListNode(-1)\\n        large = ListNode(-1)\\n        small_head = small\\n        large_head = large\\n        \\n        while head:\\n            \\n            if head.val < x:\\n                small.next = head\\n                head = head.next\\n                small = small.next\\n                small.next = None\\n            \\n            else:\\n                large.next = head\\n                head = head.next\\n                large = large.next\\n                large.next = None\\n        \\n        small.next = large_head.next\\n        \\n        return small_head.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3910854,
                "title": "c-c-linked-lists-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nDivide the given list head into 2 linked lists, greater & smaller. Then connect these 2 lists and return the result.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n[Please turn on english subtitles if necessary]\\n[https://youtu.be/LZ6oARGKnZA](https://youtu.be/LZ6oARGKnZA)\\n\\nSince my program uses the constructors, it needs extra O(1) space, that is an extra dummy node. With such extra dummy node makes programming much easier. It is a normal trick to deal pointer question. Why? These 2 ponters smallerhead and greaterhead pointer different addressses! If you won\\'t use extra space, it needs some modification.\\n\\nLet\\'s consider the test case\\n\\n[1,4,3,2,5,2]\\n3\\n\\nUse while loop to traverse and partition\\n\\nsmaller->0->1->2->2\\ngreater->0->4->3->5->NULL\\n\\nthen connect 2 lists by \\n```\\nsmallerTail->next = greaterHead->next;\\n```\\nObtain\\nsmaller->0->1->2->2->4->3->5->NULL\\n\\nFinally\\n```\\nhead = smallerHead->next;\\n```\\nHave\\nhead->1->2->2->4->3->5->NULL\\nReturn head\\n\\nThe whole process shown by modifying submitted code in playground\\n```\\n1<3:smaller\\nsmaller:0->1->4->3->2->5->2\\ngreater:0\\n-------\\n4>=3: greater\\nsmaller:0->1->4->3->2->5->2\\ngreater:0->4->3->2->5->2\\n-------\\n3>=3: greater\\nsmaller:0->1->4->3->2->5->2\\ngreater:0->4->3->2->5->2\\n-------\\n2<3:smaller\\nsmaller:0->1->2->5->2\\ngreater:0->4->3->2->5->2\\n-------\\n5>=3: greater\\nsmaller:0->1->2->5->2\\ngreater:0->4->3->5->2\\n-------\\n2<3:smaller\\nsmaller:0->1->2->2\\ngreater:0->4->3->5->2\\n-------\\nans:\\n1->2->2->4->3->5\\n```\\n<iframe src=\"https://leetcode.com/playground/3ydV9DDY/shared\" frameBorder=\"0\" width=\"600\" height=\"300\"></iframe>\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        if (head == NULL) return head;\\n        \\n        ListNode* smallerHead=new ListNode(); //Head of the list with nodes <x\\n        ListNode* smallerTail=smallerHead; //Tail of the list with nodes <x\\n        \\n        ListNode* greaterHead=new ListNode();//Head of the list with nodes >=x\\n        ListNode* greaterTail=greaterHead; //Tail of the list with nodes >=x\\n        \\n        ListNode* curr = head;\\n        while (curr) {//partition into greater & smaller lists\\n            if (curr->val < x) {\\n                smallerTail->next = curr;\\n                smallerTail =smallerTail->next;\\n            } \\n            else {\\n                greaterTail->next = curr;\\n                greaterTail=greaterTail->next;\\n            }\\n            curr = curr->next;\\n        }\\n        \\n        greaterTail->next = NULL; \\n        smallerTail->next = greaterHead->next;//Connect the smaller and the greater lists\\n        delete greaterHead; //avoid of memory leak thx to @heder\\n        head = smallerHead->next; //Update the head of the list\\n        delete smallerHead; //avoid of memory leak thx to @heder\\n        return head;\\n    }\\n};\\n\\n```\\n# C code\\n\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     struct ListNode *next;\\n * };\\n */\\ntypedef  struct ListNode ListNode;\\nstruct ListNode* partition(struct ListNode* head, int x){\\n    if (head == NULL) return head;\\n    ListNode* smaller=(ListNode*)malloc(sizeof(ListNode)); \\n    smaller->val=0;\\n    ListNode* smallerTail=smaller; //Tail of the list with nodes <x\\n        \\n    ListNode* greater=(ListNode*)malloc(sizeof(ListNode));\\n    greater->val=0;\\n    ListNode* greaterTail=greater; //Tail of the list with nodes >=x\\n        \\n    ListNode* curr = head;\\n    while (curr) {//partition into greater & smaller lists\\n        if (curr->val < x) {\\n            smallerTail->next = curr;\\n            smallerTail =smallerTail->next;\\n        } \\n        else {\\n            greaterTail->next = curr;\\n            greaterTail=greaterTail->next;\\n        }\\n        curr = curr->next;\\n    }\\n        \\n    greaterTail->next = NULL; \\n    smallerTail->next = greater->next;//Connect the smaller and the greater lists\\n    free(greater);   \\n    head = smaller->next; //Update the head of the list\\n    free(smaller);  \\n    return head;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "```\\nsmallerTail->next = greaterHead->next;\\n```\n```\\nhead = smallerHead->next;\\n```\n```\\n1<3:smaller\\nsmaller:0->1->4->3->2->5->2\\ngreater:0\\n-------\\n4>=3: greater\\nsmaller:0->1->4->3->2->5->2\\ngreater:0->4->3->2->5->2\\n-------\\n3>=3: greater\\nsmaller:0->1->4->3->2->5->2\\ngreater:0->4->3->2->5->2\\n-------\\n2<3:smaller\\nsmaller:0->1->2->5->2\\ngreater:0->4->3->2->5->2\\n-------\\n5>=3: greater\\nsmaller:0->1->2->5->2\\ngreater:0->4->3->5->2\\n-------\\n2<3:smaller\\nsmaller:0->1->2->2\\ngreater:0->4->3->5->2\\n-------\\nans:\\n1->2->2->4->3->5\\n```\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        if (head == NULL) return head;\\n        \\n        ListNode* smallerHead=new ListNode(); //Head of the list with nodes <x\\n        ListNode* smallerTail=smallerHead; //Tail of the list with nodes <x\\n        \\n        ListNode* greaterHead=new ListNode();//Head of the list with nodes >=x\\n        ListNode* greaterTail=greaterHead; //Tail of the list with nodes >=x\\n        \\n        ListNode* curr = head;\\n        while (curr) {//partition into greater & smaller lists\\n            if (curr->val < x) {\\n                smallerTail->next = curr;\\n                smallerTail =smallerTail->next;\\n            } \\n            else {\\n                greaterTail->next = curr;\\n                greaterTail=greaterTail->next;\\n            }\\n            curr = curr->next;\\n        }\\n        \\n        greaterTail->next = NULL; \\n        smallerTail->next = greaterHead->next;//Connect the smaller and the greater lists\\n        delete greaterHead; //avoid of memory leak thx to @heder\\n        head = smallerHead->next; //Update the head of the list\\n        delete smallerHead; //avoid of memory leak thx to @heder\\n        return head;\\n    }\\n};\\n\\n```\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     struct ListNode *next;\\n * };\\n */\\ntypedef  struct ListNode ListNode;\\nstruct ListNode* partition(struct ListNode* head, int x){\\n    if (head == NULL) return head;\\n    ListNode* smaller=(ListNode*)malloc(sizeof(ListNode)); \\n    smaller->val=0;\\n    ListNode* smallerTail=smaller; //Tail of the list with nodes <x\\n        \\n    ListNode* greater=(ListNode*)malloc(sizeof(ListNode));\\n    greater->val=0;\\n    ListNode* greaterTail=greater; //Tail of the list with nodes >=x\\n        \\n    ListNode* curr = head;\\n    while (curr) {//partition into greater & smaller lists\\n        if (curr->val < x) {\\n            smallerTail->next = curr;\\n            smallerTail =smallerTail->next;\\n        } \\n        else {\\n            greaterTail->next = curr;\\n            greaterTail=greaterTail->next;\\n        }\\n        curr = curr->next;\\n    }\\n        \\n    greaterTail->next = NULL; \\n    smallerTail->next = greater->next;//Connect the smaller and the greater lists\\n    free(greater);   \\n    head = smaller->next; //Update the head of the list\\n    free(smaller);  \\n    return head;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 29263,
                "title": "8ms-c-easy-to-understand",
                "content": "    class Solution {\\n    public:\\n        ListNode* partition(ListNode* head, int x) {\\n            ListNode *l1 = new ListNode(0),*l2 = new ListNode(0); /*create two list for two partitions*/\\n            ListNode *p1=l1,*p2=l2,*p=head;\\n            while(p!=NULL){\\n                if((p->val)<x) p1 = p1->next = p;\\n                else p2 = p2->next = p;\\n                p = p->next;\\n            }\\n            p2->next = NULL;\\n            p1->next = l2->next;\\n            return l1->next;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        ListNode* partition(ListNode* head, int x) {\\n            ListNode *l1 = new ListNode(0),*l2 = new ListNode(0); /*create two list for two partitions*/\\n            ListNode *p1=l1,*p2=l2,*p=head;\\n            while(p!=NULL){\\n                if((p->val)<x) p1 = p1->next = p;\\n                else p2 = p2->next = p;\\n                p = p->next;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1158193,
                "title": "java-explained-solution",
                "content": "**EXPLANATION AND IDEA:**\\n 1->4->3->2->5->2  , x=3\\n make two dummy variable and initail them with 0(to avoid handle null things)\\n left :0\\n right:0\\n \\n iterate over given node. If node value is less than x add it to left else add to right.\\n \\n \\n left : 0 -> 1 -> 2 -> 2 \\n right : 0 -> 4 -> 3 -> 5\\n \\n now connect tail of left to 4(i.e right.next)\\n \\n left : 0->1->2->2->4->3->5\\n    make tail2.next=null;\\n     return left.next;\\n\\t \\n**CODE:** \\n```\\npublic ListNode partition(ListNode head, int x) {\\n        if(head==null) return null;\\n        \\n      \\n        ListNode left=new ListNode(0);\\n        ListNode right=new ListNode(0);\\n        \\n        ListNode tail1=left , tail2=right;\\n      \\n        ListNode iterator=head;\\n        while(iterator!=null){\\n            if(iterator.val<x){\\n                tail1.next=iterator;\\n                tail1=tail1.next;\\n            }else{\\n                tail2.next=iterator;\\n                tail2=tail2.next;\\n            }\\n           iterator=iterator.next;\\n        }\\n        tail1.next=right.next;\\n        tail2.next=null; // important\\n\\n        return left.next;\\n    }\\n```\\n\\n**Complexity:**\\nTime:O(n) \\nSpace:O(1) [ as we are using just 2 pointers and rebuilding given list]\\n\\nPlease **UPVOTE** if found it helpful and feel free to comment down or reach out to me if you have any doubt.",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\npublic ListNode partition(ListNode head, int x) {\\n        if(head==null) return null;\\n        \\n      \\n        ListNode left=new ListNode(0);\\n        ListNode right=new ListNode(0);\\n        \\n        ListNode tail1=left , tail2=right;\\n      \\n        ListNode iterator=head;\\n        while(iterator!=null){\\n            if(iterator.val<x){\\n                tail1.next=iterator;\\n                tail1=tail1.next;\\n            }else{\\n                tail2.next=iterator;\\n                tail2=tail2.next;\\n            }\\n           iterator=iterator.next;\\n        }\\n        tail1.next=right.next;\\n        tail2.next=null; // important\\n\\n        return left.next;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 29335,
                "title": "my-accepted-solution-any-improvement",
                "content": "This is my accepted solution:\\n\\n    public class Solution {\\n        public ListNode partition(ListNode head, int x) {\\n            ListNode cur=head;\\n            \\n            ListNode smaller_sentinel=new ListNode(0);\\n            ListNode smaller_cur=smaller_sentinel;\\n            ListNode larger_sentinel=new ListNode(0);\\n            ListNode larger_cur=larger_sentinel;\\n    //Now, go along the list, partitioning into two halves.        \\n            while(cur!=null){\\n                if(cur.val<x){\\n                        smaller_cur.next=cur;\\n                        smaller_cur=smaller_cur.next;\\n                    \\n                }else{\\n                        larger_cur.next=cur;\\n                        larger_cur=larger_cur.next;\\n                }\\n                cur=cur.next;\\n            }\\n    //Now, do the concatenation of two havles. Make sure the last node points to null \\n            larger_cur.next=null;\\n            smaller_cur.next=larger_sentinel.next;\\n            return smaller_sentinel.next;\\n        }\\n    }\\n\\nIt's pretty straightforward. I used multiple references (including sentinels), first to get the two halves, and then link them together. It took 400+ ms to pass the tests (in Java). I guess it's not the optimal solution. Any idea improving it?",
                "solutionTags": [],
                "code": "class Solution {\\n        public ListNode partition(ListNode head, int x) {\\n            ListNode cur=head;\\n            \\n            ListNode smaller_sentinel=new ListNode(0);\\n            ListNode smaller_cur=smaller_sentinel;\\n            ListNode larger_sentinel=new ListNode(0);\\n            ListNode larger_cur=larger_sentinel;\\n    //Now, go along the list, partitioning into two halves.        \\n            while(cur!=null){\\n                if(cur.val<x){\\n                        smaller_cur.next=cur;\\n                        smaller_cur=smaller_cur.next;\\n                    \\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1921915,
                "title": "100-fastest-swift-solution",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public var val: Int\\n *     public var next: ListNode?\\n *     public init() { self.val = 0; self.next = nil; }\\n *     public init(_ val: Int) { self.val = val; self.next = nil; }\\n *     public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\\n * }\\n */\\nclass Solution {\\n    func partition(_ head: ListNode?, _ x: Int) -> ListNode? {\\n        var current = head\\n        var left_nodes: [ListNode?] = []\\n        var right_nodes: [ListNode?] = []\\n        var head: ListNode?\\n        var prev: ListNode?\\n        \\n        while current != nil {\\n            if current!.val < x {\\n                left_nodes.append(current)\\n            } else {\\n                right_nodes.append(current)\\n            }\\n            \\n            current = current?.next\\n        }\\n        \\n        for node in left_nodes + right_nodes {\\n            node?.next = nil\\n            \\n            if head == nil {\\n                head = node\\n            } else {\\n                prev?.next = node\\n            }\\n            \\n            prev = node\\n        }\\n        \\n        return head\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public var val: Int\\n *     public var next: ListNode?\\n *     public init() { self.val = 0; self.next = nil; }\\n *     public init(_ val: Int) { self.val = val; self.next = nil; }\\n *     public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\\n * }\\n */\\nclass Solution {\\n    func partition(_ head: ListNode?, _ x: Int) -> ListNode? {\\n        var current = head\\n        var left_nodes: [ListNode?] = []\\n        var right_nodes: [ListNode?] = []\\n        var head: ListNode?\\n        var prev: ListNode?\\n        \\n        while current != nil {\\n            if current!.val < x {\\n                left_nodes.append(current)\\n            } else {\\n                right_nodes.append(current)\\n            }\\n            \\n            current = current?.next\\n        }\\n        \\n        for node in left_nodes + right_nodes {\\n            node?.next = nil\\n            \\n            if head == nil {\\n                head = node\\n            } else {\\n                prev?.next = node\\n            }\\n            \\n            prev = node\\n        }\\n        \\n        return head\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1278506,
                "title": "python-simple-and-easy-approach",
                "content": "# Partition List\\n**We basically need to keep track of first and last node of each partioned sub lists, so that we can connect them later.**\\n\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def partition(self, head: ListNode, x: int) -> ListNode:\\n        h1 = l1 = ListNode(0)\\n        h2 = l2 = ListNode(0)\\n        \\n        while head:\\n            if head.val < x:\\n                l1.next = head\\n                l1 = l1.next\\n            else:\\n                l2.next = head\\n                l2 = l2.next\\n            head = head.next\\n            \\n        l2.next = None\\n        l1.next = h2.next\\n        \\n        return h1.next\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def partition(self, head: ListNode, x: int) -> ListNode:\\n        h1 = l1 = ListNode(0)\\n        h2 = l2 = ListNode(0)\\n        \\n        while head:\\n            if head.val < x:\\n                l1.next = head\\n                l1 = l1.next\\n            else:\\n                l2.next = head\\n                l2 = l2.next\\n            head = head.next\\n            \\n        l2.next = None\\n        l1.next = h2.next\\n        \\n        return h1.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 29203,
                "title": "intuitive-javascript-solution",
                "content": "```\\nvar partition = function(head, x) {\\n    const dummyLess = new ListNode();\\n    const dummyMore = new ListNode();\\n    let node = head;\\n    let less = dummyLess;\\n    let more = dummyMore;\\n    while (node) {\\n        if (node.val < x) {\\n            less = less.next = node;\\n        } else {\\n            more = more.next = node;\\n        }\\n        node = node.next;\\n    }\\n    less.next = dummyMore.next;\\n    more.next = null;\\n    return dummyLess.next;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar partition = function(head, x) {\\n    const dummyLess = new ListNode();\\n    const dummyMore = new ListNode();\\n    let node = head;\\n    let less = dummyLess;\\n    let more = dummyMore;\\n    while (node) {\\n        if (node.val < x) {\\n            less = less.next = node;\\n        } else {\\n            more = more.next = node;\\n        }\\n        node = node.next;\\n    }\\n    less.next = dummyMore.next;\\n    more.next = null;\\n    return dummyLess.next;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3915216,
                "title": "c-don-t-leak-memory-index-pointer-instead-of-branches",
                "content": "There are a couple of solutions that allocate the dummy heads on the heap like so:\\n\\n```cpp\\n    ListNode* dummy = new ListeNode(0);\\n```\\n\\nIn many of these solutions this dummy head doesn\\'t get deleted, so the solution is leaking memory. This can easly be avoid be allocating the dummy head on the stack like so:\\n\\n```cpp\\n   ListNode dummy;\\n```\\n\\nThis avoids a heap allocation, which is faster. The memory is not leaked and it doesn\\'t require an explict ```delete```.\\n\\n# Approach 1: dummy node on stack and fewer branches\\nIn this solution we use the condition ```head->val >= x``` to index into the list pointers, this avoids a branch which is hard to predict by the CPU and also yields pretty short code.\\n\\n```cpp\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode lt;\\n        ListNode ge;\\n        array<ListNode*, 2> p = {&lt, &ge};\\n        for ( ; head; head = head->next) {\\n            const bool cond = head->val >= x;\\n            p[cond] = p[cond]->next = head;\\n        }\\n        p[1]->next = nullptr;\\n        p[0]->next = ge.next;\\n        return lt.next;\\n    }\\n```\\n\\n**Complexity Analysis**\\nLet $$n$$ be the length of the list then the\\n\\n* Time complexity is $$O(n)$$ as we need to traverse the list once and the\\n\\n* Space comlexity is $$O(1)$$ as we only need dummy heads and two extra pointers.\\n\\n_As always: Feedback, questions, and comments are welcome. Leaving an up-vote sparks joy! :)_\\n\\n**p.s. Join us on the [LeetCode The Hard Way Discord Server](https://discord.gg/hFUyVyWy2E)!**\\n",
                "solutionTags": [],
                "code": "```cpp\\n    ListNode* dummy = new ListeNode(0);\\n```\n```cpp\\n   ListNode dummy;\\n```\n```delete```\n```head->val >= x```\n```cpp\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode lt;\\n        ListNode ge;\\n        array<ListNode*, 2> p = {&lt, &ge};\\n        for ( ; head; head = head->next) {\\n            const bool cond = head->val >= x;\\n            p[cond] = p[cond]->next = head;\\n        }\\n        p[1]->next = nullptr;\\n        p[0]->next = ge.next;\\n        return lt.next;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3911215,
                "title": "simple-java-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public ListNode partition(ListNode head, int x) {\\n        if(head==null||head.next==null)\\n            return head;\\n        ListNode start=null,fresh,prev=null;\\n        for(ListNode ptr=head;ptr!=null;ptr=ptr.next)\\n        {\\n            if(ptr.val<x)\\n            {\\n                fresh=new ListNode(ptr.val);\\n                if(start==null)\\n                    start=fresh;\\n                else\\n                    prev.next=fresh;\\n                prev=fresh;\\n            }\\n        }\\n        for(ListNode ptr=head;ptr!=null;ptr=ptr.next)\\n        {\\n            if(ptr.val>=x)\\n            {\\n                fresh=new ListNode(ptr.val);\\n                if(start==null)\\n                    start=fresh;\\n                else\\n                    prev.next=fresh;\\n                prev=fresh;\\n            }\\n        }\\n        return start;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode partition(ListNode head, int x) {\\n        if(head==null||head.next==null)\\n            return head;\\n        ListNode start=null,fresh,prev=null;\\n        for(ListNode ptr=head;ptr!=null;ptr=ptr.next)\\n        {\\n            if(ptr.val<x)\\n            {\\n                fresh=new ListNode(ptr.val);\\n                if(start==null)\\n                    start=fresh;\\n                else\\n                    prev.next=fresh;\\n                prev=fresh;\\n            }\\n        }\\n        for(ListNode ptr=head;ptr!=null;ptr=ptr.next)\\n        {\\n            if(ptr.val>=x)\\n            {\\n                fresh=new ListNode(ptr.val);\\n                if(start==null)\\n                    start=fresh;\\n                else\\n                    prev.next=fresh;\\n                prev=fresh;\\n            }\\n        }\\n        return start;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3232034,
                "title": "partition-a-linked-list-around-a-given-value-in-python-beats-99",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem asks us to partition a linked list around a given value `x`, such that all nodes less than `x` come before nodes greater than or equal to `x`, while preserving the original relative order of the nodes in each partition.\\n\\nOne way to approach this problem is to create two new linked lists: one for nodes less than `x` and another for nodes greater than or equal to `x`. We can then iterate over the original linked list and append each node to the appropriate new list based on its value. Finally, we merge the two new lists into one, preserving the relative order of the nodes in each list.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Create two new linked lists: one for nodes less than `x` and another for nodes greater than or equal to `x`. Initialize two dummy nodes for the heads of each list, and two tail pointers to the dummy nodes.\\n\\n- Traverse the original linked list and append each node to the appropriate new list based on its value. If a node has a value less than `x`, append it to the `less` list and update `less_tail`. Otherwise, append it to the `greater` list and update `greater_tail`.\\n\\n- Terminate the `greater` list by setting the `next` pointer of `greater_tail` to `None`. Then, link the end of the `less` list to the beginning of the `greater` list by setting the `next` pointer of `less_tail` to the `next` pointer of `greater_head`.\\n\\n- Return the `next` pointer of the `less_head` dummy node, which will skip over the initial dummy node and give us the head of the new linked list.\\n# Complexity\\n- Time complexity: The algorithm makes a single pass over the linked list, so its time complexity is O(N), where N is the length of the linked list.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: The algorithm uses a constant amount of extra space for the two dummy nodes and the two tail pointers, so its space complexity is O(1).\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def partition(self, head: Optional[ListNode], x: int) -> Optional[ListNode]:\\n        less_head = less_tail = ListNode(0)\\n        greater_head = greater_tail = ListNode(0)\\n    \\n        while head:\\n            if head.val < x:\\n                less_tail.next = head\\n                less_tail = less_tail.next\\n            else:\\n                greater_tail.next = head\\n                greater_tail = greater_tail.next\\n            head = head.next\\n    \\n        greater_tail.next = None\\n        less_tail.next = greater_head.next\\n    \\n        return less_head.next\\n```",
                "solutionTags": [
                    "Python3",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def partition(self, head: Optional[ListNode], x: int) -> Optional[ListNode]:\\n        less_head = less_tail = ListNode(0)\\n        greater_head = greater_tail = ListNode(0)\\n    \\n        while head:\\n            if head.val < x:\\n                less_tail.next = head\\n                less_tail = less_tail.next\\n            else:\\n                greater_tail.next = head\\n                greater_tail = greater_tail.next\\n            head = head.next\\n    \\n        greater_tail.next = None\\n        less_tail.next = greater_head.next\\n    \\n        return less_head.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1157886,
                "title": "partition-list-simple-1-pass-partition-w-2-pointers-explained",
                "content": "There are a few approach using which this question can be solved. In the simplest solution, we can iterate over the list in the first pass and append all nodes less than `x` and in the second pass append all nodes greater than or equal to `x`.\\n\\nLet\\'s try to solve the problem in one-pass and O(1) Space without making duplicate copies of original nodes.\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution (2-pointer partition)***\\n\\nWe can easily partition the list if we maintain two pointers -\\n* `lesser` - to store all the nodes from original list which are less than `x`.\\n* `greater` - to store all the nodes from original list which are greater than or equal to `x`.\\n\\nWe initialise both of these pointers to temporary / dummy nodes so that we can easily append to them without having to do any extra checks.\\n\\nWe would also need two more variable to store the heads of these pointers - `lesser_head` and `greater_head` which would be required later to join `lesser` to `greater_head` and finally return the head of partition list which would be `lesser_head -> next` (since lesser_head is dummy node, so return its next).\\n\\n\\n```\\n ListNode* partition(ListNode* head, int x) {\\n \\xA0 \\xA0 ListNode *lesser = new ListNode(-1), *greater = new ListNode(-1), *lesser_head = lesser, *greater_head = greater;\\n \\xA0 \\xA0 while(head){\\n \\xA0 \\xA0 \\xA0 \\xA0 if(head -> val < x) \\n                lesser -> next = head, lesser = lesser -> next;\\n \\xA0 \\xA0 \\xA0 \\xA0 else \\n                greater -> next = head, greater = greater -> next;\\n \\xA0 \\xA0 \\xA0 \\xA0 head = head -> next; \\n \\xA0 \\xA0 }\\n \\xA0 \\xA0 greater -> next = NULL;\\n \\xA0 \\xA0 lesser -> next = greater_head -> next;\\n \\xA0 \\xA0 return lesser_head -> next;\\n }\\n```\\n\\n***Time Complexity :*** **`O(N)`**, where `N` is the total number of nodes in original linked list.\\n***Space Complexity :*** **`O(1)`**. Note that we are not making duplicate nodes, just rearranging the original nodes in our partitioned",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n ListNode* partition(ListNode* head, int x) {\\n \\xA0 \\xA0 ListNode *lesser = new ListNode(-1), *greater = new ListNode(-1), *lesser_head = lesser, *greater_head = greater;\\n \\xA0 \\xA0 while(head){\\n \\xA0 \\xA0 \\xA0 \\xA0 if(head -> val < x) \\n                lesser -> next = head, lesser = lesser -> next;\\n \\xA0 \\xA0 \\xA0 \\xA0 else \\n                greater -> next = head, greater = greater -> next;\\n \\xA0 \\xA0 \\xA0 \\xA0 head = head -> next; \\n \\xA0 \\xA0 }\\n \\xA0 \\xA0 greater -> next = NULL;\\n \\xA0 \\xA0 lesser -> next = greater_head -> next;\\n \\xA0 \\xA0 return lesser_head -> next;\\n }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1157785,
                "title": "c-super-simple-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode *smaller_ptr = new ListNode(0), *greater_ptr = new ListNode(0), *ptr = head;\\n        ListNode *smaller = smaller_ptr, *greater = greater_ptr;\\n        \\n        while (ptr) {\\n            if (ptr->val < x) {\\n                smaller_ptr->next = ptr;\\n                smaller_ptr = smaller_ptr->next;\\n            }\\n            \\n            else {\\n                greater_ptr->next = ptr;\\n                greater_ptr = greater_ptr->next;\\n            }\\n            ptr = ptr->next;\\n        }\\n        \\n        greater_ptr->next = NULL;\\n        smaller_ptr->next = greater->next;\\n        return smaller->next;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode *smaller_ptr = new ListNode(0), *greater_ptr = new ListNode(0), *ptr = head;\\n        ListNode *smaller = smaller_ptr, *greater = greater_ptr;\\n        \\n        while (ptr) {\\n            if (ptr->val < x) {\\n                smaller_ptr->next = ptr;\\n                smaller_ptr = smaller_ptr->next;\\n            }\\n            \\n            else {\\n                greater_ptr->next = ptr;\\n                greater_ptr = greater_ptr->next;\\n            }\\n            ptr = ptr->next;\\n        }\\n        \\n        greater_ptr->next = NULL;\\n        smaller_ptr->next = greater->next;\\n        return smaller->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 29296,
                "title": "c-concise-solution",
                "content": "        \\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode *dummy1 = new ListNode(0), *dummy2 = new ListNode(0), *node1, *node2;\\n        node1 = dummy1;\\n        node2 = dummy2;\\n        while (head) {\\n            if (head->val < x) {\\n                node1->next = head;\\n                node1 = node1->next;\\n            } else {\\n                node2->next = head;\\n                node2 = node2->next;\\n            }\\n            head = head->next;\\n        }\\n        node2->next = NULL;\\n        node1->next = dummy2->next;\\n        return dummy1->next;\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "        \\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode *dummy1 = new ListNode(0), *dummy2 = new ListNode(0), *node1, *node2;\\n        node1 = dummy1;\\n        node2 = dummy2;\\n        while (head) {\\n            if (head->val < x) {\\n                node1->next = head;\\n                node1 = node1->next;\\n            } else {\\n                node2->next = head;\\n                node2 = node2->next;\\n            }\\n            head = head->next;\\n        }\\n        node2->next = NULL;\\n        node1->next = dummy2->next;\\n        return dummy1->next;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3911378,
                "title": "beats-100-o-n-time-o-1-space-inplace-without-making-new-list",
                "content": "\\n# Approach\\nTraverse the linked list and when you see the node less than target then remove this node and insert it after the previous smaller node.\\nTake care of boundary cases.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1) extra space\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        if(head==NULL) return head;\\n        if(head->next == NULL) return head;\\n        if(head->val >= x){\\n            ListNode* k1,*k2;\\n            k2 = head->next;\\n            k1 = head;\\n            while(k2 && k2->val>=x){                            \\n                k1 = k1->next;\\n                k2 = k2->next;\\n            }\\n            if(k2!=NULL){\\n                k1->next = k2->next;\\n                k2->next = head;\\n                head = k2;\\n            }\\n        }\\n        ListNode* l1,*l2,*l3;\\n        l1 = head;\\n        while(l1 && l1->next && l1->next->val < x && l1->val < x){\\n            l1 = l1->next;\\n        }    \\n        if(l1==NULL){\\n            return head;\\n        }                                                                  \\n        l2 = l1;\\n        l3 = l1->next;\\n        while(l3&&l2){\\n            if(l3->val >= x){\\n                l3 = l3->next;\\n                l2 = l2->next;\\n                continue;\\n            }\\n            l2->next = l3->next;\\n            l3->next = l1->next;\\n            l1->next = l3;\\n            l1 = l1->next;\\n            l3 = l2->next;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        if(head==NULL) return head;\\n        if(head->next == NULL) return head;\\n        if(head->val >= x){\\n            ListNode* k1,*k2;\\n            k2 = head->next;\\n            k1 = head;\\n            while(k2 && k2->val>=x){                            \\n                k1 = k1->next;\\n                k2 = k2->next;\\n            }\\n            if(k2!=NULL){\\n                k1->next = k2->next;\\n                k2->next = head;\\n                head = k2;\\n            }\\n        }\\n        ListNode* l1,*l2,*l3;\\n        l1 = head;\\n        while(l1 && l1->next && l1->next->val < x && l1->val < x){\\n            l1 = l1->next;\\n        }    \\n        if(l1==NULL){\\n            return head;\\n        }                                                                  \\n        l2 = l1;\\n        l3 = l1->next;\\n        while(l3&&l2){\\n            if(l3->val >= x){\\n                l3 = l3->next;\\n                l2 = l2->next;\\n                continue;\\n            }\\n            l2->next = l3->next;\\n            l3->next = l1->next;\\n            l1->next = l3;\\n            l1 = l1->next;\\n            l3 = l2->next;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3910919,
                "title": "rust-python-list-fast-solution",
                "content": "# Intuition \\uD83E\\uDD14\\nImagine you\\'re a \\uD83E\\uDD80 sorting pearls and stones from the ocean floor. The pearls (values less than `x`) are precious and you want to keep them close. The stones (values greater than or equal to `x`), while not as valuable, still need to be stored neatly. Now, imagine each pearl and stone is a node in the linked list. Our goal is to reorganize these nodes (or pearls and stones) based on their value relative to `x`.\\n\\n# Approach \\uD83D\\uDE80\\nOur \\uD83E\\uDD80 has two baskets - one for pearls (`before`) and another for stones (`after`). It picks items one-by-one (or traverses the list). Depending on the value of the item, it places it in the appropriate basket. Once all items are sorted, it connects the two baskets to have a neat collection.\\n\\n1. \\uD83D\\uDECD\\uFE0F Create two baskets (`before` and `after`).\\n2. \\uD83C\\uDF0A Dive through the ocean floor (or traverse the list).\\n3. \\uD83C\\uDF10 For each find, decide if it\\'s a pearl or a stone and place it in the appropriate basket.\\n4. \\uD83D\\uDD17 Once all items are collected, connect the two baskets.\\n\\n# Complexity \\uD83D\\uDD0D\\n- Time complexity: $$O(n)$$\\n  - Our \\uD83E\\uDD80 dives through the ocean floor once, collecting each item.\\n\\n- Space complexity: $$O(1)$$\\n  - The \\uD83E\\uDD80 uses only two baskets regardless of the number of pearls and stones.\\n\\n# Code \\uD83D\\uDCDC\\n``` Rust []\\nimpl Solution {\\n    pub fn partition(mut head: Option<Box<ListNode>>, x: i32) -> Option<Box<ListNode>> {\\n        // Initialize two dummy nodes for \\'before\\' and \\'after\\' lists.\\n        let mut before = ListNode::new(0);\\n        let mut after = ListNode::new(0);\\n        \\n        // Pointers to the tails of \\'before\\' and \\'after\\' lists to aid in appending nodes.\\n        let mut before_tail = &mut before;\\n        let mut after_tail = &mut after;\\n\\n        // Traverse the original list.\\n        while let Some(mut node) = head {\\n            head = node.next.take();\\n            \\n            // Compare current node\\'s value with x and append to appropriate list.\\n            if node.val < x {\\n                before_tail.next = Some(node);\\n                before_tail = before_tail.next.as_mut().unwrap();\\n            } else {\\n                after_tail.next = Some(node);\\n                after_tail = after_tail.next.as_mut().unwrap();\\n            }\\n        }\\n\\n        // Connect the end of \\'before\\' list to the start of \\'after\\' list.\\n        before_tail.next = after.next.take();\\n\\n        // Return the merged list.\\n        before.next\\n    }\\n}\\n\\n```\\n``` Go []\\nfunc partition(head *ListNode, x int) *ListNode {\\n    // Initialize two dummy nodes for \\'before\\' and \\'after\\' lists.\\n    before := &ListNode{}\\n    after := &ListNode{}\\n    \\n    // Pointers to help in appending nodes to \\'before\\' and \\'after\\' lists.\\n    before_curr := before\\n    after_curr := after\\n    \\n    // Traverse the original list.\\n    for head != nil {\\n        // Compare current node\\'s value with x and append to appropriate list.\\n        if head.Val < x {\\n            before_curr.Next = head\\n            before_curr = before_curr.Next\\n        } else {\\n            after_curr.Next = head\\n            after_curr = after_curr.Next\\n        }\\n        head = head.Next\\n    }\\n    \\n    // Ensure \\'after\\' list\\'s end points to nil.\\n    after_curr.Next = nil\\n    \\n    // Connect the end of \\'before\\' list to the start of \\'after\\' list.\\n    before_curr.Next = after.Next\\n    \\n    // Return the merged list.\\n    return before.Next\\n}\\n```\\n``` Python []\\nclass Solution:\\n    def partition(self, head: Optional[ListNode], x: int) -> Optional[ListNode]:\\n        # Initialize two dummy nodes for \\'before\\' and \\'after\\' lists.\\n        before, after = ListNode(0), ListNode(0)\\n        \\n        # Pointers to help in appending nodes to \\'before\\' and \\'after\\' lists.\\n        before_curr, after_curr = before, after\\n        \\n        # Traverse the original list.\\n        while head:\\n            # Compare current node\\'s value with x and append to appropriate list.\\n            if head.val < x:\\n                before_curr.next, before_curr = head, head\\n            else:\\n                after_curr.next, after_curr = head, head\\n            head = head.next\\n        \\n        # Ensure \\'after\\' list\\'s end points to None.\\n        after_curr.next = None\\n        \\n        # Connect the end of \\'before\\' list to the start of \\'after\\' list.\\n        before_curr.next = after.next\\n        \\n        # Return the merged list.\\n        return before.next\\n```\\n\\n\\n# Motivation \\uD83C\\uDF1F\\nGreat job diving deep into the ocean of algorithms with our Rusty \\uD83E\\uDD80, Pythonic \\uD83D\\uDC0D, and Gopher friends! Each problem you tackle not only sharpens your coding skills but also adds a pearl of wisdom to your collection. Remember, every challenge is a step forward. Keep coding, keep collecting pearls, and let\\'s make the ocean shine brighter! \\uD83C\\uDF0A\\uD83C\\uDF1F\\uD83D\\uDE80",
                "solutionTags": [
                    "Python3",
                    "Go",
                    "Rust",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "``` Rust []\\nimpl Solution {\\n    pub fn partition(mut head: Option<Box<ListNode>>, x: i32) -> Option<Box<ListNode>> {\\n        // Initialize two dummy nodes for \\'before\\' and \\'after\\' lists.\\n        let mut before = ListNode::new(0);\\n        let mut after = ListNode::new(0);\\n        \\n        // Pointers to the tails of \\'before\\' and \\'after\\' lists to aid in appending nodes.\\n        let mut before_tail = &mut before;\\n        let mut after_tail = &mut after;\\n\\n        // Traverse the original list.\\n        while let Some(mut node) = head {\\n            head = node.next.take();\\n            \\n            // Compare current node\\'s value with x and append to appropriate list.\\n            if node.val < x {\\n                before_tail.next = Some(node);\\n                before_tail = before_tail.next.as_mut().unwrap();\\n            } else {\\n                after_tail.next = Some(node);\\n                after_tail = after_tail.next.as_mut().unwrap();\\n            }\\n        }\\n\\n        // Connect the end of \\'before\\' list to the start of \\'after\\' list.\\n        before_tail.next = after.next.take();\\n\\n        // Return the merged list.\\n        before.next\\n    }\\n}\\n\\n```\n``` Go []\\nfunc partition(head *ListNode, x int) *ListNode {\\n    // Initialize two dummy nodes for \\'before\\' and \\'after\\' lists.\\n    before := &ListNode{}\\n    after := &ListNode{}\\n    \\n    // Pointers to help in appending nodes to \\'before\\' and \\'after\\' lists.\\n    before_curr := before\\n    after_curr := after\\n    \\n    // Traverse the original list.\\n    for head != nil {\\n        // Compare current node\\'s value with x and append to appropriate list.\\n        if head.Val < x {\\n            before_curr.Next = head\\n            before_curr = before_curr.Next\\n        } else {\\n            after_curr.Next = head\\n            after_curr = after_curr.Next\\n        }\\n        head = head.Next\\n    }\\n    \\n    // Ensure \\'after\\' list\\'s end points to nil.\\n    after_curr.Next = nil\\n    \\n    // Connect the end of \\'before\\' list to the start of \\'after\\' list.\\n    before_curr.Next = after.Next\\n    \\n    // Return the merged list.\\n    return before.Next\\n}\\n```\n``` Python []\\nclass Solution:\\n    def partition(self, head: Optional[ListNode], x: int) -> Optional[ListNode]:\\n        # Initialize two dummy nodes for \\'before\\' and \\'after\\' lists.\\n        before, after = ListNode(0), ListNode(0)\\n        \\n        # Pointers to help in appending nodes to \\'before\\' and \\'after\\' lists.\\n        before_curr, after_curr = before, after\\n        \\n        # Traverse the original list.\\n        while head:\\n            # Compare current node\\'s value with x and append to appropriate list.\\n            if head.val < x:\\n                before_curr.next, before_curr = head, head\\n            else:\\n                after_curr.next, after_curr = head, head\\n            head = head.next\\n        \\n        # Ensure \\'after\\' list\\'s end points to None.\\n        after_curr.next = None\\n        \\n        # Connect the end of \\'before\\' list to the start of \\'after\\' list.\\n        before_curr.next = after.next\\n        \\n        # Return the merged list.\\n        return before.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2315449,
                "title": "java-easy-solution-using-stack",
                "content": "PLEASE UPVOTE IF YOU LIKE\\n```\\nclass Solution {\\n  public ListNode partition(ListNode head, int x) {\\n        if (head == null)\\n            return head;\\n        Stack<ListNode> stack1 = new Stack<>();\\n        Stack<ListNode> stack2 = new Stack<>();\\n        while (head != null) {\\n            if (head.val < x) {\\n                stack1.push(head);\\n            } else {\\n                stack2.push(head);\\n            }\\n            head = head.next;\\n        }\\n        head = null;\\n        while (!stack2.isEmpty()) {\\n            ListNode pop = stack2.pop();\\n            pop.next = head;\\n            head = pop;\\n        }\\n        while (!stack1.isEmpty()) {\\n            ListNode pop = stack1.pop();\\n            pop.next = head;\\n            head = pop;\\n        }\\n        return head;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n  public ListNode partition(ListNode head, int x) {\\n        if (head == null)\\n            return head;\\n        Stack<ListNode> stack1 = new Stack<>();\\n        Stack<ListNode> stack2 = new Stack<>();\\n        while (head != null) {\\n            if (head.val < x) {\\n                stack1.push(head);\\n            } else {\\n                stack2.push(head);\\n            }\\n            head = head.next;\\n        }\\n        head = null;\\n        while (!stack2.isEmpty()) {\\n            ListNode pop = stack2.pop();\\n            pop.next = head;\\n            head = pop;\\n        }\\n        while (!stack1.isEmpty()) {\\n            ListNode pop = stack1.pop();\\n            pop.next = head;\\n            head = pop;\\n        }\\n        return head;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2315400,
                "title": "c-easy-to-understand-explanined-full-logic-space-o-1",
                "content": "**Approch :-**\\nThe main idea is, Keep track of node that is greater than equal to x, whenever we find a node that has lesser value than x, we shift the value and and increment the pointer.\\nwe have two cases,\\n`->node->val >= x:` In this case, we have to do nothing.\\n`-> node->val < x :` In this case we need replace our value before the nodes that has greater value than x.Our pointer cur represents the node that has greater value than x. So, we initialize a duplicate pointer. and shift the value until dup reaches the temp. At last we update the cur.\\n**Do upvote** if you like the code !!\\n\\n**Code :-**\\n```\\nListNode* partition(ListNode* head, int x) {\\n        if(head == NULL || head->next == NULL) return head;\\n        ListNode* temp = head, *cur = head;\\n        while(temp){\\n            if(temp->val < x){\\n                int value = temp->val;\\n                ListNode* dup = cur;\\n                while(dup){\\n                    int y = dup->val;\\n                    dup->val = value;\\n                    value = y;\\n                    if(dup == temp) break;\\n                    dup=dup->next;\\n                }\\n                cur = cur->next;\\n            }\\n            temp = temp->next;\\n        }\\n        return head;\\n    }\\n```\\n**Do upvote** if you like the code !!",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nListNode* partition(ListNode* head, int x) {\\n        if(head == NULL || head->next == NULL) return head;\\n        ListNode* temp = head, *cur = head;\\n        while(temp){\\n            if(temp->val < x){\\n                int value = temp->val;\\n                ListNode* dup = cur;\\n                while(dup){\\n                    int y = dup->val;\\n                    dup->val = value;\\n                    value = y;\\n                    if(dup == temp) break;\\n                    dup=dup->next;\\n                }\\n                cur = cur->next;\\n            }\\n            temp = temp->next;\\n        }\\n        return head;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3911466,
                "title": "c-two-pointer-day-15",
                "content": "# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode* before = new ListNode(0);\\n        ListNode* after = new ListNode(0);\\n        ListNode* temp_before = before;\\n        ListNode* temp_after = after;\\n        while(head!=NULL){\\n            if(head->val < x){\\n                temp_before->next = head;\\n                temp_before = head;\\n            }\\n            else {\\n                 temp_after->next = head;\\n                temp_after = head;\\n            }\\n            head = head->next;\\n        }\\n        temp_after->next = NULL;\\n        temp_before->next = after->next;\\n        return before->next;\\n    }\\n};\\n```\\n![upvote (2).jpg](https://assets.leetcode.com/users/images/be59d078-846e-4a98-ac54-6e6dfd7f5570_1692075145.9488869.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode* before = new ListNode(0);\\n        ListNode* after = new ListNode(0);\\n        ListNode* temp_before = before;\\n        ListNode* temp_after = after;\\n        while(head!=NULL){\\n            if(head->val < x){\\n                temp_before->next = head;\\n                temp_before = head;\\n            }\\n            else {\\n                 temp_after->next = head;\\n                temp_after = head;\\n            }\\n            head = head->next;\\n        }\\n        temp_after->next = NULL;\\n        temp_before->next = after->next;\\n        return before->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2318027,
                "title": "single-pass-o-n-constant-space-o-1-explained",
                "content": "Idea is to create two seperate linked lists,\\n**1. left : list having values < x** and **2. right : list having values >= x**\\n\\nand at last, just **link both of them** and return that list\\n\\nTime Complexity : **O(n)**\\nSpace Complexity : **O(1)**, because *we are **NOT** creating NEW Nodes*, we are just *borrowing Nodes from input list only* and just rearranging them\\n\\nIf you still have any doubts, please *Ask in Comments* \\uD83D\\uDCAC\\n\\n**PLEASE UPVOTE \\u2B06\\uFE0F\\uD83D\\uDD3C\\nIt Really Motivates :) \\u2728**\\n\\n```\\nListNode* partition(ListNode* head, int x) {\\n\\t// two dummy nodes for creating two different lists\\n\\t// 1. left : has values < x\\n\\t// 2. right : has values >= x\\n\\tListNode* left = new ListNode(), *right = new ListNode();\\n\\n\\t// heads for left and right\\n\\tListNode *newHead = left, *mid = right;\\n\\n\\twhile(head) {\\n\\t\\t// add in left list\\n\\t\\tif(head->val < x) {\\n\\t\\t\\tleft->next = head;\\n\\t\\t\\tleft = left->next;\\n\\t\\t} \\n\\t\\t// add in right list\\n\\t\\telse {\\n\\t\\t\\tright->next = head;\\n\\t\\t\\tright = right->next;\\n\\t\\t}\\n\\t\\t// move ahead\\n\\t\\thead = head->next;\\n\\t}\\n\\n\\t// linking left list with right list\\n\\tleft->next = mid->next;\\n\\tright->next = NULL;\\n\\n\\t// newHead is a dummy node, from it\\'s next our list starts\\n\\treturn newHead->next;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\nListNode* partition(ListNode* head, int x) {\\n\\t// two dummy nodes for creating two different lists\\n\\t// 1. left : has values < x\\n\\t// 2. right : has values >= x\\n\\tListNode* left = new ListNode(), *right = new ListNode();\\n\\n\\t// heads for left and right\\n\\tListNode *newHead = left, *mid = right;\\n\\n\\twhile(head) {\\n\\t\\t// add in left list\\n\\t\\tif(head->val < x) {\\n\\t\\t\\tleft->next = head;\\n\\t\\t\\tleft = left->next;\\n\\t\\t} \\n\\t\\t// add in right list\\n\\t\\telse {\\n\\t\\t\\tright->next = head;\\n\\t\\t\\tright = right->next;\\n\\t\\t}\\n\\t\\t// move ahead\\n\\t\\thead = head->next;\\n\\t}\\n\\n\\t// linking left list with right list\\n\\tleft->next = mid->next;\\n\\tright->next = NULL;\\n\\n\\t// newHead is a dummy node, from it\\'s next our list starts\\n\\treturn newHead->next;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1277292,
                "title": "c-92-faster-easy-to-understand-fast-clean-and-efficient-code",
                "content": "***Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)\\nAny suggestions and improvements are always welcome***\\n```\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode *LH=NULL,*LT=NULL,*RH=NULL,*RT=NULL;\\n        ListNode* A=head;\\n        while(A)\\n        {\\n            if(A->val<x)\\n            {\\n             if(LH==NULL)\\n              {\\n                 LH=A;\\n                 LT=A;\\n              } \\n              else \\n              {\\n                  LT->next=A;\\n                  LT=A;\\n              }   \\n            }\\n            else\\n            {\\n                if(RH==NULL)\\n              {\\n                 RH=A;\\n                 RT=A;\\n              } \\n              else \\n              {\\n                  RT->next=A;\\n                  RT=A;\\n              }  \\n            }\\n           A=A->next;        \\n        }\\n        if(LH==NULL&&RH!=NULL)\\n        {\\n            RT->next=NULL;\\n            return RH;\\n        }\\n        else if(LH!=NULL&&RH==NULL)\\n        {\\n            LT->next=NULL;\\n            return LH;\\n        }\\n        else if(LH&&RH)\\n        {\\n            LT->next=RH;\\n            RT->next=NULL;\\n        }\\n        return LH;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "class Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode *LH=NULL,*LT=NULL,*RH=NULL,*RT=NULL;\\n        ListNode* A=head;\\n        while(A)\\n        {\\n            if(A->val<x)\\n            {\\n             if(LH==NULL)\\n              {\\n                 LH=A;\\n                 LT=A;\\n              }",
                "codeTag": "Java"
            },
            {
                "id": 29375,
                "title": "my-o-n-o-1-solution",
                "content": "I use tail to keep track of the end point where the nodes before it are smaller than x.\\n\\n----------\\n\\n    public ListNode partition(ListNode head, int x) {\\n        ListNode dummy=new ListNode(0);\\n        dummy.next=head;\\n        ListNode p=dummy;\\n        ListNode tail=dummy;\\n        while(p!=null && p.next!=null){\\n            if(p.next.val>=x)\\n                p=p.next;\\n            else{\\n                if(p==tail){  // don't forget the edge cases when p==tail\\n                    tail=tail.next;\\n                    p=p.next;\\n                }\\n                else{\\n                    ListNode tmp=p.next;\\n                    p.next=tmp.next;\\n                    tmp.next=tail.next;\\n                    tail.next=tmp;\\n                    tail=tmp; // don't forget to move tail.\\n                }\\n            }\\n        }\\n        return dummy.next;\\n    }",
                "solutionTags": [],
                "code": "I use tail to keep track of the end point where the nodes before it are smaller than x.\\n\\n----------\\n\\n    public ListNode partition(ListNode head, int x) {\\n        ListNode dummy=new ListNode(0);\\n        dummy.next=head;\\n        ListNode p=dummy;\\n        ListNode tail=dummy;\\n        while(p!=null && p.next!=null){\\n            if(p.next.val>=x)\\n                p=p.next;\\n            else{\\n                if(p==tail){  // don't forget the edge cases when p==tail\\n                    tail=tail.next;\\n                    p=p.next;\\n                }\\n                else{\\n                    ListNode tmp=p.next;\\n                    p.next=tmp.next;\\n                    tmp.next=tail.next;\\n                    tail.next=tmp;\\n                    tail=tmp; // don't forget to move tail.\\n                }\\n            }\\n        }\\n        return dummy.next;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3913152,
                "title": "o-n-time-o-1-space-easy-explained-clean",
                "content": "# Intuition\\nWe must rearrange the nodes such that the nodes smaller than x will come before the nodes greater than or equal to x.\\n\\n# Approach\\nWe will create a dummy node and will start attaching nodes to it whenever we encounter nodes with value smaller than x.\\n\\nWe will also maintain a record of second part of the list as well, which contains the node greater than or equal to x.\\n\\n$$SecondPart$$ will contain the head of the list which will have nodes greater than or equal to x in the original order.\\n\\n$$SecondPartExists$$ is a boolean variable which is set to true as soon as first greater or equal element is attached to make sure cases like List = [1] and x = 3 works fine.\\n\\n# Complexity\\n- Time complexity: Since we only traverse the list once, TC is O(n).\\n\\n- Space complexity: We do not use any extra space to store the nodes except some dummy nodes and ListNode* pointers. So SC is also O(n).\\n\\n# **PLEASE UPVOTE :)\\u2705**\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode* dummyHead = new ListNode();   //To store head of resulting list\\n        ListNode* dummy = dummyHead; //to point to the tail of resulting list\\n        ListNode* prev = NULL, *curr = head; //to point to the nodes in given list\\n        ListNode* secondPart = new ListNode(); //to maintain track of nodes greater than x\\n        bool secondPartExists = false; //to indicate greater and smaller elements exist\\n\\n        while(curr != NULL){\\n            if(curr->val >= x){\\n                if(prev == NULL){\\n                    secondPartExists = true; //found first greater element\\n                    secondPart = curr; \\n                }\\n                prev = curr;\\n                curr = curr->next;\\n            }\\n            else{\\n                dummy->next = curr;\\n                dummy = dummy->next;\\n                if(prev != NULL)prev->next = curr->next;\\n                curr = curr->next;\\n                dummy->next = NULL;\\n            }\\n        }\\n\\n        if(secondPartExists) dummy->next = secondPart;\\n\\n        return dummyHead->next; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode* dummyHead = new ListNode();   //To store head of resulting list\\n        ListNode* dummy = dummyHead; //to point to the tail of resulting list\\n        ListNode* prev = NULL, *curr = head; //to point to the nodes in given list\\n        ListNode* secondPart = new ListNode(); //to maintain track of nodes greater than x\\n        bool secondPartExists = false; //to indicate greater and smaller elements exist\\n\\n        while(curr != NULL){\\n            if(curr->val >= x){\\n                if(prev == NULL){\\n                    secondPartExists = true; //found first greater element\\n                    secondPart = curr; \\n                }\\n                prev = curr;\\n                curr = curr->next;\\n            }\\n            else{\\n                dummy->next = curr;\\n                dummy = dummy->next;\\n                if(prev != NULL)prev->next = curr->next;\\n                curr = curr->next;\\n                dummy->next = NULL;\\n            }\\n        }\\n\\n        if(secondPartExists) dummy->next = secondPart;\\n\\n        return dummyHead->next; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2315157,
                "title": "daily-leetcoding-challenge-july-day-22",
                "content": "This problem is the Daily LeetCoding Challenge for July, Day 22.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/partition-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Two Pointer Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/partition-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 1630355,
                "title": "c-linked-list-to-vector",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        if(!head || !head->next) return head;\\n        \\n        vector<int> nums;\\n        ListNode* temp = head;\\n        while(temp != NULL){\\n            nums.push_back(temp->val);\\n            temp = temp->next;\\n        }\\n        \\n        vector<int> res;\\n        for(int val : nums)\\n            if(val < x)\\n                res.push_back(val);\\n\\n        for(int val : nums)\\n            if(val >= x)\\n                res.push_back(val);\\n        \\n        \\n        temp = head;\\n        int i = 0;\\n        while(temp != NULL){\\n            temp->val = res[i++];\\n            temp = temp->next;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        if(!head || !head->next) return head;\\n        \\n        vector<int> nums;\\n        ListNode* temp = head;\\n        while(temp != NULL){\\n            nums.push_back(temp->val);\\n            temp = temp->next;\\n        }\\n        \\n        vector<int> res;\\n        for(int val : nums)\\n            if(val < x)\\n                res.push_back(val);\\n\\n        for(int val : nums)\\n            if(val >= x)\\n                res.push_back(val);\\n        \\n        \\n        temp = head;\\n        int i = 0;\\n        while(temp != NULL){\\n            temp->val = res[i++];\\n            temp = temp->next;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1492448,
                "title": "rust-0ms-clean",
                "content": "```rust\\npub fn partition(mut head: Option<Box<ListNode>>, x: i32) -> Option<Box<ListNode>> {\\n    let (mut lhead, mut hhead) = (None, None);\\n    let (mut low, mut high) = (&mut lhead, &mut hhead);\\n    while let Some(mut node) = head {\\n        head = node.next.take();\\n        if node.val < x {\\n            *low = Some(node);\\n            low = &mut low.as_deref_mut().unwrap().next;\\n        } else {\\n            *high = Some(node);\\n            high = &mut high.as_deref_mut().unwrap().next;\\n        }\\n    }\\n    *low = hhead;\\n    lhead\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\npub fn partition(mut head: Option<Box<ListNode>>, x: i32) -> Option<Box<ListNode>> {\\n    let (mut lhead, mut hhead) = (None, None);\\n    let (mut low, mut high) = (&mut lhead, &mut hhead);\\n    while let Some(mut node) = head {\\n        head = node.next.take();\\n        if node.val < x {\\n            *low = Some(node);\\n            low = &mut low.as_deref_mut().unwrap().next;\\n        } else {\\n            *high = Some(node);\\n            high = &mut high.as_deref_mut().unwrap().next;\\n        }\\n    }\\n    *low = hhead;\\n    lhead\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 858387,
                "title": "clean-python-100-speed",
                "content": "**Clean Python | 100% Speed**\\n\\n```\\n\\nclass Solution:\\n    def partition(self, head, x):\\n        # h1,h2: Linked Lists with numbers Lower and GEQ (greater or equal) than X respectively\\n        h1, h2 = None, None\\n        # -------------------------------------------------------------------\\n        #     Main Loop (Iterate through Linked List starting at Head)\\n        # -------------------------------------------------------------------\\n        n      = head\\n        while n:\\n            if n.val<x:\\n                if h1:\\n                    n1.next = n\\n                else:\\n                    h1      = n\\n                n1 = n\\n            else:\\n                if h2:\\n                    n2.next = n\\n                else:\\n                    h2      = n\\n                n2 = n\\n            n = n.next\\n        # -------------------------------------------------------------------\\n        #     Fix Tails\\n        # -------------------------------------------------------------------\\n        if h1:\\n            n1.next = h2\\n        if h2:\\n            n2.next = None\\n        # -------------------------------------------------------------------\\n        #     Try to Return Non-Empty Linked List\\n        # -------------------------------------------------------------------\\n        return h1 or h2\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n\\nclass Solution:\\n    def partition(self, head, x):\\n        # h1,h2: Linked Lists with numbers Lower and GEQ (greater or equal) than X respectively\\n        h1, h2 = None, None\\n        # -------------------------------------------------------------------\\n        #     Main Loop (Iterate through Linked List starting at Head)\\n        # -------------------------------------------------------------------\\n        n      = head\\n        while n:\\n            if n.val<x:\\n                if h1:\\n                    n1.next = n\\n                else:\\n                    h1      = n\\n                n1 = n\\n            else:\\n                if h2:\\n                    n2.next = n\\n                else:\\n                    h2      = n\\n                n2 = n\\n            n = n.next\\n        # -------------------------------------------------------------------\\n        #     Fix Tails\\n        # -------------------------------------------------------------------\\n        if h1:\\n            n1.next = h2\\n        if h2:\\n            n2.next = None\\n        # -------------------------------------------------------------------\\n        #     Try to Return Non-Empty Linked List\\n        # -------------------------------------------------------------------\\n        return h1 or h2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 349660,
                "title": "simple-recursive-solution-runtime-and-memory-both-100-with-detailed-explanations",
                "content": "First of all, when using recursion, the function callback loop is effectively the first pointer. And the direction to which this pointer moves is determined by how each function call was made. In the simplest case, if ```head``` was passed in, ```head.next``` is passed in the function call within the current function. Therefore the recursion pointer moves from the end of the linked list to where the very first function call was made.\\n\\nThe tricky part is what to use as the second pointer and how to use it. Either the start of the linked list, the \"head\", (stored by making an assignment outside of the recursion function), or the end of the linked list, the \"tail\", (stored when recursion pointer begins to move), can be used as the second pointer. There are also two operations we can do at this pointer: either repeatedly append the node after the pointer, or repeatedly insert the node before the pointer. Appending keeps the order of nodes and inserting reverse the order of nodes. But since the recursion pointer is moving in reverse, in order to keep the order of the original nodes, we have to use inserting to reverse back.\\nNow at this point, it would appear that both inserting at the head and inserting at the tail would work. But it turns out inserting at the tail is actually easier, at least as far as I\\'m concerned. The reason would become apparent after I lay out my implementation.\\n\\nFirst, we need to trigger the cascading function call backs. This  can be simply done by the recursion function return a value other than the function itself, which naturally is the first line. Next, we need to figure out what needs to be done whenever we encounter a node with val >= x. Sine singly-linked list knows only what\\'s next, inserting a node can only be done by inserting it after a certain node. Since we are inserting the node with val >=x BEFORE the tail to perserve the original order, what we actually store is not the tail itself, but the node right before the tail, call it ```before_tail```. \\nNow inserting the node (call it ```node```) requires two steps: 1. Connect ```node``` to ```before_tail```, by a) ```node.next=before_tail.next```, and b) ```before_tail.next=node```. 2. Sewing back the link from which we took ```node```, by... well, actually we can\\'t do this within the function call because we don\\'t know what\\'s before ```node``` since only ```node``` was passed in, not the previous node. Therefore, this last step has to be done by the function call directly above and this is why the resursion call is ```head.next=partition(head.next, x)```, which reconnect the severed link. \\nNow setting up the tail is not so simple either. We could just store it the first time we encounter the actual tail. But remember what we need to store is ```before_tail```, not tail itself. However, if the tail has val<2, we don\\'t want node with val>=x inserted before it, we want it inserted after it. So in this case, ```null``` is actually new tail and we store the old tail as ```before_tail```. Otherwise, we need to wait one more function call. The good thing though, is that if a lot of nodes adjacent to the tail has val>=x, we don\\'t need to do anything but wait one more function call.\\n\\nNow why was inserting at the head difficult to implement? At least from my few attempts at implementing such algorithm, it seems the problem was that we can\\'t just wrap an additional function call above the initial one. Now hear me out here, it\\'s actually not that complicated. Remember the last step in inserting a node is sewing back the severed link? If the last recursion call (the one you pass in the original head in as the node) returns with the node that needs to be sewed back on, we can\\'t do this unless we store the node that comes before the original head, which should be the first node that was ever inserted. This means storing two nodes at the same time now. You can of course have the operations done on the node after the node in the resursive function, but that creates much more problem than solved. Trust me, I went down that rabbit whole and it was ugly.\\n\\nI hope this has been helpful.\\n\\n\\n```\\nclass Solution{\\n    ListNode before_tail=null;\\n    public ListNode partition(ListNode head, int x){\\n        if (head == null) return null;\\n        head.next = partition(head.next, x);\\n        if (before_tail == null) {\\n            if (head.val < x) before_tail = head;\\n            return head;\\n        }\\n        else{\\n            if (head.val >= x) {\\n                ListNode next = head.next;\\n                head.next = before_tail.next;\\n                before_tail.next = head;\\n                return next;\\n            }\\n            else return head;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```head```\n```head.next```\n```before_tail```\n```node```\n```node```\n```before_tail```\n```node.next=before_tail.next```\n```before_tail.next=node```\n```node```\n```node```\n```node```\n```head.next=partition(head.next, x)```\n```before_tail```\n```null```\n```before_tail```\n```\\nclass Solution{\\n    ListNode before_tail=null;\\n    public ListNode partition(ListNode head, int x){\\n        if (head == null) return null;\\n        head.next = partition(head.next, x);\\n        if (before_tail == null) {\\n            if (head.val < x) before_tail = head;\\n            return head;\\n        }\\n        else{\\n            if (head.val >= x) {\\n                ListNode next = head.next;\\n                head.next = before_tail.next;\\n                before_tail.next = head;\\n                return next;\\n            }\\n            else return head;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3911476,
                "title": "easy-solution-by-using-2-linked-list-time-complexity-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nsince the relative order should remain same, we need to store elements seperately - element<x &element>=x.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwe required 2 linked list  to store elements seperate.\\niterate the given linked list -\\nleftTail stores element<x.\\nrightTail stores element>=x.\\nIn the end merge the 2 linked list.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code-JAVA\\n```\\nclass Solution {\\n    public ListNode partition(ListNode head, int x) {\\n        ListNode left= new ListNode(0);\\n        ListNode right = new ListNode(0);\\n\\n        ListNode leftTail = left;\\n        ListNode rightTail = right;\\n\\n        while(head!=null){\\n            if(head.val<x){\\n                leftTail.next = head;\\n                leftTail = leftTail.next;\\n            }\\n            else{\\n                rightTail.next = head;\\n                rightTail = rightTail.next;\\n            }\\n            head=head.next;\\n        }\\n        leftTail.next = right.next;\\n        rightTail.next = null;\\n        return left.next;\\n    }\\n}\\n```\\n\\n# Code-CPP\\n```\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode *left = new ListNode(0);\\n        ListNode *right = new ListNode(0);\\n        \\n        ListNode *leftTail = left;\\n        ListNode *rightTail = right;\\n        \\n        while(head != NULL){\\n            if(head->val < x){\\n                leftTail->next = head;\\n                leftTail = leftTail->next;\\n            }\\n            else{\\n                rightTail->next = head;\\n                rightTail = rightTail->next;\\n            }\\n            head = head->next;\\n        }\\n        \\n        leftTail->next = right->next;\\n        rightTail->next = NULL;\\n        \\n        return left->next;\\n    }\\n};\\n```\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode partition(ListNode head, int x) {\\n        ListNode left= new ListNode(0);\\n        ListNode right = new ListNode(0);\\n\\n        ListNode leftTail = left;\\n        ListNode rightTail = right;\\n\\n        while(head!=null){\\n            if(head.val<x){\\n                leftTail.next = head;\\n                leftTail = leftTail.next;\\n            }\\n            else{\\n                rightTail.next = head;\\n                rightTail = rightTail.next;\\n            }\\n            head=head.next;\\n        }\\n        leftTail.next = right.next;\\n        rightTail.next = null;\\n        return left.next;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode *left = new ListNode(0);\\n        ListNode *right = new ListNode(0);\\n        \\n        ListNode *leftTail = left;\\n        ListNode *rightTail = right;\\n        \\n        while(head != NULL){\\n            if(head->val < x){\\n                leftTail->next = head;\\n                leftTail = leftTail->next;\\n            }\\n            else{\\n                rightTail->next = head;\\n                rightTail = rightTail->next;\\n            }\\n            head = head->next;\\n        }\\n        \\n        leftTail->next = right->next;\\n        rightTail->next = NULL;\\n        \\n        return left->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2316099,
                "title": "beginner-friendly-o-n-two-pointer",
                "content": "Idea is to separate the list into two lists: One of smaller node values (`before` as head) and other for greater than and equal values (`after` as head). And then merge them like this `before` -> `after`\\n\\nTo complete the process in just single traversal, keep track of last node of each of two separated lists, denoted by i(for list with smaller values) and j(for list with greater values).\\n\\n```\\nclass Solution {\\n    \\n    ListNode before, after, i, j;\\n    \\n    public ListNode partition(ListNode head, int x) {\\n        \\n        if(head == null) return head;\\n        ListNode temp = head;\\n        \\n        // Traversing all the nodes to make two separate lists\\n        while(temp != null){\\n            addNode(temp.val, temp.val < x);\\n            temp = temp.next;\\n        }\\n        \\n        // Case if the list with smaller values has no items\\n        if(i == null) return after;\\n        \\n        // Else merge the lists\\n        else i.next = after;\\n        \\n        return before;\\n    }\\n    \\n    private void addNode(int val, boolean isLess){\\n        \\n        // Add node in smaller list (`before`)\\n        if(isLess){\\n            \\n            // Initialize the head of smaller list\\n            if(before == null){\\n                before = new ListNode(val);\\n                i = before;\\n            }\\n            \\n            // Add node at the end of list and move pointer `i` to the last node\\n            else{\\n                i.next = new ListNode(val);\\n                i = i.next;\\n            }\\n        }\\n        \\n        // Add node in greater list (`after`)\\n        else{\\n            \\n            // Initialize the head of greater list\\n            if(after == null){\\n                after = new ListNode(val);\\n                j = after;\\n            }\\n            \\n            // Add node at the end of list and move pointer `j` to the last node\\n            else{\\n                j.next = new ListNode(val);\\n                j = j.next;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    ListNode before, after, i, j;\\n    \\n    public ListNode partition(ListNode head, int x) {\\n        \\n        if(head == null) return head;\\n        ListNode temp = head;\\n        \\n        // Traversing all the nodes to make two separate lists\\n        while(temp != null){\\n            addNode(temp.val, temp.val < x);\\n            temp = temp.next;\\n        }\\n        \\n        // Case if the list with smaller values has no items\\n        if(i == null) return after;\\n        \\n        // Else merge the lists\\n        else i.next = after;\\n        \\n        return before;\\n    }\\n    \\n    private void addNode(int val, boolean isLess){\\n        \\n        // Add node in smaller list (`before`)\\n        if(isLess){\\n            \\n            // Initialize the head of smaller list\\n            if(before == null){\\n                before = new ListNode(val);\\n                i = before;\\n            }\\n            \\n            // Add node at the end of list and move pointer `i` to the last node\\n            else{\\n                i.next = new ListNode(val);\\n                i = i.next;\\n            }\\n        }\\n        \\n        // Add node in greater list (`after`)\\n        else{\\n            \\n            // Initialize the head of greater list\\n            if(after == null){\\n                after = new ListNode(val);\\n                j = after;\\n            }\\n            \\n            // Add node at the end of list and move pointer `j` to the last node\\n            else{\\n                j.next = new ListNode(val);\\n                j = j.next;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2204259,
                "title": "solution-in-c-with-explanation",
                "content": "Idea is very simple. Just make two linked list. Add all elements less than x in less linked list and add all elements higher or equal to x in high linked list. At the end, join the less linked list last element with first element of high linked list.\\n\\n**Code**\\n```\\nstruct ListNode* partition(struct ListNode* head, int x){\\n    struct ListNode* less = (struct ListNode*)malloc(sizeof(struct ListNode));\\n    less->val = 0;\\n    less->next = NULL;\\n    \\n    struct ListNode* high = (struct ListNode*)malloc(sizeof(struct ListNode));\\n    high->val = 0;\\n    high->next = NULL;\\n    \\n    struct ListNode* lessT = less;\\n    struct ListNode* highT = high;\\n    \\n    while(head){\\n        if(head->val < x){\\n            lessT->next = head;\\n            lessT = lessT->next;\\n        }\\n        else{\\n            highT->next = head;\\n            highT = highT->next;\\n        }\\n        head = head->next;\\n    }\\n    lessT->next = high->next;\\n    highT->next = NULL;\\n    \\n    \\n    return less->next;\\n}\\n```\\n**Please upvote if you found the solution helpful**\\n*Feel free to ask any questions in the comment section*",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nstruct ListNode* partition(struct ListNode* head, int x){\\n    struct ListNode* less = (struct ListNode*)malloc(sizeof(struct ListNode));\\n    less->val = 0;\\n    less->next = NULL;\\n    \\n    struct ListNode* high = (struct ListNode*)malloc(sizeof(struct ListNode));\\n    high->val = 0;\\n    high->next = NULL;\\n    \\n    struct ListNode* lessT = less;\\n    struct ListNode* highT = high;\\n    \\n    while(head){\\n        if(head->val < x){\\n            lessT->next = head;\\n            lessT = lessT->next;\\n        }\\n        else{\\n            highT->next = head;\\n            highT = highT->next;\\n        }\\n        head = head->next;\\n    }\\n    lessT->next = high->next;\\n    highT->next = NULL;\\n    \\n    \\n    return less->next;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1352614,
                "title": "java-one-pass-beats-100-clear-code",
                "content": "Hopefully u will find it useful!\\n```\\nclass Solution {\\n    public ListNode partition(ListNode head, int x) {\\n        ListNode less = new ListNode(0), lessCurr = less;\\n        ListNode greater = new ListNode(0), greaterCurr = greater;\\n        while (head != null) {\\n            if (head.val < x) {\\n                lessCurr.next = new ListNode(head.val);\\n                lessCurr = lessCurr.next;\\n            } else {\\n                greaterCurr.next = new ListNode(head.val);\\n                greaterCurr = greaterCurr.next;\\n            }\\n            head = head.next;\\n        }\\n        lessCurr.next = greater.next;\\n        return less.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode partition(ListNode head, int x) {\\n        ListNode less = new ListNode(0), lessCurr = less;\\n        ListNode greater = new ListNode(0), greaterCurr = greater;\\n        while (head != null) {\\n            if (head.val < x) {\\n                lessCurr.next = new ListNode(head.val);\\n                lessCurr = lessCurr.next;\\n            } else {\\n                greaterCurr.next = new ListNode(head.val);\\n                greaterCurr = greaterCurr.next;\\n            }\\n            head = head.next;\\n        }\\n        lessCurr.next = greater.next;\\n        return less.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1351273,
                "title": "intuitive-python-approach",
                "content": "Most of LinkedList problems can be solved easily using extra space.\\n\\nIt is intuitive to maintain two partitions(lists): one for nodes less than x, the other for nodes greater than or equal to x.\\n\\nTo save `None` checks, we create dummy nodes in front of the two partitions\\' heads: `dummy_smaller`, `dummy_larger`.\\n\\nIterating over the original list can preserve original relative order in each of the two partitions.\\n\\nNote that end nodes of two partitions should be processed at last.\\n```\\n        larger_cur.next = None\\n        smaller_cur.next = dummy_larger.next\\n```\\n\\n```\\nclass Solution:\\n    def partition(self, head: ListNode, x: int) -> ListNode:\\n        dummy_smaller = smaller_cur = ListNode(0)\\n        dummy_larger = larger_cur = ListNode(0)\\n        cur = head\\n        while cur:\\n            if cur.val < x:\\n                smaller_cur.next = cur\\n                smaller_cur = smaller_cur.next\\n            else:\\n                larger_cur.next = cur\\n                larger_cur = larger_cur.next\\n            cur = cur.next\\n        larger_cur.next = None\\n        smaller_cur.next = dummy_larger.next\\n        return dummy_smaller.next\\n\\n```",
                "solutionTags": [],
                "code": "```\\n        larger_cur.next = None\\n        smaller_cur.next = dummy_larger.next\\n```\n```\\nclass Solution:\\n    def partition(self, head: ListNode, x: int) -> ListNode:\\n        dummy_smaller = smaller_cur = ListNode(0)\\n        dummy_larger = larger_cur = ListNode(0)\\n        cur = head\\n        while cur:\\n            if cur.val < x:\\n                smaller_cur.next = cur\\n                smaller_cur = smaller_cur.next\\n            else:\\n                larger_cur.next = cur\\n                larger_cur = larger_cur.next\\n            cur = cur.next\\n        larger_cur.next = None\\n        smaller_cur.next = dummy_larger.next\\n        return dummy_smaller.next\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 29210,
                "title": "clean-c-6ms-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode left(0);\\n        ListNode right(0);\\n        ListNode* l = &left;\\n        ListNode* r = &right;\\n        ListNode* cur = head;\\n        while(cur){\\n            if(cur->val < x){\\n                l->next = cur;\\n                l = l->next;\\n            }\\n            else{\\n                r->next = cur;\\n                r = r->next;\\n            }\\n            cur = cur->next;\\n        }\\n        r->next = NULL;\\n        l->next = right.next;\\n        return left.next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode left(0);\\n        ListNode right(0);\\n        ListNode* l = &left;\\n        ListNode* r = &right;\\n        ListNode* cur = head;\\n        while(cur){\\n            if(cur->val < x){\\n                l->next = cur;\\n                l = l->next;\\n            }\\n            else{\\n                r->next = cur;\\n                r = r->next;\\n            }\\n            cur = cur->next;\\n        }\\n        r->next = NULL;\\n        l->next = right.next;\\n        return left.next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 29272,
                "title": "my-ac-java-code",
                "content": "public ListNode partition(ListNode head, int x) {\\n\\t\\t\\n\\t\\tListNode firstHead = new ListNode(0);\\n\\t\\tfirstHead.next = head;\\n\\t\\tListNode secondHead = new ListNode(x);\\n\\t\\n\\t\\t\\n\\t\\tListNode first = firstHead;\\n\\t\\tListNode second = secondHead;\\n\\t\\tListNode curNode = head;\\n\\t\\twhile(curNode!=null){\\n\\t\\t\\tListNode tmp = curNode.next;\\n\\t\\t\\tif(curNode.val<x){\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tfirst.next = curNode;\\n\\t\\t\\t\\tfirst = curNode; \\n\\t\\t\\t}else{\\n\\t\\t\\t\\tsecond.next = curNode;\\n\\t\\t\\t\\tsecond = curNode;\\n\\t\\t\\t\\tsecond.next = null;// important\\n\\t\\t\\t}\\n\\t\\t\\tcurNode = tmp;\\n\\t\\t}\\n\\t\\tfirst.next = secondHead.next;\\n\\t\\treturn firstHead.next;\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "public ListNode partition(ListNode head, int x) {\\n\\t\\t\\n\\t\\tListNode firstHead = new ListNode(0);\\n\\t\\tfirstHead.next = head;\\n\\t\\tListNode secondHead = new ListNode(x);\\n\\t\\n\\t\\t\\n\\t\\tListNode first = firstHead;\\n\\t\\tListNode second = secondHead;\\n\\t\\tListNode curNode = head;\\n\\t\\twhile(curNode!=null){\\n\\t\\t\\tListNode tmp = curNode.next;\\n\\t\\t\\tif(curNode.val<x){\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tfirst.next = curNode;\\n\\t\\t\\t\\tfirst = curNode; \\n\\t\\t\\t}else{\\n\\t\\t\\t\\tsecond.next = curNode;\\n\\t\\t\\t\\tsecond = curNode;\\n\\t\\t\\t\\tsecond.next = null;// important\\n\\t\\t\\t}\\n\\t\\t\\tcurNode = tmp;\\n\\t\\t}\\n\\t\\tfirst.next = secondHead.next;\\n\\t\\treturn firstHead.next;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 29325,
                "title": "share-my-solution-10ms-in-c",
                "content": "\\n\\n    class Solution {\\n    public:\\n        ListNode *partition(ListNode *head, int x) {\\n            ListNode *newHead = new ListNode(0);\\n            newHead->next = head;\\n            ListNode *p1 = newHead;\\n            while (p1->next) {    \\n                if((p1->next->val)<x)\\n                    p1 = p1->next;   //find the beginning\\n                else\\n                    break;\\n            }\\n            ListNode *p2 = p1;\\n            \\n            ListNode *nextOne;\\n            while (p2->next) {\\n                nextOne = p2->next;\\n                if (nextOne->val<x){\\n                    p2->next = nextOne->next;\\n                    nextOne->next = p1->next;\\n                    p1->next = nextOne;\\n                    p1 = p1->next;\\n                }else{\\n                    p2 = p2->next;\\n                }\\n            }\\n            return newHead->next;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        ListNode *partition(ListNode *head, int x) {\\n            ListNode *newHead = new ListNode(0);\\n            newHead->next = head;\\n            ListNode *p1 = newHead;\\n            while (p1->next) {    \\n                if((p1->next->val)<x)\\n                    p1 = p1->next;   //find the beginning\\n                else\\n                    break;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3949649,
                "title": "best-o-n-solution",
                "content": "# Approach\\nTwo Pointer\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode* dummy1 = new ListNode();\\n        ListNode* temp1 = dummy1;\\n        ListNode* dummy2 = new ListNode();\\n        ListNode* temp2 = dummy2;\\n        while (head != NULL) {\\n            if (head->val < x) {\\n                temp1->next = head;\\n                temp1 = temp1->next;\\n            } else {\\n                temp2->next = head;\\n                temp2 = temp2->next;\\n            }\\n            head = head->next;\\n        }\\n        if (dummy1->next == NULL)\\n            return dummy2->next;\\n        temp1->next = dummy2->next;\\n        temp2->next = NULL;\\n        return dummy1->next;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode* dummy1 = new ListNode();\\n        ListNode* temp1 = dummy1;\\n        ListNode* dummy2 = new ListNode();\\n        ListNode* temp2 = dummy2;\\n        while (head != NULL) {\\n            if (head->val < x) {\\n                temp1->next = head;\\n                temp1 = temp1->next;\\n            } else {\\n                temp2->next = head;\\n                temp2 = temp2->next;\\n            }\\n            head = head->next;\\n        }\\n        if (dummy1->next == NULL)\\n            return dummy2->next;\\n        temp1->next = dummy2->next;\\n        temp2->next = NULL;\\n        return dummy1->next;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3911684,
                "title": "86-partition-list-c-rust",
                "content": "# Intuition\\nSuppose we have the following linked list:\\n```\\n1 -> 4 -> 3 -> 2 -> 5 -> 2\\n```\\nAnd `x = 3`.\\n\\nWe\\'ll walk through the code step by step:\\n\\n1. Initialize two dummy nodes `d1` and `d2`:\\n   ```\\n   d1: [0]->nullptr\\n   d2: [0]->nullptr\\n   ```\\n\\n2. Initialize `n1` and `n2` pointers to point to the dummy nodes `d1` and `d2`.\\n\\n3. Loop starts:\\n   - Current node: 1\\n     Since 1 < 3, append to the linked list represented by `d1`. Update `n1` to point to 1.\\n     ```\\n     d1: [0]->[1]->nullptr\\n     d2: [0]->nullptr\\n     ```\\n   - Current node: 4\\n     Since 4 >= 3, append to the linked list represented by `d2`. Update `n2` to point to 4.\\n     ```\\n     d1: [0]->[1]->nullptr\\n     d2: [0]->[4]->nullptr\\n     ```\\n   - Current node: 3\\n     Since 3 >= 3, append to the linked list represented by `d2`. Update `n2` to point to 3.\\n     ```\\n     d1: [0]->[1]->nullptr\\n     d2: [0]->[4]->[3]->nullptr\\n     ```\\n   - Current node: 2\\n     Since 2 < 3, append to the linked list represented by `d1`. Update `n1` to point to 2.\\n     ```\\n     d1: [0]->[1]->[2]->nullptr\\n     d2: [0]->[4]->[3]->nullptr\\n     ```\\n   - Current node: 5\\n     Since 5 >= 3, append to the linked list represented by `d2`. Update `n2` to point to 5.\\n     ```\\n     d1: [0]->[1]->[2]->nullptr\\n     d2: [0]->[4]->[3]->[5]->nullptr\\n     ```\\n   - Current node: 2\\n     Since 2 < 3, append to the linked list represented by `d1`. Update `n1` to point to 2.\\n     ```\\n     d1: [0]->[1]->[2]->[2]->nullptr\\n     d2: [0]->[4]->[3]->[5]->nullptr\\n     ```\\n\\n4. The loop ends. Set `n2->next` and `n1->next` to `nullptr` to terminate the partitioned linked lists.\\n   ```\\n   d1: [0]->[1]->[2]->[2]->nullptr\\n   d2: [0]->[4]->[3]->[5]->nullptr\\n   ```\\n\\n5. Connect the partitioned linked lists: Update the `next` pointer of the last node in the linked list represented by `d1` (`n1`) to point to the first node in the linked list represented by `d2` (`d2->next`).\\n   ```\\n   d1: [0]->[1]->[2]->[2]->[4]->[3]->[5]->nullptr\\n   d2: [0]->[4]->[3]->[5]->nullptr\\n   ```\\n\\n6. Return `d1->next`, which points to the head of the partitioned linked list:\\n   ```\\n   1 -> 2 -> 2 -> 4 -> 3 -> 5\\n   ```\\n\\nSo, the final partitioned linked list is `1 -> 2 -> 2 -> 4 -> 3 -> 5`, where nodes with values less than 3 come before nodes with values greater than or equal to 3.\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode *d1 = new ListNode(0), *d2 = new ListNode(0), *n1, *n2;\\n        n1 = d1;\\n        n2=d2;\\n        while(head!=NULL){\\n            if(head->val < x){\\n                n1->next=head;\\n                n1=n1->next;\\n            } else{\\n                n2->next=head;\\n                n2=n2->next;\\n            }\\n            head=head->next;\\n        }\\n\\n        n2->next=NULL;\\n        n1->next=d2->next;\\n        return d1->next;\\n\\n    }\\n};\\n\\n```\\n\\n```\\n// Definition for singly-linked list.\\n// #[derive(PartialEq, Eq, Clone, Debug)]\\n// pub struct ListNode {\\n//   pub val: i32,\\n//   pub next: Option<Box<ListNode>>\\n// }\\n// \\n// impl ListNode {\\n//   #[inline]\\n//   fn new(val: i32) -> Self {\\n//     ListNode {\\n//       next: None,\\n//       val\\n//     }\\n//   }\\n// }\\nimpl Solution {\\n    pub fn partition(head: Option<Box<ListNode>>, x: i32) -> Option<Box<ListNode>> {\\n        let mut less_dummy =ListNode::new(0);\\n        let mut greater_or_equal_dummy = ListNode::new(0);\\n        let mut less_tail = &mut less_dummy;\\n        let mut greater_or_equal_tail = &mut greater_or_equal_dummy;\\n        let mut current = head;\\n\\n\\n        while let Some(mut node) = current.take() {\\n            current = node.next.take();\\n            if node.val < x {\\n                less_tail.next = Some(node);\\n                less_tail = less_tail.next.as_mut().unwrap();\\n            } else {\\n                greater_or_equal_tail.next = Some(node);\\n                greater_or_equal_tail = greater_or_equal_tail.next.as_mut().unwrap();\\n            }\\n        }\\n\\n        greater_or_equal_tail.next = None;\\n        less_tail.next = greater_or_equal_dummy.next;\\n        less_dummy.next\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Rust"
                ],
                "code": "```\\n1 -> 4 -> 3 -> 2 -> 5 -> 2\\n```\n```\\n   d1: [0]->nullptr\\n   d2: [0]->nullptr\\n   ```\n```\\n     d1: [0]->[1]->nullptr\\n     d2: [0]->nullptr\\n     ```\n```\\n     d1: [0]->[1]->nullptr\\n     d2: [0]->[4]->nullptr\\n     ```\n```\\n     d1: [0]->[1]->nullptr\\n     d2: [0]->[4]->[3]->nullptr\\n     ```\n```\\n     d1: [0]->[1]->[2]->nullptr\\n     d2: [0]->[4]->[3]->nullptr\\n     ```\n```\\n     d1: [0]->[1]->[2]->nullptr\\n     d2: [0]->[4]->[3]->[5]->nullptr\\n     ```\n```\\n     d1: [0]->[1]->[2]->[2]->nullptr\\n     d2: [0]->[4]->[3]->[5]->nullptr\\n     ```\n```\\n   d1: [0]->[1]->[2]->[2]->nullptr\\n   d2: [0]->[4]->[3]->[5]->nullptr\\n   ```\n```\\n   d1: [0]->[1]->[2]->[2]->[4]->[3]->[5]->nullptr\\n   d2: [0]->[4]->[3]->[5]->nullptr\\n   ```\n```\\n   1 -> 2 -> 2 -> 4 -> 3 -> 5\\n   ```\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode *d1 = new ListNode(0), *d2 = new ListNode(0), *n1, *n2;\\n        n1 = d1;\\n        n2=d2;\\n        while(head!=NULL){\\n            if(head->val < x){\\n                n1->next=head;\\n                n1=n1->next;\\n            } else{\\n                n2->next=head;\\n                n2=n2->next;\\n            }\\n            head=head->next;\\n        }\\n\\n        n2->next=NULL;\\n        n1->next=d2->next;\\n        return d1->next;\\n\\n    }\\n};\\n\\n```\n```\\n// Definition for singly-linked list.\\n// #[derive(PartialEq, Eq, Clone, Debug)]\\n// pub struct ListNode {\\n//   pub val: i32,\\n//   pub next: Option<Box<ListNode>>\\n// }\\n// \\n// impl ListNode {\\n//   #[inline]\\n//   fn new(val: i32) -> Self {\\n//     ListNode {\\n//       next: None,\\n//       val\\n//     }\\n//   }\\n// }\\nimpl Solution {\\n    pub fn partition(head: Option<Box<ListNode>>, x: i32) -> Option<Box<ListNode>> {\\n        let mut less_dummy =ListNode::new(0);\\n        let mut greater_or_equal_dummy = ListNode::new(0);\\n        let mut less_tail = &mut less_dummy;\\n        let mut greater_or_equal_tail = &mut greater_or_equal_dummy;\\n        let mut current = head;\\n\\n\\n        while let Some(mut node) = current.take() {\\n            current = node.next.take();\\n            if node.val < x {\\n                less_tail.next = Some(node);\\n                less_tail = less_tail.next.as_mut().unwrap();\\n            } else {\\n                greater_or_equal_tail.next = Some(node);\\n                greater_or_equal_tail = greater_or_equal_tail.next.as_mut().unwrap();\\n            }\\n        }\\n\\n        greater_or_equal_tail.next = None;\\n        less_tail.next = greater_or_equal_dummy.next;\\n        less_dummy.next\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3911210,
                "title": "c-easy-solution",
                "content": "# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    ListNode* partition(ListNode* head, int x) {\\n        \\n        ListNode* small = new ListNode(-1);\\n        ListNode* large = new ListNode(-1);\\n        ListNode* small_head = small;\\n        ListNode* large_head = large;\\n        \\n        while (head){\\n            if (head->val < x){\\n                small->next = head;\\n                small = small -> next;\\n                head = head -> next;\\n                small->next = NULL;\\n            }\\n            else{\\n                large->next = head;\\n                large = large -> next;\\n                head = head -> next;\\n                large -> next = NULL;\\n            }\\n        }\\n        small -> next = large_head -> next;\\n\\n        return small_head -> next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    ListNode* partition(ListNode* head, int x) {\\n        \\n        ListNode* small = new ListNode(-1);\\n        ListNode* large = new ListNode(-1);\\n        ListNode* small_head = small;\\n        ListNode* large_head = large;\\n        \\n        while (head){\\n            if (head->val < x){\\n                small->next = head;\\n                small = small -> next;\\n                head = head -> next;\\n                small->next = NULL;\\n            }\\n            else{\\n                large->next = head;\\n                large = large -> next;\\n                head = head -> next;\\n                large -> next = NULL;\\n            }\\n        }\\n        small -> next = large_head -> next;\\n\\n        return small_head -> next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2953901,
                "title": "c-97-runtime-explained-using-queue-and-two-pointers",
                "content": "# Easy and Optimised Approach\\n\\n    Runtime - 97%\\uD83D\\uDD25 \\n\\n# Approach\\n1. Firstly we will point lar the first node whose value >= x.\\n2. Now we will store the node whose value < x in queue.\\n3. Then we will take out all the nodes stored in queue.\\n4. Then we will connect the last node in queue to the lar.\\n5. If there are no nodes in queue then we will return head.\\n\\n#  If you like the solution and understand it then Please Upvote.\\u2B06\\uFE0F\\u2764\\uFE0F \\n\\t* PEACE OUT LUV\\u270C\\uFE0F*\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        if(head == NULL || head ->next == NULL){\\n            return head;\\n        }\\n        queue<ListNode*>q;\\n        ListNode* lar = head;\\n        while(lar != NULL){\\n            if(lar ->val >= x){\\n                break;\\n            }\\n            lar = lar ->next;\\n        }\\n        ListNode* temp = head;\\n        ListNode* prev = head;\\n        ListNode* back = NULL;\\n        while(temp != NULL){\\n            temp = temp ->next;\\n            if(prev ->val >=x){\\n                back = prev;\\n            }\\n            if(prev ->val <x){\\n                prev ->next = NULL;\\n                if(back != NULL){\\n                    back ->next = temp;\\n                }\\n                q.push(prev);\\n            }\\n            prev = temp;\\n        }\\n        ListNode* temp1 = NULL;\\n        if(q.empty()==false){\\n            ListNode* l = q.front();\\n            temp1 = l;\\n            q.pop();\\n            while(!q.empty()){\\n                l ->next = q.front();\\n                q.pop();\\n                l = l ->next;\\n            }\\n            if(l != NULL){\\n                l ->next = lar;\\n            }\\n            return temp1;\\n        }\\n        return head;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        if(head == NULL || head ->next == NULL){\\n            return head;\\n        }\\n        queue<ListNode*>q;\\n        ListNode* lar = head;\\n        while(lar != NULL){\\n            if(lar ->val >= x){\\n                break;\\n            }\\n            lar = lar ->next;\\n        }\\n        ListNode* temp = head;\\n        ListNode* prev = head;\\n        ListNode* back = NULL;\\n        while(temp != NULL){\\n            temp = temp ->next;\\n            if(prev ->val >=x){\\n                back = prev;\\n            }\\n            if(prev ->val <x){\\n                prev ->next = NULL;\\n                if(back != NULL){\\n                    back ->next = temp;\\n                }\\n                q.push(prev);\\n            }\\n            prev = temp;\\n        }\\n        ListNode* temp1 = NULL;\\n        if(q.empty()==false){\\n            ListNode* l = q.front();\\n            temp1 = l;\\n            q.pop();\\n            while(!q.empty()){\\n                l ->next = q.front();\\n                q.pop();\\n                l = l ->next;\\n            }\\n            if(l != NULL){\\n                l ->next = lar;\\n            }\\n            return temp1;\\n        }\\n        return head;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2319240,
                "title": "easy-small-python-solution",
                "content": "Easy small solution\\n\\n```python\\nclass Solution:\\n  def partition(self, head: Optional[ListNode], x: int) -> Optional[ListNode]:\\n    small_head = small = ListNode(-1)\\n    large_head = large = ListNode(-1)\\n\\n    while head:\\n      if head.val < x:\\n        small.next = head\\n        small = small.next\\n      else:\\n        large.next = head \\n        large = large.next\\n      head = head.next\\n    \\n    large.next = None\\n    small.next = large_head.next\\n    return small_head.next\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n  def partition(self, head: Optional[ListNode], x: int) -> Optional[ListNode]:\\n    small_head = small = ListNode(-1)\\n    large_head = large = ListNode(-1)\\n\\n    while head:\\n      if head.val < x:\\n        small.next = head\\n        small = small.next\\n      else:\\n        large.next = head \\n        large = large.next\\n      head = head.next\\n    \\n    large.next = None\\n    small.next = large_head.next\\n    return small_head.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2319061,
                "title": "2-ms-faster-than-69-53-of-java-online-submissions-for-partition-list",
                "content": "```\\nclass Solution {\\n    public ListNode partition(ListNode head, int x) {\\n        if(head==null)return head;\\n        Queue<Integer> q_l=new LinkedList<>();\\n        Queue<Integer> q_s=new LinkedList<>();\\n        ListNode cur=head;\\n        while(cur!=null){\\n            if(cur.val<x){\\n                q_s.add(cur.val);\\n            }else{\\n                q_l.add(cur.val);\\n            }\\n            cur=cur.next;\\n        }\\n        ListNode head2=new ListNode(Integer.MIN_VALUE);\\n        ListNode cur2=head2;\\n        while(!q_s.isEmpty()){\\n            ListNode nn=new ListNode(q_s.remove());\\n            cur2.next=nn;\\n            cur2=cur2.next;\\n        }\\n        while(!q_l.isEmpty()){\\n            ListNode nn=new ListNode(q_l.remove());\\n            cur2.next=nn;\\n            cur2=cur2.next;\\n        }\\n        return head2.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode partition(ListNode head, int x) {\\n        if(head==null)return head;\\n        Queue<Integer> q_l=new LinkedList<>();\\n        Queue<Integer> q_s=new LinkedList<>();\\n        ListNode cur=head;\\n        while(cur!=null){\\n            if(cur.val<x){\\n                q_s.add(cur.val);\\n            }else{\\n                q_l.add(cur.val);\\n            }\\n            cur=cur.next;\\n        }\\n        ListNode head2=new ListNode(Integer.MIN_VALUE);\\n        ListNode cur2=head2;\\n        while(!q_s.isEmpty()){\\n            ListNode nn=new ListNode(q_s.remove());\\n            cur2.next=nn;\\n            cur2=cur2.next;\\n        }\\n        while(!q_l.isEmpty()){\\n            ListNode nn=new ListNode(q_l.remove());\\n            cur2.next=nn;\\n            cur2=cur2.next;\\n        }\\n        return head2.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2318553,
                "title": "c-code-using-dummy-nodes",
                "content": "```\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode* dm1 = new ListNode(0);\\n        ListNode* dm2 = new ListNode(0);\\n        ListNode* leftCurr = dm1;\\n        ListNode* rightCurr = dm2;\\n        \\n        while(head != NULL){\\n            if(head -> val < x){\\n                leftCurr->next = head;\\n                leftCurr = head;\\n            }\\n            else {\\n                rightCurr->next=head;\\n                rightCurr = head;\\n            }\\n            head=head->next;\\n        }\\n        \\n        leftCurr->next = dm2->next;\\n        rightCurr->next = NULL;\\n        return dm1->next;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode* dm1 = new ListNode(0);\\n        ListNode* dm2 = new ListNode(0);\\n        ListNode* leftCurr = dm1;\\n        ListNode* rightCurr = dm2;\\n        \\n        while(head != NULL){\\n            if(head -> val < x){\\n                leftCurr->next = head;\\n                leftCurr = head;\\n            }\\n            else {\\n                rightCurr->next=head;\\n                rightCurr = head;\\n            }\\n            head=head->next;\\n        }\\n        \\n        leftCurr->next = dm2->next;\\n        rightCurr->next = NULL;\\n        return dm1->next;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2316102,
                "title": "c-brute-force-easy-and-readable-code",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        vector<int> Helper;\\n        ListNode* temp=head;\\n        while(temp!=NULL)\\n        {\\n            (Helper.push_back(temp->val));\\n            \\n            temp=temp->next;\\n        }\\n        ListNode* temp1=head;\\n        int nose=0;\\n        for(int i=0;i<Helper.size();i++)\\n        {\\n            \\n            if(Helper[i]<x)\\n            {\\n                temp1->val=Helper[i];\\n                temp1=temp1->next;\\n                nose++;\\n            }\\n         \\n            \\n        }\\n       \\n        for(int i=0;i<Helper.size();i++)\\n        {\\n            if(Helper[i]>=x)\\n            {\\n                cout<<temp1->val;\\n                temp1->val=Helper[i];\\n                temp1=temp1->next;\\n            }\\n\\n            \\n        }\\n        return head;\\n        \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        vector<int> Helper;\\n        ListNode* temp=head;\\n        while(temp!=NULL)\\n        {\\n            (Helper.push_back(temp->val));\\n            \\n            temp=temp->next;\\n        }\\n        ListNode* temp1=head;\\n        int nose=0;\\n        for(int i=0;i<Helper.size();i++)\\n        {\\n            \\n            if(Helper[i]<x)\\n            {\\n                temp1->val=Helper[i];\\n                temp1=temp1->next;\\n                nose++;\\n            }\\n         \\n            \\n        }\\n       \\n        for(int i=0;i<Helper.size();i++)\\n        {\\n            if(Helper[i]>=x)\\n            {\\n                cout<<temp1->val;\\n                temp1->val=Helper[i];\\n                temp1=temp1->next;\\n            }\\n\\n            \\n        }\\n        return head;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2312370,
                "title": "partition-list-time-o-n-space-o-1-solution",
                "content": "**Intuition is straightforward.**\\n* We must divide the list so that all nodes with values less than X are on the left side.\\n* As a result, we will create two distinct partitions. One with all nodes with values less than X in the same order and the other nodes in a different list.\\n* Finally, we will connect the smaller list to the larger partition list and return the smaller partition\\'s head.\\n```\\nclass Solution:\\n    def partition(self, head: Optional[ListNode], x: int) -> Optional[ListNode]:\\n\\n\\t\\t#Creating DummyNode for Node smaller and (equal or larger) than x. \\n        smallerList=ListNode(0)\\n        largerList=ListNode(0)\\n\\n\\t\\t#Saving pointer of Smaller and larger partition\\n        smallerHead=smallerList\\n        largerHead=largerList\\n        \\n        # Iterate through all Node\\n        while head:\\n            if head.val<x:\\n                #If val of current Node is Smaller than X Link that Node to smaller partition\\n                smallerList.next=head\\n                smallerList=smallerList.next\\n                \\n            else:\\n                # else val of current Node is equal or larger than X Link that Node to larger partition\\n                largerList.next=head\\n                largerList=largerList.next\\n        \\n            # Move head ptr to next Node\\n            head=head.next\\n\\n\\t\\t# Link smaller Partition Last Node to Larger Partition Head Node\\n        smallerList.next=largerHead.next\\n\\t\\t#Larger partition Last Node to None\\n        largerList.next=None\\n\\n        #Return Smaller partition starting Node\\n        return smallerHead.next   \\n```\\n**Vote if you Love the solution**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List"
                ],
                "code": "```\\nclass Solution:\\n    def partition(self, head: Optional[ListNode], x: int) -> Optional[ListNode]:\\n\\n\\t\\t#Creating DummyNode for Node smaller and (equal or larger) than x. \\n        smallerList=ListNode(0)\\n        largerList=ListNode(0)\\n\\n\\t\\t#Saving pointer of Smaller and larger partition\\n        smallerHead=smallerList\\n        largerHead=largerList\\n        \\n        # Iterate through all Node\\n        while head:\\n            if head.val<x:\\n                #If val of current Node is Smaller than X Link that Node to smaller partition\\n                smallerList.next=head\\n                smallerList=smallerList.next\\n                \\n            else:\\n                # else val of current Node is equal or larger than X Link that Node to larger partition\\n                largerList.next=head\\n                largerList=largerList.next\\n        \\n            # Move head ptr to next Node\\n            head=head.next\\n\\n\\t\\t# Link smaller Partition Last Node to Larger Partition Head Node\\n        smallerList.next=largerHead.next\\n\\t\\t#Larger partition Last Node to None\\n        largerList.next=None\\n\\n        #Return Smaller partition starting Node\\n        return smallerHead.next   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2072641,
                "title": "c-easy-2-list-solution",
                "content": "```\\nclass Solution {\\npublic:\\nListNode* partition(ListNode* head, int x) {\\n\\tListNode* l1 = new ListNode(0);\\n\\tListNode* l2 = new ListNode(0);\\n\\tListNode* ptr1 = l1;\\n\\tListNode* ptr2 = l2;\\n\\n\\t// make 2 lists\\n\\twhile (head) {\\n\\t\\tif (head->val < x) {\\n\\t\\t\\tptr1->next = head;\\n\\t\\t\\tptr1 = ptr1->next;\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tptr2->next = head;\\n\\t\\t\\tptr2 = ptr2->next;\\n\\t\\t}\\n\\t\\thead = head->next;\\n\\t}\\n\\t//connect 2 lists\\n\\tptr1->next = l2->next;\\n\\tptr2->next = NULL;\\n\\treturn l1->next;\\n}\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nListNode* partition(ListNode* head, int x) {\\n\\tListNode* l1 = new ListNode(0);\\n\\tListNode* l2 = new ListNode(0);\\n\\tListNode* ptr1 = l1;\\n\\tListNode* ptr2 = l2;\\n\\n\\t// make 2 lists\\n\\twhile (head) {\\n\\t\\tif (head->val < x) {\\n\\t\\t\\tptr1->next = head;\\n\\t\\t\\tptr1 = ptr1->next;\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tptr2->next = head;\\n\\t\\t\\tptr2 = ptr2->next;\\n\\t\\t}\\n\\t\\thead = head->next;\\n\\t}\\n\\t//connect 2 lists\\n\\tptr1->next = l2->next;\\n\\tptr2->next = NULL;\\n\\treturn l1->next;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1112598,
                "title": "java-simple-and-easy-to-understand-solution-0-ms-faster-than-100-00-clean-code-with-comments",
                "content": "**PLEASE UPVOTE IF YOU LIKE THIS SOLUTION**\\n\\n\\n\\n```\\nclass Solution {\\n    public ListNode partition(ListNode head, int x) {\\n        ListNode dummyNodeLess = new ListNode();\\n        ListNode currL = dummyNodeLess;\\n        \\n        ListNode dummyNodeGreater = new ListNode();\\n        ListNode currG = dummyNodeGreater;\\n        \\n        \\n        ListNode curr = head;\\n        \\n        //separete less and greater node,\\n        while(curr != null){\\n            \\n            ListNode node = curr;\\n            if(node.val < x){\\n                currL.next = node;\\n                currL = currL.next;\\n            } else {\\n                currG.next = node;\\n                currG = currG.next;\\n            }\\n            \\n            curr = node.next;\\n            node.next = null;\\n        }\\n        \\n        //just append, greater list in last of less node list\\n        currL.next = dummyNodeGreater.next;\\n        \\n        return dummyNodeLess.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode partition(ListNode head, int x) {\\n        ListNode dummyNodeLess = new ListNode();\\n        ListNode currL = dummyNodeLess;\\n        \\n        ListNode dummyNodeGreater = new ListNode();\\n        ListNode currG = dummyNodeGreater;\\n        \\n        \\n        ListNode curr = head;\\n        \\n        //separete less and greater node,\\n        while(curr != null){\\n            \\n            ListNode node = curr;\\n            if(node.val < x){\\n                currL.next = node;\\n                currL = currL.next;\\n            } else {\\n                currG.next = node;\\n                currG = currG.next;\\n            }\\n            \\n            curr = node.next;\\n            node.next = null;\\n        }\\n        \\n        //just append, greater list in last of less node list\\n        currL.next = dummyNodeGreater.next;\\n        \\n        return dummyNodeLess.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 29242,
                "title": "11-line-one-pass-easy-to-understand-python-solution",
                "content": "```\\nclass Solution(object):\\n    def partition(self, head, x):\\n        \"\"\"\\n        :type head: ListNode\\n        :type x: int\\n        :rtype: ListNode\\n        \"\"\"\\n        left, right = ListNode(None), ListNode(None)\\n        left_cur, right_cur = left, right\\n        while head:\\n            if head.val < x:\\n                left_cur.next, head = head, head.next\\n                left_cur, left_cur.next = left_cur.next, None\\n            else:\\n                right_cur.next, head = head, head.next\\n                right_cur, right_cur.next = right_cur.next, None\\n        left_cur.next = right.next\\n        return left.next\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def partition(self, head, x):\\n        \"\"\"\\n        :type head: ListNode\\n        :type x: int\\n        :rtype: ListNode\\n        \"\"\"\\n        left, right = ListNode(None), ListNode(None)\\n        left_cur, right_cur = left, right\\n        while head:\\n            if head.val < x:\\n                left_cur.next, head = head, head.next\\n                left_cur, left_cur.next = left_cur.next, None\\n            else:\\n                right_cur.next, head = head, head.next\\n                right_cur, right_cur.next = right_cur.next, None\\n        left_cur.next = right.next\\n        return left.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 29314,
                "title": "java-solution-pick-out-larger-nodes-and-append-to-the-end",
                "content": "    public ListNode partition(ListNode head, int x) {\\n        if(head==null || head.next==null) return head;\\n        \\n        ListNode l1 = new ListNode(0); \\n        ListNode l2 = new ListNode(0);\\n        ListNode p1=l1, p2=l2;\\n        \\n        p1.next = head;\\n        while(p1.next!=null) {\\n            // keep moving larger node to list 2;\\n            \\n            if(p1.next.val>=x) {\\n                ListNode tmp = p1.next;\\n                p1.next = tmp.next;\\n                \\n                p2.next = tmp;\\n                p2 = p2.next;\\n            }\\n            else {\\n                p1 = p1.next;\\n            }\\n        }\\n        \\n        // conbine lists 1 and 2;\\n        p2.next = null;\\n        p1.next = l2.next;\\n        return l1.next;\\n    }",
                "solutionTags": [],
                "code": "    public ListNode partition(ListNode head, int x) {\\n        if(head==null || head.next==null) return head;\\n        \\n        ListNode l1 = new ListNode(0); \\n        ListNode l2 = new ListNode(0);\\n        ListNode p1=l1, p2=l2;\\n        \\n        p1.next = head;\\n        while(p1.next!=null) {\\n            // keep moving larger node to list 2;\\n            \\n            if(p1.next.val>=x) {\\n                ListNode tmp = p1.next;\\n                p1.next = tmp.next;\\n                \\n                p2.next = tmp;\\n                p2 = p2.next;\\n            }\\n            else {\\n                p1 = p1.next;\\n            }\\n        }\\n        \\n        // conbine lists 1 and 2;\\n        p2.next = null;\\n        p1.next = l2.next;\\n        return l1.next;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3913580,
                "title": "c-linkedlist-two-pointers-beats-100",
                "content": "# Intuition\\n# *The intuition behind this code is that it separates the nodes into two partitions while preserving their original order. Nodes with values less than x are placed in the small partition, and nodes with values greater than or equal to x are placed in the large partition. After processing all nodes, the two partitions are connected, resulting in the desired partitioned linked list*.\\n\\n# Approach\\n1. *Two new nodes, small and large, are created as dummy nodes to serve as the heads of the two partitions: one for nodes with values less than x (small) and another for nodes with values greater than or equal to x (large)*.\\n\\n2. *smallPtr and largePtr are pointers to track the last node in each partition. They are initially set to point to the dummy nodes small and large, respectively*.\\n\\n3. *A loop iterates through the input linked list pointed to by head*.\\n\\nInside the loop:\\n\\n1. *If the current node\\'s value is less than x, it is appended to the small partition by making smallPtr->next point to it, and then smallPtr is moved to the newly added node*.\\n\\n2. *If the current node\\'s value is greater than or equal to x, it is appended to the large partition using similar logic*.\\n\\n3. *After processing all nodes in the original linked list, the next pointers of smallPtr and largePtr are adjusted. The next pointer of smallPtr is connected to the first node of the large partition, effectively merging the two partitions*.\\n\\n\\n5. *Finally, the next pointer of largePtr is set to NULL to terminate the large partition*.\\n\\n6. *The function returns the next pointer of the small dummy node, which points to the beginning of the partitioned linked list*.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1**Bold**)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode* small = new ListNode(0);\\n        ListNode* large = new ListNode(0);\\n\\n        ListNode* smallPtr = small;\\n        ListNode* largePtr = large;\\n\\n        while(head != NULL){\\n            if(head->val < x){\\n                smallPtr->next = head;\\n                smallPtr = smallPtr->next;\\n            }\\n            else{\\n                largePtr->next = head;\\n                largePtr = largePtr->next;\\n            }\\n            head = head->next;\\n        }\\n        smallPtr->next = large->next;\\n        largePtr->next = NULL;\\n\\n        return small->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode* small = new ListNode(0);\\n        ListNode* large = new ListNode(0);\\n\\n        ListNode* smallPtr = small;\\n        ListNode* largePtr = large;\\n\\n        while(head != NULL){\\n            if(head->val < x){\\n                smallPtr->next = head;\\n                smallPtr = smallPtr->next;\\n            }\\n            else{\\n                largePtr->next = head;\\n                largePtr = largePtr->next;\\n            }\\n            head = head->next;\\n        }\\n        smallPtr->next = large->next;\\n        largePtr->next = NULL;\\n\\n        return small->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3911985,
                "title": "simple-beginner-friendly-c-solution-with-intuition-and-explanation",
                "content": "# Intuition\\nIn the problem, we have to partition a singly linked list into two segments: one with elements less than a given value x and the other with elements greater than or equal to x. We accomplish this by iterating through the original list and using two dummy nodes (Prev and Next) to construct the partitioned segments. As each node is examined, we assign it to the appropriate segment based on its value compared to x. After the traversal, the two segments are linked together by updating pointers, resulting in a new linked list that fulfills the partitioning condition.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n\\nFollow the following steps:\\n- Create pointers prev_curr and next_curr to track the current positions in the two dummy nodes.\\n\\n- Loop through the original linked list using the head pointer:\\n\\n- >If the current node\\'s value is greater than or equal to x, add it to the Next partition.\\n- >Otherwise, add it to the Prev partition.\\n- After the loop, set next_curr->next to NULL to terminate the Next partition.\\n\\n- Finally, set prev_curr->next to Next.next to link the Prev partition with the Next partition.\\n\\n- Return Prev.next, which is the head of the partitioned linked list.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nUPVOTE. Glad to help.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode Prev(0),Next(0);\\n        ListNode* prev_curr=&Prev;\\n        ListNode* next_curr=&Next;\\n        while(head){\\n            if(head->val>=x){\\n                next_curr->next=head;\\n                next_curr=head;\\n            } else {\\n                prev_curr->next=head;\\n                prev_curr=head;\\n            }\\n            head=head->next;\\n        }\\n        next_curr->next=NULL;\\n        prev_curr->next=Next.next;\\n        return Prev.next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode Prev(0),Next(0);\\n        ListNode* prev_curr=&Prev;\\n        ListNode* next_curr=&Next;\\n        while(head){\\n            if(head->val>=x){\\n                next_curr->next=head;\\n                next_curr=head;\\n            } else {\\n                prev_curr->next=head;\\n                prev_curr=head;\\n            }\\n            head=head->next;\\n        }\\n        next_curr->next=NULL;\\n        prev_curr->next=Next.next;\\n        return Prev.next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3911888,
                "title": "my-java-easy-0-ms-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode partition(ListNode head, int x) {\\n        ListNode first = new ListNode(0);\\n        ListNode sec = new ListNode(0);\\n\\n        ListNode dS = first;\\n        ListNode dL = sec;\\n\\n        while(head != null){\\n            if(head.val < x){\\n                dS.next = new ListNode(head.val);\\n                dS = dS.next;\\n            }else{\\n                dL.next = new ListNode(head.val);\\n                dL = dL.next;\\n            }\\n            head = head.next;\\n        }\\n        dS.next = sec.next;\\n        return first.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode partition(ListNode head, int x) {\\n        ListNode first = new ListNode(0);\\n        ListNode sec = new ListNode(0);\\n\\n        ListNode dS = first;\\n        ListNode dL = sec;\\n\\n        while(head != null){\\n            if(head.val < x){\\n                dS.next = new ListNode(head.val);\\n                dS = dS.next;\\n            }else{\\n                dL.next = new ListNode(head.val);\\n                dL = dL.next;\\n            }\\n            head = head.next;\\n        }\\n        dS.next = sec.next;\\n        return first.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3911555,
                "title": "two-approaches-java-python-c",
                "content": "# Approach 1 : \\n> ### *Maintain two queues smallerQueue to store the smaller value nodes and and greaterQueue to store greater or equal value nodes. You can store either the whole Node or just the value in the node. After filling these queues you can manipulate the original linkedlist using these queues. Look at the code for better understanding.*\\n\\n# Code\\n```java []\\nclass Solution {\\n    public ListNode partition(ListNode head, int x) {\\n        if(head == null || head.next == null)\\n            return head;\\n        Queue<Integer> smaller = new LinkedList<>();\\n        Queue<Integer> greater = new LinkedList<>();\\n        ListNode temp = head;\\n        while(temp!=null)\\n        {\\n            if(temp.val < x)\\n                smaller.add(temp.val);\\n            else\\n                greater.add(temp.val);\\n            temp = temp.next;\\n        }\\n        temp = head;\\n        while(temp!=null)\\n        {\\n            if(smaller.size() > 0)\\n                temp.val = smaller.poll();\\n            else\\n                temp.val = greater.poll();\\n            temp = temp.next;\\n        }\\n        return head;\\n    }\\n}\\n```\\n```python []\\nclass Solution:\\n    def partition(self, head: Optional[ListNode], x: int) -> Optional[ListNode]:\\n        if not head or not head.next:\\n            return head\\n        smaller = []\\n        greater = []\\n        temp = head\\n        while temp:\\n            if temp.val < x:\\n                smaller.append(temp.val)\\n            else:\\n                greater.append(temp.val)\\n            temp = temp.next\\n        \\n        temp = head\\n        while temp:\\n            if smaller:\\n                temp.val = smaller.pop(0)\\n            else:\\n                temp.val = greater.pop(0)\\n            temp = temp.next\\n        \\n        return head\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        if (!head || !head->next)\\n            return head;\\n\\n        queue<int> smaller;\\n        queue<int> greater;\\n        ListNode* temp = head;\\n        while (temp) {\\n            if (temp->val < x)\\n                smaller.push(temp->val);\\n            else\\n                greater.push(temp->val);\\n            temp = temp->next;\\n        }\\n\\n        temp = head;\\n        while (temp) {\\n            if (!smaller.empty()) {\\n                temp->val = smaller.front();\\n                smaller.pop();\\n            } else {\\n                temp->val = greater.front();\\n                greater.pop();\\n            }\\n            temp = temp->next;\\n        }\\n\\n        return head;\\n    }\\n};\\n```\\n---\\n> ## *But this is not an optimal approach because space-complexity is O(N) and time complexity is O(N). Can we further optimize the solution to use O(1) space ??* \\n---\\n# Approach 2 : \\n> ### *Instead of maintaing two queues we will maintain two pointers smaller and greater pointers and when we traverse the array if the node value is smaller than given value then we link it to smaller pointer otherwise we link it to the greater pointer. After traversing the whole linkedlist you can attach the smaller List nd greater List and return it. Look at the code for better understanding.*\\n\\n# Code\\n```java []\\nclass Solution {\\n    public ListNode partition(ListNode head, int x) {\\n        if(head == null || head.next == null)\\n            return head;\\n        ListNode smaller = new ListNode(-1),greater = new ListNode(-1),curr1 = smaller,curr2 = greater,temp = head;\\n        while(temp!=null)\\n        {\\n            if(temp.val < x)\\n            {\\n                curr1.next = temp;\\n                curr1 = curr1.next;\\n            }\\n            else\\n            {\\n                curr2.next = temp;\\n                curr2 = curr2.next;\\n            }\\n            temp = temp.next;\\n        }\\n        curr2.next = null;\\n        curr1.next = greater.next;\\n        return smaller.next;\\n    }\\n}\\n```\\n```python []\\nclass Solution:\\n    def partition(self, head: Optional[ListNode], x: int) -> Optional[ListNode]:\\n        if not head or not head.next:\\n            return head\\n        smaller = ListNode(-1)\\n        greater = ListNode(-1)\\n        curr1 = smaller\\n        curr2 = greater\\n        temp = head\\n        \\n        while temp:\\n            if temp.val < x:\\n                curr1.next = temp\\n                curr1 = curr1.next\\n            else:\\n                curr2.next = temp\\n                curr2 = curr2.next\\n            temp = temp.next\\n        \\n        curr2.next = None\\n        curr1.next = greater.next\\n        return smaller.next\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        if (!head || !head->next)\\n            return head;\\n        \\n        ListNode* smaller = new ListNode(-1);\\n        ListNode* greater = new ListNode(-1);\\n        ListNode* curr1 = smaller;\\n        ListNode* curr2 = greater;\\n        ListNode* temp = head;\\n        \\n        while (temp) {\\n            if (temp->val < x) {\\n                curr1->next = temp;\\n                curr1 = curr1->next;\\n            } else {\\n                curr2->next = temp;\\n                curr2 = curr2->next;\\n            }\\n            temp = temp->next;\\n        }\\n        \\n        curr2->next = nullptr;\\n        curr1->next = greater->next;\\n        \\n        ListNode* result = smaller->next;\\n        delete smaller;\\n        delete greater;\\n        \\n        return result;\\n    }\\n};\\n```\\n---\\n> ## *Please don\\'t forget to upvote if you\\'ve liked my explanation. Do post your suggestions through the comments.* \\uD83D\\uDCAC",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```java []\\nclass Solution {\\n    public ListNode partition(ListNode head, int x) {\\n        if(head == null || head.next == null)\\n            return head;\\n        Queue<Integer> smaller = new LinkedList<>();\\n        Queue<Integer> greater = new LinkedList<>();\\n        ListNode temp = head;\\n        while(temp!=null)\\n        {\\n            if(temp.val < x)\\n                smaller.add(temp.val);\\n            else\\n                greater.add(temp.val);\\n            temp = temp.next;\\n        }\\n        temp = head;\\n        while(temp!=null)\\n        {\\n            if(smaller.size() > 0)\\n                temp.val = smaller.poll();\\n            else\\n                temp.val = greater.poll();\\n            temp = temp.next;\\n        }\\n        return head;\\n    }\\n}\\n```\n```python []\\nclass Solution:\\n    def partition(self, head: Optional[ListNode], x: int) -> Optional[ListNode]:\\n        if not head or not head.next:\\n            return head\\n        smaller = []\\n        greater = []\\n        temp = head\\n        while temp:\\n            if temp.val < x:\\n                smaller.append(temp.val)\\n            else:\\n                greater.append(temp.val)\\n            temp = temp.next\\n        \\n        temp = head\\n        while temp:\\n            if smaller:\\n                temp.val = smaller.pop(0)\\n            else:\\n                temp.val = greater.pop(0)\\n            temp = temp.next\\n        \\n        return head\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        if (!head || !head->next)\\n            return head;\\n\\n        queue<int> smaller;\\n        queue<int> greater;\\n        ListNode* temp = head;\\n        while (temp) {\\n            if (temp->val < x)\\n                smaller.push(temp->val);\\n            else\\n                greater.push(temp->val);\\n            temp = temp->next;\\n        }\\n\\n        temp = head;\\n        while (temp) {\\n            if (!smaller.empty()) {\\n                temp->val = smaller.front();\\n                smaller.pop();\\n            } else {\\n                temp->val = greater.front();\\n                greater.pop();\\n            }\\n            temp = temp->next;\\n        }\\n\\n        return head;\\n    }\\n};\\n```\n```java []\\nclass Solution {\\n    public ListNode partition(ListNode head, int x) {\\n        if(head == null || head.next == null)\\n            return head;\\n        ListNode smaller = new ListNode(-1),greater = new ListNode(-1),curr1 = smaller,curr2 = greater,temp = head;\\n        while(temp!=null)\\n        {\\n            if(temp.val < x)\\n            {\\n                curr1.next = temp;\\n                curr1 = curr1.next;\\n            }\\n            else\\n            {\\n                curr2.next = temp;\\n                curr2 = curr2.next;\\n            }\\n            temp = temp.next;\\n        }\\n        curr2.next = null;\\n        curr1.next = greater.next;\\n        return smaller.next;\\n    }\\n}\\n```\n```python []\\nclass Solution:\\n    def partition(self, head: Optional[ListNode], x: int) -> Optional[ListNode]:\\n        if not head or not head.next:\\n            return head\\n        smaller = ListNode(-1)\\n        greater = ListNode(-1)\\n        curr1 = smaller\\n        curr2 = greater\\n        temp = head\\n        \\n        while temp:\\n            if temp.val < x:\\n                curr1.next = temp\\n                curr1 = curr1.next\\n            else:\\n                curr2.next = temp\\n                curr2 = curr2.next\\n            temp = temp.next\\n        \\n        curr2.next = None\\n        curr1.next = greater.next\\n        return smaller.next\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        if (!head || !head->next)\\n            return head;\\n        \\n        ListNode* smaller = new ListNode(-1);\\n        ListNode* greater = new ListNode(-1);\\n        ListNode* curr1 = smaller;\\n        ListNode* curr2 = greater;\\n        ListNode* temp = head;\\n        \\n        while (temp) {\\n            if (temp->val < x) {\\n                curr1->next = temp;\\n                curr1 = curr1->next;\\n            } else {\\n                curr2->next = temp;\\n                curr2 = curr2->next;\\n            }\\n            temp = temp->next;\\n        }\\n        \\n        curr2->next = nullptr;\\n        curr1->next = greater->next;\\n        \\n        ListNode* result = smaller->next;\\n        delete smaller;\\n        delete greater;\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3911070,
                "title": "video-solution-with-drawings-c-java-in-depth",
                "content": "# Intuition, approach and complexity discussed in video solution in detail\\nhttps://youtu.be/0ROu_XHnop4\\n\\n# Code\\nC++\\n```\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        if(head == NULL)return head;\\n        ListNode *dummyHeadSml = new ListNode();\\n        ListNode *curSmlNode = dummyHeadSml;\\n\\n        ListNode *dummyHeadEg = new ListNode();\\n        ListNode *curEgNode = dummyHeadEg;\\n\\n        for(ListNode *curr = head; curr != NULL;){\\n            ListNode *next = curr->next;\\n            curr->next = NULL;\\n            if(curr->val < x){\\n                curSmlNode->next = curr;\\n                curSmlNode = curr;\\n            }else{\\n                curEgNode->next = curr;\\n                curEgNode = curr;\\n            }\\n            curr = next;\\n        }\\n        \\n        curSmlNode->next = dummyHeadEg->next;\\n        return dummyHeadSml->next;\\n    }\\n};\\n```\\nJava\\n```\\nclass Solution {\\n    public ListNode partition(ListNode head, int x) {\\n        if(head == null)return head;\\n        ListNode dummyHeadSml = new ListNode();\\n        ListNode curSmlNode = dummyHeadSml;\\n\\n        ListNode dummyHeadEg = new ListNode();\\n        ListNode curEgNode = dummyHeadEg;\\n\\n        for(ListNode curr = head; curr != null;){\\n            ListNode next = curr.next;\\n            curr.next = null;\\n            if(curr.val < x){\\n                curSmlNode.next = curr;\\n                curSmlNode = curr;\\n            }else{\\n                curEgNode.next = curr;\\n                curEgNode = curr;\\n            }\\n            curr = next;\\n        }\\n        \\n        curSmlNode.next = dummyHeadEg.next;\\n        return dummyHeadSml.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        if(head == NULL)return head;\\n        ListNode *dummyHeadSml = new ListNode();\\n        ListNode *curSmlNode = dummyHeadSml;\\n\\n        ListNode *dummyHeadEg = new ListNode();\\n        ListNode *curEgNode = dummyHeadEg;\\n\\n        for(ListNode *curr = head; curr != NULL;){\\n            ListNode *next = curr->next;\\n            curr->next = NULL;\\n            if(curr->val < x){\\n                curSmlNode->next = curr;\\n                curSmlNode = curr;\\n            }else{\\n                curEgNode->next = curr;\\n                curEgNode = curr;\\n            }\\n            curr = next;\\n        }\\n        \\n        curSmlNode->next = dummyHeadEg->next;\\n        return dummyHeadSml->next;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public ListNode partition(ListNode head, int x) {\\n        if(head == null)return head;\\n        ListNode dummyHeadSml = new ListNode();\\n        ListNode curSmlNode = dummyHeadSml;\\n\\n        ListNode dummyHeadEg = new ListNode();\\n        ListNode curEgNode = dummyHeadEg;\\n\\n        for(ListNode curr = head; curr != null;){\\n            ListNode next = curr.next;\\n            curr.next = null;\\n            if(curr.val < x){\\n                curSmlNode.next = curr;\\n                curSmlNode = curr;\\n            }else{\\n                curEgNode.next = curr;\\n                curEgNode = curr;\\n            }\\n            curr = next;\\n        }\\n        \\n        curSmlNode.next = dummyHeadEg.next;\\n        return dummyHeadSml.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3910908,
                "title": "c-solution-with-explanation-optimal-solution-o-n-time-and-o-1-space-complexity-two-pointer",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTwo Pointer Approach\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Take two pointers, one is pointing to the list in which the vlaue is less then x and the other one pointing to the list in which the value is greater than equal to the x.\\n2. if the second list is non empty then update the link of last node to NULL\\n3. if the first list is empty then simply return the second list otherwise connect the first and second list and return the combined list.\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        if (head == NULL) return head;\\n        ListNode *first = NULL, *l1 = NULL, *l2 = NULL, *second = NULL;\\n        while(head != NULL){\\n            if (head->val < x){\\n                if (first == NULL){\\n                    first = head;\\n                    l1 = first;\\n                }\\n                else {\\n                    l1->next = head;\\n                    l1 = l1->next;\\n                }\\n            }\\n            else{\\n                if (second == NULL){\\n                    second = head;\\n                    l2 = second;\\n                }\\n                else{\\n                    l2->next = head;\\n                    l2 = l2->next;\\n                }\\n            }\\n            head = head->next;\\n        }\\n        // if second list is not empty then update the last node link to NULL\\n        if (l2 != NULL)\\n        l2->next = NULL;\\n        // if the first list is not empty then connect the first and second list otherwise return the second list \\n        if (l1 != NULL)\\n        l1->next = second;\\n        else return second;\\n        return first;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        if (head == NULL) return head;\\n        ListNode *first = NULL, *l1 = NULL, *l2 = NULL, *second = NULL;\\n        while(head != NULL){\\n            if (head->val < x){\\n                if (first == NULL){\\n                    first = head;\\n                    l1 = first;\\n                }\\n                else {\\n                    l1->next = head;\\n                    l1 = l1->next;\\n                }\\n            }\\n            else{\\n                if (second == NULL){\\n                    second = head;\\n                    l2 = second;\\n                }\\n                else{\\n                    l2->next = head;\\n                    l2 = l2->next;\\n                }\\n            }\\n            head = head->next;\\n        }\\n        // if second list is not empty then update the last node link to NULL\\n        if (l2 != NULL)\\n        l2->next = NULL;\\n        // if the first list is not empty then connect the first and second list otherwise return the second list \\n        if (l1 != NULL)\\n        l1->next = second;\\n        else return second;\\n        return first;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3862218,
                "title": "best-c-solution-time-o-n-space-o-1-beats-100",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void solve(ListNode* &first, ListNode* &second, ListNode* &curr, int x){\\n        while(curr != NULL){\\n            if(curr->val < x){\\n                first->next = curr;\\n                first = curr;\\n            }\\n            else{\\n                second->next = curr;\\n                second = curr;\\n            }\\n            curr = curr->next;\\n        }\\n    }\\n\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode *smallHead = head, *largeHead = head;\\n        \\n        // Step 1 - Find the first small node and first large node\\n        // Also calculate the position at which they occur\\n        int sCount = 1, lCount = 1;\\n        while(smallHead != NULL && smallHead->val >= x){\\n            smallHead = smallHead->next;\\n            sCount++;\\n        }\\n        while(largeHead != NULL && largeHead->val < x){\\n            largeHead = largeHead->next;\\n            lCount++;\\n        }\\n        if(smallHead == NULL || largeHead == NULL)   \\n            return head;\\n        \\n        // Step 2 - Traverse the LL such that the two heads are adjacent\\n        // based on which head occurs first\\n        ListNode *first = smallHead, *second = largeHead, *curr;\\n        if(sCount < lCount){\\n            while(first->next != second)\\n                first = first->next;\\n            curr = second->next;\\n        }\\n        else{\\n            while(second->next != first)\\n                second = second->next;\\n            curr = first->next;\\n        }\\n        \\n        // Step 3 - Use solve() to form two separate LL and then merge them\\n        solve(first, second, curr, x);\\n        first->next = largeHead;\\n        second->next = NULL;\\n        return smallHead;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(ListNode* &first, ListNode* &second, ListNode* &curr, int x){\\n        while(curr != NULL){\\n            if(curr->val < x){\\n                first->next = curr;\\n                first = curr;\\n            }\\n            else{\\n                second->next = curr;\\n                second = curr;\\n            }\\n            curr = curr->next;\\n        }\\n    }\\n\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode *smallHead = head, *largeHead = head;\\n        \\n        // Step 1 - Find the first small node and first large node\\n        // Also calculate the position at which they occur\\n        int sCount = 1, lCount = 1;\\n        while(smallHead != NULL && smallHead->val >= x){\\n            smallHead = smallHead->next;\\n            sCount++;\\n        }\\n        while(largeHead != NULL && largeHead->val < x){\\n            largeHead = largeHead->next;\\n            lCount++;\\n        }\\n        if(smallHead == NULL || largeHead == NULL)   \\n            return head;\\n        \\n        // Step 2 - Traverse the LL such that the two heads are adjacent\\n        // based on which head occurs first\\n        ListNode *first = smallHead, *second = largeHead, *curr;\\n        if(sCount < lCount){\\n            while(first->next != second)\\n                first = first->next;\\n            curr = second->next;\\n        }\\n        else{\\n            while(second->next != first)\\n                second = second->next;\\n            curr = first->next;\\n        }\\n        \\n        // Step 3 - Use solve() to form two separate LL and then merge them\\n        solve(first, second, curr, x);\\n        first->next = largeHead;\\n        second->next = NULL;\\n        return smallHead;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3685462,
                "title": "c-solution-easy-to-understand",
                "content": "# Approach\\n1. create two lists - one for nodes with value less than x and one for nodes with value greater than x.\\n2. Join the left list to right and right ends with NULL.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode* left = new ListNode();\\n        ListNode* right = new ListNode();\\n        ListNode* head1 = left;\\n        ListNode* head2 = right;\\n        ListNode* curr = head;\\n        while(curr!=NULL){\\n            if(curr->val>=x){\\n                right->next = curr;\\n                right = right->next;\\n                curr = curr->next;\\n            }\\n            else{\\n                left->next = curr; \\n                left= left->next;\\n                curr = curr->next;\\n            }\\n        }\\n        left->next = head2->next;\\n        right->next = NULL;\\n        return head1->next;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode* left = new ListNode();\\n        ListNode* right = new ListNode();\\n        ListNode* head1 = left;\\n        ListNode* head2 = right;\\n        ListNode* curr = head;\\n        while(curr!=NULL){\\n            if(curr->val>=x){\\n                right->next = curr;\\n                right = right->next;\\n                curr = curr->next;\\n            }\\n            else{\\n                left->next = curr; \\n                left= left->next;\\n                curr = curr->next;\\n            }\\n        }\\n        left->next = head2->next;\\n        right->next = NULL;\\n        return head1->next;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3622187,
                "title": "easy-c-solution-with-pseudocode",
                "content": "We can solve this problem by the following steps-\\n1) Make a temp variable which points towards head in the begging ; \\n2) Make Two new node which will start as the dummy head for the beginning of the two new linked list \\n3) The First LinkedList consists of all the node which are smaller than the the value x\\n4) Meanwhile the other one consists of all which are larger or equal to x ; \\n5) We check the value at temp and add that desired node to one of the newly made list and then perform temp = temp->next while temp!=NULL ; \\n6) Now if temp reaches null that means we have iterated throught the linkedlist completely so \\n7) We connected the Smaller element LL with the Biggest Element LinkedList \\n\\nHere Is the code of the above pseudocode ; \\nUpvote if you found this helpful \\n\\n    class Solution {\\n     public:\\n     ListNode* partition(ListNode* head, int x) {\\n        ListNode* temp = head  ; \\n        \\n        ListNode* left = new ListNode(0);\\n        ListNode* right = new ListNode(0) ; \\n        ListNode* dummy1 = left  ;\\n        ListNode* dummy2 = right ; \\n        while(temp!=NULL){\\n            if(temp->val < x){\\n                dummy1->next = temp ; \\n                dummy1 = dummy1->next ; \\n             }\\n            else {\\n                dummy2->next = temp ; \\n                dummy2 = dummy2->next ; \\n                \\n            }\\n            temp = temp->next ; \\n        }\\n        dummy1->next = right->next ; \\n        dummy2->next = NULL;\\n        \\n        return left->next ; \\n    }\\n    };\\n\\n\\n",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "class Solution {\\n     public:\\n     ListNode* partition(ListNode* head, int x) {\\n        ListNode* temp = head  ; \\n        \\n        ListNode* left = new ListNode(0);\\n        ListNode* right = new ListNode(0) ; \\n        ListNode* dummy1 = left  ;\\n        ListNode* dummy2 = right ; \\n        while(temp!=NULL){\\n            if(temp->val < x){\\n                dummy1->next = temp ; \\n                dummy1 = dummy1->next ; \\n             }",
                "codeTag": "Java"
            },
            {
                "id": 3529295,
                "title": "java-very-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode partition(ListNode head, int x) {\\n        ListNode list1=new ListNode(0);\\n        ListNode list2=new ListNode(0);\\n\\n        ListNode l1=list1;\\n        ListNode l2=list2;\\n\\n        while(head!=null){\\n            if(head.val<x){\\n                l1.next=head;\\n                l1=l1.next;\\n            }\\n            else{\\n                l2.next=head;\\n                l2=l2.next;\\n            }\\n            head=head.next;\\n\\n        }\\n        l1.next=list2.next;\\n        l2.next=null;\\n        return list1.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode partition(ListNode head, int x) {\\n        ListNode list1=new ListNode(0);\\n        ListNode list2=new ListNode(0);\\n\\n        ListNode l1=list1;\\n        ListNode l2=list2;\\n\\n        while(head!=null){\\n            if(head.val<x){\\n                l1.next=head;\\n                l1=l1.next;\\n            }\\n            else{\\n                l2.next=head;\\n                l2=l2.next;\\n            }\\n            head=head.next;\\n\\n        }\\n        l1.next=list2.next;\\n        l2.next=null;\\n        return list1.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3185253,
                "title": "partition-list-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThis solution uses two dummy nodes to keep track of the partitioned linked list. It traverses the original linked list and adds each node to either the \"before\" partition (nodes with values less than x) or the \"after\" partition (nodes with values greater than or equal to x). After the partitioning, the two partitioned linked lists are combined and the head of the combined linked list is returned as the result.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\nclass ListNode:\\n    def __init__(self, val=0, next=None):\\n        self.val = val\\n        self.next = next\\n\\nclass Solution:\\n    def partition(self, head: ListNode, x: int) -> ListNode:\\n        # Create two dummy nodes for partitioned list\\n        before_head = ListNode(0)\\n        before = before_head\\n        after_head = ListNode(0)\\n        after = after_head\\n        \\n        # Traverse the original list and add each node to either \\n        # the before partition or after partition\\n        while head:\\n            if head.val < x:\\n                before.next = head\\n                before = before.next\\n            else:\\n                after.next = head\\n                after = after.next\\n            head = head.next\\n        \\n        # End the after partition list\\n        after.next = None\\n        # Combine the before and after partitions\\n        before.next = after_head.next\\n        return before_head.next\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\nclass ListNode:\\n    def __init__(self, val=0, next=None):\\n        self.val = val\\n        self.next = next\\n\\nclass Solution:\\n    def partition(self, head: ListNode, x: int) -> ListNode:\\n        # Create two dummy nodes for partitioned list\\n        before_head = ListNode(0)\\n        before = before_head\\n        after_head = ListNode(0)\\n        after = after_head\\n        \\n        # Traverse the original list and add each node to either \\n        # the before partition or after partition\\n        while head:\\n            if head.val < x:\\n                before.next = head\\n                before = before.next\\n            else:\\n                after.next = head\\n                after = after.next\\n            head = head.next\\n        \\n        # End the after partition list\\n        after.next = None\\n        # Combine the before and after partitions\\n        before.next = after_head.next\\n        return before_head.next\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3011516,
                "title": "linear-time-solution-for-partitioning-a-linked-list-two-stacks",
                "content": "# Intuition\\nI solved this problem by using two lists to partition the elements of the linked list. My approach involved using two stacks in JavaScript to store the elements of the linked list.\\n\\n# Approach\\n1. Initialized two empty stacks, called left and right.\\n2. Traversed the linked list, adding elements less than x to the left stack and the rest of the elements to the right stack.\\n3. Created an empty ListNode to serve as the head of the new linked list that I would build.\\n4. Used a while loop to iterate through the right stack, adding each element to the new linked list in reverse order.\\n5. Used another while loop to iterate through the left stack, adding each element to the new linked list in reverse order.\\n6. Returned the head of the new linked list as the result.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of this solution is ***O(n)***, because it takes a single pass through the linked list to partition the elements into the left and right stacks.\\n\\n- Space complexity:\\nThe space complexity of this solution is also ***O(n)***, because it uses two stacks to store the elements of the linked list. The maximum size of the stacks is equal to the number of elements in the linked list, so the space complexity is O(n).\\n\\nOverall, this solution has efficient time and space complexity, as it is linear in the number of elements in the linked list.\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @param {number} x\\n * @return {ListNode}\\n */\\nvar partition = function(head, x) {\\n    let left = [];\\n    let right = [];\\n    while(head){\\n        if(head.val < x){\\n            left.push(head.val);\\n        }else{\\n            right.push(head.val)\\n        }\\n        head = head.next;\\n    }\\n    \\n    head = null;\\n\\n    while(right.length !== 0){\\n        let node = new ListNode(right.pop());\\n        node.next = head;\\n        head = node;\\n    }\\n    while(left.length !== 0){\\n        let node = new ListNode(left.pop());\\n        node.next = head;\\n        head = node;\\n    }\\n    return head;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Stack"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @param {number} x\\n * @return {ListNode}\\n */\\nvar partition = function(head, x) {\\n    let left = [];\\n    let right = [];\\n    while(head){\\n        if(head.val < x){\\n            left.push(head.val);\\n        }else{\\n            right.push(head.val)\\n        }\\n        head = head.next;\\n    }\\n    \\n    head = null;\\n\\n    while(right.length !== 0){\\n        let node = new ListNode(right.pop());\\n        node.next = head;\\n        head = node;\\n    }\\n    while(left.length !== 0){\\n        let node = new ListNode(left.pop());\\n        node.next = head;\\n        head = node;\\n    }\\n    return head;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2971103,
                "title": "c-two-solutions",
                "content": "# Complexity:\\n- Time complexity: O(n)<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code 1: Without Space\\n```\\nclass Solution\\n{\\npublic:\\n    ListNode *partition(ListNode *head, int x)\\n    {\\n        ListNode *list1 = new ListNode(0);\\n        ListNode *list2 = new ListNode(0);\\n\\n        ListNode *l1 = list1;\\n        ListNode *l2 = list2;\\n\\n        while (head)\\n        {\\n            if (head->val < x)\\n            {\\n                l1->next = head;\\n                l1 = l1->next;\\n            }\\n\\n            else\\n            {\\n                l2->next = head;\\n                l2 = l2->next;\\n            }\\n\\n            head = head->next;\\n        }\\n\\n        l1->next = list2->next;\\n        l2->next = NULL;\\n\\n        return list1->next;\\n    }\\n};\\n```\\n# Complexity:\\n- Time complexity: O(2n)<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code 2: With Space\\n```\\nclass Solution\\n{\\npublic:\\n    ListNode *partition(ListNode *head, int x)\\n    {\\n        vector<int> left;\\n        vector<int> right;\\n        ListNode *temp = head;\\n\\n        while (temp)\\n        {\\n            if (temp->val < x)\\n                left.push_back(temp->val);\\n\\n            else\\n                right.push_back(temp->val);\\n\\n            temp = temp->next;\\n        }\\n\\n        ListNode *node = new ListNode();\\n        ListNode *t = node;\\n\\n        for (auto i : left)\\n        {\\n            node->next = new ListNode(i);\\n            node = node->next;\\n        }\\n\\n        for (auto i : right)\\n        {\\n            node->next = new ListNode(i);\\n            node = node->next;\\n        }\\n\\n        return t->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    ListNode *partition(ListNode *head, int x)\\n    {\\n        ListNode *list1 = new ListNode(0);\\n        ListNode *list2 = new ListNode(0);\\n\\n        ListNode *l1 = list1;\\n        ListNode *l2 = list2;\\n\\n        while (head)\\n        {\\n            if (head->val < x)\\n            {\\n                l1->next = head;\\n                l1 = l1->next;\\n            }\\n\\n            else\\n            {\\n                l2->next = head;\\n                l2 = l2->next;\\n            }\\n\\n            head = head->next;\\n        }\\n\\n        l1->next = list2->next;\\n        l2->next = NULL;\\n\\n        return list1->next;\\n    }\\n};\\n```\n```\\nclass Solution\\n{\\npublic:\\n    ListNode *partition(ListNode *head, int x)\\n    {\\n        vector<int> left;\\n        vector<int> right;\\n        ListNode *temp = head;\\n\\n        while (temp)\\n        {\\n            if (temp->val < x)\\n                left.push_back(temp->val);\\n\\n            else\\n                right.push_back(temp->val);\\n\\n            temp = temp->next;\\n        }\\n\\n        ListNode *node = new ListNode();\\n        ListNode *t = node;\\n\\n        for (auto i : left)\\n        {\\n            node->next = new ListNode(i);\\n            node = node->next;\\n        }\\n\\n        for (auto i : right)\\n        {\\n            node->next = new ListNode(i);\\n            node = node->next;\\n        }\\n\\n        return t->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2320001,
                "title": "java-c-solution-explained-tc-o-n-sc-o-1-100",
                "content": "```\\nLeft will have values smaller then x & Right will have value greater or equal to x.\\n```\\n\\n\\n```\\n     /* \\n     2 seprate linkedLists there by preserving the order in which they appear in the original list \\n     after creating 2 different partition of 2 LL \\n     we have to combine 2 sub LL to create resultant LL\\n     */\\n```\\n```\\nSo, to do that. Create 2 sublists.\\n\\nsmaller dummy linked list\\nhigher dummy linked list\\nsmaller LL will have values smaller then x & higher LL will have value greater or equal to x.\\n```\\n\\n```\\nclass Solution {\\n    public ListNode partition(ListNode head, int x) {\\n        ListNode smaller =new ListNode(Integer.MIN_VALUE);\\n        ListNode higher  =new ListNode(Integer.MIN_VALUE);\\n        \\n        ListNode smallHead=smaller ;\\n        ListNode highHead = higher;\\n        \\n        while(head!=null){\\n            if(head.val<x){\\n\\t\\t\\t\\n                //1 partition which are lesser than x value \\n                //smaller list\\n                smallHead.next=head;\\n                smallHead=smallHead.next;\\n                \\n            }\\n            else{\\n\\t\\t\\t\\n                //2 partition >= x\\n                //higher list\\n                highHead.next=head;\\n                highHead=highHead.next;\\n            }\\n            head=head.next;\\n        }\\n```\\n\\t\\t\\n```\\nwe have seperated the list\\'s as per the questions, our final job is to merge them into one list.\\n\\nSo, to do that , tecnically smaller list end i.e. 2 is pointing to null and higher list \\nend i.e.\\n\\n5 pointing to 2. But we want 2 to point to the beginning of higher list not null.\\nthats why we already created a infine[never ending] loop. \\n\\n```\\n\\n```\\n\\t\\t\\n        highHead.next=null;   // higher Lists\\'s last node now pointing to null\\n        smallHead.next=higher.next;     //small\\'s last node pointing to first node of higher node\\n        return smaller.next;\\n    }\\n\\n}\\n```\\nCPP Solution\\nhttps://leetcode.com/problems/partition-list/discuss/2320042/Java-C%2B%2B-Solution-Explained-TC-O(N)-SC-O(1)-100\\n",
                "solutionTags": [],
                "code": "```\\nLeft will have values smaller then x & Right will have value greater or equal to x.\\n```\n```\\n     /* \\n     2 seprate linkedLists there by preserving the order in which they appear in the original list \\n     after creating 2 different partition of 2 LL \\n     we have to combine 2 sub LL to create resultant LL\\n     */\\n```\n```\\nSo, to do that. Create 2 sublists.\\n\\nsmaller dummy linked list\\nhigher dummy linked list\\nsmaller LL will have values smaller then x & higher LL will have value greater or equal to x.\\n```\n```\\nclass Solution {\\n    public ListNode partition(ListNode head, int x) {\\n        ListNode smaller =new ListNode(Integer.MIN_VALUE);\\n        ListNode higher  =new ListNode(Integer.MIN_VALUE);\\n        \\n        ListNode smallHead=smaller ;\\n        ListNode highHead = higher;\\n        \\n        while(head!=null){\\n            if(head.val<x){\\n\\t\\t\\t\\n                //1 partition which are lesser than x value \\n                //smaller list\\n                smallHead.next=head;\\n                smallHead=smallHead.next;\\n                \\n            }\\n            else{\\n\\t\\t\\t\\n                //2 partition >= x\\n                //higher list\\n                highHead.next=head;\\n                highHead=highHead.next;\\n            }\\n            head=head.next;\\n        }\\n```\n```\\nwe have seperated the list\\'s as per the questions, our final job is to merge them into one list.\\n\\nSo, to do that , tecnically smaller list end i.e. 2 is pointing to null and higher list \\nend i.e.\\n\\n5 pointing to 2. But we want 2 to point to the beginning of higher list not null.\\nthats why we already created a infine[never ending] loop. \\n\\n```\n```\\n\\t\\t\\n        highHead.next=null;   // higher Lists\\'s last node now pointing to null\\n        smallHead.next=higher.next;     //small\\'s last node pointing to first node of higher node\\n        return smaller.next;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2318859,
                "title": "c-easy-to-understand-commented-fully-explained-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n    //we will make two list list1 contain element lesser than x and list two contain element bigger than x\\n        //and after that put list 2 in list1->next\\n        ListNode*list1=new ListNode(0);  //initially  given 0 to list 1\\n        ListNode*list2=new ListNode(0);  //initially  given 0 to list 2\\n        \\n        ListNode*l1=list1; //l1=0 initially\\n        ListNode*l2=list2;  //l2=0  initially\\n        \\n        while(head){  //while head!=null ITERATE OVER THE ll\\n            if(head->val<x){   //IF val of head <x \\n                l1->next=head;  //put head in l1->next   0->1->2->2->NULL\\n                l1=l1->next; //move next of l1\\n            }\\n            else{  //if head->val not less than x \\n                l2->next=head;  //put in l2->next      0->4->3->5->NULL     \\n                l2=l2->next;   //move l2->next\\n            }\\n            \\n            head=head->next; //iterating over the ll\\n        }\\n        l1->next=list2->next;  //first element of list2 is 0 so we have to put 4 3 5 so putting next of list2\\n        l2->next=NULL; \\n        return list1->next;  // return  1->2->2->4 >2->5->NULL  so we call next of list1\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n    //we will make two list list1 contain element lesser than x and list two contain element bigger than x\\n        //and after that put list 2 in list1->next\\n        ListNode*list1=new ListNode(0);  //initially  given 0 to list 1\\n        ListNode*list2=new ListNode(0);  //initially  given 0 to list 2\\n        \\n        ListNode*l1=list1; //l1=0 initially\\n        ListNode*l2=list2;  //l2=0  initially\\n        \\n        while(head){  //while head!=null ITERATE OVER THE ll\\n            if(head->val<x){   //IF val of head <x \\n                l1->next=head;  //put head in l1->next   0->1->2->2->NULL\\n                l1=l1->next; //move next of l1\\n            }\\n            else{  //if head->val not less than x \\n                l2->next=head;  //put in l2->next      0->4->3->5->NULL     \\n                l2=l2->next;   //move l2->next\\n            }\\n            \\n            head=head->next; //iterating over the ll\\n        }\\n        l1->next=list2->next;  //first element of list2 is 0 so we have to put 4 3 5 so putting next of list2\\n        l2->next=NULL; \\n        return list1->next;  // return  1->2->2->4 >2->5->NULL  so we call next of list1\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2316652,
                "title": "easy-to-code",
                "content": "```\\nclass Solution {\\n\\tpublic ListNode partition(ListNode head, int x) {\\n\\t\\tListNode temp1 = new ListNode(0);\\n\\t\\tListNode temp2 = new ListNode(0);\\n\\t\\ttemp1.next = head;\\n\\n\\t\\tListNode first = temp1;\\n\\t\\tListNode second = temp2;\\n\\t\\tListNode curr = head;\\n\\n\\t\\twhile (curr != null) {\\n\\t\\t\\tListNode temp = curr.next;\\n\\t\\t\\tif (curr.val < x) {\\n\\t\\t\\t\\tfirst.next = curr;\\n\\t\\t\\t\\tfirst = curr;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tsecond.next = curr;\\n\\t\\t\\t\\tsecond = curr;\\n\\t\\t\\t\\tsecond.next = null;\\n\\t\\t\\t}\\n\\t\\t\\tcurr = temp;\\n\\t\\t}\\n\\t\\tfirst.next = temp2.next;\\n\\t\\treturn temp1.next;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\tpublic ListNode partition(ListNode head, int x) {\\n\\t\\tListNode temp1 = new ListNode(0);\\n\\t\\tListNode temp2 = new ListNode(0);\\n\\t\\ttemp1.next = head;\\n\\n\\t\\tListNode first = temp1;\\n\\t\\tListNode second = temp2;\\n\\t\\tListNode curr = head;\\n\\n\\t\\twhile (curr != null) {\\n\\t\\t\\tListNode temp = curr.next;\\n\\t\\t\\tif (curr.val < x) {\\n\\t\\t\\t\\tfirst.next = curr;\\n\\t\\t\\t\\tfirst = curr;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tsecond.next = curr;\\n\\t\\t\\t\\tsecond = curr;\\n\\t\\t\\t\\tsecond.next = null;\\n\\t\\t\\t}\\n\\t\\t\\tcurr = temp;\\n\\t\\t}\\n\\t\\tfirst.next = temp2.next;\\n\\t\\treturn temp1.next;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2316244,
                "title": "python-linear-time-three-steps-with-explanation",
                "content": "PYTHON | Linear Time | Three Steps | With Explanation\\n\\n* Step-1: Before and after are the two pointers used to create two list, before_head and after_head are used to save the heads of the two lists. All of these are initialized with the dummy nodes created.\\n* Step-2: Iterate through the Linked List.\\nIf the original list node is lesser than the given x, assign it to the before list, else if the original list node is greater or equal to the given x, assign it to the after list.\\n* Step-3: Once all the nodes are correctly assigned to the two lists, combine them to form a single list which would be returned.\\n\\nCode:               \\n```\\ndef partition( head: Optional[ListNode], x: int) -> Optional[ListNode]:\\n\\n        # Step-1\\n        before = before_head = ListNode(0)\\n        after = after_head = ListNode(0)\\n\\n\\t    # Step-2\\n        while head:\\n            if head.val < x:\\n                before.next = head\\n                before = before.next\\n            else:\\n                after.next = head\\n                after = after.next\\n            head = head.next\\n\\t\\t\\n\\t\\t# Step-3\\n        # Last node of \"after\" list would also be ending node of the reformed list\\n        after.next = None\\n        # combine the nodes to form a single list which would be returned.\\n        before.next = after_head.next\\n\\t\\t\\n\\t\\t# Lastly,\\n\\t\\t# return the final head of the Linked List\\n        return before_head.next\\n```\\n\\n*Complexity Analysis\\nTime Complexity: O(N); N is the number of nodes in the original linked list and we iterate the original list.\\nSpace Complexity: O(1); we have not utilized any extra space, the point to note is that we are reforming the original list, by moving the original nodes, we have not used any extra space as such.\\n\\np.s:- you can also have a look at the alternative solution, which might be a little easier to understand for Beginners [here](https://leetcode.com/problems/partition-list/discuss/2316178/PYTHON-or-For-Beginners-or-With-Explanation-or-Linear-Time).\\n\\n*The only difference is that in the above solution, we are playing with the nodes directly, and reforming the original list, whereas in the alternate solution, we are forming a new LinkedList.\\nTherefore, the Time-Complexity remains the same for both the solutions, but the Space-Complexity is Constant here, whereas it is Linear in the alternative one.*",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef partition( head: Optional[ListNode], x: int) -> Optional[ListNode]:\\n\\n        # Step-1\\n        before = before_head = ListNode(0)\\n        after = after_head = ListNode(0)\\n\\n\\t    # Step-2\\n        while head:\\n            if head.val < x:\\n                before.next = head\\n                before = before.next\\n            else:\\n                after.next = head\\n                after = after.next\\n            head = head.next\\n\\t\\t\\n\\t\\t# Step-3\\n        # Last node of \"after\" list would also be ending node of the reformed list\\n        after.next = None\\n        # combine the nodes to form a single list which would be returned.\\n        before.next = after_head.next\\n\\t\\t\\n\\t\\t# Lastly,\\n\\t\\t# return the final head of the Linked List\\n        return before_head.next\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2315450,
                "title": "python3-easy-clean-code-explained",
                "content": "```\\nclass Solution:\\n    def partition(self, head: Optional[ListNode], x: int) -> Optional[ListNode]:\\n        \\n        temp=[]                             # to store the values in temp\\n        curr = head\\n        while curr:\\n            temp.append(curr.val)\\n            curr = curr.next\\n        \\n        # check and replace the values which are < x and mark used values as -1e9\\n        curr = head\\n        for i in range(len(temp)):\\n            if temp[i] < x:\\n                curr.val = temp[i]\\n                curr = curr.next\\n                temp[i] = -1e9\\n        \\n        \\n        # remaining unused values can be replaced in list\\n        for e in temp:\\n            if e != -1e9:\\n                curr.val = e\\n                curr = curr.next\\n        \\n        return head\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def partition(self, head: Optional[ListNode], x: int) -> Optional[ListNode]:\\n        \\n        temp=[]                             # to store the values in temp\\n        curr = head\\n        while curr:\\n            temp.append(curr.val)\\n            curr = curr.next\\n        \\n        # check and replace the values which are < x and mark used values as -1e9\\n        curr = head\\n        for i in range(len(temp)):\\n            if temp[i] < x:\\n                curr.val = temp[i]\\n                curr = curr.next\\n                temp[i] = -1e9\\n        \\n        \\n        # remaining unused values can be replaced in list\\n        for e in temp:\\n            if e != -1e9:\\n                curr.val = e\\n                curr = curr.next\\n        \\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2315339,
                "title": "python3-14-lines-w-explanation-t-m-99-56",
                "content": "Here\\'s a linked list with k for the sake of example:\\n```\\n                     -1-> 4-> 3-> 2-> 5 -> 2, k = 3\\n```               \\n\\nHere\\'s the plan:\\n1. We initialize two linked lists, one for each node for which `node.val` is less than `k` and another for each node for which `node.val` is not less than `k`.\\n    \\n1. We traverse the given linked list, and append each node to its appropriate  `more` or `less` list. In our example,\\n```\\n                    less: 1-> 2-> 2       more: 3->5\\n```   \\n3. We attach more to less. In our example,\\n```\\n                        less = 1-> 2-> 2-> 3-> 5\\n```\\n4. We return joined list \\n```\\nclass Solution:    \\n    def partition(self, head: ListNode, k: int) -> ListNode:\\n    \\n        if not head: return None           \\n        less, more = ListNode(), ListNode()         # <-- 1\\n        lNode, mNode = less, more\\n        \\n        while head :                                # <-- 2                 \\n            if head.val < k :\\n                lNode.next = head\\n                lNode = lNode.next\\n            else:\\n                mNode.next = head\\n                mNode = mNode.next\\n            head=head.next\\n\\n        lNode.next, mNode.next = more.next, None    # <-- 3\\n\\n        return less.next                            # <-- 4\\n```\\n[https://leetcode.com/problems/partition-list/submissions/1021575874/](http://)\\n\\n\\n\\nI could be wrong, but I think that time complexity is *O*(*N*) and space complexity is *O*(1), in which *N* ~ the numer of nodes in the list`.\\n\\'\\'\\'",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n                     -1-> 4-> 3-> 2-> 5 -> 2, k = 3\\n```\n```\\n                    less: 1-> 2-> 2       more: 3->5\\n```\n```\\n                        less = 1-> 2-> 2-> 3-> 5\\n```\n```\\nclass Solution:    \\n    def partition(self, head: ListNode, k: int) -> ListNode:\\n    \\n        if not head: return None           \\n        less, more = ListNode(), ListNode()         # <-- 1\\n        lNode, mNode = less, more\\n        \\n        while head :                                # <-- 2                 \\n            if head.val < k :\\n                lNode.next = head\\n                lNode = lNode.next\\n            else:\\n                mNode.next = head\\n                mNode = mNode.next\\n            head=head.next\\n\\n        lNode.next, mNode.next = more.next, None    # <-- 3\\n\\n        return less.next                            # <-- 4\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2315214,
                "title": "o-1-space-c-easy-solution",
                "content": "class Solution {\\npublic:\\n\\nListNode* partition(ListNode* head, int x) {\\n\\n    if(head == NULL) return head;\\n    \\n    ListNode* temp = head;\\n    ListNode* list1 = NULL;\\n    ListNode* list2 = NULL;\\n    ListNode* head1 = NULL;\\n    ListNode* head2 = NULL;\\n    \\n    while(temp != NULL){\\n        \\n        if(temp->val < x){\\n            \\n            if(head1 == NULL){\\n                head1 = temp;\\n                list1 = temp;\\n            }\\n            else{\\n                list1->next = temp;\\n                list1 = list1->next;\\n            }\\n            \\n        }\\n        else{\\n            \\n            \\n            if(head2 == NULL){\\n                head2 = temp;\\n                list2 = temp;\\n            }\\n            else{\\n                list2->next = temp;\\n                list2 = list2->next;\\n            }\\n            \\n        }\\n        \\n        \\n        temp = temp->next;\\n    }\\n    \\n    \\n    if(head1 == NULL) return head2;\\n    \\n    list1->next = NULL;\\n    \\n    if(list2 != NULL ) list2->next = NULL;\\n    \\n    list1->next = head2;\\n    \\n    return head1;\\n}\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\nListNode* partition(ListNode* head, int x) {\\n\\n    if(head == NULL) return head;\\n    \\n    ListNode* temp = head;\\n    ListNode* list1 = NULL;\\n    ListNode* list2 = NULL;\\n    ListNode* head1 = NULL;\\n    ListNode* head2 = NULL;\\n    \\n    while(temp != NULL){\\n        \\n        if(temp->val < x){\\n            \\n            if(head1 == NULL){\\n                head1 = temp;\\n                list1 = temp;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2315209,
                "title": "partition-list-basic-to-be-used-when-in-some-oa-coding-contest",
                "content": "Solution : Initially I had thought of using a vector of nodes,could have been solved that way too.But when someone is under time pressure, these solutions come handy.\\n   ```/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode* curr=head;\\n        vector< int > v1;\\n        vector< int >  v2;\\n        while(curr!=NULL){\\n            if(curr->val>=x)\\n                v1.push_back(curr->val);\\n            else\\n                v2.push_back(curr->val);\\n            curr=curr->next;\\n        }\\n        curr=head;\\n        for(int i=0;i < v2.size();i++){\\n            curr->val=v2[i];\\n            curr=curr->next;\\n        }\\n        for(int i=0;i < v1.size();i++){\\n            curr->val=v1[i];\\n            curr=curr->next;\\n        }\\n        return head;\\n       \\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode* curr=head;\\n        vector< int > v1;\\n        vector< int >  v2;\\n        while(curr!=NULL){\\n            if(curr->val>=x)\\n                v1.push_back(curr->val);\\n            else\\n                v2.push_back(curr->val);\\n            curr=curr->next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1947124,
                "title": "python3-simple-to-understand-o-1-space",
                "content": "```\\nclass Solution:\\n    def partition(self, head: Optional[ListNode], x: int) -> Optional[ListNode]:\\n        h1=l1=ListNode(0)\\n        h2=l2=ListNode(0)\\n        while head:\\n            if head.val<x:\\n                l1.next=head\\n                l1=l1.next\\n            else:\\n                l2.next=head\\n                l2=l2.next\\n            head=head.next\\n        l2.next=None\\n        l1.next=h2.next\\n        return h1.next\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def partition(self, head: Optional[ListNode], x: int) -> Optional[ListNode]:\\n        h1=l1=ListNode(0)\\n        h2=l2=ListNode(0)\\n        while head:\\n            if head.val<x:\\n                l1.next=head\\n                l1=l1.next\\n            else:\\n                l2.next=head\\n                l2=l2.next\\n            head=head.next\\n        l2.next=None\\n        l1.next=h2.next\\n        return h1.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1636573,
                "title": "c-o-n-time-and-o-1-space-solution-very-simple-logic",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        //special cases for length = 0,1 and 2\\n        if(!head) return head;\\n        if(!head->next) return head;\\n        if(!head->next->next){\\n            if(head->val>=x and head->next->val<x){\\n                ListNode* temp=head->next;\\n                head->next->next=head;\\n                head->next=NULL;\\n                head = temp;\\n                return head;\\n            }\\n            else return head;\\n        }\\n        \\n        ListNode* p1=head;\\n        ListNode* p2=head->next;\\n        ListNode* tail=head;\\n        int n=1;\\n        while(tail->next){\\n            n++;\\n            tail=tail->next;\\n        }\\n        //cout<<tail->val<<\" \"<<n;\\n        \\n        \\n        for(int i=1; i<n; i++){\\n            if(head->val>=x){\\n                //1st node should be sent to last node\\n                p1=p2; p2=p2->next;\\n                tail->next=head;\\n                tail=tail->next;\\n                head->next=NULL;\\n                head=p1;\\n            }\\n            else if(p2->val>=x){\\n                //those values >= x go to the last of the list one by one to maintain their order\\n                tail->next=p2;\\n                p1->next=p2->next;\\n                p2->next=NULL;\\n                tail=tail->next;\\n                p2=p1->next;\\n            }\\n            else {\\n                p1=p1->next; p2=p2->next; //going to next node\\n            }\\n        }\\n        //we have to run 1 more iteration if all val >= x\\n        if(head->val>=x){\\n            ListNode* temp = head->next;\\n            tail->next=head;\\n            head->next=NULL;\\n            tail=tail->next; //unnecessary\\n            head=temp;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        //special cases for length = 0,1 and 2\\n        if(!head) return head;\\n        if(!head->next) return head;\\n        if(!head->next->next){\\n            if(head->val>=x and head->next->val<x){\\n                ListNode* temp=head->next;\\n                head->next->next=head;\\n                head->next=NULL;\\n                head = temp;\\n                return head;\\n            }\\n            else return head;\\n        }\\n        \\n        ListNode* p1=head;\\n        ListNode* p2=head->next;\\n        ListNode* tail=head;\\n        int n=1;\\n        while(tail->next){\\n            n++;\\n            tail=tail->next;\\n        }\\n        //cout<<tail->val<<\" \"<<n;\\n        \\n        \\n        for(int i=1; i<n; i++){\\n            if(head->val>=x){\\n                //1st node should be sent to last node\\n                p1=p2; p2=p2->next;\\n                tail->next=head;\\n                tail=tail->next;\\n                head->next=NULL;\\n                head=p1;\\n            }\\n            else if(p2->val>=x){\\n                //those values >= x go to the last of the list one by one to maintain their order\\n                tail->next=p2;\\n                p1->next=p2->next;\\n                p2->next=NULL;\\n                tail=tail->next;\\n                p2=p1->next;\\n            }\\n            else {\\n                p1=p1->next; p2=p2->next; //going to next node\\n            }\\n        }\\n        //we have to run 1 more iteration if all val >= x\\n        if(head->val>=x){\\n            ListNode* temp = head->next;\\n            tail->next=head;\\n            head->next=NULL;\\n            tail=tail->next; //unnecessary\\n            head=temp;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1473271,
                "title": "easy-to-understand-c-short-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* curr, int x) {\\n        ListNode *dummy1 = new ListNode(-1);\\n        ListNode *dummy2 = new ListNode(-1);;\\n        \\n        ListNode *h2 = dummy2, *h1 = dummy1;\\n        \\n        while(curr) {\\n            if(curr->val < x) {\\n                dummy1->next = curr;\\n                dummy1 = dummy1->next;\\n            }\\n            else {\\n                dummy2->next = curr;\\n                dummy2 = dummy2->next;\\n            }\\n            curr = curr->next;\\n        }\\n        \\n        \\n        dummy1->next = h2->next;\\n        dummy2->next = NULL;\\n        \\n        return h1->next;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* curr, int x) {\\n        ListNode *dummy1 = new ListNode(-1);\\n        ListNode *dummy2 = new ListNode(-1);;\\n        \\n        ListNode *h2 = dummy2, *h1 = dummy1;\\n        \\n        while(curr) {\\n            if(curr->val < x) {\\n                dummy1->next = curr;\\n                dummy1 = dummy1->next;\\n            }\\n            else {\\n                dummy2->next = curr;\\n                dummy2 = dummy2->next;\\n            }\\n            curr = curr->next;\\n        }\\n        \\n        \\n        dummy1->next = h2->next;\\n        dummy2->next = NULL;\\n        \\n        return h1->next;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1299805,
                "title": "c-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode* left = new ListNode(0);\\n         ListNode* right = new ListNode(0);\\n         ListNode* ltail = left;\\n         ListNode* rtail = right;\\nwhile(head != NULL){\\n           if(head->val < x ){\\n                 ltail->next = head;\\n                 ltail = ltail->next;\\n            }else{\\n              rtail->next = head;\\n              rtail = rtail->next;\\n            }\\n           head= head->next;\\n      }\\n           ltail->next= right->next;  \\n           rtail->next = NULL;\\nreturn left->next;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode* left = new ListNode(0);\\n         ListNode* right = new ListNode(0);\\n         ListNode* ltail = left;\\n         ListNode* rtail = right;\\nwhile(head != NULL){\\n           if(head->val < x ){\\n                 ltail->next = head;\\n                 ltail = ltail->next;\\n            }else{\\n              rtail->next = head;\\n              rtail = rtail->next;\\n            }\\n           head= head->next;\\n      }\\n           ltail->next= right->next;  \\n           rtail->next = NULL;\\nreturn left->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1243649,
                "title": "very-simple-and-understandable-java-soln",
                "content": "```\\nclass Solution {\\n    public ListNode partition(ListNode head, int x) {\\n        if(head == null || head.next == null)\\n            return head;\\n        \\n        ListNode small = new ListNode(-1);\\n        ListNode greater = new ListNode(-1);\\n        ListNode sp = small, gp =greater, cur = head;\\n        while(cur != null){\\n            if(cur.val < x){\\n                sp.next = cur;\\n                sp = sp.next;\\n            }\\n            else{\\n                gp.next = cur;\\n                gp = gp.next;\\n            }\\n            cur = cur.next;\\n        }\\n        sp.next = greater.next;\\n        gp.next = null;\\n        \\n        head = small.next;\\n        small = greater = null; //Not necessary to do this\\n        return head;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public ListNode partition(ListNode head, int x) {\\n        if(head == null || head.next == null)\\n            return head;\\n        \\n        ListNode small = new ListNode(-1);\\n        ListNode greater = new ListNode(-1);\\n        ListNode sp = small, gp =greater, cur = head;\\n        while(cur != null){\\n            if(cur.val < x){\\n                sp.next = cur;\\n                sp = sp.next;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1157838,
                "title": "partition-list-simple-solution-easy-to-understand-explained",
                "content": "The main idea is, Keep track of node that is greater than equal to `x`, whenever we find a node that has lesser value than `x`, we shift the value and and increment the pointer.\\nwe have two cases,\\n->` node->val >= x`: In this case, we have to do nothing. \\n-> `node->val < x` : In this case we need replace our value before the nodes that has greater value than x.Our pointer `cur` represents the node that has greater value than `x`. So, we initialize a duplicate pointer. and shift the value until `dup` reaches the temp. At last we update the `cur`.\\n\\n**Do upvote** if you like the code !!\\n```\\nListNode* partition(ListNode* head, int x) {\\n        if(head == NULL || head->next == NULL) return head;\\n        ListNode* temp = head, *cur = head;\\n        while(temp){\\n            if(temp->val < x){\\n                int value = temp->val;\\n                ListNode* dup = cur;\\n                while(dup){\\n                    int y = dup->val;\\n                    dup->val = value;\\n                    value = y;\\n                    if(dup == temp) break;\\n                    dup=dup->next;\\n                }\\n                cur = cur->next;\\n            }\\n            temp = temp->next;\\n        }\\n        return head;\\n    }\\n```\\nAny other ways to solve ?? Comment down below !!",
                "solutionTags": [],
                "code": "```\\nListNode* partition(ListNode* head, int x) {\\n        if(head == NULL || head->next == NULL) return head;\\n        ListNode* temp = head, *cur = head;\\n        while(temp){\\n            if(temp->val < x){\\n                int value = temp->val;\\n                ListNode* dup = cur;\\n                while(dup){\\n                    int y = dup->val;\\n                    dup->val = value;\\n                    value = y;\\n                    if(dup == temp) break;\\n                    dup=dup->next;\\n                }\\n                cur = cur->next;\\n            }\\n            temp = temp->next;\\n        }\\n        return head;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 826370,
                "title": "rust-safe-time-complexity-o-n-space-complexity-o-1-0ms-2mb",
                "content": "```\\n// Definition for singly-linked list.\\n// #[derive(PartialEq, Eq, Clone, Debug)]\\n// pub struct ListNode {\\n//   pub val: i32,\\n//   pub next: Option<Box<ListNode>>\\n// }\\n// \\n// impl ListNode {\\n//   #[inline]\\n//   fn new(val: i32) -> Self {\\n//     ListNode {\\n//       next: None,\\n//       val\\n//     }\\n//   }\\n// }\\nimpl Solution {\\n    pub fn partition(mut head: Option<Box<ListNode>>, x: i32) -> Option<Box<ListNode>> {\\n        if head.is_none() {\\n            return head;\\n        }\\n\\n        // before and after are the two pointers used to create the two list\\n        // before_head and after_head are used to save the heads of the two lists.\\n        // All of these are initialized with the dummy nodes created.\\n        let mut before_head = Box::new(ListNode {\\n            val: -1,\\n            next: None,\\n        });\\n        let mut after_head = Box::new(ListNode::new(-1));\\n\\n        let mut before = &mut before_head;\\n        let mut after = &mut after_head;\\n        while let Some(mut node) = head {\\n            // If the original list node is lesser than the given x,\\n            // assign it to the before list.\\n            if node.val < x {\\n                // move ahead in the original list\\n                head = node.next.take();\\n                before.next = Some(node);\\n                before = before.next.as_mut().unwrap();\\n            } else {\\n                // move ahead in the original list\\n                head = node.next.take();\\n                // If the original list node is greater or equal to the given x,\\n                // assign it to the after list.\\n                after.next = Some(node);\\n                after = after.next.as_mut().unwrap();\\n            }\\n        }\\n        after.next = None;\\n\\n        // Once all the nodes are correctly assigned to the two lists,\\n        // combine them to form a single list which would be returned.\\n        before.next = after_head.next;\\n        before_head.next\\n    }\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// Definition for singly-linked list.\\n// #[derive(PartialEq, Eq, Clone, Debug)]\\n// pub struct ListNode {\\n//   pub val: i32,\\n//   pub next: Option<Box<ListNode>>\\n// }\\n// \\n// impl ListNode {\\n//   #[inline]\\n//   fn new(val: i32) -> Self {\\n//     ListNode {\\n//       next: None,\\n//       val\\n//     }\\n//   }\\n// }\\nimpl Solution {\\n    pub fn partition(mut head: Option<Box<ListNode>>, x: i32) -> Option<Box<ListNode>> {\\n        if head.is_none() {\\n            return head;\\n        }\\n\\n        // before and after are the two pointers used to create the two list\\n        // before_head and after_head are used to save the heads of the two lists.\\n        // All of these are initialized with the dummy nodes created.\\n        let mut before_head = Box::new(ListNode {\\n            val: -1,\\n            next: None,\\n        });\\n        let mut after_head = Box::new(ListNode::new(-1));\\n\\n        let mut before = &mut before_head;\\n        let mut after = &mut after_head;\\n        while let Some(mut node) = head {\\n            // If the original list node is lesser than the given x,\\n            // assign it to the before list.\\n            if node.val < x {\\n                // move ahead in the original list\\n                head = node.next.take();\\n                before.next = Some(node);\\n                before = before.next.as_mut().unwrap();\\n            } else {\\n                // move ahead in the original list\\n                head = node.next.take();\\n                // If the original list node is greater or equal to the given x,\\n                // assign it to the after list.\\n                after.next = Some(node);\\n                after = after.next.as_mut().unwrap();\\n            }\\n        }\\n        after.next = None;\\n\\n        // Once all the nodes are correctly assigned to the two lists,\\n        // combine them to form a single list which would be returned.\\n        before.next = after_head.next;\\n        before_head.next\\n    }\\n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 719013,
                "title": "rust-100-fast-solution",
                "content": "```rust\\nimpl Solution {\\n    pub fn partition(head: Option<Box<ListNode>>, x: i32) -> Option<Box<ListNode>> {\\n        if head.is_none() {\\n            return None;\\n        }\\n        let mut before_head = Some(Box::new(ListNode::new(0)));\\n        let mut after_head = Some(Box::new(ListNode::new(0)));\\n        let mut before = before_head.as_mut();\\n        let mut after = after_head.as_mut();\\n        let mut curr = head;\\n\\n        while let Some(node) = curr {\\n            if node.val < x {\\n                if let Some(b) = before {\\n                    b.next = Some(node.clone());\\n                    before = b.next.as_mut();\\n                }\\n            } else {\\n                if let Some(a) = after {\\n                    a.next = Some(node.clone());\\n                    after = a.next.as_mut();\\n                }\\n            }\\n            curr = node.next;\\n        }\\n        if let Some(a) = after {\\n            a.next = None;\\n        }\\n        if let Some(b) = before {\\n            b.next = after_head.unwrap().next;\\n        }\\n        before_head.unwrap().next\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\nimpl Solution {\\n    pub fn partition(head: Option<Box<ListNode>>, x: i32) -> Option<Box<ListNode>> {\\n        if head.is_none() {\\n            return None;\\n        }\\n        let mut before_head = Some(Box::new(ListNode::new(0)));\\n        let mut after_head = Some(Box::new(ListNode::new(0)));\\n        let mut before = before_head.as_mut();\\n        let mut after = after_head.as_mut();\\n        let mut curr = head;\\n\\n        while let Some(node) = curr {\\n            if node.val < x {\\n                if let Some(b) = before {\\n                    b.next = Some(node.clone());\\n                    before = b.next.as_mut();\\n                }\\n            } else {\\n                if let Some(a) = after {\\n                    a.next = Some(node.clone());\\n                    after = a.next.as_mut();\\n                }\\n            }\\n            curr = node.next;\\n        }\\n        if let Some(a) = after {\\n            a.next = None;\\n        }\\n        if let Some(b) = before {\\n            b.next = after_head.unwrap().next;\\n        }\\n        before_head.unwrap().next\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 466152,
                "title": "java-o-n-time-o-1-space-w-explanation",
                "content": "The idea is to create two separate lists that we will link together at the end.\\n\\nWe will create the ListNodes lessNodes (for nodes with a val < x) and grEqNodes (for nodes with a val >= x). Note that lessNodes and grEqNodes are initialized with dummy nodes of value 0. Additionally, lessHead and grEqHead initially point to these dummy nodes.\\n\\nWe set curr equal to head as our starting point.\\n\\nWe iterate through the list in a while loop, using curr to move forward along our list until curr equals null. If curr.val is less than x, we make lessNodes.next point to curr and move lessNodes forward. Else, we make grEqNodes.next point to curr and move greaterEqNodes forward.\\n\\nNow, we eliminate the dummy nodes we initially used. We link the lessNodes list to the node after grEqHead, since the first node is a placeholder. We then set the end of the grEqNodes list to null, thus terminating the list.\\n\\nWe return the node after lessHead, since the first node is a placeholder.\\n```\\nclass Solution {\\n    public ListNode partition(ListNode head, int x) {\\n        ListNode lessNodes = new ListNode(0);\\n        ListNode grEqNodes = new ListNode(0);\\n        \\n        ListNode lessHead = lessNodes;\\n        ListNode grEqHead = grEqNodes;\\n        \\n        ListNode curr = head;\\n        \\n        while(curr != null){\\n\\n            if(curr.val < x){\\n                lessNodes.next = curr;\\n                lessNodes = lessNodes.next;\\n            }\\n            else {\\n                grEqNodes.next = curr;\\n                grEqNodes = grEqNodes.next;\\n            }\\n            curr = curr.next;\\n        }\\n        \\n        lessNodes.next = grEqHead.next;\\n        grEqNodes.next = null;\\n        \\n        return lessHead.next;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode partition(ListNode head, int x) {\\n        ListNode lessNodes = new ListNode(0);\\n        ListNode grEqNodes = new ListNode(0);\\n        \\n        ListNode lessHead = lessNodes;\\n        ListNode grEqHead = grEqNodes;\\n        \\n        ListNode curr = head;\\n        \\n        while(curr != null){\\n\\n            if(curr.val < x){\\n                lessNodes.next = curr;\\n                lessNodes = lessNodes.next;\\n            }\\n            else {\\n                grEqNodes.next = curr;\\n                grEqNodes = grEqNodes.next;\\n            }\\n            curr = curr.next;\\n        }\\n        \\n        lessNodes.next = grEqHead.next;\\n        grEqNodes.next = null;\\n        \\n        return lessHead.next;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 287896,
                "title": "0ms-java-easy-to-understand-solution",
                "content": "Inline comments for explanation\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public ListNode partition(ListNode head, int x) {\\n        \\n        ListNode sList = new ListNode(0); //Dummy head for smaller elements list\\n        ListNode gList = new ListNode(0);//Dummy head for >= element list\\n        ListNode sptr = sList; //pointer for current element in sList\\n        ListNode gptr = gList; // pointer for current element in gList\\n        \\n        while(head !=null){\\n            if(head.val<x){\\n                //add element to first sList\\n                sptr.next = head;\\n                head = head.next;\\n                sptr = sptr.next;\\n                sptr.next = null;\\n                \\n            }else{\\n                //add element to larger element list\\n                gptr.next = head;\\n                head = head.next;\\n                gptr = gptr.next;\\n                gptr.next = null;\\n            }\\n        }\\n        //Merge both list joining last element for sList to first element of gList\\n        sptr.next = gList.next;\\n        return sList.next; \\n                \\n    }\\n        \\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public ListNode partition(ListNode head, int x) {\\n        \\n        ListNode sList = new ListNode(0); //Dummy head for smaller elements list\\n        ListNode gList = new ListNode(0);//Dummy head for >= element list\\n        ListNode sptr = sList; //pointer for current element in sList\\n        ListNode gptr = gList; // pointer for current element in gList\\n        \\n        while(head !=null){\\n            if(head.val<x){\\n                //add element to first sList\\n                sptr.next = head;\\n                head = head.next;\\n                sptr = sptr.next;\\n                sptr.next = null;\\n                \\n            }else{\\n                //add element to larger element list\\n                gptr.next = head;\\n                head = head.next;\\n                gptr = gptr.next;\\n                gptr.next = null;\\n            }\\n        }\\n        //Merge both list joining last element for sList to first element of gList\\n        sptr.next = gList.next;\\n        return sList.next; \\n                \\n    }\\n        \\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 155293,
                "title": "c-c-short-single-pass-iterative-solution-no-allocation-or-dummy-o-n-time-o-1-space",
                "content": "# TL;DR\\n**C++ solution**\\n```cpp\\n  ListNode* partition(ListNode* head, int x) {\\n    ListNode* larger = nullptr;\\n    ListNode** larger_next = &larger;\\n    ListNode** prev = &head;\\n    while (*prev) {\\n      if ((*prev)->val >= x) { // Node needs to be moved to greater list\\n        *larger_next = *prev;\\n        larger_next = &((*larger_next)->next);\\n        *prev = (*prev)->next;\\n      } else { // Node can be left in place\\n        prev = &((*prev)->next);\\n      }\\n    }\\n\\n    *larger_next = nullptr;\\n    *prev = larger; \\n    \\n    return head;\\n  }  \\n```\\n**C Solution**\\nBasically as the above c++ solution with a few syntax changes\\n```c\\nstruct ListNode* partition(struct ListNode* head, int x){\\n  struct ListNode* larger = NULL;\\n  struct ListNode** larger_next = &larger;\\n  struct ListNode** prev = &head;\\n  while (*prev) {\\n    if ((*prev)->val >= x) { /* Node needs to be moved to greater list */\\n      *larger_next = *prev;\\n      larger_next = &((*larger_next)->next);\\n      *prev = (*prev)->next;\\n    } else { /* Node can be left in place */\\n      prev = &((*prev)->next);\\n    }\\n  }\\n\\n  *larger_next = NULL;\\n  *prev = larger; \\n\\n  return head;\\n}\\n```\\n# Details\\nHold two pointers to pointers. One holds the previous node\\'s next pointer (or the _head_ pointer) and is advanced whenever the node is in the correct location. The other holds a list of those greater than or equal to _x_.\\n\\nProcess the list and if a node greater or equal to _x_ is encounted, move to the end of our _larger_ list. At the end, join the two lists back together and return the _head_. With a few more comments to help explain the pointer to pointer.\\n\\n```cpp\\n  ListNode* partition(ListNode* head, int x) {\\n    // Will hold the nodes greater than or equal to x\\t\\n    ListNode* larger = nullptr;\\n    ListNode** larger_next = &larger;\\n\\n    ListNode** prev = &head;\\n    while (*prev) {\\n      if ((*prev)->val >= x) {\\n        // Move the found node to the end of the list of larger nodes\\n        *larger_next = *prev;\\n        larger_next = &((*larger_next)->next);\\n        \\n        // Update the less than list to skip over the node we\\'ve moved\\n        *prev = (*prev)->next;\\n      } else {\\n        // Node is in the correct place, skip over it\\n        prev = &((*prev)->next);\\n      }\\n    }\\n    \\n    // Terminate the equal or larger than x list\\n    *larger_next = nullptr;\\n    \\n    // Attach those less than x to those greater than x\\n    *prev = larger; \\n    \\n    return head;\\n  }  \\n```\\n# Alternative\\nAn alternative approach that reduces the number of pointer updates could remove consecutive larger than nodes in a single update. Things like [2, 4, 5, 6, 7, 8, 1] with _x_ of 3 would move 4, 5, 6, 7, 8 in a single update.\\n```cpp\\n  ListNode* partition(ListNode* head, int x) {\\n    ListNode* larger = nullptr;\\n    ListNode** larger_next = &larger;\\n\\n    ListNode** prev = &head;\\n    while (*prev) {\\n      if ((*prev)->val >= x) {\\n        // Move the found node to the end of the list of larger nodes\\n        *larger_next = *prev;\\n        do {\\n          larger_next = &((*larger_next)->next);\\n        }\\n        while (*larger_next && (*larger_next)->val >= x);\\n        \\n        // Update the less than list to skip over the nodes we\\'ve \\'moved\\'\\n        *prev = *larger_next;\\n      } else {\\n        // Node is in correct place, skip over it\\n        prev = &((*prev)->next);\\n      }\\n    }\\n    \\n    // Terminate the equal or larger than x list\\n    *larger_next = nullptr;\\n    \\n    // Attach those less than x to those greater than x\\n    *prev = larger; \\n    \\n    return head;\\n  }\\n```\\t\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\n  ListNode* partition(ListNode* head, int x) {\\n    ListNode* larger = nullptr;\\n    ListNode** larger_next = &larger;\\n    ListNode** prev = &head;\\n    while (*prev) {\\n      if ((*prev)->val >= x) { // Node needs to be moved to greater list\\n        *larger_next = *prev;\\n        larger_next = &((*larger_next)->next);\\n        *prev = (*prev)->next;\\n      } else { // Node can be left in place\\n        prev = &((*prev)->next);\\n      }\\n    }\\n\\n    *larger_next = nullptr;\\n    *prev = larger; \\n    \\n    return head;\\n  }  \\n```\n```c\\nstruct ListNode* partition(struct ListNode* head, int x){\\n  struct ListNode* larger = NULL;\\n  struct ListNode** larger_next = &larger;\\n  struct ListNode** prev = &head;\\n  while (*prev) {\\n    if ((*prev)->val >= x) { /* Node needs to be moved to greater list */\\n      *larger_next = *prev;\\n      larger_next = &((*larger_next)->next);\\n      *prev = (*prev)->next;\\n    } else { /* Node can be left in place */\\n      prev = &((*prev)->next);\\n    }\\n  }\\n\\n  *larger_next = NULL;\\n  *prev = larger; \\n\\n  return head;\\n}\\n```\n```cpp\\n  ListNode* partition(ListNode* head, int x) {\\n    // Will hold the nodes greater than or equal to x\\t\\n    ListNode* larger = nullptr;\\n    ListNode** larger_next = &larger;\\n\\n    ListNode** prev = &head;\\n    while (*prev) {\\n      if ((*prev)->val >= x) {\\n        // Move the found node to the end of the list of larger nodes\\n        *larger_next = *prev;\\n        larger_next = &((*larger_next)->next);\\n        \\n        // Update the less than list to skip over the node we\\'ve moved\\n        *prev = (*prev)->next;\\n      } else {\\n        // Node is in the correct place, skip over it\\n        prev = &((*prev)->next);\\n      }\\n    }\\n    \\n    // Terminate the equal or larger than x list\\n    *larger_next = nullptr;\\n    \\n    // Attach those less than x to those greater than x\\n    *prev = larger; \\n    \\n    return head;\\n  }  \\n```\n```cpp\\n  ListNode* partition(ListNode* head, int x) {\\n    ListNode* larger = nullptr;\\n    ListNode** larger_next = &larger;\\n\\n    ListNode** prev = &head;\\n    while (*prev) {\\n      if ((*prev)->val >= x) {\\n        // Move the found node to the end of the list of larger nodes\\n        *larger_next = *prev;\\n        do {\\n          larger_next = &((*larger_next)->next);\\n        }\\n        while (*larger_next && (*larger_next)->val >= x);\\n        \\n        // Update the less than list to skip over the nodes we\\'ve \\'moved\\'\\n        *prev = *larger_next;\\n      } else {\\n        // Node is in correct place, skip over it\\n        prev = &((*prev)->next);\\n      }\\n    }\\n    \\n    // Terminate the equal or larger than x list\\n    *larger_next = nullptr;\\n    \\n    // Attach those less than x to those greater than x\\n    *prev = larger; \\n    \\n    return head;\\n  }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 29188,
                "title": "please-help-understand",
                "content": "can someone explain why the 4 isnt after the 3??\\n\\n```\\nGiven 1->4->3->2->5->2 and x = 3,\\nreturn 1->2->2->4->3->5.\\n```",
                "solutionTags": [],
                "code": "```\\nGiven 1->4->3->2->5->2 and x = 3,\\nreturn 1->2->2->4->3->5.\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 29269,
                "title": "java-concise-solution",
                "content": "        \\n    public ListNode partition(ListNode head, int x) {\\n        if (head == null || head.next == null) {\\n            return head;\\n        }\\n        ListNode head1, p1 = new ListNode(0), head2, p2 = new ListNode(0);\\n        head1 = p1;\\n        head2 = p2;\\n        while (head != null) {\\n            if (head.val < x) {\\n                p1.next = head;\\n                p1 = p1.next;\\n            } else {\\n                p2.next = head;\\n                p2 = p2.next;\\n            }\\n            head = head.next;\\n        }\\n        p2.next = null;\\n        p1.next = head2.next;\\n        return head1.next;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "        \\n    public ListNode partition(ListNode head, int x) {\\n        if (head == null || head.next == null) {\\n            return head;\\n        }\\n        ListNode head1, p1 = new ListNode(0), head2, p2 = new ListNode(0);\\n        head1 = p1;\\n        head2 = p2;\\n        while (head != null) {\\n            if (head.val < x) {\\n                p1.next = head;\\n                p1 = p1.next;\\n            } else {\\n                p2.next = head;\\n                p2 = p2.next;\\n            }\\n            head = head.next;\\n        }\\n        p2.next = null;\\n        p1.next = head2.next;\\n        return head1.next;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 29292,
                "title": "simple-c-solution",
                "content": "The idea is to keep adding the nodes to two different list which I have maintained it as head1 and head2.\\nHead1 list contains the value which are smaller than x and head 2 which has greater than or equal to x.\\ntemp1 and temp2 are used to keep track of the last element that has been added to the end . We traverse the given input list and keep changing the next pointer accordingly. At the end if there were no elements in head 1 we just return head2, otherwise we link the list head1(smaller elemets) to head2 and return head1\\n\\n\\n\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        \\n        if(head == NULL)\\n            return head;\\n            \\n        ListNode *head1=NULL,*temp1,*head2=NULL,*temp2;\\n        ListNode *curr=head;\\n        \\n        while(curr!=NULL){\\n            if(curr->val<x){\\n                //for the list with smaller than number\\n                if(head1 == NULL){\\n                    //checking condition if the first element of this list\\n                    head1=curr;\\n                    curr=curr->next;\\n                    temp1=head1;\\n                    \\n                }else{\\n                    temp1->next=curr;\\n                    curr=curr->next;\\n                    temp1=temp1->next;\\n                    }\\n                \\n            }else{\\n                //for the list with greater than or equal to number\\n                if(head2 == NULL){\\n                    //checking condition if the first element of this list\\n                    head2=curr;\\n                    curr=curr->next;\\n                    temp2=head2;\\n                    temp2->next=NULL;\\n                    \\n                }else{\\n                    temp2->next=curr;\\n                    curr=curr->next;\\n                    temp2=temp2->next;\\n                    temp2->next=NULL;\\n                }\\n                \\n            }\\n        }\\n        if(head1!=NULL ){\\n            temp1->next = head2;\\n            return head1;\\n        }else if(head2!=NULL){\\n              return head2;\\n        }\\n        \\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        \\n        if(head == NULL)\\n            return head;\\n            \\n        ListNode *head1=NULL,*temp1,*head2=NULL,*temp2;\\n        ListNode *curr=head;\\n        \\n        while(curr!=NULL){\\n            if(curr->val<x){\\n                //for the list with smaller than number\\n                if(head1 == NULL){\\n                    //checking condition if the first element of this list\\n                    head1=curr;\\n                    curr=curr->next;\\n                    temp1=head1;\\n                    \\n                }",
                "codeTag": "Java"
            },
            {
                "id": 29352,
                "title": "simple-python-solution-and-easy-to-understand",
                "content": "    def partition(self, head, x):\\n        if not head:\\n            return None\\n        dy = ListNode(0)\\n        dy.next = head\\n        a = dy\\n        while a.next and a.next.val < x:\\n            a = a.next\\n        b = a.next\\n        c = b\\n        while c and c.next:\\n            if c.next.val < x:\\n                d = c.next\\n                c.next = c.next.next\\n                a.next = d\\n                d.next = b\\n                a = d\\n            else:\\n                c = c.next\\n        return dy.next",
                "solutionTags": [],
                "code": "    def partition(self, head, x):\\n        if not head:\\n            return None\\n        dy = ListNode(0)\\n        dy.next = head\\n        a = dy\\n        while a.next and a.next.val < x:\\n            a = a.next\\n        b = a.next\\n        c = b\\n        while c and c.next:\\n            if c.next.val < x:\\n                d = c.next\\n                c.next = c.next.next\\n                a.next = d\\n                d.next = b\\n                a = d\\n            else:\\n                c = c.next\\n        return dy.next",
                "codeTag": "Python3"
            },
            {
                "id": 29377,
                "title": "my-accepted-solution-using-pointer-to-pointers",
                "content": "It looks as simple as i could think of. Going along our list, all nodes with a value less than x are appended to  list left, while nodes with a value greater than or equal to x are appended to list right. Finally join right to the tail of left and left is the answer.\\n\\n    ListNode *partition(ListNode *head, int x)\\n     {\\n            ListNode *left = NULL, *right = NULL, **p = &left, **q = &right, *entry = head;\\n    \\t\\n        \\twhile (entry) {\\n    \\t\\t    if (entry->val < x) {\\n    \\t\\t    \\t*p = entry; p = &(entry->next); entry = *p;\\n    \\t    \\t    }\\n    \\t    \\t    else {\\n    \\t\\t    \\t*q = entry; q = &(entry->next); entry = *q;\\n    \\t    \\t}\\n        \\t}\\n    \\t    *p = right; *q = NULL;\\n            return left;\\n     }",
                "solutionTags": [],
                "code": "It looks as simple as i could think of. Going along our list, all nodes with a value less than x are appended to  list left, while nodes with a value greater than or equal to x are appended to list right. Finally join right to the tail of left and left is the answer.\\n\\n    ListNode *partition(ListNode *head, int x)\\n     {\\n            ListNode *left = NULL, *right = NULL, **p = &left, **q = &right, *entry = head;\\n    \\t\\n        \\twhile (entry) {\\n    \\t\\t    if (entry->val < x) {\\n    \\t\\t    \\t*p = entry; p = &(entry->next); entry = *p;\\n    \\t    \\t    }\\n    \\t    \\t    else {\\n    \\t\\t    \\t*q = entry; q = &(entry->next); entry = *q;\\n    \\t    \\t}\\n        \\t}\\n    \\t    *p = right; *q = NULL;\\n            return left;\\n     }",
                "codeTag": "Unknown"
            },
            {
                "id": 29380,
                "title": "my-accepted-solution",
                "content": "Solution:\\n \\nKeep going along our list.  When we at node that greater or equal x, we remove this node from our list and move it to list of nodes greater than x.\\n\\nThen we need connect tail our list and list of nodes greater than x.\\n\\n    class Solution {\\n    public:\\n        ListNode *partition(ListNode *head, int x) {\\n            if (!head) return NULL;\\n            ListNode * iterator = head; \\n            \\n            ListNode * start = new ListNode(0); // list of nodes greater than x\\n            ListNode * tail = start;\\n            \\n            ListNode * newHead = new ListNode(0); \\n            newHead -> next = head;\\n            ListNode * pre = newHead; // previous node, we need it for removing\\n            \\n            \\n            while (iterator) {\\n                if (iterator -> val >= x) {\\n                    pre -> next = iterator -> next; // remove from our list\\n                    tail -> next = iterator; // add to list of nodes greater than x\\n                    tail = tail -> next;\\n                    iterator = iterator -> next;\\n                    tail -> next = NULL;\\n                }\\n                else\\n                    pre = iterator, iterator = iterator -> next;\\n            }\\n            pre -> next = start -> next;\\n            return newHead -> next;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        ListNode *partition(ListNode *head, int x) {\\n            if (!head) return NULL;\\n            ListNode * iterator = head; \\n            \\n            ListNode * start = new ListNode(0); // list of nodes greater than x\\n            ListNode * tail = start;\\n            \\n            ListNode * newHead = new ListNode(0); \\n            newHead -> next = head;\\n            ListNode * pre = newHead; // previous node, we need it for removing\\n            \\n            \\n            while (iterator) {\\n                if (iterator -> val >= x) {\\n                    pre -> next = iterator -> next; // remove from our list\\n                    tail -> next = iterator; // add to list of nodes greater than x\\n                    tail = tail -> next;\\n                    iterator = iterator -> next;\\n                    tail -> next = NULL;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 4022004,
                "title": "partition-list-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode* dummy1 = new ListNode();\\n        ListNode* temp1 = dummy1;\\n        ListNode* dummy2 = new ListNode();\\n        ListNode* temp2 = dummy2;\\n        while (head != NULL) {\\n            if (head->val < x) {\\n                temp1->next = head;\\n                temp1 = temp1->next;\\n            } else {\\n                temp2->next = head;\\n                temp2 = temp2->next;\\n            }\\n            head = head->next;\\n        }\\n        if (dummy1->next == NULL)\\n            return dummy2->next;\\n        temp1->next = dummy2->next;\\n        temp2->next = NULL;\\n        return dummy1->next;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode* dummy1 = new ListNode();\\n        ListNode* temp1 = dummy1;\\n        ListNode* dummy2 = new ListNode();\\n        ListNode* temp2 = dummy2;\\n        while (head != NULL) {\\n            if (head->val < x) {\\n                temp1->next = head;\\n                temp1 = temp1->next;\\n            } else {\\n                temp2->next = head;\\n                temp2 = temp2->next;\\n            }\\n            head = head->next;\\n        }\\n        if (dummy1->next == NULL)\\n            return dummy2->next;\\n        temp1->next = dummy2->next;\\n        temp2->next = NULL;\\n        return dummy1->next;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3913088,
                "title": "beats-99-memory",
                "content": "# Intuition\\nTo solve this problem, you can create two separate linked lists: one for nodes less than x and another for nodes greater than or equal to x. Traverse the original linked list and insert nodes into the appropriate partitions based on their values. Finally, connect the tail of the \"less than x\" partition to the head of the \"greater than or equal to x\" partition. \\n\\n# Approach\\nThis code creates two separate partitions for nodes less than x and nodes greater than or equal to x, then connects them together while preserving their relative order.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution(object):\\n    def partition(self, head, x):\\n        \"\"\"\\n        :type head: ListNode\\n        :type x: int\\n        :rtype: ListNode\\n        \"\"\"\\n        greater_than_x_head=ListNode()\\n        greater_than_x_tail=greater_than_x_head\\n        less_than_x_head=ListNode()\\n        less_than_x_tail=less_than_x_head\\n\\n        current=head\\n        while current:\\n            if current.val<x:\\n                less_than_x_tail.next=current\\n                less_than_x_tail= less_than_x_tail.next\\n            else:\\n                greater_than_x_tail.next=current\\n                greater_than_x_tail=greater_than_x_tail.next\\n            current=current.next\\n        greater_than_x_tail.next=None\\n        less_than_x_tail.next=greater_than_x_head.next\\n        return less_than_x_head.next\\n\\n        \\n\\n```\\n# **PLEASE DO UPVOTE!!!\\uD83E\\uDD79**",
                "solutionTags": [
                    "Python",
                    "Linked List"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution(object):\\n    def partition(self, head, x):\\n        \"\"\"\\n        :type head: ListNode\\n        :type x: int\\n        :rtype: ListNode\\n        \"\"\"\\n        greater_than_x_head=ListNode()\\n        greater_than_x_tail=greater_than_x_head\\n        less_than_x_head=ListNode()\\n        less_than_x_tail=less_than_x_head\\n\\n        current=head\\n        while current:\\n            if current.val<x:\\n                less_than_x_tail.next=current\\n                less_than_x_tail= less_than_x_tail.next\\n            else:\\n                greater_than_x_tail.next=current\\n                greater_than_x_tail=greater_than_x_tail.next\\n            current=current.next\\n        greater_than_x_tail.next=None\\n        less_than_x_tail.next=greater_than_x_head.next\\n        return less_than_x_head.next\\n\\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3912915,
                "title": "python-easy-solution",
                "content": "# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass ListNode:\\n    def __init__(self, val=0, next=None):\\n        self.val = val\\n        self.next = next\\n\\nclass Solution:\\n    def partition(self, head: Optional[ListNode], x: int) -> Optional[ListNode]:\\n    \\n        before_x = ListNode(0)\\n        after_x = ListNode(0)\\n        \\n        before = before_x\\n        after = after_x\\n        \\n        current = head\\n        while current:\\n            if current.val < x:\\n                before.next = current\\n                before = before.next\\n            else:\\n                after.next = current\\n                after = after.next\\n            current = current.next\\n        \\n        \\n        before.next = after_x.next\\n        after.next = None\\n        \\n        return before_x.next\\n```",
                "solutionTags": [
                    "Python3",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass ListNode:\\n    def __init__(self, val=0, next=None):\\n        self.val = val\\n        self.next = next\\n\\nclass Solution:\\n    def partition(self, head: Optional[ListNode], x: int) -> Optional[ListNode]:\\n    \\n        before_x = ListNode(0)\\n        after_x = ListNode(0)\\n        \\n        before = before_x\\n        after = after_x\\n        \\n        current = head\\n        while current:\\n            if current.val < x:\\n                before.next = current\\n                before = before.next\\n            else:\\n                after.next = current\\n                after = after.next\\n            current = current.next\\n        \\n        \\n        before.next = after_x.next\\n        after.next = None\\n        \\n        return before_x.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3912465,
                "title": "kotlin-solution",
                "content": "# Code\\n```\\n/**\\n * Example:\\n * var li = ListNode(5)\\n * var v = li.`val`\\n * Definition for singly-linked list.\\n * class ListNode(var `val`: Int) {\\n *     var next: ListNode? = null\\n * }\\n */\\nclass Solution {\\n\\n    var headLeft: ListNode? = null\\n    var tailLeft: ListNode? = null\\n    var headRight: ListNode? = null\\n    var tailRight: ListNode? = null\\n\\n    fun addLeft(node: ListNode?) {\\n        if(headLeft == null){\\n            headLeft = node\\n        } else {\\n            tailLeft!!.next = node\\n        }\\n        tailLeft = node\\n    }\\n\\n    fun addRight(node: ListNode?) {\\n        if(headRight == null){\\n            headRight = node\\n        } else {\\n            tailRight!!.next = node\\n        }\\n        tailRight = node\\n    }\\n\\n    fun partition(head: ListNode?, x: Int): ListNode? {\\n        var current = head\\n        while(current != null){\\n            if(current.`val` < x){\\n                addLeft(current)\\n            } else {\\n                addRight(current)\\n            }\\n            current = current.next\\n        }\\n\\n        return if(tailLeft != null) {\\n            tailLeft?.next = headRight\\n            tailRight?.next = null\\n            headLeft\\n        } else {\\n            headRight\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\n/**\\n * Example:\\n * var li = ListNode(5)\\n * var v = li.`val`\\n * Definition for singly-linked list.\\n * class ListNode(var `val`: Int) {\\n *     var next: ListNode? = null\\n * }\\n */\\nclass Solution {\\n\\n    var headLeft: ListNode? = null\\n    var tailLeft: ListNode? = null\\n    var headRight: ListNode? = null\\n    var tailRight: ListNode? = null\\n\\n    fun addLeft(node: ListNode?) {\\n        if(headLeft == null){\\n            headLeft = node\\n        } else {\\n            tailLeft!!.next = node\\n        }\\n        tailLeft = node\\n    }\\n\\n    fun addRight(node: ListNode?) {\\n        if(headRight == null){\\n            headRight = node\\n        } else {\\n            tailRight!!.next = node\\n        }\\n        tailRight = node\\n    }\\n\\n    fun partition(head: ListNode?, x: Int): ListNode? {\\n        var current = head\\n        while(current != null){\\n            if(current.`val` < x){\\n                addLeft(current)\\n            } else {\\n                addRight(current)\\n            }\\n            current = current.next\\n        }\\n\\n        return if(tailLeft != null) {\\n            tailLeft?.next = headRight\\n            tailRight?.next = null\\n            headLeft\\n        } else {\\n            headRight\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3911700,
                "title": "c-cut-and-paste-beats-100-tc-well-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n***Cut and paste***\\nCut from the later part of the list and add to the initial part of the list. \\nRearranging linked list by moving nodes with values less than x to the beginning of the list while maintaining their relative order.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n***Two Pointers:*** \\nYou maintain two pointers: one that tracks the end of the first part of the list (containing elements less than x), and another that traverses the later part of the list.\\n\\n***Rearranging Nodes:*** \\nWhile traversing the later part of the list with the second pointer, if you encounter a node with a value less than x, you detach it from its current position and insert it at the end of the first part of the list. This operation essentially \"cuts and pastes\" the node.\\n\\n***Maintaining Relative Order:*** \\nIt\\'s important to note that while you\\'re moving nodes from the later part of the list to the first part, you should maintain their relative order. This means that if the later part of the list contains nodes with values in the order A -> B -> C, and you encounter node B with a value less than x, you should move B to the end of the first part without disrupting the order of A and C.\\n\\n***Completion:*** \\nOnce you\\'ve traversed the entire list with the second pointer, all nodes with values less than x should be moved to the beginning of the list. The second part of the list will now only contain nodes with values greater than or equal to x.\\n\\n**NO NEED TO MAKE 2 NEW LIST AND THEN JOIN THEM JUST CUT AND PASTE.**\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n        O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n        O(1)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode* new_head = new ListNode(0);\\n        new_head->next = head;\\n        head = new_head;\\n        ListNode* after = new_head;\\n        while(head->next != NULL && head->next->val < x){\\n            head = head->next;\\n            after = after->next;\\n        }\\n        while(after->next != NULL){\\n            while(after->next != NULL && after->next->val >= x){\\n                after = after->next;\\n            }\\n            if(after->next != NULL){\\n                ListNode* temp = after->next;\\n                after->next = after->next->next;\\n                temp->next = head->next;\\n                head->next = temp;\\n                head = temp;\\n            }\\n        }\\n        return new_head->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode* new_head = new ListNode(0);\\n        new_head->next = head;\\n        head = new_head;\\n        ListNode* after = new_head;\\n        while(head->next != NULL && head->next->val < x){\\n            head = head->next;\\n            after = after->next;\\n        }\\n        while(after->next != NULL){\\n            while(after->next != NULL && after->next->val >= x){\\n                after = after->next;\\n            }\\n            if(after->next != NULL){\\n                ListNode* temp = after->next;\\n                after->next = after->next->next;\\n                temp->next = head->next;\\n                head->next = temp;\\n                head = temp;\\n            }\\n        }\\n        return new_head->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3911630,
                "title": "c-faster-than-100-readable-code-intuition-explained",
                "content": "# Intuition\\nThe idea in here is really very simple. The total problem is divided into two equal parts.\\nFinding the nodes which are lesser than the key value, and finding the nodes which are greater than or equal to key value.\\n\\nAs, an initial step we will in total maintain 4 pointers lesser, greater, startLesser, startGreater.\\n\\nlesser and greater stores the current values of lesser and greater values and the start pointers stores the start values. We will traverse and then store the values.\\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode *lesser = NULL;\\n        ListNode *greater = NULL;\\n        ListNode *startLesser = NULL;\\n        ListNode *startGreater = NULL;\\n\\n        ListNode *prev;\\n\\n        while(head != NULL){\\n            prev = head;\\n            head = head->next;\\n            prev->next = NULL;\\n\\n            if(prev->val < x){\\n                if(lesser == NULL){\\n                    lesser = prev;\\n                    startLesser = lesser;\\n                }\\n                else{\\n                    lesser->next = prev;\\n                    lesser = lesser->next;\\n                }\\n            }\\n\\n            else{\\n                if(greater == NULL){\\n                    greater = prev;\\n                    startGreater = greater;\\n                }\\n                else{\\n                    greater->next = prev;\\n                    greater = greater->next;\\n                }\\n            }\\n\\n        }\\n\\n        if(!startLesser) return startGreater;\\n        if(!startGreater) return startLesser;\\n        lesser->next = startGreater;\\n\\n        return startLesser;\\n\\n    }\\n};\\n```\\n**Please upvote if you like the solution**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode *lesser = NULL;\\n        ListNode *greater = NULL;\\n        ListNode *startLesser = NULL;\\n        ListNode *startGreater = NULL;\\n\\n        ListNode *prev;\\n\\n        while(head != NULL){\\n            prev = head;\\n            head = head->next;\\n            prev->next = NULL;\\n\\n            if(prev->val < x){\\n                if(lesser == NULL){\\n                    lesser = prev;\\n                    startLesser = lesser;\\n                }\\n                else{\\n                    lesser->next = prev;\\n                    lesser = lesser->next;\\n                }\\n            }\\n\\n            else{\\n                if(greater == NULL){\\n                    greater = prev;\\n                    startGreater = greater;\\n                }\\n                else{\\n                    greater->next = prev;\\n                    greater = greater->next;\\n                }\\n            }\\n\\n        }\\n\\n        if(!startLesser) return startGreater;\\n        if(!startGreater) return startLesser;\\n        lesser->next = startGreater;\\n\\n        return startLesser;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3911381,
                "title": "c-solution-for-partition-list-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem requires partitioning a linked list into two parts: one containing nodes with values less than a given x, and the other containing nodes with values greater than or equal to x. The relative order of nodes within each partition should be preserved. To achieve this, we can iterate through the original list, creating two new lists: one for nodes less than x and another for nodes greater than or equal to x. After processing all nodes, we can connect the two new lists and return the modified linked list.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- We\\'ll maintain two new linked lists: one for nodes less than x and another for nodes greater than or equal to x.\\n- We\\'ll iterate through the original linked list, and for each node:\\n1. If the node\\'s value is less than x, we\\'ll add it to the \"less\" list.\\n1. Otherwise, we\\'ll add it to the \"greater\" list.\\n- After processing all nodes, we\\'ll connect the end of the \"less\" list to the start of the \"greater\" list.\\n- Finally, we\\'ll return the head of the \"less\" list as the result.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this solution is O(n), where n is the number of nodes in the original linked list. This is because we traverse the original linked list once and perform constant-time operations for each node (addition to the \"less\" or \"greater\" list). The final step of connecting the two lists also takes constant time.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity is O(n) as well. We create two new linked lists to hold the nodes less than x and nodes greater than or equal to x. In the worst case, all nodes could belong to one of these lists, resulting in O(n) additional space usage. Additionally, the space required for the original linked list traversal is negligible compared to the space used for the new lists.\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public int val;\\n *     public ListNode next;\\n *     public ListNode(int val=0, ListNode next=null) {\\n *         this.val = val;\\n *         this.next = next;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public ListNode Partition(ListNode head, int x) {\\n        ListNode lessHead = new ListNode(); // Head of the list for nodes less than x\\n        ListNode less = lessHead; // Current pointer for nodes less than x\\n        ListNode greaterHead = new ListNode(); // Head of the list for nodes greater than or equal to x\\n        ListNode greater = greaterHead; // Current pointer for nodes greater than or equal to x\\n        \\n        while (head != null) {\\n            if (head.val < x) {\\n                less.next = head;\\n                less = less.next;\\n            } else {\\n                greater.next = head;\\n                greater = greater.next;\\n            }\\n            head = head.next;\\n        }\\n        \\n        greater.next = null; // Set the end of greater list to null\\n        less.next = greaterHead.next; // Connect the less list to the greater list\\n        \\n        return lessHead.next; // The final partitioned list\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public int val;\\n *     public ListNode next;\\n *     public ListNode(int val=0, ListNode next=null) {\\n *         this.val = val;\\n *         this.next = next;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public ListNode Partition(ListNode head, int x) {\\n        ListNode lessHead = new ListNode(); // Head of the list for nodes less than x\\n        ListNode less = lessHead; // Current pointer for nodes less than x\\n        ListNode greaterHead = new ListNode(); // Head of the list for nodes greater than or equal to x\\n        ListNode greater = greaterHead; // Current pointer for nodes greater than or equal to x\\n        \\n        while (head != null) {\\n            if (head.val < x) {\\n                less.next = head;\\n                less = less.next;\\n            } else {\\n                greater.next = head;\\n                greater = greater.next;\\n            }\\n            head = head.next;\\n        }\\n        \\n        greater.next = null; // Set the end of greater list to null\\n        less.next = greaterHead.next; // Connect the less list to the greater list\\n        \\n        return lessHead.next; // The final partitioned list\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3911165,
                "title": "easy-solution-explained-line-by-line-beats-95-33-90-11",
                "content": "`code`# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n---\\n\\n```\\n\\n---\\n\\nclass Solution:\\n    def partition(self, head, x):\\n        less_head = ListNode()  # Dummy node for the less than x list\\n        greater_head = ListNode()  # Dummy node for the greater than or equal to x list\\n        less_ptr = less_head  # Pointer for the less than x list\\n        greater_ptr = greater_head  # Pointer for the greater than or equal to x list\\n        \\n        current = head\\n        \\n        while current:\\n            if current.val < x:\\n                less_ptr.next = current\\n                less_ptr = less_ptr.next\\n            else:\\n                greater_ptr.next = current\\n                greater_ptr = greater_ptr.next\\n            \\n            current = current.next\\n        \\n        greater_ptr.next = None  # Set the end of the greater list\\n        less_ptr.next = greater_head.next  # Connect the end of the less list to the beginning of the greater list\\n        \\n        return less_head.next\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "C",
                    "C#"
                ],
                "code": "```\\n\\n---\\n\\nclass Solution:\\n    def partition(self, head, x):\\n        less_head = ListNode()  # Dummy node for the less than x list\\n        greater_head = ListNode()  # Dummy node for the greater than or equal to x list\\n        less_ptr = less_head  # Pointer for the less than x list\\n        greater_ptr = greater_head  # Pointer for the greater than or equal to x list\\n        \\n        current = head\\n        \\n        while current:\\n            if current.val < x:\\n                less_ptr.next = current\\n                less_ptr = less_ptr.next\\n            else:\\n                greater_ptr.next = current\\n                greater_ptr = greater_ptr.next\\n            \\n            current = current.next\\n        \\n        greater_ptr.next = None  # Set the end of the greater list\\n        less_ptr.next = greater_head.next  # Connect the end of the less list to the beginning of the greater list\\n        \\n        return less_head.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3894351,
                "title": "c-o-n-0ms-100-beats-with-proper-explaination",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        struct ListNode *left_list = new ListNode(0);\\n        struct ListNode *right_list = new ListNode(0);\\n\\n        struct ListNode *left_pointer = left_list;\\n        struct ListNode *right_pointer = right_list;\\n\\n        while(head)\\n        {\\n            if(head->val < x)\\n            {\\n                left_pointer->next = head;\\n                left_pointer = left_pointer->next;\\n            }\\n            else\\n            {\\n                right_pointer->next = head;\\n                right_pointer = right_pointer->next;\\n            }\\n            head = head->next;   \\n        }\\n        left_pointer->next = right_list->next;\\n        right_pointer->next = NULL;\\n        return left_list->next;       \\n        }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        struct ListNode *left_list = new ListNode(0);\\n        struct ListNode *right_list = new ListNode(0);\\n\\n        struct ListNode *left_pointer = left_list;\\n        struct ListNode *right_pointer = right_list;\\n\\n        while(head)\\n        {\\n            if(head->val < x)\\n            {\\n                left_pointer->next = head;\\n                left_pointer = left_pointer->next;\\n            }\\n            else\\n            {\\n                right_pointer->next = head;\\n                right_pointer = right_pointer->next;\\n            }\\n            head = head->next;   \\n        }\\n        left_pointer->next = right_list->next;\\n        right_pointer->next = NULL;\\n        return left_list->next;       \\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3875785,
                "title": "beginners-friendly-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->step 1 : create 2 new linked lists , create 2 new pointers which points at head of new lists.\\nstep 2 : traverse the given list and insert the value in both the list according to the given conditions.\\nstep 3 : merge both the list.\\nstep 4 : return the next pointer of th list.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode* temp1 = new ListNode(0);\\n        ListNode* temp2 = new ListNode(0);\\n\\n        ListNode* l1 = temp1;\\n        ListNode* l2 = temp2;\\n\\n        while(head != NULL){\\n            if(head->val < x){\\n                l1->next = head;\\n                l1 = l1->next;\\n            }\\n            else{\\n                l2->next = head;\\n                l2 = l2->next;\\n            }\\n            head = head->next;\\n        }\\n        //combine both lists\\n        l1->next = temp2->next;\\n        l2->next = NULL;\\n\\n        return temp1->next;\\n    };\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode* temp1 = new ListNode(0);\\n        ListNode* temp2 = new ListNode(0);\\n\\n        ListNode* l1 = temp1;\\n        ListNode* l2 = temp2;\\n\\n        while(head != NULL){\\n            if(head->val < x){\\n                l1->next = head;\\n                l1 = l1->next;\\n            }\\n            else{\\n                l2->next = head;\\n                l2 = l2->next;\\n            }\\n            head = head->next;\\n        }\\n        //combine both lists\\n        l1->next = temp2->next;\\n        l2->next = NULL;\\n\\n        return temp1->next;\\n    };\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3774210,
                "title": "easy-java-solution-easy-to-understand-clean-code-beats-100",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTraversing the linked list two times. In the first traversal, adding all the nodes to the answer which are less than x. In the second traversal, adding all the nodes which are greater than or equal to x to the answer.\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode partition(ListNode head, int x) {\\n        \\n        if(head == null || head.next == null) {\\n            return head;\\n        }\\n\\n        ListNode traverse1 = head;\\n        ListNode traverse2 = head;\\n        ListNode temp = new ListNode();\\n        ListNode ans = temp;\\n\\n        while(traverse1 != null) {\\n\\n            if(traverse1.val < x) {\\n                temp.next = new ListNode(traverse1.val);\\n                temp = temp.next;\\n                traverse1 = traverse1.next;\\n            }\\n            else {\\n                traverse1 = traverse1.next;\\n            }\\n        }\\n\\n        while(traverse2 != null) {\\n\\n            if(traverse2.val >= x) {\\n                temp.next = new ListNode(traverse2.val);\\n                temp = temp.next;\\n                traverse2 = traverse2.next;\\n            }\\n            else {\\n                traverse2 = traverse2.next;\\n            }\\n        }\\n\\n        temp.next = null;\\n        return ans.next;\\n\\n    }\\n}\\n```\\n\\n![cat.jpeg](https://assets.leetcode.com/users/images/790808e1-ff70-4d2c-a9bf-6fb030beed05_1689519896.3915954.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode partition(ListNode head, int x) {\\n        \\n        if(head == null || head.next == null) {\\n            return head;\\n        }\\n\\n        ListNode traverse1 = head;\\n        ListNode traverse2 = head;\\n        ListNode temp = new ListNode();\\n        ListNode ans = temp;\\n\\n        while(traverse1 != null) {\\n\\n            if(traverse1.val < x) {\\n                temp.next = new ListNode(traverse1.val);\\n                temp = temp.next;\\n                traverse1 = traverse1.next;\\n            }\\n            else {\\n                traverse1 = traverse1.next;\\n            }\\n        }\\n\\n        while(traverse2 != null) {\\n\\n            if(traverse2.val >= x) {\\n                temp.next = new ListNode(traverse2.val);\\n                temp = temp.next;\\n                traverse2 = traverse2.next;\\n            }\\n            else {\\n                traverse2 = traverse2.next;\\n            }\\n        }\\n\\n        temp.next = null;\\n        return ans.next;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3772710,
                "title": "using-dummy-node-connecting-pointer-linked-list-solution",
                "content": "\\n\\n    class Solution {\\n    public:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode* dummy=new ListNode(-1);\\n        ListNode* p=dummy;\\n        ListNode* dummy1=new ListNode(-1);\\n        ListNode* q=dummy1;\\n        ListNode* s=head;\\n        while(s){\\n            if(s->val<x){\\n                dummy->next=s;\\n                dummy=dummy->next;\\n            }\\n            else{\\n                dummy1->next=s;\\n                dummy1=dummy1->next;\\n            }\\n            s=s->next;\\n        }\\n        \\n        dummy1->next=NULL;\\n        dummy->next=q->next;\\n        return p->next;\\n      }\\n     };",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "class Solution {\\n    public:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode* dummy=new ListNode(-1);\\n        ListNode* p=dummy;\\n        ListNode* dummy1=new ListNode(-1);\\n        ListNode* q=dummy1;\\n        ListNode* s=head;\\n        while(s){\\n            if(s->val<x){\\n                dummy->next=s;\\n                dummy=dummy->next;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3740668,
                "title": "easy-implementation-using-linkedlist-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode* lower = new ListNode();\\n        ListNode* ans = lower;\\n        ListNode* higher = new ListNode();\\n        ListNode* temp = higher;\\n\\n        while(head){\\n            if(head->val < x) lower->next = new ListNode(head->val), lower = lower->next;\\n            else higher->next = new ListNode(head->val), higher = higher->next;\\n            head = head->next;\\n        }\\n\\n        lower->next = temp->next;\\n        return ans->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode* lower = new ListNode();\\n        ListNode* ans = lower;\\n        ListNode* higher = new ListNode();\\n        ListNode* temp = higher;\\n\\n        while(head){\\n            if(head->val < x) lower->next = new ListNode(head->val), lower = lower->next;\\n            else higher->next = new ListNode(head->val), higher = higher->next;\\n            head = head->next;\\n        }\\n\\n        lower->next = temp->next;\\n        return ans->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3524027,
                "title": "c-beats-100-easiest-solution",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode left(0), right(0);\\n        ListNode *l = &left, *r = &right;\\n        while(head){\\n            ListNode* & ref = head->val < x ? l : r;\\n            ref->next = head;\\n            ref = ref->next;\\n            head = head->next;\\n        }\\n        l->next = right.next;\\n        r->next = NULL;\\n        return left.next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode left(0), right(0);\\n        ListNode *l = &left, *r = &right;\\n        while(head){\\n            ListNode* & ref = head->val < x ? l : r;\\n            ref->next = head;\\n            ref = ref->next;\\n            head = head->next;\\n        }\\n        l->next = right.next;\\n        r->next = NULL;\\n        return left.next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3442825,
                "title": "86-partition-list-java",
                "content": "```\\nclass Solution {\\n    public ListNode partition(ListNode head, int x) {\\n       ListNode list1=new ListNode(0);\\n       ListNode list2=new ListNode(0);\\n       ListNode l1=list1;\\n       ListNode l2=list2;\\n       while(head!=null)\\n       {\\n           if(x<=head.val)\\n           {\\n               l2.next=head;\\n               l2=l2.next;\\n           }\\n           else\\n           {\\n                l1.next=head;\\n               l1=l1.next;\\n           }\\n           head=head.next;\\n       }\\n        l1.next=list2.next;\\n         l2.next=null;\\n        return list1.next;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public ListNode partition(ListNode head, int x) {\\n       ListNode list1=new ListNode(0);\\n       ListNode list2=new ListNode(0);\\n       ListNode l1=list1;\\n       ListNode l2=list2;\\n       while(head!=null)\\n       {\\n           if(x<=head.val)\\n           {\\n               l2.next=head;\\n               l2=l2.next;\\n           }\\n           else\\n           {\\n                l1.next=head;\\n               l1=l1.next;\\n           }\\n           head=head.next;\\n       }\\n        l1.next=list2.next;\\n         l2.next=null;\\n        return list1.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3348462,
                "title": "easy-solution",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode* left=new ListNode();\\n        ListNode* right= new ListNode();\\n        ListNode* ptr=right;\\n        ListNode* ptr2=left;\\n        ListNode*curr=head;\\n        while(curr){\\n            if(curr->val>=x){\\n                //right\\n                ptr->next=new ListNode(curr->val);\\n                ptr=ptr->next;\\n            }\\n            else{\\n                //left\\n                ptr2->next=new ListNode(curr->val);\\n                ptr2=ptr2->next;\\n            }\\n            curr=curr->next;\\n        }\\n        ptr2->next=right->next;\\n        \\n        return left->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode* left=new ListNode();\\n        ListNode* right= new ListNode();\\n        ListNode* ptr=right;\\n        ListNode* ptr2=left;\\n        ListNode*curr=head;\\n        while(curr){\\n            if(curr->val>=x){\\n                //right\\n                ptr->next=new ListNode(curr->val);\\n                ptr=ptr->next;\\n            }\\n            else{\\n                //left\\n                ptr2->next=new ListNode(curr->val);\\n                ptr2=ptr2->next;\\n            }\\n            curr=curr->next;\\n        }\\n        ptr2->next=right->next;\\n        \\n        return left->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3254043,
                "title": "python3-by-linkedlist-into-list-conversion-easy-solution",
                "content": "Please upvote if you find the solution helpful.\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def partition(self, head: Optional[ListNode], x: int) -> Optional[ListNode]:\\n        lst=[]\\n        lowlst=[]\\n        highlst=[]\\n        x_index = 0\\n        while head:\\n            lst.append(head.val)\\n            head = head.next\\n        for i in range(len(lst)):\\n            if lst[i]<x:\\n                lowlst.append(lst[i])\\n            else:\\n                highlst.append(lst[i])\\n        a = ListNode(0)\\n        temp = a\\n        for i in lowlst+highlst:\\n            temp.next = ListNode(i)\\n            temp = temp.next\\n        return a.next\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Linked List"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def partition(self, head: Optional[ListNode], x: int) -> Optional[ListNode]:\\n        lst=[]\\n        lowlst=[]\\n        highlst=[]\\n        x_index = 0\\n        while head:\\n            lst.append(head.val)\\n            head = head.next\\n        for i in range(len(lst)):\\n            if lst[i]<x:\\n                lowlst.append(lst[i])\\n            else:\\n                highlst.append(lst[i])\\n        a = ListNode(0)\\n        temp = a\\n        for i in lowlst+highlst:\\n            temp.next = ListNode(i)\\n            temp = temp.next\\n        return a.next\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3196949,
                "title": "c-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n\\n- Space complexity:$$O(n)$$\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        if(!head){return NULL;}\\n        vector<int>v;\\n        while(head){\\n            v.push_back(head->val);\\n            head=head->next;\\n        }\\n        vector<int>v1;\\n        for(int i=0; i<v.size(); i++){\\n            if(v[i]<x){\\n                v1.push_back(v[i]);\\n                v.erase(v.begin()+i);\\n                i--;\\n            }\\n        }\\n        reverse(v.begin(), v.end());\\n        for(int i=v1.size()-1; i>=0; i--){\\n            v.push_back(v1[i]);\\n        }\\n        reverse(v.begin(), v.end());\\n        ListNode* root=NULL;\\n        for(int i=v.size()-1; i>=0; i--){\\n            ListNode* temp=new ListNode;\\n            temp->val=v[i];\\n            temp->next=root;\\n            root=temp;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        if(!head){return NULL;}\\n        vector<int>v;\\n        while(head){\\n            v.push_back(head->val);\\n            head=head->next;\\n        }\\n        vector<int>v1;\\n        for(int i=0; i<v.size(); i++){\\n            if(v[i]<x){\\n                v1.push_back(v[i]);\\n                v.erase(v.begin()+i);\\n                i--;\\n            }\\n        }\\n        reverse(v.begin(), v.end());\\n        for(int i=v1.size()-1; i>=0; i--){\\n            v.push_back(v1[i]);\\n        }\\n        reverse(v.begin(), v.end());\\n        ListNode* root=NULL;\\n        for(int i=v.size()-1; i>=0; i--){\\n            ListNode* temp=new ListNode;\\n            temp->val=v[i];\\n            temp->next=root;\\n            root=temp;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3128330,
                "title": "0ms-beats-100-java-solution-with-explanation",
                "content": "# Intuition\\nAlgorithm:\\n1. Keep two dummy nodes named smallerHead and largerHead.\\n2. Make curr point to head.\\n3. If (curr.val<x) , then make smallerHead\\'s next to point to currr.\\n4. Otherwise, make largerHead\\'s next to point to currr.\\n5. After reaching the end of the list, make current largerHead\\'s next node to point to null (to avoid cycle-found-in-linkedlist error).\\n6. Join the largerHead to the smallerHead.\\n7. Return smallerHead.next.\\n\\n![answer.jpeg](https://assets.leetcode.com/users/images/2644d90b-e167-45b7-b4f3-1deda5d42c14_1675275035.2494404.jpeg)\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n- Space complexity: O(1)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode partition(ListNode head, int x) {\\n        ListNode smallerHead = new ListNode(0);\\n        ListNode smaller=smallerHead;\\n        ListNode largerHead = new ListNode(0);\\n        ListNode larger=largerHead;\\n\\n        ListNode curr=head;\\n\\n        while(curr!=null) {\\n            if(curr.val<x) {\\n                smaller.next=curr;\\n                smaller=smaller.next;\\n            }\\n            else {\\n                larger.next=curr;\\n                larger=larger.next;\\n                \\n            }\\n            curr=curr.next;\\n        }\\n        larger.next=null;\\n        smaller.next=largerHead.next;\\n        return smallerHead.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode partition(ListNode head, int x) {\\n        ListNode smallerHead = new ListNode(0);\\n        ListNode smaller=smallerHead;\\n        ListNode largerHead = new ListNode(0);\\n        ListNode larger=largerHead;\\n\\n        ListNode curr=head;\\n\\n        while(curr!=null) {\\n            if(curr.val<x) {\\n                smaller.next=curr;\\n                smaller=smaller.next;\\n            }\\n            else {\\n                larger.next=curr;\\n                larger=larger.next;\\n                \\n            }\\n            curr=curr.next;\\n        }\\n        larger.next=null;\\n        smaller.next=largerHead.next;\\n        return smallerHead.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3062779,
                "title": "100-0-ms-4-pointers-trick-simple",
                "content": "\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```java []\\npublic ListNode partition(ListNode head, int x) {\\n  ListNode leftHead=new ListNode(),rightHead=new ListNode();\\n  ListNode leftTailPointer=leftHead,rightTailPointer=rightHead;\\n  while(head!=null){\\n      if(head.val<x){\\n          leftTailPointer.next=head;\\n          leftTailPointer=leftTailPointer.next;\\n      }else{\\n          rightTailPointer.next=head;\\n          rightTailPointer=rightTailPointer.next;\\n      }\\n      head=head.next;\\n  }\\n  rightTailPointer.next=null;\\n  leftTailPointer.next=rightHead.next;\\n  return leftHead.next;\\n}\\n```\\n```c++ [] \\nListNode* partition(ListNode* head, int x) {\\n  ListNode* leftHead = new ListNode();\\n  ListNode* rightHead = new ListNode();\\n  ListNode* leftTailPointer = leftHead;\\n  ListNode* rightTailPointer = rightHead;\\n  while (head != nullptr) {\\n    if (head->val < x) {\\n      leftTailPointer->next = head;\\n      leftTailPointer = leftTailPointer->next;\\n    } else {\\n      rightTailPointer->next = head;\\n      rightTailPointer = rightTailPointer->next;\\n    }\\n    head = head->next;\\n  }\\n  rightTailPointer->next = nullptr;\\n  leftTailPointer->next = rightHead->next;\\n  return leftHead->next;\\n}\\n```\\n```python [] \\ndef partition(head, x):\\n  leftHead = ListNode()\\n  rightHead = ListNode()\\n  leftTail = leftHead\\n  rightTail = rightHead\\n  while head is not None:\\n    if head.val < x:\\n      leftTail.next = head\\n      leftTail = leftTail.next\\n    else:\\n      rightTail.next = head\\n      rightTail = rightTail.next\\n    head = head.next\\n  rightTail.next = None\\n  leftTail.next = rightHead.next\\n  return leftHead.next\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3"
                ],
                "code": "```java []\\npublic ListNode partition(ListNode head, int x) {\\n  ListNode leftHead=new ListNode(),rightHead=new ListNode();\\n  ListNode leftTailPointer=leftHead,rightTailPointer=rightHead;\\n  while(head!=null){\\n      if(head.val<x){\\n          leftTailPointer.next=head;\\n          leftTailPointer=leftTailPointer.next;\\n      }else{\\n          rightTailPointer.next=head;\\n          rightTailPointer=rightTailPointer.next;\\n      }\\n      head=head.next;\\n  }\\n  rightTailPointer.next=null;\\n  leftTailPointer.next=rightHead.next;\\n  return leftHead.next;\\n}\\n```\n```c++ [] \\nListNode* partition(ListNode* head, int x) {\\n  ListNode* leftHead = new ListNode();\\n  ListNode* rightHead = new ListNode();\\n  ListNode* leftTailPointer = leftHead;\\n  ListNode* rightTailPointer = rightHead;\\n  while (head != nullptr) {\\n    if (head->val < x) {\\n      leftTailPointer->next = head;\\n      leftTailPointer = leftTailPointer->next;\\n    } else {\\n      rightTailPointer->next = head;\\n      rightTailPointer = rightTailPointer->next;\\n    }\\n    head = head->next;\\n  }\\n  rightTailPointer->next = nullptr;\\n  leftTailPointer->next = rightHead->next;\\n  return leftHead->next;\\n}\\n```\n```python [] \\ndef partition(head, x):\\n  leftHead = ListNode()\\n  rightHead = ListNode()\\n  leftTail = leftHead\\n  rightTail = rightHead\\n  while head is not None:\\n    if head.val < x:\\n      leftTail.next = head\\n      leftTail = leftTail.next\\n    else:\\n      rightTail.next = head\\n      rightTail = rightTail.next\\n    head = head.next\\n  rightTail.next = None\\n  leftTail.next = rightHead.next\\n  return leftHead.next\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3053084,
                "title": "c-using-queue-beginner-friendly-solution",
                "content": "\\n\\n### Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n### Code\\n```\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        queue<ListNode*> before;\\n        queue<ListNode*> after;\\n\\n        while(head) {\\n            if(head-> val >= x) before.push(head);\\n            else after.push(head);\\n            head = head->next;\\n        }\\n\\n        ListNode *answer = nullptr;\\n        ListNode *curr = nullptr;\\n\\n        while(!after.empty()) {\\n            auto f = after.front(); after.pop();\\n            if(!answer) {\\n                answer = f;\\n                curr = f;\\n            }else {\\n                curr -> next = f;\\n                curr = f;\\n            }\\n        }\\n\\n        while(!before.empty()) {\\n            auto f = before.front(); before.pop();\\n            if(!answer) {\\n                answer = f;\\n                curr = f;\\n            }else {\\n                curr -> next = f;\\n                curr = f;\\n            }\\n        }\\n\\n        if(curr) curr -> next = nullptr;\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        queue<ListNode*> before;\\n        queue<ListNode*> after;\\n\\n        while(head) {\\n            if(head-> val >= x) before.push(head);\\n            else after.push(head);\\n            head = head->next;\\n        }\\n\\n        ListNode *answer = nullptr;\\n        ListNode *curr = nullptr;\\n\\n        while(!after.empty()) {\\n            auto f = after.front(); after.pop();\\n            if(!answer) {\\n                answer = f;\\n                curr = f;\\n            }else {\\n                curr -> next = f;\\n                curr = f;\\n            }\\n        }\\n\\n        while(!before.empty()) {\\n            auto f = before.front(); before.pop();\\n            if(!answer) {\\n                answer = f;\\n                curr = f;\\n            }else {\\n                curr -> next = f;\\n                curr = f;\\n            }\\n        }\\n\\n        if(curr) curr -> next = nullptr;\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2985105,
                "title": "c-faster-than-85-using-2-new-copy-nodes-beginner-friendly-clean-code",
                "content": "\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n\\n    ListNode* partition(ListNode* head, int x) {\\n\\n      \\n      if(head == NULL || head->next == NULL) return head;\\n\\n\\n       ListNode *node1 = new ListNode(), *node2 = new ListNode(NULL);\\n       ListNode *l = node1, *r = node2, *ptr = head;\\n\\n       while(ptr!=NULL)\\n       {\\n           if(ptr->val < x)\\n           {\\n               ListNode *curr = new ListNode(ptr->val);\\n               l->next = curr;\\n               l = l->next;    \\n           }\\n\\n            ptr = ptr->next;\\n       }\\n       \\n       ptr = head;\\n\\n       while(ptr!=NULL)\\n       {\\n           if(ptr->val >= x)\\n           {\\n               ListNode *curr = new ListNode(ptr->val);\\n               r->next = curr;\\n               r = r->next;\\n               \\n           }\\n\\n            ptr = ptr->next;\\n       }\\n\\n\\n        node2 = node2->next;\\n        node1 = node1->next;\\n\\n\\n        if(node1 == NULL) return node2;\\n\\n        l->next = node2;\\n       \\n    \\n        return node1;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n\\n    ListNode* partition(ListNode* head, int x) {\\n\\n      \\n      if(head == NULL || head->next == NULL) return head;\\n\\n\\n       ListNode *node1 = new ListNode(), *node2 = new ListNode(NULL);\\n       ListNode *l = node1, *r = node2, *ptr = head;\\n\\n       while(ptr!=NULL)\\n       {\\n           if(ptr->val < x)\\n           {\\n               ListNode *curr = new ListNode(ptr->val);\\n               l->next = curr;\\n               l = l->next;    \\n           }\\n\\n            ptr = ptr->next;\\n       }\\n       \\n       ptr = head;\\n\\n       while(ptr!=NULL)\\n       {\\n           if(ptr->val >= x)\\n           {\\n               ListNode *curr = new ListNode(ptr->val);\\n               r->next = curr;\\n               r = r->next;\\n               \\n           }\\n\\n            ptr = ptr->next;\\n       }\\n\\n\\n        node2 = node2->next;\\n        node1 = node1->next;\\n\\n\\n        if(node1 == NULL) return node2;\\n\\n        l->next = node2;\\n       \\n    \\n        return node1;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2974188,
                "title": "java-100-faster-solution-o-n",
                "content": "# Approach\\nTwo pointers approach\\n\\n# Complexity\\n- Time complexity: O(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public ListNode partition(ListNode head, int x) {\\n        if (head == null || head.next == null) return head;\\n        ListNode lessCurr = null, xCurr = null, current = head;\\n        ListNode lessHead = null, xHead = null;\\n        while (current != null) {\\n            if (current.val < x) {\\n                if (lessCurr == null) {\\n                    lessCurr = current;\\n                    lessHead = lessCurr;\\n                }\\n                else {\\n                    lessCurr.next = current;\\n                    lessCurr = lessCurr.next;\\n                }\\n            } else {\\n                if (xCurr == null) {\\n                    xCurr = current;\\n                    xHead = xCurr;\\n                }\\n                else {\\n                    xCurr.next = current;\\n                    xCurr = xCurr.next;\\n                }\\n            }\\n            current = current.next;\\n        }\\n        if (xCurr != null) xCurr.next = null;\\n        if (lessCurr != null) lessCurr.next = xHead;\\n        return lessHead != null ? lessHead : xHead;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode partition(ListNode head, int x) {\\n        if (head == null || head.next == null) return head;\\n        ListNode lessCurr = null, xCurr = null, current = head;\\n        ListNode lessHead = null, xHead = null;\\n        while (current != null) {\\n            if (current.val < x) {\\n                if (lessCurr == null) {\\n                    lessCurr = current;\\n                    lessHead = lessCurr;\\n                }\\n                else {\\n                    lessCurr.next = current;\\n                    lessCurr = lessCurr.next;\\n                }\\n            } else {\\n                if (xCurr == null) {\\n                    xCurr = current;\\n                    xHead = xCurr;\\n                }\\n                else {\\n                    xCurr.next = current;\\n                    xCurr = xCurr.next;\\n                }\\n            }\\n            current = current.next;\\n        }\\n        if (xCurr != null) xCurr.next = null;\\n        if (lessCurr != null) lessCurr.next = xHead;\\n        return lessHead != null ? lessHead : xHead;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2906962,
                "title": "easy-solution-beats-97",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        vector<int> v1;\\n        vector<int> v2;\\n        ListNode* temp = head;\\n        while(temp != NULL){\\n            int y = temp->val;\\n            if(y>=x){\\n                v2.push_back(y);\\n            }\\n            else{\\n                v1.push_back(y);\\n            }\\n            temp = temp->next;\\n        }\\n        temp = head;\\n        for(int i =0; i<v1.size();i++){\\n            temp->val = v1[i];\\n            temp = temp->next;\\n        }\\n        for(int i =0; i<v2.size();i++){\\n            temp->val = v2[i];\\n            temp = temp->next;\\n        }\\n        return head;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        vector<int> v1;\\n        vector<int> v2;\\n        ListNode* temp = head;\\n        while(temp != NULL){\\n            int y = temp->val;\\n            if(y>=x){\\n                v2.push_back(y);\\n            }\\n            else{\\n                v1.push_back(y);\\n            }\\n            temp = temp->next;\\n        }\\n        temp = head;\\n        for(int i =0; i<v1.size();i++){\\n            temp->val = v1[i];\\n            temp = temp->next;\\n        }\\n        for(int i =0; i<v2.size();i++){\\n            temp->val = v2[i];\\n            temp = temp->next;\\n        }\\n        return head;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2900084,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe two parts have their own pseudo heads\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     struct ListNode *next;\\n * };\\n */\\n\\ntypedef struct ListNode List_t;\\n\\nstruct ListNode *partition(struct ListNode *head, int x)\\n{\\n    List_t small, great;\\n    List_t *shead = &small;\\n    List_t *ghead = &great;\\n    List_t *iter = head;\\n\\n    while (iter) {\\n        List_t *tmp = iter;\\n        iter = iter->next;\\n        if (tmp->val < x) {\\n            shead->next = tmp;\\n            shead = shead->next;\\n        }\\n        else {\\n            ghead->next = tmp;\\n            ghead = ghead->next;\\n        }\\n    }\\n    ghead->next = NULL;\\n    shead->next = great.next;\\n    return small.next;\\n}\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     struct ListNode *next;\\n * };\\n */\\n\\ntypedef struct ListNode List_t;\\n\\nstruct ListNode *partition(struct ListNode *head, int x)\\n{\\n    List_t small, great;\\n    List_t *shead = &small;\\n    List_t *ghead = &great;\\n    List_t *iter = head;\\n\\n    while (iter) {\\n        List_t *tmp = iter;\\n        iter = iter->next;\\n        if (tmp->val < x) {\\n            shead->next = tmp;\\n            shead = shead->next;\\n        }\\n        else {\\n            ghead->next = tmp;\\n            ghead = ghead->next;\\n        }\\n    }\\n    ghead->next = NULL;\\n    shead->next = great.next;\\n    return small.next;\\n}\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2886350,
                "title": "java-one-pass-0-ms-100-easy",
                "content": "## **Please Upvote** :D\\n\\n``` Java []\\nclass Solution {\\n    public ListNode partition(ListNode head, int x) {\\n        if (head == null) {\\n            return head;\\n        }\\n\\n        ListNode less = new ListNode();\\n        ListNode greater = new ListNode();\\n        ListNode lessHead = less, greaterHead = greater;\\n\\n        while (head != null) {\\n            if (head.val < x) {\\n                lessHead.next = head;\\n                lessHead = lessHead.next;\\n            } else {\\n                greaterHead.next = head;\\n                greaterHead = greaterHead.next;\\n            }\\n            head = head.next;\\n        }\\n\\n        lessHead.next = greater.next;\\n        greaterHead.next = null;\\n        return less.next;\\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "``` Java []\\nclass Solution {\\n    public ListNode partition(ListNode head, int x) {\\n        if (head == null) {\\n            return head;\\n        }\\n\\n        ListNode less = new ListNode();\\n        ListNode greater = new ListNode();\\n        ListNode lessHead = less, greaterHead = greater;\\n\\n        while (head != null) {\\n            if (head.val < x) {\\n                lessHead.next = head;\\n                lessHead = lessHead.next;\\n            } else {\\n                greaterHead.next = head;\\n                greaterHead = greaterHead.next;\\n            }\\n            head = head.next;\\n        }\\n\\n        lessHead.next = greater.next;\\n        greaterHead.next = null;\\n        return less.next;\\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2694276,
                "title": "java-simple-solution-without-using-dummy-nodes",
                "content": "```\\n public ListNode partition(ListNode head, int x) {\\n        if(head==null || head.next==null) return head;\\n\\t\\t\\n\\t\\t//head1  refers to head of another list with elements greater than x and prev1 refers to its previous node\\n        ListNode curr=head, prev=null, head1=null, prev1=null;\\n        while(curr!=null){\\n            if(curr.val<x){\\n                if(prev==null) {head=curr;prev=curr;}\\n                else{prev.next=curr;\\n                prev=curr;}\\n            }else{\\n                if(head1==null) {head1=curr;prev1=curr;}\\n                else{prev1.next=curr;\\n                prev1=curr;}\\n            }\\n          curr=curr.next;\\n        }\\n        if(prev!=null) prev.next=head1;\\n        if(prev1!=null) prev1.next=null;\\n        return head;\\n```",
                "solutionTags": [],
                "code": "```\\n public ListNode partition(ListNode head, int x) {\\n        if(head==null || head.next==null) return head;\\n\\t\\t\\n\\t\\t//head1  refers to head of another list with elements greater than x and prev1 refers to its previous node\\n        ListNode curr=head, prev=null, head1=null, prev1=null;\\n        while(curr!=null){\\n            if(curr.val<x){\\n                if(prev==null) {head=curr;prev=curr;}\\n                else{prev.next=curr;\\n                prev=curr;}\\n            }else{\\n                if(head1==null) {head1=curr;prev1=curr;}\\n                else{prev1.next=curr;\\n                prev1=curr;}\\n            }\\n          curr=curr.next;\\n        }\\n        if(prev!=null) prev.next=head1;\\n        if(prev1!=null) prev1.next=null;\\n        return head;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2582938,
                "title": "c-solution-partition-list",
                "content": "```\\nclass Solution {\\nprivate:\\n    void insertAtTail(ListNode * &tail , ListNode *curr){\\n        tail->next = curr;\\n        tail = curr;\\n    }\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode* lessHead = new ListNode(-1);\\n        ListNode *moreHead = new ListNode(-1);\\n        ListNode *lessTail = lessHead;\\n        ListNode *moreTail = moreHead;\\n        \\n        ListNode *temp = head;\\n        \\n        while(temp != NULL){\\n            if(temp->val < x){\\n                insertAtTail(lessTail , temp);\\n            }\\n            else\\n                insertAtTail(moreTail , temp);\\n            \\n            temp = temp->next;\\n        }\\n        \\n        if(lessHead->next == NULL){\\n            head = moreHead->next;\\n            moreTail->next = NULL;\\n        }\\n        else{\\n            lessTail->next = moreHead->next;\\n            moreTail->next = NULL;\\n            head = lessHead->next;\\n        }\\n        delete(lessHead);\\n        delete(moreHead);\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    void insertAtTail(ListNode * &tail , ListNode *curr){\\n        tail->next = curr;\\n        tail = curr;\\n    }\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode* lessHead = new ListNode(-1);\\n        ListNode *moreHead = new ListNode(-1);\\n        ListNode *lessTail = lessHead;\\n        ListNode *moreTail = moreHead;\\n        \\n        ListNode *temp = head;\\n        \\n        while(temp != NULL){\\n            if(temp->val < x){\\n                insertAtTail(lessTail , temp);\\n            }\\n            else\\n                insertAtTail(moreTail , temp);\\n            \\n            temp = temp->next;\\n        }\\n        \\n        if(lessHead->next == NULL){\\n            head = moreHead->next;\\n            moreTail->next = NULL;\\n        }\\n        else{\\n            lessTail->next = moreHead->next;\\n            moreTail->next = NULL;\\n            head = lessHead->next;\\n        }\\n        delete(lessHead);\\n        delete(moreHead);\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2535429,
                "title": "c-easy-hai-bro-you-got-this-buddy",
                "content": "class Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        \\n     ListNode* left= new ListNode(0);\\n     ListNode* right= new  ListNode(0);   \\n        \\n      ListNode* lefttail=left;\\n      ListNode* righttail=right;\\n        \\n        while(head!=NULL)\\n        {\\n            if(head->val<x)\\n            {\\n                lefttail->next=head;\\n                lefttail=lefttail->next;\\n                \\n            }\\n            \\n            else\\n            {\\n                righttail->next=head;\\n                righttail=righttail->next;\\n                \\n            }\\n            \\n            head=head->next;\\n        }\\n         righttail->next=NULL;\\n        lefttail->next=right->next;\\n        \\n        return left->next;\\n        \\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        \\n     ListNode* left= new ListNode(0);\\n     ListNode* right= new  ListNode(0);   \\n        \\n      ListNode* lefttail=left;\\n      ListNode* righttail=right;\\n        \\n        while(head!=NULL)\\n        {\\n            if(head->val<x)\\n            {\\n                lefttail->next=head;\\n                lefttail=lefttail->next;\\n                \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2335492,
                "title": "java-easy-implementation",
                "content": "Approach:\\n* We will take two node left and right and intiate them with zero\\n* The intution here is to iterate the list if the current node value is less than x\\n* Then point the next of left to current and move the left node\\'s pointer\\n* Else point the next or right to current and move the right node\\'s pointer\\n* After the loop we just need to set the end of left node to start of the right node\\n* And the end of the right node to null\\n* And return the next of left (since we initiated the list with zero so return values next to zero)\\n\\n```\\nclass Solution {\\n    public ListNode partition(ListNode head, int x) {\\n        if(head == null) return null;\\n        \\n        ListNode left = new ListNode(0), tempL = left, right = new ListNode(0), tempR = right;\\n        \\n        while(head != null){\\n            \\n            if(head.val < x){ \\n                tempL.next = head;\\n                tempL = tempL.next;\\n            }\\n            else {\\n                tempR.next = head;\\n                tempR = tempR.next;\\n            }\\n            head = head.next;\\n        }\\n        \\n        tempL.next = right.next;\\n        tempR.next = null;\\n        return left.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode partition(ListNode head, int x) {\\n        if(head == null) return null;\\n        \\n        ListNode left = new ListNode(0), tempL = left, right = new ListNode(0), tempR = right;\\n        \\n        while(head != null){\\n            \\n            if(head.val < x){ \\n                tempL.next = head;\\n                tempL = tempL.next;\\n            }\\n            else {\\n                tempR.next = head;\\n                tempR = tempR.next;\\n            }\\n            head = head.next;\\n        }\\n        \\n        tempL.next = right.next;\\n        tempR.next = null;\\n        return left.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2320042,
                "title": "java-c-solution-explained-tc-o-n-sc-o-1-100",
                "content": "JAVA Solution\\nhttps://leetcode.com/problems/partition-list/discuss/2320001/Java-C%2B%2B-Solution-Explained-TC-O(N)-SC-O(1)-100\\n```\\n\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode node1(0) ,node2(0);\\n        ListNode *p1=&node1 ,*p2 =&node2;\\n        \\n        while(head)\\n        {\\n            if(head->val < x)\\n            {\\n                \\n                //p1=p1->next=head; \\n                p1->next=head;\\n                p1=p1->next;\\n            }\\n            else\\n            {\\n                \\n                p2->next=head;\\n                p2=p2->next;\\n            }\\n            head=head->next;\\n        }        \\n        p2->next=NULL;\\n        p1->next=node2.next;;\\n        return node1.next;\\n        \\n        \\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode node1(0) ,node2(0);\\n        ListNode *p1=&node1 ,*p2 =&node2;\\n        \\n        while(head)\\n        {\\n            if(head->val < x)\\n            {\\n                \\n                //p1=p1->next=head; \\n                p1->next=head;\\n                p1=p1->next;\\n            }\\n            else\\n            {\\n                \\n                p2->next=head;\\n                p2=p2->next;\\n            }\\n            head=head->next;\\n        }        \\n        p2->next=NULL;\\n        p1->next=node2.next;;\\n        return node1.next;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2319304,
                "title": "java-best-solution-possible",
                "content": "```\\nclass Solution {\\n    public ListNode partition(ListNode head, int x) {\\n     ListNode less = new ListNode(0);\\n      ListNode greater = new ListNode(0);\\n      ListNode curr1 = less;\\n      ListNode curr2 = greater;\\n      while(head != null) {\\n        if(head.val < x) {\\n          curr1.next = new ListNode(head.val);\\n          curr1 = curr1.next;\\n        }\\n        else {\\n          curr2.next = new ListNode(head.val);\\n          curr2 = curr2.next;\\n        }\\n        head = head.next;\\n      }\\n      curr1.next = greater.next;\\n      return less.next;\\n    }\\n}\\n```\\n# PLEASE UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode partition(ListNode head, int x) {\\n     ListNode less = new ListNode(0);\\n      ListNode greater = new ListNode(0);\\n      ListNode curr1 = less;\\n      ListNode curr2 = greater;\\n      while(head != null) {\\n        if(head.val < x) {\\n          curr1.next = new ListNode(head.val);\\n          curr1 = curr1.next;\\n        }\\n        else {\\n          curr2.next = new ListNode(head.val);\\n          curr2 = curr2.next;\\n        }\\n        head = head.next;\\n      }\\n      curr1.next = greater.next;\\n      return less.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2317462,
                "title": "easy-understanding-c-solution-with-explanation",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        if(!head) return nullptr;\\n        ListNode *fast = head,*slow = nullptr;\\n        \\n        // Find first greater element.\\n        \\n        while(fast)\\n        {\\n            if(fast->val >= x) break;\\n            slow = fast;\\n            fast = fast->next;\\n        }\\n        \\n        // If no greater element return head.\\n        \\n        if(!fast) return head;\\n        \\n        // Start from greater elemnts next and traverse the full list.\\n        \\n        ListNode *temp = fast->next,*slow1 = fast,*ans;\\n        \\n        int flag = 0;\\n        \\n        while(temp)\\n        {\\n            if(temp->val >= x)          // If not a smaller element just skip.\\n            {\\n                slow1 = temp;\\n                temp = temp->next;\\n            }\\n            else\\n            { \\n                slow1->next = temp->next;     //Break\\n                ListNode* copy = temp;        //The \\n                copy->next = fast;            //Link of smaller elements\\n                temp = temp -> next;          // with it\\'s preducesor and successor\\n                \\n                if(!slow)           //If first element is greater\\n                {\\n                    slow = copy;\\n                    ans = slow;\\n                    flag = 1;\\n                }\\n                else\\n                {\\n                    copy->next = slow->next;\\n                    slow->next = copy;\\n                    slow = copy;\\n                }\\n            }\\n        }\\n        return flag==0?head:ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        if(!head) return nullptr;\\n        ListNode *fast = head,*slow = nullptr;\\n        \\n        // Find first greater element.\\n        \\n        while(fast)\\n        {\\n            if(fast->val >= x) break;\\n            slow = fast;\\n            fast = fast->next;\\n        }\\n        \\n        // If no greater element return head.\\n        \\n        if(!fast) return head;\\n        \\n        // Start from greater elemnts next and traverse the full list.\\n        \\n        ListNode *temp = fast->next,*slow1 = fast,*ans;\\n        \\n        int flag = 0;\\n        \\n        while(temp)\\n        {\\n            if(temp->val >= x)          // If not a smaller element just skip.\\n            {\\n                slow1 = temp;\\n                temp = temp->next;\\n            }\\n            else\\n            { \\n                slow1->next = temp->next;     //Break\\n                ListNode* copy = temp;        //The \\n                copy->next = fast;            //Link of smaller elements\\n                temp = temp -> next;          // with it\\'s preducesor and successor\\n                \\n                if(!slow)           //If first element is greater\\n                {\\n                    slow = copy;\\n                    ans = slow;\\n                    flag = 1;\\n                }\\n                else\\n                {\\n                    copy->next = slow->next;\\n                    slow->next = copy;\\n                    slow = copy;\\n                }\\n            }\\n        }\\n        return flag==0?head:ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2316951,
                "title": "faster-solution-8ms-c-detailed-explanation",
                "content": "I have tried to approach the problem by the following approach :(though i know its a noob approach but still, i think we should think in all possible directions)\\n\\nso what i have did is... first of all i have declared two vector.. one having values greater than or equal to x and the other one is storing the value smaller than x.\\nAfter that i am reversing both vectors so that i can get the values in original order.\\nThen i\\'m traversing the linked list and modifying the values from smaller to greater one.\\n\\n/**********/\\n\\noriginal : 1 - 4 - 3 - 2 - 5 - 2\\ngreater : (5 3 4)\\nsmaller(2 2 1)\\nAfter reversing :\\ngreater : (4 3 5)\\nsmaller : (1 2 2)\\nNow modifying the linked list values\\n\\nnew : 1 - 2 - 2 - 4 - 3 - 5\\n\\nBut this solution will give you MEMORY LIMIT EXCEEDED !\\nDon\\'t spam that this is a noob approach and all...i\\'m just trying to share what i have thinked so that if any beginner is reading this then he/she will get a clear idea how things work.\\n\\nBelow, i have attached the efficient solution that beats around 50% of the CPP submissions...if you can optimise it more then share it.\\n\\nHappy Learning guys !!!\\n\\n/-------CODE ----------/\\n\\nclass Solution {\\npublic:\\nListNode partition(ListNode* head, int x) {\\n\\n/*Approach 1 : Make 2 vectors.. one having values greater than or equal to x\\nand other having values less than x. Now reverse the both vectors\\nand modify the value of the linked list correspondingly */\\n// MEMORY LIMIT EXCEEDED problem !!\\n// ListNode *temp1 = head,*temp2 = head;\\n// int size=0;\\n// ListNode *trav = head;\\n// while(trav !=NULL) {\\n// trav = trav->next;\\n// size++;\\n// }\\n\\n// vector smaller,greater;\\n\\n// while(temp1 !=NULL) {\\n// if(temp1->val >= x ) greater.pb(temp1->val);\\n// else smaller.pb(temp1->val);\\n// }\\n// reverse(beg2end(smaller));\\n// reverse(beg2end(greater));\\n\\n// loop(i,0,smaller.size()) {\\n// temp2->val = smaller[i];\\n// temp2 = temp2->next;\\n// }\\n// loop(i,0,greater.size()) {\\n// temp2->val = greater[i];\\n// temp2 = temp2->next;\\n// }\\n// return head;\\n\\n/*Approach 2 : Make 2 new linked lists, one with values greater than equal to x\\n               and other having values smaller than x;\\n               Now add the last point of smaller linked list to the head of the \\n               greater linked list.\\n*/\\n\\nListNode *greater = new ListNode(0);\\nListNode *smaller = new ListNode(0);\\n\\nListNode *storegreater = greater, *storesmaller = smaller;\\n\\nListNode *temp = head;\\nwhile(temp!=NULL) {\\n    if(temp->val >= x) {\\n       greater->next = temp;\\n       greater = greater->next;\\n    }\\n    else {\\n        smaller->next = temp;\\n        smaller = smaller->next;\\n    }\\n    temp = temp->next;\\n}\\n\\nsmaller->next = storegreater->next; \\ngreater->next = NULL;\\n\\n\\nreturn storesmaller->next;\\n}\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\nListNode partition(ListNode* head, int x) {\\n\\n/*Approach 1 : Make 2 vectors.. one having values greater than or equal to x\\nand other having values less than x. Now reverse the both vectors\\nand modify the value of the linked list correspondingly */\\n// MEMORY LIMIT EXCEEDED problem !!\\n// ListNode *temp1 = head,*temp2 = head;\\n// int size=0;\\n// ListNode *trav = head;\\n// while(trav !=NULL) {\\n// trav = trav->next;\\n// size++;\\n// }",
                "codeTag": "Java"
            },
            {
                "id": 2316332,
                "title": "java-easy-fast-small-iterative-solution",
                "content": "Runtime: 0 ms, faster than 100.00% of Java online submissions for Partition List.\\nMemory Usage: 43.2 MB, less than 9.67% of Java online submissions for Partition List.\\n```\\nclass Solution {\\n  public ListNode partition(ListNode head, int x) {\\n    ListNode less = new ListNode(), grea = new ListNode();\\n    ListNode ans = less, fh = grea;\\n    \\n    for(; head != null; head = head.next)\\n      if(head.val < x) less = less.next = head;\\n      else             grea = grea.next = head;\\n    \\n    less.next = fh.next;\\n    grea.next = null;\\n    return ans.next;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public ListNode partition(ListNode head, int x) {\\n    ListNode less = new ListNode(), grea = new ListNode();\\n    ListNode ans = less, fh = grea;\\n    \\n    for(; head != null; head = head.next)\\n      if(head.val < x) less = less.next = head;\\n      else             grea = grea.next = head;\\n    \\n    less.next = fh.next;\\n    grea.next = null;\\n    return ans.next;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2315786,
                "title": "java-easy-to-understand",
                "content": "In order to solve the given problem we can declare two ListNode left and right and have two pointer nodes h1 and h2 pointing to left and right respectively. Now we will traverse through the given linked list and check if head.val<x put head in h1.next and then point h1 and head  to next. Similar steps to be followed with h2 when head.val>=x.\\n \\n![image](https://assets.leetcode.com/users/images/449f1a91-718f-4aaf-b355-7fbb8a75bb99_1658463139.474912.png)\\n\\nNow if we consider the above shown example and try our logic we observe that \\n\\n*if(head.val<x)*\\n*  h1=left\\n*  left->1=h1\\n*  left->1->2=h1\\n*  left->1->2->2=h1\\n\\n*else* \\n* h2=right\\n* right->4 = h2\\n* right->4->3 = h2\\n* right->4->3->5 = h2\\n\\nNow we have two linked lists as follows:\\n**[left,1,2,2] and [right,4,3,5]**\\n\\nonly steps left are to connect them as follows \\n* h1.next = right.next ( Now list will be [left,1,2,2,4,3,5] )\\n* But a linkedlist ends with a null so we need to do h2.next=null\\n\\nWith this we have successfully done the required operation on Linked List given.\\n### *The code is as follows:*\\n```\\nclass Solution {\\n    public ListNode partition(ListNode head, int x) {\\n        \\n        //case when list is null or only one node \\n        if(head==null || head.next==null) return head;\\n        \\n        ListNode left = new ListNode();\\n        ListNode h1 = left;\\n        \\n        ListNode right = new ListNode();\\n        ListNode h2 = right;\\n        \\n        while(head!=null){\\n            \\n            //when node val is less than x\\n            if(head.val<x){\\n                h1.next=head;\\n                head=head.next;\\n                h1=h1.next;\\n            }\\n            \\n            //when node val is greater or equal to x\\n             else{\\n                h2.next=head;\\n                head=head.next;\\n                h2=h2.next;\\n            }\\n            \\n        }\\n        \\n        //connecting the right and left lists\\n        h1.next=right.next;\\n        h2.next=null;\\n        \\n        return left.next;\\n        \\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode partition(ListNode head, int x) {\\n        \\n        //case when list is null or only one node \\n        if(head==null || head.next==null) return head;\\n        \\n        ListNode left = new ListNode();\\n        ListNode h1 = left;\\n        \\n        ListNode right = new ListNode();\\n        ListNode h2 = right;\\n        \\n        while(head!=null){\\n            \\n            //when node val is less than x\\n            if(head.val<x){\\n                h1.next=head;\\n                head=head.next;\\n                h1=h1.next;\\n            }\\n            \\n            //when node val is greater or equal to x\\n             else{\\n                h2.next=head;\\n                head=head.next;\\n                h2=h2.next;\\n            }\\n            \\n        }\\n        \\n        //connecting the right and left lists\\n        h1.next=right.next;\\n        h2.next=null;\\n        \\n        return left.next;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2315500,
                "title": "javascript-beats-80-memory-o-n",
                "content": "This is very easy problem to solve.\\n\\n**There can 2 approaches:**\\n**Approach 1 - o(n) and use 2 extra pointers**\\n1. Iterate through the list once, take out node, append it in `less` list, otherwise in `greater` list. \\n2. Later before returning, connect them\\n```\\nvar partition = function(head, x) {\\n    \\n    let ptr = head;\\n    let less = new ListNode();\\n    let greater = new ListNode();\\n    const startPtrOfLess = less;\\n    const startPtrOfGreater = greater;\\n    let basePtr;\\n    \\n    let nextPtr;\\n    \\n    while(ptr) {        \\n        nextPtr = ptr.next;\\n        \\n        if (ptr.val < x) {\\n            less.next = ptr;            \\n            less = ptr;\\n        } else {\\n            greater.next = ptr;           \\n            greater = ptr;\\n        }\\n        \\n        ptr.next = null;\\n        ptr = nextPtr;\\n    }\\n    \\n    less.next = startPtrOfGreater.next;\\n    \\n    return startPtrOfLess.next;\\n};\\n```\\n\\n**Approach 2 - Run the n loop twice, use an arrary to separate and merge**\\n1. Filter out nodes in 2 separate list\\n2. Merge those list. Make sure smaller nodes appear first.\\n3. Iterate through merged list, and update the next pointer.... simple :)\\n4. Make sure the last node is set to null to avoid cyclic reference. \\n\\n```\\nvar partition = function(head, x) {\\n    \\n    let ptr = head;\\n    let less = [];\\n    let greater = [];\\n    let basePtr;\\n    \\n    while(ptr) {\\n        if (ptr.val < x) {\\n            less.push(ptr);\\n        } else {\\n            greater.push(ptr);\\n        }\\n        \\n        ptr = ptr.next;\\n    }\\n    \\n    const final = [...less, ...greater];\\n    \\n    for(let i = 1; i < final.length; i++) {\\n        final[i - 1].next = final[i];\\n    }    \\n    \\n    const lastNode = final.at(-1);\\n    \\n    if (lastNode) {\\n        lastNode.next = null;\\n    }\\n    \\n    return final.at(0) || null;\\n};\\n```",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\nvar partition = function(head, x) {\\n    \\n    let ptr = head;\\n    let less = new ListNode();\\n    let greater = new ListNode();\\n    const startPtrOfLess = less;\\n    const startPtrOfGreater = greater;\\n    let basePtr;\\n    \\n    let nextPtr;\\n    \\n    while(ptr) {        \\n        nextPtr = ptr.next;\\n        \\n        if (ptr.val < x) {\\n            less.next = ptr;            \\n            less = ptr;\\n        } else {\\n            greater.next = ptr;           \\n            greater = ptr;\\n        }\\n        \\n        ptr.next = null;\\n        ptr = nextPtr;\\n    }\\n    \\n    less.next = startPtrOfGreater.next;\\n    \\n    return startPtrOfLess.next;\\n};\\n```\n```\\nvar partition = function(head, x) {\\n    \\n    let ptr = head;\\n    let less = [];\\n    let greater = [];\\n    let basePtr;\\n    \\n    while(ptr) {\\n        if (ptr.val < x) {\\n            less.push(ptr);\\n        } else {\\n            greater.push(ptr);\\n        }\\n        \\n        ptr = ptr.next;\\n    }\\n    \\n    const final = [...less, ...greater];\\n    \\n    for(let i = 1; i < final.length; i++) {\\n        final[i - 1].next = final[i];\\n    }    \\n    \\n    const lastNode = final.at(-1);\\n    \\n    if (lastNode) {\\n        lastNode.next = null;\\n    }\\n    \\n    return final.at(0) || null;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2315384,
                "title": "c-two-pointers-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode* small = new ListNode(0);\\n        ListNode* great = new ListNode(0);\\n        \\n        ListNode* smalltail  = small;\\n        ListNode* greattail = great;\\n        \\n        while(head!=NULL){\\n            if(head->val < x){\\n                smalltail->next = head;\\n                smalltail = smalltail->next;\\n            }\\n            else{\\n                greattail->next = head;\\n                greattail = greattail->next;\\n            }\\n            head = head -> next;\\n        }\\n        greattail->next = NULL;\\n        smalltail->next = great->next;\\n        \\n        return small->next;\\n    }\\n};\\n```\\n\\n# ****Please Upvote\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode* small = new ListNode(0);\\n        ListNode* great = new ListNode(0);\\n        \\n        ListNode* smalltail  = small;\\n        ListNode* greattail = great;\\n        \\n        while(head!=NULL){\\n            if(head->val < x){\\n                smalltail->next = head;\\n                smalltail = smalltail->next;\\n            }\\n            else{\\n                greattail->next = head;\\n                greattail = greattail->next;\\n            }\\n            head = head -> next;\\n        }\\n        greattail->next = NULL;\\n        smalltail->next = great->next;\\n        \\n        return small->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2315357,
                "title": "easy-to-understand-two-pointer",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode*dummy=new ListNode(-1);\\n        ListNode*s=dummy;\\n        ListNode*dummy2=new ListNode(-1);\\n        ListNode*l=dummy2;\\n        while(head!=NULL)\\n        {\\n            if(head->val<x)\\n            {\\n                s->next=head;\\n                s=s->next;\\n            }\\n            else\\n            {\\n                l->next=head;\\n                l=l->next; \\n            }\\n            head =head->next;\\n        }\\n        l->next=NULL;\\n        s->next=dummy2->next;\\n        return dummy->next;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "class Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode*dummy=new ListNode(-1);\\n        ListNode*s=dummy;\\n        ListNode*dummy2=new ListNode(-1);\\n        ListNode*l=dummy2;\\n        while(head!=NULL)\\n        {\\n            if(head->val<x)\\n            {\\n                s->next=head;\\n                s=s->next;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2315342,
                "title": "c-iterative-approach-o-n-time-complexity",
                "content": "\\t// in this approach we create 2 independent lists and connect them after traversing all the nodes, just simple logic and linkedlist traversal gives us the appropriate solution\\n\\t\\tListNode* partition(ListNode* head, int x) {\\n\\t\\t\\tif(head == NULL or head->next == NULL) return head;\\n\\t\\t\\tListNode *partition1 = new ListNode(0); //smaller than x\\n\\t\\t\\tListNode *partition2 = new ListNode(0); // greater than or equal to x\\n\\t\\t\\tListNode *iterator1 = partition1;        \\n\\t\\t\\tListNode *iterator2 = partition2;\\n\\t\\t\\tListNode *temp = head;\\n\\t\\t\\twhile(temp!=NULL){\\n\\t\\t\\t\\tif(temp->val < x){\\n\\t\\t\\t\\t\\titerator1->next = new ListNode(temp->val);\\n\\t\\t\\t\\t\\titerator1 = iterator1->next;\\n\\t\\t\\t\\t}else if(temp->val >= x){\\n\\t\\t\\t\\t\\titerator2->next = new ListNode(temp->val);\\n\\t\\t\\t\\t\\titerator2 = iterator2->next;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\ttemp = temp->next;\\n\\t\\t\\t}\\n\\t\\t\\t// connect end of partition1 to start of partition2\\n\\t\\t\\titerator1->next = partition2->next;\\n\\t\\t\\treturn partition1->next;\\n\\t\\t}",
                "solutionTags": [
                    "C",
                    "Linked List",
                    "Iterator"
                ],
                "code": "\\t// in this approach we create 2 independent lists and connect them after traversing all the nodes, just simple logic and linkedlist traversal gives us the appropriate solution\\n\\t\\tListNode* partition(ListNode* head, int x) {\\n\\t\\t\\tif(head == NULL or head->next == NULL) return head;\\n\\t\\t\\tListNode *partition1 = new ListNode(0); //smaller than x\\n\\t\\t\\tListNode *partition2 = new ListNode(0); // greater than or equal to x\\n\\t\\t\\tListNode *iterator1 = partition1;        \\n\\t\\t\\tListNode *iterator2 = partition2;\\n\\t\\t\\tListNode *temp = head;\\n\\t\\t\\twhile(temp!=NULL){\\n\\t\\t\\t\\tif(temp->val < x){\\n\\t\\t\\t\\t\\titerator1->next = new ListNode(temp->val);\\n\\t\\t\\t\\t\\titerator1 = iterator1->next;\\n\\t\\t\\t\\t}else if(temp->val >= x){\\n\\t\\t\\t\\t\\titerator2->next = new ListNode(temp->val);\\n\\t\\t\\t\\t\\titerator2 = iterator2->next;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\ttemp = temp->next;\\n\\t\\t\\t}\\n\\t\\t\\t// connect end of partition1 to start of partition2\\n\\t\\t\\titerator1->next = partition2->next;\\n\\t\\t\\treturn partition1->next;\\n\\t\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 2255105,
                "title": "java-solution-tc-o-n-sc-o-1-100-faster",
                "content": "/* Please upvote if you find it helpful. It will encourage me too help you guys. Happy Coding!\\n\\nIn this question, we need to partition a linked list such that all nodes less than x come before nodes greater than or equal to x.\\nNow what does that mean, this means that relative order of linked list should not be lost and to be preserved and how do we maintain that!\\n\\nSuppose, Input : 1 --> 4 --> 3 --> 2 --> 5 --> 2, x = 3\\nOutput :  1 --> 2 --> 2 --> 4 --> 3 --> 5.\\n***In this we can clearly see that 1 is coming before 2 and less than x so they are in their order. But 4 is greater than equal to 3 and first thing that will come in our mind that output should be of this order 1 --> 2 --> 2 --> 3 --> 4 --> 5 but we should not forget about the point \"all nodes less than x come before nodes greater than or equal to x.\"***\\n\\n***And their relative order should not be disturbed, hence the output is : 1 --> 2 --> 2 --> 4 --> 3 --> 5, in this 4 is coming before 3 and it doesn\\'t matter if it is greater than equal to 3 or not but they are in their relative order in which they should be.***\\n\\nNow comes to the solution, how to approach this problem.\\n\\nTo approach this problem, we can think our output as two different lists one with nodes less than x and other list with nodes greater than equal to x with their relative order.\\n\\nWe will take list1 as \"**smaller**\" and list2 as \"**higher**\", one for nodes less than x and other for nodes greater than equal to x and in order maintain these lists we also need their heads so we take \"**smallerHead**\" and \"**higherHead**\" variables which will point to smaller and higher respectively. In this end we need to concatenate these two lists.\\nThen we will traverse through the given head and check the condition within it and add our smallerHead and higherHead according to conditions. At the end our smallerHead will point to last of smaller list and higherHead will point to end of higher list.\\n\\nIn order to concatenate them, we will do **smallerHead.next = higher** and as we know that in our linked list last node should point to null and as we know in this our last node will be higherHead which will be in the end of higher list so we will do **higherHead.next = null**. And finally we return the head of concatenated list by doing **smalller.next** because smaller.next will be pointing to the first node of concatenated list.\\n*/\\nclass Solution {\\n    public ListNode partition(ListNode head, int x) {\\n        ListNode smaller = new ListNode(0);\\n        ListNode higher = new ListNode(0);\\n        \\n        ListNode smallerHead = smaller;\\n        ListNode higherHead = higher;\\n        \\n        while (head != null) {\\n            if (head.val < x) {\\n                // smaller list\\n                smallerHead.next = head;\\n                smallerHead = smallerHead.next;\\n            } else {\\n                // higher list\\n                higherHead.next = head;\\n                higherHead = higherHead.next;\\n            }\\n            head = head.next;\\n        }\\n        \\n        smallerHead.next = higher.next;\\n        higherHead.next = null;\\n        \\n        return smaller.next;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "class Solution {\\n    public ListNode partition(ListNode head, int x) {\\n        ListNode smaller = new ListNode(0);\\n        ListNode higher = new ListNode(0);\\n        \\n        ListNode smallerHead = smaller;\\n        ListNode higherHead = higher;\\n        \\n        while (head != null) {\\n            if (head.val < x) {\\n                // smaller list\\n                smallerHead.next = head;\\n                smallerHead = smallerHead.next;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2250164,
                "title": "c-implementation-using-map-explanation",
                "content": "1. First of all I am making a new linked list (dummy), then I am placing the prev node on dummy\\'s head.\\n2. Then I am keeping a curr pointer on the head of original linked list.\\n3. Then I am traversing through the original linked list and checking which node\\'s value is less than \\'x\\', if I found an element less than \\'x\\', I make a new temp node with that curr\\'s value, the I will connect prev->next (prev is on the dummy\\'s head) to temp node, then I will move prev pointer to the new temp\\'s node, I will also store curr\\'s value in a map.\\n4. Then in the second while loop i am traversing once again through the original Linked List and checking if the curr node\\'s element is present in the map, and if is not present, make a new node temp and connect prev\\'s next to temp.\\n5. Then I am returning dummy\\'s next.\\n6. Dry run the code for better understanding.\\n\\n```\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        \\n        if(head==NULL)return head;\\n        \\n        ListNode* dummy = new ListNode(-1);\\n        ListNode* prev = dummy;  //1st point\\n        ListNode* curr = head;  //2nd point\\n        unordered_map<int, int> m;\\n        while(curr){\\n            \\n            if(curr->val<x){     //3rd point\\n                ListNode* temp = new ListNode(curr->val);\\n                m[curr->val]++;\\n                prev->next = temp;\\n                prev = temp;\\n            }\\n            \\n            curr = curr->next;\\n            \\n        }\\n        curr=head;\\n        while(curr){\\n            \\n            if(m.find(curr->val)==m.end()){   //4th point\\n                ListNode* temp = new ListNode(curr->val);\\n                prev->next = temp;\\n                prev = temp;\\n            }\\n            curr = curr->next;\\n        }\\n        return dummy->next;         //5th point\\n    } \\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        \\n        if(head==NULL)return head;\\n        \\n        ListNode* dummy = new ListNode(-1);\\n        ListNode* prev = dummy;  //1st point\\n        ListNode* curr = head;  //2nd point\\n        unordered_map<int, int> m;\\n        while(curr){\\n            \\n            if(curr->val<x){     //3rd point\\n                ListNode* temp = new ListNode(curr->val);\\n                m[curr->val]++;\\n                prev->next = temp;\\n                prev = temp;\\n            }\\n            \\n            curr = curr->next;\\n            \\n        }\\n        curr=head;\\n        while(curr){\\n            \\n            if(m.find(curr->val)==m.end()){   //4th point\\n                ListNode* temp = new ListNode(curr->val);\\n                prev->next = temp;\\n                prev = temp;\\n            }\\n            curr = curr->next;\\n        }\\n        return dummy->next;         //5th point\\n    } \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2128797,
                "title": "c-solution-using-stack",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        queue<ListNode*>s;\\n        ListNode*prev=new ListNode(0),*p=head,*dummy=prev;\\n        while(p){\\n            if(p->val<x){\\n                prev->next=p;\\n                prev=p;\\n            }\\n            else{\\n                s.push(p);\\n            }\\n            \\n            p=p->next;\\n        }\\n                while(!s.empty()){\\n                    cout<<s.front()->val<<s.size()<<endl;\\n                    prev->next=s.front();\\n                    prev=prev->next;\\n                    s.pop();\\n                }\\n        prev->next=nullptr;\\n        return dummy->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List",
                    "Stack"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        queue<ListNode*>s;\\n        ListNode*prev=new ListNode(0),*p=head,*dummy=prev;\\n        while(p){\\n            if(p->val<x){\\n                prev->next=p;\\n                prev=p;\\n            }\\n            else{\\n                s.push(p);\\n            }\\n            \\n            p=p->next;\\n        }\\n                while(!s.empty()){\\n                    cout<<s.front()->val<<s.size()<<endl;\\n                    prev->next=s.front();\\n                    prev=prev->next;\\n                    s.pop();\\n                }\\n        prev->next=nullptr;\\n        return dummy->next;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1963214,
                "title": "c-o-1-space-complexity-and-o-n-time-complexity",
                "content": "\\tclass Solution {\\n\\tpublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        \\n        ListNode *leftNode=new ListNode(0);\\n        ListNode *leftHead=leftNode;\\n        ListNode *rightNode=new ListNode(0);\\n        ListNode *rightHead=rightNode;\\n        ListNode *temp=head;\\n        \\n        while(temp!=NULL){\\n            if(temp->val<x){\\n               leftNode->next=temp;\\n                leftNode=leftNode->next;\\n            }\\n            else{\\n                rightNode->next=temp;\\n                rightNode=rightNode->next;  \\n            }\\n            temp=temp->next;\\n        }\\n        rightNode->next=NULL;\\n        leftNode->next=rightHead->next;\\n        \\n        return leftHead->next;\\n    }\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        \\n        ListNode *leftNode=new ListNode(0);\\n        ListNode *leftHead=leftNode;\\n        ListNode *rightNode=new ListNode(0);\\n        ListNode *rightHead=rightNode;\\n        ListNode *temp=head;\\n        \\n        while(temp!=NULL){\\n            if(temp->val<x){\\n               leftNode->next=temp;\\n                leftNode=leftNode->next;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1932533,
                "title": "java-100-faster",
                "content": "class Solution {\\n    public ListNode partition(ListNode head, int x) {\\n     ListNode before_head = new ListNode(0);\\n     ListNode before  = before_head;\\n     ListNode after_head = new ListNode(0);\\n     ListNode after  = after_head;   \\n        \\n        while(head!= null){\\n            if(head.val <x){\\n              before.next = head;\\n              before = before.next;  \\n            }else{\\n                after.next = head;\\n                after = after.next; \\n            }\\n            head= head.next;\\n        }\\n        after.next = null;\\n        before.next = after_head.next;\\n        \\n        return before_head.next;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "class Solution {\\n    public ListNode partition(ListNode head, int x) {\\n     ListNode before_head = new ListNode(0);\\n     ListNode before  = before_head;\\n     ListNode after_head = new ListNode(0);\\n     ListNode after  = after_head;   \\n        \\n        while(head!= null){\\n            if(head.val <x){\\n              before.next = head;\\n              before = before.next;  \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1820349,
                "title": "100-faster-java-solution-0ms-solution",
                "content": "```\\nclass Solution {\\n    public ListNode partition(ListNode head, int x) {\\n        ListNode before_head= new ListNode(0);\\n        ListNode before= before_head;\\n        ListNode after_head= new ListNode(0);\\n        ListNode after= after_head;\\n        \\n        while(head!=null){\\n            if(head.val< x){\\n                before.next= head;\\n                before= before.next;\\n            }\\n            else{\\n                after.next= head;\\n                after= after.next;\\n            }\\n            head= head.next;\\n        }\\n        after.next=null;\\n        before.next= after_head.next;\\n        return before_head.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode partition(ListNode head, int x) {\\n        ListNode before_head= new ListNode(0);\\n        ListNode before= before_head;\\n        ListNode after_head= new ListNode(0);\\n        ListNode after= after_head;\\n        \\n        while(head!=null){\\n            if(head.val< x){\\n                before.next= head;\\n                before= before.next;\\n            }\\n            else{\\n                after.next= head;\\n                after= after.next;\\n            }\\n            head= head.next;\\n        }\\n        after.next=null;\\n        before.next= after_head.next;\\n        return before_head.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1770086,
                "title": "partition-list-solution-java",
                "content": "class Solution {\\n  public ListNode partition(ListNode head, int x) {\\n    ListNode beforeHead = new ListNode(0);\\n    ListNode afterHead = new ListNode(0);\\n    ListNode before = beforeHead;\\n    ListNode after = afterHead;\\n\\n    for (; head != null; head = head.next)\\n      if (head.val < x) {\\n        before.next = head;\\n        before = head;\\n      } else {\\n        after.next = head;\\n        after = head;\\n      }\\n\\n    after.next = null;\\n    before.next = afterHead.next;\\n\\n    return beforeHead.next;\\n  }\\n}\\n",
                "solutionTags": [
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "class Solution {\\n  public ListNode partition(ListNode head, int x) {\\n    ListNode beforeHead = new ListNode(0);\\n    ListNode afterHead = new ListNode(0);\\n    ListNode before = beforeHead;\\n    ListNode after = afterHead;\\n\\n    for (; head != null; head = head.next)\\n      if (head.val < x) {\\n        before.next = head;\\n        before = head;\\n      }",
                "codeTag": "Java"
            },
            {
                "id": 1528469,
                "title": "c-solution-two-pointers-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode *node1 = new ListNode();\\n        ListNode *node2 = new ListNode();\\n        \\n        ListNode *ptr1 = node1;\\n        ListNode *ptr2 = node2;\\n        \\n        while(head){\\n            if(head->val < x){\\n                node1->next = head;\\n                node1 = node1->next;\\n            }\\n            else{\\n                node2->next = head;\\n                node2 = node2->next;\\n            }\\n            \\n            head = head->next;\\n        }\\n        \\n        node2->next = NULL;\\n        node1->next = ptr2->next;\\n        \\n        return ptr1->next;\\n    }\\n};\\n```\\n\\n**UPVOTE this solution, if you find it useful.**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode *node1 = new ListNode();\\n        ListNode *node2 = new ListNode();\\n        \\n        ListNode *ptr1 = node1;\\n        ListNode *ptr2 = node2;\\n        \\n        while(head){\\n            if(head->val < x){\\n                node1->next = head;\\n                node1 = node1->next;\\n            }\\n            else{\\n                node2->next = head;\\n                node2 = node2->next;\\n            }\\n            \\n            head = head->next;\\n        }\\n        \\n        node2->next = NULL;\\n        node1->next = ptr2->next;\\n        \\n        return ptr1->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1565050,
                "content": [
                    {
                        "username": "zdf826504558",
                        "content": "The description for this problem is somewhat very misleading. \\nI took at least 15 min and tested serval test cases so that I understood what it was asking for.\\n\\nLet me briefly explain it to relieve your pain.\\n\\nBasically, it asks us:\\n`reorder the sequence by the given number x`\\n\\nThe rules are:\\n1. Any number that is `less than x` has to be before `x`, and maintain the relative order with thoese that are less than `x` but already before `x`.\\ne.g. `[3,4,1,2], target = 4` -> `[3,1,2,4]`, so the order of `[3,1,2]` is maintained.\\n2. Any number that is `greater than x` but already before `x` will still be before `x`, but all of them come after those that are less than `x` and at the same time maintain their relative order.\\ne.g. `[3,6,5,4,1,2] target = 4` -> `[3,1,2,6,5,4]`\\n3. Any number that is `greater than x` and after `x` will only need to maintain their relative order\\ne.g. `[3,6,5,4,8,1,7,2] target = 4` -> `[3,1,2,6,5,4,8,7]`\\n\\nHope this helps those who have a difficulty time understanding **\"all nodes less than x come before nodes greater than or equal to x.\"** like me.  \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\n"
                    },
                    {
                        "username": "kishore_001",
                        "content": "[@The_Laughing_Storm](/The_Laughing_Storm)  i understand the question now"
                    },
                    {
                        "username": "ahad7792",
                        "content": "Maximum leetcode  question\\'s description is very unclear"
                    },
                    {
                        "username": "pavan9100",
                        "content": "Haha!...They explained about the place and you explained about the directions"
                    },
                    {
                        "username": "dporwal985",
                        "content": "I was confused for a second and got into the discussion section about that particular line. Seeing your detailed discussion helped. Thanks man!"
                    },
                    {
                        "username": "DeadlyTRex",
                        "content": "[@diksm0ker](/diksm0ker) if relative order was important then in first test case \\nInput: head = [1,4,3,2,5,2], x = 3\\nOutput: [1,2,2,4,3,5]\\nwhy the output is not 1,4,2,2,3,5. the relative order got changed for 2 and 4 in the description\\'s output"
                    },
                    {
                        "username": "The_Laughing_Storm",
                        "content": "[@normanlmfung](/normanlmfung) Relative order means that the orignal order given. So in [3,4,1,2] the order is 3->4->1->2 so after target is 4 the order should be 3->1->2->4 because in the orignal order 3 was before 1 and 1 was before 2. Relative order means wrt to the question. These are linked lists here not arrays so order here is wierd"
                    },
                    {
                        "username": "normanlmfung",
                        "content": "It's still unclear [3,4,1,2], target = 4 -> [3,1,2,4] \n\nWhy not \n     [1,2,3,4]? <-- 1 appear before 2 so \"relative order\" still maintained\nor even \n    [1,3,2,4] <-- same here, 1 apear before 2 and \"relative order\" still maintained.\n\nAnother example,\n    [3,6,5,4,1,2] target = 4 -> [3,1,2,6,5,4]\n\n    Why not \n        [1,2,3,6,5,4]           <-- \"preserve the original relative order of the nodes in each of the two partitions\" does not explains why 1,2 should appear after 3\n        [3,6,5,1,2,4]           <-- \"all nodes less than x come before nodes greater than or equal to x\" explains why 1,2 should appear BEFORE 6,5 so this is fine\n\nQuestion poorly written. So I think developers are expected to try different test cases to understand pick up things that's not specified in problem statement."
                    },
                    {
                        "username": "comanea",
                        "content": "You understood that statement correctly. The description adds right below `You should preserve the original relative order of the nodes in each of the two partitions.`. If that wasn\\'t there when you wrote the comment, then that\\'s on the problem maker, but it looks correct now. Fortunately it\\'s an easy fix anyway."
                    },
                    {
                        "username": "Jaiff",
                        "content": "Happy Independence Day Indian bros. \\nWe live young, \\nWe live free!!!"
                    },
                    {
                        "username": "vinnnu",
                        "content": "Jai Hind!!! Onwards and Upwards"
                    },
                    {
                        "username": "ckvb18",
                        "content": "YES GLORY TO INDIA !!!"
                    },
                    {
                        "username": "codewithnavneet",
                        "content": "Happy independence day brother JAY HIND"
                    },
                    {
                        "username": "aarush_badkur30",
                        "content": "same to u bro Jai Hind "
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "jai hind"
                    },
                    {
                        "username": "kandalachetan",
                        "content": "same to you bro"
                    },
                    {
                        "username": "KingShuK17",
                        "content": "JAI HIND! upwards and onwards, always!"
                    },
                    {
                        "username": "homer_simpson",
                        "content": "\"For example,\\n\\nGiven 1->4->3->2->5->2 and x = 3,\\n\\nreturn 1->2->2->4->3->5.\"\\n\\nIn the return, why does 4 come before 3 if it's larger???\\n\\n\\nAlso, my code fails this test:\\n\"Input:\\t{2,1}, 1\\n\\nOutput:\\t{1,2}\\n\\nExpected:\\t{2,1}\"\\n\\nIf x is 1, why would the expected output have 2 come before 1?\\n\\nThanks."
                    },
                    {
                        "username": "rahulkasula23",
                        "content": "bro I done this question 8 years after your submission"
                    },
                    {
                        "username": "powerup7",
                        "content": "[@Anand_On_Leet](/Anand_On_Leet) No, no sorting of the list is required. That\\'s how you keep relative order."
                    },
                    {
                        "username": "powerup7",
                        "content": "[@Anand_On_Leet](/Anand_On_Leet) No. No sorting of the list is required. That\\'s how you keep relative order."
                    },
                    {
                        "username": "brb715",
                        "content": "In the first eg, since 4 is greater than or equal to 3(i.e x), all the nodes that are less than 3 will come before 4 and the order of the nodes should be same."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes thankfully they covered that case in the examples, right?\n\n4 comes before 3 because relative order must be preserved.\n\n3 doesn't require being moved because it is >= x.\n\nhope that wasn't too much of a spoiler."
                    },
                    {
                        "username": "Anand_On_Leet",
                        "content": "Then , we should only sort that list."
                    },
                    {
                        "username": "1ort",
                        "content": "tip: Don\\'t forget to clear the Next of the last element of the list if you are spreading elements across two lists. I tried for half an hour to figure out why my solution fails with an error until I realized that I was returning a list with a loop"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Divide the given list head into 2 linked lists, greater & smaller. Then connect these 2 lists and return the result. One more hint:\nThe whole process shown by modifying submitted code in playground\n```\n1<3:smaller\nsmaller:0->1->4->3->2->5->2\ngreater:0\n-------\n4>=3: greater\nsmaller:0->1->4->3->2->5->2\ngreater:0->4->3->2->5->2\n-------\n3>=3: greater\nsmaller:0->1->4->3->2->5->2\ngreater:0->4->3->2->5->2\n-------\n2<3:smaller\nsmaller:0->1->2->5->2\ngreater:0->4->3->2->5->2\n-------\n5>=3: greater\nsmaller:0->1->2->5->2\ngreater:0->4->3->5->2\n-------\n2<3:smaller\nsmaller:0->1->2->2\ngreater:0->4->3->5->2\n-------\nans:\n1->2->2->4->3->5\n```"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@omeirr13](/omeirr13) Since my program uses the constructors, it needs extra O(1) space, that is an extra dummy node.  With such extra dummy node makes programming easier. If you won't use extra space, it needs some modification which may lead to an error."
                    },
                    {
                        "username": "omeirr13",
                        "content": "wont this use extra space"
                    },
                    {
                        "username": "anuron_das",
                        "content": "It is an interesting problem, at least to me. If I were to explain the problem statement to anyone in the simplest terms, I would go like this:\n\nYou are given a linked list and a target number `x`.  You have to reorder the list in such a way that any node with a value `strictly less than x` appears `in the beginning` of the list, such that their relative order `among themselves` is preserved.\n\nFor example: `[1,4,3,2,5,2]` and `x=3`. All the numbers `strictly smaller than x` are `[1,2,2]`. So preserve only their relative order and add them in the beginning of the list.\n\nAfter that you have to preserve the relative order of all the `remaining elements` as well, and after that you can return the list `head`.\n\nFor example, let us consider the above example only, in `[1,4,3,2,5,2]` and `x=3`, after removing all the numbers `strictly less than x`, the remaining list is `[4,3,5]`. So their relative order is preserved accordingly.\n\nIn the end just concatenate the two and return the result.\n\nSo if the problem statement is clear, then one can appreciate the importance of `two pointers` approach, as this problem involves the use of `two pointers` on linked lists. I hope the reader finds this helpful. "
                    },
                    {
                        "username": "valige7091",
                        "content": "All the problem asks one to do is loop through a list and add each element to one of two lists, before combining the two then returning."
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@sameer89](/sameer89) well, as i understood valige, he meant to say take 2 separate lists of all nodes < x and nodes >= x, and then in the end join the tail of one to head of another which will take O(n). "
                    },
                    {
                        "username": "sameer89",
                        "content": "[@2uringTested](/2uringTested) No it wont.  Since these are linked lists it can be done in O(1) space like \"merge\" in mergesort."
                    },
                    {
                        "username": "2uringTested",
                        "content": "that will use extra space, thats not the best solution, you can do the partition in the same list and in one pass."
                    },
                    {
                        "username": "woodyinho",
                        "content": "Input: head = 1->4->3->2->5->2, x = 3\\nOutput: 1->2->2->4->3->5\\n\\nwhy 4 is exist before than 3 not after ?\\n"
                    },
                    {
                        "username": "pahwagautam786",
                        "content": "Because we also have to maintane  the relative order of elements and we have to compare with greater or eqaul to \\'x\\' "
                    },
                    {
                        "username": "sairam852",
                        "content": "because problem description was all nodes less than x come before nodes greater than or equal to x i.e., we no need to move the greater values to after of that targeted value"
                    },
                    {
                        "username": "Abhishen99",
                        "content": "\\n[328. Odd Even Linked List ](https://leetcode.com/problems/odd-even-linked-list/)\\n\\nabove problem is quite similiar to this problem after trying this you can solve that too.\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I wanted to comment the same thing, that one is a nice follow up, requiring O(1) space and O(n) time"
                    },
                    {
                        "username": "Ausho_Roup",
                        "content": "Anyone please explain this question. I am unable to get it. I am trying to understand nearly from two days still not able to figure it out ."
                    },
                    {
                        "username": "nikhilnyalakanti2003",
                        "content": "checkout the discussion section again, ig you\\'ll have it cleared this time"
                    }
                ]
            },
            {
                "id": 2014762,
                "content": [
                    {
                        "username": "zdf826504558",
                        "content": "The description for this problem is somewhat very misleading. \\nI took at least 15 min and tested serval test cases so that I understood what it was asking for.\\n\\nLet me briefly explain it to relieve your pain.\\n\\nBasically, it asks us:\\n`reorder the sequence by the given number x`\\n\\nThe rules are:\\n1. Any number that is `less than x` has to be before `x`, and maintain the relative order with thoese that are less than `x` but already before `x`.\\ne.g. `[3,4,1,2], target = 4` -> `[3,1,2,4]`, so the order of `[3,1,2]` is maintained.\\n2. Any number that is `greater than x` but already before `x` will still be before `x`, but all of them come after those that are less than `x` and at the same time maintain their relative order.\\ne.g. `[3,6,5,4,1,2] target = 4` -> `[3,1,2,6,5,4]`\\n3. Any number that is `greater than x` and after `x` will only need to maintain their relative order\\ne.g. `[3,6,5,4,8,1,7,2] target = 4` -> `[3,1,2,6,5,4,8,7]`\\n\\nHope this helps those who have a difficulty time understanding **\"all nodes less than x come before nodes greater than or equal to x.\"** like me.  \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\n"
                    },
                    {
                        "username": "kishore_001",
                        "content": "[@The_Laughing_Storm](/The_Laughing_Storm)  i understand the question now"
                    },
                    {
                        "username": "ahad7792",
                        "content": "Maximum leetcode  question\\'s description is very unclear"
                    },
                    {
                        "username": "pavan9100",
                        "content": "Haha!...They explained about the place and you explained about the directions"
                    },
                    {
                        "username": "dporwal985",
                        "content": "I was confused for a second and got into the discussion section about that particular line. Seeing your detailed discussion helped. Thanks man!"
                    },
                    {
                        "username": "DeadlyTRex",
                        "content": "[@diksm0ker](/diksm0ker) if relative order was important then in first test case \\nInput: head = [1,4,3,2,5,2], x = 3\\nOutput: [1,2,2,4,3,5]\\nwhy the output is not 1,4,2,2,3,5. the relative order got changed for 2 and 4 in the description\\'s output"
                    },
                    {
                        "username": "The_Laughing_Storm",
                        "content": "[@normanlmfung](/normanlmfung) Relative order means that the orignal order given. So in [3,4,1,2] the order is 3->4->1->2 so after target is 4 the order should be 3->1->2->4 because in the orignal order 3 was before 1 and 1 was before 2. Relative order means wrt to the question. These are linked lists here not arrays so order here is wierd"
                    },
                    {
                        "username": "normanlmfung",
                        "content": "It's still unclear [3,4,1,2], target = 4 -> [3,1,2,4] \n\nWhy not \n     [1,2,3,4]? <-- 1 appear before 2 so \"relative order\" still maintained\nor even \n    [1,3,2,4] <-- same here, 1 apear before 2 and \"relative order\" still maintained.\n\nAnother example,\n    [3,6,5,4,1,2] target = 4 -> [3,1,2,6,5,4]\n\n    Why not \n        [1,2,3,6,5,4]           <-- \"preserve the original relative order of the nodes in each of the two partitions\" does not explains why 1,2 should appear after 3\n        [3,6,5,1,2,4]           <-- \"all nodes less than x come before nodes greater than or equal to x\" explains why 1,2 should appear BEFORE 6,5 so this is fine\n\nQuestion poorly written. So I think developers are expected to try different test cases to understand pick up things that's not specified in problem statement."
                    },
                    {
                        "username": "comanea",
                        "content": "You understood that statement correctly. The description adds right below `You should preserve the original relative order of the nodes in each of the two partitions.`. If that wasn\\'t there when you wrote the comment, then that\\'s on the problem maker, but it looks correct now. Fortunately it\\'s an easy fix anyway."
                    },
                    {
                        "username": "Jaiff",
                        "content": "Happy Independence Day Indian bros. \\nWe live young, \\nWe live free!!!"
                    },
                    {
                        "username": "vinnnu",
                        "content": "Jai Hind!!! Onwards and Upwards"
                    },
                    {
                        "username": "ckvb18",
                        "content": "YES GLORY TO INDIA !!!"
                    },
                    {
                        "username": "codewithnavneet",
                        "content": "Happy independence day brother JAY HIND"
                    },
                    {
                        "username": "aarush_badkur30",
                        "content": "same to u bro Jai Hind "
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "jai hind"
                    },
                    {
                        "username": "kandalachetan",
                        "content": "same to you bro"
                    },
                    {
                        "username": "KingShuK17",
                        "content": "JAI HIND! upwards and onwards, always!"
                    },
                    {
                        "username": "homer_simpson",
                        "content": "\"For example,\\n\\nGiven 1->4->3->2->5->2 and x = 3,\\n\\nreturn 1->2->2->4->3->5.\"\\n\\nIn the return, why does 4 come before 3 if it's larger???\\n\\n\\nAlso, my code fails this test:\\n\"Input:\\t{2,1}, 1\\n\\nOutput:\\t{1,2}\\n\\nExpected:\\t{2,1}\"\\n\\nIf x is 1, why would the expected output have 2 come before 1?\\n\\nThanks."
                    },
                    {
                        "username": "rahulkasula23",
                        "content": "bro I done this question 8 years after your submission"
                    },
                    {
                        "username": "powerup7",
                        "content": "[@Anand_On_Leet](/Anand_On_Leet) No, no sorting of the list is required. That\\'s how you keep relative order."
                    },
                    {
                        "username": "powerup7",
                        "content": "[@Anand_On_Leet](/Anand_On_Leet) No. No sorting of the list is required. That\\'s how you keep relative order."
                    },
                    {
                        "username": "brb715",
                        "content": "In the first eg, since 4 is greater than or equal to 3(i.e x), all the nodes that are less than 3 will come before 4 and the order of the nodes should be same."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes thankfully they covered that case in the examples, right?\n\n4 comes before 3 because relative order must be preserved.\n\n3 doesn't require being moved because it is >= x.\n\nhope that wasn't too much of a spoiler."
                    },
                    {
                        "username": "Anand_On_Leet",
                        "content": "Then , we should only sort that list."
                    },
                    {
                        "username": "1ort",
                        "content": "tip: Don\\'t forget to clear the Next of the last element of the list if you are spreading elements across two lists. I tried for half an hour to figure out why my solution fails with an error until I realized that I was returning a list with a loop"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Divide the given list head into 2 linked lists, greater & smaller. Then connect these 2 lists and return the result. One more hint:\nThe whole process shown by modifying submitted code in playground\n```\n1<3:smaller\nsmaller:0->1->4->3->2->5->2\ngreater:0\n-------\n4>=3: greater\nsmaller:0->1->4->3->2->5->2\ngreater:0->4->3->2->5->2\n-------\n3>=3: greater\nsmaller:0->1->4->3->2->5->2\ngreater:0->4->3->2->5->2\n-------\n2<3:smaller\nsmaller:0->1->2->5->2\ngreater:0->4->3->2->5->2\n-------\n5>=3: greater\nsmaller:0->1->2->5->2\ngreater:0->4->3->5->2\n-------\n2<3:smaller\nsmaller:0->1->2->2\ngreater:0->4->3->5->2\n-------\nans:\n1->2->2->4->3->5\n```"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@omeirr13](/omeirr13) Since my program uses the constructors, it needs extra O(1) space, that is an extra dummy node.  With such extra dummy node makes programming easier. If you won't use extra space, it needs some modification which may lead to an error."
                    },
                    {
                        "username": "omeirr13",
                        "content": "wont this use extra space"
                    },
                    {
                        "username": "anuron_das",
                        "content": "It is an interesting problem, at least to me. If I were to explain the problem statement to anyone in the simplest terms, I would go like this:\n\nYou are given a linked list and a target number `x`.  You have to reorder the list in such a way that any node with a value `strictly less than x` appears `in the beginning` of the list, such that their relative order `among themselves` is preserved.\n\nFor example: `[1,4,3,2,5,2]` and `x=3`. All the numbers `strictly smaller than x` are `[1,2,2]`. So preserve only their relative order and add them in the beginning of the list.\n\nAfter that you have to preserve the relative order of all the `remaining elements` as well, and after that you can return the list `head`.\n\nFor example, let us consider the above example only, in `[1,4,3,2,5,2]` and `x=3`, after removing all the numbers `strictly less than x`, the remaining list is `[4,3,5]`. So their relative order is preserved accordingly.\n\nIn the end just concatenate the two and return the result.\n\nSo if the problem statement is clear, then one can appreciate the importance of `two pointers` approach, as this problem involves the use of `two pointers` on linked lists. I hope the reader finds this helpful. "
                    },
                    {
                        "username": "valige7091",
                        "content": "All the problem asks one to do is loop through a list and add each element to one of two lists, before combining the two then returning."
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@sameer89](/sameer89) well, as i understood valige, he meant to say take 2 separate lists of all nodes < x and nodes >= x, and then in the end join the tail of one to head of another which will take O(n). "
                    },
                    {
                        "username": "sameer89",
                        "content": "[@2uringTested](/2uringTested) No it wont.  Since these are linked lists it can be done in O(1) space like \"merge\" in mergesort."
                    },
                    {
                        "username": "2uringTested",
                        "content": "that will use extra space, thats not the best solution, you can do the partition in the same list and in one pass."
                    },
                    {
                        "username": "woodyinho",
                        "content": "Input: head = 1->4->3->2->5->2, x = 3\\nOutput: 1->2->2->4->3->5\\n\\nwhy 4 is exist before than 3 not after ?\\n"
                    },
                    {
                        "username": "pahwagautam786",
                        "content": "Because we also have to maintane  the relative order of elements and we have to compare with greater or eqaul to \\'x\\' "
                    },
                    {
                        "username": "sairam852",
                        "content": "because problem description was all nodes less than x come before nodes greater than or equal to x i.e., we no need to move the greater values to after of that targeted value"
                    },
                    {
                        "username": "Abhishen99",
                        "content": "\\n[328. Odd Even Linked List ](https://leetcode.com/problems/odd-even-linked-list/)\\n\\nabove problem is quite similiar to this problem after trying this you can solve that too.\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I wanted to comment the same thing, that one is a nice follow up, requiring O(1) space and O(n) time"
                    },
                    {
                        "username": "Ausho_Roup",
                        "content": "Anyone please explain this question. I am unable to get it. I am trying to understand nearly from two days still not able to figure it out ."
                    },
                    {
                        "username": "nikhilnyalakanti2003",
                        "content": "checkout the discussion section again, ig you\\'ll have it cleared this time"
                    }
                ]
            },
            {
                "id": 1564789,
                "content": [
                    {
                        "username": "zdf826504558",
                        "content": "The description for this problem is somewhat very misleading. \\nI took at least 15 min and tested serval test cases so that I understood what it was asking for.\\n\\nLet me briefly explain it to relieve your pain.\\n\\nBasically, it asks us:\\n`reorder the sequence by the given number x`\\n\\nThe rules are:\\n1. Any number that is `less than x` has to be before `x`, and maintain the relative order with thoese that are less than `x` but already before `x`.\\ne.g. `[3,4,1,2], target = 4` -> `[3,1,2,4]`, so the order of `[3,1,2]` is maintained.\\n2. Any number that is `greater than x` but already before `x` will still be before `x`, but all of them come after those that are less than `x` and at the same time maintain their relative order.\\ne.g. `[3,6,5,4,1,2] target = 4` -> `[3,1,2,6,5,4]`\\n3. Any number that is `greater than x` and after `x` will only need to maintain their relative order\\ne.g. `[3,6,5,4,8,1,7,2] target = 4` -> `[3,1,2,6,5,4,8,7]`\\n\\nHope this helps those who have a difficulty time understanding **\"all nodes less than x come before nodes greater than or equal to x.\"** like me.  \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\n"
                    },
                    {
                        "username": "kishore_001",
                        "content": "[@The_Laughing_Storm](/The_Laughing_Storm)  i understand the question now"
                    },
                    {
                        "username": "ahad7792",
                        "content": "Maximum leetcode  question\\'s description is very unclear"
                    },
                    {
                        "username": "pavan9100",
                        "content": "Haha!...They explained about the place and you explained about the directions"
                    },
                    {
                        "username": "dporwal985",
                        "content": "I was confused for a second and got into the discussion section about that particular line. Seeing your detailed discussion helped. Thanks man!"
                    },
                    {
                        "username": "DeadlyTRex",
                        "content": "[@diksm0ker](/diksm0ker) if relative order was important then in first test case \\nInput: head = [1,4,3,2,5,2], x = 3\\nOutput: [1,2,2,4,3,5]\\nwhy the output is not 1,4,2,2,3,5. the relative order got changed for 2 and 4 in the description\\'s output"
                    },
                    {
                        "username": "The_Laughing_Storm",
                        "content": "[@normanlmfung](/normanlmfung) Relative order means that the orignal order given. So in [3,4,1,2] the order is 3->4->1->2 so after target is 4 the order should be 3->1->2->4 because in the orignal order 3 was before 1 and 1 was before 2. Relative order means wrt to the question. These are linked lists here not arrays so order here is wierd"
                    },
                    {
                        "username": "normanlmfung",
                        "content": "It's still unclear [3,4,1,2], target = 4 -> [3,1,2,4] \n\nWhy not \n     [1,2,3,4]? <-- 1 appear before 2 so \"relative order\" still maintained\nor even \n    [1,3,2,4] <-- same here, 1 apear before 2 and \"relative order\" still maintained.\n\nAnother example,\n    [3,6,5,4,1,2] target = 4 -> [3,1,2,6,5,4]\n\n    Why not \n        [1,2,3,6,5,4]           <-- \"preserve the original relative order of the nodes in each of the two partitions\" does not explains why 1,2 should appear after 3\n        [3,6,5,1,2,4]           <-- \"all nodes less than x come before nodes greater than or equal to x\" explains why 1,2 should appear BEFORE 6,5 so this is fine\n\nQuestion poorly written. So I think developers are expected to try different test cases to understand pick up things that's not specified in problem statement."
                    },
                    {
                        "username": "comanea",
                        "content": "You understood that statement correctly. The description adds right below `You should preserve the original relative order of the nodes in each of the two partitions.`. If that wasn\\'t there when you wrote the comment, then that\\'s on the problem maker, but it looks correct now. Fortunately it\\'s an easy fix anyway."
                    },
                    {
                        "username": "Jaiff",
                        "content": "Happy Independence Day Indian bros. \\nWe live young, \\nWe live free!!!"
                    },
                    {
                        "username": "vinnnu",
                        "content": "Jai Hind!!! Onwards and Upwards"
                    },
                    {
                        "username": "ckvb18",
                        "content": "YES GLORY TO INDIA !!!"
                    },
                    {
                        "username": "codewithnavneet",
                        "content": "Happy independence day brother JAY HIND"
                    },
                    {
                        "username": "aarush_badkur30",
                        "content": "same to u bro Jai Hind "
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "jai hind"
                    },
                    {
                        "username": "kandalachetan",
                        "content": "same to you bro"
                    },
                    {
                        "username": "KingShuK17",
                        "content": "JAI HIND! upwards and onwards, always!"
                    },
                    {
                        "username": "homer_simpson",
                        "content": "\"For example,\\n\\nGiven 1->4->3->2->5->2 and x = 3,\\n\\nreturn 1->2->2->4->3->5.\"\\n\\nIn the return, why does 4 come before 3 if it's larger???\\n\\n\\nAlso, my code fails this test:\\n\"Input:\\t{2,1}, 1\\n\\nOutput:\\t{1,2}\\n\\nExpected:\\t{2,1}\"\\n\\nIf x is 1, why would the expected output have 2 come before 1?\\n\\nThanks."
                    },
                    {
                        "username": "rahulkasula23",
                        "content": "bro I done this question 8 years after your submission"
                    },
                    {
                        "username": "powerup7",
                        "content": "[@Anand_On_Leet](/Anand_On_Leet) No, no sorting of the list is required. That\\'s how you keep relative order."
                    },
                    {
                        "username": "powerup7",
                        "content": "[@Anand_On_Leet](/Anand_On_Leet) No. No sorting of the list is required. That\\'s how you keep relative order."
                    },
                    {
                        "username": "brb715",
                        "content": "In the first eg, since 4 is greater than or equal to 3(i.e x), all the nodes that are less than 3 will come before 4 and the order of the nodes should be same."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes thankfully they covered that case in the examples, right?\n\n4 comes before 3 because relative order must be preserved.\n\n3 doesn't require being moved because it is >= x.\n\nhope that wasn't too much of a spoiler."
                    },
                    {
                        "username": "Anand_On_Leet",
                        "content": "Then , we should only sort that list."
                    },
                    {
                        "username": "1ort",
                        "content": "tip: Don\\'t forget to clear the Next of the last element of the list if you are spreading elements across two lists. I tried for half an hour to figure out why my solution fails with an error until I realized that I was returning a list with a loop"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Divide the given list head into 2 linked lists, greater & smaller. Then connect these 2 lists and return the result. One more hint:\nThe whole process shown by modifying submitted code in playground\n```\n1<3:smaller\nsmaller:0->1->4->3->2->5->2\ngreater:0\n-------\n4>=3: greater\nsmaller:0->1->4->3->2->5->2\ngreater:0->4->3->2->5->2\n-------\n3>=3: greater\nsmaller:0->1->4->3->2->5->2\ngreater:0->4->3->2->5->2\n-------\n2<3:smaller\nsmaller:0->1->2->5->2\ngreater:0->4->3->2->5->2\n-------\n5>=3: greater\nsmaller:0->1->2->5->2\ngreater:0->4->3->5->2\n-------\n2<3:smaller\nsmaller:0->1->2->2\ngreater:0->4->3->5->2\n-------\nans:\n1->2->2->4->3->5\n```"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@omeirr13](/omeirr13) Since my program uses the constructors, it needs extra O(1) space, that is an extra dummy node.  With such extra dummy node makes programming easier. If you won't use extra space, it needs some modification which may lead to an error."
                    },
                    {
                        "username": "omeirr13",
                        "content": "wont this use extra space"
                    },
                    {
                        "username": "anuron_das",
                        "content": "It is an interesting problem, at least to me. If I were to explain the problem statement to anyone in the simplest terms, I would go like this:\n\nYou are given a linked list and a target number `x`.  You have to reorder the list in such a way that any node with a value `strictly less than x` appears `in the beginning` of the list, such that their relative order `among themselves` is preserved.\n\nFor example: `[1,4,3,2,5,2]` and `x=3`. All the numbers `strictly smaller than x` are `[1,2,2]`. So preserve only their relative order and add them in the beginning of the list.\n\nAfter that you have to preserve the relative order of all the `remaining elements` as well, and after that you can return the list `head`.\n\nFor example, let us consider the above example only, in `[1,4,3,2,5,2]` and `x=3`, after removing all the numbers `strictly less than x`, the remaining list is `[4,3,5]`. So their relative order is preserved accordingly.\n\nIn the end just concatenate the two and return the result.\n\nSo if the problem statement is clear, then one can appreciate the importance of `two pointers` approach, as this problem involves the use of `two pointers` on linked lists. I hope the reader finds this helpful. "
                    },
                    {
                        "username": "valige7091",
                        "content": "All the problem asks one to do is loop through a list and add each element to one of two lists, before combining the two then returning."
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@sameer89](/sameer89) well, as i understood valige, he meant to say take 2 separate lists of all nodes < x and nodes >= x, and then in the end join the tail of one to head of another which will take O(n). "
                    },
                    {
                        "username": "sameer89",
                        "content": "[@2uringTested](/2uringTested) No it wont.  Since these are linked lists it can be done in O(1) space like \"merge\" in mergesort."
                    },
                    {
                        "username": "2uringTested",
                        "content": "that will use extra space, thats not the best solution, you can do the partition in the same list and in one pass."
                    },
                    {
                        "username": "woodyinho",
                        "content": "Input: head = 1->4->3->2->5->2, x = 3\\nOutput: 1->2->2->4->3->5\\n\\nwhy 4 is exist before than 3 not after ?\\n"
                    },
                    {
                        "username": "pahwagautam786",
                        "content": "Because we also have to maintane  the relative order of elements and we have to compare with greater or eqaul to \\'x\\' "
                    },
                    {
                        "username": "sairam852",
                        "content": "because problem description was all nodes less than x come before nodes greater than or equal to x i.e., we no need to move the greater values to after of that targeted value"
                    },
                    {
                        "username": "Abhishen99",
                        "content": "\\n[328. Odd Even Linked List ](https://leetcode.com/problems/odd-even-linked-list/)\\n\\nabove problem is quite similiar to this problem after trying this you can solve that too.\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I wanted to comment the same thing, that one is a nice follow up, requiring O(1) space and O(n) time"
                    },
                    {
                        "username": "Ausho_Roup",
                        "content": "Anyone please explain this question. I am unable to get it. I am trying to understand nearly from two days still not able to figure it out ."
                    },
                    {
                        "username": "nikhilnyalakanti2003",
                        "content": "checkout the discussion section again, ig you\\'ll have it cleared this time"
                    }
                ]
            },
            {
                "id": 1750971,
                "content": [
                    {
                        "username": "zdf826504558",
                        "content": "The description for this problem is somewhat very misleading. \\nI took at least 15 min and tested serval test cases so that I understood what it was asking for.\\n\\nLet me briefly explain it to relieve your pain.\\n\\nBasically, it asks us:\\n`reorder the sequence by the given number x`\\n\\nThe rules are:\\n1. Any number that is `less than x` has to be before `x`, and maintain the relative order with thoese that are less than `x` but already before `x`.\\ne.g. `[3,4,1,2], target = 4` -> `[3,1,2,4]`, so the order of `[3,1,2]` is maintained.\\n2. Any number that is `greater than x` but already before `x` will still be before `x`, but all of them come after those that are less than `x` and at the same time maintain their relative order.\\ne.g. `[3,6,5,4,1,2] target = 4` -> `[3,1,2,6,5,4]`\\n3. Any number that is `greater than x` and after `x` will only need to maintain their relative order\\ne.g. `[3,6,5,4,8,1,7,2] target = 4` -> `[3,1,2,6,5,4,8,7]`\\n\\nHope this helps those who have a difficulty time understanding **\"all nodes less than x come before nodes greater than or equal to x.\"** like me.  \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\n"
                    },
                    {
                        "username": "kishore_001",
                        "content": "[@The_Laughing_Storm](/The_Laughing_Storm)  i understand the question now"
                    },
                    {
                        "username": "ahad7792",
                        "content": "Maximum leetcode  question\\'s description is very unclear"
                    },
                    {
                        "username": "pavan9100",
                        "content": "Haha!...They explained about the place and you explained about the directions"
                    },
                    {
                        "username": "dporwal985",
                        "content": "I was confused for a second and got into the discussion section about that particular line. Seeing your detailed discussion helped. Thanks man!"
                    },
                    {
                        "username": "DeadlyTRex",
                        "content": "[@diksm0ker](/diksm0ker) if relative order was important then in first test case \\nInput: head = [1,4,3,2,5,2], x = 3\\nOutput: [1,2,2,4,3,5]\\nwhy the output is not 1,4,2,2,3,5. the relative order got changed for 2 and 4 in the description\\'s output"
                    },
                    {
                        "username": "The_Laughing_Storm",
                        "content": "[@normanlmfung](/normanlmfung) Relative order means that the orignal order given. So in [3,4,1,2] the order is 3->4->1->2 so after target is 4 the order should be 3->1->2->4 because in the orignal order 3 was before 1 and 1 was before 2. Relative order means wrt to the question. These are linked lists here not arrays so order here is wierd"
                    },
                    {
                        "username": "normanlmfung",
                        "content": "It's still unclear [3,4,1,2], target = 4 -> [3,1,2,4] \n\nWhy not \n     [1,2,3,4]? <-- 1 appear before 2 so \"relative order\" still maintained\nor even \n    [1,3,2,4] <-- same here, 1 apear before 2 and \"relative order\" still maintained.\n\nAnother example,\n    [3,6,5,4,1,2] target = 4 -> [3,1,2,6,5,4]\n\n    Why not \n        [1,2,3,6,5,4]           <-- \"preserve the original relative order of the nodes in each of the two partitions\" does not explains why 1,2 should appear after 3\n        [3,6,5,1,2,4]           <-- \"all nodes less than x come before nodes greater than or equal to x\" explains why 1,2 should appear BEFORE 6,5 so this is fine\n\nQuestion poorly written. So I think developers are expected to try different test cases to understand pick up things that's not specified in problem statement."
                    },
                    {
                        "username": "comanea",
                        "content": "You understood that statement correctly. The description adds right below `You should preserve the original relative order of the nodes in each of the two partitions.`. If that wasn\\'t there when you wrote the comment, then that\\'s on the problem maker, but it looks correct now. Fortunately it\\'s an easy fix anyway."
                    },
                    {
                        "username": "Jaiff",
                        "content": "Happy Independence Day Indian bros. \\nWe live young, \\nWe live free!!!"
                    },
                    {
                        "username": "vinnnu",
                        "content": "Jai Hind!!! Onwards and Upwards"
                    },
                    {
                        "username": "ckvb18",
                        "content": "YES GLORY TO INDIA !!!"
                    },
                    {
                        "username": "codewithnavneet",
                        "content": "Happy independence day brother JAY HIND"
                    },
                    {
                        "username": "aarush_badkur30",
                        "content": "same to u bro Jai Hind "
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "jai hind"
                    },
                    {
                        "username": "kandalachetan",
                        "content": "same to you bro"
                    },
                    {
                        "username": "KingShuK17",
                        "content": "JAI HIND! upwards and onwards, always!"
                    },
                    {
                        "username": "homer_simpson",
                        "content": "\"For example,\\n\\nGiven 1->4->3->2->5->2 and x = 3,\\n\\nreturn 1->2->2->4->3->5.\"\\n\\nIn the return, why does 4 come before 3 if it's larger???\\n\\n\\nAlso, my code fails this test:\\n\"Input:\\t{2,1}, 1\\n\\nOutput:\\t{1,2}\\n\\nExpected:\\t{2,1}\"\\n\\nIf x is 1, why would the expected output have 2 come before 1?\\n\\nThanks."
                    },
                    {
                        "username": "rahulkasula23",
                        "content": "bro I done this question 8 years after your submission"
                    },
                    {
                        "username": "powerup7",
                        "content": "[@Anand_On_Leet](/Anand_On_Leet) No, no sorting of the list is required. That\\'s how you keep relative order."
                    },
                    {
                        "username": "powerup7",
                        "content": "[@Anand_On_Leet](/Anand_On_Leet) No. No sorting of the list is required. That\\'s how you keep relative order."
                    },
                    {
                        "username": "brb715",
                        "content": "In the first eg, since 4 is greater than or equal to 3(i.e x), all the nodes that are less than 3 will come before 4 and the order of the nodes should be same."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes thankfully they covered that case in the examples, right?\n\n4 comes before 3 because relative order must be preserved.\n\n3 doesn't require being moved because it is >= x.\n\nhope that wasn't too much of a spoiler."
                    },
                    {
                        "username": "Anand_On_Leet",
                        "content": "Then , we should only sort that list."
                    },
                    {
                        "username": "1ort",
                        "content": "tip: Don\\'t forget to clear the Next of the last element of the list if you are spreading elements across two lists. I tried for half an hour to figure out why my solution fails with an error until I realized that I was returning a list with a loop"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Divide the given list head into 2 linked lists, greater & smaller. Then connect these 2 lists and return the result. One more hint:\nThe whole process shown by modifying submitted code in playground\n```\n1<3:smaller\nsmaller:0->1->4->3->2->5->2\ngreater:0\n-------\n4>=3: greater\nsmaller:0->1->4->3->2->5->2\ngreater:0->4->3->2->5->2\n-------\n3>=3: greater\nsmaller:0->1->4->3->2->5->2\ngreater:0->4->3->2->5->2\n-------\n2<3:smaller\nsmaller:0->1->2->5->2\ngreater:0->4->3->2->5->2\n-------\n5>=3: greater\nsmaller:0->1->2->5->2\ngreater:0->4->3->5->2\n-------\n2<3:smaller\nsmaller:0->1->2->2\ngreater:0->4->3->5->2\n-------\nans:\n1->2->2->4->3->5\n```"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@omeirr13](/omeirr13) Since my program uses the constructors, it needs extra O(1) space, that is an extra dummy node.  With such extra dummy node makes programming easier. If you won't use extra space, it needs some modification which may lead to an error."
                    },
                    {
                        "username": "omeirr13",
                        "content": "wont this use extra space"
                    },
                    {
                        "username": "anuron_das",
                        "content": "It is an interesting problem, at least to me. If I were to explain the problem statement to anyone in the simplest terms, I would go like this:\n\nYou are given a linked list and a target number `x`.  You have to reorder the list in such a way that any node with a value `strictly less than x` appears `in the beginning` of the list, such that their relative order `among themselves` is preserved.\n\nFor example: `[1,4,3,2,5,2]` and `x=3`. All the numbers `strictly smaller than x` are `[1,2,2]`. So preserve only their relative order and add them in the beginning of the list.\n\nAfter that you have to preserve the relative order of all the `remaining elements` as well, and after that you can return the list `head`.\n\nFor example, let us consider the above example only, in `[1,4,3,2,5,2]` and `x=3`, after removing all the numbers `strictly less than x`, the remaining list is `[4,3,5]`. So their relative order is preserved accordingly.\n\nIn the end just concatenate the two and return the result.\n\nSo if the problem statement is clear, then one can appreciate the importance of `two pointers` approach, as this problem involves the use of `two pointers` on linked lists. I hope the reader finds this helpful. "
                    },
                    {
                        "username": "valige7091",
                        "content": "All the problem asks one to do is loop through a list and add each element to one of two lists, before combining the two then returning."
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@sameer89](/sameer89) well, as i understood valige, he meant to say take 2 separate lists of all nodes < x and nodes >= x, and then in the end join the tail of one to head of another which will take O(n). "
                    },
                    {
                        "username": "sameer89",
                        "content": "[@2uringTested](/2uringTested) No it wont.  Since these are linked lists it can be done in O(1) space like \"merge\" in mergesort."
                    },
                    {
                        "username": "2uringTested",
                        "content": "that will use extra space, thats not the best solution, you can do the partition in the same list and in one pass."
                    },
                    {
                        "username": "woodyinho",
                        "content": "Input: head = 1->4->3->2->5->2, x = 3\\nOutput: 1->2->2->4->3->5\\n\\nwhy 4 is exist before than 3 not after ?\\n"
                    },
                    {
                        "username": "pahwagautam786",
                        "content": "Because we also have to maintane  the relative order of elements and we have to compare with greater or eqaul to \\'x\\' "
                    },
                    {
                        "username": "sairam852",
                        "content": "because problem description was all nodes less than x come before nodes greater than or equal to x i.e., we no need to move the greater values to after of that targeted value"
                    },
                    {
                        "username": "Abhishen99",
                        "content": "\\n[328. Odd Even Linked List ](https://leetcode.com/problems/odd-even-linked-list/)\\n\\nabove problem is quite similiar to this problem after trying this you can solve that too.\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I wanted to comment the same thing, that one is a nice follow up, requiring O(1) space and O(n) time"
                    },
                    {
                        "username": "Ausho_Roup",
                        "content": "Anyone please explain this question. I am unable to get it. I am trying to understand nearly from two days still not able to figure it out ."
                    },
                    {
                        "username": "nikhilnyalakanti2003",
                        "content": "checkout the discussion section again, ig you\\'ll have it cleared this time"
                    }
                ]
            },
            {
                "id": 2014581,
                "content": [
                    {
                        "username": "zdf826504558",
                        "content": "The description for this problem is somewhat very misleading. \\nI took at least 15 min and tested serval test cases so that I understood what it was asking for.\\n\\nLet me briefly explain it to relieve your pain.\\n\\nBasically, it asks us:\\n`reorder the sequence by the given number x`\\n\\nThe rules are:\\n1. Any number that is `less than x` has to be before `x`, and maintain the relative order with thoese that are less than `x` but already before `x`.\\ne.g. `[3,4,1,2], target = 4` -> `[3,1,2,4]`, so the order of `[3,1,2]` is maintained.\\n2. Any number that is `greater than x` but already before `x` will still be before `x`, but all of them come after those that are less than `x` and at the same time maintain their relative order.\\ne.g. `[3,6,5,4,1,2] target = 4` -> `[3,1,2,6,5,4]`\\n3. Any number that is `greater than x` and after `x` will only need to maintain their relative order\\ne.g. `[3,6,5,4,8,1,7,2] target = 4` -> `[3,1,2,6,5,4,8,7]`\\n\\nHope this helps those who have a difficulty time understanding **\"all nodes less than x come before nodes greater than or equal to x.\"** like me.  \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\n"
                    },
                    {
                        "username": "kishore_001",
                        "content": "[@The_Laughing_Storm](/The_Laughing_Storm)  i understand the question now"
                    },
                    {
                        "username": "ahad7792",
                        "content": "Maximum leetcode  question\\'s description is very unclear"
                    },
                    {
                        "username": "pavan9100",
                        "content": "Haha!...They explained about the place and you explained about the directions"
                    },
                    {
                        "username": "dporwal985",
                        "content": "I was confused for a second and got into the discussion section about that particular line. Seeing your detailed discussion helped. Thanks man!"
                    },
                    {
                        "username": "DeadlyTRex",
                        "content": "[@diksm0ker](/diksm0ker) if relative order was important then in first test case \\nInput: head = [1,4,3,2,5,2], x = 3\\nOutput: [1,2,2,4,3,5]\\nwhy the output is not 1,4,2,2,3,5. the relative order got changed for 2 and 4 in the description\\'s output"
                    },
                    {
                        "username": "The_Laughing_Storm",
                        "content": "[@normanlmfung](/normanlmfung) Relative order means that the orignal order given. So in [3,4,1,2] the order is 3->4->1->2 so after target is 4 the order should be 3->1->2->4 because in the orignal order 3 was before 1 and 1 was before 2. Relative order means wrt to the question. These are linked lists here not arrays so order here is wierd"
                    },
                    {
                        "username": "normanlmfung",
                        "content": "It's still unclear [3,4,1,2], target = 4 -> [3,1,2,4] \n\nWhy not \n     [1,2,3,4]? <-- 1 appear before 2 so \"relative order\" still maintained\nor even \n    [1,3,2,4] <-- same here, 1 apear before 2 and \"relative order\" still maintained.\n\nAnother example,\n    [3,6,5,4,1,2] target = 4 -> [3,1,2,6,5,4]\n\n    Why not \n        [1,2,3,6,5,4]           <-- \"preserve the original relative order of the nodes in each of the two partitions\" does not explains why 1,2 should appear after 3\n        [3,6,5,1,2,4]           <-- \"all nodes less than x come before nodes greater than or equal to x\" explains why 1,2 should appear BEFORE 6,5 so this is fine\n\nQuestion poorly written. So I think developers are expected to try different test cases to understand pick up things that's not specified in problem statement."
                    },
                    {
                        "username": "comanea",
                        "content": "You understood that statement correctly. The description adds right below `You should preserve the original relative order of the nodes in each of the two partitions.`. If that wasn\\'t there when you wrote the comment, then that\\'s on the problem maker, but it looks correct now. Fortunately it\\'s an easy fix anyway."
                    },
                    {
                        "username": "Jaiff",
                        "content": "Happy Independence Day Indian bros. \\nWe live young, \\nWe live free!!!"
                    },
                    {
                        "username": "vinnnu",
                        "content": "Jai Hind!!! Onwards and Upwards"
                    },
                    {
                        "username": "ckvb18",
                        "content": "YES GLORY TO INDIA !!!"
                    },
                    {
                        "username": "codewithnavneet",
                        "content": "Happy independence day brother JAY HIND"
                    },
                    {
                        "username": "aarush_badkur30",
                        "content": "same to u bro Jai Hind "
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "jai hind"
                    },
                    {
                        "username": "kandalachetan",
                        "content": "same to you bro"
                    },
                    {
                        "username": "KingShuK17",
                        "content": "JAI HIND! upwards and onwards, always!"
                    },
                    {
                        "username": "homer_simpson",
                        "content": "\"For example,\\n\\nGiven 1->4->3->2->5->2 and x = 3,\\n\\nreturn 1->2->2->4->3->5.\"\\n\\nIn the return, why does 4 come before 3 if it's larger???\\n\\n\\nAlso, my code fails this test:\\n\"Input:\\t{2,1}, 1\\n\\nOutput:\\t{1,2}\\n\\nExpected:\\t{2,1}\"\\n\\nIf x is 1, why would the expected output have 2 come before 1?\\n\\nThanks."
                    },
                    {
                        "username": "rahulkasula23",
                        "content": "bro I done this question 8 years after your submission"
                    },
                    {
                        "username": "powerup7",
                        "content": "[@Anand_On_Leet](/Anand_On_Leet) No, no sorting of the list is required. That\\'s how you keep relative order."
                    },
                    {
                        "username": "powerup7",
                        "content": "[@Anand_On_Leet](/Anand_On_Leet) No. No sorting of the list is required. That\\'s how you keep relative order."
                    },
                    {
                        "username": "brb715",
                        "content": "In the first eg, since 4 is greater than or equal to 3(i.e x), all the nodes that are less than 3 will come before 4 and the order of the nodes should be same."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes thankfully they covered that case in the examples, right?\n\n4 comes before 3 because relative order must be preserved.\n\n3 doesn't require being moved because it is >= x.\n\nhope that wasn't too much of a spoiler."
                    },
                    {
                        "username": "Anand_On_Leet",
                        "content": "Then , we should only sort that list."
                    },
                    {
                        "username": "1ort",
                        "content": "tip: Don\\'t forget to clear the Next of the last element of the list if you are spreading elements across two lists. I tried for half an hour to figure out why my solution fails with an error until I realized that I was returning a list with a loop"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Divide the given list head into 2 linked lists, greater & smaller. Then connect these 2 lists and return the result. One more hint:\nThe whole process shown by modifying submitted code in playground\n```\n1<3:smaller\nsmaller:0->1->4->3->2->5->2\ngreater:0\n-------\n4>=3: greater\nsmaller:0->1->4->3->2->5->2\ngreater:0->4->3->2->5->2\n-------\n3>=3: greater\nsmaller:0->1->4->3->2->5->2\ngreater:0->4->3->2->5->2\n-------\n2<3:smaller\nsmaller:0->1->2->5->2\ngreater:0->4->3->2->5->2\n-------\n5>=3: greater\nsmaller:0->1->2->5->2\ngreater:0->4->3->5->2\n-------\n2<3:smaller\nsmaller:0->1->2->2\ngreater:0->4->3->5->2\n-------\nans:\n1->2->2->4->3->5\n```"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@omeirr13](/omeirr13) Since my program uses the constructors, it needs extra O(1) space, that is an extra dummy node.  With such extra dummy node makes programming easier. If you won't use extra space, it needs some modification which may lead to an error."
                    },
                    {
                        "username": "omeirr13",
                        "content": "wont this use extra space"
                    },
                    {
                        "username": "anuron_das",
                        "content": "It is an interesting problem, at least to me. If I were to explain the problem statement to anyone in the simplest terms, I would go like this:\n\nYou are given a linked list and a target number `x`.  You have to reorder the list in such a way that any node with a value `strictly less than x` appears `in the beginning` of the list, such that their relative order `among themselves` is preserved.\n\nFor example: `[1,4,3,2,5,2]` and `x=3`. All the numbers `strictly smaller than x` are `[1,2,2]`. So preserve only their relative order and add them in the beginning of the list.\n\nAfter that you have to preserve the relative order of all the `remaining elements` as well, and after that you can return the list `head`.\n\nFor example, let us consider the above example only, in `[1,4,3,2,5,2]` and `x=3`, after removing all the numbers `strictly less than x`, the remaining list is `[4,3,5]`. So their relative order is preserved accordingly.\n\nIn the end just concatenate the two and return the result.\n\nSo if the problem statement is clear, then one can appreciate the importance of `two pointers` approach, as this problem involves the use of `two pointers` on linked lists. I hope the reader finds this helpful. "
                    },
                    {
                        "username": "valige7091",
                        "content": "All the problem asks one to do is loop through a list and add each element to one of two lists, before combining the two then returning."
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@sameer89](/sameer89) well, as i understood valige, he meant to say take 2 separate lists of all nodes < x and nodes >= x, and then in the end join the tail of one to head of another which will take O(n). "
                    },
                    {
                        "username": "sameer89",
                        "content": "[@2uringTested](/2uringTested) No it wont.  Since these are linked lists it can be done in O(1) space like \"merge\" in mergesort."
                    },
                    {
                        "username": "2uringTested",
                        "content": "that will use extra space, thats not the best solution, you can do the partition in the same list and in one pass."
                    },
                    {
                        "username": "woodyinho",
                        "content": "Input: head = 1->4->3->2->5->2, x = 3\\nOutput: 1->2->2->4->3->5\\n\\nwhy 4 is exist before than 3 not after ?\\n"
                    },
                    {
                        "username": "pahwagautam786",
                        "content": "Because we also have to maintane  the relative order of elements and we have to compare with greater or eqaul to \\'x\\' "
                    },
                    {
                        "username": "sairam852",
                        "content": "because problem description was all nodes less than x come before nodes greater than or equal to x i.e., we no need to move the greater values to after of that targeted value"
                    },
                    {
                        "username": "Abhishen99",
                        "content": "\\n[328. Odd Even Linked List ](https://leetcode.com/problems/odd-even-linked-list/)\\n\\nabove problem is quite similiar to this problem after trying this you can solve that too.\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I wanted to comment the same thing, that one is a nice follow up, requiring O(1) space and O(n) time"
                    },
                    {
                        "username": "Ausho_Roup",
                        "content": "Anyone please explain this question. I am unable to get it. I am trying to understand nearly from two days still not able to figure it out ."
                    },
                    {
                        "username": "nikhilnyalakanti2003",
                        "content": "checkout the discussion section again, ig you\\'ll have it cleared this time"
                    }
                ]
            },
            {
                "id": 2014671,
                "content": [
                    {
                        "username": "zdf826504558",
                        "content": "The description for this problem is somewhat very misleading. \\nI took at least 15 min and tested serval test cases so that I understood what it was asking for.\\n\\nLet me briefly explain it to relieve your pain.\\n\\nBasically, it asks us:\\n`reorder the sequence by the given number x`\\n\\nThe rules are:\\n1. Any number that is `less than x` has to be before `x`, and maintain the relative order with thoese that are less than `x` but already before `x`.\\ne.g. `[3,4,1,2], target = 4` -> `[3,1,2,4]`, so the order of `[3,1,2]` is maintained.\\n2. Any number that is `greater than x` but already before `x` will still be before `x`, but all of them come after those that are less than `x` and at the same time maintain their relative order.\\ne.g. `[3,6,5,4,1,2] target = 4` -> `[3,1,2,6,5,4]`\\n3. Any number that is `greater than x` and after `x` will only need to maintain their relative order\\ne.g. `[3,6,5,4,8,1,7,2] target = 4` -> `[3,1,2,6,5,4,8,7]`\\n\\nHope this helps those who have a difficulty time understanding **\"all nodes less than x come before nodes greater than or equal to x.\"** like me.  \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\n"
                    },
                    {
                        "username": "kishore_001",
                        "content": "[@The_Laughing_Storm](/The_Laughing_Storm)  i understand the question now"
                    },
                    {
                        "username": "ahad7792",
                        "content": "Maximum leetcode  question\\'s description is very unclear"
                    },
                    {
                        "username": "pavan9100",
                        "content": "Haha!...They explained about the place and you explained about the directions"
                    },
                    {
                        "username": "dporwal985",
                        "content": "I was confused for a second and got into the discussion section about that particular line. Seeing your detailed discussion helped. Thanks man!"
                    },
                    {
                        "username": "DeadlyTRex",
                        "content": "[@diksm0ker](/diksm0ker) if relative order was important then in first test case \\nInput: head = [1,4,3,2,5,2], x = 3\\nOutput: [1,2,2,4,3,5]\\nwhy the output is not 1,4,2,2,3,5. the relative order got changed for 2 and 4 in the description\\'s output"
                    },
                    {
                        "username": "The_Laughing_Storm",
                        "content": "[@normanlmfung](/normanlmfung) Relative order means that the orignal order given. So in [3,4,1,2] the order is 3->4->1->2 so after target is 4 the order should be 3->1->2->4 because in the orignal order 3 was before 1 and 1 was before 2. Relative order means wrt to the question. These are linked lists here not arrays so order here is wierd"
                    },
                    {
                        "username": "normanlmfung",
                        "content": "It's still unclear [3,4,1,2], target = 4 -> [3,1,2,4] \n\nWhy not \n     [1,2,3,4]? <-- 1 appear before 2 so \"relative order\" still maintained\nor even \n    [1,3,2,4] <-- same here, 1 apear before 2 and \"relative order\" still maintained.\n\nAnother example,\n    [3,6,5,4,1,2] target = 4 -> [3,1,2,6,5,4]\n\n    Why not \n        [1,2,3,6,5,4]           <-- \"preserve the original relative order of the nodes in each of the two partitions\" does not explains why 1,2 should appear after 3\n        [3,6,5,1,2,4]           <-- \"all nodes less than x come before nodes greater than or equal to x\" explains why 1,2 should appear BEFORE 6,5 so this is fine\n\nQuestion poorly written. So I think developers are expected to try different test cases to understand pick up things that's not specified in problem statement."
                    },
                    {
                        "username": "comanea",
                        "content": "You understood that statement correctly. The description adds right below `You should preserve the original relative order of the nodes in each of the two partitions.`. If that wasn\\'t there when you wrote the comment, then that\\'s on the problem maker, but it looks correct now. Fortunately it\\'s an easy fix anyway."
                    },
                    {
                        "username": "Jaiff",
                        "content": "Happy Independence Day Indian bros. \\nWe live young, \\nWe live free!!!"
                    },
                    {
                        "username": "vinnnu",
                        "content": "Jai Hind!!! Onwards and Upwards"
                    },
                    {
                        "username": "ckvb18",
                        "content": "YES GLORY TO INDIA !!!"
                    },
                    {
                        "username": "codewithnavneet",
                        "content": "Happy independence day brother JAY HIND"
                    },
                    {
                        "username": "aarush_badkur30",
                        "content": "same to u bro Jai Hind "
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "jai hind"
                    },
                    {
                        "username": "kandalachetan",
                        "content": "same to you bro"
                    },
                    {
                        "username": "KingShuK17",
                        "content": "JAI HIND! upwards and onwards, always!"
                    },
                    {
                        "username": "homer_simpson",
                        "content": "\"For example,\\n\\nGiven 1->4->3->2->5->2 and x = 3,\\n\\nreturn 1->2->2->4->3->5.\"\\n\\nIn the return, why does 4 come before 3 if it's larger???\\n\\n\\nAlso, my code fails this test:\\n\"Input:\\t{2,1}, 1\\n\\nOutput:\\t{1,2}\\n\\nExpected:\\t{2,1}\"\\n\\nIf x is 1, why would the expected output have 2 come before 1?\\n\\nThanks."
                    },
                    {
                        "username": "rahulkasula23",
                        "content": "bro I done this question 8 years after your submission"
                    },
                    {
                        "username": "powerup7",
                        "content": "[@Anand_On_Leet](/Anand_On_Leet) No, no sorting of the list is required. That\\'s how you keep relative order."
                    },
                    {
                        "username": "powerup7",
                        "content": "[@Anand_On_Leet](/Anand_On_Leet) No. No sorting of the list is required. That\\'s how you keep relative order."
                    },
                    {
                        "username": "brb715",
                        "content": "In the first eg, since 4 is greater than or equal to 3(i.e x), all the nodes that are less than 3 will come before 4 and the order of the nodes should be same."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes thankfully they covered that case in the examples, right?\n\n4 comes before 3 because relative order must be preserved.\n\n3 doesn't require being moved because it is >= x.\n\nhope that wasn't too much of a spoiler."
                    },
                    {
                        "username": "Anand_On_Leet",
                        "content": "Then , we should only sort that list."
                    },
                    {
                        "username": "1ort",
                        "content": "tip: Don\\'t forget to clear the Next of the last element of the list if you are spreading elements across two lists. I tried for half an hour to figure out why my solution fails with an error until I realized that I was returning a list with a loop"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Divide the given list head into 2 linked lists, greater & smaller. Then connect these 2 lists and return the result. One more hint:\nThe whole process shown by modifying submitted code in playground\n```\n1<3:smaller\nsmaller:0->1->4->3->2->5->2\ngreater:0\n-------\n4>=3: greater\nsmaller:0->1->4->3->2->5->2\ngreater:0->4->3->2->5->2\n-------\n3>=3: greater\nsmaller:0->1->4->3->2->5->2\ngreater:0->4->3->2->5->2\n-------\n2<3:smaller\nsmaller:0->1->2->5->2\ngreater:0->4->3->2->5->2\n-------\n5>=3: greater\nsmaller:0->1->2->5->2\ngreater:0->4->3->5->2\n-------\n2<3:smaller\nsmaller:0->1->2->2\ngreater:0->4->3->5->2\n-------\nans:\n1->2->2->4->3->5\n```"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@omeirr13](/omeirr13) Since my program uses the constructors, it needs extra O(1) space, that is an extra dummy node.  With such extra dummy node makes programming easier. If you won't use extra space, it needs some modification which may lead to an error."
                    },
                    {
                        "username": "omeirr13",
                        "content": "wont this use extra space"
                    },
                    {
                        "username": "anuron_das",
                        "content": "It is an interesting problem, at least to me. If I were to explain the problem statement to anyone in the simplest terms, I would go like this:\n\nYou are given a linked list and a target number `x`.  You have to reorder the list in such a way that any node with a value `strictly less than x` appears `in the beginning` of the list, such that their relative order `among themselves` is preserved.\n\nFor example: `[1,4,3,2,5,2]` and `x=3`. All the numbers `strictly smaller than x` are `[1,2,2]`. So preserve only their relative order and add them in the beginning of the list.\n\nAfter that you have to preserve the relative order of all the `remaining elements` as well, and after that you can return the list `head`.\n\nFor example, let us consider the above example only, in `[1,4,3,2,5,2]` and `x=3`, after removing all the numbers `strictly less than x`, the remaining list is `[4,3,5]`. So their relative order is preserved accordingly.\n\nIn the end just concatenate the two and return the result.\n\nSo if the problem statement is clear, then one can appreciate the importance of `two pointers` approach, as this problem involves the use of `two pointers` on linked lists. I hope the reader finds this helpful. "
                    },
                    {
                        "username": "valige7091",
                        "content": "All the problem asks one to do is loop through a list and add each element to one of two lists, before combining the two then returning."
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@sameer89](/sameer89) well, as i understood valige, he meant to say take 2 separate lists of all nodes < x and nodes >= x, and then in the end join the tail of one to head of another which will take O(n). "
                    },
                    {
                        "username": "sameer89",
                        "content": "[@2uringTested](/2uringTested) No it wont.  Since these are linked lists it can be done in O(1) space like \"merge\" in mergesort."
                    },
                    {
                        "username": "2uringTested",
                        "content": "that will use extra space, thats not the best solution, you can do the partition in the same list and in one pass."
                    },
                    {
                        "username": "woodyinho",
                        "content": "Input: head = 1->4->3->2->5->2, x = 3\\nOutput: 1->2->2->4->3->5\\n\\nwhy 4 is exist before than 3 not after ?\\n"
                    },
                    {
                        "username": "pahwagautam786",
                        "content": "Because we also have to maintane  the relative order of elements and we have to compare with greater or eqaul to \\'x\\' "
                    },
                    {
                        "username": "sairam852",
                        "content": "because problem description was all nodes less than x come before nodes greater than or equal to x i.e., we no need to move the greater values to after of that targeted value"
                    },
                    {
                        "username": "Abhishen99",
                        "content": "\\n[328. Odd Even Linked List ](https://leetcode.com/problems/odd-even-linked-list/)\\n\\nabove problem is quite similiar to this problem after trying this you can solve that too.\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I wanted to comment the same thing, that one is a nice follow up, requiring O(1) space and O(n) time"
                    },
                    {
                        "username": "Ausho_Roup",
                        "content": "Anyone please explain this question. I am unable to get it. I am trying to understand nearly from two days still not able to figure it out ."
                    },
                    {
                        "username": "nikhilnyalakanti2003",
                        "content": "checkout the discussion section again, ig you\\'ll have it cleared this time"
                    }
                ]
            },
            {
                "id": 1570330,
                "content": [
                    {
                        "username": "zdf826504558",
                        "content": "The description for this problem is somewhat very misleading. \\nI took at least 15 min and tested serval test cases so that I understood what it was asking for.\\n\\nLet me briefly explain it to relieve your pain.\\n\\nBasically, it asks us:\\n`reorder the sequence by the given number x`\\n\\nThe rules are:\\n1. Any number that is `less than x` has to be before `x`, and maintain the relative order with thoese that are less than `x` but already before `x`.\\ne.g. `[3,4,1,2], target = 4` -> `[3,1,2,4]`, so the order of `[3,1,2]` is maintained.\\n2. Any number that is `greater than x` but already before `x` will still be before `x`, but all of them come after those that are less than `x` and at the same time maintain their relative order.\\ne.g. `[3,6,5,4,1,2] target = 4` -> `[3,1,2,6,5,4]`\\n3. Any number that is `greater than x` and after `x` will only need to maintain their relative order\\ne.g. `[3,6,5,4,8,1,7,2] target = 4` -> `[3,1,2,6,5,4,8,7]`\\n\\nHope this helps those who have a difficulty time understanding **\"all nodes less than x come before nodes greater than or equal to x.\"** like me.  \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\n"
                    },
                    {
                        "username": "kishore_001",
                        "content": "[@The_Laughing_Storm](/The_Laughing_Storm)  i understand the question now"
                    },
                    {
                        "username": "ahad7792",
                        "content": "Maximum leetcode  question\\'s description is very unclear"
                    },
                    {
                        "username": "pavan9100",
                        "content": "Haha!...They explained about the place and you explained about the directions"
                    },
                    {
                        "username": "dporwal985",
                        "content": "I was confused for a second and got into the discussion section about that particular line. Seeing your detailed discussion helped. Thanks man!"
                    },
                    {
                        "username": "DeadlyTRex",
                        "content": "[@diksm0ker](/diksm0ker) if relative order was important then in first test case \\nInput: head = [1,4,3,2,5,2], x = 3\\nOutput: [1,2,2,4,3,5]\\nwhy the output is not 1,4,2,2,3,5. the relative order got changed for 2 and 4 in the description\\'s output"
                    },
                    {
                        "username": "The_Laughing_Storm",
                        "content": "[@normanlmfung](/normanlmfung) Relative order means that the orignal order given. So in [3,4,1,2] the order is 3->4->1->2 so after target is 4 the order should be 3->1->2->4 because in the orignal order 3 was before 1 and 1 was before 2. Relative order means wrt to the question. These are linked lists here not arrays so order here is wierd"
                    },
                    {
                        "username": "normanlmfung",
                        "content": "It's still unclear [3,4,1,2], target = 4 -> [3,1,2,4] \n\nWhy not \n     [1,2,3,4]? <-- 1 appear before 2 so \"relative order\" still maintained\nor even \n    [1,3,2,4] <-- same here, 1 apear before 2 and \"relative order\" still maintained.\n\nAnother example,\n    [3,6,5,4,1,2] target = 4 -> [3,1,2,6,5,4]\n\n    Why not \n        [1,2,3,6,5,4]           <-- \"preserve the original relative order of the nodes in each of the two partitions\" does not explains why 1,2 should appear after 3\n        [3,6,5,1,2,4]           <-- \"all nodes less than x come before nodes greater than or equal to x\" explains why 1,2 should appear BEFORE 6,5 so this is fine\n\nQuestion poorly written. So I think developers are expected to try different test cases to understand pick up things that's not specified in problem statement."
                    },
                    {
                        "username": "comanea",
                        "content": "You understood that statement correctly. The description adds right below `You should preserve the original relative order of the nodes in each of the two partitions.`. If that wasn\\'t there when you wrote the comment, then that\\'s on the problem maker, but it looks correct now. Fortunately it\\'s an easy fix anyway."
                    },
                    {
                        "username": "Jaiff",
                        "content": "Happy Independence Day Indian bros. \\nWe live young, \\nWe live free!!!"
                    },
                    {
                        "username": "vinnnu",
                        "content": "Jai Hind!!! Onwards and Upwards"
                    },
                    {
                        "username": "ckvb18",
                        "content": "YES GLORY TO INDIA !!!"
                    },
                    {
                        "username": "codewithnavneet",
                        "content": "Happy independence day brother JAY HIND"
                    },
                    {
                        "username": "aarush_badkur30",
                        "content": "same to u bro Jai Hind "
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "jai hind"
                    },
                    {
                        "username": "kandalachetan",
                        "content": "same to you bro"
                    },
                    {
                        "username": "KingShuK17",
                        "content": "JAI HIND! upwards and onwards, always!"
                    },
                    {
                        "username": "homer_simpson",
                        "content": "\"For example,\\n\\nGiven 1->4->3->2->5->2 and x = 3,\\n\\nreturn 1->2->2->4->3->5.\"\\n\\nIn the return, why does 4 come before 3 if it's larger???\\n\\n\\nAlso, my code fails this test:\\n\"Input:\\t{2,1}, 1\\n\\nOutput:\\t{1,2}\\n\\nExpected:\\t{2,1}\"\\n\\nIf x is 1, why would the expected output have 2 come before 1?\\n\\nThanks."
                    },
                    {
                        "username": "rahulkasula23",
                        "content": "bro I done this question 8 years after your submission"
                    },
                    {
                        "username": "powerup7",
                        "content": "[@Anand_On_Leet](/Anand_On_Leet) No, no sorting of the list is required. That\\'s how you keep relative order."
                    },
                    {
                        "username": "powerup7",
                        "content": "[@Anand_On_Leet](/Anand_On_Leet) No. No sorting of the list is required. That\\'s how you keep relative order."
                    },
                    {
                        "username": "brb715",
                        "content": "In the first eg, since 4 is greater than or equal to 3(i.e x), all the nodes that are less than 3 will come before 4 and the order of the nodes should be same."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes thankfully they covered that case in the examples, right?\n\n4 comes before 3 because relative order must be preserved.\n\n3 doesn't require being moved because it is >= x.\n\nhope that wasn't too much of a spoiler."
                    },
                    {
                        "username": "Anand_On_Leet",
                        "content": "Then , we should only sort that list."
                    },
                    {
                        "username": "1ort",
                        "content": "tip: Don\\'t forget to clear the Next of the last element of the list if you are spreading elements across two lists. I tried for half an hour to figure out why my solution fails with an error until I realized that I was returning a list with a loop"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Divide the given list head into 2 linked lists, greater & smaller. Then connect these 2 lists and return the result. One more hint:\nThe whole process shown by modifying submitted code in playground\n```\n1<3:smaller\nsmaller:0->1->4->3->2->5->2\ngreater:0\n-------\n4>=3: greater\nsmaller:0->1->4->3->2->5->2\ngreater:0->4->3->2->5->2\n-------\n3>=3: greater\nsmaller:0->1->4->3->2->5->2\ngreater:0->4->3->2->5->2\n-------\n2<3:smaller\nsmaller:0->1->2->5->2\ngreater:0->4->3->2->5->2\n-------\n5>=3: greater\nsmaller:0->1->2->5->2\ngreater:0->4->3->5->2\n-------\n2<3:smaller\nsmaller:0->1->2->2\ngreater:0->4->3->5->2\n-------\nans:\n1->2->2->4->3->5\n```"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@omeirr13](/omeirr13) Since my program uses the constructors, it needs extra O(1) space, that is an extra dummy node.  With such extra dummy node makes programming easier. If you won't use extra space, it needs some modification which may lead to an error."
                    },
                    {
                        "username": "omeirr13",
                        "content": "wont this use extra space"
                    },
                    {
                        "username": "anuron_das",
                        "content": "It is an interesting problem, at least to me. If I were to explain the problem statement to anyone in the simplest terms, I would go like this:\n\nYou are given a linked list and a target number `x`.  You have to reorder the list in such a way that any node with a value `strictly less than x` appears `in the beginning` of the list, such that their relative order `among themselves` is preserved.\n\nFor example: `[1,4,3,2,5,2]` and `x=3`. All the numbers `strictly smaller than x` are `[1,2,2]`. So preserve only their relative order and add them in the beginning of the list.\n\nAfter that you have to preserve the relative order of all the `remaining elements` as well, and after that you can return the list `head`.\n\nFor example, let us consider the above example only, in `[1,4,3,2,5,2]` and `x=3`, after removing all the numbers `strictly less than x`, the remaining list is `[4,3,5]`. So their relative order is preserved accordingly.\n\nIn the end just concatenate the two and return the result.\n\nSo if the problem statement is clear, then one can appreciate the importance of `two pointers` approach, as this problem involves the use of `two pointers` on linked lists. I hope the reader finds this helpful. "
                    },
                    {
                        "username": "valige7091",
                        "content": "All the problem asks one to do is loop through a list and add each element to one of two lists, before combining the two then returning."
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@sameer89](/sameer89) well, as i understood valige, he meant to say take 2 separate lists of all nodes < x and nodes >= x, and then in the end join the tail of one to head of another which will take O(n). "
                    },
                    {
                        "username": "sameer89",
                        "content": "[@2uringTested](/2uringTested) No it wont.  Since these are linked lists it can be done in O(1) space like \"merge\" in mergesort."
                    },
                    {
                        "username": "2uringTested",
                        "content": "that will use extra space, thats not the best solution, you can do the partition in the same list and in one pass."
                    },
                    {
                        "username": "woodyinho",
                        "content": "Input: head = 1->4->3->2->5->2, x = 3\\nOutput: 1->2->2->4->3->5\\n\\nwhy 4 is exist before than 3 not after ?\\n"
                    },
                    {
                        "username": "pahwagautam786",
                        "content": "Because we also have to maintane  the relative order of elements and we have to compare with greater or eqaul to \\'x\\' "
                    },
                    {
                        "username": "sairam852",
                        "content": "because problem description was all nodes less than x come before nodes greater than or equal to x i.e., we no need to move the greater values to after of that targeted value"
                    },
                    {
                        "username": "Abhishen99",
                        "content": "\\n[328. Odd Even Linked List ](https://leetcode.com/problems/odd-even-linked-list/)\\n\\nabove problem is quite similiar to this problem after trying this you can solve that too.\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I wanted to comment the same thing, that one is a nice follow up, requiring O(1) space and O(n) time"
                    },
                    {
                        "username": "Ausho_Roup",
                        "content": "Anyone please explain this question. I am unable to get it. I am trying to understand nearly from two days still not able to figure it out ."
                    },
                    {
                        "username": "nikhilnyalakanti2003",
                        "content": "checkout the discussion section again, ig you\\'ll have it cleared this time"
                    }
                ]
            },
            {
                "id": 1568102,
                "content": [
                    {
                        "username": "zdf826504558",
                        "content": "The description for this problem is somewhat very misleading. \\nI took at least 15 min and tested serval test cases so that I understood what it was asking for.\\n\\nLet me briefly explain it to relieve your pain.\\n\\nBasically, it asks us:\\n`reorder the sequence by the given number x`\\n\\nThe rules are:\\n1. Any number that is `less than x` has to be before `x`, and maintain the relative order with thoese that are less than `x` but already before `x`.\\ne.g. `[3,4,1,2], target = 4` -> `[3,1,2,4]`, so the order of `[3,1,2]` is maintained.\\n2. Any number that is `greater than x` but already before `x` will still be before `x`, but all of them come after those that are less than `x` and at the same time maintain their relative order.\\ne.g. `[3,6,5,4,1,2] target = 4` -> `[3,1,2,6,5,4]`\\n3. Any number that is `greater than x` and after `x` will only need to maintain their relative order\\ne.g. `[3,6,5,4,8,1,7,2] target = 4` -> `[3,1,2,6,5,4,8,7]`\\n\\nHope this helps those who have a difficulty time understanding **\"all nodes less than x come before nodes greater than or equal to x.\"** like me.  \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\n"
                    },
                    {
                        "username": "kishore_001",
                        "content": "[@The_Laughing_Storm](/The_Laughing_Storm)  i understand the question now"
                    },
                    {
                        "username": "ahad7792",
                        "content": "Maximum leetcode  question\\'s description is very unclear"
                    },
                    {
                        "username": "pavan9100",
                        "content": "Haha!...They explained about the place and you explained about the directions"
                    },
                    {
                        "username": "dporwal985",
                        "content": "I was confused for a second and got into the discussion section about that particular line. Seeing your detailed discussion helped. Thanks man!"
                    },
                    {
                        "username": "DeadlyTRex",
                        "content": "[@diksm0ker](/diksm0ker) if relative order was important then in first test case \\nInput: head = [1,4,3,2,5,2], x = 3\\nOutput: [1,2,2,4,3,5]\\nwhy the output is not 1,4,2,2,3,5. the relative order got changed for 2 and 4 in the description\\'s output"
                    },
                    {
                        "username": "The_Laughing_Storm",
                        "content": "[@normanlmfung](/normanlmfung) Relative order means that the orignal order given. So in [3,4,1,2] the order is 3->4->1->2 so after target is 4 the order should be 3->1->2->4 because in the orignal order 3 was before 1 and 1 was before 2. Relative order means wrt to the question. These are linked lists here not arrays so order here is wierd"
                    },
                    {
                        "username": "normanlmfung",
                        "content": "It's still unclear [3,4,1,2], target = 4 -> [3,1,2,4] \n\nWhy not \n     [1,2,3,4]? <-- 1 appear before 2 so \"relative order\" still maintained\nor even \n    [1,3,2,4] <-- same here, 1 apear before 2 and \"relative order\" still maintained.\n\nAnother example,\n    [3,6,5,4,1,2] target = 4 -> [3,1,2,6,5,4]\n\n    Why not \n        [1,2,3,6,5,4]           <-- \"preserve the original relative order of the nodes in each of the two partitions\" does not explains why 1,2 should appear after 3\n        [3,6,5,1,2,4]           <-- \"all nodes less than x come before nodes greater than or equal to x\" explains why 1,2 should appear BEFORE 6,5 so this is fine\n\nQuestion poorly written. So I think developers are expected to try different test cases to understand pick up things that's not specified in problem statement."
                    },
                    {
                        "username": "comanea",
                        "content": "You understood that statement correctly. The description adds right below `You should preserve the original relative order of the nodes in each of the two partitions.`. If that wasn\\'t there when you wrote the comment, then that\\'s on the problem maker, but it looks correct now. Fortunately it\\'s an easy fix anyway."
                    },
                    {
                        "username": "Jaiff",
                        "content": "Happy Independence Day Indian bros. \\nWe live young, \\nWe live free!!!"
                    },
                    {
                        "username": "vinnnu",
                        "content": "Jai Hind!!! Onwards and Upwards"
                    },
                    {
                        "username": "ckvb18",
                        "content": "YES GLORY TO INDIA !!!"
                    },
                    {
                        "username": "codewithnavneet",
                        "content": "Happy independence day brother JAY HIND"
                    },
                    {
                        "username": "aarush_badkur30",
                        "content": "same to u bro Jai Hind "
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "jai hind"
                    },
                    {
                        "username": "kandalachetan",
                        "content": "same to you bro"
                    },
                    {
                        "username": "KingShuK17",
                        "content": "JAI HIND! upwards and onwards, always!"
                    },
                    {
                        "username": "homer_simpson",
                        "content": "\"For example,\\n\\nGiven 1->4->3->2->5->2 and x = 3,\\n\\nreturn 1->2->2->4->3->5.\"\\n\\nIn the return, why does 4 come before 3 if it's larger???\\n\\n\\nAlso, my code fails this test:\\n\"Input:\\t{2,1}, 1\\n\\nOutput:\\t{1,2}\\n\\nExpected:\\t{2,1}\"\\n\\nIf x is 1, why would the expected output have 2 come before 1?\\n\\nThanks."
                    },
                    {
                        "username": "rahulkasula23",
                        "content": "bro I done this question 8 years after your submission"
                    },
                    {
                        "username": "powerup7",
                        "content": "[@Anand_On_Leet](/Anand_On_Leet) No, no sorting of the list is required. That\\'s how you keep relative order."
                    },
                    {
                        "username": "powerup7",
                        "content": "[@Anand_On_Leet](/Anand_On_Leet) No. No sorting of the list is required. That\\'s how you keep relative order."
                    },
                    {
                        "username": "brb715",
                        "content": "In the first eg, since 4 is greater than or equal to 3(i.e x), all the nodes that are less than 3 will come before 4 and the order of the nodes should be same."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes thankfully they covered that case in the examples, right?\n\n4 comes before 3 because relative order must be preserved.\n\n3 doesn't require being moved because it is >= x.\n\nhope that wasn't too much of a spoiler."
                    },
                    {
                        "username": "Anand_On_Leet",
                        "content": "Then , we should only sort that list."
                    },
                    {
                        "username": "1ort",
                        "content": "tip: Don\\'t forget to clear the Next of the last element of the list if you are spreading elements across two lists. I tried for half an hour to figure out why my solution fails with an error until I realized that I was returning a list with a loop"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Divide the given list head into 2 linked lists, greater & smaller. Then connect these 2 lists and return the result. One more hint:\nThe whole process shown by modifying submitted code in playground\n```\n1<3:smaller\nsmaller:0->1->4->3->2->5->2\ngreater:0\n-------\n4>=3: greater\nsmaller:0->1->4->3->2->5->2\ngreater:0->4->3->2->5->2\n-------\n3>=3: greater\nsmaller:0->1->4->3->2->5->2\ngreater:0->4->3->2->5->2\n-------\n2<3:smaller\nsmaller:0->1->2->5->2\ngreater:0->4->3->2->5->2\n-------\n5>=3: greater\nsmaller:0->1->2->5->2\ngreater:0->4->3->5->2\n-------\n2<3:smaller\nsmaller:0->1->2->2\ngreater:0->4->3->5->2\n-------\nans:\n1->2->2->4->3->5\n```"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@omeirr13](/omeirr13) Since my program uses the constructors, it needs extra O(1) space, that is an extra dummy node.  With such extra dummy node makes programming easier. If you won't use extra space, it needs some modification which may lead to an error."
                    },
                    {
                        "username": "omeirr13",
                        "content": "wont this use extra space"
                    },
                    {
                        "username": "anuron_das",
                        "content": "It is an interesting problem, at least to me. If I were to explain the problem statement to anyone in the simplest terms, I would go like this:\n\nYou are given a linked list and a target number `x`.  You have to reorder the list in such a way that any node with a value `strictly less than x` appears `in the beginning` of the list, such that their relative order `among themselves` is preserved.\n\nFor example: `[1,4,3,2,5,2]` and `x=3`. All the numbers `strictly smaller than x` are `[1,2,2]`. So preserve only their relative order and add them in the beginning of the list.\n\nAfter that you have to preserve the relative order of all the `remaining elements` as well, and after that you can return the list `head`.\n\nFor example, let us consider the above example only, in `[1,4,3,2,5,2]` and `x=3`, after removing all the numbers `strictly less than x`, the remaining list is `[4,3,5]`. So their relative order is preserved accordingly.\n\nIn the end just concatenate the two and return the result.\n\nSo if the problem statement is clear, then one can appreciate the importance of `two pointers` approach, as this problem involves the use of `two pointers` on linked lists. I hope the reader finds this helpful. "
                    },
                    {
                        "username": "valige7091",
                        "content": "All the problem asks one to do is loop through a list and add each element to one of two lists, before combining the two then returning."
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@sameer89](/sameer89) well, as i understood valige, he meant to say take 2 separate lists of all nodes < x and nodes >= x, and then in the end join the tail of one to head of another which will take O(n). "
                    },
                    {
                        "username": "sameer89",
                        "content": "[@2uringTested](/2uringTested) No it wont.  Since these are linked lists it can be done in O(1) space like \"merge\" in mergesort."
                    },
                    {
                        "username": "2uringTested",
                        "content": "that will use extra space, thats not the best solution, you can do the partition in the same list and in one pass."
                    },
                    {
                        "username": "woodyinho",
                        "content": "Input: head = 1->4->3->2->5->2, x = 3\\nOutput: 1->2->2->4->3->5\\n\\nwhy 4 is exist before than 3 not after ?\\n"
                    },
                    {
                        "username": "pahwagautam786",
                        "content": "Because we also have to maintane  the relative order of elements and we have to compare with greater or eqaul to \\'x\\' "
                    },
                    {
                        "username": "sairam852",
                        "content": "because problem description was all nodes less than x come before nodes greater than or equal to x i.e., we no need to move the greater values to after of that targeted value"
                    },
                    {
                        "username": "Abhishen99",
                        "content": "\\n[328. Odd Even Linked List ](https://leetcode.com/problems/odd-even-linked-list/)\\n\\nabove problem is quite similiar to this problem after trying this you can solve that too.\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I wanted to comment the same thing, that one is a nice follow up, requiring O(1) space and O(n) time"
                    },
                    {
                        "username": "Ausho_Roup",
                        "content": "Anyone please explain this question. I am unable to get it. I am trying to understand nearly from two days still not able to figure it out ."
                    },
                    {
                        "username": "nikhilnyalakanti2003",
                        "content": "checkout the discussion section again, ig you\\'ll have it cleared this time"
                    }
                ]
            },
            {
                "id": 1570499,
                "content": [
                    {
                        "username": "zdf826504558",
                        "content": "The description for this problem is somewhat very misleading. \\nI took at least 15 min and tested serval test cases so that I understood what it was asking for.\\n\\nLet me briefly explain it to relieve your pain.\\n\\nBasically, it asks us:\\n`reorder the sequence by the given number x`\\n\\nThe rules are:\\n1. Any number that is `less than x` has to be before `x`, and maintain the relative order with thoese that are less than `x` but already before `x`.\\ne.g. `[3,4,1,2], target = 4` -> `[3,1,2,4]`, so the order of `[3,1,2]` is maintained.\\n2. Any number that is `greater than x` but already before `x` will still be before `x`, but all of them come after those that are less than `x` and at the same time maintain their relative order.\\ne.g. `[3,6,5,4,1,2] target = 4` -> `[3,1,2,6,5,4]`\\n3. Any number that is `greater than x` and after `x` will only need to maintain their relative order\\ne.g. `[3,6,5,4,8,1,7,2] target = 4` -> `[3,1,2,6,5,4,8,7]`\\n\\nHope this helps those who have a difficulty time understanding **\"all nodes less than x come before nodes greater than or equal to x.\"** like me.  \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\n"
                    },
                    {
                        "username": "kishore_001",
                        "content": "[@The_Laughing_Storm](/The_Laughing_Storm)  i understand the question now"
                    },
                    {
                        "username": "ahad7792",
                        "content": "Maximum leetcode  question\\'s description is very unclear"
                    },
                    {
                        "username": "pavan9100",
                        "content": "Haha!...They explained about the place and you explained about the directions"
                    },
                    {
                        "username": "dporwal985",
                        "content": "I was confused for a second and got into the discussion section about that particular line. Seeing your detailed discussion helped. Thanks man!"
                    },
                    {
                        "username": "DeadlyTRex",
                        "content": "[@diksm0ker](/diksm0ker) if relative order was important then in first test case \\nInput: head = [1,4,3,2,5,2], x = 3\\nOutput: [1,2,2,4,3,5]\\nwhy the output is not 1,4,2,2,3,5. the relative order got changed for 2 and 4 in the description\\'s output"
                    },
                    {
                        "username": "The_Laughing_Storm",
                        "content": "[@normanlmfung](/normanlmfung) Relative order means that the orignal order given. So in [3,4,1,2] the order is 3->4->1->2 so after target is 4 the order should be 3->1->2->4 because in the orignal order 3 was before 1 and 1 was before 2. Relative order means wrt to the question. These are linked lists here not arrays so order here is wierd"
                    },
                    {
                        "username": "normanlmfung",
                        "content": "It's still unclear [3,4,1,2], target = 4 -> [3,1,2,4] \n\nWhy not \n     [1,2,3,4]? <-- 1 appear before 2 so \"relative order\" still maintained\nor even \n    [1,3,2,4] <-- same here, 1 apear before 2 and \"relative order\" still maintained.\n\nAnother example,\n    [3,6,5,4,1,2] target = 4 -> [3,1,2,6,5,4]\n\n    Why not \n        [1,2,3,6,5,4]           <-- \"preserve the original relative order of the nodes in each of the two partitions\" does not explains why 1,2 should appear after 3\n        [3,6,5,1,2,4]           <-- \"all nodes less than x come before nodes greater than or equal to x\" explains why 1,2 should appear BEFORE 6,5 so this is fine\n\nQuestion poorly written. So I think developers are expected to try different test cases to understand pick up things that's not specified in problem statement."
                    },
                    {
                        "username": "comanea",
                        "content": "You understood that statement correctly. The description adds right below `You should preserve the original relative order of the nodes in each of the two partitions.`. If that wasn\\'t there when you wrote the comment, then that\\'s on the problem maker, but it looks correct now. Fortunately it\\'s an easy fix anyway."
                    },
                    {
                        "username": "Jaiff",
                        "content": "Happy Independence Day Indian bros. \\nWe live young, \\nWe live free!!!"
                    },
                    {
                        "username": "vinnnu",
                        "content": "Jai Hind!!! Onwards and Upwards"
                    },
                    {
                        "username": "ckvb18",
                        "content": "YES GLORY TO INDIA !!!"
                    },
                    {
                        "username": "codewithnavneet",
                        "content": "Happy independence day brother JAY HIND"
                    },
                    {
                        "username": "aarush_badkur30",
                        "content": "same to u bro Jai Hind "
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "jai hind"
                    },
                    {
                        "username": "kandalachetan",
                        "content": "same to you bro"
                    },
                    {
                        "username": "KingShuK17",
                        "content": "JAI HIND! upwards and onwards, always!"
                    },
                    {
                        "username": "homer_simpson",
                        "content": "\"For example,\\n\\nGiven 1->4->3->2->5->2 and x = 3,\\n\\nreturn 1->2->2->4->3->5.\"\\n\\nIn the return, why does 4 come before 3 if it's larger???\\n\\n\\nAlso, my code fails this test:\\n\"Input:\\t{2,1}, 1\\n\\nOutput:\\t{1,2}\\n\\nExpected:\\t{2,1}\"\\n\\nIf x is 1, why would the expected output have 2 come before 1?\\n\\nThanks."
                    },
                    {
                        "username": "rahulkasula23",
                        "content": "bro I done this question 8 years after your submission"
                    },
                    {
                        "username": "powerup7",
                        "content": "[@Anand_On_Leet](/Anand_On_Leet) No, no sorting of the list is required. That\\'s how you keep relative order."
                    },
                    {
                        "username": "powerup7",
                        "content": "[@Anand_On_Leet](/Anand_On_Leet) No. No sorting of the list is required. That\\'s how you keep relative order."
                    },
                    {
                        "username": "brb715",
                        "content": "In the first eg, since 4 is greater than or equal to 3(i.e x), all the nodes that are less than 3 will come before 4 and the order of the nodes should be same."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes thankfully they covered that case in the examples, right?\n\n4 comes before 3 because relative order must be preserved.\n\n3 doesn't require being moved because it is >= x.\n\nhope that wasn't too much of a spoiler."
                    },
                    {
                        "username": "Anand_On_Leet",
                        "content": "Then , we should only sort that list."
                    },
                    {
                        "username": "1ort",
                        "content": "tip: Don\\'t forget to clear the Next of the last element of the list if you are spreading elements across two lists. I tried for half an hour to figure out why my solution fails with an error until I realized that I was returning a list with a loop"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Divide the given list head into 2 linked lists, greater & smaller. Then connect these 2 lists and return the result. One more hint:\nThe whole process shown by modifying submitted code in playground\n```\n1<3:smaller\nsmaller:0->1->4->3->2->5->2\ngreater:0\n-------\n4>=3: greater\nsmaller:0->1->4->3->2->5->2\ngreater:0->4->3->2->5->2\n-------\n3>=3: greater\nsmaller:0->1->4->3->2->5->2\ngreater:0->4->3->2->5->2\n-------\n2<3:smaller\nsmaller:0->1->2->5->2\ngreater:0->4->3->2->5->2\n-------\n5>=3: greater\nsmaller:0->1->2->5->2\ngreater:0->4->3->5->2\n-------\n2<3:smaller\nsmaller:0->1->2->2\ngreater:0->4->3->5->2\n-------\nans:\n1->2->2->4->3->5\n```"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@omeirr13](/omeirr13) Since my program uses the constructors, it needs extra O(1) space, that is an extra dummy node.  With such extra dummy node makes programming easier. If you won't use extra space, it needs some modification which may lead to an error."
                    },
                    {
                        "username": "omeirr13",
                        "content": "wont this use extra space"
                    },
                    {
                        "username": "anuron_das",
                        "content": "It is an interesting problem, at least to me. If I were to explain the problem statement to anyone in the simplest terms, I would go like this:\n\nYou are given a linked list and a target number `x`.  You have to reorder the list in such a way that any node with a value `strictly less than x` appears `in the beginning` of the list, such that their relative order `among themselves` is preserved.\n\nFor example: `[1,4,3,2,5,2]` and `x=3`. All the numbers `strictly smaller than x` are `[1,2,2]`. So preserve only their relative order and add them in the beginning of the list.\n\nAfter that you have to preserve the relative order of all the `remaining elements` as well, and after that you can return the list `head`.\n\nFor example, let us consider the above example only, in `[1,4,3,2,5,2]` and `x=3`, after removing all the numbers `strictly less than x`, the remaining list is `[4,3,5]`. So their relative order is preserved accordingly.\n\nIn the end just concatenate the two and return the result.\n\nSo if the problem statement is clear, then one can appreciate the importance of `two pointers` approach, as this problem involves the use of `two pointers` on linked lists. I hope the reader finds this helpful. "
                    },
                    {
                        "username": "valige7091",
                        "content": "All the problem asks one to do is loop through a list and add each element to one of two lists, before combining the two then returning."
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@sameer89](/sameer89) well, as i understood valige, he meant to say take 2 separate lists of all nodes < x and nodes >= x, and then in the end join the tail of one to head of another which will take O(n). "
                    },
                    {
                        "username": "sameer89",
                        "content": "[@2uringTested](/2uringTested) No it wont.  Since these are linked lists it can be done in O(1) space like \"merge\" in mergesort."
                    },
                    {
                        "username": "2uringTested",
                        "content": "that will use extra space, thats not the best solution, you can do the partition in the same list and in one pass."
                    },
                    {
                        "username": "woodyinho",
                        "content": "Input: head = 1->4->3->2->5->2, x = 3\\nOutput: 1->2->2->4->3->5\\n\\nwhy 4 is exist before than 3 not after ?\\n"
                    },
                    {
                        "username": "pahwagautam786",
                        "content": "Because we also have to maintane  the relative order of elements and we have to compare with greater or eqaul to \\'x\\' "
                    },
                    {
                        "username": "sairam852",
                        "content": "because problem description was all nodes less than x come before nodes greater than or equal to x i.e., we no need to move the greater values to after of that targeted value"
                    },
                    {
                        "username": "Abhishen99",
                        "content": "\\n[328. Odd Even Linked List ](https://leetcode.com/problems/odd-even-linked-list/)\\n\\nabove problem is quite similiar to this problem after trying this you can solve that too.\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I wanted to comment the same thing, that one is a nice follow up, requiring O(1) space and O(n) time"
                    },
                    {
                        "username": "Ausho_Roup",
                        "content": "Anyone please explain this question. I am unable to get it. I am trying to understand nearly from two days still not able to figure it out ."
                    },
                    {
                        "username": "nikhilnyalakanti2003",
                        "content": "checkout the discussion section again, ig you\\'ll have it cleared this time"
                    }
                ]
            },
            {
                "id": 1574465,
                "content": [
                    {
                        "username": "zdf826504558",
                        "content": "The description for this problem is somewhat very misleading. \\nI took at least 15 min and tested serval test cases so that I understood what it was asking for.\\n\\nLet me briefly explain it to relieve your pain.\\n\\nBasically, it asks us:\\n`reorder the sequence by the given number x`\\n\\nThe rules are:\\n1. Any number that is `less than x` has to be before `x`, and maintain the relative order with thoese that are less than `x` but already before `x`.\\ne.g. `[3,4,1,2], target = 4` -> `[3,1,2,4]`, so the order of `[3,1,2]` is maintained.\\n2. Any number that is `greater than x` but already before `x` will still be before `x`, but all of them come after those that are less than `x` and at the same time maintain their relative order.\\ne.g. `[3,6,5,4,1,2] target = 4` -> `[3,1,2,6,5,4]`\\n3. Any number that is `greater than x` and after `x` will only need to maintain their relative order\\ne.g. `[3,6,5,4,8,1,7,2] target = 4` -> `[3,1,2,6,5,4,8,7]`\\n\\nHope this helps those who have a difficulty time understanding **\"all nodes less than x come before nodes greater than or equal to x.\"** like me.  \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\n"
                    },
                    {
                        "username": "kishore_001",
                        "content": "[@The_Laughing_Storm](/The_Laughing_Storm)  i understand the question now"
                    },
                    {
                        "username": "ahad7792",
                        "content": "Maximum leetcode  question\\'s description is very unclear"
                    },
                    {
                        "username": "pavan9100",
                        "content": "Haha!...They explained about the place and you explained about the directions"
                    },
                    {
                        "username": "dporwal985",
                        "content": "I was confused for a second and got into the discussion section about that particular line. Seeing your detailed discussion helped. Thanks man!"
                    },
                    {
                        "username": "DeadlyTRex",
                        "content": "[@diksm0ker](/diksm0ker) if relative order was important then in first test case \\nInput: head = [1,4,3,2,5,2], x = 3\\nOutput: [1,2,2,4,3,5]\\nwhy the output is not 1,4,2,2,3,5. the relative order got changed for 2 and 4 in the description\\'s output"
                    },
                    {
                        "username": "The_Laughing_Storm",
                        "content": "[@normanlmfung](/normanlmfung) Relative order means that the orignal order given. So in [3,4,1,2] the order is 3->4->1->2 so after target is 4 the order should be 3->1->2->4 because in the orignal order 3 was before 1 and 1 was before 2. Relative order means wrt to the question. These are linked lists here not arrays so order here is wierd"
                    },
                    {
                        "username": "normanlmfung",
                        "content": "It's still unclear [3,4,1,2], target = 4 -> [3,1,2,4] \n\nWhy not \n     [1,2,3,4]? <-- 1 appear before 2 so \"relative order\" still maintained\nor even \n    [1,3,2,4] <-- same here, 1 apear before 2 and \"relative order\" still maintained.\n\nAnother example,\n    [3,6,5,4,1,2] target = 4 -> [3,1,2,6,5,4]\n\n    Why not \n        [1,2,3,6,5,4]           <-- \"preserve the original relative order of the nodes in each of the two partitions\" does not explains why 1,2 should appear after 3\n        [3,6,5,1,2,4]           <-- \"all nodes less than x come before nodes greater than or equal to x\" explains why 1,2 should appear BEFORE 6,5 so this is fine\n\nQuestion poorly written. So I think developers are expected to try different test cases to understand pick up things that's not specified in problem statement."
                    },
                    {
                        "username": "comanea",
                        "content": "You understood that statement correctly. The description adds right below `You should preserve the original relative order of the nodes in each of the two partitions.`. If that wasn\\'t there when you wrote the comment, then that\\'s on the problem maker, but it looks correct now. Fortunately it\\'s an easy fix anyway."
                    },
                    {
                        "username": "Jaiff",
                        "content": "Happy Independence Day Indian bros. \\nWe live young, \\nWe live free!!!"
                    },
                    {
                        "username": "vinnnu",
                        "content": "Jai Hind!!! Onwards and Upwards"
                    },
                    {
                        "username": "ckvb18",
                        "content": "YES GLORY TO INDIA !!!"
                    },
                    {
                        "username": "codewithnavneet",
                        "content": "Happy independence day brother JAY HIND"
                    },
                    {
                        "username": "aarush_badkur30",
                        "content": "same to u bro Jai Hind "
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "jai hind"
                    },
                    {
                        "username": "kandalachetan",
                        "content": "same to you bro"
                    },
                    {
                        "username": "KingShuK17",
                        "content": "JAI HIND! upwards and onwards, always!"
                    },
                    {
                        "username": "homer_simpson",
                        "content": "\"For example,\\n\\nGiven 1->4->3->2->5->2 and x = 3,\\n\\nreturn 1->2->2->4->3->5.\"\\n\\nIn the return, why does 4 come before 3 if it's larger???\\n\\n\\nAlso, my code fails this test:\\n\"Input:\\t{2,1}, 1\\n\\nOutput:\\t{1,2}\\n\\nExpected:\\t{2,1}\"\\n\\nIf x is 1, why would the expected output have 2 come before 1?\\n\\nThanks."
                    },
                    {
                        "username": "rahulkasula23",
                        "content": "bro I done this question 8 years after your submission"
                    },
                    {
                        "username": "powerup7",
                        "content": "[@Anand_On_Leet](/Anand_On_Leet) No, no sorting of the list is required. That\\'s how you keep relative order."
                    },
                    {
                        "username": "powerup7",
                        "content": "[@Anand_On_Leet](/Anand_On_Leet) No. No sorting of the list is required. That\\'s how you keep relative order."
                    },
                    {
                        "username": "brb715",
                        "content": "In the first eg, since 4 is greater than or equal to 3(i.e x), all the nodes that are less than 3 will come before 4 and the order of the nodes should be same."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes thankfully they covered that case in the examples, right?\n\n4 comes before 3 because relative order must be preserved.\n\n3 doesn't require being moved because it is >= x.\n\nhope that wasn't too much of a spoiler."
                    },
                    {
                        "username": "Anand_On_Leet",
                        "content": "Then , we should only sort that list."
                    },
                    {
                        "username": "1ort",
                        "content": "tip: Don\\'t forget to clear the Next of the last element of the list if you are spreading elements across two lists. I tried for half an hour to figure out why my solution fails with an error until I realized that I was returning a list with a loop"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Divide the given list head into 2 linked lists, greater & smaller. Then connect these 2 lists and return the result. One more hint:\nThe whole process shown by modifying submitted code in playground\n```\n1<3:smaller\nsmaller:0->1->4->3->2->5->2\ngreater:0\n-------\n4>=3: greater\nsmaller:0->1->4->3->2->5->2\ngreater:0->4->3->2->5->2\n-------\n3>=3: greater\nsmaller:0->1->4->3->2->5->2\ngreater:0->4->3->2->5->2\n-------\n2<3:smaller\nsmaller:0->1->2->5->2\ngreater:0->4->3->2->5->2\n-------\n5>=3: greater\nsmaller:0->1->2->5->2\ngreater:0->4->3->5->2\n-------\n2<3:smaller\nsmaller:0->1->2->2\ngreater:0->4->3->5->2\n-------\nans:\n1->2->2->4->3->5\n```"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@omeirr13](/omeirr13) Since my program uses the constructors, it needs extra O(1) space, that is an extra dummy node.  With such extra dummy node makes programming easier. If you won't use extra space, it needs some modification which may lead to an error."
                    },
                    {
                        "username": "omeirr13",
                        "content": "wont this use extra space"
                    },
                    {
                        "username": "anuron_das",
                        "content": "It is an interesting problem, at least to me. If I were to explain the problem statement to anyone in the simplest terms, I would go like this:\n\nYou are given a linked list and a target number `x`.  You have to reorder the list in such a way that any node with a value `strictly less than x` appears `in the beginning` of the list, such that their relative order `among themselves` is preserved.\n\nFor example: `[1,4,3,2,5,2]` and `x=3`. All the numbers `strictly smaller than x` are `[1,2,2]`. So preserve only their relative order and add them in the beginning of the list.\n\nAfter that you have to preserve the relative order of all the `remaining elements` as well, and after that you can return the list `head`.\n\nFor example, let us consider the above example only, in `[1,4,3,2,5,2]` and `x=3`, after removing all the numbers `strictly less than x`, the remaining list is `[4,3,5]`. So their relative order is preserved accordingly.\n\nIn the end just concatenate the two and return the result.\n\nSo if the problem statement is clear, then one can appreciate the importance of `two pointers` approach, as this problem involves the use of `two pointers` on linked lists. I hope the reader finds this helpful. "
                    },
                    {
                        "username": "valige7091",
                        "content": "All the problem asks one to do is loop through a list and add each element to one of two lists, before combining the two then returning."
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@sameer89](/sameer89) well, as i understood valige, he meant to say take 2 separate lists of all nodes < x and nodes >= x, and then in the end join the tail of one to head of another which will take O(n). "
                    },
                    {
                        "username": "sameer89",
                        "content": "[@2uringTested](/2uringTested) No it wont.  Since these are linked lists it can be done in O(1) space like \"merge\" in mergesort."
                    },
                    {
                        "username": "2uringTested",
                        "content": "that will use extra space, thats not the best solution, you can do the partition in the same list and in one pass."
                    },
                    {
                        "username": "woodyinho",
                        "content": "Input: head = 1->4->3->2->5->2, x = 3\\nOutput: 1->2->2->4->3->5\\n\\nwhy 4 is exist before than 3 not after ?\\n"
                    },
                    {
                        "username": "pahwagautam786",
                        "content": "Because we also have to maintane  the relative order of elements and we have to compare with greater or eqaul to \\'x\\' "
                    },
                    {
                        "username": "sairam852",
                        "content": "because problem description was all nodes less than x come before nodes greater than or equal to x i.e., we no need to move the greater values to after of that targeted value"
                    },
                    {
                        "username": "Abhishen99",
                        "content": "\\n[328. Odd Even Linked List ](https://leetcode.com/problems/odd-even-linked-list/)\\n\\nabove problem is quite similiar to this problem after trying this you can solve that too.\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I wanted to comment the same thing, that one is a nice follow up, requiring O(1) space and O(n) time"
                    },
                    {
                        "username": "Ausho_Roup",
                        "content": "Anyone please explain this question. I am unable to get it. I am trying to understand nearly from two days still not able to figure it out ."
                    },
                    {
                        "username": "nikhilnyalakanti2003",
                        "content": "checkout the discussion section again, ig you\\'ll have it cleared this time"
                    }
                ]
            },
            {
                "id": 1565050,
                "content": [
                    {
                        "username": "zdf826504558",
                        "content": "The description for this problem is somewhat very misleading. \\nI took at least 15 min and tested serval test cases so that I understood what it was asking for.\\n\\nLet me briefly explain it to relieve your pain.\\n\\nBasically, it asks us:\\n`reorder the sequence by the given number x`\\n\\nThe rules are:\\n1. Any number that is `less than x` has to be before `x`, and maintain the relative order with thoese that are less than `x` but already before `x`.\\ne.g. `[3,4,1,2], target = 4` -> `[3,1,2,4]`, so the order of `[3,1,2]` is maintained.\\n2. Any number that is `greater than x` but already before `x` will still be before `x`, but all of them come after those that are less than `x` and at the same time maintain their relative order.\\ne.g. `[3,6,5,4,1,2] target = 4` -> `[3,1,2,6,5,4]`\\n3. Any number that is `greater than x` and after `x` will only need to maintain their relative order\\ne.g. `[3,6,5,4,8,1,7,2] target = 4` -> `[3,1,2,6,5,4,8,7]`\\n\\nHope this helps those who have a difficulty time understanding **\"all nodes less than x come before nodes greater than or equal to x.\"** like me.  \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\n"
                    },
                    {
                        "username": "kishore_001",
                        "content": "[@The_Laughing_Storm](/The_Laughing_Storm)  i understand the question now"
                    },
                    {
                        "username": "ahad7792",
                        "content": "Maximum leetcode  question\\'s description is very unclear"
                    },
                    {
                        "username": "pavan9100",
                        "content": "Haha!...They explained about the place and you explained about the directions"
                    },
                    {
                        "username": "dporwal985",
                        "content": "I was confused for a second and got into the discussion section about that particular line. Seeing your detailed discussion helped. Thanks man!"
                    },
                    {
                        "username": "DeadlyTRex",
                        "content": "[@diksm0ker](/diksm0ker) if relative order was important then in first test case \\nInput: head = [1,4,3,2,5,2], x = 3\\nOutput: [1,2,2,4,3,5]\\nwhy the output is not 1,4,2,2,3,5. the relative order got changed for 2 and 4 in the description\\'s output"
                    },
                    {
                        "username": "The_Laughing_Storm",
                        "content": "[@normanlmfung](/normanlmfung) Relative order means that the orignal order given. So in [3,4,1,2] the order is 3->4->1->2 so after target is 4 the order should be 3->1->2->4 because in the orignal order 3 was before 1 and 1 was before 2. Relative order means wrt to the question. These are linked lists here not arrays so order here is wierd"
                    },
                    {
                        "username": "normanlmfung",
                        "content": "It's still unclear [3,4,1,2], target = 4 -> [3,1,2,4] \n\nWhy not \n     [1,2,3,4]? <-- 1 appear before 2 so \"relative order\" still maintained\nor even \n    [1,3,2,4] <-- same here, 1 apear before 2 and \"relative order\" still maintained.\n\nAnother example,\n    [3,6,5,4,1,2] target = 4 -> [3,1,2,6,5,4]\n\n    Why not \n        [1,2,3,6,5,4]           <-- \"preserve the original relative order of the nodes in each of the two partitions\" does not explains why 1,2 should appear after 3\n        [3,6,5,1,2,4]           <-- \"all nodes less than x come before nodes greater than or equal to x\" explains why 1,2 should appear BEFORE 6,5 so this is fine\n\nQuestion poorly written. So I think developers are expected to try different test cases to understand pick up things that's not specified in problem statement."
                    },
                    {
                        "username": "comanea",
                        "content": "You understood that statement correctly. The description adds right below `You should preserve the original relative order of the nodes in each of the two partitions.`. If that wasn\\'t there when you wrote the comment, then that\\'s on the problem maker, but it looks correct now. Fortunately it\\'s an easy fix anyway."
                    },
                    {
                        "username": "Jaiff",
                        "content": "Happy Independence Day Indian bros. \\nWe live young, \\nWe live free!!!"
                    },
                    {
                        "username": "vinnnu",
                        "content": "Jai Hind!!! Onwards and Upwards"
                    },
                    {
                        "username": "ckvb18",
                        "content": "YES GLORY TO INDIA !!!"
                    },
                    {
                        "username": "codewithnavneet",
                        "content": "Happy independence day brother JAY HIND"
                    },
                    {
                        "username": "aarush_badkur30",
                        "content": "same to u bro Jai Hind "
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "jai hind"
                    },
                    {
                        "username": "kandalachetan",
                        "content": "same to you bro"
                    },
                    {
                        "username": "KingShuK17",
                        "content": "JAI HIND! upwards and onwards, always!"
                    },
                    {
                        "username": "homer_simpson",
                        "content": "\"For example,\\n\\nGiven 1->4->3->2->5->2 and x = 3,\\n\\nreturn 1->2->2->4->3->5.\"\\n\\nIn the return, why does 4 come before 3 if it's larger???\\n\\n\\nAlso, my code fails this test:\\n\"Input:\\t{2,1}, 1\\n\\nOutput:\\t{1,2}\\n\\nExpected:\\t{2,1}\"\\n\\nIf x is 1, why would the expected output have 2 come before 1?\\n\\nThanks."
                    },
                    {
                        "username": "rahulkasula23",
                        "content": "bro I done this question 8 years after your submission"
                    },
                    {
                        "username": "powerup7",
                        "content": "[@Anand_On_Leet](/Anand_On_Leet) No, no sorting of the list is required. That\\'s how you keep relative order."
                    },
                    {
                        "username": "powerup7",
                        "content": "[@Anand_On_Leet](/Anand_On_Leet) No. No sorting of the list is required. That\\'s how you keep relative order."
                    },
                    {
                        "username": "brb715",
                        "content": "In the first eg, since 4 is greater than or equal to 3(i.e x), all the nodes that are less than 3 will come before 4 and the order of the nodes should be same."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes thankfully they covered that case in the examples, right?\n\n4 comes before 3 because relative order must be preserved.\n\n3 doesn't require being moved because it is >= x.\n\nhope that wasn't too much of a spoiler."
                    },
                    {
                        "username": "Anand_On_Leet",
                        "content": "Then , we should only sort that list."
                    },
                    {
                        "username": "1ort",
                        "content": "tip: Don\\'t forget to clear the Next of the last element of the list if you are spreading elements across two lists. I tried for half an hour to figure out why my solution fails with an error until I realized that I was returning a list with a loop"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Divide the given list head into 2 linked lists, greater & smaller. Then connect these 2 lists and return the result. One more hint:\nThe whole process shown by modifying submitted code in playground\n```\n1<3:smaller\nsmaller:0->1->4->3->2->5->2\ngreater:0\n-------\n4>=3: greater\nsmaller:0->1->4->3->2->5->2\ngreater:0->4->3->2->5->2\n-------\n3>=3: greater\nsmaller:0->1->4->3->2->5->2\ngreater:0->4->3->2->5->2\n-------\n2<3:smaller\nsmaller:0->1->2->5->2\ngreater:0->4->3->2->5->2\n-------\n5>=3: greater\nsmaller:0->1->2->5->2\ngreater:0->4->3->5->2\n-------\n2<3:smaller\nsmaller:0->1->2->2\ngreater:0->4->3->5->2\n-------\nans:\n1->2->2->4->3->5\n```"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@omeirr13](/omeirr13) Since my program uses the constructors, it needs extra O(1) space, that is an extra dummy node.  With such extra dummy node makes programming easier. If you won't use extra space, it needs some modification which may lead to an error."
                    },
                    {
                        "username": "omeirr13",
                        "content": "wont this use extra space"
                    },
                    {
                        "username": "anuron_das",
                        "content": "It is an interesting problem, at least to me. If I were to explain the problem statement to anyone in the simplest terms, I would go like this:\n\nYou are given a linked list and a target number `x`.  You have to reorder the list in such a way that any node with a value `strictly less than x` appears `in the beginning` of the list, such that their relative order `among themselves` is preserved.\n\nFor example: `[1,4,3,2,5,2]` and `x=3`. All the numbers `strictly smaller than x` are `[1,2,2]`. So preserve only their relative order and add them in the beginning of the list.\n\nAfter that you have to preserve the relative order of all the `remaining elements` as well, and after that you can return the list `head`.\n\nFor example, let us consider the above example only, in `[1,4,3,2,5,2]` and `x=3`, after removing all the numbers `strictly less than x`, the remaining list is `[4,3,5]`. So their relative order is preserved accordingly.\n\nIn the end just concatenate the two and return the result.\n\nSo if the problem statement is clear, then one can appreciate the importance of `two pointers` approach, as this problem involves the use of `two pointers` on linked lists. I hope the reader finds this helpful. "
                    },
                    {
                        "username": "valige7091",
                        "content": "All the problem asks one to do is loop through a list and add each element to one of two lists, before combining the two then returning."
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@sameer89](/sameer89) well, as i understood valige, he meant to say take 2 separate lists of all nodes < x and nodes >= x, and then in the end join the tail of one to head of another which will take O(n). "
                    },
                    {
                        "username": "sameer89",
                        "content": "[@2uringTested](/2uringTested) No it wont.  Since these are linked lists it can be done in O(1) space like \"merge\" in mergesort."
                    },
                    {
                        "username": "2uringTested",
                        "content": "that will use extra space, thats not the best solution, you can do the partition in the same list and in one pass."
                    },
                    {
                        "username": "woodyinho",
                        "content": "Input: head = 1->4->3->2->5->2, x = 3\\nOutput: 1->2->2->4->3->5\\n\\nwhy 4 is exist before than 3 not after ?\\n"
                    },
                    {
                        "username": "pahwagautam786",
                        "content": "Because we also have to maintane  the relative order of elements and we have to compare with greater or eqaul to \\'x\\' "
                    },
                    {
                        "username": "sairam852",
                        "content": "because problem description was all nodes less than x come before nodes greater than or equal to x i.e., we no need to move the greater values to after of that targeted value"
                    },
                    {
                        "username": "Abhishen99",
                        "content": "\\n[328. Odd Even Linked List ](https://leetcode.com/problems/odd-even-linked-list/)\\n\\nabove problem is quite similiar to this problem after trying this you can solve that too.\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I wanted to comment the same thing, that one is a nice follow up, requiring O(1) space and O(n) time"
                    },
                    {
                        "username": "Ausho_Roup",
                        "content": "Anyone please explain this question. I am unable to get it. I am trying to understand nearly from two days still not able to figure it out ."
                    },
                    {
                        "username": "nikhilnyalakanti2003",
                        "content": "checkout the discussion section again, ig you\\'ll have it cleared this time"
                    }
                ]
            },
            {
                "id": 2014762,
                "content": [
                    {
                        "username": "zdf826504558",
                        "content": "The description for this problem is somewhat very misleading. \\nI took at least 15 min and tested serval test cases so that I understood what it was asking for.\\n\\nLet me briefly explain it to relieve your pain.\\n\\nBasically, it asks us:\\n`reorder the sequence by the given number x`\\n\\nThe rules are:\\n1. Any number that is `less than x` has to be before `x`, and maintain the relative order with thoese that are less than `x` but already before `x`.\\ne.g. `[3,4,1,2], target = 4` -> `[3,1,2,4]`, so the order of `[3,1,2]` is maintained.\\n2. Any number that is `greater than x` but already before `x` will still be before `x`, but all of them come after those that are less than `x` and at the same time maintain their relative order.\\ne.g. `[3,6,5,4,1,2] target = 4` -> `[3,1,2,6,5,4]`\\n3. Any number that is `greater than x` and after `x` will only need to maintain their relative order\\ne.g. `[3,6,5,4,8,1,7,2] target = 4` -> `[3,1,2,6,5,4,8,7]`\\n\\nHope this helps those who have a difficulty time understanding **\"all nodes less than x come before nodes greater than or equal to x.\"** like me.  \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\n"
                    },
                    {
                        "username": "kishore_001",
                        "content": "[@The_Laughing_Storm](/The_Laughing_Storm)  i understand the question now"
                    },
                    {
                        "username": "ahad7792",
                        "content": "Maximum leetcode  question\\'s description is very unclear"
                    },
                    {
                        "username": "pavan9100",
                        "content": "Haha!...They explained about the place and you explained about the directions"
                    },
                    {
                        "username": "dporwal985",
                        "content": "I was confused for a second and got into the discussion section about that particular line. Seeing your detailed discussion helped. Thanks man!"
                    },
                    {
                        "username": "DeadlyTRex",
                        "content": "[@diksm0ker](/diksm0ker) if relative order was important then in first test case \\nInput: head = [1,4,3,2,5,2], x = 3\\nOutput: [1,2,2,4,3,5]\\nwhy the output is not 1,4,2,2,3,5. the relative order got changed for 2 and 4 in the description\\'s output"
                    },
                    {
                        "username": "The_Laughing_Storm",
                        "content": "[@normanlmfung](/normanlmfung) Relative order means that the orignal order given. So in [3,4,1,2] the order is 3->4->1->2 so after target is 4 the order should be 3->1->2->4 because in the orignal order 3 was before 1 and 1 was before 2. Relative order means wrt to the question. These are linked lists here not arrays so order here is wierd"
                    },
                    {
                        "username": "normanlmfung",
                        "content": "It's still unclear [3,4,1,2], target = 4 -> [3,1,2,4] \n\nWhy not \n     [1,2,3,4]? <-- 1 appear before 2 so \"relative order\" still maintained\nor even \n    [1,3,2,4] <-- same here, 1 apear before 2 and \"relative order\" still maintained.\n\nAnother example,\n    [3,6,5,4,1,2] target = 4 -> [3,1,2,6,5,4]\n\n    Why not \n        [1,2,3,6,5,4]           <-- \"preserve the original relative order of the nodes in each of the two partitions\" does not explains why 1,2 should appear after 3\n        [3,6,5,1,2,4]           <-- \"all nodes less than x come before nodes greater than or equal to x\" explains why 1,2 should appear BEFORE 6,5 so this is fine\n\nQuestion poorly written. So I think developers are expected to try different test cases to understand pick up things that's not specified in problem statement."
                    },
                    {
                        "username": "comanea",
                        "content": "You understood that statement correctly. The description adds right below `You should preserve the original relative order of the nodes in each of the two partitions.`. If that wasn\\'t there when you wrote the comment, then that\\'s on the problem maker, but it looks correct now. Fortunately it\\'s an easy fix anyway."
                    },
                    {
                        "username": "Jaiff",
                        "content": "Happy Independence Day Indian bros. \\nWe live young, \\nWe live free!!!"
                    },
                    {
                        "username": "vinnnu",
                        "content": "Jai Hind!!! Onwards and Upwards"
                    },
                    {
                        "username": "ckvb18",
                        "content": "YES GLORY TO INDIA !!!"
                    },
                    {
                        "username": "codewithnavneet",
                        "content": "Happy independence day brother JAY HIND"
                    },
                    {
                        "username": "aarush_badkur30",
                        "content": "same to u bro Jai Hind "
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "jai hind"
                    },
                    {
                        "username": "kandalachetan",
                        "content": "same to you bro"
                    },
                    {
                        "username": "KingShuK17",
                        "content": "JAI HIND! upwards and onwards, always!"
                    },
                    {
                        "username": "homer_simpson",
                        "content": "\"For example,\\n\\nGiven 1->4->3->2->5->2 and x = 3,\\n\\nreturn 1->2->2->4->3->5.\"\\n\\nIn the return, why does 4 come before 3 if it's larger???\\n\\n\\nAlso, my code fails this test:\\n\"Input:\\t{2,1}, 1\\n\\nOutput:\\t{1,2}\\n\\nExpected:\\t{2,1}\"\\n\\nIf x is 1, why would the expected output have 2 come before 1?\\n\\nThanks."
                    },
                    {
                        "username": "rahulkasula23",
                        "content": "bro I done this question 8 years after your submission"
                    },
                    {
                        "username": "powerup7",
                        "content": "[@Anand_On_Leet](/Anand_On_Leet) No, no sorting of the list is required. That\\'s how you keep relative order."
                    },
                    {
                        "username": "powerup7",
                        "content": "[@Anand_On_Leet](/Anand_On_Leet) No. No sorting of the list is required. That\\'s how you keep relative order."
                    },
                    {
                        "username": "brb715",
                        "content": "In the first eg, since 4 is greater than or equal to 3(i.e x), all the nodes that are less than 3 will come before 4 and the order of the nodes should be same."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes thankfully they covered that case in the examples, right?\n\n4 comes before 3 because relative order must be preserved.\n\n3 doesn't require being moved because it is >= x.\n\nhope that wasn't too much of a spoiler."
                    },
                    {
                        "username": "Anand_On_Leet",
                        "content": "Then , we should only sort that list."
                    },
                    {
                        "username": "1ort",
                        "content": "tip: Don\\'t forget to clear the Next of the last element of the list if you are spreading elements across two lists. I tried for half an hour to figure out why my solution fails with an error until I realized that I was returning a list with a loop"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Divide the given list head into 2 linked lists, greater & smaller. Then connect these 2 lists and return the result. One more hint:\nThe whole process shown by modifying submitted code in playground\n```\n1<3:smaller\nsmaller:0->1->4->3->2->5->2\ngreater:0\n-------\n4>=3: greater\nsmaller:0->1->4->3->2->5->2\ngreater:0->4->3->2->5->2\n-------\n3>=3: greater\nsmaller:0->1->4->3->2->5->2\ngreater:0->4->3->2->5->2\n-------\n2<3:smaller\nsmaller:0->1->2->5->2\ngreater:0->4->3->2->5->2\n-------\n5>=3: greater\nsmaller:0->1->2->5->2\ngreater:0->4->3->5->2\n-------\n2<3:smaller\nsmaller:0->1->2->2\ngreater:0->4->3->5->2\n-------\nans:\n1->2->2->4->3->5\n```"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@omeirr13](/omeirr13) Since my program uses the constructors, it needs extra O(1) space, that is an extra dummy node.  With such extra dummy node makes programming easier. If you won't use extra space, it needs some modification which may lead to an error."
                    },
                    {
                        "username": "omeirr13",
                        "content": "wont this use extra space"
                    },
                    {
                        "username": "anuron_das",
                        "content": "It is an interesting problem, at least to me. If I were to explain the problem statement to anyone in the simplest terms, I would go like this:\n\nYou are given a linked list and a target number `x`.  You have to reorder the list in such a way that any node with a value `strictly less than x` appears `in the beginning` of the list, such that their relative order `among themselves` is preserved.\n\nFor example: `[1,4,3,2,5,2]` and `x=3`. All the numbers `strictly smaller than x` are `[1,2,2]`. So preserve only their relative order and add them in the beginning of the list.\n\nAfter that you have to preserve the relative order of all the `remaining elements` as well, and after that you can return the list `head`.\n\nFor example, let us consider the above example only, in `[1,4,3,2,5,2]` and `x=3`, after removing all the numbers `strictly less than x`, the remaining list is `[4,3,5]`. So their relative order is preserved accordingly.\n\nIn the end just concatenate the two and return the result.\n\nSo if the problem statement is clear, then one can appreciate the importance of `two pointers` approach, as this problem involves the use of `two pointers` on linked lists. I hope the reader finds this helpful. "
                    },
                    {
                        "username": "valige7091",
                        "content": "All the problem asks one to do is loop through a list and add each element to one of two lists, before combining the two then returning."
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@sameer89](/sameer89) well, as i understood valige, he meant to say take 2 separate lists of all nodes < x and nodes >= x, and then in the end join the tail of one to head of another which will take O(n). "
                    },
                    {
                        "username": "sameer89",
                        "content": "[@2uringTested](/2uringTested) No it wont.  Since these are linked lists it can be done in O(1) space like \"merge\" in mergesort."
                    },
                    {
                        "username": "2uringTested",
                        "content": "that will use extra space, thats not the best solution, you can do the partition in the same list and in one pass."
                    },
                    {
                        "username": "woodyinho",
                        "content": "Input: head = 1->4->3->2->5->2, x = 3\\nOutput: 1->2->2->4->3->5\\n\\nwhy 4 is exist before than 3 not after ?\\n"
                    },
                    {
                        "username": "pahwagautam786",
                        "content": "Because we also have to maintane  the relative order of elements and we have to compare with greater or eqaul to \\'x\\' "
                    },
                    {
                        "username": "sairam852",
                        "content": "because problem description was all nodes less than x come before nodes greater than or equal to x i.e., we no need to move the greater values to after of that targeted value"
                    },
                    {
                        "username": "Abhishen99",
                        "content": "\\n[328. Odd Even Linked List ](https://leetcode.com/problems/odd-even-linked-list/)\\n\\nabove problem is quite similiar to this problem after trying this you can solve that too.\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I wanted to comment the same thing, that one is a nice follow up, requiring O(1) space and O(n) time"
                    },
                    {
                        "username": "Ausho_Roup",
                        "content": "Anyone please explain this question. I am unable to get it. I am trying to understand nearly from two days still not able to figure it out ."
                    },
                    {
                        "username": "nikhilnyalakanti2003",
                        "content": "checkout the discussion section again, ig you\\'ll have it cleared this time"
                    }
                ]
            },
            {
                "id": 1564789,
                "content": [
                    {
                        "username": "zdf826504558",
                        "content": "The description for this problem is somewhat very misleading. \\nI took at least 15 min and tested serval test cases so that I understood what it was asking for.\\n\\nLet me briefly explain it to relieve your pain.\\n\\nBasically, it asks us:\\n`reorder the sequence by the given number x`\\n\\nThe rules are:\\n1. Any number that is `less than x` has to be before `x`, and maintain the relative order with thoese that are less than `x` but already before `x`.\\ne.g. `[3,4,1,2], target = 4` -> `[3,1,2,4]`, so the order of `[3,1,2]` is maintained.\\n2. Any number that is `greater than x` but already before `x` will still be before `x`, but all of them come after those that are less than `x` and at the same time maintain their relative order.\\ne.g. `[3,6,5,4,1,2] target = 4` -> `[3,1,2,6,5,4]`\\n3. Any number that is `greater than x` and after `x` will only need to maintain their relative order\\ne.g. `[3,6,5,4,8,1,7,2] target = 4` -> `[3,1,2,6,5,4,8,7]`\\n\\nHope this helps those who have a difficulty time understanding **\"all nodes less than x come before nodes greater than or equal to x.\"** like me.  \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\n"
                    },
                    {
                        "username": "kishore_001",
                        "content": "[@The_Laughing_Storm](/The_Laughing_Storm)  i understand the question now"
                    },
                    {
                        "username": "ahad7792",
                        "content": "Maximum leetcode  question\\'s description is very unclear"
                    },
                    {
                        "username": "pavan9100",
                        "content": "Haha!...They explained about the place and you explained about the directions"
                    },
                    {
                        "username": "dporwal985",
                        "content": "I was confused for a second and got into the discussion section about that particular line. Seeing your detailed discussion helped. Thanks man!"
                    },
                    {
                        "username": "DeadlyTRex",
                        "content": "[@diksm0ker](/diksm0ker) if relative order was important then in first test case \\nInput: head = [1,4,3,2,5,2], x = 3\\nOutput: [1,2,2,4,3,5]\\nwhy the output is not 1,4,2,2,3,5. the relative order got changed for 2 and 4 in the description\\'s output"
                    },
                    {
                        "username": "The_Laughing_Storm",
                        "content": "[@normanlmfung](/normanlmfung) Relative order means that the orignal order given. So in [3,4,1,2] the order is 3->4->1->2 so after target is 4 the order should be 3->1->2->4 because in the orignal order 3 was before 1 and 1 was before 2. Relative order means wrt to the question. These are linked lists here not arrays so order here is wierd"
                    },
                    {
                        "username": "normanlmfung",
                        "content": "It's still unclear [3,4,1,2], target = 4 -> [3,1,2,4] \n\nWhy not \n     [1,2,3,4]? <-- 1 appear before 2 so \"relative order\" still maintained\nor even \n    [1,3,2,4] <-- same here, 1 apear before 2 and \"relative order\" still maintained.\n\nAnother example,\n    [3,6,5,4,1,2] target = 4 -> [3,1,2,6,5,4]\n\n    Why not \n        [1,2,3,6,5,4]           <-- \"preserve the original relative order of the nodes in each of the two partitions\" does not explains why 1,2 should appear after 3\n        [3,6,5,1,2,4]           <-- \"all nodes less than x come before nodes greater than or equal to x\" explains why 1,2 should appear BEFORE 6,5 so this is fine\n\nQuestion poorly written. So I think developers are expected to try different test cases to understand pick up things that's not specified in problem statement."
                    },
                    {
                        "username": "comanea",
                        "content": "You understood that statement correctly. The description adds right below `You should preserve the original relative order of the nodes in each of the two partitions.`. If that wasn\\'t there when you wrote the comment, then that\\'s on the problem maker, but it looks correct now. Fortunately it\\'s an easy fix anyway."
                    },
                    {
                        "username": "Jaiff",
                        "content": "Happy Independence Day Indian bros. \\nWe live young, \\nWe live free!!!"
                    },
                    {
                        "username": "vinnnu",
                        "content": "Jai Hind!!! Onwards and Upwards"
                    },
                    {
                        "username": "ckvb18",
                        "content": "YES GLORY TO INDIA !!!"
                    },
                    {
                        "username": "codewithnavneet",
                        "content": "Happy independence day brother JAY HIND"
                    },
                    {
                        "username": "aarush_badkur30",
                        "content": "same to u bro Jai Hind "
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "jai hind"
                    },
                    {
                        "username": "kandalachetan",
                        "content": "same to you bro"
                    },
                    {
                        "username": "KingShuK17",
                        "content": "JAI HIND! upwards and onwards, always!"
                    },
                    {
                        "username": "homer_simpson",
                        "content": "\"For example,\\n\\nGiven 1->4->3->2->5->2 and x = 3,\\n\\nreturn 1->2->2->4->3->5.\"\\n\\nIn the return, why does 4 come before 3 if it's larger???\\n\\n\\nAlso, my code fails this test:\\n\"Input:\\t{2,1}, 1\\n\\nOutput:\\t{1,2}\\n\\nExpected:\\t{2,1}\"\\n\\nIf x is 1, why would the expected output have 2 come before 1?\\n\\nThanks."
                    },
                    {
                        "username": "rahulkasula23",
                        "content": "bro I done this question 8 years after your submission"
                    },
                    {
                        "username": "powerup7",
                        "content": "[@Anand_On_Leet](/Anand_On_Leet) No, no sorting of the list is required. That\\'s how you keep relative order."
                    },
                    {
                        "username": "powerup7",
                        "content": "[@Anand_On_Leet](/Anand_On_Leet) No. No sorting of the list is required. That\\'s how you keep relative order."
                    },
                    {
                        "username": "brb715",
                        "content": "In the first eg, since 4 is greater than or equal to 3(i.e x), all the nodes that are less than 3 will come before 4 and the order of the nodes should be same."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes thankfully they covered that case in the examples, right?\n\n4 comes before 3 because relative order must be preserved.\n\n3 doesn't require being moved because it is >= x.\n\nhope that wasn't too much of a spoiler."
                    },
                    {
                        "username": "Anand_On_Leet",
                        "content": "Then , we should only sort that list."
                    },
                    {
                        "username": "1ort",
                        "content": "tip: Don\\'t forget to clear the Next of the last element of the list if you are spreading elements across two lists. I tried for half an hour to figure out why my solution fails with an error until I realized that I was returning a list with a loop"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Divide the given list head into 2 linked lists, greater & smaller. Then connect these 2 lists and return the result. One more hint:\nThe whole process shown by modifying submitted code in playground\n```\n1<3:smaller\nsmaller:0->1->4->3->2->5->2\ngreater:0\n-------\n4>=3: greater\nsmaller:0->1->4->3->2->5->2\ngreater:0->4->3->2->5->2\n-------\n3>=3: greater\nsmaller:0->1->4->3->2->5->2\ngreater:0->4->3->2->5->2\n-------\n2<3:smaller\nsmaller:0->1->2->5->2\ngreater:0->4->3->2->5->2\n-------\n5>=3: greater\nsmaller:0->1->2->5->2\ngreater:0->4->3->5->2\n-------\n2<3:smaller\nsmaller:0->1->2->2\ngreater:0->4->3->5->2\n-------\nans:\n1->2->2->4->3->5\n```"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@omeirr13](/omeirr13) Since my program uses the constructors, it needs extra O(1) space, that is an extra dummy node.  With such extra dummy node makes programming easier. If you won't use extra space, it needs some modification which may lead to an error."
                    },
                    {
                        "username": "omeirr13",
                        "content": "wont this use extra space"
                    },
                    {
                        "username": "anuron_das",
                        "content": "It is an interesting problem, at least to me. If I were to explain the problem statement to anyone in the simplest terms, I would go like this:\n\nYou are given a linked list and a target number `x`.  You have to reorder the list in such a way that any node with a value `strictly less than x` appears `in the beginning` of the list, such that their relative order `among themselves` is preserved.\n\nFor example: `[1,4,3,2,5,2]` and `x=3`. All the numbers `strictly smaller than x` are `[1,2,2]`. So preserve only their relative order and add them in the beginning of the list.\n\nAfter that you have to preserve the relative order of all the `remaining elements` as well, and after that you can return the list `head`.\n\nFor example, let us consider the above example only, in `[1,4,3,2,5,2]` and `x=3`, after removing all the numbers `strictly less than x`, the remaining list is `[4,3,5]`. So their relative order is preserved accordingly.\n\nIn the end just concatenate the two and return the result.\n\nSo if the problem statement is clear, then one can appreciate the importance of `two pointers` approach, as this problem involves the use of `two pointers` on linked lists. I hope the reader finds this helpful. "
                    },
                    {
                        "username": "valige7091",
                        "content": "All the problem asks one to do is loop through a list and add each element to one of two lists, before combining the two then returning."
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@sameer89](/sameer89) well, as i understood valige, he meant to say take 2 separate lists of all nodes < x and nodes >= x, and then in the end join the tail of one to head of another which will take O(n). "
                    },
                    {
                        "username": "sameer89",
                        "content": "[@2uringTested](/2uringTested) No it wont.  Since these are linked lists it can be done in O(1) space like \"merge\" in mergesort."
                    },
                    {
                        "username": "2uringTested",
                        "content": "that will use extra space, thats not the best solution, you can do the partition in the same list and in one pass."
                    },
                    {
                        "username": "woodyinho",
                        "content": "Input: head = 1->4->3->2->5->2, x = 3\\nOutput: 1->2->2->4->3->5\\n\\nwhy 4 is exist before than 3 not after ?\\n"
                    },
                    {
                        "username": "pahwagautam786",
                        "content": "Because we also have to maintane  the relative order of elements and we have to compare with greater or eqaul to \\'x\\' "
                    },
                    {
                        "username": "sairam852",
                        "content": "because problem description was all nodes less than x come before nodes greater than or equal to x i.e., we no need to move the greater values to after of that targeted value"
                    },
                    {
                        "username": "Abhishen99",
                        "content": "\\n[328. Odd Even Linked List ](https://leetcode.com/problems/odd-even-linked-list/)\\n\\nabove problem is quite similiar to this problem after trying this you can solve that too.\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I wanted to comment the same thing, that one is a nice follow up, requiring O(1) space and O(n) time"
                    },
                    {
                        "username": "Ausho_Roup",
                        "content": "Anyone please explain this question. I am unable to get it. I am trying to understand nearly from two days still not able to figure it out ."
                    },
                    {
                        "username": "nikhilnyalakanti2003",
                        "content": "checkout the discussion section again, ig you\\'ll have it cleared this time"
                    }
                ]
            },
            {
                "id": 1750971,
                "content": [
                    {
                        "username": "zdf826504558",
                        "content": "The description for this problem is somewhat very misleading. \\nI took at least 15 min and tested serval test cases so that I understood what it was asking for.\\n\\nLet me briefly explain it to relieve your pain.\\n\\nBasically, it asks us:\\n`reorder the sequence by the given number x`\\n\\nThe rules are:\\n1. Any number that is `less than x` has to be before `x`, and maintain the relative order with thoese that are less than `x` but already before `x`.\\ne.g. `[3,4,1,2], target = 4` -> `[3,1,2,4]`, so the order of `[3,1,2]` is maintained.\\n2. Any number that is `greater than x` but already before `x` will still be before `x`, but all of them come after those that are less than `x` and at the same time maintain their relative order.\\ne.g. `[3,6,5,4,1,2] target = 4` -> `[3,1,2,6,5,4]`\\n3. Any number that is `greater than x` and after `x` will only need to maintain their relative order\\ne.g. `[3,6,5,4,8,1,7,2] target = 4` -> `[3,1,2,6,5,4,8,7]`\\n\\nHope this helps those who have a difficulty time understanding **\"all nodes less than x come before nodes greater than or equal to x.\"** like me.  \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\n"
                    },
                    {
                        "username": "kishore_001",
                        "content": "[@The_Laughing_Storm](/The_Laughing_Storm)  i understand the question now"
                    },
                    {
                        "username": "ahad7792",
                        "content": "Maximum leetcode  question\\'s description is very unclear"
                    },
                    {
                        "username": "pavan9100",
                        "content": "Haha!...They explained about the place and you explained about the directions"
                    },
                    {
                        "username": "dporwal985",
                        "content": "I was confused for a second and got into the discussion section about that particular line. Seeing your detailed discussion helped. Thanks man!"
                    },
                    {
                        "username": "DeadlyTRex",
                        "content": "[@diksm0ker](/diksm0ker) if relative order was important then in first test case \\nInput: head = [1,4,3,2,5,2], x = 3\\nOutput: [1,2,2,4,3,5]\\nwhy the output is not 1,4,2,2,3,5. the relative order got changed for 2 and 4 in the description\\'s output"
                    },
                    {
                        "username": "The_Laughing_Storm",
                        "content": "[@normanlmfung](/normanlmfung) Relative order means that the orignal order given. So in [3,4,1,2] the order is 3->4->1->2 so after target is 4 the order should be 3->1->2->4 because in the orignal order 3 was before 1 and 1 was before 2. Relative order means wrt to the question. These are linked lists here not arrays so order here is wierd"
                    },
                    {
                        "username": "normanlmfung",
                        "content": "It's still unclear [3,4,1,2], target = 4 -> [3,1,2,4] \n\nWhy not \n     [1,2,3,4]? <-- 1 appear before 2 so \"relative order\" still maintained\nor even \n    [1,3,2,4] <-- same here, 1 apear before 2 and \"relative order\" still maintained.\n\nAnother example,\n    [3,6,5,4,1,2] target = 4 -> [3,1,2,6,5,4]\n\n    Why not \n        [1,2,3,6,5,4]           <-- \"preserve the original relative order of the nodes in each of the two partitions\" does not explains why 1,2 should appear after 3\n        [3,6,5,1,2,4]           <-- \"all nodes less than x come before nodes greater than or equal to x\" explains why 1,2 should appear BEFORE 6,5 so this is fine\n\nQuestion poorly written. So I think developers are expected to try different test cases to understand pick up things that's not specified in problem statement."
                    },
                    {
                        "username": "comanea",
                        "content": "You understood that statement correctly. The description adds right below `You should preserve the original relative order of the nodes in each of the two partitions.`. If that wasn\\'t there when you wrote the comment, then that\\'s on the problem maker, but it looks correct now. Fortunately it\\'s an easy fix anyway."
                    },
                    {
                        "username": "Jaiff",
                        "content": "Happy Independence Day Indian bros. \\nWe live young, \\nWe live free!!!"
                    },
                    {
                        "username": "vinnnu",
                        "content": "Jai Hind!!! Onwards and Upwards"
                    },
                    {
                        "username": "ckvb18",
                        "content": "YES GLORY TO INDIA !!!"
                    },
                    {
                        "username": "codewithnavneet",
                        "content": "Happy independence day brother JAY HIND"
                    },
                    {
                        "username": "aarush_badkur30",
                        "content": "same to u bro Jai Hind "
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "jai hind"
                    },
                    {
                        "username": "kandalachetan",
                        "content": "same to you bro"
                    },
                    {
                        "username": "KingShuK17",
                        "content": "JAI HIND! upwards and onwards, always!"
                    },
                    {
                        "username": "homer_simpson",
                        "content": "\"For example,\\n\\nGiven 1->4->3->2->5->2 and x = 3,\\n\\nreturn 1->2->2->4->3->5.\"\\n\\nIn the return, why does 4 come before 3 if it's larger???\\n\\n\\nAlso, my code fails this test:\\n\"Input:\\t{2,1}, 1\\n\\nOutput:\\t{1,2}\\n\\nExpected:\\t{2,1}\"\\n\\nIf x is 1, why would the expected output have 2 come before 1?\\n\\nThanks."
                    },
                    {
                        "username": "rahulkasula23",
                        "content": "bro I done this question 8 years after your submission"
                    },
                    {
                        "username": "powerup7",
                        "content": "[@Anand_On_Leet](/Anand_On_Leet) No, no sorting of the list is required. That\\'s how you keep relative order."
                    },
                    {
                        "username": "powerup7",
                        "content": "[@Anand_On_Leet](/Anand_On_Leet) No. No sorting of the list is required. That\\'s how you keep relative order."
                    },
                    {
                        "username": "brb715",
                        "content": "In the first eg, since 4 is greater than or equal to 3(i.e x), all the nodes that are less than 3 will come before 4 and the order of the nodes should be same."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes thankfully they covered that case in the examples, right?\n\n4 comes before 3 because relative order must be preserved.\n\n3 doesn't require being moved because it is >= x.\n\nhope that wasn't too much of a spoiler."
                    },
                    {
                        "username": "Anand_On_Leet",
                        "content": "Then , we should only sort that list."
                    },
                    {
                        "username": "1ort",
                        "content": "tip: Don\\'t forget to clear the Next of the last element of the list if you are spreading elements across two lists. I tried for half an hour to figure out why my solution fails with an error until I realized that I was returning a list with a loop"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Divide the given list head into 2 linked lists, greater & smaller. Then connect these 2 lists and return the result. One more hint:\nThe whole process shown by modifying submitted code in playground\n```\n1<3:smaller\nsmaller:0->1->4->3->2->5->2\ngreater:0\n-------\n4>=3: greater\nsmaller:0->1->4->3->2->5->2\ngreater:0->4->3->2->5->2\n-------\n3>=3: greater\nsmaller:0->1->4->3->2->5->2\ngreater:0->4->3->2->5->2\n-------\n2<3:smaller\nsmaller:0->1->2->5->2\ngreater:0->4->3->2->5->2\n-------\n5>=3: greater\nsmaller:0->1->2->5->2\ngreater:0->4->3->5->2\n-------\n2<3:smaller\nsmaller:0->1->2->2\ngreater:0->4->3->5->2\n-------\nans:\n1->2->2->4->3->5\n```"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@omeirr13](/omeirr13) Since my program uses the constructors, it needs extra O(1) space, that is an extra dummy node.  With such extra dummy node makes programming easier. If you won't use extra space, it needs some modification which may lead to an error."
                    },
                    {
                        "username": "omeirr13",
                        "content": "wont this use extra space"
                    },
                    {
                        "username": "anuron_das",
                        "content": "It is an interesting problem, at least to me. If I were to explain the problem statement to anyone in the simplest terms, I would go like this:\n\nYou are given a linked list and a target number `x`.  You have to reorder the list in such a way that any node with a value `strictly less than x` appears `in the beginning` of the list, such that their relative order `among themselves` is preserved.\n\nFor example: `[1,4,3,2,5,2]` and `x=3`. All the numbers `strictly smaller than x` are `[1,2,2]`. So preserve only their relative order and add them in the beginning of the list.\n\nAfter that you have to preserve the relative order of all the `remaining elements` as well, and after that you can return the list `head`.\n\nFor example, let us consider the above example only, in `[1,4,3,2,5,2]` and `x=3`, after removing all the numbers `strictly less than x`, the remaining list is `[4,3,5]`. So their relative order is preserved accordingly.\n\nIn the end just concatenate the two and return the result.\n\nSo if the problem statement is clear, then one can appreciate the importance of `two pointers` approach, as this problem involves the use of `two pointers` on linked lists. I hope the reader finds this helpful. "
                    },
                    {
                        "username": "valige7091",
                        "content": "All the problem asks one to do is loop through a list and add each element to one of two lists, before combining the two then returning."
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@sameer89](/sameer89) well, as i understood valige, he meant to say take 2 separate lists of all nodes < x and nodes >= x, and then in the end join the tail of one to head of another which will take O(n). "
                    },
                    {
                        "username": "sameer89",
                        "content": "[@2uringTested](/2uringTested) No it wont.  Since these are linked lists it can be done in O(1) space like \"merge\" in mergesort."
                    },
                    {
                        "username": "2uringTested",
                        "content": "that will use extra space, thats not the best solution, you can do the partition in the same list and in one pass."
                    },
                    {
                        "username": "woodyinho",
                        "content": "Input: head = 1->4->3->2->5->2, x = 3\\nOutput: 1->2->2->4->3->5\\n\\nwhy 4 is exist before than 3 not after ?\\n"
                    },
                    {
                        "username": "pahwagautam786",
                        "content": "Because we also have to maintane  the relative order of elements and we have to compare with greater or eqaul to \\'x\\' "
                    },
                    {
                        "username": "sairam852",
                        "content": "because problem description was all nodes less than x come before nodes greater than or equal to x i.e., we no need to move the greater values to after of that targeted value"
                    },
                    {
                        "username": "Abhishen99",
                        "content": "\\n[328. Odd Even Linked List ](https://leetcode.com/problems/odd-even-linked-list/)\\n\\nabove problem is quite similiar to this problem after trying this you can solve that too.\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I wanted to comment the same thing, that one is a nice follow up, requiring O(1) space and O(n) time"
                    },
                    {
                        "username": "Ausho_Roup",
                        "content": "Anyone please explain this question. I am unable to get it. I am trying to understand nearly from two days still not able to figure it out ."
                    },
                    {
                        "username": "nikhilnyalakanti2003",
                        "content": "checkout the discussion section again, ig you\\'ll have it cleared this time"
                    }
                ]
            },
            {
                "id": 2014581,
                "content": [
                    {
                        "username": "zdf826504558",
                        "content": "The description for this problem is somewhat very misleading. \\nI took at least 15 min and tested serval test cases so that I understood what it was asking for.\\n\\nLet me briefly explain it to relieve your pain.\\n\\nBasically, it asks us:\\n`reorder the sequence by the given number x`\\n\\nThe rules are:\\n1. Any number that is `less than x` has to be before `x`, and maintain the relative order with thoese that are less than `x` but already before `x`.\\ne.g. `[3,4,1,2], target = 4` -> `[3,1,2,4]`, so the order of `[3,1,2]` is maintained.\\n2. Any number that is `greater than x` but already before `x` will still be before `x`, but all of them come after those that are less than `x` and at the same time maintain their relative order.\\ne.g. `[3,6,5,4,1,2] target = 4` -> `[3,1,2,6,5,4]`\\n3. Any number that is `greater than x` and after `x` will only need to maintain their relative order\\ne.g. `[3,6,5,4,8,1,7,2] target = 4` -> `[3,1,2,6,5,4,8,7]`\\n\\nHope this helps those who have a difficulty time understanding **\"all nodes less than x come before nodes greater than or equal to x.\"** like me.  \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\n"
                    },
                    {
                        "username": "kishore_001",
                        "content": "[@The_Laughing_Storm](/The_Laughing_Storm)  i understand the question now"
                    },
                    {
                        "username": "ahad7792",
                        "content": "Maximum leetcode  question\\'s description is very unclear"
                    },
                    {
                        "username": "pavan9100",
                        "content": "Haha!...They explained about the place and you explained about the directions"
                    },
                    {
                        "username": "dporwal985",
                        "content": "I was confused for a second and got into the discussion section about that particular line. Seeing your detailed discussion helped. Thanks man!"
                    },
                    {
                        "username": "DeadlyTRex",
                        "content": "[@diksm0ker](/diksm0ker) if relative order was important then in first test case \\nInput: head = [1,4,3,2,5,2], x = 3\\nOutput: [1,2,2,4,3,5]\\nwhy the output is not 1,4,2,2,3,5. the relative order got changed for 2 and 4 in the description\\'s output"
                    },
                    {
                        "username": "The_Laughing_Storm",
                        "content": "[@normanlmfung](/normanlmfung) Relative order means that the orignal order given. So in [3,4,1,2] the order is 3->4->1->2 so after target is 4 the order should be 3->1->2->4 because in the orignal order 3 was before 1 and 1 was before 2. Relative order means wrt to the question. These are linked lists here not arrays so order here is wierd"
                    },
                    {
                        "username": "normanlmfung",
                        "content": "It's still unclear [3,4,1,2], target = 4 -> [3,1,2,4] \n\nWhy not \n     [1,2,3,4]? <-- 1 appear before 2 so \"relative order\" still maintained\nor even \n    [1,3,2,4] <-- same here, 1 apear before 2 and \"relative order\" still maintained.\n\nAnother example,\n    [3,6,5,4,1,2] target = 4 -> [3,1,2,6,5,4]\n\n    Why not \n        [1,2,3,6,5,4]           <-- \"preserve the original relative order of the nodes in each of the two partitions\" does not explains why 1,2 should appear after 3\n        [3,6,5,1,2,4]           <-- \"all nodes less than x come before nodes greater than or equal to x\" explains why 1,2 should appear BEFORE 6,5 so this is fine\n\nQuestion poorly written. So I think developers are expected to try different test cases to understand pick up things that's not specified in problem statement."
                    },
                    {
                        "username": "comanea",
                        "content": "You understood that statement correctly. The description adds right below `You should preserve the original relative order of the nodes in each of the two partitions.`. If that wasn\\'t there when you wrote the comment, then that\\'s on the problem maker, but it looks correct now. Fortunately it\\'s an easy fix anyway."
                    },
                    {
                        "username": "Jaiff",
                        "content": "Happy Independence Day Indian bros. \\nWe live young, \\nWe live free!!!"
                    },
                    {
                        "username": "vinnnu",
                        "content": "Jai Hind!!! Onwards and Upwards"
                    },
                    {
                        "username": "ckvb18",
                        "content": "YES GLORY TO INDIA !!!"
                    },
                    {
                        "username": "codewithnavneet",
                        "content": "Happy independence day brother JAY HIND"
                    },
                    {
                        "username": "aarush_badkur30",
                        "content": "same to u bro Jai Hind "
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "jai hind"
                    },
                    {
                        "username": "kandalachetan",
                        "content": "same to you bro"
                    },
                    {
                        "username": "KingShuK17",
                        "content": "JAI HIND! upwards and onwards, always!"
                    },
                    {
                        "username": "homer_simpson",
                        "content": "\"For example,\\n\\nGiven 1->4->3->2->5->2 and x = 3,\\n\\nreturn 1->2->2->4->3->5.\"\\n\\nIn the return, why does 4 come before 3 if it's larger???\\n\\n\\nAlso, my code fails this test:\\n\"Input:\\t{2,1}, 1\\n\\nOutput:\\t{1,2}\\n\\nExpected:\\t{2,1}\"\\n\\nIf x is 1, why would the expected output have 2 come before 1?\\n\\nThanks."
                    },
                    {
                        "username": "rahulkasula23",
                        "content": "bro I done this question 8 years after your submission"
                    },
                    {
                        "username": "powerup7",
                        "content": "[@Anand_On_Leet](/Anand_On_Leet) No, no sorting of the list is required. That\\'s how you keep relative order."
                    },
                    {
                        "username": "powerup7",
                        "content": "[@Anand_On_Leet](/Anand_On_Leet) No. No sorting of the list is required. That\\'s how you keep relative order."
                    },
                    {
                        "username": "brb715",
                        "content": "In the first eg, since 4 is greater than or equal to 3(i.e x), all the nodes that are less than 3 will come before 4 and the order of the nodes should be same."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes thankfully they covered that case in the examples, right?\n\n4 comes before 3 because relative order must be preserved.\n\n3 doesn't require being moved because it is >= x.\n\nhope that wasn't too much of a spoiler."
                    },
                    {
                        "username": "Anand_On_Leet",
                        "content": "Then , we should only sort that list."
                    },
                    {
                        "username": "1ort",
                        "content": "tip: Don\\'t forget to clear the Next of the last element of the list if you are spreading elements across two lists. I tried for half an hour to figure out why my solution fails with an error until I realized that I was returning a list with a loop"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Divide the given list head into 2 linked lists, greater & smaller. Then connect these 2 lists and return the result. One more hint:\nThe whole process shown by modifying submitted code in playground\n```\n1<3:smaller\nsmaller:0->1->4->3->2->5->2\ngreater:0\n-------\n4>=3: greater\nsmaller:0->1->4->3->2->5->2\ngreater:0->4->3->2->5->2\n-------\n3>=3: greater\nsmaller:0->1->4->3->2->5->2\ngreater:0->4->3->2->5->2\n-------\n2<3:smaller\nsmaller:0->1->2->5->2\ngreater:0->4->3->2->5->2\n-------\n5>=3: greater\nsmaller:0->1->2->5->2\ngreater:0->4->3->5->2\n-------\n2<3:smaller\nsmaller:0->1->2->2\ngreater:0->4->3->5->2\n-------\nans:\n1->2->2->4->3->5\n```"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@omeirr13](/omeirr13) Since my program uses the constructors, it needs extra O(1) space, that is an extra dummy node.  With such extra dummy node makes programming easier. If you won't use extra space, it needs some modification which may lead to an error."
                    },
                    {
                        "username": "omeirr13",
                        "content": "wont this use extra space"
                    },
                    {
                        "username": "anuron_das",
                        "content": "It is an interesting problem, at least to me. If I were to explain the problem statement to anyone in the simplest terms, I would go like this:\n\nYou are given a linked list and a target number `x`.  You have to reorder the list in such a way that any node with a value `strictly less than x` appears `in the beginning` of the list, such that their relative order `among themselves` is preserved.\n\nFor example: `[1,4,3,2,5,2]` and `x=3`. All the numbers `strictly smaller than x` are `[1,2,2]`. So preserve only their relative order and add them in the beginning of the list.\n\nAfter that you have to preserve the relative order of all the `remaining elements` as well, and after that you can return the list `head`.\n\nFor example, let us consider the above example only, in `[1,4,3,2,5,2]` and `x=3`, after removing all the numbers `strictly less than x`, the remaining list is `[4,3,5]`. So their relative order is preserved accordingly.\n\nIn the end just concatenate the two and return the result.\n\nSo if the problem statement is clear, then one can appreciate the importance of `two pointers` approach, as this problem involves the use of `two pointers` on linked lists. I hope the reader finds this helpful. "
                    },
                    {
                        "username": "valige7091",
                        "content": "All the problem asks one to do is loop through a list and add each element to one of two lists, before combining the two then returning."
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@sameer89](/sameer89) well, as i understood valige, he meant to say take 2 separate lists of all nodes < x and nodes >= x, and then in the end join the tail of one to head of another which will take O(n). "
                    },
                    {
                        "username": "sameer89",
                        "content": "[@2uringTested](/2uringTested) No it wont.  Since these are linked lists it can be done in O(1) space like \"merge\" in mergesort."
                    },
                    {
                        "username": "2uringTested",
                        "content": "that will use extra space, thats not the best solution, you can do the partition in the same list and in one pass."
                    },
                    {
                        "username": "woodyinho",
                        "content": "Input: head = 1->4->3->2->5->2, x = 3\\nOutput: 1->2->2->4->3->5\\n\\nwhy 4 is exist before than 3 not after ?\\n"
                    },
                    {
                        "username": "pahwagautam786",
                        "content": "Because we also have to maintane  the relative order of elements and we have to compare with greater or eqaul to \\'x\\' "
                    },
                    {
                        "username": "sairam852",
                        "content": "because problem description was all nodes less than x come before nodes greater than or equal to x i.e., we no need to move the greater values to after of that targeted value"
                    },
                    {
                        "username": "Abhishen99",
                        "content": "\\n[328. Odd Even Linked List ](https://leetcode.com/problems/odd-even-linked-list/)\\n\\nabove problem is quite similiar to this problem after trying this you can solve that too.\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I wanted to comment the same thing, that one is a nice follow up, requiring O(1) space and O(n) time"
                    },
                    {
                        "username": "Ausho_Roup",
                        "content": "Anyone please explain this question. I am unable to get it. I am trying to understand nearly from two days still not able to figure it out ."
                    },
                    {
                        "username": "nikhilnyalakanti2003",
                        "content": "checkout the discussion section again, ig you\\'ll have it cleared this time"
                    }
                ]
            },
            {
                "id": 2014671,
                "content": [
                    {
                        "username": "zdf826504558",
                        "content": "The description for this problem is somewhat very misleading. \\nI took at least 15 min and tested serval test cases so that I understood what it was asking for.\\n\\nLet me briefly explain it to relieve your pain.\\n\\nBasically, it asks us:\\n`reorder the sequence by the given number x`\\n\\nThe rules are:\\n1. Any number that is `less than x` has to be before `x`, and maintain the relative order with thoese that are less than `x` but already before `x`.\\ne.g. `[3,4,1,2], target = 4` -> `[3,1,2,4]`, so the order of `[3,1,2]` is maintained.\\n2. Any number that is `greater than x` but already before `x` will still be before `x`, but all of them come after those that are less than `x` and at the same time maintain their relative order.\\ne.g. `[3,6,5,4,1,2] target = 4` -> `[3,1,2,6,5,4]`\\n3. Any number that is `greater than x` and after `x` will only need to maintain their relative order\\ne.g. `[3,6,5,4,8,1,7,2] target = 4` -> `[3,1,2,6,5,4,8,7]`\\n\\nHope this helps those who have a difficulty time understanding **\"all nodes less than x come before nodes greater than or equal to x.\"** like me.  \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\n"
                    },
                    {
                        "username": "kishore_001",
                        "content": "[@The_Laughing_Storm](/The_Laughing_Storm)  i understand the question now"
                    },
                    {
                        "username": "ahad7792",
                        "content": "Maximum leetcode  question\\'s description is very unclear"
                    },
                    {
                        "username": "pavan9100",
                        "content": "Haha!...They explained about the place and you explained about the directions"
                    },
                    {
                        "username": "dporwal985",
                        "content": "I was confused for a second and got into the discussion section about that particular line. Seeing your detailed discussion helped. Thanks man!"
                    },
                    {
                        "username": "DeadlyTRex",
                        "content": "[@diksm0ker](/diksm0ker) if relative order was important then in first test case \\nInput: head = [1,4,3,2,5,2], x = 3\\nOutput: [1,2,2,4,3,5]\\nwhy the output is not 1,4,2,2,3,5. the relative order got changed for 2 and 4 in the description\\'s output"
                    },
                    {
                        "username": "The_Laughing_Storm",
                        "content": "[@normanlmfung](/normanlmfung) Relative order means that the orignal order given. So in [3,4,1,2] the order is 3->4->1->2 so after target is 4 the order should be 3->1->2->4 because in the orignal order 3 was before 1 and 1 was before 2. Relative order means wrt to the question. These are linked lists here not arrays so order here is wierd"
                    },
                    {
                        "username": "normanlmfung",
                        "content": "It's still unclear [3,4,1,2], target = 4 -> [3,1,2,4] \n\nWhy not \n     [1,2,3,4]? <-- 1 appear before 2 so \"relative order\" still maintained\nor even \n    [1,3,2,4] <-- same here, 1 apear before 2 and \"relative order\" still maintained.\n\nAnother example,\n    [3,6,5,4,1,2] target = 4 -> [3,1,2,6,5,4]\n\n    Why not \n        [1,2,3,6,5,4]           <-- \"preserve the original relative order of the nodes in each of the two partitions\" does not explains why 1,2 should appear after 3\n        [3,6,5,1,2,4]           <-- \"all nodes less than x come before nodes greater than or equal to x\" explains why 1,2 should appear BEFORE 6,5 so this is fine\n\nQuestion poorly written. So I think developers are expected to try different test cases to understand pick up things that's not specified in problem statement."
                    },
                    {
                        "username": "comanea",
                        "content": "You understood that statement correctly. The description adds right below `You should preserve the original relative order of the nodes in each of the two partitions.`. If that wasn\\'t there when you wrote the comment, then that\\'s on the problem maker, but it looks correct now. Fortunately it\\'s an easy fix anyway."
                    },
                    {
                        "username": "Jaiff",
                        "content": "Happy Independence Day Indian bros. \\nWe live young, \\nWe live free!!!"
                    },
                    {
                        "username": "vinnnu",
                        "content": "Jai Hind!!! Onwards and Upwards"
                    },
                    {
                        "username": "ckvb18",
                        "content": "YES GLORY TO INDIA !!!"
                    },
                    {
                        "username": "codewithnavneet",
                        "content": "Happy independence day brother JAY HIND"
                    },
                    {
                        "username": "aarush_badkur30",
                        "content": "same to u bro Jai Hind "
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "jai hind"
                    },
                    {
                        "username": "kandalachetan",
                        "content": "same to you bro"
                    },
                    {
                        "username": "KingShuK17",
                        "content": "JAI HIND! upwards and onwards, always!"
                    },
                    {
                        "username": "homer_simpson",
                        "content": "\"For example,\\n\\nGiven 1->4->3->2->5->2 and x = 3,\\n\\nreturn 1->2->2->4->3->5.\"\\n\\nIn the return, why does 4 come before 3 if it's larger???\\n\\n\\nAlso, my code fails this test:\\n\"Input:\\t{2,1}, 1\\n\\nOutput:\\t{1,2}\\n\\nExpected:\\t{2,1}\"\\n\\nIf x is 1, why would the expected output have 2 come before 1?\\n\\nThanks."
                    },
                    {
                        "username": "rahulkasula23",
                        "content": "bro I done this question 8 years after your submission"
                    },
                    {
                        "username": "powerup7",
                        "content": "[@Anand_On_Leet](/Anand_On_Leet) No, no sorting of the list is required. That\\'s how you keep relative order."
                    },
                    {
                        "username": "powerup7",
                        "content": "[@Anand_On_Leet](/Anand_On_Leet) No. No sorting of the list is required. That\\'s how you keep relative order."
                    },
                    {
                        "username": "brb715",
                        "content": "In the first eg, since 4 is greater than or equal to 3(i.e x), all the nodes that are less than 3 will come before 4 and the order of the nodes should be same."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes thankfully they covered that case in the examples, right?\n\n4 comes before 3 because relative order must be preserved.\n\n3 doesn't require being moved because it is >= x.\n\nhope that wasn't too much of a spoiler."
                    },
                    {
                        "username": "Anand_On_Leet",
                        "content": "Then , we should only sort that list."
                    },
                    {
                        "username": "1ort",
                        "content": "tip: Don\\'t forget to clear the Next of the last element of the list if you are spreading elements across two lists. I tried for half an hour to figure out why my solution fails with an error until I realized that I was returning a list with a loop"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Divide the given list head into 2 linked lists, greater & smaller. Then connect these 2 lists and return the result. One more hint:\nThe whole process shown by modifying submitted code in playground\n```\n1<3:smaller\nsmaller:0->1->4->3->2->5->2\ngreater:0\n-------\n4>=3: greater\nsmaller:0->1->4->3->2->5->2\ngreater:0->4->3->2->5->2\n-------\n3>=3: greater\nsmaller:0->1->4->3->2->5->2\ngreater:0->4->3->2->5->2\n-------\n2<3:smaller\nsmaller:0->1->2->5->2\ngreater:0->4->3->2->5->2\n-------\n5>=3: greater\nsmaller:0->1->2->5->2\ngreater:0->4->3->5->2\n-------\n2<3:smaller\nsmaller:0->1->2->2\ngreater:0->4->3->5->2\n-------\nans:\n1->2->2->4->3->5\n```"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@omeirr13](/omeirr13) Since my program uses the constructors, it needs extra O(1) space, that is an extra dummy node.  With such extra dummy node makes programming easier. If you won't use extra space, it needs some modification which may lead to an error."
                    },
                    {
                        "username": "omeirr13",
                        "content": "wont this use extra space"
                    },
                    {
                        "username": "anuron_das",
                        "content": "It is an interesting problem, at least to me. If I were to explain the problem statement to anyone in the simplest terms, I would go like this:\n\nYou are given a linked list and a target number `x`.  You have to reorder the list in such a way that any node with a value `strictly less than x` appears `in the beginning` of the list, such that their relative order `among themselves` is preserved.\n\nFor example: `[1,4,3,2,5,2]` and `x=3`. All the numbers `strictly smaller than x` are `[1,2,2]`. So preserve only their relative order and add them in the beginning of the list.\n\nAfter that you have to preserve the relative order of all the `remaining elements` as well, and after that you can return the list `head`.\n\nFor example, let us consider the above example only, in `[1,4,3,2,5,2]` and `x=3`, after removing all the numbers `strictly less than x`, the remaining list is `[4,3,5]`. So their relative order is preserved accordingly.\n\nIn the end just concatenate the two and return the result.\n\nSo if the problem statement is clear, then one can appreciate the importance of `two pointers` approach, as this problem involves the use of `two pointers` on linked lists. I hope the reader finds this helpful. "
                    },
                    {
                        "username": "valige7091",
                        "content": "All the problem asks one to do is loop through a list and add each element to one of two lists, before combining the two then returning."
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@sameer89](/sameer89) well, as i understood valige, he meant to say take 2 separate lists of all nodes < x and nodes >= x, and then in the end join the tail of one to head of another which will take O(n). "
                    },
                    {
                        "username": "sameer89",
                        "content": "[@2uringTested](/2uringTested) No it wont.  Since these are linked lists it can be done in O(1) space like \"merge\" in mergesort."
                    },
                    {
                        "username": "2uringTested",
                        "content": "that will use extra space, thats not the best solution, you can do the partition in the same list and in one pass."
                    },
                    {
                        "username": "woodyinho",
                        "content": "Input: head = 1->4->3->2->5->2, x = 3\\nOutput: 1->2->2->4->3->5\\n\\nwhy 4 is exist before than 3 not after ?\\n"
                    },
                    {
                        "username": "pahwagautam786",
                        "content": "Because we also have to maintane  the relative order of elements and we have to compare with greater or eqaul to \\'x\\' "
                    },
                    {
                        "username": "sairam852",
                        "content": "because problem description was all nodes less than x come before nodes greater than or equal to x i.e., we no need to move the greater values to after of that targeted value"
                    },
                    {
                        "username": "Abhishen99",
                        "content": "\\n[328. Odd Even Linked List ](https://leetcode.com/problems/odd-even-linked-list/)\\n\\nabove problem is quite similiar to this problem after trying this you can solve that too.\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I wanted to comment the same thing, that one is a nice follow up, requiring O(1) space and O(n) time"
                    },
                    {
                        "username": "Ausho_Roup",
                        "content": "Anyone please explain this question. I am unable to get it. I am trying to understand nearly from two days still not able to figure it out ."
                    },
                    {
                        "username": "nikhilnyalakanti2003",
                        "content": "checkout the discussion section again, ig you\\'ll have it cleared this time"
                    }
                ]
            },
            {
                "id": 1570330,
                "content": [
                    {
                        "username": "zdf826504558",
                        "content": "The description for this problem is somewhat very misleading. \\nI took at least 15 min and tested serval test cases so that I understood what it was asking for.\\n\\nLet me briefly explain it to relieve your pain.\\n\\nBasically, it asks us:\\n`reorder the sequence by the given number x`\\n\\nThe rules are:\\n1. Any number that is `less than x` has to be before `x`, and maintain the relative order with thoese that are less than `x` but already before `x`.\\ne.g. `[3,4,1,2], target = 4` -> `[3,1,2,4]`, so the order of `[3,1,2]` is maintained.\\n2. Any number that is `greater than x` but already before `x` will still be before `x`, but all of them come after those that are less than `x` and at the same time maintain their relative order.\\ne.g. `[3,6,5,4,1,2] target = 4` -> `[3,1,2,6,5,4]`\\n3. Any number that is `greater than x` and after `x` will only need to maintain their relative order\\ne.g. `[3,6,5,4,8,1,7,2] target = 4` -> `[3,1,2,6,5,4,8,7]`\\n\\nHope this helps those who have a difficulty time understanding **\"all nodes less than x come before nodes greater than or equal to x.\"** like me.  \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\n"
                    },
                    {
                        "username": "kishore_001",
                        "content": "[@The_Laughing_Storm](/The_Laughing_Storm)  i understand the question now"
                    },
                    {
                        "username": "ahad7792",
                        "content": "Maximum leetcode  question\\'s description is very unclear"
                    },
                    {
                        "username": "pavan9100",
                        "content": "Haha!...They explained about the place and you explained about the directions"
                    },
                    {
                        "username": "dporwal985",
                        "content": "I was confused for a second and got into the discussion section about that particular line. Seeing your detailed discussion helped. Thanks man!"
                    },
                    {
                        "username": "DeadlyTRex",
                        "content": "[@diksm0ker](/diksm0ker) if relative order was important then in first test case \\nInput: head = [1,4,3,2,5,2], x = 3\\nOutput: [1,2,2,4,3,5]\\nwhy the output is not 1,4,2,2,3,5. the relative order got changed for 2 and 4 in the description\\'s output"
                    },
                    {
                        "username": "The_Laughing_Storm",
                        "content": "[@normanlmfung](/normanlmfung) Relative order means that the orignal order given. So in [3,4,1,2] the order is 3->4->1->2 so after target is 4 the order should be 3->1->2->4 because in the orignal order 3 was before 1 and 1 was before 2. Relative order means wrt to the question. These are linked lists here not arrays so order here is wierd"
                    },
                    {
                        "username": "normanlmfung",
                        "content": "It's still unclear [3,4,1,2], target = 4 -> [3,1,2,4] \n\nWhy not \n     [1,2,3,4]? <-- 1 appear before 2 so \"relative order\" still maintained\nor even \n    [1,3,2,4] <-- same here, 1 apear before 2 and \"relative order\" still maintained.\n\nAnother example,\n    [3,6,5,4,1,2] target = 4 -> [3,1,2,6,5,4]\n\n    Why not \n        [1,2,3,6,5,4]           <-- \"preserve the original relative order of the nodes in each of the two partitions\" does not explains why 1,2 should appear after 3\n        [3,6,5,1,2,4]           <-- \"all nodes less than x come before nodes greater than or equal to x\" explains why 1,2 should appear BEFORE 6,5 so this is fine\n\nQuestion poorly written. So I think developers are expected to try different test cases to understand pick up things that's not specified in problem statement."
                    },
                    {
                        "username": "comanea",
                        "content": "You understood that statement correctly. The description adds right below `You should preserve the original relative order of the nodes in each of the two partitions.`. If that wasn\\'t there when you wrote the comment, then that\\'s on the problem maker, but it looks correct now. Fortunately it\\'s an easy fix anyway."
                    },
                    {
                        "username": "Jaiff",
                        "content": "Happy Independence Day Indian bros. \\nWe live young, \\nWe live free!!!"
                    },
                    {
                        "username": "vinnnu",
                        "content": "Jai Hind!!! Onwards and Upwards"
                    },
                    {
                        "username": "ckvb18",
                        "content": "YES GLORY TO INDIA !!!"
                    },
                    {
                        "username": "codewithnavneet",
                        "content": "Happy independence day brother JAY HIND"
                    },
                    {
                        "username": "aarush_badkur30",
                        "content": "same to u bro Jai Hind "
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "jai hind"
                    },
                    {
                        "username": "kandalachetan",
                        "content": "same to you bro"
                    },
                    {
                        "username": "KingShuK17",
                        "content": "JAI HIND! upwards and onwards, always!"
                    },
                    {
                        "username": "homer_simpson",
                        "content": "\"For example,\\n\\nGiven 1->4->3->2->5->2 and x = 3,\\n\\nreturn 1->2->2->4->3->5.\"\\n\\nIn the return, why does 4 come before 3 if it's larger???\\n\\n\\nAlso, my code fails this test:\\n\"Input:\\t{2,1}, 1\\n\\nOutput:\\t{1,2}\\n\\nExpected:\\t{2,1}\"\\n\\nIf x is 1, why would the expected output have 2 come before 1?\\n\\nThanks."
                    },
                    {
                        "username": "rahulkasula23",
                        "content": "bro I done this question 8 years after your submission"
                    },
                    {
                        "username": "powerup7",
                        "content": "[@Anand_On_Leet](/Anand_On_Leet) No, no sorting of the list is required. That\\'s how you keep relative order."
                    },
                    {
                        "username": "powerup7",
                        "content": "[@Anand_On_Leet](/Anand_On_Leet) No. No sorting of the list is required. That\\'s how you keep relative order."
                    },
                    {
                        "username": "brb715",
                        "content": "In the first eg, since 4 is greater than or equal to 3(i.e x), all the nodes that are less than 3 will come before 4 and the order of the nodes should be same."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes thankfully they covered that case in the examples, right?\n\n4 comes before 3 because relative order must be preserved.\n\n3 doesn't require being moved because it is >= x.\n\nhope that wasn't too much of a spoiler."
                    },
                    {
                        "username": "Anand_On_Leet",
                        "content": "Then , we should only sort that list."
                    },
                    {
                        "username": "1ort",
                        "content": "tip: Don\\'t forget to clear the Next of the last element of the list if you are spreading elements across two lists. I tried for half an hour to figure out why my solution fails with an error until I realized that I was returning a list with a loop"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Divide the given list head into 2 linked lists, greater & smaller. Then connect these 2 lists and return the result. One more hint:\nThe whole process shown by modifying submitted code in playground\n```\n1<3:smaller\nsmaller:0->1->4->3->2->5->2\ngreater:0\n-------\n4>=3: greater\nsmaller:0->1->4->3->2->5->2\ngreater:0->4->3->2->5->2\n-------\n3>=3: greater\nsmaller:0->1->4->3->2->5->2\ngreater:0->4->3->2->5->2\n-------\n2<3:smaller\nsmaller:0->1->2->5->2\ngreater:0->4->3->2->5->2\n-------\n5>=3: greater\nsmaller:0->1->2->5->2\ngreater:0->4->3->5->2\n-------\n2<3:smaller\nsmaller:0->1->2->2\ngreater:0->4->3->5->2\n-------\nans:\n1->2->2->4->3->5\n```"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@omeirr13](/omeirr13) Since my program uses the constructors, it needs extra O(1) space, that is an extra dummy node.  With such extra dummy node makes programming easier. If you won't use extra space, it needs some modification which may lead to an error."
                    },
                    {
                        "username": "omeirr13",
                        "content": "wont this use extra space"
                    },
                    {
                        "username": "anuron_das",
                        "content": "It is an interesting problem, at least to me. If I were to explain the problem statement to anyone in the simplest terms, I would go like this:\n\nYou are given a linked list and a target number `x`.  You have to reorder the list in such a way that any node with a value `strictly less than x` appears `in the beginning` of the list, such that their relative order `among themselves` is preserved.\n\nFor example: `[1,4,3,2,5,2]` and `x=3`. All the numbers `strictly smaller than x` are `[1,2,2]`. So preserve only their relative order and add them in the beginning of the list.\n\nAfter that you have to preserve the relative order of all the `remaining elements` as well, and after that you can return the list `head`.\n\nFor example, let us consider the above example only, in `[1,4,3,2,5,2]` and `x=3`, after removing all the numbers `strictly less than x`, the remaining list is `[4,3,5]`. So their relative order is preserved accordingly.\n\nIn the end just concatenate the two and return the result.\n\nSo if the problem statement is clear, then one can appreciate the importance of `two pointers` approach, as this problem involves the use of `two pointers` on linked lists. I hope the reader finds this helpful. "
                    },
                    {
                        "username": "valige7091",
                        "content": "All the problem asks one to do is loop through a list and add each element to one of two lists, before combining the two then returning."
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@sameer89](/sameer89) well, as i understood valige, he meant to say take 2 separate lists of all nodes < x and nodes >= x, and then in the end join the tail of one to head of another which will take O(n). "
                    },
                    {
                        "username": "sameer89",
                        "content": "[@2uringTested](/2uringTested) No it wont.  Since these are linked lists it can be done in O(1) space like \"merge\" in mergesort."
                    },
                    {
                        "username": "2uringTested",
                        "content": "that will use extra space, thats not the best solution, you can do the partition in the same list and in one pass."
                    },
                    {
                        "username": "woodyinho",
                        "content": "Input: head = 1->4->3->2->5->2, x = 3\\nOutput: 1->2->2->4->3->5\\n\\nwhy 4 is exist before than 3 not after ?\\n"
                    },
                    {
                        "username": "pahwagautam786",
                        "content": "Because we also have to maintane  the relative order of elements and we have to compare with greater or eqaul to \\'x\\' "
                    },
                    {
                        "username": "sairam852",
                        "content": "because problem description was all nodes less than x come before nodes greater than or equal to x i.e., we no need to move the greater values to after of that targeted value"
                    },
                    {
                        "username": "Abhishen99",
                        "content": "\\n[328. Odd Even Linked List ](https://leetcode.com/problems/odd-even-linked-list/)\\n\\nabove problem is quite similiar to this problem after trying this you can solve that too.\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I wanted to comment the same thing, that one is a nice follow up, requiring O(1) space and O(n) time"
                    },
                    {
                        "username": "Ausho_Roup",
                        "content": "Anyone please explain this question. I am unable to get it. I am trying to understand nearly from two days still not able to figure it out ."
                    },
                    {
                        "username": "nikhilnyalakanti2003",
                        "content": "checkout the discussion section again, ig you\\'ll have it cleared this time"
                    }
                ]
            },
            {
                "id": 1568102,
                "content": [
                    {
                        "username": "zdf826504558",
                        "content": "The description for this problem is somewhat very misleading. \\nI took at least 15 min and tested serval test cases so that I understood what it was asking for.\\n\\nLet me briefly explain it to relieve your pain.\\n\\nBasically, it asks us:\\n`reorder the sequence by the given number x`\\n\\nThe rules are:\\n1. Any number that is `less than x` has to be before `x`, and maintain the relative order with thoese that are less than `x` but already before `x`.\\ne.g. `[3,4,1,2], target = 4` -> `[3,1,2,4]`, so the order of `[3,1,2]` is maintained.\\n2. Any number that is `greater than x` but already before `x` will still be before `x`, but all of them come after those that are less than `x` and at the same time maintain their relative order.\\ne.g. `[3,6,5,4,1,2] target = 4` -> `[3,1,2,6,5,4]`\\n3. Any number that is `greater than x` and after `x` will only need to maintain their relative order\\ne.g. `[3,6,5,4,8,1,7,2] target = 4` -> `[3,1,2,6,5,4,8,7]`\\n\\nHope this helps those who have a difficulty time understanding **\"all nodes less than x come before nodes greater than or equal to x.\"** like me.  \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\n"
                    },
                    {
                        "username": "kishore_001",
                        "content": "[@The_Laughing_Storm](/The_Laughing_Storm)  i understand the question now"
                    },
                    {
                        "username": "ahad7792",
                        "content": "Maximum leetcode  question\\'s description is very unclear"
                    },
                    {
                        "username": "pavan9100",
                        "content": "Haha!...They explained about the place and you explained about the directions"
                    },
                    {
                        "username": "dporwal985",
                        "content": "I was confused for a second and got into the discussion section about that particular line. Seeing your detailed discussion helped. Thanks man!"
                    },
                    {
                        "username": "DeadlyTRex",
                        "content": "[@diksm0ker](/diksm0ker) if relative order was important then in first test case \\nInput: head = [1,4,3,2,5,2], x = 3\\nOutput: [1,2,2,4,3,5]\\nwhy the output is not 1,4,2,2,3,5. the relative order got changed for 2 and 4 in the description\\'s output"
                    },
                    {
                        "username": "The_Laughing_Storm",
                        "content": "[@normanlmfung](/normanlmfung) Relative order means that the orignal order given. So in [3,4,1,2] the order is 3->4->1->2 so after target is 4 the order should be 3->1->2->4 because in the orignal order 3 was before 1 and 1 was before 2. Relative order means wrt to the question. These are linked lists here not arrays so order here is wierd"
                    },
                    {
                        "username": "normanlmfung",
                        "content": "It's still unclear [3,4,1,2], target = 4 -> [3,1,2,4] \n\nWhy not \n     [1,2,3,4]? <-- 1 appear before 2 so \"relative order\" still maintained\nor even \n    [1,3,2,4] <-- same here, 1 apear before 2 and \"relative order\" still maintained.\n\nAnother example,\n    [3,6,5,4,1,2] target = 4 -> [3,1,2,6,5,4]\n\n    Why not \n        [1,2,3,6,5,4]           <-- \"preserve the original relative order of the nodes in each of the two partitions\" does not explains why 1,2 should appear after 3\n        [3,6,5,1,2,4]           <-- \"all nodes less than x come before nodes greater than or equal to x\" explains why 1,2 should appear BEFORE 6,5 so this is fine\n\nQuestion poorly written. So I think developers are expected to try different test cases to understand pick up things that's not specified in problem statement."
                    },
                    {
                        "username": "comanea",
                        "content": "You understood that statement correctly. The description adds right below `You should preserve the original relative order of the nodes in each of the two partitions.`. If that wasn\\'t there when you wrote the comment, then that\\'s on the problem maker, but it looks correct now. Fortunately it\\'s an easy fix anyway."
                    },
                    {
                        "username": "Jaiff",
                        "content": "Happy Independence Day Indian bros. \\nWe live young, \\nWe live free!!!"
                    },
                    {
                        "username": "vinnnu",
                        "content": "Jai Hind!!! Onwards and Upwards"
                    },
                    {
                        "username": "ckvb18",
                        "content": "YES GLORY TO INDIA !!!"
                    },
                    {
                        "username": "codewithnavneet",
                        "content": "Happy independence day brother JAY HIND"
                    },
                    {
                        "username": "aarush_badkur30",
                        "content": "same to u bro Jai Hind "
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "jai hind"
                    },
                    {
                        "username": "kandalachetan",
                        "content": "same to you bro"
                    },
                    {
                        "username": "KingShuK17",
                        "content": "JAI HIND! upwards and onwards, always!"
                    },
                    {
                        "username": "homer_simpson",
                        "content": "\"For example,\\n\\nGiven 1->4->3->2->5->2 and x = 3,\\n\\nreturn 1->2->2->4->3->5.\"\\n\\nIn the return, why does 4 come before 3 if it's larger???\\n\\n\\nAlso, my code fails this test:\\n\"Input:\\t{2,1}, 1\\n\\nOutput:\\t{1,2}\\n\\nExpected:\\t{2,1}\"\\n\\nIf x is 1, why would the expected output have 2 come before 1?\\n\\nThanks."
                    },
                    {
                        "username": "rahulkasula23",
                        "content": "bro I done this question 8 years after your submission"
                    },
                    {
                        "username": "powerup7",
                        "content": "[@Anand_On_Leet](/Anand_On_Leet) No, no sorting of the list is required. That\\'s how you keep relative order."
                    },
                    {
                        "username": "powerup7",
                        "content": "[@Anand_On_Leet](/Anand_On_Leet) No. No sorting of the list is required. That\\'s how you keep relative order."
                    },
                    {
                        "username": "brb715",
                        "content": "In the first eg, since 4 is greater than or equal to 3(i.e x), all the nodes that are less than 3 will come before 4 and the order of the nodes should be same."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes thankfully they covered that case in the examples, right?\n\n4 comes before 3 because relative order must be preserved.\n\n3 doesn't require being moved because it is >= x.\n\nhope that wasn't too much of a spoiler."
                    },
                    {
                        "username": "Anand_On_Leet",
                        "content": "Then , we should only sort that list."
                    },
                    {
                        "username": "1ort",
                        "content": "tip: Don\\'t forget to clear the Next of the last element of the list if you are spreading elements across two lists. I tried for half an hour to figure out why my solution fails with an error until I realized that I was returning a list with a loop"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Divide the given list head into 2 linked lists, greater & smaller. Then connect these 2 lists and return the result. One more hint:\nThe whole process shown by modifying submitted code in playground\n```\n1<3:smaller\nsmaller:0->1->4->3->2->5->2\ngreater:0\n-------\n4>=3: greater\nsmaller:0->1->4->3->2->5->2\ngreater:0->4->3->2->5->2\n-------\n3>=3: greater\nsmaller:0->1->4->3->2->5->2\ngreater:0->4->3->2->5->2\n-------\n2<3:smaller\nsmaller:0->1->2->5->2\ngreater:0->4->3->2->5->2\n-------\n5>=3: greater\nsmaller:0->1->2->5->2\ngreater:0->4->3->5->2\n-------\n2<3:smaller\nsmaller:0->1->2->2\ngreater:0->4->3->5->2\n-------\nans:\n1->2->2->4->3->5\n```"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@omeirr13](/omeirr13) Since my program uses the constructors, it needs extra O(1) space, that is an extra dummy node.  With such extra dummy node makes programming easier. If you won't use extra space, it needs some modification which may lead to an error."
                    },
                    {
                        "username": "omeirr13",
                        "content": "wont this use extra space"
                    },
                    {
                        "username": "anuron_das",
                        "content": "It is an interesting problem, at least to me. If I were to explain the problem statement to anyone in the simplest terms, I would go like this:\n\nYou are given a linked list and a target number `x`.  You have to reorder the list in such a way that any node with a value `strictly less than x` appears `in the beginning` of the list, such that their relative order `among themselves` is preserved.\n\nFor example: `[1,4,3,2,5,2]` and `x=3`. All the numbers `strictly smaller than x` are `[1,2,2]`. So preserve only their relative order and add them in the beginning of the list.\n\nAfter that you have to preserve the relative order of all the `remaining elements` as well, and after that you can return the list `head`.\n\nFor example, let us consider the above example only, in `[1,4,3,2,5,2]` and `x=3`, after removing all the numbers `strictly less than x`, the remaining list is `[4,3,5]`. So their relative order is preserved accordingly.\n\nIn the end just concatenate the two and return the result.\n\nSo if the problem statement is clear, then one can appreciate the importance of `two pointers` approach, as this problem involves the use of `two pointers` on linked lists. I hope the reader finds this helpful. "
                    },
                    {
                        "username": "valige7091",
                        "content": "All the problem asks one to do is loop through a list and add each element to one of two lists, before combining the two then returning."
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@sameer89](/sameer89) well, as i understood valige, he meant to say take 2 separate lists of all nodes < x and nodes >= x, and then in the end join the tail of one to head of another which will take O(n). "
                    },
                    {
                        "username": "sameer89",
                        "content": "[@2uringTested](/2uringTested) No it wont.  Since these are linked lists it can be done in O(1) space like \"merge\" in mergesort."
                    },
                    {
                        "username": "2uringTested",
                        "content": "that will use extra space, thats not the best solution, you can do the partition in the same list and in one pass."
                    },
                    {
                        "username": "woodyinho",
                        "content": "Input: head = 1->4->3->2->5->2, x = 3\\nOutput: 1->2->2->4->3->5\\n\\nwhy 4 is exist before than 3 not after ?\\n"
                    },
                    {
                        "username": "pahwagautam786",
                        "content": "Because we also have to maintane  the relative order of elements and we have to compare with greater or eqaul to \\'x\\' "
                    },
                    {
                        "username": "sairam852",
                        "content": "because problem description was all nodes less than x come before nodes greater than or equal to x i.e., we no need to move the greater values to after of that targeted value"
                    },
                    {
                        "username": "Abhishen99",
                        "content": "\\n[328. Odd Even Linked List ](https://leetcode.com/problems/odd-even-linked-list/)\\n\\nabove problem is quite similiar to this problem after trying this you can solve that too.\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I wanted to comment the same thing, that one is a nice follow up, requiring O(1) space and O(n) time"
                    },
                    {
                        "username": "Ausho_Roup",
                        "content": "Anyone please explain this question. I am unable to get it. I am trying to understand nearly from two days still not able to figure it out ."
                    },
                    {
                        "username": "nikhilnyalakanti2003",
                        "content": "checkout the discussion section again, ig you\\'ll have it cleared this time"
                    }
                ]
            },
            {
                "id": 1570499,
                "content": [
                    {
                        "username": "zdf826504558",
                        "content": "The description for this problem is somewhat very misleading. \\nI took at least 15 min and tested serval test cases so that I understood what it was asking for.\\n\\nLet me briefly explain it to relieve your pain.\\n\\nBasically, it asks us:\\n`reorder the sequence by the given number x`\\n\\nThe rules are:\\n1. Any number that is `less than x` has to be before `x`, and maintain the relative order with thoese that are less than `x` but already before `x`.\\ne.g. `[3,4,1,2], target = 4` -> `[3,1,2,4]`, so the order of `[3,1,2]` is maintained.\\n2. Any number that is `greater than x` but already before `x` will still be before `x`, but all of them come after those that are less than `x` and at the same time maintain their relative order.\\ne.g. `[3,6,5,4,1,2] target = 4` -> `[3,1,2,6,5,4]`\\n3. Any number that is `greater than x` and after `x` will only need to maintain their relative order\\ne.g. `[3,6,5,4,8,1,7,2] target = 4` -> `[3,1,2,6,5,4,8,7]`\\n\\nHope this helps those who have a difficulty time understanding **\"all nodes less than x come before nodes greater than or equal to x.\"** like me.  \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\n"
                    },
                    {
                        "username": "kishore_001",
                        "content": "[@The_Laughing_Storm](/The_Laughing_Storm)  i understand the question now"
                    },
                    {
                        "username": "ahad7792",
                        "content": "Maximum leetcode  question\\'s description is very unclear"
                    },
                    {
                        "username": "pavan9100",
                        "content": "Haha!...They explained about the place and you explained about the directions"
                    },
                    {
                        "username": "dporwal985",
                        "content": "I was confused for a second and got into the discussion section about that particular line. Seeing your detailed discussion helped. Thanks man!"
                    },
                    {
                        "username": "DeadlyTRex",
                        "content": "[@diksm0ker](/diksm0ker) if relative order was important then in first test case \\nInput: head = [1,4,3,2,5,2], x = 3\\nOutput: [1,2,2,4,3,5]\\nwhy the output is not 1,4,2,2,3,5. the relative order got changed for 2 and 4 in the description\\'s output"
                    },
                    {
                        "username": "The_Laughing_Storm",
                        "content": "[@normanlmfung](/normanlmfung) Relative order means that the orignal order given. So in [3,4,1,2] the order is 3->4->1->2 so after target is 4 the order should be 3->1->2->4 because in the orignal order 3 was before 1 and 1 was before 2. Relative order means wrt to the question. These are linked lists here not arrays so order here is wierd"
                    },
                    {
                        "username": "normanlmfung",
                        "content": "It's still unclear [3,4,1,2], target = 4 -> [3,1,2,4] \n\nWhy not \n     [1,2,3,4]? <-- 1 appear before 2 so \"relative order\" still maintained\nor even \n    [1,3,2,4] <-- same here, 1 apear before 2 and \"relative order\" still maintained.\n\nAnother example,\n    [3,6,5,4,1,2] target = 4 -> [3,1,2,6,5,4]\n\n    Why not \n        [1,2,3,6,5,4]           <-- \"preserve the original relative order of the nodes in each of the two partitions\" does not explains why 1,2 should appear after 3\n        [3,6,5,1,2,4]           <-- \"all nodes less than x come before nodes greater than or equal to x\" explains why 1,2 should appear BEFORE 6,5 so this is fine\n\nQuestion poorly written. So I think developers are expected to try different test cases to understand pick up things that's not specified in problem statement."
                    },
                    {
                        "username": "comanea",
                        "content": "You understood that statement correctly. The description adds right below `You should preserve the original relative order of the nodes in each of the two partitions.`. If that wasn\\'t there when you wrote the comment, then that\\'s on the problem maker, but it looks correct now. Fortunately it\\'s an easy fix anyway."
                    },
                    {
                        "username": "Jaiff",
                        "content": "Happy Independence Day Indian bros. \\nWe live young, \\nWe live free!!!"
                    },
                    {
                        "username": "vinnnu",
                        "content": "Jai Hind!!! Onwards and Upwards"
                    },
                    {
                        "username": "ckvb18",
                        "content": "YES GLORY TO INDIA !!!"
                    },
                    {
                        "username": "codewithnavneet",
                        "content": "Happy independence day brother JAY HIND"
                    },
                    {
                        "username": "aarush_badkur30",
                        "content": "same to u bro Jai Hind "
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "jai hind"
                    },
                    {
                        "username": "kandalachetan",
                        "content": "same to you bro"
                    },
                    {
                        "username": "KingShuK17",
                        "content": "JAI HIND! upwards and onwards, always!"
                    },
                    {
                        "username": "homer_simpson",
                        "content": "\"For example,\\n\\nGiven 1->4->3->2->5->2 and x = 3,\\n\\nreturn 1->2->2->4->3->5.\"\\n\\nIn the return, why does 4 come before 3 if it's larger???\\n\\n\\nAlso, my code fails this test:\\n\"Input:\\t{2,1}, 1\\n\\nOutput:\\t{1,2}\\n\\nExpected:\\t{2,1}\"\\n\\nIf x is 1, why would the expected output have 2 come before 1?\\n\\nThanks."
                    },
                    {
                        "username": "rahulkasula23",
                        "content": "bro I done this question 8 years after your submission"
                    },
                    {
                        "username": "powerup7",
                        "content": "[@Anand_On_Leet](/Anand_On_Leet) No, no sorting of the list is required. That\\'s how you keep relative order."
                    },
                    {
                        "username": "powerup7",
                        "content": "[@Anand_On_Leet](/Anand_On_Leet) No. No sorting of the list is required. That\\'s how you keep relative order."
                    },
                    {
                        "username": "brb715",
                        "content": "In the first eg, since 4 is greater than or equal to 3(i.e x), all the nodes that are less than 3 will come before 4 and the order of the nodes should be same."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes thankfully they covered that case in the examples, right?\n\n4 comes before 3 because relative order must be preserved.\n\n3 doesn't require being moved because it is >= x.\n\nhope that wasn't too much of a spoiler."
                    },
                    {
                        "username": "Anand_On_Leet",
                        "content": "Then , we should only sort that list."
                    },
                    {
                        "username": "1ort",
                        "content": "tip: Don\\'t forget to clear the Next of the last element of the list if you are spreading elements across two lists. I tried for half an hour to figure out why my solution fails with an error until I realized that I was returning a list with a loop"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Divide the given list head into 2 linked lists, greater & smaller. Then connect these 2 lists and return the result. One more hint:\nThe whole process shown by modifying submitted code in playground\n```\n1<3:smaller\nsmaller:0->1->4->3->2->5->2\ngreater:0\n-------\n4>=3: greater\nsmaller:0->1->4->3->2->5->2\ngreater:0->4->3->2->5->2\n-------\n3>=3: greater\nsmaller:0->1->4->3->2->5->2\ngreater:0->4->3->2->5->2\n-------\n2<3:smaller\nsmaller:0->1->2->5->2\ngreater:0->4->3->2->5->2\n-------\n5>=3: greater\nsmaller:0->1->2->5->2\ngreater:0->4->3->5->2\n-------\n2<3:smaller\nsmaller:0->1->2->2\ngreater:0->4->3->5->2\n-------\nans:\n1->2->2->4->3->5\n```"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@omeirr13](/omeirr13) Since my program uses the constructors, it needs extra O(1) space, that is an extra dummy node.  With such extra dummy node makes programming easier. If you won't use extra space, it needs some modification which may lead to an error."
                    },
                    {
                        "username": "omeirr13",
                        "content": "wont this use extra space"
                    },
                    {
                        "username": "anuron_das",
                        "content": "It is an interesting problem, at least to me. If I were to explain the problem statement to anyone in the simplest terms, I would go like this:\n\nYou are given a linked list and a target number `x`.  You have to reorder the list in such a way that any node with a value `strictly less than x` appears `in the beginning` of the list, such that their relative order `among themselves` is preserved.\n\nFor example: `[1,4,3,2,5,2]` and `x=3`. All the numbers `strictly smaller than x` are `[1,2,2]`. So preserve only their relative order and add them in the beginning of the list.\n\nAfter that you have to preserve the relative order of all the `remaining elements` as well, and after that you can return the list `head`.\n\nFor example, let us consider the above example only, in `[1,4,3,2,5,2]` and `x=3`, after removing all the numbers `strictly less than x`, the remaining list is `[4,3,5]`. So their relative order is preserved accordingly.\n\nIn the end just concatenate the two and return the result.\n\nSo if the problem statement is clear, then one can appreciate the importance of `two pointers` approach, as this problem involves the use of `two pointers` on linked lists. I hope the reader finds this helpful. "
                    },
                    {
                        "username": "valige7091",
                        "content": "All the problem asks one to do is loop through a list and add each element to one of two lists, before combining the two then returning."
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@sameer89](/sameer89) well, as i understood valige, he meant to say take 2 separate lists of all nodes < x and nodes >= x, and then in the end join the tail of one to head of another which will take O(n). "
                    },
                    {
                        "username": "sameer89",
                        "content": "[@2uringTested](/2uringTested) No it wont.  Since these are linked lists it can be done in O(1) space like \"merge\" in mergesort."
                    },
                    {
                        "username": "2uringTested",
                        "content": "that will use extra space, thats not the best solution, you can do the partition in the same list and in one pass."
                    },
                    {
                        "username": "woodyinho",
                        "content": "Input: head = 1->4->3->2->5->2, x = 3\\nOutput: 1->2->2->4->3->5\\n\\nwhy 4 is exist before than 3 not after ?\\n"
                    },
                    {
                        "username": "pahwagautam786",
                        "content": "Because we also have to maintane  the relative order of elements and we have to compare with greater or eqaul to \\'x\\' "
                    },
                    {
                        "username": "sairam852",
                        "content": "because problem description was all nodes less than x come before nodes greater than or equal to x i.e., we no need to move the greater values to after of that targeted value"
                    },
                    {
                        "username": "Abhishen99",
                        "content": "\\n[328. Odd Even Linked List ](https://leetcode.com/problems/odd-even-linked-list/)\\n\\nabove problem is quite similiar to this problem after trying this you can solve that too.\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I wanted to comment the same thing, that one is a nice follow up, requiring O(1) space and O(n) time"
                    },
                    {
                        "username": "Ausho_Roup",
                        "content": "Anyone please explain this question. I am unable to get it. I am trying to understand nearly from two days still not able to figure it out ."
                    },
                    {
                        "username": "nikhilnyalakanti2003",
                        "content": "checkout the discussion section again, ig you\\'ll have it cleared this time"
                    }
                ]
            },
            {
                "id": 1574465,
                "content": [
                    {
                        "username": "zdf826504558",
                        "content": "The description for this problem is somewhat very misleading. \\nI took at least 15 min and tested serval test cases so that I understood what it was asking for.\\n\\nLet me briefly explain it to relieve your pain.\\n\\nBasically, it asks us:\\n`reorder the sequence by the given number x`\\n\\nThe rules are:\\n1. Any number that is `less than x` has to be before `x`, and maintain the relative order with thoese that are less than `x` but already before `x`.\\ne.g. `[3,4,1,2], target = 4` -> `[3,1,2,4]`, so the order of `[3,1,2]` is maintained.\\n2. Any number that is `greater than x` but already before `x` will still be before `x`, but all of them come after those that are less than `x` and at the same time maintain their relative order.\\ne.g. `[3,6,5,4,1,2] target = 4` -> `[3,1,2,6,5,4]`\\n3. Any number that is `greater than x` and after `x` will only need to maintain their relative order\\ne.g. `[3,6,5,4,8,1,7,2] target = 4` -> `[3,1,2,6,5,4,8,7]`\\n\\nHope this helps those who have a difficulty time understanding **\"all nodes less than x come before nodes greater than or equal to x.\"** like me.  \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\n"
                    },
                    {
                        "username": "kishore_001",
                        "content": "[@The_Laughing_Storm](/The_Laughing_Storm)  i understand the question now"
                    },
                    {
                        "username": "ahad7792",
                        "content": "Maximum leetcode  question\\'s description is very unclear"
                    },
                    {
                        "username": "pavan9100",
                        "content": "Haha!...They explained about the place and you explained about the directions"
                    },
                    {
                        "username": "dporwal985",
                        "content": "I was confused for a second and got into the discussion section about that particular line. Seeing your detailed discussion helped. Thanks man!"
                    },
                    {
                        "username": "DeadlyTRex",
                        "content": "[@diksm0ker](/diksm0ker) if relative order was important then in first test case \\nInput: head = [1,4,3,2,5,2], x = 3\\nOutput: [1,2,2,4,3,5]\\nwhy the output is not 1,4,2,2,3,5. the relative order got changed for 2 and 4 in the description\\'s output"
                    },
                    {
                        "username": "The_Laughing_Storm",
                        "content": "[@normanlmfung](/normanlmfung) Relative order means that the orignal order given. So in [3,4,1,2] the order is 3->4->1->2 so after target is 4 the order should be 3->1->2->4 because in the orignal order 3 was before 1 and 1 was before 2. Relative order means wrt to the question. These are linked lists here not arrays so order here is wierd"
                    },
                    {
                        "username": "normanlmfung",
                        "content": "It's still unclear [3,4,1,2], target = 4 -> [3,1,2,4] \n\nWhy not \n     [1,2,3,4]? <-- 1 appear before 2 so \"relative order\" still maintained\nor even \n    [1,3,2,4] <-- same here, 1 apear before 2 and \"relative order\" still maintained.\n\nAnother example,\n    [3,6,5,4,1,2] target = 4 -> [3,1,2,6,5,4]\n\n    Why not \n        [1,2,3,6,5,4]           <-- \"preserve the original relative order of the nodes in each of the two partitions\" does not explains why 1,2 should appear after 3\n        [3,6,5,1,2,4]           <-- \"all nodes less than x come before nodes greater than or equal to x\" explains why 1,2 should appear BEFORE 6,5 so this is fine\n\nQuestion poorly written. So I think developers are expected to try different test cases to understand pick up things that's not specified in problem statement."
                    },
                    {
                        "username": "comanea",
                        "content": "You understood that statement correctly. The description adds right below `You should preserve the original relative order of the nodes in each of the two partitions.`. If that wasn\\'t there when you wrote the comment, then that\\'s on the problem maker, but it looks correct now. Fortunately it\\'s an easy fix anyway."
                    },
                    {
                        "username": "Jaiff",
                        "content": "Happy Independence Day Indian bros. \\nWe live young, \\nWe live free!!!"
                    },
                    {
                        "username": "vinnnu",
                        "content": "Jai Hind!!! Onwards and Upwards"
                    },
                    {
                        "username": "ckvb18",
                        "content": "YES GLORY TO INDIA !!!"
                    },
                    {
                        "username": "codewithnavneet",
                        "content": "Happy independence day brother JAY HIND"
                    },
                    {
                        "username": "aarush_badkur30",
                        "content": "same to u bro Jai Hind "
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "jai hind"
                    },
                    {
                        "username": "kandalachetan",
                        "content": "same to you bro"
                    },
                    {
                        "username": "KingShuK17",
                        "content": "JAI HIND! upwards and onwards, always!"
                    },
                    {
                        "username": "homer_simpson",
                        "content": "\"For example,\\n\\nGiven 1->4->3->2->5->2 and x = 3,\\n\\nreturn 1->2->2->4->3->5.\"\\n\\nIn the return, why does 4 come before 3 if it's larger???\\n\\n\\nAlso, my code fails this test:\\n\"Input:\\t{2,1}, 1\\n\\nOutput:\\t{1,2}\\n\\nExpected:\\t{2,1}\"\\n\\nIf x is 1, why would the expected output have 2 come before 1?\\n\\nThanks."
                    },
                    {
                        "username": "rahulkasula23",
                        "content": "bro I done this question 8 years after your submission"
                    },
                    {
                        "username": "powerup7",
                        "content": "[@Anand_On_Leet](/Anand_On_Leet) No, no sorting of the list is required. That\\'s how you keep relative order."
                    },
                    {
                        "username": "powerup7",
                        "content": "[@Anand_On_Leet](/Anand_On_Leet) No. No sorting of the list is required. That\\'s how you keep relative order."
                    },
                    {
                        "username": "brb715",
                        "content": "In the first eg, since 4 is greater than or equal to 3(i.e x), all the nodes that are less than 3 will come before 4 and the order of the nodes should be same."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes thankfully they covered that case in the examples, right?\n\n4 comes before 3 because relative order must be preserved.\n\n3 doesn't require being moved because it is >= x.\n\nhope that wasn't too much of a spoiler."
                    },
                    {
                        "username": "Anand_On_Leet",
                        "content": "Then , we should only sort that list."
                    },
                    {
                        "username": "1ort",
                        "content": "tip: Don\\'t forget to clear the Next of the last element of the list if you are spreading elements across two lists. I tried for half an hour to figure out why my solution fails with an error until I realized that I was returning a list with a loop"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Divide the given list head into 2 linked lists, greater & smaller. Then connect these 2 lists and return the result. One more hint:\nThe whole process shown by modifying submitted code in playground\n```\n1<3:smaller\nsmaller:0->1->4->3->2->5->2\ngreater:0\n-------\n4>=3: greater\nsmaller:0->1->4->3->2->5->2\ngreater:0->4->3->2->5->2\n-------\n3>=3: greater\nsmaller:0->1->4->3->2->5->2\ngreater:0->4->3->2->5->2\n-------\n2<3:smaller\nsmaller:0->1->2->5->2\ngreater:0->4->3->2->5->2\n-------\n5>=3: greater\nsmaller:0->1->2->5->2\ngreater:0->4->3->5->2\n-------\n2<3:smaller\nsmaller:0->1->2->2\ngreater:0->4->3->5->2\n-------\nans:\n1->2->2->4->3->5\n```"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@omeirr13](/omeirr13) Since my program uses the constructors, it needs extra O(1) space, that is an extra dummy node.  With such extra dummy node makes programming easier. If you won't use extra space, it needs some modification which may lead to an error."
                    },
                    {
                        "username": "omeirr13",
                        "content": "wont this use extra space"
                    },
                    {
                        "username": "anuron_das",
                        "content": "It is an interesting problem, at least to me. If I were to explain the problem statement to anyone in the simplest terms, I would go like this:\n\nYou are given a linked list and a target number `x`.  You have to reorder the list in such a way that any node with a value `strictly less than x` appears `in the beginning` of the list, such that their relative order `among themselves` is preserved.\n\nFor example: `[1,4,3,2,5,2]` and `x=3`. All the numbers `strictly smaller than x` are `[1,2,2]`. So preserve only their relative order and add them in the beginning of the list.\n\nAfter that you have to preserve the relative order of all the `remaining elements` as well, and after that you can return the list `head`.\n\nFor example, let us consider the above example only, in `[1,4,3,2,5,2]` and `x=3`, after removing all the numbers `strictly less than x`, the remaining list is `[4,3,5]`. So their relative order is preserved accordingly.\n\nIn the end just concatenate the two and return the result.\n\nSo if the problem statement is clear, then one can appreciate the importance of `two pointers` approach, as this problem involves the use of `two pointers` on linked lists. I hope the reader finds this helpful. "
                    },
                    {
                        "username": "valige7091",
                        "content": "All the problem asks one to do is loop through a list and add each element to one of two lists, before combining the two then returning."
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@sameer89](/sameer89) well, as i understood valige, he meant to say take 2 separate lists of all nodes < x and nodes >= x, and then in the end join the tail of one to head of another which will take O(n). "
                    },
                    {
                        "username": "sameer89",
                        "content": "[@2uringTested](/2uringTested) No it wont.  Since these are linked lists it can be done in O(1) space like \"merge\" in mergesort."
                    },
                    {
                        "username": "2uringTested",
                        "content": "that will use extra space, thats not the best solution, you can do the partition in the same list and in one pass."
                    },
                    {
                        "username": "woodyinho",
                        "content": "Input: head = 1->4->3->2->5->2, x = 3\\nOutput: 1->2->2->4->3->5\\n\\nwhy 4 is exist before than 3 not after ?\\n"
                    },
                    {
                        "username": "pahwagautam786",
                        "content": "Because we also have to maintane  the relative order of elements and we have to compare with greater or eqaul to \\'x\\' "
                    },
                    {
                        "username": "sairam852",
                        "content": "because problem description was all nodes less than x come before nodes greater than or equal to x i.e., we no need to move the greater values to after of that targeted value"
                    },
                    {
                        "username": "Abhishen99",
                        "content": "\\n[328. Odd Even Linked List ](https://leetcode.com/problems/odd-even-linked-list/)\\n\\nabove problem is quite similiar to this problem after trying this you can solve that too.\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I wanted to comment the same thing, that one is a nice follow up, requiring O(1) space and O(n) time"
                    },
                    {
                        "username": "Ausho_Roup",
                        "content": "Anyone please explain this question. I am unable to get it. I am trying to understand nearly from two days still not able to figure it out ."
                    },
                    {
                        "username": "nikhilnyalakanti2003",
                        "content": "checkout the discussion section again, ig you\\'ll have it cleared this time"
                    }
                ]
            },
            {
                "id": 2014946,
                "content": [
                    {
                        "username": "StefanelStan",
                        "content": "A very interesting and cute problem. Simply use 4 pointers that hold the reference to 2 new linked list segments: lessThanX and greaterOrEqualThanX.\\nTraverse the whole list and append each node to one of these two. At the end, carefully link the tail of the first segment to the head of the 2nd segment."
                    },
                    {
                        "username": "sorcererwdj",
                        "content": "Input: {2,1}, 1  \\nOutput: {1,2}  \\nExpected: {2,1} \\n\\nWhy?"
                    },
                    {
                        "username": "greedycat",
                        "content": "![image](https://assets.leetcode.com/users/images/95a69de4-8e62-470c-b232-98de668b0481_1630418462.159717.png)\\n"
                    },
                    {
                        "username": "aryan1113",
                        "content": "This is just a way of taking in the input in python3"
                    },
                    {
                        "username": "SG-C",
                        "content": "no leetcode no partition today "
                    },
                    {
                        "username": "sam_cee",
                        "content": "Can anyone help me to understand why this is wrong please?\\nhead =\\n[1,4,3,0,2,5,2]\\nx =\\n3\\nOutput\\n[0,1,2,2,4,3,5]\\nExpected\\n[1,0,2,2,4,3,5]"
                    },
                    {
                        "username": "sam_cee",
                        "content": "[@Gauravkr007](/Gauravkr007) because 4 is greater than k(3). Any number less than k should stay where it is relative to other numbers less than k but be moved to the left of 'k' (and any number greater than 'k'.\neg, k = 4\n[*2,*3,5,7,4,*0,*1]\nnumbers < k ( *) must be on the left of 4 so result would be\n[*2,*3,*0,*1,5,7,4]\nnumbers < k ( *) now on the left of 'k' in their same relative positions."
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "[@sameer89](/sameer89) ok then 4 also came before 0 and 2 why 4 is shifted but 1 is not ?"
                    },
                    {
                        "username": "sam_cee",
                        "content": "[@sameer89](/sameer89) thanks for your reply,  it helped me to figure it out in the end!"
                    },
                    {
                        "username": "sameer89",
                        "content": "The question mentions that you need to preserve the relative order. Since 1 comes before 0, it has to come before zero in the answer too! And both of them should come before 3."
                    },
                    {
                        "username": "namanchandak",
                        "content": "for test case\\n[1,4,3,2,5,2]\\nx =\\n3  \\nbelow answer should also be valid.?\\n[2,2,1,4,3,5]"
                    },
                    {
                        "username": "Simon_Noble",
                        "content": "The original order of the list should be the same, just split into a section that is less than x (in the order they originally appeared), then the elements greater than or equal to x (in the original order they appeared)."
                    },
                    {
                        "username": "oops_moment",
                        "content": "If handling the swapping with a double pointer feels tricky, here\\'s a hint: consider using two linked lists. In one list, gather elements less than x, and in the other, store elements greater than x. Then, simply connect these two lists together. Happy coding!"
                    },
                    {
                        "username": "exquiro",
                        "content": "For the test case - [3,6,5,2,4,8,1,7], target = 4\\nExpected answer is  - [3,2,1,6,5,4,8,7]\\n\\nWhy 2\\'s position is changed, if it is less than target and is in left of it?"
                    },
                    {
                        "username": "breathermachine",
                        "content": "A: Numbers less than 4 (in input order) = [3, 2, 1]\\nB: Numbers greater than or equal to 4 (in input order) = [6, 5, 4, 8, 7]\\nA + B = [3, 2, 1, 6, 5, 4, 8, 7]"
                    },
                    {
                        "username": "uchihaXmadara",
                        "content": "It should be easy?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "For those who want tip or unable to understand the question\\nCreate a list with minimum number than X\\nCreate the list with remaining numbers\\nmerger both and return the head."
                    }
                ]
            },
            {
                "id": 1568906,
                "content": [
                    {
                        "username": "StefanelStan",
                        "content": "A very interesting and cute problem. Simply use 4 pointers that hold the reference to 2 new linked list segments: lessThanX and greaterOrEqualThanX.\\nTraverse the whole list and append each node to one of these two. At the end, carefully link the tail of the first segment to the head of the 2nd segment."
                    },
                    {
                        "username": "sorcererwdj",
                        "content": "Input: {2,1}, 1  \\nOutput: {1,2}  \\nExpected: {2,1} \\n\\nWhy?"
                    },
                    {
                        "username": "greedycat",
                        "content": "![image](https://assets.leetcode.com/users/images/95a69de4-8e62-470c-b232-98de668b0481_1630418462.159717.png)\\n"
                    },
                    {
                        "username": "aryan1113",
                        "content": "This is just a way of taking in the input in python3"
                    },
                    {
                        "username": "SG-C",
                        "content": "no leetcode no partition today "
                    },
                    {
                        "username": "sam_cee",
                        "content": "Can anyone help me to understand why this is wrong please?\\nhead =\\n[1,4,3,0,2,5,2]\\nx =\\n3\\nOutput\\n[0,1,2,2,4,3,5]\\nExpected\\n[1,0,2,2,4,3,5]"
                    },
                    {
                        "username": "sam_cee",
                        "content": "[@Gauravkr007](/Gauravkr007) because 4 is greater than k(3). Any number less than k should stay where it is relative to other numbers less than k but be moved to the left of 'k' (and any number greater than 'k'.\neg, k = 4\n[*2,*3,5,7,4,*0,*1]\nnumbers < k ( *) must be on the left of 4 so result would be\n[*2,*3,*0,*1,5,7,4]\nnumbers < k ( *) now on the left of 'k' in their same relative positions."
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "[@sameer89](/sameer89) ok then 4 also came before 0 and 2 why 4 is shifted but 1 is not ?"
                    },
                    {
                        "username": "sam_cee",
                        "content": "[@sameer89](/sameer89) thanks for your reply,  it helped me to figure it out in the end!"
                    },
                    {
                        "username": "sameer89",
                        "content": "The question mentions that you need to preserve the relative order. Since 1 comes before 0, it has to come before zero in the answer too! And both of them should come before 3."
                    },
                    {
                        "username": "namanchandak",
                        "content": "for test case\\n[1,4,3,2,5,2]\\nx =\\n3  \\nbelow answer should also be valid.?\\n[2,2,1,4,3,5]"
                    },
                    {
                        "username": "Simon_Noble",
                        "content": "The original order of the list should be the same, just split into a section that is less than x (in the order they originally appeared), then the elements greater than or equal to x (in the original order they appeared)."
                    },
                    {
                        "username": "oops_moment",
                        "content": "If handling the swapping with a double pointer feels tricky, here\\'s a hint: consider using two linked lists. In one list, gather elements less than x, and in the other, store elements greater than x. Then, simply connect these two lists together. Happy coding!"
                    },
                    {
                        "username": "exquiro",
                        "content": "For the test case - [3,6,5,2,4,8,1,7], target = 4\\nExpected answer is  - [3,2,1,6,5,4,8,7]\\n\\nWhy 2\\'s position is changed, if it is less than target and is in left of it?"
                    },
                    {
                        "username": "breathermachine",
                        "content": "A: Numbers less than 4 (in input order) = [3, 2, 1]\\nB: Numbers greater than or equal to 4 (in input order) = [6, 5, 4, 8, 7]\\nA + B = [3, 2, 1, 6, 5, 4, 8, 7]"
                    },
                    {
                        "username": "uchihaXmadara",
                        "content": "It should be easy?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "For those who want tip or unable to understand the question\\nCreate a list with minimum number than X\\nCreate the list with remaining numbers\\nmerger both and return the head."
                    }
                ]
            },
            {
                "id": 1567653,
                "content": [
                    {
                        "username": "StefanelStan",
                        "content": "A very interesting and cute problem. Simply use 4 pointers that hold the reference to 2 new linked list segments: lessThanX and greaterOrEqualThanX.\\nTraverse the whole list and append each node to one of these two. At the end, carefully link the tail of the first segment to the head of the 2nd segment."
                    },
                    {
                        "username": "sorcererwdj",
                        "content": "Input: {2,1}, 1  \\nOutput: {1,2}  \\nExpected: {2,1} \\n\\nWhy?"
                    },
                    {
                        "username": "greedycat",
                        "content": "![image](https://assets.leetcode.com/users/images/95a69de4-8e62-470c-b232-98de668b0481_1630418462.159717.png)\\n"
                    },
                    {
                        "username": "aryan1113",
                        "content": "This is just a way of taking in the input in python3"
                    },
                    {
                        "username": "SG-C",
                        "content": "no leetcode no partition today "
                    },
                    {
                        "username": "sam_cee",
                        "content": "Can anyone help me to understand why this is wrong please?\\nhead =\\n[1,4,3,0,2,5,2]\\nx =\\n3\\nOutput\\n[0,1,2,2,4,3,5]\\nExpected\\n[1,0,2,2,4,3,5]"
                    },
                    {
                        "username": "sam_cee",
                        "content": "[@Gauravkr007](/Gauravkr007) because 4 is greater than k(3). Any number less than k should stay where it is relative to other numbers less than k but be moved to the left of 'k' (and any number greater than 'k'.\neg, k = 4\n[*2,*3,5,7,4,*0,*1]\nnumbers < k ( *) must be on the left of 4 so result would be\n[*2,*3,*0,*1,5,7,4]\nnumbers < k ( *) now on the left of 'k' in their same relative positions."
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "[@sameer89](/sameer89) ok then 4 also came before 0 and 2 why 4 is shifted but 1 is not ?"
                    },
                    {
                        "username": "sam_cee",
                        "content": "[@sameer89](/sameer89) thanks for your reply,  it helped me to figure it out in the end!"
                    },
                    {
                        "username": "sameer89",
                        "content": "The question mentions that you need to preserve the relative order. Since 1 comes before 0, it has to come before zero in the answer too! And both of them should come before 3."
                    },
                    {
                        "username": "namanchandak",
                        "content": "for test case\\n[1,4,3,2,5,2]\\nx =\\n3  \\nbelow answer should also be valid.?\\n[2,2,1,4,3,5]"
                    },
                    {
                        "username": "Simon_Noble",
                        "content": "The original order of the list should be the same, just split into a section that is less than x (in the order they originally appeared), then the elements greater than or equal to x (in the original order they appeared)."
                    },
                    {
                        "username": "oops_moment",
                        "content": "If handling the swapping with a double pointer feels tricky, here\\'s a hint: consider using two linked lists. In one list, gather elements less than x, and in the other, store elements greater than x. Then, simply connect these two lists together. Happy coding!"
                    },
                    {
                        "username": "exquiro",
                        "content": "For the test case - [3,6,5,2,4,8,1,7], target = 4\\nExpected answer is  - [3,2,1,6,5,4,8,7]\\n\\nWhy 2\\'s position is changed, if it is less than target and is in left of it?"
                    },
                    {
                        "username": "breathermachine",
                        "content": "A: Numbers less than 4 (in input order) = [3, 2, 1]\\nB: Numbers greater than or equal to 4 (in input order) = [6, 5, 4, 8, 7]\\nA + B = [3, 2, 1, 6, 5, 4, 8, 7]"
                    },
                    {
                        "username": "uchihaXmadara",
                        "content": "It should be easy?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "For those who want tip or unable to understand the question\\nCreate a list with minimum number than X\\nCreate the list with remaining numbers\\nmerger both and return the head."
                    }
                ]
            },
            {
                "id": 2015494,
                "content": [
                    {
                        "username": "StefanelStan",
                        "content": "A very interesting and cute problem. Simply use 4 pointers that hold the reference to 2 new linked list segments: lessThanX and greaterOrEqualThanX.\\nTraverse the whole list and append each node to one of these two. At the end, carefully link the tail of the first segment to the head of the 2nd segment."
                    },
                    {
                        "username": "sorcererwdj",
                        "content": "Input: {2,1}, 1  \\nOutput: {1,2}  \\nExpected: {2,1} \\n\\nWhy?"
                    },
                    {
                        "username": "greedycat",
                        "content": "![image](https://assets.leetcode.com/users/images/95a69de4-8e62-470c-b232-98de668b0481_1630418462.159717.png)\\n"
                    },
                    {
                        "username": "aryan1113",
                        "content": "This is just a way of taking in the input in python3"
                    },
                    {
                        "username": "SG-C",
                        "content": "no leetcode no partition today "
                    },
                    {
                        "username": "sam_cee",
                        "content": "Can anyone help me to understand why this is wrong please?\\nhead =\\n[1,4,3,0,2,5,2]\\nx =\\n3\\nOutput\\n[0,1,2,2,4,3,5]\\nExpected\\n[1,0,2,2,4,3,5]"
                    },
                    {
                        "username": "sam_cee",
                        "content": "[@Gauravkr007](/Gauravkr007) because 4 is greater than k(3). Any number less than k should stay where it is relative to other numbers less than k but be moved to the left of 'k' (and any number greater than 'k'.\neg, k = 4\n[*2,*3,5,7,4,*0,*1]\nnumbers < k ( *) must be on the left of 4 so result would be\n[*2,*3,*0,*1,5,7,4]\nnumbers < k ( *) now on the left of 'k' in their same relative positions."
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "[@sameer89](/sameer89) ok then 4 also came before 0 and 2 why 4 is shifted but 1 is not ?"
                    },
                    {
                        "username": "sam_cee",
                        "content": "[@sameer89](/sameer89) thanks for your reply,  it helped me to figure it out in the end!"
                    },
                    {
                        "username": "sameer89",
                        "content": "The question mentions that you need to preserve the relative order. Since 1 comes before 0, it has to come before zero in the answer too! And both of them should come before 3."
                    },
                    {
                        "username": "namanchandak",
                        "content": "for test case\\n[1,4,3,2,5,2]\\nx =\\n3  \\nbelow answer should also be valid.?\\n[2,2,1,4,3,5]"
                    },
                    {
                        "username": "Simon_Noble",
                        "content": "The original order of the list should be the same, just split into a section that is less than x (in the order they originally appeared), then the elements greater than or equal to x (in the original order they appeared)."
                    },
                    {
                        "username": "oops_moment",
                        "content": "If handling the swapping with a double pointer feels tricky, here\\'s a hint: consider using two linked lists. In one list, gather elements less than x, and in the other, store elements greater than x. Then, simply connect these two lists together. Happy coding!"
                    },
                    {
                        "username": "exquiro",
                        "content": "For the test case - [3,6,5,2,4,8,1,7], target = 4\\nExpected answer is  - [3,2,1,6,5,4,8,7]\\n\\nWhy 2\\'s position is changed, if it is less than target and is in left of it?"
                    },
                    {
                        "username": "breathermachine",
                        "content": "A: Numbers less than 4 (in input order) = [3, 2, 1]\\nB: Numbers greater than or equal to 4 (in input order) = [6, 5, 4, 8, 7]\\nA + B = [3, 2, 1, 6, 5, 4, 8, 7]"
                    },
                    {
                        "username": "uchihaXmadara",
                        "content": "It should be easy?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "For those who want tip or unable to understand the question\\nCreate a list with minimum number than X\\nCreate the list with remaining numbers\\nmerger both and return the head."
                    }
                ]
            },
            {
                "id": 1987373,
                "content": [
                    {
                        "username": "StefanelStan",
                        "content": "A very interesting and cute problem. Simply use 4 pointers that hold the reference to 2 new linked list segments: lessThanX and greaterOrEqualThanX.\\nTraverse the whole list and append each node to one of these two. At the end, carefully link the tail of the first segment to the head of the 2nd segment."
                    },
                    {
                        "username": "sorcererwdj",
                        "content": "Input: {2,1}, 1  \\nOutput: {1,2}  \\nExpected: {2,1} \\n\\nWhy?"
                    },
                    {
                        "username": "greedycat",
                        "content": "![image](https://assets.leetcode.com/users/images/95a69de4-8e62-470c-b232-98de668b0481_1630418462.159717.png)\\n"
                    },
                    {
                        "username": "aryan1113",
                        "content": "This is just a way of taking in the input in python3"
                    },
                    {
                        "username": "SG-C",
                        "content": "no leetcode no partition today "
                    },
                    {
                        "username": "sam_cee",
                        "content": "Can anyone help me to understand why this is wrong please?\\nhead =\\n[1,4,3,0,2,5,2]\\nx =\\n3\\nOutput\\n[0,1,2,2,4,3,5]\\nExpected\\n[1,0,2,2,4,3,5]"
                    },
                    {
                        "username": "sam_cee",
                        "content": "[@Gauravkr007](/Gauravkr007) because 4 is greater than k(3). Any number less than k should stay where it is relative to other numbers less than k but be moved to the left of 'k' (and any number greater than 'k'.\neg, k = 4\n[*2,*3,5,7,4,*0,*1]\nnumbers < k ( *) must be on the left of 4 so result would be\n[*2,*3,*0,*1,5,7,4]\nnumbers < k ( *) now on the left of 'k' in their same relative positions."
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "[@sameer89](/sameer89) ok then 4 also came before 0 and 2 why 4 is shifted but 1 is not ?"
                    },
                    {
                        "username": "sam_cee",
                        "content": "[@sameer89](/sameer89) thanks for your reply,  it helped me to figure it out in the end!"
                    },
                    {
                        "username": "sameer89",
                        "content": "The question mentions that you need to preserve the relative order. Since 1 comes before 0, it has to come before zero in the answer too! And both of them should come before 3."
                    },
                    {
                        "username": "namanchandak",
                        "content": "for test case\\n[1,4,3,2,5,2]\\nx =\\n3  \\nbelow answer should also be valid.?\\n[2,2,1,4,3,5]"
                    },
                    {
                        "username": "Simon_Noble",
                        "content": "The original order of the list should be the same, just split into a section that is less than x (in the order they originally appeared), then the elements greater than or equal to x (in the original order they appeared)."
                    },
                    {
                        "username": "oops_moment",
                        "content": "If handling the swapping with a double pointer feels tricky, here\\'s a hint: consider using two linked lists. In one list, gather elements less than x, and in the other, store elements greater than x. Then, simply connect these two lists together. Happy coding!"
                    },
                    {
                        "username": "exquiro",
                        "content": "For the test case - [3,6,5,2,4,8,1,7], target = 4\\nExpected answer is  - [3,2,1,6,5,4,8,7]\\n\\nWhy 2\\'s position is changed, if it is less than target and is in left of it?"
                    },
                    {
                        "username": "breathermachine",
                        "content": "A: Numbers less than 4 (in input order) = [3, 2, 1]\\nB: Numbers greater than or equal to 4 (in input order) = [6, 5, 4, 8, 7]\\nA + B = [3, 2, 1, 6, 5, 4, 8, 7]"
                    },
                    {
                        "username": "uchihaXmadara",
                        "content": "It should be easy?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "For those who want tip or unable to understand the question\\nCreate a list with minimum number than X\\nCreate the list with remaining numbers\\nmerger both and return the head."
                    }
                ]
            },
            {
                "id": 2015652,
                "content": [
                    {
                        "username": "StefanelStan",
                        "content": "A very interesting and cute problem. Simply use 4 pointers that hold the reference to 2 new linked list segments: lessThanX and greaterOrEqualThanX.\\nTraverse the whole list and append each node to one of these two. At the end, carefully link the tail of the first segment to the head of the 2nd segment."
                    },
                    {
                        "username": "sorcererwdj",
                        "content": "Input: {2,1}, 1  \\nOutput: {1,2}  \\nExpected: {2,1} \\n\\nWhy?"
                    },
                    {
                        "username": "greedycat",
                        "content": "![image](https://assets.leetcode.com/users/images/95a69de4-8e62-470c-b232-98de668b0481_1630418462.159717.png)\\n"
                    },
                    {
                        "username": "aryan1113",
                        "content": "This is just a way of taking in the input in python3"
                    },
                    {
                        "username": "SG-C",
                        "content": "no leetcode no partition today "
                    },
                    {
                        "username": "sam_cee",
                        "content": "Can anyone help me to understand why this is wrong please?\\nhead =\\n[1,4,3,0,2,5,2]\\nx =\\n3\\nOutput\\n[0,1,2,2,4,3,5]\\nExpected\\n[1,0,2,2,4,3,5]"
                    },
                    {
                        "username": "sam_cee",
                        "content": "[@Gauravkr007](/Gauravkr007) because 4 is greater than k(3). Any number less than k should stay where it is relative to other numbers less than k but be moved to the left of 'k' (and any number greater than 'k'.\neg, k = 4\n[*2,*3,5,7,4,*0,*1]\nnumbers < k ( *) must be on the left of 4 so result would be\n[*2,*3,*0,*1,5,7,4]\nnumbers < k ( *) now on the left of 'k' in their same relative positions."
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "[@sameer89](/sameer89) ok then 4 also came before 0 and 2 why 4 is shifted but 1 is not ?"
                    },
                    {
                        "username": "sam_cee",
                        "content": "[@sameer89](/sameer89) thanks for your reply,  it helped me to figure it out in the end!"
                    },
                    {
                        "username": "sameer89",
                        "content": "The question mentions that you need to preserve the relative order. Since 1 comes before 0, it has to come before zero in the answer too! And both of them should come before 3."
                    },
                    {
                        "username": "namanchandak",
                        "content": "for test case\\n[1,4,3,2,5,2]\\nx =\\n3  \\nbelow answer should also be valid.?\\n[2,2,1,4,3,5]"
                    },
                    {
                        "username": "Simon_Noble",
                        "content": "The original order of the list should be the same, just split into a section that is less than x (in the order they originally appeared), then the elements greater than or equal to x (in the original order they appeared)."
                    },
                    {
                        "username": "oops_moment",
                        "content": "If handling the swapping with a double pointer feels tricky, here\\'s a hint: consider using two linked lists. In one list, gather elements less than x, and in the other, store elements greater than x. Then, simply connect these two lists together. Happy coding!"
                    },
                    {
                        "username": "exquiro",
                        "content": "For the test case - [3,6,5,2,4,8,1,7], target = 4\\nExpected answer is  - [3,2,1,6,5,4,8,7]\\n\\nWhy 2\\'s position is changed, if it is less than target and is in left of it?"
                    },
                    {
                        "username": "breathermachine",
                        "content": "A: Numbers less than 4 (in input order) = [3, 2, 1]\\nB: Numbers greater than or equal to 4 (in input order) = [6, 5, 4, 8, 7]\\nA + B = [3, 2, 1, 6, 5, 4, 8, 7]"
                    },
                    {
                        "username": "uchihaXmadara",
                        "content": "It should be easy?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "For those who want tip or unable to understand the question\\nCreate a list with minimum number than X\\nCreate the list with remaining numbers\\nmerger both and return the head."
                    }
                ]
            },
            {
                "id": 2015429,
                "content": [
                    {
                        "username": "StefanelStan",
                        "content": "A very interesting and cute problem. Simply use 4 pointers that hold the reference to 2 new linked list segments: lessThanX and greaterOrEqualThanX.\\nTraverse the whole list and append each node to one of these two. At the end, carefully link the tail of the first segment to the head of the 2nd segment."
                    },
                    {
                        "username": "sorcererwdj",
                        "content": "Input: {2,1}, 1  \\nOutput: {1,2}  \\nExpected: {2,1} \\n\\nWhy?"
                    },
                    {
                        "username": "greedycat",
                        "content": "![image](https://assets.leetcode.com/users/images/95a69de4-8e62-470c-b232-98de668b0481_1630418462.159717.png)\\n"
                    },
                    {
                        "username": "aryan1113",
                        "content": "This is just a way of taking in the input in python3"
                    },
                    {
                        "username": "SG-C",
                        "content": "no leetcode no partition today "
                    },
                    {
                        "username": "sam_cee",
                        "content": "Can anyone help me to understand why this is wrong please?\\nhead =\\n[1,4,3,0,2,5,2]\\nx =\\n3\\nOutput\\n[0,1,2,2,4,3,5]\\nExpected\\n[1,0,2,2,4,3,5]"
                    },
                    {
                        "username": "sam_cee",
                        "content": "[@Gauravkr007](/Gauravkr007) because 4 is greater than k(3). Any number less than k should stay where it is relative to other numbers less than k but be moved to the left of 'k' (and any number greater than 'k'.\neg, k = 4\n[*2,*3,5,7,4,*0,*1]\nnumbers < k ( *) must be on the left of 4 so result would be\n[*2,*3,*0,*1,5,7,4]\nnumbers < k ( *) now on the left of 'k' in their same relative positions."
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "[@sameer89](/sameer89) ok then 4 also came before 0 and 2 why 4 is shifted but 1 is not ?"
                    },
                    {
                        "username": "sam_cee",
                        "content": "[@sameer89](/sameer89) thanks for your reply,  it helped me to figure it out in the end!"
                    },
                    {
                        "username": "sameer89",
                        "content": "The question mentions that you need to preserve the relative order. Since 1 comes before 0, it has to come before zero in the answer too! And both of them should come before 3."
                    },
                    {
                        "username": "namanchandak",
                        "content": "for test case\\n[1,4,3,2,5,2]\\nx =\\n3  \\nbelow answer should also be valid.?\\n[2,2,1,4,3,5]"
                    },
                    {
                        "username": "Simon_Noble",
                        "content": "The original order of the list should be the same, just split into a section that is less than x (in the order they originally appeared), then the elements greater than or equal to x (in the original order they appeared)."
                    },
                    {
                        "username": "oops_moment",
                        "content": "If handling the swapping with a double pointer feels tricky, here\\'s a hint: consider using two linked lists. In one list, gather elements less than x, and in the other, store elements greater than x. Then, simply connect these two lists together. Happy coding!"
                    },
                    {
                        "username": "exquiro",
                        "content": "For the test case - [3,6,5,2,4,8,1,7], target = 4\\nExpected answer is  - [3,2,1,6,5,4,8,7]\\n\\nWhy 2\\'s position is changed, if it is less than target and is in left of it?"
                    },
                    {
                        "username": "breathermachine",
                        "content": "A: Numbers less than 4 (in input order) = [3, 2, 1]\\nB: Numbers greater than or equal to 4 (in input order) = [6, 5, 4, 8, 7]\\nA + B = [3, 2, 1, 6, 5, 4, 8, 7]"
                    },
                    {
                        "username": "uchihaXmadara",
                        "content": "It should be easy?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "For those who want tip or unable to understand the question\\nCreate a list with minimum number than X\\nCreate the list with remaining numbers\\nmerger both and return the head."
                    }
                ]
            },
            {
                "id": 2015323,
                "content": [
                    {
                        "username": "StefanelStan",
                        "content": "A very interesting and cute problem. Simply use 4 pointers that hold the reference to 2 new linked list segments: lessThanX and greaterOrEqualThanX.\\nTraverse the whole list and append each node to one of these two. At the end, carefully link the tail of the first segment to the head of the 2nd segment."
                    },
                    {
                        "username": "sorcererwdj",
                        "content": "Input: {2,1}, 1  \\nOutput: {1,2}  \\nExpected: {2,1} \\n\\nWhy?"
                    },
                    {
                        "username": "greedycat",
                        "content": "![image](https://assets.leetcode.com/users/images/95a69de4-8e62-470c-b232-98de668b0481_1630418462.159717.png)\\n"
                    },
                    {
                        "username": "aryan1113",
                        "content": "This is just a way of taking in the input in python3"
                    },
                    {
                        "username": "SG-C",
                        "content": "no leetcode no partition today "
                    },
                    {
                        "username": "sam_cee",
                        "content": "Can anyone help me to understand why this is wrong please?\\nhead =\\n[1,4,3,0,2,5,2]\\nx =\\n3\\nOutput\\n[0,1,2,2,4,3,5]\\nExpected\\n[1,0,2,2,4,3,5]"
                    },
                    {
                        "username": "sam_cee",
                        "content": "[@Gauravkr007](/Gauravkr007) because 4 is greater than k(3). Any number less than k should stay where it is relative to other numbers less than k but be moved to the left of 'k' (and any number greater than 'k'.\neg, k = 4\n[*2,*3,5,7,4,*0,*1]\nnumbers < k ( *) must be on the left of 4 so result would be\n[*2,*3,*0,*1,5,7,4]\nnumbers < k ( *) now on the left of 'k' in their same relative positions."
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "[@sameer89](/sameer89) ok then 4 also came before 0 and 2 why 4 is shifted but 1 is not ?"
                    },
                    {
                        "username": "sam_cee",
                        "content": "[@sameer89](/sameer89) thanks for your reply,  it helped me to figure it out in the end!"
                    },
                    {
                        "username": "sameer89",
                        "content": "The question mentions that you need to preserve the relative order. Since 1 comes before 0, it has to come before zero in the answer too! And both of them should come before 3."
                    },
                    {
                        "username": "namanchandak",
                        "content": "for test case\\n[1,4,3,2,5,2]\\nx =\\n3  \\nbelow answer should also be valid.?\\n[2,2,1,4,3,5]"
                    },
                    {
                        "username": "Simon_Noble",
                        "content": "The original order of the list should be the same, just split into a section that is less than x (in the order they originally appeared), then the elements greater than or equal to x (in the original order they appeared)."
                    },
                    {
                        "username": "oops_moment",
                        "content": "If handling the swapping with a double pointer feels tricky, here\\'s a hint: consider using two linked lists. In one list, gather elements less than x, and in the other, store elements greater than x. Then, simply connect these two lists together. Happy coding!"
                    },
                    {
                        "username": "exquiro",
                        "content": "For the test case - [3,6,5,2,4,8,1,7], target = 4\\nExpected answer is  - [3,2,1,6,5,4,8,7]\\n\\nWhy 2\\'s position is changed, if it is less than target and is in left of it?"
                    },
                    {
                        "username": "breathermachine",
                        "content": "A: Numbers less than 4 (in input order) = [3, 2, 1]\\nB: Numbers greater than or equal to 4 (in input order) = [6, 5, 4, 8, 7]\\nA + B = [3, 2, 1, 6, 5, 4, 8, 7]"
                    },
                    {
                        "username": "uchihaXmadara",
                        "content": "It should be easy?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "For those who want tip or unable to understand the question\\nCreate a list with minimum number than X\\nCreate the list with remaining numbers\\nmerger both and return the head."
                    }
                ]
            },
            {
                "id": 2015255,
                "content": [
                    {
                        "username": "StefanelStan",
                        "content": "A very interesting and cute problem. Simply use 4 pointers that hold the reference to 2 new linked list segments: lessThanX and greaterOrEqualThanX.\\nTraverse the whole list and append each node to one of these two. At the end, carefully link the tail of the first segment to the head of the 2nd segment."
                    },
                    {
                        "username": "sorcererwdj",
                        "content": "Input: {2,1}, 1  \\nOutput: {1,2}  \\nExpected: {2,1} \\n\\nWhy?"
                    },
                    {
                        "username": "greedycat",
                        "content": "![image](https://assets.leetcode.com/users/images/95a69de4-8e62-470c-b232-98de668b0481_1630418462.159717.png)\\n"
                    },
                    {
                        "username": "aryan1113",
                        "content": "This is just a way of taking in the input in python3"
                    },
                    {
                        "username": "SG-C",
                        "content": "no leetcode no partition today "
                    },
                    {
                        "username": "sam_cee",
                        "content": "Can anyone help me to understand why this is wrong please?\\nhead =\\n[1,4,3,0,2,5,2]\\nx =\\n3\\nOutput\\n[0,1,2,2,4,3,5]\\nExpected\\n[1,0,2,2,4,3,5]"
                    },
                    {
                        "username": "sam_cee",
                        "content": "[@Gauravkr007](/Gauravkr007) because 4 is greater than k(3). Any number less than k should stay where it is relative to other numbers less than k but be moved to the left of 'k' (and any number greater than 'k'.\neg, k = 4\n[*2,*3,5,7,4,*0,*1]\nnumbers < k ( *) must be on the left of 4 so result would be\n[*2,*3,*0,*1,5,7,4]\nnumbers < k ( *) now on the left of 'k' in their same relative positions."
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "[@sameer89](/sameer89) ok then 4 also came before 0 and 2 why 4 is shifted but 1 is not ?"
                    },
                    {
                        "username": "sam_cee",
                        "content": "[@sameer89](/sameer89) thanks for your reply,  it helped me to figure it out in the end!"
                    },
                    {
                        "username": "sameer89",
                        "content": "The question mentions that you need to preserve the relative order. Since 1 comes before 0, it has to come before zero in the answer too! And both of them should come before 3."
                    },
                    {
                        "username": "namanchandak",
                        "content": "for test case\\n[1,4,3,2,5,2]\\nx =\\n3  \\nbelow answer should also be valid.?\\n[2,2,1,4,3,5]"
                    },
                    {
                        "username": "Simon_Noble",
                        "content": "The original order of the list should be the same, just split into a section that is less than x (in the order they originally appeared), then the elements greater than or equal to x (in the original order they appeared)."
                    },
                    {
                        "username": "oops_moment",
                        "content": "If handling the swapping with a double pointer feels tricky, here\\'s a hint: consider using two linked lists. In one list, gather elements less than x, and in the other, store elements greater than x. Then, simply connect these two lists together. Happy coding!"
                    },
                    {
                        "username": "exquiro",
                        "content": "For the test case - [3,6,5,2,4,8,1,7], target = 4\\nExpected answer is  - [3,2,1,6,5,4,8,7]\\n\\nWhy 2\\'s position is changed, if it is less than target and is in left of it?"
                    },
                    {
                        "username": "breathermachine",
                        "content": "A: Numbers less than 4 (in input order) = [3, 2, 1]\\nB: Numbers greater than or equal to 4 (in input order) = [6, 5, 4, 8, 7]\\nA + B = [3, 2, 1, 6, 5, 4, 8, 7]"
                    },
                    {
                        "username": "uchihaXmadara",
                        "content": "It should be easy?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "For those who want tip or unable to understand the question\\nCreate a list with minimum number than X\\nCreate the list with remaining numbers\\nmerger both and return the head."
                    }
                ]
            },
            {
                "id": 2015245,
                "content": [
                    {
                        "username": "StefanelStan",
                        "content": "A very interesting and cute problem. Simply use 4 pointers that hold the reference to 2 new linked list segments: lessThanX and greaterOrEqualThanX.\\nTraverse the whole list and append each node to one of these two. At the end, carefully link the tail of the first segment to the head of the 2nd segment."
                    },
                    {
                        "username": "sorcererwdj",
                        "content": "Input: {2,1}, 1  \\nOutput: {1,2}  \\nExpected: {2,1} \\n\\nWhy?"
                    },
                    {
                        "username": "greedycat",
                        "content": "![image](https://assets.leetcode.com/users/images/95a69de4-8e62-470c-b232-98de668b0481_1630418462.159717.png)\\n"
                    },
                    {
                        "username": "aryan1113",
                        "content": "This is just a way of taking in the input in python3"
                    },
                    {
                        "username": "SG-C",
                        "content": "no leetcode no partition today "
                    },
                    {
                        "username": "sam_cee",
                        "content": "Can anyone help me to understand why this is wrong please?\\nhead =\\n[1,4,3,0,2,5,2]\\nx =\\n3\\nOutput\\n[0,1,2,2,4,3,5]\\nExpected\\n[1,0,2,2,4,3,5]"
                    },
                    {
                        "username": "sam_cee",
                        "content": "[@Gauravkr007](/Gauravkr007) because 4 is greater than k(3). Any number less than k should stay where it is relative to other numbers less than k but be moved to the left of 'k' (and any number greater than 'k'.\neg, k = 4\n[*2,*3,5,7,4,*0,*1]\nnumbers < k ( *) must be on the left of 4 so result would be\n[*2,*3,*0,*1,5,7,4]\nnumbers < k ( *) now on the left of 'k' in their same relative positions."
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "[@sameer89](/sameer89) ok then 4 also came before 0 and 2 why 4 is shifted but 1 is not ?"
                    },
                    {
                        "username": "sam_cee",
                        "content": "[@sameer89](/sameer89) thanks for your reply,  it helped me to figure it out in the end!"
                    },
                    {
                        "username": "sameer89",
                        "content": "The question mentions that you need to preserve the relative order. Since 1 comes before 0, it has to come before zero in the answer too! And both of them should come before 3."
                    },
                    {
                        "username": "namanchandak",
                        "content": "for test case\\n[1,4,3,2,5,2]\\nx =\\n3  \\nbelow answer should also be valid.?\\n[2,2,1,4,3,5]"
                    },
                    {
                        "username": "Simon_Noble",
                        "content": "The original order of the list should be the same, just split into a section that is less than x (in the order they originally appeared), then the elements greater than or equal to x (in the original order they appeared)."
                    },
                    {
                        "username": "oops_moment",
                        "content": "If handling the swapping with a double pointer feels tricky, here\\'s a hint: consider using two linked lists. In one list, gather elements less than x, and in the other, store elements greater than x. Then, simply connect these two lists together. Happy coding!"
                    },
                    {
                        "username": "exquiro",
                        "content": "For the test case - [3,6,5,2,4,8,1,7], target = 4\\nExpected answer is  - [3,2,1,6,5,4,8,7]\\n\\nWhy 2\\'s position is changed, if it is less than target and is in left of it?"
                    },
                    {
                        "username": "breathermachine",
                        "content": "A: Numbers less than 4 (in input order) = [3, 2, 1]\\nB: Numbers greater than or equal to 4 (in input order) = [6, 5, 4, 8, 7]\\nA + B = [3, 2, 1, 6, 5, 4, 8, 7]"
                    },
                    {
                        "username": "uchihaXmadara",
                        "content": "It should be easy?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "For those who want tip or unable to understand the question\\nCreate a list with minimum number than X\\nCreate the list with remaining numbers\\nmerger both and return the head."
                    }
                ]
            },
            {
                "id": 2015005,
                "content": [
                    {
                        "username": "alokranjanjha10",
                        "content": "Happy Independence Day "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Lower Medium Class question, not that tough. We can do it guys. \\uD83D\\uDE42"
                    },
                    {
                        "username": "aitachii",
                        "content": "Here\\'s some edge cases you might consider before submitting your solution.\\n\\n- list is empty\\n[]\\n0\\n\\n- x is not in the linked list: \\n[1]\\n0\\n[1]\\n2\\n[1,1]\\n2\\n[1,1]\\n0\\n"
                    },
                    {
                        "username": "rahul_rasve_712",
                        "content": "Input -> [2,2,3,1,5,0]\nExpected -> [2,2,1,0,3,5]\nPivot is takes as '3'\nwhy is it not [0,1,2,2,3,5]?\n\nCan someone please explain how should the elements be placed in the left part of the list? Should they be in sorted order or any random order works?"
                    },
                    {
                        "username": "EricRaw",
                        "content": "`You should preserve the original relative order of the nodes in each of the two partitions.`\n\nsince the 2 come first before 1 and 0 in the input, you have to put 2 at the front"
                    },
                    {
                        "username": "booleanbit1",
                        "content": "I was able to submit after the 9th submission, the description is misleading, and so many test cases need to be considered,\\ntry below ones to test your code -\\n1. [2,1]   x=2\\n2. [3,6,5,4,8,1,7,2,4,5,6,7,2,1,2,3,4,5,77,88,3,3,3,4,4,4], x=4\\n3.  [] , x=0\\n4. [3,1], x=2\\n5. [2,4,1,1,2,3,4,2,2] , x=3\\n6. [2,0,4,1,3,1,4,0,3], x=4\\n\\nAlso try changing values of x, there could be test cases where x is not even in the list, so take care of that as well.\\n\\nThe idea behind the solution is - keep tracking the list before you get your number x, and make sure to put all the numbers strictly less than x before the numbers greater than x, and then continue the same for the list after finding x in the list.\\n"
                    },
                    {
                        "username": "Suhasumesh",
                        "content": "Tip :\\nCreate 2 dummy listnodes and two pointers pointing to them and use one listnode to store values less than x and other listnode to store value greater than x and join them and return dummy1\\'s listnode.\\nPlease do upvote if you like it. Thank you!"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "This is not a tip, this is literally the solution"
                    },
                    {
                        "username": "tuhinssam",
                        "content": "This is pretty straightforward:\\n1. create list1 with values lower than x while maintaining the order\\n2. create list2 with values grater or equals to x while maintaining the order\\n3. join list1 and list2\\n4. return list1 head"
                    },
                    {
                        "username": "skydodle",
                        "content": "The key here is to recognize there are two groups. One group (nodes with value less than x) should be in the front of the result list, and the other group (nodes with value >= x) should be in the latter part of result list. Therefore we can break it down to left group and right group.\\n\\nThe rest is easy. As we traverse the list, we check each node to see if it belong to left group or right group, and update left or right group along the way. In the end, connect left to right and we have a result list."
                    },
                    {
                        "username": "omeirr13",
                        "content": "but this uses extra space right?"
                    },
                    {
                        "username": "user5630Yg",
                        "content": "Are we allowed to change the val of the node? Or we need to move the node."
                    },
                    {
                        "username": "swapnils_leetcode",
                        "content": "It takes 2hr to solve this problem but at end it is a part of problem solving  \n\nhint for this problem:\ncreate a two different such that\n\nlst  = [1,4,3,2,5,2]\nx = 3\n\nsList = [1,2,2]  // small list contains smaller element in list than x .\nlList = [4,3,5]  // large list contains bigger or equal elemet to x.\n\nand done !\n\nmerge and return result."
                    },
                    {
                        "username": "raviprajapatikandari",
                        "content": "[@omeirr13](/omeirr13)  ok i will try to solve without extra space\\n"
                    },
                    {
                        "username": "omeirr13",
                        "content": "try to do without extra space"
                    }
                ]
            },
            {
                "id": 2014797,
                "content": [
                    {
                        "username": "alokranjanjha10",
                        "content": "Happy Independence Day "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Lower Medium Class question, not that tough. We can do it guys. \\uD83D\\uDE42"
                    },
                    {
                        "username": "aitachii",
                        "content": "Here\\'s some edge cases you might consider before submitting your solution.\\n\\n- list is empty\\n[]\\n0\\n\\n- x is not in the linked list: \\n[1]\\n0\\n[1]\\n2\\n[1,1]\\n2\\n[1,1]\\n0\\n"
                    },
                    {
                        "username": "rahul_rasve_712",
                        "content": "Input -> [2,2,3,1,5,0]\nExpected -> [2,2,1,0,3,5]\nPivot is takes as '3'\nwhy is it not [0,1,2,2,3,5]?\n\nCan someone please explain how should the elements be placed in the left part of the list? Should they be in sorted order or any random order works?"
                    },
                    {
                        "username": "EricRaw",
                        "content": "`You should preserve the original relative order of the nodes in each of the two partitions.`\n\nsince the 2 come first before 1 and 0 in the input, you have to put 2 at the front"
                    },
                    {
                        "username": "booleanbit1",
                        "content": "I was able to submit after the 9th submission, the description is misleading, and so many test cases need to be considered,\\ntry below ones to test your code -\\n1. [2,1]   x=2\\n2. [3,6,5,4,8,1,7,2,4,5,6,7,2,1,2,3,4,5,77,88,3,3,3,4,4,4], x=4\\n3.  [] , x=0\\n4. [3,1], x=2\\n5. [2,4,1,1,2,3,4,2,2] , x=3\\n6. [2,0,4,1,3,1,4,0,3], x=4\\n\\nAlso try changing values of x, there could be test cases where x is not even in the list, so take care of that as well.\\n\\nThe idea behind the solution is - keep tracking the list before you get your number x, and make sure to put all the numbers strictly less than x before the numbers greater than x, and then continue the same for the list after finding x in the list.\\n"
                    },
                    {
                        "username": "Suhasumesh",
                        "content": "Tip :\\nCreate 2 dummy listnodes and two pointers pointing to them and use one listnode to store values less than x and other listnode to store value greater than x and join them and return dummy1\\'s listnode.\\nPlease do upvote if you like it. Thank you!"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "This is not a tip, this is literally the solution"
                    },
                    {
                        "username": "tuhinssam",
                        "content": "This is pretty straightforward:\\n1. create list1 with values lower than x while maintaining the order\\n2. create list2 with values grater or equals to x while maintaining the order\\n3. join list1 and list2\\n4. return list1 head"
                    },
                    {
                        "username": "skydodle",
                        "content": "The key here is to recognize there are two groups. One group (nodes with value less than x) should be in the front of the result list, and the other group (nodes with value >= x) should be in the latter part of result list. Therefore we can break it down to left group and right group.\\n\\nThe rest is easy. As we traverse the list, we check each node to see if it belong to left group or right group, and update left or right group along the way. In the end, connect left to right and we have a result list."
                    },
                    {
                        "username": "omeirr13",
                        "content": "but this uses extra space right?"
                    },
                    {
                        "username": "user5630Yg",
                        "content": "Are we allowed to change the val of the node? Or we need to move the node."
                    },
                    {
                        "username": "swapnils_leetcode",
                        "content": "It takes 2hr to solve this problem but at end it is a part of problem solving  \n\nhint for this problem:\ncreate a two different such that\n\nlst  = [1,4,3,2,5,2]\nx = 3\n\nsList = [1,2,2]  // small list contains smaller element in list than x .\nlList = [4,3,5]  // large list contains bigger or equal elemet to x.\n\nand done !\n\nmerge and return result."
                    },
                    {
                        "username": "raviprajapatikandari",
                        "content": "[@omeirr13](/omeirr13)  ok i will try to solve without extra space\\n"
                    },
                    {
                        "username": "omeirr13",
                        "content": "try to do without extra space"
                    }
                ]
            },
            {
                "id": 2014753,
                "content": [
                    {
                        "username": "alokranjanjha10",
                        "content": "Happy Independence Day "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Lower Medium Class question, not that tough. We can do it guys. \\uD83D\\uDE42"
                    },
                    {
                        "username": "aitachii",
                        "content": "Here\\'s some edge cases you might consider before submitting your solution.\\n\\n- list is empty\\n[]\\n0\\n\\n- x is not in the linked list: \\n[1]\\n0\\n[1]\\n2\\n[1,1]\\n2\\n[1,1]\\n0\\n"
                    },
                    {
                        "username": "rahul_rasve_712",
                        "content": "Input -> [2,2,3,1,5,0]\nExpected -> [2,2,1,0,3,5]\nPivot is takes as '3'\nwhy is it not [0,1,2,2,3,5]?\n\nCan someone please explain how should the elements be placed in the left part of the list? Should they be in sorted order or any random order works?"
                    },
                    {
                        "username": "EricRaw",
                        "content": "`You should preserve the original relative order of the nodes in each of the two partitions.`\n\nsince the 2 come first before 1 and 0 in the input, you have to put 2 at the front"
                    },
                    {
                        "username": "booleanbit1",
                        "content": "I was able to submit after the 9th submission, the description is misleading, and so many test cases need to be considered,\\ntry below ones to test your code -\\n1. [2,1]   x=2\\n2. [3,6,5,4,8,1,7,2,4,5,6,7,2,1,2,3,4,5,77,88,3,3,3,4,4,4], x=4\\n3.  [] , x=0\\n4. [3,1], x=2\\n5. [2,4,1,1,2,3,4,2,2] , x=3\\n6. [2,0,4,1,3,1,4,0,3], x=4\\n\\nAlso try changing values of x, there could be test cases where x is not even in the list, so take care of that as well.\\n\\nThe idea behind the solution is - keep tracking the list before you get your number x, and make sure to put all the numbers strictly less than x before the numbers greater than x, and then continue the same for the list after finding x in the list.\\n"
                    },
                    {
                        "username": "Suhasumesh",
                        "content": "Tip :\\nCreate 2 dummy listnodes and two pointers pointing to them and use one listnode to store values less than x and other listnode to store value greater than x and join them and return dummy1\\'s listnode.\\nPlease do upvote if you like it. Thank you!"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "This is not a tip, this is literally the solution"
                    },
                    {
                        "username": "tuhinssam",
                        "content": "This is pretty straightforward:\\n1. create list1 with values lower than x while maintaining the order\\n2. create list2 with values grater or equals to x while maintaining the order\\n3. join list1 and list2\\n4. return list1 head"
                    },
                    {
                        "username": "skydodle",
                        "content": "The key here is to recognize there are two groups. One group (nodes with value less than x) should be in the front of the result list, and the other group (nodes with value >= x) should be in the latter part of result list. Therefore we can break it down to left group and right group.\\n\\nThe rest is easy. As we traverse the list, we check each node to see if it belong to left group or right group, and update left or right group along the way. In the end, connect left to right and we have a result list."
                    },
                    {
                        "username": "omeirr13",
                        "content": "but this uses extra space right?"
                    },
                    {
                        "username": "user5630Yg",
                        "content": "Are we allowed to change the val of the node? Or we need to move the node."
                    },
                    {
                        "username": "swapnils_leetcode",
                        "content": "It takes 2hr to solve this problem but at end it is a part of problem solving  \n\nhint for this problem:\ncreate a two different such that\n\nlst  = [1,4,3,2,5,2]\nx = 3\n\nsList = [1,2,2]  // small list contains smaller element in list than x .\nlList = [4,3,5]  // large list contains bigger or equal elemet to x.\n\nand done !\n\nmerge and return result."
                    },
                    {
                        "username": "raviprajapatikandari",
                        "content": "[@omeirr13](/omeirr13)  ok i will try to solve without extra space\\n"
                    },
                    {
                        "username": "omeirr13",
                        "content": "try to do without extra space"
                    }
                ]
            },
            {
                "id": 2014711,
                "content": [
                    {
                        "username": "alokranjanjha10",
                        "content": "Happy Independence Day "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Lower Medium Class question, not that tough. We can do it guys. \\uD83D\\uDE42"
                    },
                    {
                        "username": "aitachii",
                        "content": "Here\\'s some edge cases you might consider before submitting your solution.\\n\\n- list is empty\\n[]\\n0\\n\\n- x is not in the linked list: \\n[1]\\n0\\n[1]\\n2\\n[1,1]\\n2\\n[1,1]\\n0\\n"
                    },
                    {
                        "username": "rahul_rasve_712",
                        "content": "Input -> [2,2,3,1,5,0]\nExpected -> [2,2,1,0,3,5]\nPivot is takes as '3'\nwhy is it not [0,1,2,2,3,5]?\n\nCan someone please explain how should the elements be placed in the left part of the list? Should they be in sorted order or any random order works?"
                    },
                    {
                        "username": "EricRaw",
                        "content": "`You should preserve the original relative order of the nodes in each of the two partitions.`\n\nsince the 2 come first before 1 and 0 in the input, you have to put 2 at the front"
                    },
                    {
                        "username": "booleanbit1",
                        "content": "I was able to submit after the 9th submission, the description is misleading, and so many test cases need to be considered,\\ntry below ones to test your code -\\n1. [2,1]   x=2\\n2. [3,6,5,4,8,1,7,2,4,5,6,7,2,1,2,3,4,5,77,88,3,3,3,4,4,4], x=4\\n3.  [] , x=0\\n4. [3,1], x=2\\n5. [2,4,1,1,2,3,4,2,2] , x=3\\n6. [2,0,4,1,3,1,4,0,3], x=4\\n\\nAlso try changing values of x, there could be test cases where x is not even in the list, so take care of that as well.\\n\\nThe idea behind the solution is - keep tracking the list before you get your number x, and make sure to put all the numbers strictly less than x before the numbers greater than x, and then continue the same for the list after finding x in the list.\\n"
                    },
                    {
                        "username": "Suhasumesh",
                        "content": "Tip :\\nCreate 2 dummy listnodes and two pointers pointing to them and use one listnode to store values less than x and other listnode to store value greater than x and join them and return dummy1\\'s listnode.\\nPlease do upvote if you like it. Thank you!"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "This is not a tip, this is literally the solution"
                    },
                    {
                        "username": "tuhinssam",
                        "content": "This is pretty straightforward:\\n1. create list1 with values lower than x while maintaining the order\\n2. create list2 with values grater or equals to x while maintaining the order\\n3. join list1 and list2\\n4. return list1 head"
                    },
                    {
                        "username": "skydodle",
                        "content": "The key here is to recognize there are two groups. One group (nodes with value less than x) should be in the front of the result list, and the other group (nodes with value >= x) should be in the latter part of result list. Therefore we can break it down to left group and right group.\\n\\nThe rest is easy. As we traverse the list, we check each node to see if it belong to left group or right group, and update left or right group along the way. In the end, connect left to right and we have a result list."
                    },
                    {
                        "username": "omeirr13",
                        "content": "but this uses extra space right?"
                    },
                    {
                        "username": "user5630Yg",
                        "content": "Are we allowed to change the val of the node? Or we need to move the node."
                    },
                    {
                        "username": "swapnils_leetcode",
                        "content": "It takes 2hr to solve this problem but at end it is a part of problem solving  \n\nhint for this problem:\ncreate a two different such that\n\nlst  = [1,4,3,2,5,2]\nx = 3\n\nsList = [1,2,2]  // small list contains smaller element in list than x .\nlList = [4,3,5]  // large list contains bigger or equal elemet to x.\n\nand done !\n\nmerge and return result."
                    },
                    {
                        "username": "raviprajapatikandari",
                        "content": "[@omeirr13](/omeirr13)  ok i will try to solve without extra space\\n"
                    },
                    {
                        "username": "omeirr13",
                        "content": "try to do without extra space"
                    }
                ]
            },
            {
                "id": 2014615,
                "content": [
                    {
                        "username": "alokranjanjha10",
                        "content": "Happy Independence Day "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Lower Medium Class question, not that tough. We can do it guys. \\uD83D\\uDE42"
                    },
                    {
                        "username": "aitachii",
                        "content": "Here\\'s some edge cases you might consider before submitting your solution.\\n\\n- list is empty\\n[]\\n0\\n\\n- x is not in the linked list: \\n[1]\\n0\\n[1]\\n2\\n[1,1]\\n2\\n[1,1]\\n0\\n"
                    },
                    {
                        "username": "rahul_rasve_712",
                        "content": "Input -> [2,2,3,1,5,0]\nExpected -> [2,2,1,0,3,5]\nPivot is takes as '3'\nwhy is it not [0,1,2,2,3,5]?\n\nCan someone please explain how should the elements be placed in the left part of the list? Should they be in sorted order or any random order works?"
                    },
                    {
                        "username": "EricRaw",
                        "content": "`You should preserve the original relative order of the nodes in each of the two partitions.`\n\nsince the 2 come first before 1 and 0 in the input, you have to put 2 at the front"
                    },
                    {
                        "username": "booleanbit1",
                        "content": "I was able to submit after the 9th submission, the description is misleading, and so many test cases need to be considered,\\ntry below ones to test your code -\\n1. [2,1]   x=2\\n2. [3,6,5,4,8,1,7,2,4,5,6,7,2,1,2,3,4,5,77,88,3,3,3,4,4,4], x=4\\n3.  [] , x=0\\n4. [3,1], x=2\\n5. [2,4,1,1,2,3,4,2,2] , x=3\\n6. [2,0,4,1,3,1,4,0,3], x=4\\n\\nAlso try changing values of x, there could be test cases where x is not even in the list, so take care of that as well.\\n\\nThe idea behind the solution is - keep tracking the list before you get your number x, and make sure to put all the numbers strictly less than x before the numbers greater than x, and then continue the same for the list after finding x in the list.\\n"
                    },
                    {
                        "username": "Suhasumesh",
                        "content": "Tip :\\nCreate 2 dummy listnodes and two pointers pointing to them and use one listnode to store values less than x and other listnode to store value greater than x and join them and return dummy1\\'s listnode.\\nPlease do upvote if you like it. Thank you!"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "This is not a tip, this is literally the solution"
                    },
                    {
                        "username": "tuhinssam",
                        "content": "This is pretty straightforward:\\n1. create list1 with values lower than x while maintaining the order\\n2. create list2 with values grater or equals to x while maintaining the order\\n3. join list1 and list2\\n4. return list1 head"
                    },
                    {
                        "username": "skydodle",
                        "content": "The key here is to recognize there are two groups. One group (nodes with value less than x) should be in the front of the result list, and the other group (nodes with value >= x) should be in the latter part of result list. Therefore we can break it down to left group and right group.\\n\\nThe rest is easy. As we traverse the list, we check each node to see if it belong to left group or right group, and update left or right group along the way. In the end, connect left to right and we have a result list."
                    },
                    {
                        "username": "omeirr13",
                        "content": "but this uses extra space right?"
                    },
                    {
                        "username": "user5630Yg",
                        "content": "Are we allowed to change the val of the node? Or we need to move the node."
                    },
                    {
                        "username": "swapnils_leetcode",
                        "content": "It takes 2hr to solve this problem but at end it is a part of problem solving  \n\nhint for this problem:\ncreate a two different such that\n\nlst  = [1,4,3,2,5,2]\nx = 3\n\nsList = [1,2,2]  // small list contains smaller element in list than x .\nlList = [4,3,5]  // large list contains bigger or equal elemet to x.\n\nand done !\n\nmerge and return result."
                    },
                    {
                        "username": "raviprajapatikandari",
                        "content": "[@omeirr13](/omeirr13)  ok i will try to solve without extra space\\n"
                    },
                    {
                        "username": "omeirr13",
                        "content": "try to do without extra space"
                    }
                ]
            },
            {
                "id": 1707670,
                "content": [
                    {
                        "username": "alokranjanjha10",
                        "content": "Happy Independence Day "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Lower Medium Class question, not that tough. We can do it guys. \\uD83D\\uDE42"
                    },
                    {
                        "username": "aitachii",
                        "content": "Here\\'s some edge cases you might consider before submitting your solution.\\n\\n- list is empty\\n[]\\n0\\n\\n- x is not in the linked list: \\n[1]\\n0\\n[1]\\n2\\n[1,1]\\n2\\n[1,1]\\n0\\n"
                    },
                    {
                        "username": "rahul_rasve_712",
                        "content": "Input -> [2,2,3,1,5,0]\nExpected -> [2,2,1,0,3,5]\nPivot is takes as '3'\nwhy is it not [0,1,2,2,3,5]?\n\nCan someone please explain how should the elements be placed in the left part of the list? Should they be in sorted order or any random order works?"
                    },
                    {
                        "username": "EricRaw",
                        "content": "`You should preserve the original relative order of the nodes in each of the two partitions.`\n\nsince the 2 come first before 1 and 0 in the input, you have to put 2 at the front"
                    },
                    {
                        "username": "booleanbit1",
                        "content": "I was able to submit after the 9th submission, the description is misleading, and so many test cases need to be considered,\\ntry below ones to test your code -\\n1. [2,1]   x=2\\n2. [3,6,5,4,8,1,7,2,4,5,6,7,2,1,2,3,4,5,77,88,3,3,3,4,4,4], x=4\\n3.  [] , x=0\\n4. [3,1], x=2\\n5. [2,4,1,1,2,3,4,2,2] , x=3\\n6. [2,0,4,1,3,1,4,0,3], x=4\\n\\nAlso try changing values of x, there could be test cases where x is not even in the list, so take care of that as well.\\n\\nThe idea behind the solution is - keep tracking the list before you get your number x, and make sure to put all the numbers strictly less than x before the numbers greater than x, and then continue the same for the list after finding x in the list.\\n"
                    },
                    {
                        "username": "Suhasumesh",
                        "content": "Tip :\\nCreate 2 dummy listnodes and two pointers pointing to them and use one listnode to store values less than x and other listnode to store value greater than x and join them and return dummy1\\'s listnode.\\nPlease do upvote if you like it. Thank you!"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "This is not a tip, this is literally the solution"
                    },
                    {
                        "username": "tuhinssam",
                        "content": "This is pretty straightforward:\\n1. create list1 with values lower than x while maintaining the order\\n2. create list2 with values grater or equals to x while maintaining the order\\n3. join list1 and list2\\n4. return list1 head"
                    },
                    {
                        "username": "skydodle",
                        "content": "The key here is to recognize there are two groups. One group (nodes with value less than x) should be in the front of the result list, and the other group (nodes with value >= x) should be in the latter part of result list. Therefore we can break it down to left group and right group.\\n\\nThe rest is easy. As we traverse the list, we check each node to see if it belong to left group or right group, and update left or right group along the way. In the end, connect left to right and we have a result list."
                    },
                    {
                        "username": "omeirr13",
                        "content": "but this uses extra space right?"
                    },
                    {
                        "username": "user5630Yg",
                        "content": "Are we allowed to change the val of the node? Or we need to move the node."
                    },
                    {
                        "username": "swapnils_leetcode",
                        "content": "It takes 2hr to solve this problem but at end it is a part of problem solving  \n\nhint for this problem:\ncreate a two different such that\n\nlst  = [1,4,3,2,5,2]\nx = 3\n\nsList = [1,2,2]  // small list contains smaller element in list than x .\nlList = [4,3,5]  // large list contains bigger or equal elemet to x.\n\nand done !\n\nmerge and return result."
                    },
                    {
                        "username": "raviprajapatikandari",
                        "content": "[@omeirr13](/omeirr13)  ok i will try to solve without extra space\\n"
                    },
                    {
                        "username": "omeirr13",
                        "content": "try to do without extra space"
                    }
                ]
            },
            {
                "id": 2060561,
                "content": [
                    {
                        "username": "alokranjanjha10",
                        "content": "Happy Independence Day "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Lower Medium Class question, not that tough. We can do it guys. \\uD83D\\uDE42"
                    },
                    {
                        "username": "aitachii",
                        "content": "Here\\'s some edge cases you might consider before submitting your solution.\\n\\n- list is empty\\n[]\\n0\\n\\n- x is not in the linked list: \\n[1]\\n0\\n[1]\\n2\\n[1,1]\\n2\\n[1,1]\\n0\\n"
                    },
                    {
                        "username": "rahul_rasve_712",
                        "content": "Input -> [2,2,3,1,5,0]\nExpected -> [2,2,1,0,3,5]\nPivot is takes as '3'\nwhy is it not [0,1,2,2,3,5]?\n\nCan someone please explain how should the elements be placed in the left part of the list? Should they be in sorted order or any random order works?"
                    },
                    {
                        "username": "EricRaw",
                        "content": "`You should preserve the original relative order of the nodes in each of the two partitions.`\n\nsince the 2 come first before 1 and 0 in the input, you have to put 2 at the front"
                    },
                    {
                        "username": "booleanbit1",
                        "content": "I was able to submit after the 9th submission, the description is misleading, and so many test cases need to be considered,\\ntry below ones to test your code -\\n1. [2,1]   x=2\\n2. [3,6,5,4,8,1,7,2,4,5,6,7,2,1,2,3,4,5,77,88,3,3,3,4,4,4], x=4\\n3.  [] , x=0\\n4. [3,1], x=2\\n5. [2,4,1,1,2,3,4,2,2] , x=3\\n6. [2,0,4,1,3,1,4,0,3], x=4\\n\\nAlso try changing values of x, there could be test cases where x is not even in the list, so take care of that as well.\\n\\nThe idea behind the solution is - keep tracking the list before you get your number x, and make sure to put all the numbers strictly less than x before the numbers greater than x, and then continue the same for the list after finding x in the list.\\n"
                    },
                    {
                        "username": "Suhasumesh",
                        "content": "Tip :\\nCreate 2 dummy listnodes and two pointers pointing to them and use one listnode to store values less than x and other listnode to store value greater than x and join them and return dummy1\\'s listnode.\\nPlease do upvote if you like it. Thank you!"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "This is not a tip, this is literally the solution"
                    },
                    {
                        "username": "tuhinssam",
                        "content": "This is pretty straightforward:\\n1. create list1 with values lower than x while maintaining the order\\n2. create list2 with values grater or equals to x while maintaining the order\\n3. join list1 and list2\\n4. return list1 head"
                    },
                    {
                        "username": "skydodle",
                        "content": "The key here is to recognize there are two groups. One group (nodes with value less than x) should be in the front of the result list, and the other group (nodes with value >= x) should be in the latter part of result list. Therefore we can break it down to left group and right group.\\n\\nThe rest is easy. As we traverse the list, we check each node to see if it belong to left group or right group, and update left or right group along the way. In the end, connect left to right and we have a result list."
                    },
                    {
                        "username": "omeirr13",
                        "content": "but this uses extra space right?"
                    },
                    {
                        "username": "user5630Yg",
                        "content": "Are we allowed to change the val of the node? Or we need to move the node."
                    },
                    {
                        "username": "swapnils_leetcode",
                        "content": "It takes 2hr to solve this problem but at end it is a part of problem solving  \n\nhint for this problem:\ncreate a two different such that\n\nlst  = [1,4,3,2,5,2]\nx = 3\n\nsList = [1,2,2]  // small list contains smaller element in list than x .\nlList = [4,3,5]  // large list contains bigger or equal elemet to x.\n\nand done !\n\nmerge and return result."
                    },
                    {
                        "username": "raviprajapatikandari",
                        "content": "[@omeirr13](/omeirr13)  ok i will try to solve without extra space\\n"
                    },
                    {
                        "username": "omeirr13",
                        "content": "try to do without extra space"
                    }
                ]
            },
            {
                "id": 2041513,
                "content": [
                    {
                        "username": "alokranjanjha10",
                        "content": "Happy Independence Day "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Lower Medium Class question, not that tough. We can do it guys. \\uD83D\\uDE42"
                    },
                    {
                        "username": "aitachii",
                        "content": "Here\\'s some edge cases you might consider before submitting your solution.\\n\\n- list is empty\\n[]\\n0\\n\\n- x is not in the linked list: \\n[1]\\n0\\n[1]\\n2\\n[1,1]\\n2\\n[1,1]\\n0\\n"
                    },
                    {
                        "username": "rahul_rasve_712",
                        "content": "Input -> [2,2,3,1,5,0]\nExpected -> [2,2,1,0,3,5]\nPivot is takes as '3'\nwhy is it not [0,1,2,2,3,5]?\n\nCan someone please explain how should the elements be placed in the left part of the list? Should they be in sorted order or any random order works?"
                    },
                    {
                        "username": "EricRaw",
                        "content": "`You should preserve the original relative order of the nodes in each of the two partitions.`\n\nsince the 2 come first before 1 and 0 in the input, you have to put 2 at the front"
                    },
                    {
                        "username": "booleanbit1",
                        "content": "I was able to submit after the 9th submission, the description is misleading, and so many test cases need to be considered,\\ntry below ones to test your code -\\n1. [2,1]   x=2\\n2. [3,6,5,4,8,1,7,2,4,5,6,7,2,1,2,3,4,5,77,88,3,3,3,4,4,4], x=4\\n3.  [] , x=0\\n4. [3,1], x=2\\n5. [2,4,1,1,2,3,4,2,2] , x=3\\n6. [2,0,4,1,3,1,4,0,3], x=4\\n\\nAlso try changing values of x, there could be test cases where x is not even in the list, so take care of that as well.\\n\\nThe idea behind the solution is - keep tracking the list before you get your number x, and make sure to put all the numbers strictly less than x before the numbers greater than x, and then continue the same for the list after finding x in the list.\\n"
                    },
                    {
                        "username": "Suhasumesh",
                        "content": "Tip :\\nCreate 2 dummy listnodes and two pointers pointing to them and use one listnode to store values less than x and other listnode to store value greater than x and join them and return dummy1\\'s listnode.\\nPlease do upvote if you like it. Thank you!"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "This is not a tip, this is literally the solution"
                    },
                    {
                        "username": "tuhinssam",
                        "content": "This is pretty straightforward:\\n1. create list1 with values lower than x while maintaining the order\\n2. create list2 with values grater or equals to x while maintaining the order\\n3. join list1 and list2\\n4. return list1 head"
                    },
                    {
                        "username": "skydodle",
                        "content": "The key here is to recognize there are two groups. One group (nodes with value less than x) should be in the front of the result list, and the other group (nodes with value >= x) should be in the latter part of result list. Therefore we can break it down to left group and right group.\\n\\nThe rest is easy. As we traverse the list, we check each node to see if it belong to left group or right group, and update left or right group along the way. In the end, connect left to right and we have a result list."
                    },
                    {
                        "username": "omeirr13",
                        "content": "but this uses extra space right?"
                    },
                    {
                        "username": "user5630Yg",
                        "content": "Are we allowed to change the val of the node? Or we need to move the node."
                    },
                    {
                        "username": "swapnils_leetcode",
                        "content": "It takes 2hr to solve this problem but at end it is a part of problem solving  \n\nhint for this problem:\ncreate a two different such that\n\nlst  = [1,4,3,2,5,2]\nx = 3\n\nsList = [1,2,2]  // small list contains smaller element in list than x .\nlList = [4,3,5]  // large list contains bigger or equal elemet to x.\n\nand done !\n\nmerge and return result."
                    },
                    {
                        "username": "raviprajapatikandari",
                        "content": "[@omeirr13](/omeirr13)  ok i will try to solve without extra space\\n"
                    },
                    {
                        "username": "omeirr13",
                        "content": "try to do without extra space"
                    }
                ]
            },
            {
                "id": 2034321,
                "content": [
                    {
                        "username": "alokranjanjha10",
                        "content": "Happy Independence Day "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Lower Medium Class question, not that tough. We can do it guys. \\uD83D\\uDE42"
                    },
                    {
                        "username": "aitachii",
                        "content": "Here\\'s some edge cases you might consider before submitting your solution.\\n\\n- list is empty\\n[]\\n0\\n\\n- x is not in the linked list: \\n[1]\\n0\\n[1]\\n2\\n[1,1]\\n2\\n[1,1]\\n0\\n"
                    },
                    {
                        "username": "rahul_rasve_712",
                        "content": "Input -> [2,2,3,1,5,0]\nExpected -> [2,2,1,0,3,5]\nPivot is takes as '3'\nwhy is it not [0,1,2,2,3,5]?\n\nCan someone please explain how should the elements be placed in the left part of the list? Should they be in sorted order or any random order works?"
                    },
                    {
                        "username": "EricRaw",
                        "content": "`You should preserve the original relative order of the nodes in each of the two partitions.`\n\nsince the 2 come first before 1 and 0 in the input, you have to put 2 at the front"
                    },
                    {
                        "username": "booleanbit1",
                        "content": "I was able to submit after the 9th submission, the description is misleading, and so many test cases need to be considered,\\ntry below ones to test your code -\\n1. [2,1]   x=2\\n2. [3,6,5,4,8,1,7,2,4,5,6,7,2,1,2,3,4,5,77,88,3,3,3,4,4,4], x=4\\n3.  [] , x=0\\n4. [3,1], x=2\\n5. [2,4,1,1,2,3,4,2,2] , x=3\\n6. [2,0,4,1,3,1,4,0,3], x=4\\n\\nAlso try changing values of x, there could be test cases where x is not even in the list, so take care of that as well.\\n\\nThe idea behind the solution is - keep tracking the list before you get your number x, and make sure to put all the numbers strictly less than x before the numbers greater than x, and then continue the same for the list after finding x in the list.\\n"
                    },
                    {
                        "username": "Suhasumesh",
                        "content": "Tip :\\nCreate 2 dummy listnodes and two pointers pointing to them and use one listnode to store values less than x and other listnode to store value greater than x and join them and return dummy1\\'s listnode.\\nPlease do upvote if you like it. Thank you!"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "This is not a tip, this is literally the solution"
                    },
                    {
                        "username": "tuhinssam",
                        "content": "This is pretty straightforward:\\n1. create list1 with values lower than x while maintaining the order\\n2. create list2 with values grater or equals to x while maintaining the order\\n3. join list1 and list2\\n4. return list1 head"
                    },
                    {
                        "username": "skydodle",
                        "content": "The key here is to recognize there are two groups. One group (nodes with value less than x) should be in the front of the result list, and the other group (nodes with value >= x) should be in the latter part of result list. Therefore we can break it down to left group and right group.\\n\\nThe rest is easy. As we traverse the list, we check each node to see if it belong to left group or right group, and update left or right group along the way. In the end, connect left to right and we have a result list."
                    },
                    {
                        "username": "omeirr13",
                        "content": "but this uses extra space right?"
                    },
                    {
                        "username": "user5630Yg",
                        "content": "Are we allowed to change the val of the node? Or we need to move the node."
                    },
                    {
                        "username": "swapnils_leetcode",
                        "content": "It takes 2hr to solve this problem but at end it is a part of problem solving  \n\nhint for this problem:\ncreate a two different such that\n\nlst  = [1,4,3,2,5,2]\nx = 3\n\nsList = [1,2,2]  // small list contains smaller element in list than x .\nlList = [4,3,5]  // large list contains bigger or equal elemet to x.\n\nand done !\n\nmerge and return result."
                    },
                    {
                        "username": "raviprajapatikandari",
                        "content": "[@omeirr13](/omeirr13)  ok i will try to solve without extra space\\n"
                    },
                    {
                        "username": "omeirr13",
                        "content": "try to do without extra space"
                    }
                ]
            },
            {
                "id": 2019561,
                "content": [
                    {
                        "username": "alokranjanjha10",
                        "content": "Happy Independence Day "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Lower Medium Class question, not that tough. We can do it guys. \\uD83D\\uDE42"
                    },
                    {
                        "username": "aitachii",
                        "content": "Here\\'s some edge cases you might consider before submitting your solution.\\n\\n- list is empty\\n[]\\n0\\n\\n- x is not in the linked list: \\n[1]\\n0\\n[1]\\n2\\n[1,1]\\n2\\n[1,1]\\n0\\n"
                    },
                    {
                        "username": "rahul_rasve_712",
                        "content": "Input -> [2,2,3,1,5,0]\nExpected -> [2,2,1,0,3,5]\nPivot is takes as '3'\nwhy is it not [0,1,2,2,3,5]?\n\nCan someone please explain how should the elements be placed in the left part of the list? Should they be in sorted order or any random order works?"
                    },
                    {
                        "username": "EricRaw",
                        "content": "`You should preserve the original relative order of the nodes in each of the two partitions.`\n\nsince the 2 come first before 1 and 0 in the input, you have to put 2 at the front"
                    },
                    {
                        "username": "booleanbit1",
                        "content": "I was able to submit after the 9th submission, the description is misleading, and so many test cases need to be considered,\\ntry below ones to test your code -\\n1. [2,1]   x=2\\n2. [3,6,5,4,8,1,7,2,4,5,6,7,2,1,2,3,4,5,77,88,3,3,3,4,4,4], x=4\\n3.  [] , x=0\\n4. [3,1], x=2\\n5. [2,4,1,1,2,3,4,2,2] , x=3\\n6. [2,0,4,1,3,1,4,0,3], x=4\\n\\nAlso try changing values of x, there could be test cases where x is not even in the list, so take care of that as well.\\n\\nThe idea behind the solution is - keep tracking the list before you get your number x, and make sure to put all the numbers strictly less than x before the numbers greater than x, and then continue the same for the list after finding x in the list.\\n"
                    },
                    {
                        "username": "Suhasumesh",
                        "content": "Tip :\\nCreate 2 dummy listnodes and two pointers pointing to them and use one listnode to store values less than x and other listnode to store value greater than x and join them and return dummy1\\'s listnode.\\nPlease do upvote if you like it. Thank you!"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "This is not a tip, this is literally the solution"
                    },
                    {
                        "username": "tuhinssam",
                        "content": "This is pretty straightforward:\\n1. create list1 with values lower than x while maintaining the order\\n2. create list2 with values grater or equals to x while maintaining the order\\n3. join list1 and list2\\n4. return list1 head"
                    },
                    {
                        "username": "skydodle",
                        "content": "The key here is to recognize there are two groups. One group (nodes with value less than x) should be in the front of the result list, and the other group (nodes with value >= x) should be in the latter part of result list. Therefore we can break it down to left group and right group.\\n\\nThe rest is easy. As we traverse the list, we check each node to see if it belong to left group or right group, and update left or right group along the way. In the end, connect left to right and we have a result list."
                    },
                    {
                        "username": "omeirr13",
                        "content": "but this uses extra space right?"
                    },
                    {
                        "username": "user5630Yg",
                        "content": "Are we allowed to change the val of the node? Or we need to move the node."
                    },
                    {
                        "username": "swapnils_leetcode",
                        "content": "It takes 2hr to solve this problem but at end it is a part of problem solving  \n\nhint for this problem:\ncreate a two different such that\n\nlst  = [1,4,3,2,5,2]\nx = 3\n\nsList = [1,2,2]  // small list contains smaller element in list than x .\nlList = [4,3,5]  // large list contains bigger or equal elemet to x.\n\nand done !\n\nmerge and return result."
                    },
                    {
                        "username": "raviprajapatikandari",
                        "content": "[@omeirr13](/omeirr13)  ok i will try to solve without extra space\\n"
                    },
                    {
                        "username": "omeirr13",
                        "content": "try to do without extra space"
                    }
                ]
            },
            {
                "id": 2016039,
                "content": [
                    {
                        "username": "SubomiSultan",
                        "content": "whenever i click submit it gives an error and says solution is not defined im using python 3"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "What a Joke is this TestCase ? \\n\\n\\nInput\\nhead =\\n[1,4,3,0,2,5,2]\\nx =\\n3\\n\\nUse Testcase\\nOutput\\n[0,1,2,2,4,3,5]\\nExpected\\n[1,0,2,2,4,3,5]"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@Gauravkr007](/Gauravkr007) The relative order in a partition order should remain the same, but all numbers smaller than x should come before all the numbers larger than x. Those will be your two partitions.\\nSo 0 and 2 get pulled to the front. But all other numbers keep the same order."
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "[@Mister_CK](/Mister_CK) then why 0 and 2 came before 4 if relative order should remain same."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "why do change the order of 1 and 0. The relative order should remain the same as it occurs in the original list"
                    },
                    {
                        "username": "layyy",
                        "content": "Taking two lists and two dummy heads would work"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It would, but then try this one, where you should come up with an O(n) timen and O(1) space solution: https://leetcode.com/problems/odd-even-linked-list/"
                    },
                    {
                        "username": "shevartsoft",
                        "content": "Thank you leetCode, with tickets like this I see the light on the end of my learning way!"
                    },
                    {
                        "username": "RupinderKaur484",
                        "content": "So , I was confused about the statement  at first, basically all the numbers less than x should be before x, and the sequence of the rest (the numbers greater than or equal to x) should be unchanged."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "the relative sequence of the numbers smaller than x should also remain the same as in the original list"
                    },
                    {
                        "username": "raviprajapatikandari",
                        "content": "problem say-> \\nfirst check less then x (head.val<x) value  and store a new list .\\n& again check greater then or equle  x (head.val>=x) value  and connect previous list."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Then try this one as a follow up, where you should come up with an O(n) timen and O(1) space solution: https://leetcode.com/problems/odd-even-linked-list/"
                    },
                    {
                        "username": "chinmaykothe98",
                        "content": "Hello All!\\nThis is my approach\\n\\n1. Create a new list with value -1;\\n2. First loop on the Linked list and keep adding the elements less than value \\'x\\'\\n3. Loop on the LL again and now keep adding the elements greater than and equal to value \\'x\\' in the same list.\\n4. Return the list\\n\\nI hope this help you all. Thanks...!!!"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "For the test case - [3,6,5,2,4,8,1,7], target = 4\\nExpected answer is - [3,2,1,6,5,4,8,7]\\n\\nWhy 2\\'s position is changed, if it is less than target and is in left of it?\\n\\nSolution :-\\nA: Numbers less than 4 (in input order) = [3, 2, 1]\\nB: Numbers greater than or equal to 4 (in input order) = [6, 5, 4, 8, 7]\\nA + B = [3, 2, 1, 6, 5, 4, 8, 7]"
                    },
                    {
                        "username": "deusdev",
                        "content": "I still remember the time when I couldn\\'t make any linked list problems without seeing any solutions first. I still have to improve the efficiency, but it feels good that I can do it now :D"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Me too, I HATED linked lists, just didn\\'t understand them at all. I still don\\'t like them but did manage to pass on the first go in reasonable time :) "
                    },
                    {
                        "username": "Utsarg",
                        "content": "Works fine like this , but gives runtime error when , dummy1=node1, dummy2=node2, is written, on 5th and 6th line, instead of node1=dummy1;  node2=dummy2; . Why is this happening, how does it make a difference??\\n\\n\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode *dummy1= new ListNode(0), *dummy2=new ListNode(0),*node1,*node2;\\n        node1=dummy1;\\n        node2=dummy2;\\n\\n        while(head)\\n        {\\n            if(head->val<x){\\n            node1->next=head;\\n            node1=node1->next;\\n        }\\n        else\\n        {\\n            node2->next=head;\\n            node2=node2->next;\\n        }\\n        \\n        head=head->next;\\n        }\\n\\n        node2->next=NULL;\\n        node1->next=dummy2->next;\\n        return dummy1->next;\\n    }\\n};\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 2015881,
                "content": [
                    {
                        "username": "SubomiSultan",
                        "content": "whenever i click submit it gives an error and says solution is not defined im using python 3"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "What a Joke is this TestCase ? \\n\\n\\nInput\\nhead =\\n[1,4,3,0,2,5,2]\\nx =\\n3\\n\\nUse Testcase\\nOutput\\n[0,1,2,2,4,3,5]\\nExpected\\n[1,0,2,2,4,3,5]"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@Gauravkr007](/Gauravkr007) The relative order in a partition order should remain the same, but all numbers smaller than x should come before all the numbers larger than x. Those will be your two partitions.\\nSo 0 and 2 get pulled to the front. But all other numbers keep the same order."
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "[@Mister_CK](/Mister_CK) then why 0 and 2 came before 4 if relative order should remain same."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "why do change the order of 1 and 0. The relative order should remain the same as it occurs in the original list"
                    },
                    {
                        "username": "layyy",
                        "content": "Taking two lists and two dummy heads would work"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It would, but then try this one, where you should come up with an O(n) timen and O(1) space solution: https://leetcode.com/problems/odd-even-linked-list/"
                    },
                    {
                        "username": "shevartsoft",
                        "content": "Thank you leetCode, with tickets like this I see the light on the end of my learning way!"
                    },
                    {
                        "username": "RupinderKaur484",
                        "content": "So , I was confused about the statement  at first, basically all the numbers less than x should be before x, and the sequence of the rest (the numbers greater than or equal to x) should be unchanged."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "the relative sequence of the numbers smaller than x should also remain the same as in the original list"
                    },
                    {
                        "username": "raviprajapatikandari",
                        "content": "problem say-> \\nfirst check less then x (head.val<x) value  and store a new list .\\n& again check greater then or equle  x (head.val>=x) value  and connect previous list."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Then try this one as a follow up, where you should come up with an O(n) timen and O(1) space solution: https://leetcode.com/problems/odd-even-linked-list/"
                    },
                    {
                        "username": "chinmaykothe98",
                        "content": "Hello All!\\nThis is my approach\\n\\n1. Create a new list with value -1;\\n2. First loop on the Linked list and keep adding the elements less than value \\'x\\'\\n3. Loop on the LL again and now keep adding the elements greater than and equal to value \\'x\\' in the same list.\\n4. Return the list\\n\\nI hope this help you all. Thanks...!!!"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "For the test case - [3,6,5,2,4,8,1,7], target = 4\\nExpected answer is - [3,2,1,6,5,4,8,7]\\n\\nWhy 2\\'s position is changed, if it is less than target and is in left of it?\\n\\nSolution :-\\nA: Numbers less than 4 (in input order) = [3, 2, 1]\\nB: Numbers greater than or equal to 4 (in input order) = [6, 5, 4, 8, 7]\\nA + B = [3, 2, 1, 6, 5, 4, 8, 7]"
                    },
                    {
                        "username": "deusdev",
                        "content": "I still remember the time when I couldn\\'t make any linked list problems without seeing any solutions first. I still have to improve the efficiency, but it feels good that I can do it now :D"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Me too, I HATED linked lists, just didn\\'t understand them at all. I still don\\'t like them but did manage to pass on the first go in reasonable time :) "
                    },
                    {
                        "username": "Utsarg",
                        "content": "Works fine like this , but gives runtime error when , dummy1=node1, dummy2=node2, is written, on 5th and 6th line, instead of node1=dummy1;  node2=dummy2; . Why is this happening, how does it make a difference??\\n\\n\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode *dummy1= new ListNode(0), *dummy2=new ListNode(0),*node1,*node2;\\n        node1=dummy1;\\n        node2=dummy2;\\n\\n        while(head)\\n        {\\n            if(head->val<x){\\n            node1->next=head;\\n            node1=node1->next;\\n        }\\n        else\\n        {\\n            node2->next=head;\\n            node2=node2->next;\\n        }\\n        \\n        head=head->next;\\n        }\\n\\n        node2->next=NULL;\\n        node1->next=dummy2->next;\\n        return dummy1->next;\\n    }\\n};\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 2015878,
                "content": [
                    {
                        "username": "SubomiSultan",
                        "content": "whenever i click submit it gives an error and says solution is not defined im using python 3"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "What a Joke is this TestCase ? \\n\\n\\nInput\\nhead =\\n[1,4,3,0,2,5,2]\\nx =\\n3\\n\\nUse Testcase\\nOutput\\n[0,1,2,2,4,3,5]\\nExpected\\n[1,0,2,2,4,3,5]"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@Gauravkr007](/Gauravkr007) The relative order in a partition order should remain the same, but all numbers smaller than x should come before all the numbers larger than x. Those will be your two partitions.\\nSo 0 and 2 get pulled to the front. But all other numbers keep the same order."
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "[@Mister_CK](/Mister_CK) then why 0 and 2 came before 4 if relative order should remain same."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "why do change the order of 1 and 0. The relative order should remain the same as it occurs in the original list"
                    },
                    {
                        "username": "layyy",
                        "content": "Taking two lists and two dummy heads would work"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It would, but then try this one, where you should come up with an O(n) timen and O(1) space solution: https://leetcode.com/problems/odd-even-linked-list/"
                    },
                    {
                        "username": "shevartsoft",
                        "content": "Thank you leetCode, with tickets like this I see the light on the end of my learning way!"
                    },
                    {
                        "username": "RupinderKaur484",
                        "content": "So , I was confused about the statement  at first, basically all the numbers less than x should be before x, and the sequence of the rest (the numbers greater than or equal to x) should be unchanged."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "the relative sequence of the numbers smaller than x should also remain the same as in the original list"
                    },
                    {
                        "username": "raviprajapatikandari",
                        "content": "problem say-> \\nfirst check less then x (head.val<x) value  and store a new list .\\n& again check greater then or equle  x (head.val>=x) value  and connect previous list."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Then try this one as a follow up, where you should come up with an O(n) timen and O(1) space solution: https://leetcode.com/problems/odd-even-linked-list/"
                    },
                    {
                        "username": "chinmaykothe98",
                        "content": "Hello All!\\nThis is my approach\\n\\n1. Create a new list with value -1;\\n2. First loop on the Linked list and keep adding the elements less than value \\'x\\'\\n3. Loop on the LL again and now keep adding the elements greater than and equal to value \\'x\\' in the same list.\\n4. Return the list\\n\\nI hope this help you all. Thanks...!!!"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "For the test case - [3,6,5,2,4,8,1,7], target = 4\\nExpected answer is - [3,2,1,6,5,4,8,7]\\n\\nWhy 2\\'s position is changed, if it is less than target and is in left of it?\\n\\nSolution :-\\nA: Numbers less than 4 (in input order) = [3, 2, 1]\\nB: Numbers greater than or equal to 4 (in input order) = [6, 5, 4, 8, 7]\\nA + B = [3, 2, 1, 6, 5, 4, 8, 7]"
                    },
                    {
                        "username": "deusdev",
                        "content": "I still remember the time when I couldn\\'t make any linked list problems without seeing any solutions first. I still have to improve the efficiency, but it feels good that I can do it now :D"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Me too, I HATED linked lists, just didn\\'t understand them at all. I still don\\'t like them but did manage to pass on the first go in reasonable time :) "
                    },
                    {
                        "username": "Utsarg",
                        "content": "Works fine like this , but gives runtime error when , dummy1=node1, dummy2=node2, is written, on 5th and 6th line, instead of node1=dummy1;  node2=dummy2; . Why is this happening, how does it make a difference??\\n\\n\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode *dummy1= new ListNode(0), *dummy2=new ListNode(0),*node1,*node2;\\n        node1=dummy1;\\n        node2=dummy2;\\n\\n        while(head)\\n        {\\n            if(head->val<x){\\n            node1->next=head;\\n            node1=node1->next;\\n        }\\n        else\\n        {\\n            node2->next=head;\\n            node2=node2->next;\\n        }\\n        \\n        head=head->next;\\n        }\\n\\n        node2->next=NULL;\\n        node1->next=dummy2->next;\\n        return dummy1->next;\\n    }\\n};\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 2015667,
                "content": [
                    {
                        "username": "SubomiSultan",
                        "content": "whenever i click submit it gives an error and says solution is not defined im using python 3"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "What a Joke is this TestCase ? \\n\\n\\nInput\\nhead =\\n[1,4,3,0,2,5,2]\\nx =\\n3\\n\\nUse Testcase\\nOutput\\n[0,1,2,2,4,3,5]\\nExpected\\n[1,0,2,2,4,3,5]"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@Gauravkr007](/Gauravkr007) The relative order in a partition order should remain the same, but all numbers smaller than x should come before all the numbers larger than x. Those will be your two partitions.\\nSo 0 and 2 get pulled to the front. But all other numbers keep the same order."
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "[@Mister_CK](/Mister_CK) then why 0 and 2 came before 4 if relative order should remain same."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "why do change the order of 1 and 0. The relative order should remain the same as it occurs in the original list"
                    },
                    {
                        "username": "layyy",
                        "content": "Taking two lists and two dummy heads would work"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It would, but then try this one, where you should come up with an O(n) timen and O(1) space solution: https://leetcode.com/problems/odd-even-linked-list/"
                    },
                    {
                        "username": "shevartsoft",
                        "content": "Thank you leetCode, with tickets like this I see the light on the end of my learning way!"
                    },
                    {
                        "username": "RupinderKaur484",
                        "content": "So , I was confused about the statement  at first, basically all the numbers less than x should be before x, and the sequence of the rest (the numbers greater than or equal to x) should be unchanged."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "the relative sequence of the numbers smaller than x should also remain the same as in the original list"
                    },
                    {
                        "username": "raviprajapatikandari",
                        "content": "problem say-> \\nfirst check less then x (head.val<x) value  and store a new list .\\n& again check greater then or equle  x (head.val>=x) value  and connect previous list."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Then try this one as a follow up, where you should come up with an O(n) timen and O(1) space solution: https://leetcode.com/problems/odd-even-linked-list/"
                    },
                    {
                        "username": "chinmaykothe98",
                        "content": "Hello All!\\nThis is my approach\\n\\n1. Create a new list with value -1;\\n2. First loop on the Linked list and keep adding the elements less than value \\'x\\'\\n3. Loop on the LL again and now keep adding the elements greater than and equal to value \\'x\\' in the same list.\\n4. Return the list\\n\\nI hope this help you all. Thanks...!!!"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "For the test case - [3,6,5,2,4,8,1,7], target = 4\\nExpected answer is - [3,2,1,6,5,4,8,7]\\n\\nWhy 2\\'s position is changed, if it is less than target and is in left of it?\\n\\nSolution :-\\nA: Numbers less than 4 (in input order) = [3, 2, 1]\\nB: Numbers greater than or equal to 4 (in input order) = [6, 5, 4, 8, 7]\\nA + B = [3, 2, 1, 6, 5, 4, 8, 7]"
                    },
                    {
                        "username": "deusdev",
                        "content": "I still remember the time when I couldn\\'t make any linked list problems without seeing any solutions first. I still have to improve the efficiency, but it feels good that I can do it now :D"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Me too, I HATED linked lists, just didn\\'t understand them at all. I still don\\'t like them but did manage to pass on the first go in reasonable time :) "
                    },
                    {
                        "username": "Utsarg",
                        "content": "Works fine like this , but gives runtime error when , dummy1=node1, dummy2=node2, is written, on 5th and 6th line, instead of node1=dummy1;  node2=dummy2; . Why is this happening, how does it make a difference??\\n\\n\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode *dummy1= new ListNode(0), *dummy2=new ListNode(0),*node1,*node2;\\n        node1=dummy1;\\n        node2=dummy2;\\n\\n        while(head)\\n        {\\n            if(head->val<x){\\n            node1->next=head;\\n            node1=node1->next;\\n        }\\n        else\\n        {\\n            node2->next=head;\\n            node2=node2->next;\\n        }\\n        \\n        head=head->next;\\n        }\\n\\n        node2->next=NULL;\\n        node1->next=dummy2->next;\\n        return dummy1->next;\\n    }\\n};\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 2015666,
                "content": [
                    {
                        "username": "SubomiSultan",
                        "content": "whenever i click submit it gives an error and says solution is not defined im using python 3"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "What a Joke is this TestCase ? \\n\\n\\nInput\\nhead =\\n[1,4,3,0,2,5,2]\\nx =\\n3\\n\\nUse Testcase\\nOutput\\n[0,1,2,2,4,3,5]\\nExpected\\n[1,0,2,2,4,3,5]"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@Gauravkr007](/Gauravkr007) The relative order in a partition order should remain the same, but all numbers smaller than x should come before all the numbers larger than x. Those will be your two partitions.\\nSo 0 and 2 get pulled to the front. But all other numbers keep the same order."
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "[@Mister_CK](/Mister_CK) then why 0 and 2 came before 4 if relative order should remain same."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "why do change the order of 1 and 0. The relative order should remain the same as it occurs in the original list"
                    },
                    {
                        "username": "layyy",
                        "content": "Taking two lists and two dummy heads would work"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It would, but then try this one, where you should come up with an O(n) timen and O(1) space solution: https://leetcode.com/problems/odd-even-linked-list/"
                    },
                    {
                        "username": "shevartsoft",
                        "content": "Thank you leetCode, with tickets like this I see the light on the end of my learning way!"
                    },
                    {
                        "username": "RupinderKaur484",
                        "content": "So , I was confused about the statement  at first, basically all the numbers less than x should be before x, and the sequence of the rest (the numbers greater than or equal to x) should be unchanged."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "the relative sequence of the numbers smaller than x should also remain the same as in the original list"
                    },
                    {
                        "username": "raviprajapatikandari",
                        "content": "problem say-> \\nfirst check less then x (head.val<x) value  and store a new list .\\n& again check greater then or equle  x (head.val>=x) value  and connect previous list."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Then try this one as a follow up, where you should come up with an O(n) timen and O(1) space solution: https://leetcode.com/problems/odd-even-linked-list/"
                    },
                    {
                        "username": "chinmaykothe98",
                        "content": "Hello All!\\nThis is my approach\\n\\n1. Create a new list with value -1;\\n2. First loop on the Linked list and keep adding the elements less than value \\'x\\'\\n3. Loop on the LL again and now keep adding the elements greater than and equal to value \\'x\\' in the same list.\\n4. Return the list\\n\\nI hope this help you all. Thanks...!!!"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "For the test case - [3,6,5,2,4,8,1,7], target = 4\\nExpected answer is - [3,2,1,6,5,4,8,7]\\n\\nWhy 2\\'s position is changed, if it is less than target and is in left of it?\\n\\nSolution :-\\nA: Numbers less than 4 (in input order) = [3, 2, 1]\\nB: Numbers greater than or equal to 4 (in input order) = [6, 5, 4, 8, 7]\\nA + B = [3, 2, 1, 6, 5, 4, 8, 7]"
                    },
                    {
                        "username": "deusdev",
                        "content": "I still remember the time when I couldn\\'t make any linked list problems without seeing any solutions first. I still have to improve the efficiency, but it feels good that I can do it now :D"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Me too, I HATED linked lists, just didn\\'t understand them at all. I still don\\'t like them but did manage to pass on the first go in reasonable time :) "
                    },
                    {
                        "username": "Utsarg",
                        "content": "Works fine like this , but gives runtime error when , dummy1=node1, dummy2=node2, is written, on 5th and 6th line, instead of node1=dummy1;  node2=dummy2; . Why is this happening, how does it make a difference??\\n\\n\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode *dummy1= new ListNode(0), *dummy2=new ListNode(0),*node1,*node2;\\n        node1=dummy1;\\n        node2=dummy2;\\n\\n        while(head)\\n        {\\n            if(head->val<x){\\n            node1->next=head;\\n            node1=node1->next;\\n        }\\n        else\\n        {\\n            node2->next=head;\\n            node2=node2->next;\\n        }\\n        \\n        head=head->next;\\n        }\\n\\n        node2->next=NULL;\\n        node1->next=dummy2->next;\\n        return dummy1->next;\\n    }\\n};\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 2015621,
                "content": [
                    {
                        "username": "SubomiSultan",
                        "content": "whenever i click submit it gives an error and says solution is not defined im using python 3"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "What a Joke is this TestCase ? \\n\\n\\nInput\\nhead =\\n[1,4,3,0,2,5,2]\\nx =\\n3\\n\\nUse Testcase\\nOutput\\n[0,1,2,2,4,3,5]\\nExpected\\n[1,0,2,2,4,3,5]"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@Gauravkr007](/Gauravkr007) The relative order in a partition order should remain the same, but all numbers smaller than x should come before all the numbers larger than x. Those will be your two partitions.\\nSo 0 and 2 get pulled to the front. But all other numbers keep the same order."
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "[@Mister_CK](/Mister_CK) then why 0 and 2 came before 4 if relative order should remain same."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "why do change the order of 1 and 0. The relative order should remain the same as it occurs in the original list"
                    },
                    {
                        "username": "layyy",
                        "content": "Taking two lists and two dummy heads would work"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It would, but then try this one, where you should come up with an O(n) timen and O(1) space solution: https://leetcode.com/problems/odd-even-linked-list/"
                    },
                    {
                        "username": "shevartsoft",
                        "content": "Thank you leetCode, with tickets like this I see the light on the end of my learning way!"
                    },
                    {
                        "username": "RupinderKaur484",
                        "content": "So , I was confused about the statement  at first, basically all the numbers less than x should be before x, and the sequence of the rest (the numbers greater than or equal to x) should be unchanged."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "the relative sequence of the numbers smaller than x should also remain the same as in the original list"
                    },
                    {
                        "username": "raviprajapatikandari",
                        "content": "problem say-> \\nfirst check less then x (head.val<x) value  and store a new list .\\n& again check greater then or equle  x (head.val>=x) value  and connect previous list."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Then try this one as a follow up, where you should come up with an O(n) timen and O(1) space solution: https://leetcode.com/problems/odd-even-linked-list/"
                    },
                    {
                        "username": "chinmaykothe98",
                        "content": "Hello All!\\nThis is my approach\\n\\n1. Create a new list with value -1;\\n2. First loop on the Linked list and keep adding the elements less than value \\'x\\'\\n3. Loop on the LL again and now keep adding the elements greater than and equal to value \\'x\\' in the same list.\\n4. Return the list\\n\\nI hope this help you all. Thanks...!!!"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "For the test case - [3,6,5,2,4,8,1,7], target = 4\\nExpected answer is - [3,2,1,6,5,4,8,7]\\n\\nWhy 2\\'s position is changed, if it is less than target and is in left of it?\\n\\nSolution :-\\nA: Numbers less than 4 (in input order) = [3, 2, 1]\\nB: Numbers greater than or equal to 4 (in input order) = [6, 5, 4, 8, 7]\\nA + B = [3, 2, 1, 6, 5, 4, 8, 7]"
                    },
                    {
                        "username": "deusdev",
                        "content": "I still remember the time when I couldn\\'t make any linked list problems without seeing any solutions first. I still have to improve the efficiency, but it feels good that I can do it now :D"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Me too, I HATED linked lists, just didn\\'t understand them at all. I still don\\'t like them but did manage to pass on the first go in reasonable time :) "
                    },
                    {
                        "username": "Utsarg",
                        "content": "Works fine like this , but gives runtime error when , dummy1=node1, dummy2=node2, is written, on 5th and 6th line, instead of node1=dummy1;  node2=dummy2; . Why is this happening, how does it make a difference??\\n\\n\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode *dummy1= new ListNode(0), *dummy2=new ListNode(0),*node1,*node2;\\n        node1=dummy1;\\n        node2=dummy2;\\n\\n        while(head)\\n        {\\n            if(head->val<x){\\n            node1->next=head;\\n            node1=node1->next;\\n        }\\n        else\\n        {\\n            node2->next=head;\\n            node2=node2->next;\\n        }\\n        \\n        head=head->next;\\n        }\\n\\n        node2->next=NULL;\\n        node1->next=dummy2->next;\\n        return dummy1->next;\\n    }\\n};\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 2015554,
                "content": [
                    {
                        "username": "SubomiSultan",
                        "content": "whenever i click submit it gives an error and says solution is not defined im using python 3"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "What a Joke is this TestCase ? \\n\\n\\nInput\\nhead =\\n[1,4,3,0,2,5,2]\\nx =\\n3\\n\\nUse Testcase\\nOutput\\n[0,1,2,2,4,3,5]\\nExpected\\n[1,0,2,2,4,3,5]"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@Gauravkr007](/Gauravkr007) The relative order in a partition order should remain the same, but all numbers smaller than x should come before all the numbers larger than x. Those will be your two partitions.\\nSo 0 and 2 get pulled to the front. But all other numbers keep the same order."
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "[@Mister_CK](/Mister_CK) then why 0 and 2 came before 4 if relative order should remain same."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "why do change the order of 1 and 0. The relative order should remain the same as it occurs in the original list"
                    },
                    {
                        "username": "layyy",
                        "content": "Taking two lists and two dummy heads would work"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It would, but then try this one, where you should come up with an O(n) timen and O(1) space solution: https://leetcode.com/problems/odd-even-linked-list/"
                    },
                    {
                        "username": "shevartsoft",
                        "content": "Thank you leetCode, with tickets like this I see the light on the end of my learning way!"
                    },
                    {
                        "username": "RupinderKaur484",
                        "content": "So , I was confused about the statement  at first, basically all the numbers less than x should be before x, and the sequence of the rest (the numbers greater than or equal to x) should be unchanged."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "the relative sequence of the numbers smaller than x should also remain the same as in the original list"
                    },
                    {
                        "username": "raviprajapatikandari",
                        "content": "problem say-> \\nfirst check less then x (head.val<x) value  and store a new list .\\n& again check greater then or equle  x (head.val>=x) value  and connect previous list."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Then try this one as a follow up, where you should come up with an O(n) timen and O(1) space solution: https://leetcode.com/problems/odd-even-linked-list/"
                    },
                    {
                        "username": "chinmaykothe98",
                        "content": "Hello All!\\nThis is my approach\\n\\n1. Create a new list with value -1;\\n2. First loop on the Linked list and keep adding the elements less than value \\'x\\'\\n3. Loop on the LL again and now keep adding the elements greater than and equal to value \\'x\\' in the same list.\\n4. Return the list\\n\\nI hope this help you all. Thanks...!!!"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "For the test case - [3,6,5,2,4,8,1,7], target = 4\\nExpected answer is - [3,2,1,6,5,4,8,7]\\n\\nWhy 2\\'s position is changed, if it is less than target and is in left of it?\\n\\nSolution :-\\nA: Numbers less than 4 (in input order) = [3, 2, 1]\\nB: Numbers greater than or equal to 4 (in input order) = [6, 5, 4, 8, 7]\\nA + B = [3, 2, 1, 6, 5, 4, 8, 7]"
                    },
                    {
                        "username": "deusdev",
                        "content": "I still remember the time when I couldn\\'t make any linked list problems without seeing any solutions first. I still have to improve the efficiency, but it feels good that I can do it now :D"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Me too, I HATED linked lists, just didn\\'t understand them at all. I still don\\'t like them but did manage to pass on the first go in reasonable time :) "
                    },
                    {
                        "username": "Utsarg",
                        "content": "Works fine like this , but gives runtime error when , dummy1=node1, dummy2=node2, is written, on 5th and 6th line, instead of node1=dummy1;  node2=dummy2; . Why is this happening, how does it make a difference??\\n\\n\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode *dummy1= new ListNode(0), *dummy2=new ListNode(0),*node1,*node2;\\n        node1=dummy1;\\n        node2=dummy2;\\n\\n        while(head)\\n        {\\n            if(head->val<x){\\n            node1->next=head;\\n            node1=node1->next;\\n        }\\n        else\\n        {\\n            node2->next=head;\\n            node2=node2->next;\\n        }\\n        \\n        head=head->next;\\n        }\\n\\n        node2->next=NULL;\\n        node1->next=dummy2->next;\\n        return dummy1->next;\\n    }\\n};\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 2015480,
                "content": [
                    {
                        "username": "SubomiSultan",
                        "content": "whenever i click submit it gives an error and says solution is not defined im using python 3"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "What a Joke is this TestCase ? \\n\\n\\nInput\\nhead =\\n[1,4,3,0,2,5,2]\\nx =\\n3\\n\\nUse Testcase\\nOutput\\n[0,1,2,2,4,3,5]\\nExpected\\n[1,0,2,2,4,3,5]"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@Gauravkr007](/Gauravkr007) The relative order in a partition order should remain the same, but all numbers smaller than x should come before all the numbers larger than x. Those will be your two partitions.\\nSo 0 and 2 get pulled to the front. But all other numbers keep the same order."
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "[@Mister_CK](/Mister_CK) then why 0 and 2 came before 4 if relative order should remain same."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "why do change the order of 1 and 0. The relative order should remain the same as it occurs in the original list"
                    },
                    {
                        "username": "layyy",
                        "content": "Taking two lists and two dummy heads would work"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It would, but then try this one, where you should come up with an O(n) timen and O(1) space solution: https://leetcode.com/problems/odd-even-linked-list/"
                    },
                    {
                        "username": "shevartsoft",
                        "content": "Thank you leetCode, with tickets like this I see the light on the end of my learning way!"
                    },
                    {
                        "username": "RupinderKaur484",
                        "content": "So , I was confused about the statement  at first, basically all the numbers less than x should be before x, and the sequence of the rest (the numbers greater than or equal to x) should be unchanged."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "the relative sequence of the numbers smaller than x should also remain the same as in the original list"
                    },
                    {
                        "username": "raviprajapatikandari",
                        "content": "problem say-> \\nfirst check less then x (head.val<x) value  and store a new list .\\n& again check greater then or equle  x (head.val>=x) value  and connect previous list."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Then try this one as a follow up, where you should come up with an O(n) timen and O(1) space solution: https://leetcode.com/problems/odd-even-linked-list/"
                    },
                    {
                        "username": "chinmaykothe98",
                        "content": "Hello All!\\nThis is my approach\\n\\n1. Create a new list with value -1;\\n2. First loop on the Linked list and keep adding the elements less than value \\'x\\'\\n3. Loop on the LL again and now keep adding the elements greater than and equal to value \\'x\\' in the same list.\\n4. Return the list\\n\\nI hope this help you all. Thanks...!!!"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "For the test case - [3,6,5,2,4,8,1,7], target = 4\\nExpected answer is - [3,2,1,6,5,4,8,7]\\n\\nWhy 2\\'s position is changed, if it is less than target and is in left of it?\\n\\nSolution :-\\nA: Numbers less than 4 (in input order) = [3, 2, 1]\\nB: Numbers greater than or equal to 4 (in input order) = [6, 5, 4, 8, 7]\\nA + B = [3, 2, 1, 6, 5, 4, 8, 7]"
                    },
                    {
                        "username": "deusdev",
                        "content": "I still remember the time when I couldn\\'t make any linked list problems without seeing any solutions first. I still have to improve the efficiency, but it feels good that I can do it now :D"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Me too, I HATED linked lists, just didn\\'t understand them at all. I still don\\'t like them but did manage to pass on the first go in reasonable time :) "
                    },
                    {
                        "username": "Utsarg",
                        "content": "Works fine like this , but gives runtime error when , dummy1=node1, dummy2=node2, is written, on 5th and 6th line, instead of node1=dummy1;  node2=dummy2; . Why is this happening, how does it make a difference??\\n\\n\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode *dummy1= new ListNode(0), *dummy2=new ListNode(0),*node1,*node2;\\n        node1=dummy1;\\n        node2=dummy2;\\n\\n        while(head)\\n        {\\n            if(head->val<x){\\n            node1->next=head;\\n            node1=node1->next;\\n        }\\n        else\\n        {\\n            node2->next=head;\\n            node2=node2->next;\\n        }\\n        \\n        head=head->next;\\n        }\\n\\n        node2->next=NULL;\\n        node1->next=dummy2->next;\\n        return dummy1->next;\\n    }\\n};\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 2015425,
                "content": [
                    {
                        "username": "SubomiSultan",
                        "content": "whenever i click submit it gives an error and says solution is not defined im using python 3"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "What a Joke is this TestCase ? \\n\\n\\nInput\\nhead =\\n[1,4,3,0,2,5,2]\\nx =\\n3\\n\\nUse Testcase\\nOutput\\n[0,1,2,2,4,3,5]\\nExpected\\n[1,0,2,2,4,3,5]"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@Gauravkr007](/Gauravkr007) The relative order in a partition order should remain the same, but all numbers smaller than x should come before all the numbers larger than x. Those will be your two partitions.\\nSo 0 and 2 get pulled to the front. But all other numbers keep the same order."
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "[@Mister_CK](/Mister_CK) then why 0 and 2 came before 4 if relative order should remain same."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "why do change the order of 1 and 0. The relative order should remain the same as it occurs in the original list"
                    },
                    {
                        "username": "layyy",
                        "content": "Taking two lists and two dummy heads would work"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It would, but then try this one, where you should come up with an O(n) timen and O(1) space solution: https://leetcode.com/problems/odd-even-linked-list/"
                    },
                    {
                        "username": "shevartsoft",
                        "content": "Thank you leetCode, with tickets like this I see the light on the end of my learning way!"
                    },
                    {
                        "username": "RupinderKaur484",
                        "content": "So , I was confused about the statement  at first, basically all the numbers less than x should be before x, and the sequence of the rest (the numbers greater than or equal to x) should be unchanged."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "the relative sequence of the numbers smaller than x should also remain the same as in the original list"
                    },
                    {
                        "username": "raviprajapatikandari",
                        "content": "problem say-> \\nfirst check less then x (head.val<x) value  and store a new list .\\n& again check greater then or equle  x (head.val>=x) value  and connect previous list."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Then try this one as a follow up, where you should come up with an O(n) timen and O(1) space solution: https://leetcode.com/problems/odd-even-linked-list/"
                    },
                    {
                        "username": "chinmaykothe98",
                        "content": "Hello All!\\nThis is my approach\\n\\n1. Create a new list with value -1;\\n2. First loop on the Linked list and keep adding the elements less than value \\'x\\'\\n3. Loop on the LL again and now keep adding the elements greater than and equal to value \\'x\\' in the same list.\\n4. Return the list\\n\\nI hope this help you all. Thanks...!!!"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "For the test case - [3,6,5,2,4,8,1,7], target = 4\\nExpected answer is - [3,2,1,6,5,4,8,7]\\n\\nWhy 2\\'s position is changed, if it is less than target and is in left of it?\\n\\nSolution :-\\nA: Numbers less than 4 (in input order) = [3, 2, 1]\\nB: Numbers greater than or equal to 4 (in input order) = [6, 5, 4, 8, 7]\\nA + B = [3, 2, 1, 6, 5, 4, 8, 7]"
                    },
                    {
                        "username": "deusdev",
                        "content": "I still remember the time when I couldn\\'t make any linked list problems without seeing any solutions first. I still have to improve the efficiency, but it feels good that I can do it now :D"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Me too, I HATED linked lists, just didn\\'t understand them at all. I still don\\'t like them but did manage to pass on the first go in reasonable time :) "
                    },
                    {
                        "username": "Utsarg",
                        "content": "Works fine like this , but gives runtime error when , dummy1=node1, dummy2=node2, is written, on 5th and 6th line, instead of node1=dummy1;  node2=dummy2; . Why is this happening, how does it make a difference??\\n\\n\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode *dummy1= new ListNode(0), *dummy2=new ListNode(0),*node1,*node2;\\n        node1=dummy1;\\n        node2=dummy2;\\n\\n        while(head)\\n        {\\n            if(head->val<x){\\n            node1->next=head;\\n            node1=node1->next;\\n        }\\n        else\\n        {\\n            node2->next=head;\\n            node2=node2->next;\\n        }\\n        \\n        head=head->next;\\n        }\\n\\n        node2->next=NULL;\\n        node1->next=dummy2->next;\\n        return dummy1->next;\\n    }\\n};\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 2015407,
                "content": [
                    {
                        "username": "SubomiSultan",
                        "content": "whenever i click submit it gives an error and says solution is not defined im using python 3"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "What a Joke is this TestCase ? \\n\\n\\nInput\\nhead =\\n[1,4,3,0,2,5,2]\\nx =\\n3\\n\\nUse Testcase\\nOutput\\n[0,1,2,2,4,3,5]\\nExpected\\n[1,0,2,2,4,3,5]"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@Gauravkr007](/Gauravkr007) The relative order in a partition order should remain the same, but all numbers smaller than x should come before all the numbers larger than x. Those will be your two partitions.\\nSo 0 and 2 get pulled to the front. But all other numbers keep the same order."
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "[@Mister_CK](/Mister_CK) then why 0 and 2 came before 4 if relative order should remain same."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "why do change the order of 1 and 0. The relative order should remain the same as it occurs in the original list"
                    },
                    {
                        "username": "layyy",
                        "content": "Taking two lists and two dummy heads would work"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It would, but then try this one, where you should come up with an O(n) timen and O(1) space solution: https://leetcode.com/problems/odd-even-linked-list/"
                    },
                    {
                        "username": "shevartsoft",
                        "content": "Thank you leetCode, with tickets like this I see the light on the end of my learning way!"
                    },
                    {
                        "username": "RupinderKaur484",
                        "content": "So , I was confused about the statement  at first, basically all the numbers less than x should be before x, and the sequence of the rest (the numbers greater than or equal to x) should be unchanged."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "the relative sequence of the numbers smaller than x should also remain the same as in the original list"
                    },
                    {
                        "username": "raviprajapatikandari",
                        "content": "problem say-> \\nfirst check less then x (head.val<x) value  and store a new list .\\n& again check greater then or equle  x (head.val>=x) value  and connect previous list."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Then try this one as a follow up, where you should come up with an O(n) timen and O(1) space solution: https://leetcode.com/problems/odd-even-linked-list/"
                    },
                    {
                        "username": "chinmaykothe98",
                        "content": "Hello All!\\nThis is my approach\\n\\n1. Create a new list with value -1;\\n2. First loop on the Linked list and keep adding the elements less than value \\'x\\'\\n3. Loop on the LL again and now keep adding the elements greater than and equal to value \\'x\\' in the same list.\\n4. Return the list\\n\\nI hope this help you all. Thanks...!!!"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "For the test case - [3,6,5,2,4,8,1,7], target = 4\\nExpected answer is - [3,2,1,6,5,4,8,7]\\n\\nWhy 2\\'s position is changed, if it is less than target and is in left of it?\\n\\nSolution :-\\nA: Numbers less than 4 (in input order) = [3, 2, 1]\\nB: Numbers greater than or equal to 4 (in input order) = [6, 5, 4, 8, 7]\\nA + B = [3, 2, 1, 6, 5, 4, 8, 7]"
                    },
                    {
                        "username": "deusdev",
                        "content": "I still remember the time when I couldn\\'t make any linked list problems without seeing any solutions first. I still have to improve the efficiency, but it feels good that I can do it now :D"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Me too, I HATED linked lists, just didn\\'t understand them at all. I still don\\'t like them but did manage to pass on the first go in reasonable time :) "
                    },
                    {
                        "username": "Utsarg",
                        "content": "Works fine like this , but gives runtime error when , dummy1=node1, dummy2=node2, is written, on 5th and 6th line, instead of node1=dummy1;  node2=dummy2; . Why is this happening, how does it make a difference??\\n\\n\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode *dummy1= new ListNode(0), *dummy2=new ListNode(0),*node1,*node2;\\n        node1=dummy1;\\n        node2=dummy2;\\n\\n        while(head)\\n        {\\n            if(head->val<x){\\n            node1->next=head;\\n            node1=node1->next;\\n        }\\n        else\\n        {\\n            node2->next=head;\\n            node2=node2->next;\\n        }\\n        \\n        head=head->next;\\n        }\\n\\n        node2->next=NULL;\\n        node1->next=dummy2->next;\\n        return dummy1->next;\\n    }\\n};\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 2015330,
                "content": [
                    {
                        "username": "dikshawali",
                        "content": "________listOfNodes=[2,2]\\n________temp2=head\\n________i=0\\n________while i<len(listOfNodes) and temp2 is not None:\\n____________if temp2.val<=listOfNodes[i]:\\n________________t3=deepcopy(temp2)\\n________________temp2=temp2.next\\n____________elif temp2.val>listOfNodes[i]:\\n________________newNode=ListNode()\\n////////////////newNode.next=t3.next\\n________________t3.next=newNode\\n________________i+=1\\n________________temp2=temp2.next\\n\\nWhy the /// comment is causing the function to run 2 times?  Can anyone please explain. listOfNodes are all the smallest nodes present at the right of the x. i have put _ because it was not allowing indentation in comments."
                    },
                    {
                        "username": "aditi61",
                        "content": "Line 15: Char 16: runtime error: member access within misaligned address 0x00000000000d for type \\'ListNode\\', which requires 8 byte alignment (__ListNodeUtils__.cpp)\\n0x00000000000d: note: pointer points here\\n<memory cannot be printed>\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior __ListNodeUtils__.cpp:24:16 I am getting this error anyone knows the reason?\\n\\nListNode* partition(ListNode* head, int x) {\\n        vector<int>smaller;\\n        vector<int>greater;\\n        ListNode* curr = head;\\n        while(curr){\\n            if(curr->val>=x) greater.push_back(curr->val);\\n            else smaller.push_back(curr->val);\\n            curr= curr->next;\\n        }\\n        for(int i=0;i<greater.size();i++){\\n            smaller.push_back(greater[i]);\\n        }\\n        ListNode* ans;\\n        ListNode* temp = ans;\\n      for(int i=0;i<smaller.size();i++){\\n            temp= new ListNode(smaller[i]);\\n            temp = temp->next;\\n            \\n        }\\n        return ans;\\n\\n        \\n    }"
                    },
                    {
                        "username": "samarth-singh-thakur",
                        "content": "I found implementation confusing. :("
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Happy Independence Day \\uD83D\\uDD05"
                    },
                    {
                        "username": "saibhagyaram",
                        "content": "ListNode* partition(ListNode* head, int x) {\\n        if(head  == NULL || head->next == NULL) return head;\\n        ListNode *temp = head,*prev = head ,*temp1=head;\\n        temp = temp->next;\\n        while(temp != NULL){\\n            if(temp->val >= x){\\n                temp1 = temp;\\n                temp = temp->next;\\n            }\\n            else{\\n                temp1->next = temp->next;\\n                temp->next = prev->next;\\n                prev->next = temp;\\n                prev = prev->next;\\n                temp=temp1->next;\\n            }\\n        }\\n        return head;\\n    }\\n\\nwhy it is  giving TLE !!!!\\ncan anyone tell me where it went wrong"
                    },
                    {
                        "username": "imtiaj007",
                        "content": "The description is pretty much tricky and examples are not very much sufficient. It took me 4 wrong submissions to understand the problem. Actually the problem is -\\n\\nCheck from the starting node, if the node is less than X then, place it before the nodes that are greater than or equal to X. And one thing to keep in mind you must maintain the relative order of the nodes even if some node values are smaller than previous nodes.\\n\\nHere are some example test cases for your reference - \\n\\n`1 -> 4 -> 3-> 2-> 5 -> 2`     ----  k = 3  ----      `1 -> 2 -> 2 -> 4 -> 3 -> 5`\\n`1 -> 4 -> 3-> 0-> 5 -> 2`     ----  k = 2  ----      `1 -> 0 -> 4 -> 3 -> 5 -> 2`\\n`1 -> 4 -> 3-> 0-> 5 -> 2 -> 1`    ----  k = 2  ----      `1 -> 0 -> 1 -> 4 -> 3 -> 5 -> 2`\\n`1 -> 4 -> 3-> 1-> 5 -> 2 -> 0`    ----  k = 2  ----      `1 -> 1 -> 0 -> 4 -> 3 -> 5 -> 2`\\n`4 -> 8 -> 6-> 5-> 1 -> 7 -> 2`    ----  k = 5  ----      `4 -> 1 -> 2 -> 8 -> 6 -> 5 -> 7`\\n\\nHope this will be helpful....... If you like please upvote.......!!!!!!"
                    },
                    {
                        "username": "vrajeshrs",
                        "content": "[4,3,2,5,2]\\nx =3\\nhere x = 3 and on right hand side we have 2 , 5 , 2\\nnow preserving order ans will be\\n[4,2,2,3,5]\\nexpected answer is : [2,2,4,3,5] .. how this preserve order ???"
                    },
                    {
                        "username": "rashapredator",
                        "content": "Input: head = [1,4,3,2,5,2], x = 3\\nOutput: [1,2,2,4,3,5]\\n\\nIs sol [2, 2, 1, 4, 3, 5] correct?"
                    },
                    {
                        "username": "rahil1202",
                        "content": "Here, we start by defining the ListNode structure which is a basic structure for a singly-linked list node.\\nThe Solution class contains the partition function, which takes the head of the linked list and the value x as inputs.\\n\\nWe create two dummy nodes, lessDummy and greaterDummy, to serve as the heads of the partitions for nodes less than x and nodes greater than or equal to x.\\nlessCurrent and greaterCurrent are pointers that will keep track of the current positions in their respective partitions.\\n\\nIn this loop, we iterate through the original linked list pointed to by head.\\nIf the current node\\'s value is less than x, we update lessCurrent to point to the current node and also update its next pointer to the current node. This effectively adds the current node to the \"less than x\" partition.\\n\\nIf the current node\\'s value is greater than or equal to x, we do the same for the greaterCurrent and the \"greater than or equal to x\" partition.\\nThe code combines the pointer assignment and node connection steps into a single line to optimize the process.\\n\\nAfter the loop completes, we need to connect the two partitions.\\nWe set the next pointer of greaterCurrent (last node in the \"greater than or equal to x\" partition) to nullptr to terminate the end of that partition.\\n\\nThen, we set the next pointer of lessCurrent (last node in the \"less than x\" partition) to point to the beginning of the \"greater than or equal to x\" partition.\\n\\nFinally, we return lessDummy.next, which is the head of the linked list containing the partitioned nodes.\\n"
                    },
                    {
                        "username": "Divyanshuagarwal23",
                        "content": "very easy "
                    }
                ]
            },
            {
                "id": 2015311,
                "content": [
                    {
                        "username": "dikshawali",
                        "content": "________listOfNodes=[2,2]\\n________temp2=head\\n________i=0\\n________while i<len(listOfNodes) and temp2 is not None:\\n____________if temp2.val<=listOfNodes[i]:\\n________________t3=deepcopy(temp2)\\n________________temp2=temp2.next\\n____________elif temp2.val>listOfNodes[i]:\\n________________newNode=ListNode()\\n////////////////newNode.next=t3.next\\n________________t3.next=newNode\\n________________i+=1\\n________________temp2=temp2.next\\n\\nWhy the /// comment is causing the function to run 2 times?  Can anyone please explain. listOfNodes are all the smallest nodes present at the right of the x. i have put _ because it was not allowing indentation in comments."
                    },
                    {
                        "username": "aditi61",
                        "content": "Line 15: Char 16: runtime error: member access within misaligned address 0x00000000000d for type \\'ListNode\\', which requires 8 byte alignment (__ListNodeUtils__.cpp)\\n0x00000000000d: note: pointer points here\\n<memory cannot be printed>\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior __ListNodeUtils__.cpp:24:16 I am getting this error anyone knows the reason?\\n\\nListNode* partition(ListNode* head, int x) {\\n        vector<int>smaller;\\n        vector<int>greater;\\n        ListNode* curr = head;\\n        while(curr){\\n            if(curr->val>=x) greater.push_back(curr->val);\\n            else smaller.push_back(curr->val);\\n            curr= curr->next;\\n        }\\n        for(int i=0;i<greater.size();i++){\\n            smaller.push_back(greater[i]);\\n        }\\n        ListNode* ans;\\n        ListNode* temp = ans;\\n      for(int i=0;i<smaller.size();i++){\\n            temp= new ListNode(smaller[i]);\\n            temp = temp->next;\\n            \\n        }\\n        return ans;\\n\\n        \\n    }"
                    },
                    {
                        "username": "samarth-singh-thakur",
                        "content": "I found implementation confusing. :("
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Happy Independence Day \\uD83D\\uDD05"
                    },
                    {
                        "username": "saibhagyaram",
                        "content": "ListNode* partition(ListNode* head, int x) {\\n        if(head  == NULL || head->next == NULL) return head;\\n        ListNode *temp = head,*prev = head ,*temp1=head;\\n        temp = temp->next;\\n        while(temp != NULL){\\n            if(temp->val >= x){\\n                temp1 = temp;\\n                temp = temp->next;\\n            }\\n            else{\\n                temp1->next = temp->next;\\n                temp->next = prev->next;\\n                prev->next = temp;\\n                prev = prev->next;\\n                temp=temp1->next;\\n            }\\n        }\\n        return head;\\n    }\\n\\nwhy it is  giving TLE !!!!\\ncan anyone tell me where it went wrong"
                    },
                    {
                        "username": "imtiaj007",
                        "content": "The description is pretty much tricky and examples are not very much sufficient. It took me 4 wrong submissions to understand the problem. Actually the problem is -\\n\\nCheck from the starting node, if the node is less than X then, place it before the nodes that are greater than or equal to X. And one thing to keep in mind you must maintain the relative order of the nodes even if some node values are smaller than previous nodes.\\n\\nHere are some example test cases for your reference - \\n\\n`1 -> 4 -> 3-> 2-> 5 -> 2`     ----  k = 3  ----      `1 -> 2 -> 2 -> 4 -> 3 -> 5`\\n`1 -> 4 -> 3-> 0-> 5 -> 2`     ----  k = 2  ----      `1 -> 0 -> 4 -> 3 -> 5 -> 2`\\n`1 -> 4 -> 3-> 0-> 5 -> 2 -> 1`    ----  k = 2  ----      `1 -> 0 -> 1 -> 4 -> 3 -> 5 -> 2`\\n`1 -> 4 -> 3-> 1-> 5 -> 2 -> 0`    ----  k = 2  ----      `1 -> 1 -> 0 -> 4 -> 3 -> 5 -> 2`\\n`4 -> 8 -> 6-> 5-> 1 -> 7 -> 2`    ----  k = 5  ----      `4 -> 1 -> 2 -> 8 -> 6 -> 5 -> 7`\\n\\nHope this will be helpful....... If you like please upvote.......!!!!!!"
                    },
                    {
                        "username": "vrajeshrs",
                        "content": "[4,3,2,5,2]\\nx =3\\nhere x = 3 and on right hand side we have 2 , 5 , 2\\nnow preserving order ans will be\\n[4,2,2,3,5]\\nexpected answer is : [2,2,4,3,5] .. how this preserve order ???"
                    },
                    {
                        "username": "rashapredator",
                        "content": "Input: head = [1,4,3,2,5,2], x = 3\\nOutput: [1,2,2,4,3,5]\\n\\nIs sol [2, 2, 1, 4, 3, 5] correct?"
                    },
                    {
                        "username": "rahil1202",
                        "content": "Here, we start by defining the ListNode structure which is a basic structure for a singly-linked list node.\\nThe Solution class contains the partition function, which takes the head of the linked list and the value x as inputs.\\n\\nWe create two dummy nodes, lessDummy and greaterDummy, to serve as the heads of the partitions for nodes less than x and nodes greater than or equal to x.\\nlessCurrent and greaterCurrent are pointers that will keep track of the current positions in their respective partitions.\\n\\nIn this loop, we iterate through the original linked list pointed to by head.\\nIf the current node\\'s value is less than x, we update lessCurrent to point to the current node and also update its next pointer to the current node. This effectively adds the current node to the \"less than x\" partition.\\n\\nIf the current node\\'s value is greater than or equal to x, we do the same for the greaterCurrent and the \"greater than or equal to x\" partition.\\nThe code combines the pointer assignment and node connection steps into a single line to optimize the process.\\n\\nAfter the loop completes, we need to connect the two partitions.\\nWe set the next pointer of greaterCurrent (last node in the \"greater than or equal to x\" partition) to nullptr to terminate the end of that partition.\\n\\nThen, we set the next pointer of lessCurrent (last node in the \"less than x\" partition) to point to the beginning of the \"greater than or equal to x\" partition.\\n\\nFinally, we return lessDummy.next, which is the head of the linked list containing the partitioned nodes.\\n"
                    },
                    {
                        "username": "Divyanshuagarwal23",
                        "content": "very easy "
                    }
                ]
            },
            {
                "id": 2015230,
                "content": [
                    {
                        "username": "dikshawali",
                        "content": "________listOfNodes=[2,2]\\n________temp2=head\\n________i=0\\n________while i<len(listOfNodes) and temp2 is not None:\\n____________if temp2.val<=listOfNodes[i]:\\n________________t3=deepcopy(temp2)\\n________________temp2=temp2.next\\n____________elif temp2.val>listOfNodes[i]:\\n________________newNode=ListNode()\\n////////////////newNode.next=t3.next\\n________________t3.next=newNode\\n________________i+=1\\n________________temp2=temp2.next\\n\\nWhy the /// comment is causing the function to run 2 times?  Can anyone please explain. listOfNodes are all the smallest nodes present at the right of the x. i have put _ because it was not allowing indentation in comments."
                    },
                    {
                        "username": "aditi61",
                        "content": "Line 15: Char 16: runtime error: member access within misaligned address 0x00000000000d for type \\'ListNode\\', which requires 8 byte alignment (__ListNodeUtils__.cpp)\\n0x00000000000d: note: pointer points here\\n<memory cannot be printed>\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior __ListNodeUtils__.cpp:24:16 I am getting this error anyone knows the reason?\\n\\nListNode* partition(ListNode* head, int x) {\\n        vector<int>smaller;\\n        vector<int>greater;\\n        ListNode* curr = head;\\n        while(curr){\\n            if(curr->val>=x) greater.push_back(curr->val);\\n            else smaller.push_back(curr->val);\\n            curr= curr->next;\\n        }\\n        for(int i=0;i<greater.size();i++){\\n            smaller.push_back(greater[i]);\\n        }\\n        ListNode* ans;\\n        ListNode* temp = ans;\\n      for(int i=0;i<smaller.size();i++){\\n            temp= new ListNode(smaller[i]);\\n            temp = temp->next;\\n            \\n        }\\n        return ans;\\n\\n        \\n    }"
                    },
                    {
                        "username": "samarth-singh-thakur",
                        "content": "I found implementation confusing. :("
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Happy Independence Day \\uD83D\\uDD05"
                    },
                    {
                        "username": "saibhagyaram",
                        "content": "ListNode* partition(ListNode* head, int x) {\\n        if(head  == NULL || head->next == NULL) return head;\\n        ListNode *temp = head,*prev = head ,*temp1=head;\\n        temp = temp->next;\\n        while(temp != NULL){\\n            if(temp->val >= x){\\n                temp1 = temp;\\n                temp = temp->next;\\n            }\\n            else{\\n                temp1->next = temp->next;\\n                temp->next = prev->next;\\n                prev->next = temp;\\n                prev = prev->next;\\n                temp=temp1->next;\\n            }\\n        }\\n        return head;\\n    }\\n\\nwhy it is  giving TLE !!!!\\ncan anyone tell me where it went wrong"
                    },
                    {
                        "username": "imtiaj007",
                        "content": "The description is pretty much tricky and examples are not very much sufficient. It took me 4 wrong submissions to understand the problem. Actually the problem is -\\n\\nCheck from the starting node, if the node is less than X then, place it before the nodes that are greater than or equal to X. And one thing to keep in mind you must maintain the relative order of the nodes even if some node values are smaller than previous nodes.\\n\\nHere are some example test cases for your reference - \\n\\n`1 -> 4 -> 3-> 2-> 5 -> 2`     ----  k = 3  ----      `1 -> 2 -> 2 -> 4 -> 3 -> 5`\\n`1 -> 4 -> 3-> 0-> 5 -> 2`     ----  k = 2  ----      `1 -> 0 -> 4 -> 3 -> 5 -> 2`\\n`1 -> 4 -> 3-> 0-> 5 -> 2 -> 1`    ----  k = 2  ----      `1 -> 0 -> 1 -> 4 -> 3 -> 5 -> 2`\\n`1 -> 4 -> 3-> 1-> 5 -> 2 -> 0`    ----  k = 2  ----      `1 -> 1 -> 0 -> 4 -> 3 -> 5 -> 2`\\n`4 -> 8 -> 6-> 5-> 1 -> 7 -> 2`    ----  k = 5  ----      `4 -> 1 -> 2 -> 8 -> 6 -> 5 -> 7`\\n\\nHope this will be helpful....... If you like please upvote.......!!!!!!"
                    },
                    {
                        "username": "vrajeshrs",
                        "content": "[4,3,2,5,2]\\nx =3\\nhere x = 3 and on right hand side we have 2 , 5 , 2\\nnow preserving order ans will be\\n[4,2,2,3,5]\\nexpected answer is : [2,2,4,3,5] .. how this preserve order ???"
                    },
                    {
                        "username": "rashapredator",
                        "content": "Input: head = [1,4,3,2,5,2], x = 3\\nOutput: [1,2,2,4,3,5]\\n\\nIs sol [2, 2, 1, 4, 3, 5] correct?"
                    },
                    {
                        "username": "rahil1202",
                        "content": "Here, we start by defining the ListNode structure which is a basic structure for a singly-linked list node.\\nThe Solution class contains the partition function, which takes the head of the linked list and the value x as inputs.\\n\\nWe create two dummy nodes, lessDummy and greaterDummy, to serve as the heads of the partitions for nodes less than x and nodes greater than or equal to x.\\nlessCurrent and greaterCurrent are pointers that will keep track of the current positions in their respective partitions.\\n\\nIn this loop, we iterate through the original linked list pointed to by head.\\nIf the current node\\'s value is less than x, we update lessCurrent to point to the current node and also update its next pointer to the current node. This effectively adds the current node to the \"less than x\" partition.\\n\\nIf the current node\\'s value is greater than or equal to x, we do the same for the greaterCurrent and the \"greater than or equal to x\" partition.\\nThe code combines the pointer assignment and node connection steps into a single line to optimize the process.\\n\\nAfter the loop completes, we need to connect the two partitions.\\nWe set the next pointer of greaterCurrent (last node in the \"greater than or equal to x\" partition) to nullptr to terminate the end of that partition.\\n\\nThen, we set the next pointer of lessCurrent (last node in the \"less than x\" partition) to point to the beginning of the \"greater than or equal to x\" partition.\\n\\nFinally, we return lessDummy.next, which is the head of the linked list containing the partitioned nodes.\\n"
                    },
                    {
                        "username": "Divyanshuagarwal23",
                        "content": "very easy "
                    }
                ]
            },
            {
                "id": 2015215,
                "content": [
                    {
                        "username": "dikshawali",
                        "content": "________listOfNodes=[2,2]\\n________temp2=head\\n________i=0\\n________while i<len(listOfNodes) and temp2 is not None:\\n____________if temp2.val<=listOfNodes[i]:\\n________________t3=deepcopy(temp2)\\n________________temp2=temp2.next\\n____________elif temp2.val>listOfNodes[i]:\\n________________newNode=ListNode()\\n////////////////newNode.next=t3.next\\n________________t3.next=newNode\\n________________i+=1\\n________________temp2=temp2.next\\n\\nWhy the /// comment is causing the function to run 2 times?  Can anyone please explain. listOfNodes are all the smallest nodes present at the right of the x. i have put _ because it was not allowing indentation in comments."
                    },
                    {
                        "username": "aditi61",
                        "content": "Line 15: Char 16: runtime error: member access within misaligned address 0x00000000000d for type \\'ListNode\\', which requires 8 byte alignment (__ListNodeUtils__.cpp)\\n0x00000000000d: note: pointer points here\\n<memory cannot be printed>\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior __ListNodeUtils__.cpp:24:16 I am getting this error anyone knows the reason?\\n\\nListNode* partition(ListNode* head, int x) {\\n        vector<int>smaller;\\n        vector<int>greater;\\n        ListNode* curr = head;\\n        while(curr){\\n            if(curr->val>=x) greater.push_back(curr->val);\\n            else smaller.push_back(curr->val);\\n            curr= curr->next;\\n        }\\n        for(int i=0;i<greater.size();i++){\\n            smaller.push_back(greater[i]);\\n        }\\n        ListNode* ans;\\n        ListNode* temp = ans;\\n      for(int i=0;i<smaller.size();i++){\\n            temp= new ListNode(smaller[i]);\\n            temp = temp->next;\\n            \\n        }\\n        return ans;\\n\\n        \\n    }"
                    },
                    {
                        "username": "samarth-singh-thakur",
                        "content": "I found implementation confusing. :("
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Happy Independence Day \\uD83D\\uDD05"
                    },
                    {
                        "username": "saibhagyaram",
                        "content": "ListNode* partition(ListNode* head, int x) {\\n        if(head  == NULL || head->next == NULL) return head;\\n        ListNode *temp = head,*prev = head ,*temp1=head;\\n        temp = temp->next;\\n        while(temp != NULL){\\n            if(temp->val >= x){\\n                temp1 = temp;\\n                temp = temp->next;\\n            }\\n            else{\\n                temp1->next = temp->next;\\n                temp->next = prev->next;\\n                prev->next = temp;\\n                prev = prev->next;\\n                temp=temp1->next;\\n            }\\n        }\\n        return head;\\n    }\\n\\nwhy it is  giving TLE !!!!\\ncan anyone tell me where it went wrong"
                    },
                    {
                        "username": "imtiaj007",
                        "content": "The description is pretty much tricky and examples are not very much sufficient. It took me 4 wrong submissions to understand the problem. Actually the problem is -\\n\\nCheck from the starting node, if the node is less than X then, place it before the nodes that are greater than or equal to X. And one thing to keep in mind you must maintain the relative order of the nodes even if some node values are smaller than previous nodes.\\n\\nHere are some example test cases for your reference - \\n\\n`1 -> 4 -> 3-> 2-> 5 -> 2`     ----  k = 3  ----      `1 -> 2 -> 2 -> 4 -> 3 -> 5`\\n`1 -> 4 -> 3-> 0-> 5 -> 2`     ----  k = 2  ----      `1 -> 0 -> 4 -> 3 -> 5 -> 2`\\n`1 -> 4 -> 3-> 0-> 5 -> 2 -> 1`    ----  k = 2  ----      `1 -> 0 -> 1 -> 4 -> 3 -> 5 -> 2`\\n`1 -> 4 -> 3-> 1-> 5 -> 2 -> 0`    ----  k = 2  ----      `1 -> 1 -> 0 -> 4 -> 3 -> 5 -> 2`\\n`4 -> 8 -> 6-> 5-> 1 -> 7 -> 2`    ----  k = 5  ----      `4 -> 1 -> 2 -> 8 -> 6 -> 5 -> 7`\\n\\nHope this will be helpful....... If you like please upvote.......!!!!!!"
                    },
                    {
                        "username": "vrajeshrs",
                        "content": "[4,3,2,5,2]\\nx =3\\nhere x = 3 and on right hand side we have 2 , 5 , 2\\nnow preserving order ans will be\\n[4,2,2,3,5]\\nexpected answer is : [2,2,4,3,5] .. how this preserve order ???"
                    },
                    {
                        "username": "rashapredator",
                        "content": "Input: head = [1,4,3,2,5,2], x = 3\\nOutput: [1,2,2,4,3,5]\\n\\nIs sol [2, 2, 1, 4, 3, 5] correct?"
                    },
                    {
                        "username": "rahil1202",
                        "content": "Here, we start by defining the ListNode structure which is a basic structure for a singly-linked list node.\\nThe Solution class contains the partition function, which takes the head of the linked list and the value x as inputs.\\n\\nWe create two dummy nodes, lessDummy and greaterDummy, to serve as the heads of the partitions for nodes less than x and nodes greater than or equal to x.\\nlessCurrent and greaterCurrent are pointers that will keep track of the current positions in their respective partitions.\\n\\nIn this loop, we iterate through the original linked list pointed to by head.\\nIf the current node\\'s value is less than x, we update lessCurrent to point to the current node and also update its next pointer to the current node. This effectively adds the current node to the \"less than x\" partition.\\n\\nIf the current node\\'s value is greater than or equal to x, we do the same for the greaterCurrent and the \"greater than or equal to x\" partition.\\nThe code combines the pointer assignment and node connection steps into a single line to optimize the process.\\n\\nAfter the loop completes, we need to connect the two partitions.\\nWe set the next pointer of greaterCurrent (last node in the \"greater than or equal to x\" partition) to nullptr to terminate the end of that partition.\\n\\nThen, we set the next pointer of lessCurrent (last node in the \"less than x\" partition) to point to the beginning of the \"greater than or equal to x\" partition.\\n\\nFinally, we return lessDummy.next, which is the head of the linked list containing the partitioned nodes.\\n"
                    },
                    {
                        "username": "Divyanshuagarwal23",
                        "content": "very easy "
                    }
                ]
            },
            {
                "id": 2015202,
                "content": [
                    {
                        "username": "dikshawali",
                        "content": "________listOfNodes=[2,2]\\n________temp2=head\\n________i=0\\n________while i<len(listOfNodes) and temp2 is not None:\\n____________if temp2.val<=listOfNodes[i]:\\n________________t3=deepcopy(temp2)\\n________________temp2=temp2.next\\n____________elif temp2.val>listOfNodes[i]:\\n________________newNode=ListNode()\\n////////////////newNode.next=t3.next\\n________________t3.next=newNode\\n________________i+=1\\n________________temp2=temp2.next\\n\\nWhy the /// comment is causing the function to run 2 times?  Can anyone please explain. listOfNodes are all the smallest nodes present at the right of the x. i have put _ because it was not allowing indentation in comments."
                    },
                    {
                        "username": "aditi61",
                        "content": "Line 15: Char 16: runtime error: member access within misaligned address 0x00000000000d for type \\'ListNode\\', which requires 8 byte alignment (__ListNodeUtils__.cpp)\\n0x00000000000d: note: pointer points here\\n<memory cannot be printed>\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior __ListNodeUtils__.cpp:24:16 I am getting this error anyone knows the reason?\\n\\nListNode* partition(ListNode* head, int x) {\\n        vector<int>smaller;\\n        vector<int>greater;\\n        ListNode* curr = head;\\n        while(curr){\\n            if(curr->val>=x) greater.push_back(curr->val);\\n            else smaller.push_back(curr->val);\\n            curr= curr->next;\\n        }\\n        for(int i=0;i<greater.size();i++){\\n            smaller.push_back(greater[i]);\\n        }\\n        ListNode* ans;\\n        ListNode* temp = ans;\\n      for(int i=0;i<smaller.size();i++){\\n            temp= new ListNode(smaller[i]);\\n            temp = temp->next;\\n            \\n        }\\n        return ans;\\n\\n        \\n    }"
                    },
                    {
                        "username": "samarth-singh-thakur",
                        "content": "I found implementation confusing. :("
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Happy Independence Day \\uD83D\\uDD05"
                    },
                    {
                        "username": "saibhagyaram",
                        "content": "ListNode* partition(ListNode* head, int x) {\\n        if(head  == NULL || head->next == NULL) return head;\\n        ListNode *temp = head,*prev = head ,*temp1=head;\\n        temp = temp->next;\\n        while(temp != NULL){\\n            if(temp->val >= x){\\n                temp1 = temp;\\n                temp = temp->next;\\n            }\\n            else{\\n                temp1->next = temp->next;\\n                temp->next = prev->next;\\n                prev->next = temp;\\n                prev = prev->next;\\n                temp=temp1->next;\\n            }\\n        }\\n        return head;\\n    }\\n\\nwhy it is  giving TLE !!!!\\ncan anyone tell me where it went wrong"
                    },
                    {
                        "username": "imtiaj007",
                        "content": "The description is pretty much tricky and examples are not very much sufficient. It took me 4 wrong submissions to understand the problem. Actually the problem is -\\n\\nCheck from the starting node, if the node is less than X then, place it before the nodes that are greater than or equal to X. And one thing to keep in mind you must maintain the relative order of the nodes even if some node values are smaller than previous nodes.\\n\\nHere are some example test cases for your reference - \\n\\n`1 -> 4 -> 3-> 2-> 5 -> 2`     ----  k = 3  ----      `1 -> 2 -> 2 -> 4 -> 3 -> 5`\\n`1 -> 4 -> 3-> 0-> 5 -> 2`     ----  k = 2  ----      `1 -> 0 -> 4 -> 3 -> 5 -> 2`\\n`1 -> 4 -> 3-> 0-> 5 -> 2 -> 1`    ----  k = 2  ----      `1 -> 0 -> 1 -> 4 -> 3 -> 5 -> 2`\\n`1 -> 4 -> 3-> 1-> 5 -> 2 -> 0`    ----  k = 2  ----      `1 -> 1 -> 0 -> 4 -> 3 -> 5 -> 2`\\n`4 -> 8 -> 6-> 5-> 1 -> 7 -> 2`    ----  k = 5  ----      `4 -> 1 -> 2 -> 8 -> 6 -> 5 -> 7`\\n\\nHope this will be helpful....... If you like please upvote.......!!!!!!"
                    },
                    {
                        "username": "vrajeshrs",
                        "content": "[4,3,2,5,2]\\nx =3\\nhere x = 3 and on right hand side we have 2 , 5 , 2\\nnow preserving order ans will be\\n[4,2,2,3,5]\\nexpected answer is : [2,2,4,3,5] .. how this preserve order ???"
                    },
                    {
                        "username": "rashapredator",
                        "content": "Input: head = [1,4,3,2,5,2], x = 3\\nOutput: [1,2,2,4,3,5]\\n\\nIs sol [2, 2, 1, 4, 3, 5] correct?"
                    },
                    {
                        "username": "rahil1202",
                        "content": "Here, we start by defining the ListNode structure which is a basic structure for a singly-linked list node.\\nThe Solution class contains the partition function, which takes the head of the linked list and the value x as inputs.\\n\\nWe create two dummy nodes, lessDummy and greaterDummy, to serve as the heads of the partitions for nodes less than x and nodes greater than or equal to x.\\nlessCurrent and greaterCurrent are pointers that will keep track of the current positions in their respective partitions.\\n\\nIn this loop, we iterate through the original linked list pointed to by head.\\nIf the current node\\'s value is less than x, we update lessCurrent to point to the current node and also update its next pointer to the current node. This effectively adds the current node to the \"less than x\" partition.\\n\\nIf the current node\\'s value is greater than or equal to x, we do the same for the greaterCurrent and the \"greater than or equal to x\" partition.\\nThe code combines the pointer assignment and node connection steps into a single line to optimize the process.\\n\\nAfter the loop completes, we need to connect the two partitions.\\nWe set the next pointer of greaterCurrent (last node in the \"greater than or equal to x\" partition) to nullptr to terminate the end of that partition.\\n\\nThen, we set the next pointer of lessCurrent (last node in the \"less than x\" partition) to point to the beginning of the \"greater than or equal to x\" partition.\\n\\nFinally, we return lessDummy.next, which is the head of the linked list containing the partitioned nodes.\\n"
                    },
                    {
                        "username": "Divyanshuagarwal23",
                        "content": "very easy "
                    }
                ]
            },
            {
                "id": 2015198,
                "content": [
                    {
                        "username": "dikshawali",
                        "content": "________listOfNodes=[2,2]\\n________temp2=head\\n________i=0\\n________while i<len(listOfNodes) and temp2 is not None:\\n____________if temp2.val<=listOfNodes[i]:\\n________________t3=deepcopy(temp2)\\n________________temp2=temp2.next\\n____________elif temp2.val>listOfNodes[i]:\\n________________newNode=ListNode()\\n////////////////newNode.next=t3.next\\n________________t3.next=newNode\\n________________i+=1\\n________________temp2=temp2.next\\n\\nWhy the /// comment is causing the function to run 2 times?  Can anyone please explain. listOfNodes are all the smallest nodes present at the right of the x. i have put _ because it was not allowing indentation in comments."
                    },
                    {
                        "username": "aditi61",
                        "content": "Line 15: Char 16: runtime error: member access within misaligned address 0x00000000000d for type \\'ListNode\\', which requires 8 byte alignment (__ListNodeUtils__.cpp)\\n0x00000000000d: note: pointer points here\\n<memory cannot be printed>\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior __ListNodeUtils__.cpp:24:16 I am getting this error anyone knows the reason?\\n\\nListNode* partition(ListNode* head, int x) {\\n        vector<int>smaller;\\n        vector<int>greater;\\n        ListNode* curr = head;\\n        while(curr){\\n            if(curr->val>=x) greater.push_back(curr->val);\\n            else smaller.push_back(curr->val);\\n            curr= curr->next;\\n        }\\n        for(int i=0;i<greater.size();i++){\\n            smaller.push_back(greater[i]);\\n        }\\n        ListNode* ans;\\n        ListNode* temp = ans;\\n      for(int i=0;i<smaller.size();i++){\\n            temp= new ListNode(smaller[i]);\\n            temp = temp->next;\\n            \\n        }\\n        return ans;\\n\\n        \\n    }"
                    },
                    {
                        "username": "samarth-singh-thakur",
                        "content": "I found implementation confusing. :("
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Happy Independence Day \\uD83D\\uDD05"
                    },
                    {
                        "username": "saibhagyaram",
                        "content": "ListNode* partition(ListNode* head, int x) {\\n        if(head  == NULL || head->next == NULL) return head;\\n        ListNode *temp = head,*prev = head ,*temp1=head;\\n        temp = temp->next;\\n        while(temp != NULL){\\n            if(temp->val >= x){\\n                temp1 = temp;\\n                temp = temp->next;\\n            }\\n            else{\\n                temp1->next = temp->next;\\n                temp->next = prev->next;\\n                prev->next = temp;\\n                prev = prev->next;\\n                temp=temp1->next;\\n            }\\n        }\\n        return head;\\n    }\\n\\nwhy it is  giving TLE !!!!\\ncan anyone tell me where it went wrong"
                    },
                    {
                        "username": "imtiaj007",
                        "content": "The description is pretty much tricky and examples are not very much sufficient. It took me 4 wrong submissions to understand the problem. Actually the problem is -\\n\\nCheck from the starting node, if the node is less than X then, place it before the nodes that are greater than or equal to X. And one thing to keep in mind you must maintain the relative order of the nodes even if some node values are smaller than previous nodes.\\n\\nHere are some example test cases for your reference - \\n\\n`1 -> 4 -> 3-> 2-> 5 -> 2`     ----  k = 3  ----      `1 -> 2 -> 2 -> 4 -> 3 -> 5`\\n`1 -> 4 -> 3-> 0-> 5 -> 2`     ----  k = 2  ----      `1 -> 0 -> 4 -> 3 -> 5 -> 2`\\n`1 -> 4 -> 3-> 0-> 5 -> 2 -> 1`    ----  k = 2  ----      `1 -> 0 -> 1 -> 4 -> 3 -> 5 -> 2`\\n`1 -> 4 -> 3-> 1-> 5 -> 2 -> 0`    ----  k = 2  ----      `1 -> 1 -> 0 -> 4 -> 3 -> 5 -> 2`\\n`4 -> 8 -> 6-> 5-> 1 -> 7 -> 2`    ----  k = 5  ----      `4 -> 1 -> 2 -> 8 -> 6 -> 5 -> 7`\\n\\nHope this will be helpful....... If you like please upvote.......!!!!!!"
                    },
                    {
                        "username": "vrajeshrs",
                        "content": "[4,3,2,5,2]\\nx =3\\nhere x = 3 and on right hand side we have 2 , 5 , 2\\nnow preserving order ans will be\\n[4,2,2,3,5]\\nexpected answer is : [2,2,4,3,5] .. how this preserve order ???"
                    },
                    {
                        "username": "rashapredator",
                        "content": "Input: head = [1,4,3,2,5,2], x = 3\\nOutput: [1,2,2,4,3,5]\\n\\nIs sol [2, 2, 1, 4, 3, 5] correct?"
                    },
                    {
                        "username": "rahil1202",
                        "content": "Here, we start by defining the ListNode structure which is a basic structure for a singly-linked list node.\\nThe Solution class contains the partition function, which takes the head of the linked list and the value x as inputs.\\n\\nWe create two dummy nodes, lessDummy and greaterDummy, to serve as the heads of the partitions for nodes less than x and nodes greater than or equal to x.\\nlessCurrent and greaterCurrent are pointers that will keep track of the current positions in their respective partitions.\\n\\nIn this loop, we iterate through the original linked list pointed to by head.\\nIf the current node\\'s value is less than x, we update lessCurrent to point to the current node and also update its next pointer to the current node. This effectively adds the current node to the \"less than x\" partition.\\n\\nIf the current node\\'s value is greater than or equal to x, we do the same for the greaterCurrent and the \"greater than or equal to x\" partition.\\nThe code combines the pointer assignment and node connection steps into a single line to optimize the process.\\n\\nAfter the loop completes, we need to connect the two partitions.\\nWe set the next pointer of greaterCurrent (last node in the \"greater than or equal to x\" partition) to nullptr to terminate the end of that partition.\\n\\nThen, we set the next pointer of lessCurrent (last node in the \"less than x\" partition) to point to the beginning of the \"greater than or equal to x\" partition.\\n\\nFinally, we return lessDummy.next, which is the head of the linked list containing the partitioned nodes.\\n"
                    },
                    {
                        "username": "Divyanshuagarwal23",
                        "content": "very easy "
                    }
                ]
            },
            {
                "id": 2015030,
                "content": [
                    {
                        "username": "dikshawali",
                        "content": "________listOfNodes=[2,2]\\n________temp2=head\\n________i=0\\n________while i<len(listOfNodes) and temp2 is not None:\\n____________if temp2.val<=listOfNodes[i]:\\n________________t3=deepcopy(temp2)\\n________________temp2=temp2.next\\n____________elif temp2.val>listOfNodes[i]:\\n________________newNode=ListNode()\\n////////////////newNode.next=t3.next\\n________________t3.next=newNode\\n________________i+=1\\n________________temp2=temp2.next\\n\\nWhy the /// comment is causing the function to run 2 times?  Can anyone please explain. listOfNodes are all the smallest nodes present at the right of the x. i have put _ because it was not allowing indentation in comments."
                    },
                    {
                        "username": "aditi61",
                        "content": "Line 15: Char 16: runtime error: member access within misaligned address 0x00000000000d for type \\'ListNode\\', which requires 8 byte alignment (__ListNodeUtils__.cpp)\\n0x00000000000d: note: pointer points here\\n<memory cannot be printed>\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior __ListNodeUtils__.cpp:24:16 I am getting this error anyone knows the reason?\\n\\nListNode* partition(ListNode* head, int x) {\\n        vector<int>smaller;\\n        vector<int>greater;\\n        ListNode* curr = head;\\n        while(curr){\\n            if(curr->val>=x) greater.push_back(curr->val);\\n            else smaller.push_back(curr->val);\\n            curr= curr->next;\\n        }\\n        for(int i=0;i<greater.size();i++){\\n            smaller.push_back(greater[i]);\\n        }\\n        ListNode* ans;\\n        ListNode* temp = ans;\\n      for(int i=0;i<smaller.size();i++){\\n            temp= new ListNode(smaller[i]);\\n            temp = temp->next;\\n            \\n        }\\n        return ans;\\n\\n        \\n    }"
                    },
                    {
                        "username": "samarth-singh-thakur",
                        "content": "I found implementation confusing. :("
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Happy Independence Day \\uD83D\\uDD05"
                    },
                    {
                        "username": "saibhagyaram",
                        "content": "ListNode* partition(ListNode* head, int x) {\\n        if(head  == NULL || head->next == NULL) return head;\\n        ListNode *temp = head,*prev = head ,*temp1=head;\\n        temp = temp->next;\\n        while(temp != NULL){\\n            if(temp->val >= x){\\n                temp1 = temp;\\n                temp = temp->next;\\n            }\\n            else{\\n                temp1->next = temp->next;\\n                temp->next = prev->next;\\n                prev->next = temp;\\n                prev = prev->next;\\n                temp=temp1->next;\\n            }\\n        }\\n        return head;\\n    }\\n\\nwhy it is  giving TLE !!!!\\ncan anyone tell me where it went wrong"
                    },
                    {
                        "username": "imtiaj007",
                        "content": "The description is pretty much tricky and examples are not very much sufficient. It took me 4 wrong submissions to understand the problem. Actually the problem is -\\n\\nCheck from the starting node, if the node is less than X then, place it before the nodes that are greater than or equal to X. And one thing to keep in mind you must maintain the relative order of the nodes even if some node values are smaller than previous nodes.\\n\\nHere are some example test cases for your reference - \\n\\n`1 -> 4 -> 3-> 2-> 5 -> 2`     ----  k = 3  ----      `1 -> 2 -> 2 -> 4 -> 3 -> 5`\\n`1 -> 4 -> 3-> 0-> 5 -> 2`     ----  k = 2  ----      `1 -> 0 -> 4 -> 3 -> 5 -> 2`\\n`1 -> 4 -> 3-> 0-> 5 -> 2 -> 1`    ----  k = 2  ----      `1 -> 0 -> 1 -> 4 -> 3 -> 5 -> 2`\\n`1 -> 4 -> 3-> 1-> 5 -> 2 -> 0`    ----  k = 2  ----      `1 -> 1 -> 0 -> 4 -> 3 -> 5 -> 2`\\n`4 -> 8 -> 6-> 5-> 1 -> 7 -> 2`    ----  k = 5  ----      `4 -> 1 -> 2 -> 8 -> 6 -> 5 -> 7`\\n\\nHope this will be helpful....... If you like please upvote.......!!!!!!"
                    },
                    {
                        "username": "vrajeshrs",
                        "content": "[4,3,2,5,2]\\nx =3\\nhere x = 3 and on right hand side we have 2 , 5 , 2\\nnow preserving order ans will be\\n[4,2,2,3,5]\\nexpected answer is : [2,2,4,3,5] .. how this preserve order ???"
                    },
                    {
                        "username": "rashapredator",
                        "content": "Input: head = [1,4,3,2,5,2], x = 3\\nOutput: [1,2,2,4,3,5]\\n\\nIs sol [2, 2, 1, 4, 3, 5] correct?"
                    },
                    {
                        "username": "rahil1202",
                        "content": "Here, we start by defining the ListNode structure which is a basic structure for a singly-linked list node.\\nThe Solution class contains the partition function, which takes the head of the linked list and the value x as inputs.\\n\\nWe create two dummy nodes, lessDummy and greaterDummy, to serve as the heads of the partitions for nodes less than x and nodes greater than or equal to x.\\nlessCurrent and greaterCurrent are pointers that will keep track of the current positions in their respective partitions.\\n\\nIn this loop, we iterate through the original linked list pointed to by head.\\nIf the current node\\'s value is less than x, we update lessCurrent to point to the current node and also update its next pointer to the current node. This effectively adds the current node to the \"less than x\" partition.\\n\\nIf the current node\\'s value is greater than or equal to x, we do the same for the greaterCurrent and the \"greater than or equal to x\" partition.\\nThe code combines the pointer assignment and node connection steps into a single line to optimize the process.\\n\\nAfter the loop completes, we need to connect the two partitions.\\nWe set the next pointer of greaterCurrent (last node in the \"greater than or equal to x\" partition) to nullptr to terminate the end of that partition.\\n\\nThen, we set the next pointer of lessCurrent (last node in the \"less than x\" partition) to point to the beginning of the \"greater than or equal to x\" partition.\\n\\nFinally, we return lessDummy.next, which is the head of the linked list containing the partitioned nodes.\\n"
                    },
                    {
                        "username": "Divyanshuagarwal23",
                        "content": "very easy "
                    }
                ]
            },
            {
                "id": 2015028,
                "content": [
                    {
                        "username": "dikshawali",
                        "content": "________listOfNodes=[2,2]\\n________temp2=head\\n________i=0\\n________while i<len(listOfNodes) and temp2 is not None:\\n____________if temp2.val<=listOfNodes[i]:\\n________________t3=deepcopy(temp2)\\n________________temp2=temp2.next\\n____________elif temp2.val>listOfNodes[i]:\\n________________newNode=ListNode()\\n////////////////newNode.next=t3.next\\n________________t3.next=newNode\\n________________i+=1\\n________________temp2=temp2.next\\n\\nWhy the /// comment is causing the function to run 2 times?  Can anyone please explain. listOfNodes are all the smallest nodes present at the right of the x. i have put _ because it was not allowing indentation in comments."
                    },
                    {
                        "username": "aditi61",
                        "content": "Line 15: Char 16: runtime error: member access within misaligned address 0x00000000000d for type \\'ListNode\\', which requires 8 byte alignment (__ListNodeUtils__.cpp)\\n0x00000000000d: note: pointer points here\\n<memory cannot be printed>\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior __ListNodeUtils__.cpp:24:16 I am getting this error anyone knows the reason?\\n\\nListNode* partition(ListNode* head, int x) {\\n        vector<int>smaller;\\n        vector<int>greater;\\n        ListNode* curr = head;\\n        while(curr){\\n            if(curr->val>=x) greater.push_back(curr->val);\\n            else smaller.push_back(curr->val);\\n            curr= curr->next;\\n        }\\n        for(int i=0;i<greater.size();i++){\\n            smaller.push_back(greater[i]);\\n        }\\n        ListNode* ans;\\n        ListNode* temp = ans;\\n      for(int i=0;i<smaller.size();i++){\\n            temp= new ListNode(smaller[i]);\\n            temp = temp->next;\\n            \\n        }\\n        return ans;\\n\\n        \\n    }"
                    },
                    {
                        "username": "samarth-singh-thakur",
                        "content": "I found implementation confusing. :("
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Happy Independence Day \\uD83D\\uDD05"
                    },
                    {
                        "username": "saibhagyaram",
                        "content": "ListNode* partition(ListNode* head, int x) {\\n        if(head  == NULL || head->next == NULL) return head;\\n        ListNode *temp = head,*prev = head ,*temp1=head;\\n        temp = temp->next;\\n        while(temp != NULL){\\n            if(temp->val >= x){\\n                temp1 = temp;\\n                temp = temp->next;\\n            }\\n            else{\\n                temp1->next = temp->next;\\n                temp->next = prev->next;\\n                prev->next = temp;\\n                prev = prev->next;\\n                temp=temp1->next;\\n            }\\n        }\\n        return head;\\n    }\\n\\nwhy it is  giving TLE !!!!\\ncan anyone tell me where it went wrong"
                    },
                    {
                        "username": "imtiaj007",
                        "content": "The description is pretty much tricky and examples are not very much sufficient. It took me 4 wrong submissions to understand the problem. Actually the problem is -\\n\\nCheck from the starting node, if the node is less than X then, place it before the nodes that are greater than or equal to X. And one thing to keep in mind you must maintain the relative order of the nodes even if some node values are smaller than previous nodes.\\n\\nHere are some example test cases for your reference - \\n\\n`1 -> 4 -> 3-> 2-> 5 -> 2`     ----  k = 3  ----      `1 -> 2 -> 2 -> 4 -> 3 -> 5`\\n`1 -> 4 -> 3-> 0-> 5 -> 2`     ----  k = 2  ----      `1 -> 0 -> 4 -> 3 -> 5 -> 2`\\n`1 -> 4 -> 3-> 0-> 5 -> 2 -> 1`    ----  k = 2  ----      `1 -> 0 -> 1 -> 4 -> 3 -> 5 -> 2`\\n`1 -> 4 -> 3-> 1-> 5 -> 2 -> 0`    ----  k = 2  ----      `1 -> 1 -> 0 -> 4 -> 3 -> 5 -> 2`\\n`4 -> 8 -> 6-> 5-> 1 -> 7 -> 2`    ----  k = 5  ----      `4 -> 1 -> 2 -> 8 -> 6 -> 5 -> 7`\\n\\nHope this will be helpful....... If you like please upvote.......!!!!!!"
                    },
                    {
                        "username": "vrajeshrs",
                        "content": "[4,3,2,5,2]\\nx =3\\nhere x = 3 and on right hand side we have 2 , 5 , 2\\nnow preserving order ans will be\\n[4,2,2,3,5]\\nexpected answer is : [2,2,4,3,5] .. how this preserve order ???"
                    },
                    {
                        "username": "rashapredator",
                        "content": "Input: head = [1,4,3,2,5,2], x = 3\\nOutput: [1,2,2,4,3,5]\\n\\nIs sol [2, 2, 1, 4, 3, 5] correct?"
                    },
                    {
                        "username": "rahil1202",
                        "content": "Here, we start by defining the ListNode structure which is a basic structure for a singly-linked list node.\\nThe Solution class contains the partition function, which takes the head of the linked list and the value x as inputs.\\n\\nWe create two dummy nodes, lessDummy and greaterDummy, to serve as the heads of the partitions for nodes less than x and nodes greater than or equal to x.\\nlessCurrent and greaterCurrent are pointers that will keep track of the current positions in their respective partitions.\\n\\nIn this loop, we iterate through the original linked list pointed to by head.\\nIf the current node\\'s value is less than x, we update lessCurrent to point to the current node and also update its next pointer to the current node. This effectively adds the current node to the \"less than x\" partition.\\n\\nIf the current node\\'s value is greater than or equal to x, we do the same for the greaterCurrent and the \"greater than or equal to x\" partition.\\nThe code combines the pointer assignment and node connection steps into a single line to optimize the process.\\n\\nAfter the loop completes, we need to connect the two partitions.\\nWe set the next pointer of greaterCurrent (last node in the \"greater than or equal to x\" partition) to nullptr to terminate the end of that partition.\\n\\nThen, we set the next pointer of lessCurrent (last node in the \"less than x\" partition) to point to the beginning of the \"greater than or equal to x\" partition.\\n\\nFinally, we return lessDummy.next, which is the head of the linked list containing the partitioned nodes.\\n"
                    },
                    {
                        "username": "Divyanshuagarwal23",
                        "content": "very easy "
                    }
                ]
            },
            {
                "id": 2014901,
                "content": [
                    {
                        "username": "dikshawali",
                        "content": "________listOfNodes=[2,2]\\n________temp2=head\\n________i=0\\n________while i<len(listOfNodes) and temp2 is not None:\\n____________if temp2.val<=listOfNodes[i]:\\n________________t3=deepcopy(temp2)\\n________________temp2=temp2.next\\n____________elif temp2.val>listOfNodes[i]:\\n________________newNode=ListNode()\\n////////////////newNode.next=t3.next\\n________________t3.next=newNode\\n________________i+=1\\n________________temp2=temp2.next\\n\\nWhy the /// comment is causing the function to run 2 times?  Can anyone please explain. listOfNodes are all the smallest nodes present at the right of the x. i have put _ because it was not allowing indentation in comments."
                    },
                    {
                        "username": "aditi61",
                        "content": "Line 15: Char 16: runtime error: member access within misaligned address 0x00000000000d for type \\'ListNode\\', which requires 8 byte alignment (__ListNodeUtils__.cpp)\\n0x00000000000d: note: pointer points here\\n<memory cannot be printed>\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior __ListNodeUtils__.cpp:24:16 I am getting this error anyone knows the reason?\\n\\nListNode* partition(ListNode* head, int x) {\\n        vector<int>smaller;\\n        vector<int>greater;\\n        ListNode* curr = head;\\n        while(curr){\\n            if(curr->val>=x) greater.push_back(curr->val);\\n            else smaller.push_back(curr->val);\\n            curr= curr->next;\\n        }\\n        for(int i=0;i<greater.size();i++){\\n            smaller.push_back(greater[i]);\\n        }\\n        ListNode* ans;\\n        ListNode* temp = ans;\\n      for(int i=0;i<smaller.size();i++){\\n            temp= new ListNode(smaller[i]);\\n            temp = temp->next;\\n            \\n        }\\n        return ans;\\n\\n        \\n    }"
                    },
                    {
                        "username": "samarth-singh-thakur",
                        "content": "I found implementation confusing. :("
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Happy Independence Day \\uD83D\\uDD05"
                    },
                    {
                        "username": "saibhagyaram",
                        "content": "ListNode* partition(ListNode* head, int x) {\\n        if(head  == NULL || head->next == NULL) return head;\\n        ListNode *temp = head,*prev = head ,*temp1=head;\\n        temp = temp->next;\\n        while(temp != NULL){\\n            if(temp->val >= x){\\n                temp1 = temp;\\n                temp = temp->next;\\n            }\\n            else{\\n                temp1->next = temp->next;\\n                temp->next = prev->next;\\n                prev->next = temp;\\n                prev = prev->next;\\n                temp=temp1->next;\\n            }\\n        }\\n        return head;\\n    }\\n\\nwhy it is  giving TLE !!!!\\ncan anyone tell me where it went wrong"
                    },
                    {
                        "username": "imtiaj007",
                        "content": "The description is pretty much tricky and examples are not very much sufficient. It took me 4 wrong submissions to understand the problem. Actually the problem is -\\n\\nCheck from the starting node, if the node is less than X then, place it before the nodes that are greater than or equal to X. And one thing to keep in mind you must maintain the relative order of the nodes even if some node values are smaller than previous nodes.\\n\\nHere are some example test cases for your reference - \\n\\n`1 -> 4 -> 3-> 2-> 5 -> 2`     ----  k = 3  ----      `1 -> 2 -> 2 -> 4 -> 3 -> 5`\\n`1 -> 4 -> 3-> 0-> 5 -> 2`     ----  k = 2  ----      `1 -> 0 -> 4 -> 3 -> 5 -> 2`\\n`1 -> 4 -> 3-> 0-> 5 -> 2 -> 1`    ----  k = 2  ----      `1 -> 0 -> 1 -> 4 -> 3 -> 5 -> 2`\\n`1 -> 4 -> 3-> 1-> 5 -> 2 -> 0`    ----  k = 2  ----      `1 -> 1 -> 0 -> 4 -> 3 -> 5 -> 2`\\n`4 -> 8 -> 6-> 5-> 1 -> 7 -> 2`    ----  k = 5  ----      `4 -> 1 -> 2 -> 8 -> 6 -> 5 -> 7`\\n\\nHope this will be helpful....... If you like please upvote.......!!!!!!"
                    },
                    {
                        "username": "vrajeshrs",
                        "content": "[4,3,2,5,2]\\nx =3\\nhere x = 3 and on right hand side we have 2 , 5 , 2\\nnow preserving order ans will be\\n[4,2,2,3,5]\\nexpected answer is : [2,2,4,3,5] .. how this preserve order ???"
                    },
                    {
                        "username": "rashapredator",
                        "content": "Input: head = [1,4,3,2,5,2], x = 3\\nOutput: [1,2,2,4,3,5]\\n\\nIs sol [2, 2, 1, 4, 3, 5] correct?"
                    },
                    {
                        "username": "rahil1202",
                        "content": "Here, we start by defining the ListNode structure which is a basic structure for a singly-linked list node.\\nThe Solution class contains the partition function, which takes the head of the linked list and the value x as inputs.\\n\\nWe create two dummy nodes, lessDummy and greaterDummy, to serve as the heads of the partitions for nodes less than x and nodes greater than or equal to x.\\nlessCurrent and greaterCurrent are pointers that will keep track of the current positions in their respective partitions.\\n\\nIn this loop, we iterate through the original linked list pointed to by head.\\nIf the current node\\'s value is less than x, we update lessCurrent to point to the current node and also update its next pointer to the current node. This effectively adds the current node to the \"less than x\" partition.\\n\\nIf the current node\\'s value is greater than or equal to x, we do the same for the greaterCurrent and the \"greater than or equal to x\" partition.\\nThe code combines the pointer assignment and node connection steps into a single line to optimize the process.\\n\\nAfter the loop completes, we need to connect the two partitions.\\nWe set the next pointer of greaterCurrent (last node in the \"greater than or equal to x\" partition) to nullptr to terminate the end of that partition.\\n\\nThen, we set the next pointer of lessCurrent (last node in the \"less than x\" partition) to point to the beginning of the \"greater than or equal to x\" partition.\\n\\nFinally, we return lessDummy.next, which is the head of the linked list containing the partitioned nodes.\\n"
                    },
                    {
                        "username": "Divyanshuagarwal23",
                        "content": "very easy "
                    }
                ]
            },
            {
                "id": 2014900,
                "content": [
                    {
                        "username": "dikshawali",
                        "content": "________listOfNodes=[2,2]\\n________temp2=head\\n________i=0\\n________while i<len(listOfNodes) and temp2 is not None:\\n____________if temp2.val<=listOfNodes[i]:\\n________________t3=deepcopy(temp2)\\n________________temp2=temp2.next\\n____________elif temp2.val>listOfNodes[i]:\\n________________newNode=ListNode()\\n////////////////newNode.next=t3.next\\n________________t3.next=newNode\\n________________i+=1\\n________________temp2=temp2.next\\n\\nWhy the /// comment is causing the function to run 2 times?  Can anyone please explain. listOfNodes are all the smallest nodes present at the right of the x. i have put _ because it was not allowing indentation in comments."
                    },
                    {
                        "username": "aditi61",
                        "content": "Line 15: Char 16: runtime error: member access within misaligned address 0x00000000000d for type \\'ListNode\\', which requires 8 byte alignment (__ListNodeUtils__.cpp)\\n0x00000000000d: note: pointer points here\\n<memory cannot be printed>\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior __ListNodeUtils__.cpp:24:16 I am getting this error anyone knows the reason?\\n\\nListNode* partition(ListNode* head, int x) {\\n        vector<int>smaller;\\n        vector<int>greater;\\n        ListNode* curr = head;\\n        while(curr){\\n            if(curr->val>=x) greater.push_back(curr->val);\\n            else smaller.push_back(curr->val);\\n            curr= curr->next;\\n        }\\n        for(int i=0;i<greater.size();i++){\\n            smaller.push_back(greater[i]);\\n        }\\n        ListNode* ans;\\n        ListNode* temp = ans;\\n      for(int i=0;i<smaller.size();i++){\\n            temp= new ListNode(smaller[i]);\\n            temp = temp->next;\\n            \\n        }\\n        return ans;\\n\\n        \\n    }"
                    },
                    {
                        "username": "samarth-singh-thakur",
                        "content": "I found implementation confusing. :("
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Happy Independence Day \\uD83D\\uDD05"
                    },
                    {
                        "username": "saibhagyaram",
                        "content": "ListNode* partition(ListNode* head, int x) {\\n        if(head  == NULL || head->next == NULL) return head;\\n        ListNode *temp = head,*prev = head ,*temp1=head;\\n        temp = temp->next;\\n        while(temp != NULL){\\n            if(temp->val >= x){\\n                temp1 = temp;\\n                temp = temp->next;\\n            }\\n            else{\\n                temp1->next = temp->next;\\n                temp->next = prev->next;\\n                prev->next = temp;\\n                prev = prev->next;\\n                temp=temp1->next;\\n            }\\n        }\\n        return head;\\n    }\\n\\nwhy it is  giving TLE !!!!\\ncan anyone tell me where it went wrong"
                    },
                    {
                        "username": "imtiaj007",
                        "content": "The description is pretty much tricky and examples are not very much sufficient. It took me 4 wrong submissions to understand the problem. Actually the problem is -\\n\\nCheck from the starting node, if the node is less than X then, place it before the nodes that are greater than or equal to X. And one thing to keep in mind you must maintain the relative order of the nodes even if some node values are smaller than previous nodes.\\n\\nHere are some example test cases for your reference - \\n\\n`1 -> 4 -> 3-> 2-> 5 -> 2`     ----  k = 3  ----      `1 -> 2 -> 2 -> 4 -> 3 -> 5`\\n`1 -> 4 -> 3-> 0-> 5 -> 2`     ----  k = 2  ----      `1 -> 0 -> 4 -> 3 -> 5 -> 2`\\n`1 -> 4 -> 3-> 0-> 5 -> 2 -> 1`    ----  k = 2  ----      `1 -> 0 -> 1 -> 4 -> 3 -> 5 -> 2`\\n`1 -> 4 -> 3-> 1-> 5 -> 2 -> 0`    ----  k = 2  ----      `1 -> 1 -> 0 -> 4 -> 3 -> 5 -> 2`\\n`4 -> 8 -> 6-> 5-> 1 -> 7 -> 2`    ----  k = 5  ----      `4 -> 1 -> 2 -> 8 -> 6 -> 5 -> 7`\\n\\nHope this will be helpful....... If you like please upvote.......!!!!!!"
                    },
                    {
                        "username": "vrajeshrs",
                        "content": "[4,3,2,5,2]\\nx =3\\nhere x = 3 and on right hand side we have 2 , 5 , 2\\nnow preserving order ans will be\\n[4,2,2,3,5]\\nexpected answer is : [2,2,4,3,5] .. how this preserve order ???"
                    },
                    {
                        "username": "rashapredator",
                        "content": "Input: head = [1,4,3,2,5,2], x = 3\\nOutput: [1,2,2,4,3,5]\\n\\nIs sol [2, 2, 1, 4, 3, 5] correct?"
                    },
                    {
                        "username": "rahil1202",
                        "content": "Here, we start by defining the ListNode structure which is a basic structure for a singly-linked list node.\\nThe Solution class contains the partition function, which takes the head of the linked list and the value x as inputs.\\n\\nWe create two dummy nodes, lessDummy and greaterDummy, to serve as the heads of the partitions for nodes less than x and nodes greater than or equal to x.\\nlessCurrent and greaterCurrent are pointers that will keep track of the current positions in their respective partitions.\\n\\nIn this loop, we iterate through the original linked list pointed to by head.\\nIf the current node\\'s value is less than x, we update lessCurrent to point to the current node and also update its next pointer to the current node. This effectively adds the current node to the \"less than x\" partition.\\n\\nIf the current node\\'s value is greater than or equal to x, we do the same for the greaterCurrent and the \"greater than or equal to x\" partition.\\nThe code combines the pointer assignment and node connection steps into a single line to optimize the process.\\n\\nAfter the loop completes, we need to connect the two partitions.\\nWe set the next pointer of greaterCurrent (last node in the \"greater than or equal to x\" partition) to nullptr to terminate the end of that partition.\\n\\nThen, we set the next pointer of lessCurrent (last node in the \"less than x\" partition) to point to the beginning of the \"greater than or equal to x\" partition.\\n\\nFinally, we return lessDummy.next, which is the head of the linked list containing the partitioned nodes.\\n"
                    },
                    {
                        "username": "Divyanshuagarwal23",
                        "content": "very easy "
                    }
                ]
            },
            {
                "id": 2014872,
                "content": [
                    {
                        "username": "dikshawali",
                        "content": "I am facing very weird situation, even after I am done with function definition (partition here), it is running 2 times. Even if I am making any mistake, why is it running 2 times as it should run only once in driver program. I have faced it many times.\nIf anyone knows why please let me know.\nPS: There is not even any loop.\n"
                    },
                    {
                        "username": "Sam_Sundar",
                        "content": "How is this a Medium level problem ??"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Leetcode never fails to confuse us with the description of question.\\nIn this question, as you read the question you would  be easy question but after running the code damn I did wrong interpretation of the question.(so read the question again carefully)"
                    },
                    {
                        "username": "vaibhav6265",
                        "content": "Simple Explanation of Problem Statement:\\n\\nExample:\\nhead = [1,4,3,2,5,2] , x = 3\\n\\nYou are a value x. There can be any number of nodes from [0,n] of this value x in the list.\\n\\nNow you have to arrange the nodes in such a way, that all the nodes with value `less than x` should be `together` and `relative order` between them is `maintained`. Lets call this group `A`.\\nA = [1,2,2]\\n\\nSimilarly, all the nodes with value `greater than equal to x` should be `together` and `relative order` between them is `maintained`. Lets call this group `B`.\\nB = [4,3,2,2]\\n4 comes before 3, 3 comes before 2 same as in the problem statement.\\n\\nNote: relative order between all nodes in A and B are maintained.\\n\\nFinally, `A should be before B`."
                    },
                    {
                        "username": "swo0sh",
                        "content": "Happy Independence Day \\uD83C\\uDDEE\\uD83C\\uDDF3"
                    },
                    {
                        "username": "satyam47",
                        "content": "I have solved Linked List questions, but it took me many submissions with incorrect answers."
                    },
                    {
                        "username": "jazelly",
                        "content": "I have the solution, dividing them to 2 list and join them after a linear scan, but I really couldn\\'t figure out why I got oom in golang. I have 0 allocation on memory, but just operations on pointers. Is this a bug?"
                    },
                    {
                        "username": "sonivinayak716",
                        "content": "FOR the people who are getting the memory limit exceeded just like I tried for the first time this question by taking two vectors and storing before less than x and one with more than x values .\\nI would say the reason behind we are getting the memory limit exceeded is because we are runnin two traversals in the linked list itself .Rather we  should first copy all the elements in a single vector and then copy all the required numbers into another array .\\n\\nBy doing that we can get the easy results of desired array\\ngood luck for the approach ,Hare krishna !  "
                    },
                    {
                        "username": "user8272RT",
                        "content": "Got here after doing a quickselect problem, so the solution struck me right away."
                    },
                    {
                        "username": "user1914GI",
                        "content": "I didnt understand the question properly... can u explain how the first sample output came "
                    }
                ]
            },
            {
                "id": 2014836,
                "content": [
                    {
                        "username": "dikshawali",
                        "content": "I am facing very weird situation, even after I am done with function definition (partition here), it is running 2 times. Even if I am making any mistake, why is it running 2 times as it should run only once in driver program. I have faced it many times.\nIf anyone knows why please let me know.\nPS: There is not even any loop.\n"
                    },
                    {
                        "username": "Sam_Sundar",
                        "content": "How is this a Medium level problem ??"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Leetcode never fails to confuse us with the description of question.\\nIn this question, as you read the question you would  be easy question but after running the code damn I did wrong interpretation of the question.(so read the question again carefully)"
                    },
                    {
                        "username": "vaibhav6265",
                        "content": "Simple Explanation of Problem Statement:\\n\\nExample:\\nhead = [1,4,3,2,5,2] , x = 3\\n\\nYou are a value x. There can be any number of nodes from [0,n] of this value x in the list.\\n\\nNow you have to arrange the nodes in such a way, that all the nodes with value `less than x` should be `together` and `relative order` between them is `maintained`. Lets call this group `A`.\\nA = [1,2,2]\\n\\nSimilarly, all the nodes with value `greater than equal to x` should be `together` and `relative order` between them is `maintained`. Lets call this group `B`.\\nB = [4,3,2,2]\\n4 comes before 3, 3 comes before 2 same as in the problem statement.\\n\\nNote: relative order between all nodes in A and B are maintained.\\n\\nFinally, `A should be before B`."
                    },
                    {
                        "username": "swo0sh",
                        "content": "Happy Independence Day \\uD83C\\uDDEE\\uD83C\\uDDF3"
                    },
                    {
                        "username": "satyam47",
                        "content": "I have solved Linked List questions, but it took me many submissions with incorrect answers."
                    },
                    {
                        "username": "jazelly",
                        "content": "I have the solution, dividing them to 2 list and join them after a linear scan, but I really couldn\\'t figure out why I got oom in golang. I have 0 allocation on memory, but just operations on pointers. Is this a bug?"
                    },
                    {
                        "username": "sonivinayak716",
                        "content": "FOR the people who are getting the memory limit exceeded just like I tried for the first time this question by taking two vectors and storing before less than x and one with more than x values .\\nI would say the reason behind we are getting the memory limit exceeded is because we are runnin two traversals in the linked list itself .Rather we  should first copy all the elements in a single vector and then copy all the required numbers into another array .\\n\\nBy doing that we can get the easy results of desired array\\ngood luck for the approach ,Hare krishna !  "
                    },
                    {
                        "username": "user8272RT",
                        "content": "Got here after doing a quickselect problem, so the solution struck me right away."
                    },
                    {
                        "username": "user1914GI",
                        "content": "I didnt understand the question properly... can u explain how the first sample output came "
                    }
                ]
            },
            {
                "id": 2014776,
                "content": [
                    {
                        "username": "dikshawali",
                        "content": "I am facing very weird situation, even after I am done with function definition (partition here), it is running 2 times. Even if I am making any mistake, why is it running 2 times as it should run only once in driver program. I have faced it many times.\nIf anyone knows why please let me know.\nPS: There is not even any loop.\n"
                    },
                    {
                        "username": "Sam_Sundar",
                        "content": "How is this a Medium level problem ??"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Leetcode never fails to confuse us with the description of question.\\nIn this question, as you read the question you would  be easy question but after running the code damn I did wrong interpretation of the question.(so read the question again carefully)"
                    },
                    {
                        "username": "vaibhav6265",
                        "content": "Simple Explanation of Problem Statement:\\n\\nExample:\\nhead = [1,4,3,2,5,2] , x = 3\\n\\nYou are a value x. There can be any number of nodes from [0,n] of this value x in the list.\\n\\nNow you have to arrange the nodes in such a way, that all the nodes with value `less than x` should be `together` and `relative order` between them is `maintained`. Lets call this group `A`.\\nA = [1,2,2]\\n\\nSimilarly, all the nodes with value `greater than equal to x` should be `together` and `relative order` between them is `maintained`. Lets call this group `B`.\\nB = [4,3,2,2]\\n4 comes before 3, 3 comes before 2 same as in the problem statement.\\n\\nNote: relative order between all nodes in A and B are maintained.\\n\\nFinally, `A should be before B`."
                    },
                    {
                        "username": "swo0sh",
                        "content": "Happy Independence Day \\uD83C\\uDDEE\\uD83C\\uDDF3"
                    },
                    {
                        "username": "satyam47",
                        "content": "I have solved Linked List questions, but it took me many submissions with incorrect answers."
                    },
                    {
                        "username": "jazelly",
                        "content": "I have the solution, dividing them to 2 list and join them after a linear scan, but I really couldn\\'t figure out why I got oom in golang. I have 0 allocation on memory, but just operations on pointers. Is this a bug?"
                    },
                    {
                        "username": "sonivinayak716",
                        "content": "FOR the people who are getting the memory limit exceeded just like I tried for the first time this question by taking two vectors and storing before less than x and one with more than x values .\\nI would say the reason behind we are getting the memory limit exceeded is because we are runnin two traversals in the linked list itself .Rather we  should first copy all the elements in a single vector and then copy all the required numbers into another array .\\n\\nBy doing that we can get the easy results of desired array\\ngood luck for the approach ,Hare krishna !  "
                    },
                    {
                        "username": "user8272RT",
                        "content": "Got here after doing a quickselect problem, so the solution struck me right away."
                    },
                    {
                        "username": "user1914GI",
                        "content": "I didnt understand the question properly... can u explain how the first sample output came "
                    }
                ]
            },
            {
                "id": 2014750,
                "content": [
                    {
                        "username": "dikshawali",
                        "content": "I am facing very weird situation, even after I am done with function definition (partition here), it is running 2 times. Even if I am making any mistake, why is it running 2 times as it should run only once in driver program. I have faced it many times.\nIf anyone knows why please let me know.\nPS: There is not even any loop.\n"
                    },
                    {
                        "username": "Sam_Sundar",
                        "content": "How is this a Medium level problem ??"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Leetcode never fails to confuse us with the description of question.\\nIn this question, as you read the question you would  be easy question but after running the code damn I did wrong interpretation of the question.(so read the question again carefully)"
                    },
                    {
                        "username": "vaibhav6265",
                        "content": "Simple Explanation of Problem Statement:\\n\\nExample:\\nhead = [1,4,3,2,5,2] , x = 3\\n\\nYou are a value x. There can be any number of nodes from [0,n] of this value x in the list.\\n\\nNow you have to arrange the nodes in such a way, that all the nodes with value `less than x` should be `together` and `relative order` between them is `maintained`. Lets call this group `A`.\\nA = [1,2,2]\\n\\nSimilarly, all the nodes with value `greater than equal to x` should be `together` and `relative order` between them is `maintained`. Lets call this group `B`.\\nB = [4,3,2,2]\\n4 comes before 3, 3 comes before 2 same as in the problem statement.\\n\\nNote: relative order between all nodes in A and B are maintained.\\n\\nFinally, `A should be before B`."
                    },
                    {
                        "username": "swo0sh",
                        "content": "Happy Independence Day \\uD83C\\uDDEE\\uD83C\\uDDF3"
                    },
                    {
                        "username": "satyam47",
                        "content": "I have solved Linked List questions, but it took me many submissions with incorrect answers."
                    },
                    {
                        "username": "jazelly",
                        "content": "I have the solution, dividing them to 2 list and join them after a linear scan, but I really couldn\\'t figure out why I got oom in golang. I have 0 allocation on memory, but just operations on pointers. Is this a bug?"
                    },
                    {
                        "username": "sonivinayak716",
                        "content": "FOR the people who are getting the memory limit exceeded just like I tried for the first time this question by taking two vectors and storing before less than x and one with more than x values .\\nI would say the reason behind we are getting the memory limit exceeded is because we are runnin two traversals in the linked list itself .Rather we  should first copy all the elements in a single vector and then copy all the required numbers into another array .\\n\\nBy doing that we can get the easy results of desired array\\ngood luck for the approach ,Hare krishna !  "
                    },
                    {
                        "username": "user8272RT",
                        "content": "Got here after doing a quickselect problem, so the solution struck me right away."
                    },
                    {
                        "username": "user1914GI",
                        "content": "I didnt understand the question properly... can u explain how the first sample output came "
                    }
                ]
            },
            {
                "id": 2014745,
                "content": [
                    {
                        "username": "dikshawali",
                        "content": "I am facing very weird situation, even after I am done with function definition (partition here), it is running 2 times. Even if I am making any mistake, why is it running 2 times as it should run only once in driver program. I have faced it many times.\nIf anyone knows why please let me know.\nPS: There is not even any loop.\n"
                    },
                    {
                        "username": "Sam_Sundar",
                        "content": "How is this a Medium level problem ??"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Leetcode never fails to confuse us with the description of question.\\nIn this question, as you read the question you would  be easy question but after running the code damn I did wrong interpretation of the question.(so read the question again carefully)"
                    },
                    {
                        "username": "vaibhav6265",
                        "content": "Simple Explanation of Problem Statement:\\n\\nExample:\\nhead = [1,4,3,2,5,2] , x = 3\\n\\nYou are a value x. There can be any number of nodes from [0,n] of this value x in the list.\\n\\nNow you have to arrange the nodes in such a way, that all the nodes with value `less than x` should be `together` and `relative order` between them is `maintained`. Lets call this group `A`.\\nA = [1,2,2]\\n\\nSimilarly, all the nodes with value `greater than equal to x` should be `together` and `relative order` between them is `maintained`. Lets call this group `B`.\\nB = [4,3,2,2]\\n4 comes before 3, 3 comes before 2 same as in the problem statement.\\n\\nNote: relative order between all nodes in A and B are maintained.\\n\\nFinally, `A should be before B`."
                    },
                    {
                        "username": "swo0sh",
                        "content": "Happy Independence Day \\uD83C\\uDDEE\\uD83C\\uDDF3"
                    },
                    {
                        "username": "satyam47",
                        "content": "I have solved Linked List questions, but it took me many submissions with incorrect answers."
                    },
                    {
                        "username": "jazelly",
                        "content": "I have the solution, dividing them to 2 list and join them after a linear scan, but I really couldn\\'t figure out why I got oom in golang. I have 0 allocation on memory, but just operations on pointers. Is this a bug?"
                    },
                    {
                        "username": "sonivinayak716",
                        "content": "FOR the people who are getting the memory limit exceeded just like I tried for the first time this question by taking two vectors and storing before less than x and one with more than x values .\\nI would say the reason behind we are getting the memory limit exceeded is because we are runnin two traversals in the linked list itself .Rather we  should first copy all the elements in a single vector and then copy all the required numbers into another array .\\n\\nBy doing that we can get the easy results of desired array\\ngood luck for the approach ,Hare krishna !  "
                    },
                    {
                        "username": "user8272RT",
                        "content": "Got here after doing a quickselect problem, so the solution struck me right away."
                    },
                    {
                        "username": "user1914GI",
                        "content": "I didnt understand the question properly... can u explain how the first sample output came "
                    }
                ]
            },
            {
                "id": 2014721,
                "content": [
                    {
                        "username": "dikshawali",
                        "content": "I am facing very weird situation, even after I am done with function definition (partition here), it is running 2 times. Even if I am making any mistake, why is it running 2 times as it should run only once in driver program. I have faced it many times.\nIf anyone knows why please let me know.\nPS: There is not even any loop.\n"
                    },
                    {
                        "username": "Sam_Sundar",
                        "content": "How is this a Medium level problem ??"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Leetcode never fails to confuse us with the description of question.\\nIn this question, as you read the question you would  be easy question but after running the code damn I did wrong interpretation of the question.(so read the question again carefully)"
                    },
                    {
                        "username": "vaibhav6265",
                        "content": "Simple Explanation of Problem Statement:\\n\\nExample:\\nhead = [1,4,3,2,5,2] , x = 3\\n\\nYou are a value x. There can be any number of nodes from [0,n] of this value x in the list.\\n\\nNow you have to arrange the nodes in such a way, that all the nodes with value `less than x` should be `together` and `relative order` between them is `maintained`. Lets call this group `A`.\\nA = [1,2,2]\\n\\nSimilarly, all the nodes with value `greater than equal to x` should be `together` and `relative order` between them is `maintained`. Lets call this group `B`.\\nB = [4,3,2,2]\\n4 comes before 3, 3 comes before 2 same as in the problem statement.\\n\\nNote: relative order between all nodes in A and B are maintained.\\n\\nFinally, `A should be before B`."
                    },
                    {
                        "username": "swo0sh",
                        "content": "Happy Independence Day \\uD83C\\uDDEE\\uD83C\\uDDF3"
                    },
                    {
                        "username": "satyam47",
                        "content": "I have solved Linked List questions, but it took me many submissions with incorrect answers."
                    },
                    {
                        "username": "jazelly",
                        "content": "I have the solution, dividing them to 2 list and join them after a linear scan, but I really couldn\\'t figure out why I got oom in golang. I have 0 allocation on memory, but just operations on pointers. Is this a bug?"
                    },
                    {
                        "username": "sonivinayak716",
                        "content": "FOR the people who are getting the memory limit exceeded just like I tried for the first time this question by taking two vectors and storing before less than x and one with more than x values .\\nI would say the reason behind we are getting the memory limit exceeded is because we are runnin two traversals in the linked list itself .Rather we  should first copy all the elements in a single vector and then copy all the required numbers into another array .\\n\\nBy doing that we can get the easy results of desired array\\ngood luck for the approach ,Hare krishna !  "
                    },
                    {
                        "username": "user8272RT",
                        "content": "Got here after doing a quickselect problem, so the solution struck me right away."
                    },
                    {
                        "username": "user1914GI",
                        "content": "I didnt understand the question properly... can u explain how the first sample output came "
                    }
                ]
            },
            {
                "id": 2014696,
                "content": [
                    {
                        "username": "dikshawali",
                        "content": "I am facing very weird situation, even after I am done with function definition (partition here), it is running 2 times. Even if I am making any mistake, why is it running 2 times as it should run only once in driver program. I have faced it many times.\nIf anyone knows why please let me know.\nPS: There is not even any loop.\n"
                    },
                    {
                        "username": "Sam_Sundar",
                        "content": "How is this a Medium level problem ??"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Leetcode never fails to confuse us with the description of question.\\nIn this question, as you read the question you would  be easy question but after running the code damn I did wrong interpretation of the question.(so read the question again carefully)"
                    },
                    {
                        "username": "vaibhav6265",
                        "content": "Simple Explanation of Problem Statement:\\n\\nExample:\\nhead = [1,4,3,2,5,2] , x = 3\\n\\nYou are a value x. There can be any number of nodes from [0,n] of this value x in the list.\\n\\nNow you have to arrange the nodes in such a way, that all the nodes with value `less than x` should be `together` and `relative order` between them is `maintained`. Lets call this group `A`.\\nA = [1,2,2]\\n\\nSimilarly, all the nodes with value `greater than equal to x` should be `together` and `relative order` between them is `maintained`. Lets call this group `B`.\\nB = [4,3,2,2]\\n4 comes before 3, 3 comes before 2 same as in the problem statement.\\n\\nNote: relative order between all nodes in A and B are maintained.\\n\\nFinally, `A should be before B`."
                    },
                    {
                        "username": "swo0sh",
                        "content": "Happy Independence Day \\uD83C\\uDDEE\\uD83C\\uDDF3"
                    },
                    {
                        "username": "satyam47",
                        "content": "I have solved Linked List questions, but it took me many submissions with incorrect answers."
                    },
                    {
                        "username": "jazelly",
                        "content": "I have the solution, dividing them to 2 list and join them after a linear scan, but I really couldn\\'t figure out why I got oom in golang. I have 0 allocation on memory, but just operations on pointers. Is this a bug?"
                    },
                    {
                        "username": "sonivinayak716",
                        "content": "FOR the people who are getting the memory limit exceeded just like I tried for the first time this question by taking two vectors and storing before less than x and one with more than x values .\\nI would say the reason behind we are getting the memory limit exceeded is because we are runnin two traversals in the linked list itself .Rather we  should first copy all the elements in a single vector and then copy all the required numbers into another array .\\n\\nBy doing that we can get the easy results of desired array\\ngood luck for the approach ,Hare krishna !  "
                    },
                    {
                        "username": "user8272RT",
                        "content": "Got here after doing a quickselect problem, so the solution struck me right away."
                    },
                    {
                        "username": "user1914GI",
                        "content": "I didnt understand the question properly... can u explain how the first sample output came "
                    }
                ]
            },
            {
                "id": 2014692,
                "content": [
                    {
                        "username": "dikshawali",
                        "content": "I am facing very weird situation, even after I am done with function definition (partition here), it is running 2 times. Even if I am making any mistake, why is it running 2 times as it should run only once in driver program. I have faced it many times.\nIf anyone knows why please let me know.\nPS: There is not even any loop.\n"
                    },
                    {
                        "username": "Sam_Sundar",
                        "content": "How is this a Medium level problem ??"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Leetcode never fails to confuse us with the description of question.\\nIn this question, as you read the question you would  be easy question but after running the code damn I did wrong interpretation of the question.(so read the question again carefully)"
                    },
                    {
                        "username": "vaibhav6265",
                        "content": "Simple Explanation of Problem Statement:\\n\\nExample:\\nhead = [1,4,3,2,5,2] , x = 3\\n\\nYou are a value x. There can be any number of nodes from [0,n] of this value x in the list.\\n\\nNow you have to arrange the nodes in such a way, that all the nodes with value `less than x` should be `together` and `relative order` between them is `maintained`. Lets call this group `A`.\\nA = [1,2,2]\\n\\nSimilarly, all the nodes with value `greater than equal to x` should be `together` and `relative order` between them is `maintained`. Lets call this group `B`.\\nB = [4,3,2,2]\\n4 comes before 3, 3 comes before 2 same as in the problem statement.\\n\\nNote: relative order between all nodes in A and B are maintained.\\n\\nFinally, `A should be before B`."
                    },
                    {
                        "username": "swo0sh",
                        "content": "Happy Independence Day \\uD83C\\uDDEE\\uD83C\\uDDF3"
                    },
                    {
                        "username": "satyam47",
                        "content": "I have solved Linked List questions, but it took me many submissions with incorrect answers."
                    },
                    {
                        "username": "jazelly",
                        "content": "I have the solution, dividing them to 2 list and join them after a linear scan, but I really couldn\\'t figure out why I got oom in golang. I have 0 allocation on memory, but just operations on pointers. Is this a bug?"
                    },
                    {
                        "username": "sonivinayak716",
                        "content": "FOR the people who are getting the memory limit exceeded just like I tried for the first time this question by taking two vectors and storing before less than x and one with more than x values .\\nI would say the reason behind we are getting the memory limit exceeded is because we are runnin two traversals in the linked list itself .Rather we  should first copy all the elements in a single vector and then copy all the required numbers into another array .\\n\\nBy doing that we can get the easy results of desired array\\ngood luck for the approach ,Hare krishna !  "
                    },
                    {
                        "username": "user8272RT",
                        "content": "Got here after doing a quickselect problem, so the solution struck me right away."
                    },
                    {
                        "username": "user1914GI",
                        "content": "I didnt understand the question properly... can u explain how the first sample output came "
                    }
                ]
            },
            {
                "id": 2014655,
                "content": [
                    {
                        "username": "dikshawali",
                        "content": "I am facing very weird situation, even after I am done with function definition (partition here), it is running 2 times. Even if I am making any mistake, why is it running 2 times as it should run only once in driver program. I have faced it many times.\nIf anyone knows why please let me know.\nPS: There is not even any loop.\n"
                    },
                    {
                        "username": "Sam_Sundar",
                        "content": "How is this a Medium level problem ??"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Leetcode never fails to confuse us with the description of question.\\nIn this question, as you read the question you would  be easy question but after running the code damn I did wrong interpretation of the question.(so read the question again carefully)"
                    },
                    {
                        "username": "vaibhav6265",
                        "content": "Simple Explanation of Problem Statement:\\n\\nExample:\\nhead = [1,4,3,2,5,2] , x = 3\\n\\nYou are a value x. There can be any number of nodes from [0,n] of this value x in the list.\\n\\nNow you have to arrange the nodes in such a way, that all the nodes with value `less than x` should be `together` and `relative order` between them is `maintained`. Lets call this group `A`.\\nA = [1,2,2]\\n\\nSimilarly, all the nodes with value `greater than equal to x` should be `together` and `relative order` between them is `maintained`. Lets call this group `B`.\\nB = [4,3,2,2]\\n4 comes before 3, 3 comes before 2 same as in the problem statement.\\n\\nNote: relative order between all nodes in A and B are maintained.\\n\\nFinally, `A should be before B`."
                    },
                    {
                        "username": "swo0sh",
                        "content": "Happy Independence Day \\uD83C\\uDDEE\\uD83C\\uDDF3"
                    },
                    {
                        "username": "satyam47",
                        "content": "I have solved Linked List questions, but it took me many submissions with incorrect answers."
                    },
                    {
                        "username": "jazelly",
                        "content": "I have the solution, dividing them to 2 list and join them after a linear scan, but I really couldn\\'t figure out why I got oom in golang. I have 0 allocation on memory, but just operations on pointers. Is this a bug?"
                    },
                    {
                        "username": "sonivinayak716",
                        "content": "FOR the people who are getting the memory limit exceeded just like I tried for the first time this question by taking two vectors and storing before less than x and one with more than x values .\\nI would say the reason behind we are getting the memory limit exceeded is because we are runnin two traversals in the linked list itself .Rather we  should first copy all the elements in a single vector and then copy all the required numbers into another array .\\n\\nBy doing that we can get the easy results of desired array\\ngood luck for the approach ,Hare krishna !  "
                    },
                    {
                        "username": "user8272RT",
                        "content": "Got here after doing a quickselect problem, so the solution struck me right away."
                    },
                    {
                        "username": "user1914GI",
                        "content": "I didnt understand the question properly... can u explain how the first sample output came "
                    }
                ]
            },
            {
                "id": 2014611,
                "content": [
                    {
                        "username": "dikshawali",
                        "content": "I am facing very weird situation, even after I am done with function definition (partition here), it is running 2 times. Even if I am making any mistake, why is it running 2 times as it should run only once in driver program. I have faced it many times.\nIf anyone knows why please let me know.\nPS: There is not even any loop.\n"
                    },
                    {
                        "username": "Sam_Sundar",
                        "content": "How is this a Medium level problem ??"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Leetcode never fails to confuse us with the description of question.\\nIn this question, as you read the question you would  be easy question but after running the code damn I did wrong interpretation of the question.(so read the question again carefully)"
                    },
                    {
                        "username": "vaibhav6265",
                        "content": "Simple Explanation of Problem Statement:\\n\\nExample:\\nhead = [1,4,3,2,5,2] , x = 3\\n\\nYou are a value x. There can be any number of nodes from [0,n] of this value x in the list.\\n\\nNow you have to arrange the nodes in such a way, that all the nodes with value `less than x` should be `together` and `relative order` between them is `maintained`. Lets call this group `A`.\\nA = [1,2,2]\\n\\nSimilarly, all the nodes with value `greater than equal to x` should be `together` and `relative order` between them is `maintained`. Lets call this group `B`.\\nB = [4,3,2,2]\\n4 comes before 3, 3 comes before 2 same as in the problem statement.\\n\\nNote: relative order between all nodes in A and B are maintained.\\n\\nFinally, `A should be before B`."
                    },
                    {
                        "username": "swo0sh",
                        "content": "Happy Independence Day \\uD83C\\uDDEE\\uD83C\\uDDF3"
                    },
                    {
                        "username": "satyam47",
                        "content": "I have solved Linked List questions, but it took me many submissions with incorrect answers."
                    },
                    {
                        "username": "jazelly",
                        "content": "I have the solution, dividing them to 2 list and join them after a linear scan, but I really couldn\\'t figure out why I got oom in golang. I have 0 allocation on memory, but just operations on pointers. Is this a bug?"
                    },
                    {
                        "username": "sonivinayak716",
                        "content": "FOR the people who are getting the memory limit exceeded just like I tried for the first time this question by taking two vectors and storing before less than x and one with more than x values .\\nI would say the reason behind we are getting the memory limit exceeded is because we are runnin two traversals in the linked list itself .Rather we  should first copy all the elements in a single vector and then copy all the required numbers into another array .\\n\\nBy doing that we can get the easy results of desired array\\ngood luck for the approach ,Hare krishna !  "
                    },
                    {
                        "username": "user8272RT",
                        "content": "Got here after doing a quickselect problem, so the solution struck me right away."
                    },
                    {
                        "username": "user1914GI",
                        "content": "I didnt understand the question properly... can u explain how the first sample output came "
                    }
                ]
            },
            {
                "id": 1944225,
                "content": [
                    {
                        "username": "Himatheja",
                        "content": "   ListNode* temp = head;\\n        ListNode* curr1 = head;\\n        ListNode* curr2 = head;\\n        ListNode* head1;\\n        ListNode* head2;\\n        bool pass1,pass2 = true;\\n        while(temp!=NULL){\\n            if(temp->val<x){\\n                 if(pass1){\\n                     pass1 = false;\\n                     head1 = temp;\\n                     curr1 = temp;\\n                     temp = temp->next;\\n                 }\\n                 else{\\n                     curr1->next = temp;\\n                     curr1=temp;\\n                     temp = temp->next;\\n                 }\\n            }\\n            else{\\n                if(pass2){\\n                     pass2 = false;\\n                     head2 = temp;\\n                     curr2 = temp;\\n                     temp = temp->next;\\n                 }\\n                 else{\\n                     curr2->next = temp;\\n                     curr2=temp;\\n                     temp = temp->next;\\n                 }\\n            }\\n            \\n        }\\n        curr1->next = head2;\\n        return\\xA0head1;\\nI still don\\'t get why it is giving tle;"
                    },
                    {
                        "username": "tifv",
                        "content": "There are several errors here. For starters, one can observe that `bool pass1,pass2 = true;` only initializes the second variable. Other problems include the end of resulting list not necessarily being set to `NULL`."
                    },
                    {
                        "username": "swapniljk14",
                        "content": "why it showing time limit exceeded?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "A tip for those of you who recognized quicksort partitioning, and are trying to implement it this way: don't.\nYou would get there eventually (I did), but quicksort partitioning is designed for arrays, not linked lists. \nFor a linked list there is a much more straightforward way to do it that will save you a lot of headaches with pointer management and edge cases. Good luck!"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is my Straightforward approach:-\n\n1. Create an ArrayList<Integer> to store the values of the input ListNode.\n2. Traverse the input ListNode, adding each value to the ArrayList<Integer>.\n3. Sort the ArrayList<Integer> using a Comparator that prioritizes values less than 3.\n4. Create a new ListNode from the sorted ArrayList<Integer>.\n5. Return the new ListNode.\n\n- Constraints friendly"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for help:-\\nhttps://leetcode.com/problems/partition-list/solutions/3303261/straightforward-brute-force-approach/"
                    },
                    {
                        "username": "Mirro0w0",
                        "content": "I feel so stupid.... :(\\nI know the logic but it took me almost 3 damn hours to code this"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "Statement is hella confusing. Think of it as you\\'re only allowed to move nodes with node.val<x while maintaining the relative order and leave the rest as it is."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "pahwagautam786",
                        "content": "Nice problem"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "The problem description doesn\\'t say, but I assume you can only manipulate the pointers of the original list nodes, and are not allowed to create new list nodes to copy the values over?"
                    },
                    {
                        "username": "aniketdali",
                        "content": "rearrange the list such that we can create  two logical partitions one < x and another x <="
                    }
                ]
            },
            {
                "id": 1938529,
                "content": [
                    {
                        "username": "Himatheja",
                        "content": "   ListNode* temp = head;\\n        ListNode* curr1 = head;\\n        ListNode* curr2 = head;\\n        ListNode* head1;\\n        ListNode* head2;\\n        bool pass1,pass2 = true;\\n        while(temp!=NULL){\\n            if(temp->val<x){\\n                 if(pass1){\\n                     pass1 = false;\\n                     head1 = temp;\\n                     curr1 = temp;\\n                     temp = temp->next;\\n                 }\\n                 else{\\n                     curr1->next = temp;\\n                     curr1=temp;\\n                     temp = temp->next;\\n                 }\\n            }\\n            else{\\n                if(pass2){\\n                     pass2 = false;\\n                     head2 = temp;\\n                     curr2 = temp;\\n                     temp = temp->next;\\n                 }\\n                 else{\\n                     curr2->next = temp;\\n                     curr2=temp;\\n                     temp = temp->next;\\n                 }\\n            }\\n            \\n        }\\n        curr1->next = head2;\\n        return\\xA0head1;\\nI still don\\'t get why it is giving tle;"
                    },
                    {
                        "username": "tifv",
                        "content": "There are several errors here. For starters, one can observe that `bool pass1,pass2 = true;` only initializes the second variable. Other problems include the end of resulting list not necessarily being set to `NULL`."
                    },
                    {
                        "username": "swapniljk14",
                        "content": "why it showing time limit exceeded?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "A tip for those of you who recognized quicksort partitioning, and are trying to implement it this way: don't.\nYou would get there eventually (I did), but quicksort partitioning is designed for arrays, not linked lists. \nFor a linked list there is a much more straightforward way to do it that will save you a lot of headaches with pointer management and edge cases. Good luck!"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is my Straightforward approach:-\n\n1. Create an ArrayList<Integer> to store the values of the input ListNode.\n2. Traverse the input ListNode, adding each value to the ArrayList<Integer>.\n3. Sort the ArrayList<Integer> using a Comparator that prioritizes values less than 3.\n4. Create a new ListNode from the sorted ArrayList<Integer>.\n5. Return the new ListNode.\n\n- Constraints friendly"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for help:-\\nhttps://leetcode.com/problems/partition-list/solutions/3303261/straightforward-brute-force-approach/"
                    },
                    {
                        "username": "Mirro0w0",
                        "content": "I feel so stupid.... :(\\nI know the logic but it took me almost 3 damn hours to code this"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "Statement is hella confusing. Think of it as you\\'re only allowed to move nodes with node.val<x while maintaining the relative order and leave the rest as it is."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "pahwagautam786",
                        "content": "Nice problem"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "The problem description doesn\\'t say, but I assume you can only manipulate the pointers of the original list nodes, and are not allowed to create new list nodes to copy the values over?"
                    },
                    {
                        "username": "aniketdali",
                        "content": "rearrange the list such that we can create  two logical partitions one < x and another x <="
                    }
                ]
            },
            {
                "id": 1852881,
                "content": [
                    {
                        "username": "Himatheja",
                        "content": "   ListNode* temp = head;\\n        ListNode* curr1 = head;\\n        ListNode* curr2 = head;\\n        ListNode* head1;\\n        ListNode* head2;\\n        bool pass1,pass2 = true;\\n        while(temp!=NULL){\\n            if(temp->val<x){\\n                 if(pass1){\\n                     pass1 = false;\\n                     head1 = temp;\\n                     curr1 = temp;\\n                     temp = temp->next;\\n                 }\\n                 else{\\n                     curr1->next = temp;\\n                     curr1=temp;\\n                     temp = temp->next;\\n                 }\\n            }\\n            else{\\n                if(pass2){\\n                     pass2 = false;\\n                     head2 = temp;\\n                     curr2 = temp;\\n                     temp = temp->next;\\n                 }\\n                 else{\\n                     curr2->next = temp;\\n                     curr2=temp;\\n                     temp = temp->next;\\n                 }\\n            }\\n            \\n        }\\n        curr1->next = head2;\\n        return\\xA0head1;\\nI still don\\'t get why it is giving tle;"
                    },
                    {
                        "username": "tifv",
                        "content": "There are several errors here. For starters, one can observe that `bool pass1,pass2 = true;` only initializes the second variable. Other problems include the end of resulting list not necessarily being set to `NULL`."
                    },
                    {
                        "username": "swapniljk14",
                        "content": "why it showing time limit exceeded?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "A tip for those of you who recognized quicksort partitioning, and are trying to implement it this way: don't.\nYou would get there eventually (I did), but quicksort partitioning is designed for arrays, not linked lists. \nFor a linked list there is a much more straightforward way to do it that will save you a lot of headaches with pointer management and edge cases. Good luck!"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is my Straightforward approach:-\n\n1. Create an ArrayList<Integer> to store the values of the input ListNode.\n2. Traverse the input ListNode, adding each value to the ArrayList<Integer>.\n3. Sort the ArrayList<Integer> using a Comparator that prioritizes values less than 3.\n4. Create a new ListNode from the sorted ArrayList<Integer>.\n5. Return the new ListNode.\n\n- Constraints friendly"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for help:-\\nhttps://leetcode.com/problems/partition-list/solutions/3303261/straightforward-brute-force-approach/"
                    },
                    {
                        "username": "Mirro0w0",
                        "content": "I feel so stupid.... :(\\nI know the logic but it took me almost 3 damn hours to code this"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "Statement is hella confusing. Think of it as you\\'re only allowed to move nodes with node.val<x while maintaining the relative order and leave the rest as it is."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "pahwagautam786",
                        "content": "Nice problem"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "The problem description doesn\\'t say, but I assume you can only manipulate the pointers of the original list nodes, and are not allowed to create new list nodes to copy the values over?"
                    },
                    {
                        "username": "aniketdali",
                        "content": "rearrange the list such that we can create  two logical partitions one < x and another x <="
                    }
                ]
            },
            {
                "id": 1833938,
                "content": [
                    {
                        "username": "Himatheja",
                        "content": "   ListNode* temp = head;\\n        ListNode* curr1 = head;\\n        ListNode* curr2 = head;\\n        ListNode* head1;\\n        ListNode* head2;\\n        bool pass1,pass2 = true;\\n        while(temp!=NULL){\\n            if(temp->val<x){\\n                 if(pass1){\\n                     pass1 = false;\\n                     head1 = temp;\\n                     curr1 = temp;\\n                     temp = temp->next;\\n                 }\\n                 else{\\n                     curr1->next = temp;\\n                     curr1=temp;\\n                     temp = temp->next;\\n                 }\\n            }\\n            else{\\n                if(pass2){\\n                     pass2 = false;\\n                     head2 = temp;\\n                     curr2 = temp;\\n                     temp = temp->next;\\n                 }\\n                 else{\\n                     curr2->next = temp;\\n                     curr2=temp;\\n                     temp = temp->next;\\n                 }\\n            }\\n            \\n        }\\n        curr1->next = head2;\\n        return\\xA0head1;\\nI still don\\'t get why it is giving tle;"
                    },
                    {
                        "username": "tifv",
                        "content": "There are several errors here. For starters, one can observe that `bool pass1,pass2 = true;` only initializes the second variable. Other problems include the end of resulting list not necessarily being set to `NULL`."
                    },
                    {
                        "username": "swapniljk14",
                        "content": "why it showing time limit exceeded?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "A tip for those of you who recognized quicksort partitioning, and are trying to implement it this way: don't.\nYou would get there eventually (I did), but quicksort partitioning is designed for arrays, not linked lists. \nFor a linked list there is a much more straightforward way to do it that will save you a lot of headaches with pointer management and edge cases. Good luck!"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is my Straightforward approach:-\n\n1. Create an ArrayList<Integer> to store the values of the input ListNode.\n2. Traverse the input ListNode, adding each value to the ArrayList<Integer>.\n3. Sort the ArrayList<Integer> using a Comparator that prioritizes values less than 3.\n4. Create a new ListNode from the sorted ArrayList<Integer>.\n5. Return the new ListNode.\n\n- Constraints friendly"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for help:-\\nhttps://leetcode.com/problems/partition-list/solutions/3303261/straightforward-brute-force-approach/"
                    },
                    {
                        "username": "Mirro0w0",
                        "content": "I feel so stupid.... :(\\nI know the logic but it took me almost 3 damn hours to code this"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "Statement is hella confusing. Think of it as you\\'re only allowed to move nodes with node.val<x while maintaining the relative order and leave the rest as it is."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "pahwagautam786",
                        "content": "Nice problem"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "The problem description doesn\\'t say, but I assume you can only manipulate the pointers of the original list nodes, and are not allowed to create new list nodes to copy the values over?"
                    },
                    {
                        "username": "aniketdali",
                        "content": "rearrange the list such that we can create  two logical partitions one < x and another x <="
                    }
                ]
            },
            {
                "id": 1829388,
                "content": [
                    {
                        "username": "Himatheja",
                        "content": "   ListNode* temp = head;\\n        ListNode* curr1 = head;\\n        ListNode* curr2 = head;\\n        ListNode* head1;\\n        ListNode* head2;\\n        bool pass1,pass2 = true;\\n        while(temp!=NULL){\\n            if(temp->val<x){\\n                 if(pass1){\\n                     pass1 = false;\\n                     head1 = temp;\\n                     curr1 = temp;\\n                     temp = temp->next;\\n                 }\\n                 else{\\n                     curr1->next = temp;\\n                     curr1=temp;\\n                     temp = temp->next;\\n                 }\\n            }\\n            else{\\n                if(pass2){\\n                     pass2 = false;\\n                     head2 = temp;\\n                     curr2 = temp;\\n                     temp = temp->next;\\n                 }\\n                 else{\\n                     curr2->next = temp;\\n                     curr2=temp;\\n                     temp = temp->next;\\n                 }\\n            }\\n            \\n        }\\n        curr1->next = head2;\\n        return\\xA0head1;\\nI still don\\'t get why it is giving tle;"
                    },
                    {
                        "username": "tifv",
                        "content": "There are several errors here. For starters, one can observe that `bool pass1,pass2 = true;` only initializes the second variable. Other problems include the end of resulting list not necessarily being set to `NULL`."
                    },
                    {
                        "username": "swapniljk14",
                        "content": "why it showing time limit exceeded?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "A tip for those of you who recognized quicksort partitioning, and are trying to implement it this way: don't.\nYou would get there eventually (I did), but quicksort partitioning is designed for arrays, not linked lists. \nFor a linked list there is a much more straightforward way to do it that will save you a lot of headaches with pointer management and edge cases. Good luck!"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is my Straightforward approach:-\n\n1. Create an ArrayList<Integer> to store the values of the input ListNode.\n2. Traverse the input ListNode, adding each value to the ArrayList<Integer>.\n3. Sort the ArrayList<Integer> using a Comparator that prioritizes values less than 3.\n4. Create a new ListNode from the sorted ArrayList<Integer>.\n5. Return the new ListNode.\n\n- Constraints friendly"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for help:-\\nhttps://leetcode.com/problems/partition-list/solutions/3303261/straightforward-brute-force-approach/"
                    },
                    {
                        "username": "Mirro0w0",
                        "content": "I feel so stupid.... :(\\nI know the logic but it took me almost 3 damn hours to code this"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "Statement is hella confusing. Think of it as you\\'re only allowed to move nodes with node.val<x while maintaining the relative order and leave the rest as it is."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "pahwagautam786",
                        "content": "Nice problem"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "The problem description doesn\\'t say, but I assume you can only manipulate the pointers of the original list nodes, and are not allowed to create new list nodes to copy the values over?"
                    },
                    {
                        "username": "aniketdali",
                        "content": "rearrange the list such that we can create  two logical partitions one < x and another x <="
                    }
                ]
            },
            {
                "id": 1798624,
                "content": [
                    {
                        "username": "Himatheja",
                        "content": "   ListNode* temp = head;\\n        ListNode* curr1 = head;\\n        ListNode* curr2 = head;\\n        ListNode* head1;\\n        ListNode* head2;\\n        bool pass1,pass2 = true;\\n        while(temp!=NULL){\\n            if(temp->val<x){\\n                 if(pass1){\\n                     pass1 = false;\\n                     head1 = temp;\\n                     curr1 = temp;\\n                     temp = temp->next;\\n                 }\\n                 else{\\n                     curr1->next = temp;\\n                     curr1=temp;\\n                     temp = temp->next;\\n                 }\\n            }\\n            else{\\n                if(pass2){\\n                     pass2 = false;\\n                     head2 = temp;\\n                     curr2 = temp;\\n                     temp = temp->next;\\n                 }\\n                 else{\\n                     curr2->next = temp;\\n                     curr2=temp;\\n                     temp = temp->next;\\n                 }\\n            }\\n            \\n        }\\n        curr1->next = head2;\\n        return\\xA0head1;\\nI still don\\'t get why it is giving tle;"
                    },
                    {
                        "username": "tifv",
                        "content": "There are several errors here. For starters, one can observe that `bool pass1,pass2 = true;` only initializes the second variable. Other problems include the end of resulting list not necessarily being set to `NULL`."
                    },
                    {
                        "username": "swapniljk14",
                        "content": "why it showing time limit exceeded?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "A tip for those of you who recognized quicksort partitioning, and are trying to implement it this way: don't.\nYou would get there eventually (I did), but quicksort partitioning is designed for arrays, not linked lists. \nFor a linked list there is a much more straightforward way to do it that will save you a lot of headaches with pointer management and edge cases. Good luck!"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is my Straightforward approach:-\n\n1. Create an ArrayList<Integer> to store the values of the input ListNode.\n2. Traverse the input ListNode, adding each value to the ArrayList<Integer>.\n3. Sort the ArrayList<Integer> using a Comparator that prioritizes values less than 3.\n4. Create a new ListNode from the sorted ArrayList<Integer>.\n5. Return the new ListNode.\n\n- Constraints friendly"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for help:-\\nhttps://leetcode.com/problems/partition-list/solutions/3303261/straightforward-brute-force-approach/"
                    },
                    {
                        "username": "Mirro0w0",
                        "content": "I feel so stupid.... :(\\nI know the logic but it took me almost 3 damn hours to code this"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "Statement is hella confusing. Think of it as you\\'re only allowed to move nodes with node.val<x while maintaining the relative order and leave the rest as it is."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "pahwagautam786",
                        "content": "Nice problem"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "The problem description doesn\\'t say, but I assume you can only manipulate the pointers of the original list nodes, and are not allowed to create new list nodes to copy the values over?"
                    },
                    {
                        "username": "aniketdali",
                        "content": "rearrange the list such that we can create  two logical partitions one < x and another x <="
                    }
                ]
            },
            {
                "id": 1760994,
                "content": [
                    {
                        "username": "Himatheja",
                        "content": "   ListNode* temp = head;\\n        ListNode* curr1 = head;\\n        ListNode* curr2 = head;\\n        ListNode* head1;\\n        ListNode* head2;\\n        bool pass1,pass2 = true;\\n        while(temp!=NULL){\\n            if(temp->val<x){\\n                 if(pass1){\\n                     pass1 = false;\\n                     head1 = temp;\\n                     curr1 = temp;\\n                     temp = temp->next;\\n                 }\\n                 else{\\n                     curr1->next = temp;\\n                     curr1=temp;\\n                     temp = temp->next;\\n                 }\\n            }\\n            else{\\n                if(pass2){\\n                     pass2 = false;\\n                     head2 = temp;\\n                     curr2 = temp;\\n                     temp = temp->next;\\n                 }\\n                 else{\\n                     curr2->next = temp;\\n                     curr2=temp;\\n                     temp = temp->next;\\n                 }\\n            }\\n            \\n        }\\n        curr1->next = head2;\\n        return\\xA0head1;\\nI still don\\'t get why it is giving tle;"
                    },
                    {
                        "username": "tifv",
                        "content": "There are several errors here. For starters, one can observe that `bool pass1,pass2 = true;` only initializes the second variable. Other problems include the end of resulting list not necessarily being set to `NULL`."
                    },
                    {
                        "username": "swapniljk14",
                        "content": "why it showing time limit exceeded?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "A tip for those of you who recognized quicksort partitioning, and are trying to implement it this way: don't.\nYou would get there eventually (I did), but quicksort partitioning is designed for arrays, not linked lists. \nFor a linked list there is a much more straightforward way to do it that will save you a lot of headaches with pointer management and edge cases. Good luck!"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is my Straightforward approach:-\n\n1. Create an ArrayList<Integer> to store the values of the input ListNode.\n2. Traverse the input ListNode, adding each value to the ArrayList<Integer>.\n3. Sort the ArrayList<Integer> using a Comparator that prioritizes values less than 3.\n4. Create a new ListNode from the sorted ArrayList<Integer>.\n5. Return the new ListNode.\n\n- Constraints friendly"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for help:-\\nhttps://leetcode.com/problems/partition-list/solutions/3303261/straightforward-brute-force-approach/"
                    },
                    {
                        "username": "Mirro0w0",
                        "content": "I feel so stupid.... :(\\nI know the logic but it took me almost 3 damn hours to code this"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "Statement is hella confusing. Think of it as you\\'re only allowed to move nodes with node.val<x while maintaining the relative order and leave the rest as it is."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "pahwagautam786",
                        "content": "Nice problem"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "The problem description doesn\\'t say, but I assume you can only manipulate the pointers of the original list nodes, and are not allowed to create new list nodes to copy the values over?"
                    },
                    {
                        "username": "aniketdali",
                        "content": "rearrange the list such that we can create  two logical partitions one < x and another x <="
                    }
                ]
            },
            {
                "id": 1754243,
                "content": [
                    {
                        "username": "Himatheja",
                        "content": "   ListNode* temp = head;\\n        ListNode* curr1 = head;\\n        ListNode* curr2 = head;\\n        ListNode* head1;\\n        ListNode* head2;\\n        bool pass1,pass2 = true;\\n        while(temp!=NULL){\\n            if(temp->val<x){\\n                 if(pass1){\\n                     pass1 = false;\\n                     head1 = temp;\\n                     curr1 = temp;\\n                     temp = temp->next;\\n                 }\\n                 else{\\n                     curr1->next = temp;\\n                     curr1=temp;\\n                     temp = temp->next;\\n                 }\\n            }\\n            else{\\n                if(pass2){\\n                     pass2 = false;\\n                     head2 = temp;\\n                     curr2 = temp;\\n                     temp = temp->next;\\n                 }\\n                 else{\\n                     curr2->next = temp;\\n                     curr2=temp;\\n                     temp = temp->next;\\n                 }\\n            }\\n            \\n        }\\n        curr1->next = head2;\\n        return\\xA0head1;\\nI still don\\'t get why it is giving tle;"
                    },
                    {
                        "username": "tifv",
                        "content": "There are several errors here. For starters, one can observe that `bool pass1,pass2 = true;` only initializes the second variable. Other problems include the end of resulting list not necessarily being set to `NULL`."
                    },
                    {
                        "username": "swapniljk14",
                        "content": "why it showing time limit exceeded?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "A tip for those of you who recognized quicksort partitioning, and are trying to implement it this way: don't.\nYou would get there eventually (I did), but quicksort partitioning is designed for arrays, not linked lists. \nFor a linked list there is a much more straightforward way to do it that will save you a lot of headaches with pointer management and edge cases. Good luck!"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is my Straightforward approach:-\n\n1. Create an ArrayList<Integer> to store the values of the input ListNode.\n2. Traverse the input ListNode, adding each value to the ArrayList<Integer>.\n3. Sort the ArrayList<Integer> using a Comparator that prioritizes values less than 3.\n4. Create a new ListNode from the sorted ArrayList<Integer>.\n5. Return the new ListNode.\n\n- Constraints friendly"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for help:-\\nhttps://leetcode.com/problems/partition-list/solutions/3303261/straightforward-brute-force-approach/"
                    },
                    {
                        "username": "Mirro0w0",
                        "content": "I feel so stupid.... :(\\nI know the logic but it took me almost 3 damn hours to code this"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "Statement is hella confusing. Think of it as you\\'re only allowed to move nodes with node.val<x while maintaining the relative order and leave the rest as it is."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "pahwagautam786",
                        "content": "Nice problem"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "The problem description doesn\\'t say, but I assume you can only manipulate the pointers of the original list nodes, and are not allowed to create new list nodes to copy the values over?"
                    },
                    {
                        "username": "aniketdali",
                        "content": "rearrange the list such that we can create  two logical partitions one < x and another x <="
                    }
                ]
            },
            {
                "id": 1733666,
                "content": [
                    {
                        "username": "Himatheja",
                        "content": "   ListNode* temp = head;\\n        ListNode* curr1 = head;\\n        ListNode* curr2 = head;\\n        ListNode* head1;\\n        ListNode* head2;\\n        bool pass1,pass2 = true;\\n        while(temp!=NULL){\\n            if(temp->val<x){\\n                 if(pass1){\\n                     pass1 = false;\\n                     head1 = temp;\\n                     curr1 = temp;\\n                     temp = temp->next;\\n                 }\\n                 else{\\n                     curr1->next = temp;\\n                     curr1=temp;\\n                     temp = temp->next;\\n                 }\\n            }\\n            else{\\n                if(pass2){\\n                     pass2 = false;\\n                     head2 = temp;\\n                     curr2 = temp;\\n                     temp = temp->next;\\n                 }\\n                 else{\\n                     curr2->next = temp;\\n                     curr2=temp;\\n                     temp = temp->next;\\n                 }\\n            }\\n            \\n        }\\n        curr1->next = head2;\\n        return\\xA0head1;\\nI still don\\'t get why it is giving tle;"
                    },
                    {
                        "username": "tifv",
                        "content": "There are several errors here. For starters, one can observe that `bool pass1,pass2 = true;` only initializes the second variable. Other problems include the end of resulting list not necessarily being set to `NULL`."
                    },
                    {
                        "username": "swapniljk14",
                        "content": "why it showing time limit exceeded?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "A tip for those of you who recognized quicksort partitioning, and are trying to implement it this way: don't.\nYou would get there eventually (I did), but quicksort partitioning is designed for arrays, not linked lists. \nFor a linked list there is a much more straightforward way to do it that will save you a lot of headaches with pointer management and edge cases. Good luck!"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is my Straightforward approach:-\n\n1. Create an ArrayList<Integer> to store the values of the input ListNode.\n2. Traverse the input ListNode, adding each value to the ArrayList<Integer>.\n3. Sort the ArrayList<Integer> using a Comparator that prioritizes values less than 3.\n4. Create a new ListNode from the sorted ArrayList<Integer>.\n5. Return the new ListNode.\n\n- Constraints friendly"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for help:-\\nhttps://leetcode.com/problems/partition-list/solutions/3303261/straightforward-brute-force-approach/"
                    },
                    {
                        "username": "Mirro0w0",
                        "content": "I feel so stupid.... :(\\nI know the logic but it took me almost 3 damn hours to code this"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "Statement is hella confusing. Think of it as you\\'re only allowed to move nodes with node.val<x while maintaining the relative order and leave the rest as it is."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "pahwagautam786",
                        "content": "Nice problem"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "The problem description doesn\\'t say, but I assume you can only manipulate the pointers of the original list nodes, and are not allowed to create new list nodes to copy the values over?"
                    },
                    {
                        "username": "aniketdali",
                        "content": "rearrange the list such that we can create  two logical partitions one < x and another x <="
                    }
                ]
            },
            {
                "id": 1692188,
                "content": [
                    {
                        "username": "Himatheja",
                        "content": "   ListNode* temp = head;\\n        ListNode* curr1 = head;\\n        ListNode* curr2 = head;\\n        ListNode* head1;\\n        ListNode* head2;\\n        bool pass1,pass2 = true;\\n        while(temp!=NULL){\\n            if(temp->val<x){\\n                 if(pass1){\\n                     pass1 = false;\\n                     head1 = temp;\\n                     curr1 = temp;\\n                     temp = temp->next;\\n                 }\\n                 else{\\n                     curr1->next = temp;\\n                     curr1=temp;\\n                     temp = temp->next;\\n                 }\\n            }\\n            else{\\n                if(pass2){\\n                     pass2 = false;\\n                     head2 = temp;\\n                     curr2 = temp;\\n                     temp = temp->next;\\n                 }\\n                 else{\\n                     curr2->next = temp;\\n                     curr2=temp;\\n                     temp = temp->next;\\n                 }\\n            }\\n            \\n        }\\n        curr1->next = head2;\\n        return\\xA0head1;\\nI still don\\'t get why it is giving tle;"
                    },
                    {
                        "username": "tifv",
                        "content": "There are several errors here. For starters, one can observe that `bool pass1,pass2 = true;` only initializes the second variable. Other problems include the end of resulting list not necessarily being set to `NULL`."
                    },
                    {
                        "username": "swapniljk14",
                        "content": "why it showing time limit exceeded?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "A tip for those of you who recognized quicksort partitioning, and are trying to implement it this way: don't.\nYou would get there eventually (I did), but quicksort partitioning is designed for arrays, not linked lists. \nFor a linked list there is a much more straightforward way to do it that will save you a lot of headaches with pointer management and edge cases. Good luck!"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is my Straightforward approach:-\n\n1. Create an ArrayList<Integer> to store the values of the input ListNode.\n2. Traverse the input ListNode, adding each value to the ArrayList<Integer>.\n3. Sort the ArrayList<Integer> using a Comparator that prioritizes values less than 3.\n4. Create a new ListNode from the sorted ArrayList<Integer>.\n5. Return the new ListNode.\n\n- Constraints friendly"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for help:-\\nhttps://leetcode.com/problems/partition-list/solutions/3303261/straightforward-brute-force-approach/"
                    },
                    {
                        "username": "Mirro0w0",
                        "content": "I feel so stupid.... :(\\nI know the logic but it took me almost 3 damn hours to code this"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "Statement is hella confusing. Think of it as you\\'re only allowed to move nodes with node.val<x while maintaining the relative order and leave the rest as it is."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "pahwagautam786",
                        "content": "Nice problem"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "The problem description doesn\\'t say, but I assume you can only manipulate the pointers of the original list nodes, and are not allowed to create new list nodes to copy the values over?"
                    },
                    {
                        "username": "aniketdali",
                        "content": "rearrange the list such that we can create  two logical partitions one < x and another x <="
                    }
                ]
            }
        ]
    },
    {
        "title": "Reverse Words in a String II",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1571833,
                "content": [
                    {
                        "username": "Kyochi",
                        "content": "Hello\\n\\ni don't understand why the time complexity is O(n) instead of O(n\\xb2) or O(n+kw) cause of reverse word operation. k number of word."
                    },
                    {
                        "username": "JustinAdams",
                        "content": "The loops aren\\'t nested"
                    },
                    {
                        "username": "thepha3drus",
                        "content": "It was an interview question at one of the BIG 4.  \\n\\nAt a high level, this seems like an application of breaking the input in chunks (intermedia files) and then merging the results. \\n\\nBut, I was looking for a solution that is more in-depth."
                    },
                    {
                        "username": "user3801tN",
                        "content": "its so annoying this question says allocate no extraspace, but it really means the space complexity must constant O(1)"
                    }
                ]
            },
            {
                "id": 1571392,
                "content": [
                    {
                        "username": "Kyochi",
                        "content": "Hello\\n\\ni don't understand why the time complexity is O(n) instead of O(n\\xb2) or O(n+kw) cause of reverse word operation. k number of word."
                    },
                    {
                        "username": "JustinAdams",
                        "content": "The loops aren\\'t nested"
                    },
                    {
                        "username": "thepha3drus",
                        "content": "It was an interview question at one of the BIG 4.  \\n\\nAt a high level, this seems like an application of breaking the input in chunks (intermedia files) and then merging the results. \\n\\nBut, I was looking for a solution that is more in-depth."
                    },
                    {
                        "username": "user3801tN",
                        "content": "its so annoying this question says allocate no extraspace, but it really means the space complexity must constant O(1)"
                    }
                ]
            },
            {
                "id": 1888564,
                "content": [
                    {
                        "username": "Kyochi",
                        "content": "Hello\\n\\ni don't understand why the time complexity is O(n) instead of O(n\\xb2) or O(n+kw) cause of reverse word operation. k number of word."
                    },
                    {
                        "username": "JustinAdams",
                        "content": "The loops aren\\'t nested"
                    },
                    {
                        "username": "thepha3drus",
                        "content": "It was an interview question at one of the BIG 4.  \\n\\nAt a high level, this seems like an application of breaking the input in chunks (intermedia files) and then merging the results. \\n\\nBut, I was looking for a solution that is more in-depth."
                    },
                    {
                        "username": "user3801tN",
                        "content": "its so annoying this question says allocate no extraspace, but it really means the space complexity must constant O(1)"
                    }
                ]
            }
        ]
    },
    {
        "title": "Walls and Gates",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1566253,
                "content": [
                    {
                        "username": "wzhwawhxm",
                        "content": "I think the time complexity of BFS and DFS are almost the same at the worst case, if we take care of the base case in recursion, we return as long as the current step is smaller than the cumulative one. Time(BFS) = Time(DFS) + 4mn\\n\\nI am confused about the time complexity here, what is the TC of DFS here, is it O((mn)^2)? If this is the worst case than what about the TC of BFS? Could someone help?..."
                    },
                    {
                        "username": "EugenYushin",
                        "content": "This problem lacks the description of possible directions to move. For example, is the diagonal distance is the same as vertical/horizontal? It\\'s turned out that you can move in 4 directions: up/down/left/right."
                    },
                    {
                        "username": "ingoscardan",
                        "content": "If you see the cell (3,3) it have 4, if you count the number of cell you have to visit to go to the nearest gate moving only on 4-directions, the count is 4, but if the directions were 8-direction then the count will be 3."
                    },
                    {
                        "username": "crackcoding2020",
                        "content": "When we are doing a BFS from a gate to an empty room, what if there is another gate on the way. Shouldn\\'t we just pass through the gate or are we assuming we wont encounter another gate when searching for the empty room. How does this solution takes care of that scenario?"
                    },
                    {
                        "username": "datfob",
                        "content": "HELP!! \\n\\nI got the solution but i\\'m a bit confused. If we run BFS from the first Gate, and updates all the empty rooms with shortest distance to the first Gate. When we run BFS on the second Gate, it won\\'t update the empty rooms anymore since it\\'s already updated. But what if there exists such room that is closer to the second gate than the first one? Then it will get the distance to the first gate but never the second gate?!!"
                    },
                    {
                        "username": "mahakpandia",
                        "content": "\nI am getting TLE for the 14th test case. Can someone help me out figure it how to resolve this\n\nclass Solution {\npublic:\n    \n    vector<int> x = {0, 0, -1, 1};\n    vector<int> y = {1, -1, 0, 0};\n\n    void dfs(vector<vector<int>>& rooms, int i, int j, int n, int m, int dis)\n    {\n        if(i==n or i<0 or j==m or j<0 or rooms[i][j] == -1 or rooms[i][j] == -10 or rooms[i][j] == 1)\n        {\n            return;\n        }\n        int temp = rooms[i][j];\n        rooms[i][j] = -10;\n        for(int it=0; it<4; it++)\n        {\n            dfs(rooms, i+x[it], j+y[it], n, m, dis+1);\n        }\n        rooms[i][j] = min(dis, temp);\n    }\n    void wallsAndGates(vector<vector<int>>& rooms) \n    {\n        int n = rooms.size();\n        int m = rooms[0].size();\n\n        for(int i=0; i<n; i++)\n        {\n            for(int j=0; j<m; j++)\n            {\n                if(rooms[i][j] == 0)\n                {\n                    dfs(rooms, i, j, n, m, 0);\n                }\n            }\n        }    \n    }\n};"
                    },
                    {
                        "username": "825800401",
                        "content": "I was wondering why dfs is about 2x faster than bfs? Aren't they all O(n)?"
                    },
                    {
                        "username": "AlexanderFSP",
                        "content": "I've got `terminate called after throwing an instance of 'std::bad_alloc'  what():  std::bad_alloc` error for my overengineered TypeScript solution :) Don't have an idea where the real problem, the message is just something..\n\n ```\nclass MyLinkedListNode<T> {\n    constructor(\n        public readonly val: T,\n        public next?: MyLinkedListNode<T>\n    ) {}\n}\n\nclass MyLinkedListQueue<T> {\n    private head?: MyLinkedListNode<T>;\n    private tail?: MyLinkedListNode<T>;\n    private _size = 0;\n\n    public get size(): number {\n        return this._size;\n    }\n\n    public set size(val: number) {\n        this._size = val;\n    }\n    \n    constructor(vals: T[] = []) {\n        for (const val of vals) {\n            this.enqueue(val);\n        }\n    }\n\n    public enqueue(val: T): void {\n        const node = new MyLinkedListNode<T>(val);\n        \n        if (this.tail) {\n            this.tail = this.tail.next = node;\n        } else {\n            this.head = this.tail = node;\n        }\n\n        this.size++;\n    }\n\n    public dequeue(): T | undefined {\n        const val = this.head?.val;\n\n        if (this.size <= 1) {\n            this.head = this.tail = undefined;\n            this.size = 0;\n            \n            return val;\n        }\n        \n        this.head = this.head.next;\n        this.size--;\n        \n        return val;\n    }\n}\n\nfunction wallsAndGates(rooms: number[][]): void {\n    const GATE = 0, WALL = -1;\n    \n    for (let i = 0; i < rooms.length; i++) {\n        for (let j = 0; j < rooms[i].length; j++) {            \n            if (rooms[i][j] !== GATE) {\n                continue;\n            }\n            \n            const queue = new MyLinkedListQueue<number[]>([[i, j]]);            \n            let step = 0;\n            \n            while (queue.size) {\n                const { size } = queue;\n                \n                for (let k = 0; k < size; k++) {\n                    const [l, m] = queue.dequeue();\n                    \n                    rooms[l][m] = step;\n                    \n                    [[l - 1, m], [l, m + 1], [l + 1, m], [l, m - 1]].forEach(idxes => {\n                       const el = rooms[idxes[0]]?.[idxes[1]];\n                                         \n                        if (el != null && el > step + 1) {\n                            queue.enqueue(idxes);\n                        }\n                    });\n                }\n                \n                step++;\n            }\n        }\n    }\n};\n```"
                    },
                    {
                        "username": "AlexanderFSP",
                        "content": "UPD: The problem was that there were situations when the one element was added to the queue multiple times. Here is the working final solution:\n\n```\nclass MyLinkedListNode<T> {\n    constructor(\n        public readonly val: T,\n        public next?: MyLinkedListNode<T>\n    ) {}\n}\n\nclass MyLinkedListQueue<T> {\n    private head?: MyLinkedListNode<T>;\n    private tail?: MyLinkedListNode<T>;\n    private _size = 0;\n\n    public get size(): number {\n        return this._size;\n    }\n\n    public set size(val: number) {\n        this._size = val;\n    }\n    \n    constructor(vals: T[] = []) {\n        for (const val of vals) {\n            this.enqueue(val);\n        }\n    }\n\n    public enqueue(val: T): void {\n        const node = new MyLinkedListNode<T>(val);\n        \n        if (this.tail) {\n            this.tail = this.tail.next = node;\n        } else {\n            this.head = this.tail = node;\n        }\n\n        this.size++;\n    }\n\n    public dequeue(): T | undefined {\n        const val = this.head?.val;\n\n        if (this.size <= 1) {\n            this.head = this.tail = undefined;\n            this.size = 0;\n            \n            return val;\n        }\n        \n        this.head = this.head.next;\n        this.size--;\n        \n        return val;\n    }\n}\n\nfunction wallsAndGates(rooms: number[][]): void {\n    const GATE = 0, WALL = -1;\n    \n    for (let i = 0; i < rooms.length; i++) {\n        for (let j = 0; j < rooms[i].length; j++) {            \n            if (rooms[i][j] !== GATE) {\n                continue;\n            }\n            \n            const queue = new MyLinkedListQueue<number[]>([[i, j]]);            \n            let step = 0;\n            \n            while (queue.size) {\n                const { size } = queue;\n                \n                for (let k = 0; k < size; k++) {\n                    const [l, m] = queue.dequeue();\n                                        \n                    [[l - 1, m], [l, m + 1], [l + 1, m], [l, m - 1]].forEach(idxes => {\n                       const el = rooms[idxes[0]]?.[idxes[1]];\n                                         \n                        if (el != null && el > step + 1) {\n                            rooms[idxes[0]][idxes[1]] = step + 1;                     \n                            queue.enqueue(idxes);\n                        }\n                    });\n                }\n                \n                step++;\n            }\n        }\n    }\n};\n```"
                    },
                    {
                        "username": "batchgott",
                        "content": "For anyone wondering: You can move **up**, **down**, **left** and **right**"
                    }
                ]
            },
            {
                "id": 1707418,
                "content": [
                    {
                        "username": "wzhwawhxm",
                        "content": "I think the time complexity of BFS and DFS are almost the same at the worst case, if we take care of the base case in recursion, we return as long as the current step is smaller than the cumulative one. Time(BFS) = Time(DFS) + 4mn\\n\\nI am confused about the time complexity here, what is the TC of DFS here, is it O((mn)^2)? If this is the worst case than what about the TC of BFS? Could someone help?..."
                    },
                    {
                        "username": "EugenYushin",
                        "content": "This problem lacks the description of possible directions to move. For example, is the diagonal distance is the same as vertical/horizontal? It\\'s turned out that you can move in 4 directions: up/down/left/right."
                    },
                    {
                        "username": "ingoscardan",
                        "content": "If you see the cell (3,3) it have 4, if you count the number of cell you have to visit to go to the nearest gate moving only on 4-directions, the count is 4, but if the directions were 8-direction then the count will be 3."
                    },
                    {
                        "username": "crackcoding2020",
                        "content": "When we are doing a BFS from a gate to an empty room, what if there is another gate on the way. Shouldn\\'t we just pass through the gate or are we assuming we wont encounter another gate when searching for the empty room. How does this solution takes care of that scenario?"
                    },
                    {
                        "username": "datfob",
                        "content": "HELP!! \\n\\nI got the solution but i\\'m a bit confused. If we run BFS from the first Gate, and updates all the empty rooms with shortest distance to the first Gate. When we run BFS on the second Gate, it won\\'t update the empty rooms anymore since it\\'s already updated. But what if there exists such room that is closer to the second gate than the first one? Then it will get the distance to the first gate but never the second gate?!!"
                    },
                    {
                        "username": "mahakpandia",
                        "content": "\nI am getting TLE for the 14th test case. Can someone help me out figure it how to resolve this\n\nclass Solution {\npublic:\n    \n    vector<int> x = {0, 0, -1, 1};\n    vector<int> y = {1, -1, 0, 0};\n\n    void dfs(vector<vector<int>>& rooms, int i, int j, int n, int m, int dis)\n    {\n        if(i==n or i<0 or j==m or j<0 or rooms[i][j] == -1 or rooms[i][j] == -10 or rooms[i][j] == 1)\n        {\n            return;\n        }\n        int temp = rooms[i][j];\n        rooms[i][j] = -10;\n        for(int it=0; it<4; it++)\n        {\n            dfs(rooms, i+x[it], j+y[it], n, m, dis+1);\n        }\n        rooms[i][j] = min(dis, temp);\n    }\n    void wallsAndGates(vector<vector<int>>& rooms) \n    {\n        int n = rooms.size();\n        int m = rooms[0].size();\n\n        for(int i=0; i<n; i++)\n        {\n            for(int j=0; j<m; j++)\n            {\n                if(rooms[i][j] == 0)\n                {\n                    dfs(rooms, i, j, n, m, 0);\n                }\n            }\n        }    \n    }\n};"
                    },
                    {
                        "username": "825800401",
                        "content": "I was wondering why dfs is about 2x faster than bfs? Aren't they all O(n)?"
                    },
                    {
                        "username": "AlexanderFSP",
                        "content": "I've got `terminate called after throwing an instance of 'std::bad_alloc'  what():  std::bad_alloc` error for my overengineered TypeScript solution :) Don't have an idea where the real problem, the message is just something..\n\n ```\nclass MyLinkedListNode<T> {\n    constructor(\n        public readonly val: T,\n        public next?: MyLinkedListNode<T>\n    ) {}\n}\n\nclass MyLinkedListQueue<T> {\n    private head?: MyLinkedListNode<T>;\n    private tail?: MyLinkedListNode<T>;\n    private _size = 0;\n\n    public get size(): number {\n        return this._size;\n    }\n\n    public set size(val: number) {\n        this._size = val;\n    }\n    \n    constructor(vals: T[] = []) {\n        for (const val of vals) {\n            this.enqueue(val);\n        }\n    }\n\n    public enqueue(val: T): void {\n        const node = new MyLinkedListNode<T>(val);\n        \n        if (this.tail) {\n            this.tail = this.tail.next = node;\n        } else {\n            this.head = this.tail = node;\n        }\n\n        this.size++;\n    }\n\n    public dequeue(): T | undefined {\n        const val = this.head?.val;\n\n        if (this.size <= 1) {\n            this.head = this.tail = undefined;\n            this.size = 0;\n            \n            return val;\n        }\n        \n        this.head = this.head.next;\n        this.size--;\n        \n        return val;\n    }\n}\n\nfunction wallsAndGates(rooms: number[][]): void {\n    const GATE = 0, WALL = -1;\n    \n    for (let i = 0; i < rooms.length; i++) {\n        for (let j = 0; j < rooms[i].length; j++) {            \n            if (rooms[i][j] !== GATE) {\n                continue;\n            }\n            \n            const queue = new MyLinkedListQueue<number[]>([[i, j]]);            \n            let step = 0;\n            \n            while (queue.size) {\n                const { size } = queue;\n                \n                for (let k = 0; k < size; k++) {\n                    const [l, m] = queue.dequeue();\n                    \n                    rooms[l][m] = step;\n                    \n                    [[l - 1, m], [l, m + 1], [l + 1, m], [l, m - 1]].forEach(idxes => {\n                       const el = rooms[idxes[0]]?.[idxes[1]];\n                                         \n                        if (el != null && el > step + 1) {\n                            queue.enqueue(idxes);\n                        }\n                    });\n                }\n                \n                step++;\n            }\n        }\n    }\n};\n```"
                    },
                    {
                        "username": "AlexanderFSP",
                        "content": "UPD: The problem was that there were situations when the one element was added to the queue multiple times. Here is the working final solution:\n\n```\nclass MyLinkedListNode<T> {\n    constructor(\n        public readonly val: T,\n        public next?: MyLinkedListNode<T>\n    ) {}\n}\n\nclass MyLinkedListQueue<T> {\n    private head?: MyLinkedListNode<T>;\n    private tail?: MyLinkedListNode<T>;\n    private _size = 0;\n\n    public get size(): number {\n        return this._size;\n    }\n\n    public set size(val: number) {\n        this._size = val;\n    }\n    \n    constructor(vals: T[] = []) {\n        for (const val of vals) {\n            this.enqueue(val);\n        }\n    }\n\n    public enqueue(val: T): void {\n        const node = new MyLinkedListNode<T>(val);\n        \n        if (this.tail) {\n            this.tail = this.tail.next = node;\n        } else {\n            this.head = this.tail = node;\n        }\n\n        this.size++;\n    }\n\n    public dequeue(): T | undefined {\n        const val = this.head?.val;\n\n        if (this.size <= 1) {\n            this.head = this.tail = undefined;\n            this.size = 0;\n            \n            return val;\n        }\n        \n        this.head = this.head.next;\n        this.size--;\n        \n        return val;\n    }\n}\n\nfunction wallsAndGates(rooms: number[][]): void {\n    const GATE = 0, WALL = -1;\n    \n    for (let i = 0; i < rooms.length; i++) {\n        for (let j = 0; j < rooms[i].length; j++) {            \n            if (rooms[i][j] !== GATE) {\n                continue;\n            }\n            \n            const queue = new MyLinkedListQueue<number[]>([[i, j]]);            \n            let step = 0;\n            \n            while (queue.size) {\n                const { size } = queue;\n                \n                for (let k = 0; k < size; k++) {\n                    const [l, m] = queue.dequeue();\n                                        \n                    [[l - 1, m], [l, m + 1], [l + 1, m], [l, m - 1]].forEach(idxes => {\n                       const el = rooms[idxes[0]]?.[idxes[1]];\n                                         \n                        if (el != null && el > step + 1) {\n                            rooms[idxes[0]][idxes[1]] = step + 1;                     \n                            queue.enqueue(idxes);\n                        }\n                    });\n                }\n                \n                step++;\n            }\n        }\n    }\n};\n```"
                    },
                    {
                        "username": "batchgott",
                        "content": "For anyone wondering: You can move **up**, **down**, **left** and **right**"
                    }
                ]
            },
            {
                "id": 1569716,
                "content": [
                    {
                        "username": "wzhwawhxm",
                        "content": "I think the time complexity of BFS and DFS are almost the same at the worst case, if we take care of the base case in recursion, we return as long as the current step is smaller than the cumulative one. Time(BFS) = Time(DFS) + 4mn\\n\\nI am confused about the time complexity here, what is the TC of DFS here, is it O((mn)^2)? If this is the worst case than what about the TC of BFS? Could someone help?..."
                    },
                    {
                        "username": "EugenYushin",
                        "content": "This problem lacks the description of possible directions to move. For example, is the diagonal distance is the same as vertical/horizontal? It\\'s turned out that you can move in 4 directions: up/down/left/right."
                    },
                    {
                        "username": "ingoscardan",
                        "content": "If you see the cell (3,3) it have 4, if you count the number of cell you have to visit to go to the nearest gate moving only on 4-directions, the count is 4, but if the directions were 8-direction then the count will be 3."
                    },
                    {
                        "username": "crackcoding2020",
                        "content": "When we are doing a BFS from a gate to an empty room, what if there is another gate on the way. Shouldn\\'t we just pass through the gate or are we assuming we wont encounter another gate when searching for the empty room. How does this solution takes care of that scenario?"
                    },
                    {
                        "username": "datfob",
                        "content": "HELP!! \\n\\nI got the solution but i\\'m a bit confused. If we run BFS from the first Gate, and updates all the empty rooms with shortest distance to the first Gate. When we run BFS on the second Gate, it won\\'t update the empty rooms anymore since it\\'s already updated. But what if there exists such room that is closer to the second gate than the first one? Then it will get the distance to the first gate but never the second gate?!!"
                    },
                    {
                        "username": "mahakpandia",
                        "content": "\nI am getting TLE for the 14th test case. Can someone help me out figure it how to resolve this\n\nclass Solution {\npublic:\n    \n    vector<int> x = {0, 0, -1, 1};\n    vector<int> y = {1, -1, 0, 0};\n\n    void dfs(vector<vector<int>>& rooms, int i, int j, int n, int m, int dis)\n    {\n        if(i==n or i<0 or j==m or j<0 or rooms[i][j] == -1 or rooms[i][j] == -10 or rooms[i][j] == 1)\n        {\n            return;\n        }\n        int temp = rooms[i][j];\n        rooms[i][j] = -10;\n        for(int it=0; it<4; it++)\n        {\n            dfs(rooms, i+x[it], j+y[it], n, m, dis+1);\n        }\n        rooms[i][j] = min(dis, temp);\n    }\n    void wallsAndGates(vector<vector<int>>& rooms) \n    {\n        int n = rooms.size();\n        int m = rooms[0].size();\n\n        for(int i=0; i<n; i++)\n        {\n            for(int j=0; j<m; j++)\n            {\n                if(rooms[i][j] == 0)\n                {\n                    dfs(rooms, i, j, n, m, 0);\n                }\n            }\n        }    \n    }\n};"
                    },
                    {
                        "username": "825800401",
                        "content": "I was wondering why dfs is about 2x faster than bfs? Aren't they all O(n)?"
                    },
                    {
                        "username": "AlexanderFSP",
                        "content": "I've got `terminate called after throwing an instance of 'std::bad_alloc'  what():  std::bad_alloc` error for my overengineered TypeScript solution :) Don't have an idea where the real problem, the message is just something..\n\n ```\nclass MyLinkedListNode<T> {\n    constructor(\n        public readonly val: T,\n        public next?: MyLinkedListNode<T>\n    ) {}\n}\n\nclass MyLinkedListQueue<T> {\n    private head?: MyLinkedListNode<T>;\n    private tail?: MyLinkedListNode<T>;\n    private _size = 0;\n\n    public get size(): number {\n        return this._size;\n    }\n\n    public set size(val: number) {\n        this._size = val;\n    }\n    \n    constructor(vals: T[] = []) {\n        for (const val of vals) {\n            this.enqueue(val);\n        }\n    }\n\n    public enqueue(val: T): void {\n        const node = new MyLinkedListNode<T>(val);\n        \n        if (this.tail) {\n            this.tail = this.tail.next = node;\n        } else {\n            this.head = this.tail = node;\n        }\n\n        this.size++;\n    }\n\n    public dequeue(): T | undefined {\n        const val = this.head?.val;\n\n        if (this.size <= 1) {\n            this.head = this.tail = undefined;\n            this.size = 0;\n            \n            return val;\n        }\n        \n        this.head = this.head.next;\n        this.size--;\n        \n        return val;\n    }\n}\n\nfunction wallsAndGates(rooms: number[][]): void {\n    const GATE = 0, WALL = -1;\n    \n    for (let i = 0; i < rooms.length; i++) {\n        for (let j = 0; j < rooms[i].length; j++) {            \n            if (rooms[i][j] !== GATE) {\n                continue;\n            }\n            \n            const queue = new MyLinkedListQueue<number[]>([[i, j]]);            \n            let step = 0;\n            \n            while (queue.size) {\n                const { size } = queue;\n                \n                for (let k = 0; k < size; k++) {\n                    const [l, m] = queue.dequeue();\n                    \n                    rooms[l][m] = step;\n                    \n                    [[l - 1, m], [l, m + 1], [l + 1, m], [l, m - 1]].forEach(idxes => {\n                       const el = rooms[idxes[0]]?.[idxes[1]];\n                                         \n                        if (el != null && el > step + 1) {\n                            queue.enqueue(idxes);\n                        }\n                    });\n                }\n                \n                step++;\n            }\n        }\n    }\n};\n```"
                    },
                    {
                        "username": "AlexanderFSP",
                        "content": "UPD: The problem was that there were situations when the one element was added to the queue multiple times. Here is the working final solution:\n\n```\nclass MyLinkedListNode<T> {\n    constructor(\n        public readonly val: T,\n        public next?: MyLinkedListNode<T>\n    ) {}\n}\n\nclass MyLinkedListQueue<T> {\n    private head?: MyLinkedListNode<T>;\n    private tail?: MyLinkedListNode<T>;\n    private _size = 0;\n\n    public get size(): number {\n        return this._size;\n    }\n\n    public set size(val: number) {\n        this._size = val;\n    }\n    \n    constructor(vals: T[] = []) {\n        for (const val of vals) {\n            this.enqueue(val);\n        }\n    }\n\n    public enqueue(val: T): void {\n        const node = new MyLinkedListNode<T>(val);\n        \n        if (this.tail) {\n            this.tail = this.tail.next = node;\n        } else {\n            this.head = this.tail = node;\n        }\n\n        this.size++;\n    }\n\n    public dequeue(): T | undefined {\n        const val = this.head?.val;\n\n        if (this.size <= 1) {\n            this.head = this.tail = undefined;\n            this.size = 0;\n            \n            return val;\n        }\n        \n        this.head = this.head.next;\n        this.size--;\n        \n        return val;\n    }\n}\n\nfunction wallsAndGates(rooms: number[][]): void {\n    const GATE = 0, WALL = -1;\n    \n    for (let i = 0; i < rooms.length; i++) {\n        for (let j = 0; j < rooms[i].length; j++) {            \n            if (rooms[i][j] !== GATE) {\n                continue;\n            }\n            \n            const queue = new MyLinkedListQueue<number[]>([[i, j]]);            \n            let step = 0;\n            \n            while (queue.size) {\n                const { size } = queue;\n                \n                for (let k = 0; k < size; k++) {\n                    const [l, m] = queue.dequeue();\n                                        \n                    [[l - 1, m], [l, m + 1], [l + 1, m], [l, m - 1]].forEach(idxes => {\n                       const el = rooms[idxes[0]]?.[idxes[1]];\n                                         \n                        if (el != null && el > step + 1) {\n                            rooms[idxes[0]][idxes[1]] = step + 1;                     \n                            queue.enqueue(idxes);\n                        }\n                    });\n                }\n                \n                step++;\n            }\n        }\n    }\n};\n```"
                    },
                    {
                        "username": "batchgott",
                        "content": "For anyone wondering: You can move **up**, **down**, **left** and **right**"
                    }
                ]
            },
            {
                "id": 1987853,
                "content": [
                    {
                        "username": "wzhwawhxm",
                        "content": "I think the time complexity of BFS and DFS are almost the same at the worst case, if we take care of the base case in recursion, we return as long as the current step is smaller than the cumulative one. Time(BFS) = Time(DFS) + 4mn\\n\\nI am confused about the time complexity here, what is the TC of DFS here, is it O((mn)^2)? If this is the worst case than what about the TC of BFS? Could someone help?..."
                    },
                    {
                        "username": "EugenYushin",
                        "content": "This problem lacks the description of possible directions to move. For example, is the diagonal distance is the same as vertical/horizontal? It\\'s turned out that you can move in 4 directions: up/down/left/right."
                    },
                    {
                        "username": "ingoscardan",
                        "content": "If you see the cell (3,3) it have 4, if you count the number of cell you have to visit to go to the nearest gate moving only on 4-directions, the count is 4, but if the directions were 8-direction then the count will be 3."
                    },
                    {
                        "username": "crackcoding2020",
                        "content": "When we are doing a BFS from a gate to an empty room, what if there is another gate on the way. Shouldn\\'t we just pass through the gate or are we assuming we wont encounter another gate when searching for the empty room. How does this solution takes care of that scenario?"
                    },
                    {
                        "username": "datfob",
                        "content": "HELP!! \\n\\nI got the solution but i\\'m a bit confused. If we run BFS from the first Gate, and updates all the empty rooms with shortest distance to the first Gate. When we run BFS on the second Gate, it won\\'t update the empty rooms anymore since it\\'s already updated. But what if there exists such room that is closer to the second gate than the first one? Then it will get the distance to the first gate but never the second gate?!!"
                    },
                    {
                        "username": "mahakpandia",
                        "content": "\nI am getting TLE for the 14th test case. Can someone help me out figure it how to resolve this\n\nclass Solution {\npublic:\n    \n    vector<int> x = {0, 0, -1, 1};\n    vector<int> y = {1, -1, 0, 0};\n\n    void dfs(vector<vector<int>>& rooms, int i, int j, int n, int m, int dis)\n    {\n        if(i==n or i<0 or j==m or j<0 or rooms[i][j] == -1 or rooms[i][j] == -10 or rooms[i][j] == 1)\n        {\n            return;\n        }\n        int temp = rooms[i][j];\n        rooms[i][j] = -10;\n        for(int it=0; it<4; it++)\n        {\n            dfs(rooms, i+x[it], j+y[it], n, m, dis+1);\n        }\n        rooms[i][j] = min(dis, temp);\n    }\n    void wallsAndGates(vector<vector<int>>& rooms) \n    {\n        int n = rooms.size();\n        int m = rooms[0].size();\n\n        for(int i=0; i<n; i++)\n        {\n            for(int j=0; j<m; j++)\n            {\n                if(rooms[i][j] == 0)\n                {\n                    dfs(rooms, i, j, n, m, 0);\n                }\n            }\n        }    \n    }\n};"
                    },
                    {
                        "username": "825800401",
                        "content": "I was wondering why dfs is about 2x faster than bfs? Aren't they all O(n)?"
                    },
                    {
                        "username": "AlexanderFSP",
                        "content": "I've got `terminate called after throwing an instance of 'std::bad_alloc'  what():  std::bad_alloc` error for my overengineered TypeScript solution :) Don't have an idea where the real problem, the message is just something..\n\n ```\nclass MyLinkedListNode<T> {\n    constructor(\n        public readonly val: T,\n        public next?: MyLinkedListNode<T>\n    ) {}\n}\n\nclass MyLinkedListQueue<T> {\n    private head?: MyLinkedListNode<T>;\n    private tail?: MyLinkedListNode<T>;\n    private _size = 0;\n\n    public get size(): number {\n        return this._size;\n    }\n\n    public set size(val: number) {\n        this._size = val;\n    }\n    \n    constructor(vals: T[] = []) {\n        for (const val of vals) {\n            this.enqueue(val);\n        }\n    }\n\n    public enqueue(val: T): void {\n        const node = new MyLinkedListNode<T>(val);\n        \n        if (this.tail) {\n            this.tail = this.tail.next = node;\n        } else {\n            this.head = this.tail = node;\n        }\n\n        this.size++;\n    }\n\n    public dequeue(): T | undefined {\n        const val = this.head?.val;\n\n        if (this.size <= 1) {\n            this.head = this.tail = undefined;\n            this.size = 0;\n            \n            return val;\n        }\n        \n        this.head = this.head.next;\n        this.size--;\n        \n        return val;\n    }\n}\n\nfunction wallsAndGates(rooms: number[][]): void {\n    const GATE = 0, WALL = -1;\n    \n    for (let i = 0; i < rooms.length; i++) {\n        for (let j = 0; j < rooms[i].length; j++) {            \n            if (rooms[i][j] !== GATE) {\n                continue;\n            }\n            \n            const queue = new MyLinkedListQueue<number[]>([[i, j]]);            \n            let step = 0;\n            \n            while (queue.size) {\n                const { size } = queue;\n                \n                for (let k = 0; k < size; k++) {\n                    const [l, m] = queue.dequeue();\n                    \n                    rooms[l][m] = step;\n                    \n                    [[l - 1, m], [l, m + 1], [l + 1, m], [l, m - 1]].forEach(idxes => {\n                       const el = rooms[idxes[0]]?.[idxes[1]];\n                                         \n                        if (el != null && el > step + 1) {\n                            queue.enqueue(idxes);\n                        }\n                    });\n                }\n                \n                step++;\n            }\n        }\n    }\n};\n```"
                    },
                    {
                        "username": "AlexanderFSP",
                        "content": "UPD: The problem was that there were situations when the one element was added to the queue multiple times. Here is the working final solution:\n\n```\nclass MyLinkedListNode<T> {\n    constructor(\n        public readonly val: T,\n        public next?: MyLinkedListNode<T>\n    ) {}\n}\n\nclass MyLinkedListQueue<T> {\n    private head?: MyLinkedListNode<T>;\n    private tail?: MyLinkedListNode<T>;\n    private _size = 0;\n\n    public get size(): number {\n        return this._size;\n    }\n\n    public set size(val: number) {\n        this._size = val;\n    }\n    \n    constructor(vals: T[] = []) {\n        for (const val of vals) {\n            this.enqueue(val);\n        }\n    }\n\n    public enqueue(val: T): void {\n        const node = new MyLinkedListNode<T>(val);\n        \n        if (this.tail) {\n            this.tail = this.tail.next = node;\n        } else {\n            this.head = this.tail = node;\n        }\n\n        this.size++;\n    }\n\n    public dequeue(): T | undefined {\n        const val = this.head?.val;\n\n        if (this.size <= 1) {\n            this.head = this.tail = undefined;\n            this.size = 0;\n            \n            return val;\n        }\n        \n        this.head = this.head.next;\n        this.size--;\n        \n        return val;\n    }\n}\n\nfunction wallsAndGates(rooms: number[][]): void {\n    const GATE = 0, WALL = -1;\n    \n    for (let i = 0; i < rooms.length; i++) {\n        for (let j = 0; j < rooms[i].length; j++) {            \n            if (rooms[i][j] !== GATE) {\n                continue;\n            }\n            \n            const queue = new MyLinkedListQueue<number[]>([[i, j]]);            \n            let step = 0;\n            \n            while (queue.size) {\n                const { size } = queue;\n                \n                for (let k = 0; k < size; k++) {\n                    const [l, m] = queue.dequeue();\n                                        \n                    [[l - 1, m], [l, m + 1], [l + 1, m], [l, m - 1]].forEach(idxes => {\n                       const el = rooms[idxes[0]]?.[idxes[1]];\n                                         \n                        if (el != null && el > step + 1) {\n                            rooms[idxes[0]][idxes[1]] = step + 1;                     \n                            queue.enqueue(idxes);\n                        }\n                    });\n                }\n                \n                step++;\n            }\n        }\n    }\n};\n```"
                    },
                    {
                        "username": "batchgott",
                        "content": "For anyone wondering: You can move **up**, **down**, **left** and **right**"
                    }
                ]
            },
            {
                "id": 1721078,
                "content": [
                    {
                        "username": "wzhwawhxm",
                        "content": "I think the time complexity of BFS and DFS are almost the same at the worst case, if we take care of the base case in recursion, we return as long as the current step is smaller than the cumulative one. Time(BFS) = Time(DFS) + 4mn\\n\\nI am confused about the time complexity here, what is the TC of DFS here, is it O((mn)^2)? If this is the worst case than what about the TC of BFS? Could someone help?..."
                    },
                    {
                        "username": "EugenYushin",
                        "content": "This problem lacks the description of possible directions to move. For example, is the diagonal distance is the same as vertical/horizontal? It\\'s turned out that you can move in 4 directions: up/down/left/right."
                    },
                    {
                        "username": "ingoscardan",
                        "content": "If you see the cell (3,3) it have 4, if you count the number of cell you have to visit to go to the nearest gate moving only on 4-directions, the count is 4, but if the directions were 8-direction then the count will be 3."
                    },
                    {
                        "username": "crackcoding2020",
                        "content": "When we are doing a BFS from a gate to an empty room, what if there is another gate on the way. Shouldn\\'t we just pass through the gate or are we assuming we wont encounter another gate when searching for the empty room. How does this solution takes care of that scenario?"
                    },
                    {
                        "username": "datfob",
                        "content": "HELP!! \\n\\nI got the solution but i\\'m a bit confused. If we run BFS from the first Gate, and updates all the empty rooms with shortest distance to the first Gate. When we run BFS on the second Gate, it won\\'t update the empty rooms anymore since it\\'s already updated. But what if there exists such room that is closer to the second gate than the first one? Then it will get the distance to the first gate but never the second gate?!!"
                    },
                    {
                        "username": "mahakpandia",
                        "content": "\nI am getting TLE for the 14th test case. Can someone help me out figure it how to resolve this\n\nclass Solution {\npublic:\n    \n    vector<int> x = {0, 0, -1, 1};\n    vector<int> y = {1, -1, 0, 0};\n\n    void dfs(vector<vector<int>>& rooms, int i, int j, int n, int m, int dis)\n    {\n        if(i==n or i<0 or j==m or j<0 or rooms[i][j] == -1 or rooms[i][j] == -10 or rooms[i][j] == 1)\n        {\n            return;\n        }\n        int temp = rooms[i][j];\n        rooms[i][j] = -10;\n        for(int it=0; it<4; it++)\n        {\n            dfs(rooms, i+x[it], j+y[it], n, m, dis+1);\n        }\n        rooms[i][j] = min(dis, temp);\n    }\n    void wallsAndGates(vector<vector<int>>& rooms) \n    {\n        int n = rooms.size();\n        int m = rooms[0].size();\n\n        for(int i=0; i<n; i++)\n        {\n            for(int j=0; j<m; j++)\n            {\n                if(rooms[i][j] == 0)\n                {\n                    dfs(rooms, i, j, n, m, 0);\n                }\n            }\n        }    \n    }\n};"
                    },
                    {
                        "username": "825800401",
                        "content": "I was wondering why dfs is about 2x faster than bfs? Aren't they all O(n)?"
                    },
                    {
                        "username": "AlexanderFSP",
                        "content": "I've got `terminate called after throwing an instance of 'std::bad_alloc'  what():  std::bad_alloc` error for my overengineered TypeScript solution :) Don't have an idea where the real problem, the message is just something..\n\n ```\nclass MyLinkedListNode<T> {\n    constructor(\n        public readonly val: T,\n        public next?: MyLinkedListNode<T>\n    ) {}\n}\n\nclass MyLinkedListQueue<T> {\n    private head?: MyLinkedListNode<T>;\n    private tail?: MyLinkedListNode<T>;\n    private _size = 0;\n\n    public get size(): number {\n        return this._size;\n    }\n\n    public set size(val: number) {\n        this._size = val;\n    }\n    \n    constructor(vals: T[] = []) {\n        for (const val of vals) {\n            this.enqueue(val);\n        }\n    }\n\n    public enqueue(val: T): void {\n        const node = new MyLinkedListNode<T>(val);\n        \n        if (this.tail) {\n            this.tail = this.tail.next = node;\n        } else {\n            this.head = this.tail = node;\n        }\n\n        this.size++;\n    }\n\n    public dequeue(): T | undefined {\n        const val = this.head?.val;\n\n        if (this.size <= 1) {\n            this.head = this.tail = undefined;\n            this.size = 0;\n            \n            return val;\n        }\n        \n        this.head = this.head.next;\n        this.size--;\n        \n        return val;\n    }\n}\n\nfunction wallsAndGates(rooms: number[][]): void {\n    const GATE = 0, WALL = -1;\n    \n    for (let i = 0; i < rooms.length; i++) {\n        for (let j = 0; j < rooms[i].length; j++) {            \n            if (rooms[i][j] !== GATE) {\n                continue;\n            }\n            \n            const queue = new MyLinkedListQueue<number[]>([[i, j]]);            \n            let step = 0;\n            \n            while (queue.size) {\n                const { size } = queue;\n                \n                for (let k = 0; k < size; k++) {\n                    const [l, m] = queue.dequeue();\n                    \n                    rooms[l][m] = step;\n                    \n                    [[l - 1, m], [l, m + 1], [l + 1, m], [l, m - 1]].forEach(idxes => {\n                       const el = rooms[idxes[0]]?.[idxes[1]];\n                                         \n                        if (el != null && el > step + 1) {\n                            queue.enqueue(idxes);\n                        }\n                    });\n                }\n                \n                step++;\n            }\n        }\n    }\n};\n```"
                    },
                    {
                        "username": "AlexanderFSP",
                        "content": "UPD: The problem was that there were situations when the one element was added to the queue multiple times. Here is the working final solution:\n\n```\nclass MyLinkedListNode<T> {\n    constructor(\n        public readonly val: T,\n        public next?: MyLinkedListNode<T>\n    ) {}\n}\n\nclass MyLinkedListQueue<T> {\n    private head?: MyLinkedListNode<T>;\n    private tail?: MyLinkedListNode<T>;\n    private _size = 0;\n\n    public get size(): number {\n        return this._size;\n    }\n\n    public set size(val: number) {\n        this._size = val;\n    }\n    \n    constructor(vals: T[] = []) {\n        for (const val of vals) {\n            this.enqueue(val);\n        }\n    }\n\n    public enqueue(val: T): void {\n        const node = new MyLinkedListNode<T>(val);\n        \n        if (this.tail) {\n            this.tail = this.tail.next = node;\n        } else {\n            this.head = this.tail = node;\n        }\n\n        this.size++;\n    }\n\n    public dequeue(): T | undefined {\n        const val = this.head?.val;\n\n        if (this.size <= 1) {\n            this.head = this.tail = undefined;\n            this.size = 0;\n            \n            return val;\n        }\n        \n        this.head = this.head.next;\n        this.size--;\n        \n        return val;\n    }\n}\n\nfunction wallsAndGates(rooms: number[][]): void {\n    const GATE = 0, WALL = -1;\n    \n    for (let i = 0; i < rooms.length; i++) {\n        for (let j = 0; j < rooms[i].length; j++) {            \n            if (rooms[i][j] !== GATE) {\n                continue;\n            }\n            \n            const queue = new MyLinkedListQueue<number[]>([[i, j]]);            \n            let step = 0;\n            \n            while (queue.size) {\n                const { size } = queue;\n                \n                for (let k = 0; k < size; k++) {\n                    const [l, m] = queue.dequeue();\n                                        \n                    [[l - 1, m], [l, m + 1], [l + 1, m], [l, m - 1]].forEach(idxes => {\n                       const el = rooms[idxes[0]]?.[idxes[1]];\n                                         \n                        if (el != null && el > step + 1) {\n                            rooms[idxes[0]][idxes[1]] = step + 1;                     \n                            queue.enqueue(idxes);\n                        }\n                    });\n                }\n                \n                step++;\n            }\n        }\n    }\n};\n```"
                    },
                    {
                        "username": "batchgott",
                        "content": "For anyone wondering: You can move **up**, **down**, **left** and **right**"
                    }
                ]
            },
            {
                "id": 1571530,
                "content": [
                    {
                        "username": "wzhwawhxm",
                        "content": "I think the time complexity of BFS and DFS are almost the same at the worst case, if we take care of the base case in recursion, we return as long as the current step is smaller than the cumulative one. Time(BFS) = Time(DFS) + 4mn\\n\\nI am confused about the time complexity here, what is the TC of DFS here, is it O((mn)^2)? If this is the worst case than what about the TC of BFS? Could someone help?..."
                    },
                    {
                        "username": "EugenYushin",
                        "content": "This problem lacks the description of possible directions to move. For example, is the diagonal distance is the same as vertical/horizontal? It\\'s turned out that you can move in 4 directions: up/down/left/right."
                    },
                    {
                        "username": "ingoscardan",
                        "content": "If you see the cell (3,3) it have 4, if you count the number of cell you have to visit to go to the nearest gate moving only on 4-directions, the count is 4, but if the directions were 8-direction then the count will be 3."
                    },
                    {
                        "username": "crackcoding2020",
                        "content": "When we are doing a BFS from a gate to an empty room, what if there is another gate on the way. Shouldn\\'t we just pass through the gate or are we assuming we wont encounter another gate when searching for the empty room. How does this solution takes care of that scenario?"
                    },
                    {
                        "username": "datfob",
                        "content": "HELP!! \\n\\nI got the solution but i\\'m a bit confused. If we run BFS from the first Gate, and updates all the empty rooms with shortest distance to the first Gate. When we run BFS on the second Gate, it won\\'t update the empty rooms anymore since it\\'s already updated. But what if there exists such room that is closer to the second gate than the first one? Then it will get the distance to the first gate but never the second gate?!!"
                    },
                    {
                        "username": "mahakpandia",
                        "content": "\nI am getting TLE for the 14th test case. Can someone help me out figure it how to resolve this\n\nclass Solution {\npublic:\n    \n    vector<int> x = {0, 0, -1, 1};\n    vector<int> y = {1, -1, 0, 0};\n\n    void dfs(vector<vector<int>>& rooms, int i, int j, int n, int m, int dis)\n    {\n        if(i==n or i<0 or j==m or j<0 or rooms[i][j] == -1 or rooms[i][j] == -10 or rooms[i][j] == 1)\n        {\n            return;\n        }\n        int temp = rooms[i][j];\n        rooms[i][j] = -10;\n        for(int it=0; it<4; it++)\n        {\n            dfs(rooms, i+x[it], j+y[it], n, m, dis+1);\n        }\n        rooms[i][j] = min(dis, temp);\n    }\n    void wallsAndGates(vector<vector<int>>& rooms) \n    {\n        int n = rooms.size();\n        int m = rooms[0].size();\n\n        for(int i=0; i<n; i++)\n        {\n            for(int j=0; j<m; j++)\n            {\n                if(rooms[i][j] == 0)\n                {\n                    dfs(rooms, i, j, n, m, 0);\n                }\n            }\n        }    \n    }\n};"
                    },
                    {
                        "username": "825800401",
                        "content": "I was wondering why dfs is about 2x faster than bfs? Aren't they all O(n)?"
                    },
                    {
                        "username": "AlexanderFSP",
                        "content": "I've got `terminate called after throwing an instance of 'std::bad_alloc'  what():  std::bad_alloc` error for my overengineered TypeScript solution :) Don't have an idea where the real problem, the message is just something..\n\n ```\nclass MyLinkedListNode<T> {\n    constructor(\n        public readonly val: T,\n        public next?: MyLinkedListNode<T>\n    ) {}\n}\n\nclass MyLinkedListQueue<T> {\n    private head?: MyLinkedListNode<T>;\n    private tail?: MyLinkedListNode<T>;\n    private _size = 0;\n\n    public get size(): number {\n        return this._size;\n    }\n\n    public set size(val: number) {\n        this._size = val;\n    }\n    \n    constructor(vals: T[] = []) {\n        for (const val of vals) {\n            this.enqueue(val);\n        }\n    }\n\n    public enqueue(val: T): void {\n        const node = new MyLinkedListNode<T>(val);\n        \n        if (this.tail) {\n            this.tail = this.tail.next = node;\n        } else {\n            this.head = this.tail = node;\n        }\n\n        this.size++;\n    }\n\n    public dequeue(): T | undefined {\n        const val = this.head?.val;\n\n        if (this.size <= 1) {\n            this.head = this.tail = undefined;\n            this.size = 0;\n            \n            return val;\n        }\n        \n        this.head = this.head.next;\n        this.size--;\n        \n        return val;\n    }\n}\n\nfunction wallsAndGates(rooms: number[][]): void {\n    const GATE = 0, WALL = -1;\n    \n    for (let i = 0; i < rooms.length; i++) {\n        for (let j = 0; j < rooms[i].length; j++) {            \n            if (rooms[i][j] !== GATE) {\n                continue;\n            }\n            \n            const queue = new MyLinkedListQueue<number[]>([[i, j]]);            \n            let step = 0;\n            \n            while (queue.size) {\n                const { size } = queue;\n                \n                for (let k = 0; k < size; k++) {\n                    const [l, m] = queue.dequeue();\n                    \n                    rooms[l][m] = step;\n                    \n                    [[l - 1, m], [l, m + 1], [l + 1, m], [l, m - 1]].forEach(idxes => {\n                       const el = rooms[idxes[0]]?.[idxes[1]];\n                                         \n                        if (el != null && el > step + 1) {\n                            queue.enqueue(idxes);\n                        }\n                    });\n                }\n                \n                step++;\n            }\n        }\n    }\n};\n```"
                    },
                    {
                        "username": "AlexanderFSP",
                        "content": "UPD: The problem was that there were situations when the one element was added to the queue multiple times. Here is the working final solution:\n\n```\nclass MyLinkedListNode<T> {\n    constructor(\n        public readonly val: T,\n        public next?: MyLinkedListNode<T>\n    ) {}\n}\n\nclass MyLinkedListQueue<T> {\n    private head?: MyLinkedListNode<T>;\n    private tail?: MyLinkedListNode<T>;\n    private _size = 0;\n\n    public get size(): number {\n        return this._size;\n    }\n\n    public set size(val: number) {\n        this._size = val;\n    }\n    \n    constructor(vals: T[] = []) {\n        for (const val of vals) {\n            this.enqueue(val);\n        }\n    }\n\n    public enqueue(val: T): void {\n        const node = new MyLinkedListNode<T>(val);\n        \n        if (this.tail) {\n            this.tail = this.tail.next = node;\n        } else {\n            this.head = this.tail = node;\n        }\n\n        this.size++;\n    }\n\n    public dequeue(): T | undefined {\n        const val = this.head?.val;\n\n        if (this.size <= 1) {\n            this.head = this.tail = undefined;\n            this.size = 0;\n            \n            return val;\n        }\n        \n        this.head = this.head.next;\n        this.size--;\n        \n        return val;\n    }\n}\n\nfunction wallsAndGates(rooms: number[][]): void {\n    const GATE = 0, WALL = -1;\n    \n    for (let i = 0; i < rooms.length; i++) {\n        for (let j = 0; j < rooms[i].length; j++) {            \n            if (rooms[i][j] !== GATE) {\n                continue;\n            }\n            \n            const queue = new MyLinkedListQueue<number[]>([[i, j]]);            \n            let step = 0;\n            \n            while (queue.size) {\n                const { size } = queue;\n                \n                for (let k = 0; k < size; k++) {\n                    const [l, m] = queue.dequeue();\n                                        \n                    [[l - 1, m], [l, m + 1], [l + 1, m], [l, m - 1]].forEach(idxes => {\n                       const el = rooms[idxes[0]]?.[idxes[1]];\n                                         \n                        if (el != null && el > step + 1) {\n                            rooms[idxes[0]][idxes[1]] = step + 1;                     \n                            queue.enqueue(idxes);\n                        }\n                    });\n                }\n                \n                step++;\n            }\n        }\n    }\n};\n```"
                    },
                    {
                        "username": "batchgott",
                        "content": "For anyone wondering: You can move **up**, **down**, **left** and **right**"
                    }
                ]
            },
            {
                "id": 2003716,
                "content": [
                    {
                        "username": "wzhwawhxm",
                        "content": "I think the time complexity of BFS and DFS are almost the same at the worst case, if we take care of the base case in recursion, we return as long as the current step is smaller than the cumulative one. Time(BFS) = Time(DFS) + 4mn\\n\\nI am confused about the time complexity here, what is the TC of DFS here, is it O((mn)^2)? If this is the worst case than what about the TC of BFS? Could someone help?..."
                    },
                    {
                        "username": "EugenYushin",
                        "content": "This problem lacks the description of possible directions to move. For example, is the diagonal distance is the same as vertical/horizontal? It\\'s turned out that you can move in 4 directions: up/down/left/right."
                    },
                    {
                        "username": "ingoscardan",
                        "content": "If you see the cell (3,3) it have 4, if you count the number of cell you have to visit to go to the nearest gate moving only on 4-directions, the count is 4, but if the directions were 8-direction then the count will be 3."
                    },
                    {
                        "username": "crackcoding2020",
                        "content": "When we are doing a BFS from a gate to an empty room, what if there is another gate on the way. Shouldn\\'t we just pass through the gate or are we assuming we wont encounter another gate when searching for the empty room. How does this solution takes care of that scenario?"
                    },
                    {
                        "username": "datfob",
                        "content": "HELP!! \\n\\nI got the solution but i\\'m a bit confused. If we run BFS from the first Gate, and updates all the empty rooms with shortest distance to the first Gate. When we run BFS on the second Gate, it won\\'t update the empty rooms anymore since it\\'s already updated. But what if there exists such room that is closer to the second gate than the first one? Then it will get the distance to the first gate but never the second gate?!!"
                    },
                    {
                        "username": "mahakpandia",
                        "content": "\nI am getting TLE for the 14th test case. Can someone help me out figure it how to resolve this\n\nclass Solution {\npublic:\n    \n    vector<int> x = {0, 0, -1, 1};\n    vector<int> y = {1, -1, 0, 0};\n\n    void dfs(vector<vector<int>>& rooms, int i, int j, int n, int m, int dis)\n    {\n        if(i==n or i<0 or j==m or j<0 or rooms[i][j] == -1 or rooms[i][j] == -10 or rooms[i][j] == 1)\n        {\n            return;\n        }\n        int temp = rooms[i][j];\n        rooms[i][j] = -10;\n        for(int it=0; it<4; it++)\n        {\n            dfs(rooms, i+x[it], j+y[it], n, m, dis+1);\n        }\n        rooms[i][j] = min(dis, temp);\n    }\n    void wallsAndGates(vector<vector<int>>& rooms) \n    {\n        int n = rooms.size();\n        int m = rooms[0].size();\n\n        for(int i=0; i<n; i++)\n        {\n            for(int j=0; j<m; j++)\n            {\n                if(rooms[i][j] == 0)\n                {\n                    dfs(rooms, i, j, n, m, 0);\n                }\n            }\n        }    \n    }\n};"
                    },
                    {
                        "username": "825800401",
                        "content": "I was wondering why dfs is about 2x faster than bfs? Aren't they all O(n)?"
                    },
                    {
                        "username": "AlexanderFSP",
                        "content": "I've got `terminate called after throwing an instance of 'std::bad_alloc'  what():  std::bad_alloc` error for my overengineered TypeScript solution :) Don't have an idea where the real problem, the message is just something..\n\n ```\nclass MyLinkedListNode<T> {\n    constructor(\n        public readonly val: T,\n        public next?: MyLinkedListNode<T>\n    ) {}\n}\n\nclass MyLinkedListQueue<T> {\n    private head?: MyLinkedListNode<T>;\n    private tail?: MyLinkedListNode<T>;\n    private _size = 0;\n\n    public get size(): number {\n        return this._size;\n    }\n\n    public set size(val: number) {\n        this._size = val;\n    }\n    \n    constructor(vals: T[] = []) {\n        for (const val of vals) {\n            this.enqueue(val);\n        }\n    }\n\n    public enqueue(val: T): void {\n        const node = new MyLinkedListNode<T>(val);\n        \n        if (this.tail) {\n            this.tail = this.tail.next = node;\n        } else {\n            this.head = this.tail = node;\n        }\n\n        this.size++;\n    }\n\n    public dequeue(): T | undefined {\n        const val = this.head?.val;\n\n        if (this.size <= 1) {\n            this.head = this.tail = undefined;\n            this.size = 0;\n            \n            return val;\n        }\n        \n        this.head = this.head.next;\n        this.size--;\n        \n        return val;\n    }\n}\n\nfunction wallsAndGates(rooms: number[][]): void {\n    const GATE = 0, WALL = -1;\n    \n    for (let i = 0; i < rooms.length; i++) {\n        for (let j = 0; j < rooms[i].length; j++) {            \n            if (rooms[i][j] !== GATE) {\n                continue;\n            }\n            \n            const queue = new MyLinkedListQueue<number[]>([[i, j]]);            \n            let step = 0;\n            \n            while (queue.size) {\n                const { size } = queue;\n                \n                for (let k = 0; k < size; k++) {\n                    const [l, m] = queue.dequeue();\n                    \n                    rooms[l][m] = step;\n                    \n                    [[l - 1, m], [l, m + 1], [l + 1, m], [l, m - 1]].forEach(idxes => {\n                       const el = rooms[idxes[0]]?.[idxes[1]];\n                                         \n                        if (el != null && el > step + 1) {\n                            queue.enqueue(idxes);\n                        }\n                    });\n                }\n                \n                step++;\n            }\n        }\n    }\n};\n```"
                    },
                    {
                        "username": "AlexanderFSP",
                        "content": "UPD: The problem was that there were situations when the one element was added to the queue multiple times. Here is the working final solution:\n\n```\nclass MyLinkedListNode<T> {\n    constructor(\n        public readonly val: T,\n        public next?: MyLinkedListNode<T>\n    ) {}\n}\n\nclass MyLinkedListQueue<T> {\n    private head?: MyLinkedListNode<T>;\n    private tail?: MyLinkedListNode<T>;\n    private _size = 0;\n\n    public get size(): number {\n        return this._size;\n    }\n\n    public set size(val: number) {\n        this._size = val;\n    }\n    \n    constructor(vals: T[] = []) {\n        for (const val of vals) {\n            this.enqueue(val);\n        }\n    }\n\n    public enqueue(val: T): void {\n        const node = new MyLinkedListNode<T>(val);\n        \n        if (this.tail) {\n            this.tail = this.tail.next = node;\n        } else {\n            this.head = this.tail = node;\n        }\n\n        this.size++;\n    }\n\n    public dequeue(): T | undefined {\n        const val = this.head?.val;\n\n        if (this.size <= 1) {\n            this.head = this.tail = undefined;\n            this.size = 0;\n            \n            return val;\n        }\n        \n        this.head = this.head.next;\n        this.size--;\n        \n        return val;\n    }\n}\n\nfunction wallsAndGates(rooms: number[][]): void {\n    const GATE = 0, WALL = -1;\n    \n    for (let i = 0; i < rooms.length; i++) {\n        for (let j = 0; j < rooms[i].length; j++) {            \n            if (rooms[i][j] !== GATE) {\n                continue;\n            }\n            \n            const queue = new MyLinkedListQueue<number[]>([[i, j]]);            \n            let step = 0;\n            \n            while (queue.size) {\n                const { size } = queue;\n                \n                for (let k = 0; k < size; k++) {\n                    const [l, m] = queue.dequeue();\n                                        \n                    [[l - 1, m], [l, m + 1], [l + 1, m], [l, m - 1]].forEach(idxes => {\n                       const el = rooms[idxes[0]]?.[idxes[1]];\n                                         \n                        if (el != null && el > step + 1) {\n                            rooms[idxes[0]][idxes[1]] = step + 1;                     \n                            queue.enqueue(idxes);\n                        }\n                    });\n                }\n                \n                step++;\n            }\n        }\n    }\n};\n```"
                    },
                    {
                        "username": "batchgott",
                        "content": "For anyone wondering: You can move **up**, **down**, **left** and **right**"
                    }
                ]
            },
            {
                "id": 1723673,
                "content": [
                    {
                        "username": "wzhwawhxm",
                        "content": "I think the time complexity of BFS and DFS are almost the same at the worst case, if we take care of the base case in recursion, we return as long as the current step is smaller than the cumulative one. Time(BFS) = Time(DFS) + 4mn\\n\\nI am confused about the time complexity here, what is the TC of DFS here, is it O((mn)^2)? If this is the worst case than what about the TC of BFS? Could someone help?..."
                    },
                    {
                        "username": "EugenYushin",
                        "content": "This problem lacks the description of possible directions to move. For example, is the diagonal distance is the same as vertical/horizontal? It\\'s turned out that you can move in 4 directions: up/down/left/right."
                    },
                    {
                        "username": "ingoscardan",
                        "content": "If you see the cell (3,3) it have 4, if you count the number of cell you have to visit to go to the nearest gate moving only on 4-directions, the count is 4, but if the directions were 8-direction then the count will be 3."
                    },
                    {
                        "username": "crackcoding2020",
                        "content": "When we are doing a BFS from a gate to an empty room, what if there is another gate on the way. Shouldn\\'t we just pass through the gate or are we assuming we wont encounter another gate when searching for the empty room. How does this solution takes care of that scenario?"
                    },
                    {
                        "username": "datfob",
                        "content": "HELP!! \\n\\nI got the solution but i\\'m a bit confused. If we run BFS from the first Gate, and updates all the empty rooms with shortest distance to the first Gate. When we run BFS on the second Gate, it won\\'t update the empty rooms anymore since it\\'s already updated. But what if there exists such room that is closer to the second gate than the first one? Then it will get the distance to the first gate but never the second gate?!!"
                    },
                    {
                        "username": "mahakpandia",
                        "content": "\nI am getting TLE for the 14th test case. Can someone help me out figure it how to resolve this\n\nclass Solution {\npublic:\n    \n    vector<int> x = {0, 0, -1, 1};\n    vector<int> y = {1, -1, 0, 0};\n\n    void dfs(vector<vector<int>>& rooms, int i, int j, int n, int m, int dis)\n    {\n        if(i==n or i<0 or j==m or j<0 or rooms[i][j] == -1 or rooms[i][j] == -10 or rooms[i][j] == 1)\n        {\n            return;\n        }\n        int temp = rooms[i][j];\n        rooms[i][j] = -10;\n        for(int it=0; it<4; it++)\n        {\n            dfs(rooms, i+x[it], j+y[it], n, m, dis+1);\n        }\n        rooms[i][j] = min(dis, temp);\n    }\n    void wallsAndGates(vector<vector<int>>& rooms) \n    {\n        int n = rooms.size();\n        int m = rooms[0].size();\n\n        for(int i=0; i<n; i++)\n        {\n            for(int j=0; j<m; j++)\n            {\n                if(rooms[i][j] == 0)\n                {\n                    dfs(rooms, i, j, n, m, 0);\n                }\n            }\n        }    \n    }\n};"
                    },
                    {
                        "username": "825800401",
                        "content": "I was wondering why dfs is about 2x faster than bfs? Aren't they all O(n)?"
                    },
                    {
                        "username": "AlexanderFSP",
                        "content": "I've got `terminate called after throwing an instance of 'std::bad_alloc'  what():  std::bad_alloc` error for my overengineered TypeScript solution :) Don't have an idea where the real problem, the message is just something..\n\n ```\nclass MyLinkedListNode<T> {\n    constructor(\n        public readonly val: T,\n        public next?: MyLinkedListNode<T>\n    ) {}\n}\n\nclass MyLinkedListQueue<T> {\n    private head?: MyLinkedListNode<T>;\n    private tail?: MyLinkedListNode<T>;\n    private _size = 0;\n\n    public get size(): number {\n        return this._size;\n    }\n\n    public set size(val: number) {\n        this._size = val;\n    }\n    \n    constructor(vals: T[] = []) {\n        for (const val of vals) {\n            this.enqueue(val);\n        }\n    }\n\n    public enqueue(val: T): void {\n        const node = new MyLinkedListNode<T>(val);\n        \n        if (this.tail) {\n            this.tail = this.tail.next = node;\n        } else {\n            this.head = this.tail = node;\n        }\n\n        this.size++;\n    }\n\n    public dequeue(): T | undefined {\n        const val = this.head?.val;\n\n        if (this.size <= 1) {\n            this.head = this.tail = undefined;\n            this.size = 0;\n            \n            return val;\n        }\n        \n        this.head = this.head.next;\n        this.size--;\n        \n        return val;\n    }\n}\n\nfunction wallsAndGates(rooms: number[][]): void {\n    const GATE = 0, WALL = -1;\n    \n    for (let i = 0; i < rooms.length; i++) {\n        for (let j = 0; j < rooms[i].length; j++) {            \n            if (rooms[i][j] !== GATE) {\n                continue;\n            }\n            \n            const queue = new MyLinkedListQueue<number[]>([[i, j]]);            \n            let step = 0;\n            \n            while (queue.size) {\n                const { size } = queue;\n                \n                for (let k = 0; k < size; k++) {\n                    const [l, m] = queue.dequeue();\n                    \n                    rooms[l][m] = step;\n                    \n                    [[l - 1, m], [l, m + 1], [l + 1, m], [l, m - 1]].forEach(idxes => {\n                       const el = rooms[idxes[0]]?.[idxes[1]];\n                                         \n                        if (el != null && el > step + 1) {\n                            queue.enqueue(idxes);\n                        }\n                    });\n                }\n                \n                step++;\n            }\n        }\n    }\n};\n```"
                    },
                    {
                        "username": "AlexanderFSP",
                        "content": "UPD: The problem was that there were situations when the one element was added to the queue multiple times. Here is the working final solution:\n\n```\nclass MyLinkedListNode<T> {\n    constructor(\n        public readonly val: T,\n        public next?: MyLinkedListNode<T>\n    ) {}\n}\n\nclass MyLinkedListQueue<T> {\n    private head?: MyLinkedListNode<T>;\n    private tail?: MyLinkedListNode<T>;\n    private _size = 0;\n\n    public get size(): number {\n        return this._size;\n    }\n\n    public set size(val: number) {\n        this._size = val;\n    }\n    \n    constructor(vals: T[] = []) {\n        for (const val of vals) {\n            this.enqueue(val);\n        }\n    }\n\n    public enqueue(val: T): void {\n        const node = new MyLinkedListNode<T>(val);\n        \n        if (this.tail) {\n            this.tail = this.tail.next = node;\n        } else {\n            this.head = this.tail = node;\n        }\n\n        this.size++;\n    }\n\n    public dequeue(): T | undefined {\n        const val = this.head?.val;\n\n        if (this.size <= 1) {\n            this.head = this.tail = undefined;\n            this.size = 0;\n            \n            return val;\n        }\n        \n        this.head = this.head.next;\n        this.size--;\n        \n        return val;\n    }\n}\n\nfunction wallsAndGates(rooms: number[][]): void {\n    const GATE = 0, WALL = -1;\n    \n    for (let i = 0; i < rooms.length; i++) {\n        for (let j = 0; j < rooms[i].length; j++) {            \n            if (rooms[i][j] !== GATE) {\n                continue;\n            }\n            \n            const queue = new MyLinkedListQueue<number[]>([[i, j]]);            \n            let step = 0;\n            \n            while (queue.size) {\n                const { size } = queue;\n                \n                for (let k = 0; k < size; k++) {\n                    const [l, m] = queue.dequeue();\n                                        \n                    [[l - 1, m], [l, m + 1], [l + 1, m], [l, m - 1]].forEach(idxes => {\n                       const el = rooms[idxes[0]]?.[idxes[1]];\n                                         \n                        if (el != null && el > step + 1) {\n                            rooms[idxes[0]][idxes[1]] = step + 1;                     \n                            queue.enqueue(idxes);\n                        }\n                    });\n                }\n                \n                step++;\n            }\n        }\n    }\n};\n```"
                    },
                    {
                        "username": "batchgott",
                        "content": "For anyone wondering: You can move **up**, **down**, **left** and **right**"
                    }
                ]
            }
        ]
    },
    {
        "title": "Lexicographical Numbers",
        "question_content": "<p>Given an integer <code>n</code>, return all the numbers in the range <code>[1, n]</code> sorted in lexicographical order.</p>\n\n<p>You must write an algorithm that runs in&nbsp;<code>O(n)</code>&nbsp;time and uses <code>O(1)</code> extra space.&nbsp;</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> n = 13\n<strong>Output:</strong> [1,10,11,12,13,2,3,4,5,6,7,8,9]\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> n = 2\n<strong>Output:</strong> [1,2]\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 5 * 10<sup>4</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 86231,
                "title": "simple-java-dfs-solution",
                "content": "\\n```\\nThe idea is pretty simple. If we look at the order we can find out we just keep adding digit from 0 to 9 to every digit and make it a tree.\\nThen we visit every node in pre-order. \\n       1        2        3    ...\\n      /\\\\        /\\\\       /\\\\\\n   10 ...19  20...29  30...39   ....\\n\\n```\\n\\n\\n```\\npublic class Solution {\\n    public List<Integer> lexicalOrder(int n) {\\n        List<Integer> res = new ArrayList<>();\\n        for(int i=1;i<10;++i){\\n          dfs(i, n, res); \\n        }\\n        return res;\\n    }\\n    \\n    public void dfs(int cur, int n, List<Integer> res){\\n        if(cur>n)\\n            return;\\n        else{\\n            res.add(cur);\\n            for(int i=0;i<10;++i){\\n                if(10*cur+i>n)\\n                    return;\\n                dfs(10*cur+i, n, res);\\n            }\\n        }\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nThe idea is pretty simple. If we look at the order we can find out we just keep adding digit from 0 to 9 to every digit and make it a tree.\\nThen we visit every node in pre-order. \\n       1        2        3    ...\\n      /\\\\        /\\\\       /\\\\\\n   10 ...19  20...29  30...39   ....\\n\\n```\n```\\npublic class Solution {\\n    public List<Integer> lexicalOrder(int n) {\\n        List<Integer> res = new ArrayList<>();\\n        for(int i=1;i<10;++i){\\n          dfs(i, n, res); \\n        }\\n        return res;\\n    }\\n    \\n    public void dfs(int cur, int n, List<Integer> res){\\n        if(cur>n)\\n            return;\\n        else{\\n            res.add(cur);\\n            for(int i=0;i<10;++i){\\n                if(10*cur+i>n)\\n                    return;\\n                dfs(10*cur+i, n, res);\\n            }\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 86242,
                "title": "java-o-n-time-o-1-space-iterative-solution-130ms",
                "content": "```\\npublic List<Integer> lexicalOrder(int n) {\\n        List<Integer> list = new ArrayList<>(n);\\n        int curr = 1;\\n        for (int i = 1; i <= n; i++) {\\n            list.add(curr);\\n            if (curr * 10 <= n) {\\n                curr *= 10;\\n            } else if (curr % 10 != 9 && curr + 1 <= n) {\\n                curr++;\\n            } else {\\n                while ((curr / 10) % 10 == 9) {\\n                    curr /= 10;\\n                }\\n                curr = curr / 10 + 1;\\n            }\\n        }\\n        return list;\\n    }\\n```\\n\\nThe basic idea is to find the next number to add.\\nTake 45 for example: if the current number is 45, the next one will be 450 (450 == 45 * 10)(if 450 <= n), or 46 (46 == 45 + 1) (if 46 <= n) or 5 (5 == 45 / 10 + 1)(5 is less than 45 so it is for sure less than n).\\nWe should also consider n = 600, and the current number = 499, the next number is 5 because there are all \"9\"s after \"4\" in \"499\" so we should divide 499 by 10 until the last digit is not \"9\".\\nIt is like a tree, and we are easy to get a sibling, a left most child and the parent of any node.",
                "solutionTags": [],
                "code": "```\\npublic List<Integer> lexicalOrder(int n) {\\n        List<Integer> list = new ArrayList<>(n);\\n        int curr = 1;\\n        for (int i = 1; i <= n; i++) {\\n            list.add(curr);\\n            if (curr * 10 <= n) {\\n                curr *= 10;\\n            } else if (curr % 10 != 9 && curr + 1 <= n) {\\n                curr++;\\n            } else {\\n                while ((curr / 10) % 10 == 9) {\\n                    curr /= 10;\\n                }\\n                curr = curr / 10 + 1;\\n            }\\n        }\\n        return list;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 86237,
                "title": "ac-200ms-c-solution-beats-98",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> lexicalOrder(int n) {\\n        vector<int> res(n);\\n        int cur = 1;\\n        for (int i = 0; i < n; i++) {\\n            res[i] = cur;\\n            if (cur * 10 <= n) {\\n                cur *= 10;\\n            } else {\\n                if (cur >= n) \\n                    cur /= 10;\\n                cur += 1;\\n                while (cur % 10 == 0)\\n                    cur /= 10;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> lexicalOrder(int n) {\\n        vector<int> res(n);\\n        int cur = 1;\\n        for (int i = 0; i < n; i++) {\\n            res[i] = cur;\\n            if (cur * 10 <= n) {\\n                cur *= 10;\\n            } else {\\n                if (cur >= n) \\n                    cur /= 10;\\n                cur += 1;\\n                while (cur % 10 == 0)\\n                    cur /= 10;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 86228,
                "title": "the-most-elegant-python-solution-so-far-10-liner-iterative-o-n-time-o-1-space",
                "content": "Simple. easy to understand. No fking weird, rarely used built-int functions.\\n'''\\n\\n    class Solution(object):\\n        def lexicalOrder(self, n):\\n            ans = [1]\\n            while len(ans) < n:\\n                new = ans[-1] * 10\\n                while new > n:\\n                    new /= 10\\n                    new += 1\\n                    while new % 10 == 0:    # deal with case like 199+1=200 when we need to restart from 2.\\n                        new /= 10\\n                ans.append(new)    \\n            return ans\\n'''",
                "solutionTags": [],
                "code": "Simple. easy to understand. No fking weird, rarely used built-int functions.\\n'''\\n\\n    class Solution(object):\\n        def lexicalOrder(self, n):\\n            ans = [1]\\n            while len(ans) < n:\\n                new = ans[-1] * 10\\n                while new > n:\\n                    new /= 10\\n                    new += 1\\n                    while new % 10 == 0:    # deal with case like 199+1=200 when we need to restart from 2.\\n                        new /= 10\\n                ans.append(new)    \\n            return ans\\n'''",
                "codeTag": "Java"
            },
            {
                "id": 86288,
                "title": "7-lines-simple-c-recursive-solution",
                "content": "Just repeatedly try from 1 to 9, 1 -> 10 -> 100 first, and then plus 1 to the deepest number. Take 13 as example:\\n```1 -> 10 -> (100) -> 11 -> (110) -> 12 -> (120) -> 13 -> (130) -> (14) -> 2 -> (20) ... -> 9 -> (90) ```\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> lexicalOrder(int n) {\\n        vector<int> res;\\n        helper(1, n, res);\\n        return res;\\n    }\\n    \\n    void helper(int target, int n, vector<int>& res) {\\n        if (target > n) return;\\n        res.push_back(target);\\n        helper(target * 10, n, res);\\n        if (target % 10 != 9) helper(target+1, n, res);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```1 -> 10 -> (100) -> 11 -> (110) -> 12 -> (120) -> 13 -> (130) -> (14) -> 2 -> (20) ... -> 9 -> (90) ```\n```\\nclass Solution {\\npublic:\\n    vector<int> lexicalOrder(int n) {\\n        vector<int> res;\\n        helper(1, n, res);\\n        return res;\\n    }\\n    \\n    void helper(int target, int n, vector<int>& res) {\\n        if (target > n) return;\\n        res.push_back(target);\\n        helper(target * 10, n, res);\\n        if (target % 10 != 9) helper(target+1, n, res);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 86235,
                "title": "python-with-sorting",
                "content": "Three accepted solutions and me rambling on about failed attempts :-D\\n\\n<br>\\n\\n## Solution 1 <sup>(accepted in 1792, 1747, 1700 ms)</sup>\\n\\nI just sort the numbers 1 to n using my custom comparison. To compare two numbers, I \"left-shift\" them both before comparing them. For example if n = 49999, then I left-shift numbers so they're five digits. That is, 42 becomes 42000 and 123 becomes 12300. In case of ties, e.g., 420 also becoming 42000, the stability of `sorted` keeps them in order.\\n```\\ndef lexicalOrder(self, n):\\n    top = 1\\n    while top * 10 <= n:\\n        top *= 10\\n    def mycmp(a, b, top=top):\\n        while a < top: a *= 10\\n        while b < top: b *= 10\\n        return -1 if a < b else b < a\\n    return sorted(xrange(1, n+1), mycmp)\\n```\\n\\n<br>\\n\\n## Solution 2 <sup>(accepted in 1268, 1508, 1320, 1356, 1336 ms)</sup>\\n```\\ndef lexicalOrder(self, n):\\n    withKeys = []\\n    for i in xrange(1, n+1):\\n        key = i\\n        while key < 1000000:\\n            key *= 10\\n        withKeys.append(key * 10000000 + i)\\n    withKeys.sort()\\n    return [ki % 10000000 for ki in withKeys]\\n```\\nHere I combine each number with a left-aligned version of it, for example:\\n```\\n     42  =>  42000000000042\\n   4200  =>  42000000004200\\n 123456  =>  12345600123456\\n```\\nThen just sort these and then extract the lower parts.\\n\\n<br>\\n\\n## Complexity\\n\\nI think **Time** complexity and **space** complexity are both **O(n)** (at least if sort does what I think it does, I'll check some more), and the space complexity has a low hidden factor.\\n\\nThe time and memory limits for Python for this problem are pretty low, requiring a fairly efficient solution. On LeetCode, Python ints are 64 bits, so embedding the left-aligned version of numbers in the numbers (solution 2) doesn't cost extra memory. Also, sorting simple ints is fast. Especially since the order from 1 to n is already largely sorted lexicographically, like the streak from 100 to 999 and the streak from 1000 to 9999. And Python's (Tim)sort can take advantage of those streaks and just merge them. If it merges \"left to right\" like I think it does, then it merges the small streaks first and only integrates the longest streaks last, which leads to overall O(n) time.\\n\\n<br>\\n\\n## Optimizing Solution 2 <sup>(accepted in 980, 984, 980 ms)\\n\\nInstead of assuming that we get numbers up to seven digits long and using constants, this uses the largest power of 10 up to n.\\n```\\ndef lexicalOrder(self, n):\\n    highDigit = 1\\n    while highDigit * 10 <= n:\\n        highDigit *= 10\\n    higherDigit = highDigit * 10\\n    withKeys = []\\n    for i in xrange(1, n+1):\\n        key = i\\n        while key < highDigit:\\n            key *= 10\\n        withKeys.append(key * higherDigit + i)\\n    withKeys.sort()\\n    return [ki % higherDigit for ki in withKeys]\\n```\\n\\n<br>\\n\\n## History...\\n\\nOf course the first thing I had tried was this:\\n\\n    def lexicalOrder(self, n):\\n        return sorted(range(1, n+1), key=str)\\n\\nOutrageously, this wasn't accepted! Got \"Memory Limit Exceeded\" at input n=49999! So next I tried the `cmp`-version of `sorted` instead of the `key`-version, and building strings only on the fly so it takes less memory:\\n\\n    def lexicalOrder(self, n):\\n        return sorted(range(1, n+1), lambda a, b: cmp(str(a), str(b)))\\n\\nHorrendously, this wasn't accepted! Got \"Time Limit Exceeded\" at input n=49999! So next I tried converting to strings, sorting those, and converting back to ints. Uses more memory, but less time:\\n\\n    def lexicalOrder(self, n):\\n        return map(int, sorted(map(str, xrange(1, n+1))))\\n        \\nUnfathomably, this wasn't accepted! Got \"Memory Limit Exceeded\" at input n=49999! The horror! Apparently LeetCode really didn't want me to get away with being lazy. So I tried it without sorting or strings and built the numbers in correct order:\\n\\n    def lexicalOrder(self, n):\\n        def dfs(i):\\n            if i <= n:\\n                result.append(i)\\n                for d in xrange(10):\\n                    dfs(10 * i + d)\\n        result = []\\n        for i in range(1, 10):\\n            dfs(i)\\n        return result\\n\\nIrritatingly, this wasn't accepted! Got \"Time Limit Exceeded\"! At input n=**14959**! So it was even **slower** than the above. Geez. And none of this was even remotely close to the \"5,000,000\" that the problem threatened me with. I gave up. And implemented that last solution in C++. It got accepted.\\n\\nLater I found out that the \"5,000,000\" isn't even close to true, the largest actual test case is 49999. But even after lots of different attempts, I still can't get any simple stringify+sort solution accepted. The most efficient I came up with is this:\\n\\n    def lexicalOrder(self, n):\\n        return sorted(xrange(1, n+1), lambda a, b, s=str: 1 if s(b) < s(a) else -1)\\n\\nThat uses `xrange`, which is faster than `range`, uses the `cmp`-version of `sorted` because the `key` version gets memory limit exceeded, uses a fast local variable instead of the slower global `str`, and exploits that there are no duplicate numbers so I just have to distinguish two cases which I do with `<` instead of the `cmp` function. Still, after all of that optimization it's not fast enough. But based on comparing it with accepted solutions in custom testing, I think it's close. Maybe 10% too slow.\\n\\nI did get one stringify+sort solution accepted, but it's less simple. I'll post that one later...",
                "solutionTags": [
                    "Python",
                    "Sorting"
                ],
                "code": "```\\ndef lexicalOrder(self, n):\\n    top = 1\\n    while top * 10 <= n:\\n        top *= 10\\n    def mycmp(a, b, top=top):\\n        while a < top: a *= 10\\n        while b < top: b *= 10\\n        return -1 if a < b else b < a\\n    return sorted(xrange(1, n+1), mycmp)\\n```\n```\\ndef lexicalOrder(self, n):\\n    withKeys = []\\n    for i in xrange(1, n+1):\\n        key = i\\n        while key < 1000000:\\n            key *= 10\\n        withKeys.append(key * 10000000 + i)\\n    withKeys.sort()\\n    return [ki % 10000000 for ki in withKeys]\\n```\n```\\n     42  =>  42000000000042\\n   4200  =>  42000000004200\\n 123456  =>  12345600123456\\n```\n```\\ndef lexicalOrder(self, n):\\n    highDigit = 1\\n    while highDigit * 10 <= n:\\n        highDigit *= 10\\n    higherDigit = highDigit * 10\\n    withKeys = []\\n    for i in xrange(1, n+1):\\n        key = i\\n        while key < highDigit:\\n            key *= 10\\n        withKeys.append(key * higherDigit + i)\\n    withKeys.sort()\\n    return [ki % higherDigit for ki in withKeys]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 86269,
                "title": "simple-java-dfs-solution-beats-85-12-lines",
                "content": "\\n```java\\n\\npublic class Solution {\\n    public List<Integer> lexicalOrder(int n) {\\n        List<Integer> res = new ArrayList<>(n);\\n        //  from  1 to 9.\\n        //  0 is can't be a soution.\\n        dfs(1, 9, n, res);\\n        return res;\\n    }\\n    private void dfs(int start, int end, int n, List<Integer> res){\\n        // <= n make the solution can't bigger than n\\n        for (int i = start; i <= end && i <= n; i++){\\n            res.add(i);\\n            // 10 -> next recursion: 100(->next recursion 1000), 101,102....\\n            // next loop: 11 -> next recursion: 110,  111,112....\\n            // next loop: 12 -> next recursion: 120,  121,122....\\n            // from 0 to 9 different from the dfs call in method lexicalOrder\\n            dfs(i * 10, i * 10 + 9, n, res);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\n\\npublic class Solution {\\n    public List<Integer> lexicalOrder(int n) {\\n        List<Integer> res = new ArrayList<>(n);\\n        //  from  1 to 9.\\n        //  0 is can't be a soution.\\n        dfs(1, 9, n, res);\\n        return res;\\n    }\\n    private void dfs(int start, int end, int n, List<Integer> res){\\n        // <= n make the solution can't bigger than n\\n        for (int i = start; i <= end && i <= n; i++){\\n            res.add(i);\\n            // 10 -> next recursion: 100(->next recursion 1000), 101,102....\\n            // next loop: 11 -> next recursion: 110,  111,112....\\n            // next loop: 12 -> next recursion: 120,  121,122....\\n            // from 0 to 9 different from the dfs call in method lexicalOrder\\n            dfs(i * 10, i * 10 + 9, n, res);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 399796,
                "title": "easy-simple-recursion-beats-100-explanation-graphic-illustration-included",
                "content": "**TLDR**\\nThe plan is to automatically create the result array without further sorting that will cost us excess runtime/space.\\n\\nYou have to notice how the result array is formed, and especially that you need **Iterations within other Iterations.** \\n\\nLet\\'s create an example result array for a given  ***n**=**112*** to illustrate the requirements.\\n\\n![image](https://assets.leetcode.com/users/georgechryso/image_1570485262.png)\\nNotice how each color represents an iteration that **needs** to occur,   **IN THAT ORDER**.\\n\\nSo after 10, comes 100 ( which is 10* 10 and continues the green iteration until its end, 109=10* 10+9).\\nThe Yellow Iteration\\'s previous element is 1, so the yellow starts with 1* 10=10 and ends with 1* 10+9=119.\\nThe Orange iteration\\'s previous element is 2, so It starts with 2* 10=20 and ends with 2* 10+9=29\\nNotice that every iteration (except the olive green one) has the same relationship with its previous element. \\nAs for the olive green, it stopped prematurely. We expected it to keep going until 11 * 10 +9=119 (its end). Well this happened because we dont need the excess elements as they are bigger than our n.\\n\\nSince we have required nested iterations, **recursion** can be helpful here. \\n\\n```\\nvar lexicalOrder = function(n) {\\n\\n        function pushFromTo( start, end ) {\\n            /* essentially this function pushes every integer between start and\\n\\t\\t\\tend to the results array and breaks whenever either the end or n is reached */\\n            while( start<=end && start<=n ){ \\n                result.push(start);   \\n\\n                /* The nesting occurs, new iterations are attempted within this\\n\\t\\t\\t\\tstep utilizing the observed pattern*/\\n\\t\\t\\t\\tpushFromTo(start*10, start*10+9)\\n\\n                start++   \\n            }\\n\\n        }\\n\\n   var result = [];\\n\\n   /* start the recursion */ \\n   pushFromTo( 1, 9);\\n\\n   return result;\\n };\\n \\n\\n```\\n**Let\\'s examine how the algorith behaves with our previous example of n =112\\nEach line represents the order of processing that takes place.**\\n\\n![image](https://assets.leetcode.com/users/georgechryso/image_1570485926.png)\\n",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\nvar lexicalOrder = function(n) {\\n\\n        function pushFromTo( start, end ) {\\n            /* essentially this function pushes every integer between start and\\n\\t\\t\\tend to the results array and breaks whenever either the end or n is reached */\\n            while( start<=end && start<=n ){ \\n                result.push(start);   \\n\\n                /* The nesting occurs, new iterations are attempted within this\\n\\t\\t\\t\\tstep utilizing the observed pattern*/\\n\\t\\t\\t\\tpushFromTo(start*10, start*10+9)\\n\\n                start++   \\n            }\\n\\n        }\\n\\n   var result = [];\\n\\n   /* start the recursion */ \\n   pushFromTo( 1, 9);\\n\\n   return result;\\n };\\n \\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1744111,
                "title": "brute-force-using-comparator-4-liner-39-ms-java",
                "content": "```\\nclass Solution {\\n    public List<Integer> lexicalOrder(int n) {\\n        List<Integer> res = new ArrayList<>();\\n        for(int i = 1; i <= n; i++){res.add(i);}\\n        Collections.sort(res,(a,b)->(Integer.toString(a).compareTo(Integer.toString(b)))); //comparing integers lexicographically\\n        return res;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "class Solution {\\n    public List<Integer> lexicalOrder(int n) {\\n        List<Integer> res = new ArrayList<>();\\n        for(int i = 1; i <= n; i++){res.add(i);}",
                "codeTag": "Java"
            },
            {
                "id": 1345862,
                "title": "using-trie-c-with-step-wise-explanation-and-example",
                "content": "Not an optimised one but if you are learning trie then it will be good for Practice\\n**Examples are just for a demo of working of the code**\\n\\n```\\nclass Trie{\\n    public:\\n    vector<Trie*> v;\\n    bool isEnd;\\n    int data;\\n    Trie(){\\n        v=vector<Trie*>(10,nullptr);\\n        isEnd=false;\\n        data = -1;\\n    }\\n};\\nclass Solution {\\n    void insert(Trie* node, int a)\\n    {\\n        Trie* root = node;\\n        string key = to_string(a);\\n        for(auto &x:key)\\n        {\\n            int curr = x-\\'0\\';\\n            if(root->v[curr]==nullptr) root->v[curr]=new Trie();\\n            root = root->v[curr];\\n        }\\n        root->isEnd=true;\\n        root->data = a;\\n    }\\n    vector<int> ans;\\n    void printAll(Trie* root)\\n    {\\n        if(root->isEnd){\\n            ans.push_back(root->data);\\n        }\\n        for(int i=0;i<10;i++){\\n            if(root->v[i]) printAll(root->v[i]);\\n        }\\n    }\\npublic:\\n    vector<int> lexicalOrder(int n) {\\n        ans.clear();\\n        Trie* root = new Trie();\\n        for(int i=1;i<=n;i++) insert(root,i);\\n        printAll(root);\\n        return ans;\\n    }\\n};\\n```\\nHere We are building a Trie having children vector of size 10, a boolean variable to store the end of digit and a data variable to store the number at the leaf node..\\n**Step 1:** Create a root node for trie and insert all the values from 1 to n in it..\\nWe are having 10 nodes to store each digit of the number at ith iteration\\nExample 190 will be inserted as\\n```\\n                                 root\\n\\t\\t  \\t\\t/   /   /   /   /  \\\\   \\\\  \\\\   \\\\   \\\\\\n\\t\\t\\t\\t   1                                      (1st node having another TrieNode)\\n  /   /   /   /   /  \\\\   \\\\  \\\\   \\\\   \\\\\\n                                      9                   (9th node having another TrieNode)\\n                     /   /   /   /   /  \\\\   \\\\  \\\\   \\\\   \\\\\\n\\t\\t\\t\\t   0                                      (end=true, data=190)\\n```\\n(NOTE: don\\'t forget to add data at the leaf node)\\n\\n**Step 2:** For Searching Purpose checking from the root node and recursively add the numbers in the given vector\\nExample if we have  1, 10, 2 in Trie\\n```\\nWe will iterate at 0 found NULL\\nthen iterate at 1 and using recursion we call Node at 1 \\n              **Recursion call 1:**\\n              Resulting we found 1 isEnd of a number so we add data at that node in our vector (data = 1)\\n              Then inside this recursion part we call for rest of the nodes after 1\\n              We found 0 is also not NULL node and add call recursion for this node \\n                          **Recursion call 2:**\\n\\t\\t\\t              Resulting we found that 0 isEnd of a number so we add data at that node in our vector (data = 10)\\n\\t\\t\\t\\t\\t\\t  Then inside the recursion part we call rest of the nodes but found all nodes NULL\\n\\t\\t\\t\\t\\t\\t   \\n              **Back to Recursion call 1:**\\n\\t\\t\\t after 0 there is no NOT NULL nodes in this recursion call\\n \\n**Back to initial call :**\\nAfter 1 we also have 2 as a Not NULL node in this call so we call once again for this node\\n            **Recursion call 1:**\\n            Resulting we found 2 isEnd of a number so we add data at that node in our vector   (data = 2)\\n\\t\\t\\tand further it doesnt found any not NULL node.. \\n**Back to initail call:**\\nNow there is no Not NULL node after 2\\n```\\n\\nso our result vector should look like this\\n```\\nans = [1, 10, 2]\\n```\\nWhich is lexicographically sorted\\n\\nGood Luck..\\n\\t\\t\\t\\n\\n\\t\\t\\t\\n\\t\\t\\t\\n\\n                          \\n\\n",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```\\nclass Trie{\\n    public:\\n    vector<Trie*> v;\\n    bool isEnd;\\n    int data;\\n    Trie(){\\n        v=vector<Trie*>(10,nullptr);\\n        isEnd=false;\\n        data = -1;\\n    }\\n};\\nclass Solution {\\n    void insert(Trie* node, int a)\\n    {\\n        Trie* root = node;\\n        string key = to_string(a);\\n        for(auto &x:key)\\n        {\\n            int curr = x-\\'0\\';\\n            if(root->v[curr]==nullptr) root->v[curr]=new Trie();\\n            root = root->v[curr];\\n        }\\n        root->isEnd=true;\\n        root->data = a;\\n    }\\n    vector<int> ans;\\n    void printAll(Trie* root)\\n    {\\n        if(root->isEnd){\\n            ans.push_back(root->data);\\n        }\\n        for(int i=0;i<10;i++){\\n            if(root->v[i]) printAll(root->v[i]);\\n        }\\n    }\\npublic:\\n    vector<int> lexicalOrder(int n) {\\n        ans.clear();\\n        Trie* root = new Trie();\\n        for(int i=1;i<=n;i++) insert(root,i);\\n        printAll(root);\\n        return ans;\\n    }\\n};\\n```\n```\\n                                 root\\n\\t\\t  \\t\\t/   /   /   /   /  \\\\   \\\\  \\\\   \\\\   \\\\\\n\\t\\t\\t\\t   1                                      (1st node having another TrieNode)\\n  /   /   /   /   /  \\\\   \\\\  \\\\   \\\\   \\\\\\n                                      9                   (9th node having another TrieNode)\\n                     /   /   /   /   /  \\\\   \\\\  \\\\   \\\\   \\\\\\n\\t\\t\\t\\t   0                                      (end=true, data=190)\\n```\n```\\nWe will iterate at 0 found NULL\\nthen iterate at 1 and using recursion we call Node at 1 \\n              **Recursion call 1:**\\n              Resulting we found 1 isEnd of a number so we add data at that node in our vector (data = 1)\\n              Then inside this recursion part we call for rest of the nodes after 1\\n              We found 0 is also not NULL node and add call recursion for this node \\n                          **Recursion call 2:**\\n\\t\\t\\t              Resulting we found that 0 isEnd of a number so we add data at that node in our vector (data = 10)\\n\\t\\t\\t\\t\\t\\t  Then inside the recursion part we call rest of the nodes but found all nodes NULL\\n\\t\\t\\t\\t\\t\\t   \\n              **Back to Recursion call 1:**\\n\\t\\t\\t after 0 there is no NOT NULL nodes in this recursion call\\n \\n**Back to initial call :**\\nAfter 1 we also have 2 as a Not NULL node in this call so we call once again for this node\\n            **Recursion call 1:**\\n            Resulting we found 2 isEnd of a number so we add data at that node in our vector   (data = 2)\\n\\t\\t\\tand further it doesnt found any not NULL node.. \\n**Back to initail call:**\\nNow there is no Not NULL node after 2\\n```\n```\\nans = [1, 10, 2]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 746182,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> lexicalOrder(int n) {\\n        if(n==0) return {};\\n        vector<int> result;\\n        int current=1; //Initial element\\n        for(int i=0;i<n;i++){\\n            result.push_back(current); //Push current to the result.\\n            current*=10; // Add zero at the end of current.\\n            while(current>n){ //If current exceeds n.\\n                current/=10; //Fall back to last element.\\n                current++; //Get Next in order.\\n                while(current%10==0) current/=10; //Remove extra trailing zeros.\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> lexicalOrder(int n) {\\n        if(n==0) return {};\\n        vector<int> result;\\n        int current=1; //Initial element\\n        for(int i=0;i<n;i++){\\n            result.push_back(current); //Push current to the result.\\n            current*=10; // Add zero at the end of current.\\n            while(current>n){ //If current exceeds n.\\n                current/=10; //Fall back to last element.\\n                current++; //Get Next in order.\\n                while(current%10==0) current/=10; //Remove extra trailing zeros.\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 86331,
                "title": "merge-sort-solution-with-explanation",
                "content": "**Idea:** Each streak of same-length numbers (`1..9`, `10..99`, `100..999`, `1000..9999`, etc) is already lexicographically sorted. Just merge these streaks. First merge `1..9` with `10..99`, then merge with `100..999`, and so on.\\n\\n    vector<int> lexicalOrder(int n) {\\n        vector<int> result(n);\\n        int* first = &result[0];\\n        iota(first, first + n, 1);\\n        for (int ok = 9; ok < n; ok = 10*ok+9)\\n            inplace_merge(first,\\n                          first + ok,\\n                          first + min(ok*10+9, n),\\n                          [ok](int a, int b){\\n                              while (b <= ok) b *= 10;\\n                              return a < b;\\n                          });\\n        return result;\\n    }\\n\\nFirst I use `iota` to store the numbers 1 to n in normal order. Note that 1 to 9 are already `ok`, i.e., already lexicographically sorted. And 10 to 99 are as well. Now I just merge those two streaks and then the first 99 entries are already ok. Then I merge them with the streak 100 to 999, and so on. The comparison for the merging scales up the numbers from the already ok range. For example if I'm merging with the next streak 1000 to 9999, then the previously already ok numbers like 26 or 7 get scaled to 2600 and 7000.",
                "solutionTags": [],
                "code": "**Idea:** Each streak of same-length numbers (`1..9`, `10..99`, `100..999`, `1000..9999`, etc) is already lexicographically sorted. Just merge these streaks. First merge `1..9` with `10..99`, then merge with `100..999`, and so on.\\n\\n    vector<int> lexicalOrder(int n) {\\n        vector<int> result(n);\\n        int* first = &result[0];\\n        iota(first, first + n, 1);\\n        for (int ok = 9; ok < n; ok = 10*ok+9)\\n            inplace_merge(first,\\n                          first + ok,\\n                          first + min(ok*10+9, n),\\n                          [ok](int a, int b){\\n                              while (b <= ok) b *= 10;\\n                              return a < b;\\n                          });\\n        return result;\\n    }\\n\\nFirst I use `iota` to store the numbers 1 to n in normal order. Note that 1 to 9 are already `ok`, i.e., already lexicographically sorted. And 10 to 99 are as well. Now I just merge those two streaks and then the first 99 entries are already ok. Then I merge them with the streak 100 to 999, and so on. The comparison for the merging scales up the numbers from the already ok range. For example if I'm merging with the next streak 1000 to 9999, then the previously already ok numbers like 26 or 7 get scaled to 2600 and 7000.",
                "codeTag": "Unknown"
            },
            {
                "id": 86255,
                "title": "python-with-dfs",
                "content": "Accepted python code with DFS (1073ms):\\n```\\n    def lexicalOrder(self, n):\\n        def dfs(k, res):\\n            if k <= n:\\n                res.append(k)\\n                t = 10*k\\n                if t <= n:\\n                    for i in range(10):\\n                        dfs(t + i, res)\\n        res = []\\n        for i in range(1, 10):\\n            dfs(i, res)\\n        return res\\n```\\nInterestingly, with only one modification to the above code, the following code gets Memory Limit Exceeded.\\n```\\n    def lexicalOrder(self, n):\\n        def dfs(k):\\n            if k <= n:\\n                res.append(k)\\n                t = 10*k\\n                if t <= n:\\n                    for i in range(10):\\n                        dfs(t + i)\\n        res = []\\n        for i in range(1, 10):\\n            dfs(i)\\n        return res\\n```\\nThe only difference between these two is that, in the latter one, we do not pass the list `res` as an argument to the function `dfs`. Can anybody explain this phenomenon? Thanks!",
                "solutionTags": [],
                "code": "```\\n    def lexicalOrder(self, n):\\n        def dfs(k, res):\\n            if k <= n:\\n                res.append(k)\\n                t = 10*k\\n                if t <= n:\\n                    for i in range(10):\\n                        dfs(t + i, res)\\n        res = []\\n        for i in range(1, 10):\\n            dfs(i, res)\\n        return res\\n```\n```\\n    def lexicalOrder(self, n):\\n        def dfs(k):\\n            if k <= n:\\n                res.append(k)\\n                t = 10*k\\n                if t <= n:\\n                    for i in range(10):\\n                        dfs(t + i)\\n        res = []\\n        for i in range(1, 10):\\n            dfs(i)\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1029627,
                "title": "simple-c-code-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    void dfs(int i,int n){\\n    if(i>n){\\n        return;\\n    }\\n        ans.push_back(i);\\n    for(int j=0;j<10;j++){\\n    dfs(10*i+j,n);    \\n    }\\n    \\n}\\n    vector<int> lexicalOrder(int n) {\\n        for(int i=1;i<=9;i++){\\n            dfs(i,n);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    void dfs(int i,int n){\\n    if(i>n){\\n        return;\\n    }\\n        ans.push_back(i);\\n    for(int j=0;j<10;j++){\\n    dfs(10*i+j,n);    \\n    }\\n    \\n}\\n    vector<int> lexicalOrder(int n) {\\n        for(int i=1;i<=9;i++){\\n            dfs(i,n);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3254687,
                "title": "386-time-99-87-and-space-93-99-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Initialize an empty list res to store the result and a variable cur to start from 1.\\n```\\nres = []\\ncur = 1\\n```\\n2. Loop through the range n times, where n is the upper limit of the numbers to generate.\\n```\\nfor i in range(n):\\n```\\n3. Append the current number cur to the result list.\\n```\\nres.append(cur)\\n```\\n4. If the current number times 10 is less than or equal to n, move to the next level by multiplying cur by 10.\\n```\\nif cur * 10 <= n:\\n    cur *= 10\\n```\\n5. If the current number times 10 is greater than n, move to the next number at the current level by adding 1 to cur.\\n```\\nelse:\\n    # If we\\'ve reached the end of a level, divide by 10 to go back up one level\\n    if cur >= n:\\n        cur //= 10\\n    cur += 1\\n```\\n6. Skip over any trailing zeroes (e.g. if cur is 19, skip over 190, 191, 192, etc.) by dividing cur by 10 until the last digit is not 0.\\n```\\nwhile cur % 10 == 0:\\n    cur //= 10\\n```\\n7. Return the result list res.\\n```\\nreturn res\\n```\\nThis algorithm generates all the numbers in the range [1, n] in lexicographical order, and runs in O(n) time complexity and uses O(1) extra space.\\n\\n# Complexity\\n- Time complexity:\\n99.87%\\n\\n- Space complexity:\\n93.99%\\n\\n# Code\\n```\\nclass Solution:\\n    def lexicalOrder(self, n: int) -> List[int]:\\n        res = []\\n        cur = 1\\n        for i in range(n):\\n            # Add the current number to the result\\n            res.append(cur)\\n            # If the current number times 10 is less than or equal to n, move to the next level\\n            if cur * 10 <= n:\\n                cur *= 10\\n            # Otherwise, move to the next number at the current level\\n            else:\\n                # If we\\'ve reached the end of a level, divide by 10 to go back up one level\\n                if cur >= n:\\n                    cur //= 10\\n                cur += 1\\n                # Skip over any trailing zeroes (e.g. if cur = 19, skip over 190, 191, 192, etc.)\\n                while cur % 10 == 0:\\n                    cur //= 10\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```\\nres = []\\ncur = 1\\n```\n```\\nfor i in range(n):\\n```\n```\\nres.append(cur)\\n```\n```\\nif cur * 10 <= n:\\n    cur *= 10\\n```\n```\\nelse:\\n    # If we\\'ve reached the end of a level, divide by 10 to go back up one level\\n    if cur >= n:\\n        cur //= 10\\n    cur += 1\\n```\n```\\nwhile cur % 10 == 0:\\n    cur //= 10\\n```\n```\\nreturn res\\n```\n```\\nclass Solution:\\n    def lexicalOrder(self, n: int) -> List[int]:\\n        res = []\\n        cur = 1\\n        for i in range(n):\\n            # Add the current number to the result\\n            res.append(cur)\\n            # If the current number times 10 is less than or equal to n, move to the next level\\n            if cur * 10 <= n:\\n                cur *= 10\\n            # Otherwise, move to the next number at the current level\\n            else:\\n                # If we\\'ve reached the end of a level, divide by 10 to go back up one level\\n                if cur >= n:\\n                    cur //= 10\\n                cur += 1\\n                # Skip over any trailing zeroes (e.g. if cur = 19, skip over 190, 191, 192, etc.)\\n                while cur % 10 == 0:\\n                    cur //= 10\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 280456,
                "title": "easy-understand-trie-method",
                "content": "Basice idea: think about Trie. we append digits to the specific suffix until we reach the target number.\\n```\\nclass Solution:\\n    def lexicalOrder(self, n: int) -> List[int]:\\n        # recursively use Trie\\n        res = []\\n        if n < 10:\\n            return list(range(1, n+1))\\n        for i in range(1, 10):\\n            res += [i]\\n            res += self.helper(i, n)\\n        return res\\n    \\n    def helper(self, start, n):\\n        res = []\\n        for aux in range(10):\\n            newStart = start*10+aux\\n            if newStart > n:\\n                break\\n            res += [newStart]\\n            res += self.helper(newStart, n)\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def lexicalOrder(self, n: int) -> List[int]:\\n        # recursively use Trie\\n        res = []\\n        if n < 10:\\n            return list(range(1, n+1))\\n        for i in range(1, 10):\\n            res += [i]\\n            res += self.helper(i, n)\\n        return res\\n    \\n    def helper(self, start, n):\\n        res = []\\n        for aux in range(10):\\n            newStart = start*10+aux\\n            if newStart > n:\\n                break\\n            res += [newStart]\\n            res += self.helper(newStart, n)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 201218,
                "title": "very-simple-recursive-java-solution",
                "content": "When I saw the problem I remembered a problem which I struggled to solve and when I checked the solution it\\'s a recursive method of 5 lines of code. So I managed to attack it recursively.\\n\\n### Explanation:\\n* For code simplicity I assumed that it\\'s required to print the numbers rather than filling a list.\\n\\n![image](https://assets.leetcode.com/users/islamsalah/image_1543826042.png)\\n\\n\\n### Submitted solution:\\n```\\nclass Solution {\\n    public List<Integer> lexicalOrder(int n) {\\n        List<Integer> list = new LinkedList<>();\\n        formSeries(1, n, list);\\n        return list;\\n    }\\n    \\n    private void formSeries(int i, int n, List<Integer> list) {\\n        if(i > n) return;\\n        \\n        list.add(i);\\n        formSeries(i*10, n, list);\\n        if( i%10 != 9 ) formSeries(i+1, n, list);\\n    }\\n    \\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> lexicalOrder(int n) {\\n        List<Integer> list = new LinkedList<>();\\n        formSeries(1, n, list);\\n        return list;\\n    }\\n    \\n    private void formSeries(int i, int n, List<Integer> list) {\\n        if(i > n) return;\\n        \\n        list.add(i);\\n        formSeries(i*10, n, list);\\n        if( i%10 != 9 ) formSeries(i+1, n, list);\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2975868,
                "title": "c-beats-96-97-4-different-sol-recursive-iterative-trie-brute-force-all-approaches",
                "content": "* Recursive Sol\\n\\t* Beats 96.97%\\n\\t*  Run time - 4 ms\\n```\\nclass Solution {\\n    int n; vector<int> ans;\\n    \\n    void dfs(int currVal){\\n        ans.push_back(currVal); \\n        for(int i = 0;i<=9;i++){\\n            int x = currVal*10 + i;\\n            if(x>n) return; \\n\\t\\t\\tdfs(x);\\n        }\\n    }\\n    \\npublic:\\n    vector<int> lexicalOrder(int n) {\\n        this->n = n; \\n        for(int i = 1;i<=9 and i<=n;i++) dfs(i);\\n        return ans;\\n    }\\n};\\n```\\n* Iterative Sol\\n\\t* Beats 79.88%\\n\\t*  Run time - 11 ms\\n```\\nclass Solution {\\npublic:\\n    vector<int> lexicalOrder(int n) {\\n        vector<int> ans;\\n        int cur = 1, i=0;\\n        while(i++ < n) {\\n            ans.emplace_back(cur);\\n            if (cur * 10 <= n) cur *= 10;\\n            else {\\n                if (cur == n) cur /= 10;\\n                cur += 1;\\n                while (cur % 10 == 0) cur /= 10;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n* Trie Sol\\n\\t* Beats 44.48%\\n\\t* Run time - 26 ms\\n\\n```\\nclass Solution {\\npublic:\\n     class TrieNode {\\n    public:\\n        bool eon = false; // eon = End of No.\\n        TrieNode *children[10];\\n    };\\n    \\n    class Trie {\\n    public:\\n        TrieNode *root;\\n        \\n        Trie() {\\n            root = new TrieNode();\\n        }\\n        \\n        void insert(int x,int s){\\n            TrieNode *curr = root;\\n            while(s){\\n                int idx=x/s;\\n                if(!curr->children[idx]) curr->children[idx] = new TrieNode();\\n                curr = curr->children[idx]; x%=s; s/=10;\\n            }\\n            curr->eon = true;\\n        }\\n        \\n        void getLexicalOrder(TrieNode *root, vector<int> &ans, int num = 0){\\n            for(int i=0;i<10;i++){\\n                if(!root->children[i]) continue; \\n                if(root->children[i]->eon) ans.push_back(num+i);\\n                getLexicalOrder(root->children[i],ans, (num+i)*10);\\n            }\\n        }    \\n    };\\n    vector<int> lexicalOrder(int n) {\\n        Trie trie;\\n        for(int i=1;i<=n;i++){\\n            if(i<10) trie.insert(i,1);\\n            else if(i<100) trie.insert(i,10);\\n            else if(i<1000) trie.insert(i,100);\\n            else if(i<10000) trie.insert(i,1000);\\n            else trie.insert(i,10000);\\n        }\\n        vector<int> ans;\\n        trie.getLexicalOrder(trie.root, ans);\\n        return ans;\\n    }\\n};\\n```\\n\\n* Brute Force\\n\\t* Beats  26.06 %\\n\\t* Run time - 111 ms\\n```\\nclass Solution {\\npublic:\\n    vector<int> lexicalOrder(int n) {\\n        vector<string> strs;\\n        vector<int> ans;\\n        while(n) strs.push_back(to_string(n--));\\n        sort(strs.begin(),strs.end());\\n        for(auto it:strs) ans.push_back(stoi(it));\\n        return ans;\\n    }\\n};\\n```\\n* Another Brute Force\\n\\t* Beats  5.05%\\n\\t* Run time - 1016  ms\\n\\t* This one most memory optimized.\\n```\\nclass Solution {\\npublic:\\n    vector<int> lexicalOrder(int n) {\\n        vector<int> ans(n);\\n        iota(ans.begin(), ans.end(), 1);\\n        sort(ans.begin(),ans.end(),[](int a, int b){\\n            return to_string(a)<to_string(b);\\n        });\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Trie",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int n; vector<int> ans;\\n    \\n    void dfs(int currVal){\\n        ans.push_back(currVal); \\n        for(int i = 0;i<=9;i++){\\n            int x = currVal*10 + i;\\n            if(x>n) return; \\n\\t\\t\\tdfs(x);\\n        }\\n    }\\n    \\npublic:\\n    vector<int> lexicalOrder(int n) {\\n        this->n = n; \\n        for(int i = 1;i<=9 and i<=n;i++) dfs(i);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> lexicalOrder(int n) {\\n        vector<int> ans;\\n        int cur = 1, i=0;\\n        while(i++ < n) {\\n            ans.emplace_back(cur);\\n            if (cur * 10 <= n) cur *= 10;\\n            else {\\n                if (cur == n) cur /= 10;\\n                cur += 1;\\n                while (cur % 10 == 0) cur /= 10;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n     class TrieNode {\\n    public:\\n        bool eon = false; // eon = End of No.\\n        TrieNode *children[10];\\n    };\\n    \\n    class Trie {\\n    public:\\n        TrieNode *root;\\n        \\n        Trie() {\\n            root = new TrieNode();\\n        }\\n        \\n        void insert(int x,int s){\\n            TrieNode *curr = root;\\n            while(s){\\n                int idx=x/s;\\n                if(!curr->children[idx]) curr->children[idx] = new TrieNode();\\n                curr = curr->children[idx]; x%=s; s/=10;\\n            }\\n            curr->eon = true;\\n        }\\n        \\n        void getLexicalOrder(TrieNode *root, vector<int> &ans, int num = 0){\\n            for(int i=0;i<10;i++){\\n                if(!root->children[i]) continue; \\n                if(root->children[i]->eon) ans.push_back(num+i);\\n                getLexicalOrder(root->children[i],ans, (num+i)*10);\\n            }\\n        }    \\n    };\\n    vector<int> lexicalOrder(int n) {\\n        Trie trie;\\n        for(int i=1;i<=n;i++){\\n            if(i<10) trie.insert(i,1);\\n            else if(i<100) trie.insert(i,10);\\n            else if(i<1000) trie.insert(i,100);\\n            else if(i<10000) trie.insert(i,1000);\\n            else trie.insert(i,10000);\\n        }\\n        vector<int> ans;\\n        trie.getLexicalOrder(trie.root, ans);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> lexicalOrder(int n) {\\n        vector<string> strs;\\n        vector<int> ans;\\n        while(n) strs.push_back(to_string(n--));\\n        sort(strs.begin(),strs.end());\\n        for(auto it:strs) ans.push_back(stoi(it));\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> lexicalOrder(int n) {\\n        vector<int> ans(n);\\n        iota(ans.begin(), ans.end(), 1);\\n        sort(ans.begin(),ans.end(),[](int a, int b){\\n            return to_string(a)<to_string(b);\\n        });\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1687465,
                "title": "python-dfs-trie-o-n",
                "content": "Step1: Converting every number in [1, n] to a string and building a Trie. Treat each number as a word.\\nStep2: Running DFS to save every words in the Trie and converting them back to number. \\n\\nTime:O(N)\\nSpace:O(N)\\n\\n```\\nclass TrieNode():\\n    \\n    def __init__(self):\\n        self.children = {}\\n        self.is_end = False\\n        \\n\\nclass Solution:\\n    \\n    def __init__(self):\\n        self.trie_root = TrieNode()\\n        self.result_list = []\\n    \\n    def build_trie(self, s):\\n        \\n        c_node = self.trie_root\\n        for c in s:\\n            if(c not in c_node.children):\\n                c_node.children[c] = TrieNode()\\n            c_node = c_node.children[c]\\n            \\n        c_node.is_end = True\\n        \\n    def print_trie(self, c_node, cs):\\n        \\n        if(c_node.is_end):\\n            self.result_list.append(int(cs))\\n        \\n        for c, n_node in c_node.children.items():\\n            self.print_trie(n_node, cs+c)\\n        \\n        return\\n    \\n    \\n    \\n    def lexicalOrder(self, n: int) -> List[int]:\\n        \\n        for i in range(1, n+1):   \\n            s = str(i)\\n            self.build_trie(s)\\n        \\n        self.print_trie(self.trie_root, \\'\\')\\n        \\n        return self.result_list\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Trie"
                ],
                "code": "```\\nclass TrieNode():\\n    \\n    def __init__(self):\\n        self.children = {}\\n        self.is_end = False\\n        \\n\\nclass Solution:\\n    \\n    def __init__(self):\\n        self.trie_root = TrieNode()\\n        self.result_list = []\\n    \\n    def build_trie(self, s):\\n        \\n        c_node = self.trie_root\\n        for c in s:\\n            if(c not in c_node.children):\\n                c_node.children[c] = TrieNode()\\n            c_node = c_node.children[c]\\n            \\n        c_node.is_end = True\\n        \\n    def print_trie(self, c_node, cs):\\n        \\n        if(c_node.is_end):\\n            self.result_list.append(int(cs))\\n        \\n        for c, n_node in c_node.children.items():\\n            self.print_trie(n_node, cs+c)\\n        \\n        return\\n    \\n    \\n    \\n    def lexicalOrder(self, n: int) -> List[int]:\\n        \\n        for i in range(1, n+1):   \\n            s = str(i)\\n            self.build_trie(s)\\n        \\n        self.print_trie(self.trie_root, \\'\\')\\n        \\n        return self.result_list\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1243846,
                "title": "java-python-c-clean-dfs-2ms-solution-no-for-loop",
                "content": "The ideas is\\n\\n* Always multiply `cur` by `10` until `cur * 10` is greater than `n`;\\n* Then increment `cur` by `1` each time only when the last digit of `cur` is not `9`.\\n\\nFor example, let `n = 12`, `cur = 1`, `ans = []`.\\n* Step 1: Add `cur = 1` to `ans`: `ans = [1]`. Call `backtrack(cur * 10)`.\\n* Step 2: `cur = 1 * 10 = 10 <= n = 12`, add `cur` to `ans`: `ans = [1, 10]`. Call `backtrack(cur * 10)`.\\n* Step 3: `cur = 10 * 10 = 100 > n = 12`, return to `cur = 10`. Then call `backtrack(cur + 1)`.\\n* Step 4: `cur = 10 + 1 = 11 <= n = 12`, add `cur` to `ans`: `ans = [1, 10, 11]`. Call `backtrack(cur * 10)`.\\n* Step 5: `cur = 11 * 10 = 110 > n = 12`, return to `cur = 11`. Then call `backtrack(cur + 1)`.\\n* Step 6: `cur = 11 + 1 = 12 <= n = 12`, add `cur` to `ans`: `ans = [1, 10, 11, 12]`. Call `backtrack(cur * 10)`.\\n* Step 7: `cur = 12 * 10 = 120 > n = 12`, return to `cur = 12`. Then call `backtrack(cur + 1)`.\\n* Step 8: `cur = 12 + 1 = 13 > n = 12`, return to `cur = 1`. Then call `backtrack(cur + 1)`.\\n* Step 9: `cur = 1 + 1 = 2 <= n = 12`, add `cur`  to `ans`: `ans = [1, 10, 11, 12, 2]`. Then call `backtrack(cur * 10)`.\\n* and so forth, we will get `ans = [1, 10, 11, 12, 2, 3, 4, 5, 6, 7, 8, 9]`.\\n\\nTime complexity: O(n)\\nSpace complexity: O(1)\\n\\nJava:\\n```\\n  public List<Integer> lexicalOrder(int n) {\\n    List<Integer> ans = new ArrayList<>();\\n    backtrack(1, n, ans);\\n    return ans;\\n  }\\n  \\n  public void backtrack(int cur, int n, List<Integer> ans) {\\n    if (cur > n) return;\\n    ans.add(cur);\\n    backtrack(cur * 10, n, ans);\\n    if (cur % 10 != 9)\\n      backtrack(cur + 1, n, ans);\\n  }\\n```\\nPython:\\n```\\n  def lexicalOrder(self, n: int) -> List[int]:\\n    ans = []\\n    \\n    def backtrack(cur):\\n      if (cur > n): return\\n      ans.append(cur)\\n      backtrack(cur * 10)\\n      if cur % 10 != 9:\\n\\t    backtrack(cur + 1)\\n        \\n    backtrack(1)\\n    return ans\\n```\\nC++:\\n```\\n  vector<int> lexicalOrder(int n) {\\n    vector<int> ans;\\n    backtrack(1, n, ans);\\n    return ans;\\n  }\\n  \\n  void backtrack(int cur, int n, vector<int>& ans) {\\n    if (cur > n) return;\\n    ans.push_back(cur);\\n    backtrack(cur * 10, n, ans);\\n    if (cur % 10 != 9)\\n\\t  backtrack(cur + 1, n, ans);\\n  }\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\n  public List<Integer> lexicalOrder(int n) {\\n    List<Integer> ans = new ArrayList<>();\\n    backtrack(1, n, ans);\\n    return ans;\\n  }\\n  \\n  public void backtrack(int cur, int n, List<Integer> ans) {\\n    if (cur > n) return;\\n    ans.add(cur);\\n    backtrack(cur * 10, n, ans);\\n    if (cur % 10 != 9)\\n      backtrack(cur + 1, n, ans);\\n  }\\n```\n```\\n  def lexicalOrder(self, n: int) -> List[int]:\\n    ans = []\\n    \\n    def backtrack(cur):\\n      if (cur > n): return\\n      ans.append(cur)\\n      backtrack(cur * 10)\\n      if cur % 10 != 9:\\n\\t    backtrack(cur + 1)\\n        \\n    backtrack(1)\\n    return ans\\n```\n```\\n  vector<int> lexicalOrder(int n) {\\n    vector<int> ans;\\n    backtrack(1, n, ans);\\n    return ans;\\n  }\\n  \\n  void backtrack(int cur, int n, vector<int>& ans) {\\n    if (cur > n) return;\\n    ans.push_back(cur);\\n    backtrack(cur * 10, n, ans);\\n    if (cur % 10 != 9)\\n\\t  backtrack(cur + 1, n, ans);\\n  }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 967902,
                "title": "java-1ms-beats-100-dfs-solution-easy-understanding",
                "content": "This question can be simplifed as a DFS model: \\n1) For each number from 0-9, add the next level in order of 0-9, and so on for the next. 1,10,11..19,2,20,21...29, 3,30,31...\\n2) Get rid of number 0.\\n3) When the number is larger than n, return;\\n\\nUse two int num and int cur, cur = 10*num + i, num stores the previous level and cur represents the current level.\\n\\n```\\nclass Solution {\\n    public List<Integer> lexicalOrder(int n) {\\n        List<Integer> lst = new ArrayList<>();\\n        dfs(lst, n, 0);\\n        return lst;       \\n    }\\n    \\n    private void dfs(List<Integer> lst, int n, int num) {\\n        \\n        for(int i = 0; i <=9; i++) {\\n            int cur = 10*num + i;\\n\\t\\t\\t//get rid of 0\\n            if(cur == 0) continue;\\n\\t\\t\\t// when larger than n, return to the previous level\\n            if (cur > n) return;\\n            lst.add(cur);\\n            dfs(lst, n, cur);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> lexicalOrder(int n) {\\n        List<Integer> lst = new ArrayList<>();\\n        dfs(lst, n, 0);\\n        return lst;       \\n    }\\n    \\n    private void dfs(List<Integer> lst, int n, int num) {\\n        \\n        for(int i = 0; i <=9; i++) {\\n            int cur = 10*num + i;\\n\\t\\t\\t//get rid of 0\\n            if(cur == 0) continue;\\n\\t\\t\\t// when larger than n, return to the previous level\\n            if (cur > n) return;\\n            lst.add(cur);\\n            dfs(lst, n, cur);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 764698,
                "title": "python-solution",
                "content": "Algorithm: start with `1`, Initialize the result `res = []`, while `len(res) < n`, if the current number is smaller than or equal to `n`, add it to `res`, and append a `0` to it (multiple by 10); otherwise if the current number is larger than `n`, remove a `0` from it (divide by 10) and increment the resulting number by `1`. Say `n = 13`, the sequence would be `1` -> `10` -> `100` (x) -> `11` -> `110` (x) -> `12` -> `120` (x) -> `13` -> `130` (x) -> `14` (x) -> `2` -> `...`\\n\\nCorner case: for example, if `n = 20`,  the above algorithm would result in \\n\\t`1` -> `10` -> `100` (x) -> `11` -> `110` (x) -> `12` -> `120` (x) -> `13` -> `130` (x) -> `14` -> `140` (x) -> `15` -> `150` (x) -> `16` -> `160` (x) -> `17` -> `170` (x) -> `18` -> `180` (x) -> `19` -> `190` (x) -> `20` -> `200` (x) -> `...`, which is wrong, because after `19`, we should be starting from `2`, instead of `20`. This means that if the current number is larger than `n`, we will first remove a `0` from it (divide by 10) and increment the resulting number by `1`, and then we need to check if there are trailing `0`\\'s in the resulting number, and remove all of them if there are any, i.e., make the sequence `...` -> `19` -> `190` (x) -> `2` -> `...`, instead of `...` -> `19` -> `190` (x) -> `20` -> `...`.\\n\\t\\nTime complexity: O(n), space complexity: O(1).\\n\\nThe only tricky point of the time complexity calculation is to count how many times (denote by `N`) the division is performed in the inner while loop. Suppose `n = 10000`, then `N` is approximately `N \\u2248 1000 * 1 + 100 * 2 + 10 * 3`. It\\'s not hard to see that `O(N) = O(n)`, together with some O(1) operations in the outer while loop, this gives a total time complexity of O(n).\\n\\n```\\nclass Solution:\\n    def lexicalOrder(self, n: int) -> List[int]:\\n        res = []\\n        num = 1\\n        while len(res) < n:\\n            if num <= n:\\n                res.append(num)\\n                num *= 10\\n            else:\\n                num //= 10\\n                num += 1\\n                while num % 10 == 0:\\n                    num //= 10\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def lexicalOrder(self, n: int) -> List[int]:\\n        res = []\\n        num = 1\\n        while len(res) < n:\\n            if num <= n:\\n                res.append(num)\\n                num *= 10\\n            else:\\n                num //= 10\\n                num += 1\\n                while num % 10 == 0:\\n                    num //= 10\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 148522,
                "title": "1-line-python-3-solution",
                "content": "```python\\nclass Solution:\\n    def lexicalOrder(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: List[int]\\n        \"\"\"\\n        return sorted(range(1, n+1), key=lambda x: str(x))\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def lexicalOrder(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: List[int]\\n        \"\"\"\\n        return sorted(range(1, n+1), key=lambda x: str(x))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 86249,
                "title": "recursive-java-solution-using-pre-order-traversal",
                "content": "The big idea is Tree's ```pre-order traversal```, which means we first output the root, and then its left and right child, and we cannot output right child until we finishing outputting all nodes on the left branch.\\nFor this problem, a dummy node is the top root, and its children are ```1``` through ```9```; for node ```1```, its children are ```10, 100, 1000``` and so on; for node ```10```, its children are ```11``` through ```19```. \\nNotes that we use ```(i + 1 <= (i / 10) * 10 + 9)``` to restrict the range of children.\\n```\\npublic class Solution {\\n    public List<Integer> lexicalOrder(int n) {\\n        List<Integer> res = new ArrayList<>();\\n        lexicalOrderHelper(res, 1, n);\\n        return res;\\n    }\\n\\n    private void lexicalOrderHelper(List<Integer> res, int i, int n) {\\n        if(i > n) return;\\n        res.add(i);\\n        lexicalOrderHelper(res, i * 10, n);\\n        if(i + 1 <= (i / 10) * 10 + 9) lexicalOrderHelper(res, i + 1, n);\\n        else return;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```pre-order traversal```\n```1```\n```9```\n```1```\n```10, 100, 1000```\n```10```\n```11```\n```19```\n```(i + 1 <= (i / 10) * 10 + 9)```\n```\\npublic class Solution {\\n    public List<Integer> lexicalOrder(int n) {\\n        List<Integer> res = new ArrayList<>();\\n        lexicalOrderHelper(res, 1, n);\\n        return res;\\n    }\\n\\n    private void lexicalOrderHelper(List<Integer> res, int i, int n) {\\n        if(i > n) return;\\n        res.add(i);\\n        lexicalOrderHelper(res, i * 10, n);\\n        if(i + 1 <= (i / 10) * 10 + 9) lexicalOrderHelper(res, i + 1, n);\\n        else return;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1361912,
                "title": "python-easy-dfs-solution",
                "content": "```\\nclass Solution:\\n    def lexicalOrder(self, n: int) -> List[int]:\\n        res=[]\\n        def dfs(num):\\n            if num<=n:\\n                res.append(num)\\n                for i in range(10):\\n                    dfs(num*10+i)\\n        for i in range(1,10):\\n            dfs(i)\\n        return res\\n```\\nFirst we build the sequence for numbers starting with 1, then 2 and so on up to 9.\\nFor each number, we recursively build the sequence  like 1,10,11,12,13, while making sure we don\\'t exceed the given n. Then we do 2,20,21,22,23... and so on, while staying within limit.",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def lexicalOrder(self, n: int) -> List[int]:\\n        res=[]\\n        def dfs(num):\\n            if num<=n:\\n                res.append(num)\\n                for i in range(10):\\n                    dfs(num*10+i)\\n        for i in range(1,10):\\n            dfs(i)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 702417,
                "title": "c-dfs-with-comments-and-explanation",
                "content": "Explanation:\\nWe want to order this lexicographically. So we first add a base value (one): `[1]`. We then need to add all it\\'s children because they are all smaller than two. We do this, and we can use the same logic on the children of the children of a number, so it becomes a tree structure where a number\\'s child is that number with a digit appended to it. With that, we can construct a dfs/preorder tree algorithm to solve this problem.\\n\\nC++ code:\\n```c++\\nclass Solution {\\n\\t// store the values as members (you can also pass referance)\\n    vector<int> res; // store this so we don\\'t need to concatenate vectors\\n    int max;\\n    void dfs(int i)\\n    {\\n        if(i > max) // check to make sure it\\'s not larger than max\\n            return;\\n        res.push_back(i); \\n        // we push back current first because:\\n        // children of a number is always larger lexicographically\\n        // example: 123 is lexicographically smaller than 1231, 1232, etc\\n        \\n        int shift = i * 10; \\n        // we shift it so it becomes \\n\\t    // <number>0\\n\\t    // for example 123 becomes 1230\\n        for(int i = 0; i < 10; i++)\\n            dfs(shift + i); // call recursion with its children\\n    }\\npublic:\\n    vector<int> lexicalOrder(int n) {\\n        max = n; // set max value\\n        for(int i = 1; i < 10; i++) // iterate throught all starting vals (can\\'t start with 0)\\n            dfs(i);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\n\\t// store the values as members (you can also pass referance)\\n    vector<int> res; // store this so we don\\'t need to concatenate vectors\\n    int max;\\n    void dfs(int i)\\n    {\\n        if(i > max) // check to make sure it\\'s not larger than max\\n            return;\\n        res.push_back(i); \\n        // we push back current first because:\\n        // children of a number is always larger lexicographically\\n        // example: 123 is lexicographically smaller than 1231, 1232, etc\\n        \\n        int shift = i * 10; \\n        // we shift it so it becomes \\n\\t    // <number>0\\n\\t    // for example 123 becomes 1230\\n        for(int i = 0; i < 10; i++)\\n            dfs(shift + i); // call recursion with its children\\n    }\\npublic:\\n    vector<int> lexicalOrder(int n) {\\n        max = n; // set max value\\n        for(int i = 1; i < 10; i++) // iterate throught all starting vals (can\\'t start with 0)\\n            dfs(i);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 688372,
                "title": "python3-solution-using-dfs",
                "content": "```\\nclass Solution:\\n    \\n    def get_result(self,curr,n):\\n        self.result.append(curr)\\n        for i in range(0,10):\\n            if 10*curr+i<=n:\\n                self.get_result(10*curr+i,n)\\n                \\n    \\n    def lexicalOrder(self, n: int) -> List[int]:\\n        self.result = []\\n        for i in range(1,10):\\n            if i<=n:\\n                self.get_result(i,n)\\n        return self.result\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    \\n    def get_result(self,curr,n):\\n        self.result.append(curr)\\n        for i in range(0,10):\\n            if 10*curr+i<=n:\\n                self.get_result(10*curr+i,n)\\n                \\n    \\n    def lexicalOrder(self, n: int) -> List[int]:\\n        self.result = []\\n        for i in range(1,10):\\n            if i<=n:\\n                self.get_result(i,n)\\n        return self.result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 86327,
                "title": "a-very-very-very-sample-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> lexicalOrder(int n) \\n    {\\n        vector<int> rs;\\n        stack<int> stk;\\n        stk.push(1);\\n        while(!stk.empty())\\n        {\\n            int num = stk.top();\\n            rs.push_back(num);\\n            stk.pop();\\n            if(num + 1 <= n && num%10 < 9)\\n                stk.push(num + 1);\\n            if(10*num <= n)\\n                stk.push(10*num);\\n        }\\n\\n        return rs;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> lexicalOrder(int n) \\n    {\\n        vector<int> rs;\\n        stack<int> stk;\\n        stk.push(1);\\n        while(!stk.empty())\\n        {\\n            int num = stk.top();\\n            rs.push_back(num);\\n            stk.pop();\\n            if(num + 1 <= n && num%10 < 9)\\n                stk.push(num + 1);\\n            if(10*num <= n)\\n                stk.push(10*num);\\n        }\\n\\n        return rs;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3638974,
                "title": "simple-easy-o-n-c-solution-using-recursion-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1) (if we dont count the ans vector otherwise O(n))\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    void solve(int i, int n,vector<int> &v){\\n        //base case\\n        if(i>n) return; // if the number choosen is larger than n that is out of bound and we return\\n\\n        //recersive case\\n        v.push_back(i); // we push the i when it is in the range\\n        for(int j=0;j<=9;j++){\\n            solve(i*10+j,n,v); // after insert the i we move to the next number starting with i and check for all possibility and insert them \\n        }\\n    }\\n    vector<int> lexicalOrder(int n) {\\n        vector<int> ans;\\n        for(int i=1;i<10;i++){\\n            solve(i,n,ans); // we have to insert the number in order from 1 to 9 so we use the loop for it and will insert all the number starting with this digit before moving ahead\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**FEEL FREE TO ASK ANY DOUBT IN THE COMMENT**\\n**IF YOU LIKED MY SOLUTION PLEASE DO UPVOTE :)**",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    void solve(int i, int n,vector<int> &v){\\n        //base case\\n        if(i>n) return; // if the number choosen is larger than n that is out of bound and we return\\n\\n        //recersive case\\n        v.push_back(i); // we push the i when it is in the range\\n        for(int j=0;j<=9;j++){\\n            solve(i*10+j,n,v); // after insert the i we move to the next number starting with i and check for all possibility and insert them \\n        }\\n    }\\n    vector<int> lexicalOrder(int n) {\\n        vector<int> ans;\\n        for(int i=1;i<10;i++){\\n            solve(i,n,ans); // we have to insert the number in order from 1 to 9 so we use the loop for it and will insert all the number starting with this digit before moving ahead\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1705668,
                "title": "simplest-java-1ms-4-liner-solution",
                "content": "![image](https://assets.leetcode.com/users/images/b6f8d72d-c4f3-4d7c-a9c0-b834447c6ae4_1642717297.9898012.png)\\n\\n\\n```\\n\\tpublic void printLex(int n, int asf, ArrayList<Integer> arr) {\\n\\n\\t\\tfor(int digit = 0; digit <= 9; digit++) {\\n\\t\\t\\tif(asf * 10 + digit > 0 && asf * 10 + digit <= n) {\\n\\t\\t\\t\\tarr.add(asf * 10 + digit);\\n\\t\\t\\t\\tprintLex(n, asf * 10 + digit, arr);\\n\\t\\t\\t}\\n\\t\\t}\\n        \\n\\t}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\n\\tpublic void printLex(int n, int asf, ArrayList<Integer> arr) {\\n\\n\\t\\tfor(int digit = 0; digit <= 9; digit++) {\\n\\t\\t\\tif(asf * 10 + digit > 0 && asf * 10 + digit <= n) {\\n\\t\\t\\t\\tarr.add(asf * 10 + digit);\\n\\t\\t\\t\\tprintLex(n, asf * 10 + digit, arr);\\n\\t\\t\\t}\\n\\t\\t}\\n        \\n\\t}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 704549,
                "title": "python-3-inspired-by-iteratively-traverse-through-a-dec-tree-96ms",
                "content": "```\\nclass Solution:\\n    def lexicalOrder(self, n: int) -> List[int]:\\n        res = []\\n        stack = [1] # 1 the root\\n        \\n        while stack:\\n            res.append(stack[-1])\\n            num = stack[-1] * 10 # to check whether it has children\\n            if num <= n: # if it\\'s valid, the means that this node has children, append it\\n                if stack[-1] % 10 != 9: # right shift to visit its sibling\\n                    stack[-1] = stack[-1] + 1\\n                else: #if it\\'s ending with \"9\", means it has no right siblings, then just discard it\\n                    stack.pop()\\n                stack.append(num)\\n            else:\\n                for t in range(stack[-1] + 1, min(n, stack[-1] // 10* 10 + 9) + 1): #it has no children, just add all its siblings to res and discard it\\n                    res.append(t)\\n                stack.pop()\\n        return res\\n\\t\\t```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def lexicalOrder(self, n: int) -> List[int]:\\n        res = []\\n        stack = [1] # 1 the root\\n        \\n        while stack:\\n            res.append(stack[-1])\\n            num = stack[-1] * 10 # to check whether it has children\\n            if num <= n: # if it\\'s valid, the means that this node has children, append it\\n                if stack[-1] % 10 != 9: # right shift to visit its sibling\\n                    stack[-1] = stack[-1] + 1\\n                else: #if it\\'s ending with \"9\", means it has no right siblings, then just discard it\\n                    stack.pop()\\n                stack.append(num)\\n            else:\\n                for t in range(stack[-1] + 1, min(n, stack[-1] // 10* 10 + 9) + 1): #it has no children, just add all its siblings to res and discard it\\n                    res.append(t)\\n                stack.pop()\\n        return res\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 86285,
                "title": "java-backtracking-solution-similar-to-subsets",
                "content": "```\\npublic class Solution {\\n    public List<Integer> lexicalOrder(int n) {\\n        List<Integer> result = new ArrayList<>();\\n        for (int i = 1; i <= 9; i++) {\\n            if (i <= n) {\\n                helper(result, n, i);\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    private void helper(List<Integer> result, int n, int last) {\\n        if (last > n) {\\n            return;\\n        }\\n\\n        result.add(last);\\n\\n        for (int i = 0; i <= 9; i++) {\\n            helper(result, n, last * 10 + i);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public List<Integer> lexicalOrder(int n) {\\n        List<Integer> result = new ArrayList<>();\\n        for (int i = 1; i <= 9; i++) {\\n            if (i <= n) {\\n                helper(result, n, i);\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    private void helper(List<Integer> result, int n, int last) {\\n        if (last > n) {\\n            return;\\n        }\\n\\n        result.add(last);\\n\\n        for (int i = 0; i <= 9; i++) {\\n            helper(result, n, last * 10 + i);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3514484,
                "title": "java-js-2-line-code-98-81-faster",
                "content": "# PLEASE UPVOTE, IF YOU LIKE IT\\n\\n\\n# Complexity\\n- Time complexity:O(nlogn)\\n- Space complexity:O(n)\\n\\n# Code\\n\\n```\\n/**\\n * @param {number} n\\n * @return {number[]}\\n */\\nvar lexicalOrder = function(n) {\\n  const a = new Array(n)\\n  for(let i = 0; i < n; i++){\\n    a[i] = i + 1;\\n  }\\n  return a.sort()\\n};\\n```\\n\\n```\\npublic static List<Integer> lexicalOrder(int n) {\\n        List<Integer> list = new ArrayList<>();\\n        String[] str = new String[n];\\n\\n        for(int i=1;i<=n;i++) str[i-1] = Integer.toString(i);\\n        Arrays.sort(str);\\n        for(String s: str) list.add(Integer.parseInt(s));\\n        return list;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "JavaScript",
                    "Sorting"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {number[]}\\n */\\nvar lexicalOrder = function(n) {\\n  const a = new Array(n)\\n  for(let i = 0; i < n; i++){\\n    a[i] = i + 1;\\n  }\\n  return a.sort()\\n};\\n```\n```\\npublic static List<Integer> lexicalOrder(int n) {\\n        List<Integer> list = new ArrayList<>();\\n        String[] str = new String[n];\\n\\n        for(int i=1;i<=n;i++) str[i-1] = Integer.toString(i);\\n        Arrays.sort(str);\\n        for(String s: str) list.add(Integer.parseInt(s));\\n        return list;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3340674,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(nlogn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> lexicalOrder(int n) \\n    {\\n        vector<int>v;\\n        vector<string>v1;\\n        for(int i=0;i<n;i++)\\n        {\\n            v1.push_back(to_string(i+1));\\n        }\\n        sort(v1.begin(),v1.end());\\n        for(int i=0;i<v1.size();i++)\\n        {\\n            v.push_back(stoi(v1[i]));\\n        }\\n        return v;\\n\\n\\n    }\\n};\\n```\\n![upvote.jpg](https://assets.leetcode.com/users/images/387ced23-a129-4d24-816e-f287ec17dc99_1679764948.063362.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> lexicalOrder(int n) \\n    {\\n        vector<int>v;\\n        vector<string>v1;\\n        for(int i=0;i<n;i++)\\n        {\\n            v1.push_back(to_string(i+1));\\n        }\\n        sort(v1.begin(),v1.end());\\n        for(int i=0;i<v1.size();i++)\\n        {\\n            v.push_back(stoi(v1[i]));\\n        }\\n        return v;\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2063168,
                "title": "accepted-clean-c-code-using-trie-data-structure",
                "content": "```\\nclass Node {\\n    private:\\n    Node* links[10];\\n    bool flag = false;\\n    public:\\n    bool containsKey(int digit) {\\n        return links[digit] != nullptr;\\n    }\\n    void put(int digit, Node* node) {\\n        links[digit] = node;\\n    }\\n    Node* get(int digit) {\\n        return links[digit];\\n    }\\n    bool isEnd() {\\n        return flag;\\n    }\\n    void setEnd() {\\n        flag = true;\\n    }\\n};\\n\\nclass Trie {\\n    private:\\n    Node* root;\\n    public:\\n    Trie() {\\n        root = new Node();\\n    }\\n    void insert(int num) {\\n        stack<int> st;\\n        while(num) {\\n            st.push(num%10);\\n            num /= 10;\\n        }\\n        Node* node = root;\\n        while(!st.empty()) {\\n            int digit = st.top();\\n            st.pop();\\n            if(!node->containsKey(digit)) {\\n                node->put(digit, new Node());\\n            }\\n            node = node->get(digit);\\n        }\\n        node->setEnd();\\n    }\\n    vector<int> dfs() {\\n        vector<int> list;\\n        search(root, list, 0);\\n        return list;\\n    }\\n    void search(Node* root, vector<int> &list, int num) {\\n        if(root->isEnd()) {\\n            list.push_back(num);\\n        }\\n        for(int i=0; i<=9; i++) {\\n            if(root->containsKey(i)) {\\n                int tmp = num*10 + i;\\n                search(root->get(i), list, tmp);\\n            }\\n        }\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> lexicalOrder(int n) {\\n        Trie trie;\\n        for(int i=1; i<=n; i++) trie.insert(i);\\n        return trie.dfs();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack",
                    "Depth-First Search",
                    "Trie",
                    "Recursion"
                ],
                "code": "```\\nclass Node {\\n    private:\\n    Node* links[10];\\n    bool flag = false;\\n    public:\\n    bool containsKey(int digit) {\\n        return links[digit] != nullptr;\\n    }\\n    void put(int digit, Node* node) {\\n        links[digit] = node;\\n    }\\n    Node* get(int digit) {\\n        return links[digit];\\n    }\\n    bool isEnd() {\\n        return flag;\\n    }\\n    void setEnd() {\\n        flag = true;\\n    }\\n};\\n\\nclass Trie {\\n    private:\\n    Node* root;\\n    public:\\n    Trie() {\\n        root = new Node();\\n    }\\n    void insert(int num) {\\n        stack<int> st;\\n        while(num) {\\n            st.push(num%10);\\n            num /= 10;\\n        }\\n        Node* node = root;\\n        while(!st.empty()) {\\n            int digit = st.top();\\n            st.pop();\\n            if(!node->containsKey(digit)) {\\n                node->put(digit, new Node());\\n            }\\n            node = node->get(digit);\\n        }\\n        node->setEnd();\\n    }\\n    vector<int> dfs() {\\n        vector<int> list;\\n        search(root, list, 0);\\n        return list;\\n    }\\n    void search(Node* root, vector<int> &list, int num) {\\n        if(root->isEnd()) {\\n            list.push_back(num);\\n        }\\n        for(int i=0; i<=9; i++) {\\n            if(root->containsKey(i)) {\\n                int tmp = num*10 + i;\\n                search(root->get(i), list, tmp);\\n            }\\n        }\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> lexicalOrder(int n) {\\n        Trie trie;\\n        for(int i=1; i<=n; i++) trie.insert(i);\\n        return trie.dfs();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1826797,
                "title": "lexographical-number-using-map-c",
                "content": "class Solution \\n{\\n public:\\n    vector<int> lexicalOrder(int n) \\n    {\\n        map<string,int>mp;\\n\\t\\t// store it in such manner where it will sort itself accordingly\\n        for(int i=1;i<=n;i++)\\n            mp[to_string(i)]=i;\\n        vector<int>ans;\\n\\t\\t// now after storing print the actual value in by using vector\\n        for(auto i=mp.begin();i!=mp.end();i++)\\n            ans.push_back(i->second);\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution \\n{\\n public:\\n    vector<int> lexicalOrder(int n) \\n    {\\n        map<string,int>mp;\\n\\t\\t// store it in such manner where it will sort itself accordingly\\n        for(int i=1;i<=n;i++)\\n            mp[to_string(i)]=i;\\n        vector<int>ans;\\n\\t\\t// now after storing print the actual value in by using vector\\n        for(auto i=mp.begin();i!=mp.end();i++)\\n            ans.push_back(i->second);\\n        return ans;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1724418,
                "title": "just-observe-things-number-pattern",
                "content": "\\'\\'\\'\\nclass Solution {\\npublic:\\n    void helper(int i,int n,vector<int> &ans)\\n    {\\n        if(i>n) return;\\n        ans.push_back(i);\\n        for(int j=0;j<10;j++)\\n        {\\n            helper(i*10+j,n,ans);\\n        }\\n    }\\n    vector<int> lexicalOrder(int n) {\\n        vector<int> ans;\\n        for(int i=1;i<=9;i++)\\n        {\\n            helper(i,n,ans);\\n        }\\n        return ans;\\n    }\\n};\\nIf u like , then upvote buddy....",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    void helper(int i,int n,vector<int> &ans)\\n    {\\n        if(i>n) return;\\n        ans.push_back(i);\\n        for(int j=0;j<10;j++)\\n        {\\n            helper(i*10+j,n,ans);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 955546,
                "title": "java-3-different-solutions-with-explanation",
                "content": "Approach - 1 : Using string sort\\nWe know that strings are by default sorted lexicographically. Using this, we could create a String array with numbers 1 to N, sort the array and parse the integers back to a list.\\n```\\nclass Solution {\\n    public List<Integer> lexicalOrder(int n) {\\n        String[] strs = new String[n];\\n        for(int i=1;i<=n;i++) strs[i-1] = Integer.toString(i);\\n        Arrays.sort(strs);\\n        List<Integer> op = new ArrayList<>();\\n        for(String s: strs) op.add(Integer.parseInt(s));\\n        return op;\\n    }\\n}\\n```\\n\\nApproach - 2 : Using a stack\\nIf we build the stack so that the first element is always the smallest, then for every pop operation, we have to simply check if any of the numbers are possible with popped number * 10 + (1 to 9).\\n```\\nclass Solution {\\n    public List<Integer> lexicalOrder(int n) {\\n        List<Integer> op = new ArrayList<>();\\n        Stack<Integer> stack = new Stack<>();\\n        for(int i=9;i>=1;i--) if(i<=n) stack.add(i);\\n        while(stack.size()!=0){\\n            int cur = stack.pop();\\n            op.add(cur);\\n            if(cur<n){\\n                for(int i=9;i>=0;i--){\\n                    int next = cur*10+i;\\n                    if(next<=n) stack.add(next);\\n                }\\n            }\\n        }\\n        return op;\\n    }\\n}\\n```\\n\\nApproach - 3: Using recursion \\nSimilar to approach 2, we could start with the smallest possible element and build elements that are possible with this number. If the number is greater than N, we end our recursion\\n```\\nclass Solution {\\n    private int num;\\n    private List<Integer> op;\\n    public List<Integer> lexicalOrder(int n) {\\n        this.num = n;\\n        this.op = new ArrayList<>();\\n        helper(0);\\n        return op;\\n    }\\n    private void helper(int prevNum) {\\n        int start = (prevNum>0?0:1);\\n        for(int i=start;i<=9;i++){\\n            int curNum = prevNum*10+i;\\n            if(curNum<=num){\\n                op.add(curNum);\\n                helper(curNum);\\n            }\\n        }\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Stack",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> lexicalOrder(int n) {\\n        String[] strs = new String[n];\\n        for(int i=1;i<=n;i++) strs[i-1] = Integer.toString(i);\\n        Arrays.sort(strs);\\n        List<Integer> op = new ArrayList<>();\\n        for(String s: strs) op.add(Integer.parseInt(s));\\n        return op;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public List<Integer> lexicalOrder(int n) {\\n        List<Integer> op = new ArrayList<>();\\n        Stack<Integer> stack = new Stack<>();\\n        for(int i=9;i>=1;i--) if(i<=n) stack.add(i);\\n        while(stack.size()!=0){\\n            int cur = stack.pop();\\n            op.add(cur);\\n            if(cur<n){\\n                for(int i=9;i>=0;i--){\\n                    int next = cur*10+i;\\n                    if(next<=n) stack.add(next);\\n                }\\n            }\\n        }\\n        return op;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    private int num;\\n    private List<Integer> op;\\n    public List<Integer> lexicalOrder(int n) {\\n        this.num = n;\\n        this.op = new ArrayList<>();\\n        helper(0);\\n        return op;\\n    }\\n    private void helper(int prevNum) {\\n        int start = (prevNum>0?0:1);\\n        for(int i=start;i<=9;i++){\\n            int curNum = prevNum*10+i;\\n            if(curNum<=num){\\n                op.add(curNum);\\n                helper(curNum);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 290481,
                "title": "java-very-easy-1ms-beats-100-dfs",
                "content": "Idea: For every number, say 1, we are just trying to do 2 things **one by one:**\\n1. Try our best to multipy it with 10 until reaches `n`, e.g., if n is 5000, then the result will be \"1 10 100 1000 ...\"\\n2. Adding 1 to `current` until `current % 10`\\' reaches `9`, i.e., 100 101 102 103 104 105.. 108 109.\\n\\n\\n\\n\\n```\\nclass Solution {\\n    public List<Integer> lexicalOrder(int n) {\\n        List<Integer> res = new ArrayList<>();\\n        dfs(res, n, 1);\\n        return res;\\n    }\\n    \\n    private void dfs(List<Integer> res, int n, int cur) {\\n        if(cur > n) return;\\n        res.add(cur);\\n        dfs(res, n, cur * 10);\\n        if(cur % 10 < 9)\\n            dfs(res, n, cur + 1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> lexicalOrder(int n) {\\n        List<Integer> res = new ArrayList<>();\\n        dfs(res, n, 1);\\n        return res;\\n    }\\n    \\n    private void dfs(List<Integer> res, int n, int cur) {\\n        if(cur > n) return;\\n        res.add(cur);\\n        dfs(res, n, cur * 10);\\n        if(cur % 10 < 9)\\n            dfs(res, n, cur + 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3020669,
                "title": "easy-python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def lexicalOrder(self, n: int) -> List[int]:\\n        lst=[str(i) for i in range(1,n+1)]\\n        lst.sort()\\n        return [int(i) for i in lst]\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def lexicalOrder(self, n: int) -> List[int]:\\n        lst=[str(i) for i in range(1,n+1)]\\n        lst.sort()\\n        return [int(i) for i in lst]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2757701,
                "title": "simple-python-dfs-solution",
                "content": "```\\nclass Solution:\\n    def lexicalOrder(self, n: int) -> List[int]:\\n        ans = []\\n        def helper(x):\\n            nonlocal ans\\n            for y in range(0, 10):\\n                new = (x*10)+y\\n                if new <= n and new > 0:\\n                    ans.append(new)\\n                    helper(new)\\n            \\n        helper(0)\\n        return ans\\n\\t",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def lexicalOrder(self, n: int) -> List[int]:\\n        ans = []\\n        def helper(x):\\n            nonlocal ans\\n            for y in range(0, 10):\\n                new = (x*10)+y\\n                if new <= n and new > 0:\\n                    ans.append(new)\\n                    helper(new)\\n            \\n        helper(0)\\n        return ans\\n\\t",
                "codeTag": "Java"
            },
            {
                "id": 2611394,
                "title": "solution-using-trie",
                "content": "```\\nclass node{\\n  public:\\n    node* v[10];\\n    bool end=false;\\n    \\n    bool ispresent(char i){\\n        return this->v[i-\\'0\\']!=NULL;\\n    }\\n    \\n    void create(char c,node* n){\\n        this->v[c-\\'0\\']=n;\\n    }\\n    \\n    void setend(){\\n        this->end=true;\\n    }\\n    \\n    void find(node* root,string &a,vector<int>&ans){\\n        for(int i=0;i<10;i++){\\n            if(root->ispresent(char(i+\\'0\\'))){\\n                a+=char(i+\\'0\\');\\n                ans.push_back(stoi(a));\\n                find(root->v[i],a,ans);\\n                a.pop_back();\\n            }\\n        }\\n    }\\n    \\n};\\n\\nclass trie{\\n  public:\\n    node* root;\\n    \\n    trie(){\\n        root=new node();\\n    }\\n    \\n    void create(string s){\\n        node* r1=root;\\n        for(auto ele:s){\\n            if(!r1->ispresent(ele)){\\n                r1->create(ele,new node());\\n            }\\n            r1=r1->v[ele-\\'0\\'];\\n        }\\n        \\n        r1->setend();\\n    }\\n    \\n    void find(vector<int>&ans){\\n        string a=\"\";\\n        root->find(root,a,ans);\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> lexicalOrder(int n) {\\n        vector<int>ans;\\n        trie* root=new trie;\\n        \\n        for(int i=1;i<=n;i++){\\n            string s=to_string(i);\\n            root->create(s);\\n        }\\n        \\n        root->find(ans);\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Trie"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> lexicalOrder(int n) {\\n        vector<int>ans;\\n        trie* root=new trie;\\n        \\n        for(int i=1;i<=n;i++){\\n            string s=to_string(i);\\n            root->create(s);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2045898,
                "title": "simple-java-o-n-time-o-1-space-easy-understanding-7ms",
                "content": "**UPVOTE IF YOU FIND IT HELPFUL**\\n```\\nclass Solution {\\n    public void dfs(int curr,int n, List<Integer> list){\\n        if(curr>n)\\n            return;\\n        list.add(curr);\\n        for(int i=0;i<10;i++)\\n            dfs(10*curr+i,n,list);\\n    }\\n    \\n    \\n    public List<Integer> lexicalOrder(int n) {\\n        List<Integer> list = new ArrayList<>();\\n        for(int i=1;i<=9;i++)\\n            dfs(i,n,list);\\n        \\n        return list;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public void dfs(int curr,int n, List<Integer> list){\\n        if(curr>n)\\n            return;\\n        list.add(curr);\\n        for(int i=0;i<10;i++)\\n            dfs(10*curr+i,n,list);\\n    }\\n    \\n    \\n    public List<Integer> lexicalOrder(int n) {\\n        List<Integer> list = new ArrayList<>();\\n        for(int i=1;i<=9;i++)\\n            dfs(i,n,list);\\n        \\n        return list;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1982700,
                "title": "c-iterative-solution",
                "content": "The idea for this one is that you can figure out the next number in lexographic order, starting with a current value of 1.\\n\\nFirst you check to see if you can append a zero. If so, then multiply the current number by 10 to get the next number.\\n\\nFor example, if n = 120, then this rule will give the following:\\n1 -> 10\\n10 -> 100\\n11 -> 110\\n\\nIf you cannot append a zero, then you need to increment the current number by 1. However, it is possible that incrementing the number may cause the number to exceed the limit. In that case, you need to pop the trailing digits off until you can successfully increment by 1. After popping digits, increment the current number by 1. It is not finished though, since you might introduce trailing zeroes, e.g. 199 will become 120. The next in lexographic order after 199 is 12, so we should pop trailing zeroes first.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> lexicalOrder(int n) {\\n        \\n        int current = 1;\\n        vector<int> nums;\\n        while (nums.size() < n) {\\n            nums.push_back(current);\\n            if (current * 10 <= n) { // can we append 0?\\n                current *= 10;\\n            } else {\\n                while (current + 1 > n) { // pop off until we can increment by 1\\n                    current /= 10;\\n                }\\n                current += 1;  // increment by 1\\n                while (current % 10 == 0) {  // if zeros appear, pop them off\\n                    current /= 10;\\n                }\\n            }\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> lexicalOrder(int n) {\\n        \\n        int current = 1;\\n        vector<int> nums;\\n        while (nums.size() < n) {\\n            nums.push_back(current);\\n            if (current * 10 <= n) { // can we append 0?\\n                current *= 10;\\n            } else {\\n                while (current + 1 > n) { // pop off until we can increment by 1\\n                    current /= 10;\\n                }\\n                current += 1;  // increment by 1\\n                while (current % 10 == 0) {  // if zeros appear, pop them off\\n                    current /= 10;\\n                }\\n            }\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1745594,
                "title": "python-o-n-time-o-1-space",
                "content": "```py\\nclass Solution:\\n    def lexicalOrder(self, n: int) -> List[int]:\\n        res = [1]\\n        \\n        while len(res) < n:\\n            last = res[-1]\\n\\n            if last * 10 <= n:\\n                res.append(last * 10)\\n            elif last + 1 <= n and (last + 1) % 10 != 0:\\n                res.append(last + 1)\\n            else:\\n                last = last + 1 if (last + 1) % 10 == 0 else last // 10 + 1\\n                \\n                while last % 10 == 0:\\n                    last //= 10\\n                res.append(last)\\n\\n        return res\\n```\\n\\nI mainly just came up with this through trial and error. On each iteration you build up on the last value.\\n\\nNote: The while loops divide the number by 10 on each iteration. So even on the max 64-bit number the loop terminates in 20 iterations (much fewer here due to constraints).",
                "solutionTags": [
                    "Python",
                    "Iterator"
                ],
                "code": "```py\\nclass Solution:\\n    def lexicalOrder(self, n: int) -> List[int]:\\n        res = [1]\\n        \\n        while len(res) < n:\\n            last = res[-1]\\n\\n            if last * 10 <= n:\\n                res.append(last * 10)\\n            elif last + 1 <= n and (last + 1) % 10 != 0:\\n                res.append(last + 1)\\n            else:\\n                last = last + 1 if (last + 1) % 10 == 0 else last // 10 + 1\\n                \\n                while last % 10 == 0:\\n                    last //= 10\\n                res.append(last)\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1100514,
                "title": "c-4ms-backtracking-solution",
                "content": "I considered this backtracking because the recursive call implicitly does `x *= 10` and then `x /= 10`. I\\'ve seen some implementations (even the iterative ones) do this explicitly to make it more similar to a conventional backtracking.\\n\\nI like this solution because it\\'s concise and doesn\\'t require explicitly handling the edge case such as 1999 -> 2.\\n\\n**Time: O(n)**\\n**Space: O(k)** where k = len(str(n)) due to height of recursion stack. This is technically O(1) if the constraint of max value of n is given.\\n\\nNotes for comprehension:\\nThe for loop index starts at `i = x % 10` because the first call to `backtrack` has the value of x of 1 to 9 while every other call to backtrack has a value of x with the ones digit of 0 to 9.\\nThe `if (x * 10 <= n)` condition makes it 4ms, without it it is 8ms. I believe this is because when x <= n but x * 10 > n, then x * 10, (x + 1) * 10, (x + 2) * 10, etc. will all add to the recursion stack but early terminate.\\n```\\nclass Solution {\\n    \\nprivate:\\n    void backtrack(std::vector<int>& ordering, int x, int n) {\\n        for (int i = x % 10; i < 10; ++i) {\\n            if (x > n) return;\\n            ordering.push_back(x);\\n            if (x * 10 <= n) backtrack(ordering, x * 10, n);\\n            ++x;\\n        }\\n    }\\n    \\npublic:\\n    vector<int> lexicalOrder(int n) {\\n        std::vector<int> ordering;\\n        backtrack(ordering, 1, n);\\n        return ordering;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    \\nprivate:\\n    void backtrack(std::vector<int>& ordering, int x, int n) {\\n        for (int i = x % 10; i < 10; ++i) {\\n            if (x > n) return;\\n            ordering.push_back(x);\\n            if (x * 10 <= n) backtrack(ordering, x * 10, n);\\n            ++x;\\n        }\\n    }\\n    \\npublic:\\n    vector<int> lexicalOrder(int n) {\\n        std::vector<int> ordering;\\n        backtrack(ordering, 1, n);\\n        return ordering;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 882550,
                "title": "c-recursion-dfs-solution-explained-beats-95-runtime",
                "content": "Runtime: 8 ms, faster than 94.63% of C++ online submissions for Lexicographical Numbers.\\nMemory Usage: 11.3 MB, less than 43.81% of C++ online submissions for Lexicographical Numbers.\\n\\nGenerating Lexical Order of Integer 1 to N is actually same as traversing a Trie DataStructure as Trie has items in lexical order. \\nSuppose all numbers are stored in Trie, now how will we traverse trie sequntially ? DFS ?\\n\\n```\\nGiven N = 100, Starting from number 1 \\n\\n1 < N => push 1\\n1->0 <N  => push 10\\n1->0->0 ==N =>push 100\\n1->0->1 > N => return\\n1->1 <N => push 11\\n1->1->0 >N => return \\n1->2 <N => push 12\\n1->2->0 >N => return\\n....................................\\n1->9 <N => push 19\\n1->9->0 >N => return\\n2 < N => push 2\\n............................................ and so on\\n\\nNow to perform this traverse we call recursion starting with MSB digit 1 to 9 as the number with  MSB digit 2\\nalways has lower rank than number with MSB digit 1 and higher rank than number with MSB digit 3. \\n\\nEvery number x called in recursion has next starting number x*10 and next number range is \\nfrom x*10 + 0  to x*10 + 9. So we call recursion again for number x*10+K.\\nGiven, N = 100 we get the below sequence when recursion called with 1.\\n\\n[1, 10, 100, 11, 12, 13, 14, 15, 16, 17, 18, 19]\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    bool lexNum(int x, int &n, vector<int>&result)\\n    {\\n        // If number <=N push in to result\\n        if(x<=n) result.push_back(x);\\n        else return false;  // otherwise return to prevent unnecessary recursion call\\n        \\n        // get starting value of next number x * 10\\n        x = x * 10;\\n        \\n        // next number is in range x * 10 + 0 to x * 10 + 9\\n        for(int j=0;j<=9;j++)\\n            if(!lexNum(x+j,n,result))break; // If next number is not in range of N then break\\n                                            // to prevent unnecessary recursion call\\n        return true;\\n    }\\n    \\n    vector<int> lexicalOrder(int n) {\\n        \\n        // result vector\\n        vector<int>res;\\n        \\n        // call recursion with starting MSB digit 1 to 9  \\n        for(int i=1;i<=9;i++)\\n            lexNum(i, n, res);\\n        \\n        return res;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nGiven N = 100, Starting from number 1 \\n\\n1 < N => push 1\\n1->0 <N  => push 10\\n1->0->0 ==N =>push 100\\n1->0->1 > N => return\\n1->1 <N => push 11\\n1->1->0 >N => return \\n1->2 <N => push 12\\n1->2->0 >N => return\\n....................................\\n1->9 <N => push 19\\n1->9->0 >N => return\\n2 < N => push 2\\n............................................ and so on\\n\\nNow to perform this traverse we call recursion starting with MSB digit 1 to 9 as the number with  MSB digit 2\\nalways has lower rank than number with MSB digit 1 and higher rank than number with MSB digit 3. \\n\\nEvery number x called in recursion has next starting number x*10 and next number range is \\nfrom x*10 + 0  to x*10 + 9. So we call recursion again for number x*10+K.\\nGiven, N = 100 we get the below sequence when recursion called with 1.\\n\\n[1, 10, 100, 11, 12, 13, 14, 15, 16, 17, 18, 19]\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    bool lexNum(int x, int &n, vector<int>&result)\\n    {\\n        // If number <=N push in to result\\n        if(x<=n) result.push_back(x);\\n        else return false;  // otherwise return to prevent unnecessary recursion call\\n        \\n        // get starting value of next number x * 10\\n        x = x * 10;\\n        \\n        // next number is in range x * 10 + 0 to x * 10 + 9\\n        for(int j=0;j<=9;j++)\\n            if(!lexNum(x+j,n,result))break; // If next number is not in range of N then break\\n                                            // to prevent unnecessary recursion call\\n        return true;\\n    }\\n    \\n    vector<int> lexicalOrder(int n) {\\n        \\n        // result vector\\n        vector<int>res;\\n        \\n        // call recursion with starting MSB digit 1 to 9  \\n        for(int i=1;i<=9;i++)\\n            lexNum(i, n, res);\\n        \\n        return res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 260860,
                "title": "elegant-python-solution-beats-100",
                "content": "DFS -- Find all multiples of 10 that fit in n first.\\n \\n1. Look for all multiples of 10 that fit in n\\n2. Add one, but make sure it isnt a multiple of 10\\n3. Repeat\\n\\n\\n```\\nclass Solution(object):\\n    def lexicalOrder(self, n):\\n        res = []\\n        \\n        def dfs(curr):\\n            if curr > n: return\\n            res.append(curr)\\n            \\n            dfs(curr * 10)   \\n            if (curr + 1) % 10 != 0: dfs(curr + 1)\\n            \\n        dfs(1)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def lexicalOrder(self, n):\\n        res = []\\n        \\n        def dfs(curr):\\n            if curr > n: return\\n            res.append(curr)\\n            \\n            dfs(curr * 10)   \\n            if (curr + 1) % 10 != 0: dfs(curr + 1)\\n            \\n        dfs(1)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3529211,
                "title": "java-easy-100-o-n-dfs-solution",
                "content": "```java\\nclass Solution {\\n    public List<Integer> lexicalOrder(int n) {\\n        List<Integer> result = new ArrayList<>();\\n        helper(n, 1, result);\\n        return result;\\n    }\\n\\n    private void helper(int n, int curr, List<Integer> result) {\\n        if(curr > n)\\n            return;\\n        \\n        result.add(curr);\\n        helper(n, curr * 10, result);\\n        if(curr % 10 != 9)\\n            helper(n, curr + 1, result);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public List<Integer> lexicalOrder(int n) {\\n        List<Integer> result = new ArrayList<>();\\n        helper(n, 1, result);\\n        return result;\\n    }\\n\\n    private void helper(int n, int curr, List<Integer> result) {\\n        if(curr > n)\\n            return;\\n        \\n        result.add(curr);\\n        helper(n, curr * 10, result);\\n        if(curr % 10 != 9)\\n            helper(n, curr + 1, result);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3317581,
                "title": "easy-solution-o-n-time-o-1-space-beats-90-examples-and-thought-process",
                "content": "To solve this problem, it\\u2019s less about data structure knowledge and applying them, it\\u2019s more about understanding what is \\u201Clexicographical order?\\u201D If you do understand what that means the problem becomes easy.\\n\\n## What is lexicographical order?\\n\\nPeople online say it\\u2019s like alphabetical order but applied with numbers. Let\\u2019s go over some alphabetical examples that made me understand then translate that into numbers. This example is only to showcase \\u201Clexicographical order,\\u201D not an example for the actual problem.\\n\\n```json\\na, aa, aaa, aab, aac\\u2026aaz, ab\\u2026az, b\\u2026\\n```\\n\\n\\u201Ca\\u201D is the smallest letter, so we keep on going with it until we reach \\u201Cz,\\u201D which I like to call the \\u201Cmax letter\\u201D we can go up to.\\n\\nOnce we hit this \\u201Cmax letter\\u201D we want to increment the next letter. In this example, specifically at \\u201Caaz,\\u201D we reached the max letter, so we want to increment the next letter which is the \\u201C**a**\\u201D in \\u201Ca**a**z.\\u201D So we drop the z and keep going with this process. Once we hit \\u201Caz,\\u201D we do the samething and finally we reach \\u201Cb!\\u201D\\n\\nSo now we can translate this into numbers:\\n\\n- the \\u201Cmax letter\\u201D in this case will be the number 9\\n- the number 0 is the smallest number\\n\\n## Examples\\n\\nGreat, so now we know what lexicographical order means and are able to translate the process into numbers, lets go through some examples to maybe showcase how we can code this by going through it by hand.\\n\\n##### Example 1\\n\\n- Input = 9\\n- Output:\\n\\n```json\\n[1, 2, 3, 4, 5, 6, 7, 8, 9]\\n```\\n\\nWith 1 digit inputs it doesn\\u2019t look like it\\u2019s in lexicographical order, but when we reach 2+ digits it does.\\n\\n##### Example 2\\n\\n- Input = 19\\n- Output:\\n\\n```json\\n[1, 10...19, 2, 3, 4, 5, 6, 7, 8, 9]\\n```\\n\\nWe\\u2019ve reached our input, 19, this is a standard case. Once we hit our max number, 9, for that digit, we want to move onto that \\u201C**1**\\u201D in \\u201C**1**9\\u201D and increment that.\\n\\n##### Example 3\\n\\n- Input = 10\\n- Output:\\n\\n```json\\n[1, 10, 2, 3, 4, 5, 6, 7, 8, 9]\\n```\\n\\nInteresting, we\\u2019ve reached out input but haven\\u2019t reached the max number, but we still had to move onto that \\u201C**1**\\u201D in \\u201C**1**0\\u201D to make it a 2. We\\u2019re going through it by hand, but just something to note on how we might code it.\\n\\n##### Example 4:\\n\\n- Input = 200\\n- Output:\\n\\n```json\\n[1, 10, 100..109, 11, 110......199, 2, 20, 200, 3, 30, 31......]\\n```\\n\\nAs you can see here, we keep on adding the smallest number, 0, to the end of our current number and never go over our input, this is so we have a list that has a range of 0 to N.\\n\\nThere\\u2019s also an interesting case, the 199. It already has two digits with two max numbers, so that means we would have to drop both and increment the \\u201C**1**\\u201D in \\u201C**1**99\\u201D so we can get to 2 and move on lexicographically.\\n\\nNow that we have gone through some examples, specifically examples that showcase how our code and algorithm, lets go ahead and take what we\\u2019ve learned and finally implement.\\n\\n## Implement\\n\\n```python\\ndef lexicalOrder(n):\\n\\tcurNum = 1\\n    res = []\\n\\n    for i in range(0, n):\\n        res.append(curNum)\\n        if curNum * 10 <= n:\\n            curNum * 10\\n        else:\\n            while((curNum % 10) == 9 or curNum == n):\\n                curNum = curNum // 10\\n            curNum += 1\\n    \\n    return res\\n```\\n\\n## Thought Process Behind Implementation\\n(Best to first look at the code below the text to get context)\\n\\nI\\u2019m usually brainwashed to use `i` as a value to append into a list but in this case it wouldn\\u2019t work for lexicographical order. So I created a `int curNum` that would be this number we could append and modify.\\n\\nSo we\\u2019re basically using the for loop to be a counter of how many iterations we\\u2019re at, which should be up to `n` iterations to satisfy a list of numbers `[1, n]`\\n\\nIt\\u2019s also given at each iteration we\\u2019re going to append our `curNum`.\\n\\n```python\\n\\tcurNum = 1\\n    res = []\\n\\n    for i in range(0, n):\\n\\t\\t\\tres.append(curNum)\\n```\\n\\nThis is our intuition from Example 4, where we keep adding the smallest number, 0, as long as we don\\u2019t go over our input `n`\\n\\n```python\\n        if curNum * 10 <= n:\\n            curNum * 10\\n```\\n\\nIf we can\\u2019t keep adding our smallest number, we\\u2019ll just keep incrementing our current number we\\u2019re at.\\n\\n```python\\n        else:\\n            ...\\n                ...\\n            curNum += 1\\n```\\n\\nBut once we\\u2019re at the point where we reached our max number, we need to move onto the next number to increment.\\n\\nTo identify if our number has reached its max, 9, we can do modulo division extract the ones placed digit. Just like Example 2.\\n\\nIf it is 9, we want to integer divide our `curNum` by 10 so we can remove the 9 and keep incrementing.\\n\\nThere will also be a case where our `curNum` has reached `n` in that case it will have the same outcome as if we\\u2019ve reached 9.\\n\\nIn Example 4 we\\u2019ve identified there would be numbers like 199, 1999, etc. So that\\u2019s why there\\u2019s a `while` loop to compensate for those cases of `curNum`.\\n\\n```python\\n        else:\\n            while((curNum % 10) == 9 or curNum == n):\\n                curNum = curNum // 10\\n            curNum += 1\\n```\\n\\n## Review Complexity\\n\\n**Time O(n)**\\n\\nWe\\u2019re iterating `n` times within the for loop. In every iteration, we\\u2019re storing a correct and already lexicographical result into the list. There is a while which loops as many \\u201C9\\u201D there are in the number, but that shouldn\\u2019t be an issue to change our time complexity.\\n\\n**Extra Space O(1)**\\n\\nWe\\u2019re not using any extra data structures to solve this problem, we\\u2019re only using extra variables such as `curNum`. We created a list to store our result, but that\\u2019s not considered extra space, it\\u2019s necessary. \\n\\n## Conclusion\\n\\nHope this helps if you were stuck or just wanted to undestand it from another perspective. This was from my perspective and my own understanding so it might be confusing if you don\\u2019t get me haha, I\\u2019m sure there are other explanations and solutions that are better for you in that case.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```json\\na, aa, aaa, aab, aac\\u2026aaz, ab\\u2026az, b\\u2026\\n```\n```json\\n[1, 2, 3, 4, 5, 6, 7, 8, 9]\\n```\n```json\\n[1, 10...19, 2, 3, 4, 5, 6, 7, 8, 9]\\n```\n```json\\n[1, 10, 2, 3, 4, 5, 6, 7, 8, 9]\\n```\n```json\\n[1, 10, 100..109, 11, 110......199, 2, 20, 200, 3, 30, 31......]\\n```\n```python\\ndef lexicalOrder(n):\\n\\tcurNum = 1\\n    res = []\\n\\n    for i in range(0, n):\\n        res.append(curNum)\\n        if curNum * 10 <= n:\\n            curNum * 10\\n        else:\\n            while((curNum % 10) == 9 or curNum == n):\\n                curNum = curNum // 10\\n            curNum += 1\\n    \\n    return res\\n```\n```python\\n\\tcurNum = 1\\n    res = []\\n\\n    for i in range(0, n):\\n\\t\\t\\tres.append(curNum)\\n```\n```python\\n        if curNum * 10 <= n:\\n            curNum * 10\\n```\n```python\\n        else:\\n            ...\\n                ...\\n            curNum += 1\\n```\n```python\\n        else:\\n            while((curNum % 10) == 9 or curNum == n):\\n                curNum = curNum // 10\\n            curNum += 1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2922350,
                "title": "easy-trie-solution-c",
                "content": "# Intuition\\nJust insert all the number in trie and then traverse in trie to get the numbers in lexographical order.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    struct Node {\\n        Node * links[10];               // 0-9\\n        bool flag = false;\\n        bool isContains(char ch){       // Node has ch or not\\n            return links[ch-\\'0\\'] != NULL;\\n        }\\n        void put (char ch, Node * node){\\n            links[ch-\\'0\\'] = node;\\n        }\\n        Node* get(char ch){\\n            return links[ch-\\'0\\'];\\n        }\\n    };\\n    class Trie {\\n    public:\\n         Node * root;\\n        Trie() {\\n            root = new Node();\\n        }\\n        void insert(string word) {\\n            Node * node = root;\\n            int n = word.size();\\n            for(int i = 0;i<n;i++){\\n                if(!(node ->isContains(word[i]))){    // if node doesn\\'t contain word[i]\\n                    node->put(word[i],new Node());\\n                }\\n                node = node->get(word[i]);       // move forward\\n            }\\n            node->flag = true;                   // word is end here mark flag as true \\n        }\\n        \\n    };\\n    void traverseTrie(Node * root, int curr, vector<int> &ans){       // normal dfs\\n        if(root == NULL) return;\\n        if(root->flag) {\\n            ans.push_back(curr);\\n        }\\n        for(char ch = \\'0\\';ch <=\\'9\\';ch++){\\n            if(root->isContains(ch)){\\n                traverseTrie(root->get(ch), (curr*10 )+ (ch - \\'0\\'), ans);\\n            }\\n        }\\n    }\\n    vector<int> lexicalOrder(int n) {\\n        Trie trie;\\n        for(int i = 1;i<=n;i++){\\n            string s = to_string(i);        // it will be easy to traverse a string as compared to integer\\n            trie.insert(s);\\n        }\\n        vector<int> ans;                     \\n        traverseTrie(trie.root,0,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    struct Node {\\n        Node * links[10];               // 0-9\\n        bool flag = false;\\n        bool isContains(char ch){       // Node has ch or not\\n            return links[ch-\\'0\\'] != NULL;\\n        }\\n        void put (char ch, Node * node){\\n            links[ch-\\'0\\'] = node;\\n        }\\n        Node* get(char ch){\\n            return links[ch-\\'0\\'];\\n        }\\n    };\\n    class Trie {\\n    public:\\n         Node * root;\\n        Trie() {\\n            root = new Node();\\n        }\\n        void insert(string word) {\\n            Node * node = root;\\n            int n = word.size();\\n            for(int i = 0;i<n;i++){\\n                if(!(node ->isContains(word[i]))){    // if node doesn\\'t contain word[i]\\n                    node->put(word[i],new Node());\\n                }\\n                node = node->get(word[i]);       // move forward\\n            }\\n            node->flag = true;                   // word is end here mark flag as true \\n        }\\n        \\n    };\\n    void traverseTrie(Node * root, int curr, vector<int> &ans){       // normal dfs\\n        if(root == NULL) return;\\n        if(root->flag) {\\n            ans.push_back(curr);\\n        }\\n        for(char ch = \\'0\\';ch <=\\'9\\';ch++){\\n            if(root->isContains(ch)){\\n                traverseTrie(root->get(ch), (curr*10 )+ (ch - \\'0\\'), ans);\\n            }\\n        }\\n    }\\n    vector<int> lexicalOrder(int n) {\\n        Trie trie;\\n        for(int i = 1;i<=n;i++){\\n            string s = to_string(i);        // it will be easy to traverse a string as compared to integer\\n            trie.insert(s);\\n        }\\n        vector<int> ans;                     \\n        traverseTrie(trie.root,0,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2672240,
                "title": "c-trie-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Trie{\\n    public:\\n    vector<Trie*> v;\\n    bool isEnd;\\n    int data;\\n    Trie(){\\n        v=vector<Trie*>(10,nullptr);\\n        isEnd=false;\\n        data = -1;\\n    }\\n};\\nclass Solution {\\n    void insert(Trie* node, int a)\\n    {\\n        Trie* root = node;\\n        string key = to_string(a);\\n        for(auto &x:key)\\n        {\\n            int curr = x-\\'0\\';\\n            if(root->v[curr]==nullptr) root->v[curr]=new Trie();\\n            root = root->v[curr];\\n        }\\n        root->isEnd=true;\\n        root->data = a;\\n    }\\n    vector<int> ans;\\n    void printAll(Trie* root)\\n    {\\n        if(root->isEnd){\\n            ans.push_back(root->data);\\n        }\\n        for(int i=0;i<10;i++){\\n            if(root->v[i]) printAll(root->v[i]);\\n        }\\n    }\\npublic:\\n    vector<int> lexicalOrder(int n) {\\n        ans.clear();\\n        Trie* root = new Trie();\\n        for(int i=1;i<=n;i++) insert(root,i);\\n        printAll(root);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Trie{\\n    public:\\n    vector<Trie*> v;\\n    bool isEnd;\\n    int data;\\n    Trie(){\\n        v=vector<Trie*>(10,nullptr);\\n        isEnd=false;\\n        data = -1;\\n    }\\n};\\nclass Solution {\\n    void insert(Trie* node, int a)\\n    {\\n        Trie* root = node;\\n        string key = to_string(a);\\n        for(auto &x:key)\\n        {\\n            int curr = x-\\'0\\';\\n            if(root->v[curr]==nullptr) root->v[curr]=new Trie();\\n            root = root->v[curr];\\n        }\\n        root->isEnd=true;\\n        root->data = a;\\n    }\\n    vector<int> ans;\\n    void printAll(Trie* root)\\n    {\\n        if(root->isEnd){\\n            ans.push_back(root->data);\\n        }\\n        for(int i=0;i<10;i++){\\n            if(root->v[i]) printAll(root->v[i]);\\n        }\\n    }\\npublic:\\n    vector<int> lexicalOrder(int n) {\\n        ans.clear();\\n        Trie* root = new Trie();\\n        for(int i=1;i<=n;i++) insert(root,i);\\n        printAll(root);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2668420,
                "title": "very-simple-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUsing BackTacking and abstraction\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nfirt we will be getting the number and will go to it\\'s below see whether number is in range or not if it is move recursively\\ndo the backtrack on the number\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n     void solve(vector<int>&ans,int n,int re){\\n         for(int i = 0;i<=9;i++){\\n             re = re*10+i;\\n             if(re>=1 && re<=n){\\n                 ans.push_back(re);\\n                 solve(ans,n,re);\\n             }\\n             re = re-i;\\n             re = re/10;\\n         }\\n         return ;\\n     }\\n    vector<int> lexicalOrder(int n) {\\n        vector<int>ans;\\n        int re = 0;\\n        solve(ans,n,re);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Trie",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     void solve(vector<int>&ans,int n,int re){\\n         for(int i = 0;i<=9;i++){\\n             re = re*10+i;\\n             if(re>=1 && re<=n){\\n                 ans.push_back(re);\\n                 solve(ans,n,re);\\n             }\\n             re = re-i;\\n             re = re/10;\\n         }\\n         return ;\\n     }\\n    vector<int> lexicalOrder(int n) {\\n        vector<int>ans;\\n        int re = 0;\\n        solve(ans,n,re);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2287388,
                "title": "easy-python-solution-using-dfs-and-trie-logic",
                "content": "```\\ndef lexicalOrder(self, n: int) -> List[int]:\\n\\tans = []\\n\\tdef dfs(s):\\n\\t\\tans.append(int(s))\\n\\t\\tfor i in range(10):\\n\\t\\t\\tif(int(s+str(i)) > n):\\n\\t\\t\\t\\treturn\\n\\t\\t\\telse:\\n\\t\\t\\t\\tif(s): dfs(s+str(i))\\n\\n\\tfor i in range(1, min(n+1, 10)): dfs(str(i))\\n\\treturn ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```\\ndef lexicalOrder(self, n: int) -> List[int]:\\n\\tans = []\\n\\tdef dfs(s):\\n\\t\\tans.append(int(s))\\n\\t\\tfor i in range(10):\\n\\t\\t\\tif(int(s+str(i)) > n):\\n\\t\\t\\t\\treturn\\n\\t\\t\\telse:\\n\\t\\t\\t\\tif(s): dfs(s+str(i))\\n\\n\\tfor i in range(1, min(n+1, 10)): dfs(str(i))\\n\\treturn ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2180370,
                "title": "3-solutions-easy-2-understand-with-optimizations-c",
                "content": "# Solution 1:\\n```\\nclass Solution {\\npublic:\\n    vector<int> lexicalOrder(int n) {\\n        vector<int> nums;\\n        for(int i=1;i<=n;i++)\\n            nums.push_back(i);\\n        \\n        sort(nums.begin(),nums.end(),compare);\\n        return nums;\\n    }\\n    \\n    bool static compare(int a, int b){\\n        string str_a = to_string(a);\\n        string str_b = to_string(b);\\n        \\n        return str_a < str_b;\\n    }\\n};\\n```\\n\\n# Solution 2:\\n```\\nclass Node{\\n    public:\\n    int num;\\n    map<int,Node*> children;\\n    bool isTerminal;\\n    Node(int num){\\n        this->num = num;\\n    }\\n};\\n\\nclass Trie{\\n    public:\\n    Node *root;\\n    \\n    Trie(){\\n        root = new Node(0);\\n    }\\n    \\n    void insert(int num){\\n        Node *temp = root;\\n        vector<int> digit;\\n        while(num){\\n            int r = num%10;\\n            digit.push_back(r);\\n            num /= 10;\\n        }\\n        for(int i=digit.size()-1;i>=0;i--){\\n            int n = digit[i];\\n            if(temp->children.count(n)){\\n                temp = temp->children[n];\\n            }else{\\n                temp->children[n] = new Node(n);\\n                temp = temp->children[n];\\n            }\\n        }\\n        temp->isTerminal = true;\\n    }\\n    \\n    vector<int> getNums(){\\n        vector<int> ans;\\n        int num=0;\\n        dfs_helper(root,ans,num);\\n        return ans;\\n    }\\n    \\n    void dfs_helper(Node *root,vector<int> &ans,int &num){\\n        for(auto it : root->children){\\n            num = num*10 + it.first;\\n            if(it.second->isTerminal)\\n                ans.push_back(num);\\n            dfs_helper(it.second,ans,num);\\n            num /= 10;\\n        }\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> lexicalOrder(int n) {\\n        Trie T;\\n        for(int i=1;i<=n;i++)\\n            T.insert(i);\\n        \\n        return T.getNums();\\n    }\\n};\\n```\\n\\n# Solution 3:\\n```\\nCredits : @Hcisly\\nhttps://leetcode.com/problems/lexicographical-numbers/discuss/86288/7-lines-simple-C%2B%2B-recursive-solution\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> lexicalOrder(int n) {\\n        vector<int> nums;\\n        traverse(1,n,nums);\\n        return nums;\\n    }\\n    \\n    // draw the recursive to understand better\\n    void traverse(int i,int n,vector<int> &nums){\\n        if(i > n)\\n            return;\\n        nums.push_back(i);\\n        traverse(i*10,n,nums);\\n        if(i % 10 != 9)\\n            traverse(i+1,n,nums);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Trie",
                    "Recursion",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> lexicalOrder(int n) {\\n        vector<int> nums;\\n        for(int i=1;i<=n;i++)\\n            nums.push_back(i);\\n        \\n        sort(nums.begin(),nums.end(),compare);\\n        return nums;\\n    }\\n    \\n    bool static compare(int a, int b){\\n        string str_a = to_string(a);\\n        string str_b = to_string(b);\\n        \\n        return str_a < str_b;\\n    }\\n};\\n```\n```\\nclass Node{\\n    public:\\n    int num;\\n    map<int,Node*> children;\\n    bool isTerminal;\\n    Node(int num){\\n        this->num = num;\\n    }\\n};\\n\\nclass Trie{\\n    public:\\n    Node *root;\\n    \\n    Trie(){\\n        root = new Node(0);\\n    }\\n    \\n    void insert(int num){\\n        Node *temp = root;\\n        vector<int> digit;\\n        while(num){\\n            int r = num%10;\\n            digit.push_back(r);\\n            num /= 10;\\n        }\\n        for(int i=digit.size()-1;i>=0;i--){\\n            int n = digit[i];\\n            if(temp->children.count(n)){\\n                temp = temp->children[n];\\n            }else{\\n                temp->children[n] = new Node(n);\\n                temp = temp->children[n];\\n            }\\n        }\\n        temp->isTerminal = true;\\n    }\\n    \\n    vector<int> getNums(){\\n        vector<int> ans;\\n        int num=0;\\n        dfs_helper(root,ans,num);\\n        return ans;\\n    }\\n    \\n    void dfs_helper(Node *root,vector<int> &ans,int &num){\\n        for(auto it : root->children){\\n            num = num*10 + it.first;\\n            if(it.second->isTerminal)\\n                ans.push_back(num);\\n            dfs_helper(it.second,ans,num);\\n            num /= 10;\\n        }\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> lexicalOrder(int n) {\\n        Trie T;\\n        for(int i=1;i<=n;i++)\\n            T.insert(i);\\n        \\n        return T.getNums();\\n    }\\n};\\n```\n```\\nCredits : @Hcisly\\nhttps://leetcode.com/problems/lexicographical-numbers/discuss/86288/7-lines-simple-C%2B%2B-recursive-solution\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> lexicalOrder(int n) {\\n        vector<int> nums;\\n        traverse(1,n,nums);\\n        return nums;\\n    }\\n    \\n    // draw the recursive to understand better\\n    void traverse(int i,int n,vector<int> &nums){\\n        if(i > n)\\n            return;\\n        nums.push_back(i);\\n        traverse(i*10,n,nums);\\n        if(i % 10 != 9)\\n            traverse(i+1,n,nums);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2169377,
                "title": "javascript-dfs-recursive",
                "content": "Start with the larger numbers say 1390\\nDesired output is: 1,1**0**,1**00**,1**000**,1001,1002,1003,...,1008, 1009, **101**, 1010, 1011, 1012...1019, **102**, 1020, 1021, 1022...1029, **103**, 1030, 1031...1039, **104**, 1040, 1041, 1042...\\nSo the key to solve this problem is:\\n1. Every number starts from 1-9 (Obviously :))\\n2. For the current number, recursively go deep to generate numbers with digits counts equals digits count of n. Apply DFS.\\n3. Keep aggregating them in a single arr while they are being generated. \\n For an example for n = 1390,\\n \\n Start from 1, \\n go deep 10, \\n go deep 100,\\n go deep 1000,\\n go deep 10000(meh, it is > 1390) <--- Discard\\n Add 1001 to 1009 ( Add 9 numbers in each pass, meh, 10010 to 10090 can\\'t go deeper )\\n go up 101\\n go deep 1010\\n go deep 10100(meh, return bro)\\n Add 1011 to 1019\\n go up 102\\n go deep 1020.\\n ...\\n ...\\n ...\\nlikewise\\n\\n```\\n/**\\n * @param {number} n\\n * @return {number[]}\\n */\\nvar lexicalOrder = function(n) {\\n    const arr = [];\\n    \\n    function dfs(baseIndex) {\\n        if (baseIndex * 10 > n) {\\n            return;\\n        }\\n        \\n        for(let i = baseIndex * 10; i < baseIndex * 10 + 10 && i <= n; i++)  {\\n           arr.push(i);\\n           dfs(i);\\n        }\\n    }\\n    \\n    let stack = [];\\n    \\n    for(let i = 1; i <= 9 && i <= n; i++) {\\n        arr.push(i);        \\n        dfs(i);\\n    }\\n    \\n    return arr;\\n};\\n```\\n\\n",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {number[]}\\n */\\nvar lexicalOrder = function(n) {\\n    const arr = [];\\n    \\n    function dfs(baseIndex) {\\n        if (baseIndex * 10 > n) {\\n            return;\\n        }\\n        \\n        for(let i = baseIndex * 10; i < baseIndex * 10 + 10 && i <= n; i++)  {\\n           arr.push(i);\\n           dfs(i);\\n        }\\n    }\\n    \\n    let stack = [];\\n    \\n    for(let i = 1; i <= 9 && i <= n; i++) {\\n        arr.push(i);        \\n        dfs(i);\\n    }\\n    \\n    return arr;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2053392,
                "title": "python-oneliner",
                "content": "```\\nclass Solution:\\n    def lexicalOrder(self, n: int) -> List[int]:\\n        return sorted([x for x in range(1,n+1)],key=lambda x: str(x))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def lexicalOrder(self, n: int) -> List[int]:\\n        return sorted([x for x in range(1,n+1)],key=lambda x: str(x))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1796513,
                "title": "python-o-n-time-but-not-o-1-space-complexity-accepted-at-143ms-need-review",
                "content": "```\\nclass Solution:\\n    def lexicalOrder(self, n: int) -> List[int]:\\n        temp = []\\n        for i in range(1, n+1):\\n            temp.append(str(i))\\n        \\n        temp.sort()\\n        res = [int(i) for i in temp]\\n        return res\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def lexicalOrder(self, n: int) -> List[int]:\\n        temp = []\\n        for i in range(1, n+1):\\n            temp.append(str(i))\\n        \\n        temp.sort()\\n        res = [int(i) for i in temp]\\n        return res\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1785953,
                "title": "c-backtracking-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> lexicalOrder(int n) {\\n        vector<int> results;\\n        \\n        lexicalOrder(results, n);\\n        \\n        return results;\\n    }\\n    \\n    void lexicalOrder(vector<int> &results, int n) {\\n        for(int i = 1; i < 10; ++i) {\\n            DFS(results, i, n);\\n        }\\n    }\\n    \\n    void DFS(vector<int> &results, int digit, int n) {\\n        if(digit > n)\\n            return;\\n        \\n        results.push_back(digit);\\n        for(int i = 0; i < 10; ++i) {\\n            int temp = (10*digit + i);\\n            \\n            DFS(results, temp, n);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> lexicalOrder(int n) {\\n        vector<int> results;\\n        \\n        lexicalOrder(results, n);\\n        \\n        return results;\\n    }\\n    \\n    void lexicalOrder(vector<int> &results, int n) {\\n        for(int i = 1; i < 10; ++i) {\\n            DFS(results, i, n);\\n        }\\n    }\\n    \\n    void DFS(vector<int> &results, int digit, int n) {\\n        if(digit > n)\\n            return;\\n        \\n        results.push_back(digit);\\n        for(int i = 0; i < 10; ++i) {\\n            int temp = (10*digit + i);\\n            \\n            DFS(results, temp, n);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1658983,
                "title": "python-iterative-o-n-time-o-1-space",
                "content": "Thanks to @whglamrock, I didn\\'t come up with this solution at the first time.\\n\\nHere is my thinking process: consider the first few number in the lexical order of  n = 100, ```1,10,100,11,12,13,14,15,16,17,18,19,2,20```. It is not hard to find out the next lexical order number after number ```num``` should be ```10*num``` if ```10*num``` is still in the range since ```0``` is the smallest char in the sence of  lexical order. For example, ```1, 10, 100``` here. \\n\\nThen here comes with our **rule #1: if num is still in the range, check if 10*num is still in the range**\\n\\nThen, naturally, one might wonder what if ```10*num``` is no longer in the range? By focusing on the sequence ```1, 10, 100, 11, 12```, we might find out the pattern. If ```10*num``` is no longer in the range, ```num + 1``` seems to be the next smallest lexiorder numer. To test if that is true, we can try to write down the first few number ```1,10,100,11,12,13,14,15,16,17,18,19,20,21```. We can see in our sequence, we get ```18, 19, 20``` vs the correct lexiorder ```18, 19, 2, 20```. Our rule fails when ```num + 1``` ends with 0. This is because, as we see eariler, ```10*num``` is larger than ```num``` in lexiorder. Which means we need to modify our rule a little: If ```num + 1``` has trailing 0s, remove them first.\\n\\nThen here comes with our **rule #2: when ```10*num``` is no longer in the range, add ```num + 1``` if it doesn\\'t have trailing 0s else remove them first**\\n\\nBy combining rule #1 and rule #2, we get the following code\\n```\\ndef lexicalOrder(self, n: int) -> List[int]:\\n\\tres = []\\n\\tnum = 1 # we start with number 1\\n\\twhile len(res) < n:     \\n\\t\\tif num <= n:\\n\\t\\t\\tres.append(num)\\n\\t\\t\\tnum *= 10\\n\\t\\telse:\\n\\t\\t\\tnum = num // 10 + 1\\n\\t\\t\\t# remove trailing 0s\\n\\t\\t\\twhile num % 10 == 0:\\n\\t\\t\\t\\tnum //= 10\\n\\treturn res\\n```\\n\\nOne might wonder if this solution might not be a O(n) solution since we have a inner while loop to remove trailing 0s. Actually we can count how many time the while loop will execute, this will be the same as the number of trailing 0s in all numbers from 1 to n, which is bounded by O(1 * n/10 + 2 * n/100 + 3 * n/1000 + ... ). n/10 computes how many number ends with one 0, n/100 computes how many number ends with two 0s, etc.\\n\\nLet\\'s say ```x = 1 * n/10 + 2 * n/100 + 3 * n/1000 + ...``` **(1)**, \\nDivide x by 10: ```x/10 = 1 * n/100 + 2 * n/1000 + 3 * n/10000 + ...```**(2)**.\\n\\nCompute **(1)** - **(2)**, we get ```9x/10 = 1 * n/10 + 1 * n/100 + 1 * n/1000 + ... = O(n)```, then ```x = O(n)```\\n\\nOur conclusion is the number of execution of inner while loop is bounded by O(n) and thus the total amortized time complexity is just O(n)\\n\\nVisited [my site](https://kaiwang.co/2021/12/30/1143-longest-common-subsequence/?preview_id=613&preview_nonce=7d309322f5&preview=true) to see all my post~",
                "solutionTags": [],
                "code": "```1,10,100,11,12,13,14,15,16,17,18,19,2,20```\n```num```\n```10*num```\n```10*num```\n```0```\n```1, 10, 100```\n```10*num```\n```1, 10, 100, 11, 12```\n```10*num```\n```num + 1```\n```1,10,100,11,12,13,14,15,16,17,18,19,20,21```\n```18, 19, 20```\n```18, 19, 2, 20```\n```num + 1```\n```10*num```\n```num```\n```num + 1```\n```10*num```\n```num + 1```\n```\\ndef lexicalOrder(self, n: int) -> List[int]:\\n\\tres = []\\n\\tnum = 1 # we start with number 1\\n\\twhile len(res) < n:     \\n\\t\\tif num <= n:\\n\\t\\t\\tres.append(num)\\n\\t\\t\\tnum *= 10\\n\\t\\telse:\\n\\t\\t\\tnum = num // 10 + 1\\n\\t\\t\\t# remove trailing 0s\\n\\t\\t\\twhile num % 10 == 0:\\n\\t\\t\\t\\tnum //= 10\\n\\treturn res\\n```\n```x = 1 * n/10 + 2 * n/100 + 3 * n/1000 + ...```\n```x/10 = 1 * n/100 + 2 * n/1000 + 3 * n/10000 + ...```\n```9x/10 = 1 * n/10 + 1 * n/100 + 1 * n/1000 + ... = O(n)```\n```x = O(n)```",
                "codeTag": "Python3"
            },
            {
                "id": 1637121,
                "title": "java-simple-solution-using-recursion",
                "content": "```\\nclass Solution {\\n    List<Integer> list;\\n    public List<Integer> lexicalOrder(int n) {\\n        list = new ArrayList<>();\\n        for(int i=1;i<=9;i++)\\n        {\\n            dfs(i,n);\\n        }\\n        return list;\\n    }\\n    void dfs(int i,int n)\\n    {\\n        if(i > n)\\n            return;\\n        list.add(i);\\n        for(int j=0;j<10;j++)\\n            dfs(10*i+j,n);\\n    }\\n}\\n```\\nPleae upvote if u find my code easy to understand",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    List<Integer> list;\\n    public List<Integer> lexicalOrder(int n) {\\n        list = new ArrayList<>();\\n        for(int i=1;i<=9;i++)\\n        {\\n            dfs(i,n);\\n        }\\n        return list;\\n    }\\n    void dfs(int i,int n)\\n    {\\n        if(i > n)\\n            return;\\n        list.add(i);\\n        for(int j=0;j<10;j++)\\n            dfs(10*i+j,n);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1581326,
                "title": "dfs-on-trie-comment-how-to-optimize-the-solution",
                "content": "```\\nclass Node{\\npublic:\\n    int data;\\n    unordered_map<int, Node*> children;\\n    bool contains_num;\\n    int num;    \\n\\t// we store the number in the node itself, so that we don\\'t need to backtrack to get the number again.\\n    \\n    Node(int n){\\n        data = n;\\n        contains_num = false;   \\n    }\\n};\\n\\nclass Trie{\\npublic:\\n    Node *root;\\n    \\n    Trie(){\\n        root = new Node(0);\\n    }\\n    \\n    void insert(int n){\\n        //we break the number and store it in an array and then insert each digit into the trie.\\n        int x = n;\\n        vector<int> temp;\\n        while(n){\\n            temp.push_back(n%10);\\n            n /= 10;\\n        }\\n        reverse(temp.begin(), temp.end());\\n        \\n        Node* head = root;\\n        for (int i: temp){\\n            if(head->children.count(i) == 0){\\n                head->children[i] = new Node(i);\\n            }\\n            head = head->children[i];\\n        }\\n        head->contains_num = true;\\n        head->num = x;\\n    }\\n    \\n};\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    \\n    void dfs(Node *head){\\n        //we do a dfs from root node till the end and this is guaranteed to get the numbers in a lexicographic range.\\n        if (head->contains_num)     ans.push_back(head->num);\\n        for (int i = 0; i<=9; i++){\\n            if (head->children.count(i)){\\n                dfs(head->children[i]);\\n            }\\n        }\\n    }\\n    \\n    vector<int> lexicalOrder(int n) {\\n        Trie t;\\n        for (int i = 1; i<=n; i++){\\n            t.insert(i);\\n        }\\n        dfs(t.root);\\n        \\n        return ans;\\n    }\\n};\\n```\\nThe Runtime complexity for my solution is only faster than 9%. Please give tips on how to optimise my code.",
                "solutionTags": [
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```\\nclass Node{\\npublic:\\n    int data;\\n    unordered_map<int, Node*> children;\\n    bool contains_num;\\n    int num;    \\n\\t// we store the number in the node itself, so that we don\\'t need to backtrack to get the number again.\\n    \\n    Node(int n){\\n        data = n;\\n        contains_num = false;   \\n    }\\n};\\n\\nclass Trie{\\npublic:\\n    Node *root;\\n    \\n    Trie(){\\n        root = new Node(0);\\n    }\\n    \\n    void insert(int n){\\n        //we break the number and store it in an array and then insert each digit into the trie.\\n        int x = n;\\n        vector<int> temp;\\n        while(n){\\n            temp.push_back(n%10);\\n            n /= 10;\\n        }\\n        reverse(temp.begin(), temp.end());\\n        \\n        Node* head = root;\\n        for (int i: temp){\\n            if(head->children.count(i) == 0){\\n                head->children[i] = new Node(i);\\n            }\\n            head = head->children[i];\\n        }\\n        head->contains_num = true;\\n        head->num = x;\\n    }\\n    \\n};\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    \\n    void dfs(Node *head){\\n        //we do a dfs from root node till the end and this is guaranteed to get the numbers in a lexicographic range.\\n        if (head->contains_num)     ans.push_back(head->num);\\n        for (int i = 0; i<=9; i++){\\n            if (head->children.count(i)){\\n                dfs(head->children[i]);\\n            }\\n        }\\n    }\\n    \\n    vector<int> lexicalOrder(int n) {\\n        Trie t;\\n        for (int i = 1; i<=n; i++){\\n            t.insert(i);\\n        }\\n        dfs(t.root);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1566643,
                "title": "java-2-solutions-dfs-and-heap-100-faster-dfs",
                "content": "DFS Solution :\\n```\\nclass Solution {\\n    List<Integer> result;\\n    public List<Integer> lexicalOrder(int n) {\\n        result = new ArrayList();\\n        depthFirst(0, n);\\n        return result;\\n    }\\n    void depthFirst(int curr, int num) {\\n        for (int i = 0; i < 10; i++) {\\n            int x = curr * 10 + i;\\n            if (x > num)\\n                return;\\n            if (x != 0) {\\n                result.add(x);\\n                depthFirst(x, num);\\n            }\\n        }\\n    }\\n}\\n```\\nHeap Solution :\\n```\\nclass Solution {\\n    public List<Integer> lexicalOrder(int n) {\\n        PriorityQueue<String> queue = new PriorityQueue<>((x, y) -> x.compareTo(y));\\n        \\n        for (int i = 1; i <= n; i++) {\\n            String s = Integer.toString(i);\\n            queue.offer(s);\\n        }\\n        \\n        List<Integer> result = new ArrayList();\\n        for (int i = 0; i < n; i++)\\n            result.add(Integer.parseInt(queue.poll()));\\n        return result;\\n    }\\n}\\n```\\nPlease upvote :)",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    List<Integer> result;\\n    public List<Integer> lexicalOrder(int n) {\\n        result = new ArrayList();\\n        depthFirst(0, n);\\n        return result;\\n    }\\n    void depthFirst(int curr, int num) {\\n        for (int i = 0; i < 10; i++) {\\n            int x = curr * 10 + i;\\n            if (x > num)\\n                return;\\n            if (x != 0) {\\n                result.add(x);\\n                depthFirst(x, num);\\n            }\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public List<Integer> lexicalOrder(int n) {\\n        PriorityQueue<String> queue = new PriorityQueue<>((x, y) -> x.compareTo(y));\\n        \\n        for (int i = 1; i <= n; i++) {\\n            String s = Integer.toString(i);\\n            queue.offer(s);\\n        }\\n        \\n        List<Integer> result = new ArrayList();\\n        for (int i = 0; i < n; i++)\\n            result.add(Integer.parseInt(queue.poll()));\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1545108,
                "title": "simple-python-trie-dfs-solution",
                "content": "```\\nclass Trie:\\n    def __init__(self):\\n        self.root ={}\\n        \\n    def insert(self, word):\\n        cur_node = self.root\\n        \\n        for c in word:\\n            if c not in cur_node:\\n                cur_node[c] ={}\\n        \\n            cur_node = cur_node[c]\\n        cur_node[\\'#\\'] = \\'#\\'\\n    \\n    def get_numbers(self):\\n        ans= []\\n        #return all numbers sorted on this key\\n        \\n        def dfs(cur_key, cur_node):\\n            if \\'#\\' in cur_node:\\n                ans.append(int(cur_key))\\n                \\n            for new_key in sorted(cur_node.keys()):\\n                if new_key == \\'#\\': continue\\n                dfs(cur_key+new_key, cur_node[new_key])\\n                \\n            return\\n        \\n        dfs(\\'\\', self.root)\\n        return ans\\n        \\n    \\nclass Solution:\\n    def lexicalOrder(self, n: int) -> List[int]:\\n        \\n        trie = Trie()\\n        for i in range(1, n+1): trie.insert(str(i))\\n            \\n        #now sort and read the numbers\\n        return trie.get_numbers()\\n```",
                "solutionTags": [],
                "code": "```\\nclass Trie:\\n    def __init__(self):\\n        self.root ={}\\n        \\n    def insert(self, word):\\n        cur_node = self.root\\n        \\n        for c in word:\\n            if c not in cur_node:\\n                cur_node[c] ={}\\n        \\n            cur_node = cur_node[c]\\n        cur_node[\\'#\\'] = \\'#\\'\\n    \\n    def get_numbers(self):\\n        ans= []\\n        #return all numbers sorted on this key\\n        \\n        def dfs(cur_key, cur_node):\\n            if \\'#\\' in cur_node:\\n                ans.append(int(cur_key))\\n                \\n            for new_key in sorted(cur_node.keys()):\\n                if new_key == \\'#\\': continue\\n                dfs(cur_key+new_key, cur_node[new_key])\\n                \\n            return\\n        \\n        dfs(\\'\\', self.root)\\n        return ans\\n        \\n    \\nclass Solution:\\n    def lexicalOrder(self, n: int) -> List[int]:\\n        \\n        trie = Trie()\\n        for i in range(1, n+1): trie.insert(str(i))\\n            \\n        #now sort and read the numbers\\n        return trie.get_numbers()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1435934,
                "title": "super-simple-c-solution-o-n-time-o-1-space",
                "content": "```\\n    vector<int> _res;\\n    void GetNums(int n, int prefix) {\\n        if(prefix>n) return;\\n        _res.push_back(prefix);\\n        for(int i=0; i<10; i++) GetNums(n, prefix*10+i);\\n    }\\n    vector<int> lexicalOrder(int n) {\\n        for(int i=1; i<10; i++) GetNums(n, i);\\n        return _res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    vector<int> _res;\\n    void GetNums(int n, int prefix) {\\n        if(prefix>n) return;\\n        _res.push_back(prefix);\\n        for(int i=0; i<10; i++) GetNums(n, prefix*10+i);\\n    }\\n    vector<int> lexicalOrder(int n) {\\n        for(int i=1; i<10; i++) GetNums(n, i);\\n        return _res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1102114,
                "title": "python-construct-result-o-n-time-o-1-space",
                "content": "Explaination:\\nThis is the way you construct:\\n1.     1, 10, 100, 1000, ... unitil you reach largest 10^k  that is not larger than n\\n       \\n2.     then you add 1:  when you reach 1000..0099, next +1 numnber is 1000...0100, but you need to put 1000...01 because it is shorter, \\n\\t    so when the last digit is 9, the next number is +1 and remove trailing 0s, then goto step 1.\\n\\n3.     when you reach n, remove the last digit,  +1 and remove trailing 0s, then goto step 1. \\n        if we take a closer look at step 2, we can use the same procedure since adding 1 to last digit 9 is the same as remove last digit and +1.\\n       \\nThe followign are the codes:\\n\\n```\\n    def lexicalOrder(self, n: int) -> List[int]:\\n        ret = [0]*n\\n        num = 1        \\n        for i in range(n):\\n            ret[i] = num\\n            if num * 10 <=n :\\n                num = num * 10\\n            elif num + 1 <= n and num % 10 != 9:\\n                num = num + 1                \\n            else:\\n                num = num // 10 + 1\\n                while num % 10 == 0:\\n                    num = num // 10\\n        return ret\\n```",
                "solutionTags": [],
                "code": "```\\n    def lexicalOrder(self, n: int) -> List[int]:\\n        ret = [0]*n\\n        num = 1        \\n        for i in range(n):\\n            ret[i] = num\\n            if num * 10 <=n :\\n                num = num * 10\\n            elif num + 1 <= n and num % 10 != 9:\\n                num = num + 1                \\n            else:\\n                num = num // 10 + 1\\n                while num % 10 == 0:\\n                    num = num // 10\\n        return ret\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1088742,
                "title": "koltin-o-n-time-and-o-n-space",
                "content": "\\n    fun lexicalOrder(n: Int): List<Int> {\\n        val list = ArrayList<Int>()\\n        fun recursion(x: Int) {\\n            if (x > n) return\\n            list.add(x)\\n            for (i in 0..9) {\\n                recursion(x * 10 + i)\\n            }\\n        }\\n        for (i in 1..9) {\\n            recursion(i)\\n        }\\n        return list\\n    }",
                "solutionTags": [],
                "code": "\\n    fun lexicalOrder(n: Int): List<Int> {\\n        val list = ArrayList<Int>()\\n        fun recursion(x: Int) {\\n            if (x > n) return\\n            list.add(x)\\n            for (i in 0..9) {\\n                recursion(x * 10 + i)\\n            }\\n        }\\n        for (i in 1..9) {\\n            recursion(i)\\n        }\\n        return list\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 905383,
                "title": "simple-java-based-on-the-idea-of-traversal-trie",
                "content": "```\\nclass Solution {\\n    //Treat it as we are traversing Trie(Prefix Tree)\\n    //          root\\n    // 1     2    3   4   5 6 7 8 9\\n    //(0-9) (0-9) .....\\n    List<Integer> res = new ArrayList();\\n    public List<Integer> lexicalOrder(int n) {\\n        for (int i = 1; i <= 9; i++) {\\n            dfs(i, n);\\n        }\\n        return res;\\n    }\\n    \\n    private void dfs(int cur, int n) {\\n        if (cur <= n) {\\n            res.add(cur);\\n        } else {\\n            return;\\n        }\\n        for (int i = 0; i <= 9; i++) {\\n            dfs(cur * 10 + i, n);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    //Treat it as we are traversing Trie(Prefix Tree)\\n    //          root\\n    // 1     2    3   4   5 6 7 8 9\\n    //(0-9) (0-9) .....\\n    List<Integer> res = new ArrayList();\\n    public List<Integer> lexicalOrder(int n) {\\n        for (int i = 1; i <= 9; i++) {\\n            dfs(i, n);\\n        }\\n        return res;\\n    }\\n    \\n    private void dfs(int cur, int n) {\\n        if (cur <= n) {\\n            res.add(cur);\\n        } else {\\n            return;\\n        }\\n        for (int i = 0; i <= 9; i++) {\\n            dfs(cur * 10 + i, n);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 712717,
                "title": "simple-backtracking-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> res;\\n    \\n    void makeResult(int curr,int n)\\n    {\\n        if(res.size()==n)\\n            return;\\n        if(curr>n)\\n            return;\\n        res.push_back(curr);\\n        makeResult(curr*10,n);\\n        if(curr%10!=0 && curr!=1) return;\\n        for(int i=1;i<=9;i++)\\n        {\\n            makeResult(curr+i,n);\\n        }\\n    }\\n    \\n    vector<int> lexicalOrder(int n) {\\n        makeResult(1,n);\\n        return res;\\n            \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> res;\\n    \\n    void makeResult(int curr,int n)\\n    {\\n        if(res.size()==n)\\n            return;\\n        if(curr>n)\\n            return;\\n        res.push_back(curr);\\n        makeResult(curr*10,n);\\n        if(curr%10!=0 && curr!=1) return;\\n        for(int i=1;i<=9;i++)\\n        {\\n            makeResult(curr+i,n);\\n        }\\n    }\\n    \\n    vector<int> lexicalOrder(int n) {\\n        makeResult(1,n);\\n        return res;\\n            \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 600486,
                "title": "python-one-liner-with-sort-by-string-key-97-faster-than-all-python-submissions",
                "content": "Using python\\'s sorted key parameter (70% faster than all python submission). Convering the number to a string forces the comparison to be lexological. \\'111\\' < \\'121\\' in string comparison. \\n```\\nclass Solution:\\n    def lexicalOrder(self, n: int) -> List[int]:\\n        return sorted(range(1, n+1), key = str)\\n```\\nReversing the range makes the algorithm go much faster because it uses the best case for quicksort which is used by `sorted`. This is 97% faster than all python submissions:\\n```\\nclass Solution:\\n    def lexicalOrder(self, n: int) -> List[int]:\\n        return sorted(range(n, 0, -1), key = str)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def lexicalOrder(self, n: int) -> List[int]:\\n        return sorted(range(1, n+1), key = str)\\n```\n```\\nclass Solution:\\n    def lexicalOrder(self, n: int) -> List[int]:\\n        return sorted(range(n, 0, -1), key = str)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 582213,
                "title": "c-iterative-method-using-last-number",
                "content": "```\\nclass Solution {\\n    int nextNumber(int lastNum, int n) {\\n        \\n        if (lastNum * 10 <= n)\\n            return lastNum*10;\\n        \\n        if (lastNum == n)\\n            lastNum /= 10;\\n        \\n        lastNum++;\\n        while (lastNum % 10 == 0)\\n            lastNum /= 10;\\n            \\n        return lastNum;\\n    }\\npublic:\\n    vector<int> lexicalOrder(int n) {\\n        \\n        vector<int>result(n);\\n        \\n        result[0] = 1;\\n        for (int i = 1; i < n; i++) {\\n            result[i] = nextNumber(result[i-1], n);\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int nextNumber(int lastNum, int n) {\\n        \\n        if (lastNum * 10 <= n)\\n            return lastNum*10;\\n        \\n        if (lastNum == n)\\n            lastNum /= 10;\\n        \\n        lastNum++;\\n        while (lastNum % 10 == 0)\\n            lastNum /= 10;\\n            \\n        return lastNum;\\n    }\\npublic:\\n    vector<int> lexicalOrder(int n) {\\n        \\n        vector<int>result(n);\\n        \\n        result[0] = 1;\\n        for (int i = 1; i < n; i++) {\\n            result[i] = nextNumber(result[i-1], n);\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 455371,
                "title": "java-short-dfs-solution-starting-from-0-instead-of-1",
                "content": "Instead of starting from 1, we start from 0 and have `helper` validate the num.\\n```\\nclass Solution {\\n    public List<Integer> lexicalOrder(int n) {\\n        List<Integer> result = new ArrayList<>();\\n        helper(result, 0, n);\\n        return result;\\n    }\\n\\n    private void helper(List<Integer> result, int start, int n) {\\n        for (int i = 0; i <= 9; i++) {\\n            int num = start * 10 + i;\\n            if (num > 0 && num <= n) {\\n                result.add(num);\\n                helper(result, num, n);\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> lexicalOrder(int n) {\\n        List<Integer> result = new ArrayList<>();\\n        helper(result, 0, n);\\n        return result;\\n    }\\n\\n    private void helper(List<Integer> result, int start, int n) {\\n        for (int i = 0; i <= 9; i++) {\\n            int num = start * 10 + i;\\n            if (num > 0 && num <= n) {\\n                result.add(num);\\n                helper(result, num, n);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 421871,
                "title": "java-dfs-beats-90",
                "content": "```\\nclass Solution {\\n    public List<Integer> lexicalOrder(int n) {\\n        List<Integer> out = new ArrayList<>();\\n        if(n <= 0) {\\n            return out;\\n        }\\n        for(int i=1; i<10; i++) {\\n            dfs(out, i, n);\\n        }\\n        return out;\\n    }\\n    private void dfs(List<Integer> out, int start, int n) {\\n        if(start > n) {\\n            return;\\n        }\\n        out.add(start);\\n        for(int i=0; i<10; i++) {\\n            dfs(out, start * 10 + i, n);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> lexicalOrder(int n) {\\n        List<Integer> out = new ArrayList<>();\\n        if(n <= 0) {\\n            return out;\\n        }\\n        for(int i=1; i<10; i++) {\\n            dfs(out, i, n);\\n        }\\n        return out;\\n    }\\n    private void dfs(List<Integer> out, int start, int n) {\\n        if(start > n) {\\n            return;\\n        }\\n        out.add(start);\\n        for(int i=0; i<10; i++) {\\n            dfs(out, start * 10 + i, n);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 379209,
                "title": "1ms-java-solution",
                "content": "```\\nclass Solution {\\n    public List<Integer> lexicalOrder(int n) {\\n         List<Integer> list = new ArrayList();\\n      if(n<=9){\\n          for(int i = 1; i <= n; i++){\\n              list.add(i);\\n          }\\n      }else{\\n          for(int i = 1;i <= 9; i++){\\n              list.add(i);\\n              helper(list,i,n);\\n          }\\n      }\\n        return list;\\n    }\\n    \\n    \\n    public void  helper(List<Integer> list, int num,int n){\\n        for(int i = num * 10; i<num*10+10;i++){\\n            if(i>n)break;\\n            list.add(i);\\n            helper(list,i,n);\\n        }\\n    } \\n}\\n```\\n![image](https://assets.leetcode.com/users/daiyang/image_1568106023.png)\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> lexicalOrder(int n) {\\n         List<Integer> list = new ArrayList();\\n      if(n<=9){\\n          for(int i = 1; i <= n; i++){\\n              list.add(i);\\n          }\\n      }else{\\n          for(int i = 1;i <= 9; i++){\\n              list.add(i);\\n              helper(list,i,n);\\n          }\\n      }\\n        return list;\\n    }\\n    \\n    \\n    public void  helper(List<Integer> list, int num,int n){\\n        for(int i = num * 10; i<num*10+10;i++){\\n            if(i>n)break;\\n            list.add(i);\\n            helper(list,i,n);\\n        }\\n    } \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 371243,
                "title": "dfs-solution",
                "content": "```c++\\nclass Solution {\\npublic:\\n    void dfs(vector<int>& ret, int i, int n) {\\n        if (i > n) return;\\n        ret.push_back(i);\\n        for (int j = 0; j < 10; j++)\\n            dfs(ret, i * 10 + j, n);\\n    }\\n    vector<int> lexicalOrder(int n) {\\n        vector<int> ret;\\n        for (int i = 1; i < 10; i++)\\n            dfs(ret, i, n);\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    void dfs(vector<int>& ret, int i, int n) {\\n        if (i > n) return;\\n        ret.push_back(i);\\n        for (int j = 0; j < 10; j++)\\n            dfs(ret, i * 10 + j, n);\\n    }\\n    vector<int> lexicalOrder(int n) {\\n        vector<int> ret;\\n        for (int i = 1; i < 10; i++)\\n            dfs(ret, i, n);\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 314231,
                "title": "an-easy-c-solution",
                "content": "\\tvoid dfs(int i,int n,vector<int>& v)\\n    {\\n        if(i<=n)\\n            v.push_back(i);\\n        for(int j=0;j<=9;j++)\\n        {\\n            int temp=i*10+j;\\n            if(temp<=n)\\n                dfs(temp,n,v);      \\n        }\\n    }\\n\\t\\n\\t\\n    vector<int> lexicalOrder(int n) {\\n        vector<int> v;\\n        for(int i=1;i<=9;i++)\\n            dfs(i,n,v);\\n        return v;\\n    }\\n};",
                "solutionTags": [],
                "code": "\\tvoid dfs(int i,int n,vector<int>& v)\\n    {\\n        if(i<=n)\\n            v.push_back(i);\\n        for(int j=0;j<=9;j++)\\n        {\\n            int temp=i*10+j;\\n            if(temp<=n)\\n                dfs(temp,n,v);      \\n        }\\n    }\\n\\t\\n\\t\\n    vector<int> lexicalOrder(int n) {\\n        vector<int> v;\\n        for(int i=1;i<=9;i++)\\n            dfs(i,n,v);\\n        return v;\\n    }\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 287984,
                "title": "ruby-one-line",
                "content": "```\\ndef lexical_order(n)\\n    Array.new(n) { |i| (i+1).to_s }.sort.map(&:to_i)\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef lexical_order(n)\\n    Array.new(n) { |i| (i+1).to_s }.sort.map(&:to_i)\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 236306,
                "title": "java-simple-recursion-beat-90",
                "content": "\\tclass Solution {\\n\\t\\tpublic List<Integer> lexicalOrder(int n) {\\n\\t\\t\\tList<Integer> list = new ArrayList();\\n\\n\\t\\t\\tfor(int i=1;i<=9;i++){\\n\\t\\t\\t   helper(n,i,list); \\n\\t\\t\\t}\\n\\n\\t\\t\\treturn list;\\n\\t\\t}\\n\\n\\t\\tpublic void helper(int n,int i,List<Integer> list){\\n\\t\\t\\tif(i>n)\\n\\t\\t\\t\\treturn;\\n\\t\\t\\tlist.add(i);\\n\\n\\t\\t\\tfor(int k=0;k<10;k++){\\n\\t\\t\\t\\thelper(n,i*10+k,list);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic List<Integer> lexicalOrder(int n) {\\n\\t\\t\\tList<Integer> list = new ArrayList();\\n\\n\\t\\t\\tfor(int i=1;i<=9;i++){\\n\\t\\t\\t   helper(n,i,list); \\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 231037,
                "title": "java-easy-simple-straightforward-solution",
                "content": "Run-time is O(n + nlgn)\\nSpace is O(n)\\n\\n```\\npublic class Solution {\\n    public List<Integer> lexicalOrder(int n) {\\n        List<Integer> res = new ArrayList<>();\\n        List<String> strings = new ArrayList<>();\\n        \\n\\t\\t/* Add the string representation of the integer to the list\\n\\t\\t Example: An integer of value 1 gets added as \"1\" */\\n        while(n >= 1) {\\n            strings.add(String.valueOf(n));\\n            n--;\\n        }\\n        \\n\\t\\t/* Sort the string list, guarenteeing the order is like \"1\", \"10\", \"11\", \"2\", \"3\"... */\\n        Collections.sort(strings);\\n        \\n\\t\\t/* Add the integer representation of the string to the result */\\n        for(String s : strings) {\\n            res.add(Integer.parseInt(s));\\n        }\\n        \\n\\t\\t/* Return the resulting list */\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public List<Integer> lexicalOrder(int n) {\\n        List<Integer> res = new ArrayList<>();\\n        List<String> strings = new ArrayList<>();\\n        \\n\\t\\t/* Add the string representation of the integer to the list\\n\\t\\t Example: An integer of value 1 gets added as \"1\" */\\n        while(n >= 1) {\\n            strings.add(String.valueOf(n));\\n            n--;\\n        }\\n        \\n\\t\\t/* Sort the string list, guarenteeing the order is like \"1\", \"10\", \"11\", \"2\", \"3\"... */\\n        Collections.sort(strings);\\n        \\n\\t\\t/* Add the integer representation of the string to the result */\\n        for(String s : strings) {\\n            res.add(Integer.parseInt(s));\\n        }\\n        \\n\\t\\t/* Return the resulting list */\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 206243,
                "title": "java-recursive-solution",
                "content": "The idea is try to expand the number with multiply 10, if exceeds, then try plus 1.\\nif the last digit is 9, do not plus 1, because this new number is already be generated before.\\n\\npublic class LexicographicalNumbers {\\n\\n\\tpublic List<Integer> lexicalOrder(int n) {\\n\\t\\tList <Integer> result = new ArrayList<>();\\n\\t\\tdfs(1, result, n);\\n\\t\\treturn result;\\n\\t}\\n\\n\\tprivate void dfs(int x, List <Integer> result, int n) {\\n\\t\\tresult.add(x);\\n\\t\\tif (x * 10 <= n) {\\n\\t\\t\\tdfs(x * 10, result, n);\\n\\t\\t}\\n\\t\\tif (x % 10 != 9 && x + 1 <= n) {\\n\\t\\t\\tdfs(x + 1, result, n);\\n\\t\\t}\\n\\t}\\n\\t\\n}\\n\\n",
                "solutionTags": [],
                "code": "The idea is try to expand the number with multiply 10, if exceeds, then try plus 1.\\nif the last digit is 9, do not plus 1, because this new number is already be generated before.\\n\\npublic class LexicographicalNumbers {\\n\\n\\tpublic List<Integer> lexicalOrder(int n) {\\n\\t\\tList <Integer> result = new ArrayList<>();\\n\\t\\tdfs(1, result, n);\\n\\t\\treturn result;\\n\\t}\\n\\n\\tprivate void dfs(int x, List <Integer> result, int n) {\\n\\t\\tresult.add(x);\\n\\t\\tif (x * 10 <= n) {\\n\\t\\t\\tdfs(x * 10, result, n);\\n\\t\\t}\\n\\t\\tif (x % 10 != 9 && x + 1 <= n) {\\n\\t\\t\\tdfs(x + 1, result, n);\\n\\t\\t}\\n\\t}\\n\\t\\n}\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 157387,
                "title": "java-backtracking-solution",
                "content": "```\\n    public List<Integer> lexicalOrder(int n) {\\n        \\n        List<Integer> lexical = new ArrayList<>();\\n        for(int i = 1; i < 10; ++i) {\\n            dfs(lexical, i, n);\\n        }\\n        \\n        return lexical;\\n        \\n    }\\n    \\n    private void dfs(List<Integer> lexical, int num, int total) {\\n        if(num > total) {\\n            return;\\n        } \\n        \\n        lexical.add(num);\\n        \\n        for(int i = 0; i < 10; ++i) {\\n            num *= 10;\\n            num += i;\\n            dfs(lexical, num, total);\\n            num -= i;\\n            num /= 10;\\n        }\\n    }\\n}",
                "solutionTags": [],
                "code": "```\\n    public List<Integer> lexicalOrder(int n) {\\n        \\n        List<Integer> lexical = new ArrayList<>();\\n        for(int i = 1; i < 10; ++i) {\\n            dfs(lexical, i, n);\\n        }\\n        \\n        return lexical;\\n        \\n    }\\n    \\n    private void dfs(List<Integer> lexical, int num, int total) {\\n        if(num > total) {\\n            return;\\n        } \\n        \\n        lexical.add(num);\\n        \\n        for(int i = 0; i < 10; ++i) {\\n            num *= 10;\\n            num += i;\\n            dfs(lexical, num, total);\\n            num -= i;\\n            num /= 10;\\n        }\\n    }\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 86247,
                "title": "python-one-line-solution-used-map",
                "content": "```\\nclass Solution(object):\\n    def lexicalOrder(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: List[int]\\n        \"\"\"\\n        return list(map(int,sorted(map(str,list(range(1,n+1))))))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def lexicalOrder(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: List[int]\\n        \"\"\"\\n        return list(map(int,sorted(map(str,list(range(1,n+1))))))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 86260,
                "title": "python-solution-with-detailed-explanation",
                "content": "**Solution**\\n\\n**Lexicographical Numbers** https://leetcode.com/problems/lexicographical-numbers/\\n\\n* The key insight in this question is to model this as a graph and apply DFS.\\n* Draw the recursion and implement the code.\\n* https://goo.gl/photos/7XTcssvrdXvXhUDi8\\n\\n```\\nclass Solution(object):\\n    def helper(self, curr, result, n):\\n        result.append(curr)\\n        start = 1 if curr == 0 else 0\\n        for i in range(start, 10):\\n            if curr * 10 + i <= n:\\n                self.helper(curr*10 + i, result, n)\\n        return\\n    \\n    def lexicalOrder(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: List[int]\\n        \"\"\"\\n        result = []\\n        self.helper(0, result, n)\\n        return result[1:]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def helper(self, curr, result, n):\\n        result.append(curr)\\n        start = 1 if curr == 0 else 0\\n        for i in range(start, 10):\\n            if curr * 10 + i <= n:\\n                self.helper(curr*10 + i, result, n)\\n        return\\n    \\n    def lexicalOrder(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: List[int]\\n        \"\"\"\\n        result = []\\n        self.helper(0, result, n)\\n        return result[1:]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 86303,
                "title": "simple-java-solution-by-recursion",
                "content": "...\\n\\n    public List<Integer> lexicalOrder(int n) {\\n        List<Integer> ans = new ArrayList<>(n);\\n        \\n        for (int i = 1; i <= 9 && i <= n; i++) {\\n            ans.add(i);\\n            solve(ans, n, i*10);\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    private void solve(List<Integer> ans, int n, int high) {\\n        for (int i = 0; i <= 9; i++) {\\n            int newNum = high+i;\\n            if (newNum > n) return;\\n            ans.add(newNum);\\n            solve(ans, n, newNum*10);\\n        }\\n    }\\n...",
                "solutionTags": [],
                "code": "...\\n\\n    public List<Integer> lexicalOrder(int n) {\\n        List<Integer> ans = new ArrayList<>(n);\\n        \\n        for (int i = 1; i <= 9 && i <= n; i++) {\\n            ans.add(i);\\n            solve(ans, n, i*10);\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    private void solve(List<Integer> ans, int n, int high) {\\n        for (int i = 0; i <= 9; i++) {\\n            int newNum = high+i;\\n            if (newNum > n) return;\\n            ans.add(newNum);\\n            solve(ans, n, newNum*10);\\n        }\\n    }\\n...",
                "codeTag": "Unknown"
            },
            {
                "id": 86312,
                "title": "c-o-n-time-o-1-space-clean-and-clear-solution-with-explanation",
                "content": "I believe the logic is clear enough without a long paragraph of explanation. But in case you are still confused, I added some explanation:\\n```cs\\nclass Solution {\\n    int next(int last, int n)\\n    {\\n        if (last * 10 <= n)\\n            return last * 10;\\n        if (last == n)\\n            last /= 10;\\n        ++last;\\n        while(last % 10 == 0)\\n            last /= 10;\\n        return last;\\n    }\\npublic:\\n    vector<int> lexicalOrder(int n) {\\n        if (n < 1) return vector<int>();\\n        vector<int> result(n);\\n        result[0] = 1;\\n        for (int i = 1; i < n; ++ i)\\n            result[i] = next(result[i - 1], n);\\n        return result;\\n    }\\n};\\n```\\n\\nExplanation:\\nBasically, there are only 4 situations: (or 4 rules to generate next number, depending on n and i )\\nA: Suppose n = 30\\n...17,18, 19, 2, 20, ..\\n....................i...i+1.....\\nB: Suppose n = 30\\n...17,18, 19, 2, 20,..\\n...............i...i+1.....\\nC:Suppose n = 14\\n...12,13, 14, 2, 3, 4 ..\\n................i..i+1.....\\nD:Suppose n = 14\\n...12,13, 14, 2, 3, 4 ..\\n...i....i+1......................\\n\\nThe \"next\" function is just an implementation of checking which situation it is now and generate the next number accordingly.",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cs\\nclass Solution {\\n    int next(int last, int n)\\n    {\\n        if (last * 10 <= n)\\n            return last * 10;\\n        if (last == n)\\n            last /= 10;\\n        ++last;\\n        while(last % 10 == 0)\\n            last /= 10;\\n        return last;\\n    }\\npublic:\\n    vector<int> lexicalOrder(int n) {\\n        if (n < 1) return vector<int>();\\n        vector<int> result(n);\\n        result[0] = 1;\\n        for (int i = 1; i < n; ++ i)\\n            result[i] = next(result[i - 1], n);\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 86325,
                "title": "c-solution-o-n-time-and-o-1-space-with-explanation",
                "content": "Observations:\\nFor any given digit k, the lexical order of all numbers starting with digit k looks like:\\n\\nk, k\\xd710, k\\xd710^2, k\\xd710^3, ..., k\\xd710^p +1, k\\xd710^p + 2, ..., k\\xd710^(p-m) +1, ...\\n\\nFor example, the sequence of numbers starting with digit 1 will be like (with n = 2000):\\n\\n1, 10, 100, 1000, 1001, 1002, ..., 1009, 101, 1010, 1011, 1012, ..., 1019, 102, 1020, ..., 1099, 11, 110, 1100, 1101, ...\\n\\nThrough the observations above, a valid sub-sequence can only be started when we 1) cannot append more zeroes to the previous number; or 2) encounter a number that ends in consecutive '9's.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> lexicalOrder(int n) {\\n        vector<int> rs;\\n        \\n        int i = 1, j;\\n        int k;\\n        for(;;)\\n        {\\n            // append as many zeroes as possible to the previous number\\n            for(k = 0; i*pow(10,k) <= n; ++k) rs.push_back(i*pow(10,k));\\n            \\n            // count continuously until we reach a number that ends with consecutive '9's\\n            for(j = rs.back()+1; j <= n && (j % 10) != 0; ++j) rs.push_back(j);\\n            \\n            // backtrace\\n            if(j % 10 == 0)\\n            {\\n                j--;\\n            }\\n            else\\n            {\\n                j /= 10;\\n            }\\n\\n            // find the last non-'9' digit\\n            while(j % 10 == 9) j /= 10;\\n            \\n            // start a new sub-sequence\\n            i = j+1;\\n            \\n            if(rs.size() >= n) break;\\n        }\\n\\n        return rs;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> lexicalOrder(int n) {\\n        vector<int> rs;\\n        \\n        int i = 1, j;\\n        int k;\\n        for(;;)\\n        {\\n            // append as many zeroes as possible to the previous number\\n            for(k = 0; i*pow(10,k) <= n; ++k) rs.push_back(i*pow(10,k));\\n            \\n            // count continuously until we reach a number that ends with consecutive '9's\\n            for(j = rs.back()+1; j <= n && (j % 10) != 0; ++j) rs.push_back(j);\\n            \\n            // backtrace\\n            if(j % 10 == 0)\\n            {\\n                j--;\\n            }\\n            else\\n            {\\n                j /= 10;\\n            }\\n\\n            // find the last non-'9' digit\\n            while(j % 10 == 9) j /= 10;\\n            \\n            // start a new sub-sequence\\n            i = j+1;\\n            \\n            if(rs.size() >= n) break;\\n        }\\n\\n        return rs;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3959985,
                "title": "easy-python-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\ncreating a list of string(i) for integers i in range(1,n)\\nsorting them in  lexicographical order.\\nconverting the list of strings into list of integers \\nreturning the list\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nBeats 88% of the python coders\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def lexicalOrder(self, n: int) -> List[int]:\\n        l=[]\\n        for i in range(1,n+1):\\n            l.append(str(i))\\n        l.sort()\\n        l2=[int(i) for i in l]\\n        return l2\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def lexicalOrder(self, n: int) -> List[int]:\\n        l=[]\\n        for i in range(1,n+1):\\n            l.append(str(i))\\n        l.sort()\\n        l2=[int(i) for i in l]\\n        return l2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3773896,
                "title": "python-3-simple-dfs-with-explanation",
                "content": "# Intuition\\nWhenever any lexicographical solution is asked, the first thing that should come to your mind should be DFS on Trees.\\n\\n(A more [flashy one liner](https://leetcode.com/problems/lexicographical-numbers/solutions/3773772/python-3-disgusting-1-liner-use-at-end-of-interview/))\\n# Approach\\nWe start from the digit \"1\", and try placing every possible digit in front of it in ascending order. Then we try placing every possible digit in front of all the previously generated numbers, and so on, till we get a number that is greater than n.\\n\\n1. Initialize an ```ans``` array to store the results.\\n2. Create a dfs function, which will first append a number to the list, and then start by placing every other digit in front of it.\\nThe way we do that is by multiplying the current number by 10, and adding whatever digit we want in front of it.\\n\\nEg - To place a 2 in front of 34, we do ```34 * 10 = 340```, and then we add 2 ```340 + 2 = 342``` to get the desired number.\\n3. We then check if this new number is still lesser than whatever our ```n``` was. If yes, we start a dfs on it. \\n- Note- The inner loop places all digits from 0-9, whereas the outer loop only places digits from 1-9, as that is what the question statement requires.\\n# Complexity\\n- Time complexity:\\nO(N), since we are generating every number up to N at most.\\n- Space complexity:\\nO(N) to store the numbers, and O(log(N)) for the recursive call stack in the worst case. \\n\\n# Code-\\n```\\nclass Solution:\\n    def lexicalOrder(self, n: int) -> List[int]:\\n        ans = []\\n\\n        def dfs(num):\\n            ans.append(num)\\n\\n            for i in range(0, 10):\\n                if (n2 := 10 * num + i) <= n:\\n                    dfs(n2)\\n\\n        for i in range(1, 10):\\n            if i <= n:\\n                dfs(i)\\n\\n        return ans\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```ans```\n```34 * 10 = 340```\n```340 + 2 = 342```\n```n```\n```\\nclass Solution:\\n    def lexicalOrder(self, n: int) -> List[int]:\\n        ans = []\\n\\n        def dfs(num):\\n            ans.append(num)\\n\\n            for i in range(0, 10):\\n                if (n2 := 10 * num + i) <= n:\\n                    dfs(n2)\\n\\n        for i in range(1, 10):\\n            if i <= n:\\n                dfs(i)\\n\\n        return ans\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3741089,
                "title": "java-beats-100-easy-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public List<Integer>result = new ArrayList<>();\\n    public void helper(int n,int curr){\\n        if(curr > n)\\n            return;\\n        result.add(curr);\\n        helper(n,curr*10);\\n        if(curr%10 != 9)\\n            helper(n,curr+1);\\n    }\\n    public List<Integer> lexicalOrder(int n) {\\n        helper(n,1);\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer>result = new ArrayList<>();\\n    public void helper(int n,int curr){\\n        if(curr > n)\\n            return;\\n        result.add(curr);\\n        helper(n,curr*10);\\n        if(curr%10 != 9)\\n            helper(n,curr+1);\\n    }\\n    public List<Integer> lexicalOrder(int n) {\\n        helper(n,1);\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3666273,
                "title": "easy-trie-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI used a very simple approach with Tries by storing all the numbers in character format into tries. Then performing DFS and returning that.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Convert all data to string and store in a trie\\n2. The trie will look something like this for the input values 1,2,3,10,11,100\\n![1.png](https://assets.leetcode.com/users/images/0626df3e-7792-4516-be7a-ff3d6eb5a6cb_1687363296.1645823.png)\\n\\n3. Then you apply DFS to the trie.\\n4. When you reach the end of a trie push the vector to the main vector.\\n5. Since the dfs pushes in reverse order you reverse the strings at the last\\n6. Then convert them to int and push to a new vector and return this vector. \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nstruct Trie{\\n    Trie* arr[10];\\n    bool end = false;\\n    \\n    bool isSet(char ch){\\n       return (arr[ch-\\'0\\'] != NULL) ;\\n    }\\n\\n    void set(char ch){\\n       arr[ch-\\'0\\'] = new Trie();\\n    }\\n\\n    Trie* getNext(char ch){\\n        return arr[ch-\\'0\\'];\\n    }\\n    \\n    void setEnd(){\\n        end = true;\\n    }\\n\\n};\\nclass Solution {\\npublic:\\n    vector<vector<char>> ans;\\n    void dfs(Trie* root,vector<char> vect){\\n        if(root->end != NULL){\\n            \\n           ans.push_back(vect);\\n           \\n        } \\n         for(int i=0;i<10;i++){\\n            if(root->arr[i] != NULL){\\n                //cout<<i<<endl;\\n                char c = static_cast<char>(i + \\'0\\');\\n                vect.push_back(c);\\n                Trie* temp = root->getNext(c);\\n                dfs(temp,vect);\\n                vect.pop_back();\\n            }\\n         }\\n    }\\n    void insert(Trie* root,string s){\\n\\n        for(auto ch:s){\\n            //cout<<ch<<\"\\\\n\";\\n            if(!root->isSet(ch)){\\n               root->set(ch);\\n            }\\n            root= root->getNext(ch);\\n        }\\n        root->setEnd();\\n    }\\n\\n    vector<int> lexicalOrder(int n) {\\n        Trie* root = new Trie();\\n        for(int i=1;i<=n;i++){\\n            Trie* temp = root;\\n            insert(temp,to_string(i));\\n        }\\n\\n        vector<char> vect;\\n        \\n        dfs(root,vect);\\n        vector<int> fin;\\n        for(int i=0;i<ans.size();i++){\\n            int k = 0;\\n            reverse(ans[i].begin(),ans[i].end());\\n            for(int j = ans[i].size()-1;j>=0;j--){\\n              int m = ans[i][j]-\\'0\\';\\n              //cout<<m<<\" \";\\n              k = (k*10)+m ;\\n            }\\n            fin.push_back(k);\\n            cout<<endl;\\n        }\\n        \\n        return fin;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nstruct Trie{\\n    Trie* arr[10];\\n    bool end = false;\\n    \\n    bool isSet(char ch){\\n       return (arr[ch-\\'0\\'] != NULL) ;\\n    }\\n\\n    void set(char ch){\\n       arr[ch-\\'0\\'] = new Trie();\\n    }\\n\\n    Trie* getNext(char ch){\\n        return arr[ch-\\'0\\'];\\n    }\\n    \\n    void setEnd(){\\n        end = true;\\n    }\\n\\n};\\nclass Solution {\\npublic:\\n    vector<vector<char>> ans;\\n    void dfs(Trie* root,vector<char> vect){\\n        if(root->end != NULL){\\n            \\n           ans.push_back(vect);\\n           \\n        } \\n         for(int i=0;i<10;i++){\\n            if(root->arr[i] != NULL){\\n                //cout<<i<<endl;\\n                char c = static_cast<char>(i + \\'0\\');\\n                vect.push_back(c);\\n                Trie* temp = root->getNext(c);\\n                dfs(temp,vect);\\n                vect.pop_back();\\n            }\\n         }\\n    }\\n    void insert(Trie* root,string s){\\n\\n        for(auto ch:s){\\n            //cout<<ch<<\"\\\\n\";\\n            if(!root->isSet(ch)){\\n               root->set(ch);\\n            }\\n            root= root->getNext(ch);\\n        }\\n        root->setEnd();\\n    }\\n\\n    vector<int> lexicalOrder(int n) {\\n        Trie* root = new Trie();\\n        for(int i=1;i<=n;i++){\\n            Trie* temp = root;\\n            insert(temp,to_string(i));\\n        }\\n\\n        vector<char> vect;\\n        \\n        dfs(root,vect);\\n        vector<int> fin;\\n        for(int i=0;i<ans.size();i++){\\n            int k = 0;\\n            reverse(ans[i].begin(),ans[i].end());\\n            for(int j = ans[i].size()-1;j>=0;j--){\\n              int m = ans[i][j]-\\'0\\';\\n              //cout<<m<<\" \";\\n              k = (k*10)+m ;\\n            }\\n            fin.push_back(k);\\n            cout<<endl;\\n        }\\n        \\n        return fin;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3665780,
                "title": "easiest-implementation-using-trie-dfs-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nstruct Node{\\n    Node* links[10];\\n    bool flag = false;\\n};\\n\\nclass Trie{\\npublic:\\n    Node* head;\\n    Trie(){\\n        head = new Node();\\n    }\\n\\n    void insert(string s){\\n        Node* node = head;\\n        for(auto ch : s){\\n            if(node->links[ch - \\'0\\'] == NULL){\\n                node->links[ch - \\'0\\'] = new Node();\\n            }\\n            node = node->links[ch - \\'0\\'];\\n        }\\n        node->flag = 1;\\n    }\\n    \\n};\\n\\nclass Solution {\\npublic:\\n    vector<int>ans;\\n    void dfs(Node* node, string &curr){\\n        if(node->flag == 1){\\n            ans.push_back(stoi(curr));\\n        }\\n        for(int i=0; i<10; i++){\\n            if(node->links[i]){\\n                curr += (i + \\'0\\');\\n                dfs(node->links[i],curr);\\n                curr.pop_back();\\n            }\\n        }\\n    }\\n    vector<int> lexicalOrder(int n) {\\n        Trie t;\\n        for(int i=1; i<=n; i++){\\n            t.insert(to_string(i));\\n        }\\n        string curr = \"\";\\n        dfs(t.head,curr);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```\\nstruct Node{\\n    Node* links[10];\\n    bool flag = false;\\n};\\n\\nclass Trie{\\npublic:\\n    Node* head;\\n    Trie(){\\n        head = new Node();\\n    }\\n\\n    void insert(string s){\\n        Node* node = head;\\n        for(auto ch : s){\\n            if(node->links[ch - \\'0\\'] == NULL){\\n                node->links[ch - \\'0\\'] = new Node();\\n            }\\n            node = node->links[ch - \\'0\\'];\\n        }\\n        node->flag = 1;\\n    }\\n    \\n};\\n\\nclass Solution {\\npublic:\\n    vector<int>ans;\\n    void dfs(Node* node, string &curr){\\n        if(node->flag == 1){\\n            ans.push_back(stoi(curr));\\n        }\\n        for(int i=0; i<10; i++){\\n            if(node->links[i]){\\n                curr += (i + \\'0\\');\\n                dfs(node->links[i],curr);\\n                curr.pop_back();\\n            }\\n        }\\n    }\\n    vector<int> lexicalOrder(int n) {\\n        Trie t;\\n        for(int i=1; i<=n; i++){\\n            t.insert(to_string(i));\\n        }\\n        string curr = \"\";\\n        dfs(t.head,curr);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3346488,
                "title": "c-dfs-solution",
                "content": "# Approach\\nSimple DFS to get all possible numbers in lexicographical order.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$ - as the most number of operations is equal to $$9*(digits(n))$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    void dfs(int sum, int n, vector<int>& ans){\\n        if(sum >= n) return;\\n        for(int i = 0; i <= 9; i++){\\n            if(sum*10 + i <= n){\\n                ans.push_back(sum*10 + i);\\n                dfs(sum*10 + i, n, ans);\\n            }\\n        }\\n    }\\n\\n    vector<int> lexicalOrder(int n) {\\n        int sum = 0;\\n        vector<int> ans;\\n        for(int i = 1; i <= 9; i++){\\n            if(sum*10 + i <= n){\\n                ans.push_back(sum*10 + i);\\n                dfs(sum*10 + i, n, ans);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    void dfs(int sum, int n, vector<int>& ans){\\n        if(sum >= n) return;\\n        for(int i = 0; i <= 9; i++){\\n            if(sum*10 + i <= n){\\n                ans.push_back(sum*10 + i);\\n                dfs(sum*10 + i, n, ans);\\n            }\\n        }\\n    }\\n\\n    vector<int> lexicalOrder(int n) {\\n        int sum = 0;\\n        vector<int> ans;\\n        for(int i = 1; i <= 9; i++){\\n            if(sum*10 + i <= n){\\n                ans.push_back(sum*10 + i);\\n                dfs(sum*10 + i, n, ans);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2845989,
                "title": "simple-c-trie-dfs-solution",
                "content": "```\\nstruct Node\\n{\\n    vector<Node*> links;\\n    bool isEnd;\\n    Node()\\n    {\\n        links.resize(10,NULL);\\n        isEnd=false;\\n    }\\n};\\nclass Solution \\n{\\n    public:\\n    vector<int> ans;\\n    void insert(Node* root,string str,int i)\\n    {\\n        if(i==str.length())\\n        {\\n            root->isEnd=true;\\n            return;\\n        }\\n        if(!root->links[str[i]-\\'0\\'])\\n            root->links[str[i]-\\'0\\']=new Node();\\n        insert(root->links[str[i]-\\'0\\'],str,i+1);\\n    }\\n    void allvalues(Node* root,int num)\\n    {\\n        if(root->isEnd)\\n        {\\n            ans.push_back(num);\\n        }\\n        for(int i=0;i<10;i++)\\n        {\\n            if(root->links[i])\\n            {\\n                num=num*10+i;\\n                allvalues(root->links[i],num);\\n                num=(num-i)/10;\\n            }\\n        }\\n    }\\n    vector<int> lexicalOrder(int n) \\n    {\\n        Node* root=new Node();\\n        for(int i=1;i<=n;i++)\\n        {\\n            string str=to_string(i);\\n            insert(root,str,0);\\n        }\\n        allvalues(root,0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Trie",
                    "Recursion"
                ],
                "code": "```\\nstruct Node\\n{\\n    vector<Node*> links;\\n    bool isEnd;\\n    Node()\\n    {\\n        links.resize(10,NULL);\\n        isEnd=false;\\n    }\\n};\\nclass Solution \\n{\\n    public:\\n    vector<int> ans;\\n    void insert(Node* root,string str,int i)\\n    {\\n        if(i==str.length())\\n        {\\n            root->isEnd=true;\\n            return;\\n        }\\n        if(!root->links[str[i]-\\'0\\'])\\n            root->links[str[i]-\\'0\\']=new Node();\\n        insert(root->links[str[i]-\\'0\\'],str,i+1);\\n    }\\n    void allvalues(Node* root,int num)\\n    {\\n        if(root->isEnd)\\n        {\\n            ans.push_back(num);\\n        }\\n        for(int i=0;i<10;i++)\\n        {\\n            if(root->links[i])\\n            {\\n                num=num*10+i;\\n                allvalues(root->links[i],num);\\n                num=(num-i)/10;\\n            }\\n        }\\n    }\\n    vector<int> lexicalOrder(int n) \\n    {\\n        Node* root=new Node();\\n        for(int i=1;i<=n;i++)\\n        {\\n            string str=to_string(i);\\n            insert(root,str,0);\\n        }\\n        allvalues(root,0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2638736,
                "title": "2-solutions-trie-ds-dfs-dfs-only",
                "content": "# TRIE + DFS traversal\\n```\\nstruct Node{\\n    Node *child[10];\\n    bool flag = false;\\n    void put(int ch, Node *node)\\n    {\\n        // cout<<\"put : \"<<ch<<endl;\\n        child[ch] = node;\\n    }\\n    Node *get(int ch)\\n    {\\n        // cout<<\"get : \"<<ch<<endl;\\n        return child[ch];\\n    }\\n    bool isEnd()\\n    {\\n        return flag;\\n    }\\n    void setEnd()\\n    {\\n        flag = true;\\n    }\\n    bool containKey(int ch)\\n    {\\n        return (child[ch]!=NULL);\\n    }\\n};\\n\\nclass Trie{\\n    Node *root;\\n    public:\\n    Trie()\\n    {\\n        root = new Node();\\n    }\\n    int digit(long long n) {\\n      return floor(log10(n) + 1);\\n    }\\n    void insert(int num)\\n    {\\n        Node *node = root;\\n        int di = digit(num);\\n        int mod = pow(10,di-1);\\n        \\n        for(int i=0;i<di;i++)\\n        {\\n            if(!node->containKey(num/mod))\\n            {\\n                node->put(num/mod, new Node());\\n            }\\n            node = node->get(num/mod);\\n            num%=mod;\\n            mod/=10;\\n        }\\n        node->setEnd();\\n    }\\n    void recur(Node *node,vector<int> &res,int num)\\n    {\\n        if(node==NULL)\\n            return;\\n        for(int i=0;i<10;i++)\\n        {\\n            if(node->containKey(i))\\n            {\\n                if(num*10 + i != 0)\\n                res.push_back(num*10 + i);\\n                recur(node->get(i),res,num*10 + i);\\n            }\\n        }\\n    }\\n    void explore(vector<int> &res)\\n    {\\n        recur(root, res,0);\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<int> lexicalOrder(int n) {\\n        vector<int> res;\\n        Trie trie;\\n        for(int i=1;i<=n;i++)\\n        {\\n            trie.insert(i);\\n            // cout<<endl;\\n        }\\n        trie.explore(res);\\n        return res;\\n    }\\n};\\n```\\n# Simple dfs traversal\\n```\\nclass Solution {\\n    void dfs(int n,int num,vector<int> &res)\\n    {\\n        if(num>n) return;\\n        res.push_back(num);\\n        for(int i=0;i<10;i++)\\n        {\\n            dfs(n,num*10 + i,res);\\n        }\\n    }\\npublic:\\n    vector<int> lexicalOrder(int n) {\\n        vector<int> res;\\n        for(int i=1;i<10;i++)\\n        dfs(n,i,res);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```\\nstruct Node{\\n    Node *child[10];\\n    bool flag = false;\\n    void put(int ch, Node *node)\\n    {\\n        // cout<<\"put : \"<<ch<<endl;\\n        child[ch] = node;\\n    }\\n    Node *get(int ch)\\n    {\\n        // cout<<\"get : \"<<ch<<endl;\\n        return child[ch];\\n    }\\n    bool isEnd()\\n    {\\n        return flag;\\n    }\\n    void setEnd()\\n    {\\n        flag = true;\\n    }\\n    bool containKey(int ch)\\n    {\\n        return (child[ch]!=NULL);\\n    }\\n};\\n\\nclass Trie{\\n    Node *root;\\n    public:\\n    Trie()\\n    {\\n        root = new Node();\\n    }\\n    int digit(long long n) {\\n      return floor(log10(n) + 1);\\n    }\\n    void insert(int num)\\n    {\\n        Node *node = root;\\n        int di = digit(num);\\n        int mod = pow(10,di-1);\\n        \\n        for(int i=0;i<di;i++)\\n        {\\n            if(!node->containKey(num/mod))\\n            {\\n                node->put(num/mod, new Node());\\n            }\\n            node = node->get(num/mod);\\n            num%=mod;\\n            mod/=10;\\n        }\\n        node->setEnd();\\n    }\\n    void recur(Node *node,vector<int> &res,int num)\\n    {\\n        if(node==NULL)\\n            return;\\n        for(int i=0;i<10;i++)\\n        {\\n            if(node->containKey(i))\\n            {\\n                if(num*10 + i != 0)\\n                res.push_back(num*10 + i);\\n                recur(node->get(i),res,num*10 + i);\\n            }\\n        }\\n    }\\n    void explore(vector<int> &res)\\n    {\\n        recur(root, res,0);\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<int> lexicalOrder(int n) {\\n        vector<int> res;\\n        Trie trie;\\n        for(int i=1;i<=n;i++)\\n        {\\n            trie.insert(i);\\n            // cout<<endl;\\n        }\\n        trie.explore(res);\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    void dfs(int n,int num,vector<int> &res)\\n    {\\n        if(num>n) return;\\n        res.push_back(num);\\n        for(int i=0;i<10;i++)\\n        {\\n            dfs(n,num*10 + i,res);\\n        }\\n    }\\npublic:\\n    vector<int> lexicalOrder(int n) {\\n        vector<int> res;\\n        for(int i=1;i<10;i++)\\n        dfs(n,i,res);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2507945,
                "title": "java-clean-concise-dfs-solution-uwu-beats-100-00",
                "content": "If you find the code helpful, I would really appreciate your **upvote**!\\n```\\nclass Solution {\\n    public List<Integer> lexicalOrder(int n) {\\n        List<Integer> ans = new ArrayList<>();\\n        dfs(ans, n, 1); // Start at 1\\n        return ans;\\n    }\\n    \\n    private void dfs(List<Integer> ans, int n, int curr) {\\n        if (curr > n) return; // Terminate condition\\n        ans.add(curr); // Add curr to the List\\n        dfs(ans, n, 10*curr); // Prioritize (compared to += 1) adding a 0 to current number\\'s end\\n        if (curr % 10 < 9) { // The condition is to avoid counting a number for multiple times \\n            dfs(ans, n, curr + 1); // Plus 1 to the current number\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> lexicalOrder(int n) {\\n        List<Integer> ans = new ArrayList<>();\\n        dfs(ans, n, 1); // Start at 1\\n        return ans;\\n    }\\n    \\n    private void dfs(List<Integer> ans, int n, int curr) {\\n        if (curr > n) return; // Terminate condition\\n        ans.add(curr); // Add curr to the List\\n        dfs(ans, n, 10*curr); // Prioritize (compared to += 1) adding a 0 to current number\\'s end\\n        if (curr % 10 < 9) { // The condition is to avoid counting a number for multiple times \\n            dfs(ans, n, curr + 1); // Plus 1 to the current number\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2319323,
                "title": "c-easy-and-fastest-recursive-solution",
                "content": "```\\nclass Solution {\\nprivate:\\n\\t// Ans and the index\\n    vector<int> ans;\\n    int ind=0;\\n\\t\\n\\t// Recursive function\\n    void helper(int a, int n){\\n        if (a > n) return;\\n        ans[ind] = a;\\n        ind++;\\n\\t\\t\\n\\t\\t// First priority to check multiple of 10\\n        helper(a * 10, n);\\n\\t\\t\\n\\t\\t// Then second priority is the next number\\n        if (a % 10 != 9) helper(a+1, n);\\n    }\\npublic:\\n    vector<int> lexicalOrder(int n) {\\n        ans.resize(n);\\n        helper(1, n);\\n        return ans;\\n    }\\n};\\n```\\nUpvote if you find it useful. \\uD83D\\uDE4C",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n\\t// Ans and the index\\n    vector<int> ans;\\n    int ind=0;\\n\\t\\n\\t// Recursive function\\n    void helper(int a, int n){\\n        if (a > n) return;\\n        ans[ind] = a;\\n        ind++;\\n\\t\\t\\n\\t\\t// First priority to check multiple of 10\\n        helper(a * 10, n);\\n\\t\\t\\n\\t\\t// Then second priority is the next number\\n        if (a % 10 != 9) helper(a+1, n);\\n    }\\npublic:\\n    vector<int> lexicalOrder(int n) {\\n        ans.resize(n);\\n        helper(1, n);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2285616,
                "title": "simple-backtracking-solution",
                "content": "class Solution {\\npublic:\\n    \\n    vector<int> ans;\\n    \\n    vector<int> lexicalOrder(int n) {\\n        \\n        for(int j=1;j<=9;j++)\\n        {\\n            if(j>n)\\n                break;\\n            \\n            ans.push_back(j);\\n            solve(j,n);\\n            \\n        }\\n        \\n        return ans;\\n        \\n    }\\n    \\n    void solve(long long int num,int n){  \\n       \\n       if(num>n)     \\n           return;\\n         \\n        \\n       for(int i=0;i<=9;i++)\\n       {\\n             \\n           num=num*10;\\n           num+=i;\\n           \\n           if(num<=n)      \\n               ans.push_back(num);\\n           \\n           \\n           solve(num,n);    \\n\\t\\t   \\n\\t\\t   num-=i;\\n           num=num/10;\\n           \\n       }     \\n     \\n   }    \\n};",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    vector<int> ans;\\n    \\n    vector<int> lexicalOrder(int n) {\\n        \\n        for(int j=1;j<=9;j++)\\n        {\\n            if(j>n)\\n                break;\\n            \\n            ans.push_back(j);\\n            solve(j,n);\\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2000385,
                "title": "python-o-n-o-1-solution-with-explanation",
                "content": "Basically is to simulate how lexicography order is realized. \\nUsually, lexicography order is the same as arithmetic order (like 5 < 6), so just take the last number and plus 1, it gives you the next number. However there are two edge cases for this problem:\\n1. When the number becomes multiple of 10, there needs to be some arrangements. Like when you come to 110, you can\\'t just append 110 to 109 becase 11 is in between them (109 < 11 < 110, and similarly 1999 < 2 < 20 < 200 < 2000). To do this, just divide this number by 10 until it becomes non-multiple of 10, and reverse the numbers you meet along this path and stick them back to the answer.\\n2. When the numbe grows larger than your limit (say n = 513, and you now come to 514), there is no need to try 515 or 516 and the next number you need is 52. How comes 52? for **everything starts with 51 that comes before 513** is already there (51, 511, 5121 etc), and **everything starts with 51 that comes after 513 should not be considered** (514, 5156, 5177 etc).\\n\\n```\\nclass Solution:\\n    def lexicalOrder(self, n: int) -> List[int]:\\n        digit = 1\\n        tmp = n\\n        while tmp // 10 != 0:\\n            tmp //= 10\\n            digit += 1\\n        ans = []\\n        for i in range(digit):\\n            ans.append(10 ** i)\\n        while len(ans) < n:\\n            self.lexiType(ans, n)\\n        while len(ans) > n:\\n            ans.pop()\\n        return ans\\n        \\n    def lexiType(self, a, limit):\\n        base = a[-1]\\n        new = a[-1] + 1\\n        if new > limit: #edge case #2\\n            new = int(str(base)[:-1]) + 1\\n        tmp = []\\n        while new % 10 == 0: #edge case #1\\n            tmp.append(new)\\n            new //= 10\\n        tmp.append(new)\\n        a += tmp[::-1]\\n        return",
                "solutionTags": [],
                "code": "Basically is to simulate how lexicography order is realized. \\nUsually, lexicography order is the same as arithmetic order (like 5 < 6), so just take the last number and plus 1, it gives you the next number. However there are two edge cases for this problem:\\n1. When the number becomes multiple of 10, there needs to be some arrangements. Like when you come to 110, you can\\'t just append 110 to 109 becase 11 is in between them (109 < 11 < 110, and similarly 1999 < 2 < 20 < 200 < 2000). To do this, just divide this number by 10 until it becomes non-multiple of 10, and reverse the numbers you meet along this path and stick them back to the answer.\\n2. When the numbe grows larger than your limit (say n = 513, and you now come to 514), there is no need to try 515 or 516 and the next number you need is 52. How comes 52? for **everything starts with 51 that comes before 513** is already there (51, 511, 5121 etc), and **everything starts with 51 that comes after 513 should not be considered** (514, 5156, 5177 etc).\\n\\n```\\nclass Solution:\\n    def lexicalOrder(self, n: int) -> List[int]:\\n        digit = 1\\n        tmp = n\\n        while tmp // 10 != 0:\\n            tmp //= 10\\n            digit += 1\\n        ans = []\\n        for i in range(digit):\\n            ans.append(10 ** i)\\n        while len(ans) < n:\\n            self.lexiType(ans, n)\\n        while len(ans) > n:\\n            ans.pop()\\n        return ans\\n        \\n    def lexiType(self, a, limit):\\n        base = a[-1]\\n        new = a[-1] + 1\\n        if new > limit: #edge case #2\\n            new = int(str(base)[:-1]) + 1\\n        tmp = []\\n        while new % 10 == 0: #edge case #1\\n            tmp.append(new)\\n            new //= 10\\n        tmp.append(new)\\n        a += tmp[::-1]\\n        return",
                "codeTag": "Java"
            },
            {
                "id": 1954892,
                "title": "c-trie-implementation",
                "content": "```\\nclass Solution {\\npublic:\\n    #define NUM_DIGITS (10)\\n    \\n    struct TN {\\n        struct TN *children[NUM_DIGITS];\\n        bool isEndOfWord;\\n    };\\n    \\n    struct TN *getNode() {\\n        struct TN *node = new TN;\\n        for(int i = 0; i < NUM_DIGITS; ++i) {\\n            node->children[i] = nullptr;\\n        }\\n        node->isEndOfWord = false;\\n        return node;\\n    }\\n    \\n    vector<int> getDigits(int key) {\\n        vector<int> digits;\\n        while(key) {\\n            digits.push_back(key%10);\\n            key /= 10;\\n        }\\n        int l = 0, r = digits.size()-1;\\n        while(l < r) {\\n            swap(digits[l++], digits[r--]);\\n        }\\n        return digits;\\n    }\\n    \\n    void insert(struct TN *root, int key) {\\n        vector<int> digits = getDigits(key);\\n        \\n        for(int d : digits) {\\n            cout << d << \" \";\\n            if(root->children[d] == nullptr) {\\n                struct TN *node = getNode();\\n                root->children[d] = node;\\n            }\\n            root = root->children[d];\\n        }\\n        cout << endl;\\n        root->isEndOfWord = true;\\n    }\\n    \\n    vector<int> lexicalOrder(int n) {\\n        vector<int> ans;\\n        struct TN *root = getNode();\\n        \\n        for(int i = 1; i <= n; ++i) {\\n            insert(root, i);\\n        }\\n        dfs(root, 0, ans);\\n        return ans;\\n    }\\n    \\n    void dfs(struct TN *root, int num, vector<int>& ans) {\\n        if(root->isEndOfWord) {\\n            ans.push_back(num);\\n        }\\n        for(int i = 0; i < NUM_DIGITS; ++i) {\\n            if(root->children[i] != nullptr) {\\n                int n = num * 10 + i;\\n                dfs(root->children[i], n, ans);\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    #define NUM_DIGITS (10)\\n    \\n    struct TN {\\n        struct TN *children[NUM_DIGITS];\\n        bool isEndOfWord;\\n    };\\n    \\n    struct TN *getNode() {\\n        struct TN *node = new TN;\\n        for(int i = 0; i < NUM_DIGITS; ++i) {\\n            node->children[i] = nullptr;\\n        }\\n        node->isEndOfWord = false;\\n        return node;\\n    }\\n    \\n    vector<int> getDigits(int key) {\\n        vector<int> digits;\\n        while(key) {\\n            digits.push_back(key%10);\\n            key /= 10;\\n        }\\n        int l = 0, r = digits.size()-1;\\n        while(l < r) {\\n            swap(digits[l++], digits[r--]);\\n        }\\n        return digits;\\n    }\\n    \\n    void insert(struct TN *root, int key) {\\n        vector<int> digits = getDigits(key);\\n        \\n        for(int d : digits) {\\n            cout << d << \" \";\\n            if(root->children[d] == nullptr) {\\n                struct TN *node = getNode();\\n                root->children[d] = node;\\n            }\\n            root = root->children[d];\\n        }\\n        cout << endl;\\n        root->isEndOfWord = true;\\n    }\\n    \\n    vector<int> lexicalOrder(int n) {\\n        vector<int> ans;\\n        struct TN *root = getNode();\\n        \\n        for(int i = 1; i <= n; ++i) {\\n            insert(root, i);\\n        }\\n        dfs(root, 0, ans);\\n        return ans;\\n    }\\n    \\n    void dfs(struct TN *root, int num, vector<int>& ans) {\\n        if(root->isEndOfWord) {\\n            ans.push_back(num);\\n        }\\n        for(int i = 0; i < NUM_DIGITS; ++i) {\\n            if(root->children[i] != nullptr) {\\n                int n = num * 10 + i;\\n                dfs(root->children[i], n, ans);\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1879853,
                "title": "single-line-python-3-solution-98-faster",
                "content": "```\\nclass Solution:\\n    def lexicalOrder(self, n: int) -> List[int]:\\n        return sorted(list(map(str,list(range(1,n+1)))))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def lexicalOrder(self, n: int) -> List[int]:\\n        return sorted(list(map(str,list(range(1,n+1)))))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1863043,
                "title": "c-dfs-solution-with-image",
                "content": "![image](https://assets.leetcode.com/users/images/99263d54-a9f5-455e-b892-3690fb229306_1647683882.623225.png)\\n\\n \\n A graph having each node has 9 child  and for getting lexographic order we need to traverse in the preorder.\\n \\n```\\nclass Solution {\\npublic:\\n    vector<int>ans;\\n    void dfs(int i,int n)\\n    {\\n        if(i>n)\\n            return ;\\n          \\n        ans.push_back(i);\\n        for(int j=0;j<=9;j++)\\n        {\\n            int t=i*10+j;\\n            dfs(t,n);\\n        }\\n      \\n    }\\n    vector<int> lexicalOrder(int n) {\\n        \\n       for(int i=1;i<=9;i++) \\n          {\\n           dfs(i,n);\\n          }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>ans;\\n    void dfs(int i,int n)\\n    {\\n        if(i>n)\\n            return ;\\n          \\n        ans.push_back(i);\\n        for(int j=0;j<=9;j++)\\n        {\\n            int t=i*10+j;\\n            dfs(t,n);\\n        }\\n      \\n    }\\n    vector<int> lexicalOrder(int n) {\\n        \\n       for(int i=1;i<=9;i++) \\n          {\\n           dfs(i,n);\\n          }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1850402,
                "title": "c-trie-implementation-understandable-solution",
                "content": "```\\nclass TrieNode\\n{\\n\\npublic:\\n    vector<TrieNode *> children;\\n    bool isEnd;\\n    TrieNode()\\n    {\\n        children.resize(10, nullptr);\\n        isEnd = false;\\n    }\\n};\\nclass Solution\\n{\\n    TrieNode *root;\\n\\npublic:\\n    Solution()\\n    {\\n        root = new TrieNode();\\n    }\\n    void insert(int num)\\n    {\\n        string digit = to_string(num);\\n        TrieNode *iter = root;\\n        for (auto &ch : digit)\\n        {\\n            if (iter->children[ch - \\'0\\'] == nullptr)\\n            {\\n                iter->children[ch - \\'0\\'] = new TrieNode();\\n            }\\n            iter = iter->children[ch - \\'0\\'];\\n        }\\n        iter->isEnd = true;\\n    }\\n\\n    vector<int> lexicalOrder(int n)\\n    {\\n        vector<int> result;\\n        for (int i = 1; i <= n; i++)\\n        {\\n            this->insert(i);\\n        }\\n        ordering(root, result, \"\");\\n        return result;\\n    }\\n    void ordering(TrieNode *root, vector<int> &result, string currStr)\\n    {\\n\\n        if (!root)\\n        {\\n            return;\\n        }\\n        if (root->isEnd)\\n        {\\n            result.push_back(stoi(currStr));\\n        }\\n        for (int i = 0; i < 10; ++i)\\n        {\\n            if (root->children[i])\\n            {\\n                ordering(root->children[i], result, currStr + to_string(i));\\n            }\\n        }\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Trie"
                ],
                "code": "class Solution\\n{\\n    TrieNode *root;\\n\\npublic:\\n    Solution()\\n    {\\n        root = new TrieNode();\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1787311,
                "title": "o-n-time-o-1-space-stack-solution-in-python",
                "content": "If the current number is 7, next possible numbers are 70, 71, 72, ...., 79. We use a stack to keep track of the current possible numbers. For each last element, we multiply by 10 and create next possible numbers. If that number is larger than `n`, just go to the next iteration. If that number is less than or equal to `n`, append to `res` and append 10 possible numbers.\\n\\nIn this solution, time complexity is **O(N)**, since you start from 1 digit number, and increase them until they exceed N.\\nFor space complexity, it is **O(1)**, since you start from O(9) for the stack, and as you increase number, you pop and add 10 numbers. This means that in the worst case, stack size changes like this:\\n\\nstack size: 9 -> 8 (pop) -> 18 (add 10 numbers) -> 17 (pop) -> 27 (add 10 numbers) -> 26 (pop) -> ....\\n\\nIn this problem, N is 5 digit number, so the above process is repeated at most 5 times, which leads to the maximum size of `54`.\\n\\n```\\nclass Solution:\\n    def lexicalOrder(self, n: int) -> List[int]:\\n        stack = []\\n        for i in range(min(n, 9), 0, -1):\\n            stack.append(i)\\n    \\n        res = []\\n        while stack:\\n            last = stack.pop()\\n            if last > n:\\n                continue\\n            else:\\n                res.append(last)\\n            for i in range(9, -1, -1):\\n                stack.append(last * 10 + i)\\n            \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def lexicalOrder(self, n: int) -> List[int]:\\n        stack = []\\n        for i in range(min(n, 9), 0, -1):\\n            stack.append(i)\\n    \\n        res = []\\n        while stack:\\n            last = stack.pop()\\n            if last > n:\\n                continue\\n            else:\\n                res.append(last)\\n            for i in range(9, -1, -1):\\n                stack.append(last * 10 + i)\\n            \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1747573,
                "title": "c-solution-space-o-1-90-time-o-n-100",
                "content": "class Solution {\\npublic:\\n    vector<int> lexicalOrder(int n) {\\n        vector<int> ans(n);\\n\\n        int current = 1;\\n        for (int i=0; i<n; i++)\\n        {\\n            ans[i] = current;\\n            // add zeros behind the current digit\\n            if ((current * 10) <= n)\\n            {\\n                current *= 10;\\n                continue;\\n            }\\n            // if not going beyond the range or if not changing most significant digit\\n            // just add one to the current digit\\n            if ((current % 10) != 9 && (current + 1) <= n)\\n            {\\n                current += 1;\\n                continue;\\n            }\\n            // if overflowing n or increasing digit\\n            // bring number down until not overflowing and not changing M.S.D.\\n            while ((current % 10) == 9 || (current + 1) > n)\\n                current /= 10;\\n            // go to the next digit \\n            current++;\\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> lexicalOrder(int n) {\\n        vector<int> ans(n);\\n\\n        int current = 1;\\n        for (int i=0; i<n; i++)\\n        {\\n            ans[i] = current;\\n            // add zeros behind the current digit\\n            if ((current * 10) <= n)\\n            {\\n                current *= 10;\\n                continue;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1734861,
                "title": "c-solutions-from-147ms-to-8ms",
                "content": "\\n# View it as a tree, then perform preorder DFS: 8ms\\n\\nIdea is as follows (reference: https://leetcode.com/problems/lexicographical-numbers/discuss/86231/Simple-Java-DFS-Solution)\\n\\n```\\n      1        2        3      ...\\n     / \\\\      / \\\\      / \\\\\\n   10...19  20...29  30...39   ...\\n```\\n\\n```cpp\\nclass Solution {\\n public:\\n  auto lexicalOrder(int n) -> vector<int> {\\n    this->n = n;\\n    for (int i = 1; i <= 9; ++i) {\\n      dfs(i);\\n    }\\n    return ans;\\n  }\\n\\n private:\\n  vector<int> ans;\\n  int n;\\n  void dfs(int num) {\\n    if (num > n) return;\\n    ans.push_back(num);\\n    for (int i = 0; i <= 9; ++i) {\\n      if (num * 10 + i > n) return;\\n      dfs(num * 10 + i);\\n    }\\n  }\\n};\\n```\\n\\n\\n\\n\\n# Naive solution: 147ms\\n\\n```cpp\\nclass Solution {\\n public:\\n  vector<int> lexicalOrder(int n) {\\n    vector<string> vs;\\n    for (int i = 1; i <= n; ++i) {\\n      vs.push_back(to_string(i));\\n    }\\n    sort(begin(vs), end(vs));\\n    vector<int> v;\\n    for (const auto &s : vs) {\\n      v.push_back(stoi(s));\\n    }\\n    return v;\\n  }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\n      1        2        3      ...\\n     / \\\\      / \\\\      / \\\\\\n   10...19  20...29  30...39   ...\\n```\n```cpp\\nclass Solution {\\n public:\\n  auto lexicalOrder(int n) -> vector<int> {\\n    this->n = n;\\n    for (int i = 1; i <= 9; ++i) {\\n      dfs(i);\\n    }\\n    return ans;\\n  }\\n\\n private:\\n  vector<int> ans;\\n  int n;\\n  void dfs(int num) {\\n    if (num > n) return;\\n    ans.push_back(num);\\n    for (int i = 0; i <= 9; ++i) {\\n      if (num * 10 + i > n) return;\\n      dfs(num * 10 + i);\\n    }\\n  }\\n};\\n```\n```cpp\\nclass Solution {\\n public:\\n  vector<int> lexicalOrder(int n) {\\n    vector<string> vs;\\n    for (int i = 1; i <= n; ++i) {\\n      vs.push_back(to_string(i));\\n    }\\n    sort(begin(vs), end(vs));\\n    vector<int> v;\\n    for (const auto &s : vs) {\\n      v.push_back(stoi(s));\\n    }\\n    return v;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1678267,
                "title": "c-solution-very-easy",
                "content": "```\\nvoid helper(int i,int n,vector<int> &ans)\\n    {\\n        if(i>n) return;\\n        ans.push_back(i);\\n        for(int j=0;j<10;j++)\\n        {\\n            helper(i*10+j,n,ans);\\n        }\\n    }\\n    vector<int> lexicalOrder(int n) {\\n        vector<int> ans;\\n        for(int i=1;i<=9;i++)\\n        {\\n            helper(i,n,ans);\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nvoid helper(int i,int n,vector<int> &ans)\\n    {\\n        if(i>n) return;\\n        ans.push_back(i);\\n        for(int j=0;j<10;j++)\\n        {\\n            helper(i*10+j,n,ans);\\n        }\\n    }\\n    vector<int> lexicalOrder(int n) {\\n        vector<int> ans;\\n        for(int i=1;i<=9;i++)\\n        {\\n            helper(i,n,ans);\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1664729,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int>res;\\n    int n;\\n    void solve(int k){\\n        for(int i = 0;i<=9;i++){\\n            if(k*10+i<=n){\\n                res.push_back(k*10+i);\\n                solve(k*10+i);\\n            }\\n        }\\n    }\\n    vector<int> lexicalOrder(int n) {\\n        this->n = n;\\n        for(int i = 1;i<=9;i++){\\n            if(i>n) return res;\\n            res.push_back(i);\\n            solve(i);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>res;\\n    int n;\\n    void solve(int k){\\n        for(int i = 0;i<=9;i++){\\n            if(k*10+i<=n){\\n                res.push_back(k*10+i);\\n                solve(k*10+i);\\n            }\\n        }\\n    }\\n    vector<int> lexicalOrder(int n) {\\n        this->n = n;\\n        for(int i = 1;i<=9;i++){\\n            if(i>n) return res;\\n            res.push_back(i);\\n            solve(i);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1649019,
                "title": "recursion-c",
                "content": "```\\nvector<int> v;\\n    void rec(int n, int s){\\n        if(s>n) return;\\n        v.push_back(s);\\n        rec(n, s*10);\\n        if((s+1)%10) rec(n, s+1);\\n    }\\n    vector<int> lexicalOrder(int n) {\\n        rec(n,1);\\n        return v;\\n    }",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nvector<int> v;\\n    void rec(int n, int s){\\n        if(s>n) return;\\n        v.push_back(s);\\n        rec(n, s*10);\\n        if((s+1)%10) rec(n, s+1);\\n    }\\n    vector<int> lexicalOrder(int n) {\\n        rec(n,1);\\n        return v;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1619630,
                "title": "easy-c-solution-0-ms",
                "content": "# C++ EASY EXPLAINED SOLUTION\\nIn this problem we begin with number, i=1. We change the value of i using two ways on priority:\\n1. **multiplying by 10** : It is given higher priority because for example: for i=10, 100 (10 * 10) will always before 11 (10+1).\\n2. **incrementing by 1**: It is given lower priority. Also, incrementing the value can only be performed till last digit is 9. Because, for example: i=119, if we increment it we 120, but by this process 120 gets added to result before 12 (which would have come by incrementing 10). \\n\\n**TIP: Draw tree for better understanding. Take n= 130 as an example.**\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    void fun(vector<int>&res, int i, int n){\\n        if(i>n)             // if is is out of range, don\\'t add it\\n            return;\\n        res.push_back(i);   //adding the i to result\\n        fun(res,i*10,n);    // checking for number i*10, if it\\'s less than n\\n        if((i+1)%10!=0)     // if the last digit becomes 0 we must not perform increment operation\\n            fun(res,i+1,n);\\n    }\\n    vector<int> lexicalOrder(int n) {\\n        vector<int> res;\\n        fun(res,1,n);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack",
                    "Tree",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void fun(vector<int>&res, int i, int n){\\n        if(i>n)             // if is is out of range, don\\'t add it\\n            return;\\n        res.push_back(i);   //adding the i to result\\n        fun(res,i*10,n);    // checking for number i*10, if it\\'s less than n\\n        if((i+1)%10!=0)     // if the last digit becomes 0 we must not perform increment operation\\n            fun(res,i+1,n);\\n    }\\n    vector<int> lexicalOrder(int n) {\\n        vector<int> res;\\n        fun(res,1,n);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1566176,
                "title": "using-priority-queue",
                "content": "\\'\\'\\'class Solution {\\npublic:\\n    vector<int> lexicalOrder(int n) {\\n        priority_queue<string>q;\\n        for(int i=1;i<=n;i++)\\n        {\\n            string a=to_string(i);\\n            q.push(a);\\n        }\\n        vector<int>ans;\\n        while(!q.empty())\\n        {\\n           ans.push_back(stoi(q.top()));\\n            q.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n        \\n    }\\n};\\'\\'\\'",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> lexicalOrder(int n) {\\n        priority_queue<string>q;\\n        for(int i=1;i<=n;i++)\\n        {\\n            string a=to_string(i);\\n            q.push(a);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1565793,
                "title": "java-easy-dfs",
                "content": "```\\nclass Solution {\\n    public List<Integer> lexicalOrder(int n) {\\n         res = new ArrayList<>();\\n         for(int i = 1; i <= 9 ; i++){\\n               dfs(i,n);\\n         }\\n        return res;\\n    }\\n    List<Integer> res;\\n    public void dfs(int cn,int n){\\n        if(cn > n){\\n            return;\\n        }\\n        res.add(cn); //Add the valid number in your list\\n        for(int i = 0 ; i <= 9;i++){\\n            //Make necessary DFS calls\\n            if(cn * 10 + i <= n){\\n               dfs(cn * 10 + i,n);\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> lexicalOrder(int n) {\\n         res = new ArrayList<>();\\n         for(int i = 1; i <= 9 ; i++){\\n               dfs(i,n);\\n         }\\n        return res;\\n    }\\n    List<Integer> res;\\n    public void dfs(int cn,int n){\\n        if(cn > n){\\n            return;\\n        }\\n        res.add(cn); //Add the valid number in your list\\n        for(int i = 0 ; i <= 9;i++){\\n            //Make necessary DFS calls\\n            if(cn * 10 + i <= n){\\n               dfs(cn * 10 + i,n);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1545087,
                "title": "simple-python-7-lines-dfs-o-n",
                "content": "```\\ndef lexicalOrder(self, n: int) -> List[int]:\\n        \\n        ans =[]\\n        def dfs(cur_s):\\n            if int(cur_s)<=n: ans.append(int(cur_s))\\n            else: return\\n                \\n            for j in range(10): dfs(cur_s + str(j))\\n                \\n        [dfs(str(i)) for i in range(1, 10)]\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\ndef lexicalOrder(self, n: int) -> List[int]:\\n        \\n        ans =[]\\n        def dfs(cur_s):\\n            if int(cur_s)<=n: ans.append(int(cur_s))\\n            else: return\\n                \\n            for j in range(10): dfs(cur_s + str(j))\\n                \\n        [dfs(str(i)) for i in range(1, 10)]\\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1523627,
                "title": "simple-easy-dfs-code",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    \\n    void dfs(int i,int& n,   vector<int>& ans){  \\n        if(i>n) return ;\\n        if(i)\\n        ans.push_back(i);\\n                    \\n        for(int j=0;j<10;j++){\\n            if(i==0&&j==0) continue;\\n            dfs(i*10+j,n,ans);\\n        }\\n        \\n    }\\n    \\n    \\n    vector<int> lexicalOrder(int n) {\\n         vector<int> ans;\\n        dfs(0,n,ans);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    \\n    void dfs(int i,int& n,   vector<int>& ans){  \\n        if(i>n) return ;\\n        if(i)\\n        ans.push_back(i);\\n                    \\n        for(int j=0;j<10;j++){\\n            if(i==0&&j==0) continue;\\n            dfs(i*10+j,n,ans);\\n        }\\n        \\n    }\\n    \\n    \\n    vector<int> lexicalOrder(int n) {\\n         vector<int> ans;\\n        dfs(0,n,ans);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1522388,
                "title": "c-easy-trie-solution",
                "content": "* Insert all the numbers in Trie , and leaf node contain the data for which the whole path is created\\n* and simply traverse whole Trie , and the most amazing property of trie is , it will traverse only in lexicographicall order :)\\n```\\nclass TrieNode\\n{\\n  public:\\n    vector<TrieNode*> next;\\n    bool isWord;\\n    int data;\\n    TrieNode()\\n    {\\n        next.resize(10,NULL);\\n        isWord = false;\\n        data=-1;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    \\n    TrieNode* root = new TrieNode();\\n    vector<int> ans;\\n    void printAll(TrieNode* root)\\n    {\\n        if(root->isWord){\\n            ans.push_back(root->data);\\n        }\\n        for(int i=0;i<10;i++){\\n            if(root->next[i])\\n                printAll(root->next[i]);\\n        }\\n    }\\n    void insert(int num)\\n    {\\n        string s = to_string(num);\\n        TrieNode* p = root;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(p->next[s[i]-\\'0\\']==NULL)\\n                p->next[s[i]-\\'0\\'] = new TrieNode();\\n            p = p->next[s[i]-\\'0\\'];\\n        }\\n        p->data = num;\\n        p->isWord = true;\\n    }\\n    \\n    vector<int> lexicalOrder(int n) {\\n        for(int i=1;i<=n;i++)\\n            insert(i);\\n        printAll(root);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Trie"
                ],
                "code": "```\\nclass TrieNode\\n{\\n  public:\\n    vector<TrieNode*> next;\\n    bool isWord;\\n    int data;\\n    TrieNode()\\n    {\\n        next.resize(10,NULL);\\n        isWord = false;\\n        data=-1;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    \\n    TrieNode* root = new TrieNode();\\n    vector<int> ans;\\n    void printAll(TrieNode* root)\\n    {\\n        if(root->isWord){\\n            ans.push_back(root->data);\\n        }\\n        for(int i=0;i<10;i++){\\n            if(root->next[i])\\n                printAll(root->next[i]);\\n        }\\n    }\\n    void insert(int num)\\n    {\\n        string s = to_string(num);\\n        TrieNode* p = root;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(p->next[s[i]-\\'0\\']==NULL)\\n                p->next[s[i]-\\'0\\'] = new TrieNode();\\n            p = p->next[s[i]-\\'0\\'];\\n        }\\n        p->data = num;\\n        p->isWord = true;\\n    }\\n    \\n    vector<int> lexicalOrder(int n) {\\n        for(int i=1;i<=n;i++)\\n            insert(i);\\n        printAll(root);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1512649,
                "title": "c-dfs-recursion-easy-implementation",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> res;\\n    vector<int> lexicalOrder(int n) {\\n        solve(1,n);\\n        return res;\\n    }\\n    void solve(int x, int n){\\n        if(x>n) return ;\\n        res.push_back(x);\\n        solve(x*10,n);\\n        if((x+1)%10) solve(x+1,n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> res;\\n    vector<int> lexicalOrder(int n) {\\n        solve(1,n);\\n        return res;\\n    }\\n    void solve(int x, int n){\\n        if(x>n) return ;\\n        res.push_back(x);\\n        solve(x*10,n);\\n        if((x+1)%10) solve(x+1,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1487479,
                "title": "dfs-and-smart-javascript-solutions",
                "content": "Just Fast!\\n```\\nvar lexicalOrder = function(n) {\\n    return [...new Array(n)].map((a, i)=>i+1).sort();\\n}\\n```\\n![image](https://assets.leetcode.com/users/images/a52c96f8-da9c-4ca5-ac55-11e009b141b9_1632670559.391142.png)\\n\\nDfs Solution -> Super Fast\\n```\\nvar lexicalOrder = function(n) {\\n    const result = [];\\n    function backtrack(i=1){\\n        if(i>n) return;\\n        result.push(i);\\n        backtrack(i*10);\\n        if(i%10 !== 9)\\n            backtrack(i+1);\\n    }\\n    backtrack();\\n    return result;\\n    \\n}\\n```\\n![image](https://assets.leetcode.com/users/images/de9575a8-b941-4538-a1f3-6f2633e3ecfe_1632670598.6479573.png)\\n",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\nvar lexicalOrder = function(n) {\\n    return [...new Array(n)].map((a, i)=>i+1).sort();\\n}\\n```\n```\\nvar lexicalOrder = function(n) {\\n    const result = [];\\n    function backtrack(i=1){\\n        if(i>n) return;\\n        result.push(i);\\n        backtrack(i*10);\\n        if(i%10 !== 9)\\n            backtrack(i+1);\\n    }\\n    backtrack();\\n    return result;\\n    \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1484808,
                "title": "c-backtracking",
                "content": "![image](https://assets.leetcode.com/users/images/0d5bd258-a8ff-4d21-b8a8-021241c592ab_1632557112.3369095.jpeg)\\n\\n\\n```\\nclass Solution {\\npublic:\\n    void f(int n, int cur, vector<int> &ans) {\\n        if(cur > n ) return;\\n            \\n        ans.push_back(cur);\\n        for(int i = 0; i < 10; i++) {\\n            f(n, cur*10 + i, ans);\\n        }\\n    }\\n    vector<int> lexicalOrder(int n) {\\n        \\n        vector<int> ans;\\n        for(int cur = 1; cur < 10; cur++) {\\n            f(n, cur, ans);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void f(int n, int cur, vector<int> &ans) {\\n        if(cur > n ) return;\\n            \\n        ans.push_back(cur);\\n        for(int i = 0; i < 10; i++) {\\n            f(n, cur*10 + i, ans);\\n        }\\n    }\\n    vector<int> lexicalOrder(int n) {\\n        \\n        vector<int> ans;\\n        for(int cur = 1; cur < 10; cur++) {\\n            f(n, cur, ans);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1473223,
                "title": "python-1-liner",
                "content": "```\\ndef lexicalOrder(self, n: int) -> List[int]:\\n        return [int(j) for j in sorted([str(i) for i in range(1,n+1)])]\\n```",
                "solutionTags": [],
                "code": "```\\ndef lexicalOrder(self, n: int) -> List[int]:\\n        return [int(j) for j in sorted([str(i) for i in range(1,n+1)])]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1436764,
                "title": "simple-10-lines-python-3-solution-using-generator-t-o-n-s-o-1",
                "content": "```\\n    def lexicalOrder(self, n: int) -> List[int]:\\n        next = 1 \\n        while True:\\n            if next <= n:\\n                yield next\\n                next = 10*next\\n            else:\\n                while next%10 == 9:\\n                    if next == 9: return\\n                    next = next//10\\n                next += 1\\n```",
                "solutionTags": [],
                "code": "```\\n    def lexicalOrder(self, n: int) -> List[int]:\\n        next = 1 \\n        while True:\\n            if next <= n:\\n                yield next\\n                next = 10*next\\n            else:\\n                while next%10 == 9:\\n                    if next == 9: return\\n                    next = next//10\\n                next += 1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1418580,
                "title": "c-comparator-o-nlogn-easily-understandable",
                "content": "```\\nstatic bool cmp(int a, int b){\\n        return to_string(a) < to_string(b);\\n    }\\n    vector<int> lexicalOrder(int n) {\\n        vector<int> v;\\n        for(int i=1; i<=n; i++){\\n            v.push_back(i);\\n        }\\n        sort(v.begin(),v.end(),cmp);\\n        return v;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nstatic bool cmp(int a, int b){\\n        return to_string(a) < to_string(b);\\n    }\\n    vector<int> lexicalOrder(int n) {\\n        vector<int> v;\\n        for(int i=1; i<=n; i++){\\n            v.push_back(i);\\n        }\\n        sort(v.begin(),v.end(),cmp);\\n        return v;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1390897,
                "title": "java-easy-to-understand-dfs-solution-with-explanation",
                "content": "![image](https://assets.leetcode.com/users/images/e65cd049-9994-463f-af9e-31e633986ad8_1628416234.18332.png)\\n\\n\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t\\nIf we look carefully we can observe that we just need to do DFS for a tree constructed by [0-9] nodes at every node.\\nand the value at each node is (10 * parentNode + i) where i is in range 0 - 9. We will process only those nodes whose value is less than the value of n and add the value of node into our output.\\n\\n```\\nclass Solution {\\n    List<Integer> output;\\n    public List<Integer> lexicalOrder(int n) {\\n        output = new ArrayList<>();\\n        getLexiOrder(n,0);\\n        return output;\\n        \\n    }\\n    \\n    public void getLexiOrder(int n, int prev){\\n        for(int i = 0; i <= 9; i++){\\n\\t\\t   //We donot need to process 0 for single digit\\n            if(i == 0 && prev == 0){\\n                continue;\\n            }\\n            int no = prev * 10 + i;\\n            if(no <= n){\\n                output.add(no);\\n                getLexiOrder(n,no);\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    List<Integer> output;\\n    public List<Integer> lexicalOrder(int n) {\\n        output = new ArrayList<>();\\n        getLexiOrder(n,0);\\n        return output;\\n        \\n    }\\n    \\n    public void getLexiOrder(int n, int prev){\\n        for(int i = 0; i <= 9; i++){\\n\\t\\t   //We donot need to process 0 for single digit\\n            if(i == 0 && prev == 0){\\n                continue;\\n            }\\n            int no = prev * 10 + i;\\n            if(no <= n){\\n                output.add(no);\\n                getLexiOrder(n,no);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1383427,
                "title": "python-using-sorting",
                "content": "class Solution:\\n\\n    def lexicalOrder(self, n: int) -> List[int]:\\n        temp = [str(i) for i in range(1, n + 1)]        \\n        temp.sort()\\n        \\n        lst = []\\n        for i in temp:\\n            lst.append(int(i))\\n        \\n        return lst\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "class Solution:\\n\\n    def lexicalOrder(self, n: int) -> List[int]:\\n        temp = [str(i) for i in range(1, n + 1)]        \\n        temp.sort()\\n        \\n        lst = []\\n        for i in temp:\\n            lst.append(int(i))\\n        \\n        return lst\\n",
                "codeTag": "Java"
            },
            {
                "id": 1327801,
                "title": "short-and-simple-dfs-in-c",
                "content": "```\\nclass Solution {\\npublic:\\n    void dfs(int curr,int n,vector<int>& v)\\n    {\\n        if(curr<=n) v.push_back(curr);\\n        else return ;\\n        for(int i=0;i<=9;i++) dfs(curr*10+i,n,v);\\n    }\\n    vector<int> lexicalOrder(int n) {\\n        vector<int> v;\\n        for(int i=1;i<=9;i++) dfs(i,n,v);\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(int curr,int n,vector<int>& v)\\n    {\\n        if(curr<=n) v.push_back(curr);\\n        else return ;\\n        for(int i=0;i<=9;i++) dfs(curr*10+i,n,v);\\n    }\\n    vector<int> lexicalOrder(int n) {\\n        vector<int> v;\\n        for(int i=1;i<=9;i++) dfs(i,n,v);\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1320022,
                "title": "simple-approach-using-trie",
                "content": "***Insert All Number from 1 to n  In trie in the form Of String , then apply dfs on Trie through root of Trie.***\\n```\\nclass Node{``\\n  \\n public:\\n    Node* child[10];\\n    bool end;\\n    Node(){\\n        \\n      for(int i=0;i<10;i++){\\n          child[i]= NULL;\\n      }\\n    end=0;\\n    }\\n};\\nclass Trie{\\n   public:\\n  Node * root=new Node();\\n   void insert(string const &str){\\n        \\n      Node* curr=root;\\n     for(int i=0;i<str.size();i++){\\n         int index= str[i]-\\'0\\';\\n         if(curr->child[index] ==NULL){\\n             curr->child[index]=new Node();\\n         }\\n         curr= curr->child[index];\\n     }\\n    curr->end=true;\\n    }\\n    \\n \\n};\\nclass Solution {\\npublic:\\n     void dfs(vector<int> &ans, Node* root,int output){\\n      \\n      if(root==NULL){\\n          return ;\\n      }\\n      \\n      if(root->end==true){\\n          ans.push_back(output);\\n          \\n      }\\n      for(int i=0;i<10;i++){\\n          dfs(ans,root->child[i],output*10+ i);\\n      }\\n  }\\n    vector<int> lexicalOrder(int n) {\\n     \\n    Trie t;\\n     for(int i=1;i<=n;i++){\\n        t.insert(to_string(i));  \\n     }\\n     vector<int> ans;\\n     dfs(ans, t.root, 0);\\n        return ans;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Node{``\\n  \\n public:\\n    Node* child[10];\\n    bool end;\\n    Node(){\\n        \\n      for(int i=0;i<10;i++){\\n          child[i]= NULL;\\n      }\\n    end=0;\\n    }\\n};\\nclass Trie{\\n   public:\\n  Node * root=new Node();\\n   void insert(string const &str){\\n        \\n      Node* curr=root;\\n     for(int i=0;i<str.size();i++){\\n         int index= str[i]-\\'0\\';\\n         if(curr->child[index] ==NULL){\\n             curr->child[index]=new Node();\\n         }\\n         curr= curr->child[index];\\n     }\\n    curr->end=true;\\n    }\\n    \\n \\n};\\nclass Solution {\\npublic:\\n     void dfs(vector<int> &ans, Node* root,int output){\\n      \\n      if(root==NULL){\\n          return ;\\n      }\\n      \\n      if(root->end==true){\\n          ans.push_back(output);\\n          \\n      }\\n      for(int i=0;i<10;i++){\\n          dfs(ans,root->child[i],output*10+ i);\\n      }\\n  }\\n    vector<int> lexicalOrder(int n) {\\n     \\n    Trie t;\\n     for(int i=1;i<=n;i++){\\n        t.insert(to_string(i));  \\n     }\\n     vector<int> ans;\\n     dfs(ans, t.root, 0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1319517,
                "title": "python-96ms-solution-with-comment-no-trie-o-n-time-and-o-1-extra-space",
                "content": "Use rule-based solution to generate lexicographical order. Firstly, the first element must be 1. Then, the current element must depend on the previous element. For example, we know that the current element must be 10 if the previous element is 1 and n is 13. Hence, let follow the logic or the rule of the lexicographical order to generate number in each iteration.\\n(96ms 104ms 108ms)\\n```\\nclass Solution:\\n    def lexicalOrder(self, n: int) -> List[int]:\\n        lexOrder = [1]*n\\n        for i in range(n-1):\\n            # always consider 0 first\\n            # ex: 1 -> 10 -> 100\\n            if  lexOrder[i]*10<=n:\\n                lexOrder[i+1] = lexOrder[i]*10\\n            # consider critical point\\n            # n = 123, previous = 123, current?\\n            # 122 -> 123 -> 13 (124~129 is not allowed)\\n            elif lexOrder[i]==n:\\n                lexOrder[i+1] = lexOrder[i]//10+1\\n                # eliminate extra 0\\n                # n = 199, previous = 199, current?\\n                # ex: 198 -> 199 -> 2\\n                while lexOrder[i+1]%10==0:\\n                    lexOrder[i+1] //= 10\\n            # consider 1 to 9\\n            # n = 199, previous = 125, current?\\n            # 124 -> 125 -> 126\\n            else:\\n                lexOrder[i+1] = lexOrder[i]+1\\n                # eliminate extra 0 \\n                while not lexOrder[i+1]%10:\\n                    lexOrder[i+1] //= 10\\n        return lexOrder\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def lexicalOrder(self, n: int) -> List[int]:\\n        lexOrder = [1]*n\\n        for i in range(n-1):\\n            # always consider 0 first\\n            # ex: 1 -> 10 -> 100\\n            if  lexOrder[i]*10<=n:\\n                lexOrder[i+1] = lexOrder[i]*10\\n            # consider critical point\\n            # n = 123, previous = 123, current?\\n            # 122 -> 123 -> 13 (124~129 is not allowed)\\n            elif lexOrder[i]==n:\\n                lexOrder[i+1] = lexOrder[i]//10+1\\n                # eliminate extra 0\\n                # n = 199, previous = 199, current?\\n                # ex: 198 -> 199 -> 2\\n                while lexOrder[i+1]%10==0:\\n                    lexOrder[i+1] //= 10\\n            # consider 1 to 9\\n            # n = 199, previous = 125, current?\\n            # 124 -> 125 -> 126\\n            else:\\n                lexOrder[i+1] = lexOrder[i]+1\\n                # eliminate extra 0 \\n                while not lexOrder[i+1]%10:\\n                    lexOrder[i+1] //= 10\\n        return lexOrder\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1302248,
                "title": "simple-java-dfs-solution-beats-100",
                "content": "```\\nclass Solution {\\n    public List \\\\<Integer> lexicalOrder(int n) {\\n        List \\\\<Integer> a=new ArrayList<>();\\n        for(int i=1;i<=9;i++)\\n        {\\n            dfs(i,n,a);\\n        }\\n        return a;\\n    }\\n\\t\\n\\t\\n    public void dfs(int s, int d, List<Integer>a)\\n    {\\n        if(s>d)\\n        return;\\n         a.add(s);\\n        for(int i=0;i<=9;i++)\\n        {\\n            int c= s*10+i;\\n            if(c>d)\\n                break;\\n            dfs(c,d,a);\\n        }\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n    public List \\\\<Integer> lexicalOrder(int n) {\\n        List \\\\<Integer> a=new ArrayList<>();\\n        for(int i=1;i<=9;i++)\\n        {\\n            dfs(i,n,a);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1249425,
                "title": "vanilla-iteration",
                "content": "No helpers, no recursion, no additional datastructures, no `stl::algorithm`s.\\n\\n**Outline**\\n\\nGiven number `x` how to get the next number in lexicographic order (less or equal than `n`)?\\n* If `10*x<=n` then `10*x` is the next number;\\n\\n![image](https://assets.leetcode.com/users/images/649e1aee-6432-4a14-979f-aa6f010026bd_1622749041.768796.png)\\n\\n* Otherwise delete all trailing `9`s in `x` (and also possibly last digit iff `x==n`). If after this operation `x_del` is `0` then `x_new=9`. Otherwise the next number is `x_del+1`.\\n \\n![image](https://assets.leetcode.com/users/images/dda1d214-02d6-4c4a-97b3-cbef537bac23_1622750186.7180414.png)\\n\\n\\n <br>\\n <br>\\n \\n**time: O(N); aux. space `O(1)`**\\n```\\nvector<int> lexicalOrder(int n) \\n{\\n\\tvector out{1};\\n\\tfor(int x{1}; size(out)<n; out.push_back(x))\\n\\t\\tif(x*10>n) \\n        {\\n            for( ; x%10==9 or x==n; x/=10);\\n\\t\\t\\tx = x ? x+1 : 9;\\n        }\\n        else\\n\\t\\t\\tx*=10;\\n\\treturn out;\\n}\\n```\\n\\n![image](https://assets.leetcode.com/users/images/43ff072c-7e0f-4e96-b6a9-023825207d08_1622751570.618892.png)\\n\\nFew variations:\\n```\\nvector<int> lexicalOrder(int n) \\n{\\n\\tvector out{1};\\n\\tfor(int x{1}; size(out)<n; out.push_back(x))\\n\\t\\tif((x*=10)>n) \\n        {\\n            for( ; x%10==9 or x>=n; x/=10);\\n\\t\\t\\tx = x ? x+1 : 9;\\n        }\\n\\treturn out;\\n}\\n```\\n||\\n```\\nvector<int> lexicalOrder(int n) \\n{\\n\\tvector out{1};\\n\\tfor(int x{1}; size(out)<n; )\\n\\t{\\n        for( ; (x*=10)<=n; out.push_back(x));\\n        for( ; x%10==9 or x>=n; x/=10);\\n\\t\\tout.push_back(x = x ? x+1 : 9);\\n\\t}\\n\\treturn out;\\n}\\n```\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nvector<int> lexicalOrder(int n) \\n{\\n\\tvector out{1};\\n\\tfor(int x{1}; size(out)<n; out.push_back(x))\\n\\t\\tif(x*10>n) \\n        {\\n            for( ; x%10==9 or x==n; x/=10);\\n\\t\\t\\tx = x ? x+1 : 9;\\n        }\\n        else\\n\\t\\t\\tx*=10;\\n\\treturn out;\\n}\\n```\n```\\nvector<int> lexicalOrder(int n) \\n{\\n\\tvector out{1};\\n\\tfor(int x{1}; size(out)<n; out.push_back(x))\\n\\t\\tif((x*=10)>n) \\n        {\\n            for( ; x%10==9 or x>=n; x/=10);\\n\\t\\t\\tx = x ? x+1 : 9;\\n        }\\n\\treturn out;\\n}\\n```\n```\\nvector<int> lexicalOrder(int n) \\n{\\n\\tvector out{1};\\n\\tfor(int x{1}; size(out)<n; )\\n\\t{\\n        for( ; (x*=10)<=n; out.push_back(x));\\n        for( ; x%10==9 or x>=n; x/=10);\\n\\t\\tout.push_back(x = x ? x+1 : 9);\\n\\t}\\n\\treturn out;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1174319,
                "title": "simple-c-o-n-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    void helper(int i, int n, vector<int>& res)\\n    { \\n        res.push_back(i);\\n        for(int j = 0; j < 10; j++)\\n        { \\n            int num = (i * 10) + j;\\n            if(num <= n)\\n            {\\n                helper(num, n, res);\\n            }   \\n            \\n        }\\n    }\\n    \\n    vector<int> lexicalOrder(int n) {\\n        vector<int> res;\\n        \\n        for(int i = 1; i < 10; i++)\\n        {\\n            if(i < n)\\n            {\\n                helper(i, n, res);\\n            }    \\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void helper(int i, int n, vector<int>& res)\\n    { \\n        res.push_back(i);\\n        for(int j = 0; j < 10; j++)\\n        { \\n            int num = (i * 10) + j;\\n            if(num <= n)\\n            {\\n                helper(num, n, res);\\n            }   \\n            \\n        }\\n    }\\n    \\n    vector<int> lexicalOrder(int n) {\\n        vector<int> res;\\n        \\n        for(int i = 1; i < 10; i++)\\n        {\\n            if(i < n)\\n            {\\n                helper(i, n, res);\\n            }    \\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1162136,
                "title": "python-1-liner",
                "content": "Runtime is O(n^3), but it still made 50% runtime.\\n```\\nclass Solution:\\n    def lexicalOrder(self, n: int) -> List[int]:\\n        return [int(i) for i in sorted([str(j) for j in [h+1 for h in range(n)]])]\\n```\\nIt\\'s slow, but hey it\\'s still a 1-liner. :)\\ndon\\'t mind me I\\'m still learning\\nEDIT: looks like I can reduce it to O(n^2), totally forgot about the arguments of the range() function\\n```\\nclass Solution:\\n    def lexicalOrder(self, n: int) -> List[int]:\\n        return [int(i) for i in sorted([str(j) for j in range(1,n+1)])]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def lexicalOrder(self, n: int) -> List[int]:\\n        return [int(i) for i in sorted([str(j) for j in [h+1 for h in range(n)]])]\\n```\n```\\nclass Solution:\\n    def lexicalOrder(self, n: int) -> List[int]:\\n        return [int(i) for i in sorted([str(j) for j in range(1,n+1)])]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1066047,
                "title": "simple-python-1-liner",
                "content": "```\\nreturn sorted([str(i) for i in range(1,n+1)])\\n```\\n\\nRuntime: 88 ms, faster than 89.33% of Python online submissions for Lexicographical Numbers.\\nMemory Usage: 18.8 MB, less than 62.67% of Python online submissions for Lexicographical Numbers.",
                "solutionTags": [],
                "code": "```\\nreturn sorted([str(i) for i in range(1,n+1)])\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1019661,
                "title": "java-dfs",
                "content": "```\\nclass Solution {\\n    \\n    public List<Integer> lexicalOrder(int n) {\\n        List<Integer> list = new ArrayList<>();\\n        \\n        dfs(list, 0, n);\\n        \\n        return list;\\n    }\\n    \\n    //*****************************************\\n    private void dfs(List<Integer> list, int num, int n) {\\n        for(int i = 0; i <= 9; i++) {\\n            int curr = 10*num+i;\\n            \\n            if(curr == 0) {\\n                continue;\\n            } else if(curr > n) {\\n                return;\\n            }\\n            \\n            list.add(curr);\\n            dfs(list, curr, n);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public List<Integer> lexicalOrder(int n) {\\n        List<Integer> list = new ArrayList<>();\\n        \\n        dfs(list, 0, n);\\n        \\n        return list;\\n    }\\n    \\n    //*****************************************\\n    private void dfs(List<Integer> list, int num, int n) {\\n        for(int i = 0; i <= 9; i++) {\\n            int curr = 10*num+i;\\n            \\n            if(curr == 0) {\\n                continue;\\n            } else if(curr > n) {\\n                return;\\n            }\\n            \\n            list.add(curr);\\n            dfs(list, curr, n);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 958369,
                "title": "c-simple-short-beginner-solution-concise-beats-90",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    void dfs(int curr,int n){\\n        ans.push_back(curr);\\n        for(int dig=0;dig<=9;dig++){\\n            if(curr*10+dig<=n)\\n                dfs(curr*10+dig,n);\\n        }\\n    }\\n    vector<int> lexicalOrder(int n) {\\n        for(int i=1;i<=9;++i){\\n            if(i<=n)\\n                dfs(i,n);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    void dfs(int curr,int n){\\n        ans.push_back(curr);\\n        for(int dig=0;dig<=9;dig++){\\n            if(curr*10+dig<=n)\\n                dfs(curr*10+dig,n);\\n        }\\n    }\\n    vector<int> lexicalOrder(int n) {\\n        for(int i=1;i<=9;++i){\\n            if(i<=n)\\n                dfs(i,n);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 903649,
                "title": "java-concise-code-dfs-o-n",
                "content": "```\\nclass Solution {\\n    List<Integer> ans = new ArrayList<>();\\n    public List<Integer> lexicalOrder(int n) {\\n        for (int i = 1; i < 10; i++)\\n            dfs(i, n);\\n        return ans;\\n    }\\n    void dfs(int cur, int n) {\\n        if (cur <= n) {\\n            ans.add(cur);\\n            for (int i = 0; i < 10; i++)\\n                dfs(cur*10+i, n);\\n        }\\n    } \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    List<Integer> ans = new ArrayList<>();\\n    public List<Integer> lexicalOrder(int n) {\\n        for (int i = 1; i < 10; i++)\\n            dfs(i, n);\\n        return ans;\\n    }\\n    void dfs(int cur, int n) {\\n        if (cur <= n) {\\n            ans.add(cur);\\n            for (int i = 0; i < 10; i++)\\n                dfs(cur*10+i, n);\\n        }\\n    } \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 873244,
                "title": "java-beats-100-1-ms-optimised-backtracking",
                "content": "\\n    public List<Integer> lexicalOrder(int n) {\\n        List<Integer>ans = new ArrayList<>();\\n        for(int i=1;i<=9;i++)\\n            Lexical(i,n,ans);\\n        return ans;\\n    }\\n    \\n    public void Lexical(int i,int n,List<Integer>ans){\\n        \\n        if(i>n)\\n            return;\\n        \\n        ans.add(i);\\n        for(int j=0;j<=9;j++){\\n            if(10*i+j>n)\\n                return;\\n            Lexical(10*i+j,n,ans);\\n        }\\n    }\\n",
                "solutionTags": [],
                "code": "\\n    public List<Integer> lexicalOrder(int n) {\\n        List<Integer>ans = new ArrayList<>();\\n        for(int i=1;i<=9;i++)\\n            Lexical(i,n,ans);\\n        return ans;\\n    }\\n    \\n    public void Lexical(int i,int n,List<Integer>ans){\\n        \\n        if(i>n)\\n            return;\\n        \\n        ans.add(i);\\n        for(int j=0;j<=9;j++){\\n            if(10*i+j>n)\\n                return;\\n            Lexical(10*i+j,n,ans);\\n        }\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 834239,
                "title": "c-16ms-60-runtime-solution-generating-numbers",
                "content": "```\\nclass Solution {\\npublic:\\n    void helper(vector<int>&result,int&n,int element){\\n        element*=10;\\n        if(element!=0&&element<=n){result.push_back(element);helper(result,n,element);}\\n        for(int i=1;i<10;i++){\\n            if(element+i<=n){result.push_back(element+i);helper(result,n,element+i);}\\n        }\\n    }\\n    vector<int> lexicalOrder(int n) {\\n        vector<int>result;\\n        helper(result,n,0);\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void helper(vector<int>&result,int&n,int element){\\n        element*=10;\\n        if(element!=0&&element<=n){result.push_back(element);helper(result,n,element);}\\n        for(int i=1;i<10;i++){\\n            if(element+i<=n){result.push_back(element+i);helper(result,n,element+i);}\\n        }\\n    }\\n    vector<int> lexicalOrder(int n) {\\n        vector<int>result;\\n        helper(result,n,0);\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 822434,
                "title": "python-dfs",
                "content": "```\\nclass Solution:\\n    def lexicalOrder(self, n: int) -> List[int]:\\n        if n < 10:\\n            return range(1, n + 1)\\n        res = []\\n        for i in range(1, 10):\\n            self.dfs(i, res, n)\\n        return res \\n \\n    def dfs(self, curr, res, n):\\n        res.append(curr)\\n        for i in range(10):\\n            if curr*10 + i <= n:\\n                self.dfs(curr*10 + i, res, n)\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def lexicalOrder(self, n: int) -> List[int]:\\n        if n < 10:\\n            return range(1, n + 1)\\n        res = []\\n        for i in range(1, 10):\\n            self.dfs(i, res, n)\\n        return res \\n \\n    def dfs(self, curr, res, n):\\n        res.append(curr)\\n        for i in range(10):\\n            if curr*10 + i <= n:\\n                self.dfs(curr*10 + i, res, n)\\n",
                "codeTag": "Java"
            },
            {
                "id": 817573,
                "title": "python3-two-approaches-sorting-dfs",
                "content": "approach 1 - sorting (`O(NlogN)` time & `O(N)` space)\\n(92ms, 99.44%)\\n```\\nclass Solution:\\n    def lexicalOrder(self, n: int) -> List[int]:\\n        return sorted(range(1, n+1), key=str)\\n```\\n\\napproach 2 - dfs (`O(NlogN)` time & `O(N)` space)\\n(284ms, 13.64%)\\n```\\nclass Solution:\\n    def lexicalOrder(self, n: int) -> List[int]:\\n        \\n        def dfs(x):\\n            \"\"\"Pre-order traverse the tree.\"\"\"\\n            if x <= n:\\n                ans.append(x)\\n                for xx in range(10): dfs(10*x + xx)\\n        \\n        ans = []\\n        for x in range(1, 10): dfs(x)\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def lexicalOrder(self, n: int) -> List[int]:\\n        return sorted(range(1, n+1), key=str)\\n```\n```\\nclass Solution:\\n    def lexicalOrder(self, n: int) -> List[int]:\\n        \\n        def dfs(x):\\n            \"\"\"Pre-order traverse the tree.\"\"\"\\n            if x <= n:\\n                ans.append(x)\\n                for xx in range(10): dfs(10*x + xx)\\n        \\n        ans = []\\n        for x in range(1, 10): dfs(x)\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 810448,
                "title": "python-3-one-liner-cheat-sort-string",
                "content": "Super straight forward, but I wouldn\\'t do it this way during interview :)\\n```\\nclass Solution:\\n    def lexicalOrder(self, n: int) -> List[int]:\\n        return [int(i) for i in sorted([str(i) for i in range(1, n+1)])]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def lexicalOrder(self, n: int) -> List[int]:\\n        return [int(i) for i in sorted([str(i) for i in range(1, n+1)])]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 802001,
                "title": "c-stack-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> lexicalOrder(int n) {\\n        stack<int> st;\\n        \\n        for(int i=9;i>=1;i--){\\n            if(i<=n){\\n                st.push(i);\\n            }\\n        }\\n        \\n        vector<int> result;\\n        \\n        while(st.size()){\\n            int tp=st.top();\\n            st.pop();\\n            \\n            result.push_back(tp);\\n            \\n            for(int i=9;i>=0;i--){\\n                int ok=tp*10+i;\\n                \\n                if(ok<=n){\\n                    st.push(ok);   \\n                }\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> lexicalOrder(int n) {\\n        stack<int> st;\\n        \\n        for(int i=9;i>=1;i--){\\n            if(i<=n){\\n                st.push(i);\\n            }\\n        }\\n        \\n        vector<int> result;\\n        \\n        while(st.size()){\\n            int tp=st.top();\\n            st.pop();\\n            \\n            result.push_back(tp);\\n            \\n            for(int i=9;i>=0;i--){\\n                int ok=tp*10+i;\\n                \\n                if(ok<=n){\\n                    st.push(ok);   \\n                }\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 769498,
                "title": "simple-recursive-c-solution-beats-90-of-users",
                "content": "```\\nclass Solution {\\npublic:  \\n\\tvector<int> v {};\\n    \\n    void helper(int a, int n) {\\n        if (a > n) {\\n            return;\\n        }\\n        v.push_back(a);\\n        helper(a * 10, n);\\n        if (a % 10 == 0) {\\n            for (int i = 1; i <= 9; i++) {\\n                helper(a + i, n);\\n            }\\n        }\\n    }\\n    \\n    vector<int> lexicalOrder(int n) {\\n        for (int i = 1; i <= 9; i++) {\\n            helper(i, n);\\n        }\\n        return v;\\n    }\\n};\\n```\\n\\nI will run through an example to explain the code. Suppose n = 147. Then, we start by calling helper(1,147), and we add 1 to our vector since 1 < 147. Next, we call helper(10,147), and since 10 < 147, we again add 10 to our vector v. Similar for helper(100,147), and finally at helper(1000,147), since 1000 > 147, we return. At this point, the stack frame is at the helper(100,147) frame, and so we continue to the rest of the helper code. Since 100 % 10 == 0 (this case prevents us from adding an element twice), we add 1 to 100, and continue this 9 times (from 101-109), and since all of these are less than 147, 101-109 will be added to v. We return to the next stack frame, which was helper(10, 147). Since 10 % 10 == 0, we continue onto the for loop, and we try helper(11, 147). Since 11 < 147, we add 11 to v, and we then call helper(110, 147). We continue on this process and add (111-119) to v. \\n\\nI think at this point, the process is pretty clear. All the numbers starting with 1 will be added in lexicographical order, and then the numbers starting with 2 will be added in lexicographical order, and so on. \\n\\nI will note that though the space requirement is O(n) (for the vector v), this code will require a bit of space since recursion uses more memory than an iterative approach. However, I think that this approach is clearer and simpler to understand than an iterative approach, at least in my head.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:  \\n\\tvector<int> v {};\\n    \\n    void helper(int a, int n) {\\n        if (a > n) {\\n            return;\\n        }\\n        v.push_back(a);\\n        helper(a * 10, n);\\n        if (a % 10 == 0) {\\n            for (int i = 1; i <= 9; i++) {\\n                helper(a + i, n);\\n            }\\n        }\\n    }\\n    \\n    vector<int> lexicalOrder(int n) {\\n        for (int i = 1; i <= 9; i++) {\\n            helper(i, n);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 715217,
                "title": "simplest-solution-in-java",
                "content": "```\\nclass Solution {\\n    public List<Integer> lexicalOrder(int n) {\\n        \\n        List<Integer> list = new ArrayList<>();\\n        for(int i=1;i<=n;i++){\\n            list.add(i);\\n        }\\n        \\n        Collections.sort(list, (o1,o2)-> (String.valueOf(o1)).compareTo(String.valueOf(o2)));\\n        \\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> lexicalOrder(int n) {\\n        \\n        List<Integer> list = new ArrayList<>();\\n        for(int i=1;i<=n;i++){\\n            list.add(i);\\n        }\\n        \\n        Collections.sort(list, (o1,o2)-> (String.valueOf(o1)).compareTo(String.valueOf(o2)));\\n        \\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 690659,
                "title": "simple-c-code",
                "content": "```\\nvector<int> lexicalOrder(int n) {\\n\\tvector<int> res(n);\\n\\n\\tint curr = 1;\\n\\n\\tfor (int i = 0; i < n; ++i) {\\n\\n\\t\\tres[i] = curr;\\n\\n\\t\\tif (curr * 10 <= n) {\\n\\t\\t\\tcurr *= 10;\\n\\t\\t} else {\\n\\n\\t\\t\\tif (curr % 10 < 9 && curr + 1 <= n)  ++curr;\\n\\t\\t\\telse {\\n\\n\\t\\t\\t\\twhile ((curr % 10 == 9 && curr / 10 > 0) || curr + 1 > n) curr = curr / 10;\\n\\t\\t\\t\\t++curr;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\treturn res;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvector<int> lexicalOrder(int n) {\\n\\tvector<int> res(n);\\n\\n\\tint curr = 1;\\n\\n\\tfor (int i = 0; i < n; ++i) {\\n\\n\\t\\tres[i] = curr;\\n\\n\\t\\tif (curr * 10 <= n) {\\n\\t\\t\\tcurr *= 10;\\n\\t\\t} else {\\n\\n\\t\\t\\tif (curr % 10 < 9 && curr + 1 <= n)  ++curr;\\n\\t\\t\\telse {\\n\\n\\t\\t\\t\\twhile ((curr % 10 == 9 && curr / 10 > 0) || curr + 1 > n) curr = curr / 10;\\n\\t\\t\\t\\t++curr;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 612799,
                "title": "java-backtrack-2ms",
                "content": "\\n```\\nclass Solution {\\n    public List<Integer> lexicalOrder(int n) {\\n        List<Integer> result = new ArrayList<Integer>();\\n        helper(1, n, result, false);\\n        return result;\\n        \\n    }\\n\\n    void helper(int n, int num, List<Integer> result, boolean flag){\\n        if(n > num || (n % 10 == 0 && flag == true)) return;\\n        \\n        result.add(n);\\n        helper(n*10, num, result, false);\\n        helper(n+1, num, result, true);\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> lexicalOrder(int n) {\\n        List<Integer> result = new ArrayList<Integer>();\\n        helper(1, n, result, false);\\n        return result;\\n        \\n    }\\n\\n    void helper(int n, int num, List<Integer> result, boolean flag){\\n        if(n > num || (n % 10 == 0 && flag == true)) return;\\n        \\n        result.add(n);\\n        helper(n*10, num, result, false);\\n        helper(n+1, num, result, true);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 579822,
                "title": "python-dfs",
                "content": "```\\ndef lexicalOrder(n):\\n    res = []\\n    nex = [\\'0\\', \\'1\\', \\'2\\', \\'3\\', \\'4\\', \\'5\\', \\'6\\', \\'7\\', \\'8\\', \\'9\\']\\n    def dfs(cur):\\n        if int(cur) <= n:\\n            res.append(int(cur))\\n            for x in nex:\\n                dfs(cur + x)\\n    for i in range(1, 10):\\n        dfs(str(i))\\n    return res\\n```",
                "solutionTags": [],
                "code": "```\\ndef lexicalOrder(n):\\n    res = []\\n    nex = [\\'0\\', \\'1\\', \\'2\\', \\'3\\', \\'4\\', \\'5\\', \\'6\\', \\'7\\', \\'8\\', \\'9\\']\\n    def dfs(cur):\\n        if int(cur) <= n:\\n            res.append(int(cur))\\n            for x in nex:\\n                dfs(cur + x)\\n    for i in range(1, 10):\\n        dfs(str(i))\\n    return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 544131,
                "title": "java-dfs",
                "content": "```\\nclass Solution {\\n    int n;\\n    List<Integer> res;\\n    public List<Integer> lexicalOrder(int n) {\\n        this.n = n;\\n        res = new ArrayList<>();\\n        for (int i = 1; i < 10; i ++) {\\n            if (i > n) break;\\n            dfs(i);\\n        }\\n        return res;\\n    }\\n    private void dfs(int st) {\\n        res.add(st);\\n        st *= 10;\\n        for (int i = 0; i < 10; i++){\\n            if (st + i > n) return;\\n            dfs(st + i); \\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int n;\\n    List<Integer> res;\\n    public List<Integer> lexicalOrder(int n) {\\n        this.n = n;\\n        res = new ArrayList<>();\\n        for (int i = 1; i < 10; i ++) {\\n            if (i > n) break;\\n            dfs(i);\\n        }\\n        return res;\\n    }\\n    private void dfs(int st) {\\n        res.add(st);\\n        st *= 10;\\n        for (int i = 0; i < 10; i++){\\n            if (st + i > n) return;\\n            dfs(st + i); \\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 503072,
                "title": "simple-comparator-used-java-solution-19ms",
                "content": "```\\nclass Solution {\\n    public List<Integer> lexicalOrder(int n) {\\n        List<Integer> sol=new ArrayList<>();\\n        for(int i=0;i<n;i++) sol.add(i+1);\\n        Collections.sort(sol,new Comparator<Integer>(){\\n            public int compare(Integer a,Integer b){\\n                String s1=a.toString();\\n                String s2=b.toString();\\n                int i;\\n                if(s1.length()==s2.length()) return a-b;\\n                else{\\n                    for(i=0;i<s1.length() && i<s2.length();i++){\\n                        if(s1.charAt(i)!=s2.charAt(i))\\n                            return s1.charAt(i)-s2.charAt(i);\\n                    }\\n                    if(i==s1.length()) return -1;\\n                    else return 1;\\n                }\\n        }});   \\n        return sol;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> lexicalOrder(int n) {\\n        List<Integer> sol=new ArrayList<>();\\n        for(int i=0;i<n;i++) sol.add(i+1);\\n        Collections.sort(sol,new Comparator<Integer>(){\\n            public int compare(Integer a,Integer b){\\n                String s1=a.toString();\\n                String s2=b.toString();\\n                int i;\\n                if(s1.length()==s2.length()) return a-b;\\n                else{\\n                    for(i=0;i<s1.length() && i<s2.length();i++){\\n                        if(s1.charAt(i)!=s2.charAt(i))\\n                            return s1.charAt(i)-s2.charAt(i);\\n                    }\\n                    if(i==s1.length()) return -1;\\n                    else return 1;\\n                }\\n        }});   \\n        return sol;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 421496,
                "title": "accepted-python-answer-using-sorted",
                "content": "- Just for contest \\u2013 not interview:\\n```\\nclass Solution:\\n    def lexicalOrder(self, n):\\n        return sorted([str(num) for num in range(1, n + 1)])\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def lexicalOrder(self, n):\\n        return sorted([str(num) for num in range(1, n + 1)])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 362261,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> lexicalOrder(int n) {\\n        vector<int> res;\\n        res.push_back(1);\\n        int k=n;\\n        int number=1;\\n        k--;\\n        while (k) {\\n            if (number*10 <= n) {\\n                number*=10;\\n                res.push_back(number);\\n            }\\n            else if (number+1<=n && number%10!=9) {\\n                number += 1;\\n                res.push_back(number);\\n            }\\n            else {\\n                number = number/10;\\n                while (number%10==9)\\n                    number = number/10;\\n                number += 1;\\n                res.push_back(number);\\n            }\\n            k--;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> lexicalOrder(int n) {\\n        vector<int> res;\\n        res.push_back(1);\\n        int k=n;\\n        int number=1;\\n        k--;\\n        while (k) {\\n            if (number*10 <= n) {\\n                number*=10;\\n                res.push_back(number);\\n            }\\n            else if (number+1<=n && number%10!=9) {\\n                number += 1;\\n                res.push_back(number);\\n            }\\n            else {\\n                number = number/10;\\n                while (number%10==9)\\n                    number = number/10;\\n                number += 1;\\n                res.push_back(number);\\n            }\\n            k--;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 359390,
                "title": "recursive-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n  vector<int> lexicalOrder(int n) {\\n  \\tvector<int> R;\\n  \\tfor(int i=1; i<=9; i++) {\\n  \\t\\tif(i > n) break;\\n  \\t\\tR.push_back(i);\\n  \\t\\tgo(i, n, R);\\n  \\t}\\n  \\treturn R;\\n  }\\n\\n  void go(int n, int t, vector<int> &R) {\\n\\tfor(int i=0; i<=9; i++) {\\n\\t\\tint next = n * 10 + i;\\n\\t\\tif(next > t) break;\\n\\t\\tR.push_back(next);\\n\\t\\tgo(next, t, R);\\n\\t\\t}\\n\\t}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n  vector<int> lexicalOrder(int n) {\\n  \\tvector<int> R;\\n  \\tfor(int i=1; i<=9; i++) {\\n  \\t\\tif(i > n) break;\\n  \\t\\tR.push_back(i);\\n  \\t\\tgo(i, n, R);\\n  \\t}\\n  \\treturn R;\\n  }\\n\\n  void go(int n, int t, vector<int> &R) {\\n\\tfor(int i=0; i<=9; i++) {\\n\\t\\tint next = n * 10 + i;\\n\\t\\tif(next > t) break;\\n\\t\\tR.push_back(next);\\n\\t\\tgo(next, t, R);\\n\\t\\t}\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 355204,
                "title": "python-recursive-using-generator",
                "content": "Keep yield return next number of current number.\\ne.g., for \"1\", yield return 10, and 100 ... first, then 11, and 110, ...\\n\\n```\\nclass Solution:\\n    def lexicalOrder(self, n: int) -> List[int]:\\n        def dfs(num):\\n            if num>n:\\n                return\\n            yield num\\n            if num*10<=n:\\n                for d in dfs(num*10):\\n                    yield d\\n            if num%10==9:\\n                return\\n            if num+1<=n:\\n                for d in dfs(num+1):\\n                    yield d\\n        return list(dfs(1))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def lexicalOrder(self, n: int) -> List[int]:\\n        def dfs(num):\\n            if num>n:\\n                return\\n            yield num\\n            if num*10<=n:\\n                for d in dfs(num*10):\\n                    yield d\\n            if num%10==9:\\n                return\\n            if num+1<=n:\\n                for d in dfs(num+1):\\n                    yield d\\n        return list(dfs(1))\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1565749,
                "content": [
                    {
                        "username": "wong2333",
                        "content": "![0_1480987480523_upload-12fc3406-aae6-484c-a653-1fa91e5f2ec5](/uploads/files/1480987290472-upload-12fc3406-aae6-484c-a653-1fa91e5f2ec5.png) \\n\\nwe can imagine such a tree, out task is to traversal it with DFS, and collect numbers along the way: 1, 10, 100, ... you get it. When we encounter a number larger than `n`, we can return back to the previous   level. \\n\\nHope it helps"
                    },
                    {
                        "username": "jstephenj14",
                        "content": "super helpful, thanks!\\n"
                    },
                    {
                        "username": "aalmos",
                        "content": "The recursive solutions are not `O(1)` extra space."
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "yes it should be O(N) !!"
                    },
                    {
                        "username": "zplu",
                        "content": "return sorted(str(num) for num in list(range(1, n + 1)))"
                    },
                    {
                        "username": "adam-hoelscher",
                        "content": "[@Hmit](/Hmit)\n`range` is $$O(1)$$\n`list` is $$O(n)$$\n`(str(num) for num in ...)` is $$O(n)$$\n`sorted` is $$O(nlog(n))$$\n\nThe total is $$O(nlog(n))$$"
                    },
                    {
                        "username": "Hmit",
                        "content": "[@adam-hoelscher](/adam-hoelscher) Actually, n log(n)^2"
                    },
                    {
                        "username": "adam-hoelscher",
                        "content": "`O(n log n)`"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "The difficulty is definitely inaccurate."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Do not build a trie for this it\\'s very slow"
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "Can anyone please tell me my mistake ??\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> lexicalOrder(int n) {\\n        \\n        stack<int>s;\\n        vector<int>ans;\\n        s.push(1);\\n        ans.push_back(1);\\n\\n        while(!s.empty()) {\\n            \\n            while(s.top()*10 <= n) {\\n                ans.push_back(s.top()*10);\\n                s.push(s.top()*10);\\n            }\\n\\n            while(s.top() + 1 <= n && (s.top() + 1)%10 != 0) {\\n              \\n                int update = s.top();\\n                update++;\\n                s.pop();\\n                s.push(update);\\n                ans.push_back(update);\\n\\n                if((update + 1)%10 == 0) break;\\n\\n            }\\n\\n            \\n            s.pop();\\n\\n         \\n            if(s.empty())break;\\n            \\n            int last = s.top();\\n            s.pop();\\n            s.push(last + 1);\\n            ans.push_back(last + 1); \\n\\n        }\\n\\n\\n        return ans;\\n\\n    }\\n};"
                    },
                    {
                        "username": "Hmit",
                        "content": "Well, n takes up O(log n) space to write. So O(n logn) is probably good enough?"
                    },
                    {
                        "username": "keshav-Aggarwal_001",
                        "content": "class Solution {\\npublic:\\n    static bool comp(string &a , string &b){\\n        return lexicographical_compare(a.begin() , a.end() , b.begin() , b.end());\\n    }\\n    vector<int> lexicalOrder(int n) {\\n        vector<string> st;\\n        vector<int> ans;\\n        for(int i=1;i <= n;i++) st.push_back(to_string(i));\\n        sort(st.begin() , st.end() , comp);\\n        for(auto it: st) ans.push_back(stoi(it));\\n        return ans;\\n    }\\n};\\n\\nConstraints here are in my code\\'s favour . \\uD83D\\uDE01 using stl , everything is easy ."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/386_Lexicographical_Numbers.cpp"
                    }
                ]
            },
            {
                "id": 1786993,
                "content": [
                    {
                        "username": "wong2333",
                        "content": "![0_1480987480523_upload-12fc3406-aae6-484c-a653-1fa91e5f2ec5](/uploads/files/1480987290472-upload-12fc3406-aae6-484c-a653-1fa91e5f2ec5.png) \\n\\nwe can imagine such a tree, out task is to traversal it with DFS, and collect numbers along the way: 1, 10, 100, ... you get it. When we encounter a number larger than `n`, we can return back to the previous   level. \\n\\nHope it helps"
                    },
                    {
                        "username": "jstephenj14",
                        "content": "super helpful, thanks!\\n"
                    },
                    {
                        "username": "aalmos",
                        "content": "The recursive solutions are not `O(1)` extra space."
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "yes it should be O(N) !!"
                    },
                    {
                        "username": "zplu",
                        "content": "return sorted(str(num) for num in list(range(1, n + 1)))"
                    },
                    {
                        "username": "adam-hoelscher",
                        "content": "[@Hmit](/Hmit)\n`range` is $$O(1)$$\n`list` is $$O(n)$$\n`(str(num) for num in ...)` is $$O(n)$$\n`sorted` is $$O(nlog(n))$$\n\nThe total is $$O(nlog(n))$$"
                    },
                    {
                        "username": "Hmit",
                        "content": "[@adam-hoelscher](/adam-hoelscher) Actually, n log(n)^2"
                    },
                    {
                        "username": "adam-hoelscher",
                        "content": "`O(n log n)`"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "The difficulty is definitely inaccurate."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Do not build a trie for this it\\'s very slow"
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "Can anyone please tell me my mistake ??\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> lexicalOrder(int n) {\\n        \\n        stack<int>s;\\n        vector<int>ans;\\n        s.push(1);\\n        ans.push_back(1);\\n\\n        while(!s.empty()) {\\n            \\n            while(s.top()*10 <= n) {\\n                ans.push_back(s.top()*10);\\n                s.push(s.top()*10);\\n            }\\n\\n            while(s.top() + 1 <= n && (s.top() + 1)%10 != 0) {\\n              \\n                int update = s.top();\\n                update++;\\n                s.pop();\\n                s.push(update);\\n                ans.push_back(update);\\n\\n                if((update + 1)%10 == 0) break;\\n\\n            }\\n\\n            \\n            s.pop();\\n\\n         \\n            if(s.empty())break;\\n            \\n            int last = s.top();\\n            s.pop();\\n            s.push(last + 1);\\n            ans.push_back(last + 1); \\n\\n        }\\n\\n\\n        return ans;\\n\\n    }\\n};"
                    },
                    {
                        "username": "Hmit",
                        "content": "Well, n takes up O(log n) space to write. So O(n logn) is probably good enough?"
                    },
                    {
                        "username": "keshav-Aggarwal_001",
                        "content": "class Solution {\\npublic:\\n    static bool comp(string &a , string &b){\\n        return lexicographical_compare(a.begin() , a.end() , b.begin() , b.end());\\n    }\\n    vector<int> lexicalOrder(int n) {\\n        vector<string> st;\\n        vector<int> ans;\\n        for(int i=1;i <= n;i++) st.push_back(to_string(i));\\n        sort(st.begin() , st.end() , comp);\\n        for(auto it: st) ans.push_back(stoi(it));\\n        return ans;\\n    }\\n};\\n\\nConstraints here are in my code\\'s favour . \\uD83D\\uDE01 using stl , everything is easy ."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/386_Lexicographical_Numbers.cpp"
                    }
                ]
            },
            {
                "id": 1573151,
                "content": [
                    {
                        "username": "wong2333",
                        "content": "![0_1480987480523_upload-12fc3406-aae6-484c-a653-1fa91e5f2ec5](/uploads/files/1480987290472-upload-12fc3406-aae6-484c-a653-1fa91e5f2ec5.png) \\n\\nwe can imagine such a tree, out task is to traversal it with DFS, and collect numbers along the way: 1, 10, 100, ... you get it. When we encounter a number larger than `n`, we can return back to the previous   level. \\n\\nHope it helps"
                    },
                    {
                        "username": "jstephenj14",
                        "content": "super helpful, thanks!\\n"
                    },
                    {
                        "username": "aalmos",
                        "content": "The recursive solutions are not `O(1)` extra space."
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "yes it should be O(N) !!"
                    },
                    {
                        "username": "zplu",
                        "content": "return sorted(str(num) for num in list(range(1, n + 1)))"
                    },
                    {
                        "username": "adam-hoelscher",
                        "content": "[@Hmit](/Hmit)\n`range` is $$O(1)$$\n`list` is $$O(n)$$\n`(str(num) for num in ...)` is $$O(n)$$\n`sorted` is $$O(nlog(n))$$\n\nThe total is $$O(nlog(n))$$"
                    },
                    {
                        "username": "Hmit",
                        "content": "[@adam-hoelscher](/adam-hoelscher) Actually, n log(n)^2"
                    },
                    {
                        "username": "adam-hoelscher",
                        "content": "`O(n log n)`"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "The difficulty is definitely inaccurate."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Do not build a trie for this it\\'s very slow"
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "Can anyone please tell me my mistake ??\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> lexicalOrder(int n) {\\n        \\n        stack<int>s;\\n        vector<int>ans;\\n        s.push(1);\\n        ans.push_back(1);\\n\\n        while(!s.empty()) {\\n            \\n            while(s.top()*10 <= n) {\\n                ans.push_back(s.top()*10);\\n                s.push(s.top()*10);\\n            }\\n\\n            while(s.top() + 1 <= n && (s.top() + 1)%10 != 0) {\\n              \\n                int update = s.top();\\n                update++;\\n                s.pop();\\n                s.push(update);\\n                ans.push_back(update);\\n\\n                if((update + 1)%10 == 0) break;\\n\\n            }\\n\\n            \\n            s.pop();\\n\\n         \\n            if(s.empty())break;\\n            \\n            int last = s.top();\\n            s.pop();\\n            s.push(last + 1);\\n            ans.push_back(last + 1); \\n\\n        }\\n\\n\\n        return ans;\\n\\n    }\\n};"
                    },
                    {
                        "username": "Hmit",
                        "content": "Well, n takes up O(log n) space to write. So O(n logn) is probably good enough?"
                    },
                    {
                        "username": "keshav-Aggarwal_001",
                        "content": "class Solution {\\npublic:\\n    static bool comp(string &a , string &b){\\n        return lexicographical_compare(a.begin() , a.end() , b.begin() , b.end());\\n    }\\n    vector<int> lexicalOrder(int n) {\\n        vector<string> st;\\n        vector<int> ans;\\n        for(int i=1;i <= n;i++) st.push_back(to_string(i));\\n        sort(st.begin() , st.end() , comp);\\n        for(auto it: st) ans.push_back(stoi(it));\\n        return ans;\\n    }\\n};\\n\\nConstraints here are in my code\\'s favour . \\uD83D\\uDE01 using stl , everything is easy ."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/386_Lexicographical_Numbers.cpp"
                    }
                ]
            },
            {
                "id": 2076988,
                "content": [
                    {
                        "username": "wong2333",
                        "content": "![0_1480987480523_upload-12fc3406-aae6-484c-a653-1fa91e5f2ec5](/uploads/files/1480987290472-upload-12fc3406-aae6-484c-a653-1fa91e5f2ec5.png) \\n\\nwe can imagine such a tree, out task is to traversal it with DFS, and collect numbers along the way: 1, 10, 100, ... you get it. When we encounter a number larger than `n`, we can return back to the previous   level. \\n\\nHope it helps"
                    },
                    {
                        "username": "jstephenj14",
                        "content": "super helpful, thanks!\\n"
                    },
                    {
                        "username": "aalmos",
                        "content": "The recursive solutions are not `O(1)` extra space."
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "yes it should be O(N) !!"
                    },
                    {
                        "username": "zplu",
                        "content": "return sorted(str(num) for num in list(range(1, n + 1)))"
                    },
                    {
                        "username": "adam-hoelscher",
                        "content": "[@Hmit](/Hmit)\n`range` is $$O(1)$$\n`list` is $$O(n)$$\n`(str(num) for num in ...)` is $$O(n)$$\n`sorted` is $$O(nlog(n))$$\n\nThe total is $$O(nlog(n))$$"
                    },
                    {
                        "username": "Hmit",
                        "content": "[@adam-hoelscher](/adam-hoelscher) Actually, n log(n)^2"
                    },
                    {
                        "username": "adam-hoelscher",
                        "content": "`O(n log n)`"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "The difficulty is definitely inaccurate."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Do not build a trie for this it\\'s very slow"
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "Can anyone please tell me my mistake ??\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> lexicalOrder(int n) {\\n        \\n        stack<int>s;\\n        vector<int>ans;\\n        s.push(1);\\n        ans.push_back(1);\\n\\n        while(!s.empty()) {\\n            \\n            while(s.top()*10 <= n) {\\n                ans.push_back(s.top()*10);\\n                s.push(s.top()*10);\\n            }\\n\\n            while(s.top() + 1 <= n && (s.top() + 1)%10 != 0) {\\n              \\n                int update = s.top();\\n                update++;\\n                s.pop();\\n                s.push(update);\\n                ans.push_back(update);\\n\\n                if((update + 1)%10 == 0) break;\\n\\n            }\\n\\n            \\n            s.pop();\\n\\n         \\n            if(s.empty())break;\\n            \\n            int last = s.top();\\n            s.pop();\\n            s.push(last + 1);\\n            ans.push_back(last + 1); \\n\\n        }\\n\\n\\n        return ans;\\n\\n    }\\n};"
                    },
                    {
                        "username": "Hmit",
                        "content": "Well, n takes up O(log n) space to write. So O(n logn) is probably good enough?"
                    },
                    {
                        "username": "keshav-Aggarwal_001",
                        "content": "class Solution {\\npublic:\\n    static bool comp(string &a , string &b){\\n        return lexicographical_compare(a.begin() , a.end() , b.begin() , b.end());\\n    }\\n    vector<int> lexicalOrder(int n) {\\n        vector<string> st;\\n        vector<int> ans;\\n        for(int i=1;i <= n;i++) st.push_back(to_string(i));\\n        sort(st.begin() , st.end() , comp);\\n        for(auto it: st) ans.push_back(stoi(it));\\n        return ans;\\n    }\\n};\\n\\nConstraints here are in my code\\'s favour . \\uD83D\\uDE01 using stl , everything is easy ."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/386_Lexicographical_Numbers.cpp"
                    }
                ]
            },
            {
                "id": 2037937,
                "content": [
                    {
                        "username": "wong2333",
                        "content": "![0_1480987480523_upload-12fc3406-aae6-484c-a653-1fa91e5f2ec5](/uploads/files/1480987290472-upload-12fc3406-aae6-484c-a653-1fa91e5f2ec5.png) \\n\\nwe can imagine such a tree, out task is to traversal it with DFS, and collect numbers along the way: 1, 10, 100, ... you get it. When we encounter a number larger than `n`, we can return back to the previous   level. \\n\\nHope it helps"
                    },
                    {
                        "username": "jstephenj14",
                        "content": "super helpful, thanks!\\n"
                    },
                    {
                        "username": "aalmos",
                        "content": "The recursive solutions are not `O(1)` extra space."
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "yes it should be O(N) !!"
                    },
                    {
                        "username": "zplu",
                        "content": "return sorted(str(num) for num in list(range(1, n + 1)))"
                    },
                    {
                        "username": "adam-hoelscher",
                        "content": "[@Hmit](/Hmit)\n`range` is $$O(1)$$\n`list` is $$O(n)$$\n`(str(num) for num in ...)` is $$O(n)$$\n`sorted` is $$O(nlog(n))$$\n\nThe total is $$O(nlog(n))$$"
                    },
                    {
                        "username": "Hmit",
                        "content": "[@adam-hoelscher](/adam-hoelscher) Actually, n log(n)^2"
                    },
                    {
                        "username": "adam-hoelscher",
                        "content": "`O(n log n)`"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "The difficulty is definitely inaccurate."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Do not build a trie for this it\\'s very slow"
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "Can anyone please tell me my mistake ??\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> lexicalOrder(int n) {\\n        \\n        stack<int>s;\\n        vector<int>ans;\\n        s.push(1);\\n        ans.push_back(1);\\n\\n        while(!s.empty()) {\\n            \\n            while(s.top()*10 <= n) {\\n                ans.push_back(s.top()*10);\\n                s.push(s.top()*10);\\n            }\\n\\n            while(s.top() + 1 <= n && (s.top() + 1)%10 != 0) {\\n              \\n                int update = s.top();\\n                update++;\\n                s.pop();\\n                s.push(update);\\n                ans.push_back(update);\\n\\n                if((update + 1)%10 == 0) break;\\n\\n            }\\n\\n            \\n            s.pop();\\n\\n         \\n            if(s.empty())break;\\n            \\n            int last = s.top();\\n            s.pop();\\n            s.push(last + 1);\\n            ans.push_back(last + 1); \\n\\n        }\\n\\n\\n        return ans;\\n\\n    }\\n};"
                    },
                    {
                        "username": "Hmit",
                        "content": "Well, n takes up O(log n) space to write. So O(n logn) is probably good enough?"
                    },
                    {
                        "username": "keshav-Aggarwal_001",
                        "content": "class Solution {\\npublic:\\n    static bool comp(string &a , string &b){\\n        return lexicographical_compare(a.begin() , a.end() , b.begin() , b.end());\\n    }\\n    vector<int> lexicalOrder(int n) {\\n        vector<string> st;\\n        vector<int> ans;\\n        for(int i=1;i <= n;i++) st.push_back(to_string(i));\\n        sort(st.begin() , st.end() , comp);\\n        for(auto it: st) ans.push_back(stoi(it));\\n        return ans;\\n    }\\n};\\n\\nConstraints here are in my code\\'s favour . \\uD83D\\uDE01 using stl , everything is easy ."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/386_Lexicographical_Numbers.cpp"
                    }
                ]
            },
            {
                "id": 1954742,
                "content": [
                    {
                        "username": "wong2333",
                        "content": "![0_1480987480523_upload-12fc3406-aae6-484c-a653-1fa91e5f2ec5](/uploads/files/1480987290472-upload-12fc3406-aae6-484c-a653-1fa91e5f2ec5.png) \\n\\nwe can imagine such a tree, out task is to traversal it with DFS, and collect numbers along the way: 1, 10, 100, ... you get it. When we encounter a number larger than `n`, we can return back to the previous   level. \\n\\nHope it helps"
                    },
                    {
                        "username": "jstephenj14",
                        "content": "super helpful, thanks!\\n"
                    },
                    {
                        "username": "aalmos",
                        "content": "The recursive solutions are not `O(1)` extra space."
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "yes it should be O(N) !!"
                    },
                    {
                        "username": "zplu",
                        "content": "return sorted(str(num) for num in list(range(1, n + 1)))"
                    },
                    {
                        "username": "adam-hoelscher",
                        "content": "[@Hmit](/Hmit)\n`range` is $$O(1)$$\n`list` is $$O(n)$$\n`(str(num) for num in ...)` is $$O(n)$$\n`sorted` is $$O(nlog(n))$$\n\nThe total is $$O(nlog(n))$$"
                    },
                    {
                        "username": "Hmit",
                        "content": "[@adam-hoelscher](/adam-hoelscher) Actually, n log(n)^2"
                    },
                    {
                        "username": "adam-hoelscher",
                        "content": "`O(n log n)`"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "The difficulty is definitely inaccurate."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Do not build a trie for this it\\'s very slow"
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "Can anyone please tell me my mistake ??\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> lexicalOrder(int n) {\\n        \\n        stack<int>s;\\n        vector<int>ans;\\n        s.push(1);\\n        ans.push_back(1);\\n\\n        while(!s.empty()) {\\n            \\n            while(s.top()*10 <= n) {\\n                ans.push_back(s.top()*10);\\n                s.push(s.top()*10);\\n            }\\n\\n            while(s.top() + 1 <= n && (s.top() + 1)%10 != 0) {\\n              \\n                int update = s.top();\\n                update++;\\n                s.pop();\\n                s.push(update);\\n                ans.push_back(update);\\n\\n                if((update + 1)%10 == 0) break;\\n\\n            }\\n\\n            \\n            s.pop();\\n\\n         \\n            if(s.empty())break;\\n            \\n            int last = s.top();\\n            s.pop();\\n            s.push(last + 1);\\n            ans.push_back(last + 1); \\n\\n        }\\n\\n\\n        return ans;\\n\\n    }\\n};"
                    },
                    {
                        "username": "Hmit",
                        "content": "Well, n takes up O(log n) space to write. So O(n logn) is probably good enough?"
                    },
                    {
                        "username": "keshav-Aggarwal_001",
                        "content": "class Solution {\\npublic:\\n    static bool comp(string &a , string &b){\\n        return lexicographical_compare(a.begin() , a.end() , b.begin() , b.end());\\n    }\\n    vector<int> lexicalOrder(int n) {\\n        vector<string> st;\\n        vector<int> ans;\\n        for(int i=1;i <= n;i++) st.push_back(to_string(i));\\n        sort(st.begin() , st.end() , comp);\\n        for(auto it: st) ans.push_back(stoi(it));\\n        return ans;\\n    }\\n};\\n\\nConstraints here are in my code\\'s favour . \\uD83D\\uDE01 using stl , everything is easy ."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/386_Lexicographical_Numbers.cpp"
                    }
                ]
            },
            {
                "id": 1939001,
                "content": [
                    {
                        "username": "wong2333",
                        "content": "![0_1480987480523_upload-12fc3406-aae6-484c-a653-1fa91e5f2ec5](/uploads/files/1480987290472-upload-12fc3406-aae6-484c-a653-1fa91e5f2ec5.png) \\n\\nwe can imagine such a tree, out task is to traversal it with DFS, and collect numbers along the way: 1, 10, 100, ... you get it. When we encounter a number larger than `n`, we can return back to the previous   level. \\n\\nHope it helps"
                    },
                    {
                        "username": "jstephenj14",
                        "content": "super helpful, thanks!\\n"
                    },
                    {
                        "username": "aalmos",
                        "content": "The recursive solutions are not `O(1)` extra space."
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "yes it should be O(N) !!"
                    },
                    {
                        "username": "zplu",
                        "content": "return sorted(str(num) for num in list(range(1, n + 1)))"
                    },
                    {
                        "username": "adam-hoelscher",
                        "content": "[@Hmit](/Hmit)\n`range` is $$O(1)$$\n`list` is $$O(n)$$\n`(str(num) for num in ...)` is $$O(n)$$\n`sorted` is $$O(nlog(n))$$\n\nThe total is $$O(nlog(n))$$"
                    },
                    {
                        "username": "Hmit",
                        "content": "[@adam-hoelscher](/adam-hoelscher) Actually, n log(n)^2"
                    },
                    {
                        "username": "adam-hoelscher",
                        "content": "`O(n log n)`"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "The difficulty is definitely inaccurate."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Do not build a trie for this it\\'s very slow"
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "Can anyone please tell me my mistake ??\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> lexicalOrder(int n) {\\n        \\n        stack<int>s;\\n        vector<int>ans;\\n        s.push(1);\\n        ans.push_back(1);\\n\\n        while(!s.empty()) {\\n            \\n            while(s.top()*10 <= n) {\\n                ans.push_back(s.top()*10);\\n                s.push(s.top()*10);\\n            }\\n\\n            while(s.top() + 1 <= n && (s.top() + 1)%10 != 0) {\\n              \\n                int update = s.top();\\n                update++;\\n                s.pop();\\n                s.push(update);\\n                ans.push_back(update);\\n\\n                if((update + 1)%10 == 0) break;\\n\\n            }\\n\\n            \\n            s.pop();\\n\\n         \\n            if(s.empty())break;\\n            \\n            int last = s.top();\\n            s.pop();\\n            s.push(last + 1);\\n            ans.push_back(last + 1); \\n\\n        }\\n\\n\\n        return ans;\\n\\n    }\\n};"
                    },
                    {
                        "username": "Hmit",
                        "content": "Well, n takes up O(log n) space to write. So O(n logn) is probably good enough?"
                    },
                    {
                        "username": "keshav-Aggarwal_001",
                        "content": "class Solution {\\npublic:\\n    static bool comp(string &a , string &b){\\n        return lexicographical_compare(a.begin() , a.end() , b.begin() , b.end());\\n    }\\n    vector<int> lexicalOrder(int n) {\\n        vector<string> st;\\n        vector<int> ans;\\n        for(int i=1;i <= n;i++) st.push_back(to_string(i));\\n        sort(st.begin() , st.end() , comp);\\n        for(auto it: st) ans.push_back(stoi(it));\\n        return ans;\\n    }\\n};\\n\\nConstraints here are in my code\\'s favour . \\uD83D\\uDE01 using stl , everything is easy ."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/386_Lexicographical_Numbers.cpp"
                    }
                ]
            },
            {
                "id": 1935809,
                "content": [
                    {
                        "username": "wong2333",
                        "content": "![0_1480987480523_upload-12fc3406-aae6-484c-a653-1fa91e5f2ec5](/uploads/files/1480987290472-upload-12fc3406-aae6-484c-a653-1fa91e5f2ec5.png) \\n\\nwe can imagine such a tree, out task is to traversal it with DFS, and collect numbers along the way: 1, 10, 100, ... you get it. When we encounter a number larger than `n`, we can return back to the previous   level. \\n\\nHope it helps"
                    },
                    {
                        "username": "jstephenj14",
                        "content": "super helpful, thanks!\\n"
                    },
                    {
                        "username": "aalmos",
                        "content": "The recursive solutions are not `O(1)` extra space."
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "yes it should be O(N) !!"
                    },
                    {
                        "username": "zplu",
                        "content": "return sorted(str(num) for num in list(range(1, n + 1)))"
                    },
                    {
                        "username": "adam-hoelscher",
                        "content": "[@Hmit](/Hmit)\n`range` is $$O(1)$$\n`list` is $$O(n)$$\n`(str(num) for num in ...)` is $$O(n)$$\n`sorted` is $$O(nlog(n))$$\n\nThe total is $$O(nlog(n))$$"
                    },
                    {
                        "username": "Hmit",
                        "content": "[@adam-hoelscher](/adam-hoelscher) Actually, n log(n)^2"
                    },
                    {
                        "username": "adam-hoelscher",
                        "content": "`O(n log n)`"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "The difficulty is definitely inaccurate."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Do not build a trie for this it\\'s very slow"
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "Can anyone please tell me my mistake ??\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> lexicalOrder(int n) {\\n        \\n        stack<int>s;\\n        vector<int>ans;\\n        s.push(1);\\n        ans.push_back(1);\\n\\n        while(!s.empty()) {\\n            \\n            while(s.top()*10 <= n) {\\n                ans.push_back(s.top()*10);\\n                s.push(s.top()*10);\\n            }\\n\\n            while(s.top() + 1 <= n && (s.top() + 1)%10 != 0) {\\n              \\n                int update = s.top();\\n                update++;\\n                s.pop();\\n                s.push(update);\\n                ans.push_back(update);\\n\\n                if((update + 1)%10 == 0) break;\\n\\n            }\\n\\n            \\n            s.pop();\\n\\n         \\n            if(s.empty())break;\\n            \\n            int last = s.top();\\n            s.pop();\\n            s.push(last + 1);\\n            ans.push_back(last + 1); \\n\\n        }\\n\\n\\n        return ans;\\n\\n    }\\n};"
                    },
                    {
                        "username": "Hmit",
                        "content": "Well, n takes up O(log n) space to write. So O(n logn) is probably good enough?"
                    },
                    {
                        "username": "keshav-Aggarwal_001",
                        "content": "class Solution {\\npublic:\\n    static bool comp(string &a , string &b){\\n        return lexicographical_compare(a.begin() , a.end() , b.begin() , b.end());\\n    }\\n    vector<int> lexicalOrder(int n) {\\n        vector<string> st;\\n        vector<int> ans;\\n        for(int i=1;i <= n;i++) st.push_back(to_string(i));\\n        sort(st.begin() , st.end() , comp);\\n        for(auto it: st) ans.push_back(stoi(it));\\n        return ans;\\n    }\\n};\\n\\nConstraints here are in my code\\'s favour . \\uD83D\\uDE01 using stl , everything is easy ."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/386_Lexicographical_Numbers.cpp"
                    }
                ]
            },
            {
                "id": 1766101,
                "content": [
                    {
                        "username": "wong2333",
                        "content": "![0_1480987480523_upload-12fc3406-aae6-484c-a653-1fa91e5f2ec5](/uploads/files/1480987290472-upload-12fc3406-aae6-484c-a653-1fa91e5f2ec5.png) \\n\\nwe can imagine such a tree, out task is to traversal it with DFS, and collect numbers along the way: 1, 10, 100, ... you get it. When we encounter a number larger than `n`, we can return back to the previous   level. \\n\\nHope it helps"
                    },
                    {
                        "username": "jstephenj14",
                        "content": "super helpful, thanks!\\n"
                    },
                    {
                        "username": "aalmos",
                        "content": "The recursive solutions are not `O(1)` extra space."
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "yes it should be O(N) !!"
                    },
                    {
                        "username": "zplu",
                        "content": "return sorted(str(num) for num in list(range(1, n + 1)))"
                    },
                    {
                        "username": "adam-hoelscher",
                        "content": "[@Hmit](/Hmit)\n`range` is $$O(1)$$\n`list` is $$O(n)$$\n`(str(num) for num in ...)` is $$O(n)$$\n`sorted` is $$O(nlog(n))$$\n\nThe total is $$O(nlog(n))$$"
                    },
                    {
                        "username": "Hmit",
                        "content": "[@adam-hoelscher](/adam-hoelscher) Actually, n log(n)^2"
                    },
                    {
                        "username": "adam-hoelscher",
                        "content": "`O(n log n)`"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "The difficulty is definitely inaccurate."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Do not build a trie for this it\\'s very slow"
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "Can anyone please tell me my mistake ??\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> lexicalOrder(int n) {\\n        \\n        stack<int>s;\\n        vector<int>ans;\\n        s.push(1);\\n        ans.push_back(1);\\n\\n        while(!s.empty()) {\\n            \\n            while(s.top()*10 <= n) {\\n                ans.push_back(s.top()*10);\\n                s.push(s.top()*10);\\n            }\\n\\n            while(s.top() + 1 <= n && (s.top() + 1)%10 != 0) {\\n              \\n                int update = s.top();\\n                update++;\\n                s.pop();\\n                s.push(update);\\n                ans.push_back(update);\\n\\n                if((update + 1)%10 == 0) break;\\n\\n            }\\n\\n            \\n            s.pop();\\n\\n         \\n            if(s.empty())break;\\n            \\n            int last = s.top();\\n            s.pop();\\n            s.push(last + 1);\\n            ans.push_back(last + 1); \\n\\n        }\\n\\n\\n        return ans;\\n\\n    }\\n};"
                    },
                    {
                        "username": "Hmit",
                        "content": "Well, n takes up O(log n) space to write. So O(n logn) is probably good enough?"
                    },
                    {
                        "username": "keshav-Aggarwal_001",
                        "content": "class Solution {\\npublic:\\n    static bool comp(string &a , string &b){\\n        return lexicographical_compare(a.begin() , a.end() , b.begin() , b.end());\\n    }\\n    vector<int> lexicalOrder(int n) {\\n        vector<string> st;\\n        vector<int> ans;\\n        for(int i=1;i <= n;i++) st.push_back(to_string(i));\\n        sort(st.begin() , st.end() , comp);\\n        for(auto it: st) ans.push_back(stoi(it));\\n        return ans;\\n    }\\n};\\n\\nConstraints here are in my code\\'s favour . \\uD83D\\uDE01 using stl , everything is easy ."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/386_Lexicographical_Numbers.cpp"
                    }
                ]
            }
        ]
    },
    {
        "title": "Predict the Winner",
        "question_content": "<p>You are given an integer array <code>nums</code>. Two players are playing a game with this array: player 1 and player 2.</p>\n\n<p>Player 1 and player 2 take turns, with player 1 starting first. Both players start the game with a score of <code>0</code>. At each turn, the player takes one of the numbers from either end of the array (i.e., <code>nums[0]</code> or <code>nums[nums.length - 1]</code>) which reduces the size of the array by <code>1</code>. The player adds the chosen number to their score. The game ends when there are no more elements in the array.</p>\n\n<p>Return <code>true</code> if Player 1 can win the game. If the scores of both players are equal, then player 1 is still the winner, and you should also return <code>true</code>. You may assume that both players are playing optimally.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,5,2]\n<strong>Output:</strong> false\n<strong>Explanation:</strong> Initially, player 1 can choose between 1 and 2. \nIf he chooses 2 (or 1), then player 2 can choose from 1 (or 2) and 5. If player 2 chooses 5, then player 1 will be left with 1 (or 2). \nSo, final score of player 1 is 1 + 2 = 3, and player 2 is 5. \nHence, player 1 will never be the winner and you need to return false.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,5,233,7]\n<strong>Output:</strong> true\n<strong>Explanation:</strong> Player 1 first chooses 1. Then player 2 has to choose between 5 and 7. No matter which number player 2 choose, player 1 can choose 233.\nFinally, player 1 has more score (234) than player 2 (12), so you need to return True representing player1 can win.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 20</code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 10<sup>7</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 96828,
                "title": "java-9-lines-dp-solution-easy-to-understand-with-improvement-to-o-n-space-complexity",
                "content": "The dp[i][j] saves how much ***more*** scores that the first-in-action player will get from i to j than the second player. First-in-action means whomever moves first. You can still make the code even shorter but I think it looks clean in this way.\\n\\n    public boolean PredictTheWinner(int[] nums) {\\n        int n = nums.length;\\n        int[][] dp = new int[n][n];\\n        for (int i = 0; i < n; i++) { dp[i][i] = nums[i]; }\\n        for (int len = 1; len < n; len++) {\\n            for (int i = 0; i < n - len; i++) {\\n                int j = i + len;\\n                dp[i][j] = Math.max(nums[i] - dp[i + 1][j], nums[j] - dp[i][j - 1]);\\n            }\\n        }\\n        return dp[0][n - 1] >= 0;\\n    }\\n\\nHere is the code for O(N) space complexity:\\n```\\n\\npublic boolean PredictTheWinner(int[] nums) {\\n    if (nums == null) { return true; }\\n    int n = nums.length;\\n    if ((n & 1) == 0) { return true; } // Improved with hot13399's comment.\\n    int[] dp = new int[n];\\n    for (int i = n - 1; i >= 0; i--) {\\n        for (int j = i; j < n; j++) {\\n            if (i == j) {\\n                dp[i] = nums[i];\\n            } else {\\n                dp[j] = Math.max(nums[i] - dp[j], nums[j] - dp[j - 1]);\\n            }\\n        }\\n    }\\n    return dp[n - 1] >= 0;\\n}\\n\\n```\\n\\nEdit : Since I have some time now, I will explain how I come up with this solution step by step:\\n\\n1, The first step is to break the question into the sub-problems that we can program. From the question, the winning goal is that \"The player with the maximum score wins\". So one way to approach it is that we may want to find a way to maximize player 1's sum and check if it is greater than player 2's sum (or more than half of the sum of all numbers). Another way, after noting that the sum of all numbers is fixed, I realized that it doesn't matter how much player 1's total sum is as long as the sum is no less than player 2's sum. No matter how, I think we can easily recognize that it is a recursive problem where we may use the status on one step to calculate the answer for the next step. It is a common way to solve game problems. So we may start with using a brutal force recursive method to solve this one.\\n\\n2, However, we always want to do better than brutal force. We may easily notice that there will be lots of redundant calculation. For example, \"player 1 picks left, then player 2 picks left, then player 1 picks right, then player 2 picks right\" will end up the same as \"player 1 picks right, then player 2 picks right, then player 1 picks left, then player 2 picks left\". So, we may want to use dynamic programming to save intermediate states.\\n\\n3, I think it will be easy to think about using a two dimensional array dp[i][j] to save all the intermediate states. From step 1, we may see at least two ways of doing it. It just turned out that if we choose to save how much more scores that the first-in-action player will earn from position i to j in the array (as I did), the code will be better in a couple of ways.\\n\\n4, After we decide that dp[i][j] saves how much more scores that the first-in-action player will get from i to j than the second player, the next step is how we update the dp table from one state to the next. Going back to the question, each player can pick one number either from the left or the right end of the array. Suppose they are picking up numbers from position i to j in the array and it is player A's turn to pick the number now. If player A picks position i, player A will earn nums[i] score instantly. Then player B will choose from i + 1 to j. Please note that dp[i + 1][j] already saves how much more score that the first-in-action player will get from i + 1 to j than the second player. So it means that player B will eventually earn dp[i + 1][j] more score from i + 1 to j than player A. So if player A picks position i, eventually player A will get nums[i] - dp[i + 1][j] more score than player B after they pick up all numbers. Similarly, if player A picks position j, player A will earn nums[j] - dp[i][j - 1] more score than player B after they pick up all numbers. Since A is smart, A will always choose the max in those two options, so:\\ndp[i][j] = Math.max(nums[i] - dp[i + 1][j], nums[j] - dp[i][j - 1]);\\n\\n5, Now we have the recursive formula, the next step is to decide where it all starts. This step is easy because we can easily recognize that we can start from dp[i][i], where dp[i][i] = nums[i]. Then the process becomes a very commonly seen process to update the dp table. I promise that this is a very useful process. Everyone who is preparing for interviews should get comfortable with this process:\\nUsing a 5 x 5 dp table as an example, where i is the row number and j is the column number. Each dp[i][j] corresponds to a block at row i, column j on the table. We may start from filling dp[i][i], which are all the diagonal blocks. I marked them as 1. Then we can see that each dp[i][j] depends only on dp[i + 1][j] and dp[i][j - 1]. On the table, it means each block (i, j) only depends on the block to its left (i, j - 1) and to its down (i + 1, j). So after filling all the blocks marked as 1, we can start to calculate those blocks marked as 2. After that, all blocks marked as 3 and so on.\\n![0_1488092542752_dp.jpg](/uploads/files/1488092557587-dp.jpg) \\nSo in my code, I always use len to denote how far the block is away from the diagonal. So len ranges from 1 to n - 1. Remember this is the outer loop. The inner loop is all valid i positions. After filling all the upper side of the table, we will get our answer at dp[0][n - 1] (marked as 5). This is the end of my code.\\n\\n6. However, if you are interviewing with a good company, they may challenge you to further improve your code, probably in the aspect of space complexity. So far, we are using a n x n matrix so the space complexity is O(n^2). It actually can be improved to O(n). That can be done by changing our way of filling the table. We may use only one dimensional dp[i] and we start to fill the table at the bottom right corner where dp[4] = nums[4]. On the next step, we start to fill the second to the last line, where it starts from dp[3] = nums[3]. Then dp[4] = Math.max(nums[4] - dp[3], nums[3] - dp[4]). Then we fill the third to the last line where dp[2] = nums[2] and so on... Eventually after we fill the first line and after the filling, dp[4] will be the answer.\\n\\n7. On a related note, whenever we do sum, subtract, multiply or divide of integers, we might need to think about overflow. It doesn't seem to be a point to check for this question. However, we may want to consider using long instead of int for some cases. Further, in my way of code dp[i][j] roughly varies around zero or at least it doesn't always increases with approaching the upper right corner. So it will be less likely to overflow.",
                "solutionTags": [],
                "code": "```\\n\\npublic boolean PredictTheWinner(int[] nums) {\\n    if (nums == null) { return true; }\\n    int n = nums.length;\\n    if ((n & 1) == 0) { return true; } // Improved with hot13399's comment.\\n    int[] dp = new int[n];\\n    for (int i = n - 1; i >= 0; i--) {\\n        for (int j = i; j < n; j++) {\\n            if (i == j) {\\n                dp[i] = nums[i];\\n            } else {\\n                dp[j] = Math.max(nums[i] - dp[j], nums[j] - dp[j - 1]);\\n            }\\n        }\\n    }\\n    return dp[n - 1] >= 0;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 155217,
                "title": "from-brute-force-to-top-down-dp",
                "content": "### Brute Force\\n\\nLet\\'s build the search tree first, take `nums = [3, 2, 4]` for example,\\n```\\n [3,2,4]\\n   3/\\\\4---------- 1st player\\'s decision\\n[2,4] [3,2]\\n2/ \\\\4  3/ \\\\2----- 2nd player\\'s decision\\n[4][2] [2][3]\\n\\ncurrently 1st with choosable i, j,\\n        1.if 1st picks nums[i], 2nd can pick either ends of nums[i + 1, j]\\n            a.if 2nd picks nums[i + 1], 1st can pick either ends of nums[i + 2, j]\\n            b.if 2nd picks nums[j], 1st can pick either ends of nums[i + 1, j - 1]\\n            since 2nd plays to maximize his score, 1st can get nums[i] + min(1.a, 1.b)\\n\\t\\t\\t\\t\\t\\t\\n        2.if 1st picks nums[j], 2nd can pick either ends of nums[i, j - 1]\\n            a.if 2nd picks nums[i], 1st can pick either ends of nums[i + 1, j - 1];\\n            b.if 2nd picks nums[j - 1], 1st can pick either ends of nums[i, j - 2];\\n            since 2nd plays to maximize his score, 1st can get nums[j] + min(2.a, 2.b)\\n        \\n        since the 1st plays to maximize his score, 1st can get max(nums[i] + min(1.a, 1.b), nums[j] + min(2.a, 2.b));\\n```\\n\\n```\\nclass Solution {\\n    public boolean PredictTheWinner(int[] nums) {\\n        \\n        int scoreFirst = predictTheWinnerFrom(nums, 0, nums.length - 1);\\n        int scoreTotal = getTotalScores(nums);\\n        \\n        // Compare final scores of two players.\\n        return scoreFirst >= scoreTotal - scoreFirst;\\n    }\\n    \\n    private int predictTheWinnerFrom(int[] nums, int i, int j) {\\n        if (i > j) {\\n            return 0;\\n        }\\n        if (i == j) {\\n            return nums[i];\\n        }\\n        \\n        int curScore = Math.max(\\n            nums[i] + Math.min(\\n                predictTheWinnerFrom(nums, i + 2, j), \\n                predictTheWinnerFrom(nums, i + 1, j - 1)\\n            ),\\n            nums[j] + Math.min(\\n                predictTheWinnerFrom(nums, i, j - 2), \\n                predictTheWinnerFrom(nums, i + 1, j - 1)\\n            )\\n        );   \\n        return curScore;\\n    }\\n    \\n    private int getTotalScores (int[] nums) {\\n        int scoreTotal = 0;\\n        for (int num : nums) {\\n            scoreTotal += num;\\n        }\\n        \\n        return scoreTotal;\\n    }\\n}\\n```\\n\\n### Top-down DP\\nTo overcome overlapping subproblems, we use memoization.\\n```\\nclass Solution {\\n    public boolean PredictTheWinner(int[] nums) {\\n        int[][] memo = buildMemo(nums.length);\\n        \\n        int scoreFirst = predictTheWinnerFrom(nums, 0, nums.length - 1, memo);\\n        \\n        int scoreTotal = getTotalScores(nums);\\n        \\n        return scoreFirst >= scoreTotal - scoreFirst;\\n    }\\n    \\n    private int predictTheWinnerFrom(int[] nums, int i, int j, int[][] memo) {\\n        if (i > j) {\\n            return 0;\\n        }\\n        \\n        if (i == j) {\\n            return nums[i];\\n        }\\n        \\n        if (memo[i][j] != -1) {\\n            return memo[i][j];\\n        }\\n        \\n        int curScore = Math.max(\\n            nums[i] + Math.min(\\n                predictTheWinnerFrom(nums, i + 2, j, memo), \\n                predictTheWinnerFrom(nums, i + 1, j - 1, memo)\\n            ),\\n            nums[j] + Math.min(\\n                predictTheWinnerFrom(nums, i, j - 2, memo), \\n                predictTheWinnerFrom(nums, i + 1, j - 1, memo)\\n            )\\n        );   \\n        \\n        return memo[i][j] = curScore;\\n    }\\n    \\n    private int getTotalScores (int[] nums) {\\n        int scoreTotal = 0;\\n        for (int num : nums) {\\n            scoreTotal += num;\\n        }\\n        \\n        return scoreTotal;\\n    }\\n    \\n    private int[][] buildMemo(int n) {\\n        int[][] memo = new int[n][n];\\n        \\n        for (int[] memoRow : memo)\\n            Arrays.fill(memoRow, -1);\\n        return memo;\\n    }\\n}\\n```\\n\\n**Python**\\n```\\n    def PredictTheWinner(self, nums):\\n        n = len(nums)\\n        memo = [[-1 for x in range(n)] for y in range(n)]      \\n        scoreFirst = self.PredictTheWinnerInSituation(nums, 0, n - 1, memo)\\n        scoreTotal = sum(nums)\\n        return scoreFirst >= scoreTotal - scoreFirst\\n    \\n    def PredictTheWinnerInSituation(self, nums, i, j, memo):\\n        # Base case.\\n        if i > j:\\n            return 0\\n        if i == j:\\n            return nums[i]\\n        if memo[i][j] != -1:\\n            return memo[i][j]\\n        # Recursive case.\\n        curScore = max(nums[i] + min(self.PredictTheWinnerInSituation(nums, i+2, j, memo), self.PredictTheWinnerInSituation(nums, i+1, j-1, memo)), \\n                       nums[j] + min(self.PredictTheWinnerInSituation(nums, i, j-2, memo), self.PredictTheWinnerInSituation(nums, i+1, j-1, memo)))\\n        memo[i][j] = curScore        \\n        return curScore\\n```\\n**(\\u4EBA \\u2022\\u0348\\u1D17\\u2022\\u0348)** Thanks for voting!",
                "solutionTags": [],
                "code": "```\\n [3,2,4]\\n   3/\\\\4---------- 1st player\\'s decision\\n[2,4] [3,2]\\n2/ \\\\4  3/ \\\\2----- 2nd player\\'s decision\\n[4][2] [2][3]\\n\\ncurrently 1st with choosable i, j,\\n        1.if 1st picks nums[i], 2nd can pick either ends of nums[i + 1, j]\\n            a.if 2nd picks nums[i + 1], 1st can pick either ends of nums[i + 2, j]\\n            b.if 2nd picks nums[j], 1st can pick either ends of nums[i + 1, j - 1]\\n            since 2nd plays to maximize his score, 1st can get nums[i] + min(1.a, 1.b)\\n\\t\\t\\t\\t\\t\\t\\n        2.if 1st picks nums[j], 2nd can pick either ends of nums[i, j - 1]\\n            a.if 2nd picks nums[i], 1st can pick either ends of nums[i + 1, j - 1];\\n            b.if 2nd picks nums[j - 1], 1st can pick either ends of nums[i, j - 2];\\n            since 2nd plays to maximize his score, 1st can get nums[j] + min(2.a, 2.b)\\n        \\n        since the 1st plays to maximize his score, 1st can get max(nums[i] + min(1.a, 1.b), nums[j] + min(2.a, 2.b));\\n```\n```\\nclass Solution {\\n    public boolean PredictTheWinner(int[] nums) {\\n        \\n        int scoreFirst = predictTheWinnerFrom(nums, 0, nums.length - 1);\\n        int scoreTotal = getTotalScores(nums);\\n        \\n        // Compare final scores of two players.\\n        return scoreFirst >= scoreTotal - scoreFirst;\\n    }\\n    \\n    private int predictTheWinnerFrom(int[] nums, int i, int j) {\\n        if (i > j) {\\n            return 0;\\n        }\\n        if (i == j) {\\n            return nums[i];\\n        }\\n        \\n        int curScore = Math.max(\\n            nums[i] + Math.min(\\n                predictTheWinnerFrom(nums, i + 2, j), \\n                predictTheWinnerFrom(nums, i + 1, j - 1)\\n            ),\\n            nums[j] + Math.min(\\n                predictTheWinnerFrom(nums, i, j - 2), \\n                predictTheWinnerFrom(nums, i + 1, j - 1)\\n            )\\n        );   \\n        return curScore;\\n    }\\n    \\n    private int getTotalScores (int[] nums) {\\n        int scoreTotal = 0;\\n        for (int num : nums) {\\n            scoreTotal += num;\\n        }\\n        \\n        return scoreTotal;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean PredictTheWinner(int[] nums) {\\n        int[][] memo = buildMemo(nums.length);\\n        \\n        int scoreFirst = predictTheWinnerFrom(nums, 0, nums.length - 1, memo);\\n        \\n        int scoreTotal = getTotalScores(nums);\\n        \\n        return scoreFirst >= scoreTotal - scoreFirst;\\n    }\\n    \\n    private int predictTheWinnerFrom(int[] nums, int i, int j, int[][] memo) {\\n        if (i > j) {\\n            return 0;\\n        }\\n        \\n        if (i == j) {\\n            return nums[i];\\n        }\\n        \\n        if (memo[i][j] != -1) {\\n            return memo[i][j];\\n        }\\n        \\n        int curScore = Math.max(\\n            nums[i] + Math.min(\\n                predictTheWinnerFrom(nums, i + 2, j, memo), \\n                predictTheWinnerFrom(nums, i + 1, j - 1, memo)\\n            ),\\n            nums[j] + Math.min(\\n                predictTheWinnerFrom(nums, i, j - 2, memo), \\n                predictTheWinnerFrom(nums, i + 1, j - 1, memo)\\n            )\\n        );   \\n        \\n        return memo[i][j] = curScore;\\n    }\\n    \\n    private int getTotalScores (int[] nums) {\\n        int scoreTotal = 0;\\n        for (int num : nums) {\\n            scoreTotal += num;\\n        }\\n        \\n        return scoreTotal;\\n    }\\n    \\n    private int[][] buildMemo(int n) {\\n        int[][] memo = new int[n][n];\\n        \\n        for (int[] memoRow : memo)\\n            Arrays.fill(memoRow, -1);\\n        return memo;\\n    }\\n}\\n```\n```\\n    def PredictTheWinner(self, nums):\\n        n = len(nums)\\n        memo = [[-1 for x in range(n)] for y in range(n)]      \\n        scoreFirst = self.PredictTheWinnerInSituation(nums, 0, n - 1, memo)\\n        scoreTotal = sum(nums)\\n        return scoreFirst >= scoreTotal - scoreFirst\\n    \\n    def PredictTheWinnerInSituation(self, nums, i, j, memo):\\n        # Base case.\\n        if i > j:\\n            return 0\\n        if i == j:\\n            return nums[i]\\n        if memo[i][j] != -1:\\n            return memo[i][j]\\n        # Recursive case.\\n        curScore = max(nums[i] + min(self.PredictTheWinnerInSituation(nums, i+2, j, memo), self.PredictTheWinnerInSituation(nums, i+1, j-1, memo)), \\n                       nums[j] + min(self.PredictTheWinnerInSituation(nums, i, j-2, memo), self.PredictTheWinnerInSituation(nums, i+1, j-1, memo)))\\n        memo[i][j] = curScore        \\n        return curScore\\n```",
                "codeTag": "Java"
            },
            {
                "id": 96838,
                "title": "java-1-line-recursive-solution-o-n-2-time-and-o-n-space",
                "content": "Not the most readable solution, but just for fun and for the sake for being able to put all the logic in one line. ;) (I actually think the logic is very clear and not that unreadable..) \\n```\\npublic class Solution {\\n    public boolean PredictTheWinner(int[] nums) {\\n        return helper(nums, 0, nums.length-1)>=0;\\n    }\\n    private int helper(int[] nums, int s, int e){        \\n        return s==e ? nums[e] : Math.max(nums[e] - helper(nums, s, e-1), nums[s] - helper(nums, s+1, e));\\n    }\\n}\\n```\\n\\nInspired by @sameer13, add a cache: \\n```\\npublic class Solution {\\n    public boolean PredictTheWinner(int[] nums) {\\n        return helper(nums, 0, nums.length-1, new Integer[nums.length][nums.length])>=0;\\n    }\\n    private int helper(int[] nums, int s, int e, Integer[][] mem){    \\n        if(mem[s][e]==null)\\n            mem[s][e] = s==e ? nums[e] : Math.max(nums[e]-helper(nums,s,e-1,mem),nums[s]-helper(nums,s+1,e,mem));\\n        return mem[s][e];\\n    }\\n}\\n```\\n\\n**Explanation**\\nSo assuming the sum of the array it SUM, so eventually player1 and player2 will split the SUM between themselves. For player1 to win, he/she has to get more than what player2 gets. If we think from the prospective of one player, then what he/she gains each time is a **plus**, while, what the other player gains each time is a **minus**. Eventually if player1 can have a >0 total, player1 can win. \\n\\nHelper function simulate this process. In each round: \\nif e==s, there is no choice but have to select nums[s]\\notherwise, this current player has 2 options: \\n --> nums[s]-helper(nums,s+1,e): this player select the front item, leaving the other player a choice from s+1 to e\\n --> nums[e]-helper(nums,s,e-1): this player select the tail item, leaving the other player a choice from s to e-1\\nThen take the max of these two options as this player\\'s selection, return it.\\n\\n**complexity**\\nSpace: O(n), the recursive can go as deep as n. \\nTime: Without cache/mem, it is O(2^n), because each node can have 2 children. With cache/mem, it is O(n^2), same as DP, because at most, we will calculate all index * index combinations and others are just read from cache. There are n ^ 2 of possible combinations. ",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public boolean PredictTheWinner(int[] nums) {\\n        return helper(nums, 0, nums.length-1)>=0;\\n    }\\n    private int helper(int[] nums, int s, int e){        \\n        return s==e ? nums[e] : Math.max(nums[e] - helper(nums, s, e-1), nums[s] - helper(nums, s+1, e));\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public boolean PredictTheWinner(int[] nums) {\\n        return helper(nums, 0, nums.length-1, new Integer[nums.length][nums.length])>=0;\\n    }\\n    private int helper(int[] nums, int s, int e, Integer[][] mem){    \\n        if(mem[s][e]==null)\\n            mem[s][e] = s==e ? nums[e] : Math.max(nums[e]-helper(nums,s,e-1,mem),nums[s]-helper(nums,s+1,e,mem));\\n        return mem[s][e];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 96829,
                "title": "dp-o-n-2-mit-ocw-solution-explanation",
                "content": "The idea is that this is a minimax game, and if you went to MIT and took 6.046 then you would have seen something similar to this problem in class.  And thanks to MIT OCW everyone can see the [explanation](https://youtu.be/Tw1k46ywN6E?list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp&t=3622)\\n\\nThe DP solution \\n```\\nclass Solution {\\npublic:\\n    bool PredictTheWinner(vector<int>& nums) {\\n        if(nums.size()% 2 == 0) return true;\\n        \\n        int n = nums.size();\\n        vector<vector<int>> dp(n, vector<int>(n, -1));\\n        \\n        int myBest = utill(nums, dp, 0, n-1);\\n        return 2*myBest >= accumulate(nums.begin(), nums.end(), 0);\\n    }\\n    \\n    int utill(vector<int>& v, vector<vector<int>> &dp, int i, int j){\\n        if(i > j) return 0;\\n        if(dp[i][j] != -1) return dp[i][j];\\n        \\n        int a = v[i] + min(utill(v,dp, i+1, j-1), utill(v, dp, i+2, j));\\n        int b = v[j] + min(utill(v,dp,i, j-2), utill(v,dp, i+1, j-1));\\n        dp[i][j] = max(a, b);\\n                        \\n        return dp[i][j];\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool PredictTheWinner(vector<int>& nums) {\\n        if(nums.size()% 2 == 0) return true;\\n        \\n        int n = nums.size();\\n        vector<vector<int>> dp(n, vector<int>(n, -1));\\n        \\n        int myBest = utill(nums, dp, 0, n-1);\\n        return 2*myBest >= accumulate(nums.begin(), nums.end(), 0);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1625806,
                "title": "100-faster-simple-c-solution-well-explained-dp-recursive",
                "content": "***Please do upvote if you like my explaination so that it can remain on top and help others also***\\n\\nOur basic idea will be to get the max score any player can have, given that both players play optimally.\\n\\n# Recursive Approach\\n**Step1: Assumption**\\nLet the function ***maxScore(...)*** gives the maximum score a player can have if its their turn\\nAnd let ***\\'total\\'*** be the sum of all the elements in the array that is yet to be picked,\\n\\n**Step 2: Main Logic**\\nNow, the maxm any player will be able to get is ***total-maxm the other player can get**.*\\nMathematically maximum we can get is total-maximum the next player can get.\\nNow, we can choose an element either from start or end, it depends on us. But since we are trying to play optimally so we will try to reduce the maximum score of the other player.\\n\\nSo In simple words it will be ***total-min(maxSum when our player chooses starting element ,maxSum when our player chooses ending element)***\\n\\n*so maxSum(...) will depend on the following parameters :*\\n* nums array\\n* starting index(i)\\n* ending index(j)\\n* total\\n\\nNow, for every next player total will be equal to total-(the element we choose)\\n\\n**Step 3: Base Condition**\\nIt will be simplem when i>j we can\\'t evaluate, so we return 0;\\n\\n**Now enough with the theory, lets see it in code**\\n\\n**TC:- O(2^N)** As we have N levels and each level we have 2 choices either to select ith or jth element.\\n\\n**SC: O(N^2)** Recursive stack space.\\n\\n```\\nclass Solution {\\n    bool checkWin(int ans,int total){\\n\\t   //ans=max player 1 can score and total=sum of all elements in the array\\n\\t   //so, player2\\'s score=total-player1\\'s score . ie:-total-ans;\\n\\t   //According to question player1\\'s score should be greater than or equal to player2\\'s score. \\n\\t   return ans>=total-ans;\\n    }\\n    int maxScore(vector<int>&A,int total,int i,int j){\\n        if(i>j) //our base condition\\n            return 0;\\n      return total-min(maxScore(A,total-A[i],i+1,j),maxScore(A,total-A[j],i,j-1)); //max the current player can get is total-maxm the next player can get.\\n    }\\npublic:\\n    bool PredictTheWinner(vector<int>& nums) {\\n        int total=0; \\n\\t\\t//total=sum of all elements in the array\\n        for(auto x:nums)\\n            total+=x;\\n        return checkWin(maxScore(nums,total,0,nums.size()-1),total);\\n    }\\n};\\n```\\n\\n\\n# Memoization (DP)\\n**Step 1: Dp Statement**\\nOur dp[i][j] will contain the maxm a player can score if he has access to elements from i to j only\\n\\n**Step 2: Thats all we will code now :**\\n\\n\\n**TC:- O(N^2)** As we have N^2 dp states and we visit every state only once.\\n\\n**SC: O(N^2)** Dp array size\\n\\n```\\nclass Solution {\\n    int dp[21][21]; //dp array\\n\\t//dp[i][j]= maxm a player can score if they have access to elements form index i to index j only\\n    bool checkWin(int ans,int total){\\n        return ans>=total-ans;\\n    }\\n    int maxScore(vector<int>&A,int total,int i,int j){\\n        if(i>j)\\n            return 0;\\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        dp[i][j]=total-min(maxScore(A,total-A[i],i+1,j),maxScore(A,total-A[j],i,j-1));\\n        return dp[i][j];\\n    }\\npublic:\\n    bool PredictTheWinner(vector<int>& nums) {\\n        int total=0;\\n        for(int i=0;i<21;i++)\\n            for(int j=0;j<21;j++)\\n                dp[i][j]=-1;  //initialising to -1\\n        for(auto x:nums)\\n            total+=x;\\n        return checkWin(maxScore(nums,total,0,nums.size()-1),total);\\n    }\\n};\\n```\\n\\n***I did a lot of hardwork in explaining this. If you like it please do upvote and if you have any query feel free to ask me in the comment section down below.***\\n\\n***Thank you***",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    bool checkWin(int ans,int total){\\n\\t   //ans=max player 1 can score and total=sum of all elements in the array\\n\\t   //so, player2\\'s score=total-player1\\'s score . ie:-total-ans;\\n\\t   //According to question player1\\'s score should be greater than or equal to player2\\'s score. \\n\\t   return ans>=total-ans;\\n    }\\n    int maxScore(vector<int>&A,int total,int i,int j){\\n        if(i>j) //our base condition\\n            return 0;\\n      return total-min(maxScore(A,total-A[i],i+1,j),maxScore(A,total-A[j],i,j-1)); //max the current player can get is total-maxm the next player can get.\\n    }\\npublic:\\n    bool PredictTheWinner(vector<int>& nums) {\\n        int total=0; \\n\\t\\t//total=sum of all elements in the array\\n        for(auto x:nums)\\n            total+=x;\\n        return checkWin(maxScore(nums,total,0,nums.size()-1),total);\\n    }\\n};\\n```\n```\\nclass Solution {\\n    int dp[21][21]; //dp array\\n\\t//dp[i][j]= maxm a player can score if they have access to elements form index i to index j only\\n    bool checkWin(int ans,int total){\\n        return ans>=total-ans;\\n    }\\n    int maxScore(vector<int>&A,int total,int i,int j){\\n        if(i>j)\\n            return 0;\\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        dp[i][j]=total-min(maxScore(A,total-A[i],i+1,j),maxScore(A,total-A[j],i,j-1));\\n        return dp[i][j];\\n    }\\npublic:\\n    bool PredictTheWinner(vector<int>& nums) {\\n        int total=0;\\n        for(int i=0;i<21;i++)\\n            for(int j=0;j<21;j++)\\n                dp[i][j]=-1;  //initialising to -1\\n        for(auto x:nums)\\n            total+=x;\\n        return checkWin(maxScore(nums,total,0,nums.size()-1),total);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 96832,
                "title": "c-dp-solution-with-explanation",
                "content": "Store the maximum score player1 can get for any sub array [i, j]\\n\\nGiven an array ```A[i, j]```, player 1 can either take the first number A[i] or A[j], after that, it forms a new array``` A[i+1, j]``` or ```A[i, j-1]``` accordingly and it is player2's turn to pick up. The maximum score that player1 can get from the the sub arrays will be the larger one left by player2. So,\\n\\nDP formula: \\n```dp(i, j) = max(sum(i, j-1)  - dp(i, j-1) + nums[j], sum(i+1, j) - dp(i+1, j) + nums[i])```\\n\\nBecause  ```sum(i, j-1) + nums[j]  = sum(i, j) = nums[i] + sum(i+1, j)```, the formula can be simplified to\\n```dp(i, j) = max(sum(i, j)  - dp(i, j-1), sum(i, j) - dp(i+1, j))```\\n\\nMore simpler:\\n~~From ```dp(i, j) = max(sum(i, j)  - dp(i, j-1), sum(i, j) - dp(i+1, j))```, each ```dp(i, j)``` contains ```sum(i, j)```, then if we subtract the sum, it should have no impact to final result.~~\\n\\nThanks to @coder2 point out that the mistake of the dp formula deduction. \\n**If we do more deduction, we can eliminate the ```sum(i, j)``` from the formula**:\\nInstead of storing the maximum score that player 1 can get in each sub array, we can store the ```diff``` between player1 and player 2. For example: if player 1 get ```A```, player 2 get ```B```, **we can use ```dp'``` to store ```A-B```**. \\n\\nif ```A = dp(i, j)```, then ```B = sum(i, j) - dp(i, j)```\\n\\nSo ```dp'(i, j)``` =  ```dp(i, j) - ( sum(i, j) - dp(i, j) )``` = ```2*dp(i, j) - sum(i, j)```, so\\n```2*dp(i, j) = dp'(i, j) + sum(i, j)``` (**this will be used below**)\\n\\n```dp'(i, j)``` =  ```dp(i, j) - ( sum(i, j) - dp(i, j) )``` = ```2dp(i, j) - sum(i, j)```\\n= ``` 2 * max( sum(i, j)  - dp(i, j-1), sum(i, j) - dp(i+1, j) ) - sum(i, j)```\\n= ```max(sum(i, j) - 2*dp(i, j-1), sum(i, j) - 2*dp(i+1, j) )```\\n= ```max(sum(i, j) - ( dp'(i, j-1) + sum(i, j-1) ), sum(i, j) - ( dp'(i+1, j) + sum(i+1, j))) ```\\n= ```max(sum(i, j) - sum(i, j-1)  - dp'(i, j-1), sum(i, j) - sum(i+1, j) - dp'(i+1, j))```\\n= ```max(nums[j] - dp'(i, j-1), nums[i] - dp'(i+1, j)) ```\\n\\nFinal formula: ```dp(i, j) = max(nums[j]  - dp(i, j-1), nums[i] - dp(i+1, j))```\\n\\n\\n```\\nclass Solution {\\npublic:\\n    bool PredictTheWinner(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<vector<int>> dp(n, vector<int>(n)); // use to keep the score gap between player1 and player2\\n        for (int i = 0; i < n; i++) dp[i][i] = nums[i];\\n        for (int i = 1; i < n; i++) {\\n            for (int j = 0; j+i < n; j++) {\\n                dp[j][j+i] = max(nums[j+i]-dp[j][j+i-1], nums[j]-dp[j+1][j+i]);\\n            }\\n        }\\n        return dp[0][n-1] >= 0; // player1 get more score points than player2\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```A[i, j]```\n``` A[i+1, j]```\n```A[i, j-1]```\n```dp(i, j) = max(sum(i, j-1)  - dp(i, j-1) + nums[j], sum(i+1, j) - dp(i+1, j) + nums[i])```\n```sum(i, j-1) + nums[j]  = sum(i, j) = nums[i] + sum(i+1, j)```\n```dp(i, j) = max(sum(i, j)  - dp(i, j-1), sum(i, j) - dp(i+1, j))```\n```dp(i, j) = max(sum(i, j)  - dp(i, j-1), sum(i, j) - dp(i+1, j))```\n```dp(i, j)```\n```sum(i, j)```\n```sum(i, j)```\n```diff```\n```A```\n```B```\n```dp'```\n```A-B```\n```A = dp(i, j)```\n```B = sum(i, j) - dp(i, j)```\n```dp'(i, j)```\n```dp(i, j) - ( sum(i, j) - dp(i, j) )```\n```2*dp(i, j) - sum(i, j)```\n```2*dp(i, j) = dp'(i, j) + sum(i, j)```\n```dp'(i, j)```\n```dp(i, j) - ( sum(i, j) - dp(i, j) )```\n```2dp(i, j) - sum(i, j)```\n``` 2 * max( sum(i, j)  - dp(i, j-1), sum(i, j) - dp(i+1, j) ) - sum(i, j)```\n```max(sum(i, j) - 2*dp(i, j-1), sum(i, j) - 2*dp(i+1, j) )```\n```max(sum(i, j) - ( dp'(i, j-1) + sum(i, j-1) ), sum(i, j) - ( dp'(i+1, j) + sum(i+1, j))) ```\n```max(sum(i, j) - sum(i, j-1)  - dp'(i, j-1), sum(i, j) - sum(i+1, j) - dp'(i+1, j))```\n```max(nums[j] - dp'(i, j-1), nums[i] - dp'(i+1, j)) ```\n```dp(i, j) = max(nums[j]  - dp(i, j-1), nums[i] - dp(i+1, j))```\n```\\nclass Solution {\\npublic:\\n    bool PredictTheWinner(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<vector<int>> dp(n, vector<int>(n)); // use to keep the score gap between player1 and player2\\n        for (int i = 0; i < n; i++) dp[i][i] = nums[i];\\n        for (int i = 1; i < n; i++) {\\n            for (int j = 0; j+i < n; j++) {\\n                dp[j][j+i] = max(nums[j+i]-dp[j][j+i-1], nums[j]-dp[j+1][j+i]);\\n            }\\n        }\\n        return dp[0][n-1] >= 0; // player1 get more score points than player2\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 151676,
                "title": "python-dp-with-memorization",
                "content": "Keep track of the difference between player1 and player2. Return True if the difference >= 0 (player1 >= player2)\\n```\\nclass Solution(object):\\n    def PredictTheWinner(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        dp = {}\\n\\n        def find(i, j):\\n            if (i, j) not in dp:\\n                if i == j:\\n                    return nums[i]\\n                dp[i,j] = max(nums[i]-find(i+1, j), nums[j]-find(i, j-1))\\n            return dp[i,j]\\n\\n        return find(0, len(nums)-1) >= 0\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def PredictTheWinner(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        dp = {}\\n\\n        def find(i, j):\\n            if (i, j) not in dp:\\n                if i == j:\\n                    return nums[i]\\n                dp[i,j] = max(nums[i]-find(i+1, j), nums[j]-find(i, j-1))\\n            return dp[i,j]\\n\\n        return find(0, len(nums)-1) >= 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 96875,
                "title": "share-my-9ms-recursive-solution-with-explanation",
                "content": "The main idea is each player will play optimally,\\nso if there exist that my opponent will lose the game (false), I will return true, that's why I use '!' in the return;\\n\\nFor example : [1, 5, 2]\\n```\\nif (player1 pick 1) the rest is [5, 2];\\n\\tif (player2 pick 2) player1 win(true),\\n\\tif (player2 pick 5) player1 lose(false),\\n-> because player2 play optimally, so he choose to pick 5,\\n   player2 = !(pick 2) || !(pick 5)  = !true || !false = true;\\n   so when player1 first choose 1, he always loses.\\n\\nif (player1 pick 2) the rest is [1, 5];\\n\\tif (player2 pick 1) player1 win(true),\\n\\tif (player2 pick 5) player1 lose(false),\\n-> because player2 play optimally, so he choose to pick 5,\\n   player2 = !(pick 1) || !(pick 5)  = !true || !false = true;\\n   so when player1 first choose 2, he always loses.\\n\\nSo, it this case, no matter player1 first choose 1 or 2, he always loses.\\n   player1 = !(pick 1) || !(pick 2)  = !true || !true = false;\\n```\\n\\nHere is my code:\\n```\\npublic boolean PredictTheWinner(int[] nums) {\\n\\treturn first(0, 0, nums, 0, nums.length-1);\\n}\\n\\nprivate boolean first(int s1, int s2, int[] nums, int start, int end) {\\n\\tif (start > end ){\\n\\t\\tif (s1 >= s2) return true;\\n\\t\\telse return false;\\n\\t}\\n\\treturn !second(s1+nums[start], s2, nums, start+1, end) || !second(s1+nums[end], s2, nums, start, end-1);\\n}\\n\\nprivate boolean second(int s1, int s2, int[] nums, int start, int end) {\\n\\tif (start > end ){\\n\\t\\tif (s1 < s2) return true;\\n\\t\\telse return false;\\n\\t}\\n\\treturn !first(s1, s2+nums[start], nums, start+1, end) || !first(s1, s2+nums[end], nums, start, end-1);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nif (player1 pick 1) the rest is [5, 2];\\n\\tif (player2 pick 2) player1 win(true),\\n\\tif (player2 pick 5) player1 lose(false),\\n-> because player2 play optimally, so he choose to pick 5,\\n   player2 = !(pick 2) || !(pick 5)  = !true || !false = true;\\n   so when player1 first choose 1, he always loses.\\n\\nif (player1 pick 2) the rest is [1, 5];\\n\\tif (player2 pick 1) player1 win(true),\\n\\tif (player2 pick 5) player1 lose(false),\\n-> because player2 play optimally, so he choose to pick 5,\\n   player2 = !(pick 1) || !(pick 5)  = !true || !false = true;\\n   so when player1 first choose 2, he always loses.\\n\\nSo, it this case, no matter player1 first choose 1 or 2, he always loses.\\n   player1 = !(pick 1) || !(pick 2)  = !true || !true = false;\\n```\n```\\npublic boolean PredictTheWinner(int[] nums) {\\n\\treturn first(0, 0, nums, 0, nums.length-1);\\n}\\n\\nprivate boolean first(int s1, int s2, int[] nums, int start, int end) {\\n\\tif (start > end ){\\n\\t\\tif (s1 >= s2) return true;\\n\\t\\telse return false;\\n\\t}\\n\\treturn !second(s1+nums[start], s2, nums, start+1, end) || !second(s1+nums[end], s2, nums, start, end-1);\\n}\\n\\nprivate boolean second(int s1, int s2, int[] nums, int start, int end) {\\n\\tif (start > end ){\\n\\t\\tif (s1 < s2) return true;\\n\\t\\telse return false;\\n\\t}\\n\\treturn !first(s1, s2+nums[start], nums, start+1, end) || !first(s1, s2+nums[end], nums, start, end-1);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3826440,
                "title": "beats-100-video-java-c-python",
                "content": "<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/OO7KUGUJHRs\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen></iframe>\\n\\n```\\nclass Solution {\\n    int[][] dp;\\n    \\n    private int score(int[] nums, int l, int r) {\\n        if (dp[l][r] != -1) {\\n            return dp[l][r];\\n        }\\n        if (l == r) {\\n            return nums[l];\\n        }\\n        \\n        int left = nums[l] - score(nums, l + 1, r);\\n        int right = nums[r] - score(nums, l, r - 1);\\n        dp[l][r] = Math.max(left, right);\\n        \\n        return dp[l][r];\\n    }\\n    \\n    public boolean PredictTheWinner(int[] nums) {\\n        int n = nums.length;\\n        dp = new int[n][n];\\n        for (int i = 0; i < n; ++i) {\\n            Arrays.fill(dp[i], -1);\\n        }\\n        \\n        return score(nums, 0, n - 1) >= 0;\\n    }\\n}\\n```\\n\\n```\\nclass Solution {\\nprivate:\\n    vector<vector<int>> dp;\\n    \\n    int score(vector<int>& nums, int l, int r) {\\n        if (dp[l][r] != -1) {\\n            return dp[l][r];\\n        }\\n        if (l == r) {\\n            return nums[l];\\n        }\\n        \\n        int left = nums[l] - score(nums, l + 1, r);\\n        int right = nums[r] - score(nums, l, r - 1);\\n        dp[l][r] = max(left, right);\\n        \\n        return dp[l][r];\\n    }\\n    \\npublic:\\n    bool PredictTheWinner(vector<int>& nums) {\\n        int n = nums.size();\\n        dp = vector<vector<int>>(n, vector<int>(n, -1));\\n        \\n        return score(nums, 0, n - 1) >= 0;\\n    }\\n};\\n```\\n\\n```\\nclass Solution:\\n    def score(self, nums, l, r, dp):\\n        if dp[l][r] != -1:\\n            return dp[l][r]\\n        if l == r:\\n            return nums[l]\\n        \\n        left = nums[l] - self.score(nums, l + 1, r, dp)\\n        right = nums[r] - self.score(nums, l, r - 1, dp)\\n        dp[l][r] = max(left, right)\\n        \\n        return dp[l][r]\\n    \\n    def PredictTheWinner(self, nums):\\n        n = len(nums)\\n        dp = [[-1 for _ in range(n)] for _ in range(n)]\\n        \\n        return self.score(nums, 0, n - 1, dp) >= 0\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    int[][] dp;\\n    \\n    private int score(int[] nums, int l, int r) {\\n        if (dp[l][r] != -1) {\\n            return dp[l][r];\\n        }\\n        if (l == r) {\\n            return nums[l];\\n        }\\n        \\n        int left = nums[l] - score(nums, l + 1, r);\\n        int right = nums[r] - score(nums, l, r - 1);\\n        dp[l][r] = Math.max(left, right);\\n        \\n        return dp[l][r];\\n    }\\n    \\n    public boolean PredictTheWinner(int[] nums) {\\n        int n = nums.length;\\n        dp = new int[n][n];\\n        for (int i = 0; i < n; ++i) {\\n            Arrays.fill(dp[i], -1);\\n        }\\n        \\n        return score(nums, 0, n - 1) >= 0;\\n    }\\n}\\n```\n```\\nclass Solution {\\nprivate:\\n    vector<vector<int>> dp;\\n    \\n    int score(vector<int>& nums, int l, int r) {\\n        if (dp[l][r] != -1) {\\n            return dp[l][r];\\n        }\\n        if (l == r) {\\n            return nums[l];\\n        }\\n        \\n        int left = nums[l] - score(nums, l + 1, r);\\n        int right = nums[r] - score(nums, l, r - 1);\\n        dp[l][r] = max(left, right);\\n        \\n        return dp[l][r];\\n    }\\n    \\npublic:\\n    bool PredictTheWinner(vector<int>& nums) {\\n        int n = nums.size();\\n        dp = vector<vector<int>>(n, vector<int>(n, -1));\\n        \\n        return score(nums, 0, n - 1) >= 0;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def score(self, nums, l, r, dp):\\n        if dp[l][r] != -1:\\n            return dp[l][r]\\n        if l == r:\\n            return nums[l]\\n        \\n        left = nums[l] - self.score(nums, l + 1, r, dp)\\n        right = nums[r] - self.score(nums, l, r - 1, dp)\\n        dp[l][r] = max(left, right)\\n        \\n        return dp[l][r]\\n    \\n    def PredictTheWinner(self, nums):\\n        n = len(nums)\\n        dp = [[-1 for _ in range(n)] for _ in range(n)]\\n        \\n        return self.score(nums, 0, n - 1, dp) >= 0\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2184031,
                "title": "simple-c-recursive-sol",
                "content": "Let scores be a function with boolean return type , which returns if A can win or not (provided both players play optimally).\\n\\nHere we have boolean variable **a_turn** , which determines if it is A\\'s turn to choose a number.\\n**score_a** , to maintain the score of A,\\n**score_b** , to maintain the score of B, \\n**i , j** to keep track of available range of indices of nums that can be used , i being the leftmost index , j being the rightmost index. \\n\\n**Base case -**\\n When there are no elements left in the window ,i.e i>j.\\n Hence we will check if score of a is greater than or equal to b , return true , otherwise return false.\\n \\n For every function call , we have two possibilities , it\\'s A\\'s turn to choose the number optimally , \\n or is it B\\'s turn to choose the number optimally.\\n \\n**NOTE** - *If function returns true , A wins \\n                    If function returns false , B wins*\\n Lets look at the first case ,\\n 1. a_turn  is TRUE , i.e It\\'s A\\'s turn to choose the number .\\n       We have again 2 options ,   A chooses element from beginning , i.e i th index\\n\\t                                               A  chooses element from end  , i.e j th index\\n\\t  If either of the two cases return true (A wins) , we will return true, otherwise return false.\\n\\t  (Because A is supposed to play optimally)\\n\\t  \\n2. a_turn is FALSE ,  it is B\\'s turn to choose one number optimally,\\n    We have again 2 options ,   B chooses element from beginning , i.e i th index\\n\\t                                             B  chooses element from end  , i.e j th index\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t \\n\\tB will choose one of the above options such that it wins (if possible)\\n\\t\\n\\tSuppose  b1 and b2 be the results corresponding to the two cases.\\n\\t\\n\\tif either of b1 and b2 is false , function will return false( B wins)\\n\\thence return b1&&b2\\n\\n```\\nbool scores(vector<int>& nums, bool a_turn, int score_a,int score_b, int i,int j)\\n{\\n    if(i>j)\\n        return score_a>=score_b;\\n      \\n    if(a_turn)\\n        return scores(nums,false,score_a+nums[i],score_b,i+1,j)||scores(nums,false,score_a+nums[j],score_b,i,j-1);\\n        \\n    \\n         return scores(nums,true,score_a,score_b+nums[i],i+1,j)&&scores(nums,true,score_a,score_b+nums[j],i,j-1);\\n    \\n    \\n}\\nclass Solution {\\npublic:\\n    bool PredictTheWinner(vector<int>& nums) {\\n        return scores(nums,true,0,0,0,nums.size()-1);\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    bool PredictTheWinner(vector<int>& nums) {\\n        return scores(nums,true,0,0,0,nums.size()-1);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2206301,
                "title": "c-3-recursive-methods-well-explained-dp",
                "content": "METHOD_1\\nhere we will just pass a recursive function where we have passed a bool variable \"turn\" which indicates the turn of player 1 when its true , and false when player 2 will have to pick\\n\\nif i>j   => this will indicate the base case , here we will check the condition sum1>=sum2 , if well and good , otheriwse for that part player 2 has won \\n\\nanother important thing to see is that for player 1 \\'s turn we have used or ie || , means if either of the 2 calls is true , means that player 1 has won \\nand for player 2 we have used && becuase as we know that , player 2 will choose the maximum posssible value , therefore if both of the recursive conditions will be true , means that in both of the calls player 1 has won , then only player 1 willl win \\n pls draw decison tree the try to understand \\n\\nno need of memoization as , it isnt giving TLE\\nwe can easily do it through 2D matrix\\n```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& nums, int sum1 , int sum2, bool turn ,int i, int j ){\\n        if(i>j){\\n            if(sum1>=sum2)\\n                return 1;\\n            \\n            return 0;\\n        }\\n        \\n        if(turn){\\n             return solve(nums,sum1+nums[i],sum2,false,i+1,j) || solve(nums,sum1+nums[j],sum2,false,i,j-1);\\n        }\\n        \\n        else\\n           return solve(nums,sum1,sum2+nums[i],true,i+1,j) &&  solve(nums,sum1,sum2+nums[j],true,i,j-1);\\n        \\n        \\n    }\\n    \\n\\n    bool PredictTheWinner(vector<int>& nums) {\\n        return solve(nums,0,0,true,0,nums.size()-1);\\n    }\\n};\\n```\\n\\nMETHOD_2\\nhere we will just calculate the maximum possible sum for player 1 , and  after that we will subtract this from total sum of nums , then we will get the sum for player 2 \\n\\nhere is just one catch , while writing recursive calls for player 2 we will not add nums[i ]/ nums[j], and just return the minimum because we are calculating the sum for player1\\n\\n```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& nums, bool turn ,int i, int j ){\\n        if(i>j)\\n            return 0;\\n        \\n        if(turn){\\n         return max(nums[i]+solve(nums,false,i+1,j),nums[j]+solve(nums,false,i,j-1));\\n        }\\n        \\n        else\\n           return min(solve(nums,true,i+1,j),solve(nums,true,i,j-1));\\n        \\n    }\\n    \\n\\n    bool PredictTheWinner(vector<int>& nums) {\\n        \\n        int totalSum=0;\\n        for(int i=0;i<nums.size();i++){\\n            totalSum+=nums[i];\\n        }\\n        \\n        int sum1= solve(nums,true,0,nums.size()-1);\\n        \\n        int sum2=totalSum-sum1;\\n        \\n        return sum1>=sum2;\\n    }\\n};\\n```\\n\\nMETHOD_3\\nalmost similar to 2nd method \\nwatch this video by [pepcoding](https://www.youtube.com/watch?v=ww4V7vRIzSk&t=90s)\\n\\n```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& nums,int i, int j ){\\n      if(i>j)\\n          return 0;\\n    \\n     int choice1=nums[i]+min(solve(nums,i+2,j),solve(nums,i+1,j-1));\\n     int choice2=nums[j]+min(solve(nums,i+1,j-1),solve(nums,i,j-2));\\n        \\n     return max(choice1,choice2);\\n        \\n    }\\n    \\n\\n    bool PredictTheWinner(vector<int>& nums) {\\n        \\n        int totalSum=0;\\n        for(int i=0;i<nums.size();i++){\\n            totalSum+=nums[i];\\n        }\\n        \\n        int sum1= solve(nums,0,nums.size()-1);\\n        \\n        int sum2=totalSum-sum1;\\n        \\n        return sum1>=sum2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& nums, int sum1 , int sum2, bool turn ,int i, int j ){\\n        if(i>j){\\n            if(sum1>=sum2)\\n                return 1;\\n            \\n            return 0;\\n        }\\n        \\n        if(turn){\\n             return solve(nums,sum1+nums[i],sum2,false,i+1,j) || solve(nums,sum1+nums[j],sum2,false,i,j-1);\\n        }\\n        \\n        else\\n           return solve(nums,sum1,sum2+nums[i],true,i+1,j) &&  solve(nums,sum1,sum2+nums[j],true,i,j-1);\\n        \\n        \\n    }\\n    \\n\\n    bool PredictTheWinner(vector<int>& nums) {\\n        return solve(nums,0,0,true,0,nums.size()-1);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& nums, bool turn ,int i, int j ){\\n        if(i>j)\\n            return 0;\\n        \\n        if(turn){\\n         return max(nums[i]+solve(nums,false,i+1,j),nums[j]+solve(nums,false,i,j-1));\\n        }\\n        \\n        else\\n           return min(solve(nums,true,i+1,j),solve(nums,true,i,j-1));\\n        \\n    }\\n    \\n\\n    bool PredictTheWinner(vector<int>& nums) {\\n        \\n        int totalSum=0;\\n        for(int i=0;i<nums.size();i++){\\n            totalSum+=nums[i];\\n        }\\n        \\n        int sum1= solve(nums,true,0,nums.size()-1);\\n        \\n        int sum2=totalSum-sum1;\\n        \\n        return sum1>=sum2;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& nums,int i, int j ){\\n      if(i>j)\\n          return 0;\\n    \\n     int choice1=nums[i]+min(solve(nums,i+2,j),solve(nums,i+1,j-1));\\n     int choice2=nums[j]+min(solve(nums,i+1,j-1),solve(nums,i,j-2));\\n        \\n     return max(choice1,choice2);\\n        \\n    }\\n    \\n\\n    bool PredictTheWinner(vector<int>& nums) {\\n        \\n        int totalSum=0;\\n        for(int i=0;i<nums.size();i++){\\n            totalSum+=nums[i];\\n        }\\n        \\n        int sum1= solve(nums,0,nums.size()-1);\\n        \\n        int sum2=totalSum-sum1;\\n        \\n        return sum1>=sum2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 884166,
                "title": "c-recursive-dp-minimax-solution",
                "content": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Predict the Winner.\\nMemory Usage: 7.7 MB, less than 46.48% of C++ online submissions for Predict the Winner.\\n\\nProblem is similar as [Stone Game](https://leetcode.com/problems/stone-game/) problem and the [solution](https://leetcode.com/problems/stone-game/discuss/882969/C++-Recursive-DP-MiniMax-Solution) as well.\\n\\nSolved using MiniMax Algorithm where player1 tries to maximize his score and player2 tries to\\nminimize player1\\'s score recursively. To get the game score between two player we can add player1\\'s\\nchoice and deduce player2\\'s choice which will give max score of player1 - max score of player 2 at the end.\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    // Player1 turn adds score and Player2\\'s turn deducts score\\n    // Game result = max score of Player1 - max score of Player2\\n    // dp vector tracks the game result in range l to h => max array length 20\\n    int dp[21][21]={};\\n    \\n    int takeStone(bool Player, int l, int h, vector<int>& nums)\\n    {\\n        // base cases : impossible and so return -1 as scores are non-negative\\n        if(l>h) return -1;\\n        \\n        // l==h return the score\\n        if(l==h) return nums[l];\\n        \\n        // return precalculated result\\n        if(dp[l][h]!=-1) return dp[l][h];\\n        \\n        // Player1\\'s turn, Player1 can take either nums[l] or nums[h] so we add them with the recursion call as\\n        // nums[l]+takeStone(l+1,h) or nums[h]+takeStone(l,h-1) and get the max value betweeen them \\n        // for getting the game result as Player1 always tries to maximize his score\\n        if(Player)    \\n            dp[l][h] = max(nums[l]+takeStone(!Player,l+1,h,piles),nums[h]+takeStone(!Player,l,h-1,piles));\\n        \\n        // Player2\\'s turn, choice for Player2 is same as Player1, only differece is that Player2 wants to maximize his\\n        // game result by minimizing Player1\\'s result and so we return the min value between those two choices\\n        // also to get game result we deduct nums[l] or nums[h] with recursion calls\\n        else\\n            dp[l][h] = min(-nums[l]+takeStone(!Player,l+1,h,piles),-nums[h]+takeStone(!Player,l,h-1,piles));\\n\\n        return dp[l][h];\\n    }\\n    \\n    bool PredictTheWinner(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        memset(dp,-1,sizeof(dp));\\n        \\n        // Player1 turn = true, Player2 turn = false\\n        // Game result = max score of Player1 - max score of Player2\\n        // If result >= 0 then Player1 wins\\n\\t\\t\\treturn takeStone(true,0,n-1,nums) >= 0; // Incase of draw Player1 wins\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // Player1 turn adds score and Player2\\'s turn deducts score\\n    // Game result = max score of Player1 - max score of Player2\\n    // dp vector tracks the game result in range l to h => max array length 20\\n    int dp[21][21]={};\\n    \\n    int takeStone(bool Player, int l, int h, vector<int>& nums)\\n    {\\n        // base cases : impossible and so return -1 as scores are non-negative\\n        if(l>h) return -1;\\n        \\n        // l==h return the score\\n        if(l==h) return nums[l];\\n        \\n        // return precalculated result\\n        if(dp[l][h]!=-1) return dp[l][h];\\n        \\n        // Player1\\'s turn, Player1 can take either nums[l] or nums[h] so we add them with the recursion call as\\n        // nums[l]+takeStone(l+1,h) or nums[h]+takeStone(l,h-1) and get the max value betweeen them \\n        // for getting the game result as Player1 always tries to maximize his score\\n        if(Player)    \\n            dp[l][h] = max(nums[l]+takeStone(!Player,l+1,h,piles),nums[h]+takeStone(!Player,l,h-1,piles));\\n        \\n        // Player2\\'s turn, choice for Player2 is same as Player1, only differece is that Player2 wants to maximize his\\n        // game result by minimizing Player1\\'s result and so we return the min value between those two choices\\n        // also to get game result we deduct nums[l] or nums[h] with recursion calls\\n        else\\n            dp[l][h] = min(-nums[l]+takeStone(!Player,l+1,h,piles),-nums[h]+takeStone(!Player,l,h-1,piles));\\n\\n        return dp[l][h];\\n    }\\n    \\n    bool PredictTheWinner(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        memset(dp,-1,sizeof(dp));\\n        \\n        // Player1 turn = true, Player2 turn = false\\n        // Game result = max score of Player1 - max score of Player2\\n        // If result >= 0 then Player1 wins\\n\\t\\t\\treturn takeStone(true,0,n-1,nums) >= 0; // Incase of draw Player1 wins\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 746142,
                "title": "easy-python-100-speed-recursion-memoization",
                "content": "**Easy Python | 100% Speed | Recursion + Memoization**\\n\\nEasy Python solution tracking the maximum score that Player 1 can achieve. The score of Player 2 can be calculated afterwards by noting that both scores must sum the total of the array: Player_1 + Player_2 = Sum(nums).\\n\\nFor each turn of Player_1, we do the following:\\n1. We consider picking the first or the last element of the (remaining) array separately. Each alternative is assigned a score, according to the rules of step-2.\\n\\n2. For each alternative in step-1, we consider that Player 2 is smart and will leave us with the worst possible score afterwards. So, from the 2 upcoming turns (with Player 2 picking his/her first or last element), we consider that we achieve the **minimum** score from these possibilities.\\n\\n3. After using the previous rules, we pick the **best** score from the 2 alternatives described in (1).\\n\\n4. Steps (1-3) are repeated recursively until we reach an answer. We use memoization to avoid redundant calculations.\\n\\nI hope the expalanation was helpful. Cheers,\\n\\n```\\nclass Solution:\\n    def PredictTheWinner(self, A):\\n        memo = {}\\n        def maxscore(i,j):\\n            if (i,j) in memo:\\n                return memo[i,j]\\n            if i>j:\\n                return 0\\n            #\\n            sA = A[i] + min( maxscore(i+1,j-1), maxscore(i+2,j  ) ) # pick A[i] + min of the 2 possible upcoming turns (player 2 is smart)\\n            sB = A[j] + min( maxscore(i  ,j-2), maxscore(i+1,j-1) )\\n            score = max(sA,sB)\\n            memo[i,j] = score\\n            return score\\n        p1 = maxscore(0,len(A)-1) # Score Player 1\\n        return p1>=(sum(A)-p1) # p1 >= p2\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def PredictTheWinner(self, A):\\n        memo = {}\\n        def maxscore(i,j):\\n            if (i,j) in memo:\\n                return memo[i,j]\\n            if i>j:\\n                return 0\\n            #\\n            sA = A[i] + min( maxscore(i+1,j-1), maxscore(i+2,j  ) ) # pick A[i] + min of the 2 possible upcoming turns (player 2 is smart)\\n            sB = A[j] + min( maxscore(i  ,j-2), maxscore(i+1,j-1) )\\n            score = max(sA,sB)\\n            memo[i,j] = score\\n            return score\\n        p1 = maxscore(0,len(A)-1) # Score Player 1\\n        return p1>=(sum(A)-p1) # p1 >= p2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3826819,
                "title": "c-easy-solution-with-explanation-beats-100-0ms-solution-recursive-and-memoized-code",
                "content": "# Intuition\\nThe intuition behind the question was pretty simple like , we have to two choices at a point whether we take from start or from end and based on that we keep repeating the steps and playing optimally for both the peoples\\n\\n# Approach\\n- Made 3 base cases : \\n    - When we take all from start\\n    - When we take all from end\\n    - When we take from both sides\\n- *(We can create only one base case too (i > j) , but for showing i made all possiblities).*\\n- Then when we choose for player one we add that to our total sum. \\n- When we choose for player two we subtract it from our total sum as it takes score away from player one.\\n- We keep on doing this until we hit our base case and then if we manage to find one set where the sum of the player ones point is greater than or equal zero we simply return true;\\n\\n# Complexity\\n- Time complexity: O(N * N)\\n\\n- Space complexity: O(N * N * 2)\\n\\n\\n![Screenshot (455).png](https://assets.leetcode.com/users/images/65fa1630-0053-46d9-b423-90ecc2616d8f_1690519013.8204145.png)\\n![Screenshot (456).png](https://assets.leetcode.com/users/images/ff777891-f012-4e19-b69f-46195033ef6f_1690519004.6939564.png)\\n\\n# Recursive Code\\n```\\nclass Solution {\\npublic:\\n    int dfs(int i , int j ,vector<int>& nums , int turn){\\n        if(i == nums.size() || j == -1) return 0;\\n        if(i > j) return 0;\\n        if(turn == 0){\\n            return max(nums[i] + dfs(i + 1 , j , nums , 1), \\n                       nums[j] + dfs(i , j - 1 , nums , 1));\\n        }\\n        else{\\n            return min(-nums[i] + dfs(i + 1 , j , nums , 0),\\n                       -nums[j] + dfs(i , j - 1 , nums , 0));\\n        }\\n    }\\n    bool PredictTheWinner(vector<int>& nums) {\\n        int n = nums.size();\\n        int val = dfs(0 , n - 1 , nums , 0);\\n        return val >= 0;\\n    }\\n};\\n```\\n\\n# Memoized Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<vector<long>>> dp;\\n    int dfs(int i , int j ,vector<int>& nums , int turn){\\n        if(i == nums.size() || j == -1) return 0;\\n        if(i > j) return 0;\\n        if(dp[i][j][turn] != -1e10) return dp[i][j][turn];\\n        if(turn == 0){\\n            return dp[i][j][turn] = max(nums[i] + dfs(i + 1 , j , nums , 1), \\n                                        nums[j] + dfs(i , j - 1 , nums , 1));\\n        }\\n        else{\\n            return dp[i][j][turn] = min(-nums[i] + dfs(i + 1 , j , nums , 0),\\n                                        -nums[j] + dfs(i , j - 1 , nums , 0));\\n        }\\n    }\\n    bool PredictTheWinner(vector<int>& nums) {\\n        int n = nums.size();\\n        dp.resize(n , vector<vector<long>>(n , vector<long>(2 , -1e10)));\\n        int val = dfs(0 , n - 1 , nums , 0);\\n        return val >= 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dfs(int i , int j ,vector<int>& nums , int turn){\\n        if(i == nums.size() || j == -1) return 0;\\n        if(i > j) return 0;\\n        if(turn == 0){\\n            return max(nums[i] + dfs(i + 1 , j , nums , 1), \\n                       nums[j] + dfs(i , j - 1 , nums , 1));\\n        }\\n        else{\\n            return min(-nums[i] + dfs(i + 1 , j , nums , 0),\\n                       -nums[j] + dfs(i , j - 1 , nums , 0));\\n        }\\n    }\\n    bool PredictTheWinner(vector<int>& nums) {\\n        int n = nums.size();\\n        int val = dfs(0 , n - 1 , nums , 0);\\n        return val >= 0;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<vector<long>>> dp;\\n    int dfs(int i , int j ,vector<int>& nums , int turn){\\n        if(i == nums.size() || j == -1) return 0;\\n        if(i > j) return 0;\\n        if(dp[i][j][turn] != -1e10) return dp[i][j][turn];\\n        if(turn == 0){\\n            return dp[i][j][turn] = max(nums[i] + dfs(i + 1 , j , nums , 1), \\n                                        nums[j] + dfs(i , j - 1 , nums , 1));\\n        }\\n        else{\\n            return dp[i][j][turn] = min(-nums[i] + dfs(i + 1 , j , nums , 0),\\n                                        -nums[j] + dfs(i , j - 1 , nums , 0));\\n        }\\n    }\\n    bool PredictTheWinner(vector<int>& nums) {\\n        int n = nums.size();\\n        dp.resize(n , vector<vector<long>>(n , vector<long>(2 , -1e10)));\\n        int val = dfs(0 , n - 1 , nums , 0);\\n        return val >= 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 96901,
                "title": "java-dp-solution-with-explanation",
                "content": "If the first player choose nums[0], the max he can get is sum( nums )-max[1, end](which is max for the second player). If the first player choose the last element in nums, then the max he can get is sum(nums)-max[0, end-1](which is the max for the second player). Thus, the DP formula is DP[start][end]=Max(sum-dp[start][end-1], sum-dp[start+1][end]).\\n\\nOne thing I wanna to mention is that, sum in the DP formula is not the total sum for nums, but the sum for nums[start, end].\\n```\\npublic boolean PredictTheWinner(int[] nums) {\\n        int length = nums.length;\\n        \\n        int sum = 0;\\n        for(int num : nums) sum+=num;\\n        \\n        int[][] dp = new int[length][length];\\n        \\n        for(int j = 0 ; j< length ; j++)\\n        {\\n            int curSum = 0;\\n            for(int i = j ; i>= 0 ; i--)\\n            {\\n                curSum+=nums[i];\\n                if(i == j) dp[i][j]=nums[j];\\n                else\\n                {\\n                    dp[i][j]=Math.max(curSum-dp[i][j-1], curSum-dp[i+1][j]);\\n                }\\n            }\\n        }\\n        return dp[0][length-1]*2>=sum;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean PredictTheWinner(int[] nums) {\\n        int length = nums.length;\\n        \\n        int sum = 0;\\n        for(int num : nums) sum+=num;\\n        \\n        int[][] dp = new int[length][length];\\n        \\n        for(int j = 0 ; j< length ; j++)\\n        {\\n            int curSum = 0;\\n            for(int i = j ; i>= 0 ; i--)\\n            {\\n                curSum+=nums[i];\\n                if(i == j) dp[i][j]=nums[j];\\n                else\\n                {\\n                    dp[i][j]=Math.max(curSum-dp[i][j-1], curSum-dp[i+1][j]);\\n                }\\n            }\\n        }\\n        return dp[0][length-1]*2>=sum;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3827565,
                "title": "simple-answer-beats-100-runtime-ms",
                "content": "1. The code works by creating a dp array that stores the maximum number of stones that the first player can remove from the array such that the second player cannot win the game. The dp array is filled in a bottom-up fashion, starting from the last element and working its way to the first element.\\n\\n2. For each element in the table, the code considers all the possible values of the next element. The code then updates the table element to the maximum of the following two values:\\ni. *The number of stones that the first player can remove from the current element.*\\nii. *The number of stones that the first player can remove from the next element, plus the number of stones that the second player can remove from the next element.*\\n\\n---\\n\\n\\nThe code finally returns true if the first player can always win the game, and false otherwise.\\n\\nIn simpler terms, the code is trying to figure out how many elements the first player should remove from the array in order to make it impossible for the second player to win. The code does this by looking at all the possible ways that the second player could respond to the first player\\'s move, and then choosing the move that makes it the most difficult for the second player to win.\\n\\nThe code is based on the following idea: if the first player can always remove enough elements from the array to make it impossible for the second player to win, then the first player will always win the game. So, created a dp array that stores the maximum number of elements that the first player can remove from the pile such that the second player cannot win the game.\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```Java(100%) []\\nclass Solution {\\n    public boolean PredictTheWinner(int[] nums) {\\n        int n = nums.length;\\n        int[] dp = new int[n];\\n\\n        for (int i=n-1; i>=0; i--) {\\n            dp[i] = nums[i];\\n            for(int j=i+1; j<n; j++) {\\n                dp[j] = Math.max(nums[i]-dp[j],nums[j]-dp[j-1]);\\n            }\\n        }\\n        return dp[n-1]>=0;\\n    }\\n}\\n```\\n```C++(100%) []\\nclass Solution {\\npublic:\\n    bool PredictTheWinner(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> dp(n);\\n\\n        for (int i = n - 1; i >= 0; i--) {\\n            dp[i] = nums[i];\\n            for (int j = i + 1; j < n; j++) {\\n                dp[j] = max(nums[i] - dp[j], nums[j] - dp[j - 1]);\\n            }\\n        }\\n\\n        return dp[n - 1] >= 0;\\n    }\\n};\\n```\\n```Python3(97.36%) []\\nclass Solution:\\n    def PredictTheWinner(self, nums: List[int]) -> bool:\\n        n = len(nums)\\n        dp = nums[:]\\n\\n        for i in range(n - 2, -1, -1):\\n            for j in range(i + 1, n):\\n                dp[j] = max(nums[i] - dp[j], nums[j] - dp[j - 1])\\n\\n        return dp[-1] >= 0\\n```\\n```C(63%) []\\n#include <stdbool.h>\\n\\nbool PredictTheWinner(int* nums, int numsSize) {\\n    int dp[numsSize];\\n\\n    for (int i = numsSize - 1; i >= 0; i--) {\\n        dp[i] = nums[i];\\n        for (int j = i + 1; j < numsSize; j++) {\\n            dp[j] = (nums[i] - dp[j]) > (nums[j] - dp[j - 1]) ? (nums[i] - dp[j]) : (nums[j] - dp[j - 1]);\\n        }\\n    }\\n\\n    return dp[numsSize - 1] >= 0;\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```Java(100%) []\\nclass Solution {\\n    public boolean PredictTheWinner(int[] nums) {\\n        int n = nums.length;\\n        int[] dp = new int[n];\\n\\n        for (int i=n-1; i>=0; i--) {\\n            dp[i] = nums[i];\\n            for(int j=i+1; j<n; j++) {\\n                dp[j] = Math.max(nums[i]-dp[j],nums[j]-dp[j-1]);\\n            }\\n        }\\n        return dp[n-1]>=0;\\n    }\\n}\\n```\n```C++(100%) []\\nclass Solution {\\npublic:\\n    bool PredictTheWinner(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> dp(n);\\n\\n        for (int i = n - 1; i >= 0; i--) {\\n            dp[i] = nums[i];\\n            for (int j = i + 1; j < n; j++) {\\n                dp[j] = max(nums[i] - dp[j], nums[j] - dp[j - 1]);\\n            }\\n        }\\n\\n        return dp[n - 1] >= 0;\\n    }\\n};\\n```\n```Python3(97.36%) []\\nclass Solution:\\n    def PredictTheWinner(self, nums: List[int]) -> bool:\\n        n = len(nums)\\n        dp = nums[:]\\n\\n        for i in range(n - 2, -1, -1):\\n            for j in range(i + 1, n):\\n                dp[j] = max(nums[i] - dp[j], nums[j] - dp[j - 1])\\n\\n        return dp[-1] >= 0\\n```\n```C(63%) []\\n#include <stdbool.h>\\n\\nbool PredictTheWinner(int* nums, int numsSize) {\\n    int dp[numsSize];\\n\\n    for (int i = numsSize - 1; i >= 0; i--) {\\n        dp[i] = nums[i];\\n        for (int j = i + 1; j < numsSize; j++) {\\n            dp[j] = (nums[i] - dp[j]) > (nums[j] - dp[j - 1]) ? (nums[i] - dp[j]) : (nums[j] - dp[j - 1]);\\n        }\\n    }\\n\\n    return dp[numsSize - 1] >= 0;\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 414803,
                "title": "python-ac-98-both-recursion-dp-with-detailed-explanation",
                "content": "#### Solution 1: Recursion with memo, 32ms AC 98%.\\nhelper(i, j) return the margin of the score when it\\'s current player\\'s turn and the array left are nums[i]..nums[j] inclusively. \\n```\\nclass Solution:\\n    def PredictTheWinner(self, nums: List[int]) -> bool:\\n        def helper(i, j):\\n            if i == j:\\n                return nums[i]\\n            \\n            if (i, j) in memo:\\n                return memo[(i, j)]\\n            \\n            score = max(nums[j] - helper(i, j-1), nums[i] - helper(i+1, j))\\n            memo[(i, j)] = score\\n            \\n            return score\\n            \\n        memo = {}            \\n        return helper(0, len(nums)-1) >= 0\\n```\\n\\n**Complexity, Time: O(n^2), Space: O(n)**    \\n\\n\\n**Solution2:** dynamic programming, dp[i][j] is the margin of the score when it\\'s current player\\'s turn and the array left are nums[i]..nums[j] inclusively. \\n```\\n class Solution:\\n     def PredictTheWinner(self, nums: List[int]) -> bool:\\n         dp[i][j] the person\\'s effective score when pick, facing nums[i..j]\\n         dp = [[0] * len(nums) for _ in range(len(nums))]\\n         for s in range(len(nums)):\\n             for i in range(len(nums)-s):\\n                 j = i + s\\n                 if i == j:\\n                     dp[i][i] = nums[i]\\n                 else:\\n                     dp[i][j] = max(nums[j] - dp[i][j-1], nums[i] - dp[i+1][j])\\n         return dp[0][-1] >= 0\\n```\\n\\n**Complexity, Time: O(n^2), Space: O(n^2)**\\n  \\n  \\n**Solution 3:** the dp updates the hill diagnal which depends only on previous hill diagal, so it could be turned to a 1-D DP. \\n\\n```\\n class Solution:\\n     def PredictTheWinner(self, nums: List[int]) -> bool:\\n         n = len(nums)\\n         dp = nums[:]\\n       \\n         for s in range(1, n):\\n             newdp = [0] * n\\n             for j in range(s, n):\\n                 i = j - s\\n                 newdp[j] = max(nums[i] - dp[j], nums[j] - dp[j-1])\\n                \\n             dp = newdp\\n         return dp[-1] >= 0\\n\\n```\\n**Complexity, Time: O(n^2), Space: O(n)**  \\n\\n\\nO(\\u2229_\\u2229)O~ Vote up if you find it helpful.\\n\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def PredictTheWinner(self, nums: List[int]) -> bool:\\n        def helper(i, j):\\n            if i == j:\\n                return nums[i]\\n            \\n            if (i, j) in memo:\\n                return memo[(i, j)]\\n            \\n            score = max(nums[j] - helper(i, j-1), nums[i] - helper(i+1, j))\\n            memo[(i, j)] = score\\n            \\n            return score\\n            \\n        memo = {}            \\n        return helper(0, len(nums)-1) >= 0\\n```\n```\\n class Solution:\\n     def PredictTheWinner(self, nums: List[int]) -> bool:\\n         dp[i][j] the person\\'s effective score when pick, facing nums[i..j]\\n         dp = [[0] * len(nums) for _ in range(len(nums))]\\n         for s in range(len(nums)):\\n             for i in range(len(nums)-s):\\n                 j = i + s\\n                 if i == j:\\n                     dp[i][i] = nums[i]\\n                 else:\\n                     dp[i][j] = max(nums[j] - dp[i][j-1], nums[i] - dp[i+1][j])\\n         return dp[0][-1] >= 0\\n```\n```\\n class Solution:\\n     def PredictTheWinner(self, nums: List[int]) -> bool:\\n         n = len(nums)\\n         dp = nums[:]\\n       \\n         for s in range(1, n):\\n             newdp = [0] * n\\n             for j in range(s, n):\\n                 i = j - s\\n                 newdp[j] = max(nums[i] - dp[j], nums[j] - dp[j-1])\\n                \\n             dp = newdp\\n         return dp[-1] >= 0\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 171774,
                "title": "easy-recursive-python-solution-that-beats-90",
                "content": "```\\nclass Solution:\\n    def PredictTheWinner(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        memo = {}\\n    \\n        def helper(_sum, nums, start, end):\\n            \\n            if (start, end) in memo:\\n                return memo[(start, end)]\\n            \\n            if start == end:\\n                memo[(start, end)] = nums[start]\\n                return nums[start]\\n            \\n            score1 = _sum - helper(_sum - nums[start], nums, start+1, end) \\n            score2 = _sum - helper(_sum - nums[end], nums, start, end-1)\\n            \\n            res = max(score1, score2)\\n            memo[(start, end)] = res\\n            \\n            return res\\n        \\n        return helper(sum(nums), nums, 0, len(nums)-1) * 2 >= sum(nums)\\n```\\n\\nMy solution uses DP.\\nThe helper function computes the maximal possible score the first-mover player can get in  `nums`. \\nIn each recursive step, we compute two different possible moves: pick first number or last number.\\nIf we pick the first number, the maximal possible score I can get is the the sum of all numbers subtracting the maximal possible sore the other player can get in `nums[1:]` if he is the first-mover in `nums[1:]`, because we assume each player is aplying the game optimally. \\n\\nSimilarly, If we pick the last number, the maximal possible score I can get is the the sum of all numbers subtracting the maximal possible sore the other player can get in `nums[:len(nums)-1]` if he is the first-mover in `nums[:len(nums)-1]`.\\n\\nAbove is the naive solution that will exceed time limit. \\n\\nMy code then uses Memoization by hashing sub-solution for each subarray. With memoization, my algorithm beats 90% of runtimes. \\n\\n\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def PredictTheWinner(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        memo = {}\\n    \\n        def helper(_sum, nums, start, end):\\n            \\n            if (start, end) in memo:\\n                return memo[(start, end)]\\n            \\n            if start == end:\\n                memo[(start, end)] = nums[start]\\n                return nums[start]\\n            \\n            score1 = _sum - helper(_sum - nums[start], nums, start+1, end) \\n            score2 = _sum - helper(_sum - nums[end], nums, start, end-1)\\n            \\n            res = max(score1, score2)\\n            memo[(start, end)] = res\\n            \\n            return res\\n        \\n        return helper(sum(nums), nums, 0, len(nums)-1) * 2 >= sum(nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 96835,
                "title": "clean-3ms-c-dp-solution-with-detailed-explanation",
                "content": "This problem can be solved in DP.\\n\\nLet first outline the DP state:\\n\\n**dp[i][j] means that for a sub-game in between [i, j] inclusive, the maximum score that Player 1 could get.**\\n\\nOur final goal is to find out whether Player 1 could score more than half of the total score in the game between [0, n-1], or in other words the dp[0][n-1]. Another thing to notice is that, because Player 1 and Player 2 pick numbers one after each other, this means:\\n\\n**If dp[i][j] means maximum score Player 1 could get between [i, j] then dp[i-1][j] could mean the maximum score Player 2 could get between [i-1, j], and same thing for dp[i][j-1].**\\n\\nAnother more **important** thing based on the above statement is that:\\n\\n**The sum[i-1][j] - dp[i-1][j] means the maximum score Player 1 can get between [i-1, j] after he picks nums[i] in between [i, j]. Also the same rule applies to dp[i][j-1].**\\n\\nThus we have the following induction rule for this DP solution:\\n\\n**pickLeft = nums[i] + sum[i-1][j] - dp[i-1][j]  //if left number is picked**\\n**pickRight = nums[j] + sum[i][j-1] - dp[i][j-1] //if right number is picked**\\n**dp[i][j] = max(pickLeft, pickRight)**\\n\\nOf course we can treat i == j and i == j-1 as special cases:\\ndp[i][j] = nums[i] // if i == j\\ndp[i][j] = max(nums[i], nums[j) // if i == j-1\\n\\nFor space complexity reason the sum[i][j] can be replaced with prefixSum.\\nsum[i][j] = prefixSum[j] - prefixSum[i-1]\\n\\n```\\n    bool PredictTheWinner(vector<int>& nums) {\\n        vector<vector<int>> score(nums.size(), vector<int>(nums.size()));\\n        vector<int> prefixSum(nums.size()+1);\\n        prefixSum[0] = 0;\\n        for (int i=0; i<nums.size(); i++) {\\n            prefixSum[i+1] = prefixSum[i] + nums[i];\\n        }\\n        \\n        for (int len=1; len<=nums.size(); len++) {\\n            for (int lhs=0; lhs+len-1<nums.size(); lhs++) {\\n                int rhs = lhs + len - 1;\\n                if (lhs == rhs) {\\n                    score[lhs][rhs] = nums[lhs];\\n                } else if (lhs == rhs-1) {\\n                    score[lhs][rhs] = max(nums[lhs], nums[rhs]);\\n                } else {\\n                    int pickLeft = nums[lhs] + prefixSum[rhs+1] - prefixSum[lhs+1] - score[lhs+1][rhs];\\n                    int pickRight = nums[rhs] + prefixSum[rhs] - prefixSum[lhs] - score[lhs][rhs-1];\\n                    score[lhs][rhs] = max(pickLeft, pickRight);\\n                }\\n            }\\n        }\\n        \\n        return score[0][nums.size()-1] >= prefixSum.back()/2 + prefixSum.back()%2;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    bool PredictTheWinner(vector<int>& nums) {\\n        vector<vector<int>> score(nums.size(), vector<int>(nums.size()));\\n        vector<int> prefixSum(nums.size()+1);\\n        prefixSum[0] = 0;\\n        for (int i=0; i<nums.size(); i++) {\\n            prefixSum[i+1] = prefixSum[i] + nums[i];\\n        }\\n        \\n        for (int len=1; len<=nums.size(); len++) {\\n            for (int lhs=0; lhs+len-1<nums.size(); lhs++) {\\n                int rhs = lhs + len - 1;\\n                if (lhs == rhs) {\\n                    score[lhs][rhs] = nums[lhs];\\n                } else if (lhs == rhs-1) {\\n                    score[lhs][rhs] = max(nums[lhs], nums[rhs]);\\n                } else {\\n                    int pickLeft = nums[lhs] + prefixSum[rhs+1] - prefixSum[lhs+1] - score[lhs+1][rhs];\\n                    int pickRight = nums[rhs] + prefixSum[rhs] - prefixSum[lhs] - score[lhs][rhs-1];\\n                    score[lhs][rhs] = max(pickLeft, pickRight);\\n                }\\n            }\\n        }\\n        \\n        return score[0][nums.size()-1] >= prefixSum.back()/2 + prefixSum.back()%2;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3826301,
                "title": "dp-memoization-min-max-easy-c-java-solution-with-explanation",
                "content": "# Intuition\\n\\n- It\\'s a simple question of the Min-Max algorithm, where both players are playing optimally. Player 1 plays to maximize their score, and player 2 tries to minimize player 1\\'s score. \\n- We just have to check who is winning, or we don\\'t have to return the scores of both players (even finding that is easy too). So, we will add the score of player 1 and subtract the score of player 2 from player 1\\'s score, which basically means that if Player 1\\'s Score >= Player 2\\'s Score, then the total score will be positive; otherwise, it will be negative.\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Create a 2D dp array of size n x n and initialize it with the value INT_MIN. Then, call the solve function.\\n  - Now, let\\'s first write the answer for the base cases where our recursion ends: \\n   If the current first index (i) > current last index (j), then return 0 because it implies that we are left with no index to proceed, and we have already calculated the score in which all the n elements are contributing (not even a single element left).\\n  - If we have already stored the answer for the current first and last indexes in the dp table, then simply return it.\\n  - Next, if K%2==0 (implies that it\\'s player 1\\'s turn as both are playing optimally, and player 1 started first), store the maximum score calculated using either the first element or the last element, and store it in ans.\\n  - Otherwise, if K%2!=0 (implies that it\\'s player 2\\'s turn), store the minimum score calculated using either the first element or the last element, and store it in ans.\\n\\nFinally, we are done, return the answer while storing it in the dp table.\\n\\n# Complexity\\n- Time complexity:O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n^2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    int solve(vector<vector<int>>&dp,vector<int>&v,int i,int j,int k){\\n        if(i>j)return 0;\\n        if(dp[i][j]!=INT_MIN)return dp[i][j];\\n        int first=0,last=0,ans=0;\\n        if(k%2==0){// it\\'s player 1\\'s turn\\n            first=v[i]+solve(dp,v,i+1,j,k+1); // pick the first element and add it to the score of player 1\\n            last=v[j]+solve(dp,v,i,j-1,k+1); // pick the last element and add it to the score player 1\\n            ans=max(first,last);//store the ans which will return the max score for player 1 \\n        }\\n        else{// it\\'s player 2\\'s turn\\n            first=-v[i]+solve(dp,v,i+1,j,k+1); // pick the first element and subtract it from the score of player 1\\n            last=-v[j]+solve(dp,v,i,j-1,k+1); // pick the lastelement and subtract it from the score of player 1\\n            ans=min(first,last);//store the ans which will return the min score for player 1 \\n        }\\n        return dp[i][j]=ans;\\n    }\\n    bool PredictTheWinner(vector<int>&v) {\\n        int i,n=v.size();\\n        vector<vector<int>>dp(n,vector<int>(n,INT_MIN));\\n        return solve(dp,v,0,n-1,0)>=0; // ans >=0 implies player 1\\'s score is greater than player 2\\'s score\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int solve(int[][] dp,int []v,int i,int j,int k){\\n        if(i>j)return 0;\\n        if(dp[i][j]!=Integer.MIN_VALUE)return dp[i][j];\\n        int first=0,last=0,ans=0;\\n        if(k%2==0){// it\\'s player 1\\'s turn\\n            first=v[i]+solve(dp,v,i+1,j,k+1);// pick the first element and add it to the score of player 1\\n            last=v[j]+solve(dp,v,i,j-1,k+1);// pick the last element and add it to the score player 1\\n            ans=Math.max(first,last);//store the ans which will return the max score for player 1 \\n        }\\n        else{// it\\'s player 2\\'s turn\\n            first=-v[i]+solve(dp,v,i+1,j,k+1);// pick the first element and subtract it from the score of player 1\\n            last=-v[j]+solve(dp,v,i,j-1,k+1);// pick the lastelement and subtract it from the score of player 1\\n            ans=Math.min(first,last); //store the ans which will return the min score for player 1 \\n        }\\n        return dp[i][j]=ans;\\n    }\\n    public boolean PredictTheWinner(int[] v) {\\n        int i,n=v.length;\\n        int[][] dp=new int[n][n];\\n        for(i=0;i<n;i++)Arrays.fill(dp[i],Integer.MIN_VALUE);\\n        return solve(dp,v,0,n-1,0)>=0; // ans >=0 implies player 1\\'s score is greater than player 2\\'s score\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Dynamic Programming",
                    "Game Theory"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int solve(vector<vector<int>>&dp,vector<int>&v,int i,int j,int k){\\n        if(i>j)return 0;\\n        if(dp[i][j]!=INT_MIN)return dp[i][j];\\n        int first=0,last=0,ans=0;\\n        if(k%2==0){// it\\'s player 1\\'s turn\\n            first=v[i]+solve(dp,v,i+1,j,k+1); // pick the first element and add it to the score of player 1\\n            last=v[j]+solve(dp,v,i,j-1,k+1); // pick the last element and add it to the score player 1\\n            ans=max(first,last);//store the ans which will return the max score for player 1 \\n        }\\n        else{// it\\'s player 2\\'s turn\\n            first=-v[i]+solve(dp,v,i+1,j,k+1); // pick the first element and subtract it from the score of player 1\\n            last=-v[j]+solve(dp,v,i,j-1,k+1); // pick the lastelement and subtract it from the score of player 1\\n            ans=min(first,last);//store the ans which will return the min score for player 1 \\n        }\\n        return dp[i][j]=ans;\\n    }\\n    bool PredictTheWinner(vector<int>&v) {\\n        int i,n=v.size();\\n        vector<vector<int>>dp(n,vector<int>(n,INT_MIN));\\n        return solve(dp,v,0,n-1,0)>=0; // ans >=0 implies player 1\\'s score is greater than player 2\\'s score\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int solve(int[][] dp,int []v,int i,int j,int k){\\n        if(i>j)return 0;\\n        if(dp[i][j]!=Integer.MIN_VALUE)return dp[i][j];\\n        int first=0,last=0,ans=0;\\n        if(k%2==0){// it\\'s player 1\\'s turn\\n            first=v[i]+solve(dp,v,i+1,j,k+1);// pick the first element and add it to the score of player 1\\n            last=v[j]+solve(dp,v,i,j-1,k+1);// pick the last element and add it to the score player 1\\n            ans=Math.max(first,last);//store the ans which will return the max score for player 1 \\n        }\\n        else{// it\\'s player 2\\'s turn\\n            first=-v[i]+solve(dp,v,i+1,j,k+1);// pick the first element and subtract it from the score of player 1\\n            last=-v[j]+solve(dp,v,i,j-1,k+1);// pick the lastelement and subtract it from the score of player 1\\n            ans=Math.min(first,last); //store the ans which will return the min score for player 1 \\n        }\\n        return dp[i][j]=ans;\\n    }\\n    public boolean PredictTheWinner(int[] v) {\\n        int i,n=v.length;\\n        int[][] dp=new int[n][n];\\n        for(i=0;i<n;i++)Arrays.fill(dp[i],Integer.MIN_VALUE);\\n        return solve(dp,v,0,n-1,0)>=0; // ans >=0 implies player 1\\'s score is greater than player 2\\'s score\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3826236,
                "title": "video-100-winning-strategy-with-dynamic-programming-code",
                "content": "# Intuition\\nWhen I first read the problem, I realized that it was a game theory problem with a twist of dynamic programming. The problem states that two players are playing a game where they can choose numbers from either ends of the array, and the player with the maximum total wins. The challenge is to determine if the first player can win or not, assuming both players are playing optimally.\\n\\nhttps://youtu.be/s_B77SzZ7T4\\n\\n# Approach\\nTo solve this problem, I leveraged dynamic programming (DP). The primary logic revolves around setting up a 2D DP array, `dp[i][j]`, where each cell signifies the maximum possible score the first player can achieve over the second player. This score is derived from a subarray of the original array, starting from index `i` to `j`.\\n\\nHere\\'s the detailed breakdown of the approach:\\n\\n1. **Initialization**: I initialized the DP array diagonally. This step was necessary because, when there is only one element left to pick (i.e., `i == j`), the player will take that number, and hence `dp[i][j] = nums[i]`.\\n\\n2. **State Transition**: For every cell `dp[i][j]` in the DP array, the first player has two choices: either pick the `i`-th number or the `j`-th number. Each choice leads to a different state:\\n\\n    - If the first player picks the `i`-th number, the remaining array becomes `nums[i+1 : j+1]`. Now it\\'s the second player\\'s turn. Given that the second player also plays optimally to maximize his net score, he will pick a number which leaves the first player with a minimum net score. This results in a state transition to `dp[i+1][j]`, causing the net score for the first player to be `nums[i] - dp[i+1][j]`.\\n\\n    - Similarly, if the first player picks the `j`-th number, the remaining array becomes `nums[i : j]`. This results in a state transition to `dp[i][j-1]`, leading to a net score for the first player of `nums[j] - dp[i][j-1]`.\\n\\n3. **Choice**: For each `dp[i][j]`, the first player will choose the maximum net score between the two possible state transitions. Hence, `dp[i][j] = max(nums[i] - dp[i+1][j], nums[j] - dp[i][j-1])`.\\n\\n4. **Final Decision**: I examined `dp[0][n-1]` to determine the outcome of the game. If `dp[0][n-1]` is non-negative, it means the first player can win or tie the game, so I returned `True`. Otherwise, I returned `False`. This is because `dp[0][n-1]` represents the maximum net score the first player can get over the second player by considering the entire array. If this score is non-negative, the first player can secure a win or at least a tie.\\n# Complexity\\n- Time complexity: The time complexity of this solution is \\\\(O(n^2)\\\\), where \\\\(n\\\\) is the length of the input array. This is because we have to fill up the \\\\(n \\\\times n\\\\) DP table.\\n\\n- Space complexity: The space complexity is also \\\\(O(n^2)\\\\) for the DP table. \\n\\nThis code follows the approach I mentioned above and solves the problem by building a dynamic programming table and then using that table to determine if the first player can win.\\n\\n# Code\\n``` Python []\\nclass Solution:\\n    def PredictTheWinner(self, nums: List[int]) -> bool:\\n        n = len(nums) \\n        dp = [[0]*n for _ in range(n)] \\n        for i in range(n-1, -1, -1): \\n            for j in range(i, n): \\n                if i == j: \\n                    dp[i][j] = nums[i] \\n                else: \\n                    dp[i][j] = max(nums[i] - dp[i+1][j], nums[j] - dp[i][j-1])    \\n        return dp[0][n-1] >= 0 \\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    bool PredictTheWinner(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<vector<int>> dp(n, vector<int>(n, 0));\\n        \\n        for (int i = n-1; i >= 0; --i) {\\n            for (int j = i; j < n; ++j) {\\n                if (i == j) {\\n                    dp[i][j] = nums[i];\\n                } else {\\n                    dp[i][j] = max(nums[i] - dp[i+1][j], nums[j] - dp[i][j-1]);\\n                }\\n            }\\n        }\\n        \\n        return dp[0][n-1] >= 0;\\n    }\\n};\\n```\\n``` Java []\\nclass Solution {\\n    public boolean PredictTheWinner(int[] nums) {\\n        int n = nums.length;\\n        int[][] dp = new int[n][n];\\n        \\n        for (int i = n-1; i >= 0; --i) {\\n            for (int j = i; j < n; ++j) {\\n                if (i == j) {\\n                    dp[i][j] = nums[i];\\n                } else {\\n                    dp[i][j] = Math.max(nums[i] - dp[i+1][j], nums[j] - dp[i][j-1]);\\n                }\\n            }\\n        }\\n        \\n        return dp[0][n-1] >= 0;\\n    }\\n}\\n```\\n``` JavaScript []\\n/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar PredictTheWinner = function(nums) {\\n    const n = nums.length;\\n    const dp = Array.from(Array(n), () => Array(n).fill(0));\\n    \\n    for (let i = n-1; i >= 0; --i) {\\n        for (let j = i; j < n; ++j) {\\n            if (i == j) {\\n                dp[i][j] = nums[i];\\n            } else {\\n                dp[i][j] = Math.max(nums[i] - dp[i+1][j], nums[j] - dp[i][j-1]);\\n            }\\n        }\\n    }\\n    \\n    return dp[0][n-1] >= 0;\\n};\\n```\\n``` C# []\\npublic class Solution {\\n    public bool PredictTheWinner(int[] nums) {\\n        int n = nums.Length;\\n        int[,] dp = new int[n, n];\\n        \\n        for (int i = n-1; i >= 0; --i) {\\n            for (int j = i; j < n; ++j) {\\n                if (i == j) {\\n                    dp[i, j] = nums[i];\\n                } else {\\n                    dp[i, j] = Math.Max(nums[i] - dp[i+1, j], nums[j] - dp[i, j-1]);\\n                }\\n            }\\n        }\\n        \\n        return dp[0, n-1] >= 0;\\n    }\\n}\\n```\\n\\n# Video for  C++\\nhttps://www.youtube.com/watch?v=5EbtcjwE2qw",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "C#",
                    "JavaScript"
                ],
                "code": "``` Python []\\nclass Solution:\\n    def PredictTheWinner(self, nums: List[int]) -> bool:\\n        n = len(nums) \\n        dp = [[0]*n for _ in range(n)] \\n        for i in range(n-1, -1, -1): \\n            for j in range(i, n): \\n                if i == j: \\n                    dp[i][j] = nums[i] \\n                else: \\n                    dp[i][j] = max(nums[i] - dp[i+1][j], nums[j] - dp[i][j-1])    \\n        return dp[0][n-1] >= 0 \\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    bool PredictTheWinner(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<vector<int>> dp(n, vector<int>(n, 0));\\n        \\n        for (int i = n-1; i >= 0; --i) {\\n            for (int j = i; j < n; ++j) {\\n                if (i == j) {\\n                    dp[i][j] = nums[i];\\n                } else {\\n                    dp[i][j] = max(nums[i] - dp[i+1][j], nums[j] - dp[i][j-1]);\\n                }\\n            }\\n        }\\n        \\n        return dp[0][n-1] >= 0;\\n    }\\n};\\n```\n``` Java []\\nclass Solution {\\n    public boolean PredictTheWinner(int[] nums) {\\n        int n = nums.length;\\n        int[][] dp = new int[n][n];\\n        \\n        for (int i = n-1; i >= 0; --i) {\\n            for (int j = i; j < n; ++j) {\\n                if (i == j) {\\n                    dp[i][j] = nums[i];\\n                } else {\\n                    dp[i][j] = Math.max(nums[i] - dp[i+1][j], nums[j] - dp[i][j-1]);\\n                }\\n            }\\n        }\\n        \\n        return dp[0][n-1] >= 0;\\n    }\\n}\\n```\n``` JavaScript []\\n/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar PredictTheWinner = function(nums) {\\n    const n = nums.length;\\n    const dp = Array.from(Array(n), () => Array(n).fill(0));\\n    \\n    for (let i = n-1; i >= 0; --i) {\\n        for (let j = i; j < n; ++j) {\\n            if (i == j) {\\n                dp[i][j] = nums[i];\\n            } else {\\n                dp[i][j] = Math.max(nums[i] - dp[i+1][j], nums[j] - dp[i][j-1]);\\n            }\\n        }\\n    }\\n    \\n    return dp[0][n-1] >= 0;\\n};\\n```\n``` C# []\\npublic class Solution {\\n    public bool PredictTheWinner(int[] nums) {\\n        int n = nums.Length;\\n        int[,] dp = new int[n, n];\\n        \\n        for (int i = n-1; i >= 0; --i) {\\n            for (int j = i; j < n; ++j) {\\n                if (i == j) {\\n                    dp[i, j] = nums[i];\\n                } else {\\n                    dp[i, j] = Math.Max(nums[i] - dp[i+1, j], nums[j] - dp[i, j-1]);\\n                }\\n            }\\n        }\\n        \\n        return dp[0, n-1] >= 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3828618,
                "title": "find-the-intuition-here",
                "content": "# Intuition\\nI was pretty confused seeing others solutions when they were using concept of MaxDifference >=0. It was not at all intuitive, atleast for me, heh! So i came up with this soltution for people like me who needs to find intuition behind everything.\\n\\n# Approach\\nIf you read the code, you will pretty much understand it because ive written it in very naive way, the only part where you can get stuck is the part where it is written (way1 && way2). **So why &?**\\n\\n*Copied from chatGPT to save my as well as your time.*\\nIn this game, both players play optimally, and each player wants to maximize their own score while minimizing their opponent\\'s score. When Player 1 is playing (i.e., now == 1), we use || because Player 1 can choose either the left end (nums[l]) or the right end (nums[r]) of the array, and we want to find a way for Player 1 to win by maximizing their score.\\n\\nHowever, when Player 2 is playing (i.e., now == 0), Player 2 wants to minimize Player 1\\'s score. Player 2 will take the turn that results in the smallest increase in Player 1\\'s score. This means that if either of the two moves (picking from the left end or the right end) increases Player 1\\'s score, Player 2 will prevent that move and choose the move that results in the smallest increase in Player 1\\'s score.\\n\\nTo achieve this, we use && (AND) in the else block. When Player 2 is playing, we want to return true only if both moves (picking from the left end and picking from the right end) result in an increase in Player 1\\'s score. If either of the moves reduces Player 1\\'s score or keeps it the same, Player 2 will choose that move to minimize Player 1\\'s score. So, we need both moves to be favorable for Player 1 (i.e., both way1 and way2 to be true) for Player 2 to choose that path.\\n\\nYou can memoize it using 3d dp[l][r][now] to reduce its time complexity to polynomial, which would have been exponential otherwise.\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nRecursion stack space only\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool solve(vector<int>& nums, int l, int r, int sc1, int sc2, bool now) {\\n        if (l > r) {\\n            return sc1 >= sc2;\\n        }\\n\\n        if (now == 1) {\\n            bool way1 = solve(nums, l + 1, r, sc1 + nums[l], sc2, !now);\\n            bool way2 = solve(nums, l, r - 1, sc1 + nums[r], sc2, !now);\\n\\n            return way1 || way2;\\n        } \\n        else {\\n            bool way1 = solve(nums, l + 1, r, sc1, sc2 + nums[l], !now);\\n            bool way2 = solve(nums, l, r - 1, sc1, sc2 + nums[r], !now);\\n            \\n            return way1 && way2; \\n        }\\n    }\\n\\n    bool PredictTheWinner(vector<int>& nums) {\\n        int n = nums.size();\\n\\n        return solve(nums, 0, n - 1, 0, 0, true);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool solve(vector<int>& nums, int l, int r, int sc1, int sc2, bool now) {\\n        if (l > r) {\\n            return sc1 >= sc2;\\n        }\\n\\n        if (now == 1) {\\n            bool way1 = solve(nums, l + 1, r, sc1 + nums[l], sc2, !now);\\n            bool way2 = solve(nums, l, r - 1, sc1 + nums[r], sc2, !now);\\n\\n            return way1 || way2;\\n        } \\n        else {\\n            bool way1 = solve(nums, l + 1, r, sc1, sc2 + nums[l], !now);\\n            bool way2 = solve(nums, l, r - 1, sc1, sc2 + nums[r], !now);\\n            \\n            return way1 && way2; \\n        }\\n    }\\n\\n    bool PredictTheWinner(vector<int>& nums) {\\n        int n = nums.size();\\n\\n        return solve(nums, 0, n - 1, 0, 0, true);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1707034,
                "title": "recursive-memoization-easy-to-understand",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int dp[22][22][2];\\n    vector <int> arr;\\n    int memo(int i , int j , int c){\\n        if(j < i)\\n          return 0;\\n        /*\\n            i = current front index\\n            j = current back index\\n            c = stores parity, c = 0 first player turn and c = 1 second player turn\\n        */\\n        \\n        int &ans = dp[i][j][c];\\n        \\n        if(ans != -1)\\n            return ans;\\n        /* \\n            The optimal approach for 1st player would be get the maximum, \\n            since he need to collect more than 2nd player, \\n            from either states he use which provides him maximum sum. \\n        */\\n        if(c == 0){\\n            ans = max(memo(i + 1 , j , 1 - c) + arr[i] , memo(i , j - 1 , 1 - c) + arr[j]) ;\\n        } else {\\n            /*\\n                In case of 2nd player, he is actually taking away the element he choses.\\n                And also tried to give back minimum possible to 1st player so he has minimal chances,\\n                to win.\\n            */\\n            ans = min(memo(i + 1 , j , 1 - c) - arr[i] , memo(i , j - 1 , 1 - c) - arr[j]) ;\\n        }\\n        return ans;\\n    }\\n    bool PredictTheWinner(vector<int>& nums) {\\n        int n = nums.size();\\n        for(int i = 0;i<n;i++){\\n            for(int j = 0;j<n;j++){\\n                dp[i][j][0] = dp[i][j][1] = -1;\\n            }\\n        }\\n        arr = nums;\\n        int ans = memo(0 , n-1 , 0) ;\\n        // If at the end 1st player can make 0 or more than zero Sum he can win\\n        return ans >= 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[22][22][2];\\n    vector <int> arr;\\n    int memo(int i , int j , int c){\\n        if(j < i)\\n          return 0;\\n        /*\\n            i = current front index\\n            j = current back index\\n            c = stores parity, c = 0 first player turn and c = 1 second player turn\\n        */\\n        \\n        int &ans = dp[i][j][c];\\n        \\n        if(ans != -1)\\n            return ans;\\n        /* \\n            The optimal approach for 1st player would be get the maximum, \\n            since he need to collect more than 2nd player, \\n            from either states he use which provides him maximum sum. \\n        */\\n        if(c == 0){\\n            ans = max(memo(i + 1 , j , 1 - c) + arr[i] , memo(i , j - 1 , 1 - c) + arr[j]) ;\\n        } else {\\n            /*\\n                In case of 2nd player, he is actually taking away the element he choses.\\n                And also tried to give back minimum possible to 1st player so he has minimal chances,\\n                to win.\\n            */\\n            ans = min(memo(i + 1 , j , 1 - c) - arr[i] , memo(i , j - 1 , 1 - c) - arr[j]) ;\\n        }\\n        return ans;\\n    }\\n    bool PredictTheWinner(vector<int>& nums) {\\n        int n = nums.size();\\n        for(int i = 0;i<n;i++){\\n            for(int j = 0;j<n;j++){\\n                dp[i][j][0] = dp[i][j][1] = -1;\\n            }\\n        }\\n        arr = nums;\\n        int ans = memo(0 , n-1 , 0) ;\\n        // If at the end 1st player can make 0 or more than zero Sum he can win\\n        return ans >= 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1304516,
                "title": "simple-and-easy-recursive-solution-in-c",
                "content": "```\\n int static check(vector<int>& nums,int i,int j,int chance){\\n        \\n        if(i>j) return (0);\\n        \\n        if(chance==0){\\n            return max(nums[i] + check(nums,i + 1,j,1),nums[j]+ check(nums,i,j-1,1));\\n        }else{\\n            return min(check(nums,i + 1,j,0) ,check(nums,i,j-1,0));\\n        }\\n    }\\n    bool PredictTheWinner(vector<int>& nums) {\\n       int player2=0;\\n        \\n        for(auto x:nums) player2+=x;\\n        \\n        \\n         int player1=check(nums,0,nums.size() - 1,0);\\n        player2-=player1;\\n        \\n        return player1>=player2;\\n    }\\n```\\n**Note: Thanks for seeing my approach.**",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\n int static check(vector<int>& nums,int i,int j,int chance){\\n        \\n        if(i>j) return (0);\\n        \\n        if(chance==0){\\n            return max(nums[i] + check(nums,i + 1,j,1),nums[j]+ check(nums,i,j-1,1));\\n        }else{\\n            return min(check(nums,i + 1,j,0) ,check(nums,i,j-1,0));\\n        }\\n    }\\n    bool PredictTheWinner(vector<int>& nums) {\\n       int player2=0;\\n        \\n        for(auto x:nums) player2+=x;\\n        \\n        \\n         int player1=check(nums,0,nums.size() - 1,0);\\n        player2-=player1;\\n        \\n        return player1>=player2;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 704868,
                "title": "java-simple-recursion",
                "content": "```\\nclass Solution {\\n        \\n    public boolean PredictTheWinner(int[] nums) {\\n        return dfs(0, nums.length - 1, 0, nums, true) >= 0;\\n    }\\n\\n    // p1 is player one score minus player 2; n is total visited\\n    public int dfs(int start, int end, int p1, int[] nums, boolean p1Turn) {\\n        // used all numbers\\n        if (start == end)\\n            return p1;\\n        \\n        int turn = p1Turn ? 1: 0;\\n        \\n        if (p1Turn) {\\n            int bottom = dfs(start + 1, end, p1 + nums[start], nums, false);\\n            int top = dfs(start, end - 1, p1 + nums[end], nums, false);\\n\\n            // this is the best play at this score\\n            return Math.max(top, bottom);\\n        } else {\\n            int bottom = dfs(start + 1, end, p1 - nums[start], nums, true);\\n            int top = dfs(start, end - 1, p1 - nums[end], nums, true);\\n            return Math.min(bottom, top);\\n        }        \\n    } \\n}",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "class Solution {\\n        \\n    public boolean PredictTheWinner(int[] nums) {\\n        return dfs(0, nums.length - 1, 0, nums, true) >= 0;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3826241,
                "title": "python-3-7-lines-iteration-t-m-99-100",
                "content": "```\\nclass Solution:\\n    def PredictTheWinner(self, nums: List[int]) -> bool:\\n\\n        arr = [0] * (n:= len(nums))\\n        \\n        for i in range(n-1,-1,-1):\\n            arr[i] = nums[i]\\n            \\n            for j in range(i+1, n):\\n                arr[j] = max(nums[i]-arr[j  ],\\n                             nums[j]-arr[j-1])\\n            \\n        return arr[n-1] >= 0\\n```\\n[https://leetcode.com/problems/predict-the-winner/submissions/884153215/](http://)\\n\\nI could be wrong, but I think that time complexity is *O*(*N*^2) and space complexity is *O*(*N*), in which *N* ~ `len(nums)`.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def PredictTheWinner(self, nums: List[int]) -> bool:\\n\\n        arr = [0] * (n:= len(nums))\\n        \\n        for i in range(n-1,-1,-1):\\n            arr[i] = nums[i]\\n            \\n            for j in range(i+1, n):\\n                arr[j] = max(nums[i]-arr[j  ],\\n                             nums[j]-arr[j-1])\\n            \\n        return arr[n-1] >= 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 643427,
                "title": "python-o-n-2-by-recursion-memoization-80-w-comment",
                "content": "Python O(n^2) by Dynamic Programming \\n\\n---\\n\\n**Implementation** by Dynamic Programming\\n\\n```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def PredictTheWinner(self, nums: List[int]) -> bool:\\n        \\n        # use dictionary as dynamic programming table, to store the score gap\\n        dp_table = defaultdict( int )\\n        \\n        def optimal_pick( nums: List, left: int, right: int):\\n            \\n            if left == right:\\n                # Only one choice remains\\n                return nums[left]\\n            \\n            if (left, right) in dp_table:\\n                # If this query has been computed before\\n                # directly return by dp table\\n                return dp_table[ (left, right) ]\\n            \\n            # Maximize and compute the score gap by recurrence relationship\\n\\t\\t\\t# \\n\\t\\t\\t# for player 1:\\n\\t\\t\\t# benefit of pick left = score of left - optimal pick of player 2 in ( left+1, right )\\n\\t\\t\\t# benefit of pick right = score of right - optimal pick of player 2 in ( left, right-1 )\\n            choose_left = nums[left] - optimal_pick( nums, left+1, right )\\n            choose_right = nums[right] - optimal_pick( nums, left, right-1 )\\n            \\n            dp_table[ (left, right) ] = max( choose_left, choose_right)\\n            return dp_table[ (left, right) ] \\n        \\n        # ------------------------------------------------------\\n        \\n        # score gap = score of player 1 - score of player 2\\n        # Player 1 is winner if score gap >= 0\\n        return optimal_pick( nums, left = 0, right = len(nums)-1 ) >= 0\\n```\\n\\n---\\n\\nRelated leetcode challenge:\\n\\n[Leetcode #887 Stone Game](https://leetcode.com/problems/stone-game/)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def PredictTheWinner(self, nums: List[int]) -> bool:\\n        \\n        # use dictionary as dynamic programming table, to store the score gap\\n        dp_table = defaultdict( int )\\n        \\n        def optimal_pick( nums: List, left: int, right: int):\\n            \\n            if left == right:\\n                # Only one choice remains\\n                return nums[left]\\n            \\n            if (left, right) in dp_table:\\n                # If this query has been computed before\\n                # directly return by dp table\\n                return dp_table[ (left, right) ]\\n            \\n            # Maximize and compute the score gap by recurrence relationship\\n\\t\\t\\t# \\n\\t\\t\\t# for player 1:\\n\\t\\t\\t# benefit of pick left = score of left - optimal pick of player 2 in ( left+1, right )\\n\\t\\t\\t# benefit of pick right = score of right - optimal pick of player 2 in ( left, right-1 )\\n            choose_left = nums[left] - optimal_pick( nums, left+1, right )\\n            choose_right = nums[right] - optimal_pick( nums, left, right-1 )\\n            \\n            dp_table[ (left, right) ] = max( choose_left, choose_right)\\n            return dp_table[ (left, right) ] \\n        \\n        # ------------------------------------------------------\\n        \\n        # score gap = score of player 1 - score of player 2\\n        # Player 1 is winner if score gap >= 0\\n        return optimal_pick( nums, left = 0, right = len(nums)-1 ) >= 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3826634,
                "title": "c-3ms-fastest-medium-problem-486-predict-the-winner",
                "content": "# C++ | Medium Problem | 486. Predict the Winner\\n```\\nclass Solution {\\npublic:\\n\\n    int dp[21][21];\\n    int solve(int start, int end, vector<int>& nums) {\\n          if(dp[start][end]!=-1)\\n        {\\n            return dp[start][end];\\n        }\\n        if (start == end) {\\n            return nums[start];\\n        }\\n      \\n        int pickStart = nums[start] - solve(start + 1, end, nums);\\n        int pickEnd = nums[end] - solve(start, end - 1, nums);\\n\\n        return dp[start][end]=max(pickStart, pickEnd);\\n    }\\n\\n    bool PredictTheWinner(vector<int>& nums) {\\n        int start = 0;\\n        int end = nums.size() - 1;\\n\\n        memset(dp,-1,sizeof(dp));\\n\\n        return solve(start, end, nums) >= 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int dp[21][21];\\n    int solve(int start, int end, vector<int>& nums) {\\n          if(dp[start][end]!=-1)\\n        {\\n            return dp[start][end];\\n        }\\n        if (start == end) {\\n            return nums[start];\\n        }\\n      \\n        int pickStart = nums[start] - solve(start + 1, end, nums);\\n        int pickEnd = nums[end] - solve(start, end - 1, nums);\\n\\n        return dp[start][end]=max(pickStart, pickEnd);\\n    }\\n\\n    bool PredictTheWinner(vector<int>& nums) {\\n        int start = 0;\\n        int end = nums.size() - 1;\\n\\n        memset(dp,-1,sizeof(dp));\\n\\n        return solve(start, end, nums) >= 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3829642,
                "title": "recursion-neat-solution-with-thought-process",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTask is to determine whether player1 can win the game or not . Just after reading the problem , first thought which came in mind is of picking the best option from either end i.e pick maximum of nums[left] and nums[right] but it is evident from example 2 , this will not work . Hence our greedy approach fails\\n\\nSo what next ?\\n\\nAs greedy fails hence we get the hint that we have to explore all the ways of choosing the values from either end , and this directs our mind in the direction of recursion\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe key idea is I will try to calculate the maximum score for the player one , if he cannot win the game even when he has maximum score then he can never win the game.\\n\\n##### Deciding the parameters of recursive function \\n\\nSo we can pick the number from the leftmost and rightmost end hence we will have to track the left and right\\n\\nAlso we need to know which player\\'s turn it is , i.e who is going to play this move so we need a turn variable \\n\\nHence left , right , turn and definately nums will be needed . So we will take these things in our recursive call \\n\\n\\n##### What should we do to satisfy optimality in moves for both the players\\n\\n1 ) turn = true \\n\\n it means it is P1 turn hence we will try to maximise the value which we can get , hence we have taken maximum of the values present at both the end .  \\n\\n2) turn = false\\n\\n it means it is P2 turn hence we will try to minimise the value which we can get , hence we have taken minimum of the values present at both the end . \\n\\nHence using this we will be easily able to maintain the optimal play\\n\\n\\nAt last this recursion will return us the maximum score possible for the player one , hence we will subtract this from total score possible i.e sum of elements of nums \\n\\nNow we just need to compare the two values , if the maximum score for player one is greater than that of two then it will return true otherwise false.\\n\\n# Complexity\\n- Time complexity: Exponential\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n\\nint play ( int left , int right , bool turn , vector<int>&nums)\\n{   \\n    // in this case no more moves are possible hence return 0\\n\\n    if( left > right)\\n    {\\n        return 0;\\n    }\\n    \\n    // turn = true means p1 is choosing hence he will choose such that sum of value maximises\\n    // turn  = false means p2 is choosing hence he will choose such that sum of value minimises for p1 \\n\\n    if( turn == true)\\n    {   \\n        // pick best from left and right i.e return maximum\\n\\n        int pick_left = nums[left] + play( left + 1 , right , false , nums);\\n        int pick_right = nums[right] + play( left , right - 1 , false , nums);\\n\\n        return max( pick_left , pick_right);\\n    }\\n    else\\n    {   \\n        // skip best from left and right i.e return minimum or worst\\n\\n        int skip_left = play( left + 1 , right , true , nums);\\n        int skip_right = play( left , right - 1 , true , nums);\\n\\n        return min( skip_left , skip_right);\\n    }\\n}\\n\\npublic:\\n    bool PredictTheWinner(vector<int>& nums) {\\n        \\n        // left right turn \\n\\n        // turn =  true means p1 will choose\\n        // turn = false means p2 will choose \\n        \\n        \\n        int sum = 0;\\n\\n        for( auto x : nums) sum += x;\\n\\n        int n = nums.size();\\n         \\n        int max_score_p1 = play( 0 , n-1 , true , nums);\\n        \\n        int max_score_p2 = sum - max_score_p1;\\n        \\n        // if p1 sum is greater than equal to p2 sum then return true\\n\\n        return max_score_p1 >= max_score_p2;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n\\nint play ( int left , int right , bool turn , vector<int>&nums)\\n{   \\n    // in this case no more moves are possible hence return 0\\n\\n    if( left > right)\\n    {\\n        return 0;\\n    }\\n    \\n    // turn = true means p1 is choosing hence he will choose such that sum of value maximises\\n    // turn  = false means p2 is choosing hence he will choose such that sum of value minimises for p1 \\n\\n    if( turn == true)\\n    {   \\n        // pick best from left and right i.e return maximum\\n\\n        int pick_left = nums[left] + play( left + 1 , right , false , nums);\\n        int pick_right = nums[right] + play( left , right - 1 , false , nums);\\n\\n        return max( pick_left , pick_right);\\n    }\\n    else\\n    {   \\n        // skip best from left and right i.e return minimum or worst\\n\\n        int skip_left = play( left + 1 , right , true , nums);\\n        int skip_right = play( left , right - 1 , true , nums);\\n\\n        return min( skip_left , skip_right);\\n    }\\n}\\n\\npublic:\\n    bool PredictTheWinner(vector<int>& nums) {\\n        \\n        // left right turn \\n\\n        // turn =  true means p1 will choose\\n        // turn = false means p2 will choose \\n        \\n        \\n        int sum = 0;\\n\\n        for( auto x : nums) sum += x;\\n\\n        int n = nums.size();\\n         \\n        int max_score_p1 = play( 0 , n-1 , true , nums);\\n        \\n        int max_score_p2 = sum - max_score_p1;\\n        \\n        // if p1 sum is greater than equal to p2 sum then return true\\n\\n        return max_score_p1 >= max_score_p2;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3827017,
                "title": "recursion-dp-with-english-and-hindi-proper-explanation-of-approach-and-intuition",
                "content": "# Intuition\\nWe will discover every possible options for player1 i.e. select from left or right and then return the maximum from these two options.\\nSo it is a Recursion problem.\\n# Approach\\nplayer1 first choose the left or right element available plus player2 will also select maximum from remaining array options so player1 just have option to select minimum. Lastly we will choose maximum from right and left so to maximise player1 score.\\nThen we will check if the player1 score>= player2 score.\\n# Complexity\\n- Time complexity:\\nO(N^2)\\n\\n- Space complexity:\\nO(N^2)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(vector<int>&nums,int i,int j,vector<vector<int>>&dp)\\n    {\\n        if(i>j)\\n        {\\n            return 0;\\n        }\\n        \\n        if(i==j)\\n        {\\n            return nums[i];\\n        }\\n        if(dp[i][j]!=-1)\\n        {\\n            return dp[i][j];\\n        }\\n\\n//player1 first choose the left or right element available plus player2 will also select maximum from remaining array options so player1 just have option to select minimum. Lastly we will choose maximum from right and left so to maximise player1 score.\\n\\n //player 1 ke pass kya options thi pehle jo element hai vo plus player 2 ne bhi max chuna hoga toh player 1 ke  pass min choose krne ka hi option hai aur hume left ya right dono mei se jo max deta hai voh option rakhni hai to maximise player 1 score.   \\n     \\nint left=nums[i]+min(solve(nums,i+2,j,dp),solve(nums,i+1,j-1,dp));\\n        int right=nums[j]+min(solve(nums,i+1,j-1,dp),solve(nums,i,j-2,dp));\\n\\n        return dp[i][j]=max(left,right);//max from left or right is optimal answer\\n    }\\n\\n    bool PredictTheWinner(vector<int>& nums) {\\n        int i=0,j=nums.size()-1;\\n        int total=0;\\n        for(auto ele:nums)\\n        {\\n            total+=ele;\\n        }\\n        vector<vector<int>>dp(j+1,vector<int>(j+1,-1));\\n        int p1score=solve(nums,i,j,dp);\\n        return p1score>=total-p1score;//player1 score>=player2 score\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Dynamic Programming",
                    "Recursion",
                    "Game Theory"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<int>&nums,int i,int j,vector<vector<int>>&dp)\\n    {\\n        if(i>j)\\n        {\\n            return 0;\\n        }\\n        \\n        if(i==j)\\n        {\\n            return nums[i];\\n        }\\n        if(dp[i][j]!=-1)\\n        {\\n            return dp[i][j];\\n        }\\n\\n//player1 first choose the left or right element available plus player2 will also select maximum from remaining array options so player1 just have option to select minimum. Lastly we will choose maximum from right and left so to maximise player1 score.\\n\\n //player 1 ke pass kya options thi pehle jo element hai vo plus player 2 ne bhi max chuna hoga toh player 1 ke  pass min choose krne ka hi option hai aur hume left ya right dono mei se jo max deta hai voh option rakhni hai to maximise player 1 score.   \\n     \\nint left=nums[i]+min(solve(nums,i+2,j,dp),solve(nums,i+1,j-1,dp));\\n        int right=nums[j]+min(solve(nums,i+1,j-1,dp),solve(nums,i,j-2,dp));\\n\\n        return dp[i][j]=max(left,right);//max from left or right is optimal answer\\n    }\\n\\n    bool PredictTheWinner(vector<int>& nums) {\\n        int i=0,j=nums.size()-1;\\n        int total=0;\\n        for(auto ele:nums)\\n        {\\n            total+=ele;\\n        }\\n        vector<vector<int>>dp(j+1,vector<int>(j+1,-1));\\n        int p1score=solve(nums,i,j,dp);\\n        return p1score>=total-p1score;//player1 score>=player2 score\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 215385,
                "title": "elegant-c-with-o-n-space",
                "content": "DP array stores the difference between the player\\'s score and the other player\\'s score. To reduce space to O(n), we iterate on the lengths of the subarrays (outer) and then the starting indices (inner).\\n\\nIf the difference is zero, then the player wins (according to the problem statement).\\n\\n```\\nclass Solution {\\npublic:\\n    bool PredictTheWinner(vector<int>& nums) {\\n        vector<int> r = nums;\\n        for (int m = 2; m <= nums.size(); m++) {\\n            for (int i = 0; i <= nums.size() - m; i++) {\\n                r[i] = max(nums[i] - r[i + 1], nums[i + m - 1] - r[i]);\\n            }\\n        }\\n        return r[0] >= 0;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool PredictTheWinner(vector<int>& nums) {\\n        vector<int> r = nums;\\n        for (int m = 2; m <= nums.size(); m++) {\\n            for (int i = 0; i <= nums.size() - m; i++) {\\n                r[i] = max(nums[i] - r[i + 1], nums[i + m - 1] - r[i]);\\n            }\\n        }\\n        return r[0] >= 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3830605,
                "title": "ex-amazon-explains-a-solution-with-a-video-python-javascript-java-and-c",
                "content": "# Intuition\\nUsing dynamic programming to calculate and keep the maximum difference in scores for all possible subarrays of nums.\\n\\nThis Python solution beats 99%. \\n\\n![Screen Shot 2023-07-28 at 16.52.34.png](https://assets.leetcode.com/users/images/dc189bef-77b9-48ed-832c-6ee834f65fd3_1690530771.867497.png)\\n\\n---\\n\\n# Solution Video\\n## *** Please upvote for this article. *** \\n\\nhttps://youtu.be/VReJJ1ZYeIk\\n\\n# Subscribe to my channel from here. I have 233 videos as of July 28th\\nhttp://www.youtube.com/channel/UC9RMNwYTL3SXCP6ShLWVFww?sub_confirmation=1\\n\\n---\\n\\n# Approach\\nThis is based on Python solution. Other languages might be different a bit.\\n\\n1. Initialize a variable `n` with the length of the input array `nums`.\\n\\n2. Create a new array `max_diff` of length `n` and fill it with zeros. This array will store the maximum difference in scores that the first player can achieve in each subarray.\\n\\n3. Start a loop from `i = n - 1` to `i = 0` (inclusive) using a step of `-1`.\\n\\n4. Inside the outer loop, set the value of `max_diff[i]` to the value of `nums[i]`. This means, initially, the maximum difference the first player can achieve when selecting only one number is the value of that number itself.\\n\\n5. Start an inner loop from `j = i + 1` to `j = n - 1` (inclusive).\\n\\n6. Inside the inner loop, update the value of `max_diff[j]` by taking the maximum of two choices:\\n   - The difference between `nums[i]` and the value of `max_diff[j]`.\\n   - The difference between `nums[j]` and the value of `max_diff[j - 1]`.\\n\\n   This step calculates the maximum difference the first player can achieve when selecting from the subarray `nums[i:j+1]` and updates `max_diff[j]` accordingly.\\n\\n7. After both loops are completed, the `max_diff` array will be fully calculated, and it will represent the maximum difference in scores that the first player can achieve for each subarray.\\n\\n8. Finally, check if `max_diff[n - 1]` is greater than or equal to 0. If it is, it means the first player can achieve a non-negative score difference, and thus the function returns `True`, indicating that the first player can win. Otherwise, the function returns `False`, indicating that the first player cannot win.\\n\\nThis algorithm uses dynamic programming to efficiently calculate the maximum difference in scores for all possible subarrays of `nums`, allowing the function to determine whether the first player can win with an optimal strategy.\\n\\n# Complexity\\n- Time complexity: O(n^2)\\nWe have nested loop to calculate the maximum difference in score.\\n\\n- Space complexity: O(n)\\nWe use max_diff to keep the maximum difference.\\n\\n```python []\\nclass Solution:\\n    def PredictTheWinner(self, nums: List[int]) -> bool:\\n        n = len(nums)\\n        max_diff = [0] * n\\n\\n        for i in range(n - 1, -1, -1):\\n            max_diff[i] = nums[i]\\n            for j in range(i + 1, n):\\n                max_diff[j] = max(nums[i] - max_diff[j], nums[j] - max_diff[j - 1])\\n        \\n        return max_diff[n - 1] >= 0\\n```\\n```javascript []\\n/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar PredictTheWinner = function(nums) {\\n    const n = nums.length;\\n    const max_diff = new Array(n).fill(0);\\n\\n    for (let i = n - 1; i >= 0; i--) {\\n        max_diff[i] = nums[i];\\n        for (let j = i + 1; j < n; j++) {\\n            max_diff[j] = Math.max(nums[i] - max_diff[j], nums[j] - max_diff[j - 1]);\\n        }\\n    }\\n\\n    return max_diff[n - 1] >= 0;    \\n};\\n```\\n```java []\\nlass Solution {\\n    public boolean PredictTheWinner(int[] nums) {\\n        int n = nums.length;\\n        int[] max_diff = new int[n];\\n\\n        for (int i = n - 1; i >= 0; i--) {\\n            max_diff[i] = nums[i];\\n            for (int j = i + 1; j < n; j++) {\\n                max_diff[j] = Math.max(nums[i] - max_diff[j], nums[j] - max_diff[j - 1]);\\n            }\\n        }\\n\\n        return max_diff[n - 1] >= 0;        \\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    bool PredictTheWinner(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> max_diff(n, 0);\\n\\n        for (int i = n - 1; i >= 0; i--) {\\n            max_diff[i] = nums[i];\\n            for (int j = i + 1; j < n; j++) {\\n                max_diff[j] = max(nums[i] - max_diff[j], nums[j] - max_diff[j - 1]);\\n            }\\n        }\\n\\n        return max_diff[n - 1] >= 0;        \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "JavaScript"
                ],
                "code": "```python []\\nclass Solution:\\n    def PredictTheWinner(self, nums: List[int]) -> bool:\\n        n = len(nums)\\n        max_diff = [0] * n\\n\\n        for i in range(n - 1, -1, -1):\\n            max_diff[i] = nums[i]\\n            for j in range(i + 1, n):\\n                max_diff[j] = max(nums[i] - max_diff[j], nums[j] - max_diff[j - 1])\\n        \\n        return max_diff[n - 1] >= 0\\n```\n```javascript []\\n/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar PredictTheWinner = function(nums) {\\n    const n = nums.length;\\n    const max_diff = new Array(n).fill(0);\\n\\n    for (let i = n - 1; i >= 0; i--) {\\n        max_diff[i] = nums[i];\\n        for (let j = i + 1; j < n; j++) {\\n            max_diff[j] = Math.max(nums[i] - max_diff[j], nums[j] - max_diff[j - 1]);\\n        }\\n    }\\n\\n    return max_diff[n - 1] >= 0;    \\n};\\n```\n```java []\\nlass Solution {\\n    public boolean PredictTheWinner(int[] nums) {\\n        int n = nums.length;\\n        int[] max_diff = new int[n];\\n\\n        for (int i = n - 1; i >= 0; i--) {\\n            max_diff[i] = nums[i];\\n            for (int j = i + 1; j < n; j++) {\\n                max_diff[j] = Math.max(nums[i] - max_diff[j], nums[j] - max_diff[j - 1]);\\n            }\\n        }\\n\\n        return max_diff[n - 1] >= 0;        \\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    bool PredictTheWinner(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> max_diff(n, 0);\\n\\n        for (int i = n - 1; i >= 0; i--) {\\n            max_diff[i] = nums[i];\\n            for (int j = i + 1; j < n; j++) {\\n                max_diff[j] = max(nums[i] - max_diff[j], nums[j] - max_diff[j - 1]);\\n            }\\n        }\\n\\n        return max_diff[n - 1] >= 0;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3826282,
                "title": "c-beats-100-in-0ms-iterative-approach-complexity-o-n-easy-dp-solution",
                "content": "# Approach :\\n so here A.T.Q we have to see if playe1 have more points than player2 or not and we have to return true or false accordingly. and also first chance is of player1 and then player2 will play. Here one more thing given as they can choose points either from first or last , and once one point selected that will removed from array. \\n\\nso here what i have done is - i have created a 2d dp [i][j] to store the difference . now what difference ? the difference btw player1 and player2 selected value. and we save difference as player1-player2. hence if value is negative means player2 wins and if value is +ve means player 1 wins. but we can\\'t decide it by just taking single value. hence here we go threw whole array till every index value is taken by players .\\n\\nnow you might confusing in how i am saving and assigning values , then for that here understand this part approach - \\n\\nwe have two choices for both players. let talk about player1 .\\n \\ninitially i=0 and j=nums.size()-1;\\n1. Let player1 picks nums[i], then the remaining subarray becomes nums[i+1] to num[j]. In this case, the score difference will be = nums[i] - dp[i+1][j] .\\n2. If player1 picks nums[j], then the remaining subarray becomes nums[i]to num[j-1]. In this case, the score difference will be = nums[j] - dp[i][j-1];\\n\\nAnd the max difference of 1 and 2 will be pushed in dp.\\n\\nand  reason for using dynamic programming here is to store and reuse intermediate results efficiently.and here the values in dp will store the maximum score difference possible in each step. and the final difference will be stored in dp[0][n-1];\\n\\nif dp[0][n-1]>0 it return TRUE , else FALSE !\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n^2) & O(n) both codes respectively\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n\\n# Code with space complexity - O(n^2) Beats 100% in 0 ms\\n```\\nclass Solution {\\npublic:\\n    bool PredictTheWinner(vector<int>& nums) {\\n        int n = nums.size();\\n    vector<vector<int>> dp(n, vector<int>(n, 0));\\n\\n    for (int i = 0; i < n; i++) {\\n        dp[i][i] = nums[i];\\n    }\\n\\n    for (int len = 2; len <= n; len++) {\\n        for (int i = 0; i <= n - len; i++) {\\n            int j = i + len - 1;\\n\\n   dp[i][j] = max(nums[i] - dp[i + 1][j], nums[j] - dp[i][j - 1]);\\n\\n        }\\n    }\\n    return dp[0][n - 1] >= 0;\\n    }\\n};\\n```\\n\\n# Code with space complety - O(n) but it beats 70% with 3ms\\n```\\nclass Solution {\\npublic:\\n    bool PredictTheWinner(vector<int>& nums) {\\n        int n = nums.size();\\n    vector<int> dp(n, 0);\\n\\n   for (int i = 0; i < n; i++) {\\n        dp[i] = nums[i];\\n    }\\n\\n   for (int len = 2; len <= n; len++) {\\n        for (int i = 0; i <= n - len; i++) {\\n            int j = i + len - 1;\\n dp[i] = max(nums[i] - dp[i + 1], nums[j] - dp[i]);\\n        }\\n    }\\n\\n    return dp[0] >= 0;\\n    }\\n};\\n```\\n\\n# Code Explanation 1st one : \\n\\n    // Base case: when there\\'s only one element, the player can get that score.\\n    for (int i = 0; i < n; i++) {\\n        dp[i][i] = nums[i];\\n    }\\n\\n    // Filling the dp table diagonally.\\n    for (int len = 2; len <= n; len++) {\\n        for (int i = 0; i <= n - len; i++) {\\n            int j = i + len - 1;\\n            // Player 1 chooses the number from the beginning (nums[i]) or the end (nums[j])\\n            // and the other player (Player 2) will take the best option.\\n            dp[i][j] = max(nums[i] - dp[i + 1][j], nums[j] - dp[i][j - 1]);\\n        }\\n    }\\n\\n    // The final value in dp table will represent the maximum score difference between Player 1 and Player 2.\\n    // If it\\'s positive or zero, Player 1 wins.\\n    return dp[0][n - 1] >= 0;\\n\\n# Code explanation for O(n) space complexity -\\n\\n    // Base case: when there\\'s only one element, the player can get that score.\\n    for (int i = 0; i < n; i++) {\\n        dp[i] = nums[i];\\n    }\\n\\n    // Filling the DP array\\n    for (int len = 2; len <= n; len++) {\\n        for (int i = 0; i <= n - len; i++) {\\n            int j = i + len - 1;\\n            // Player 1 chooses the number from the beginning (nums[i]) or the end (nums[j])\\n            // and the other player (Player 2) will take the best option.\\n            dp[i] = max(nums[i] - dp[i + 1], nums[j] - dp[i]);\\n        }\\n    }\\n\\n    // The final value in dp array will represent the maximum score difference between Player 1 and Player 2.\\n    // If it\\'s positive or zero, Player 1 wins.\\n    return dp[0] >= 0;\\n}\\n\\n\\n\\n\\n![upvote1.jpg](https://assets.leetcode.com/users/images/f02e4a1e-27ad-4f20-b423-f90f4bb25591_1690507312.9389474.jpeg)\\n\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool PredictTheWinner(vector<int>& nums) {\\n        int n = nums.size();\\n    vector<vector<int>> dp(n, vector<int>(n, 0));\\n\\n    for (int i = 0; i < n; i++) {\\n        dp[i][i] = nums[i];\\n    }\\n\\n    for (int len = 2; len <= n; len++) {\\n        for (int i = 0; i <= n - len; i++) {\\n            int j = i + len - 1;\\n\\n   dp[i][j] = max(nums[i] - dp[i + 1][j], nums[j] - dp[i][j - 1]);\\n\\n        }\\n    }\\n    return dp[0][n - 1] >= 0;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool PredictTheWinner(vector<int>& nums) {\\n        int n = nums.size();\\n    vector<int> dp(n, 0);\\n\\n   for (int i = 0; i < n; i++) {\\n        dp[i] = nums[i];\\n    }\\n\\n   for (int len = 2; len <= n; len++) {\\n        for (int i = 0; i <= n - len; i++) {\\n            int j = i + len - 1;\\n dp[i] = max(nums[i] - dp[i + 1], nums[j] - dp[i]);\\n        }\\n    }\\n\\n    return dp[0] >= 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 96884,
                "title": "java-7ms-recursion-solution-with-explaination-easy-to-understand",
                "content": "```\\npublic class Solution {\\n    public boolean PredictTheWinner(int[] nums) {\\n        if(nums.length <= 1){\\n            return true;\\n        }\\n        return canWin(nums, 0, nums.length-1, 0, 0);\\n    }\\n    private boolean canWin(int[] nums, int left, int right, int fistScore, int secondScore){\\n        // assume fistScore is the score of current player (to pick in this round)\\n        if(left > right){\\n            return fistScore >= secondScore;\\n        }\\n        fistScore += nums[left++]; //  pick left\\n        if(!canWin(nums, left, right, secondScore, fistScore)){ \\n        // check if next player can win. if next player cannot win, return true, which means the current player can win \\n            return true;\\n        }\\n        // backtrack\\n        left--;\\n        fistScore -= nums[left];\\n        // pick right;\\n        fistScore += nums[right--];\\n        if(!canWin(nums, left, right, secondScore, fistScore)){\\n        //check if next player can win\\n            return true;\\n        }\\n        right++;\\n        fistScore -= nums[right];\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public boolean PredictTheWinner(int[] nums) {\\n        if(nums.length <= 1){\\n            return true;\\n        }\\n        return canWin(nums, 0, nums.length-1, 0, 0);\\n    }\\n    private boolean canWin(int[] nums, int left, int right, int fistScore, int secondScore){\\n        // assume fistScore is the score of current player (to pick in this round)\\n        if(left > right){\\n            return fistScore >= secondScore;\\n        }\\n        fistScore += nums[left++]; //  pick left\\n        if(!canWin(nums, left, right, secondScore, fistScore)){ \\n        // check if next player can win. if next player cannot win, return true, which means the current player can win \\n            return true;\\n        }\\n        // backtrack\\n        left--;\\n        fistScore -= nums[left];\\n        // pick right;\\n        fistScore += nums[right--];\\n        if(!canWin(nums, left, right, secondScore, fistScore)){\\n        //check if next player can win\\n            return true;\\n        }\\n        right++;\\n        fistScore -= nums[right];\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2555814,
                "title": "c-recursion-memoization-tabulation-clean-code",
                "content": "# Method - 1 [Recursion]\\n![image](https://assets.leetcode.com/users/images/1404b21b-c106-44dd-9988-109ec4b65126_1662738888.887507.png)\\n\\n**T->O(Expo) && S->O(n) [Recursion Stack Space]**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint f(int i,int j,vector<int>& nums){\\n\\t\\t\\tif(i>j) return 0;\\n\\t\\t\\tint a= nums[i]+ min(f(i+2,j,nums),f(i+1,j-1,nums));\\n\\t\\t\\tint b= nums[j]+ min(f(i+1,j-1,nums),f(i,j-2,nums));\\n\\t\\t\\treturn max(a,b);\\n\\t\\t}\\n\\n\\t\\tbool PredictTheWinner(vector<int>& nums) {\\n\\t\\t\\tint n=nums.size();\\n\\t\\t\\tint p1=f(0,n-1,nums);  \\n\\t\\t\\tint p2=accumulate(nums.begin(),nums.end(),0)-p1;\\n\\t\\t\\treturn p1>=p2;\\n\\t\\t}\\n\\t};\\n\\t\\n# Method - 2 [Memoization]\\n\\n![image](https://assets.leetcode.com/users/images/493dea8a-428a-44d9-bd11-c453be1e5a53_1662739431.794526.png)\\n\\n**T->O(n^2) && S->O(n^2) && O(n) [Recursion Stack Space]**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint f(int i,int j,vector<int>& nums,vector<vector<int>>& dp){\\n\\t\\t\\tif(i>j) return 0;\\n\\t\\t\\tif(dp[i][j]!=-1) return dp[i][j];\\n\\t\\t\\tint a= nums[i]+ min(f(i+2,j,nums,dp),f(i+1,j-1,nums,dp));\\n\\t\\t\\tint b= nums[j]+ min(f(i+1,j-1,nums,dp),f(i,j-2,nums,dp));\\n\\t\\t\\treturn dp[i][j]=max(a,b);\\n\\t\\t}\\n\\n\\t\\tbool PredictTheWinner(vector<int>& nums) {\\n\\t\\t\\tint n=nums.size();\\n\\t\\t\\tvector<vector<int>> dp(n,vector<int>(n,-1));\\n\\t\\t\\tint p1=f(0,n-1,nums,dp);  \\n\\t\\t\\tint p2=accumulate(nums.begin(),nums.end(),0)-p1;\\n\\t\\t\\treturn p1>=p2;\\n\\t\\t}\\n\\t};\\n\\n# Method -3 [Tabulation]\\n![image](https://assets.leetcode.com/users/images/08c5ace7-7ada-4ae4-bb87-3f117beb40a4_1662780316.0806363.png)\\n\\n# T->O(n^2) &&. S->O(n^2)\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tbool PredictTheWinner(vector<int>& nums) {\\n\\t\\t\\tint n=nums.size();\\n\\t\\t\\tif(n%2==0) return true;\\n\\t\\t\\tvector<vector<int>> dp(n,vector<int>(n,0));\\n\\t\\t\\tfor(int k=0;k<n;k++) dp[k][k]=nums[k];\\n\\t\\t\\tfor(int i=n-3;i>=0;i--){\\n\\t\\t\\t\\tfor(int j=i+1;j<n;j++){\\n\\t\\t\\t\\t\\tif(j-2<0) continue;\\n\\t\\t\\t\\t\\tint a = nums[i] + min(dp[i+2][j],dp[i+1][j-1]);\\n\\t\\t\\t\\t\\tint b = nums[j] + min(dp[i+1][j-1],dp[i][j-2]);\\n\\t\\t\\t\\t\\tdp[i][j]=max(a,b);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tint p1=dp[0][n-1];  \\n\\t\\t\\tint p2=accumulate(nums.begin(),nums.end(),0)-p1;\\n\\t\\t\\treturn p1>=p2;\\n\\t\\t}\\n\\t};\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint f(int i,int j,vector<int>& nums){\\n\\t\\t\\tif(i>j) return 0;\\n\\t\\t\\tint a= nums[i]+ min(f(i+2,j,nums),f(i+1,j-1,nums));\\n\\t\\t\\tint b= nums[j]+ min(f(i+1,j-1,nums),f(i,j-2,nums));\\n\\t\\t\\treturn max(a,b);\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1686992,
                "title": "recursion-to-top-down-dp",
                "content": "**Recursion (276ms)**\\n```\\nclass Solution {\\n    public boolean PredictTheWinner(int[] nums) {\\n          int ans = sol(nums, nums.length, 0, nums.length - 1, true);\\n            int sum = 0;\\n            for (int i = 0; i < nums.length; i++) {\\n              sum += nums[i];\\n            }\\n            sum -= ans;\\n            return ans>=sum;\\n    }\\n\\t\\n\\t//If player variable is true then its player 1 move\\n      private static int sol(int[] arr, int n, int i, int j, Boolean player) {\\n        if (i > j)\\n          return 0;\\n\\n        if (player) {\\n\\t\\t// We want maximum result for player 1 case\\n\\t\\t// If we inclued ith element then we have to discard that element for further moves\\n\\t\\t// Same goes for jth element\\n          return Math.max(arr[i] + sol(arr, n, i + 1, j, !player), arr[j] + sol(arr, n, i, j - 1, !player));\\n        } else {\\n\\t\\t// We want minimum result for player 2 case\\n\\t\\t// if Player 2 picks ith element  then we have to discard that element for further moves \\n\\t\\t// Same goes for jth element\\n          return Math.min(sol(arr, n, i + 1, j, !player), sol(arr, n, i, j - 1, !player));\\n        }\\n      }\\n}\\n```\\n\\n**memorization (1ms)**\\n```\\nclass Solution {\\n    public boolean PredictTheWinner(int[] nums) {\\n            int[][] mem = new int[nums.length][nums.length];\\n\\t\\t\\tfor (int i = 0; i < mem.length; i++) {\\n\\t\\t\\t\\t for (int j = 0; j < mem.length; j++) {\\n\\t\\t\\t\\t\\tmem[i][j] = -1;\\n\\t\\t\\t\\t }\\n\\t\\t\\t }\\n            int ans = sol(nums, nums.length, 0, nums.length - 1,mem, true);\\n            int sum = 0;\\n            for (int i = 0; i < nums.length; i++) {\\n              sum += nums[i];\\n            }\\n            sum -= ans;\\n            return ans>=sum;\\n    }\\n    \\n    private static int sol(int[] arr, int n, int i, int j, int[][] mem, Boolean player) {\\n\\t\\tif (i > j)\\n\\t\\t  return 0;\\n\\t\\t // if mem[i][j] has already been computed we do not\\n\\t\\t // do further recursive calls and hence reduce\\n\\t\\t // the number of repeated work \\n\\t\\tif(mem[i][j] != -1){\\n\\t\\t  return mem[i][j];\\n\\t\\t}\\n\\t\\tif (player) {\\n\\t\\t  mem[i][j] =  Math.max(arr[i] + sol(arr, n, i + 1, j, mem,!player), arr[j] + sol(arr, n, i, j - 1,mem, !player));\\n\\t\\t} else {\\n\\t\\t  mem[i][j] =  Math.min(sol(arr, n, i + 1, j, mem,!player), sol(arr, n, i, j - 1,mem, !player));\\n\\t\\t}\\n\\t\\treturn mem[i][j];\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public boolean PredictTheWinner(int[] nums) {\\n          int ans = sol(nums, nums.length, 0, nums.length - 1, true);\\n            int sum = 0;\\n            for (int i = 0; i < nums.length; i++) {\\n              sum += nums[i];\\n            }\\n            sum -= ans;\\n            return ans>=sum;\\n    }\\n\\t\\n\\t//If player variable is true then its player 1 move\\n      private static int sol(int[] arr, int n, int i, int j, Boolean player) {\\n        if (i > j)\\n          return 0;\\n\\n        if (player) {\\n\\t\\t// We want maximum result for player 1 case\\n\\t\\t// If we inclued ith element then we have to discard that element for further moves\\n\\t\\t// Same goes for jth element\\n          return Math.max(arr[i] + sol(arr, n, i + 1, j, !player), arr[j] + sol(arr, n, i, j - 1, !player));\\n        } else {\\n\\t\\t// We want minimum result for player 2 case\\n\\t\\t// if Player 2 picks ith element  then we have to discard that element for further moves \\n\\t\\t// Same goes for jth element\\n          return Math.min(sol(arr, n, i + 1, j, !player), sol(arr, n, i, j - 1, !player));\\n        }\\n      }\\n}\\n```\n```\\nclass Solution {\\n    public boolean PredictTheWinner(int[] nums) {\\n            int[][] mem = new int[nums.length][nums.length];\\n\\t\\t\\tfor (int i = 0; i < mem.length; i++) {\\n\\t\\t\\t\\t for (int j = 0; j < mem.length; j++) {\\n\\t\\t\\t\\t\\tmem[i][j] = -1;\\n\\t\\t\\t\\t }\\n\\t\\t\\t }\\n            int ans = sol(nums, nums.length, 0, nums.length - 1,mem, true);\\n            int sum = 0;\\n            for (int i = 0; i < nums.length; i++) {\\n              sum += nums[i];\\n            }\\n            sum -= ans;\\n            return ans>=sum;\\n    }\\n    \\n    private static int sol(int[] arr, int n, int i, int j, int[][] mem, Boolean player) {\\n\\t\\tif (i > j)\\n\\t\\t  return 0;\\n\\t\\t // if mem[i][j] has already been computed we do not\\n\\t\\t // do further recursive calls and hence reduce\\n\\t\\t // the number of repeated work \\n\\t\\tif(mem[i][j] != -1){\\n\\t\\t  return mem[i][j];\\n\\t\\t}\\n\\t\\tif (player) {\\n\\t\\t  mem[i][j] =  Math.max(arr[i] + sol(arr, n, i + 1, j, mem,!player), arr[j] + sol(arr, n, i, j - 1,mem, !player));\\n\\t\\t} else {\\n\\t\\t  mem[i][j] =  Math.min(sol(arr, n, i + 1, j, mem,!player), sol(arr, n, i, j - 1,mem, !player));\\n\\t\\t}\\n\\t\\treturn mem[i][j];\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1430698,
                "title": "c-solution-recursion-without-dp-and-approach",
                "content": "The approach is that for Player1 to have a chance to win ..\\n\\nPlayer1 can choose from 2 options(  Possibly one would lead to victory and one would lead to defeat  OR both lead to victory OR both lead to defeat)\\nIf any one leads to victory OR both lead to victory ,our Player1 can win as he will choose optimally.\\nSo use OR for both the options(i.e choosing the first or the last element).\\n\\nThen Player2 chooses and he also has 2 options(  Possibly one would lead to victory of Player1 and one would lead to defeat  of Player1 OR both lead to victory of Player1 OR both lead to defeat of Player1).\\nSo even if one option leads to defeat of Player1, Player1 will lose as Player 2 also plays optimally and will choose that option such that Player1 loses.\\nSo use AND here (if both the options lead to victory of Player1 only then player 1 can win) .\\n\\nTo check whose turn it is just use a counter variable and if counter is odd its Player1 turn and Player2\\'s if its even..\\n\\n```\\nclass Solution {\\npublic:\\n    bool PredictTheWinner(vector<int>& num) {\\n\\n        return solve(0,0,0,num.size(),1,num);\\n    }\\n    \\n    bool solve(int sum1,int sum2,int i,int n,int c,vector<int>& nums)\\n    {\\n        \\n        if(n<=i)\\n        {\\n            if(sum1>=sum2)\\n                return true;\\n            else\\n                return false;\\n        }\\n        \\n        if(c%2==1)\\n            return solve(sum1+nums[n-1],sum2,i,n-1,c+1,nums)||solve(sum1+nums[i],sum2,i+1,n,c+1,nums);\\n        else\\n            return solve(sum1,sum2+nums[n-1],i,n-1,c+1,nums)&&solve(sum1,sum2+nums[i],i+1,n,c+1,nums);\\n            \\n            \\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool PredictTheWinner(vector<int>& num) {\\n\\n        return solve(0,0,0,num.size(),1,num);\\n    }\\n    \\n    bool solve(int sum1,int sum2,int i,int n,int c,vector<int>& nums)\\n    {\\n        \\n        if(n<=i)\\n        {\\n            if(sum1>=sum2)\\n                return true;\\n            else\\n                return false;\\n        }\\n        \\n        if(c%2==1)\\n            return solve(sum1+nums[n-1],sum2,i,n-1,c+1,nums)||solve(sum1+nums[i],sum2,i+1,n,c+1,nums);\\n        else\\n            return solve(sum1,sum2+nums[n-1],i,n-1,c+1,nums)&&solve(sum1,sum2+nums[i],i+1,n,c+1,nums);\\n            \\n            \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3827901,
                "title": "c-easy-and-clean-code",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool helper(int start, int end,int a, int b, int flag, vector<int>& nums){\\n        if(start>end)return a>=b;\\n        bool sum;\\n        if(flag==1){\\n            sum = helper(start+1,end,a+nums[start],b,2,nums)||helper(start,end-1,a+nums[end],b,2,nums);\\n        }\\n        else{\\n            sum = helper(start+1,end,a,b+nums[start],1,nums)&&helper(start,end-1,a,b+nums[end],1,nums);\\n        }\\n        return sum;\\n    }\\n    bool PredictTheWinner(vector<int>& nums) {\\n        return helper(0,nums.size()-1,0,0,1,nums);\\n    }\\n};\\n```\\n\\n```\\n\\n  int   int   if if if  set       set   OOO    for for for EEEEE  \\n  int   int   if    if   set     set  O     O      for     E      \\n  int   int   if if if    set   set   O     O      for     EEE    \\n  int   int   if           set set    O     O      for     E      \\n   int int    if             set        OOO        for     EEEEE  \\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool helper(int start, int end,int a, int b, int flag, vector<int>& nums){\\n        if(start>end)return a>=b;\\n        bool sum;\\n        if(flag==1){\\n            sum = helper(start+1,end,a+nums[start],b,2,nums)||helper(start,end-1,a+nums[end],b,2,nums);\\n        }\\n        else{\\n            sum = helper(start+1,end,a,b+nums[start],1,nums)&&helper(start,end-1,a,b+nums[end],1,nums);\\n        }\\n        return sum;\\n    }\\n    bool PredictTheWinner(vector<int>& nums) {\\n        return helper(0,nums.size()-1,0,0,1,nums);\\n    }\\n};\\n```\n```\\n\\n  int   int   if if if  set       set   OOO    for for for EEEEE  \\n  int   int   if    if   set     set  O     O      for     E      \\n  int   int   if if if    set   set   O     O      for     EEE    \\n  int   int   if           set set    O     O      for     E      \\n   int int    if             set        OOO        for     EEEEE  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3282867,
                "title": "486-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Define a function named \"PredictTheWinner\" that takes in an integer array \"nums\" and returns a boolean value.\\n2. Create a 2D array named \"dp\" with dimensions len(nums) x len(nums) and initialize all values to 0.\\n3. Fill the diagonal of \"dp\" with the values of \"nums\", since the subarray starting and ending at the same index will only contain one number.\\n4. Iterate through \"dp\" starting at the second diagonal and working our way up:For each cell (i,j), calculate the maximum score difference between player 1 and player 2 for the subarray starting at index i and ending at index j.\\nTo calculate the maximum score difference, player 1 can either choose the number at index i or index j.\\nIf player 1 chooses the number at index i, then player 2 will play optimally and take the maximum score difference for the subarray starting at index i+1 and ending at j. Player 1 will then be left with the subarray starting at index i+2 and ending at j, where they can choose either the number at index i+2 or index j.\\nIf player 1 chooses the number at index j, then player 2 will play optimally and take the maximum score difference for the subarray starting at index i and ending at j-1. Player 1 will then be left with the subarray starting at index i+1 and ending at j-1, where they can choose either the number at index i+1 or index j-1.\\nSet the value of cell (i,j) in \"dp\" to the maximum score difference calculated.\\n5. If the maximum score difference for the subarray starting at index 0 and ending at the last index of \"nums\" is greater than or equal to 0, then return True (player 1 can win). Otherwise, return False.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n  def PredictTheWinner(self, nums: List[int]) -> bool:\\n    # Create a 2D array to store the maximum score difference between \\n    # player 1 and player 2 for the subarray starting at index i and \\n    # ending at index j\\n    dp = [[0] * len(nums) for _ in range(len(nums))]\\n    \\n    # Fill the diagonal with the values of the array, as the subarray \\n    # starting and ending at the same index will only contain one number\\n    for i in range(len(nums)):\\n        dp[i][i] = nums[i]\\n    \\n    # Iterate through the array and fill the remaining cells in the 2D array\\n    # We start at the second diagonal and work our way up\\n    for diagonal in range(1, len(nums)):\\n        for i in range(len(nums) - diagonal):\\n            j = i + diagonal\\n            \\n            # Player 1 can either choose the number at index i or index j\\n            # If they choose the number at index i, then player 2 will play optimally \\n            # and take the maximum score difference for the subarray starting at index i+1 and ending at j\\n            # Player 1 will then be left with the subarray starting at index i+2 and ending at j, where they \\n            # can choose either the number at index i+2 or index j\\n            # If they choose the number at index j, then player 2 will play optimally \\n            # and take the maximum score difference for the subarray starting at index i and ending at j-1\\n            # Player 1 will then be left with the subarray starting at index i+1 and ending at j-1, where they \\n            # can choose either the number at index i+1 or index j-1\\n            dp[i][j] = max(nums[i] - dp[i+1][j], nums[j] - dp[i][j-1])\\n    \\n    # If the maximum score difference for the subarray starting at index 0 \\n    # and ending at the last index is greater than or equal to 0, then player 1 can win\\n    return dp[0][-1] >= 0\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n  def PredictTheWinner(self, nums: List[int]) -> bool:\\n    # Create a 2D array to store the maximum score difference between \\n    # player 1 and player 2 for the subarray starting at index i and \\n    # ending at index j\\n    dp = [[0] * len(nums) for _ in range(len(nums))]\\n    \\n    # Fill the diagonal with the values of the array, as the subarray \\n    # starting and ending at the same index will only contain one number\\n    for i in range(len(nums)):\\n        dp[i][i] = nums[i]\\n    \\n    # Iterate through the array and fill the remaining cells in the 2D array\\n    # We start at the second diagonal and work our way up\\n    for diagonal in range(1, len(nums)):\\n        for i in range(len(nums) - diagonal):\\n            j = i + diagonal\\n            \\n            # Player 1 can either choose the number at index i or index j\\n            # If they choose the number at index i, then player 2 will play optimally \\n            # and take the maximum score difference for the subarray starting at index i+1 and ending at j\\n            # Player 1 will then be left with the subarray starting at index i+2 and ending at j, where they \\n            # can choose either the number at index i+2 or index j\\n            # If they choose the number at index j, then player 2 will play optimally \\n            # and take the maximum score difference for the subarray starting at index i and ending at j-1\\n            # Player 1 will then be left with the subarray starting at index i+1 and ending at j-1, where they \\n            # can choose either the number at index i+1 or index j-1\\n            dp[i][j] = max(nums[i] - dp[i+1][j], nums[j] - dp[i][j-1])\\n    \\n    # If the maximum score difference for the subarray starting at index 0 \\n    # and ending at the last index is greater than or equal to 0, then player 1 can win\\n    return dp[0][-1] >= 0\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1223351,
                "title": "bottom-up-dp-in-python-a-very-useful-hack-using-negative-value-for-opponent-s-score",
                "content": "After struggling for a couple of hours, I found it clear that all we needed was one way to ensure that score of Player 1 >= score of Player 2. In other words, the difference between Player 1\\'s score and Players 2\\'s score should be non-negative.\\n\\nThe dynamic programming memo here stores the maximum difference in scores possible between the first player and the second player for each subarray.\\n\\nFor instance, dp[2][4] = 12 indicates that in a subarray from indices 2 to 4, the player starting first can obtain 12 points more than player starting second.\\nSince both the players are playing optimally, the value stored in memo can be used by either of the players. Each player chooses the starting or ending of the subarray based on the aximum of the two scenarios given by the optimal substructure below.\\n\\nThe optimal substructure for 0<= start < len(nums) and start <= end  < len(nums) is:\\n\\ndp[start][end] = max(nums[start] - dp[start + 1][end] ,  nums[end] - dp[start][end - 1]) \\n\\n*Why is the minus sign used?*\\n\\nSince the players alternate every turn and play optimally, a score obtained by Player 2 can be observed as a negative score obtained by Player 1, and vice-versa.\\n\\nFinally if dp[0][len(nums) - 1] >= 0, return True, else False\\nThe code is as follows :\\n```\\n    def PredictTheWinner(self, nums: List[int]) -> bool:\\n        \\n        dp = [[0]*(len(nums) + 1) for i in range(len(nums) + 1)]\\n        \\n        for start in range(len(nums) , -1, -1) :\\n            for end in range(start , len(nums)):\\n                \\n                dp[start][end] = max(nums[start] - dp[start + 1][end] , nums[end] - dp[start][end - 1])       \\n        if dp[0][len(nums) - 1] >= 0 :\\n            return True # Player 1 has greater/equal score as Player 2\\n        return False\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n    def PredictTheWinner(self, nums: List[int]) -> bool:\\n        \\n        dp = [[0]*(len(nums) + 1) for i in range(len(nums) + 1)]\\n        \\n        for start in range(len(nums) , -1, -1) :\\n            for end in range(start , len(nums)):\\n                \\n                dp[start][end] = max(nums[start] - dp[start + 1][end] , nums[end] - dp[start][end - 1])       \\n        if dp[0][len(nums) - 1] >= 0 :\\n            return True # Player 1 has greater/equal score as Player 2\\n        return False\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 347625,
                "title": "demystifying-gaming-questions-including-templates-for-stone-game-and-stone-game-ii",
                "content": "When looking at these types of questions, I often get confused with regarding to am I currently optimizing the first player, or the second player. Here\\'s my approach to solve these types of questions.\\n\\nIf you\\'re like me, I don\\'t really like counting maximum score difference as suggested in the editorial, and I\\'d like to keep track of what is the maximum score the current player is getting. Therefore, if the best score the first player can get exceeds 1/2 of the total score, then he can win. \\n\\nNotations: \\narr: the array representing the stones\\ni, j: indices of arr, 0 <= i, j < arr.length\\n\\nThis leads to the subproblem definition: **define our current state as the maximum score the current player can get at interval [i, j]**, where i, j are the indices of the array. \\n\\nLet\\'s think about the **base case**: If there\\'s only one choice left, i == j, then the player will get all he can, the total score is arr[i] + arr[j].\\n\\n**Inductive step**: When there are more than one choices, the current player can choose nums[i], then he hands over the interval [i+1, j] to his opponent. The maximum score he can get = nums[i] + (total possible score at interval [i, j] - best score his opponent can get at interval[i+1, j]).\\n\\nLikewise, if the player chooses nums[j], the maximum score he can get = nums[j] + (total score at interval[i, j] - best score his opponent can get at interval[i, j-1])\\nWhat\\'s the optimal strategy for current player? He shall take the maximum one over the above two choices. \\n\\n**To summarize the above ideas into formula**:\\ndp(i, j) = max(sum[i:j] - min{dp(i+1, j)}, sum[i:j] - min{dp(i, j-1)}\\n\\nNow we can code:\\n```\\nclass Solution {\\n    int[][] dp;\\n    public boolean PredictTheWinner(int[] nums) {\\n        if (nums.length == 1 || nums.length == 0) return true;\\n        dp = new int[nums.length][nums.length];\\n        for (int i = 0; i < nums.length; i++){\\n            Arrays.fill(dp[i], -1);\\n        }\\n        int[] prefix = new int[nums.length+1];\\n\\t\\t// used prefix sum for faster lookup in range sum query\\n        for (int i = 1; i <= nums.length; i++){\\n            prefix[i] = prefix[i-1] + nums[i-1];\\n        }\\n        \\n        int score = solve(0, nums.length-1, nums, prefix);\\n        int sum = prefix[nums.length];\\n        if (score >= sum/2) return true;\\n        return false;\\n    }\\n    \\n    // returns max score of current player \\n    public int solve(int i, int j, int[] nums, int[] prefix){\\n        if (i == j) return nums[i];\\n        if (dp[i][j] != -1) return dp[i][j];\\n        int total = prefix[j+1] - prefix[i];\\n        int choice1 = nums[i] + total-solve(i+1, j, nums, prefix);\\n        int choice2 = nums[j] + total-solve(i, j-1, nums, prefix);\\n        return dp[i][j] = Math.max(choice1, choice2);\\n    }\\n}\\n```\\n\\nFor 877 stone game, you can use the exact same code to pass. \\nFor 1140 stone game2, we need to make a little bit of variations, but the basic idea is the same, however, we need to enumerate all possible selections, which is based on the value of M:\\n```\\nclass Solution {\\n    int[][] dp;\\n    public int stoneGameII(int[] piles) {\\n        int n = piles.length;\\n        dp = new int[102][102];\\n        for (int i = 0; i < n; i++){\\n            Arrays.fill(dp[i], -1);\\n        }\\n        return solve(piles, 0, 1);\\n    }\\n    \\n    public int solve(int[] piles, int start, int M){\\n        if (start == piles.length-1) return piles[start];\\n        if (dp[start][M] != -1) return dp[start][M];\\n        // compute the remaining score \\n        int remt = 0;\\n        for (int i = start; i < piles.length; i++){\\n            remt += piles[i];\\n        }\\n        // maximum score the current player can get = remaining score - min score his opponent can get \\n        int score = 0;\\n        for (int i = 1; i <= 2*M && start+i-1 < piles.length; i++){\\n            int opponent = solve(piles, start+i, Math.max(i, M));\\n            score = Math.max(score, remt-opponent);\\n        }\\n        return dp[start][M] = score;\\n    }\\n}\\n```\\n\\nHope this helps!\\n\\nNow try to do 464. Can I Win to see if you truly understand it : ) \\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int[][] dp;\\n    public boolean PredictTheWinner(int[] nums) {\\n        if (nums.length == 1 || nums.length == 0) return true;\\n        dp = new int[nums.length][nums.length];\\n        for (int i = 0; i < nums.length; i++){\\n            Arrays.fill(dp[i], -1);\\n        }\\n        int[] prefix = new int[nums.length+1];\\n\\t\\t// used prefix sum for faster lookup in range sum query\\n        for (int i = 1; i <= nums.length; i++){\\n            prefix[i] = prefix[i-1] + nums[i-1];\\n        }\\n        \\n        int score = solve(0, nums.length-1, nums, prefix);\\n        int sum = prefix[nums.length];\\n        if (score >= sum/2) return true;\\n        return false;\\n    }\\n    \\n    // returns max score of current player \\n    public int solve(int i, int j, int[] nums, int[] prefix){\\n        if (i == j) return nums[i];\\n        if (dp[i][j] != -1) return dp[i][j];\\n        int total = prefix[j+1] - prefix[i];\\n        int choice1 = nums[i] + total-solve(i+1, j, nums, prefix);\\n        int choice2 = nums[j] + total-solve(i, j-1, nums, prefix);\\n        return dp[i][j] = Math.max(choice1, choice2);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    int[][] dp;\\n    public int stoneGameII(int[] piles) {\\n        int n = piles.length;\\n        dp = new int[102][102];\\n        for (int i = 0; i < n; i++){\\n            Arrays.fill(dp[i], -1);\\n        }\\n        return solve(piles, 0, 1);\\n    }\\n    \\n    public int solve(int[] piles, int start, int M){\\n        if (start == piles.length-1) return piles[start];\\n        if (dp[start][M] != -1) return dp[start][M];\\n        // compute the remaining score \\n        int remt = 0;\\n        for (int i = start; i < piles.length; i++){\\n            remt += piles[i];\\n        }\\n        // maximum score the current player can get = remaining score - min score his opponent can get \\n        int score = 0;\\n        for (int i = 1; i <= 2*M && start+i-1 < piles.length; i++){\\n            int opponent = solve(piles, start+i, Math.max(i, M));\\n            score = Math.max(score, remt-opponent);\\n        }\\n        return dp[start][M] = score;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 258437,
                "title": "1-trick-7-kinds-of-python-solutions-from-naive-version-to-dp-with-o-n-space",
                "content": "Here are my 7 python solutions.\\n\\nThey are:\\n* Naive solution\\n\\t- Recursion without cache by determining whether it\\'s a winner or loser\\n* Advanced solutions\\n\\t- Recursion with cache by calculating the score\\n\\t- Recursion with cache by calculating the score difference\\n\\t- Dp bottom-up, space O(N^2) by calculating the score\\n\\t- Dp bottom-up, space O(N^2) by calculating the score difference\\n* Best solutions\\n\\t- Dp bottom-up, space O(N) by calculating score\\n\\t- Dp bottom-up, space O(N) by calculating the score difference\\n\\nAnd the trick mentioned in the title is:\\n> We can simply return True.\\n\\nThis problem is a generalization of [877. Stone Game](https://leetcode.com/problems/stone-game/) .\\nThe answer is True when our input length is even and sum of them is odd.\\n\\nWith this and dp (see the bottom), we can reach `runtime: 36 ms, faster than 96.38% of Python3 online submissions for Predict the Winner` even nowadays ( 2019/03/21).\\n\\n---\\n\\n### Naive Solution\\n \\n Recursion without cache by determining whether it\\'s winner or loser\\n\\n```Python\\nclass Solution:\\n    def PredictTheWinner(self, nums: List[int]) -> bool:\\n        left, right = 0, 1\\n        p1 = p2 = 0  # Player scores.\\n        turn = 0  # 0 for player 1\\'s turn, 1 for player 2\\'s.\\n        \\n        def choose(side, arr, turn, p1, p2):\\n            if not arr:\\n                return p1 >= p2 if turn == 0 else p1 < p2\\n            \\n            score = arr[0] if side == left else arr[-1]\\n            arr = arr[1:] if side == left else arr[:-1]\\n            if turn == 0:\\n                p1 += score\\n            else:\\n                p2 += score\\n            turn = (turn + 1) % 2\\n            return not choose(left, arr, turn, p1, p2) and not choose(right, arr, turn, p1, p2)\\n        \\n        return choose(left, nums, turn, p1, p2) or choose(right, nums, turn, p1, p2)\\n```\\n\\n### Advanced Solutions\\n\\n\\nRecursion with cache by calculating the score\\n\\n```Python\\nimport functools\\n\\n\\nclass Solution:\\n    def PredictTheWinner(self, nums: List[int]) -> bool:\\n        \\n        @functools.lru_cache(maxsize=None)\\n        def total(i, j):\\n\\t\\t\\t\"\"\"Returns the total score in the region from i to j.\"\"\"\\n            if j - i == 1:\\n                return nums[i]\\n            return total(i, j - 1) + nums[j - 1]\\n        \\n        @functools.lru_cache(maxsize=None)\\n        def score(i, j):\\n            if j - i == 1:\\n                return nums[i]\\n            return total(i, j) - min(score(i + 1, j), score(i, j - 1))\\n        \\n        return score(0, len(nums)) >= sum(nums) / 2\\n```\\n\\nRecursion with cache by calculating the score difference\\n\\n```Python\\nimport functools\\n\\n\\nclass Solution:\\n    def PredictTheWinner(self, nums: List[int]) -> bool:\\n        \\n        @functools.lru_cache(maxsize=None)\\n        def score_diff(i, j):\\n\\t\\t\\t\"\"\"Returns the score of player 1 minus that of player 2.\"\"\"\\n            if j - i == 1:\\n                return nums[i]\\n            \\n            left = nums[i] - score_diff(i + 1, j)\\n            right = nums[j - 1] - score_diff(i, j - 1)\\n            return max(left, right)\\n        \\n        return score_diff(0, len(nums)) >= 0\\n```\\n\\nDp bottom-up, space O(N^2) by calculating the score\\n\\n```Python\\nclass Solution:\\n    def PredictTheWinner(self, nums: List[int]) -> bool:\\n        n = len(nums)\\n        score = [[0] * n for __ in range(n)]\\n        total = [[0] * n for __ in range(n)]\\n        for x in range(n):\\n            score[x][x] = total[x][x] = nums[x]\\n\\n        for length in range(2, n + 1):\\n            for i in range(n + 1 - length):\\n                j = i + length - 1\\n                total[i][j] = total[i][j - 1] + nums[j]  # Total score in region from i to j.\\n                score[i][j] = total[i][j] - min(score[i + 1][j], score[i][j - 1])\\n        \\n        return score[0][n - 1] >= sum(nums) / 2\\n```\\n\\nDp bottom-up, space O(N^2) by calculating the score difference\\n\\n```Python\\nclass Solution:\\n    def PredictTheWinner(self, nums: List[int]) -> bool:\\n        n = len(nums)\\n        score_diff = [[0] * n for __ in range(n)]\\n        for x in range(n):\\n            score_diff[x][x] = nums[x]\\n\\n        for length in range(2, n + 1):\\n            for i in range(n + 1 - length):\\n                j = i + length - 1\\n                left = nums[i] - score_diff[i + 1][j]\\n                right = nums[j] - score_diff[i][j - 1]\\n                score_diff[i][j] = max(left, right)\\n        \\n        return score_diff[0][n - 1] >= 0\\n```\\n\\n### Best Solutions\\n\\nDp bottom-up, space O(N) by calculating the score\\n\\n```Python\\nclass Solution:\\n    def PredictTheWinner(self, nums: List[int]) -> bool:\\n        n = len(nums)\\n        score = [num for num in nums]\\n        total = [num for num in nums]\\n\\n        for length in range(2, n + 1):\\n            for i in range(n + 1 - length):\\n                j = i + length - 1\\n                total[i] += nums[j]  # Total score in region from i to j.\\n                score[i] = total[i][j] - min(score[i + 1], score[i])\\n        \\n        return score[0] >= sum(nums) / 2\\n```\\n\\nDp bottom-up, space O(N) by calculating the score difference\\n\\n```Python\\nclass Solution:\\n    def PredictTheWinner(self, nums: List[int]) -> bool:\\n        n = len(nums)\\n        score_diff = [num for num in nums]\\n        for length in range(2, n + 1):\\n            for i in range(n + 1 - length):\\n                j = i + length - 1\\n                left = nums[i] - score_diff[i + 1]\\n                right = nums[j] - score_diff[i]\\n                score_diff[i] = max(left, right)\\n        return score_diff[0] >= 0\\n```\\n\\n### With the Trick\\n\\n```Python\\nclass Solution:\\n    def PredictTheWinner(self, nums: List[int]) -> bool:\\n        n = len(nums)\\n        if n % 2 == 0 and sum(nums) % 2 == 1:\\n            return True\\n        \\n        score_diff = [num for num in nums]\\n        for length in range(2, n + 1):\\n            for i in range(n + 1 - length):\\n                j = i + length - 1\\n                left = nums[i] - score_diff[i + 1]\\n                right = nums[j] - score_diff[i]\\n                score_diff[i] = max(left, right)\\n        return score_diff[0] >= 0\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```Python\\nclass Solution:\\n    def PredictTheWinner(self, nums: List[int]) -> bool:\\n        left, right = 0, 1\\n        p1 = p2 = 0  # Player scores.\\n        turn = 0  # 0 for player 1\\'s turn, 1 for player 2\\'s.\\n        \\n        def choose(side, arr, turn, p1, p2):\\n            if not arr:\\n                return p1 >= p2 if turn == 0 else p1 < p2\\n            \\n            score = arr[0] if side == left else arr[-1]\\n            arr = arr[1:] if side == left else arr[:-1]\\n            if turn == 0:\\n                p1 += score\\n            else:\\n                p2 += score\\n            turn = (turn + 1) % 2\\n            return not choose(left, arr, turn, p1, p2) and not choose(right, arr, turn, p1, p2)\\n        \\n        return choose(left, nums, turn, p1, p2) or choose(right, nums, turn, p1, p2)\\n```\n```Python\\nimport functools\\n\\n\\nclass Solution:\\n    def PredictTheWinner(self, nums: List[int]) -> bool:\\n        \\n        @functools.lru_cache(maxsize=None)\\n        def total(i, j):\\n\\t\\t\\t\"\"\"Returns the total score in the region from i to j.\"\"\"\\n            if j - i == 1:\\n                return nums[i]\\n            return total(i, j - 1) + nums[j - 1]\\n        \\n        @functools.lru_cache(maxsize=None)\\n        def score(i, j):\\n            if j - i == 1:\\n                return nums[i]\\n            return total(i, j) - min(score(i + 1, j), score(i, j - 1))\\n        \\n        return score(0, len(nums)) >= sum(nums) / 2\\n```\n```Python\\nimport functools\\n\\n\\nclass Solution:\\n    def PredictTheWinner(self, nums: List[int]) -> bool:\\n        \\n        @functools.lru_cache(maxsize=None)\\n        def score_diff(i, j):\\n\\t\\t\\t\"\"\"Returns the score of player 1 minus that of player 2.\"\"\"\\n            if j - i == 1:\\n                return nums[i]\\n            \\n            left = nums[i] - score_diff(i + 1, j)\\n            right = nums[j - 1] - score_diff(i, j - 1)\\n            return max(left, right)\\n        \\n        return score_diff(0, len(nums)) >= 0\\n```\n```Python\\nclass Solution:\\n    def PredictTheWinner(self, nums: List[int]) -> bool:\\n        n = len(nums)\\n        score = [[0] * n for __ in range(n)]\\n        total = [[0] * n for __ in range(n)]\\n        for x in range(n):\\n            score[x][x] = total[x][x] = nums[x]\\n\\n        for length in range(2, n + 1):\\n            for i in range(n + 1 - length):\\n                j = i + length - 1\\n                total[i][j] = total[i][j - 1] + nums[j]  # Total score in region from i to j.\\n                score[i][j] = total[i][j] - min(score[i + 1][j], score[i][j - 1])\\n        \\n        return score[0][n - 1] >= sum(nums) / 2\\n```\n```Python\\nclass Solution:\\n    def PredictTheWinner(self, nums: List[int]) -> bool:\\n        n = len(nums)\\n        score_diff = [[0] * n for __ in range(n)]\\n        for x in range(n):\\n            score_diff[x][x] = nums[x]\\n\\n        for length in range(2, n + 1):\\n            for i in range(n + 1 - length):\\n                j = i + length - 1\\n                left = nums[i] - score_diff[i + 1][j]\\n                right = nums[j] - score_diff[i][j - 1]\\n                score_diff[i][j] = max(left, right)\\n        \\n        return score_diff[0][n - 1] >= 0\\n```\n```Python\\nclass Solution:\\n    def PredictTheWinner(self, nums: List[int]) -> bool:\\n        n = len(nums)\\n        score = [num for num in nums]\\n        total = [num for num in nums]\\n\\n        for length in range(2, n + 1):\\n            for i in range(n + 1 - length):\\n                j = i + length - 1\\n                total[i] += nums[j]  # Total score in region from i to j.\\n                score[i] = total[i][j] - min(score[i + 1], score[i])\\n        \\n        return score[0] >= sum(nums) / 2\\n```\n```Python\\nclass Solution:\\n    def PredictTheWinner(self, nums: List[int]) -> bool:\\n        n = len(nums)\\n        score_diff = [num for num in nums]\\n        for length in range(2, n + 1):\\n            for i in range(n + 1 - length):\\n                j = i + length - 1\\n                left = nums[i] - score_diff[i + 1]\\n                right = nums[j] - score_diff[i]\\n                score_diff[i] = max(left, right)\\n        return score_diff[0] >= 0\\n```\n```Python\\nclass Solution:\\n    def PredictTheWinner(self, nums: List[int]) -> bool:\\n        n = len(nums)\\n        if n % 2 == 0 and sum(nums) % 2 == 1:\\n            return True\\n        \\n        score_diff = [num for num in nums]\\n        for length in range(2, n + 1):\\n            for i in range(n + 1 - length):\\n                j = i + length - 1\\n                left = nums[i] - score_diff[i + 1]\\n                right = nums[j] - score_diff[i]\\n                score_diff[i] = max(left, right)\\n        return score_diff[0] >= 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 96833,
                "title": "python-dp-solution-32ms-bottom-up-with-explanation",
                "content": "```\\nclass Solution(object):\\n    def PredictTheWinner(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        if len(nums)%2 == 0 or len(nums) == 1:\\n            return True\\n\\n        n = len(nums)\\n        dp = [[[0,0] for row in xrange(n)] for _ in xrange(n)]\\n        \\n        # bottom up, build each case starting from problem with 1 number in a game:\\n        # base case: only 1 number, player 1 pick first, player 2 will be left with 0 number game, aka 0\\n        # each dp[i][j] will store [bestScore, leftOver]\\n        for i in range(n):\\n            dp[i][i] = [nums[i], 0]\\n        \\n        # sub divide the game into list from index i to j \\n        # now start from 2 number game [i][j]:\\n        # if player 1 pick i, player 2 will pick the bestScore of game [i+1][j], then player 1 is left with the leftOver of game [i+1][j]\\n        # if player 1 pick j, player 2 will pick the bestScore of game [i][j-1], then player 1 is left with the leftOver of game [i][j-1]\\n        # player 1 will choose the best case in above scenarios\\n\\n        for length in xrange(2,n+1):\\n            for i in range(n-length+1):\\n                j = i + length-1\\n                # pick i:\\n                pi = dp[i+1][j][1] + nums[i]\\n                # pick j:\\n                pj = dp[i][j-1][1] + nums[j]\\n                if pi > pj:\\n                    dp[i][j][0] = pi\\n                    dp[i][j][1] = dp[i+1][j][0]\\n\\n                else:\\n                    dp[i][j][0] = pj\\n                    dp[i][j][1] = dp[i][j-1][0]\\n\\n        return dp[0][-1][0] >= dp[0][-1][1]\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution(object):\\n    def PredictTheWinner(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        if len(nums)%2 == 0 or len(nums) == 1:\\n            return True\\n\\n        n = len(nums)\\n        dp = [[[0,0] for row in xrange(n)] for _ in xrange(n)]\\n        \\n        # bottom up, build each case starting from problem with 1 number in a game:\\n        # base case: only 1 number, player 1 pick first, player 2 will be left with 0 number game, aka 0\\n        # each dp[i][j] will store [bestScore, leftOver]\\n        for i in range(n):\\n            dp[i][i] = [nums[i], 0]\\n        \\n        # sub divide the game into list from index i to j \\n        # now start from 2 number game [i][j]:\\n        # if player 1 pick i, player 2 will pick the bestScore of game [i+1][j], then player 1 is left with the leftOver of game [i+1][j]\\n        # if player 1 pick j, player 2 will pick the bestScore of game [i][j-1], then player 1 is left with the leftOver of game [i][j-1]\\n        # player 1 will choose the best case in above scenarios\\n\\n        for length in xrange(2,n+1):\\n            for i in range(n-length+1):\\n                j = i + length-1\\n                # pick i:\\n                pi = dp[i+1][j][1] + nums[i]\\n                # pick j:\\n                pj = dp[i][j-1][1] + nums[j]\\n                if pi > pj:\\n                    dp[i][j][0] = pi\\n                    dp[i][j][1] = dp[i+1][j][0]\\n\\n                else:\\n                    dp[i][j][0] = pj\\n                    dp[i][j][1] = dp[i][j-1][0]\\n\\n        return dp[0][-1][0] >= dp[0][-1][1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3829398,
                "title": "simple-solution-explained-with-an-example",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nThe question is really simple, if we start looking in a certain direction..The direction will be something like this\\n\\n**1) Player 1 needs to get maximum score**\\n\\n**2) If player 2 gets the chance, he should get minimum score**\\n\\nNow, the question comes=> How do we do that\\n\\nThe fist thing, you need to clear in your mind is that, we need to figure out all the cases..**If we need to figure out all the cases, then the best thing is recusrion only...**\\n\\nLet us say, **Player 1 is playing**,\\n\\nHe will have 2 options \\n\\n**Option 1) He can choose from the start of array, let us say start  = i**\\n\\n**Option 2) He can choose from the end of array, let us say end = j**\\n\\nNow if he choose from start, then his score will increase by **nums[i]**and for the next turn, player 2 will have the option to choose from **index i+1 to j**\\n\\nIn code it will look like this...\\n\\n```\\nint a = nums[i] + solve(i+1,j,nums, chance_of_second_player)\\n```\\nNow if he choose option 2, then his score will increase by **nums[j]** and for the next turn , player 2 has to choose from index **i to j-1**\\n\\nIn code it will look like this ...\\n\\n```\\nint b = nums[j]+ solve(i,j-1,nums,chance_of_second_player)\\n\\n```\\n\\nNow, In the starting of the question , I told you that we will maximize player 1 score \\n\\nSO out of these 2 options , **we need to return the maximum**, In code it will look like this \\n\\n```\\nreturn max(a,b);\\n```\\n\\nNow, let us say, player 2 chance has come\\n\\nNow, Initially i told you , we will be calculating the score of player 1 and for **player 2** we will try to get the minimum score\\n\\n## Now, in the recursive function, i am trying to get the max score of **player 1 => remember this**\\n\\nPlayer 2 will also have **2 options** \\n\\nOption 1) He can choose from the start , so if he choose from the start, so for the next player has to choose from **i+1 to j** \\n\\nWe **won\\'t include his score nums[i]**, because we are not calculating his score...so we don\\'t care about his score, we will just think of player 1\\n\\nIn code it will look like this \\n\\n```\\nint c = solve(i+1,j,chance_of_first_player)\\n```\\nOption 2) He can choose from the end, so if we choose from the end, so for the next player that is (1), he will have option to choose **from i to j-1**, and we won\\'t include the score of player 2, **because we don\\'t want it**\\n\\nIn code...\\n\\n```\\nint d = solve(i,j-1,chance_of_first_player)\\n```\\nNow , i ask you a really simple question , For player 2 , what do we want..\\n\\nWe want that he should loose, so to loose..whatever he choose..**it should be minimum**...Pls think it for a while...\\n\\nNow there were 2 options for him **c and d** and if we want him to loose , **we will choose the minimum out of two**.....SIMPLEEEE\\n\\nIn code \\n```\\nreturn min(c,d);\\n\\n```\\nNow, what will be the base case\\n\\n1) i was our start index, j was our end index...Now just think if  **i becomes greater then j**, then how can we choose anything...so \\n```\\nif(i>j)\\n{\\nreturn 0;\\n}\\n```\\nNow, how do we memoize it\\n\\nThe ans is simple...\\n\\nThree things are changing \\n1) start index\\n2) end index\\n3) Turn of player(1st or 2nd)\\n\\nJust make a 3-d dp array and store the results there....\\n\\nThat is how you do dynamic programming...\\n\\nNow, we got the max score of player 1\\n\\nWe know the total sum of our array\\n\\nso (total_sum_of_array - max score of player 1)  will give the score of player 2, Now you just check which one is big .... ;)\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nWe know the length of array is maximum 20(given in the question) , and we are making a 3-d dp array \\nof start_index , end_index and 2 players , so \\n\\nstart index can go from 1 to 20\\nend can go from 20 to 1\\n2 players ( 1 and 2)\\n\\nso 20 * 20 *2\\n\\nOr mathematically we can write O(N * N * 2) =>**O(N * N )**\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nWe are using a 3-d dp array so,\\n\\n**O(N * N * 2)**\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n\\n    int solve(int i,int j,vector<int>& nums,int chance,int dp[21][21][3])\\n    {\\n\\n\\n        if(i>j)\\n        {\\n            return 0;\\n        }\\n\\n\\n        if(dp[i][j][chance]!=-1)\\n        {\\n            return dp[i][j][chance];\\n        }\\n        if(chance==0)\\n        {\\n\\n            int a = nums[i]+solve(i+1,j,nums,1,dp);\\n            int b = nums[j]+solve(i,j-1,nums,1,dp);\\n\\n            dp[i][j][chance] = max(a,b);\\n            return dp[i][j][chance];\\n\\n        }\\n        else\\n        {\\n\\n            int a = solve(i+1,j,nums,0,dp);\\n            int b = solve(i,j-1,nums,0,dp);\\n\\n            dp[i][j][chance] = min(a,b);\\n            return dp[i][j][chance];\\n        }\\n\\n    }\\n\\n\\n\\n    bool PredictTheWinner(vector<int>& nums) {\\n        \\n\\n        int dp[21][21][3];\\n\\n        for(int i=0; i<=20; i++)\\n        {\\n            for(int j=0; j<=20; j++)\\n            {\\n                for(int k=0; k<=2; k++)\\n                {\\n                    dp[i][j][k]=-1;\\n                }\\n            }\\n        }\\n\\n        if(nums.size()==1)\\n        {\\n            return true;\\n        }\\n\\n        int i = 0;\\n        int j = nums.size()-1;\\n\\n        int sum = 0;\\n\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            sum+=nums[i];\\n        }\\n\\n        int chance = 0;\\n        int a = solve(i,j,nums,chance,dp);\\n\\n        int b = sum-a;\\n\\n        if(a>=b)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n    \\n\\n    }\\n};\\n```\\n\\n**TIME FOR A MEME NOW**\\n\\n![WhatsApp Image 2023-07-28 at 20.15.51.jpeg](https://assets.leetcode.com/users/images/94f33d2d-f6b9-4bd5-9d08-54cb0fb670ff_1690555635.1041806.jpeg)\\n\\n# **IF YOU LIKE MY SOLUTION, PLEASE UPVOTE...**",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nint a = nums[i] + solve(i+1,j,nums, chance_of_second_player)\\n```\n```\\nint b = nums[j]+ solve(i,j-1,nums,chance_of_second_player)\\n\\n```\n```\\nreturn max(a,b);\\n```\n```\\nint c = solve(i+1,j,chance_of_first_player)\\n```\n```\\nint d = solve(i,j-1,chance_of_first_player)\\n```\n```\\nreturn min(c,d);\\n\\n```\n```\\nif(i>j)\\n{\\nreturn 0;\\n}\\n```\n```\\nclass Solution {\\npublic:\\n\\n\\n    int solve(int i,int j,vector<int>& nums,int chance,int dp[21][21][3])\\n    {\\n\\n\\n        if(i>j)\\n        {\\n            return 0;\\n        }\\n\\n\\n        if(dp[i][j][chance]!=-1)\\n        {\\n            return dp[i][j][chance];\\n        }\\n        if(chance==0)\\n        {\\n\\n            int a = nums[i]+solve(i+1,j,nums,1,dp);\\n            int b = nums[j]+solve(i,j-1,nums,1,dp);\\n\\n            dp[i][j][chance] = max(a,b);\\n            return dp[i][j][chance];\\n\\n        }\\n        else\\n        {\\n\\n            int a = solve(i+1,j,nums,0,dp);\\n            int b = solve(i,j-1,nums,0,dp);\\n\\n            dp[i][j][chance] = min(a,b);\\n            return dp[i][j][chance];\\n        }\\n\\n    }\\n\\n\\n\\n    bool PredictTheWinner(vector<int>& nums) {\\n        \\n\\n        int dp[21][21][3];\\n\\n        for(int i=0; i<=20; i++)\\n        {\\n            for(int j=0; j<=20; j++)\\n            {\\n                for(int k=0; k<=2; k++)\\n                {\\n                    dp[i][j][k]=-1;\\n                }\\n            }\\n        }\\n\\n        if(nums.size()==1)\\n        {\\n            return true;\\n        }\\n\\n        int i = 0;\\n        int j = nums.size()-1;\\n\\n        int sum = 0;\\n\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            sum+=nums[i];\\n        }\\n\\n        int chance = 0;\\n        int a = solve(i,j,nums,chance,dp);\\n\\n        int b = sum-a;\\n\\n        if(a>=b)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n    \\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3827081,
                "title": "simple-code-java-recursion-dp",
                "content": "\\n# Approach\\n1. in optimal game solutions we have to choose best solution for us and expect worst ans for your next move.\\n2. lets take \\' i \\' as starting index of array, \\' j \\' as ending index of array.\\n3. present player1 has two options to choose i or j.\\n4. if player1 choose i, opponent has two options- (i+1 , j) or (i , j-1)\\n5. here opponent can choose (i or j) so player 1 has to expect min form his next options, because opponent plays optimally.\\n6. here are next moves of player1 - when choose i -> ((i+2 , j) or (i+1 , j-1)) , -when choose j -> ((i+1 , j-1) or (i , j-2))\\n7. take min from next moves and take best form present move which if i and j.\\n\\n---\\n\\n\\n![WhatsApp Image 2023-07-28 at 11.09.36.jpeg](https://assets.leetcode.com/users/images/7209115c-be91-4b04-8b51-6f1ab1be1085_1690522831.1890056.jpeg)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    int memo[][];\\n    public boolean PredictTheWinner(int[] nums) {\\n        memo=new int[nums.length][nums.length];\\n        int total=0;\\n        for(int i=0;i<nums.length;i++){\\n            total+=nums[i];\\n            for(int j=0;j<nums.length;j++){\\n                memo[i][j]=-1;\\n            }\\n        }\\n        int p1Score=solve(nums,0,nums.length-1);\\n        int p2Score=total-p1Score;\\n        return (p1Score >= p2Score);\\n    }\\n    public int solve(int nums[],int i,int j){\\n        if(i>j){\\n            return 0;\\n        }\\n        if(memo[i][j]!=-1){\\n            return memo[i][j];\\n        }\\n        int choose_i = nums[i] + Math.min(solve(nums,i+2,j),solve(nums,i+1,j-1));\\n        int choose_j = nums[j] + Math.min(solve(nums,i+1,j-1),solve(nums,i,j-2));\\n        return memo[i][j]=Math.max(choose_i,choose_j);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization",
                    "Game Theory"
                ],
                "code": "```\\nclass Solution {\\n    int memo[][];\\n    public boolean PredictTheWinner(int[] nums) {\\n        memo=new int[nums.length][nums.length];\\n        int total=0;\\n        for(int i=0;i<nums.length;i++){\\n            total+=nums[i];\\n            for(int j=0;j<nums.length;j++){\\n                memo[i][j]=-1;\\n            }\\n        }\\n        int p1Score=solve(nums,0,nums.length-1);\\n        int p2Score=total-p1Score;\\n        return (p1Score >= p2Score);\\n    }\\n    public int solve(int nums[],int i,int j){\\n        if(i>j){\\n            return 0;\\n        }\\n        if(memo[i][j]!=-1){\\n            return memo[i][j];\\n        }\\n        int choose_i = nums[i] + Math.min(solve(nums,i+2,j),solve(nums,i+1,j-1));\\n        int choose_j = nums[j] + Math.min(solve(nums,i+1,j-1),solve(nums,i,j-2));\\n        return memo[i][j]=Math.max(choose_i,choose_j);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3826343,
                "title": "c-python-recursive-minimax-dp-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis code is an implementation of the \"Predict the Winner\" problem using the minimax algorithm. The problem is to determine whether Player 1 can win the game if both players play optimally!\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThere is a hard question LC 1406 stone game 3 which can be solved by using DP.\\n[Please turn on English subtitles if neccessary]\\n[https://youtu.be/ZN9j4MqPGtM](https://youtu.be/ZN9j4MqPGtM)\\n\\nThe second approach uses the same idea in video; the code is simplied. Alone the recursive DP version beats 100%!\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(2^n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n# Minimax Recurive Version slow but accepted\\n```\\nclass Solution {\\npublic:\\n    int n;\\n\\n    int game(int l, int r, int score, vector<int>& nums){\\n        int sgn=((r-l-n)&1)?1:-1;\\n        if (l==r) return score+sgn*nums[l];\\n        int ans;\\n        if (sgn==1)//player 1\\n            ans=max(nums[l]+game(l+1, r, score ,nums), \\n            nums[r]+game(l, r-1, score, nums));\\n        else// player 2\\n            ans=min(-nums[l]+game(l+1, r, score ,nums), \\n            -nums[r]+game(l, r-1, score,nums));\\n        return ans;\\n    }\\n    bool PredictTheWinner(vector<int>& nums) {\\n        n=nums.size();\\n        return game(0, n-1, 0, nums)>=0;\\n    }\\n};\\n```\\n# Recursive DP C++ beats 100%. TC O(n^2), SC: O(n^2)\\n\\n```C++ []\\nclass Solution {\\npublic:\\n    vector<vector<int>> player;\\n    int n;\\n    \\n    int game(int l, int r,  vector<int>& nums){\\n        if (l==r) return nums[l];\\n        if (player[l][r]!=INT_MIN) return player[l][r];\\n        return player[l][r]\\n            =max(nums[l]-game(l+1, r, nums), nums[r]-game(l, r-1, nums));\\n        \\n    }\\n    bool PredictTheWinner(vector<int>& nums) {\\n        n=nums.size();\\n        player.assign(n, vector<int>(n, INT_MIN));\\n        return game(0, n-1, nums)>=0;\\n    }\\n};\\n```\\n```python []\\nclass Solution:\\n    def PredictTheWinner(self, nums: List[int]) -> bool:\\n        n = len(nums)\\n        row = [-2**31] * n\\n        player = [row[:] for _ in range(n)]\\n\\n        def game(l, r):\\n            if l == r:\\n                player[l][r] = nums[l]\\n                return player[l][r]\\n            if player[l][r] != -2**31:\\n                return player[l][r]\\n            player[l][r]=max(nums[l]-game(l+1,r), nums[r]-game(l, r-1))\\n            return player[l][r]\\n\\n        return game(0, n - 1) >= 0\\n```\\n\\n```\\n\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Game Theory"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n;\\n\\n    int game(int l, int r, int score, vector<int>& nums){\\n        int sgn=((r-l-n)&1)?1:-1;\\n        if (l==r) return score+sgn*nums[l];\\n        int ans;\\n        if (sgn==1)//player 1\\n            ans=max(nums[l]+game(l+1, r, score ,nums), \\n            nums[r]+game(l, r-1, score, nums));\\n        else// player 2\\n            ans=min(-nums[l]+game(l+1, r, score ,nums), \\n            -nums[r]+game(l, r-1, score,nums));\\n        return ans;\\n    }\\n    bool PredictTheWinner(vector<int>& nums) {\\n        n=nums.size();\\n        return game(0, n-1, 0, nums)>=0;\\n    }\\n};\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    vector<vector<int>> player;\\n    int n;\\n    \\n    int game(int l, int r,  vector<int>& nums){\\n        if (l==r) return nums[l];\\n        if (player[l][r]!=INT_MIN) return player[l][r];\\n        return player[l][r]\\n            =max(nums[l]-game(l+1, r, nums), nums[r]-game(l, r-1, nums));\\n        \\n    }\\n    bool PredictTheWinner(vector<int>& nums) {\\n        n=nums.size();\\n        player.assign(n, vector<int>(n, INT_MIN));\\n        return game(0, n-1, nums)>=0;\\n    }\\n};\\n```\n```python []\\nclass Solution:\\n    def PredictTheWinner(self, nums: List[int]) -> bool:\\n        n = len(nums)\\n        row = [-2**31] * n\\n        player = [row[:] for _ in range(n)]\\n\\n        def game(l, r):\\n            if l == r:\\n                player[l][r] = nums[l]\\n                return player[l][r]\\n            if player[l][r] != -2**31:\\n                return player[l][r]\\n            player[l][r]=max(nums[l]-game(l+1,r), nums[r]-game(l, r-1))\\n            return player[l][r]\\n\\n        return game(0, n - 1) >= 0\\n```\n```\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2254319,
                "title": "c-dp-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[21][21];\\n    int dfs(int l,int r,vector<int>&nums){\\n        if(l>r) return 0;\\n        if(l==r) return nums[l];\\n        if(dp[l][r]!=-1) return dp[l][r];\\n        \\n        //player 2 plays optimally so the player 1 will get the minimum out of what is left\\n        return dp[l][r]= max(nums[l]+min(dfs(l+2,r,nums),dfs(l+1,r-1,nums)),  \\n                             nums[r]+min(dfs(l,r-2,nums),dfs(l+1,r-1,nums)));   \\n    }\\n    bool PredictTheWinner(vector<int>& nums) {\\n        int n=nums.size(),sum=accumulate(nums.begin(),nums.end(),0);\\n        memset(dp,-1,sizeof(dp));\\n        int ans=dfs(0,n-1,nums);\\n        return ans>=sum-ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[21][21];\\n    int dfs(int l,int r,vector<int>&nums){\\n        if(l>r) return 0;\\n        if(l==r) return nums[l];\\n        if(dp[l][r]!=-1) return dp[l][r];\\n        \\n        //player 2 plays optimally so the player 1 will get the minimum out of what is left\\n        return dp[l][r]= max(nums[l]+min(dfs(l+2,r,nums),dfs(l+1,r-1,nums)),  \\n                             nums[r]+min(dfs(l,r-2,nums),dfs(l+1,r-1,nums)));   \\n    }\\n    bool PredictTheWinner(vector<int>& nums) {\\n        int n=nums.size(),sum=accumulate(nums.begin(),nums.end(),0);\\n        memset(dp,-1,sizeof(dp));\\n        int ans=dfs(0,n-1,nums);\\n        return ans>=sum-ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1790414,
                "title": "c-faster-one-of-the-finest-recursive-problem-i-ve-ever-come-across",
                "content": "```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& nums, int i, int j)\\n    {\\n        if(i>j) return 0;\\n        int option1 = nums[i] + min(solve(nums,i+2,j),solve(nums,i+1,j-1));\\n        int option2 = nums[j] + min(solve(nums,i,j-2),solve(nums,i+1,j-1));\\n        \\n        return max(option1,option2);\\n    }\\n    bool PredictTheWinner(vector<int>& nums) {\\n        int n = nums.size();\\n        int sum = accumulate(nums.begin(), nums.end(), 0);\\n        int optimalscore = solve(nums,0, n-1);\\n        if(optimalscore>=sum-optimalscore) return true;\\n        else return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Game Theory"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& nums, int i, int j)\\n    {\\n        if(i>j) return 0;\\n        int option1 = nums[i] + min(solve(nums,i+2,j),solve(nums,i+1,j-1));\\n        int option2 = nums[j] + min(solve(nums,i,j-2),solve(nums,i+1,j-1));\\n        \\n        return max(option1,option2);\\n    }\\n    bool PredictTheWinner(vector<int>& nums) {\\n        int n = nums.size();\\n        int sum = accumulate(nums.begin(), nums.end(), 0);\\n        int optimalscore = solve(nums,0, n-1);\\n        if(optimalscore>=sum-optimalscore) return true;\\n        else return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 478727,
                "title": "python-game-theory-dp-faster-than-100-with-some-game-theoretic-explanation",
                "content": "First of all, if len(nums) is even, first player always wins. The reason is that, the first player can always collect either \"all the numbers in the odd positions\" or \"all the numbers in the even positions\". (You can think about why before reading the rest of this post.) The key observation is that (say he wants all the numbers in the odd positions) when it is the first player\\'s turn, he can always pick a number sitting in an odd position, and leaving the second player to choose from two numbers that are both in the even positions; and whenever the second player makes a move, a number in an odd position is available for the first player to pick next. (This argument is similar to Charles L. Bouton\\'s solution of Nim.) Therefore, the first player is guaranteed to have a larger or equal score comparing to the second player, as he can pick the parity with a (weakly) larger score. This is actually the first problem in Peter Winkler\\'s book - \"Mathematical Puzzles\".\\n\\nIf len(nums) is odd, then this trick no longer works, so just use the usual dp trick such that dp[i][k] represents the max difference between the person moving first and the person moving second in the subgame consists of numbers starting from position i, ending at position k.\\n\\n```\\nclass Solution:\\n    def PredictTheWinner(self, nums: List[int]) -> bool:\\n        if len(nums) % 2 ==0:\\n            return True\\n        dp=[[0 for j in range(len(nums))] for i in range(len(nums))]\\n        for i in range(len(nums)):\\n            dp[i][i]=nums[i]\\n        for j in range(1,len(nums)):\\n            for i in range(len(nums)-j):\\n                dp[i][i+j]=max( nums[i]-dp[i+1][i+j],nums[i+j]-dp[i][i+j-1] )\\n        if dp[0][-1]>=0:\\n            return True\\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def PredictTheWinner(self, nums: List[int]) -> bool:\\n        if len(nums) % 2 ==0:\\n            return True\\n        dp=[[0 for j in range(len(nums))] for i in range(len(nums))]\\n        for i in range(len(nums)):\\n            dp[i][i]=nums[i]\\n        for j in range(1,len(nums)):\\n            for i in range(len(nums)-j):\\n                dp[i][i+j]=max( nums[i]-dp[i+1][i+j],nums[i+j]-dp[i][i+j-1] )\\n        if dp[0][-1]>=0:\\n            return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3826637,
                "title": "java-recursion-dp-easy-explanation",
                "content": "# Intuition\\n\\nThe problem can be solved using both recursion and dynamic programming. The intuition behind the approach is to simulate the game between the two players and calculate the maximum possible score difference that Player 1 can achieve if both players play optimally. If the score difference is non-negative, Player 1 can guarantee a win.\\n\\n\\n## Recursion Approach\\nIn the recursion approach, we start by defining a recursive function function that takes the current range (start and end) of the array, the current turn number (turn), and the array of numbers (nums). The base case for the recursion is when start > end, which means there are no more elements to pick, and the function returns 0 as there are no points to add to the scores.\\n\\nDuring the recursion, at each turn, the player can either choose the number at the start index or the number at the end index, and we recursively calculate the score difference between the two players. We alternate turns between Player 1 and Player 2 using the turn parameter, and the maximum or minimum of the two possibilities (depending on the player\\'s turn) is chosen, representing the optimal play.\\n\\nThe recursion approach can be inefficient for larger arrays as it recalculates the same subproblems multiple times, leading to exponential time complexity.\\n\\n## Recursion Complexity\\n- ***Time complexity:***  O(2^n), where n is the number of elements in the nums array.\\n- ***Space complexity:***  O(n) due to the recursive call stack.\\n\\n\\n## Recursion Code\\n```\\nclass Solution {\\n    public boolean PredictTheWinner(int[] nums) {\\n        int start = 0;\\n        int end = nums.length - 1;\\n        int ans = function(start,end,0,nums);\\n        return ans>=0;\\n    }\\n\\n    public int function(int start,int end,int turn,int[] nums){\\n        if(start>end) return 0;\\n\\n        int ans = 0;\\n\\n        if(turn%2==0){ // \\n            int take_first = nums[start] + function(start+1,end,turn+1,nums);\\n            int take_last = nums[end] + function(start,end-1,turn+1,nums);\\n            ans = Math.max(take_first,take_last);\\n        }else{\\n            int take_first = -nums[start] + function(start+1,end,turn+1,nums);\\n            int take_last =  -nums[end] + function(start,end-1,turn+1,nums);\\n            ans = Math.min(take_first,take_last);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```\\n\\n\\n## Dynamic Programming Approach\\n\\nIn the dynamic programming approach, we use memoization to avoid redundant calculations in the recursion. We create a 2D array dp to store the intermediate results of the recursive calls. The array dp[i][j] will store the maximum score difference between Player 1 and Player 2 for the subarray nums[i...j].\\n\\nBefore making a recursive call, we check if the result for the current range is already computed (i.e., dp[start][end] != -1). If it is, we directly return the precomputed result instead of recalculating it.\\n\\nBy using memoization, we ensure that each subproblem is calculated only once, leading to a significant improvement in efficiency.\\n\\n\\n## Dynamic Programming Complexity\\n- ***Time complexity:***  O(n^2), where n is the number of elements in the nums array\\n- ***Space complexity:***  O(n^2) due to the 2D dp array used for memoization\\n\\n\\n## Dynamic Programming Code\\n```\\nclass Solution {\\n    public boolean PredictTheWinner(int[] nums) {\\n        int length = nums.length;\\n        int start = 0;\\n        int end = nums.length - 1;\\n        int[][] dp = new int[length][length];\\n        for(int[] rows:dp) Arrays.fill(rows,-1);\\n        int ans = function(start,end,0,nums,dp);\\n        return ans>=0;\\n    }\\n\\n    public int function(int start,int end,int turn,int[] nums,int[][] dp){\\n        if(start>end) return 0;\\n\\n        if(dp[start][end]!=-1) return dp[start][end];\\n\\n        int ans = 0;\\n\\n        if(turn%2==0){ \\n            int take_first = nums[start] + function(start+1,end,turn+1,nums,dp);\\n            int take_last = nums[end] + function(start,end-1,turn+1,nums,dp);\\n            ans = Math.max(take_first,take_last);\\n        }else{\\n            int take_first = -nums[start] + function(start+1,end,turn+1,nums,dp);\\n            int take_last =  -nums[end] + function(start,end-1,turn+1,nums,dp);\\n            ans = Math.min(take_first,take_last);\\n        }\\n\\n        return dp[start][end]=ans;\\n    }\\n}\\n```\\n\\n\\n![upvote.webp](https://assets.leetcode.com/users/images/44e32a2d-5145-4561-b287-e86e1e45a273_1690516191.1653607.webp)\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public boolean PredictTheWinner(int[] nums) {\\n        int start = 0;\\n        int end = nums.length - 1;\\n        int ans = function(start,end,0,nums);\\n        return ans>=0;\\n    }\\n\\n    public int function(int start,int end,int turn,int[] nums){\\n        if(start>end) return 0;\\n\\n        int ans = 0;\\n\\n        if(turn%2==0){ // \\n            int take_first = nums[start] + function(start+1,end,turn+1,nums);\\n            int take_last = nums[end] + function(start,end-1,turn+1,nums);\\n            ans = Math.max(take_first,take_last);\\n        }else{\\n            int take_first = -nums[start] + function(start+1,end,turn+1,nums);\\n            int take_last =  -nums[end] + function(start,end-1,turn+1,nums);\\n            ans = Math.min(take_first,take_last);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean PredictTheWinner(int[] nums) {\\n        int length = nums.length;\\n        int start = 0;\\n        int end = nums.length - 1;\\n        int[][] dp = new int[length][length];\\n        for(int[] rows:dp) Arrays.fill(rows,-1);\\n        int ans = function(start,end,0,nums,dp);\\n        return ans>=0;\\n    }\\n\\n    public int function(int start,int end,int turn,int[] nums,int[][] dp){\\n        if(start>end) return 0;\\n\\n        if(dp[start][end]!=-1) return dp[start][end];\\n\\n        int ans = 0;\\n\\n        if(turn%2==0){ \\n            int take_first = nums[start] + function(start+1,end,turn+1,nums,dp);\\n            int take_last = nums[end] + function(start,end-1,turn+1,nums,dp);\\n            ans = Math.max(take_first,take_last);\\n        }else{\\n            int take_first = -nums[start] + function(start+1,end,turn+1,nums,dp);\\n            int take_last =  -nums[end] + function(start,end-1,turn+1,nums,dp);\\n            ans = Math.min(take_first,take_last);\\n        }\\n\\n        return dp[start][end]=ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3826325,
                "title": "easy-java-solution-2d-dp-beats-100-online-submissions",
                "content": "# Logic\\n\\n- The given problem involves a game played by two players, where they take turns selecting a number from either end of an integer array. The goal is to maximize their scores while considering the optimal strategy. The PredictTheWinner method in the provided Java code attempts to determine whether Player 1 can win the game or not.\\n\\n - The PredictTheWinner function uses dynamic programming to compute the best possible score that Player 1 can achieve when playing optimally. It initializes a 2D array dp to store computed subproblems to avoid redundant calculations. The helper function is recursively called to determine the maximum score Player 1 can obtain from a given range in the array. The recursive logic considers two options for Player 1 at each step: choosing the leftmost element and then calculating the optimal score for the remaining subarray, and choosing the rightmost element and calculating the optimal score for the remaining subarray. The result of each subproblem is memoized in the dp array to improve efficiency.\\n\\n - Finally, the function compares the score obtained by Player 1 with the total sum of the array minus Player 1\\'s score. If Player 1\\'s score is greater than or equal to the remaining sum, it returns true, indicating that Player 1 can win the game. This means that, according to the provided code, Player 1 can win the game if they play optimally.\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean PredictTheWinner(int[] nums) {\\n        int[][] dp = new int[nums.length][nums.length];\\n\\n        for(int[] it : dp){\\n            Arrays.fill(it,-1);\\n        }\\n        int player_1 = helper(nums,dp,0,nums.length-1);\\n\\n        int sum = 0;\\n\\n        for(int it : nums){\\n            sum += it;\\n        }\\n        sum -= player_1;\\n\\n        return player_1 >= sum;\\n    }\\n\\n    private int helper(int[] nums,int[][] dp, int i, int j){\\n        if(i > j){\\n            return 0;\\n        }\\n        if(dp[i][j] != -1){\\n            return dp[i][j];\\n        }\\n        int left =nums[i] + Math.min(helper(nums, dp, i+2, j), helper(nums, dp, i+1, j-1));\\n        int right = nums[j] + Math.min(helper(nums, dp, i+1, j-1), helper(nums, dp, i, j-2));\\n\\n        return dp[i][j] = Math.max(left,right);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Dynamic Programming",
                    "Recursion",
                    "Game Theory"
                ],
                "code": "```\\nclass Solution {\\n    public boolean PredictTheWinner(int[] nums) {\\n        int[][] dp = new int[nums.length][nums.length];\\n\\n        for(int[] it : dp){\\n            Arrays.fill(it,-1);\\n        }\\n        int player_1 = helper(nums,dp,0,nums.length-1);\\n\\n        int sum = 0;\\n\\n        for(int it : nums){\\n            sum += it;\\n        }\\n        sum -= player_1;\\n\\n        return player_1 >= sum;\\n    }\\n\\n    private int helper(int[] nums,int[][] dp, int i, int j){\\n        if(i > j){\\n            return 0;\\n        }\\n        if(dp[i][j] != -1){\\n            return dp[i][j];\\n        }\\n        int left =nums[i] + Math.min(helper(nums, dp, i+2, j), helper(nums, dp, i+1, j-1));\\n        int right = nums[j] + Math.min(helper(nums, dp, i+1, j-1), helper(nums, dp, i, j-2));\\n\\n        return dp[i][j] = Math.max(left,right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3336627,
                "title": "486-predict-the-winner-java",
                "content": "```\\nclass Solution {\\n    public long win(int nums[],int i,int j,int cha)\\n    {\\n        if(i>j)\\n            return 0;\\n        if(cha==0)\\n            return Math.max(nums[i]+win(nums,i+1,j,1),nums[j]+win(nums,i,j-1,1));\\n        else\\n            return Math.min(win(nums,i+1,j,0),win(nums,i,j-1,0));             \\n    }\\n    public boolean PredictTheWinner(int[] nums) {\\n        long sum=0;\\n        for(long x:nums)\\n            sum+=x;\\n        long one=win(nums,0,nums.length-1,0);\\n            sum-=one;\\n        return one>=sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public long win(int nums[],int i,int j,int cha)\\n    {\\n        if(i>j)\\n            return 0;\\n        if(cha==0)\\n            return Math.max(nums[i]+win(nums,i+1,j,1),nums[j]+win(nums,i,j-1,1));\\n        else\\n            return Math.min(win(nums,i+1,j,0),win(nums,i,j-1,0));             \\n    }\\n    public boolean PredictTheWinner(int[] nums) {\\n        long sum=0;\\n        for(long x:nums)\\n            sum+=x;\\n        long one=win(nums,0,nums.length-1,0);\\n            sum-=one;\\n        return one>=sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2448429,
                "title": "c-game-theory-recursion-memoization",
                "content": "* Runtime-> **With memoization -> 3ms**  **Without Memoization -> 390ms**\\n* `Solve` function calculates the best possible score that `player 1` can score. Since `player 2` also plays optimally we subtract the `player 2\\'s` best score from `player 1s` to determine the result.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> nums ;\\n    int dp[21][21] ;\\n    //solve get the maximum optimal score of player 1\\n    int solve(int i , int j){\\n        if(i > j) return 0 ;\\n        if(dp[i][j] != -1) return dp[i][j] ;\\n        \\n        int op1 = nums[i] - solve(i + 1, j) ;\\n        int op2 = nums[j] - solve(i,j - 1) ;\\n        \\n        return dp[i][j] = max(op1,op2) ;\\n    }\\n    bool PredictTheWinner(vector<int>& nums) {\\n        memset(dp,-1,sizeof(dp)) ;\\n        this->nums = nums ;\\n        return solve(0,nums.size() - 1) >= 0 ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> nums ;\\n    int dp[21][21] ;\\n    //solve get the maximum optimal score of player 1\\n    int solve(int i , int j){\\n        if(i > j) return 0 ;\\n        if(dp[i][j] != -1) return dp[i][j] ;\\n        \\n        int op1 = nums[i] - solve(i + 1, j) ;\\n        int op2 = nums[j] - solve(i,j - 1) ;\\n        \\n        return dp[i][j] = max(op1,op2) ;\\n    }\\n    bool PredictTheWinner(vector<int>& nums) {\\n        memset(dp,-1,sizeof(dp)) ;\\n        this->nums = nums ;\\n        return solve(0,nums.size() - 1) >= 0 ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2368877,
                "title": "simple-recursion-easy-to-understand",
                "content": "```\\n bool fun1(vector<int>& nums,int i,int j,int p1,int p2,bool p1turn)\\n    {\\n        if(i>j)\\n            return p1>=p2;\\n        \\n       if(p1turn)\\n       {\\n           return fun1(nums,i+1,j,p1+nums[i],p2,!p1turn)||fun1(nums,i,j-1,p1+nums[j],p2,!p1turn);\\n       }\\n       else\\n       {\\n            return fun1(nums,i+1,j,p1,p2+nums[i],!p1turn)&&fun1(nums,i,j-1,p1,p2+nums[j],!p1turn);\\n       }\\n        \\n    }\\n    bool PredictTheWinner(vector<int>& nums) { \\n        \\n        int n = nums.size();\\n        return fun1(nums,0,n-1,0,0,true);\\n       \\n        \\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\n bool fun1(vector<int>& nums,int i,int j,int p1,int p2,bool p1turn)\\n    {\\n        if(i>j)\\n            return p1>=p2;\\n        \\n       if(p1turn)\\n       {\\n           return fun1(nums,i+1,j,p1+nums[i],p2,!p1turn)||fun1(nums,i,j-1,p1+nums[j],p2,!p1turn);\\n       }\\n       else\\n       {\\n            return fun1(nums,i+1,j,p1,p2+nums[i],!p1turn)&&fun1(nums,i,j-1,p1,p2+nums[j],!p1turn);\\n       }\\n        \\n    }\\n    bool PredictTheWinner(vector<int>& nums) { \\n        \\n        int n = nums.size();\\n        return fun1(nums,0,n-1,0,0,true);\\n       \\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2029052,
                "title": "runtime-0-ms-faster-than-100-00-java-memoization",
                "content": "```\\nclass Solution {\\n    public boolean PredictTheWinner(int[] nums) {\\n        int totSum=0,n=nums.length;\\n        int[][] dp = new int[n][n];\\n        for(int i=0;i<n;i++){\\n            totSum+=nums[i];\\n            Arrays.fill(dp[i],-1);\\n        }\\n        int maxOfP1 = findMax(0,nums.length-1,nums,dp);\\n        return maxOfP1>=totSum-maxOfP1;\\n    }\\n    \\n    public static int findMax(int first,int last,int[] nums,int[][] dp){\\n        if(first>last) return 0;\\n        \\n        if(dp[first][last]!=-1) return dp[first][last];\\n//         By considering the worst case scenario,here im picking the minimum values on my next turn,\\n//         because i assume that my opponent will take max value so that i\\'ll get min value.\\n        int pickFirst = nums[first]+Math.min(findMax(first+2,last,nums,dp),findMax(first+1,last-1,nums,dp));\\n        int pickLast = nums[last]+Math.min(findMax(first+1,last-1,nums,dp),findMax(first,last-2,nums,dp));\\n        \\n//         from the minimum picks,i take maximum\\n//         picking the best value is in my hands so i pick the max value\\n        return dp[first][last]=Math.max(pickFirst,pickLast);\\n    }\\n}\\n```\\nAnalysis\\nhere we trying every combination,so that we can get max value\\nTC:O(n * n) \\nSC:O(n * n) + O(n)",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public boolean PredictTheWinner(int[] nums) {\\n        int totSum=0,n=nums.length;\\n        int[][] dp = new int[n][n];\\n        for(int i=0;i<n;i++){\\n            totSum+=nums[i];\\n            Arrays.fill(dp[i],-1);\\n        }\\n        int maxOfP1 = findMax(0,nums.length-1,nums,dp);\\n        return maxOfP1>=totSum-maxOfP1;\\n    }\\n    \\n    public static int findMax(int first,int last,int[] nums,int[][] dp){\\n        if(first>last) return 0;\\n        \\n        if(dp[first][last]!=-1) return dp[first][last];\\n//         By considering the worst case scenario,here im picking the minimum values on my next turn,\\n//         because i assume that my opponent will take max value so that i\\'ll get min value.\\n        int pickFirst = nums[first]+Math.min(findMax(first+2,last,nums,dp),findMax(first+1,last-1,nums,dp));\\n        int pickLast = nums[last]+Math.min(findMax(first+1,last-1,nums,dp),findMax(first,last-2,nums,dp));\\n        \\n//         from the minimum picks,i take maximum\\n//         picking the best value is in my hands so i pick the max value\\n        return dp[first][last]=Math.max(pickFirst,pickLast);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2007760,
                "title": "c-easy-solution-memoization-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n\\n    long long fun(int i,int j,vector<int>&nums,vector<vector<int>>&dp){\\n        if(i==j)return nums[i];\\n        if(i>j){\\n            return 0;\\n        }\\n        if(dp[i][j]!=-1)return dp[i][j];\\n        \\n        long long l=nums[i]+min(fun(i+2,j,nums,dp),fun(i+1,j-1,nums,dp));\\n        long long r=nums[j]+min(fun(i+1,j-1,nums,dp),fun(i,j-2,nums,dp));\\n        \\n        return dp[i][j]=max(l,r);\\n    }\\n    \\n    bool PredictTheWinner(vector<int>& nums) {\\n        int n=nums.size();\\n        long long a=0,b=0;\\n        vector<vector<int>>dp(n,vector<int>(n,-1));\\n        \\n        for(auto i:nums)\\n            b+=i;\\n        \\n        a=fun(0,n-1,nums,dp);\\n        long long c=b-a;\\n        return (a>=c);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Game Theory"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    long long fun(int i,int j,vector<int>&nums,vector<vector<int>>&dp){\\n        if(i==j)return nums[i];\\n        if(i>j){\\n            return 0;\\n        }\\n        if(dp[i][j]!=-1)return dp[i][j];\\n        \\n        long long l=nums[i]+min(fun(i+2,j,nums,dp),fun(i+1,j-1,nums,dp));\\n        long long r=nums[j]+min(fun(i+1,j-1,nums,dp),fun(i,j-2,nums,dp));\\n        \\n        return dp[i][j]=max(l,r);\\n    }\\n    \\n    bool PredictTheWinner(vector<int>& nums) {\\n        int n=nums.size();\\n        long long a=0,b=0;\\n        vector<vector<int>>dp(n,vector<int>(n,-1));\\n        \\n        for(auto i:nums)\\n            b+=i;\\n        \\n        a=fun(0,n-1,nums,dp);\\n        long long c=b-a;\\n        return (a>=c);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1581418,
                "title": "not-fast-1ms-but-understandable",
                "content": "```\\nclass Solution {\\n    public boolean PredictTheWinner(int[] nums) \\n    {\\n        return predict(nums,0,nums.length-1,0,0,true);\\n        \\n    }\\n    // Main mortive is to make p1 win at any cost\\n    boolean predict(int[] a,int start,int end,int p1,int p2,boolean turn)\\n    {\\n        if(start==end) // Base Case\\n        {\\n            if(turn)\\n                p1+=a[start];\\n            else\\n                p2+=a[start];\\n            \\n            return p1>=p2;\\n        }\\n        // If turn is false its p2\\'s turn or else it\\'s p1\\'s turn\\n        if(turn)    // if taking the first element in each case doesn\\'t give p1 win then take the end element \\n        {\\n            return predict(a, start+1,end, p1+a[start], p2,false) || predict(a, start,end-1, p1+a[end], p2,false);\\n        }\\n        else // if p2 get defeated in any case i.e either taking first or last element  that means this is a winning case for p1\\n            \\n            return predict(a, start+1,end, p1, p2+a[start],true) && predict(a, start,end-1, p1, p2+a[end],true); \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public boolean PredictTheWinner(int[] nums) \\n    {\\n        return predict(nums,0,nums.length-1,0,0,true);\\n        \\n    }\\n    // Main mortive is to make p1 win at any cost\\n    boolean predict(int[] a,int start,int end,int p1,int p2,boolean turn)\\n    {\\n        if(start==end) // Base Case\\n        {\\n            if(turn)\\n                p1+=a[start];\\n            else\\n                p2+=a[start];\\n            \\n            return p1>=p2;\\n        }\\n        // If turn is false its p2\\'s turn or else it\\'s p1\\'s turn\\n        if(turn)    // if taking the first element in each case doesn\\'t give p1 win then take the end element \\n        {\\n            return predict(a, start+1,end, p1+a[start], p2,false) || predict(a, start,end-1, p1+a[end], p2,false);\\n        }\\n        else // if p2 get defeated in any case i.e either taking first or last element  that means this is a winning case for p1\\n            \\n            return predict(a, start+1,end, p1, p2+a[start],true) && predict(a, start,end-1, p1, p2+a[end],true); \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1445750,
                "title": "thinking-process-java-code",
                "content": "**Approach** - You(P1) can only win if you can put your opponent(P2) in a situation where his choices don\\'t matter.\\nThat means, **both** the branches of recursion for your opponent should make him lose.\\n\\nCurrent score of any Player  = `nums[l] + score_till_now` or `nums[r] + score_till_now`\\nwhere `l` and `r` denote the array range they are currently playing in.\\n\\n```\\n```\\n\\t// returns true if score of P1 >= score of P2\\n\\t// turn = true, means it is P1\\'s turn\\n    private boolean f(int[] nums, boolean turn, int p1, int p2, int l, int r) {\\n        if (l == r) {\\n            if (turn)\\n                p1 += nums[l];\\n            else\\n                p2 += nums[l];\\n            return p1 >= p2;\\n        }\\n        if (turn) {\\n\\t\\t\\t// You can win by using left OR right\\n            return f(nums, false, nums[l]+p1, p2, l+1, r) || f(nums, false, nums[r]+p1, p2, l, r-1);\\n\\t\\t}\\n\\t\\t// For you to win, opponent needs to lose using both left AND right\\n        return f(nums, true, p1, nums[l]+p2, l+1, r) && f(nums, true, p1, nums[r]+p2, l, r-1);\\n    }\\n\\n    public boolean PredictTheWinner(int[] nums) {\\n        return f(nums, true, 0, 0, 0, nums.length-1);\\n    }\\n```\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n```\n```\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1101164,
                "title": "c-memoization",
                "content": "```\\n int dp[20][20];\\n   int solve(vector<int>&nums ,int i,int j){\\n     \\n     if(i==j) return nums[i];\\n     \\n     if(i>j){\\n       return 0;\\n     }\\n     if(dp[i][j]!=-1) return dp[i][j];\\n     \\n     int o1 = nums[i]+ min( solve(nums,i+2,j),solve(nums,i+1,j-1));\\n     int o2 = nums[j] + min(solve(nums,i,j-2),solve(nums,i+1,j-1));\\n     \\n     \\n     return dp[i][j]= max(o1,o2);\\n     \\n     \\n     \\n     \\n   }\\n  \\n  \\n  \\n  \\n  \\n    bool PredictTheWinner(vector<int>& nums) {\\n    memset(dp,-1,sizeof(dp));\\n       int sum =accumulate(nums.begin(),nums.end(),0);\\n        int o1=solve(nums,0,nums.size()-1);\\n      if(o1>=(sum-o1)) return true;\\n      return false;\\n      \\n     \\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\n int dp[20][20];\\n   int solve(vector<int>&nums ,int i,int j){\\n     \\n     if(i==j) return nums[i];\\n     \\n     if(i>j){\\n       return 0;\\n     }\\n     if(dp[i][j]!=-1) return dp[i][j];\\n     \\n     int o1 = nums[i]+ min( solve(nums,i+2,j),solve(nums,i+1,j-1));\\n     int o2 = nums[j] + min(solve(nums,i,j-2),solve(nums,i+1,j-1));\\n     \\n     \\n     return dp[i][j]= max(o1,o2);\\n     \\n     \\n     \\n     \\n   }\\n  \\n  \\n  \\n  \\n  \\n    bool PredictTheWinner(vector<int>& nums) {\\n    memset(dp,-1,sizeof(dp));\\n       int sum =accumulate(nums.begin(),nums.end(),0);\\n        int o1=solve(nums,0,nums.size()-1);\\n      if(o1>=(sum-o1)) return true;\\n      return false;\\n      \\n     \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 801836,
                "title": "easily-understandable-python-3-solution",
                "content": "This solution used the intuition that if our opponent\\'s score is `n`, then our score is `sum(nums) - n`.\\nSo for each iteration:\\n* Pass the sum of nums `summ`\\n* If There are only 2 numbers in nums - `return max(nums)`\\n* Get opponents score for both condition\\n\\t*  If first number is chosen `choose_first`\\n\\t*  If last number is chosen `choose_last`\\n* Return the maximum of the both scores we can get\\n\\n``` python 3\\nclass Solution(object):\\n    def PredictTheWinner(self, nums):\\n        summ = sum(nums)\\n        score = self.my_score(nums, summ)\\n        \\n        # If our score is greater than equal to opponents score, return True\\n        return True if score >= summ - score else False\\n    \\n    def my_score(self, nums, summ):\\n        if len(nums) <= 2:\\n\\t\\t\\t# If there are only 2 numbers, obviously we\\'ll choose the greatest number\\n            return max(nums)\\n        \\n        # my_score function will return the score of the opponent\\n        choose_first = self.my_score(nums[1:], summ-nums[0])\\n        choose_last = self.my_score(nums[:-1], summ-nums[-1])\\n        \\n        return max(summ - choose_first, summ - choose_last) \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "``` python 3\\nclass Solution(object):\\n    def PredictTheWinner(self, nums):\\n        summ = sum(nums)\\n        score = self.my_score(nums, summ)\\n        \\n        # If our score is greater than equal to opponents score, return True\\n        return True if score >= summ - score else False\\n    \\n    def my_score(self, nums, summ):\\n        if len(nums) <= 2:\\n\\t\\t\\t# If there are only 2 numbers, obviously we\\'ll choose the greatest number\\n            return max(nums)\\n        \\n        # my_score function will return the score of the opponent\\n        choose_first = self.my_score(nums[1:], summ-nums[0])\\n        choose_last = self.my_score(nums[:-1], summ-nums[-1])\\n        \\n        return max(summ - choose_first, summ - choose_last) \\n```",
                "codeTag": "Java"
            },
            {
                "id": 734028,
                "title": "c-clean-easy-to-read-solution",
                "content": "```\\nclass Solution {\\n    vector<vector<int>> dp;\\npublic:\\n    bool PredictTheWinner(vector<int>& nums) {\\n        int n = nums.size(), total = 0;\\n        dp.resize(n, vector<int>(n, -1));\\n\\t\\t\\n        for (auto num : nums)\\n            total += num;\\n        \\n        int player1_score = helper(0, n - 1, nums);\\n        int player2_score = total - player1_score;\\n        \\n        return player1_score >= player2_score;\\n    }\\n    \\n    int helper(int left, int right, vector<int>& nums) {\\n        if (left > right)\\n            return 0;\\n        \\n        if (right - left == 1)\\n            return max(nums[left], nums[right]);\\n        \\n        if (dp[left][right] != -1)\\n            return dp[left][right];\\n        \\n        int possibility1 = nums[left] + min(helper(left+2, right, nums), helper(left+1, right-1, nums));\\n        int possibility2 = nums[right] + min(helper(left, right-2, nums), helper(left+1, right-1, nums));\\n        dp[left][right] = max(possibility1, possibility2);\\n        \\n        return dp[left][right];\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n    vector<vector<int>> dp;\\npublic:\\n    bool PredictTheWinner(vector<int>& nums) {\\n        int n = nums.size(), total = 0;\\n        dp.resize(n, vector<int>(n, -1));\\n\\t\\t\\n        for (auto num : nums)\\n            total += num;\\n        \\n        int player1_score = helper(0, n - 1, nums);\\n        int player2_score = total - player1_score;\\n        \\n        return player1_score >= player2_score;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 600194,
                "title": "simple-c-solution-thoroughly-explained",
                "content": "The goal here is that we want to maximize the amount of money we can get assuming we move first.\\n\\nHere your dp[i][j] means the max value we can get if it it\\'s our turn and only coins between i and j remain.(Inclusively)\\n\\nSo dp[i][i] means there is only one coin left, we just pick it, dp[i][i+1] means there are only two left, we then pick the max one.\\n\\nNow we want to derive the more general case. dp[i][j] = max( something + v[i], something + v[j]), since we either will pick the i or j coin. The problem now turns to what \"something\" here will be.\\n\\nA quick idea may be dp[i][j] = max( dp[i + 1][j] + v[i], dp[i][j - 1] + v[j]), but here dp[i + 1][j] and dp[i][j - 1] are not the values directly available for us, it depends on the move that our opponent make.\\n\\nThen we assume our opponent is as good as we are and always make optimize move. The worse case is that we will get the minimal value out of all possible situation after our opponent make its move.\\n\\nso the correct dp formula would be dp[i][j] = max( min (dp[i + 1][j - 1], dp[i + 2][ j]) + v[i], min (dp[i][j - 2], dp[i + 1][ j - 1]) + v[j]}) .\\nIf we pick i, then our opponent need to deal with subproblem dp[i + 1][j], it either pick from i + 2 or j - 1. Similarly, If we pick j, then our opponent need to deal with subproblem dp[i][j - 1] , it either pick \\nfrom i + 1 or j - 2. We take the worse case into consideration so use min() here.\\n```\\nclass Solution {\\npublic:\\n    bool PredictTheWinner(vector<int>& nums) {\\n        if(nums.size()% 2 == 0) return true;\\n        int n = nums.size();\\n        vector<vector<int>> dp(n, vector<int>(n, 0));\\n        for(int i = 0; i < n; i++) {\\n            dp[i][i] = nums[i];\\n            for(int j = i-1; j >= 0; j--) {\\n                int a = j+1 < n && i-1 >= 0 ? dp[j+1][i-1] : 0;\\n                int b = j+2 < n ? dp[j+2][i] : 0;\\n                int c = i-2 >= 0 ? dp[j][i-2] : 0;\\n                dp[j][i] = max(nums[i]+min(a,c), nums[j]+min(a,b));\\n            }\\n        }\\n        return 2*dp[0][n-1] >= accumulate(nums.begin(), nums.end(), 0);  //profit of player1 should be greater than equal to half of the sum of array \\n    }\\n};```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool PredictTheWinner(vector<int>& nums) {\\n        if(nums.size()% 2 == 0) return true;\\n        int n = nums.size();\\n        vector<vector<int>> dp(n, vector<int>(n, 0));\\n        for(int i = 0; i < n; i++) {\\n            dp[i][i] = nums[i];\\n            for(int j = i-1; j >= 0; j--) {\\n                int a = j+1 < n && i-1 >= 0 ? dp[j+1][i-1] : 0;\\n                int b = j+2 < n ? dp[j+2][i] : 0;\\n                int c = i-2 >= 0 ? dp[j][i-2] : 0;\\n                dp[j][i] = max(nums[i]+min(a,c), nums[j]+min(a,b));\\n            }\\n        }\\n        return 2*dp[0][n-1] >= accumulate(nums.begin(), nums.end(), 0);  //profit of player1 should be greater than equal to half of the sum of array \\n    }\\n};```",
                "codeTag": "Java"
            },
            {
                "id": 114098,
                "title": "4-kinds-of-solution-recursive-memorization-2d-dp-1d-dp",
                "content": "recursive version,90ms:\\n```\\nclass Solution {\\n    public boolean PredictTheWinner(int[] nums) {\\n        return getAnswer(nums,0,nums.length - 1,1) >= 0;\\n    }\\n    public int getAnswer(int[] nums,int start,int end,int turn){\\n        if(start == end) return turn * nums[start];\\n        int l = turn * nums[start] + getAnswer(nums,start + 1,end,turn * -1);\\n        int r = turn * nums[end] + getAnswer(nums,start,end - 1,turn * -1);\\n        return turn * Math.max(turn * l,turn * r);\\n    }\\n}\\n```\\n\\nmemorization version,6ms,beats 40%:\\n```\\nclass Solution {\\n    private Integer[][] memo;\\n    public boolean PredictTheWinner(int[] nums) {\\n        memo = new Integer[nums.length][nums.length];\\n        return getAnswer(nums,0,nums.length - 1) >= 0;\\n    }\\n    public int getAnswer(int[] nums,int start,int end){\\n        if(start == end) return nums[start];\\n        if(memo[start][end] != null) return memo[start][end];\\n        int l = nums[start] - getAnswer(nums,start + 1,end);\\n        int r = nums[end] - getAnswer(nums,start,end - 1);\\n        int max = Math.max(l,r);\\n        memo[start][end] = max;\\n        return max;\\n    }\\n}\\n```\\n\\n2d-dp version,6ms,beats 40%:\\n```\\nclass Solution {\\n    public boolean PredictTheWinner(int[] nums) {\\n        int len = nums.length;\\n        int[][] dp = new int[len][len];\\n\\n        for(int i = 0;i < len;i++)  dp[i][i] = nums[i];\\n        for(int i = len - 2;i >= 0;i--){\\n            for(int j = i + 1;j < len;j++){\\n                dp[i][j] = Math.max(nums[i] - dp[i + 1][j],nums[j] - dp[i][j - 1]);\\n            }\\n        }\\n\\n        return dp[0][len - 1] >= 0;\\n    }\\n}\\n```\\n1d-dp version,5ms,beats 80%:\\n```\\nclass Solution {\\n    public boolean PredictTheWinner(int[] nums) {\\n        int len = nums.length;\\n        int[] dp = new int[len];\\n        for(int i = len - 2;i >= 0;i--){\\n            dp[i] = nums[i];\\n            for(int j = i + 1;j < len;j++)  dp[j] = Math.max(nums[i] - dp[j],nums[j] - dp[j - 1]);\\n        }\\n        return dp[len - 1] >= 0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean PredictTheWinner(int[] nums) {\\n        return getAnswer(nums,0,nums.length - 1,1) >= 0;\\n    }\\n    public int getAnswer(int[] nums,int start,int end,int turn){\\n        if(start == end) return turn * nums[start];\\n        int l = turn * nums[start] + getAnswer(nums,start + 1,end,turn * -1);\\n        int r = turn * nums[end] + getAnswer(nums,start,end - 1,turn * -1);\\n        return turn * Math.max(turn * l,turn * r);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    private Integer[][] memo;\\n    public boolean PredictTheWinner(int[] nums) {\\n        memo = new Integer[nums.length][nums.length];\\n        return getAnswer(nums,0,nums.length - 1) >= 0;\\n    }\\n    public int getAnswer(int[] nums,int start,int end){\\n        if(start == end) return nums[start];\\n        if(memo[start][end] != null) return memo[start][end];\\n        int l = nums[start] - getAnswer(nums,start + 1,end);\\n        int r = nums[end] - getAnswer(nums,start,end - 1);\\n        int max = Math.max(l,r);\\n        memo[start][end] = max;\\n        return max;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean PredictTheWinner(int[] nums) {\\n        int len = nums.length;\\n        int[][] dp = new int[len][len];\\n\\n        for(int i = 0;i < len;i++)  dp[i][i] = nums[i];\\n        for(int i = len - 2;i >= 0;i--){\\n            for(int j = i + 1;j < len;j++){\\n                dp[i][j] = Math.max(nums[i] - dp[i + 1][j],nums[j] - dp[i][j - 1]);\\n            }\\n        }\\n\\n        return dp[0][len - 1] >= 0;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean PredictTheWinner(int[] nums) {\\n        int len = nums.length;\\n        int[] dp = new int[len];\\n        for(int i = len - 2;i >= 0;i--){\\n            dp[i] = nums[i];\\n            for(int j = i + 1;j < len;j++)  dp[j] = Math.max(nums[i] - dp[j],nums[j] - dp[j - 1]);\\n        }\\n        return dp[len - 1] >= 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 96841,
                "title": "easy-python-dp-solution-without-dict",
                "content": "Because it doesn't use the dictionary, so it is quite slow.... just for fun~\\n```\\n#         p1 for player1 sum, p2 for player2 sum, turn == 0 for player1's turn\\n        def dp(nums,p1,p2,turn):\\n            if not nums:\\n                return p1 >= p2\\n            if turn:\\n                return dp(nums[1:],p1,p2+nums[0],0) and dp(nums[:-1],p1,p2+nums[-1],0)\\n            return dp(nums[1:],p1+nums[0],p2,1) or dp(nums[:-1],p1+nums[-1],p2,1)\\n        return dp(nums,0,0,0)\\n```\\nif it is the second player's turn, we need him to fail no matter which end he choose so that first player can force to a win.\\n\\nPlease correct me if I am wrong, Thanks",
                "solutionTags": [],
                "code": "```\\n#         p1 for player1 sum, p2 for player2 sum, turn == 0 for player1's turn\\n        def dp(nums,p1,p2,turn):\\n            if not nums:\\n                return p1 >= p2\\n            if turn:\\n                return dp(nums[1:],p1,p2+nums[0],0) and dp(nums[:-1],p1,p2+nums[-1],0)\\n            return dp(nums[1:],p1+nums[0],p2,1) or dp(nums[:-1],p1+nums[-1],p2,1)\\n        return dp(nums,0,0,0)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 96857,
                "title": "c-1-line-recursive-solution",
                "content": "```\\nbool helper(int* nums, int numsSize, int point, bool round){\\n    return !numsSize ? \\n    point>0 || round && !point :\\n    !helper(nums+1, numsSize-1, -(point + nums[0]), !round) || !helper(nums, numsSize-1, -(point + nums[numsSize-1]), !round);\\n}\\n\\nbool PredictTheWinner(int* nums, int numsSize) {\\n    return helper(nums, numsSize, 0, true);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nbool helper(int* nums, int numsSize, int point, bool round){\\n    return !numsSize ? \\n    point>0 || round && !point :\\n    !helper(nums+1, numsSize-1, -(point + nums[0]), !round) || !helper(nums, numsSize-1, -(point + nums[numsSize-1]), !round);\\n}\\n\\nbool PredictTheWinner(int* nums, int numsSize) {\\n    return helper(nums, numsSize, 0, true);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 96843,
                "title": "java-dp-solution-with-explanation",
                "content": "We can use dynamic programming. Suppose after several rounds, the remaining array is nums[i], nums[i+1],... nums[j]\\n- dp[i][j] = the maximum score of player1 on subarray nums[i..j] \\n\\nPlayer1 can choose either nums[i] or nums[j]. If nums[i] is chosen, player2 will also make best effort to get dp[i+1][j]. So for the subarray nums[i+1] ... nums[j], player1 can get:\\n- nums[i + 1] + nums[i + 2] + ... + nums[j] - dp[i+1][j], which is\\n- sum(nums[i+1] to nums[j]) - dp[i+1][j]\\n\\nSo we need another array sum to do range sum query, I set sum[0] to 0, sum[i] is the sum of all elements in nums before index i. so finally:\\n- dp[i][j] = max { sum[j+1] - sum[i+1] - dp[i+1][j] + nums[i], \\n                          sum[j] - sum[i] - dp[i][j-1] + nums[j]}\\n \\n\\n```\\n    public boolean PredictTheWinner(int[] nums) {\\n        if(nums.length <= 2) return true;\\n        int n = nums.length;\\n        int[] sum = new int[n+1];\\n        sum[0] = 0;\\n        for(int i = 1; i <= n; i ++) {\\n            sum[i] = sum[i-1] + nums[i-1];\\n        }\\n        \\n        int[][] dp = new int[n][n];\\n        for(int len = 1; len < n; len ++) {\\n            for(int i = 0; i + len < n; i ++) {\\n                int j = i + len;\\n                if(len == 1) dp[i][j] = Math.max(nums[i], nums[j]);\\n                else {\\n                    int can1 = sum[j+1] - sum[i+1] - dp[i+1][j] + nums[i];\\n                    int can2 = sum[j] - sum[i] - dp[i][j-1] + nums[j];\\n                    dp[i][j] = Math.max(can1, can2);\\n                }\\n            }\\n        }\\n        return sum[n] - dp[0][n-1] <= dp[0][n-1];\\n    }\\n    \\n```",
                "solutionTags": [],
                "code": "```\\n    public boolean PredictTheWinner(int[] nums) {\\n        if(nums.length <= 2) return true;\\n        int n = nums.length;\\n        int[] sum = new int[n+1];\\n        sum[0] = 0;\\n        for(int i = 1; i <= n; i ++) {\\n            sum[i] = sum[i-1] + nums[i-1];\\n        }\\n        \\n        int[][] dp = new int[n][n];\\n        for(int len = 1; len < n; len ++) {\\n            for(int i = 0; i + len < n; i ++) {\\n                int j = i + len;\\n                if(len == 1) dp[i][j] = Math.max(nums[i], nums[j]);\\n                else {\\n                    int can1 = sum[j+1] - sum[i+1] - dp[i+1][j] + nums[i];\\n                    int can2 = sum[j] - sum[i] - dp[i][j-1] + nums[j];\\n                    dp[i][j] = Math.max(can1, can2);\\n                }\\n            }\\n        }\\n        return sum[n] - dp[0][n-1] <= dp[0][n-1];\\n    }\\n    \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 96847,
                "title": "python-with-memorization-48-ms",
                "content": "```\\nclass Solution(object):\\n    def PredictTheWinner(self, nums):\\n        def check(left, right, memo):\\n            if left > right:\\n                return 0\\n            if left == right:\\n                return nums[left]\\n            if not (left, right) in memo:\\n                ss = sum(nums[left: right + 1])\\n                l, r = ss - check(left + 1, right, memo) + nums[left], ss - check(left, right - 1, memo) + nums[right]\\n                memo[(left, right)] = max(l, r)\\n            return memo[(left, right)]\\n\\n        s = sum(nums)\\n        c1 = check(0, len(nums) - 1, {})\\n        return c1 >= s - c1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def PredictTheWinner(self, nums):\\n        def check(left, right, memo):\\n            if left > right:\\n                return 0\\n            if left == right:\\n                return nums[left]\\n            if not (left, right) in memo:\\n                ss = sum(nums[left: right + 1])\\n                l, r = ss - check(left + 1, right, memo) + nums[left], ss - check(left, right - 1, memo) + nums[right]\\n                memo[(left, right)] = max(l, r)\\n            return memo[(left, right)]\\n\\n        s = sum(nums)\\n        c1 = check(0, len(nums) - 1, {})\\n        return c1 >= s - c1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3830806,
                "title": "c-4ms-dp-memoization",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(int i,int j,vector<int> &v,vector<vector<int>> &dp){\\n        if(i>j){\\n            return 0;\\n        }\\n        if(dp[i][j] != -1)return dp[i][j];\\n        int a = max(v[i]+min(solve(i+2,j,v,dp),solve(i+1,j-1,v,dp)),v[j]+min(solve(i,j-2,v,dp),solve(i+1,j-1,v,dp)));\\n        return dp[i][j] = a;\\n    }\\n    bool PredictTheWinner(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<vector<int>> dp(n+1,vector<int>(n+1,-1));\\n        int a = solve(0,n-1,nums,dp);\\n        cout<<a<<\" \";\\n        int s = 0;\\n        for(auto &i: nums)s += i;\\n        if(a >= s-a)return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int i,int j,vector<int> &v,vector<vector<int>> &dp){\\n        if(i>j){\\n            return 0;\\n        }\\n        if(dp[i][j] != -1)return dp[i][j];\\n        int a = max(v[i]+min(solve(i+2,j,v,dp),solve(i+1,j-1,v,dp)),v[j]+min(solve(i,j-2,v,dp),solve(i+1,j-1,v,dp)));\\n        return dp[i][j] = a;\\n    }\\n    bool PredictTheWinner(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<vector<int>> dp(n+1,vector<int>(n+1,-1));\\n        int a = solve(0,n-1,nums,dp);\\n        cout<<a<<\" \";\\n        int s = 0;\\n        for(auto &i: nums)s += i;\\n        if(a >= s-a)return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3830712,
                "title": "bottom-up-dp-2d-later-optimized-into-1d-beats-100",
                "content": "# Intuition\\nThis game can be modeled using recursion, where at each turn the 1st player chooses either the first or last element of the remaining array, and the second player then plays optimally on the remaining subarray. This suggests that we use dynamic programming to store the maximum score difference between the first and second player for each possible subarray of nums, and use this information to compute the final solution.\\n\\n\\n# Approach\\n\\nThe **DP** determines if the 1st player can win the game. The **state** dp[i][j] represents the maximum score difference between the first and second player when considering the subarray nums[i..j]. The base-case is when (i == j), in which case the first player can only choose the single number available, so dp[i][i] = nums[i].\\n\\nA 2D array is intuitive representing this information, since we need to keep track of both the start and end indices of each subarray. The state dp[i][j] represents the maximum score difference between the first and second player when considering the subarray nums[i..j]. For efficiency, we can use a bottom-up approach to fill in the instances of dp, starting from the base-case where (i == j) and moving towards the final solution at dp[0][n-1].\\n\\nThe outer loop iterates from n-2 down to 0, and the inner loop iterates from i+1 up to n-1, ensuring that all subproblems are solved before the final solution is computed\\n\\nThe **transition** between states is as follows: \\nAt each turn, the 1st player can choose either nums[i] or nums[j]. If the 1st player chooses nums[i], then the score difference becomes nums[i] - dp[i+1][j], since the 2nd player will then play optimally on the subarray nums[i+1 .. j]. Similarly, if the 1st player chooses nums[j], then the score difference becomes nums[j] - dp[i][j-1]. The first player will choose the option that maximizes their score difference, so we have the transition: dp[i][j] = max(nums[i] - dp[i+1][j], nums[j] - dp[i][j-1]).\\n\\nFinally, coming to the final solution after dp[0][n-1] >= 0, then the first player can win or tie, so we return true. Otherwise, we return false\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n- Space complexity:\\nO(n^2)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool PredictTheWinner(vector<int>& nums) {\\n        ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);            \\n        int n(nums.size());\\n        vector<vector<int>> dp(n, vector<int>(n));\\n        for (int i(0); i < n; ++i) \\n            dp[i][i] = nums[i];\\n        \\n        for (int i(n-2); i >= 0; --i) \\n            for (int j(i+1); j < n; ++j) \\n                dp[i][j] = max(nums[i] - dp[i+1][j], nums[j] - dp[i][j-1]);\\n            \\n        return dp[0][n-1] >= 0;\\n    }\\n};\\n```\\n\\n# **1D optimization** \\n\\n# Intuition : \\nOptimizing the space complexity from O(n^2) to O(n) \\n\\nSince the value of dp[i][j] only depends on the values of dp[i+1][j] and dp[i][j-1]. This means that we can compute the values of dp row by row, thus overwriting the previous row as we go and reducing space complexity is feasible. \\n\\n# Time complexity : \\nO(n^2)\\n\\n# Space complexity : \\nO(n)\\n\\n```\\nclass Solution {\\npublic:\\n    bool PredictTheWinner(vector<int>& nums) {\\n        ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\\n        int n(nums.size());\\n        vector<int> dp(nums);\\n        for (int i(n-2); i >= 0; --i) \\n            for (int j(i+1); j < n; ++j) \\n                dp[j] = max(nums[i] - dp[j], nums[j] - dp[j-1]);\\n        \\n        return dp[n-1] >= 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Dynamic Programming",
                    "Game Theory"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool PredictTheWinner(vector<int>& nums) {\\n        ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);            \\n        int n(nums.size());\\n        vector<vector<int>> dp(n, vector<int>(n));\\n        for (int i(0); i < n; ++i) \\n            dp[i][i] = nums[i];\\n        \\n        for (int i(n-2); i >= 0; --i) \\n            for (int j(i+1); j < n; ++j) \\n                dp[i][j] = max(nums[i] - dp[i+1][j], nums[j] - dp[i][j-1]);\\n            \\n        return dp[0][n-1] >= 0;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool PredictTheWinner(vector<int>& nums) {\\n        ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\\n        int n(nums.size());\\n        vector<int> dp(nums);\\n        for (int i(n-2); i >= 0; --i) \\n            for (int j(i+1); j < n; ++j) \\n                dp[j] = max(nums[i] - dp[j], nums[j] - dp[j-1]);\\n        \\n        return dp[n-1] >= 0;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3828756,
                "title": "simple-python-beats-100-runtime-97ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def PredictTheWinner(self, nums: List[int]) -> bool:\\n\\n        arr = [0] * (n:= len(nums))\\n        \\n        for i in range(n-1,-1,-1):\\n            arr[i] = nums[i]\\n            \\n            for j in range(i+1, n):\\n                arr[j] = max(nums[i]-arr[j  ],\\n                             nums[j]-arr[j-1])\\n            \\n        return arr[n-1] >= 0\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def PredictTheWinner(self, nums: List[int]) -> bool:\\n\\n        arr = [0] * (n:= len(nums))\\n        \\n        for i in range(n-1,-1,-1):\\n            arr[i] = nums[i]\\n            \\n            for j in range(i+1, n):\\n                arr[j] = max(nums[i]-arr[j  ],\\n                             nums[j]-arr[j-1])\\n            \\n        return arr[n-1] >= 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3827851,
                "title": "c-very-easy-simple-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMaximize the score of player 1 and Minimise the score for player two.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe start from both end and look for max (1) or for min (2). Take total sum and return the score(i.e score pf player 1) , now subract score from total sum and compare & return.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& nums,int i,int j,int chance){\\n        if(i>j) return 0;\\n        if(chance==0)\\n            return max(nums[i]+solve(nums,i+1,j,1),nums[j]+solve(nums,i,j-1,1));\\n        else\\n            return min(solve(nums,i+1,j,0),solve(nums,i,j-1,0));\\n    }\\n    bool PredictTheWinner(vector<int>& nums) {\\n        int n=nums.size();\\n        long long sum=0;\\n        for(int i=0;i<n;i++) sum=sum+nums[i];\\n        long long one=(long long) solve(nums,0,n-1,0);\\n        sum=sum-one;\\n        return(one>=sum);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& nums,int i,int j,int chance){\\n        if(i>j) return 0;\\n        if(chance==0)\\n            return max(nums[i]+solve(nums,i+1,j,1),nums[j]+solve(nums,i,j-1,1));\\n        else\\n            return min(solve(nums,i+1,j,0),solve(nums,i,j-1,0));\\n    }\\n    bool PredictTheWinner(vector<int>& nums) {\\n        int n=nums.size();\\n        long long sum=0;\\n        for(int i=0;i<n;i++) sum=sum+nums[i];\\n        long long one=(long long) solve(nums,0,n-1,0);\\n        sum=sum-one;\\n        return(one>=sum);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3827419,
                "title": "recursion-memoization-easy-to-understand-beginner-friendly-explanation",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe **score1** function is a **recursive function** that calculates the **maximum score the first player can achieve** when they are allowed to pick numbers from the array nums between indices l and r. It uses dynamic programming with memoization to avoid redundant calculations and optimize the process.\\n\\nLet\\'s break down the function step by step:\\n\\n1. **Base Cases:**\\n- If (l > r) return 0;: If the start index l becomes greater than the end index r, it means that there are no more numbers left to choose from in the current range. In this case, the score is 0 since no numbers can be picked. This serves as a base case for the recursive calls.\\n- If (dp[l][r] != -1) return dp[l][r];: Before making any recursive calls, the function checks if the score for the current range (l to r) has already been calculated and stored in the memoization array dp. If so, it directly returns the precomputed value, avoiding redundant calculations.\\n\\n2. **Recursive Calls:**\\nThe function considers **two choices** for the current player:\\n- **Choice1**: The first player picks the number at index l and then the second player (assuming both players play optimally) will choose between the two options:\\n**score1(nums, l + 2, r, dp)**: The second player picks the number at index l + 1, and the first player will choose from the range **l + 2 to r**.\\n**score1(nums, l + 1, r - 1, dp)**: The second player picks the number at index r, and the first player will choose from the range **l + 1 to r - 1**.\\n- **Choice2**: The first player picks the number at index r and then the second player (assuming both players play optimally) will choose between the two options:\\n**score1(nums, l + 1, r - 1, dp)**: The second player picks the number at index l, and the first player will choose from the range **l + 1 to r - 1**.\\n**score1(nums, l, r - 2, dp)**: The second player picks the number at index r - 1, and the first player will choose from the range **l to r - 2**.\\n3. **Returning the Maximum Score:**\\nThe function returns the maximum of choice1 and choice2. This represents the optimal score the first player can achieve for the current range (**l to r**).\\n**Memoization:**\\nBefore returning the calculated score, the function stores it in the memoization array dp at the corresponding position dp[l][r]. This way, if the function is called with the same range later on, it can directly return the precomputed value instead of recomputing it, saving time and improving the overall performance.\\nBy using this recursive approach with memoization, the function efficiently calculates the maximum score the first player can achieve for various subranges of the input array, which ultimately helps in determining whether the first player can guarantee a win in the main PredictTheWinner function.\\n\\n\\n---\\n\\n\\n\\n- ### Feel free to post your doubts in the comment section.\\n\\n---\\n\\n\\n# Complexity\\n- Time complexity: **O(n^2)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(n^2)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int score1(vector<int> &nums, int l, int r, vector<vector<int>> &dp) {\\n        if(l > r) return 0;\\n        if(dp[l][r] != -1) return dp[l][r];\\n        \\n        int choice1 = nums[l] + min(score1(nums, l + 2, r, dp), score1(nums, l + 1, r - 1, dp));\\n        int choice2 = nums[r] + min(score1(nums, l + 1, r - 1, dp), score1(nums, l, r - 2, dp));\\n        return dp[l][r] = max(choice1, choice2);\\n    }\\n    bool PredictTheWinner(vector<int>& nums) {\\n        int total = 0;\\n        for(int i = 0; i < nums.size(); i++) {\\n            total += nums[i];\\n        }\\n        vector<vector<int>> dp(nums.size(), vector<int> (nums.size(), -1));\\n        int player1 = score1(nums, 0, nums.size() - 1, dp);\\n\\n        if(player1 >= total - player1) return true;\\n        else return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int score1(vector<int> &nums, int l, int r, vector<vector<int>> &dp) {\\n        if(l > r) return 0;\\n        if(dp[l][r] != -1) return dp[l][r];\\n        \\n        int choice1 = nums[l] + min(score1(nums, l + 2, r, dp), score1(nums, l + 1, r - 1, dp));\\n        int choice2 = nums[r] + min(score1(nums, l + 1, r - 1, dp), score1(nums, l, r - 2, dp));\\n        return dp[l][r] = max(choice1, choice2);\\n    }\\n    bool PredictTheWinner(vector<int>& nums) {\\n        int total = 0;\\n        for(int i = 0; i < nums.size(); i++) {\\n            total += nums[i];\\n        }\\n        vector<vector<int>> dp(nums.size(), vector<int> (nums.size(), -1));\\n        int player1 = score1(nums, 0, nums.size() - 1, dp);\\n\\n        if(player1 >= total - player1) return true;\\n        else return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3826841,
                "title": "beats-100-3-approaches-in-depth-explanation-simple-recursion-and-dp-solution",
                "content": "# Approach-1\\n# The Game Rules:\\n1. The game is played using an array of elements.\\n2. Two players, player1 and player2, take turns to play.\\n3. Each player can choose either the first or the last element from the array.\\n4. The objective of both players is to maximize their chances of winning the game.\\n5. If a player finds that their current choice leads to a losing situation (according to some predefined winning/losing criteria), they will immediately switch to the other choice for their next turn.\\n6. The game continues until there are no more elements in the array to choose.\\n\\n# Goal of the Players:\\n1. Both player1 and player2 are trying their best to win the game.\\n2. They will analyze the outcomes of both options (choosing the first or last element) to make their decision.\\n3. If they find that their initial choice leads to a losing situation, they will change their decision and choose the other option.\\n4. They will keep adapting their choices throughout the game to maximize their chances of winning.\\n\\nAfter reading the above rules and and goal of the game i am sure that you will be able to understand the code also \\n\\n```\\nNote the function (f) return true if player1 wins and false if player1 doesn\\'t win.\\n```\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool f(int score1, int score2, int s, int e, int turn, vector<int>& nums) {\\n        // Base case: If there are no more elements in the subarray, check if the first player\\'s score is greater than or equal to the second player\\'s score\\n        if (s > e)\\n            return score1 >= score2;\\n\\n        if (turn == 0) {\\n            // It\\'s the first player\\'s turn\\n\\n            // Try choosing the first element from the array and check if the second player loses with this move\\n            if (f(score1 + nums[s], score2, s + 1, e, 1, nums)) {\\n                return true; // The first player wins in this scenario\\n            } else {\\n                // If the first player loses with the first element, they try choosing the last element from the array and check if the second player loses with this move\\n                return f(score1 + nums[e], score2, s, e - 1, 1, nums);\\n            }\\n        } else {\\n            // It\\'s the second player\\'s turn\\n\\n            // The second player tries choosing the first element from the array and check if the first player loses with this move\\n            if (f(score1, score2 + nums[s], s + 1, e, 0, nums)) \\n            {\\n                // If the first player doesn\\'t lose with the first element, the second player chooses the last element from the array and checks if they can win with this move.\\n                return f(score1, score2 + nums[e], s, e - 1, 0, nums);\\n           }\\n            return false;\\n        }\\n    }\\n\\n    bool predictTheWinner(vector<int>& nums) {\\n        int score1 = 0; // First player\\'s current score\\n        int score2 = 0; // Second player\\'s current score\\n        int turn = 0;   // 0 -> First player, 1 -> Second player\\n        int s = 0;      // Start index of the subarray\\n        int e = nums.size() - 1; // End index of the subarray\\n\\n        // Call the recursive function to determine if the first player can win the game\\n        return f(score1, score2, s, e, turn, nums);\\n    }\\n};\\n\\n```\\n# Approach-2\\n\\nNow in above recursion code it is hard to apply dynamic programming, even if you are able to apply it, the time complexity will be O(n^4) which is really bad.Now to reduce it we have to think of something better. Now suppose i have a function which gives the Max Difference between the scores of the 2 players given to us.Now we know both the player would like to have the max difference to be maximum, using this idea we will solve the question we calculate the max difference if we take the first element and do similarly for the case if we took the last element.\\nNow to check if player1 wins the output from max difference should be positive or equal to zero.\\n\\n# Recursion solution\\n```\\nclass Solution {\\npublic:\\n    int maxDiff(vector<int>&nums,int first,int last,int n)\\n    {\\n        //Base case if there is only one element left in the array.\\n        if (first == last) {\\n            return nums[first];\\n        }\\n        // check the maxDiff if the player took the first element\\n        int scoreByFirst = nums[first] - maxDiff(nums, first + 1, last, n);\\n        // check the maxDiff if the player took the last element\\n        int scoreByLast = nums[last] - maxDiff(nums, first, last - 1, n);\\n        // returning the max of the differences we get\\n        return max(scoreByFirst,scoreByLast);\\n    }\\n    bool predictTheWinner(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n        int first=0;//first element index\\n        int last=n-1;//last element index\\n        return maxDiff(nums, first, last, n) >= 0;\\n    }\\n};\\n```\\n# Dynamic Programming solution-1(Complex version)\\n```\\nclass Solution {\\npublic:\\n    int maxDiff(vector<int>&nums,int first,int last,int n,vector<vector<int>>&dp)\\n    {\\n        //Base case if there is only one element left in the array.\\n        if (first == last) {\\n            return nums[first];\\n        }\\n        //Checking if the maxDiff exist in the dp array\\n        if(dp[first][last]!=-1) return dp[first][last];\\n        // Check the maxDiff if the player took the first element\\n        int scoreByFirst = nums[first] - maxDiff(nums, first + 1, last, n,dp);\\n        // Check the maxDiff if the player took the last element\\n        int scoreByLast = nums[last] - maxDiff(nums, first, last - 1, n,dp);\\n        // Storing and returning the max of the differences we get\\n        return dp[first][last]=max(scoreByFirst,scoreByLast);\\n    }\\n    bool predictTheWinner(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n        int first=0;//first element index\\n        int last=n-1;//last element index\\n        vector<vector<int>>dp(n+1,vector<int>(n+1,-1));\\n        return maxDiff(nums, first, last, n,dp) >= 0;\\n    }\\n};\\n```\\n# Dynamic Programming solution-2(bit simpler version)\\n```\\nclass Solution {\\npublic:\\n    int f(vector<int>& nums,int s,int e,int turn,vector<vector<vector<int>>>&dp)\\n    {\\n        if(s==e)\\n        {\\n            if(turn ==0) return nums[s];\\n            return -nums[s];\\n        }\\n        if(dp[s][e][turn]!=-1) return dp[s][e][turn];\\n        if(turn==0)\\n        {\\n            int opt1=f(nums,s+1,e,1,dp)+nums[s];\\n            int opt2=f(nums,s,e-1,1,dp)+nums[e];\\n            return dp[s][e][turn]=max(opt1,opt2);\\n        }\\n        int opt1=f(nums,s+1,e,0,dp)-nums[s];\\n        int opt2=f(nums,s,e-1,0,dp)-nums[e];\\n        return dp[s][e][turn]=min(opt1,opt2);\\n    }\\n    bool predictTheWinner(vector<int>& nums) \\n    {\\n        int n=nums.size();\\n        vector<vector<vector<int>>>dp(n,vector<vector<int>>(n,vector<int>(2,-1)));\\n        return f(nums,0,n-1,0,dp) >= 0;   \\n    }\\n};\\n```\\nIf you like the soln please upvote.\\n![5kej8w.jpg](https://assets.leetcode.com/users/images/978a1bc8-0ae1-4400-a2f6-8ee50f196e25_1690520126.3655.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nNote the function (f) return true if player1 wins and false if player1 doesn\\'t win.\\n```\n```\\nclass Solution {\\npublic:\\n    bool f(int score1, int score2, int s, int e, int turn, vector<int>& nums) {\\n        // Base case: If there are no more elements in the subarray, check if the first player\\'s score is greater than or equal to the second player\\'s score\\n        if (s > e)\\n            return score1 >= score2;\\n\\n        if (turn == 0) {\\n            // It\\'s the first player\\'s turn\\n\\n            // Try choosing the first element from the array and check if the second player loses with this move\\n            if (f(score1 + nums[s], score2, s + 1, e, 1, nums)) {\\n                return true; // The first player wins in this scenario\\n            } else {\\n                // If the first player loses with the first element, they try choosing the last element from the array and check if the second player loses with this move\\n                return f(score1 + nums[e], score2, s, e - 1, 1, nums);\\n            }\\n        } else {\\n            // It\\'s the second player\\'s turn\\n\\n            // The second player tries choosing the first element from the array and check if the first player loses with this move\\n            if (f(score1, score2 + nums[s], s + 1, e, 0, nums)) \\n            {\\n                // If the first player doesn\\'t lose with the first element, the second player chooses the last element from the array and checks if they can win with this move.\\n                return f(score1, score2 + nums[e], s, e - 1, 0, nums);\\n           }\\n            return false;\\n        }\\n    }\\n\\n    bool predictTheWinner(vector<int>& nums) {\\n        int score1 = 0; // First player\\'s current score\\n        int score2 = 0; // Second player\\'s current score\\n        int turn = 0;   // 0 -> First player, 1 -> Second player\\n        int s = 0;      // Start index of the subarray\\n        int e = nums.size() - 1; // End index of the subarray\\n\\n        // Call the recursive function to determine if the first player can win the game\\n        return f(score1, score2, s, e, turn, nums);\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int maxDiff(vector<int>&nums,int first,int last,int n)\\n    {\\n        //Base case if there is only one element left in the array.\\n        if (first == last) {\\n            return nums[first];\\n        }\\n        // check the maxDiff if the player took the first element\\n        int scoreByFirst = nums[first] - maxDiff(nums, first + 1, last, n);\\n        // check the maxDiff if the player took the last element\\n        int scoreByLast = nums[last] - maxDiff(nums, first, last - 1, n);\\n        // returning the max of the differences we get\\n        return max(scoreByFirst,scoreByLast);\\n    }\\n    bool predictTheWinner(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n        int first=0;//first element index\\n        int last=n-1;//last element index\\n        return maxDiff(nums, first, last, n) >= 0;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxDiff(vector<int>&nums,int first,int last,int n,vector<vector<int>>&dp)\\n    {\\n        //Base case if there is only one element left in the array.\\n        if (first == last) {\\n            return nums[first];\\n        }\\n        //Checking if the maxDiff exist in the dp array\\n        if(dp[first][last]!=-1) return dp[first][last];\\n        // Check the maxDiff if the player took the first element\\n        int scoreByFirst = nums[first] - maxDiff(nums, first + 1, last, n,dp);\\n        // Check the maxDiff if the player took the last element\\n        int scoreByLast = nums[last] - maxDiff(nums, first, last - 1, n,dp);\\n        // Storing and returning the max of the differences we get\\n        return dp[first][last]=max(scoreByFirst,scoreByLast);\\n    }\\n    bool predictTheWinner(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n        int first=0;//first element index\\n        int last=n-1;//last element index\\n        vector<vector<int>>dp(n+1,vector<int>(n+1,-1));\\n        return maxDiff(nums, first, last, n,dp) >= 0;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int f(vector<int>& nums,int s,int e,int turn,vector<vector<vector<int>>>&dp)\\n    {\\n        if(s==e)\\n        {\\n            if(turn ==0) return nums[s];\\n            return -nums[s];\\n        }\\n        if(dp[s][e][turn]!=-1) return dp[s][e][turn];\\n        if(turn==0)\\n        {\\n            int opt1=f(nums,s+1,e,1,dp)+nums[s];\\n            int opt2=f(nums,s,e-1,1,dp)+nums[e];\\n            return dp[s][e][turn]=max(opt1,opt2);\\n        }\\n        int opt1=f(nums,s+1,e,0,dp)-nums[s];\\n        int opt2=f(nums,s,e-1,0,dp)-nums[e];\\n        return dp[s][e][turn]=min(opt1,opt2);\\n    }\\n    bool predictTheWinner(vector<int>& nums) \\n    {\\n        int n=nums.size();\\n        vector<vector<vector<int>>>dp(n,vector<vector<int>>(n,vector<int>(2,-1)));\\n        return f(nums,0,n-1,0,dp) >= 0;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3826243,
                "title": "c-solution-recursive-memoization-both-solution-explained",
                "content": "# Explaination\\n\\nThe goal of the problem is to determine whether the first player can predict to win the game, assuming both players play optimally. Each player can choose numbers from the given array \"nums\" in turns, and the winner is the one with the higher sum of chosen numbers.\\n\\nSo, If the current player is choosing a number (indicated by \"choose\" being true), the function takes the maximum of two possibilities:\\n1. Choose the number at index \"i\" and recursively call \"solve\" with the next index \"i+1\" while switching the turn (by setting \"choose\" to false).\\n2. Choose the number at index \"j\" and recursively call \"solve\" with the previous index \"j-1\" while switching the turn (by setting \"choose\" to false).\\n\\nIf the current player is not choosing a number (indicated by \"choose\" being false), the function takes the minimum of two possibilities:\\n1. Skip the number at index \"i\" and recursively call \"solve\" with the next index \"i+1\" while switching the turn (by setting \"choose\" to true).\\n2. Skip the number at index \"j\" and recursively call \"solve\" with the previous index \"j-1\" while switching the turn (by setting \"choose\" to true).\\n\\nThe \"PredictTheWinner\" function calls \"solve\" initially with the entire \"nums\" array and sets \"choose\" to true, indicating that the first player is choosing a number.\\n\\nIf the score returned by \"solve\" is greater than or equal to 0, it means the first player can predict to win the game, and the function returns true. Otherwise, it returns false.\\n\\n# Complexity (Recursive)\\n- Time complexity: O(2^N),\\n\\n- Space complexity: O(N^2)\\n\\n\\n# Recursive Solution\\n\\n# Code (Recursive)\\n```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& nums,int i,int j, bool choose){\\n        if(i>j) return 0;\\n        int ans=0;\\n        if(choose){\\n            ans=max(nums[i]+solve(nums,i+1,j,false),nums[j]+solve(nums,i,j-1,false));\\n        }\\n        else{\\n            ans=min(-nums[i]+solve(nums,i+1,j,true),-nums[j]+solve(nums,i,j-1,true));\\n        }\\n        return ans;\\n    }\\n\\n    bool PredictTheWinner(vector<int>& nums) {\\n        bool choose=true;\\n        int n=nums.size();\\n        int score=solve(nums,0,n-1,choose);\\n        if(score>=0) return true;\\n        return false;\\n    }\\n};\\n```\\n\\n# Memoization Solution \\n\\n# Complexity (Memoization)\\n- Time complexity: O(N^2)\\n\\n- Space complexity: O(N^2)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    unordered_map<string,int> dp;\\n    int solve(vector<int>& nums,int i,int j, bool choose){\\n        if(i>j) return 0;\\n        string key= to_string(i)+\"Ekansh\"+ to_string(j)+\"Sharma\"+to_string(choose);\\n        if(dp.count(key)) return dp[key];\\n\\n        int ans=0;\\n        if(choose){\\n            ans=max(nums[i]+solve(nums,i+1,j,false),nums[j]+solve(nums,i,j-1,false));\\n        }\\n        else{\\n            ans=min(-nums[i]+solve(nums,i+1,j,true),-nums[j]+solve(nums,i,j-1,true));\\n        }\\n        return dp[key]=ans;\\n    }\\n\\n    bool PredictTheWinner(vector<int>& nums) {\\n        bool choose=true;\\n        int n=nums.size();\\n        int score=solve(nums,0,n-1,choose);\\n        if(score>=0) return true;\\n        return false;\\n    }\\n};\\n\\n```\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& nums,int i,int j, bool choose){\\n        if(i>j) return 0;\\n        int ans=0;\\n        if(choose){\\n            ans=max(nums[i]+solve(nums,i+1,j,false),nums[j]+solve(nums,i,j-1,false));\\n        }\\n        else{\\n            ans=min(-nums[i]+solve(nums,i+1,j,true),-nums[j]+solve(nums,i,j-1,true));\\n        }\\n        return ans;\\n    }\\n\\n    bool PredictTheWinner(vector<int>& nums) {\\n        bool choose=true;\\n        int n=nums.size();\\n        int score=solve(nums,0,n-1,choose);\\n        if(score>=0) return true;\\n        return false;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    unordered_map<string,int> dp;\\n    int solve(vector<int>& nums,int i,int j, bool choose){\\n        if(i>j) return 0;\\n        string key= to_string(i)+\"Ekansh\"+ to_string(j)+\"Sharma\"+to_string(choose);\\n        if(dp.count(key)) return dp[key];\\n\\n        int ans=0;\\n        if(choose){\\n            ans=max(nums[i]+solve(nums,i+1,j,false),nums[j]+solve(nums,i,j-1,false));\\n        }\\n        else{\\n            ans=min(-nums[i]+solve(nums,i+1,j,true),-nums[j]+solve(nums,i,j-1,true));\\n        }\\n        return dp[key]=ans;\\n    }\\n\\n    bool PredictTheWinner(vector<int>& nums) {\\n        bool choose=true;\\n        int n=nums.size();\\n        int score=solve(nums,0,n-1,choose);\\n        if(score>=0) return true;\\n        return false;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3659978,
                "title": "easyyyyyyyy",
                "content": "# Intuition\\nbasic optimal strategy for a game\\n\\n# Approach\\nwe have two choices either to choose the first or last so we will choose the element which gives us the best result ans the other one will choose a number which will be maximum of his choice.\\n\\nif we choose the first number i then opponent can choose either i+1 or jth number then he has two choices if i+1 we get i+2,j and if he chooses jth we get i+1,j-1 . after what he chooses he will try to give us as minimum result as possible.\\nif we choose last number then the other player will get i,j-1 the he will choose either i+1 or j-1 then we get i+1,j-1 or i,j-2 and we will have minimum after these choices\\n\\n# Complexity\\n- Time complexity:\\nO(N^2)\\n\\n- Space complexity:\\nO(N2)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int f( vector<int> &nums,int i,int j,   vector<vector<int>> &dp){\\n        if(i>j) return 0;\\n        if(i==j) return nums[i];\\n        if(dp[i][j]!=-1) return dp[i][j];\\n\\n        int a = nums[i] + min(f(nums,i+2,j,dp),f(nums,i+1,j-1,dp));\\n        int b = nums[j] + min(f(nums,i,j-2,dp),f(nums,i+1,j-1,dp));\\n        dp[i][j] = max(a,b);\\n        return dp[i][j];\\n    }\\n    bool PredictTheWinner(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<vector<int>> dp(n,vector<int>(n,-1));\\n        int sum =0;\\n        for( auto i : nums){\\n            sum+= i;\\n        }\\n         int ans = f(nums,0,n-1,dp);\\n         int ans2 = sum -ans;\\n         return ans>=ans2;\\n         \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int f( vector<int> &nums,int i,int j,   vector<vector<int>> &dp){\\n        if(i>j) return 0;\\n        if(i==j) return nums[i];\\n        if(dp[i][j]!=-1) return dp[i][j];\\n\\n        int a = nums[i] + min(f(nums,i+2,j,dp),f(nums,i+1,j-1,dp));\\n        int b = nums[j] + min(f(nums,i,j-2,dp),f(nums,i+1,j-1,dp));\\n        dp[i][j] = max(a,b);\\n        return dp[i][j];\\n    }\\n    bool PredictTheWinner(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<vector<int>> dp(n,vector<int>(n,-1));\\n        int sum =0;\\n        for( auto i : nums){\\n            sum+= i;\\n        }\\n         int ans = f(nums,0,n-1,dp);\\n         int ans2 = sum -ans;\\n         return ans>=ans2;\\n         \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3329757,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int rec(vector<int> &nums,int i,int j,vector<vector<int>> &dp)\\n    { if(i > j) return 0; \\n        if(dp[i][j] != -1) return dp[i][j];\\n        int ans1 = nums[i] + min(rec(nums,i+1,j-1,dp),rec(nums,i+2,j,dp));\\n        int ans2 = nums[j] + min(rec(nums,i+1,j-1,dp),rec(nums,i,j-2,dp));\\n        dp[i][j] = max(ans1,ans2);\\n        return dp[i][j];\\n    }\\n    bool PredictTheWinner(vector<int>& nums) \\n    { int n = nums.size();\\n        vector<vector<int>> dp(n,vector<int>(n,-1));\\n        int ans = rec(nums,0,n-1,dp);\\n        int sum = 0;\\n        for(auto i:nums) sum += i;\\n        return (ans >= sum - ans);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rec(vector<int> &nums,int i,int j,vector<vector<int>> &dp)\\n    { if(i > j) return 0; \\n        if(dp[i][j] != -1) return dp[i][j];\\n        int ans1 = nums[i] + min(rec(nums,i+1,j-1,dp),rec(nums,i+2,j,dp));\\n        int ans2 = nums[j] + min(rec(nums,i+1,j-1,dp),rec(nums,i,j-2,dp));\\n        dp[i][j] = max(ans1,ans2);\\n        return dp[i][j];\\n    }\\n    bool PredictTheWinner(vector<int>& nums) \\n    { int n = nums.size();\\n        vector<vector<int>> dp(n,vector<int>(n,-1));\\n        int ans = rec(nums,0,n-1,dp);\\n        int sum = 0;\\n        for(auto i:nums) sum += i;\\n        return (ans >= sum - ans);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3175771,
                "title": "great-question-with-easy-c-solution-love-babbar",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(vector<int>&nums,int i, int j){\\n        if(i>j){\\n            return 0;\\n        }\\n        if(i==j){\\n            return nums[i];\\n        }\\n        int option1 = nums[i] + min(solve(nums,i+2,j),solve(nums,i+1,j-1));\\n        int option2 = nums[j] + min(solve(nums,i+1,j-1),solve(nums,i,j-2));\\n \\n        return max(option1 , option2);\\n    }\\n    bool PredictTheWinner(vector<int>& nums) {\\n        int p1Score = solve(nums,0,nums.size()-1);\\n        int total_Score = 0;\\n        for(int i=0;i<nums.size();i++){\\n            total_Score += nums[i];\\n        }\\n        int p2Score = total_Score - p1Score;\\n        if(p1Score>=p2Score){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<int>&nums,int i, int j){\\n        if(i>j){\\n            return 0;\\n        }\\n        if(i==j){\\n            return nums[i];\\n        }\\n        int option1 = nums[i] + min(solve(nums,i+2,j),solve(nums,i+1,j-1));\\n        int option2 = nums[j] + min(solve(nums,i+1,j-1),solve(nums,i,j-2));\\n \\n        return max(option1 , option2);\\n    }\\n    bool PredictTheWinner(vector<int>& nums) {\\n        int p1Score = solve(nums,0,nums.size()-1);\\n        int total_Score = 0;\\n        for(int i=0;i<nums.size();i++){\\n            total_Score += nums[i];\\n        }\\n        int p2Score = total_Score - p1Score;\\n        if(p1Score>=p2Score){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2597171,
                "title": "no-dp-used-recursive-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n   int solve(vector<int>& nums , int i , int j)\\n    {\\n        if(i > j)\\n        {\\n            return 0;\\n        }\\n        \\n        int op1 = nums[i] + min(solve(nums , i+2 , j) , solve(nums , i+1 , j-1));\\n        int op2 = nums[j] + min(solve(nums , i+1 , j-1) , solve(nums , i , j-2));\\n        \\n        return  max(op1 , op2); \\n    }\\n    \\n    bool PredictTheWinner(vector<int>& nums) {\\n        \\n        int totalsum = 0;\\n        for(int i = 0; i < nums.size(); i++)\\n        {\\n            totalsum += nums[i];\\n        }\\n       int p1 = solve(nums , 0 , nums.size()-1);\\n        \\n        int p2 = totalsum - p1;\\n        \\n        if(p1 < p2)\\n            return 0;\\n        \\n        return 1;\\n    }\\n};\\n```\\n**Please upvote this post to motivate me in my quest of documenting leetcode solutions.**",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n   int solve(vector<int>& nums , int i , int j)\\n    {\\n        if(i > j)\\n        {\\n            return 0;\\n        }\\n        \\n        int op1 = nums[i] + min(solve(nums , i+2 , j) , solve(nums , i+1 , j-1));\\n        int op2 = nums[j] + min(solve(nums , i+1 , j-1) , solve(nums , i , j-2));\\n        \\n        return  max(op1 , op2); \\n    }\\n    \\n    bool PredictTheWinner(vector<int>& nums) {\\n        \\n        int totalsum = 0;\\n        for(int i = 0; i < nums.size(); i++)\\n        {\\n            totalsum += nums[i];\\n        }\\n       int p1 = solve(nums , 0 , nums.size()-1);\\n        \\n        int p2 = totalsum - p1;\\n        \\n        if(p1 < p2)\\n            return 0;\\n        \\n        return 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2267734,
                "title": "c-two-appraoch-simple-and-clean-code",
                "content": "### **Approach 1: Simple recursion**\\n\\nclass Solution {\\npublic:\\n\\n    int p1 = 0;\\n    \\n    int predict(vector<int>& nums, int l, int r){\\n        if(l > r) return 0;\\n        if(l == r) return nums[l];\\n        \\n        int p1l = nums[l] + min(predict(nums, l+2, r), predict(nums, l+1, r-1));\\n        int p1r = nums[r] + min(predict(nums, l, r-2), predict(nums, l+1, r-1));\\n        p1 = max(p1l, p1r);\\n        \\n        return p1;\\n    }\\n    \\n    bool PredictTheWinner(vector<int>& nums) {\\n        int total = 0, n = nums.size();\\n\\t\\tif(n % 2 == 0) return true;  // if nums size is even player 1 will always win. Try it!\\n        // total contains the sum of all elements of the nums array.\\n        for(auto x: nums) total += x;\\n        \\n        return 2 * predict(nums, 0, nums.size()-1) >= total;\\n    }\\n};\\n\\nThe above code has time complexity of **O(4 ^ N)** since in the worst case we can have **4 functional calls.**\\n\\n### **Approach 2: Recursion with dp**\\n\\nclass Solution {\\npublic:\\n\\n    int p1 = 0;\\n    vector<vector<int>> dp;\\n    \\n    int predict(vector<int>& nums, int l, int r){\\n        if(l > r) return 0;\\n        if(l == r) return nums[l];\\n        \\n        if(dp[l][r] != -1) return dp[l][r];\\n        \\n        int p1l = nums[l] + min(predict(nums, l+2, r), predict(nums, l+1, r-1));\\n        int p1r = nums[r] + min(predict(nums, l, r-2), predict(nums, l+1, r-1));\\n    \\n        return dp[l][r] = max(p1l, p1r);;\\n    }\\n    \\n    bool PredictTheWinner(vector<int>& nums) {\\n        \\n        int total = 0, n = nums.size();\\n        \\n        if(n % 2 == 0) return true; // if nums size is even player 1 will always win. Try it!\\n        for(auto x: nums) total += x;\\n        \\n        \\n        dp.resize(n, vector<int>(n, -1));\\n        return 2 * predict(nums, 0, nums.size()-1) >= total;\\n    }\\n};\\n\\nThe above code has time complexity of **O(n^2)!**\\n\\nNote: For better understanding and learning, consider dry running the code with different test cases.\\nFor query or doubt comment below.\\n**PLEASE UPVOTE IF HELPFUL!!!**",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int p1 = 0;\\n    \\n    int predict(vector<int>& nums, int l, int r){\\n        if(l > r) return 0;\\n        if(l == r) return nums[l];\\n        \\n        int p1l = nums[l] + min(predict(nums, l+2, r), predict(nums, l+1, r-1));\\n        int p1r = nums[r] + min(predict(nums, l, r-2), predict(nums, l+1, r-1));\\n        p1 = max(p1l, p1r);\\n        \\n        return p1;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2204898,
                "title": "stone-game-this-q-should-added-in-stone-series",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dp;\\n    int win(vector<int>& piles,int l,int r){\\n        if(r<l) return 0;\\n        if(dp[l][r] != -1) return dp[l][r];\\n        \\n        int start = piles[l] - win(piles,l+1,r) ;\\n        int last =  piles[r] - win(piles,l,r-1);\\n        \\n        return dp[l][r] = max(start,last);\\n    }\\n    bool stoneGame(vector<int>& piles) {\\n        dp = vector<vector<int>> (piles.size()+1, vector<int>(piles.size()+1,-1));\\n        return win(piles,0,piles.size()-1) >= 0;\\n    }\\n    bool PredictTheWinner(vector<int>& nums) {\\n        return stoneGame(nums);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dp;\\n    int win(vector<int>& piles,int l,int r){\\n        if(r<l) return 0;\\n        if(dp[l][r] != -1) return dp[l][r];\\n        \\n        int start = piles[l] - win(piles,l+1,r) ;\\n        int last =  piles[r] - win(piles,l,r-1);\\n        \\n        return dp[l][r] = max(start,last);\\n    }\\n    bool stoneGame(vector<int>& piles) {\\n        dp = vector<vector<int>> (piles.size()+1, vector<int>(piles.size()+1,-1));\\n        return win(piles,0,piles.size()-1) >= 0;\\n    }\\n    bool PredictTheWinner(vector<int>& nums) {\\n        return stoneGame(nums);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1892496,
                "title": "c-solution",
                "content": "\\'\\'\\'\\nint dp[20][20];\\n    int help(vector<int>& num,int i,int j)\\n    {\\n        if(i>j) return 0;\\n        if(i==j) return dp[i][j]=num[i];\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        dp[i][j]=max(num[i]+min(help(num,i+2,j),help(num,i+1,j-1)),num[j]+min(help(num,i+1,j-1),help(num,i,j-2)));\\n        return dp[i][j];\\n    }\\n    bool PredictTheWinner(vector<int>& nums) {\\n        memset(dp,-1,sizeof(dp));\\n        int p1=help(nums,0,nums.size()-1);\\n        int score=0;\\n        for(auto num:nums)\\n        {\\n            score+=num;\\n        }\\n        return p1>=score-p1;\\n    }\\n\\'\\'\\'",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "\\'\\'\\'\\nint dp[20][20];\\n    int help(vector<int>& num,int i,int j)\\n    {\\n        if(i>j) return 0;\\n        if(i==j) return dp[i][j]=num[i];\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        dp[i][j]=max(num[i]+min(help(num,i+2,j),help(num,i+1,j-1)),num[j]+min(help(num,i+1,j-1),help(num,i,j-2)));\\n        return dp[i][j];\\n    }\\n    bool PredictTheWinner(vector<int>& nums) {\\n        memset(dp,-1,sizeof(dp));\\n        int p1=help(nums,0,nums.size()-1);\\n        int score=0;\\n        for(auto num:nums)\\n        {\\n            score+=num;\\n        }\\n        return p1>=score-p1;\\n    }\\n\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 1401761,
                "title": "optimized-bruteforce-without-dp-2ms-game-theory",
                "content": "```\\nclass Solution {\\n    public boolean play(int[] nums, int start, int end, boolean isPlayer1, int p1, int p2){\\n        if(start > end){\\n            return p1 >= p2;\\n        }\\n        if(isPlayer1){ // player 1 turn\\n            return play(nums, start+1,  end, false, p1+nums[start], p2) || \\n                   play(nums, start, end-1, false, p1+nums[end], p2);\\n        }\\n        // player 2 turn\\n        // irrespective of player2 moves, player1 should win the game\\n         return ( play(nums, start+1,  end, true, p1, p2+nums[start]) && \\n                  play(nums, start, end-1, true, p1, p2+nums[end]) );\\n    }\\n    public boolean PredictTheWinner(int[] nums) {\\n        return play(nums, 0, nums.length-1, true, 0, 0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean play(int[] nums, int start, int end, boolean isPlayer1, int p1, int p2){\\n        if(start > end){\\n            return p1 >= p2;\\n        }\\n        if(isPlayer1){ // player 1 turn\\n            return play(nums, start+1,  end, false, p1+nums[start], p2) || \\n                   play(nums, start, end-1, false, p1+nums[end], p2);\\n        }\\n        // player 2 turn\\n        // irrespective of player2 moves, player1 should win the game\\n         return ( play(nums, start+1,  end, true, p1, p2+nums[start]) && \\n                  play(nums, start, end-1, true, p1, p2+nums[end]) );\\n    }\\n    public boolean PredictTheWinner(int[] nums) {\\n        return play(nums, 0, nums.length-1, true, 0, 0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1339613,
                "title": "easy-c-code-using-basics-of-game-theory",
                "content": "int dp[21][21];\\n    int solve(int i,int j,vector<int>& nums)\\n    {\\n\\t\\t\\tif(i>j) return 0;\\n\\t\\t\\tif(dp[i][j]!=-1) return dp[i][j];\\n\\t\\t\\tint ans1=nums[i]-solve(i+1,j,nums); \\n        int ans2=nums[j]-solve(i,j-1,nums);\\n        return dp[i][j]=max(ans1,ans2);\\n    }\\n    bool PredictTheWinner(vector<int>& nums) {\\n        int n=nums.size();\\n        memset(dp,-1,sizeof(dp));\\n        return solve(0,n-1,nums)>=0;\\n    }",
                "solutionTags": [],
                "code": "int dp[21][21];\\n    int solve(int i,int j,vector<int>& nums)\\n    {\\n\\t\\t\\tif(i>j) return 0;\\n\\t\\t\\tif(dp[i][j]!=-1) return dp[i][j];\\n\\t\\t\\tint ans1=nums[i]-solve(i+1,j,nums); \\n        int ans2=nums[j]-solve(i,j-1,nums);\\n        return dp[i][j]=max(ans1,ans2);\\n    }\\n    bool PredictTheWinner(vector<int>& nums) {\\n        int n=nums.size();\\n        memset(dp,-1,sizeof(dp));\\n        return solve(0,n-1,nums)>=0;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1072148,
                "title": "easy-to-understand-recursive-java-o-n-2-solution",
                "content": "\\tclass Solution {\\n\\t\\tpublic boolean PredictTheWinner(int[] nums) {\\n\\t\\t\\tint start = 0;\\n\\t\\t\\tint end = nums.length;\\n\\t\\t\\tif(end==1) {\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t\\treturn nums.length == 1 ? true:\\n\\t\\t\\tcanWin(0, nums,start, end-1, 1);\\n\\t\\t}\\n\\n\\t\\tboolean canWin(int score, int[] nums, int start, int end, int turn) {\\n\\t\\t\\tif(start>end) {\\n\\t\\t\\t\\treturn score>=0;\\n\\t\\t\\t}\\n\\t\\t\\tif(turn==-1) {\\n\\t\\t\\t\\t// for player 2, we need to win no matter how he/she chooses.\\n\\t\\t\\t\\treturn canWin(score+turn*nums[start], nums, start+1, end, turn*-1) \\n\\t\\t\\t\\t\\t&& canWin(score+turn*nums[end], nums, start, end-1, turn*-1);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t// for player 1, we only need to win in one of the case.\\n\\t\\t\\t\\treturn canWin(score+turn*nums[start], nums, start+1, end, turn*-1) \\n\\t\\t\\t\\t\\t|| canWin(score+turn*nums[end], nums, start, end-1, turn*-1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\t\\n**Explanation**\\nImportant assumption for this question is that\\n1. Both players know the entire array up front, meaning that they are not just picking based on the first element and last emement each time. This is an important assumption as they know the consequences of picking different numbers. \\nFor example, if the array is [1, 2, 85, 3]. You r would pick 1 instead of 3 because otherwise you give the opponent the chance to pick up 85. Note that even 3>1, you are not \"greedy\" and choosing what\\'s larger here.\\n2. Both player would play to maximize their score.\\n\\n**Question**\\nThe question asks to know if player 1 can win. This can be translated to \"No matter how player 2 choose his/her numbers, player 1 would win.\" \\n\\n**Tips**\\nSince the quesiont asks us if player 1 can win, we can just calculate 1 final score. \\n1. For player 1\\'s turn , we add the number chosen to the final score.\\n2. For player 1\\'s turn , we subtract the number chosen to the final score.\\n3. At the end, we only need to check if the score is larger than 0 to determine if player 1 can win. \\n\\n**Solution**\\n1. canWin is the recursive function to determine if player 1 can win. \\n2. start and end are the variables to determine boundaries for the array a player can choose from currently. \\n3. After each recursion, if a player chooses nums[start], the remaining numbers can be chosen from are nums[start+1]...nums[end]\\n4. After each recursion, if a player chooses nums[end], the remaining numbers can be chosen from are nums[start]...nums[end-1]\\n5. A key here is that we need to change how we return based on the turn. if it\\'s player 1\\'s turn, we want to know if he/she can win by choosing one of the choices. Therefore the \"OR\" operator in return statement.\\n6. But if it\\'s player 2\\'s turn. Player 1 cannot control how player 2 chooses can need to win no matter which number player 2 chooses. Therefore the \"AND\" operator in return statement.",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic boolean PredictTheWinner(int[] nums) {\\n\\t\\t\\tint start = 0;\\n\\t\\t\\tint end = nums.length;\\n\\t\\t\\tif(end==1) {\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 692562,
                "title": "easy-optimal-game-strategy-algorithm-top-down",
                "content": "```python\\nclass Solution:\\n    def PredictTheWinner(self, nums: List[int]) -> bool:\\n        if len(nums) == 1: return True\\n        dp = [[-1 for i in range(len(nums)+1)] for j in range(len(nums)+1)]\\n        \\n        def game(i,j):\\n            if i > j:\\n                return 0\\n            if i == j:\\n                return nums[i]\\n            if dp[i][j] != -1: \\n                return dp[i][j]\\n            op1 = nums[i] + min(game(i+2,j),game(i+1,j-1))\\n            op2 = nums[j] + min(game(i,j-2),game(i+1,j-1))\\n            \\n            dp[i][j] = max(op1,op2)\\n            return dp[i][j]\\n        \\n        result = game(0,len(nums)-1)\\n        total = sum(nums)\\n        return result >= (total-result)\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def PredictTheWinner(self, nums: List[int]) -> bool:\\n        if len(nums) == 1: return True\\n        dp = [[-1 for i in range(len(nums)+1)] for j in range(len(nums)+1)]\\n        \\n        def game(i,j):\\n            if i > j:\\n                return 0\\n            if i == j:\\n                return nums[i]\\n            if dp[i][j] != -1: \\n                return dp[i][j]\\n            op1 = nums[i] + min(game(i+2,j),game(i+1,j-1))\\n            op2 = nums[j] + min(game(i,j-2),game(i+1,j-1))\\n            \\n            dp[i][j] = max(op1,op2)\\n            return dp[i][j]\\n        \\n        result = game(0,len(nums)-1)\\n        total = sum(nums)\\n        return result >= (total-result)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 460584,
                "title": "c-concise-recursion-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint getScore(vector<int>& nums, int l, int r){\\n\\t\\t\\tif(l==r) return nums[l];\\n\\t\\t\\treturn max(nums[l]-getScore(nums,l+1,r),nums[r]-getScore(nums,l,r-1));\\n\\t\\t}\\n\\t\\tbool PredictTheWinner(vector<int>& nums) {\\n\\t\\t\\treturn getScore(nums,0,nums.size()-1)>=0;\\n\\t\\t}\\n\\t};\\n\\t\\n\\t\\nRecursion with memorization solution:\\n\\t\\n\\t\\n\\t\\n\\t\\tclass Solution {\\n\\t\\tmap<vector<int>,int> m;\\n\\tpublic:\\n\\t\\tint getScore(vector<int>& nums, int l, int r){\\n\\t\\t\\tvector<int> tem{l,r};\\n\\t\\t\\tif(m.find(tem)!=m.end()) return m[tem];\\n\\t\\t\\tif(l==r) return nums[l];\\n\\t\\t\\tint a=max(nums[l]-getScore(nums,l+1,r),nums[r]-getScore(nums,l,r-1));\\n\\t\\t\\tm[tem]=a;\\n\\t\\t\\treturn a;\\n\\t\\t}\\n\\t\\tbool PredictTheWinner(vector<int>& nums) {\\n\\t\\t\\treturn getScore(nums,0,nums.size()-1)>=0;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint getScore(vector<int>& nums, int l, int r){\\n\\t\\t\\tif(l==r) return nums[l];\\n\\t\\t\\treturn max(nums[l]-getScore(nums,l+1,r),nums[r]-getScore(nums,l,r-1));\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 249938,
                "title": "python-dp-o-n-space-recursion-with-memory",
                "content": "Dynamic Programming\\n```\\nclass Solution(object):\\n    def PredictTheWinner(self, nums):\\n        dp = [num for num in nums]\\n        for length in range(2, len(nums) + 1):\\n            new_dp = []\\n            for j in range(len(nums) - length + 1):\\n                new_dp.append(max(nums[j] - dp[j + 1], nums[j + length - 1] - dp[j]))\\n            dp = new_dp[:]\\n        return dp[0] >= 0\\n```\\n\\nRecursion with memory\\n```\\nclass Solution:\\n    def PredictTheWinner(self, nums: List[int]) -> bool:\\n        nums = tuple(nums)\\n        mem = {}\\n        def win(nums):\\n            if nums in mem:\\n                return mem[nums]\\n            if len(nums) == 1:\\n                return nums[0]\\n            mem[nums] = max(nums[0] - win(nums[1:]), nums[-1] - win(nums[:-1]))\\n            return mem[nums]\\n        return win(nums) >= 0\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution(object):\\n    def PredictTheWinner(self, nums):\\n        dp = [num for num in nums]\\n        for length in range(2, len(nums) + 1):\\n            new_dp = []\\n            for j in range(len(nums) - length + 1):\\n                new_dp.append(max(nums[j] - dp[j + 1], nums[j + length - 1] - dp[j]))\\n            dp = new_dp[:]\\n        return dp[0] >= 0\\n```\n```\\nclass Solution:\\n    def PredictTheWinner(self, nums: List[int]) -> bool:\\n        nums = tuple(nums)\\n        mem = {}\\n        def win(nums):\\n            if nums in mem:\\n                return mem[nums]\\n            if len(nums) == 1:\\n                return nums[0]\\n            mem[nums] = max(nums[0] - win(nums[1:]), nums[-1] - win(nums[:-1]))\\n            return mem[nums]\\n        return win(nums) >= 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 213644,
                "title": "java-minimax-solution",
                "content": "```\\nclass Solution {\\n  \\n\\tpublic boolean PredictTheWinner(int[] nums) {\\n        \\n\\t\\treturn minimax(nums, 0, nums.length-1, true) >= 0;\\n    }\\n    \\n    private int minimax(int[] nums, int s, int e, boolean maximizingPlayer){\\n        \\n        if (s == e)\\n            return maximizingPlayer?nums[s]:-nums[s];\\n\\n        if (maximizingPlayer){\\n            int max = java.lang.Math.max(\\n            minimax(nums, s+1, e, false) + nums[s], \\n            minimax(nums, s, e-1, false) + nums[e]\\n            ); \\n            return max;\\n        }\\n        else{\\n            int min =  java.lang.Math.min(\\n            minimax(nums, s+1, e, true) - nums[s], \\n            minimax(nums, s, e-1, true) - nums[e]\\n            );\\n            return min;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n  \\n\\tpublic boolean PredictTheWinner(int[] nums) {\\n        \\n\\t\\treturn minimax(nums, 0, nums.length-1, true) >= 0;\\n    }\\n    \\n    private int minimax(int[] nums, int s, int e, boolean maximizingPlayer){\\n        \\n        if (s == e)\\n            return maximizingPlayer?nums[s]:-nums[s];\\n\\n        if (maximizingPlayer){\\n            int max = java.lang.Math.max(\\n            minimax(nums, s+1, e, false) + nums[s], \\n            minimax(nums, s, e-1, false) + nums[e]\\n            ); \\n            return max;\\n        }\\n        else{\\n            int min =  java.lang.Math.min(\\n            minimax(nums, s+1, e, true) - nums[s], \\n            minimax(nums, s, e-1, true) - nums[e]\\n            );\\n            return min;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 210085,
                "title": "two-c-solution",
                "content": "If it is player 1\\'s turn, use ||, if it is player 2s\\', use &&. \\nIt means in 1\\'s turn, if there is one solution, it is good enough to win, because you have the chance to pick that solution, however, in 2\\'s turn, you don\\'t have a chance to pick, so only if \"1 will win at this round no matter what 2 picks\", 1 will win in the final, so use &&.\\n```\\nclass Solution {\\npublic:\\n    bool PredictTheWinner(vector<int>& nums) {\\n        if (nums.size()<3) return true;\\n        return helper(0, nums.size()-1, 1, 0, nums);\\n    }\\n    bool helper(int left, int right, int turn, int val, vector<int>& nums){\\n        if (left==right) return (turn*nums[left]+val)>=0;\\n        if (turn==1) {\\n            return helper(left+1, right, -turn, val+turn*nums[left], nums)||helper(left, right-1, -turn, val+turn*nums[right],nums);\\n        }\\n        else{\\n           return helper(left+1, right, -turn, val+turn*nums[left], nums) && helper(left, right-1, -turn, val+turn*nums[right], nums); \\n        }\\n    }\\n};\\n```\\n\\nThe second solution is based on minimax thoery, but it doesn\\'t work as fast as the first one.\\n```\\nclass Solution {\\npublic:\\n    bool PredictTheWinner(vector<int>& nums) {\\n        if (nums.size() < 3) return true;\\n        return minimax (nums, 0, nums.size()-1, 1) >= 0;\\n    }\\n    int minimax (vector<int>& nums, int left, int right, bool turn){\\n        if (left == right) if (turn)\\n            return nums[left];\\n        else return -nums[left];\\n        int l, r;\\n        if (turn){\\n            l = nums[left] + minimax(nums, left + 1, right, false);\\n            r = nums[right] + minimax(nums, left, right-1, false);\\n            //cout<< \"1: \"<< max (l, r) << endl;\\n            return max (l, r);\\n        }else{\\n            l = -nums[left] + minimax(nums, left + 1, right, true);\\n            r = -nums[right] + minimax(nums, left, right-1, true);\\n            //cout<< \"0: \"<< min (l, r) << endl;\\n            return min (l, r);\\n        } \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool PredictTheWinner(vector<int>& nums) {\\n        if (nums.size()<3) return true;\\n        return helper(0, nums.size()-1, 1, 0, nums);\\n    }\\n    bool helper(int left, int right, int turn, int val, vector<int>& nums){\\n        if (left==right) return (turn*nums[left]+val)>=0;\\n        if (turn==1) {\\n            return helper(left+1, right, -turn, val+turn*nums[left], nums)||helper(left, right-1, -turn, val+turn*nums[right],nums);\\n        }\\n        else{\\n           return helper(left+1, right, -turn, val+turn*nums[left], nums) && helper(left, right-1, -turn, val+turn*nums[right], nums); \\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool PredictTheWinner(vector<int>& nums) {\\n        if (nums.size() < 3) return true;\\n        return minimax (nums, 0, nums.size()-1, 1) >= 0;\\n    }\\n    int minimax (vector<int>& nums, int left, int right, bool turn){\\n        if (left == right) if (turn)\\n            return nums[left];\\n        else return -nums[left];\\n        int l, r;\\n        if (turn){\\n            l = nums[left] + minimax(nums, left + 1, right, false);\\n            r = nums[right] + minimax(nums, left, right-1, false);\\n            //cout<< \"1: \"<< max (l, r) << endl;\\n            return max (l, r);\\n        }else{\\n            l = -nums[left] + minimax(nums, left + 1, right, true);\\n            r = -nums[right] + minimax(nums, left, right-1, true);\\n            //cout<< \"0: \"<< min (l, r) << endl;\\n            return min (l, r);\\n        } \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 121459,
                "title": "intuitive-minimax-solution",
                "content": "It\\'s a minimax strategy problem. Each turn, given two choice with different known payout, players will choose higher payout for himself (lower payout for the other guy).\\n\\nLet\\'s name starting player Maxi, other guy Mini\\n\\nSo the algorithm would be: \\n* Maxi\\'s turn, she will choose head or tail plus whatever she can get from Mini\\n* Mini\\'s turn, she will keep head or tail for herself and make sure Maxi will get smaller of two possible choices.\\n\\nUsing dp[i][j] to represent value of i->j for Maxi when she is making decision. \\n* Maxi: dp[i][j] = max(nums[i]+EvilMini(i+1, j), nums[j]+EvilMini(i,j-1))\\n* Mini: EvilMini(i,j) = min(dp[i+1][j], dp[i][j-1])\\n\\n```\\nclass Solution {\\npublic:\\n    int minimax(vector<vector<int>>& values, vector<int>& nums, int i, int j, bool max_player) {\\n        if (max_player) {\\n            if (values[i][j]==-1) values[i][j] = max(nums[i]+minimax(values, nums, i+1, j, false), nums[j]+minimax(values, nums, i,j-1,false));\\n            return values[i][j];\\n        } else {\\n            if (i==j) return 0;\\n            return min(minimax(values, nums, i+1, j, true), minimax(values, nums, i,j-1,true))\\n        }\\n    }\\n    \\n    bool PredictTheWinner(vector<int>& nums) {\\n        vector<vector<int>> values(nums.size(), vector<int>(nums.size(), -1)); //represents the value of position [i, j] for current player\\n        int total = 0;\\n        for (int i=0; i<nums.size(); i++) {\\n            total+=nums[i];\\n            values[i][i] = nums[i];\\n        }\\n        int result = minimax(values, nums, 0, nums.size()-1, true);\\n        return result*2>=total;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimax(vector<vector<int>>& values, vector<int>& nums, int i, int j, bool max_player) {\\n        if (max_player) {\\n            if (values[i][j]==-1) values[i][j] = max(nums[i]+minimax(values, nums, i+1, j, false), nums[j]+minimax(values, nums, i,j-1,false));\\n            return values[i][j];\\n        } else {\\n            if (i==j) return 0;\\n            return min(minimax(values, nums, i+1, j, true), minimax(values, nums, i,j-1,true))\\n        }\\n    }\\n    \\n    bool PredictTheWinner(vector<int>& nums) {\\n        vector<vector<int>> values(nums.size(), vector<int>(nums.size(), -1)); //represents the value of position [i, j] for current player\\n        int total = 0;\\n        for (int i=0; i<nums.size(); i++) {\\n            total+=nums[i];\\n            values[i][i] = nums[i];\\n        }\\n        int result = minimax(values, nums, 0, nums.size()-1, true);\\n        return result*2>=total;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 96891,
                "title": "evolve-from-brute-force-to-dp",
                "content": "1. O(2^n) The most intuitive approach is recursion. The sub problem is the max score of the first player. The first player can take either the first or the last element. The best move is the one that leaves the second player the min score.\\n```\\n     bool PredictTheWinner(vector<int>& nums) {\\n        int sum = accumulate(nums.begin(),nums.end(),0);\\n        int score = maxScore(0,nums.size()-1,sum,nums);\\n        return score >= sum -score;\\n    }\\n    int maxScore(int begin, int end, int sum, vector<int>& nums) {\\n        if(begin==end) return nums[begin];\\n        return sum-min(maxScore(begin+1,end, sum-nums[begin],nums), maxScore(begin,end-1,sum-nums[end],nums));\\n    }\\n```\\n2. O(2^n) To computer the total score of a player, we have to keep track of the sum of the array. This can be avoided by defining the sub problem as the max score difference. The idea is from [@Chidong ](https://discuss.leetcode.com/topic/76312/java-1-line-recursion-solution)\\n```\\n    bool PredictTheWinner(vector<int>& nums) {\\n        return maxScore(0,nums.size()-1,nums) >= 0;\\n    }\\n    int maxScore(int begin, int end, vector<int>& nums) {\\n        if(begin==end) return nums[begin];\\n        return max(nums[begin]-maxScore(begin+1,end,nums), nums[end]-maxScore(begin,end-1,nums));\\n    }\\n```\\n3. O(n^2) Memorization\\n```\\n    bool PredictTheWinner(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<vector<int>> mem(n,vector<int>(n,INT_MIN));\\n        return maxScore(0,n-1,nums,mem) >= 0;\\n    }\\n    int maxScore(int begin, int end, vector<int>& nums, vector<vector<int>>& mem) {\\n        if(begin==end) return nums[begin];\\n        if(mem[begin][end] != INT_MIN) return mem[begin][end];\\n        return mem[begin][end] = max(nums[begin]-maxScore(begin+1,end,nums,mem), nums[end]-maxScore(begin,end-1,nums,mem));\\n    }\\n```\\n4. O(n^2) dp and linear space dp.\\n```\\n     bool PredictTheWinner(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<vector<int>> mem(n,vector<int>(n));\\n        for(int i=n-1;i>=0;i--) {\\n            mem[i][i]=nums[i];\\n            for(int j=i+1;j<n;j++) mem[i][j] = max(nums[i]-mem[i+1][j],nums[j]-mem[i][j-1]);\\n        }\\n        return mem[0][n-1] >= 0;\\n    }\\n     bool PredictTheWinner(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> dp(n);\\n        for(int i=n-1;i>=0;i--) {\\n            dp[i] = nums[i];\\n            for(int j=i+1;j<n;j++) dp[j] = max(nums[i]-dp[j],nums[j]-dp[j-1]);\\n        }\\n        return dp[n-1] >= 0;\\n    } \\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n     bool PredictTheWinner(vector<int>& nums) {\\n        int sum = accumulate(nums.begin(),nums.end(),0);\\n        int score = maxScore(0,nums.size()-1,sum,nums);\\n        return score >= sum -score;\\n    }\\n    int maxScore(int begin, int end, int sum, vector<int>& nums) {\\n        if(begin==end) return nums[begin];\\n        return sum-min(maxScore(begin+1,end, sum-nums[begin],nums), maxScore(begin,end-1,sum-nums[end],nums));\\n    }\\n```\n```\\n    bool PredictTheWinner(vector<int>& nums) {\\n        return maxScore(0,nums.size()-1,nums) >= 0;\\n    }\\n    int maxScore(int begin, int end, vector<int>& nums) {\\n        if(begin==end) return nums[begin];\\n        return max(nums[begin]-maxScore(begin+1,end,nums), nums[end]-maxScore(begin,end-1,nums));\\n    }\\n```\n```\\n    bool PredictTheWinner(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<vector<int>> mem(n,vector<int>(n,INT_MIN));\\n        return maxScore(0,n-1,nums,mem) >= 0;\\n    }\\n    int maxScore(int begin, int end, vector<int>& nums, vector<vector<int>>& mem) {\\n        if(begin==end) return nums[begin];\\n        if(mem[begin][end] != INT_MIN) return mem[begin][end];\\n        return mem[begin][end] = max(nums[begin]-maxScore(begin+1,end,nums,mem), nums[end]-maxScore(begin,end-1,nums,mem));\\n    }\\n```\n```\\n     bool PredictTheWinner(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<vector<int>> mem(n,vector<int>(n));\\n        for(int i=n-1;i>=0;i--) {\\n            mem[i][i]=nums[i];\\n            for(int j=i+1;j<n;j++) mem[i][j] = max(nums[i]-mem[i+1][j],nums[j]-mem[i][j-1]);\\n        }\\n        return mem[0][n-1] >= 0;\\n    }\\n     bool PredictTheWinner(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> dp(n);\\n        for(int i=n-1;i>=0;i--) {\\n            dp[i] = nums[i];\\n            for(int j=i+1;j<n;j++) dp[j] = max(nums[i]-dp[j],nums[j]-dp[j-1]);\\n        }\\n        return dp[n-1] >= 0;\\n    } \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3830786,
                "title": "c-apni-bhasha-mein-seedhi-baat-no-bakwaas-dp-min-max-interview-prep",
                "content": "# Intuition & Approach\\n- Explained in the code\\n\\n# Code\\n```\\nclass Solution\\n{\\n    public:\\n\\n       \\tLOGIC\\n\\n       \\tKARNA KYA HAIN\\u2753\\n       \\t1. 2 Players hain jo ki ek game khel rahe hain.\\n       \\t2. Dono 0 score se start karenge. \\n       \\t3. Game:- Ek array \"nums\" diya hain usme se ham \"front\" and \"back\" 2 jagah\\n       \\tse number nikal sakte. Jo player number nikalega wo apne score mein wo num\\n       \\tdal lega.\\n       \\t4. Now our \"task\" is to make sure that at the end the \"player 1\" score\\n       \\tis >= \"player 2\" means we want that \"player 1 wins\".\\n       \\t5. Both players are optimally . Matlab\\u2753->Meaning ki dono players apni\\n       \\tapni baari mein apna score badhana chahenge.\\n       \\t6. Aur shuruat hamesha \"player 1\" karega.\\n\\n       \\tTHINGS TO BE CLEARED\\uD83D\\uDCA1\\n       \\t1. Problem mein hame p1 ka \"final score nahin nikalna hain\".\\n       \\t2. Our main focus is to that \"p1 ka score end mein p2 se bada aaye\".\\n       \\t3. So our focus is on difference of score of p1 and p2.\\n\\n       \\tINTUITION &APPROACH\\n       \\t1. Ab isme har player ke paas 2 choice hain ya to \"front\" se no nikale ya\\n       \\t\"back\" se.\\n       \\t2. To ab yahan choices involved hain to ham use karenge \\uD83D\\uDCA5RECURSION\\uD83D\\uDCA5.\\n       \\t3. Ab hamari is kahani mein \"p1 hain hero\" and \"p2 hain villain\".\\n       \\t4. Ham pure recursive pattern mein \"MaxDiff\" leke chalenge.\\n       \\t5. Why MaxDiff\\u2753\\n       \\t- Yeh puri kahani mein har koi jeetna chahta hain.\\n       \\t- Jab p1 ki baari ayegi to vo apna score max karna chahega\\n       \\t- Jab p2 ki baari ayegi vo apna score max karega.\\n       \\t- So ham extreme cases leke chal rahe hain.\\n       \\t- \"front\" ya \"back\" dono mein se jo elem nikalne per player ke jeetne\\n       \\tke chances badhenge vo player choose karega and hence usse maxDiff ayega.\\n       \\t6. Is kahani mein p1 hero hain to uska \"diff +\" hoga aur p2 villain to \\n       \\tuska \"diff -\" hoga.\\n       \\t7. RECURRENCE RELATION\\u2753\\n       \\t- Think in terms of index.\\n       \\t- Do all stuff on indexes.\\n       \\t- Yahan max diff se matlab hain, maanlo main player1 hu mere paas 2 choice\\n       \\thain \"x\" ya \"y\". Ham game ke beech mein hain.\\n       \\t- Abhi tak players ka max diff chalta aa raha \"dif\"(positive, neg) kuch\\n       \\tbhi ho sakta hain.\\n       \\t- To main apna max chahunga so,\\n       \\treturn max(x-dif,y-dif)\\n       \\t- Idhar alternate chal rahe hain pehle p1 and next p2.\\n       \\t- Agar last time p2 ka max diff nikalke jo score hua hoga usse bada p1\\n       \\tchah raha hain to vo max nikal raha iska p2 ki baari se.\\n       \\t- To +,-,+,- chalta rahega\\n       \\t- More clearly: (x-(z-(e-(maxDiff(left,right)))))...\\n       \\t- maxDiff(left,right) ->subarray nikal rahe.\\n       \\t- BASE CASE: Agar left==right hogaya to num[left] return karenge\\n       \\tKyo\\u2753-> Kyoki ab vohi hain hamare paas max diff koi front, back choice \\n       \\thain hi nahin.\\n       \\t8. Ab if we notice more clearly then there will \"overlapping subproblems\".\\n       \\t9. So we will use \\uD83D\\uDE0EDP.\\n       \\t10. RECURSION -> MEMOIZATION -> TABULATION -> SPACE OPTIMIZATION\\n       \\t11. Memoization steps\\n       \\t- Check what parameters are changing.(Here \"starting and end\" are changing.)\\n       \\t- According to params declare the dp array.(\"2D ARRAY\")\\n       \\t- In the recursive call check if that problem has been previously solved.\\n       \\t- Store the result in a dp array.\\n       \\t12. What does dp[left][right] denote\\u2753->It denotes the max difference upto that\\n       \\tleft and right index choices. This diff can be either \"+ve\" or \"-ve\" at any point.\\n        13. NOTE:- This is \"DP(MIN-MAX)\" pattern\\n        Why\\u2753- Player 1 apna score max karna chah raha aur Player 2\\n        Player 1 ka score min.\\n       \\t//==============================================================================================\\n        //MEMOIZATION\\n        int maxDiff(vector<vector < int>> &dp, int left, int right, vector< int > &nums)\\n        {\\n            if (left == right)\\n               \\t//ek hi choice hain jo elem bacha hain use lelo\\n                return nums[left];\\n            if (dp[left][right] != -1)\\n               \\t//Agar pehle se solved hain\\n                return dp[left][right];\\n\\n            int leftChoice = nums[left] - maxDiff(dp, left + 1, right, nums);\\n           \\t//Agar player ne starting se elem uthaya\\n            int rightChoice = nums[right] - maxDiff(dp, left, right - 1, nums);\\n           \\t//Agar player ne ending se elem uthaya\\n            return dp[left][right] = max(leftChoice, rightChoice);\\n           \\t//Storing the max diff with left and right index choices\\n        }\\n    bool PredictTheWinner(vector<int> &nums)\\n    {\\n        int n = nums.size();\\n        vector<vector < int>> dp(n + 1, vector<int> (n + 1, -1));\\n        return maxDiff(dp, 0, n - 1, nums) >= 0;\\n    }\\n};\\n```\\n# Complexity\\n- Time complexity:$O(n^2)$ great improvement from $O(2^n)$\\n\\n- Space complexity: $O(n^2)$ \\n\\nIf you *like* \\uD83D\\uDC4D this solution do *upvote* \\u2B06\\uFE0F and if there is any *improvement or suggestion* do mention it in the *comment* section \\uD83D\\uDE0A.\\n\\n<p align=\"center\">\\n<img src=\"https://assets.leetcode.com/users/images/1b604300-df68-46aa-a267-71f38463bb89_1684820402.7869222.jpeg\" width=\\'350\\' alt=\"Upvote Image\">\\n</p>",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n\\n       \\tLOGIC\\n\\n       \\tKARNA KYA HAIN\\u2753\\n       \\t1. 2 Players hain jo ki ek game khel rahe hain.\\n       \\t2. Dono 0 score se start karenge. \\n       \\t3. Game:- Ek array \"nums\" diya hain usme se ham \"front\" and \"back\" 2 jagah\\n       \\tse number nikal sakte. Jo player number nikalega wo apne score mein wo num\\n       \\tdal lega.\\n       \\t4. Now our \"task\" is to make sure that at the end the \"player 1\" score\\n       \\tis >= \"player 2\" means we want that \"player 1 wins\".\\n       \\t5. Both players are optimally . Matlab\\u2753->Meaning ki dono players apni\\n       \\tapni baari mein apna score badhana chahenge.\\n       \\t6. Aur shuruat hamesha \"player 1\" karega.\\n\\n       \\tTHINGS TO BE CLEARED\\uD83D\\uDCA1\\n       \\t1. Problem mein hame p1 ka \"final score nahin nikalna hain\".\\n       \\t2. Our main focus is to that \"p1 ka score end mein p2 se bada aaye\".\\n       \\t3. So our focus is on difference of score of p1 and p2.\\n\\n       \\tINTUITION &APPROACH\\n       \\t1. Ab isme har player ke paas 2 choice hain ya to \"front\" se no nikale ya\\n       \\t\"back\" se.\\n       \\t2. To ab yahan choices involved hain to ham use karenge \\uD83D\\uDCA5RECURSION\\uD83D\\uDCA5.\\n       \\t3. Ab hamari is kahani mein \"p1 hain hero\" and \"p2 hain villain\".\\n       \\t4. Ham pure recursive pattern mein \"MaxDiff\" leke chalenge.\\n       \\t5. Why MaxDiff\\u2753\\n       \\t- Yeh puri kahani mein har koi jeetna chahta hain.\\n       \\t- Jab p1 ki baari ayegi to vo apna score max karna chahega\\n       \\t- Jab p2 ki baari ayegi vo apna score max karega.\\n       \\t- So ham extreme cases leke chal rahe hain.\\n       \\t- \"front\" ya \"back\" dono mein se jo elem nikalne per player ke jeetne\\n       \\tke chances badhenge vo player choose karega and hence usse maxDiff ayega.\\n       \\t6. Is kahani mein p1 hero hain to uska \"diff +\" hoga aur p2 villain to \\n       \\tuska \"diff -\" hoga.\\n       \\t7. RECURRENCE RELATION\\u2753\\n       \\t- Think in terms of index.\\n       \\t- Do all stuff on indexes.\\n       \\t- Yahan max diff se matlab hain, maanlo main player1 hu mere paas 2 choice\\n       \\thain \"x\" ya \"y\". Ham game ke beech mein hain.\\n       \\t- Abhi tak players ka max diff chalta aa raha \"dif\"(positive, neg) kuch\\n       \\tbhi ho sakta hain.\\n       \\t- To main apna max chahunga so,\\n       \\treturn max(x-dif,y-dif)\\n       \\t- Idhar alternate chal rahe hain pehle p1 and next p2.\\n       \\t- Agar last time p2 ka max diff nikalke jo score hua hoga usse bada p1\\n       \\tchah raha hain to vo max nikal raha iska p2 ki baari se.\\n       \\t- To +,-,+,- chalta rahega\\n       \\t- More clearly: (x-(z-(e-(maxDiff(left,right)))))...\\n       \\t- maxDiff(left,right) ->subarray nikal rahe.\\n       \\t- BASE CASE: Agar left==right hogaya to num[left] return karenge\\n       \\tKyo\\u2753-> Kyoki ab vohi hain hamare paas max diff koi front, back choice \\n       \\thain hi nahin.\\n       \\t8. Ab if we notice more clearly then there will \"overlapping subproblems\".\\n       \\t9. So we will use \\uD83D\\uDE0EDP.\\n       \\t10. RECURSION -> MEMOIZATION -> TABULATION -> SPACE OPTIMIZATION\\n       \\t11. Memoization steps\\n       \\t- Check what parameters are changing.(Here \"starting and end\" are changing.)\\n       \\t- According to params declare the dp array.(\"2D ARRAY\")\\n       \\t- In the recursive call check if that problem has been previously solved.\\n       \\t- Store the result in a dp array.\\n       \\t12. What does dp[left][right] denote\\u2753->It denotes the max difference upto that\\n       \\tleft and right index choices. This diff can be either \"+ve\" or \"-ve\" at any point.\\n        13. NOTE:- This is \"DP(MIN-MAX)\" pattern\\n        Why\\u2753- Player 1 apna score max karna chah raha aur Player 2\\n        Player 1 ka score min.\\n       \\t//==============================================================================================\\n        //MEMOIZATION\\n        int maxDiff(vector<vector < int>> &dp, int left, int right, vector< int > &nums)\\n        {\\n            if (left == right)\\n               \\t//ek hi choice hain jo elem bacha hain use lelo\\n                return nums[left];\\n            if (dp[left][right] != -1)\\n               \\t//Agar pehle se solved hain\\n                return dp[left][right];\\n\\n            int leftChoice = nums[left] - maxDiff(dp, left + 1, right, nums);\\n           \\t//Agar player ne starting se elem uthaya\\n            int rightChoice = nums[right] - maxDiff(dp, left, right - 1, nums);\\n           \\t//Agar player ne ending se elem uthaya\\n            return dp[left][right] = max(leftChoice, rightChoice);\\n           \\t//Storing the max diff with left and right index choices\\n        }\\n    bool PredictTheWinner(vector<int> &nums)\\n    {\\n        int n = nums.size();\\n        vector<vector < int>> dp(n + 1, vector<int> (n + 1, -1));\\n        return maxDiff(dp, 0, n - 1, nums) >= 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3830240,
                "title": "video-solution-c-java-2-approaches",
                "content": "# Intuition, approach and time complexity explained in detail in video explanation.\\nhttps://youtu.be/uzPcUGcfNNQ\\n\\n# Code\\nC++\\n```\\nclass Solution {\\npublic:\\n    bool PredictTheWinner(vector<int>& nums) {\\n        int sz = nums.size();//size of given array\\n        vector<int>arrayState(1<<sz, INT_MIN);//for storing the result for a array state resulting after a set of choices for the players\\n        return scoreDiff(nums, 0, arrayState, 0, sz-1) >= 0; //checking the difference of the scores of player1 and player2 -> (p1 - p2 >= 0)\\n    }\\nprivate:\\n//recursive function\\n    int scoreDiff(vector<int>& nums, int currArrayState,  vector<int>& arrayState, int left, int right) {//two pointer left and right to keep track of the ends of the given array\\n        if(left > right) return 0; //there are no elements left to be selected           \\n        \\n        //if we have encountered this array State before then no need to re calculate it. and save some computation. \\n        if(arrayState[currArrayState] != INT_MIN) return arrayState[currArrayState];     \\n\\n        int currMaxScore = INT_MIN;\\n        //at each state of array given each player have 2 choices either to take from the left side or to take from the right side.\\n        //taking from left side\\n        currMaxScore = max(currMaxScore, nums[left] - scoreDiff(nums, (currArrayState | (1 << left)), arrayState, left+1, right));        \\n        //taking from right side\\n        currMaxScore = max(currMaxScore, nums[right] - scoreDiff(nums, (currArrayState | (1 << right)), arrayState, left, right-1));\\n        \\n        return arrayState[currArrayState] = currMaxScore;\\n    }\\n};\\n```\\nJava\\n```\\nclass Solution {\\n    public boolean PredictTheWinner(int[] nums) {\\n        int sz = nums.length;\\n        Integer[]arrayState = new Integer[1<<sz];\\n        return scoreDiff(nums, 0, arrayState, 0, sz-1) >= 0;\\n    }\\n    private int scoreDiff(int[]nums, int currArrayState,  Integer[]arrayState, int left, int right) {\\n        if(left > right) return 0;            \\n\\n        if(arrayState[currArrayState] != null) return arrayState[currArrayState];     \\n\\n        int currMaxScore = Integer.MIN_VALUE;\\n\\n        currMaxScore = Math.max(currMaxScore, nums[left] - scoreDiff(nums, (currArrayState | (1 << left)), arrayState, left+1, right));        \\n        \\n        currMaxScore = Math.max(currMaxScore, nums[right] - scoreDiff(nums, (currArrayState | (1 << right)), arrayState, left, right-1));\\n        \\n        return arrayState[currArrayState] = currMaxScore;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool PredictTheWinner(vector<int>& nums) {\\n        int sz = nums.size();//size of given array\\n        vector<int>arrayState(1<<sz, INT_MIN);//for storing the result for a array state resulting after a set of choices for the players\\n        return scoreDiff(nums, 0, arrayState, 0, sz-1) >= 0; //checking the difference of the scores of player1 and player2 -> (p1 - p2 >= 0)\\n    }\\nprivate:\\n//recursive function\\n    int scoreDiff(vector<int>& nums, int currArrayState,  vector<int>& arrayState, int left, int right) {//two pointer left and right to keep track of the ends of the given array\\n        if(left > right) return 0; //there are no elements left to be selected           \\n        \\n        //if we have encountered this array State before then no need to re calculate it. and save some computation. \\n        if(arrayState[currArrayState] != INT_MIN) return arrayState[currArrayState];     \\n\\n        int currMaxScore = INT_MIN;\\n        //at each state of array given each player have 2 choices either to take from the left side or to take from the right side.\\n        //taking from left side\\n        currMaxScore = max(currMaxScore, nums[left] - scoreDiff(nums, (currArrayState | (1 << left)), arrayState, left+1, right));        \\n        //taking from right side\\n        currMaxScore = max(currMaxScore, nums[right] - scoreDiff(nums, (currArrayState | (1 << right)), arrayState, left, right-1));\\n        \\n        return arrayState[currArrayState] = currMaxScore;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public boolean PredictTheWinner(int[] nums) {\\n        int sz = nums.length;\\n        Integer[]arrayState = new Integer[1<<sz];\\n        return scoreDiff(nums, 0, arrayState, 0, sz-1) >= 0;\\n    }\\n    private int scoreDiff(int[]nums, int currArrayState,  Integer[]arrayState, int left, int right) {\\n        if(left > right) return 0;            \\n\\n        if(arrayState[currArrayState] != null) return arrayState[currArrayState];     \\n\\n        int currMaxScore = Integer.MIN_VALUE;\\n\\n        currMaxScore = Math.max(currMaxScore, nums[left] - scoreDiff(nums, (currArrayState | (1 << left)), arrayState, left+1, right));        \\n        \\n        currMaxScore = Math.max(currMaxScore, nums[right] - scoreDiff(nums, (currArrayState | (1 << right)), arrayState, left, right-1));\\n        \\n        return arrayState[currArrayState] = currMaxScore;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3829734,
                "title": "the-art-of-dynamic-programming",
                "content": "[\\uD83C\\uDFA8 The ART of Dynamic Programming:](https://leetcode.com/discuss/general-discussion/712010/The-ART-of-Dynamic-Programming-An-Intuitive-Approach%3A-from-Apprentice-to-Master) \\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n\\nThis is a zero-sum game, ie. we optimally take either the `L`eft-most or `R`ight-most value `A[i]` or `A[j]` correspondingly, given the search space `i..j` inclusive, where initially`i = 0` and `j = N - 1`, where `N` is the cardinality of the input array `A`.  As the game proceeds, we recursively subtract the \"other\" Player\\'s optimal points acquired on their next turn.  As the recursive stack unwinds optimal sub-problem solutions are built upon themselves to formulate the overall optimal solution for Player 1.  Thus, we return `true` if-and-only-if the optimal solution for the overall problem is greater-than-or-equal-to `0`, ie. Player 1 wins.\\n\\n---\\n\\n**Kotlin Solutions:**\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nclass Solution {\\n    fun predictTheWinner(A: IntArray): Boolean {\\n        var N = A.size\\n        fun go(i: Int = 0, j: Int = N - 1): Int {\\n            if (i == j)                       // \\uD83D\\uDED1 base case\\n                return A[i]\\n            var L = A[i] - go(i + 1, j)\\n            var R = A[j] - go(i, j - 1)\\n            return Math.max(L, R)             // \\uD83C\\uDFAF accumulate maximum points for zero-sum game\\n        }\\n        return 0 <= go()                      // \\uD83C\\uDFAE player 1 win?\\n    }\\n}\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nclass Solution {\\n    fun predictTheWinner(A: IntArray): Boolean {\\n        var N = A.size\\n        var (m, key) = Pair(mutableMapOf<String, Int>(), { i: Int, j: Int -> \"$i,$j\" })\\n        fun go(i: Int = 0, j: Int = N - 1): Int {\\n            if (i == j)                          // \\uD83D\\uDED1 base case\\n                return A[i]\\n            var k = key(i, j)\\n            if (!m.contains(k)) {                 // \\uD83E\\uDD14 memo\\n                var L = A[i] - go(i + 1, j)\\n                var R = A[j] - go(i, j - 1)\\n                m[k] = Math.max(L, R)             // \\uD83C\\uDFAF accumulate maximum points for zero-sum game\\n            }\\n            return m[k]!!\\n        }\\n        return 0 <= go()                          // \\uD83C\\uDFAE player 1 win?\\n    }\\n}\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nclass Solution {\\n    fun predictTheWinner(A: IntArray): Boolean {\\n        var N = A.size\\n        var dp = Array(N){ IntArray(N){ -1 } }    // \\uD83E\\uDD14 memo\\n        for (i in 0 until N)\\n            dp[i][i] = A[i]                       // \\uD83D\\uDED1 base case: i == j\\n        for (i in N - 2 downTo 0) {\\n            for (j in i + 1 until N) {\\n                var L = A[i] - dp[i + 1][j]\\n                var R = A[j] - dp[i][j - 1]\\n                dp[i][j] = Math.max(L, R)         // \\uD83C\\uDFAF accumulate maximum points for zero-sum game\\n            }\\n        }\\n        return 0 <= dp[0][N - 1]                  // \\uD83C\\uDFAE player 1 win?\\n    }\\n}\\n```\\n\\n---\\n\\n**Javascript Solutions:**\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nlet predictTheWinner = (A, N = A.length) => {\\n    let go = (i = 0, j = N - 1) => {\\n        if (i == j)                        // \\uD83D\\uDED1 base case\\n            return A[i];\\n        let L = A[i] - go(i + 1, j),\\n            R = A[j] - go(i, j - 1);\\n        return Math.max(L, R);             // \\uD83C\\uDFAF accumulate maximum points for zero-sum game\\n    };\\n    return 0 <= go();                      // \\uD83C\\uDFAE player 1 win?\\n};\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nlet predictTheWinner = (A, N = A.length, m = new Map(), key = (i, j) => `${i},${j}`) => {\\n    let go = (i = 0, j = N - 1) => {\\n        if (i == j)                           // \\uD83D\\uDED1 base case\\n            return A[i];\\n        let k = key(i, j);\\n        if (!m.has(k)) {                      // \\uD83E\\uDD14 memo\\n            let L = A[i] - go(i + 1, j),\\n                R = A[j] - go(i, j - 1);\\n            m.set(k, Math.max(L, R));         // \\uD83C\\uDFAF accumulate maximum points for zero-sum game\\n        }\\n        return m.get(k);\\n    };\\n    return 0 <= go();                         // \\uD83C\\uDFAE player 1 win?\\n};\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nlet predictTheWinner = (A, N = A.length, dp = [...Array(N)].map(_ => Array(N).fill(-1))) => {  // \\uD83E\\uDD14 memo\\n    for (let i = 0; i < N; ++i)\\n        dp[i][i] = A[i];                       // \\uD83D\\uDED1 base case: i == j\\n    for (let i = N - 2; 0 <= i; --i) {\\n        for (let j = i + 1; j < N; ++j) {\\n            let L = A[i] - dp[i + 1][j],\\n                R = A[j] - dp[i][j - 1];\\n            dp[i][j] = Math.max(L, R);         // \\uD83C\\uDFAF accumulate maximum points for zero-sum game\\n        }\\n    }\\n    return 0 <= dp[0][N - 1];                  // \\uD83C\\uDFAE player 1 win?\\n};\\n```\\n\\n---\\n\\n**Python3 Solutions:**\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nclass Solution:\\n    def predictTheWinner(self, A: List[int]) -> bool:\\n        N = len(A)\\n        def go(i = 0, j = N - 1):\\n            if i == j:                   # \\uD83D\\uDED1 base case\\n                return A[i]\\n            L = A[i] - go(i + 1, j)\\n            R = A[j] - go(i, j - 1)\\n            return max(L, R)             # \\uD83C\\uDFAF accumulate maximum points for zero-sum game\\n        return 0 <= go()                 # \\uD83C\\uDFAE player 1 win?\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nclass Solution:\\n    def predictTheWinner(self, A: List[int]) -> bool:\\n        N = len(A)\\n        @cache                           # \\uD83E\\uDD14 memo\\n        def go(i = 0, j = N - 1):\\n            if i == j:                   # \\uD83D\\uDED1 base case\\n                return A[i]\\n            L = A[i] - go(i + 1, j)\\n            R = A[j] - go(i, j - 1)\\n            return max(L, R)             # \\uD83C\\uDFAF accumulate maximum points for zero-sum game\\n        return 0 <= go()                 # \\uD83C\\uDFAE player 1 win?\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nclass Solution:\\n    def predictTheWinner(self, A: List[int]) -> bool:\\n        N = len(A)\\n        dp = [[0] * N for _ in range(N)]         # \\uD83E\\uDD14 memo\\n        for i in range(N):\\n            dp[i][i] = A[i]                      # \\uD83D\\uDED1 base case when i == j\\n        for i in reversed(range(N)):\\n            for j in range(i + 1, N):\\n                if i + 1 < N and 0 <= j - 1:\\n                    L = A[i] - dp[i + 1][j]\\n                    R = A[j] - dp[i][j - 1]\\n                    dp[i][j] = max(L, R)         # \\uD83C\\uDFAF accumulate maximum points for zero-sum game\\n        return 0 <= dp[0][N - 1]                 # \\uD83C\\uDFAE player 1 win?\\n```\\n\\n---\\n\\n**Rust Solutions:**\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\n// TODO: how to capture outer scope within a recursive closure?\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nuse std::cmp::max;\\nimpl Solution {\\n    pub fn predict_the_winner(A: Vec<i32>) -> bool {\\n        let N = A.len();\\n        if N == 1 {                            // \\u2B50\\uFE0F corner case, since N is unsigned, we cannot start at i = N - 2 when N == 1\\n            return true;\\n        }\\n        let mut dp = vec![vec![-1; N]; N];     // \\uD83D\\uDE42 memo\\n        for i in 0..N { dp[i][i] = A[i]; }     // \\uD83D\\uDED1 base case: i == j\\n        for i in (0..N - 1).rev() {\\n            for j in i + 1..N {\\n                let L = A[i] - dp[i + 1][j];\\n                let R = A[j] - dp[i][j - 1];\\n                dp[i][j] = max(L, R);          // \\uD83C\\uDFAF accumulate maximum points for zero-sum game\\n            }\\n        }\\n        0 <= dp[0][N - 1]                      // \\uD83C\\uDFAE player 1 win?\\n    }\\n}\\n```\\n\\n---\\n\\n**C++ Solutions:**\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using fun = function<int(int, int)>;\\n    bool predictTheWinner(VI& A) {\\n        int N = A.size();\\n        fun go = [&](auto i, auto j) {\\n            if (i == j)                      // \\uD83D\\uDED1 base case\\n                return A[i];\\n            auto L = A[i] - go(i + 1, j),\\n                 R = A[j] - go(i, j - 1);\\n            return max(L, R);                // \\uD83C\\uDFAF accumulate maximum points for zero-sum game\\n        };\\n        return 0 <= go(0, N - 1);            // \\uD83C\\uDFAE player 1 win?\\n    }\\n};\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    using fun = function<int(int, int)>;\\n    bool predictTheWinner(VI& A) {\\n        int N = A.size();\\n        VVI m(N, VI(N, -1));                        // \\uD83E\\uDD14 memo    \\n        fun go = [&](auto i, auto j) {\\n            if (i == j)                             // \\uD83D\\uDED1 base case\\n                return m[i][j] = A[i];\\n            if (m[i][j] == -1) {\\n                auto L = A[i] - go(i + 1, j),\\n                     R = A[j] - go(i, j - 1);\\n                m[i][j] = max(L, R);                // \\uD83C\\uDFAF accumulate maximum points for zero-sum game\\n            }\\n            return m[i][j];\\n        };\\n        return 0 <= go(0, N - 1);                   // \\uD83C\\uDFAE player 1 win?\\n    }\\n};\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    bool PredictTheWinner(VI& A) {\\n        int N = A.size();\\n        VVI dp(N, VI(N, -1));                        // \\uD83E\\uDD14 memo\\n        for (auto i{ 0 }; i < N; ++i)\\n            dp[i][i] = A[i];                         // \\uD83D\\uDED1 base case when i == j\\n        for (auto i{ N - 2 }; 0 <= i; --i) {\\n            for (auto j{ i + 1 }; j < N; ++j) {\\n                auto L = A[i] - dp[i + 1][j],\\n                     R = A[j] - dp[i][j - 1];\\n                dp[i][j] = max(L, R);                // \\uD83C\\uDFAF accumulate maximum points for zero-sum game\\n            }\\n        }\\n        return 0 <= dp[0][N - 1];                    // \\uD83C\\uDFAE player 1 win?\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun predictTheWinner(A: IntArray): Boolean {\\n        var N = A.size\\n        fun go(i: Int = 0, j: Int = N - 1): Int {\\n            if (i == j)                       // \\uD83D\\uDED1 base case\\n                return A[i]\\n            var L = A[i] - go(i + 1, j)\\n            var R = A[j] - go(i, j - 1)\\n            return Math.max(L, R)             // \\uD83C\\uDFAF accumulate maximum points for zero-sum game\\n        }\\n        return 0 <= go()                      // \\uD83C\\uDFAE player 1 win?\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun predictTheWinner(A: IntArray): Boolean {\\n        var N = A.size\\n        var (m, key) = Pair(mutableMapOf<String, Int>(), { i: Int, j: Int -> \"$i,$j\" })\\n        fun go(i: Int = 0, j: Int = N - 1): Int {\\n            if (i == j)                          // \\uD83D\\uDED1 base case\\n                return A[i]\\n            var k = key(i, j)\\n            if (!m.contains(k)) {                 // \\uD83E\\uDD14 memo\\n                var L = A[i] - go(i + 1, j)\\n                var R = A[j] - go(i, j - 1)\\n                m[k] = Math.max(L, R)             // \\uD83C\\uDFAF accumulate maximum points for zero-sum game\\n            }\\n            return m[k]!!\\n        }\\n        return 0 <= go()                          // \\uD83C\\uDFAE player 1 win?\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun predictTheWinner(A: IntArray): Boolean {\\n        var N = A.size\\n        var dp = Array(N){ IntArray(N){ -1 } }    // \\uD83E\\uDD14 memo\\n        for (i in 0 until N)\\n            dp[i][i] = A[i]                       // \\uD83D\\uDED1 base case: i == j\\n        for (i in N - 2 downTo 0) {\\n            for (j in i + 1 until N) {\\n                var L = A[i] - dp[i + 1][j]\\n                var R = A[j] - dp[i][j - 1]\\n                dp[i][j] = Math.max(L, R)         // \\uD83C\\uDFAF accumulate maximum points for zero-sum game\\n            }\\n        }\\n        return 0 <= dp[0][N - 1]                  // \\uD83C\\uDFAE player 1 win?\\n    }\\n}\\n```\n```\\nlet predictTheWinner = (A, N = A.length) => {\\n    let go = (i = 0, j = N - 1) => {\\n        if (i == j)                        // \\uD83D\\uDED1 base case\\n            return A[i];\\n        let L = A[i] - go(i + 1, j),\\n            R = A[j] - go(i, j - 1);\\n        return Math.max(L, R);             // \\uD83C\\uDFAF accumulate maximum points for zero-sum game\\n    };\\n    return 0 <= go();                      // \\uD83C\\uDFAE player 1 win?\\n};\\n```\n```\\nlet predictTheWinner = (A, N = A.length, m = new Map(), key = (i, j) => `${i},${j}`) => {\\n    let go = (i = 0, j = N - 1) => {\\n        if (i == j)                           // \\uD83D\\uDED1 base case\\n            return A[i];\\n        let k = key(i, j);\\n        if (!m.has(k)) {                      // \\uD83E\\uDD14 memo\\n            let L = A[i] - go(i + 1, j),\\n                R = A[j] - go(i, j - 1);\\n            m.set(k, Math.max(L, R));         // \\uD83C\\uDFAF accumulate maximum points for zero-sum game\\n        }\\n        return m.get(k);\\n    };\\n    return 0 <= go();                         // \\uD83C\\uDFAE player 1 win?\\n};\\n```\n```\\nlet predictTheWinner = (A, N = A.length, dp = [...Array(N)].map(_ => Array(N).fill(-1))) => {  // \\uD83E\\uDD14 memo\\n    for (let i = 0; i < N; ++i)\\n        dp[i][i] = A[i];                       // \\uD83D\\uDED1 base case: i == j\\n    for (let i = N - 2; 0 <= i; --i) {\\n        for (let j = i + 1; j < N; ++j) {\\n            let L = A[i] - dp[i + 1][j],\\n                R = A[j] - dp[i][j - 1];\\n            dp[i][j] = Math.max(L, R);         // \\uD83C\\uDFAF accumulate maximum points for zero-sum game\\n        }\\n    }\\n    return 0 <= dp[0][N - 1];                  // \\uD83C\\uDFAE player 1 win?\\n};\\n```\n```\\nclass Solution:\\n    def predictTheWinner(self, A: List[int]) -> bool:\\n        N = len(A)\\n        def go(i = 0, j = N - 1):\\n            if i == j:                   # \\uD83D\\uDED1 base case\\n                return A[i]\\n            L = A[i] - go(i + 1, j)\\n            R = A[j] - go(i, j - 1)\\n            return max(L, R)             # \\uD83C\\uDFAF accumulate maximum points for zero-sum game\\n        return 0 <= go()                 # \\uD83C\\uDFAE player 1 win?\\n```\n```\\nclass Solution:\\n    def predictTheWinner(self, A: List[int]) -> bool:\\n        N = len(A)\\n        @cache                           # \\uD83E\\uDD14 memo\\n        def go(i = 0, j = N - 1):\\n            if i == j:                   # \\uD83D\\uDED1 base case\\n                return A[i]\\n            L = A[i] - go(i + 1, j)\\n            R = A[j] - go(i, j - 1)\\n            return max(L, R)             # \\uD83C\\uDFAF accumulate maximum points for zero-sum game\\n        return 0 <= go()                 # \\uD83C\\uDFAE player 1 win?\\n```\n```\\nclass Solution:\\n    def predictTheWinner(self, A: List[int]) -> bool:\\n        N = len(A)\\n        dp = [[0] * N for _ in range(N)]         # \\uD83E\\uDD14 memo\\n        for i in range(N):\\n            dp[i][i] = A[i]                      # \\uD83D\\uDED1 base case when i == j\\n        for i in reversed(range(N)):\\n            for j in range(i + 1, N):\\n                if i + 1 < N and 0 <= j - 1:\\n                    L = A[i] - dp[i + 1][j]\\n                    R = A[j] - dp[i][j - 1]\\n                    dp[i][j] = max(L, R)         # \\uD83C\\uDFAF accumulate maximum points for zero-sum game\\n        return 0 <= dp[0][N - 1]                 # \\uD83C\\uDFAE player 1 win?\\n```\n```\\n// TODO: how to capture outer scope within a recursive closure?\\n```\n```\\nuse std::cmp::max;\\nimpl Solution {\\n    pub fn predict_the_winner(A: Vec<i32>) -> bool {\\n        let N = A.len();\\n        if N == 1 {                            // \\u2B50\\uFE0F corner case, since N is unsigned, we cannot start at i = N - 2 when N == 1\\n            return true;\\n        }\\n        let mut dp = vec![vec![-1; N]; N];     // \\uD83D\\uDE42 memo\\n        for i in 0..N { dp[i][i] = A[i]; }     // \\uD83D\\uDED1 base case: i == j\\n        for i in (0..N - 1).rev() {\\n            for j in i + 1..N {\\n                let L = A[i] - dp[i + 1][j];\\n                let R = A[j] - dp[i][j - 1];\\n                dp[i][j] = max(L, R);          // \\uD83C\\uDFAF accumulate maximum points for zero-sum game\\n            }\\n        }\\n        0 <= dp[0][N - 1]                      // \\uD83C\\uDFAE player 1 win?\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using fun = function<int(int, int)>;\\n    bool predictTheWinner(VI& A) {\\n        int N = A.size();\\n        fun go = [&](auto i, auto j) {\\n            if (i == j)                      // \\uD83D\\uDED1 base case\\n                return A[i];\\n            auto L = A[i] - go(i + 1, j),\\n                 R = A[j] - go(i, j - 1);\\n            return max(L, R);                // \\uD83C\\uDFAF accumulate maximum points for zero-sum game\\n        };\\n        return 0 <= go(0, N - 1);            // \\uD83C\\uDFAE player 1 win?\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    using fun = function<int(int, int)>;\\n    bool predictTheWinner(VI& A) {\\n        int N = A.size();\\n        VVI m(N, VI(N, -1));                        // \\uD83E\\uDD14 memo    \\n        fun go = [&](auto i, auto j) {\\n            if (i == j)                             // \\uD83D\\uDED1 base case\\n                return m[i][j] = A[i];\\n            if (m[i][j] == -1) {\\n                auto L = A[i] - go(i + 1, j),\\n                     R = A[j] - go(i, j - 1);\\n                m[i][j] = max(L, R);                // \\uD83C\\uDFAF accumulate maximum points for zero-sum game\\n            }\\n            return m[i][j];\\n        };\\n        return 0 <= go(0, N - 1);                   // \\uD83C\\uDFAE player 1 win?\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    bool PredictTheWinner(VI& A) {\\n        int N = A.size();\\n        VVI dp(N, VI(N, -1));                        // \\uD83E\\uDD14 memo\\n        for (auto i{ 0 }; i < N; ++i)\\n            dp[i][i] = A[i];                         // \\uD83D\\uDED1 base case when i == j\\n        for (auto i{ N - 2 }; 0 <= i; --i) {\\n            for (auto j{ i + 1 }; j < N; ++j) {\\n                auto L = A[i] - dp[i + 1][j],\\n                     R = A[j] - dp[i][j - 1];\\n                dp[i][j] = max(L, R);                // \\uD83C\\uDFAF accumulate maximum points for zero-sum game\\n            }\\n        }\\n        return 0 <= dp[0][N - 1];                    // \\uD83C\\uDFAE player 1 win?\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3828356,
                "title": "python-elegant-short-top-down-dp",
                "content": "# Complexity\\n- Time complexity: $$O(n^{2})$$\\n- Space complexity: $$O(n^{2})$$\\n\\n# Code\\n```\\nclass Solution:\\n    def PredictTheWinner(self, nums: List[int]) -> bool:\\n        @cache\\n        def winner(i: int, j: int) -> int:\\n            if i == j:\\n                return nums[i]\\n            return max(\\n                nums[i] - winner(i + 1, j),\\n                nums[j] - winner(i, j - 1),\\n            )\\n\\n        return winner(0, len(nums) - 1) >= 0\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def PredictTheWinner(self, nums: List[int]) -> bool:\\n        @cache\\n        def winner(i: int, j: int) -> int:\\n            if i == j:\\n                return nums[i]\\n            return max(\\n                nums[i] - winner(i + 1, j),\\n                nums[j] - winner(i, j - 1),\\n            )\\n\\n        return winner(0, len(nums) - 1) >= 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3827661,
                "title": "dp-100-faster-proper-intuition",
                "content": "# Intuition \\uD83D\\uDE80\\n     100 % faster \\n![Screenshot 2023-07-28 131949.png](https://assets.leetcode.com/users/images/cc232b36-8325-4bdf-b327-0a802ba5a02e_1690530690.7259433.png)\\n\\n   **Optimal game strategy :**\\nwhen player 1 turn come , player 1 will be choose maximum value from given array(do his best) but he aspect minimum from opposition (player 2) side.\\nbecause player 2 is also try to get maximum(both players are playing optimally).\\n\\n\\n\\n# Approach\\n  **player 2 score will be total array sum - player 1 score .**\\n    if **player 1 score >= player 2 score** , we will return**true** otherwise we will return ***false***\\n\\n  note : we have taken nums[0] = i and nums[n-1] = j.\\n\\n\\n***You can follow this video for proper explanation:***\\n\\n[https://youtu.be/ak3DkeUBo-c]()\\n\\n **Kindly upvote me if you find helpful**\\uD83C\\uDFC6\\uD83C\\uDFC6\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int n;\\n    int t[23][23];\\n    int solve(vector<int>& nums, int l, int r) {\\n        \\n        if(l > r)\\n            return 0;\\n        \\n        if(l == r)\\n            return nums[l];\\n        \\n        if(t[l][r] != -1)\\n            return t[l][r];\\n        \\n        int take_left  = nums[l] + min(solve(nums, l+2, r), solve(nums, l+1, r-1));\\n        \\n        int take_right = nums[r] + min(solve(nums, l, r-2), solve(nums, l+1, r-1));\\n        \\n        \\n        return t[l][r] = max(take_left, take_right);\\n        \\n    }\\n    \\n    bool PredictTheWinner(vector<int>& nums) {\\n        \\n        memset(t, -1, sizeof(t));\\n        \\n        n = nums.size();\\n        \\n        \\n        int total = accumulate(begin(nums), end(nums), 0);\\n        \\n        int player1 = solve(nums, 0, n-1);\\n        int player2 = total - player1;\\n        \\n        return player1 >= player2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n;\\n    int t[23][23];\\n    int solve(vector<int>& nums, int l, int r) {\\n        \\n        if(l > r)\\n            return 0;\\n        \\n        if(l == r)\\n            return nums[l];\\n        \\n        if(t[l][r] != -1)\\n            return t[l][r];\\n        \\n        int take_left  = nums[l] + min(solve(nums, l+2, r), solve(nums, l+1, r-1));\\n        \\n        int take_right = nums[r] + min(solve(nums, l, r-2), solve(nums, l+1, r-1));\\n        \\n        \\n        return t[l][r] = max(take_left, take_right);\\n        \\n    }\\n    \\n    bool PredictTheWinner(vector<int>& nums) {\\n        \\n        memset(t, -1, sizeof(t));\\n        \\n        n = nums.size();\\n        \\n        \\n        int total = accumulate(begin(nums), end(nums), 0);\\n        \\n        int player1 = solve(nums, 0, n-1);\\n        int player2 = total - player1;\\n        \\n        return player1 >= player2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3827285,
                "title": "100-faster-c-java-javascript-python-c",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe problem at hand is known as the \"Predict the Winner\" problem. The task is to determine whether the first player, who plays optimally, can win or achieve a tie against the second player when both players take turns picking elements from a given array of integers. Each player\\'s score is the sum of the numbers they have picked, and the player with the higher score at the end of the game wins.\\n\\nTo solve this problem, the code uses dynamic programming with memoization. The idea is to break down the main problem into smaller subproblems and store their solutions in a 2D array (dp). The dp array is used to keep track of the maximum score difference between player 1 and player 2 for all possible subarrays of the input array nums.\\n\\nThe recursive function Solve is designed to find the maximum score difference between player 1 and player 2 for a given subarray nums[F..L], where F is the starting index and L is the ending index of the subarray.\\n# Complexity\\n- Time complexity:$$O(2^n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n### C++\\n```\\nclass Solution {\\npublic:\\n    int dp[23][23];\\n    int Solve(vector<int>&nums,int F,int L){\\n        if(F>L) return 0;\\n        if(F==L) return nums[F];\\n        if(dp[F][L]!=-1)return dp[F][L];\\n        int F_score=nums[F]-Solve(nums,F+1,L);\\n        int L_score=nums[L]-Solve(nums,F,L-1);\\n        return dp[F][L]=max(F_score,L_score);\\n    }\\n    bool PredictTheWinner(vector<int>& nums) {\\n        int n=nums.size()-1;\\n        memset(dp,-1,sizeof(dp));\\n        return Solve(nums,0,n)>=0;\\n    }\\n};\\n```\\n### Javascript\\n```\\nlet dp = Array.from({ length: 23 }, () => Array(23).fill(-1));\\n\\nfunction solve(nums, F, L) {\\n        if (F > L) return 0;\\n        if (F === L) return nums[F];\\n        if (dp[F][L] !== -1) return dp[F][L];\\n\\n        const F_score = nums[F] - solve(nums, F + 1, L);\\n        const L_score = nums[L] - solve(nums, F, L - 1);\\n        return dp[F][L] = Math.max(F_score, L_score);\\n}\\n\\nvar PredictTheWinner = function(nums) {\\n        const n = nums.length - 1;\\n        return solve(nums, 0, n) >= 0;\\n}\\n\\n```\\n### C\\n```\\n#define MAX_SIZE 23\\n\\nint dp[MAX_SIZE][MAX_SIZE];\\n\\nint solve(int nums[], int F, int L) {\\n    if (F > L) return 0;\\n    if (F == L) return nums[F];\\n    if (dp[F][L] != -1) return dp[F][L];\\n\\n    int F_score = nums[F] - solve(nums, F + 1, L);\\n    int L_score = nums[L] - solve(nums, F, L - 1);\\n    dp[F][L] = (F_score > L_score) ? F_score : L_score;\\n    return dp[F][L];\\n}\\n\\nbool PredictTheWinner(int nums[], int size) {\\n    memset(dp, -1, sizeof(dp));\\n    return solve(nums, 0, size - 1) >= 0;\\n}\\n```\\n### Java\\n```\\n\\nclass Solution {\\n    private int[][] dp = new int[23][23];\\n\\n    public int solve(int[] nums, int F, int L) {\\n        if (F > L) return 0;\\n        if (F == L) return nums[F];\\n        if (dp[F][L] != -1) return dp[F][L];\\n\\n        int F_score = nums[F] - solve(nums, F + 1, L);\\n        int L_score = nums[L] - solve(nums, F, L - 1);\\n        dp[F][L] = Math.max(F_score, L_score);\\n        return dp[F][L];\\n    }\\n\\n    public boolean PredictTheWinner(int[] nums) {\\n        int n = nums.length - 1;\\n        for (int[] row : dp)\\n            Arrays.fill(row, -1);\\n\\n        return solve(nums, 0, n) >= 0;\\n    }\\n}\\n\\n```\\n### Python\\n```\\nclass Solution:\\n    def __init__(self):\\n        self.dp = [[-1] * 23 for _ in range(23)]\\n\\n    def solve(self, nums, F, L):\\n        if F > L:\\n            return 0\\n        if F == L:\\n            return nums[F]\\n        if self.dp[F][L] != -1:\\n            return self.dp[F][L]\\n\\n        F_score = nums[F] - self.solve(nums, F + 1, L)\\n        L_score = nums[L] - self.solve(nums, F, L - 1)\\n        self.dp[F][L] = max(F_score, L_score)\\n        return self.dp[F][L]\\n\\n    def PredictTheWinner(self, nums:List[int])-> bool:\\n        n = len(nums) - 1\\n        return self.solve(nums, 0, n) >= 0\\n```\\n## Steps\\n- ***int dp[23][23] :*** This is a 2D array called dp, with a size of 23x23. It will be used for dynamic programming to store the results of subproblems, where dp[i][j] will represent the maximum score difference between player 1 and player 2 when playing with the subarray nums[i..j].\\n- ***int Solve(vector<int>& nums, int F, int L) { ... } :*** This is a recursive helper function named Solve. It takes a reference to a vector nums, an integer F representing the starting index, and an integer L representing the ending index of the current subarray being considered.\\n- ***if (F > L) return 0*** : This is the base case when the starting index F is greater than the ending index L. In this case, there are no elements in the subarray, so the score difference is 0.\\n- ***if (F == L) return nums[F] :*** This is the base case when the starting index F is equal to the ending index L. In this case, there is only one element in the subarray, so the score difference is the element itself.\\n- ***if (dp[F][L] != -1) return dp[F][L] :*** This is a memoization check. If the result for the subarray nums[F..L] has already been calculated and stored in dp, it directly returns that result to avoid redundant calculations.\\n- ***int F_score = nums[F] - Solve(nums, F + 1, L) :*** This calculates the score difference if the first player chooses the element at index F. It subtracts the result of Solve(nums, F + 1, L), which represents the maximum score difference when the second player plays optimally.\\n- ***int L_score = nums[L] - Solve(nums, F, L - 1) :*** This calculates the score difference if the first player chooses the element at index L. It subtracts the result of Solve(nums, F, L - 1), which represents the maximum score difference when the second player plays optimally.\\n- ***return dp[F][L] = max(F_score, L_score) :*** This line calculates the maximum score difference between the two choices (choosing F or choosing L) and stores it in the dp array for future reference. It then returns this value as the result for the current subproblem.\\n- ***bool PredictTheWinner(vector<int>& nums) { ... } :*** This is the main function that will be called from outside. It takes a reference to a vector nums\\n- ***int n = nums.size() - 1 :*** This initializes the variable n with the size of the input vector nums minus 1, representing the last index of the vector.\\n- ***memset(dp, -1, sizeof(dp)) :*** This initializes the entire dp array with -1. This is a common technique to indicate that no subproblem has been solved yet.\\n- ***return Solve(nums, 0, n) >= 0 :*** This calls the Solve function with the entire input vector nums, starting from index 0 (F) and ending at index n (L). It returns true if the maximum score difference between the two players is greater than or equal to 0, which means the first player can win or achieve a tie; otherwise, it returns false, indicating that the second player wins.",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[23][23];\\n    int Solve(vector<int>&nums,int F,int L){\\n        if(F>L) return 0;\\n        if(F==L) return nums[F];\\n        if(dp[F][L]!=-1)return dp[F][L];\\n        int F_score=nums[F]-Solve(nums,F+1,L);\\n        int L_score=nums[L]-Solve(nums,F,L-1);\\n        return dp[F][L]=max(F_score,L_score);\\n    }\\n    bool PredictTheWinner(vector<int>& nums) {\\n        int n=nums.size()-1;\\n        memset(dp,-1,sizeof(dp));\\n        return Solve(nums,0,n)>=0;\\n    }\\n};\\n```\n```\\nlet dp = Array.from({ length: 23 }, () => Array(23).fill(-1));\\n\\nfunction solve(nums, F, L) {\\n        if (F > L) return 0;\\n        if (F === L) return nums[F];\\n        if (dp[F][L] !== -1) return dp[F][L];\\n\\n        const F_score = nums[F] - solve(nums, F + 1, L);\\n        const L_score = nums[L] - solve(nums, F, L - 1);\\n        return dp[F][L] = Math.max(F_score, L_score);\\n}\\n\\nvar PredictTheWinner = function(nums) {\\n        const n = nums.length - 1;\\n        return solve(nums, 0, n) >= 0;\\n}\\n\\n```\n```\\n#define MAX_SIZE 23\\n\\nint dp[MAX_SIZE][MAX_SIZE];\\n\\nint solve(int nums[], int F, int L) {\\n    if (F > L) return 0;\\n    if (F == L) return nums[F];\\n    if (dp[F][L] != -1) return dp[F][L];\\n\\n    int F_score = nums[F] - solve(nums, F + 1, L);\\n    int L_score = nums[L] - solve(nums, F, L - 1);\\n    dp[F][L] = (F_score > L_score) ? F_score : L_score;\\n    return dp[F][L];\\n}\\n\\nbool PredictTheWinner(int nums[], int size) {\\n    memset(dp, -1, sizeof(dp));\\n    return solve(nums, 0, size - 1) >= 0;\\n}\\n```\n```\\n\\nclass Solution {\\n    private int[][] dp = new int[23][23];\\n\\n    public int solve(int[] nums, int F, int L) {\\n        if (F > L) return 0;\\n        if (F == L) return nums[F];\\n        if (dp[F][L] != -1) return dp[F][L];\\n\\n        int F_score = nums[F] - solve(nums, F + 1, L);\\n        int L_score = nums[L] - solve(nums, F, L - 1);\\n        dp[F][L] = Math.max(F_score, L_score);\\n        return dp[F][L];\\n    }\\n\\n    public boolean PredictTheWinner(int[] nums) {\\n        int n = nums.length - 1;\\n        for (int[] row : dp)\\n            Arrays.fill(row, -1);\\n\\n        return solve(nums, 0, n) >= 0;\\n    }\\n}\\n\\n```\n```\\nclass Solution:\\n    def __init__(self):\\n        self.dp = [[-1] * 23 for _ in range(23)]\\n\\n    def solve(self, nums, F, L):\\n        if F > L:\\n            return 0\\n        if F == L:\\n            return nums[F]\\n        if self.dp[F][L] != -1:\\n            return self.dp[F][L]\\n\\n        F_score = nums[F] - self.solve(nums, F + 1, L)\\n        L_score = nums[L] - self.solve(nums, F, L - 1)\\n        self.dp[F][L] = max(F_score, L_score)\\n        return self.dp[F][L]\\n\\n    def PredictTheWinner(self, nums:List[int])-> bool:\\n        n = len(nums) - 1\\n        return self.solve(nums, 0, n) >= 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3826913,
                "title": "easy-dp-solution-simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int get_winner(vector<int>& nums, int start, int end, bool turn, vector<vector<int>>& memo) {\\n        if (start > end) return 0;\\n\\n        if (memo[start][end] != -1) {\\n            return memo[start][end];\\n        }\\n\\n        int player1 = 0, player2 = 0;\\n\\n        if (turn)\\n            player1 = max(nums[start] + get_winner(nums, start + 1, end, false, memo),\\n                          nums[end] + get_winner(nums, start, end - 1, false, memo));\\n        else\\n            player2 = min(get_winner(nums, start + 1, end, true, memo),\\n                          get_winner(nums, start, end - 1, true, memo));\\n\\n        return memo[start][end] = player1 + player2;\\n    }\\n\\n    bool PredictTheWinner(vector<int>& nums) {\\n        int n = nums.size();\\n        long long sum = 0;\\n        for (auto i : nums) sum += i;\\n\\n        vector<vector<int>> memo(n, vector<int>(n, -1));\\n\\n        long long ans = get_winner(nums, 0, n - 1, true, memo);\\n        if (sum - ans <= ans) return true;\\n\\n        return false;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int get_winner(vector<int>& nums, int start, int end, bool turn, vector<vector<int>>& memo) {\\n        if (start > end) return 0;\\n\\n        if (memo[start][end] != -1) {\\n            return memo[start][end];\\n        }\\n\\n        int player1 = 0, player2 = 0;\\n\\n        if (turn)\\n            player1 = max(nums[start] + get_winner(nums, start + 1, end, false, memo),\\n                          nums[end] + get_winner(nums, start, end - 1, false, memo));\\n        else\\n            player2 = min(get_winner(nums, start + 1, end, true, memo),\\n                          get_winner(nums, start, end - 1, true, memo));\\n\\n        return memo[start][end] = player1 + player2;\\n    }\\n\\n    bool PredictTheWinner(vector<int>& nums) {\\n        int n = nums.size();\\n        long long sum = 0;\\n        for (auto i : nums) sum += i;\\n\\n        vector<vector<int>> memo(n, vector<int>(n, -1));\\n\\n        long long ans = get_winner(nums, 0, n - 1, true, memo);\\n        if (sum - ans <= ans) return true;\\n\\n        return false;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3826642,
                "title": "python-medium-problem-486-predict-the-winner",
                "content": "# Python | Medium Problem | 486. Predict the Winner\\n```\\nclass Solution:\\n    def PredictTheWinner(self, nums: List[int]) -> bool:\\n        def calc(i, j, check):\\n            if i > j:\\n                return 0\\n            best = 0\\n            if check:\\n                best = calc(i + 1, j, False) + nums[i]\\n                best = max(best, calc(i, j - 1, False)+ nums[j]) \\n            else:\\n                best = calc(i + 1, j, True) - nums[i]\\n                best = min(best, calc(i, j - 1, True)- nums[j]) \\n            return best\\n        return calc(0, len(nums) - 1, True) >= 0\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def PredictTheWinner(self, nums: List[int]) -> bool:\\n        def calc(i, j, check):\\n            if i > j:\\n                return 0\\n            best = 0\\n            if check:\\n                best = calc(i + 1, j, False) + nums[i]\\n                best = max(best, calc(i, j - 1, False)+ nums[j]) \\n            else:\\n                best = calc(i + 1, j, True) - nums[i]\\n                best = min(best, calc(i, j - 1, True)- nums[j]) \\n            return best\\n        return calc(0, len(nums) - 1, True) >= 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3826534,
                "title": "c-solution-for-predict-the-winner-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem requires us to find out if Player 1 can win the game, assuming both players play optimally. To do this, we need to determine the maximum score difference that Player 1 can achieve over Player 2. We can use dynamic programming to calculate the optimal scores for different subarrays, starting from smaller subarrays and building up to the entire array.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach used in the solution is dynamic programming. We create a 2D array dp where dp[i, j] represents the maximum score difference between Player 1 and Player 2 for the subarray nums[i..j]. We initialize the diagonal elements of the dp array with the values from the original array, as each player can choose one number from a subarray of length 1. Then, we calculate the maximum score difference for different subarray lengths, starting from subarrays of length 2 up to the entire array.\\n\\nThe maximum score difference for subarray nums[i..j] can be calculated by considering two options: either Player 1 chooses nums[i], and the remaining subarray will be nums[i+1..j], or Player 1 chooses nums[j], and the remaining subarray will be nums[i..j-1]. We choose the maximum of these two options as the optimal score difference for the current subarray.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the solution is O(n^2), where n is the length of the input array nums. This is because we use a nested loop to fill up the dp array, and for each subarray of length len, we calculate the maximum score difference in constant time. So the overall time complexity is proportional to the number of subarrays we need to calculate, which is roughly O(n^2).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the solution is O(n^2) as well. This is because we use a 2D array dp of size n x n to store the maximum score difference for different subarrays. In the worst case, we need to store the result for all possible subarrays of the input array nums, which requires O(n^2) space.\\n\\n# Code\\n```\\npublic class Solution {\\n    public bool PredictTheWinner(int[] nums) {\\n        int n = nums.Length;\\n        // dp[i, j] represents the maximum score difference between Player 1 and Player 2 for subarray nums[i..j]\\n        int[,] dp = new int[n, n];\\n        \\n        // Initialize the diagonal elements with the array values, as each player can choose one number\\n        for (int i = 0; i < n; i++) {\\n            dp[i, i] = nums[i];\\n        }\\n        \\n        // Calculate the score differences for different subarray lengths\\n        for (int len = 1; len < n; len++) {\\n            for (int i = 0; i < n - len; i++) {\\n                int j = i + len;\\n                // Calculate the maximum score difference if Player 1 chooses nums[i] or nums[j]\\n                dp[i, j] = Math.Max(nums[i] - dp[i + 1, j], nums[j] - dp[i, j - 1]);\\n            }\\n        }\\n        \\n        // The maximum score difference between Player 1 and Player 2 for the entire array (0..n-1) will be stored at dp[0, n-1]\\n        // If dp[0, n-1] is greater than or equal to 0, Player 1 can win the game\\n        return dp[0, n - 1] >= 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public bool PredictTheWinner(int[] nums) {\\n        int n = nums.Length;\\n        // dp[i, j] represents the maximum score difference between Player 1 and Player 2 for subarray nums[i..j]\\n        int[,] dp = new int[n, n];\\n        \\n        // Initialize the diagonal elements with the array values, as each player can choose one number\\n        for (int i = 0; i < n; i++) {\\n            dp[i, i] = nums[i];\\n        }\\n        \\n        // Calculate the score differences for different subarray lengths\\n        for (int len = 1; len < n; len++) {\\n            for (int i = 0; i < n - len; i++) {\\n                int j = i + len;\\n                // Calculate the maximum score difference if Player 1 chooses nums[i] or nums[j]\\n                dp[i, j] = Math.Max(nums[i] - dp[i + 1, j], nums[j] - dp[i, j - 1]);\\n            }\\n        }\\n        \\n        // The maximum score difference between Player 1 and Player 2 for the entire array (0..n-1) will be stored at dp[0, n-1]\\n        // If dp[0, n-1] is greater than or equal to 0, Player 1 can win the game\\n        return dp[0, n - 1] >= 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3826530,
                "title": "c-solution-for-predict-the-winner-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem requires us to find out if Player 1 can win the game, assuming both players play optimally. To do this, we need to determine the maximum score difference that Player 1 can achieve over Player 2. We can use dynamic programming to calculate the optimal scores for different subarrays, starting from smaller subarrays and building up to the entire array.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach used in the solution is dynamic programming. We create a 2D array dp where dp[i, j] represents the maximum score difference between Player 1 and Player 2 for the subarray nums[i..j]. We initialize the diagonal elements of the dp array with the values from the original array, as each player can choose one number from a subarray of length 1. Then, we calculate the maximum score difference for different subarray lengths, starting from subarrays of length 2 up to the entire array.\\n\\nThe maximum score difference for subarray nums[i..j] can be calculated by considering two options: either Player 1 chooses nums[i], and the remaining subarray will be nums[i+1..j], or Player 1 chooses nums[j], and the remaining subarray will be nums[i..j-1]. We choose the maximum of these two options as the optimal score difference for the current subarray.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the solution is O(n^2), where n is the length of the input array nums. This is because we use a nested loop to fill up the dp array, and for each subarray of length len, we calculate the maximum score difference in constant time. So the overall time complexity is proportional to the number of subarrays we need to calculate, which is roughly O(n^2).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the solution is O(n^2) as well. This is because we use a 2D array dp of size n x n to store the maximum score difference for different subarrays. In the worst case, we need to store the result for all possible subarrays of the input array nums, which requires O(n^2) space.\\n\\n# Code\\n```\\npublic class Solution {\\n    public bool PredictTheWinner(int[] nums) {\\n        int n = nums.Length;\\n        // dp[i, j] represents the maximum score difference between Player 1 and Player 2 for subarray nums[i..j]\\n        int[,] dp = new int[n, n];\\n        \\n        // Initialize the diagonal elements with the array values, as each player can choose one number\\n        for (int i = 0; i < n; i++) {\\n            dp[i, i] = nums[i];\\n        }\\n        \\n        // Calculate the score differences for different subarray lengths\\n        for (int len = 1; len < n; len++) {\\n            for (int i = 0; i < n - len; i++) {\\n                int j = i + len;\\n                // Calculate the maximum score difference if Player 1 chooses nums[i] or nums[j]\\n                dp[i, j] = Math.Max(nums[i] - dp[i + 1, j], nums[j] - dp[i, j - 1]);\\n            }\\n        }\\n        \\n        // The maximum score difference between Player 1 and Player 2 for the entire array (0..n-1) will be stored at dp[0, n-1]\\n        // If dp[0, n-1] is greater than or equal to 0, Player 1 can win the game\\n        return dp[0, n - 1] >= 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public bool PredictTheWinner(int[] nums) {\\n        int n = nums.Length;\\n        // dp[i, j] represents the maximum score difference between Player 1 and Player 2 for subarray nums[i..j]\\n        int[,] dp = new int[n, n];\\n        \\n        // Initialize the diagonal elements with the array values, as each player can choose one number\\n        for (int i = 0; i < n; i++) {\\n            dp[i, i] = nums[i];\\n        }\\n        \\n        // Calculate the score differences for different subarray lengths\\n        for (int len = 1; len < n; len++) {\\n            for (int i = 0; i < n - len; i++) {\\n                int j = i + len;\\n                // Calculate the maximum score difference if Player 1 chooses nums[i] or nums[j]\\n                dp[i, j] = Math.Max(nums[i] - dp[i + 1, j], nums[j] - dp[i, j - 1]);\\n            }\\n        }\\n        \\n        // The maximum score difference between Player 1 and Player 2 for the entire array (0..n-1) will be stored at dp[0, n-1]\\n        // If dp[0, n-1] is greater than or equal to 0, Player 1 can win the game\\n        return dp[0, n - 1] >= 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3826270,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def PredictTheWinner(self, nums: List[int]) -> bool:\\n        n=len(nums)\\n        @lru_cache(None)\\n        def dp(i,j):\\n            return 0 if i>j else max(-dp(i+1,j)+nums[i],-dp(i,j-1)+nums[j])\\n\\n        return dp(0,n-1)>=0\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def PredictTheWinner(self, nums: List[int]) -> bool:\\n        n=len(nums)\\n        @lru_cache(None)\\n        def dp(i,j):\\n            return 0 if i>j else max(-dp(i+1,j)+nums[i],-dp(i,j-1)+nums[j])\\n\\n        return dp(0,n-1)>=0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3711150,
                "title": "2d-dp",
                "content": "# Intuition\\n\\u8981\\u641E\\u6E05\\u695A2D DP\\u6570\\u7EC4\\u7684\\u610F\\u4E49\\uFF0Cdp[i][j]\\u8868\\u793A[i, j]\\u533A\\u95F4\\u5148\\u540E\\u624B\\u9009\\u62E9\\u7684\\u6700\\u4F18\\u89E3\\uFF0Cdp\\u6570\\u7EC4\\u7684\\u5185\\u5BB9\\u662FPair\\uFF0Cfirst\\u8868\\u793A\\u5148\\u624B\\uFF0Csecond\\u8868\\u793A\\u540E\\u624B\\u3002\\n\\n\\u8FD9\\u91CC\\u5176\\u5B9E\\u53EAcare\\u4E24\\u4E2A\\u53D8\\u91CFdp[i][j - 1] and dp[i + 1][j]\\uFF0C\\u6240\\u4EE5\\u8FD9\\u91CC\\u8981\\u81EA\\u4E0B\\u800C\\u4E0A\\uFF0C\\u81EA\\u5DE6\\u5411\\u53F3\\u904D\\u5386\\u3002\\n\\n# Code\\n```\\nclass Solution {\\n    fun PredictTheWinner(nums: IntArray): Boolean {\\n        val n = nums.size\\n        val dp = Array(n) { Array<Pair<Int, Int>>(n) { Pair(0, 0) } }\\n\\n        for (i in nums.indices) dp[i][i] = Pair(nums[i], 0)\\n\\n        for (i in n - 2 downTo 0) {\\n            for (j in i + 1 until n) {\\n                val left = nums[i] + dp[i + 1][j].second\\n                val right = nums[j] + dp[i][j - 1].second\\n\\n                if (left > right) {\\n                    dp[i][j] = Pair(left, dp[i + 1][j].first)\\n                } else {\\n                    dp[i][j] = Pair(right, dp[i][j - 1].first)\\n                }\\n            }\\n        }\\n\\n        val (first, second) = dp[0][n - 1]\\n\\n        return first >= second\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun PredictTheWinner(nums: IntArray): Boolean {\\n        val n = nums.size\\n        val dp = Array(n) { Array<Pair<Int, Int>>(n) { Pair(0, 0) } }\\n\\n        for (i in nums.indices) dp[i][i] = Pair(nums[i], 0)\\n\\n        for (i in n - 2 downTo 0) {\\n            for (j in i + 1 until n) {\\n                val left = nums[i] + dp[i + 1][j].second\\n                val right = nums[j] + dp[i][j - 1].second\\n\\n                if (left > right) {\\n                    dp[i][j] = Pair(left, dp[i + 1][j].first)\\n                } else {\\n                    dp[i][j] = Pair(right, dp[i][j - 1].first)\\n                }\\n            }\\n        }\\n\\n        val (first, second) = dp[0][n - 1]\\n\\n        return first >= second\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3635600,
                "title": "begineers-friendly-c-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& nums, int i, int j){\\n        if(i > j)\\n        return 0;\\n        \\n        if(i == j)\\n        return nums[j];\\n\\n        int p1 = nums[i] + min(solve(nums, i+2, j), solve(nums, i+1, j-1));\\n        int p2 = nums[j] + min(solve(nums, i+1, j-1), solve(nums, i, j-2));\\n\\n        return max(p1, p2);\\n    }\\n    bool PredictTheWinner(vector<int>& nums) {\\n        int i = 0;\\n        int temp = 0;\\n        int j = nums.size()-1;\\n\\n        for(auto it:nums){\\n            temp += it;\\n        }\\n\\n        int p1 = solve(nums, i, j);\\n        int p2 = temp-p1;\\n\\n        return p1 >= p2;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& nums, int i, int j){\\n        if(i > j)\\n        return 0;\\n        \\n        if(i == j)\\n        return nums[j];\\n\\n        int p1 = nums[i] + min(solve(nums, i+2, j), solve(nums, i+1, j-1));\\n        int p2 = nums[j] + min(solve(nums, i+1, j-1), solve(nums, i, j-2));\\n\\n        return max(p1, p2);\\n    }\\n    bool PredictTheWinner(vector<int>& nums) {\\n        int i = 0;\\n        int temp = 0;\\n        int j = nums.size()-1;\\n\\n        for(auto it:nums){\\n            temp += it;\\n        }\\n\\n        int p1 = solve(nums, i, j);\\n        int p2 = temp-p1;\\n\\n        return p1 >= p2;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3581069,
                "title": "visualised-code-based-on-recursion-and-memoization-do-upvote-guysss",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nintuition is based on what we have learned as a kid i.e. -(-)= +\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwe make two variables i and j pointing on either end of the array. We got two choices either pick i or pick j. In my solution I basically calculated the difference of total points of player1 and player2. See what I did lets say we have \\n[1,5,233,7]\\ni=0,j=3\\nnow in temp either we have max(1-solve(nums,1,3), 7-solve(nums,0,2))\\nlet me make u visualise what is happening\\n\\nfor optimal case its\\n1-()\\n1-(7-())\\n1-(7-(233-()))\\n1-(7-(233-(5)))\\nnow see the intuition I have written here\\n1-7+(233-5)\\n1-7+233-5\\n1+233 - (7+5)\\nthis addition part is player one total score and subtract one is player 2 final score. we see if the difference between them is +ve player 1 wins\\n\\nJust write down the above explanation on your own u will see that...Question is somewhat similar to stone game 3 problem\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[21][21];\\n    int solve(vector<int>& nums, int i, int j)\\n    {\\n        if(i>j)\\n        return 0;\\n        if(dp[i][j]!=-1)\\n        return dp[i][j];\\n        \\n        int temp= max(nums[i]- solve(nums,i+1,j) , nums[j]-solve(nums,i,j-1));\\n        //int ans=max(ans,temp);\\n\\n        return dp[i][j]=temp;\\n    }\\n\\n    bool PredictTheWinner(vector<int>& nums) {\\n        memset(dp,-1,sizeof(dp));\\n        int ans= solve(nums,0,nums.size()-1);\\n\\n        if(ans>=0)\\n        return true;\\n        else \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[21][21];\\n    int solve(vector<int>& nums, int i, int j)\\n    {\\n        if(i>j)\\n        return 0;\\n        if(dp[i][j]!=-1)\\n        return dp[i][j];\\n        \\n        int temp= max(nums[i]- solve(nums,i+1,j) , nums[j]-solve(nums,i,j-1));\\n        //int ans=max(ans,temp);\\n\\n        return dp[i][j]=temp;\\n    }\\n\\n    bool PredictTheWinner(vector<int>& nums) {\\n        memset(dp,-1,sizeof(dp));\\n        int ans= solve(nums,0,nums.size()-1);\\n\\n        if(ans>=0)\\n        return true;\\n        else \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3180604,
                "title": "java-dynamic-programming-game-theory",
                "content": "# Code\\n```\\npublic class Solution {\\n    public boolean PredictTheWinner(int[] nums) {\\n        if(nums.length == 1) return true;\\n        int su = 0;\\n        for (int i: nums) su += i;\\n        int res = ans(nums, 0, nums.length - 1);\\n        if (res < (su - res)) return false;\\n        return true;\\n    }\\n    public static int ans(int[] nums, int left, int right) {\\n        if (left > right) return 0;\\n        int choice1 = nums[left] + Math.min(ans(nums, left + 2, right), ans(nums, left + 1, right - 1));\\n        int choice2 = nums[right] + Math.min(ans(nums, left + 1, right - 1), ans(nums, left, right - 2));\\n        return Math.max(choice1, choice2);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic class Solution {\\n    public boolean PredictTheWinner(int[] nums) {\\n        if(nums.length == 1) return true;\\n        int su = 0;\\n        for (int i: nums) su += i;\\n        int res = ans(nums, 0, nums.length - 1);\\n        if (res < (su - res)) return false;\\n        return true;\\n    }\\n    public static int ans(int[] nums, int left, int right) {\\n        if (left > right) return 0;\\n        int choice1 = nums[left] + Math.min(ans(nums, left + 2, right), ans(nums, left + 1, right - 1));\\n        int choice2 = nums[right] + Math.min(ans(nums, left + 1, right - 1), ans(nums, left, right - 2));\\n        return Math.max(choice1, choice2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3151355,
                "title": "easy-beginner-friendly-simple-recursion",
                "content": "\\n```\\nspick-> start element picked\\nepick-> end element picked\\nturn-> signifies which player has to play\\n```\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool solve(vector<int>&nums, int p1,int p2,bool turn,int i,int j){\\n        if(i>j) return p1>=p2;\\n        if(turn){\\n            bool spick=solve(nums,p1+nums[i],p2,0,i+1,j);\\n            bool epick=solve(nums,p1+nums[j],p2,0,i,j-1);\\n            return spick || epick;\\n        }\\n        else{\\n            bool spick=solve(nums,p1,p2+nums[i],1,i+1,j);\\n            bool epick=solve(nums,p1,p2+nums[j],1,i,j-1);\\n            return spick && epick;\\n\\n        }\\n\\n    }\\n    bool PredictTheWinner(vector<int>& nums) {\\n        int p1=0,p2=0;\\n        return solve(nums,p1,p2,1,0,nums.size()-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nspick-> start element picked\\nepick-> end element picked\\nturn-> signifies which player has to play\\n```\n```\\nclass Solution {\\npublic:\\n    bool solve(vector<int>&nums, int p1,int p2,bool turn,int i,int j){\\n        if(i>j) return p1>=p2;\\n        if(turn){\\n            bool spick=solve(nums,p1+nums[i],p2,0,i+1,j);\\n            bool epick=solve(nums,p1+nums[j],p2,0,i,j-1);\\n            return spick || epick;\\n        }\\n        else{\\n            bool spick=solve(nums,p1,p2+nums[i],1,i+1,j);\\n            bool epick=solve(nums,p1,p2+nums[j],1,i,j-1);\\n            return spick && epick;\\n\\n        }\\n\\n    }\\n    bool PredictTheWinner(vector<int>& nums) {\\n        int p1=0,p2=0;\\n        return solve(nums,p1,p2,1,0,nums.size()-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2758826,
                "title": "c-dp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int rec(vector<int> &nums,int i,int j,vector<vector<int>> &dp){\\n        \\n        if(i > j) return 0;\\n        \\n        if(dp[i][j] != -1) return dp[i][j];\\n        \\n        int ans1 = nums[i] + min(rec(nums,i+1,j-1,dp),rec(nums,i+2,j,dp));\\n        \\n        int ans2 = nums[j] + min(rec(nums,i+1,j-1,dp),rec(nums,i,j-2,dp));\\n        \\n        dp[i][j] = max(ans1,ans2);\\n        \\n        return dp[i][j];\\n    }\\n    \\n    \\n    bool PredictTheWinner(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        vector<vector<int>> dp(n,vector<int>(n,-1));\\n        \\n        int ans = rec(nums,0,n-1,dp);\\n        \\n        int sum = 0;\\n        \\n        for(auto i:nums) sum += i;\\n        \\n        return (ans >= sum - ans);\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int rec(vector<int> &nums,int i,int j,vector<vector<int>> &dp){\\n        \\n        if(i > j) return 0;\\n        \\n        if(dp[i][j] != -1) return dp[i][j];\\n        \\n        int ans1 = nums[i] + min(rec(nums,i+1,j-1,dp),rec(nums,i+2,j,dp));\\n        \\n        int ans2 = nums[j] + min(rec(nums,i+1,j-1,dp),rec(nums,i,j-2,dp));\\n        \\n        dp[i][j] = max(ans1,ans2);\\n        \\n        return dp[i][j];\\n    }\\n    \\n    \\n    bool PredictTheWinner(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        vector<vector<int>> dp(n,vector<int>(n,-1));\\n        \\n        int ans = rec(nums,0,n-1,dp);\\n        \\n        int sum = 0;\\n        \\n        for(auto i:nums) sum += i;\\n        \\n        return (ans >= sum - ans);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2344967,
                "title": "c-easy-dp-memorization-easy-to-folllow",
                "content": "Please Upvote :)\\n\\n```\\nclass Solution {\\npublic:\\n    bool PredictTheWinner(vector<int>& nums) {\\n        vector<vector<vector<int>>> dp(nums.size(),vector<vector<int>>(nums.size(),vector<int>(3,INT_MAX)));\\n        int t=fun(dp,nums,0,nums.size()-1,1);\\n        return t>=0;\\n    }\\n    int fun(vector<vector<vector<int>>>& dp,vector<int>& v,int i,int j,int t)\\n    {\\n        if(i>j)\\n            return 0;\\n        \\n        if(dp[i][j][t+1]!=INT_MAX)\\n            return dp[i][j][t+1];\\n        \\n        if(t>0)\\n            return dp[i][j][t+1]=max(v[i]*t+fun(dp,v,i+1,j,-1),v[j]*t+fun(dp,v,i,j-1,-1));\\n        else\\n            return dp[i][j][t+1]=min(v[i]*t+fun(dp,v,i+1,j,1),v[j]*t+fun(dp,v,i,j-1,1));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool PredictTheWinner(vector<int>& nums) {\\n        vector<vector<vector<int>>> dp(nums.size(),vector<vector<int>>(nums.size(),vector<int>(3,INT_MAX)));\\n        int t=fun(dp,nums,0,nums.size()-1,1);\\n        return t>=0;\\n    }\\n    int fun(vector<vector<vector<int>>>& dp,vector<int>& v,int i,int j,int t)\\n    {\\n        if(i>j)\\n            return 0;\\n        \\n        if(dp[i][j][t+1]!=INT_MAX)\\n            return dp[i][j][t+1];\\n        \\n        if(t>0)\\n            return dp[i][j][t+1]=max(v[i]*t+fun(dp,v,i+1,j,-1),v[j]*t+fun(dp,v,i,j-1,-1));\\n        else\\n            return dp[i][j][t+1]=min(v[i]*t+fun(dp,v,i+1,j,1),v[j]*t+fun(dp,v,i,j-1,1));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2333722,
                "title": "java-dp-bottom-up",
                "content": "```\\n    public boolean PredictTheWinner(int[] nums) {\\n        int n = nums.length;\\n        // dp[i][j] represents the maximum score difference player 1 can make using nums[i] to nums[j]\\n        int[][] dp = new int[n][n];\\n        for(int right = 0; right < n; right++){\\n            // single number\\n            dp[right][right] = nums[right];\\n\\t\\t\\t// since we use dp[left + 1][right] to calculate dp[left][right]\\n\\t\\t    // the second loop need to traverse from end to start\\n            for(int left = right - 1; left >= 0; left--){\\n                // select nums[right]\\n                int diff1 = nums[right] - dp[left][right - 1];\\n\\t\\t\\t\\t// select nums[left]\\n                int diff2 = nums[left] - dp[left + 1][right];\\n                dp[left][right] = Math.max(diff1, diff2);\\n            }\\n        }\\n        // dif >= 0\\n        return dp[0][n - 1] >= 0;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\n    public boolean PredictTheWinner(int[] nums) {\\n        int n = nums.length;\\n        // dp[i][j] represents the maximum score difference player 1 can make using nums[i] to nums[j]\\n        int[][] dp = new int[n][n];\\n        for(int right = 0; right < n; right++){\\n            // single number\\n            dp[right][right] = nums[right];\\n\\t\\t\\t// since we use dp[left + 1][right] to calculate dp[left][right]\\n\\t\\t    // the second loop need to traverse from end to start\\n            for(int left = right - 1; left >= 0; left--){\\n                // select nums[right]\\n                int diff1 = nums[right] - dp[left][right - 1];\\n\\t\\t\\t\\t// select nums[left]\\n                int diff2 = nums[left] - dp[left + 1][right];\\n                dp[left][right] = Math.max(diff1, diff2);\\n            }\\n        }\\n        // dif >= 0\\n        return dp[0][n - 1] >= 0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2310607,
                "title": "c-easy-understanding-code-recursion-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[21][21][3];\\n    long long solve(vector<int>&v,int i,int j,bool turn)\\n    {\\n        if(i>j)\\n            return 0;\\n        \\n        if(dp[i][j][turn]!=-1)\\n            return dp[i][j][turn];\\n        \\n        if(turn)\\n        {\\n         return dp[i][j][turn]=max(v[i]+solve(v,i+1,j,!turn),v[j]+solve(v,i,j-1,!turn));\\n        }\\n        else\\n        return dp[i][j][turn]=min(-v[i]+solve(v,i+1,j,!turn),-v[j]+solve(v,i,j-1,!turn));\\n        \\n    }\\n    bool PredictTheWinner(vector<int>& nums) \\n    {\\n        int n=nums.size();\\n        memset(dp,-1,sizeof(dp));\\n        long long sum=solve(nums,0,n-1,true);\\n        \\n        if(sum>=0)                                               //mean first player win \\n            return true;\\n        return false;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n    int dp[21][21][3];\\n    long long solve(vector<int>&v,int i,int j,bool turn)\\n    {\\n        if(i>j)\\n            return 0;\\n        \\n        if(dp[i][j][turn]!=-1)\\n            return dp[i][j][turn];\\n        \\n        if(turn)\\n        {\\n         return dp[i][j][turn]=max(v[i]+solve(v,i+1,j,!turn),v[j]+solve(v,i,j-1,!turn));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2280970,
                "title": "c-memoization-dp-explained",
                "content": "**Code:**\\n\\n```\\nclass Solution\\n{\\npublic:\\n    map<vector<long long>, long long> memo;\\n    long long solve(int i, int j, int n, vector<int> &nums)\\n    {\\n        if (i > j || i >= n || j < 0)\\n            return 0;\\n        vector<long long> k{i, j};\\n        if (memo[k] != 0)\\n            return memo[k];\\n        int option1 = min(solve(i + 1, j - 1, n, nums), solve(i + 2, j, n, nums));\\n        int option2 = min(solve(i + 1, j - 1, n, nums), solve(i, j - 2, n, nums));\\n        memo[k] = max(nums[i] + option1, nums[j] + option2);\\n        return memo[k];\\n    }\\n    bool PredictTheWinner(vector<int> &nums)\\n    {\\n        int n = nums.size();\\n        int first_score = solve(0, n - 1, n, nums);\\n        int total_score = accumulate(nums.begin(), nums.end(), 0);\\n        return first_score >= total_score - first_score;\\n    }\\n};\\n```\\n\\n**Approach:**\\n\\n* let there be a function solve(i,j,n,nums)\\n\\t* it calculates the sum we can get if we have the ending points as \\'i\\' and \\'j\\' in an array nums of size n\\n* at the start\\n\\t* i=0 and j=n-1\\n* let\\u2019s see **if we pick the ```ith``` coin**\\n\\t* Then the opponent can pick ```(i+1)th``` coin or ```jth``` coin\\n\\t\\t* **case A:** \\n\\t\\t\\t* he choose the ```(i+1)th coin```\\n\\t\\t\\t* so now the end points are ```i+2 and j```\\n\\t\\t\\t* solve(i+2, j, n, nums)\\n\\t\\t* **case B:**  \\n\\t\\t\\t* he choose the ```(j)th coin```\\n\\t\\t\\t* so now the end points are ```i+1 and j-1```\\n\\t\\t\\t* solve(i+1, j-1, n, nums)\\n\\t* then this function will find the sum for the remaining array\\n\\t* So the opponent will pick the one in which he gets the maximum sum at the end\\n\\t* So we will be getting the case in which he got the minimum sum\\n\\t* i.e min(A,B) = option1\\n* Similarly **If we choose jth coin**\\n\\t* Then the opponent can pick ```i th``` coin or ```(j-1)th``` coin\\n\\t\\t* **case C:**\\n\\t\\t\\t\\t* he choose the ```(i)th coin```\\n\\t\\t\\t\\t* so now the end points are ```i+1 and j-1```\\n\\t\\t\\t\\t* solve(i+1, j-1, n, nums)\\n\\t\\t* **case D:** \\n\\t\\t\\t\\t* he choose the ```(j-1)th coin```\\n\\t\\t\\t\\t* so now the end points are ```i and j-2```\\n\\t\\t\\t\\t* solve(i, j-2, n, nums)\\n\\t* we will be getting the case in which he got the minimum sum\\n\\t\\t* i.e min(C,D) = option2\\n* Now we want our sum to be maximum in order to win\\n* So we choose **max(nums[i] + option1, nums[j]+option2)**\\n* **now in order to win the sum of first >= sum of second**\\n* and we know that sum of second +sum of first = total sum\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    map<vector<long long>, long long> memo;\\n    long long solve(int i, int j, int n, vector<int> &nums)\\n    {\\n        if (i > j || i >= n || j < 0)\\n            return 0;\\n        vector<long long> k{i, j};\\n        if (memo[k] != 0)\\n            return memo[k];\\n        int option1 = min(solve(i + 1, j - 1, n, nums), solve(i + 2, j, n, nums));\\n        int option2 = min(solve(i + 1, j - 1, n, nums), solve(i, j - 2, n, nums));\\n        memo[k] = max(nums[i] + option1, nums[j] + option2);\\n        return memo[k];\\n    }\\n    bool PredictTheWinner(vector<int> &nums)\\n    {\\n        int n = nums.size();\\n        int first_score = solve(0, n - 1, n, nums);\\n        int total_score = accumulate(nums.begin(), nums.end(), 0);\\n        return first_score >= total_score - first_score;\\n    }\\n};\\n```\n```ith```\n```(i+1)th```\n```jth```\n```(i+1)th coin```\n```i+2 and j```\n```(j)th coin```\n```i+1 and j-1```\n```i th```\n```(j-1)th```\n```(i)th coin```\n```i+1 and j-1```\n```(j-1)th coin```\n```i and j-2```",
                "codeTag": "Java"
            },
            {
                "id": 2166546,
                "title": "c-7-liner-recursive-code-with-explaination-pick-notpick-analogy",
                "content": "```\\n/*pointer-->denotes the position which you choosefrom vector nums. it is initialised in bool PredictTheWinner() with  0. In the solve function we ourself assign it either the 0th index or (nums.size()-1)th index.\\n   lend-->denotes the left most index for the vector nums. it is initialised with 0 since you can choose 0th index in solve function.\\n   rend-->denotes the right most index for the vector nums. it is initialised with nums.size()-1 since you can choose (nums.size()-1)th index in solve function.\\n\\n\\n   lets suppose the given nums vector is [1,2,3,4,5,6,7,8,9].you have two choice.Lets explore the first choice and see where it leads.\\n\\n   1st choice- You choose index 0(nums[0]=1). when you choose the 0th index,your opponent has two choices, either the opponent chooses index 1(nums[1]=2) or he chooses index 8[nums[8]=9].chooseleft1 denotes what valid vector is left for you to choose after your opponent chooses index 8. chooseleft2 denotes what valid vector is left for you to  choose after you opponent picked index 1\\n\\n   2nd choice- You choose index 8(nums[8]=9).Then choices are same as above.  \\n\\n\\n\\n         \\n*/\\n    int solve(int pointer,int lend,int rend,vector<int>& nums){\\n        if(pointer<lend||pointer>rend) return 0;\\n        \\n        int chooseleft1=nums[lend]+solve(lend+2,lend+2,rend,nums);\\n        int chooseleft2=nums[lend]+solve(lend+1,lend+1,rend-1,nums);\\n        int chooseright1=nums[rend]+solve(rend-2,lend,rend-2,nums);\\n        int chooseright2=nums[rend]+solve(rend-1,lend+1,rend-1,nums);\\n        return max(min(chooseleft1,chooseleft2),min(chooseright1,chooseright2));\\n    }\\n    bool PredictTheWinner(vector<int>& nums) {\\n        int x= solve(0,0,nums.size()-1,nums);//x returns the max amount you can make from given vector if you play optimally\\n        int sum=0;//sum stores the sum of nums\\n        for(auto it:nums) sum+=it;\\n        \\n        if(x>=sum-x) return true;//if x is greater than sum-x then you win!\\n            else return false;\\n        \\n        \\n    }\\n```\\n**Note**: It is not the fastest nor an efficent piece of code,but i hope the elaboration of variables helps in understanding how other recursive soln posted(in discuss section) works.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n/*pointer-->denotes the position which you choosefrom vector nums. it is initialised in bool PredictTheWinner() with  0. In the solve function we ourself assign it either the 0th index or (nums.size()-1)th index.\\n   lend-->denotes the left most index for the vector nums. it is initialised with 0 since you can choose 0th index in solve function.\\n   rend-->denotes the right most index for the vector nums. it is initialised with nums.size()-1 since you can choose (nums.size()-1)th index in solve function.\\n\\n\\n   lets suppose the given nums vector is [1,2,3,4,5,6,7,8,9].you have two choice.Lets explore the first choice and see where it leads.\\n\\n   1st choice- You choose index 0(nums[0]=1). when you choose the 0th index,your opponent has two choices, either the opponent chooses index 1(nums[1]=2) or he chooses index 8[nums[8]=9].chooseleft1 denotes what valid vector is left for you to choose after your opponent chooses index 8. chooseleft2 denotes what valid vector is left for you to  choose after you opponent picked index 1\\n\\n   2nd choice- You choose index 8(nums[8]=9).Then choices are same as above.  \\n\\n\\n\\n         \\n*/\\n    int solve(int pointer,int lend,int rend,vector<int>& nums){\\n        if(pointer<lend||pointer>rend) return 0;\\n        \\n        int chooseleft1=nums[lend]+solve(lend+2,lend+2,rend,nums);\\n        int chooseleft2=nums[lend]+solve(lend+1,lend+1,rend-1,nums);\\n        int chooseright1=nums[rend]+solve(rend-2,lend,rend-2,nums);\\n        int chooseright2=nums[rend]+solve(rend-1,lend+1,rend-1,nums);\\n        return max(min(chooseleft1,chooseleft2),min(chooseright1,chooseright2));\\n    }\\n    bool PredictTheWinner(vector<int>& nums) {\\n        int x= solve(0,0,nums.size()-1,nums);//x returns the max amount you can make from given vector if you play optimally\\n        int sum=0;//sum stores the sum of nums\\n        for(auto it:nums) sum+=it;\\n        \\n        if(x>=sum-x) return true;//if x is greater than sum-x then you win!\\n            else return false;\\n        \\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2000408,
                "title": "c-recursive",
                "content": "```\\nbool recur(vector<int> & nums, int i , int j, int total , bool turn)\\n    {\\n        if( i > j) return total>=0;\\n          \\n        if( turn )\\n\\t\\treturn recur( nums , i + 1 , j , total + nums[i] , !turn) or  recur( nums , i , j - 1 , total + nums[j] , !turn );\\n\\n        \\t \\n            return recur( nums , i+1 , j , total - nums[i] , !turn )   and recur( nums , i , j -  1 , total - nums[j] , !turn);     \\n \\n    }\\n    bool PredictTheWinner(vector<int>& nums) {\\n        \\n        return recur(nums,0,nums.size()-1,0,true);\\n    }",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nbool recur(vector<int> & nums, int i , int j, int total , bool turn)\\n    {\\n        if( i > j) return total>=0;\\n          \\n        if( turn )\\n\\t\\treturn recur( nums , i + 1 , j , total + nums[i] , !turn) or  recur( nums , i , j - 1 , total + nums[j] , !turn );\\n\\n        \\t \\n            return recur( nums , i+1 , j , total - nums[i] , !turn )   and recur( nums , i , j -  1 , total - nums[j] , !turn);     \\n \\n    }\\n    bool PredictTheWinner(vector<int>& nums) {\\n        \\n        return recur(nums,0,nums.size()-1,0,true);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1969411,
                "title": "javascript-solution-using-recursion",
                "content": "```\\nvar PredictTheWinner = function(nums,turn = 1, score1 = 0,score2 = 0) {\\n    \\n    let len = nums.length;\\n    if(len === 0 ) return score1>= score2;\\n    \\n    if(turn%2===0){\\n        return PredictTheWinner(nums.slice(1,),turn+1,score1,score2+nums[0]) && PredictTheWinner(nums.slice(0,-1),turn+1,score1,score2+nums[len-1])\\n    }\\n    \\n    return PredictTheWinner(nums.slice(1,),turn+1,score1+nums[0],score2) || PredictTheWinner(nums.slice(0,-1),turn+1,score1+nums[len-1],score2)\\n\\n};\\n    \\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\nvar PredictTheWinner = function(nums,turn = 1, score1 = 0,score2 = 0) {\\n    \\n    let len = nums.length;\\n    if(len === 0 ) return score1>= score2;\\n    \\n    if(turn%2===0){\\n        return PredictTheWinner(nums.slice(1,),turn+1,score1,score2+nums[0]) && PredictTheWinner(nums.slice(0,-1),turn+1,score1,score2+nums[len-1])\\n    }\\n    \\n    return PredictTheWinner(nums.slice(1,),turn+1,score1+nums[0],score2) || PredictTheWinner(nums.slice(0,-1),turn+1,score1+nums[len-1],score2)\\n\\n};\\n    \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1939817,
                "title": "memoization",
                "content": "class Solution {\\npublic:\\n    \\n    int solve(vector<int>&nums,int i,int j,vector<vector<int>>&dp)\\n    {\\n        if(i>j)\\n        {\\n            return 0;\\n        }\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int a=nums[i]+min(  solve(nums,i+2,j,dp)  , solve(nums,i+1,j-1,dp)   );\\n        int b=nums[j]+min(  solve(nums,i+1,j-1,dp)  , solve(nums,i,j-2,dp)   );\\n        return dp[i][j]= max(a,b);\\n        \\n    }\\n    \\n    bool PredictTheWinner(vector<int>& nums) {\\n        \\n        \\n        vector<vector<int>>dp(nums.size(),vector<int>(nums.size(),-1));\\n        int sum=0;\\n        for(int i=0;i<nums.size();i++) sum+=nums[i];\\n        \\n        int res=solve(nums,0,nums.size()-1,dp);\\n        if(res>=(sum-res))\\n        {\\n            return true;\\n        }\\n        return false;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    int solve(vector<int>&nums,int i,int j,vector<vector<int>>&dp)\\n    {\\n        if(i>j)\\n        {\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1764853,
                "title": "c-dp",
                "content": "Solve all possible ways and save the value calculated so as to reduce the time\\n\\n```\\nint helper_func(vector<int> arr, int start, int end, vector<vector<int>> &dp){\\n        cout<<start<<\" \"<<end<<endl;\\n        if(start==end)\\n            return arr[start];\\n        \\n        if(dp[start][end]!=INT_MIN)\\n            return dp[start][end];            \\n                \\n        int left= arr[start] - helper_func(arr,start+1,end,dp);\\n        int right= arr[end]  - helper_func(arr,start,end-1,dp);\\n        \\n        return dp[start][end]= max(left,right);\\n    }\\n    \\n    \\n    bool PredictTheWinner(vector<int>& nums) {\\n        vector<vector<int>> dp(nums.size(), vector<int>(nums.size(),INT_MIN));       \\n        int ans=helper_func(nums,0,nums.size()-1,dp);\\n        \\n        return ans>=0;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nint helper_func(vector<int> arr, int start, int end, vector<vector<int>> &dp){\\n        cout<<start<<\" \"<<end<<endl;\\n        if(start==end)\\n            return arr[start];\\n        \\n        if(dp[start][end]!=INT_MIN)\\n            return dp[start][end];            \\n                \\n        int left= arr[start] - helper_func(arr,start+1,end,dp);\\n        int right= arr[end]  - helper_func(arr,start,end-1,dp);\\n        \\n        return dp[start][end]= max(left,right);\\n    }\\n    \\n    \\n    bool PredictTheWinner(vector<int>& nums) {\\n        vector<vector<int>> dp(nums.size(), vector<int>(nums.size(),INT_MIN));       \\n        int ans=helper_func(nums,0,nums.size()-1,dp);\\n        \\n        return ans>=0;\\n    }\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1738760,
                "title": "c-dynamic-programming-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    long long dp[21][21];\\n    long long solve(vector<int> &arr, int i, int j)\\n    {\\n        int n = arr.size();\\n        // below diagonal values zero\\n        if(i > j)\\n            return 0;\\n        // filling the central diagonal value\\n        if(i == j)\\n            dp[i][j] = arr[i];\\n        \\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n        \\n        // case 1: if you have picked arr[i]\\n        // Then your opponent can pick either i+1 or j. If he/she picks\\n        //  i+1 -> choices left for you are i+2 or j\\n        //  j -> choices left you you are i+1 or j-1\\n        // Now, since your opponent is playing as smartly as you are he/she will pick i+1 or j\\n        // such that you can get min choice options in your turn.\\n        long long int front_pick = arr[i]+ min(solve(arr,i+2,j), solve(arr,i+1,j-1));\\n        \\n        // case 2: if you have picked arr[j]\\n        // Then your opponent can pick either i or j-1. If he/she picks\\n        //  i -> choices left for you are i+1 or j-1\\n        //  j-1 -> choices left you you are i or j-2\\n        // Now, since your opponent is playing as smartly as you are he/she will pick i or j-1\\n        // such that you can get min choice options in your turn.\\n        long long int back_pick = arr[j]+ min(solve(arr,i,j-2), solve(arr,i+1,j-1));\\n        \\n        return dp[i][j] = max(front_pick, back_pick);\\n        \\n    }\\n    bool PredictTheWinner(vector<int>& nums) {\\n        int n = nums.size();\\n        memset(dp, -1, sizeof(dp));\\n        long long val = solve(nums, 0, n-1);\\n        long long sum = accumulate(nums.begin(), nums.end(), 0LL);\\n        return (val >= (sum-val));\\n    }\\n};\\n```\\n\\nTime Complexity: O(n^2)\\nAuxilary Space: O(n^2)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long dp[21][21];\\n    long long solve(vector<int> &arr, int i, int j)\\n    {\\n        int n = arr.size();\\n        // below diagonal values zero\\n        if(i > j)\\n            return 0;\\n        // filling the central diagonal value\\n        if(i == j)\\n            dp[i][j] = arr[i];\\n        \\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n        \\n        // case 1: if you have picked arr[i]\\n        // Then your opponent can pick either i+1 or j. If he/she picks\\n        //  i+1 -> choices left for you are i+2 or j\\n        //  j -> choices left you you are i+1 or j-1\\n        // Now, since your opponent is playing as smartly as you are he/she will pick i+1 or j\\n        // such that you can get min choice options in your turn.\\n        long long int front_pick = arr[i]+ min(solve(arr,i+2,j), solve(arr,i+1,j-1));\\n        \\n        // case 2: if you have picked arr[j]\\n        // Then your opponent can pick either i or j-1. If he/she picks\\n        //  i -> choices left for you are i+1 or j-1\\n        //  j-1 -> choices left you you are i or j-2\\n        // Now, since your opponent is playing as smartly as you are he/she will pick i or j-1\\n        // such that you can get min choice options in your turn.\\n        long long int back_pick = arr[j]+ min(solve(arr,i,j-2), solve(arr,i+1,j-1));\\n        \\n        return dp[i][j] = max(front_pick, back_pick);\\n        \\n    }\\n    bool PredictTheWinner(vector<int>& nums) {\\n        int n = nums.size();\\n        memset(dp, -1, sizeof(dp));\\n        long long val = solve(nums, 0, n-1);\\n        long long sum = accumulate(nums.begin(), nums.end(), 0LL);\\n        return (val >= (sum-val));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1688071,
                "title": "easy-recursive-solution-with-dp-and-without-dp-c",
                "content": "//without dp\\n```\\nclass Solution {\\npublic:\\n   \\n    \\n   int score(vector<int>& nums,int s,int e,int turn){\\n       if(s==e)\\n           return turn*nums[s];\\n       if(turn==1)\\n       return max(score(nums,s+1,e,-turn)+(nums[s]*turn),score(nums,s,e-1,-turn)+(nums[e]*turn));\\n      \\n           return min(score(nums,s+1,e,-turn)+(nums[s]*turn),score(nums,s,e-1,-turn)+(nums[e]*turn)); \\n      \\n    }\\n    bool PredictTheWinner(vector<int>& nums) {\\n   return score (nums,0,nums.size()-1,1)>=0;\\n    }\\n};\\n```\\n// with dp\\n```\\nclass Solution {\\npublic:\\n   \\n    \\n   int score(vector<int>& nums){\\n      int dp[nums.size()][nums.size()];\\n       memset(dp,0,nums.size());\\n        for (int s = nums.size()-1; s >= 0; s--) {\\n           for (int e = s; e < nums.size(); e++) {\\n                if(s==e)\\n          \\n           dp[s][e]=nums[s];\\n               else\\n      dp[s][e]= max((nums[s]-dp[s+1][e]),(nums[e]-dp[s][e-1]));\\n      \\n          \\n           }\\n       }\\n     return dp[0][nums.size()-1];\\n      \\n    }\\n    bool PredictTheWinner(vector<int>& nums) {\\n   return score (nums)>=0;\\n    }\\n};\\n```\\n//if you like the solution plz upvote",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   \\n    \\n   int score(vector<int>& nums,int s,int e,int turn){\\n       if(s==e)\\n           return turn*nums[s];\\n       if(turn==1)\\n       return max(score(nums,s+1,e,-turn)+(nums[s]*turn),score(nums,s,e-1,-turn)+(nums[e]*turn));\\n      \\n           return min(score(nums,s+1,e,-turn)+(nums[s]*turn),score(nums,s,e-1,-turn)+(nums[e]*turn)); \\n      \\n    }\\n    bool PredictTheWinner(vector<int>& nums) {\\n   return score (nums,0,nums.size()-1,1)>=0;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n   \\n    \\n   int score(vector<int>& nums){\\n      int dp[nums.size()][nums.size()];\\n       memset(dp,0,nums.size());\\n        for (int s = nums.size()-1; s >= 0; s--) {\\n           for (int e = s; e < nums.size(); e++) {\\n                if(s==e)\\n          \\n           dp[s][e]=nums[s];\\n               else\\n      dp[s][e]= max((nums[s]-dp[s+1][e]),(nums[e]-dp[s][e-1]));\\n      \\n          \\n           }\\n       }\\n     return dp[0][nums.size()-1];\\n      \\n    }\\n    bool PredictTheWinner(vector<int>& nums) {\\n   return score (nums)>=0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1575398,
                "title": "c-100-fast-recursion-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[21][21];\\n    int solve(int i, int j, vector<int> &nums){\\n           if(i==j) return nums[i];\\n        else if(i>j) return 0;\\n          if(dp[i][j]!=-1) return dp[i][j];\\n         int l = nums[i] + min(solve(i+2,j,nums),solve(i+1,j-1,nums));\\n        int r = nums[j] + min(solve(i,j-2,nums),solve(i+1,j-1,nums));\\n          dp[i][j] = max(l,r);  \\n        return max(l,r);\\n    }\\n    \\n    \\n    bool PredictTheWinner(vector<int>& nums) {\\n          memset(dp,-1,sizeof(dp));\\n        if(nums.size()==1) return true;\\n        int p1=solve(0,nums.size()-1,nums);\\n        int p2 = accumulate(nums.begin(),nums.end(),0) - p1;\\n        return p1>=p2;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int dp[21][21];\\n    int solve(int i, int j, vector<int> &nums){\\n           if(i==j) return nums[i];\\n        else if(i>j) return 0;\\n          if(dp[i][j]!=-1) return dp[i][j];\\n         int l = nums[i] + min(solve(i+2,j,nums),solve(i+1,j-1,nums));\\n        int r = nums[j] + min(solve(i,j-2,nums),solve(i+1,j-1,nums));\\n          dp[i][j] = max(l,r);  \\n        return max(l,r);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1522643,
                "title": "c-dp-solution-100-faster",
                "content": "bool PredictTheWinner(vector<int>& nums) \\n    {\\n        int n=nums.size();\\n        \\n        int dp[n][n];\\n        \\n        for(int k=1;k<=n;k++)\\n        {\\n            for(int i=0;i<n-k+1;i++)\\n            {\\n                if(k==1)dp[i][i]=nums[i];\\n                \\n                else if(k==2)dp[i][i+k-1]=max(nums[i],nums[i+k-1]);\\n                \\n                else\\n                {\\n                    dp[i][i+k-1]=max(nums[i]+min(dp[i+2][i+k-1],dp[i+1][i+k-2]),nums[i+k-1]+min(dp[i+1][i+k-2],dp[i][i+k-3]));\\n                }\\n            }\\n        }\\n        \\n        int sum=0;\\n        for(int i=0;i<n;i++)sum+=nums[i];\\n        \\n        if(2*dp[0][n-1]>=sum)return true;\\n        \\n        return false;\\n        \\n    }",
                "solutionTags": [],
                "code": "bool PredictTheWinner(vector<int>& nums) \\n    {\\n        int n=nums.size();\\n        \\n        int dp[n][n];\\n        \\n        for(int k=1;k<=n;k++)\\n        {\\n            for(int i=0;i<n-k+1;i++)\\n            {\\n                if(k==1)dp[i][i]=nums[i];\\n                \\n                else if(k==2)dp[i][i+k-1]=max(nums[i],nums[i+k-1]);\\n                \\n                else\\n                {\\n                    dp[i][i+k-1]=max(nums[i]+min(dp[i+2][i+k-1],dp[i+1][i+k-2]),nums[i+k-1]+min(dp[i+1][i+k-2],dp[i][i+k-3]));\\n                }\\n            }\\n        }\\n        \\n        int sum=0;\\n        for(int i=0;i<n;i++)sum+=nums[i];\\n        \\n        if(2*dp[0][n-1]>=sum)return true;\\n        \\n        return false;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1462015,
                "title": "c-dp-o-n-2-with-comments",
                "content": "Note that the sum of the scores of both the players (say Alice and Bob) will be the sum of all the numbers in the array. So if we are given one player\\'s score, we can calculate the other player\\'s score in O(1) if we have precalculated the sum of the array. We can use the concept of cumulative sum to precalculate the sum for every range.\\n\\nNow, any player (say Alice), at any point of the game, will either choose the leftmost element or the rightmost. It\\'s Bob\\'s turn now. For the remaining smaller subarray, if we knew how much Bob will optimally score, we can use the observation above and calculate Alice\\'s score in O(1). So, this might be a DP problem.\\n\\nLet\\'s define ```dp[i][j]``` to be the optimum score a player can make by moving first on the subarray ```nums[i....j]```. Note, we have not fixed a player that will score ```dp[i][j]```. It could be either of Alice and Bob. Using these ideas, we can come up with the following code. \\n```\\nclass Solution {\\npublic:\\n    bool PredictTheWinner(vector<int>& nums) {\\n        int i, j, diff;\\n        int n = nums.size();\\n\\t\\t\\n\\t\\t// cs[i+1] = sum of all elements till and including nums[i]\\n\\t\\t// sum of elements nums[idx] for left <= idx <= right is \\n\\t\\t// cs[right+1] - cs[left]\\n        int cs[n+1];\\n        cs[0] = 0;\\n        for(i=0; i<n; i++) {\\n            cs[i+1] = cs[i] + nums[i];\\n        }\\n\\t\\t\\n\\t\\t// Meaning of dp[i][j]:\\n\\t\\t// At any point of the game, if the remaining subarray is nums[i.....j], \\n\\t\\t// the score achieved by the player that has to move at that point, \\n\\t\\t// (could be either Player 1 or Player 2), \\n\\t\\t// assuming both players play optimally,\\n\\t\\t// is dp[i][j]\\n\\t\\t\\n        int dp[n][n];\\n\\t\\t\\n\\t\\t// iterating through the 2D dp diagonal by diagonal (top left to bottom right)\\n\\t\\t// starting from the leading diagonal\\n\\t\\t// because dp[i][j] can be calculated using only \\n\\t\\t// dp[i+1][j] and dp[i][j-1]\\n\\t\\t\\n        for(diff=0; diff<n; diff++) {\\n            for(i=0; i<n-diff; i++) {\\n                j = i + diff; \\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// Consider nums[i.....j]\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// if there\\'s only one element, \\n\\t\\t\\t\\t// the player to move will score exactly that element\\n                if(i == j) {\\n\\t\\t\\t\\t\\tdp[i][j] = nums[i];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// Else, the player (say Player 1) will have two options\\n\\t\\t\\t\\t// 1) Take the left element. The array then becomes nums[i+1....j]\\n\\t\\t\\t\\t//    At this point, the next player (Player 2) will make a move, \\n\\t\\t\\t\\t//    and will score dp[i+1][j]\\n\\t\\t\\t\\t//    So, Player 1 will finally score \\n\\t\\t\\t\\t//    nums[i] + (sum of nums from i+1 to j) - dp[i+1][j]\\n\\t\\t\\t\\t//    which is nums[i] +(cs[j+1]-cs[i+1]) - dp[i+1][j]\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// 2) Take the right element. Using a similar logic, \\n\\t\\t\\t\\t//    this player\\'s score will be \\n\\t\\t\\t\\t//    nums[j] + (cs[j]-cs[i]) -dp[i][j-1]\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// So, the optimum score that the player can make \\n\\t\\t\\t\\t// will be the maximum of the two\\n                else {\\n\\t\\t\\t\\t\\tdp[i][j] = max( nums[i] + (cs[j+1] - cs[i+1]) - dp[i+1][j], \\n\\t\\t\\t\\t\\t\\t\\t\\t\\tnums[j] + (cs[j] - cs[i]) - dp[i][j-1] \\n\\t\\t\\t\\t\\t\\t\\t\\t);\\n\\t\\t\\t\\t}\\n            }\\n        }\\n\\t\\t\\n\\t\\t// Player 1 wins if their score is >= Player 2\\'s score \\n\\t\\t// (total of all nums - score of Player 1)\\n        return dp[0][n-1] >= (cs[n]-cs[0]) - dp[0][n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```dp[i][j]```\n```nums[i....j]```\n```dp[i][j]```\n```\\nclass Solution {\\npublic:\\n    bool PredictTheWinner(vector<int>& nums) {\\n        int i, j, diff;\\n        int n = nums.size();\\n\\t\\t\\n\\t\\t// cs[i+1] = sum of all elements till and including nums[i]\\n\\t\\t// sum of elements nums[idx] for left <= idx <= right is \\n\\t\\t// cs[right+1] - cs[left]\\n        int cs[n+1];\\n        cs[0] = 0;\\n        for(i=0; i<n; i++) {\\n            cs[i+1] = cs[i] + nums[i];\\n        }\\n\\t\\t\\n\\t\\t// Meaning of dp[i][j]:\\n\\t\\t// At any point of the game, if the remaining subarray is nums[i.....j], \\n\\t\\t// the score achieved by the player that has to move at that point, \\n\\t\\t// (could be either Player 1 or Player 2), \\n\\t\\t// assuming both players play optimally,\\n\\t\\t// is dp[i][j]\\n\\t\\t\\n        int dp[n][n];\\n\\t\\t\\n\\t\\t// iterating through the 2D dp diagonal by diagonal (top left to bottom right)\\n\\t\\t// starting from the leading diagonal\\n\\t\\t// because dp[i][j] can be calculated using only \\n\\t\\t// dp[i+1][j] and dp[i][j-1]\\n\\t\\t\\n        for(diff=0; diff<n; diff++) {\\n            for(i=0; i<n-diff; i++) {\\n                j = i + diff; \\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// Consider nums[i.....j]\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// if there\\'s only one element, \\n\\t\\t\\t\\t// the player to move will score exactly that element\\n                if(i == j) {\\n\\t\\t\\t\\t\\tdp[i][j] = nums[i];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// Else, the player (say Player 1) will have two options\\n\\t\\t\\t\\t// 1) Take the left element. The array then becomes nums[i+1....j]\\n\\t\\t\\t\\t//    At this point, the next player (Player 2) will make a move, \\n\\t\\t\\t\\t//    and will score dp[i+1][j]\\n\\t\\t\\t\\t//    So, Player 1 will finally score \\n\\t\\t\\t\\t//    nums[i] + (sum of nums from i+1 to j) - dp[i+1][j]\\n\\t\\t\\t\\t//    which is nums[i] +(cs[j+1]-cs[i+1]) - dp[i+1][j]\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// 2) Take the right element. Using a similar logic, \\n\\t\\t\\t\\t//    this player\\'s score will be \\n\\t\\t\\t\\t//    nums[j] + (cs[j]-cs[i]) -dp[i][j-1]\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// So, the optimum score that the player can make \\n\\t\\t\\t\\t// will be the maximum of the two\\n                else {\\n\\t\\t\\t\\t\\tdp[i][j] = max( nums[i] + (cs[j+1] - cs[i+1]) - dp[i+1][j], \\n\\t\\t\\t\\t\\t\\t\\t\\t\\tnums[j] + (cs[j] - cs[i]) - dp[i][j-1] \\n\\t\\t\\t\\t\\t\\t\\t\\t);\\n\\t\\t\\t\\t}\\n            }\\n        }\\n\\t\\t\\n\\t\\t// Player 1 wins if their score is >= Player 2\\'s score \\n\\t\\t// (total of all nums - score of Player 1)\\n        return dp[0][n-1] >= (cs[n]-cs[0]) - dp[0][n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1384046,
                "title": "python-easy-solution-dp",
                "content": "The \\'Optimally\\' meaning is probably hard to understand for someone.\\nHere\\'s an idea that I came up with, The  \\'Optimally\\' means every player wants max value compared to the other player every his/her turn.\\n\\nSee this below code.\\n\\n```\\n\\tdp[i][j] = max(nums[i] - dp[i + 1][j], nums[j] - dp[i][j - 1])\\n```\\n\\ni : starting index, j : end index\\nnums[i], nums[j] : the num that the player picked  \\n\\nI hope that it helps you to understand this meaning.\\n\\n\\nDP\\n```\\n\\nclass Solution:\\n\\tdef PredictTheWinner(self, nums: List[int]) -> bool:\\n\\t\\tn = len(nums)\\n\\t\\tdp = [[0] * (n) for _ in range(n + 1)]\\n\\t\\tfor i in range(n - 1, -1, -1):\\n\\t\\t\\tfor j in range(i, n):\\n\\t\\t\\t\\tdp[i][j] = max(nums[i] - dp[i + 1][j], \\n\\t\\t\\t\\tnums[j] - dp[i][j - 1])\\n\\t\\t\\n\\t\\treturn dp[0][n - 1] >= 0 \\n```\\n\\nRecursion, Memoization\\n```\\nfrom functools import lru_cache\\n\\nclass Solution:\\n\\tdef PredictTheWinner(self, nums: List[int]) -> bool:\\n\\t\\t@lru_cache(None)\\n\\t\\tdef dp(i, j):\\n\\t\\t\\tif j - i + 1 <= 0:\\n\\t\\t\\t\\treturn 0\\n\\t\\t\\treturn max(nums[i] - dp(i + 1, j), nums[j] - dp(i, j - 1))\\n\\t\\t\\t\\n\\t\\treturn dp(0, len(nums) -1) >= 0 \\t\\n```",
                "solutionTags": [],
                "code": "```\\n\\tdp[i][j] = max(nums[i] - dp[i + 1][j], nums[j] - dp[i][j - 1])\\n```\n```\\n\\nclass Solution:\\n\\tdef PredictTheWinner(self, nums: List[int]) -> bool:\\n\\t\\tn = len(nums)\\n\\t\\tdp = [[0] * (n) for _ in range(n + 1)]\\n\\t\\tfor i in range(n - 1, -1, -1):\\n\\t\\t\\tfor j in range(i, n):\\n\\t\\t\\t\\tdp[i][j] = max(nums[i] - dp[i + 1][j], \\n\\t\\t\\t\\tnums[j] - dp[i][j - 1])\\n\\t\\t\\n\\t\\treturn dp[0][n - 1] >= 0 \\n```\n```\\nfrom functools import lru_cache\\n\\nclass Solution:\\n\\tdef PredictTheWinner(self, nums: List[int]) -> bool:\\n\\t\\t@lru_cache(None)\\n\\t\\tdef dp(i, j):\\n\\t\\t\\tif j - i + 1 <= 0:\\n\\t\\t\\t\\treturn 0\\n\\t\\t\\treturn max(nums[i] - dp(i + 1, j), nums[j] - dp(i, j - 1))\\n\\t\\t\\t\\n\\t\\treturn dp(0, len(nums) -1) >= 0 \\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1263428,
                "title": "javascript-for-beninners",
                "content": "It is a typical dynamic programming question.\\n\\n```\\nvar PredictTheWinner = function(nums) {\\n    if (nums.length < 3) return true; // If there are only less than 3 elements, always a player 1 can win\\n    \\n    let memo = Array(nums.length).fill(0).map(a => Array(nums.length).fill(-1)); // Memoization to record the previous result\\n    \\n    const check = (left, right) => {\\n        if (memo[left][right] > -1) {\\n            return memo[left][right];\\n        }\\n        let a = nums[left]; // If I choose the left number\\n        let b = nums[right]; // If I choose the right number\\n        let val = 0;\\n        if (left < right) {\\n\\t\\t\\t// The next line is important to understand. \\n\\t\\t\\t// If I choose a(left number) then the next player will try his/her best to get the best number, \\n\\t\\t\\t// but it is the opponent\\'s score, so we have to substract the return value from the recursive call.\\n\\t\\t\\t// It is the same when I choose the number b(right number)\\n            val = Math.max(a - check(left + 1, right), b - check(left, right - 1)); // I want to get a maximum number\\n        } else {\\n\\t\\t\\t// If left == right, it doesn\\'t matter I choose a or b, since it is the same number\\n            val = a;\\n        }\\n        memo[left][right] = val;\\n        return val;\\n    };\\n\\n    let p1Val = check(0, nums.length - 1); // Because a player 1 start first, it returns the player 1 maximum value\\n    return p1Val >= 0;  // If player 1 get 0 or greater value, it means player 1 wins, if p1Val is a minus number, it means player 2 win.\\n};",
                "solutionTags": [],
                "code": "It is a typical dynamic programming question.\\n\\n```\\nvar PredictTheWinner = function(nums) {\\n    if (nums.length < 3) return true; // If there are only less than 3 elements, always a player 1 can win\\n    \\n    let memo = Array(nums.length).fill(0).map(a => Array(nums.length).fill(-1)); // Memoization to record the previous result\\n    \\n    const check = (left, right) => {\\n        if (memo[left][right] > -1) {\\n            return memo[left][right];\\n        }\\n        let a = nums[left]; // If I choose the left number\\n        let b = nums[right]; // If I choose the right number\\n        let val = 0;\\n        if (left < right) {\\n\\t\\t\\t// The next line is important to understand. \\n\\t\\t\\t// If I choose a(left number) then the next player will try his/her best to get the best number, \\n\\t\\t\\t// but it is the opponent\\'s score, so we have to substract the return value from the recursive call.\\n\\t\\t\\t// It is the same when I choose the number b(right number)\\n            val = Math.max(a - check(left + 1, right), b - check(left, right - 1)); // I want to get a maximum number\\n        } else {\\n\\t\\t\\t// If left == right, it doesn\\'t matter I choose a or b, since it is the same number\\n            val = a;\\n        }\\n        memo[left][right] = val;\\n        return val;\\n    };\\n\\n    let p1Val = check(0, nums.length - 1); // Because a player 1 start first, it returns the player 1 maximum value\\n    return p1Val >= 0;  // If player 1 get 0 or greater value, it means player 1 wins, if p1Val is a minus number, it means player 2 win.\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1129212,
                "title": "c-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    int score(vector<int>&nums, int start, int end, int turn){\\n        if(start == end)return turn*nums[start];\\n        \\n        int start_element  = turn*nums[start] + score(nums, start+1, end, -turn);\\n        int end_element = turn*nums[end]+ score(nums, start, end-1, -turn);\\n        \\n        return turn* max(turn*start_element, turn*end_element);\\n    }\\npublic:\\n    bool PredictTheWinner(vector<int>& nums) {\\n        int total_score = score(nums,0, nums.size()-1, 1);\\n        if(total_score>=0)return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int score(vector<int>&nums, int start, int end, int turn){\\n        if(start == end)return turn*nums[start];\\n        \\n        int start_element  = turn*nums[start] + score(nums, start+1, end, -turn);\\n        int end_element = turn*nums[end]+ score(nums, start, end-1, -turn);\\n        \\n        return turn* max(turn*start_element, turn*end_element);\\n    }\\npublic:\\n    bool PredictTheWinner(vector<int>& nums) {\\n        int total_score = score(nums,0, nums.size()-1, 1);\\n        if(total_score>=0)return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1056202,
                "title": "dp-top-down-time-space-o-n-2-clean-soln",
                "content": "![image](https://assets.leetcode.com/users/images/d7d338f2-af38-454c-ac45-702dced7dcb8_1612795755.4670303.png)\\n```\\npublic class Solution {\\n    public bool PredictTheWinner(int[] nums) {\\n        int totalSum=0, p1Total=0, l = nums.Length;\\n        for(int i=0;i<l;i++) totalSum+=nums[i];\\n        \\n        p1Total = OptimalStrategyGame(nums,0,l-1, new int[l,l]);\\n        return p1Total>=(totalSum-p1Total);\\n    }\\n    // Time O(n^2) || Auxillary Space O(n^2)\\n    int OptimalStrategyGame(int[] nums, int start, int last, int[,] cache)\\n    {\\n        if(cache[start,last]>0) return cache[start,last];   // Memoization Step added\\n        if(start==last)                                     // only single coin left P1 takes it\\n            return cache[start,last] = nums[start];\\n        if(start+1==last)                                   // if just 2 coins are left P1 takes Max\\n            return cache[start,last] = Math.Max(nums[start],nums[last]);\\n        return cache[start,last] = Math.Max( nums[start] + Math.Min(OptimalStrategyGame(nums,start+1,last-1,cache),\\n                                                                    OptimalStrategyGame(nums,start+2,last,cache)),\\n                                             nums[last] +  Math.Min(OptimalStrategyGame(nums,start+1,last-1,cache),\\n                                                                    OptimalStrategyGame(nums,start,last-2,cache)));\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public bool PredictTheWinner(int[] nums) {\\n        int totalSum=0, p1Total=0, l = nums.Length;\\n        for(int i=0;i<l;i++) totalSum+=nums[i];\\n        \\n        p1Total = OptimalStrategyGame(nums,0,l-1, new int[l,l]);\\n        return p1Total>=(totalSum-p1Total);\\n    }\\n    // Time O(n^2) || Auxillary Space O(n^2)\\n    int OptimalStrategyGame(int[] nums, int start, int last, int[,] cache)\\n    {\\n        if(cache[start,last]>0) return cache[start,last];   // Memoization Step added\\n        if(start==last)                                     // only single coin left P1 takes it\\n            return cache[start,last] = nums[start];\\n        if(start+1==last)                                   // if just 2 coins are left P1 takes Max\\n            return cache[start,last] = Math.Max(nums[start],nums[last]);\\n        return cache[start,last] = Math.Max( nums[start] + Math.Min(OptimalStrategyGame(nums,start+1,last-1,cache),\\n                                                                    OptimalStrategyGame(nums,start+2,last,cache)),\\n                                             nums[last] +  Math.Min(OptimalStrategyGame(nums,start+1,last-1,cache),\\n                                                                    OptimalStrategyGame(nums,start,last-2,cache)));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935490,
                "title": "java-minimax-dp",
                "content": "maxVal() returns the minimum margin by which player 1 can win. If it is negative, then player 1 loses.\\n```\\n    public boolean PredictTheWinner(int[] nums) {\\n        dp = new int[21][21];\\n        return maxVal(nums, 0, nums.length-1) >= 0;\\n    }\\n\\n    int[][] dp;\\n    public int maxVal(int[] arr, int i,int j){\\n        if(i==j)\\n            return arr[j];\\n        if(dp[i][j] != 0)\\n            return dp[i][j];\\n        dp[i][j] =  Math.max(minVal(arr,i,j-1)+arr[j], minVal(arr,i+1,j)+arr[i]);\\n        return dp[i][j];\\n    }\\n\\n    public int minVal(int[] arr, int i,int j){\\n        if(i==j)\\n            return arr[j];\\n        if(dp[i][j] != 0)\\n            return dp[i][j];\\n        dp[i][j] = Math.min(maxVal(arr,i,j-1)-arr[j], maxVal(arr,i+1,j)-arr[i]);\\n        return dp[i][j];\\n    }",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "maxVal() returns the minimum margin by which player 1 can win. If it is negative, then player 1 loses.\\n```\\n    public boolean PredictTheWinner(int[] nums) {\\n        dp = new int[21][21];\\n        return maxVal(nums, 0, nums.length-1) >= 0;\\n    }\\n\\n    int[][] dp;\\n    public int maxVal(int[] arr, int i,int j){\\n        if(i==j)\\n            return arr[j];\\n        if(dp[i][j] != 0)\\n            return dp[i][j];\\n        dp[i][j] =  Math.max(minVal(arr,i,j-1)+arr[j], minVal(arr,i+1,j)+arr[i]);\\n        return dp[i][j];\\n    }\\n\\n    public int minVal(int[] arr, int i,int j){\\n        if(i==j)\\n            return arr[j];\\n        if(dp[i][j] != 0)\\n            return dp[i][j];\\n        dp[i][j] = Math.min(maxVal(arr,i,j-1)-arr[j], maxVal(arr,i+1,j)-arr[i]);\\n        return dp[i][j];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 820283,
                "title": "dp-recursive-solution-0ms-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int fun(vector<vector<int>>& dp, vector<int>& nums, int start, int end){\\n        if(start > end){\\n            return 0;\\n        }\\n                \\n        if(dp[start][end] != -1) return dp[start][end];\\n        \\n        //dp stores the margin of winning\\n        dp[start][end] = max(nums[start] - fun(dp, nums, start+1, end), nums[end] - fun(dp, nums, start, end-1));\\n        return dp[start][end];\\n    }\\n    \\n    bool PredictTheWinner(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<vector<int>> dp(n, vector<int>(n, -1));\\n        return fun(dp, nums, 0, n-1) >= 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int fun(vector<vector<int>>& dp, vector<int>& nums, int start, int end){\\n        if(start > end){\\n            return 0;\\n        }\\n                \\n        if(dp[start][end] != -1) return dp[start][end];\\n        \\n        //dp stores the margin of winning\\n        dp[start][end] = max(nums[start] - fun(dp, nums, start+1, end), nums[end] - fun(dp, nums, start, end-1));\\n        return dp[start][end];\\n    }\\n    \\n    bool PredictTheWinner(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<vector<int>> dp(n, vector<int>(n, -1));\\n        return fun(dp, nums, 0, n-1) >= 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 733211,
                "title": "javascript-solution-dp",
                "content": "```\\nvar PredictTheWinner = function(nums) {\\n    const n = nums.length;\\n    const dp = [];\\n    \\n    for (let i = 0; i < n; i++) {\\n        dp[i] = new Array(n).fill(0);\\n        dp[i][i] = nums[i];\\n    }\\n    \\n    for (let len = 2; len <= n; len++) {\\n        for (let start = 0; start < n - len + 1; start++) {\\n            const end = start + len - 1;\\n            dp[start][end] = Math.max(nums[start] - dp[start + 1][end], nums[end] - dp[start][end - 1]);\\n        }\\n    }\\n    \\n    return dp[0][n - 1] >= 0;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nvar PredictTheWinner = function(nums) {\\n    const n = nums.length;\\n    const dp = [];\\n    \\n    for (let i = 0; i < n; i++) {\\n        dp[i] = new Array(n).fill(0);\\n        dp[i][i] = nums[i];\\n    }\\n    \\n    for (let len = 2; len <= n; len++) {\\n        for (let start = 0; start < n - len + 1; start++) {\\n            const end = start + len - 1;\\n            dp[start][end] = Math.max(nums[start] - dp[start + 1][end], nums[end] - dp[start][end - 1]);\\n        }\\n    }\\n    \\n    return dp[0][n - 1] >= 0;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 673923,
                "title": "java-simple-dp",
                "content": "ptifalls:\\nuse n + 1 other than n in case of overflow and corner cases\\nsocre 0 can win...  though human-beings think it should be a tie\\n```\\npublic boolean PredictTheWinner(int[] nums) {\\n        int n = nums.length, dp[][] = new int[n + 1][n + 1]; \\n        // dp[i][j] current play scores more when i stones left, from j th stone;\\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 0; j + i - 1 < n; j++) {\\n                dp[i][j] = Math.max(nums[j] - dp[i - 1][j + 1], //say j + 1 may overflow, so we set dp n+1s\\n                                   nums[j + i - 1] - dp[i - 1][j]);\\n                \\n            }\\n        }\\n        return dp[n][0] >= 0;  // == for [0]\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean PredictTheWinner(int[] nums) {\\n        int n = nums.length, dp[][] = new int[n + 1][n + 1]; \\n        // dp[i][j] current play scores more when i stones left, from j th stone;\\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 0; j + i - 1 < n; j++) {\\n                dp[i][j] = Math.max(nums[j] - dp[i - 1][j + 1], //say j + 1 may overflow, so we set dp n+1s\\n                                   nums[j + i - 1] - dp[i - 1][j]);\\n                \\n            }\\n        }\\n        return dp[n][0] >= 0;  // == for [0]\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 584846,
                "title": "python-recursive-fast-and-short-explained",
                "content": "```\\nclass Solution:\\n    def PredictTheWinner(self, nums: List[int]) -> bool:\\n        d = {}\\n        def h( l, r, p):\\n            if l == r:\\n                return p * nums[l]\\n            if (l,r) not in d:\\n                d[(l,r)]=p*max(nums[l] + p*h(l + 1, r, -p), nums[r] + p*h(l, r - 1, -p))\\n            return d[(l,r)]\\n        \\n        return h(0,len(nums)-1,1)>=0\\n```\\n\\nThis is a straighforward recursion with caching.\\n\\nWe start with defining a dictionary for caching results:\\n\\n```\\n        d = {}\\n```\\n\\nnow we define a recursive function:\\n\\n```\\n        def h( l, r, p):\\n```\\n\\nWe are going to pass left and right pointers `l` and `r` and `p` - stands for player. `1` for player 1 and `-1` for player 2.\\n\\nWe end recursion when `l==r`:\\n\\n```\\n            if l == r:\\n                return p * nums[l]\\n```\\n\\nOtherwise we recursively try two options: when the next player picks an item from the left side and from the right side of the list, save the result to the dictionary and return:\\n\\n```\\n            if (l,r) not in d:\\n                d[(l,r)]=p*max(nums[l] + p*h(l + 1, r, -p), nums[r] + p*h(l, r - 1, -p))\\n            return d[(l,r)]\\n```\\n\\nFinally, we call that function with the head and the tail of the list and player1\\'s first turn. the result >=0 means player 1 won, otherwise it\\'s player2:\\n\\n```\\n        return h(0,len(nums)-1,1)>=0\\n```\\n\\nCaching makes it fairly competitive. The hardest part is to write the recursive call properly:\\n\\n```\\n                d[(l,r)]=p*max(nums[l] + p*h(l + 1, r, -p), nums[r] + p*h(l, r - 1, -p))\\n```\\n\\nIt\\'s easy to miss one of the `p` multiplier, but if you think slowly, it makes sense.\\n\\nThank you!",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def PredictTheWinner(self, nums: List[int]) -> bool:\\n        d = {}\\n        def h( l, r, p):\\n            if l == r:\\n                return p * nums[l]\\n            if (l,r) not in d:\\n                d[(l,r)]=p*max(nums[l] + p*h(l + 1, r, -p), nums[r] + p*h(l, r - 1, -p))\\n            return d[(l,r)]\\n        \\n        return h(0,len(nums)-1,1)>=0\\n```\n```\\n        d = {}\\n```\n```\\n        def h( l, r, p):\\n```\n```\\n            if l == r:\\n                return p * nums[l]\\n```\n```\\n            if (l,r) not in d:\\n                d[(l,r)]=p*max(nums[l] + p*h(l + 1, r, -p), nums[r] + p*h(l, r - 1, -p))\\n            return d[(l,r)]\\n```\n```\\n        return h(0,len(nums)-1,1)>=0\\n```\n```\\n                d[(l,r)]=p*max(nums[l] + p*h(l + 1, r, -p), nums[r] + p*h(l, r - 1, -p))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 529789,
                "title": "python3-simple-dp-solution",
                "content": "```\\nclass Solution:\\n    def PredictTheWinner(self, nums: List[int]) -> bool:\\n        \"\"\"\\n        O(n^2) time complexity\\n        O(n) space complexity\\n        \"\"\"\\n        dp = [0]*len(nums)\\n        for i in range(len(nums) - 1, -1, -1):\\n            for j in range(i + 1, len(nums)):\\n                m, n = nums[i] - dp[j], nums[j] - dp[j - 1]\\n                dp[j] = max(m, n)\\n        return dp[-1] >= 0\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def PredictTheWinner(self, nums: List[int]) -> bool:\\n        \"\"\"\\n        O(n^2) time complexity\\n        O(n) space complexity\\n        \"\"\"\\n        dp = [0]*len(nums)\\n        for i in range(len(nums) - 1, -1, -1):\\n            for j in range(i + 1, len(nums)):\\n                m, n = nums[i] - dp[j], nums[j] - dp[j - 1]\\n                dp[j] = max(m, n)\\n        return dp[-1] >= 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 503145,
                "title": "c-recurrsion-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    bool predictTheWinner(int start,int end,int score1,int score2,vector<int> &numbs,int turn){\\n        //base case;\\n        if(start>end){\\n            return score1>=score2?true:false;\\n        }else{\\n            if(turn%2==0){\\n                return predictTheWinner(start+1,end,score1+numbs[start],score2,numbs,turn+1)||\\n                       predictTheWinner(start,end-1,score1+numbs[end],score2,numbs,turn+1);\\n            }else{\\n                return predictTheWinner(start+1,end,score1,score2+numbs[start],numbs,turn+1) &&\\n                        predictTheWinner(start,end-1,score1,score2+numbs[end],numbs,turn+1);\\n            }\\n        }\\n    }\\n    bool PredictTheWinner(vector<int>& nums) {\\n        if(nums.size()==1)\\n            return true;\\n        return predictTheWinner(0,nums.size()-1,0,0,nums,0);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool predictTheWinner(int start,int end,int score1,int score2,vector<int> &numbs,int turn){\\n        //base case;\\n        if(start>end){\\n            return score1>=score2?true:false;\\n        }else{\\n            if(turn%2==0){\\n                return predictTheWinner(start+1,end,score1+numbs[start],score2,numbs,turn+1)||\\n                       predictTheWinner(start,end-1,score1+numbs[end],score2,numbs,turn+1);\\n            }else{\\n                return predictTheWinner(start+1,end,score1,score2+numbs[start],numbs,turn+1) &&\\n                        predictTheWinner(start,end-1,score1,score2+numbs[end],numbs,turn+1);\\n            }\\n        }\\n    }\\n    bool PredictTheWinner(vector<int>& nums) {\\n        if(nums.size()==1)\\n            return true;\\n        return predictTheWinner(0,nums.size()-1,0,0,nums,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 452945,
                "title": "java-dp-100-code-with-explainantion-with-resource-which-explains-the-solution",
                "content": "[**Video explaination**](https://www.youtube.com/watch?v=3hNuefaICxw&list=PL7MU_yLLrmacD7i6WFz0AVL0lxWpAAR0q)\\nIt is highly recommended that you attempt to solve the problem after watching the video and not directly jump into the solution below. Only look at the solution, if you cannot come up with the solution.\\n\\n```\\nimport java.util.*;\\n\\n// 468 https://leetcode.com/problems/predict-the-winner/\\npublic class PrdictWinner {\\n    public boolean PredictTheWinner(int[] nums) {\\n        int n = nums.length;\\n\\n\\t\\t// If there is a single number or if there are even number of numbers, then player one always wins.\\n\\t\\t// See https://leetcode.com/problems/stone-game/\\n        if (n == 1 || n % 2 == 0) return true;\\n        \\n        // the table to store the intermediate results.\\n        int[][] dp = new int[n][n];\\n\\n        // initialise the dp table with -1\\n        for (int i = 0; i < n; i++) {\\n            Arrays.fill(dp[i], -1);\\n        }\\n\\n        // total score that is possible. The winner has to get more than half of this value to win.\\n        int totalScore = 0;\\n\\n        for (int num : nums) totalScore += num;\\n\\n        // The final score that player1 can score after considering all possible scenarios.\\n        int player1Score = score(nums, 0, n - 1, dp);\\n\\n        return player1Score > totalScore / 2;\\n    }\\n\\n    private int score(int[] nums, int i, int j, int[][] dp) {\\n        if (i > j) return 0;\\n        if (i == j) return nums[i];\\n\\n        if (dp[i][j] != -1) return dp[i][j];\\n\\n        // Player 1 has choosen nums[i].\\n        int scoreFromChoice1 = nums[i] + Math.min(score(nums, i + 2, j, dp), score(nums, i + 1, j - 1, dp));\\n        \\n        // Player 1 has choosen nums[j].\\n        int scoreFromChoice2 = nums[j] + Math.min(score(nums, i + 1, j - 1, dp), score(nums, i, j - 2, dp));\\n\\n        // The maximum of the two values will be the optimal solution\\n        dp[i][j] = Math.max(scoreFromChoice1, scoreFromChoice2);\\n        return dp[i][j];\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nimport java.util.*;\\n\\n// 468 https://leetcode.com/problems/predict-the-winner/\\npublic class PrdictWinner {\\n    public boolean PredictTheWinner(int[] nums) {\\n        int n = nums.length;\\n\\n\\t\\t// If there is a single number or if there are even number of numbers, then player one always wins.\\n\\t\\t// See https://leetcode.com/problems/stone-game/\\n        if (n == 1 || n % 2 == 0) return true;\\n        \\n        // the table to store the intermediate results.\\n        int[][] dp = new int[n][n];\\n\\n        // initialise the dp table with -1\\n        for (int i = 0; i < n; i++) {\\n            Arrays.fill(dp[i], -1);\\n        }\\n\\n        // total score that is possible. The winner has to get more than half of this value to win.\\n        int totalScore = 0;\\n\\n        for (int num : nums) totalScore += num;\\n\\n        // The final score that player1 can score after considering all possible scenarios.\\n        int player1Score = score(nums, 0, n - 1, dp);\\n\\n        return player1Score > totalScore / 2;\\n    }\\n\\n    private int score(int[] nums, int i, int j, int[][] dp) {\\n        if (i > j) return 0;\\n        if (i == j) return nums[i];\\n\\n        if (dp[i][j] != -1) return dp[i][j];\\n\\n        // Player 1 has choosen nums[i].\\n        int scoreFromChoice1 = nums[i] + Math.min(score(nums, i + 2, j, dp), score(nums, i + 1, j - 1, dp));\\n        \\n        // Player 1 has choosen nums[j].\\n        int scoreFromChoice2 = nums[j] + Math.min(score(nums, i + 1, j - 1, dp), score(nums, i, j - 2, dp));\\n\\n        // The maximum of the two values will be the optimal solution\\n        dp[i][j] = Math.max(scoreFromChoice1, scoreFromChoice2);\\n        return dp[i][j];\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 402794,
                "title": "486-predict-winner-2d-dp-and-1d-dp-c-beat-100-cpp",
                "content": "2D\\n```\\nclass Solution {\\npublic:\\n    bool PredictTheWinner(vector<int>& nums) {\\n        //dp[i][j] was supposed to be the difference of score of the current round\\'s first player\\'s\\n\\t\\t//and second player, once getting the dp[0][n-1], we check it is\\n        //positive or negative\\n        //dp[i][j] = max(nums[i] - dp[i+1][j], nums[j] - dp[i][j-1])\\n        int n = nums.size();\\n        if(n == 0) return false;\\n\\n        vector<vector<int>> dp(n, vector<int>(n));\\n        for(int i = 0; i<n; i++) dp[i][i] = nums[i];\\n\\n        for(int s = n-2; s >= 0; s--){ // you should start from rear to use the known value\\n            for(int e = s+1; e < n; e++){\\n                dp[s][e] = max(nums[s]-dp[s+1][e], nums[e]-dp[s][e-1]);\\n            }\\n        }\\n        return dp[0][n-1] >= 0;\\n    }\\n};\\n```\\n\\nThen it can be converted to 1D, because the dp[s][e] relys on the its previous dp[s][e-1] and the last column, i.e, dp[s+1][e], thus we\\nhave dp[e] = f(dp[e], dp[e-1]) = max(nums[s] - dp[e], nums[e] - dp[e-1])\\n```\\nclass Solution {\\npublic:\\n    bool PredictTheWinner(vector<int>& nums) {\\n        //dp[i][j] = max(nums[i] - dp[i+1][j], nums[j] - dp[i][j-1])\\n        int n = nums.size();\\n        if(n == 0) return false;\\n\\n        vector<int> dp(n, 0);\\n        for(int i = 0; i<n-2; i++) dp[i] = nums[i];\\n\\n        for(int s = n-2; s >= 0; s--){ // you should start from rear to use the known value\\n            for(int e = s+1; e < n; e++){\\n                dp[e] = max(nums[s]-dp[e], nums[e]-dp[e-1]);\\n            }\\n        }\\n        return dp[n-1] >= 0;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool PredictTheWinner(vector<int>& nums) {\\n        //dp[i][j] was supposed to be the difference of score of the current round\\'s first player\\'s\\n\\t\\t//and second player, once getting the dp[0][n-1], we check it is\\n        //positive or negative\\n        //dp[i][j] = max(nums[i] - dp[i+1][j], nums[j] - dp[i][j-1])\\n        int n = nums.size();\\n        if(n == 0) return false;\\n\\n        vector<vector<int>> dp(n, vector<int>(n));\\n        for(int i = 0; i<n; i++) dp[i][i] = nums[i];\\n\\n        for(int s = n-2; s >= 0; s--){ // you should start from rear to use the known value\\n            for(int e = s+1; e < n; e++){\\n                dp[s][e] = max(nums[s]-dp[s+1][e], nums[e]-dp[s][e-1]);\\n            }\\n        }\\n        return dp[0][n-1] >= 0;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool PredictTheWinner(vector<int>& nums) {\\n        //dp[i][j] = max(nums[i] - dp[i+1][j], nums[j] - dp[i][j-1])\\n        int n = nums.size();\\n        if(n == 0) return false;\\n\\n        vector<int> dp(n, 0);\\n        for(int i = 0; i<n-2; i++) dp[i] = nums[i];\\n\\n        for(int s = n-2; s >= 0; s--){ // you should start from rear to use the known value\\n            for(int e = s+1; e < n; e++){\\n                dp[e] = max(nums[s]-dp[e], nums[e]-dp[e-1]);\\n            }\\n        }\\n        return dp[n-1] >= 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 400506,
                "title": "java-beats-100-this-is-essentially-877-stone-game",
                "content": "Predict the winner\\nhttps://leetcode.com/problems/predict-the-winner\\n``` dp[i][j] = how much more the active player (the one who is chosen) can get from oppoent in the range of a[i..j], inclusive ```\\n\\n```\\nclass Solution {\\n    public boolean PredictTheWinner(int[] nums) {\\n        int n = nums.length;\\n        int[][] dp = new int[n][n];\\n       \\n        for (int i=0; i<n; i++) {\\n            dp[i][i] = nums[i];\\n        }\\n        \\n        for (int len = 1; len < n; len ++) {\\n            for (int i=0; i+len < n; i++) {\\n                dp[i][i+len] = Math.max(nums[i] - dp[i+1][i+len], \\n                                        nums[i+len] - dp[i][i+len-1]);\\n            }\\n        }\\n        return dp[0][n-1] >= 0;\\n    }\\n}\\n```\\n\\nStone Game\\nhttps://leetcode.com/problems/stone-game/\\n``` dp[i][j] = how much more the active player (the one who is chosen) can get from oppoent in the range of a[i..j], inclusive ```\\n```\\npublic boolean stoneGame(int[] piles) {\\n        int n = piles.length;\\n        int[][] dp = new int[n][n];\\n        for (int i=0; i<piles.length; i++) {\\n            piles[i] = i;\\n        }\\n        for (int len=1; len <= n; len ++) {\\n            for (int i = 0; i+len < n; i ++) {\\n                dp[i][i+len] = Math.max(piles[i]- dp[i+1][i+len], piles[i+len] - dp[i][i+len-1]);\\n            }\\n        }\\n        return dp[0][n-1] > 0;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "``` dp[i][j] = how much more the active player (the one who is chosen) can get from oppoent in the range of a[i..j], inclusive ```\n```\\nclass Solution {\\n    public boolean PredictTheWinner(int[] nums) {\\n        int n = nums.length;\\n        int[][] dp = new int[n][n];\\n       \\n        for (int i=0; i<n; i++) {\\n            dp[i][i] = nums[i];\\n        }\\n        \\n        for (int len = 1; len < n; len ++) {\\n            for (int i=0; i+len < n; i++) {\\n                dp[i][i+len] = Math.max(nums[i] - dp[i+1][i+len], \\n                                        nums[i+len] - dp[i][i+len-1]);\\n            }\\n        }\\n        return dp[0][n-1] >= 0;\\n    }\\n}\\n```\n``` dp[i][j] = how much more the active player (the one who is chosen) can get from oppoent in the range of a[i..j], inclusive ```\n```\\npublic boolean stoneGame(int[] piles) {\\n        int n = piles.length;\\n        int[][] dp = new int[n][n];\\n        for (int i=0; i<piles.length; i++) {\\n            piles[i] = i;\\n        }\\n        for (int len=1; len <= n; len ++) {\\n            for (int i = 0; i+len < n; i ++) {\\n                dp[i][i+len] = Math.max(piles[i]- dp[i+1][i+len], piles[i+len] - dp[i][i+len-1]);\\n            }\\n        }\\n        return dp[0][n-1] > 0;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 184636,
                "title": "math-solution-beat-100-o-1-space-o-n-time-proved-wrong",
                "content": "If there is only one element, player 1 must win. \n\nIf there is even number sequence of elements, player 1 compare the sum of even index and the sum of odd index and pick the bigger one, then player 1 must win. Because once player 1 decide to pick the odd/even index number player2 cannot make any difference.\n\nIf there is odd number of elements, player 2 is involved only in this case. Player 1 pick nums[0] or nums[-1], then rest is an even number sequence of elemnts. So Player 2 have the right to make decision to get the bigger sum from the sum of even index and the sum of odd index in the rest. So if Player 1 wants to win, his first num plus the smaller sum in the rest sequence must be bigger than the bigger sum in the rest sequence.\n\n\n```\nclass Solution:\n    def PredictTheWinner(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        if len(nums) == 1 or len(nums)%2 == 0: \n            return True\n        if len(nums)%2 == 1:\n            sum1 = sum(nums[::2])\n            sum2 = sum(nums[1::2])\n            pick_start = min(sum1-nums[0],sum2)+nums[0]>max(sum1-nums[0],sum2)\n            pick_end = min(sum1-nums[-1],sum2)+nums[-1]>max(sum1-nums[0],sum2)\n            return pick_start or pick_end\n```",
                "solutionTags": [],
                "code": "```\nclass Solution:\n    def PredictTheWinner(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        if len(nums) == 1 or len(nums)%2 == 0: \n            return True\n        if len(nums)%2 == 1:\n            sum1 = sum(nums[::2])\n            sum2 = sum(nums[1::2])\n            pick_start = min(sum1-nums[0],sum2)+nums[0]>max(sum1-nums[0],sum2)\n            pick_end = min(sum1-nums[-1],sum2)+nums[-1]>max(sum1-nums[0],sum2)\n            return pick_start or pick_end\n```",
                "codeTag": "Java"
            },
            {
                "id": 178250,
                "title": "python-solution",
                "content": "O(n ** 2) time O(n ** 2) space Dynamic Programming top-down (memoization):\\n```\\nclass Solution(object):\\n    def PredictTheWinner(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        def helper(nums, i, j):\\n            if i > j:\\n                return 0, 0\\n            elif i == j:\\n                return nums[i], 0\\n            if (i, j) in rec:\\n                return rec[(i, j)]\\n            p2h, p1h = helper(nums, i+1, j)\\n            p1h += nums[i]\\n            p2t, p1t = helper(nums, i, j-1)\\n            p1t += nums[j]\\n            if p1h >= p1t:\\n                rec[(i, j)] = (p1h, p2h)\\n                return p1h, p2h\\n            else:\\n                rec[(i, j)] = (p1t, p2t)\\n                return p1t, p2t\\n        \\n        rec = {}\\n        p1, p2 = helper(nums, 0, len(nums)-1)\\n        return p1 >= p2\\n```\\nO(n ** 2) time O(n ** 2) space Dynamic Programming bottom-up:\\n```\\nclass Solution(object):\\n    def PredictTheWinner(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        dp = [[0] * len(nums) for _ in range(len(nums))]\\n        for l in range(1, len(nums)+1):\\n            for i in range(len(nums)-l+1):\\n                j = i+l-1\\n                if i == j:\\n                    dp[i][j] = nums[i]\\n                else:\\n                    a = nums[i] - dp[i+1][j]\\n                    b = nums[j] - dp[i][j-1]\\n                    dp[i][j] = max(a, b)\\n        return dp[0][len(nums)-1] >= 0\\n```\\nO(n ** 2) time O(n) space Dynamic Programming bottom-up:\\n```\\nclass Solution(object):\\n    def PredictTheWinner(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        dp = [0] * len(nums) \\n        for l in range(1, len(nums)+1):\\n            for i in range(len(nums)-l+1):\\n                j = i+l-1\\n                if i == j:\\n                    dp[i] = nums[i]\\n                else:\\n                    a = nums[i] - dp[i+1]\\n                    b = nums[j] - dp[i]\\n                    dp[i] = max(a, b)\\n        return dp[0] >= 0 \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def PredictTheWinner(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        def helper(nums, i, j):\\n            if i > j:\\n                return 0, 0\\n            elif i == j:\\n                return nums[i], 0\\n            if (i, j) in rec:\\n                return rec[(i, j)]\\n            p2h, p1h = helper(nums, i+1, j)\\n            p1h += nums[i]\\n            p2t, p1t = helper(nums, i, j-1)\\n            p1t += nums[j]\\n            if p1h >= p1t:\\n                rec[(i, j)] = (p1h, p2h)\\n                return p1h, p2h\\n            else:\\n                rec[(i, j)] = (p1t, p2t)\\n                return p1t, p2t\\n        \\n        rec = {}\\n        p1, p2 = helper(nums, 0, len(nums)-1)\\n        return p1 >= p2\\n```\n```\\nclass Solution(object):\\n    def PredictTheWinner(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        dp = [[0] * len(nums) for _ in range(len(nums))]\\n        for l in range(1, len(nums)+1):\\n            for i in range(len(nums)-l+1):\\n                j = i+l-1\\n                if i == j:\\n                    dp[i][j] = nums[i]\\n                else:\\n                    a = nums[i] - dp[i+1][j]\\n                    b = nums[j] - dp[i][j-1]\\n                    dp[i][j] = max(a, b)\\n        return dp[0][len(nums)-1] >= 0\\n```\n```\\nclass Solution(object):\\n    def PredictTheWinner(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        dp = [0] * len(nums) \\n        for l in range(1, len(nums)+1):\\n            for i in range(len(nums)-l+1):\\n                j = i+l-1\\n                if i == j:\\n                    dp[i] = nums[i]\\n                else:\\n                    a = nums[i] - dp[i+1]\\n                    b = nums[j] - dp[i]\\n                    dp[i] = max(a, b)\\n        return dp[0] >= 0 \\n```",
                "codeTag": "Java"
            },
            {
                "id": 169946,
                "title": "easy-understand-python-dp-solution-beat-100",
                "content": "Here `f[i][j]` denotes the max delta in score with wich player 1 can exceed the player 2 given the scores from index `i` to index `j` (both inclusive).\\n```\\nclass Solution(object):\\n    def PredictTheWinner(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        n = len(nums)\\n        if n % 2 == 0 or n < 3:\\n            return True\\n        f = [[0 for _ in range(n)] for _ in range(n)]\\n        \\n        for i in range(n):\\n            f[i][i] = nums[i]\\n            if i < n-1:\\n                f[i][i+1] = abs(nums[i+1] - nums[i])\\n        for l in range(3, n+1):\\n            for i in range(n-l+1):\\n                f[i][i+l-1] = max(nums[i] - f[i+1][i+l-1], nums[i+l-1] - f[i][i+l-2])\\n        return f[0][n-1] >= 0\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def PredictTheWinner(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        n = len(nums)\\n        if n % 2 == 0 or n < 3:\\n            return True\\n        f = [[0 for _ in range(n)] for _ in range(n)]\\n        \\n        for i in range(n):\\n            f[i][i] = nums[i]\\n            if i < n-1:\\n                f[i][i+1] = abs(nums[i+1] - nums[i])\\n        for l in range(3, n+1):\\n            for i in range(n-l+1):\\n                f[i][i+l-1] = max(nums[i] - f[i+1][i+l-1], nums[i+l-1] - f[i][i+l-2])\\n        return f[0][n-1] >= 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 136895,
                "title": "a-simple-c-solution-accepted",
                "content": "```\\nbool PredictTheWinner(int* nums, int numsSize) {\\n    if(numsSize==1){\\n        return true;\\n    }\\n    int player1=0;\\n    int player2=0;\\n    int sum=0;\\n    for(int i=0;i<numsSize;i++){\\n        sum+=nums[i];\\n    }\\n    int temp1=nums[0]+score(&nums[1],numsSize-1,2);\\n    int temp2=nums[numsSize-1]+score(nums,numsSize-1,2);\\n    player1=temp1>temp2?temp1:temp2;\\n    player2=sum-player1;\\n    return player1>=player2;\\n}\\nint score(int* nums, int numsSize,int flag){\\n    if(numsSize==0){\\n        return 0;\\n    }\\n    int temp1=0;\\n    int temp2=0;\\n    int ret=0;\\n    if(flag==2){\\n        temp1=score(&nums[1],numsSize-1,1);\\n        temp2=score(nums,numsSize-1,1);\\n        ret=temp1<temp2?temp1:temp2;\\n    }else if(flag==1){\\n        temp1=nums[0]+score(&nums[1],numsSize-1,2);\\n        temp2=nums[numsSize-1]+score(nums,numsSize-1,2);\\n        ret=temp1>temp2?temp1:temp2;\\n    }\\n    return ret;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nbool PredictTheWinner(int* nums, int numsSize) {\\n    if(numsSize==1){\\n        return true;\\n    }\\n    int player1=0;\\n    int player2=0;\\n    int sum=0;\\n    for(int i=0;i<numsSize;i++){\\n        sum+=nums[i];\\n    }\\n    int temp1=nums[0]+score(&nums[1],numsSize-1,2);\\n    int temp2=nums[numsSize-1]+score(nums,numsSize-1,2);\\n    player1=temp1>temp2?temp1:temp2;\\n    player2=sum-player1;\\n    return player1>=player2;\\n}\\nint score(int* nums, int numsSize,int flag){\\n    if(numsSize==0){\\n        return 0;\\n    }\\n    int temp1=0;\\n    int temp2=0;\\n    int ret=0;\\n    if(flag==2){\\n        temp1=score(&nums[1],numsSize-1,1);\\n        temp2=score(nums,numsSize-1,1);\\n        ret=temp1<temp2?temp1:temp2;\\n    }else if(flag==1){\\n        temp1=nums[0]+score(&nums[1],numsSize-1,2);\\n        temp2=nums[numsSize-1]+score(nums,numsSize-1,2);\\n        ret=temp1>temp2?temp1:temp2;\\n    }\\n    return ret;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 96831,
                "title": "python-61ms-dp-solution-with-explanation",
                "content": "**The core thought of my solution is as follows:**\\n1. Assume the array is \\n[a<sub>1</sub>, a<sub>2</sub>, a<sub>3</sub>, ..., a<sub>k</sub>] ----- \\u2460\\n2. Player1 picks a<sub>1</sub> or a<sub>k</sub>\\n3. Player2 picks from\\n[a<sub>2</sub>, a<sub>3</sub>, ..., a<sub>k</sub>] ----- \\u2461\\nor \\n[a<sub>1</sub>, a<sub>2</sub>, ..., a<sub>k-1</sub>] ----- \\u2462\\n\\nSo here comes the sub question, assume we have known the player1's best strategy, when he faced array\\u2461 or array\\u2462. It's easy to find player2 will do what player1 did, because player2 want to win the game too, and he can't find a better strategy.\\n\\n**Now, we can describe the top-down process:**\\n1. Player1 has two choice:\\ns<sub>1</sub> = a<sub>1</sub> + [player2's strategy when beginning array is \\u2461(because player1's strategy would be use by plalyer2 with beginning array is \\u2460)]\\nor\\ns<sub>2</sub> = a<sub>k</sub> + [player2's strategy when beginning array is\\u2462]\\nwhat he finally choice is:\\ns = max(s<sub>1</sub>, s<sub>2</sub>)\\nbecause he wants win the game, he need the higher score.\\n2. Player2's choice is depend on player1, he has no choice:\\nif s<sub>1</sub> > s<sub>2</sub>:\\nrs = player1's strategy when beginning array is \\u2461\\nelse:\\nrs = player1's strategy when beginning array is \\u2462\\n\\nI used a bottom-up method to write the codes, first compute the score when length of numbers is 2, then 3, then 4...\\n```\\nclass Solution:\\n    def PredictTheWinner(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        n = len(nums)\\n        # initialize a n*n*2 matrix, dp[i][k][0] means \\n        # for beginning array nums[i:k+1], player1's score, \\n        # and dp[i][k][1] means player2's.\\n        dp = [[[0 for state in range(2)] for i in range(n)] for j in range(n)]\\n        for i in range(n):\\n            dp[i][i][0] = nums[i]\\n        for i in range(1, n):\\n            #internal from 1 to n-1\\n            for k in range(n-i):\\n                # two strategies of player1\\n                p1_1 = nums[k]+dp[k+1][k+i][1]\\n                p1_2 = nums[k+i]+dp[k][k+i-1][1]\\n                if p1_1 > p1_2:\\n                    dp[k][k+i][0] = p1_1\\n                    dp[k][k+i][1] = dp[k+1][k+i][0]\\n                else:\\n                    dp[k][k+i][0] = p1_2\\n                    dp[k][k+i][1] = dp[k][k+i-1][0]\\n        # player1 win the game if the got the same scores.\\n        return dp[0][n-1][0] >= dp[0][n-1][1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def PredictTheWinner(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        n = len(nums)\\n        # initialize a n*n*2 matrix, dp[i][k][0] means \\n        # for beginning array nums[i:k+1], player1's score, \\n        # and dp[i][k][1] means player2's.\\n        dp = [[[0 for state in range(2)] for i in range(n)] for j in range(n)]\\n        for i in range(n):\\n            dp[i][i][0] = nums[i]\\n        for i in range(1, n):\\n            #internal from 1 to n-1\\n            for k in range(n-i):\\n                # two strategies of player1\\n                p1_1 = nums[k]+dp[k+1][k+i][1]\\n                p1_2 = nums[k+i]+dp[k][k+i-1][1]\\n                if p1_1 > p1_2:\\n                    dp[k][k+i][0] = p1_1\\n                    dp[k][k+i][1] = dp[k+1][k+i][0]\\n                else:\\n                    dp[k][k+i][0] = p1_2\\n                    dp[k][k+i][1] = dp[k][k+i-1][0]\\n        # player1 win the game if the got the same scores.\\n        return dp[0][n-1][0] >= dp[0][n-1][1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 96877,
                "title": "java-dp-solutions-with-o-n-2-and-o-n-space",
                "content": "dp[i][j] is the maximum gain (or minimum loss) of a player who picks first from the numbers indexed from i to j. dp[i][i] is initialized with the input numbers. The update relation is \\n```\\ndp[i][j] = Math.max(nums[j] - dp[i][j-1],  \\\\\\\\picks j first\\n                    nums[i] - dp[i+1][j]); \\\\\\\\picks i first\\n```\\ndp[0][n-1] will be the final gain of player 1. Space complexity is O(N^2). \\n\\n```\\npublic class Solution {\\n    public boolean PredictTheWinner(int[] nums) {\\n        if(nums == null || nums.length == 0) {\\n            return true;\\n        }\\n        \\n        int n = nums.length;\\n        \\n        //space O(n^2) solution:\\n        int dp[][] = new int[n][n];\\n        \\n        for(int i = 0; i < n; i++) {\\n            dp[i][i] = nums[i];\\n        }\\n        \\n        for(int len = 1; len < n; len++) {\\n            for(int i = 0; i < n - len; i++) {\\n                int j = i + len;\\n                dp[i][j] = Math.max(nums[j] - dp[i][j-1], nums[i] - dp[i+1][j]);\\n            }\\n        }\\n        \\n        return dp[0][n-1] >= 0;\\n    }\\n}\\n```\\n\\nThe space complexity can be reduced to O(N). dp[i] represents the maximum gain (or minimum loss) of a player who picks first from the numbers indexed from i to i+len. Initially, when len is 0, dp[i] is the input numbers. The update relation is \\n```\\ndp[i] = Math.max(nums[i] - dp[i+1], nums[i+len] - dp[i]); \\n```\\nThe old dp[] is the gain with length equal to len-1. Player can either pick i first, or pick i+len first.\\nAfter len increases to n-1, dp[0] will be the final gain of player 1. \\n\\n```\\npublic class Solution {\\n    public boolean PredictTheWinner(int[] nums) {\\n        if(nums == null || nums.length == 0) {\\n            return true;\\n        }\\n        \\n        int n = nums.length;\\n        \\n        //space O(n) solution:\\n        int dp[] = Arrays.copyOf(nums, n);\\n        \\n        for(int len = 1; len < n; len++) {\\n            for(int i = 0; i < n - len; i++) {\\n                dp[i] = Math.max(nums[i] - dp[i+1], nums[i+len] - dp[i]);\\n            }\\n        }\\n        return dp[0] >= 0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\ndp[i][j] = Math.max(nums[j] - dp[i][j-1],  \\\\\\\\picks j first\\n                    nums[i] - dp[i+1][j]); \\\\\\\\picks i first\\n```\n```\\npublic class Solution {\\n    public boolean PredictTheWinner(int[] nums) {\\n        if(nums == null || nums.length == 0) {\\n            return true;\\n        }\\n        \\n        int n = nums.length;\\n        \\n        //space O(n^2) solution:\\n        int dp[][] = new int[n][n];\\n        \\n        for(int i = 0; i < n; i++) {\\n            dp[i][i] = nums[i];\\n        }\\n        \\n        for(int len = 1; len < n; len++) {\\n            for(int i = 0; i < n - len; i++) {\\n                int j = i + len;\\n                dp[i][j] = Math.max(nums[j] - dp[i][j-1], nums[i] - dp[i+1][j]);\\n            }\\n        }\\n        \\n        return dp[0][n-1] >= 0;\\n    }\\n}\\n```\n```\\ndp[i] = Math.max(nums[i] - dp[i+1], nums[i+len] - dp[i]); \\n```\n```\\npublic class Solution {\\n    public boolean PredictTheWinner(int[] nums) {\\n        if(nums == null || nums.length == 0) {\\n            return true;\\n        }\\n        \\n        int n = nums.length;\\n        \\n        //space O(n) solution:\\n        int dp[] = Arrays.copyOf(nums, n);\\n        \\n        for(int len = 1; len < n; len++) {\\n            for(int i = 0; i < n - len; i++) {\\n                dp[i] = Math.max(nums[i] - dp[i+1], nums[i+len] - dp[i]);\\n            }\\n        }\\n        return dp[0] >= 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 96879,
                "title": "python-solution-with-detailed-explanation",
                "content": "**Solution**\\n\\n**Predict the Winner** https://leetcode.com/problems/predict-the-winner/\\n\\n**Memoization**\\n* We will compute score(i,j) which represents the maximum score that can be acheived by the first player for the input array between i and j. Then we can compute the score(0,N-1) and if this score is more than half the sum of full array, we would have won the game.\\n* How do we compute score(i,j)? We have two options - either to choose i or choose j.\\n* x = sum(nums,i,j)\\n* c1 = choosing i = nums[i]+sum(nums, i+1,j)-score(i+1,j): choose nums[i] and then add the remainder sum minus the score the opponent makes.\\n* c2 = choosing j = nums[j]+sum(nums, i,j-1)-score(i,j-1): choose nums[j] and then add the remainder sum minus the score the opponent makes.\\n* score(i,j) = max(c1, c2)\\n* Note x = nums[i]+sum(nums, i+1,j) = nums[j]+sum(nums, i,j-1). c1 = x-score(i+1,j). c2= x-score(i,j-1).\\n\\n```\\nfrom collections import defaultdict\\nclass Solution(object):\\n    def score(self, i, j, nums, cums, cache):\\n        if i > j:\\n            return 0\\n        elif i in cache and j in cache[j]:\\n            return cache[i][j]\\n        elif i == j:\\n            cache[i][j] = nums[i]\\n        else:\\n            x = cums[j]-cums[i]+nums[i]\\n            cache[i][j] = max(x-self.score(i+1,j, nums, cums, cache), x-self.score(i,j-1, nums, cums, cache))\\n        return cache[i][j]\\n    \\n    def PredictTheWinner(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        cums, cache = [nums[0]], defaultdict(dict)\\n        for i in range(1, len(nums)):\\n            cums.append(cums[-1]+nums[i])\\n        max_score = self.score(0, len(nums)-1, nums, cums, cache)\\n        return max_score >= cums[-1]/2.\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import defaultdict\\nclass Solution(object):\\n    def score(self, i, j, nums, cums, cache):\\n        if i > j:\\n            return 0\\n        elif i in cache and j in cache[j]:\\n            return cache[i][j]\\n        elif i == j:\\n            cache[i][j] = nums[i]\\n        else:\\n            x = cums[j]-cums[i]+nums[i]\\n            cache[i][j] = max(x-self.score(i+1,j, nums, cums, cache), x-self.score(i,j-1, nums, cums, cache))\\n        return cache[i][j]\\n    \\n    def PredictTheWinner(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        cums, cache = [nums[0]], defaultdict(dict)\\n        for i in range(1, len(nums)):\\n            cums.append(cums[-1]+nums[i])\\n        max_score = self.score(0, len(nums)-1, nums, cums, cache)\\n        return max_score >= cums[-1]/2.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3842540,
                "title": "c-best-explanation-step-by-step-in-hindi",
                "content": "dekho hamare pas kya option hai ki ham ya to starting index ko choose kare ya fir last index ko ..okk\\n\\nchalo man liye ham abhi first wala index choose kar rahe hai okk....to next move hamare against wale player ka hoga to wo v best lena chahega or mujhe minimum dega now uske pas do option hai choose karne ka ya to wo i+1 wale element ko choose karega ya fir j-1 wale ko to yaha se kyarecurrence relation bana \\n\\n option 1=num[i]+min(solve(i+2,j),solve(i+1,j-1))\\n\\n\\n\\nsimilarly jab ham last wale ko choose karege then uske liye kya option bacha hai ya to wo i wale element ko choose karega ya fir j-2 wale ko then mere liye wo minimum chhodega isliye yahan se kya recurrence relation banega \\n\\noption 2=nums[j]+min(solve(i+1,j-2),solve(i,j-2));\\n\\n\\nor fir ham dono option me se max ko le lege to ye function mera maximum score de dega \\n\\nnow totalscore nikal lege and usme se hm apna maximum score subtract karege or dekhege ki agar ye mere opposite player se jyada hai then return true;\\nnahi to false\\n\\n\\n\\nclass Solution {\\npublic:\\nint solve(int i,int j,vector<int>&nums){\\n    if(i>j)\\n    return 0;\\n    if(i>=nums.size() || j<0 )\\n    return 0;\\n    int op1=nums[i]+min(solve(i+2,j,nums),solve(i+1,j-1,nums));\\n    int op2=nums[j]+min(solve(i+1,j-1,nums),solve(i,j-2,nums));\\n    return max(op1,op2);\\n}\\n    bool PredictTheWinner(vector<int>& nums) {\\n        int maxscore= solve(0,nums.size()-1,nums);\\n        int totalscore=accumulate(nums.begin(),nums.end(),0);\\n        if(totalscore-maxscore>maxscore)\\n        return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\nint solve(int i,int j,vector<int>&nums){\\n    if(i>j)\\n    return 0;\\n    if(i>=nums.size() || j<0 )\\n    return 0;\\n    int op1=nums[i]+min(solve(i+2,j,nums),solve(i+1,j-1,nums));\\n    int op2=nums[j]+min(solve(i+1,j-1,nums),solve(i,j-2,nums));\\n    return max(op1,op2);\\n}",
                "codeTag": "Java"
            },
            {
                "id": 3834690,
                "title": "java-code-with-explanation-easy-to-understand-recursion",
                "content": "# Intuition\\n\\n The intuition of the problem is to find whether the player1 can win or not. The player1 will always starts first. I just use the brute force approach(recursion) to solve this problem.\\n\\n# Approach\\nHere we can use variables in the function such as:\\n\\n1. i->start index\\n2. j->end index\\n  (we need to keep track of both end of the array, because each time player will choose any one element from either sides of the array.)\\n3. s1->player1 score(initialy 0)\\n4. s2->player2 score(initialy 0)\\n5. chance->to keep track of which player need to select(player\\'s turn)\\n\\n**Step 1**\\n    in the first step, we need check whether player 1 needs to play or player 2 needs to play(we check this using \\'chance\\' variable in the function parameter).\\n\\n---\\n\\n**Step 2**\\n  -in next step there are two possibility that a player can choose either value at \\'start index\\' or at \\'end index\\'.\\n    - So we create two boolean variable for both the chance that a player can select. We will add the selected value(i,e from either start or end) to the score of respective player.\\n    - Based on the player we send the result value\\n1. if it is player1, we use || because we considered that player 1 can win even if he has atleast one chance(because we want to find whether player 1 can win)\\n2.  if it is player2, we use && because we considered that player 2 can win only when he has chance to win in both.\\n\\n---\\n\\n**Changes done in every recursive call**\\n    1.chance->chance of the player need to be changed each time\\n    2.start->if we choose start index(i+1)\\n    3.end->if we choose last indes(j-1)\\n    4.we also need to update the score in respective player\\'s score(in s1 or s2)\\n\\n---\\n\\n**Base Condition**\\n    When the array is completed(i.e all the elements score are updated in the players score) we need to compare score1 and score2(marks of players), \\n    1.If player 1 score high mark we would win\\n    2.Otherwise player 2 would win.\\n\\n---\\n\\n\\n\\n\\n# Time and Space Used\\n- Runtime : 95ms\\n\\n- Memory : 39.72mb\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean PredictTheWinner(int[] nums) {\\n          return check(nums,0,nums.length-1,0,0,1);\\n    }\\n    public static boolean check(int []ar, int i, int j, int s1, int s2, int chance)\\n    {\\n        if(i>j)\\n            return s1>=s2?true:false;\\n        if(i==j)\\n        {\\n            if(chance==1)\\n                return check(ar, i+1, j, s1+ar[i], s2, 2);\\n            else\\n                return check(ar, i+1, j, s1, s2+ar[i], 1);\\n        }\\n        boolean a=false, b=false;\\n        if(chance==1)\\n        {\\n            a=check(ar,i+1,j,s1+ar[i],s2,2);\\n            b=check(ar,i,j-1,s1+ar[j],s2,2);\\n            return a || b;\\n        }\\n        else\\n        {\\n            a=check(ar,i+1,j,s1,s2+ar[i],1);\\n            b=check(ar,i,j-1,s1,s2+ar[j],1);\\n            return a && b;\\n        }\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean PredictTheWinner(int[] nums) {\\n          return check(nums,0,nums.length-1,0,0,1);\\n    }\\n    public static boolean check(int []ar, int i, int j, int s1, int s2, int chance)\\n    {\\n        if(i>j)\\n            return s1>=s2?true:false;\\n        if(i==j)\\n        {\\n            if(chance==1)\\n                return check(ar, i+1, j, s1+ar[i], s2, 2);\\n            else\\n                return check(ar, i+1, j, s1, s2+ar[i], 1);\\n        }\\n        boolean a=false, b=false;\\n        if(chance==1)\\n        {\\n            a=check(ar,i+1,j,s1+ar[i],s2,2);\\n            b=check(ar,i,j-1,s1+ar[j],s2,2);\\n            return a || b;\\n        }\\n        else\\n        {\\n            a=check(ar,i+1,j,s1,s2+ar[i],1);\\n            b=check(ar,i,j-1,s1,s2+ar[j],1);\\n            return a && b;\\n        }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3831190,
                "title": "2-approaches-took-me-a-while-to-understand",
                "content": "# Intuition\\n> In game theory, there is no such thing as a free lunch. Every decision you make has a cost, and you need to weigh the costs and benefits before you make a move.\\n\\n# Approach 1:\\nCalculate the max difference. The game starts from player 1. At each state player 1 wants to maximize the score difference with player 2.\\n```\\n                                  (i, j)\\n                                /       \\\\\\n                            (i+1, j)    (i, j-1)\\n                            /       \\\\   /       \\\\\\n                       (i+2, j)   (i+1, j-1)    (i, j-2)\\n\\nf(i, j) = max[{n[i] - f(i+1, j)}, {n[j] - f(i, j-1)}];\\n\\n```\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n^2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n``` java []\\nclass Solution {\\n    public boolean PredictTheWinner(int[] nums) {\\n        // calculate difference\\n        int n = nums.length;\\n        int[][] memo = new int[n][n];\\n        for(int i=0; i<n; i++) {\\n            Arrays.fill(memo[i], Integer.MIN_VALUE);\\n        }\\n        // player 1 wishes to maximize the score difference with player 2\\n        int diff = maxDiff(0, n-1, nums, memo);\\n        return diff >= 0;\\n    }\\n\\n    int maxDiff(int i, int j, int[] nums, int[][] memo) {\\n        if(i>j) {\\n            return 0;\\n        }\\n        if(memo[i][j]!=Integer.MIN_VALUE) {\\n            return memo[i][j];\\n        }\\n        int take_i = nums[i] - maxDiff(i+1, j, nums, memo);\\n        int take_j = nums[j] - maxDiff(i, j-1, nums, memo);\\n        return memo[i][j] = Math.max(take_i, take_j);\\n    }\\n}\\n```\\n\\n# Approach 2:\\nPlay from player 1\\'s perspective. Player 2 plays optimally. So, expect the least after player 2\\'s turn.\\n\\nWe are concerned with player 1\\'s points. So, our function will look like this:\\n\\n```\\nX(i, j) = num[i] + min[X(i+2, j), X(i+1, j-1)]\\nY(i, j) = nums[j] + min[Y(i, j-2), Y(i+1, j-1)]\\n\\nf(i, j) = max(X(i, j), Y(i, j))\\n```\\nif player 1 takes (i, j), then player 2 will be able to take `(i+1, j)` or, `(i, j-1)`. Whatever player 2 chooses, he will choose optimally. So, if he chooses:\\n- `(i+1, j)` => I\\'ll have options to choose from:\\n    - `(i+2, j)` or,\\n    - `(i+1, j-1)`\\n\\nBut as he chooses optimally, I should expect the minimum score from those states.\\n\\nAgain, if he chooses:\\n- `(i, j-1)` => I\\'ll have options to choose from:\\n    - `(i, j-2)` or,\\n    - `(i+1, j-1)`\\n\\nEven though I expect the minimum from these two options, I will choose the max from my them.\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n^2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n``` java []\\nclass Solution {\\n    public boolean PredictTheWinner(int[] nums) {\\n        // calculate difference\\n        int n = nums.length;\\n        int[][] memo = new int[n][n];\\n        int totalScore = 0;\\n        for(int i=0; i<n; i++) {\\n            Arrays.fill(memo[i], -1);\\n            totalScore+=nums[i];\\n        }\\n        int p1Score = getScore(0, n-1, nums, memo);\\n        return p1Score >= totalScore - p1Score;\\n    }\\n\\n    int getScore(int i, int j, int[] nums, int[][] memo) {\\n        if(i>j) {\\n            return 0;\\n        }\\n        if(memo[i][j]!=-1) {\\n            return memo[i][j];\\n        }\\n        // if I take i, then p2 will be able to take (i+1,j) or, (i, j-1).\\n        // He will choose optimally, so, if he chooses (i+1, j) => I\\'ll have options\\n        // to choose from (i+2, j) or (i+1,j-1).\\n        // But as he chooses optimally, I should expect the minimum score from those states\\n        int take_i = nums[i] + Math.min(getScore(i+2, j, nums, memo), getScore(i+1, j-1, nums, memo));\\n        // Now, if he chooses (i, j-1) => I\\'ll have options\\n        // to choose from (i+1, j-1) or (i,j-2).\\n        // But as he chooses optimally, I should expect the minimum score from those states\\n        int take_j = nums[j] + Math.min(getScore(i, j-2, nums, memo), getScore(i+1, j-1, nums, memo));\\n\\n        // even though I expect the minimum from the upcoming states,\\n        // I will choose the max from my current states.\\n        return memo[i][j] = Math.max(take_i, take_j);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Game Theory"
                ],
                "code": "```\\n                                  (i, j)\\n                                /       \\\\\\n                            (i+1, j)    (i, j-1)\\n                            /       \\\\   /       \\\\\\n                       (i+2, j)   (i+1, j-1)    (i, j-2)\\n\\nf(i, j) = max[{n[i] - f(i+1, j)}, {n[j] - f(i, j-1)}];\\n\\n```\n``` java []\\nclass Solution {\\n    public boolean PredictTheWinner(int[] nums) {\\n        // calculate difference\\n        int n = nums.length;\\n        int[][] memo = new int[n][n];\\n        for(int i=0; i<n; i++) {\\n            Arrays.fill(memo[i], Integer.MIN_VALUE);\\n        }\\n        // player 1 wishes to maximize the score difference with player 2\\n        int diff = maxDiff(0, n-1, nums, memo);\\n        return diff >= 0;\\n    }\\n\\n    int maxDiff(int i, int j, int[] nums, int[][] memo) {\\n        if(i>j) {\\n            return 0;\\n        }\\n        if(memo[i][j]!=Integer.MIN_VALUE) {\\n            return memo[i][j];\\n        }\\n        int take_i = nums[i] - maxDiff(i+1, j, nums, memo);\\n        int take_j = nums[j] - maxDiff(i, j-1, nums, memo);\\n        return memo[i][j] = Math.max(take_i, take_j);\\n    }\\n}\\n```\n```\\nX(i, j) = num[i] + min[X(i+2, j), X(i+1, j-1)]\\nY(i, j) = nums[j] + min[Y(i, j-2), Y(i+1, j-1)]\\n\\nf(i, j) = max(X(i, j), Y(i, j))\\n```\n``` java []\\nclass Solution {\\n    public boolean PredictTheWinner(int[] nums) {\\n        // calculate difference\\n        int n = nums.length;\\n        int[][] memo = new int[n][n];\\n        int totalScore = 0;\\n        for(int i=0; i<n; i++) {\\n            Arrays.fill(memo[i], -1);\\n            totalScore+=nums[i];\\n        }\\n        int p1Score = getScore(0, n-1, nums, memo);\\n        return p1Score >= totalScore - p1Score;\\n    }\\n\\n    int getScore(int i, int j, int[] nums, int[][] memo) {\\n        if(i>j) {\\n            return 0;\\n        }\\n        if(memo[i][j]!=-1) {\\n            return memo[i][j];\\n        }\\n        // if I take i, then p2 will be able to take (i+1,j) or, (i, j-1).\\n        // He will choose optimally, so, if he chooses (i+1, j) => I\\'ll have options\\n        // to choose from (i+2, j) or (i+1,j-1).\\n        // But as he chooses optimally, I should expect the minimum score from those states\\n        int take_i = nums[i] + Math.min(getScore(i+2, j, nums, memo), getScore(i+1, j-1, nums, memo));\\n        // Now, if he chooses (i, j-1) => I\\'ll have options\\n        // to choose from (i+1, j-1) or (i,j-2).\\n        // But as he chooses optimally, I should expect the minimum score from those states\\n        int take_j = nums[j] + Math.min(getScore(i, j-2, nums, memo), getScore(i+1, j-1, nums, memo));\\n\\n        // even though I expect the minimum from the upcoming states,\\n        // I will choose the max from my current states.\\n        return memo[i][j] = Math.max(take_i, take_j);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3831120,
                "title": "java-beats-100-recursion-dp-few-lines-of-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nGet the net score for first player by substracting first player\\'s score from second player\\'s score, assuming that second player\\'s will pick max value for itself. If player one has got highest score, then the result of subtraction should also be positive given that we do not have any negative values in the array. \\n\\n# Complexity\\n- Time complexity: O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N^2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean PredictTheWinner(int[] nums) {\\n         int[][] memo = new int[nums.length][nums.length];\\n        return getScore(0, nums.length - 1, nums, memo) >= 0;\\n    }\\n\\n        /* i,  j => P1 options\\n        /        \\\\\\n    i+1, j          i, j-1 => p2 options\\n    /   \\\\          /      \\\\\\n    i+2, j   i+1,j-1  i+1,j-1  i, j-2 p1 options\\n                 */\\n    private static int getScore(int i, int j, int[] nums, int[][] memo) {\\n        if (i == j) return nums[i];\\n\\n        if (memo[i][j] != 0) return memo[i][j];\\n\\n        int iScore = nums[i] - getScore(i + 1, j, nums, memo);\\n        int jScore = nums[j] - getScore(i, j - 1, nums, memo);\\n\\n        return memo[i][j] = Math.max(iScore, jScore);\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean PredictTheWinner(int[] nums) {\\n         int[][] memo = new int[nums.length][nums.length];\\n        return getScore(0, nums.length - 1, nums, memo) >= 0;\\n    }\\n\\n        /* i,  j => P1 options\\n        /        \\\\\\n    i+1, j          i, j-1 => p2 options\\n    /   \\\\          /      \\\\\\n    i+2, j   i+1,j-1  i+1,j-1  i, j-2 p1 options\\n                 */\\n    private static int getScore(int i, int j, int[] nums, int[][] memo) {\\n        if (i == j) return nums[i];\\n\\n        if (memo[i][j] != 0) return memo[i][j];\\n\\n        int iScore = nums[i] - getScore(i + 1, j, nums, memo);\\n        int jScore = nums[j] - getScore(i, j - 1, nums, memo);\\n\\n        return memo[i][j] = Math.max(iScore, jScore);\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3830744,
                "title": "simple-c-solution-recursion",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool solve(int i,int j,int p1,int p2,bool flag,vector<int>&nums){\\n        if(i>j){\\n            return p1>=p2;\\n        }\\n        bool pf = false, ps = false;\\n        if(flag){\\n            return solve(i+1,j,p1+nums[i],p2,!flag,nums) || solve(i,j-1,p1+nums[j],p2,!flag,nums);\\n        }else{\\n            return solve(i+1,j,p1,p2+nums[i],!flag,nums) && solve(i,j-1,p1,p2+nums[j],!flag,nums);\\n        }\\n    }\\n    bool PredictTheWinner(vector<int>& nums) {\\n        int i=0,j=nums.size()-1;\\n        int p1=0,p2=0;\\n        bool flag=true;\\n        return solve(i,j,p1,p2,flag,nums);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool solve(int i,int j,int p1,int p2,bool flag,vector<int>&nums){\\n        if(i>j){\\n            return p1>=p2;\\n        }\\n        bool pf = false, ps = false;\\n        if(flag){\\n            return solve(i+1,j,p1+nums[i],p2,!flag,nums) || solve(i,j-1,p1+nums[j],p2,!flag,nums);\\n        }else{\\n            return solve(i+1,j,p1,p2+nums[i],!flag,nums) && solve(i,j-1,p1,p2+nums[j],!flag,nums);\\n        }\\n    }\\n    bool PredictTheWinner(vector<int>& nums) {\\n        int i=0,j=nums.size()-1;\\n        int p1=0,p2=0;\\n        bool flag=true;\\n        return solve(i,j,p1,p2,flag,nums);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3830713,
                "title": "min-max-game-get-max-out-of-min-you-can-get-in-the-possible-combinations",
                "content": "```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& a , int i, int j,  vector<vector<int>> &dp)\\n    {\\n        if(i>j)\\n            return 0;\\n        \\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        \\n        int t1 = a[i] + min(solve(a,i+2,j,dp),solve(a,i+1,j-1,dp));\\n        \\n        int t2 = a[j] + min(solve(a,i+1,j-1,dp),solve(a,i,j-2,dp));\\n        \\n        return dp[i][j]=max(t1,t2);\\n    }\\n    \\n    \\n    bool PredictTheWinner(vector<int>& a) {\\n        int val = accumulate(a.begin(),a.end(),0);\\n        int n  = a.size();\\n        vector<vector<int>> dp(n,vector<int>(n,-1));\\n        \\n        int res_1 = solve(a,0,n-1,dp); \\n        int res_2 = val-res_1;\\n        return res_1>=res_2;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& a , int i, int j,  vector<vector<int>> &dp)\\n    {\\n        if(i>j)\\n            return 0;\\n        \\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        \\n        int t1 = a[i] + min(solve(a,i+2,j,dp),solve(a,i+1,j-1,dp));\\n        \\n        int t2 = a[j] + min(solve(a,i+1,j-1,dp),solve(a,i,j-2,dp));\\n        \\n        return dp[i][j]=max(t1,t2);\\n    }\\n    \\n    \\n    bool PredictTheWinner(vector<int>& a) {\\n        int val = accumulate(a.begin(),a.end(),0);\\n        int n  = a.size();\\n        vector<vector<int>> dp(n,vector<int>(n,-1));\\n        \\n        int res_1 = solve(a,0,n-1,dp); \\n        int res_2 = val-res_1;\\n        return res_1>=res_2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3830649,
                "title": "c-easy-and-readable-solution-faster-than-100-less-than-90",
                "content": "![image.png](https://assets.leetcode.com/users/images/8d6d7a1e-b539-498c-b3a2-ce3f97f89a75_1690572630.8864076.png)\\n\\n**Don\\'t hesitate to suggest or ask bellow about something that you don\\'t understand**\\n\\n```\\npublic class Solution {\\n    public bool PredictTheWinner(int[] nums) {\\n        int[,] dp = new int[nums.Length, nums.Length];\\n        for (int i = 0; i < nums.Length; i++)\\n            dp[i, i] = nums[i];\\n        for (int k = 1; k < nums.Length; k++)\\n            for (int i = 0; i < nums.Length - k; i++)\\n            {\\n                int j = i + k;\\n                dp[i, j] = Math.Max(nums[i] - dp[i + 1, j], nums[j] - dp[i, j - 1]);\\n            }\\n        return 0 <= dp[0, nums.Length - 1];\\n    }\\n}\\n```\\n\\nIf you like it don\\'t forget to **upvote!**",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public bool PredictTheWinner(int[] nums) {\\n        int[,] dp = new int[nums.Length, nums.Length];\\n        for (int i = 0; i < nums.Length; i++)\\n            dp[i, i] = nums[i];\\n        for (int k = 1; k < nums.Length; k++)\\n            for (int i = 0; i < nums.Length - k; i++)\\n            {\\n                int j = i + k;\\n                dp[i, j] = Math.Max(nums[i] - dp[i + 1, j], nums[j] - dp[i, j - 1]);\\n            }\\n        return 0 <= dp[0, nums.Length - 1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1565119,
                "content": [
                    {
                        "username": "deleted_user",
                        "content": "I did not understand what the question was asking exactly during the contest. I came up with multiple solutions based on what I thought was being asked, but they were all incorrect. Looks like I finally understood it. I wanted to clarify the question for people who may be confused like me.\\n\\nThe setup should be easy to understand. p1 and p2 take turns in picking a number from the input array, either the first item or the last item. When an item is picked by one of the player, that item cannot be used anymore; you can imagine it being removed from the array.\\n\\nWhat made me confused was the part \"... predict whether player 1 is the winner. You can assume each player plays to maximize his score.\" I was not sure what maximizing the score meant. Here is what it means.\\n\\nLet's say the initial array is [1, 5, 2]. It's p1's turn. p1 will pick either 1 or 2, but it wants to make sure that whichever one he picks will maximize his gain at the end. What if p1 picks 1? Now the array is [5, 2] and it's p2's turn to pick. p2 looks at the current array and thinks about how to maximize his gain at the end. Obviously, picking 5 will maximize his gains. So, p2 will pick 5, leaving 2 for p1. Resulting scores for p1 and p2 are 3 and 5 respectively. This one did not work out for p1.\\n\\nWhat if p1 picks 2 at the beginning? Then the array becomes [1, 5]. Again, p2 looks at the current array and thinks about how to maximize his gain at the end. Picking 5 will maximize his gains. So, p2 will pick 5, leaving 1 for p1. Resulting scores for p1 and p2 are 3 and 5 respectively. This one did not work out for p1 either. Those were the only two possibilities for game play. p1 can never win.\\n\\nWhat if the input array is [1, 5, 233, 7]? For this one, let me list all possibilities and explain which ones are valid and which ones are not.\\n\\n![0_1485064722628_upload-5137006d-197e-47b8-92a3-276224ff6f97](/uploads/files/1485064725743-upload-5137006d-197e-47b8-92a3-276224ff6f97.png) \\n\\nWhat clarified the question for me was realizing that in each step the current player takes a look at the current array as a whole and tries to make the best pick for maximizing it's gain (taking into consideration what the other player may do). \\n\\nI hope this helps someone."
                    },
                    {
                        "username": "watsonsherlock",
                        "content": "[@079_RISHABH](/079_RISHABH) No, the problem is not based on greedy. Greedy means choosing the current best. But it is evident from the second example that if you always choose the best options that is available to you in each step, you will loose the game."
                    },
                    {
                        "username": "786_Rishabh",
                        "content": "Thanks bro. Question was not very clear? But From your explaination I got  point that this  problem is using greedy approach to predict the winner. Earlier it was not clear from the question."
                    },
                    {
                        "username": "Rajat_Shukla",
                        "content": "Thank you for explaining the question :)"
                    },
                    {
                        "username": "luanct",
                        "content": "This is Bob and Alice with stone games. They keep playing even when knowing the winner. Bob has a crush on Alice ngl\\uD83D\\uDE02 "
                    },
                    {
                        "username": "RebelWithoutFlaws",
                        "content": "Who wouldnt fall in love with a girl who spends all of her time playing cryptographic games \\uD83E\\uDD13"
                    },
                    {
                        "username": "aruuu____",
                        "content": "lol\\uD83D\\uDE06\\uD83D\\uDE06"
                    },
                    {
                        "username": "JS00",
                        "content": "This might be the first time they are actually playing a fair game, Bob finally came to his senses!"
                    },
                    {
                        "username": "yjian012",
                        "content": "Yeah I can totally see [how the games go](https://postimg.cc/8f8QbhPF)."
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": "Tip for recursive solutions, the player 1 win on the following conditions:\n1) In player1 turn, player1 can win by picking either left or right side Hint: `||`. \n2) In player2 turn, player1 wins when player1 have larger score than player2 in both possibilities right and left. Hint: `&&`. \n3) Base case: when the range l < r."
                    },
                    {
                        "username": "nitissssh",
                        "content": "[@rayahemesh](/rayahemesh) Note the question says both player play optimally ie , if the player 2 has chance that of to make the \n        // the player one loose , then he will not choose the path in wich the player one wins , so to make sure the\n        // player one always wins no matter how cheeky is the player2 we use && , so that we only return true if there \n        // is no way that player2 ka loose the player1 "
                    },
                    {
                        "username": "stachofsky",
                        "content": "[@shashank-lol](/shashank-lol) sorry the base case... what does `when the range l < r` mean?"
                    },
                    {
                        "username": "pj1999",
                        "content": "[@rayahemesh](/rayahemesh)  for both possibilities of player 2 if either possibility returns in favour of player 2 (say false)  we have to return false as player 2 also plays optimally."
                    },
                    {
                        "username": "chandramani_lc",
                        "content": "[@rayahemesh](/rayahemesh) you have to write the recursion thinking of **can u make Player1 win** be it any possible way. So in the course of doing so u might come across the idea that if it's **player1** turn to pick then he can go with either end element and will declared winner if he wins in any of it's choice (so OR). If it's **Player2** turn then **Player1** can only win if **player1** value is greater than that of **player2** in any of the choices of **Player2**(so we need both true i.e &&). "
                    },
                    {
                        "username": "rayahemesh",
                        "content": "Thanks... can you explain bit clearly why && is for"
                    },
                    {
                        "username": "shashank-lol",
                        "content": "Thanks a lot buddy"
                    },
                    {
                        "username": "kng",
                        "content": "Input:\\n[0,0,7,6,5,6,1]\\nOutput:\\ntrue\\nExpected:\\nfalse\\n\\nI guess the answer should be true since Player 1 can bag 13 points as compared to Player 2 with 12."
                    },
                    {
                        "username": "gd4niele",
                        "content": "Assuming that both players are playing optimally, there can be two cases:\\nFirst case (starting from the first zero): P1 [0, 6, 6, 0] P2 [1, 5, 7]\\nSecond case (starting from 1): P1 [1, 5, 6, 0] P2 [6, 0, 7]\\nSo, in this case, the first player will always lose."
                    },
                    {
                        "username": "N00b_ME",
                        "content": "[@rakeshSharma19](/rakeshSharma19) thanks so much , this cleared my doubts "
                    },
                    {
                        "username": "rakeshSharma19",
                        "content": "Same thing happen to me, think about the case Player1 - [1,5,6,0] and player2 - [6,0,7] you will get your answer"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "Both the players playing optimally for overall game not optimal at each step. "
                    },
                    {
                        "username": "belayneh_12",
                        "content": "the correct answer should be False"
                    },
                    {
                        "username": "gentlezephyr95",
                        "content": "The key step is figuring out that both players will play to maximise the score. This translates the problem to an optimization problem which can be solved with DP.\\nI found this helpful: https://medium.com/algorithms-digest/predict-the-winner-16668e9c1cb8"
                    },
                    {
                        "username": "lolcharles",
                        "content": "[0,0,7,6,5,6,1]\\n\\nApparently player 1 can\\'t win here. Why? \\nOptimized steps for player 2 yields:\\nPlayer 1: 1\\nPlayer 2: 6\\nPlayer 1: 5\\nPlayer 2: 6\\nPlayer 1: 7\\n\\nWith the score 13-12 for player 1."
                    },
                    {
                        "username": "dheeraj2002_",
                        "content": "Try to see a video about min-max algorithm, you would be able to solve the question easily."
                    },
                    {
                        "username": "rakeshSharma19",
                        "content": "If I\\'m your competitor(player 2), Then the steps are\\n\\nPlayer1 chooses 1, array now - [0, 0, 7, 6, 5, 6] Player1: 1, Player2: 0\\nPlayer2 chooses 6, array now - [0, 0, 7, 6, 5] Player1: 1, Player2: 6\\nPlayer1 chooses 5, array now - [0, 0, 7, 6] Player1: 6, Player2: 6\\nPlayer2 chooses 0, array now - [0, 7, 6] Player1: 6, Player2: 6\\nPlayer1 chooses either 0 or 6, array now - [0, 7] Player1: 12, Player2: 6 if chooses 6 \\nPlayer2 chooses 7, array now - [0,] Player1: 12, Player2: 13\\nPlayer2 Will win\\n\\nHere Both the players playing optimally for overall game not optimal at each step.\\nUse DP here to get the solution."
                    },
                    {
                        "username": "enzo_cheng",
                        "content": "If i'm your competitor (Player 2), after this step:\n>>> Player 1 chooses 5 [0,0.7,6] Player1: 6, Player2: 6\nPlayer 2 will select 0,\n>>> Player 2 chooses 0 [0,7,6] Player1: 6, Player2: 6\n>>> Player 1 chooses 6 [0,7] Player1: 12, Player2: 6\n>>> Player 2 chooses 7 [0] Player1: 12, Player2: 13\n\nResult is that Player 2 wins always"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Game theory. 2 people contest. like chess game or go! Use DP to solve! Similar questions\n# Stone Game~  Stone Game IX"
                    },
                    {
                        "username": "riturajsingh487",
                        "content": "Player 1 can never lose in this test case (wrong test case).\\n\\nFact: if number of elements in an array are even , then whoever plays first will win (or tie if sum of elements at odd position is equal to sum of elements at even position).\\n\\nNow, player1 will take max(nums[0], nums[numsSize-1]) in first step.\\nin 2nd step: number of elements left in array becomes even. Now, since sum(elements at odd positions) == sum(elemenst at even positions) , if both players play optimally they will have same points after after 1st step.\\n\\nSo, player 1 will have more points (points of 1st step + equal points with player2).\\nClearly player1 shold be the winner."
                    },
                    {
                        "username": "adityadeokar123",
                        "content": "[@disturbedbrown1](/disturbedbrown1) Test Case = [0,1,0] ?"
                    },
                    {
                        "username": "Ilkhomjon",
                        "content": "[@disturbedbrown1](/disturbedbrown1) Nope, it depends the values of each element. So can\\'t tell the winner by only considering the number of elements."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Another pattern I noticed that if there are less than 3 elements, than whoever plays first will win."
                    },
                    {
                        "username": "pyoneerC",
                        "content": "Bro if both players are playing \"optimally\" you are not gonna choose 1 over 7 \\n\\n[1,5,233,7] should be false"
                    },
                    {
                        "username": "sikora92",
                        "content": "They see whole array, so do not behave greedy."
                    },
                    {
                        "username": "psionl0",
                        "content": "But if player 1 chooses 1 then no matter what player 2 chooses, player 1 gets the jackpot (233). So choosing 1 over 7 is the optimal strategy."
                    },
                    {
                        "username": "Harrywithcode",
                        "content": "So, I don't understand what author want to say from \" Player 1 picks one of the numbers from either end of the array followed by the player 2 and then player 1 and so on.\" Is there any mistake in this sentence?\\nPlayer 1 picks either end of the array or what?\\nWhy player 1 should followed by player 2? I think player 1 pick first, right?"
                    },
                    {
                        "username": "Dylan_Yifan",
                        "content": "the start of the array is \"one end\" of an array, while the end of the array is the \"other end\" of the array. So the sentence is correct that it\\'s picking \"either end of the array\""
                    }
                ]
            },
            {
                "id": 1989476,
                "content": [
                    {
                        "username": "deleted_user",
                        "content": "I did not understand what the question was asking exactly during the contest. I came up with multiple solutions based on what I thought was being asked, but they were all incorrect. Looks like I finally understood it. I wanted to clarify the question for people who may be confused like me.\\n\\nThe setup should be easy to understand. p1 and p2 take turns in picking a number from the input array, either the first item or the last item. When an item is picked by one of the player, that item cannot be used anymore; you can imagine it being removed from the array.\\n\\nWhat made me confused was the part \"... predict whether player 1 is the winner. You can assume each player plays to maximize his score.\" I was not sure what maximizing the score meant. Here is what it means.\\n\\nLet's say the initial array is [1, 5, 2]. It's p1's turn. p1 will pick either 1 or 2, but it wants to make sure that whichever one he picks will maximize his gain at the end. What if p1 picks 1? Now the array is [5, 2] and it's p2's turn to pick. p2 looks at the current array and thinks about how to maximize his gain at the end. Obviously, picking 5 will maximize his gains. So, p2 will pick 5, leaving 2 for p1. Resulting scores for p1 and p2 are 3 and 5 respectively. This one did not work out for p1.\\n\\nWhat if p1 picks 2 at the beginning? Then the array becomes [1, 5]. Again, p2 looks at the current array and thinks about how to maximize his gain at the end. Picking 5 will maximize his gains. So, p2 will pick 5, leaving 1 for p1. Resulting scores for p1 and p2 are 3 and 5 respectively. This one did not work out for p1 either. Those were the only two possibilities for game play. p1 can never win.\\n\\nWhat if the input array is [1, 5, 233, 7]? For this one, let me list all possibilities and explain which ones are valid and which ones are not.\\n\\n![0_1485064722628_upload-5137006d-197e-47b8-92a3-276224ff6f97](/uploads/files/1485064725743-upload-5137006d-197e-47b8-92a3-276224ff6f97.png) \\n\\nWhat clarified the question for me was realizing that in each step the current player takes a look at the current array as a whole and tries to make the best pick for maximizing it's gain (taking into consideration what the other player may do). \\n\\nI hope this helps someone."
                    },
                    {
                        "username": "watsonsherlock",
                        "content": "[@079_RISHABH](/079_RISHABH) No, the problem is not based on greedy. Greedy means choosing the current best. But it is evident from the second example that if you always choose the best options that is available to you in each step, you will loose the game."
                    },
                    {
                        "username": "786_Rishabh",
                        "content": "Thanks bro. Question was not very clear? But From your explaination I got  point that this  problem is using greedy approach to predict the winner. Earlier it was not clear from the question."
                    },
                    {
                        "username": "Rajat_Shukla",
                        "content": "Thank you for explaining the question :)"
                    },
                    {
                        "username": "luanct",
                        "content": "This is Bob and Alice with stone games. They keep playing even when knowing the winner. Bob has a crush on Alice ngl\\uD83D\\uDE02 "
                    },
                    {
                        "username": "RebelWithoutFlaws",
                        "content": "Who wouldnt fall in love with a girl who spends all of her time playing cryptographic games \\uD83E\\uDD13"
                    },
                    {
                        "username": "aruuu____",
                        "content": "lol\\uD83D\\uDE06\\uD83D\\uDE06"
                    },
                    {
                        "username": "JS00",
                        "content": "This might be the first time they are actually playing a fair game, Bob finally came to his senses!"
                    },
                    {
                        "username": "yjian012",
                        "content": "Yeah I can totally see [how the games go](https://postimg.cc/8f8QbhPF)."
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": "Tip for recursive solutions, the player 1 win on the following conditions:\n1) In player1 turn, player1 can win by picking either left or right side Hint: `||`. \n2) In player2 turn, player1 wins when player1 have larger score than player2 in both possibilities right and left. Hint: `&&`. \n3) Base case: when the range l < r."
                    },
                    {
                        "username": "nitissssh",
                        "content": "[@rayahemesh](/rayahemesh) Note the question says both player play optimally ie , if the player 2 has chance that of to make the \n        // the player one loose , then he will not choose the path in wich the player one wins , so to make sure the\n        // player one always wins no matter how cheeky is the player2 we use && , so that we only return true if there \n        // is no way that player2 ka loose the player1 "
                    },
                    {
                        "username": "stachofsky",
                        "content": "[@shashank-lol](/shashank-lol) sorry the base case... what does `when the range l < r` mean?"
                    },
                    {
                        "username": "pj1999",
                        "content": "[@rayahemesh](/rayahemesh)  for both possibilities of player 2 if either possibility returns in favour of player 2 (say false)  we have to return false as player 2 also plays optimally."
                    },
                    {
                        "username": "chandramani_lc",
                        "content": "[@rayahemesh](/rayahemesh) you have to write the recursion thinking of **can u make Player1 win** be it any possible way. So in the course of doing so u might come across the idea that if it's **player1** turn to pick then he can go with either end element and will declared winner if he wins in any of it's choice (so OR). If it's **Player2** turn then **Player1** can only win if **player1** value is greater than that of **player2** in any of the choices of **Player2**(so we need both true i.e &&). "
                    },
                    {
                        "username": "rayahemesh",
                        "content": "Thanks... can you explain bit clearly why && is for"
                    },
                    {
                        "username": "shashank-lol",
                        "content": "Thanks a lot buddy"
                    },
                    {
                        "username": "kng",
                        "content": "Input:\\n[0,0,7,6,5,6,1]\\nOutput:\\ntrue\\nExpected:\\nfalse\\n\\nI guess the answer should be true since Player 1 can bag 13 points as compared to Player 2 with 12."
                    },
                    {
                        "username": "gd4niele",
                        "content": "Assuming that both players are playing optimally, there can be two cases:\\nFirst case (starting from the first zero): P1 [0, 6, 6, 0] P2 [1, 5, 7]\\nSecond case (starting from 1): P1 [1, 5, 6, 0] P2 [6, 0, 7]\\nSo, in this case, the first player will always lose."
                    },
                    {
                        "username": "N00b_ME",
                        "content": "[@rakeshSharma19](/rakeshSharma19) thanks so much , this cleared my doubts "
                    },
                    {
                        "username": "rakeshSharma19",
                        "content": "Same thing happen to me, think about the case Player1 - [1,5,6,0] and player2 - [6,0,7] you will get your answer"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "Both the players playing optimally for overall game not optimal at each step. "
                    },
                    {
                        "username": "belayneh_12",
                        "content": "the correct answer should be False"
                    },
                    {
                        "username": "gentlezephyr95",
                        "content": "The key step is figuring out that both players will play to maximise the score. This translates the problem to an optimization problem which can be solved with DP.\\nI found this helpful: https://medium.com/algorithms-digest/predict-the-winner-16668e9c1cb8"
                    },
                    {
                        "username": "lolcharles",
                        "content": "[0,0,7,6,5,6,1]\\n\\nApparently player 1 can\\'t win here. Why? \\nOptimized steps for player 2 yields:\\nPlayer 1: 1\\nPlayer 2: 6\\nPlayer 1: 5\\nPlayer 2: 6\\nPlayer 1: 7\\n\\nWith the score 13-12 for player 1."
                    },
                    {
                        "username": "dheeraj2002_",
                        "content": "Try to see a video about min-max algorithm, you would be able to solve the question easily."
                    },
                    {
                        "username": "rakeshSharma19",
                        "content": "If I\\'m your competitor(player 2), Then the steps are\\n\\nPlayer1 chooses 1, array now - [0, 0, 7, 6, 5, 6] Player1: 1, Player2: 0\\nPlayer2 chooses 6, array now - [0, 0, 7, 6, 5] Player1: 1, Player2: 6\\nPlayer1 chooses 5, array now - [0, 0, 7, 6] Player1: 6, Player2: 6\\nPlayer2 chooses 0, array now - [0, 7, 6] Player1: 6, Player2: 6\\nPlayer1 chooses either 0 or 6, array now - [0, 7] Player1: 12, Player2: 6 if chooses 6 \\nPlayer2 chooses 7, array now - [0,] Player1: 12, Player2: 13\\nPlayer2 Will win\\n\\nHere Both the players playing optimally for overall game not optimal at each step.\\nUse DP here to get the solution."
                    },
                    {
                        "username": "enzo_cheng",
                        "content": "If i'm your competitor (Player 2), after this step:\n>>> Player 1 chooses 5 [0,0.7,6] Player1: 6, Player2: 6\nPlayer 2 will select 0,\n>>> Player 2 chooses 0 [0,7,6] Player1: 6, Player2: 6\n>>> Player 1 chooses 6 [0,7] Player1: 12, Player2: 6\n>>> Player 2 chooses 7 [0] Player1: 12, Player2: 13\n\nResult is that Player 2 wins always"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Game theory. 2 people contest. like chess game or go! Use DP to solve! Similar questions\n# Stone Game~  Stone Game IX"
                    },
                    {
                        "username": "riturajsingh487",
                        "content": "Player 1 can never lose in this test case (wrong test case).\\n\\nFact: if number of elements in an array are even , then whoever plays first will win (or tie if sum of elements at odd position is equal to sum of elements at even position).\\n\\nNow, player1 will take max(nums[0], nums[numsSize-1]) in first step.\\nin 2nd step: number of elements left in array becomes even. Now, since sum(elements at odd positions) == sum(elemenst at even positions) , if both players play optimally they will have same points after after 1st step.\\n\\nSo, player 1 will have more points (points of 1st step + equal points with player2).\\nClearly player1 shold be the winner."
                    },
                    {
                        "username": "adityadeokar123",
                        "content": "[@disturbedbrown1](/disturbedbrown1) Test Case = [0,1,0] ?"
                    },
                    {
                        "username": "Ilkhomjon",
                        "content": "[@disturbedbrown1](/disturbedbrown1) Nope, it depends the values of each element. So can\\'t tell the winner by only considering the number of elements."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Another pattern I noticed that if there are less than 3 elements, than whoever plays first will win."
                    },
                    {
                        "username": "pyoneerC",
                        "content": "Bro if both players are playing \"optimally\" you are not gonna choose 1 over 7 \\n\\n[1,5,233,7] should be false"
                    },
                    {
                        "username": "sikora92",
                        "content": "They see whole array, so do not behave greedy."
                    },
                    {
                        "username": "psionl0",
                        "content": "But if player 1 chooses 1 then no matter what player 2 chooses, player 1 gets the jackpot (233). So choosing 1 over 7 is the optimal strategy."
                    },
                    {
                        "username": "Harrywithcode",
                        "content": "So, I don't understand what author want to say from \" Player 1 picks one of the numbers from either end of the array followed by the player 2 and then player 1 and so on.\" Is there any mistake in this sentence?\\nPlayer 1 picks either end of the array or what?\\nWhy player 1 should followed by player 2? I think player 1 pick first, right?"
                    },
                    {
                        "username": "Dylan_Yifan",
                        "content": "the start of the array is \"one end\" of an array, while the end of the array is the \"other end\" of the array. So the sentence is correct that it\\'s picking \"either end of the array\""
                    }
                ]
            },
            {
                "id": 1989495,
                "content": [
                    {
                        "username": "deleted_user",
                        "content": "I did not understand what the question was asking exactly during the contest. I came up with multiple solutions based on what I thought was being asked, but they were all incorrect. Looks like I finally understood it. I wanted to clarify the question for people who may be confused like me.\\n\\nThe setup should be easy to understand. p1 and p2 take turns in picking a number from the input array, either the first item or the last item. When an item is picked by one of the player, that item cannot be used anymore; you can imagine it being removed from the array.\\n\\nWhat made me confused was the part \"... predict whether player 1 is the winner. You can assume each player plays to maximize his score.\" I was not sure what maximizing the score meant. Here is what it means.\\n\\nLet's say the initial array is [1, 5, 2]. It's p1's turn. p1 will pick either 1 or 2, but it wants to make sure that whichever one he picks will maximize his gain at the end. What if p1 picks 1? Now the array is [5, 2] and it's p2's turn to pick. p2 looks at the current array and thinks about how to maximize his gain at the end. Obviously, picking 5 will maximize his gains. So, p2 will pick 5, leaving 2 for p1. Resulting scores for p1 and p2 are 3 and 5 respectively. This one did not work out for p1.\\n\\nWhat if p1 picks 2 at the beginning? Then the array becomes [1, 5]. Again, p2 looks at the current array and thinks about how to maximize his gain at the end. Picking 5 will maximize his gains. So, p2 will pick 5, leaving 1 for p1. Resulting scores for p1 and p2 are 3 and 5 respectively. This one did not work out for p1 either. Those were the only two possibilities for game play. p1 can never win.\\n\\nWhat if the input array is [1, 5, 233, 7]? For this one, let me list all possibilities and explain which ones are valid and which ones are not.\\n\\n![0_1485064722628_upload-5137006d-197e-47b8-92a3-276224ff6f97](/uploads/files/1485064725743-upload-5137006d-197e-47b8-92a3-276224ff6f97.png) \\n\\nWhat clarified the question for me was realizing that in each step the current player takes a look at the current array as a whole and tries to make the best pick for maximizing it's gain (taking into consideration what the other player may do). \\n\\nI hope this helps someone."
                    },
                    {
                        "username": "watsonsherlock",
                        "content": "[@079_RISHABH](/079_RISHABH) No, the problem is not based on greedy. Greedy means choosing the current best. But it is evident from the second example that if you always choose the best options that is available to you in each step, you will loose the game."
                    },
                    {
                        "username": "786_Rishabh",
                        "content": "Thanks bro. Question was not very clear? But From your explaination I got  point that this  problem is using greedy approach to predict the winner. Earlier it was not clear from the question."
                    },
                    {
                        "username": "Rajat_Shukla",
                        "content": "Thank you for explaining the question :)"
                    },
                    {
                        "username": "luanct",
                        "content": "This is Bob and Alice with stone games. They keep playing even when knowing the winner. Bob has a crush on Alice ngl\\uD83D\\uDE02 "
                    },
                    {
                        "username": "RebelWithoutFlaws",
                        "content": "Who wouldnt fall in love with a girl who spends all of her time playing cryptographic games \\uD83E\\uDD13"
                    },
                    {
                        "username": "aruuu____",
                        "content": "lol\\uD83D\\uDE06\\uD83D\\uDE06"
                    },
                    {
                        "username": "JS00",
                        "content": "This might be the first time they are actually playing a fair game, Bob finally came to his senses!"
                    },
                    {
                        "username": "yjian012",
                        "content": "Yeah I can totally see [how the games go](https://postimg.cc/8f8QbhPF)."
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": "Tip for recursive solutions, the player 1 win on the following conditions:\n1) In player1 turn, player1 can win by picking either left or right side Hint: `||`. \n2) In player2 turn, player1 wins when player1 have larger score than player2 in both possibilities right and left. Hint: `&&`. \n3) Base case: when the range l < r."
                    },
                    {
                        "username": "nitissssh",
                        "content": "[@rayahemesh](/rayahemesh) Note the question says both player play optimally ie , if the player 2 has chance that of to make the \n        // the player one loose , then he will not choose the path in wich the player one wins , so to make sure the\n        // player one always wins no matter how cheeky is the player2 we use && , so that we only return true if there \n        // is no way that player2 ka loose the player1 "
                    },
                    {
                        "username": "stachofsky",
                        "content": "[@shashank-lol](/shashank-lol) sorry the base case... what does `when the range l < r` mean?"
                    },
                    {
                        "username": "pj1999",
                        "content": "[@rayahemesh](/rayahemesh)  for both possibilities of player 2 if either possibility returns in favour of player 2 (say false)  we have to return false as player 2 also plays optimally."
                    },
                    {
                        "username": "chandramani_lc",
                        "content": "[@rayahemesh](/rayahemesh) you have to write the recursion thinking of **can u make Player1 win** be it any possible way. So in the course of doing so u might come across the idea that if it's **player1** turn to pick then he can go with either end element and will declared winner if he wins in any of it's choice (so OR). If it's **Player2** turn then **Player1** can only win if **player1** value is greater than that of **player2** in any of the choices of **Player2**(so we need both true i.e &&). "
                    },
                    {
                        "username": "rayahemesh",
                        "content": "Thanks... can you explain bit clearly why && is for"
                    },
                    {
                        "username": "shashank-lol",
                        "content": "Thanks a lot buddy"
                    },
                    {
                        "username": "kng",
                        "content": "Input:\\n[0,0,7,6,5,6,1]\\nOutput:\\ntrue\\nExpected:\\nfalse\\n\\nI guess the answer should be true since Player 1 can bag 13 points as compared to Player 2 with 12."
                    },
                    {
                        "username": "gd4niele",
                        "content": "Assuming that both players are playing optimally, there can be two cases:\\nFirst case (starting from the first zero): P1 [0, 6, 6, 0] P2 [1, 5, 7]\\nSecond case (starting from 1): P1 [1, 5, 6, 0] P2 [6, 0, 7]\\nSo, in this case, the first player will always lose."
                    },
                    {
                        "username": "N00b_ME",
                        "content": "[@rakeshSharma19](/rakeshSharma19) thanks so much , this cleared my doubts "
                    },
                    {
                        "username": "rakeshSharma19",
                        "content": "Same thing happen to me, think about the case Player1 - [1,5,6,0] and player2 - [6,0,7] you will get your answer"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "Both the players playing optimally for overall game not optimal at each step. "
                    },
                    {
                        "username": "belayneh_12",
                        "content": "the correct answer should be False"
                    },
                    {
                        "username": "gentlezephyr95",
                        "content": "The key step is figuring out that both players will play to maximise the score. This translates the problem to an optimization problem which can be solved with DP.\\nI found this helpful: https://medium.com/algorithms-digest/predict-the-winner-16668e9c1cb8"
                    },
                    {
                        "username": "lolcharles",
                        "content": "[0,0,7,6,5,6,1]\\n\\nApparently player 1 can\\'t win here. Why? \\nOptimized steps for player 2 yields:\\nPlayer 1: 1\\nPlayer 2: 6\\nPlayer 1: 5\\nPlayer 2: 6\\nPlayer 1: 7\\n\\nWith the score 13-12 for player 1."
                    },
                    {
                        "username": "dheeraj2002_",
                        "content": "Try to see a video about min-max algorithm, you would be able to solve the question easily."
                    },
                    {
                        "username": "rakeshSharma19",
                        "content": "If I\\'m your competitor(player 2), Then the steps are\\n\\nPlayer1 chooses 1, array now - [0, 0, 7, 6, 5, 6] Player1: 1, Player2: 0\\nPlayer2 chooses 6, array now - [0, 0, 7, 6, 5] Player1: 1, Player2: 6\\nPlayer1 chooses 5, array now - [0, 0, 7, 6] Player1: 6, Player2: 6\\nPlayer2 chooses 0, array now - [0, 7, 6] Player1: 6, Player2: 6\\nPlayer1 chooses either 0 or 6, array now - [0, 7] Player1: 12, Player2: 6 if chooses 6 \\nPlayer2 chooses 7, array now - [0,] Player1: 12, Player2: 13\\nPlayer2 Will win\\n\\nHere Both the players playing optimally for overall game not optimal at each step.\\nUse DP here to get the solution."
                    },
                    {
                        "username": "enzo_cheng",
                        "content": "If i'm your competitor (Player 2), after this step:\n>>> Player 1 chooses 5 [0,0.7,6] Player1: 6, Player2: 6\nPlayer 2 will select 0,\n>>> Player 2 chooses 0 [0,7,6] Player1: 6, Player2: 6\n>>> Player 1 chooses 6 [0,7] Player1: 12, Player2: 6\n>>> Player 2 chooses 7 [0] Player1: 12, Player2: 13\n\nResult is that Player 2 wins always"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Game theory. 2 people contest. like chess game or go! Use DP to solve! Similar questions\n# Stone Game~  Stone Game IX"
                    },
                    {
                        "username": "riturajsingh487",
                        "content": "Player 1 can never lose in this test case (wrong test case).\\n\\nFact: if number of elements in an array are even , then whoever plays first will win (or tie if sum of elements at odd position is equal to sum of elements at even position).\\n\\nNow, player1 will take max(nums[0], nums[numsSize-1]) in first step.\\nin 2nd step: number of elements left in array becomes even. Now, since sum(elements at odd positions) == sum(elemenst at even positions) , if both players play optimally they will have same points after after 1st step.\\n\\nSo, player 1 will have more points (points of 1st step + equal points with player2).\\nClearly player1 shold be the winner."
                    },
                    {
                        "username": "adityadeokar123",
                        "content": "[@disturbedbrown1](/disturbedbrown1) Test Case = [0,1,0] ?"
                    },
                    {
                        "username": "Ilkhomjon",
                        "content": "[@disturbedbrown1](/disturbedbrown1) Nope, it depends the values of each element. So can\\'t tell the winner by only considering the number of elements."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Another pattern I noticed that if there are less than 3 elements, than whoever plays first will win."
                    },
                    {
                        "username": "pyoneerC",
                        "content": "Bro if both players are playing \"optimally\" you are not gonna choose 1 over 7 \\n\\n[1,5,233,7] should be false"
                    },
                    {
                        "username": "sikora92",
                        "content": "They see whole array, so do not behave greedy."
                    },
                    {
                        "username": "psionl0",
                        "content": "But if player 1 chooses 1 then no matter what player 2 chooses, player 1 gets the jackpot (233). So choosing 1 over 7 is the optimal strategy."
                    },
                    {
                        "username": "Harrywithcode",
                        "content": "So, I don't understand what author want to say from \" Player 1 picks one of the numbers from either end of the array followed by the player 2 and then player 1 and so on.\" Is there any mistake in this sentence?\\nPlayer 1 picks either end of the array or what?\\nWhy player 1 should followed by player 2? I think player 1 pick first, right?"
                    },
                    {
                        "username": "Dylan_Yifan",
                        "content": "the start of the array is \"one end\" of an array, while the end of the array is the \"other end\" of the array. So the sentence is correct that it\\'s picking \"either end of the array\""
                    }
                ]
            },
            {
                "id": 1565966,
                "content": [
                    {
                        "username": "deleted_user",
                        "content": "I did not understand what the question was asking exactly during the contest. I came up with multiple solutions based on what I thought was being asked, but they were all incorrect. Looks like I finally understood it. I wanted to clarify the question for people who may be confused like me.\\n\\nThe setup should be easy to understand. p1 and p2 take turns in picking a number from the input array, either the first item or the last item. When an item is picked by one of the player, that item cannot be used anymore; you can imagine it being removed from the array.\\n\\nWhat made me confused was the part \"... predict whether player 1 is the winner. You can assume each player plays to maximize his score.\" I was not sure what maximizing the score meant. Here is what it means.\\n\\nLet's say the initial array is [1, 5, 2]. It's p1's turn. p1 will pick either 1 or 2, but it wants to make sure that whichever one he picks will maximize his gain at the end. What if p1 picks 1? Now the array is [5, 2] and it's p2's turn to pick. p2 looks at the current array and thinks about how to maximize his gain at the end. Obviously, picking 5 will maximize his gains. So, p2 will pick 5, leaving 2 for p1. Resulting scores for p1 and p2 are 3 and 5 respectively. This one did not work out for p1.\\n\\nWhat if p1 picks 2 at the beginning? Then the array becomes [1, 5]. Again, p2 looks at the current array and thinks about how to maximize his gain at the end. Picking 5 will maximize his gains. So, p2 will pick 5, leaving 1 for p1. Resulting scores for p1 and p2 are 3 and 5 respectively. This one did not work out for p1 either. Those were the only two possibilities for game play. p1 can never win.\\n\\nWhat if the input array is [1, 5, 233, 7]? For this one, let me list all possibilities and explain which ones are valid and which ones are not.\\n\\n![0_1485064722628_upload-5137006d-197e-47b8-92a3-276224ff6f97](/uploads/files/1485064725743-upload-5137006d-197e-47b8-92a3-276224ff6f97.png) \\n\\nWhat clarified the question for me was realizing that in each step the current player takes a look at the current array as a whole and tries to make the best pick for maximizing it's gain (taking into consideration what the other player may do). \\n\\nI hope this helps someone."
                    },
                    {
                        "username": "watsonsherlock",
                        "content": "[@079_RISHABH](/079_RISHABH) No, the problem is not based on greedy. Greedy means choosing the current best. But it is evident from the second example that if you always choose the best options that is available to you in each step, you will loose the game."
                    },
                    {
                        "username": "786_Rishabh",
                        "content": "Thanks bro. Question was not very clear? But From your explaination I got  point that this  problem is using greedy approach to predict the winner. Earlier it was not clear from the question."
                    },
                    {
                        "username": "Rajat_Shukla",
                        "content": "Thank you for explaining the question :)"
                    },
                    {
                        "username": "luanct",
                        "content": "This is Bob and Alice with stone games. They keep playing even when knowing the winner. Bob has a crush on Alice ngl\\uD83D\\uDE02 "
                    },
                    {
                        "username": "RebelWithoutFlaws",
                        "content": "Who wouldnt fall in love with a girl who spends all of her time playing cryptographic games \\uD83E\\uDD13"
                    },
                    {
                        "username": "aruuu____",
                        "content": "lol\\uD83D\\uDE06\\uD83D\\uDE06"
                    },
                    {
                        "username": "JS00",
                        "content": "This might be the first time they are actually playing a fair game, Bob finally came to his senses!"
                    },
                    {
                        "username": "yjian012",
                        "content": "Yeah I can totally see [how the games go](https://postimg.cc/8f8QbhPF)."
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": "Tip for recursive solutions, the player 1 win on the following conditions:\n1) In player1 turn, player1 can win by picking either left or right side Hint: `||`. \n2) In player2 turn, player1 wins when player1 have larger score than player2 in both possibilities right and left. Hint: `&&`. \n3) Base case: when the range l < r."
                    },
                    {
                        "username": "nitissssh",
                        "content": "[@rayahemesh](/rayahemesh) Note the question says both player play optimally ie , if the player 2 has chance that of to make the \n        // the player one loose , then he will not choose the path in wich the player one wins , so to make sure the\n        // player one always wins no matter how cheeky is the player2 we use && , so that we only return true if there \n        // is no way that player2 ka loose the player1 "
                    },
                    {
                        "username": "stachofsky",
                        "content": "[@shashank-lol](/shashank-lol) sorry the base case... what does `when the range l < r` mean?"
                    },
                    {
                        "username": "pj1999",
                        "content": "[@rayahemesh](/rayahemesh)  for both possibilities of player 2 if either possibility returns in favour of player 2 (say false)  we have to return false as player 2 also plays optimally."
                    },
                    {
                        "username": "chandramani_lc",
                        "content": "[@rayahemesh](/rayahemesh) you have to write the recursion thinking of **can u make Player1 win** be it any possible way. So in the course of doing so u might come across the idea that if it's **player1** turn to pick then he can go with either end element and will declared winner if he wins in any of it's choice (so OR). If it's **Player2** turn then **Player1** can only win if **player1** value is greater than that of **player2** in any of the choices of **Player2**(so we need both true i.e &&). "
                    },
                    {
                        "username": "rayahemesh",
                        "content": "Thanks... can you explain bit clearly why && is for"
                    },
                    {
                        "username": "shashank-lol",
                        "content": "Thanks a lot buddy"
                    },
                    {
                        "username": "kng",
                        "content": "Input:\\n[0,0,7,6,5,6,1]\\nOutput:\\ntrue\\nExpected:\\nfalse\\n\\nI guess the answer should be true since Player 1 can bag 13 points as compared to Player 2 with 12."
                    },
                    {
                        "username": "gd4niele",
                        "content": "Assuming that both players are playing optimally, there can be two cases:\\nFirst case (starting from the first zero): P1 [0, 6, 6, 0] P2 [1, 5, 7]\\nSecond case (starting from 1): P1 [1, 5, 6, 0] P2 [6, 0, 7]\\nSo, in this case, the first player will always lose."
                    },
                    {
                        "username": "N00b_ME",
                        "content": "[@rakeshSharma19](/rakeshSharma19) thanks so much , this cleared my doubts "
                    },
                    {
                        "username": "rakeshSharma19",
                        "content": "Same thing happen to me, think about the case Player1 - [1,5,6,0] and player2 - [6,0,7] you will get your answer"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "Both the players playing optimally for overall game not optimal at each step. "
                    },
                    {
                        "username": "belayneh_12",
                        "content": "the correct answer should be False"
                    },
                    {
                        "username": "gentlezephyr95",
                        "content": "The key step is figuring out that both players will play to maximise the score. This translates the problem to an optimization problem which can be solved with DP.\\nI found this helpful: https://medium.com/algorithms-digest/predict-the-winner-16668e9c1cb8"
                    },
                    {
                        "username": "lolcharles",
                        "content": "[0,0,7,6,5,6,1]\\n\\nApparently player 1 can\\'t win here. Why? \\nOptimized steps for player 2 yields:\\nPlayer 1: 1\\nPlayer 2: 6\\nPlayer 1: 5\\nPlayer 2: 6\\nPlayer 1: 7\\n\\nWith the score 13-12 for player 1."
                    },
                    {
                        "username": "dheeraj2002_",
                        "content": "Try to see a video about min-max algorithm, you would be able to solve the question easily."
                    },
                    {
                        "username": "rakeshSharma19",
                        "content": "If I\\'m your competitor(player 2), Then the steps are\\n\\nPlayer1 chooses 1, array now - [0, 0, 7, 6, 5, 6] Player1: 1, Player2: 0\\nPlayer2 chooses 6, array now - [0, 0, 7, 6, 5] Player1: 1, Player2: 6\\nPlayer1 chooses 5, array now - [0, 0, 7, 6] Player1: 6, Player2: 6\\nPlayer2 chooses 0, array now - [0, 7, 6] Player1: 6, Player2: 6\\nPlayer1 chooses either 0 or 6, array now - [0, 7] Player1: 12, Player2: 6 if chooses 6 \\nPlayer2 chooses 7, array now - [0,] Player1: 12, Player2: 13\\nPlayer2 Will win\\n\\nHere Both the players playing optimally for overall game not optimal at each step.\\nUse DP here to get the solution."
                    },
                    {
                        "username": "enzo_cheng",
                        "content": "If i'm your competitor (Player 2), after this step:\n>>> Player 1 chooses 5 [0,0.7,6] Player1: 6, Player2: 6\nPlayer 2 will select 0,\n>>> Player 2 chooses 0 [0,7,6] Player1: 6, Player2: 6\n>>> Player 1 chooses 6 [0,7] Player1: 12, Player2: 6\n>>> Player 2 chooses 7 [0] Player1: 12, Player2: 13\n\nResult is that Player 2 wins always"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Game theory. 2 people contest. like chess game or go! Use DP to solve! Similar questions\n# Stone Game~  Stone Game IX"
                    },
                    {
                        "username": "riturajsingh487",
                        "content": "Player 1 can never lose in this test case (wrong test case).\\n\\nFact: if number of elements in an array are even , then whoever plays first will win (or tie if sum of elements at odd position is equal to sum of elements at even position).\\n\\nNow, player1 will take max(nums[0], nums[numsSize-1]) in first step.\\nin 2nd step: number of elements left in array becomes even. Now, since sum(elements at odd positions) == sum(elemenst at even positions) , if both players play optimally they will have same points after after 1st step.\\n\\nSo, player 1 will have more points (points of 1st step + equal points with player2).\\nClearly player1 shold be the winner."
                    },
                    {
                        "username": "adityadeokar123",
                        "content": "[@disturbedbrown1](/disturbedbrown1) Test Case = [0,1,0] ?"
                    },
                    {
                        "username": "Ilkhomjon",
                        "content": "[@disturbedbrown1](/disturbedbrown1) Nope, it depends the values of each element. So can\\'t tell the winner by only considering the number of elements."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Another pattern I noticed that if there are less than 3 elements, than whoever plays first will win."
                    },
                    {
                        "username": "pyoneerC",
                        "content": "Bro if both players are playing \"optimally\" you are not gonna choose 1 over 7 \\n\\n[1,5,233,7] should be false"
                    },
                    {
                        "username": "sikora92",
                        "content": "They see whole array, so do not behave greedy."
                    },
                    {
                        "username": "psionl0",
                        "content": "But if player 1 chooses 1 then no matter what player 2 chooses, player 1 gets the jackpot (233). So choosing 1 over 7 is the optimal strategy."
                    },
                    {
                        "username": "Harrywithcode",
                        "content": "So, I don't understand what author want to say from \" Player 1 picks one of the numbers from either end of the array followed by the player 2 and then player 1 and so on.\" Is there any mistake in this sentence?\\nPlayer 1 picks either end of the array or what?\\nWhy player 1 should followed by player 2? I think player 1 pick first, right?"
                    },
                    {
                        "username": "Dylan_Yifan",
                        "content": "the start of the array is \"one end\" of an array, while the end of the array is the \"other end\" of the array. So the sentence is correct that it\\'s picking \"either end of the array\""
                    }
                ]
            },
            {
                "id": 1568560,
                "content": [
                    {
                        "username": "deleted_user",
                        "content": "I did not understand what the question was asking exactly during the contest. I came up with multiple solutions based on what I thought was being asked, but they were all incorrect. Looks like I finally understood it. I wanted to clarify the question for people who may be confused like me.\\n\\nThe setup should be easy to understand. p1 and p2 take turns in picking a number from the input array, either the first item or the last item. When an item is picked by one of the player, that item cannot be used anymore; you can imagine it being removed from the array.\\n\\nWhat made me confused was the part \"... predict whether player 1 is the winner. You can assume each player plays to maximize his score.\" I was not sure what maximizing the score meant. Here is what it means.\\n\\nLet's say the initial array is [1, 5, 2]. It's p1's turn. p1 will pick either 1 or 2, but it wants to make sure that whichever one he picks will maximize his gain at the end. What if p1 picks 1? Now the array is [5, 2] and it's p2's turn to pick. p2 looks at the current array and thinks about how to maximize his gain at the end. Obviously, picking 5 will maximize his gains. So, p2 will pick 5, leaving 2 for p1. Resulting scores for p1 and p2 are 3 and 5 respectively. This one did not work out for p1.\\n\\nWhat if p1 picks 2 at the beginning? Then the array becomes [1, 5]. Again, p2 looks at the current array and thinks about how to maximize his gain at the end. Picking 5 will maximize his gains. So, p2 will pick 5, leaving 1 for p1. Resulting scores for p1 and p2 are 3 and 5 respectively. This one did not work out for p1 either. Those were the only two possibilities for game play. p1 can never win.\\n\\nWhat if the input array is [1, 5, 233, 7]? For this one, let me list all possibilities and explain which ones are valid and which ones are not.\\n\\n![0_1485064722628_upload-5137006d-197e-47b8-92a3-276224ff6f97](/uploads/files/1485064725743-upload-5137006d-197e-47b8-92a3-276224ff6f97.png) \\n\\nWhat clarified the question for me was realizing that in each step the current player takes a look at the current array as a whole and tries to make the best pick for maximizing it's gain (taking into consideration what the other player may do). \\n\\nI hope this helps someone."
                    },
                    {
                        "username": "watsonsherlock",
                        "content": "[@079_RISHABH](/079_RISHABH) No, the problem is not based on greedy. Greedy means choosing the current best. But it is evident from the second example that if you always choose the best options that is available to you in each step, you will loose the game."
                    },
                    {
                        "username": "786_Rishabh",
                        "content": "Thanks bro. Question was not very clear? But From your explaination I got  point that this  problem is using greedy approach to predict the winner. Earlier it was not clear from the question."
                    },
                    {
                        "username": "Rajat_Shukla",
                        "content": "Thank you for explaining the question :)"
                    },
                    {
                        "username": "luanct",
                        "content": "This is Bob and Alice with stone games. They keep playing even when knowing the winner. Bob has a crush on Alice ngl\\uD83D\\uDE02 "
                    },
                    {
                        "username": "RebelWithoutFlaws",
                        "content": "Who wouldnt fall in love with a girl who spends all of her time playing cryptographic games \\uD83E\\uDD13"
                    },
                    {
                        "username": "aruuu____",
                        "content": "lol\\uD83D\\uDE06\\uD83D\\uDE06"
                    },
                    {
                        "username": "JS00",
                        "content": "This might be the first time they are actually playing a fair game, Bob finally came to his senses!"
                    },
                    {
                        "username": "yjian012",
                        "content": "Yeah I can totally see [how the games go](https://postimg.cc/8f8QbhPF)."
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": "Tip for recursive solutions, the player 1 win on the following conditions:\n1) In player1 turn, player1 can win by picking either left or right side Hint: `||`. \n2) In player2 turn, player1 wins when player1 have larger score than player2 in both possibilities right and left. Hint: `&&`. \n3) Base case: when the range l < r."
                    },
                    {
                        "username": "nitissssh",
                        "content": "[@rayahemesh](/rayahemesh) Note the question says both player play optimally ie , if the player 2 has chance that of to make the \n        // the player one loose , then he will not choose the path in wich the player one wins , so to make sure the\n        // player one always wins no matter how cheeky is the player2 we use && , so that we only return true if there \n        // is no way that player2 ka loose the player1 "
                    },
                    {
                        "username": "stachofsky",
                        "content": "[@shashank-lol](/shashank-lol) sorry the base case... what does `when the range l < r` mean?"
                    },
                    {
                        "username": "pj1999",
                        "content": "[@rayahemesh](/rayahemesh)  for both possibilities of player 2 if either possibility returns in favour of player 2 (say false)  we have to return false as player 2 also plays optimally."
                    },
                    {
                        "username": "chandramani_lc",
                        "content": "[@rayahemesh](/rayahemesh) you have to write the recursion thinking of **can u make Player1 win** be it any possible way. So in the course of doing so u might come across the idea that if it's **player1** turn to pick then he can go with either end element and will declared winner if he wins in any of it's choice (so OR). If it's **Player2** turn then **Player1** can only win if **player1** value is greater than that of **player2** in any of the choices of **Player2**(so we need both true i.e &&). "
                    },
                    {
                        "username": "rayahemesh",
                        "content": "Thanks... can you explain bit clearly why && is for"
                    },
                    {
                        "username": "shashank-lol",
                        "content": "Thanks a lot buddy"
                    },
                    {
                        "username": "kng",
                        "content": "Input:\\n[0,0,7,6,5,6,1]\\nOutput:\\ntrue\\nExpected:\\nfalse\\n\\nI guess the answer should be true since Player 1 can bag 13 points as compared to Player 2 with 12."
                    },
                    {
                        "username": "gd4niele",
                        "content": "Assuming that both players are playing optimally, there can be two cases:\\nFirst case (starting from the first zero): P1 [0, 6, 6, 0] P2 [1, 5, 7]\\nSecond case (starting from 1): P1 [1, 5, 6, 0] P2 [6, 0, 7]\\nSo, in this case, the first player will always lose."
                    },
                    {
                        "username": "N00b_ME",
                        "content": "[@rakeshSharma19](/rakeshSharma19) thanks so much , this cleared my doubts "
                    },
                    {
                        "username": "rakeshSharma19",
                        "content": "Same thing happen to me, think about the case Player1 - [1,5,6,0] and player2 - [6,0,7] you will get your answer"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "Both the players playing optimally for overall game not optimal at each step. "
                    },
                    {
                        "username": "belayneh_12",
                        "content": "the correct answer should be False"
                    },
                    {
                        "username": "gentlezephyr95",
                        "content": "The key step is figuring out that both players will play to maximise the score. This translates the problem to an optimization problem which can be solved with DP.\\nI found this helpful: https://medium.com/algorithms-digest/predict-the-winner-16668e9c1cb8"
                    },
                    {
                        "username": "lolcharles",
                        "content": "[0,0,7,6,5,6,1]\\n\\nApparently player 1 can\\'t win here. Why? \\nOptimized steps for player 2 yields:\\nPlayer 1: 1\\nPlayer 2: 6\\nPlayer 1: 5\\nPlayer 2: 6\\nPlayer 1: 7\\n\\nWith the score 13-12 for player 1."
                    },
                    {
                        "username": "dheeraj2002_",
                        "content": "Try to see a video about min-max algorithm, you would be able to solve the question easily."
                    },
                    {
                        "username": "rakeshSharma19",
                        "content": "If I\\'m your competitor(player 2), Then the steps are\\n\\nPlayer1 chooses 1, array now - [0, 0, 7, 6, 5, 6] Player1: 1, Player2: 0\\nPlayer2 chooses 6, array now - [0, 0, 7, 6, 5] Player1: 1, Player2: 6\\nPlayer1 chooses 5, array now - [0, 0, 7, 6] Player1: 6, Player2: 6\\nPlayer2 chooses 0, array now - [0, 7, 6] Player1: 6, Player2: 6\\nPlayer1 chooses either 0 or 6, array now - [0, 7] Player1: 12, Player2: 6 if chooses 6 \\nPlayer2 chooses 7, array now - [0,] Player1: 12, Player2: 13\\nPlayer2 Will win\\n\\nHere Both the players playing optimally for overall game not optimal at each step.\\nUse DP here to get the solution."
                    },
                    {
                        "username": "enzo_cheng",
                        "content": "If i'm your competitor (Player 2), after this step:\n>>> Player 1 chooses 5 [0,0.7,6] Player1: 6, Player2: 6\nPlayer 2 will select 0,\n>>> Player 2 chooses 0 [0,7,6] Player1: 6, Player2: 6\n>>> Player 1 chooses 6 [0,7] Player1: 12, Player2: 6\n>>> Player 2 chooses 7 [0] Player1: 12, Player2: 13\n\nResult is that Player 2 wins always"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Game theory. 2 people contest. like chess game or go! Use DP to solve! Similar questions\n# Stone Game~  Stone Game IX"
                    },
                    {
                        "username": "riturajsingh487",
                        "content": "Player 1 can never lose in this test case (wrong test case).\\n\\nFact: if number of elements in an array are even , then whoever plays first will win (or tie if sum of elements at odd position is equal to sum of elements at even position).\\n\\nNow, player1 will take max(nums[0], nums[numsSize-1]) in first step.\\nin 2nd step: number of elements left in array becomes even. Now, since sum(elements at odd positions) == sum(elemenst at even positions) , if both players play optimally they will have same points after after 1st step.\\n\\nSo, player 1 will have more points (points of 1st step + equal points with player2).\\nClearly player1 shold be the winner."
                    },
                    {
                        "username": "adityadeokar123",
                        "content": "[@disturbedbrown1](/disturbedbrown1) Test Case = [0,1,0] ?"
                    },
                    {
                        "username": "Ilkhomjon",
                        "content": "[@disturbedbrown1](/disturbedbrown1) Nope, it depends the values of each element. So can\\'t tell the winner by only considering the number of elements."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Another pattern I noticed that if there are less than 3 elements, than whoever plays first will win."
                    },
                    {
                        "username": "pyoneerC",
                        "content": "Bro if both players are playing \"optimally\" you are not gonna choose 1 over 7 \\n\\n[1,5,233,7] should be false"
                    },
                    {
                        "username": "sikora92",
                        "content": "They see whole array, so do not behave greedy."
                    },
                    {
                        "username": "psionl0",
                        "content": "But if player 1 chooses 1 then no matter what player 2 chooses, player 1 gets the jackpot (233). So choosing 1 over 7 is the optimal strategy."
                    },
                    {
                        "username": "Harrywithcode",
                        "content": "So, I don't understand what author want to say from \" Player 1 picks one of the numbers from either end of the array followed by the player 2 and then player 1 and so on.\" Is there any mistake in this sentence?\\nPlayer 1 picks either end of the array or what?\\nWhy player 1 should followed by player 2? I think player 1 pick first, right?"
                    },
                    {
                        "username": "Dylan_Yifan",
                        "content": "the start of the array is \"one end\" of an array, while the end of the array is the \"other end\" of the array. So the sentence is correct that it\\'s picking \"either end of the array\""
                    }
                ]
            },
            {
                "id": 1568046,
                "content": [
                    {
                        "username": "deleted_user",
                        "content": "I did not understand what the question was asking exactly during the contest. I came up with multiple solutions based on what I thought was being asked, but they were all incorrect. Looks like I finally understood it. I wanted to clarify the question for people who may be confused like me.\\n\\nThe setup should be easy to understand. p1 and p2 take turns in picking a number from the input array, either the first item or the last item. When an item is picked by one of the player, that item cannot be used anymore; you can imagine it being removed from the array.\\n\\nWhat made me confused was the part \"... predict whether player 1 is the winner. You can assume each player plays to maximize his score.\" I was not sure what maximizing the score meant. Here is what it means.\\n\\nLet's say the initial array is [1, 5, 2]. It's p1's turn. p1 will pick either 1 or 2, but it wants to make sure that whichever one he picks will maximize his gain at the end. What if p1 picks 1? Now the array is [5, 2] and it's p2's turn to pick. p2 looks at the current array and thinks about how to maximize his gain at the end. Obviously, picking 5 will maximize his gains. So, p2 will pick 5, leaving 2 for p1. Resulting scores for p1 and p2 are 3 and 5 respectively. This one did not work out for p1.\\n\\nWhat if p1 picks 2 at the beginning? Then the array becomes [1, 5]. Again, p2 looks at the current array and thinks about how to maximize his gain at the end. Picking 5 will maximize his gains. So, p2 will pick 5, leaving 1 for p1. Resulting scores for p1 and p2 are 3 and 5 respectively. This one did not work out for p1 either. Those were the only two possibilities for game play. p1 can never win.\\n\\nWhat if the input array is [1, 5, 233, 7]? For this one, let me list all possibilities and explain which ones are valid and which ones are not.\\n\\n![0_1485064722628_upload-5137006d-197e-47b8-92a3-276224ff6f97](/uploads/files/1485064725743-upload-5137006d-197e-47b8-92a3-276224ff6f97.png) \\n\\nWhat clarified the question for me was realizing that in each step the current player takes a look at the current array as a whole and tries to make the best pick for maximizing it's gain (taking into consideration what the other player may do). \\n\\nI hope this helps someone."
                    },
                    {
                        "username": "watsonsherlock",
                        "content": "[@079_RISHABH](/079_RISHABH) No, the problem is not based on greedy. Greedy means choosing the current best. But it is evident from the second example that if you always choose the best options that is available to you in each step, you will loose the game."
                    },
                    {
                        "username": "786_Rishabh",
                        "content": "Thanks bro. Question was not very clear? But From your explaination I got  point that this  problem is using greedy approach to predict the winner. Earlier it was not clear from the question."
                    },
                    {
                        "username": "Rajat_Shukla",
                        "content": "Thank you for explaining the question :)"
                    },
                    {
                        "username": "luanct",
                        "content": "This is Bob and Alice with stone games. They keep playing even when knowing the winner. Bob has a crush on Alice ngl\\uD83D\\uDE02 "
                    },
                    {
                        "username": "RebelWithoutFlaws",
                        "content": "Who wouldnt fall in love with a girl who spends all of her time playing cryptographic games \\uD83E\\uDD13"
                    },
                    {
                        "username": "aruuu____",
                        "content": "lol\\uD83D\\uDE06\\uD83D\\uDE06"
                    },
                    {
                        "username": "JS00",
                        "content": "This might be the first time they are actually playing a fair game, Bob finally came to his senses!"
                    },
                    {
                        "username": "yjian012",
                        "content": "Yeah I can totally see [how the games go](https://postimg.cc/8f8QbhPF)."
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": "Tip for recursive solutions, the player 1 win on the following conditions:\n1) In player1 turn, player1 can win by picking either left or right side Hint: `||`. \n2) In player2 turn, player1 wins when player1 have larger score than player2 in both possibilities right and left. Hint: `&&`. \n3) Base case: when the range l < r."
                    },
                    {
                        "username": "nitissssh",
                        "content": "[@rayahemesh](/rayahemesh) Note the question says both player play optimally ie , if the player 2 has chance that of to make the \n        // the player one loose , then he will not choose the path in wich the player one wins , so to make sure the\n        // player one always wins no matter how cheeky is the player2 we use && , so that we only return true if there \n        // is no way that player2 ka loose the player1 "
                    },
                    {
                        "username": "stachofsky",
                        "content": "[@shashank-lol](/shashank-lol) sorry the base case... what does `when the range l < r` mean?"
                    },
                    {
                        "username": "pj1999",
                        "content": "[@rayahemesh](/rayahemesh)  for both possibilities of player 2 if either possibility returns in favour of player 2 (say false)  we have to return false as player 2 also plays optimally."
                    },
                    {
                        "username": "chandramani_lc",
                        "content": "[@rayahemesh](/rayahemesh) you have to write the recursion thinking of **can u make Player1 win** be it any possible way. So in the course of doing so u might come across the idea that if it's **player1** turn to pick then he can go with either end element and will declared winner if he wins in any of it's choice (so OR). If it's **Player2** turn then **Player1** can only win if **player1** value is greater than that of **player2** in any of the choices of **Player2**(so we need both true i.e &&). "
                    },
                    {
                        "username": "rayahemesh",
                        "content": "Thanks... can you explain bit clearly why && is for"
                    },
                    {
                        "username": "shashank-lol",
                        "content": "Thanks a lot buddy"
                    },
                    {
                        "username": "kng",
                        "content": "Input:\\n[0,0,7,6,5,6,1]\\nOutput:\\ntrue\\nExpected:\\nfalse\\n\\nI guess the answer should be true since Player 1 can bag 13 points as compared to Player 2 with 12."
                    },
                    {
                        "username": "gd4niele",
                        "content": "Assuming that both players are playing optimally, there can be two cases:\\nFirst case (starting from the first zero): P1 [0, 6, 6, 0] P2 [1, 5, 7]\\nSecond case (starting from 1): P1 [1, 5, 6, 0] P2 [6, 0, 7]\\nSo, in this case, the first player will always lose."
                    },
                    {
                        "username": "N00b_ME",
                        "content": "[@rakeshSharma19](/rakeshSharma19) thanks so much , this cleared my doubts "
                    },
                    {
                        "username": "rakeshSharma19",
                        "content": "Same thing happen to me, think about the case Player1 - [1,5,6,0] and player2 - [6,0,7] you will get your answer"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "Both the players playing optimally for overall game not optimal at each step. "
                    },
                    {
                        "username": "belayneh_12",
                        "content": "the correct answer should be False"
                    },
                    {
                        "username": "gentlezephyr95",
                        "content": "The key step is figuring out that both players will play to maximise the score. This translates the problem to an optimization problem which can be solved with DP.\\nI found this helpful: https://medium.com/algorithms-digest/predict-the-winner-16668e9c1cb8"
                    },
                    {
                        "username": "lolcharles",
                        "content": "[0,0,7,6,5,6,1]\\n\\nApparently player 1 can\\'t win here. Why? \\nOptimized steps for player 2 yields:\\nPlayer 1: 1\\nPlayer 2: 6\\nPlayer 1: 5\\nPlayer 2: 6\\nPlayer 1: 7\\n\\nWith the score 13-12 for player 1."
                    },
                    {
                        "username": "dheeraj2002_",
                        "content": "Try to see a video about min-max algorithm, you would be able to solve the question easily."
                    },
                    {
                        "username": "rakeshSharma19",
                        "content": "If I\\'m your competitor(player 2), Then the steps are\\n\\nPlayer1 chooses 1, array now - [0, 0, 7, 6, 5, 6] Player1: 1, Player2: 0\\nPlayer2 chooses 6, array now - [0, 0, 7, 6, 5] Player1: 1, Player2: 6\\nPlayer1 chooses 5, array now - [0, 0, 7, 6] Player1: 6, Player2: 6\\nPlayer2 chooses 0, array now - [0, 7, 6] Player1: 6, Player2: 6\\nPlayer1 chooses either 0 or 6, array now - [0, 7] Player1: 12, Player2: 6 if chooses 6 \\nPlayer2 chooses 7, array now - [0,] Player1: 12, Player2: 13\\nPlayer2 Will win\\n\\nHere Both the players playing optimally for overall game not optimal at each step.\\nUse DP here to get the solution."
                    },
                    {
                        "username": "enzo_cheng",
                        "content": "If i'm your competitor (Player 2), after this step:\n>>> Player 1 chooses 5 [0,0.7,6] Player1: 6, Player2: 6\nPlayer 2 will select 0,\n>>> Player 2 chooses 0 [0,7,6] Player1: 6, Player2: 6\n>>> Player 1 chooses 6 [0,7] Player1: 12, Player2: 6\n>>> Player 2 chooses 7 [0] Player1: 12, Player2: 13\n\nResult is that Player 2 wins always"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Game theory. 2 people contest. like chess game or go! Use DP to solve! Similar questions\n# Stone Game~  Stone Game IX"
                    },
                    {
                        "username": "riturajsingh487",
                        "content": "Player 1 can never lose in this test case (wrong test case).\\n\\nFact: if number of elements in an array are even , then whoever plays first will win (or tie if sum of elements at odd position is equal to sum of elements at even position).\\n\\nNow, player1 will take max(nums[0], nums[numsSize-1]) in first step.\\nin 2nd step: number of elements left in array becomes even. Now, since sum(elements at odd positions) == sum(elemenst at even positions) , if both players play optimally they will have same points after after 1st step.\\n\\nSo, player 1 will have more points (points of 1st step + equal points with player2).\\nClearly player1 shold be the winner."
                    },
                    {
                        "username": "adityadeokar123",
                        "content": "[@disturbedbrown1](/disturbedbrown1) Test Case = [0,1,0] ?"
                    },
                    {
                        "username": "Ilkhomjon",
                        "content": "[@disturbedbrown1](/disturbedbrown1) Nope, it depends the values of each element. So can\\'t tell the winner by only considering the number of elements."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Another pattern I noticed that if there are less than 3 elements, than whoever plays first will win."
                    },
                    {
                        "username": "pyoneerC",
                        "content": "Bro if both players are playing \"optimally\" you are not gonna choose 1 over 7 \\n\\n[1,5,233,7] should be false"
                    },
                    {
                        "username": "sikora92",
                        "content": "They see whole array, so do not behave greedy."
                    },
                    {
                        "username": "psionl0",
                        "content": "But if player 1 chooses 1 then no matter what player 2 chooses, player 1 gets the jackpot (233). So choosing 1 over 7 is the optimal strategy."
                    },
                    {
                        "username": "Harrywithcode",
                        "content": "So, I don't understand what author want to say from \" Player 1 picks one of the numbers from either end of the array followed by the player 2 and then player 1 and so on.\" Is there any mistake in this sentence?\\nPlayer 1 picks either end of the array or what?\\nWhy player 1 should followed by player 2? I think player 1 pick first, right?"
                    },
                    {
                        "username": "Dylan_Yifan",
                        "content": "the start of the array is \"one end\" of an array, while the end of the array is the \"other end\" of the array. So the sentence is correct that it\\'s picking \"either end of the array\""
                    }
                ]
            },
            {
                "id": 1989512,
                "content": [
                    {
                        "username": "deleted_user",
                        "content": "I did not understand what the question was asking exactly during the contest. I came up with multiple solutions based on what I thought was being asked, but they were all incorrect. Looks like I finally understood it. I wanted to clarify the question for people who may be confused like me.\\n\\nThe setup should be easy to understand. p1 and p2 take turns in picking a number from the input array, either the first item or the last item. When an item is picked by one of the player, that item cannot be used anymore; you can imagine it being removed from the array.\\n\\nWhat made me confused was the part \"... predict whether player 1 is the winner. You can assume each player plays to maximize his score.\" I was not sure what maximizing the score meant. Here is what it means.\\n\\nLet's say the initial array is [1, 5, 2]. It's p1's turn. p1 will pick either 1 or 2, but it wants to make sure that whichever one he picks will maximize his gain at the end. What if p1 picks 1? Now the array is [5, 2] and it's p2's turn to pick. p2 looks at the current array and thinks about how to maximize his gain at the end. Obviously, picking 5 will maximize his gains. So, p2 will pick 5, leaving 2 for p1. Resulting scores for p1 and p2 are 3 and 5 respectively. This one did not work out for p1.\\n\\nWhat if p1 picks 2 at the beginning? Then the array becomes [1, 5]. Again, p2 looks at the current array and thinks about how to maximize his gain at the end. Picking 5 will maximize his gains. So, p2 will pick 5, leaving 1 for p1. Resulting scores for p1 and p2 are 3 and 5 respectively. This one did not work out for p1 either. Those were the only two possibilities for game play. p1 can never win.\\n\\nWhat if the input array is [1, 5, 233, 7]? For this one, let me list all possibilities and explain which ones are valid and which ones are not.\\n\\n![0_1485064722628_upload-5137006d-197e-47b8-92a3-276224ff6f97](/uploads/files/1485064725743-upload-5137006d-197e-47b8-92a3-276224ff6f97.png) \\n\\nWhat clarified the question for me was realizing that in each step the current player takes a look at the current array as a whole and tries to make the best pick for maximizing it's gain (taking into consideration what the other player may do). \\n\\nI hope this helps someone."
                    },
                    {
                        "username": "watsonsherlock",
                        "content": "[@079_RISHABH](/079_RISHABH) No, the problem is not based on greedy. Greedy means choosing the current best. But it is evident from the second example that if you always choose the best options that is available to you in each step, you will loose the game."
                    },
                    {
                        "username": "786_Rishabh",
                        "content": "Thanks bro. Question was not very clear? But From your explaination I got  point that this  problem is using greedy approach to predict the winner. Earlier it was not clear from the question."
                    },
                    {
                        "username": "Rajat_Shukla",
                        "content": "Thank you for explaining the question :)"
                    },
                    {
                        "username": "luanct",
                        "content": "This is Bob and Alice with stone games. They keep playing even when knowing the winner. Bob has a crush on Alice ngl\\uD83D\\uDE02 "
                    },
                    {
                        "username": "RebelWithoutFlaws",
                        "content": "Who wouldnt fall in love with a girl who spends all of her time playing cryptographic games \\uD83E\\uDD13"
                    },
                    {
                        "username": "aruuu____",
                        "content": "lol\\uD83D\\uDE06\\uD83D\\uDE06"
                    },
                    {
                        "username": "JS00",
                        "content": "This might be the first time they are actually playing a fair game, Bob finally came to his senses!"
                    },
                    {
                        "username": "yjian012",
                        "content": "Yeah I can totally see [how the games go](https://postimg.cc/8f8QbhPF)."
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": "Tip for recursive solutions, the player 1 win on the following conditions:\n1) In player1 turn, player1 can win by picking either left or right side Hint: `||`. \n2) In player2 turn, player1 wins when player1 have larger score than player2 in both possibilities right and left. Hint: `&&`. \n3) Base case: when the range l < r."
                    },
                    {
                        "username": "nitissssh",
                        "content": "[@rayahemesh](/rayahemesh) Note the question says both player play optimally ie , if the player 2 has chance that of to make the \n        // the player one loose , then he will not choose the path in wich the player one wins , so to make sure the\n        // player one always wins no matter how cheeky is the player2 we use && , so that we only return true if there \n        // is no way that player2 ka loose the player1 "
                    },
                    {
                        "username": "stachofsky",
                        "content": "[@shashank-lol](/shashank-lol) sorry the base case... what does `when the range l < r` mean?"
                    },
                    {
                        "username": "pj1999",
                        "content": "[@rayahemesh](/rayahemesh)  for both possibilities of player 2 if either possibility returns in favour of player 2 (say false)  we have to return false as player 2 also plays optimally."
                    },
                    {
                        "username": "chandramani_lc",
                        "content": "[@rayahemesh](/rayahemesh) you have to write the recursion thinking of **can u make Player1 win** be it any possible way. So in the course of doing so u might come across the idea that if it's **player1** turn to pick then he can go with either end element and will declared winner if he wins in any of it's choice (so OR). If it's **Player2** turn then **Player1** can only win if **player1** value is greater than that of **player2** in any of the choices of **Player2**(so we need both true i.e &&). "
                    },
                    {
                        "username": "rayahemesh",
                        "content": "Thanks... can you explain bit clearly why && is for"
                    },
                    {
                        "username": "shashank-lol",
                        "content": "Thanks a lot buddy"
                    },
                    {
                        "username": "kng",
                        "content": "Input:\\n[0,0,7,6,5,6,1]\\nOutput:\\ntrue\\nExpected:\\nfalse\\n\\nI guess the answer should be true since Player 1 can bag 13 points as compared to Player 2 with 12."
                    },
                    {
                        "username": "gd4niele",
                        "content": "Assuming that both players are playing optimally, there can be two cases:\\nFirst case (starting from the first zero): P1 [0, 6, 6, 0] P2 [1, 5, 7]\\nSecond case (starting from 1): P1 [1, 5, 6, 0] P2 [6, 0, 7]\\nSo, in this case, the first player will always lose."
                    },
                    {
                        "username": "N00b_ME",
                        "content": "[@rakeshSharma19](/rakeshSharma19) thanks so much , this cleared my doubts "
                    },
                    {
                        "username": "rakeshSharma19",
                        "content": "Same thing happen to me, think about the case Player1 - [1,5,6,0] and player2 - [6,0,7] you will get your answer"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "Both the players playing optimally for overall game not optimal at each step. "
                    },
                    {
                        "username": "belayneh_12",
                        "content": "the correct answer should be False"
                    },
                    {
                        "username": "gentlezephyr95",
                        "content": "The key step is figuring out that both players will play to maximise the score. This translates the problem to an optimization problem which can be solved with DP.\\nI found this helpful: https://medium.com/algorithms-digest/predict-the-winner-16668e9c1cb8"
                    },
                    {
                        "username": "lolcharles",
                        "content": "[0,0,7,6,5,6,1]\\n\\nApparently player 1 can\\'t win here. Why? \\nOptimized steps for player 2 yields:\\nPlayer 1: 1\\nPlayer 2: 6\\nPlayer 1: 5\\nPlayer 2: 6\\nPlayer 1: 7\\n\\nWith the score 13-12 for player 1."
                    },
                    {
                        "username": "dheeraj2002_",
                        "content": "Try to see a video about min-max algorithm, you would be able to solve the question easily."
                    },
                    {
                        "username": "rakeshSharma19",
                        "content": "If I\\'m your competitor(player 2), Then the steps are\\n\\nPlayer1 chooses 1, array now - [0, 0, 7, 6, 5, 6] Player1: 1, Player2: 0\\nPlayer2 chooses 6, array now - [0, 0, 7, 6, 5] Player1: 1, Player2: 6\\nPlayer1 chooses 5, array now - [0, 0, 7, 6] Player1: 6, Player2: 6\\nPlayer2 chooses 0, array now - [0, 7, 6] Player1: 6, Player2: 6\\nPlayer1 chooses either 0 or 6, array now - [0, 7] Player1: 12, Player2: 6 if chooses 6 \\nPlayer2 chooses 7, array now - [0,] Player1: 12, Player2: 13\\nPlayer2 Will win\\n\\nHere Both the players playing optimally for overall game not optimal at each step.\\nUse DP here to get the solution."
                    },
                    {
                        "username": "enzo_cheng",
                        "content": "If i'm your competitor (Player 2), after this step:\n>>> Player 1 chooses 5 [0,0.7,6] Player1: 6, Player2: 6\nPlayer 2 will select 0,\n>>> Player 2 chooses 0 [0,7,6] Player1: 6, Player2: 6\n>>> Player 1 chooses 6 [0,7] Player1: 12, Player2: 6\n>>> Player 2 chooses 7 [0] Player1: 12, Player2: 13\n\nResult is that Player 2 wins always"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Game theory. 2 people contest. like chess game or go! Use DP to solve! Similar questions\n# Stone Game~  Stone Game IX"
                    },
                    {
                        "username": "riturajsingh487",
                        "content": "Player 1 can never lose in this test case (wrong test case).\\n\\nFact: if number of elements in an array are even , then whoever plays first will win (or tie if sum of elements at odd position is equal to sum of elements at even position).\\n\\nNow, player1 will take max(nums[0], nums[numsSize-1]) in first step.\\nin 2nd step: number of elements left in array becomes even. Now, since sum(elements at odd positions) == sum(elemenst at even positions) , if both players play optimally they will have same points after after 1st step.\\n\\nSo, player 1 will have more points (points of 1st step + equal points with player2).\\nClearly player1 shold be the winner."
                    },
                    {
                        "username": "adityadeokar123",
                        "content": "[@disturbedbrown1](/disturbedbrown1) Test Case = [0,1,0] ?"
                    },
                    {
                        "username": "Ilkhomjon",
                        "content": "[@disturbedbrown1](/disturbedbrown1) Nope, it depends the values of each element. So can\\'t tell the winner by only considering the number of elements."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Another pattern I noticed that if there are less than 3 elements, than whoever plays first will win."
                    },
                    {
                        "username": "pyoneerC",
                        "content": "Bro if both players are playing \"optimally\" you are not gonna choose 1 over 7 \\n\\n[1,5,233,7] should be false"
                    },
                    {
                        "username": "sikora92",
                        "content": "They see whole array, so do not behave greedy."
                    },
                    {
                        "username": "psionl0",
                        "content": "But if player 1 chooses 1 then no matter what player 2 chooses, player 1 gets the jackpot (233). So choosing 1 over 7 is the optimal strategy."
                    },
                    {
                        "username": "Harrywithcode",
                        "content": "So, I don't understand what author want to say from \" Player 1 picks one of the numbers from either end of the array followed by the player 2 and then player 1 and so on.\" Is there any mistake in this sentence?\\nPlayer 1 picks either end of the array or what?\\nWhy player 1 should followed by player 2? I think player 1 pick first, right?"
                    },
                    {
                        "username": "Dylan_Yifan",
                        "content": "the start of the array is \"one end\" of an array, while the end of the array is the \"other end\" of the array. So the sentence is correct that it\\'s picking \"either end of the array\""
                    }
                ]
            },
            {
                "id": 1568741,
                "content": [
                    {
                        "username": "deleted_user",
                        "content": "I did not understand what the question was asking exactly during the contest. I came up with multiple solutions based on what I thought was being asked, but they were all incorrect. Looks like I finally understood it. I wanted to clarify the question for people who may be confused like me.\\n\\nThe setup should be easy to understand. p1 and p2 take turns in picking a number from the input array, either the first item or the last item. When an item is picked by one of the player, that item cannot be used anymore; you can imagine it being removed from the array.\\n\\nWhat made me confused was the part \"... predict whether player 1 is the winner. You can assume each player plays to maximize his score.\" I was not sure what maximizing the score meant. Here is what it means.\\n\\nLet's say the initial array is [1, 5, 2]. It's p1's turn. p1 will pick either 1 or 2, but it wants to make sure that whichever one he picks will maximize his gain at the end. What if p1 picks 1? Now the array is [5, 2] and it's p2's turn to pick. p2 looks at the current array and thinks about how to maximize his gain at the end. Obviously, picking 5 will maximize his gains. So, p2 will pick 5, leaving 2 for p1. Resulting scores for p1 and p2 are 3 and 5 respectively. This one did not work out for p1.\\n\\nWhat if p1 picks 2 at the beginning? Then the array becomes [1, 5]. Again, p2 looks at the current array and thinks about how to maximize his gain at the end. Picking 5 will maximize his gains. So, p2 will pick 5, leaving 1 for p1. Resulting scores for p1 and p2 are 3 and 5 respectively. This one did not work out for p1 either. Those were the only two possibilities for game play. p1 can never win.\\n\\nWhat if the input array is [1, 5, 233, 7]? For this one, let me list all possibilities and explain which ones are valid and which ones are not.\\n\\n![0_1485064722628_upload-5137006d-197e-47b8-92a3-276224ff6f97](/uploads/files/1485064725743-upload-5137006d-197e-47b8-92a3-276224ff6f97.png) \\n\\nWhat clarified the question for me was realizing that in each step the current player takes a look at the current array as a whole and tries to make the best pick for maximizing it's gain (taking into consideration what the other player may do). \\n\\nI hope this helps someone."
                    },
                    {
                        "username": "watsonsherlock",
                        "content": "[@079_RISHABH](/079_RISHABH) No, the problem is not based on greedy. Greedy means choosing the current best. But it is evident from the second example that if you always choose the best options that is available to you in each step, you will loose the game."
                    },
                    {
                        "username": "786_Rishabh",
                        "content": "Thanks bro. Question was not very clear? But From your explaination I got  point that this  problem is using greedy approach to predict the winner. Earlier it was not clear from the question."
                    },
                    {
                        "username": "Rajat_Shukla",
                        "content": "Thank you for explaining the question :)"
                    },
                    {
                        "username": "luanct",
                        "content": "This is Bob and Alice with stone games. They keep playing even when knowing the winner. Bob has a crush on Alice ngl\\uD83D\\uDE02 "
                    },
                    {
                        "username": "RebelWithoutFlaws",
                        "content": "Who wouldnt fall in love with a girl who spends all of her time playing cryptographic games \\uD83E\\uDD13"
                    },
                    {
                        "username": "aruuu____",
                        "content": "lol\\uD83D\\uDE06\\uD83D\\uDE06"
                    },
                    {
                        "username": "JS00",
                        "content": "This might be the first time they are actually playing a fair game, Bob finally came to his senses!"
                    },
                    {
                        "username": "yjian012",
                        "content": "Yeah I can totally see [how the games go](https://postimg.cc/8f8QbhPF)."
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": "Tip for recursive solutions, the player 1 win on the following conditions:\n1) In player1 turn, player1 can win by picking either left or right side Hint: `||`. \n2) In player2 turn, player1 wins when player1 have larger score than player2 in both possibilities right and left. Hint: `&&`. \n3) Base case: when the range l < r."
                    },
                    {
                        "username": "nitissssh",
                        "content": "[@rayahemesh](/rayahemesh) Note the question says both player play optimally ie , if the player 2 has chance that of to make the \n        // the player one loose , then he will not choose the path in wich the player one wins , so to make sure the\n        // player one always wins no matter how cheeky is the player2 we use && , so that we only return true if there \n        // is no way that player2 ka loose the player1 "
                    },
                    {
                        "username": "stachofsky",
                        "content": "[@shashank-lol](/shashank-lol) sorry the base case... what does `when the range l < r` mean?"
                    },
                    {
                        "username": "pj1999",
                        "content": "[@rayahemesh](/rayahemesh)  for both possibilities of player 2 if either possibility returns in favour of player 2 (say false)  we have to return false as player 2 also plays optimally."
                    },
                    {
                        "username": "chandramani_lc",
                        "content": "[@rayahemesh](/rayahemesh) you have to write the recursion thinking of **can u make Player1 win** be it any possible way. So in the course of doing so u might come across the idea that if it's **player1** turn to pick then he can go with either end element and will declared winner if he wins in any of it's choice (so OR). If it's **Player2** turn then **Player1** can only win if **player1** value is greater than that of **player2** in any of the choices of **Player2**(so we need both true i.e &&). "
                    },
                    {
                        "username": "rayahemesh",
                        "content": "Thanks... can you explain bit clearly why && is for"
                    },
                    {
                        "username": "shashank-lol",
                        "content": "Thanks a lot buddy"
                    },
                    {
                        "username": "kng",
                        "content": "Input:\\n[0,0,7,6,5,6,1]\\nOutput:\\ntrue\\nExpected:\\nfalse\\n\\nI guess the answer should be true since Player 1 can bag 13 points as compared to Player 2 with 12."
                    },
                    {
                        "username": "gd4niele",
                        "content": "Assuming that both players are playing optimally, there can be two cases:\\nFirst case (starting from the first zero): P1 [0, 6, 6, 0] P2 [1, 5, 7]\\nSecond case (starting from 1): P1 [1, 5, 6, 0] P2 [6, 0, 7]\\nSo, in this case, the first player will always lose."
                    },
                    {
                        "username": "N00b_ME",
                        "content": "[@rakeshSharma19](/rakeshSharma19) thanks so much , this cleared my doubts "
                    },
                    {
                        "username": "rakeshSharma19",
                        "content": "Same thing happen to me, think about the case Player1 - [1,5,6,0] and player2 - [6,0,7] you will get your answer"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "Both the players playing optimally for overall game not optimal at each step. "
                    },
                    {
                        "username": "belayneh_12",
                        "content": "the correct answer should be False"
                    },
                    {
                        "username": "gentlezephyr95",
                        "content": "The key step is figuring out that both players will play to maximise the score. This translates the problem to an optimization problem which can be solved with DP.\\nI found this helpful: https://medium.com/algorithms-digest/predict-the-winner-16668e9c1cb8"
                    },
                    {
                        "username": "lolcharles",
                        "content": "[0,0,7,6,5,6,1]\\n\\nApparently player 1 can\\'t win here. Why? \\nOptimized steps for player 2 yields:\\nPlayer 1: 1\\nPlayer 2: 6\\nPlayer 1: 5\\nPlayer 2: 6\\nPlayer 1: 7\\n\\nWith the score 13-12 for player 1."
                    },
                    {
                        "username": "dheeraj2002_",
                        "content": "Try to see a video about min-max algorithm, you would be able to solve the question easily."
                    },
                    {
                        "username": "rakeshSharma19",
                        "content": "If I\\'m your competitor(player 2), Then the steps are\\n\\nPlayer1 chooses 1, array now - [0, 0, 7, 6, 5, 6] Player1: 1, Player2: 0\\nPlayer2 chooses 6, array now - [0, 0, 7, 6, 5] Player1: 1, Player2: 6\\nPlayer1 chooses 5, array now - [0, 0, 7, 6] Player1: 6, Player2: 6\\nPlayer2 chooses 0, array now - [0, 7, 6] Player1: 6, Player2: 6\\nPlayer1 chooses either 0 or 6, array now - [0, 7] Player1: 12, Player2: 6 if chooses 6 \\nPlayer2 chooses 7, array now - [0,] Player1: 12, Player2: 13\\nPlayer2 Will win\\n\\nHere Both the players playing optimally for overall game not optimal at each step.\\nUse DP here to get the solution."
                    },
                    {
                        "username": "enzo_cheng",
                        "content": "If i'm your competitor (Player 2), after this step:\n>>> Player 1 chooses 5 [0,0.7,6] Player1: 6, Player2: 6\nPlayer 2 will select 0,\n>>> Player 2 chooses 0 [0,7,6] Player1: 6, Player2: 6\n>>> Player 1 chooses 6 [0,7] Player1: 12, Player2: 6\n>>> Player 2 chooses 7 [0] Player1: 12, Player2: 13\n\nResult is that Player 2 wins always"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Game theory. 2 people contest. like chess game or go! Use DP to solve! Similar questions\n# Stone Game~  Stone Game IX"
                    },
                    {
                        "username": "riturajsingh487",
                        "content": "Player 1 can never lose in this test case (wrong test case).\\n\\nFact: if number of elements in an array are even , then whoever plays first will win (or tie if sum of elements at odd position is equal to sum of elements at even position).\\n\\nNow, player1 will take max(nums[0], nums[numsSize-1]) in first step.\\nin 2nd step: number of elements left in array becomes even. Now, since sum(elements at odd positions) == sum(elemenst at even positions) , if both players play optimally they will have same points after after 1st step.\\n\\nSo, player 1 will have more points (points of 1st step + equal points with player2).\\nClearly player1 shold be the winner."
                    },
                    {
                        "username": "adityadeokar123",
                        "content": "[@disturbedbrown1](/disturbedbrown1) Test Case = [0,1,0] ?"
                    },
                    {
                        "username": "Ilkhomjon",
                        "content": "[@disturbedbrown1](/disturbedbrown1) Nope, it depends the values of each element. So can\\'t tell the winner by only considering the number of elements."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Another pattern I noticed that if there are less than 3 elements, than whoever plays first will win."
                    },
                    {
                        "username": "pyoneerC",
                        "content": "Bro if both players are playing \"optimally\" you are not gonna choose 1 over 7 \\n\\n[1,5,233,7] should be false"
                    },
                    {
                        "username": "sikora92",
                        "content": "They see whole array, so do not behave greedy."
                    },
                    {
                        "username": "psionl0",
                        "content": "But if player 1 chooses 1 then no matter what player 2 chooses, player 1 gets the jackpot (233). So choosing 1 over 7 is the optimal strategy."
                    },
                    {
                        "username": "Harrywithcode",
                        "content": "So, I don't understand what author want to say from \" Player 1 picks one of the numbers from either end of the array followed by the player 2 and then player 1 and so on.\" Is there any mistake in this sentence?\\nPlayer 1 picks either end of the array or what?\\nWhy player 1 should followed by player 2? I think player 1 pick first, right?"
                    },
                    {
                        "username": "Dylan_Yifan",
                        "content": "the start of the array is \"one end\" of an array, while the end of the array is the \"other end\" of the array. So the sentence is correct that it\\'s picking \"either end of the array\""
                    }
                ]
            },
            {
                "id": 1989589,
                "content": [
                    {
                        "username": "deleted_user",
                        "content": "I did not understand what the question was asking exactly during the contest. I came up with multiple solutions based on what I thought was being asked, but they were all incorrect. Looks like I finally understood it. I wanted to clarify the question for people who may be confused like me.\\n\\nThe setup should be easy to understand. p1 and p2 take turns in picking a number from the input array, either the first item or the last item. When an item is picked by one of the player, that item cannot be used anymore; you can imagine it being removed from the array.\\n\\nWhat made me confused was the part \"... predict whether player 1 is the winner. You can assume each player plays to maximize his score.\" I was not sure what maximizing the score meant. Here is what it means.\\n\\nLet's say the initial array is [1, 5, 2]. It's p1's turn. p1 will pick either 1 or 2, but it wants to make sure that whichever one he picks will maximize his gain at the end. What if p1 picks 1? Now the array is [5, 2] and it's p2's turn to pick. p2 looks at the current array and thinks about how to maximize his gain at the end. Obviously, picking 5 will maximize his gains. So, p2 will pick 5, leaving 2 for p1. Resulting scores for p1 and p2 are 3 and 5 respectively. This one did not work out for p1.\\n\\nWhat if p1 picks 2 at the beginning? Then the array becomes [1, 5]. Again, p2 looks at the current array and thinks about how to maximize his gain at the end. Picking 5 will maximize his gains. So, p2 will pick 5, leaving 1 for p1. Resulting scores for p1 and p2 are 3 and 5 respectively. This one did not work out for p1 either. Those were the only two possibilities for game play. p1 can never win.\\n\\nWhat if the input array is [1, 5, 233, 7]? For this one, let me list all possibilities and explain which ones are valid and which ones are not.\\n\\n![0_1485064722628_upload-5137006d-197e-47b8-92a3-276224ff6f97](/uploads/files/1485064725743-upload-5137006d-197e-47b8-92a3-276224ff6f97.png) \\n\\nWhat clarified the question for me was realizing that in each step the current player takes a look at the current array as a whole and tries to make the best pick for maximizing it's gain (taking into consideration what the other player may do). \\n\\nI hope this helps someone."
                    },
                    {
                        "username": "watsonsherlock",
                        "content": "[@079_RISHABH](/079_RISHABH) No, the problem is not based on greedy. Greedy means choosing the current best. But it is evident from the second example that if you always choose the best options that is available to you in each step, you will loose the game."
                    },
                    {
                        "username": "786_Rishabh",
                        "content": "Thanks bro. Question was not very clear? But From your explaination I got  point that this  problem is using greedy approach to predict the winner. Earlier it was not clear from the question."
                    },
                    {
                        "username": "Rajat_Shukla",
                        "content": "Thank you for explaining the question :)"
                    },
                    {
                        "username": "luanct",
                        "content": "This is Bob and Alice with stone games. They keep playing even when knowing the winner. Bob has a crush on Alice ngl\\uD83D\\uDE02 "
                    },
                    {
                        "username": "RebelWithoutFlaws",
                        "content": "Who wouldnt fall in love with a girl who spends all of her time playing cryptographic games \\uD83E\\uDD13"
                    },
                    {
                        "username": "aruuu____",
                        "content": "lol\\uD83D\\uDE06\\uD83D\\uDE06"
                    },
                    {
                        "username": "JS00",
                        "content": "This might be the first time they are actually playing a fair game, Bob finally came to his senses!"
                    },
                    {
                        "username": "yjian012",
                        "content": "Yeah I can totally see [how the games go](https://postimg.cc/8f8QbhPF)."
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": "Tip for recursive solutions, the player 1 win on the following conditions:\n1) In player1 turn, player1 can win by picking either left or right side Hint: `||`. \n2) In player2 turn, player1 wins when player1 have larger score than player2 in both possibilities right and left. Hint: `&&`. \n3) Base case: when the range l < r."
                    },
                    {
                        "username": "nitissssh",
                        "content": "[@rayahemesh](/rayahemesh) Note the question says both player play optimally ie , if the player 2 has chance that of to make the \n        // the player one loose , then he will not choose the path in wich the player one wins , so to make sure the\n        // player one always wins no matter how cheeky is the player2 we use && , so that we only return true if there \n        // is no way that player2 ka loose the player1 "
                    },
                    {
                        "username": "stachofsky",
                        "content": "[@shashank-lol](/shashank-lol) sorry the base case... what does `when the range l < r` mean?"
                    },
                    {
                        "username": "pj1999",
                        "content": "[@rayahemesh](/rayahemesh)  for both possibilities of player 2 if either possibility returns in favour of player 2 (say false)  we have to return false as player 2 also plays optimally."
                    },
                    {
                        "username": "chandramani_lc",
                        "content": "[@rayahemesh](/rayahemesh) you have to write the recursion thinking of **can u make Player1 win** be it any possible way. So in the course of doing so u might come across the idea that if it's **player1** turn to pick then he can go with either end element and will declared winner if he wins in any of it's choice (so OR). If it's **Player2** turn then **Player1** can only win if **player1** value is greater than that of **player2** in any of the choices of **Player2**(so we need both true i.e &&). "
                    },
                    {
                        "username": "rayahemesh",
                        "content": "Thanks... can you explain bit clearly why && is for"
                    },
                    {
                        "username": "shashank-lol",
                        "content": "Thanks a lot buddy"
                    },
                    {
                        "username": "kng",
                        "content": "Input:\\n[0,0,7,6,5,6,1]\\nOutput:\\ntrue\\nExpected:\\nfalse\\n\\nI guess the answer should be true since Player 1 can bag 13 points as compared to Player 2 with 12."
                    },
                    {
                        "username": "gd4niele",
                        "content": "Assuming that both players are playing optimally, there can be two cases:\\nFirst case (starting from the first zero): P1 [0, 6, 6, 0] P2 [1, 5, 7]\\nSecond case (starting from 1): P1 [1, 5, 6, 0] P2 [6, 0, 7]\\nSo, in this case, the first player will always lose."
                    },
                    {
                        "username": "N00b_ME",
                        "content": "[@rakeshSharma19](/rakeshSharma19) thanks so much , this cleared my doubts "
                    },
                    {
                        "username": "rakeshSharma19",
                        "content": "Same thing happen to me, think about the case Player1 - [1,5,6,0] and player2 - [6,0,7] you will get your answer"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "Both the players playing optimally for overall game not optimal at each step. "
                    },
                    {
                        "username": "belayneh_12",
                        "content": "the correct answer should be False"
                    },
                    {
                        "username": "gentlezephyr95",
                        "content": "The key step is figuring out that both players will play to maximise the score. This translates the problem to an optimization problem which can be solved with DP.\\nI found this helpful: https://medium.com/algorithms-digest/predict-the-winner-16668e9c1cb8"
                    },
                    {
                        "username": "lolcharles",
                        "content": "[0,0,7,6,5,6,1]\\n\\nApparently player 1 can\\'t win here. Why? \\nOptimized steps for player 2 yields:\\nPlayer 1: 1\\nPlayer 2: 6\\nPlayer 1: 5\\nPlayer 2: 6\\nPlayer 1: 7\\n\\nWith the score 13-12 for player 1."
                    },
                    {
                        "username": "dheeraj2002_",
                        "content": "Try to see a video about min-max algorithm, you would be able to solve the question easily."
                    },
                    {
                        "username": "rakeshSharma19",
                        "content": "If I\\'m your competitor(player 2), Then the steps are\\n\\nPlayer1 chooses 1, array now - [0, 0, 7, 6, 5, 6] Player1: 1, Player2: 0\\nPlayer2 chooses 6, array now - [0, 0, 7, 6, 5] Player1: 1, Player2: 6\\nPlayer1 chooses 5, array now - [0, 0, 7, 6] Player1: 6, Player2: 6\\nPlayer2 chooses 0, array now - [0, 7, 6] Player1: 6, Player2: 6\\nPlayer1 chooses either 0 or 6, array now - [0, 7] Player1: 12, Player2: 6 if chooses 6 \\nPlayer2 chooses 7, array now - [0,] Player1: 12, Player2: 13\\nPlayer2 Will win\\n\\nHere Both the players playing optimally for overall game not optimal at each step.\\nUse DP here to get the solution."
                    },
                    {
                        "username": "enzo_cheng",
                        "content": "If i'm your competitor (Player 2), after this step:\n>>> Player 1 chooses 5 [0,0.7,6] Player1: 6, Player2: 6\nPlayer 2 will select 0,\n>>> Player 2 chooses 0 [0,7,6] Player1: 6, Player2: 6\n>>> Player 1 chooses 6 [0,7] Player1: 12, Player2: 6\n>>> Player 2 chooses 7 [0] Player1: 12, Player2: 13\n\nResult is that Player 2 wins always"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Game theory. 2 people contest. like chess game or go! Use DP to solve! Similar questions\n# Stone Game~  Stone Game IX"
                    },
                    {
                        "username": "riturajsingh487",
                        "content": "Player 1 can never lose in this test case (wrong test case).\\n\\nFact: if number of elements in an array are even , then whoever plays first will win (or tie if sum of elements at odd position is equal to sum of elements at even position).\\n\\nNow, player1 will take max(nums[0], nums[numsSize-1]) in first step.\\nin 2nd step: number of elements left in array becomes even. Now, since sum(elements at odd positions) == sum(elemenst at even positions) , if both players play optimally they will have same points after after 1st step.\\n\\nSo, player 1 will have more points (points of 1st step + equal points with player2).\\nClearly player1 shold be the winner."
                    },
                    {
                        "username": "adityadeokar123",
                        "content": "[@disturbedbrown1](/disturbedbrown1) Test Case = [0,1,0] ?"
                    },
                    {
                        "username": "Ilkhomjon",
                        "content": "[@disturbedbrown1](/disturbedbrown1) Nope, it depends the values of each element. So can\\'t tell the winner by only considering the number of elements."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Another pattern I noticed that if there are less than 3 elements, than whoever plays first will win."
                    },
                    {
                        "username": "pyoneerC",
                        "content": "Bro if both players are playing \"optimally\" you are not gonna choose 1 over 7 \\n\\n[1,5,233,7] should be false"
                    },
                    {
                        "username": "sikora92",
                        "content": "They see whole array, so do not behave greedy."
                    },
                    {
                        "username": "psionl0",
                        "content": "But if player 1 chooses 1 then no matter what player 2 chooses, player 1 gets the jackpot (233). So choosing 1 over 7 is the optimal strategy."
                    },
                    {
                        "username": "Harrywithcode",
                        "content": "So, I don't understand what author want to say from \" Player 1 picks one of the numbers from either end of the array followed by the player 2 and then player 1 and so on.\" Is there any mistake in this sentence?\\nPlayer 1 picks either end of the array or what?\\nWhy player 1 should followed by player 2? I think player 1 pick first, right?"
                    },
                    {
                        "username": "Dylan_Yifan",
                        "content": "the start of the array is \"one end\" of an array, while the end of the array is the \"other end\" of the array. So the sentence is correct that it\\'s picking \"either end of the array\""
                    }
                ]
            },
            {
                "id": 1569129,
                "content": [
                    {
                        "username": "deleted_user",
                        "content": "I did not understand what the question was asking exactly during the contest. I came up with multiple solutions based on what I thought was being asked, but they were all incorrect. Looks like I finally understood it. I wanted to clarify the question for people who may be confused like me.\\n\\nThe setup should be easy to understand. p1 and p2 take turns in picking a number from the input array, either the first item or the last item. When an item is picked by one of the player, that item cannot be used anymore; you can imagine it being removed from the array.\\n\\nWhat made me confused was the part \"... predict whether player 1 is the winner. You can assume each player plays to maximize his score.\" I was not sure what maximizing the score meant. Here is what it means.\\n\\nLet's say the initial array is [1, 5, 2]. It's p1's turn. p1 will pick either 1 or 2, but it wants to make sure that whichever one he picks will maximize his gain at the end. What if p1 picks 1? Now the array is [5, 2] and it's p2's turn to pick. p2 looks at the current array and thinks about how to maximize his gain at the end. Obviously, picking 5 will maximize his gains. So, p2 will pick 5, leaving 2 for p1. Resulting scores for p1 and p2 are 3 and 5 respectively. This one did not work out for p1.\\n\\nWhat if p1 picks 2 at the beginning? Then the array becomes [1, 5]. Again, p2 looks at the current array and thinks about how to maximize his gain at the end. Picking 5 will maximize his gains. So, p2 will pick 5, leaving 1 for p1. Resulting scores for p1 and p2 are 3 and 5 respectively. This one did not work out for p1 either. Those were the only two possibilities for game play. p1 can never win.\\n\\nWhat if the input array is [1, 5, 233, 7]? For this one, let me list all possibilities and explain which ones are valid and which ones are not.\\n\\n![0_1485064722628_upload-5137006d-197e-47b8-92a3-276224ff6f97](/uploads/files/1485064725743-upload-5137006d-197e-47b8-92a3-276224ff6f97.png) \\n\\nWhat clarified the question for me was realizing that in each step the current player takes a look at the current array as a whole and tries to make the best pick for maximizing it's gain (taking into consideration what the other player may do). \\n\\nI hope this helps someone."
                    },
                    {
                        "username": "watsonsherlock",
                        "content": "[@079_RISHABH](/079_RISHABH) No, the problem is not based on greedy. Greedy means choosing the current best. But it is evident from the second example that if you always choose the best options that is available to you in each step, you will loose the game."
                    },
                    {
                        "username": "786_Rishabh",
                        "content": "Thanks bro. Question was not very clear? But From your explaination I got  point that this  problem is using greedy approach to predict the winner. Earlier it was not clear from the question."
                    },
                    {
                        "username": "Rajat_Shukla",
                        "content": "Thank you for explaining the question :)"
                    },
                    {
                        "username": "luanct",
                        "content": "This is Bob and Alice with stone games. They keep playing even when knowing the winner. Bob has a crush on Alice ngl\\uD83D\\uDE02 "
                    },
                    {
                        "username": "RebelWithoutFlaws",
                        "content": "Who wouldnt fall in love with a girl who spends all of her time playing cryptographic games \\uD83E\\uDD13"
                    },
                    {
                        "username": "aruuu____",
                        "content": "lol\\uD83D\\uDE06\\uD83D\\uDE06"
                    },
                    {
                        "username": "JS00",
                        "content": "This might be the first time they are actually playing a fair game, Bob finally came to his senses!"
                    },
                    {
                        "username": "yjian012",
                        "content": "Yeah I can totally see [how the games go](https://postimg.cc/8f8QbhPF)."
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": "Tip for recursive solutions, the player 1 win on the following conditions:\n1) In player1 turn, player1 can win by picking either left or right side Hint: `||`. \n2) In player2 turn, player1 wins when player1 have larger score than player2 in both possibilities right and left. Hint: `&&`. \n3) Base case: when the range l < r."
                    },
                    {
                        "username": "nitissssh",
                        "content": "[@rayahemesh](/rayahemesh) Note the question says both player play optimally ie , if the player 2 has chance that of to make the \n        // the player one loose , then he will not choose the path in wich the player one wins , so to make sure the\n        // player one always wins no matter how cheeky is the player2 we use && , so that we only return true if there \n        // is no way that player2 ka loose the player1 "
                    },
                    {
                        "username": "stachofsky",
                        "content": "[@shashank-lol](/shashank-lol) sorry the base case... what does `when the range l < r` mean?"
                    },
                    {
                        "username": "pj1999",
                        "content": "[@rayahemesh](/rayahemesh)  for both possibilities of player 2 if either possibility returns in favour of player 2 (say false)  we have to return false as player 2 also plays optimally."
                    },
                    {
                        "username": "chandramani_lc",
                        "content": "[@rayahemesh](/rayahemesh) you have to write the recursion thinking of **can u make Player1 win** be it any possible way. So in the course of doing so u might come across the idea that if it's **player1** turn to pick then he can go with either end element and will declared winner if he wins in any of it's choice (so OR). If it's **Player2** turn then **Player1** can only win if **player1** value is greater than that of **player2** in any of the choices of **Player2**(so we need both true i.e &&). "
                    },
                    {
                        "username": "rayahemesh",
                        "content": "Thanks... can you explain bit clearly why && is for"
                    },
                    {
                        "username": "shashank-lol",
                        "content": "Thanks a lot buddy"
                    },
                    {
                        "username": "kng",
                        "content": "Input:\\n[0,0,7,6,5,6,1]\\nOutput:\\ntrue\\nExpected:\\nfalse\\n\\nI guess the answer should be true since Player 1 can bag 13 points as compared to Player 2 with 12."
                    },
                    {
                        "username": "gd4niele",
                        "content": "Assuming that both players are playing optimally, there can be two cases:\\nFirst case (starting from the first zero): P1 [0, 6, 6, 0] P2 [1, 5, 7]\\nSecond case (starting from 1): P1 [1, 5, 6, 0] P2 [6, 0, 7]\\nSo, in this case, the first player will always lose."
                    },
                    {
                        "username": "N00b_ME",
                        "content": "[@rakeshSharma19](/rakeshSharma19) thanks so much , this cleared my doubts "
                    },
                    {
                        "username": "rakeshSharma19",
                        "content": "Same thing happen to me, think about the case Player1 - [1,5,6,0] and player2 - [6,0,7] you will get your answer"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "Both the players playing optimally for overall game not optimal at each step. "
                    },
                    {
                        "username": "belayneh_12",
                        "content": "the correct answer should be False"
                    },
                    {
                        "username": "gentlezephyr95",
                        "content": "The key step is figuring out that both players will play to maximise the score. This translates the problem to an optimization problem which can be solved with DP.\\nI found this helpful: https://medium.com/algorithms-digest/predict-the-winner-16668e9c1cb8"
                    },
                    {
                        "username": "lolcharles",
                        "content": "[0,0,7,6,5,6,1]\\n\\nApparently player 1 can\\'t win here. Why? \\nOptimized steps for player 2 yields:\\nPlayer 1: 1\\nPlayer 2: 6\\nPlayer 1: 5\\nPlayer 2: 6\\nPlayer 1: 7\\n\\nWith the score 13-12 for player 1."
                    },
                    {
                        "username": "dheeraj2002_",
                        "content": "Try to see a video about min-max algorithm, you would be able to solve the question easily."
                    },
                    {
                        "username": "rakeshSharma19",
                        "content": "If I\\'m your competitor(player 2), Then the steps are\\n\\nPlayer1 chooses 1, array now - [0, 0, 7, 6, 5, 6] Player1: 1, Player2: 0\\nPlayer2 chooses 6, array now - [0, 0, 7, 6, 5] Player1: 1, Player2: 6\\nPlayer1 chooses 5, array now - [0, 0, 7, 6] Player1: 6, Player2: 6\\nPlayer2 chooses 0, array now - [0, 7, 6] Player1: 6, Player2: 6\\nPlayer1 chooses either 0 or 6, array now - [0, 7] Player1: 12, Player2: 6 if chooses 6 \\nPlayer2 chooses 7, array now - [0,] Player1: 12, Player2: 13\\nPlayer2 Will win\\n\\nHere Both the players playing optimally for overall game not optimal at each step.\\nUse DP here to get the solution."
                    },
                    {
                        "username": "enzo_cheng",
                        "content": "If i'm your competitor (Player 2), after this step:\n>>> Player 1 chooses 5 [0,0.7,6] Player1: 6, Player2: 6\nPlayer 2 will select 0,\n>>> Player 2 chooses 0 [0,7,6] Player1: 6, Player2: 6\n>>> Player 1 chooses 6 [0,7] Player1: 12, Player2: 6\n>>> Player 2 chooses 7 [0] Player1: 12, Player2: 13\n\nResult is that Player 2 wins always"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Game theory. 2 people contest. like chess game or go! Use DP to solve! Similar questions\n# Stone Game~  Stone Game IX"
                    },
                    {
                        "username": "riturajsingh487",
                        "content": "Player 1 can never lose in this test case (wrong test case).\\n\\nFact: if number of elements in an array are even , then whoever plays first will win (or tie if sum of elements at odd position is equal to sum of elements at even position).\\n\\nNow, player1 will take max(nums[0], nums[numsSize-1]) in first step.\\nin 2nd step: number of elements left in array becomes even. Now, since sum(elements at odd positions) == sum(elemenst at even positions) , if both players play optimally they will have same points after after 1st step.\\n\\nSo, player 1 will have more points (points of 1st step + equal points with player2).\\nClearly player1 shold be the winner."
                    },
                    {
                        "username": "adityadeokar123",
                        "content": "[@disturbedbrown1](/disturbedbrown1) Test Case = [0,1,0] ?"
                    },
                    {
                        "username": "Ilkhomjon",
                        "content": "[@disturbedbrown1](/disturbedbrown1) Nope, it depends the values of each element. So can\\'t tell the winner by only considering the number of elements."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Another pattern I noticed that if there are less than 3 elements, than whoever plays first will win."
                    },
                    {
                        "username": "pyoneerC",
                        "content": "Bro if both players are playing \"optimally\" you are not gonna choose 1 over 7 \\n\\n[1,5,233,7] should be false"
                    },
                    {
                        "username": "sikora92",
                        "content": "They see whole array, so do not behave greedy."
                    },
                    {
                        "username": "psionl0",
                        "content": "But if player 1 chooses 1 then no matter what player 2 chooses, player 1 gets the jackpot (233). So choosing 1 over 7 is the optimal strategy."
                    },
                    {
                        "username": "Harrywithcode",
                        "content": "So, I don't understand what author want to say from \" Player 1 picks one of the numbers from either end of the array followed by the player 2 and then player 1 and so on.\" Is there any mistake in this sentence?\\nPlayer 1 picks either end of the array or what?\\nWhy player 1 should followed by player 2? I think player 1 pick first, right?"
                    },
                    {
                        "username": "Dylan_Yifan",
                        "content": "the start of the array is \"one end\" of an array, while the end of the array is the \"other end\" of the array. So the sentence is correct that it\\'s picking \"either end of the array\""
                    }
                ]
            },
            {
                "id": 1565119,
                "content": [
                    {
                        "username": "deleted_user",
                        "content": "I did not understand what the question was asking exactly during the contest. I came up with multiple solutions based on what I thought was being asked, but they were all incorrect. Looks like I finally understood it. I wanted to clarify the question for people who may be confused like me.\\n\\nThe setup should be easy to understand. p1 and p2 take turns in picking a number from the input array, either the first item or the last item. When an item is picked by one of the player, that item cannot be used anymore; you can imagine it being removed from the array.\\n\\nWhat made me confused was the part \"... predict whether player 1 is the winner. You can assume each player plays to maximize his score.\" I was not sure what maximizing the score meant. Here is what it means.\\n\\nLet's say the initial array is [1, 5, 2]. It's p1's turn. p1 will pick either 1 or 2, but it wants to make sure that whichever one he picks will maximize his gain at the end. What if p1 picks 1? Now the array is [5, 2] and it's p2's turn to pick. p2 looks at the current array and thinks about how to maximize his gain at the end. Obviously, picking 5 will maximize his gains. So, p2 will pick 5, leaving 2 for p1. Resulting scores for p1 and p2 are 3 and 5 respectively. This one did not work out for p1.\\n\\nWhat if p1 picks 2 at the beginning? Then the array becomes [1, 5]. Again, p2 looks at the current array and thinks about how to maximize his gain at the end. Picking 5 will maximize his gains. So, p2 will pick 5, leaving 1 for p1. Resulting scores for p1 and p2 are 3 and 5 respectively. This one did not work out for p1 either. Those were the only two possibilities for game play. p1 can never win.\\n\\nWhat if the input array is [1, 5, 233, 7]? For this one, let me list all possibilities and explain which ones are valid and which ones are not.\\n\\n![0_1485064722628_upload-5137006d-197e-47b8-92a3-276224ff6f97](/uploads/files/1485064725743-upload-5137006d-197e-47b8-92a3-276224ff6f97.png) \\n\\nWhat clarified the question for me was realizing that in each step the current player takes a look at the current array as a whole and tries to make the best pick for maximizing it's gain (taking into consideration what the other player may do). \\n\\nI hope this helps someone."
                    },
                    {
                        "username": "watsonsherlock",
                        "content": "[@079_RISHABH](/079_RISHABH) No, the problem is not based on greedy. Greedy means choosing the current best. But it is evident from the second example that if you always choose the best options that is available to you in each step, you will loose the game."
                    },
                    {
                        "username": "786_Rishabh",
                        "content": "Thanks bro. Question was not very clear? But From your explaination I got  point that this  problem is using greedy approach to predict the winner. Earlier it was not clear from the question."
                    },
                    {
                        "username": "Rajat_Shukla",
                        "content": "Thank you for explaining the question :)"
                    },
                    {
                        "username": "luanct",
                        "content": "This is Bob and Alice with stone games. They keep playing even when knowing the winner. Bob has a crush on Alice ngl\\uD83D\\uDE02 "
                    },
                    {
                        "username": "RebelWithoutFlaws",
                        "content": "Who wouldnt fall in love with a girl who spends all of her time playing cryptographic games \\uD83E\\uDD13"
                    },
                    {
                        "username": "aruuu____",
                        "content": "lol\\uD83D\\uDE06\\uD83D\\uDE06"
                    },
                    {
                        "username": "JS00",
                        "content": "This might be the first time they are actually playing a fair game, Bob finally came to his senses!"
                    },
                    {
                        "username": "yjian012",
                        "content": "Yeah I can totally see [how the games go](https://postimg.cc/8f8QbhPF)."
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": "Tip for recursive solutions, the player 1 win on the following conditions:\n1) In player1 turn, player1 can win by picking either left or right side Hint: `||`. \n2) In player2 turn, player1 wins when player1 have larger score than player2 in both possibilities right and left. Hint: `&&`. \n3) Base case: when the range l < r."
                    },
                    {
                        "username": "nitissssh",
                        "content": "[@rayahemesh](/rayahemesh) Note the question says both player play optimally ie , if the player 2 has chance that of to make the \n        // the player one loose , then he will not choose the path in wich the player one wins , so to make sure the\n        // player one always wins no matter how cheeky is the player2 we use && , so that we only return true if there \n        // is no way that player2 ka loose the player1 "
                    },
                    {
                        "username": "stachofsky",
                        "content": "[@shashank-lol](/shashank-lol) sorry the base case... what does `when the range l < r` mean?"
                    },
                    {
                        "username": "pj1999",
                        "content": "[@rayahemesh](/rayahemesh)  for both possibilities of player 2 if either possibility returns in favour of player 2 (say false)  we have to return false as player 2 also plays optimally."
                    },
                    {
                        "username": "chandramani_lc",
                        "content": "[@rayahemesh](/rayahemesh) you have to write the recursion thinking of **can u make Player1 win** be it any possible way. So in the course of doing so u might come across the idea that if it's **player1** turn to pick then he can go with either end element and will declared winner if he wins in any of it's choice (so OR). If it's **Player2** turn then **Player1** can only win if **player1** value is greater than that of **player2** in any of the choices of **Player2**(so we need both true i.e &&). "
                    },
                    {
                        "username": "rayahemesh",
                        "content": "Thanks... can you explain bit clearly why && is for"
                    },
                    {
                        "username": "shashank-lol",
                        "content": "Thanks a lot buddy"
                    },
                    {
                        "username": "kng",
                        "content": "Input:\\n[0,0,7,6,5,6,1]\\nOutput:\\ntrue\\nExpected:\\nfalse\\n\\nI guess the answer should be true since Player 1 can bag 13 points as compared to Player 2 with 12."
                    },
                    {
                        "username": "gd4niele",
                        "content": "Assuming that both players are playing optimally, there can be two cases:\\nFirst case (starting from the first zero): P1 [0, 6, 6, 0] P2 [1, 5, 7]\\nSecond case (starting from 1): P1 [1, 5, 6, 0] P2 [6, 0, 7]\\nSo, in this case, the first player will always lose."
                    },
                    {
                        "username": "N00b_ME",
                        "content": "[@rakeshSharma19](/rakeshSharma19) thanks so much , this cleared my doubts "
                    },
                    {
                        "username": "rakeshSharma19",
                        "content": "Same thing happen to me, think about the case Player1 - [1,5,6,0] and player2 - [6,0,7] you will get your answer"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "Both the players playing optimally for overall game not optimal at each step. "
                    },
                    {
                        "username": "belayneh_12",
                        "content": "the correct answer should be False"
                    },
                    {
                        "username": "gentlezephyr95",
                        "content": "The key step is figuring out that both players will play to maximise the score. This translates the problem to an optimization problem which can be solved with DP.\\nI found this helpful: https://medium.com/algorithms-digest/predict-the-winner-16668e9c1cb8"
                    },
                    {
                        "username": "lolcharles",
                        "content": "[0,0,7,6,5,6,1]\\n\\nApparently player 1 can\\'t win here. Why? \\nOptimized steps for player 2 yields:\\nPlayer 1: 1\\nPlayer 2: 6\\nPlayer 1: 5\\nPlayer 2: 6\\nPlayer 1: 7\\n\\nWith the score 13-12 for player 1."
                    },
                    {
                        "username": "dheeraj2002_",
                        "content": "Try to see a video about min-max algorithm, you would be able to solve the question easily."
                    },
                    {
                        "username": "rakeshSharma19",
                        "content": "If I\\'m your competitor(player 2), Then the steps are\\n\\nPlayer1 chooses 1, array now - [0, 0, 7, 6, 5, 6] Player1: 1, Player2: 0\\nPlayer2 chooses 6, array now - [0, 0, 7, 6, 5] Player1: 1, Player2: 6\\nPlayer1 chooses 5, array now - [0, 0, 7, 6] Player1: 6, Player2: 6\\nPlayer2 chooses 0, array now - [0, 7, 6] Player1: 6, Player2: 6\\nPlayer1 chooses either 0 or 6, array now - [0, 7] Player1: 12, Player2: 6 if chooses 6 \\nPlayer2 chooses 7, array now - [0,] Player1: 12, Player2: 13\\nPlayer2 Will win\\n\\nHere Both the players playing optimally for overall game not optimal at each step.\\nUse DP here to get the solution."
                    },
                    {
                        "username": "enzo_cheng",
                        "content": "If i'm your competitor (Player 2), after this step:\n>>> Player 1 chooses 5 [0,0.7,6] Player1: 6, Player2: 6\nPlayer 2 will select 0,\n>>> Player 2 chooses 0 [0,7,6] Player1: 6, Player2: 6\n>>> Player 1 chooses 6 [0,7] Player1: 12, Player2: 6\n>>> Player 2 chooses 7 [0] Player1: 12, Player2: 13\n\nResult is that Player 2 wins always"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Game theory. 2 people contest. like chess game or go! Use DP to solve! Similar questions\n# Stone Game~  Stone Game IX"
                    },
                    {
                        "username": "riturajsingh487",
                        "content": "Player 1 can never lose in this test case (wrong test case).\\n\\nFact: if number of elements in an array are even , then whoever plays first will win (or tie if sum of elements at odd position is equal to sum of elements at even position).\\n\\nNow, player1 will take max(nums[0], nums[numsSize-1]) in first step.\\nin 2nd step: number of elements left in array becomes even. Now, since sum(elements at odd positions) == sum(elemenst at even positions) , if both players play optimally they will have same points after after 1st step.\\n\\nSo, player 1 will have more points (points of 1st step + equal points with player2).\\nClearly player1 shold be the winner."
                    },
                    {
                        "username": "adityadeokar123",
                        "content": "[@disturbedbrown1](/disturbedbrown1) Test Case = [0,1,0] ?"
                    },
                    {
                        "username": "Ilkhomjon",
                        "content": "[@disturbedbrown1](/disturbedbrown1) Nope, it depends the values of each element. So can\\'t tell the winner by only considering the number of elements."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Another pattern I noticed that if there are less than 3 elements, than whoever plays first will win."
                    },
                    {
                        "username": "pyoneerC",
                        "content": "Bro if both players are playing \"optimally\" you are not gonna choose 1 over 7 \\n\\n[1,5,233,7] should be false"
                    },
                    {
                        "username": "sikora92",
                        "content": "They see whole array, so do not behave greedy."
                    },
                    {
                        "username": "psionl0",
                        "content": "But if player 1 chooses 1 then no matter what player 2 chooses, player 1 gets the jackpot (233). So choosing 1 over 7 is the optimal strategy."
                    },
                    {
                        "username": "Harrywithcode",
                        "content": "So, I don't understand what author want to say from \" Player 1 picks one of the numbers from either end of the array followed by the player 2 and then player 1 and so on.\" Is there any mistake in this sentence?\\nPlayer 1 picks either end of the array or what?\\nWhy player 1 should followed by player 2? I think player 1 pick first, right?"
                    },
                    {
                        "username": "Dylan_Yifan",
                        "content": "the start of the array is \"one end\" of an array, while the end of the array is the \"other end\" of the array. So the sentence is correct that it\\'s picking \"either end of the array\""
                    }
                ]
            },
            {
                "id": 1989476,
                "content": [
                    {
                        "username": "deleted_user",
                        "content": "I did not understand what the question was asking exactly during the contest. I came up with multiple solutions based on what I thought was being asked, but they were all incorrect. Looks like I finally understood it. I wanted to clarify the question for people who may be confused like me.\\n\\nThe setup should be easy to understand. p1 and p2 take turns in picking a number from the input array, either the first item or the last item. When an item is picked by one of the player, that item cannot be used anymore; you can imagine it being removed from the array.\\n\\nWhat made me confused was the part \"... predict whether player 1 is the winner. You can assume each player plays to maximize his score.\" I was not sure what maximizing the score meant. Here is what it means.\\n\\nLet's say the initial array is [1, 5, 2]. It's p1's turn. p1 will pick either 1 or 2, but it wants to make sure that whichever one he picks will maximize his gain at the end. What if p1 picks 1? Now the array is [5, 2] and it's p2's turn to pick. p2 looks at the current array and thinks about how to maximize his gain at the end. Obviously, picking 5 will maximize his gains. So, p2 will pick 5, leaving 2 for p1. Resulting scores for p1 and p2 are 3 and 5 respectively. This one did not work out for p1.\\n\\nWhat if p1 picks 2 at the beginning? Then the array becomes [1, 5]. Again, p2 looks at the current array and thinks about how to maximize his gain at the end. Picking 5 will maximize his gains. So, p2 will pick 5, leaving 1 for p1. Resulting scores for p1 and p2 are 3 and 5 respectively. This one did not work out for p1 either. Those were the only two possibilities for game play. p1 can never win.\\n\\nWhat if the input array is [1, 5, 233, 7]? For this one, let me list all possibilities and explain which ones are valid and which ones are not.\\n\\n![0_1485064722628_upload-5137006d-197e-47b8-92a3-276224ff6f97](/uploads/files/1485064725743-upload-5137006d-197e-47b8-92a3-276224ff6f97.png) \\n\\nWhat clarified the question for me was realizing that in each step the current player takes a look at the current array as a whole and tries to make the best pick for maximizing it's gain (taking into consideration what the other player may do). \\n\\nI hope this helps someone."
                    },
                    {
                        "username": "watsonsherlock",
                        "content": "[@079_RISHABH](/079_RISHABH) No, the problem is not based on greedy. Greedy means choosing the current best. But it is evident from the second example that if you always choose the best options that is available to you in each step, you will loose the game."
                    },
                    {
                        "username": "786_Rishabh",
                        "content": "Thanks bro. Question was not very clear? But From your explaination I got  point that this  problem is using greedy approach to predict the winner. Earlier it was not clear from the question."
                    },
                    {
                        "username": "Rajat_Shukla",
                        "content": "Thank you for explaining the question :)"
                    },
                    {
                        "username": "luanct",
                        "content": "This is Bob and Alice with stone games. They keep playing even when knowing the winner. Bob has a crush on Alice ngl\\uD83D\\uDE02 "
                    },
                    {
                        "username": "RebelWithoutFlaws",
                        "content": "Who wouldnt fall in love with a girl who spends all of her time playing cryptographic games \\uD83E\\uDD13"
                    },
                    {
                        "username": "aruuu____",
                        "content": "lol\\uD83D\\uDE06\\uD83D\\uDE06"
                    },
                    {
                        "username": "JS00",
                        "content": "This might be the first time they are actually playing a fair game, Bob finally came to his senses!"
                    },
                    {
                        "username": "yjian012",
                        "content": "Yeah I can totally see [how the games go](https://postimg.cc/8f8QbhPF)."
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": "Tip for recursive solutions, the player 1 win on the following conditions:\n1) In player1 turn, player1 can win by picking either left or right side Hint: `||`. \n2) In player2 turn, player1 wins when player1 have larger score than player2 in both possibilities right and left. Hint: `&&`. \n3) Base case: when the range l < r."
                    },
                    {
                        "username": "nitissssh",
                        "content": "[@rayahemesh](/rayahemesh) Note the question says both player play optimally ie , if the player 2 has chance that of to make the \n        // the player one loose , then he will not choose the path in wich the player one wins , so to make sure the\n        // player one always wins no matter how cheeky is the player2 we use && , so that we only return true if there \n        // is no way that player2 ka loose the player1 "
                    },
                    {
                        "username": "stachofsky",
                        "content": "[@shashank-lol](/shashank-lol) sorry the base case... what does `when the range l < r` mean?"
                    },
                    {
                        "username": "pj1999",
                        "content": "[@rayahemesh](/rayahemesh)  for both possibilities of player 2 if either possibility returns in favour of player 2 (say false)  we have to return false as player 2 also plays optimally."
                    },
                    {
                        "username": "chandramani_lc",
                        "content": "[@rayahemesh](/rayahemesh) you have to write the recursion thinking of **can u make Player1 win** be it any possible way. So in the course of doing so u might come across the idea that if it's **player1** turn to pick then he can go with either end element and will declared winner if he wins in any of it's choice (so OR). If it's **Player2** turn then **Player1** can only win if **player1** value is greater than that of **player2** in any of the choices of **Player2**(so we need both true i.e &&). "
                    },
                    {
                        "username": "rayahemesh",
                        "content": "Thanks... can you explain bit clearly why && is for"
                    },
                    {
                        "username": "shashank-lol",
                        "content": "Thanks a lot buddy"
                    },
                    {
                        "username": "kng",
                        "content": "Input:\\n[0,0,7,6,5,6,1]\\nOutput:\\ntrue\\nExpected:\\nfalse\\n\\nI guess the answer should be true since Player 1 can bag 13 points as compared to Player 2 with 12."
                    },
                    {
                        "username": "gd4niele",
                        "content": "Assuming that both players are playing optimally, there can be two cases:\\nFirst case (starting from the first zero): P1 [0, 6, 6, 0] P2 [1, 5, 7]\\nSecond case (starting from 1): P1 [1, 5, 6, 0] P2 [6, 0, 7]\\nSo, in this case, the first player will always lose."
                    },
                    {
                        "username": "N00b_ME",
                        "content": "[@rakeshSharma19](/rakeshSharma19) thanks so much , this cleared my doubts "
                    },
                    {
                        "username": "rakeshSharma19",
                        "content": "Same thing happen to me, think about the case Player1 - [1,5,6,0] and player2 - [6,0,7] you will get your answer"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "Both the players playing optimally for overall game not optimal at each step. "
                    },
                    {
                        "username": "belayneh_12",
                        "content": "the correct answer should be False"
                    },
                    {
                        "username": "gentlezephyr95",
                        "content": "The key step is figuring out that both players will play to maximise the score. This translates the problem to an optimization problem which can be solved with DP.\\nI found this helpful: https://medium.com/algorithms-digest/predict-the-winner-16668e9c1cb8"
                    },
                    {
                        "username": "lolcharles",
                        "content": "[0,0,7,6,5,6,1]\\n\\nApparently player 1 can\\'t win here. Why? \\nOptimized steps for player 2 yields:\\nPlayer 1: 1\\nPlayer 2: 6\\nPlayer 1: 5\\nPlayer 2: 6\\nPlayer 1: 7\\n\\nWith the score 13-12 for player 1."
                    },
                    {
                        "username": "dheeraj2002_",
                        "content": "Try to see a video about min-max algorithm, you would be able to solve the question easily."
                    },
                    {
                        "username": "rakeshSharma19",
                        "content": "If I\\'m your competitor(player 2), Then the steps are\\n\\nPlayer1 chooses 1, array now - [0, 0, 7, 6, 5, 6] Player1: 1, Player2: 0\\nPlayer2 chooses 6, array now - [0, 0, 7, 6, 5] Player1: 1, Player2: 6\\nPlayer1 chooses 5, array now - [0, 0, 7, 6] Player1: 6, Player2: 6\\nPlayer2 chooses 0, array now - [0, 7, 6] Player1: 6, Player2: 6\\nPlayer1 chooses either 0 or 6, array now - [0, 7] Player1: 12, Player2: 6 if chooses 6 \\nPlayer2 chooses 7, array now - [0,] Player1: 12, Player2: 13\\nPlayer2 Will win\\n\\nHere Both the players playing optimally for overall game not optimal at each step.\\nUse DP here to get the solution."
                    },
                    {
                        "username": "enzo_cheng",
                        "content": "If i'm your competitor (Player 2), after this step:\n>>> Player 1 chooses 5 [0,0.7,6] Player1: 6, Player2: 6\nPlayer 2 will select 0,\n>>> Player 2 chooses 0 [0,7,6] Player1: 6, Player2: 6\n>>> Player 1 chooses 6 [0,7] Player1: 12, Player2: 6\n>>> Player 2 chooses 7 [0] Player1: 12, Player2: 13\n\nResult is that Player 2 wins always"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Game theory. 2 people contest. like chess game or go! Use DP to solve! Similar questions\n# Stone Game~  Stone Game IX"
                    },
                    {
                        "username": "riturajsingh487",
                        "content": "Player 1 can never lose in this test case (wrong test case).\\n\\nFact: if number of elements in an array are even , then whoever plays first will win (or tie if sum of elements at odd position is equal to sum of elements at even position).\\n\\nNow, player1 will take max(nums[0], nums[numsSize-1]) in first step.\\nin 2nd step: number of elements left in array becomes even. Now, since sum(elements at odd positions) == sum(elemenst at even positions) , if both players play optimally they will have same points after after 1st step.\\n\\nSo, player 1 will have more points (points of 1st step + equal points with player2).\\nClearly player1 shold be the winner."
                    },
                    {
                        "username": "adityadeokar123",
                        "content": "[@disturbedbrown1](/disturbedbrown1) Test Case = [0,1,0] ?"
                    },
                    {
                        "username": "Ilkhomjon",
                        "content": "[@disturbedbrown1](/disturbedbrown1) Nope, it depends the values of each element. So can\\'t tell the winner by only considering the number of elements."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Another pattern I noticed that if there are less than 3 elements, than whoever plays first will win."
                    },
                    {
                        "username": "pyoneerC",
                        "content": "Bro if both players are playing \"optimally\" you are not gonna choose 1 over 7 \\n\\n[1,5,233,7] should be false"
                    },
                    {
                        "username": "sikora92",
                        "content": "They see whole array, so do not behave greedy."
                    },
                    {
                        "username": "psionl0",
                        "content": "But if player 1 chooses 1 then no matter what player 2 chooses, player 1 gets the jackpot (233). So choosing 1 over 7 is the optimal strategy."
                    },
                    {
                        "username": "Harrywithcode",
                        "content": "So, I don't understand what author want to say from \" Player 1 picks one of the numbers from either end of the array followed by the player 2 and then player 1 and so on.\" Is there any mistake in this sentence?\\nPlayer 1 picks either end of the array or what?\\nWhy player 1 should followed by player 2? I think player 1 pick first, right?"
                    },
                    {
                        "username": "Dylan_Yifan",
                        "content": "the start of the array is \"one end\" of an array, while the end of the array is the \"other end\" of the array. So the sentence is correct that it\\'s picking \"either end of the array\""
                    }
                ]
            },
            {
                "id": 1989495,
                "content": [
                    {
                        "username": "deleted_user",
                        "content": "I did not understand what the question was asking exactly during the contest. I came up with multiple solutions based on what I thought was being asked, but they were all incorrect. Looks like I finally understood it. I wanted to clarify the question for people who may be confused like me.\\n\\nThe setup should be easy to understand. p1 and p2 take turns in picking a number from the input array, either the first item or the last item. When an item is picked by one of the player, that item cannot be used anymore; you can imagine it being removed from the array.\\n\\nWhat made me confused was the part \"... predict whether player 1 is the winner. You can assume each player plays to maximize his score.\" I was not sure what maximizing the score meant. Here is what it means.\\n\\nLet's say the initial array is [1, 5, 2]. It's p1's turn. p1 will pick either 1 or 2, but it wants to make sure that whichever one he picks will maximize his gain at the end. What if p1 picks 1? Now the array is [5, 2] and it's p2's turn to pick. p2 looks at the current array and thinks about how to maximize his gain at the end. Obviously, picking 5 will maximize his gains. So, p2 will pick 5, leaving 2 for p1. Resulting scores for p1 and p2 are 3 and 5 respectively. This one did not work out for p1.\\n\\nWhat if p1 picks 2 at the beginning? Then the array becomes [1, 5]. Again, p2 looks at the current array and thinks about how to maximize his gain at the end. Picking 5 will maximize his gains. So, p2 will pick 5, leaving 1 for p1. Resulting scores for p1 and p2 are 3 and 5 respectively. This one did not work out for p1 either. Those were the only two possibilities for game play. p1 can never win.\\n\\nWhat if the input array is [1, 5, 233, 7]? For this one, let me list all possibilities and explain which ones are valid and which ones are not.\\n\\n![0_1485064722628_upload-5137006d-197e-47b8-92a3-276224ff6f97](/uploads/files/1485064725743-upload-5137006d-197e-47b8-92a3-276224ff6f97.png) \\n\\nWhat clarified the question for me was realizing that in each step the current player takes a look at the current array as a whole and tries to make the best pick for maximizing it's gain (taking into consideration what the other player may do). \\n\\nI hope this helps someone."
                    },
                    {
                        "username": "watsonsherlock",
                        "content": "[@079_RISHABH](/079_RISHABH) No, the problem is not based on greedy. Greedy means choosing the current best. But it is evident from the second example that if you always choose the best options that is available to you in each step, you will loose the game."
                    },
                    {
                        "username": "786_Rishabh",
                        "content": "Thanks bro. Question was not very clear? But From your explaination I got  point that this  problem is using greedy approach to predict the winner. Earlier it was not clear from the question."
                    },
                    {
                        "username": "Rajat_Shukla",
                        "content": "Thank you for explaining the question :)"
                    },
                    {
                        "username": "luanct",
                        "content": "This is Bob and Alice with stone games. They keep playing even when knowing the winner. Bob has a crush on Alice ngl\\uD83D\\uDE02 "
                    },
                    {
                        "username": "RebelWithoutFlaws",
                        "content": "Who wouldnt fall in love with a girl who spends all of her time playing cryptographic games \\uD83E\\uDD13"
                    },
                    {
                        "username": "aruuu____",
                        "content": "lol\\uD83D\\uDE06\\uD83D\\uDE06"
                    },
                    {
                        "username": "JS00",
                        "content": "This might be the first time they are actually playing a fair game, Bob finally came to his senses!"
                    },
                    {
                        "username": "yjian012",
                        "content": "Yeah I can totally see [how the games go](https://postimg.cc/8f8QbhPF)."
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": "Tip for recursive solutions, the player 1 win on the following conditions:\n1) In player1 turn, player1 can win by picking either left or right side Hint: `||`. \n2) In player2 turn, player1 wins when player1 have larger score than player2 in both possibilities right and left. Hint: `&&`. \n3) Base case: when the range l < r."
                    },
                    {
                        "username": "nitissssh",
                        "content": "[@rayahemesh](/rayahemesh) Note the question says both player play optimally ie , if the player 2 has chance that of to make the \n        // the player one loose , then he will not choose the path in wich the player one wins , so to make sure the\n        // player one always wins no matter how cheeky is the player2 we use && , so that we only return true if there \n        // is no way that player2 ka loose the player1 "
                    },
                    {
                        "username": "stachofsky",
                        "content": "[@shashank-lol](/shashank-lol) sorry the base case... what does `when the range l < r` mean?"
                    },
                    {
                        "username": "pj1999",
                        "content": "[@rayahemesh](/rayahemesh)  for both possibilities of player 2 if either possibility returns in favour of player 2 (say false)  we have to return false as player 2 also plays optimally."
                    },
                    {
                        "username": "chandramani_lc",
                        "content": "[@rayahemesh](/rayahemesh) you have to write the recursion thinking of **can u make Player1 win** be it any possible way. So in the course of doing so u might come across the idea that if it's **player1** turn to pick then he can go with either end element and will declared winner if he wins in any of it's choice (so OR). If it's **Player2** turn then **Player1** can only win if **player1** value is greater than that of **player2** in any of the choices of **Player2**(so we need both true i.e &&). "
                    },
                    {
                        "username": "rayahemesh",
                        "content": "Thanks... can you explain bit clearly why && is for"
                    },
                    {
                        "username": "shashank-lol",
                        "content": "Thanks a lot buddy"
                    },
                    {
                        "username": "kng",
                        "content": "Input:\\n[0,0,7,6,5,6,1]\\nOutput:\\ntrue\\nExpected:\\nfalse\\n\\nI guess the answer should be true since Player 1 can bag 13 points as compared to Player 2 with 12."
                    },
                    {
                        "username": "gd4niele",
                        "content": "Assuming that both players are playing optimally, there can be two cases:\\nFirst case (starting from the first zero): P1 [0, 6, 6, 0] P2 [1, 5, 7]\\nSecond case (starting from 1): P1 [1, 5, 6, 0] P2 [6, 0, 7]\\nSo, in this case, the first player will always lose."
                    },
                    {
                        "username": "N00b_ME",
                        "content": "[@rakeshSharma19](/rakeshSharma19) thanks so much , this cleared my doubts "
                    },
                    {
                        "username": "rakeshSharma19",
                        "content": "Same thing happen to me, think about the case Player1 - [1,5,6,0] and player2 - [6,0,7] you will get your answer"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "Both the players playing optimally for overall game not optimal at each step. "
                    },
                    {
                        "username": "belayneh_12",
                        "content": "the correct answer should be False"
                    },
                    {
                        "username": "gentlezephyr95",
                        "content": "The key step is figuring out that both players will play to maximise the score. This translates the problem to an optimization problem which can be solved with DP.\\nI found this helpful: https://medium.com/algorithms-digest/predict-the-winner-16668e9c1cb8"
                    },
                    {
                        "username": "lolcharles",
                        "content": "[0,0,7,6,5,6,1]\\n\\nApparently player 1 can\\'t win here. Why? \\nOptimized steps for player 2 yields:\\nPlayer 1: 1\\nPlayer 2: 6\\nPlayer 1: 5\\nPlayer 2: 6\\nPlayer 1: 7\\n\\nWith the score 13-12 for player 1."
                    },
                    {
                        "username": "dheeraj2002_",
                        "content": "Try to see a video about min-max algorithm, you would be able to solve the question easily."
                    },
                    {
                        "username": "rakeshSharma19",
                        "content": "If I\\'m your competitor(player 2), Then the steps are\\n\\nPlayer1 chooses 1, array now - [0, 0, 7, 6, 5, 6] Player1: 1, Player2: 0\\nPlayer2 chooses 6, array now - [0, 0, 7, 6, 5] Player1: 1, Player2: 6\\nPlayer1 chooses 5, array now - [0, 0, 7, 6] Player1: 6, Player2: 6\\nPlayer2 chooses 0, array now - [0, 7, 6] Player1: 6, Player2: 6\\nPlayer1 chooses either 0 or 6, array now - [0, 7] Player1: 12, Player2: 6 if chooses 6 \\nPlayer2 chooses 7, array now - [0,] Player1: 12, Player2: 13\\nPlayer2 Will win\\n\\nHere Both the players playing optimally for overall game not optimal at each step.\\nUse DP here to get the solution."
                    },
                    {
                        "username": "enzo_cheng",
                        "content": "If i'm your competitor (Player 2), after this step:\n>>> Player 1 chooses 5 [0,0.7,6] Player1: 6, Player2: 6\nPlayer 2 will select 0,\n>>> Player 2 chooses 0 [0,7,6] Player1: 6, Player2: 6\n>>> Player 1 chooses 6 [0,7] Player1: 12, Player2: 6\n>>> Player 2 chooses 7 [0] Player1: 12, Player2: 13\n\nResult is that Player 2 wins always"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Game theory. 2 people contest. like chess game or go! Use DP to solve! Similar questions\n# Stone Game~  Stone Game IX"
                    },
                    {
                        "username": "riturajsingh487",
                        "content": "Player 1 can never lose in this test case (wrong test case).\\n\\nFact: if number of elements in an array are even , then whoever plays first will win (or tie if sum of elements at odd position is equal to sum of elements at even position).\\n\\nNow, player1 will take max(nums[0], nums[numsSize-1]) in first step.\\nin 2nd step: number of elements left in array becomes even. Now, since sum(elements at odd positions) == sum(elemenst at even positions) , if both players play optimally they will have same points after after 1st step.\\n\\nSo, player 1 will have more points (points of 1st step + equal points with player2).\\nClearly player1 shold be the winner."
                    },
                    {
                        "username": "adityadeokar123",
                        "content": "[@disturbedbrown1](/disturbedbrown1) Test Case = [0,1,0] ?"
                    },
                    {
                        "username": "Ilkhomjon",
                        "content": "[@disturbedbrown1](/disturbedbrown1) Nope, it depends the values of each element. So can\\'t tell the winner by only considering the number of elements."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Another pattern I noticed that if there are less than 3 elements, than whoever plays first will win."
                    },
                    {
                        "username": "pyoneerC",
                        "content": "Bro if both players are playing \"optimally\" you are not gonna choose 1 over 7 \\n\\n[1,5,233,7] should be false"
                    },
                    {
                        "username": "sikora92",
                        "content": "They see whole array, so do not behave greedy."
                    },
                    {
                        "username": "psionl0",
                        "content": "But if player 1 chooses 1 then no matter what player 2 chooses, player 1 gets the jackpot (233). So choosing 1 over 7 is the optimal strategy."
                    },
                    {
                        "username": "Harrywithcode",
                        "content": "So, I don't understand what author want to say from \" Player 1 picks one of the numbers from either end of the array followed by the player 2 and then player 1 and so on.\" Is there any mistake in this sentence?\\nPlayer 1 picks either end of the array or what?\\nWhy player 1 should followed by player 2? I think player 1 pick first, right?"
                    },
                    {
                        "username": "Dylan_Yifan",
                        "content": "the start of the array is \"one end\" of an array, while the end of the array is the \"other end\" of the array. So the sentence is correct that it\\'s picking \"either end of the array\""
                    }
                ]
            },
            {
                "id": 1565966,
                "content": [
                    {
                        "username": "deleted_user",
                        "content": "I did not understand what the question was asking exactly during the contest. I came up with multiple solutions based on what I thought was being asked, but they were all incorrect. Looks like I finally understood it. I wanted to clarify the question for people who may be confused like me.\\n\\nThe setup should be easy to understand. p1 and p2 take turns in picking a number from the input array, either the first item or the last item. When an item is picked by one of the player, that item cannot be used anymore; you can imagine it being removed from the array.\\n\\nWhat made me confused was the part \"... predict whether player 1 is the winner. You can assume each player plays to maximize his score.\" I was not sure what maximizing the score meant. Here is what it means.\\n\\nLet's say the initial array is [1, 5, 2]. It's p1's turn. p1 will pick either 1 or 2, but it wants to make sure that whichever one he picks will maximize his gain at the end. What if p1 picks 1? Now the array is [5, 2] and it's p2's turn to pick. p2 looks at the current array and thinks about how to maximize his gain at the end. Obviously, picking 5 will maximize his gains. So, p2 will pick 5, leaving 2 for p1. Resulting scores for p1 and p2 are 3 and 5 respectively. This one did not work out for p1.\\n\\nWhat if p1 picks 2 at the beginning? Then the array becomes [1, 5]. Again, p2 looks at the current array and thinks about how to maximize his gain at the end. Picking 5 will maximize his gains. So, p2 will pick 5, leaving 1 for p1. Resulting scores for p1 and p2 are 3 and 5 respectively. This one did not work out for p1 either. Those were the only two possibilities for game play. p1 can never win.\\n\\nWhat if the input array is [1, 5, 233, 7]? For this one, let me list all possibilities and explain which ones are valid and which ones are not.\\n\\n![0_1485064722628_upload-5137006d-197e-47b8-92a3-276224ff6f97](/uploads/files/1485064725743-upload-5137006d-197e-47b8-92a3-276224ff6f97.png) \\n\\nWhat clarified the question for me was realizing that in each step the current player takes a look at the current array as a whole and tries to make the best pick for maximizing it's gain (taking into consideration what the other player may do). \\n\\nI hope this helps someone."
                    },
                    {
                        "username": "watsonsherlock",
                        "content": "[@079_RISHABH](/079_RISHABH) No, the problem is not based on greedy. Greedy means choosing the current best. But it is evident from the second example that if you always choose the best options that is available to you in each step, you will loose the game."
                    },
                    {
                        "username": "786_Rishabh",
                        "content": "Thanks bro. Question was not very clear? But From your explaination I got  point that this  problem is using greedy approach to predict the winner. Earlier it was not clear from the question."
                    },
                    {
                        "username": "Rajat_Shukla",
                        "content": "Thank you for explaining the question :)"
                    },
                    {
                        "username": "luanct",
                        "content": "This is Bob and Alice with stone games. They keep playing even when knowing the winner. Bob has a crush on Alice ngl\\uD83D\\uDE02 "
                    },
                    {
                        "username": "RebelWithoutFlaws",
                        "content": "Who wouldnt fall in love with a girl who spends all of her time playing cryptographic games \\uD83E\\uDD13"
                    },
                    {
                        "username": "aruuu____",
                        "content": "lol\\uD83D\\uDE06\\uD83D\\uDE06"
                    },
                    {
                        "username": "JS00",
                        "content": "This might be the first time they are actually playing a fair game, Bob finally came to his senses!"
                    },
                    {
                        "username": "yjian012",
                        "content": "Yeah I can totally see [how the games go](https://postimg.cc/8f8QbhPF)."
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": "Tip for recursive solutions, the player 1 win on the following conditions:\n1) In player1 turn, player1 can win by picking either left or right side Hint: `||`. \n2) In player2 turn, player1 wins when player1 have larger score than player2 in both possibilities right and left. Hint: `&&`. \n3) Base case: when the range l < r."
                    },
                    {
                        "username": "nitissssh",
                        "content": "[@rayahemesh](/rayahemesh) Note the question says both player play optimally ie , if the player 2 has chance that of to make the \n        // the player one loose , then he will not choose the path in wich the player one wins , so to make sure the\n        // player one always wins no matter how cheeky is the player2 we use && , so that we only return true if there \n        // is no way that player2 ka loose the player1 "
                    },
                    {
                        "username": "stachofsky",
                        "content": "[@shashank-lol](/shashank-lol) sorry the base case... what does `when the range l < r` mean?"
                    },
                    {
                        "username": "pj1999",
                        "content": "[@rayahemesh](/rayahemesh)  for both possibilities of player 2 if either possibility returns in favour of player 2 (say false)  we have to return false as player 2 also plays optimally."
                    },
                    {
                        "username": "chandramani_lc",
                        "content": "[@rayahemesh](/rayahemesh) you have to write the recursion thinking of **can u make Player1 win** be it any possible way. So in the course of doing so u might come across the idea that if it's **player1** turn to pick then he can go with either end element and will declared winner if he wins in any of it's choice (so OR). If it's **Player2** turn then **Player1** can only win if **player1** value is greater than that of **player2** in any of the choices of **Player2**(so we need both true i.e &&). "
                    },
                    {
                        "username": "rayahemesh",
                        "content": "Thanks... can you explain bit clearly why && is for"
                    },
                    {
                        "username": "shashank-lol",
                        "content": "Thanks a lot buddy"
                    },
                    {
                        "username": "kng",
                        "content": "Input:\\n[0,0,7,6,5,6,1]\\nOutput:\\ntrue\\nExpected:\\nfalse\\n\\nI guess the answer should be true since Player 1 can bag 13 points as compared to Player 2 with 12."
                    },
                    {
                        "username": "gd4niele",
                        "content": "Assuming that both players are playing optimally, there can be two cases:\\nFirst case (starting from the first zero): P1 [0, 6, 6, 0] P2 [1, 5, 7]\\nSecond case (starting from 1): P1 [1, 5, 6, 0] P2 [6, 0, 7]\\nSo, in this case, the first player will always lose."
                    },
                    {
                        "username": "N00b_ME",
                        "content": "[@rakeshSharma19](/rakeshSharma19) thanks so much , this cleared my doubts "
                    },
                    {
                        "username": "rakeshSharma19",
                        "content": "Same thing happen to me, think about the case Player1 - [1,5,6,0] and player2 - [6,0,7] you will get your answer"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "Both the players playing optimally for overall game not optimal at each step. "
                    },
                    {
                        "username": "belayneh_12",
                        "content": "the correct answer should be False"
                    },
                    {
                        "username": "gentlezephyr95",
                        "content": "The key step is figuring out that both players will play to maximise the score. This translates the problem to an optimization problem which can be solved with DP.\\nI found this helpful: https://medium.com/algorithms-digest/predict-the-winner-16668e9c1cb8"
                    },
                    {
                        "username": "lolcharles",
                        "content": "[0,0,7,6,5,6,1]\\n\\nApparently player 1 can\\'t win here. Why? \\nOptimized steps for player 2 yields:\\nPlayer 1: 1\\nPlayer 2: 6\\nPlayer 1: 5\\nPlayer 2: 6\\nPlayer 1: 7\\n\\nWith the score 13-12 for player 1."
                    },
                    {
                        "username": "dheeraj2002_",
                        "content": "Try to see a video about min-max algorithm, you would be able to solve the question easily."
                    },
                    {
                        "username": "rakeshSharma19",
                        "content": "If I\\'m your competitor(player 2), Then the steps are\\n\\nPlayer1 chooses 1, array now - [0, 0, 7, 6, 5, 6] Player1: 1, Player2: 0\\nPlayer2 chooses 6, array now - [0, 0, 7, 6, 5] Player1: 1, Player2: 6\\nPlayer1 chooses 5, array now - [0, 0, 7, 6] Player1: 6, Player2: 6\\nPlayer2 chooses 0, array now - [0, 7, 6] Player1: 6, Player2: 6\\nPlayer1 chooses either 0 or 6, array now - [0, 7] Player1: 12, Player2: 6 if chooses 6 \\nPlayer2 chooses 7, array now - [0,] Player1: 12, Player2: 13\\nPlayer2 Will win\\n\\nHere Both the players playing optimally for overall game not optimal at each step.\\nUse DP here to get the solution."
                    },
                    {
                        "username": "enzo_cheng",
                        "content": "If i'm your competitor (Player 2), after this step:\n>>> Player 1 chooses 5 [0,0.7,6] Player1: 6, Player2: 6\nPlayer 2 will select 0,\n>>> Player 2 chooses 0 [0,7,6] Player1: 6, Player2: 6\n>>> Player 1 chooses 6 [0,7] Player1: 12, Player2: 6\n>>> Player 2 chooses 7 [0] Player1: 12, Player2: 13\n\nResult is that Player 2 wins always"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Game theory. 2 people contest. like chess game or go! Use DP to solve! Similar questions\n# Stone Game~  Stone Game IX"
                    },
                    {
                        "username": "riturajsingh487",
                        "content": "Player 1 can never lose in this test case (wrong test case).\\n\\nFact: if number of elements in an array are even , then whoever plays first will win (or tie if sum of elements at odd position is equal to sum of elements at even position).\\n\\nNow, player1 will take max(nums[0], nums[numsSize-1]) in first step.\\nin 2nd step: number of elements left in array becomes even. Now, since sum(elements at odd positions) == sum(elemenst at even positions) , if both players play optimally they will have same points after after 1st step.\\n\\nSo, player 1 will have more points (points of 1st step + equal points with player2).\\nClearly player1 shold be the winner."
                    },
                    {
                        "username": "adityadeokar123",
                        "content": "[@disturbedbrown1](/disturbedbrown1) Test Case = [0,1,0] ?"
                    },
                    {
                        "username": "Ilkhomjon",
                        "content": "[@disturbedbrown1](/disturbedbrown1) Nope, it depends the values of each element. So can\\'t tell the winner by only considering the number of elements."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Another pattern I noticed that if there are less than 3 elements, than whoever plays first will win."
                    },
                    {
                        "username": "pyoneerC",
                        "content": "Bro if both players are playing \"optimally\" you are not gonna choose 1 over 7 \\n\\n[1,5,233,7] should be false"
                    },
                    {
                        "username": "sikora92",
                        "content": "They see whole array, so do not behave greedy."
                    },
                    {
                        "username": "psionl0",
                        "content": "But if player 1 chooses 1 then no matter what player 2 chooses, player 1 gets the jackpot (233). So choosing 1 over 7 is the optimal strategy."
                    },
                    {
                        "username": "Harrywithcode",
                        "content": "So, I don't understand what author want to say from \" Player 1 picks one of the numbers from either end of the array followed by the player 2 and then player 1 and so on.\" Is there any mistake in this sentence?\\nPlayer 1 picks either end of the array or what?\\nWhy player 1 should followed by player 2? I think player 1 pick first, right?"
                    },
                    {
                        "username": "Dylan_Yifan",
                        "content": "the start of the array is \"one end\" of an array, while the end of the array is the \"other end\" of the array. So the sentence is correct that it\\'s picking \"either end of the array\""
                    }
                ]
            },
            {
                "id": 1568560,
                "content": [
                    {
                        "username": "deleted_user",
                        "content": "I did not understand what the question was asking exactly during the contest. I came up with multiple solutions based on what I thought was being asked, but they were all incorrect. Looks like I finally understood it. I wanted to clarify the question for people who may be confused like me.\\n\\nThe setup should be easy to understand. p1 and p2 take turns in picking a number from the input array, either the first item or the last item. When an item is picked by one of the player, that item cannot be used anymore; you can imagine it being removed from the array.\\n\\nWhat made me confused was the part \"... predict whether player 1 is the winner. You can assume each player plays to maximize his score.\" I was not sure what maximizing the score meant. Here is what it means.\\n\\nLet's say the initial array is [1, 5, 2]. It's p1's turn. p1 will pick either 1 or 2, but it wants to make sure that whichever one he picks will maximize his gain at the end. What if p1 picks 1? Now the array is [5, 2] and it's p2's turn to pick. p2 looks at the current array and thinks about how to maximize his gain at the end. Obviously, picking 5 will maximize his gains. So, p2 will pick 5, leaving 2 for p1. Resulting scores for p1 and p2 are 3 and 5 respectively. This one did not work out for p1.\\n\\nWhat if p1 picks 2 at the beginning? Then the array becomes [1, 5]. Again, p2 looks at the current array and thinks about how to maximize his gain at the end. Picking 5 will maximize his gains. So, p2 will pick 5, leaving 1 for p1. Resulting scores for p1 and p2 are 3 and 5 respectively. This one did not work out for p1 either. Those were the only two possibilities for game play. p1 can never win.\\n\\nWhat if the input array is [1, 5, 233, 7]? For this one, let me list all possibilities and explain which ones are valid and which ones are not.\\n\\n![0_1485064722628_upload-5137006d-197e-47b8-92a3-276224ff6f97](/uploads/files/1485064725743-upload-5137006d-197e-47b8-92a3-276224ff6f97.png) \\n\\nWhat clarified the question for me was realizing that in each step the current player takes a look at the current array as a whole and tries to make the best pick for maximizing it's gain (taking into consideration what the other player may do). \\n\\nI hope this helps someone."
                    },
                    {
                        "username": "watsonsherlock",
                        "content": "[@079_RISHABH](/079_RISHABH) No, the problem is not based on greedy. Greedy means choosing the current best. But it is evident from the second example that if you always choose the best options that is available to you in each step, you will loose the game."
                    },
                    {
                        "username": "786_Rishabh",
                        "content": "Thanks bro. Question was not very clear? But From your explaination I got  point that this  problem is using greedy approach to predict the winner. Earlier it was not clear from the question."
                    },
                    {
                        "username": "Rajat_Shukla",
                        "content": "Thank you for explaining the question :)"
                    },
                    {
                        "username": "luanct",
                        "content": "This is Bob and Alice with stone games. They keep playing even when knowing the winner. Bob has a crush on Alice ngl\\uD83D\\uDE02 "
                    },
                    {
                        "username": "RebelWithoutFlaws",
                        "content": "Who wouldnt fall in love with a girl who spends all of her time playing cryptographic games \\uD83E\\uDD13"
                    },
                    {
                        "username": "aruuu____",
                        "content": "lol\\uD83D\\uDE06\\uD83D\\uDE06"
                    },
                    {
                        "username": "JS00",
                        "content": "This might be the first time they are actually playing a fair game, Bob finally came to his senses!"
                    },
                    {
                        "username": "yjian012",
                        "content": "Yeah I can totally see [how the games go](https://postimg.cc/8f8QbhPF)."
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": "Tip for recursive solutions, the player 1 win on the following conditions:\n1) In player1 turn, player1 can win by picking either left or right side Hint: `||`. \n2) In player2 turn, player1 wins when player1 have larger score than player2 in both possibilities right and left. Hint: `&&`. \n3) Base case: when the range l < r."
                    },
                    {
                        "username": "nitissssh",
                        "content": "[@rayahemesh](/rayahemesh) Note the question says both player play optimally ie , if the player 2 has chance that of to make the \n        // the player one loose , then he will not choose the path in wich the player one wins , so to make sure the\n        // player one always wins no matter how cheeky is the player2 we use && , so that we only return true if there \n        // is no way that player2 ka loose the player1 "
                    },
                    {
                        "username": "stachofsky",
                        "content": "[@shashank-lol](/shashank-lol) sorry the base case... what does `when the range l < r` mean?"
                    },
                    {
                        "username": "pj1999",
                        "content": "[@rayahemesh](/rayahemesh)  for both possibilities of player 2 if either possibility returns in favour of player 2 (say false)  we have to return false as player 2 also plays optimally."
                    },
                    {
                        "username": "chandramani_lc",
                        "content": "[@rayahemesh](/rayahemesh) you have to write the recursion thinking of **can u make Player1 win** be it any possible way. So in the course of doing so u might come across the idea that if it's **player1** turn to pick then he can go with either end element and will declared winner if he wins in any of it's choice (so OR). If it's **Player2** turn then **Player1** can only win if **player1** value is greater than that of **player2** in any of the choices of **Player2**(so we need both true i.e &&). "
                    },
                    {
                        "username": "rayahemesh",
                        "content": "Thanks... can you explain bit clearly why && is for"
                    },
                    {
                        "username": "shashank-lol",
                        "content": "Thanks a lot buddy"
                    },
                    {
                        "username": "kng",
                        "content": "Input:\\n[0,0,7,6,5,6,1]\\nOutput:\\ntrue\\nExpected:\\nfalse\\n\\nI guess the answer should be true since Player 1 can bag 13 points as compared to Player 2 with 12."
                    },
                    {
                        "username": "gd4niele",
                        "content": "Assuming that both players are playing optimally, there can be two cases:\\nFirst case (starting from the first zero): P1 [0, 6, 6, 0] P2 [1, 5, 7]\\nSecond case (starting from 1): P1 [1, 5, 6, 0] P2 [6, 0, 7]\\nSo, in this case, the first player will always lose."
                    },
                    {
                        "username": "N00b_ME",
                        "content": "[@rakeshSharma19](/rakeshSharma19) thanks so much , this cleared my doubts "
                    },
                    {
                        "username": "rakeshSharma19",
                        "content": "Same thing happen to me, think about the case Player1 - [1,5,6,0] and player2 - [6,0,7] you will get your answer"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "Both the players playing optimally for overall game not optimal at each step. "
                    },
                    {
                        "username": "belayneh_12",
                        "content": "the correct answer should be False"
                    },
                    {
                        "username": "gentlezephyr95",
                        "content": "The key step is figuring out that both players will play to maximise the score. This translates the problem to an optimization problem which can be solved with DP.\\nI found this helpful: https://medium.com/algorithms-digest/predict-the-winner-16668e9c1cb8"
                    },
                    {
                        "username": "lolcharles",
                        "content": "[0,0,7,6,5,6,1]\\n\\nApparently player 1 can\\'t win here. Why? \\nOptimized steps for player 2 yields:\\nPlayer 1: 1\\nPlayer 2: 6\\nPlayer 1: 5\\nPlayer 2: 6\\nPlayer 1: 7\\n\\nWith the score 13-12 for player 1."
                    },
                    {
                        "username": "dheeraj2002_",
                        "content": "Try to see a video about min-max algorithm, you would be able to solve the question easily."
                    },
                    {
                        "username": "rakeshSharma19",
                        "content": "If I\\'m your competitor(player 2), Then the steps are\\n\\nPlayer1 chooses 1, array now - [0, 0, 7, 6, 5, 6] Player1: 1, Player2: 0\\nPlayer2 chooses 6, array now - [0, 0, 7, 6, 5] Player1: 1, Player2: 6\\nPlayer1 chooses 5, array now - [0, 0, 7, 6] Player1: 6, Player2: 6\\nPlayer2 chooses 0, array now - [0, 7, 6] Player1: 6, Player2: 6\\nPlayer1 chooses either 0 or 6, array now - [0, 7] Player1: 12, Player2: 6 if chooses 6 \\nPlayer2 chooses 7, array now - [0,] Player1: 12, Player2: 13\\nPlayer2 Will win\\n\\nHere Both the players playing optimally for overall game not optimal at each step.\\nUse DP here to get the solution."
                    },
                    {
                        "username": "enzo_cheng",
                        "content": "If i'm your competitor (Player 2), after this step:\n>>> Player 1 chooses 5 [0,0.7,6] Player1: 6, Player2: 6\nPlayer 2 will select 0,\n>>> Player 2 chooses 0 [0,7,6] Player1: 6, Player2: 6\n>>> Player 1 chooses 6 [0,7] Player1: 12, Player2: 6\n>>> Player 2 chooses 7 [0] Player1: 12, Player2: 13\n\nResult is that Player 2 wins always"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Game theory. 2 people contest. like chess game or go! Use DP to solve! Similar questions\n# Stone Game~  Stone Game IX"
                    },
                    {
                        "username": "riturajsingh487",
                        "content": "Player 1 can never lose in this test case (wrong test case).\\n\\nFact: if number of elements in an array are even , then whoever plays first will win (or tie if sum of elements at odd position is equal to sum of elements at even position).\\n\\nNow, player1 will take max(nums[0], nums[numsSize-1]) in first step.\\nin 2nd step: number of elements left in array becomes even. Now, since sum(elements at odd positions) == sum(elemenst at even positions) , if both players play optimally they will have same points after after 1st step.\\n\\nSo, player 1 will have more points (points of 1st step + equal points with player2).\\nClearly player1 shold be the winner."
                    },
                    {
                        "username": "adityadeokar123",
                        "content": "[@disturbedbrown1](/disturbedbrown1) Test Case = [0,1,0] ?"
                    },
                    {
                        "username": "Ilkhomjon",
                        "content": "[@disturbedbrown1](/disturbedbrown1) Nope, it depends the values of each element. So can\\'t tell the winner by only considering the number of elements."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Another pattern I noticed that if there are less than 3 elements, than whoever plays first will win."
                    },
                    {
                        "username": "pyoneerC",
                        "content": "Bro if both players are playing \"optimally\" you are not gonna choose 1 over 7 \\n\\n[1,5,233,7] should be false"
                    },
                    {
                        "username": "sikora92",
                        "content": "They see whole array, so do not behave greedy."
                    },
                    {
                        "username": "psionl0",
                        "content": "But if player 1 chooses 1 then no matter what player 2 chooses, player 1 gets the jackpot (233). So choosing 1 over 7 is the optimal strategy."
                    },
                    {
                        "username": "Harrywithcode",
                        "content": "So, I don't understand what author want to say from \" Player 1 picks one of the numbers from either end of the array followed by the player 2 and then player 1 and so on.\" Is there any mistake in this sentence?\\nPlayer 1 picks either end of the array or what?\\nWhy player 1 should followed by player 2? I think player 1 pick first, right?"
                    },
                    {
                        "username": "Dylan_Yifan",
                        "content": "the start of the array is \"one end\" of an array, while the end of the array is the \"other end\" of the array. So the sentence is correct that it\\'s picking \"either end of the array\""
                    }
                ]
            },
            {
                "id": 1568046,
                "content": [
                    {
                        "username": "deleted_user",
                        "content": "I did not understand what the question was asking exactly during the contest. I came up with multiple solutions based on what I thought was being asked, but they were all incorrect. Looks like I finally understood it. I wanted to clarify the question for people who may be confused like me.\\n\\nThe setup should be easy to understand. p1 and p2 take turns in picking a number from the input array, either the first item or the last item. When an item is picked by one of the player, that item cannot be used anymore; you can imagine it being removed from the array.\\n\\nWhat made me confused was the part \"... predict whether player 1 is the winner. You can assume each player plays to maximize his score.\" I was not sure what maximizing the score meant. Here is what it means.\\n\\nLet's say the initial array is [1, 5, 2]. It's p1's turn. p1 will pick either 1 or 2, but it wants to make sure that whichever one he picks will maximize his gain at the end. What if p1 picks 1? Now the array is [5, 2] and it's p2's turn to pick. p2 looks at the current array and thinks about how to maximize his gain at the end. Obviously, picking 5 will maximize his gains. So, p2 will pick 5, leaving 2 for p1. Resulting scores for p1 and p2 are 3 and 5 respectively. This one did not work out for p1.\\n\\nWhat if p1 picks 2 at the beginning? Then the array becomes [1, 5]. Again, p2 looks at the current array and thinks about how to maximize his gain at the end. Picking 5 will maximize his gains. So, p2 will pick 5, leaving 1 for p1. Resulting scores for p1 and p2 are 3 and 5 respectively. This one did not work out for p1 either. Those were the only two possibilities for game play. p1 can never win.\\n\\nWhat if the input array is [1, 5, 233, 7]? For this one, let me list all possibilities and explain which ones are valid and which ones are not.\\n\\n![0_1485064722628_upload-5137006d-197e-47b8-92a3-276224ff6f97](/uploads/files/1485064725743-upload-5137006d-197e-47b8-92a3-276224ff6f97.png) \\n\\nWhat clarified the question for me was realizing that in each step the current player takes a look at the current array as a whole and tries to make the best pick for maximizing it's gain (taking into consideration what the other player may do). \\n\\nI hope this helps someone."
                    },
                    {
                        "username": "watsonsherlock",
                        "content": "[@079_RISHABH](/079_RISHABH) No, the problem is not based on greedy. Greedy means choosing the current best. But it is evident from the second example that if you always choose the best options that is available to you in each step, you will loose the game."
                    },
                    {
                        "username": "786_Rishabh",
                        "content": "Thanks bro. Question was not very clear? But From your explaination I got  point that this  problem is using greedy approach to predict the winner. Earlier it was not clear from the question."
                    },
                    {
                        "username": "Rajat_Shukla",
                        "content": "Thank you for explaining the question :)"
                    },
                    {
                        "username": "luanct",
                        "content": "This is Bob and Alice with stone games. They keep playing even when knowing the winner. Bob has a crush on Alice ngl\\uD83D\\uDE02 "
                    },
                    {
                        "username": "RebelWithoutFlaws",
                        "content": "Who wouldnt fall in love with a girl who spends all of her time playing cryptographic games \\uD83E\\uDD13"
                    },
                    {
                        "username": "aruuu____",
                        "content": "lol\\uD83D\\uDE06\\uD83D\\uDE06"
                    },
                    {
                        "username": "JS00",
                        "content": "This might be the first time they are actually playing a fair game, Bob finally came to his senses!"
                    },
                    {
                        "username": "yjian012",
                        "content": "Yeah I can totally see [how the games go](https://postimg.cc/8f8QbhPF)."
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": "Tip for recursive solutions, the player 1 win on the following conditions:\n1) In player1 turn, player1 can win by picking either left or right side Hint: `||`. \n2) In player2 turn, player1 wins when player1 have larger score than player2 in both possibilities right and left. Hint: `&&`. \n3) Base case: when the range l < r."
                    },
                    {
                        "username": "nitissssh",
                        "content": "[@rayahemesh](/rayahemesh) Note the question says both player play optimally ie , if the player 2 has chance that of to make the \n        // the player one loose , then he will not choose the path in wich the player one wins , so to make sure the\n        // player one always wins no matter how cheeky is the player2 we use && , so that we only return true if there \n        // is no way that player2 ka loose the player1 "
                    },
                    {
                        "username": "stachofsky",
                        "content": "[@shashank-lol](/shashank-lol) sorry the base case... what does `when the range l < r` mean?"
                    },
                    {
                        "username": "pj1999",
                        "content": "[@rayahemesh](/rayahemesh)  for both possibilities of player 2 if either possibility returns in favour of player 2 (say false)  we have to return false as player 2 also plays optimally."
                    },
                    {
                        "username": "chandramani_lc",
                        "content": "[@rayahemesh](/rayahemesh) you have to write the recursion thinking of **can u make Player1 win** be it any possible way. So in the course of doing so u might come across the idea that if it's **player1** turn to pick then he can go with either end element and will declared winner if he wins in any of it's choice (so OR). If it's **Player2** turn then **Player1** can only win if **player1** value is greater than that of **player2** in any of the choices of **Player2**(so we need both true i.e &&). "
                    },
                    {
                        "username": "rayahemesh",
                        "content": "Thanks... can you explain bit clearly why && is for"
                    },
                    {
                        "username": "shashank-lol",
                        "content": "Thanks a lot buddy"
                    },
                    {
                        "username": "kng",
                        "content": "Input:\\n[0,0,7,6,5,6,1]\\nOutput:\\ntrue\\nExpected:\\nfalse\\n\\nI guess the answer should be true since Player 1 can bag 13 points as compared to Player 2 with 12."
                    },
                    {
                        "username": "gd4niele",
                        "content": "Assuming that both players are playing optimally, there can be two cases:\\nFirst case (starting from the first zero): P1 [0, 6, 6, 0] P2 [1, 5, 7]\\nSecond case (starting from 1): P1 [1, 5, 6, 0] P2 [6, 0, 7]\\nSo, in this case, the first player will always lose."
                    },
                    {
                        "username": "N00b_ME",
                        "content": "[@rakeshSharma19](/rakeshSharma19) thanks so much , this cleared my doubts "
                    },
                    {
                        "username": "rakeshSharma19",
                        "content": "Same thing happen to me, think about the case Player1 - [1,5,6,0] and player2 - [6,0,7] you will get your answer"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "Both the players playing optimally for overall game not optimal at each step. "
                    },
                    {
                        "username": "belayneh_12",
                        "content": "the correct answer should be False"
                    },
                    {
                        "username": "gentlezephyr95",
                        "content": "The key step is figuring out that both players will play to maximise the score. This translates the problem to an optimization problem which can be solved with DP.\\nI found this helpful: https://medium.com/algorithms-digest/predict-the-winner-16668e9c1cb8"
                    },
                    {
                        "username": "lolcharles",
                        "content": "[0,0,7,6,5,6,1]\\n\\nApparently player 1 can\\'t win here. Why? \\nOptimized steps for player 2 yields:\\nPlayer 1: 1\\nPlayer 2: 6\\nPlayer 1: 5\\nPlayer 2: 6\\nPlayer 1: 7\\n\\nWith the score 13-12 for player 1."
                    },
                    {
                        "username": "dheeraj2002_",
                        "content": "Try to see a video about min-max algorithm, you would be able to solve the question easily."
                    },
                    {
                        "username": "rakeshSharma19",
                        "content": "If I\\'m your competitor(player 2), Then the steps are\\n\\nPlayer1 chooses 1, array now - [0, 0, 7, 6, 5, 6] Player1: 1, Player2: 0\\nPlayer2 chooses 6, array now - [0, 0, 7, 6, 5] Player1: 1, Player2: 6\\nPlayer1 chooses 5, array now - [0, 0, 7, 6] Player1: 6, Player2: 6\\nPlayer2 chooses 0, array now - [0, 7, 6] Player1: 6, Player2: 6\\nPlayer1 chooses either 0 or 6, array now - [0, 7] Player1: 12, Player2: 6 if chooses 6 \\nPlayer2 chooses 7, array now - [0,] Player1: 12, Player2: 13\\nPlayer2 Will win\\n\\nHere Both the players playing optimally for overall game not optimal at each step.\\nUse DP here to get the solution."
                    },
                    {
                        "username": "enzo_cheng",
                        "content": "If i'm your competitor (Player 2), after this step:\n>>> Player 1 chooses 5 [0,0.7,6] Player1: 6, Player2: 6\nPlayer 2 will select 0,\n>>> Player 2 chooses 0 [0,7,6] Player1: 6, Player2: 6\n>>> Player 1 chooses 6 [0,7] Player1: 12, Player2: 6\n>>> Player 2 chooses 7 [0] Player1: 12, Player2: 13\n\nResult is that Player 2 wins always"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Game theory. 2 people contest. like chess game or go! Use DP to solve! Similar questions\n# Stone Game~  Stone Game IX"
                    },
                    {
                        "username": "riturajsingh487",
                        "content": "Player 1 can never lose in this test case (wrong test case).\\n\\nFact: if number of elements in an array are even , then whoever plays first will win (or tie if sum of elements at odd position is equal to sum of elements at even position).\\n\\nNow, player1 will take max(nums[0], nums[numsSize-1]) in first step.\\nin 2nd step: number of elements left in array becomes even. Now, since sum(elements at odd positions) == sum(elemenst at even positions) , if both players play optimally they will have same points after after 1st step.\\n\\nSo, player 1 will have more points (points of 1st step + equal points with player2).\\nClearly player1 shold be the winner."
                    },
                    {
                        "username": "adityadeokar123",
                        "content": "[@disturbedbrown1](/disturbedbrown1) Test Case = [0,1,0] ?"
                    },
                    {
                        "username": "Ilkhomjon",
                        "content": "[@disturbedbrown1](/disturbedbrown1) Nope, it depends the values of each element. So can\\'t tell the winner by only considering the number of elements."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Another pattern I noticed that if there are less than 3 elements, than whoever plays first will win."
                    },
                    {
                        "username": "pyoneerC",
                        "content": "Bro if both players are playing \"optimally\" you are not gonna choose 1 over 7 \\n\\n[1,5,233,7] should be false"
                    },
                    {
                        "username": "sikora92",
                        "content": "They see whole array, so do not behave greedy."
                    },
                    {
                        "username": "psionl0",
                        "content": "But if player 1 chooses 1 then no matter what player 2 chooses, player 1 gets the jackpot (233). So choosing 1 over 7 is the optimal strategy."
                    },
                    {
                        "username": "Harrywithcode",
                        "content": "So, I don't understand what author want to say from \" Player 1 picks one of the numbers from either end of the array followed by the player 2 and then player 1 and so on.\" Is there any mistake in this sentence?\\nPlayer 1 picks either end of the array or what?\\nWhy player 1 should followed by player 2? I think player 1 pick first, right?"
                    },
                    {
                        "username": "Dylan_Yifan",
                        "content": "the start of the array is \"one end\" of an array, while the end of the array is the \"other end\" of the array. So the sentence is correct that it\\'s picking \"either end of the array\""
                    }
                ]
            },
            {
                "id": 1989512,
                "content": [
                    {
                        "username": "deleted_user",
                        "content": "I did not understand what the question was asking exactly during the contest. I came up with multiple solutions based on what I thought was being asked, but they were all incorrect. Looks like I finally understood it. I wanted to clarify the question for people who may be confused like me.\\n\\nThe setup should be easy to understand. p1 and p2 take turns in picking a number from the input array, either the first item or the last item. When an item is picked by one of the player, that item cannot be used anymore; you can imagine it being removed from the array.\\n\\nWhat made me confused was the part \"... predict whether player 1 is the winner. You can assume each player plays to maximize his score.\" I was not sure what maximizing the score meant. Here is what it means.\\n\\nLet's say the initial array is [1, 5, 2]. It's p1's turn. p1 will pick either 1 or 2, but it wants to make sure that whichever one he picks will maximize his gain at the end. What if p1 picks 1? Now the array is [5, 2] and it's p2's turn to pick. p2 looks at the current array and thinks about how to maximize his gain at the end. Obviously, picking 5 will maximize his gains. So, p2 will pick 5, leaving 2 for p1. Resulting scores for p1 and p2 are 3 and 5 respectively. This one did not work out for p1.\\n\\nWhat if p1 picks 2 at the beginning? Then the array becomes [1, 5]. Again, p2 looks at the current array and thinks about how to maximize his gain at the end. Picking 5 will maximize his gains. So, p2 will pick 5, leaving 1 for p1. Resulting scores for p1 and p2 are 3 and 5 respectively. This one did not work out for p1 either. Those were the only two possibilities for game play. p1 can never win.\\n\\nWhat if the input array is [1, 5, 233, 7]? For this one, let me list all possibilities and explain which ones are valid and which ones are not.\\n\\n![0_1485064722628_upload-5137006d-197e-47b8-92a3-276224ff6f97](/uploads/files/1485064725743-upload-5137006d-197e-47b8-92a3-276224ff6f97.png) \\n\\nWhat clarified the question for me was realizing that in each step the current player takes a look at the current array as a whole and tries to make the best pick for maximizing it's gain (taking into consideration what the other player may do). \\n\\nI hope this helps someone."
                    },
                    {
                        "username": "watsonsherlock",
                        "content": "[@079_RISHABH](/079_RISHABH) No, the problem is not based on greedy. Greedy means choosing the current best. But it is evident from the second example that if you always choose the best options that is available to you in each step, you will loose the game."
                    },
                    {
                        "username": "786_Rishabh",
                        "content": "Thanks bro. Question was not very clear? But From your explaination I got  point that this  problem is using greedy approach to predict the winner. Earlier it was not clear from the question."
                    },
                    {
                        "username": "Rajat_Shukla",
                        "content": "Thank you for explaining the question :)"
                    },
                    {
                        "username": "luanct",
                        "content": "This is Bob and Alice with stone games. They keep playing even when knowing the winner. Bob has a crush on Alice ngl\\uD83D\\uDE02 "
                    },
                    {
                        "username": "RebelWithoutFlaws",
                        "content": "Who wouldnt fall in love with a girl who spends all of her time playing cryptographic games \\uD83E\\uDD13"
                    },
                    {
                        "username": "aruuu____",
                        "content": "lol\\uD83D\\uDE06\\uD83D\\uDE06"
                    },
                    {
                        "username": "JS00",
                        "content": "This might be the first time they are actually playing a fair game, Bob finally came to his senses!"
                    },
                    {
                        "username": "yjian012",
                        "content": "Yeah I can totally see [how the games go](https://postimg.cc/8f8QbhPF)."
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": "Tip for recursive solutions, the player 1 win on the following conditions:\n1) In player1 turn, player1 can win by picking either left or right side Hint: `||`. \n2) In player2 turn, player1 wins when player1 have larger score than player2 in both possibilities right and left. Hint: `&&`. \n3) Base case: when the range l < r."
                    },
                    {
                        "username": "nitissssh",
                        "content": "[@rayahemesh](/rayahemesh) Note the question says both player play optimally ie , if the player 2 has chance that of to make the \n        // the player one loose , then he will not choose the path in wich the player one wins , so to make sure the\n        // player one always wins no matter how cheeky is the player2 we use && , so that we only return true if there \n        // is no way that player2 ka loose the player1 "
                    },
                    {
                        "username": "stachofsky",
                        "content": "[@shashank-lol](/shashank-lol) sorry the base case... what does `when the range l < r` mean?"
                    },
                    {
                        "username": "pj1999",
                        "content": "[@rayahemesh](/rayahemesh)  for both possibilities of player 2 if either possibility returns in favour of player 2 (say false)  we have to return false as player 2 also plays optimally."
                    },
                    {
                        "username": "chandramani_lc",
                        "content": "[@rayahemesh](/rayahemesh) you have to write the recursion thinking of **can u make Player1 win** be it any possible way. So in the course of doing so u might come across the idea that if it's **player1** turn to pick then he can go with either end element and will declared winner if he wins in any of it's choice (so OR). If it's **Player2** turn then **Player1** can only win if **player1** value is greater than that of **player2** in any of the choices of **Player2**(so we need both true i.e &&). "
                    },
                    {
                        "username": "rayahemesh",
                        "content": "Thanks... can you explain bit clearly why && is for"
                    },
                    {
                        "username": "shashank-lol",
                        "content": "Thanks a lot buddy"
                    },
                    {
                        "username": "kng",
                        "content": "Input:\\n[0,0,7,6,5,6,1]\\nOutput:\\ntrue\\nExpected:\\nfalse\\n\\nI guess the answer should be true since Player 1 can bag 13 points as compared to Player 2 with 12."
                    },
                    {
                        "username": "gd4niele",
                        "content": "Assuming that both players are playing optimally, there can be two cases:\\nFirst case (starting from the first zero): P1 [0, 6, 6, 0] P2 [1, 5, 7]\\nSecond case (starting from 1): P1 [1, 5, 6, 0] P2 [6, 0, 7]\\nSo, in this case, the first player will always lose."
                    },
                    {
                        "username": "N00b_ME",
                        "content": "[@rakeshSharma19](/rakeshSharma19) thanks so much , this cleared my doubts "
                    },
                    {
                        "username": "rakeshSharma19",
                        "content": "Same thing happen to me, think about the case Player1 - [1,5,6,0] and player2 - [6,0,7] you will get your answer"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "Both the players playing optimally for overall game not optimal at each step. "
                    },
                    {
                        "username": "belayneh_12",
                        "content": "the correct answer should be False"
                    },
                    {
                        "username": "gentlezephyr95",
                        "content": "The key step is figuring out that both players will play to maximise the score. This translates the problem to an optimization problem which can be solved with DP.\\nI found this helpful: https://medium.com/algorithms-digest/predict-the-winner-16668e9c1cb8"
                    },
                    {
                        "username": "lolcharles",
                        "content": "[0,0,7,6,5,6,1]\\n\\nApparently player 1 can\\'t win here. Why? \\nOptimized steps for player 2 yields:\\nPlayer 1: 1\\nPlayer 2: 6\\nPlayer 1: 5\\nPlayer 2: 6\\nPlayer 1: 7\\n\\nWith the score 13-12 for player 1."
                    },
                    {
                        "username": "dheeraj2002_",
                        "content": "Try to see a video about min-max algorithm, you would be able to solve the question easily."
                    },
                    {
                        "username": "rakeshSharma19",
                        "content": "If I\\'m your competitor(player 2), Then the steps are\\n\\nPlayer1 chooses 1, array now - [0, 0, 7, 6, 5, 6] Player1: 1, Player2: 0\\nPlayer2 chooses 6, array now - [0, 0, 7, 6, 5] Player1: 1, Player2: 6\\nPlayer1 chooses 5, array now - [0, 0, 7, 6] Player1: 6, Player2: 6\\nPlayer2 chooses 0, array now - [0, 7, 6] Player1: 6, Player2: 6\\nPlayer1 chooses either 0 or 6, array now - [0, 7] Player1: 12, Player2: 6 if chooses 6 \\nPlayer2 chooses 7, array now - [0,] Player1: 12, Player2: 13\\nPlayer2 Will win\\n\\nHere Both the players playing optimally for overall game not optimal at each step.\\nUse DP here to get the solution."
                    },
                    {
                        "username": "enzo_cheng",
                        "content": "If i'm your competitor (Player 2), after this step:\n>>> Player 1 chooses 5 [0,0.7,6] Player1: 6, Player2: 6\nPlayer 2 will select 0,\n>>> Player 2 chooses 0 [0,7,6] Player1: 6, Player2: 6\n>>> Player 1 chooses 6 [0,7] Player1: 12, Player2: 6\n>>> Player 2 chooses 7 [0] Player1: 12, Player2: 13\n\nResult is that Player 2 wins always"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Game theory. 2 people contest. like chess game or go! Use DP to solve! Similar questions\n# Stone Game~  Stone Game IX"
                    },
                    {
                        "username": "riturajsingh487",
                        "content": "Player 1 can never lose in this test case (wrong test case).\\n\\nFact: if number of elements in an array are even , then whoever plays first will win (or tie if sum of elements at odd position is equal to sum of elements at even position).\\n\\nNow, player1 will take max(nums[0], nums[numsSize-1]) in first step.\\nin 2nd step: number of elements left in array becomes even. Now, since sum(elements at odd positions) == sum(elemenst at even positions) , if both players play optimally they will have same points after after 1st step.\\n\\nSo, player 1 will have more points (points of 1st step + equal points with player2).\\nClearly player1 shold be the winner."
                    },
                    {
                        "username": "adityadeokar123",
                        "content": "[@disturbedbrown1](/disturbedbrown1) Test Case = [0,1,0] ?"
                    },
                    {
                        "username": "Ilkhomjon",
                        "content": "[@disturbedbrown1](/disturbedbrown1) Nope, it depends the values of each element. So can\\'t tell the winner by only considering the number of elements."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Another pattern I noticed that if there are less than 3 elements, than whoever plays first will win."
                    },
                    {
                        "username": "pyoneerC",
                        "content": "Bro if both players are playing \"optimally\" you are not gonna choose 1 over 7 \\n\\n[1,5,233,7] should be false"
                    },
                    {
                        "username": "sikora92",
                        "content": "They see whole array, so do not behave greedy."
                    },
                    {
                        "username": "psionl0",
                        "content": "But if player 1 chooses 1 then no matter what player 2 chooses, player 1 gets the jackpot (233). So choosing 1 over 7 is the optimal strategy."
                    },
                    {
                        "username": "Harrywithcode",
                        "content": "So, I don't understand what author want to say from \" Player 1 picks one of the numbers from either end of the array followed by the player 2 and then player 1 and so on.\" Is there any mistake in this sentence?\\nPlayer 1 picks either end of the array or what?\\nWhy player 1 should followed by player 2? I think player 1 pick first, right?"
                    },
                    {
                        "username": "Dylan_Yifan",
                        "content": "the start of the array is \"one end\" of an array, while the end of the array is the \"other end\" of the array. So the sentence is correct that it\\'s picking \"either end of the array\""
                    }
                ]
            },
            {
                "id": 1568741,
                "content": [
                    {
                        "username": "deleted_user",
                        "content": "I did not understand what the question was asking exactly during the contest. I came up with multiple solutions based on what I thought was being asked, but they were all incorrect. Looks like I finally understood it. I wanted to clarify the question for people who may be confused like me.\\n\\nThe setup should be easy to understand. p1 and p2 take turns in picking a number from the input array, either the first item or the last item. When an item is picked by one of the player, that item cannot be used anymore; you can imagine it being removed from the array.\\n\\nWhat made me confused was the part \"... predict whether player 1 is the winner. You can assume each player plays to maximize his score.\" I was not sure what maximizing the score meant. Here is what it means.\\n\\nLet's say the initial array is [1, 5, 2]. It's p1's turn. p1 will pick either 1 or 2, but it wants to make sure that whichever one he picks will maximize his gain at the end. What if p1 picks 1? Now the array is [5, 2] and it's p2's turn to pick. p2 looks at the current array and thinks about how to maximize his gain at the end. Obviously, picking 5 will maximize his gains. So, p2 will pick 5, leaving 2 for p1. Resulting scores for p1 and p2 are 3 and 5 respectively. This one did not work out for p1.\\n\\nWhat if p1 picks 2 at the beginning? Then the array becomes [1, 5]. Again, p2 looks at the current array and thinks about how to maximize his gain at the end. Picking 5 will maximize his gains. So, p2 will pick 5, leaving 1 for p1. Resulting scores for p1 and p2 are 3 and 5 respectively. This one did not work out for p1 either. Those were the only two possibilities for game play. p1 can never win.\\n\\nWhat if the input array is [1, 5, 233, 7]? For this one, let me list all possibilities and explain which ones are valid and which ones are not.\\n\\n![0_1485064722628_upload-5137006d-197e-47b8-92a3-276224ff6f97](/uploads/files/1485064725743-upload-5137006d-197e-47b8-92a3-276224ff6f97.png) \\n\\nWhat clarified the question for me was realizing that in each step the current player takes a look at the current array as a whole and tries to make the best pick for maximizing it's gain (taking into consideration what the other player may do). \\n\\nI hope this helps someone."
                    },
                    {
                        "username": "watsonsherlock",
                        "content": "[@079_RISHABH](/079_RISHABH) No, the problem is not based on greedy. Greedy means choosing the current best. But it is evident from the second example that if you always choose the best options that is available to you in each step, you will loose the game."
                    },
                    {
                        "username": "786_Rishabh",
                        "content": "Thanks bro. Question was not very clear? But From your explaination I got  point that this  problem is using greedy approach to predict the winner. Earlier it was not clear from the question."
                    },
                    {
                        "username": "Rajat_Shukla",
                        "content": "Thank you for explaining the question :)"
                    },
                    {
                        "username": "luanct",
                        "content": "This is Bob and Alice with stone games. They keep playing even when knowing the winner. Bob has a crush on Alice ngl\\uD83D\\uDE02 "
                    },
                    {
                        "username": "RebelWithoutFlaws",
                        "content": "Who wouldnt fall in love with a girl who spends all of her time playing cryptographic games \\uD83E\\uDD13"
                    },
                    {
                        "username": "aruuu____",
                        "content": "lol\\uD83D\\uDE06\\uD83D\\uDE06"
                    },
                    {
                        "username": "JS00",
                        "content": "This might be the first time they are actually playing a fair game, Bob finally came to his senses!"
                    },
                    {
                        "username": "yjian012",
                        "content": "Yeah I can totally see [how the games go](https://postimg.cc/8f8QbhPF)."
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": "Tip for recursive solutions, the player 1 win on the following conditions:\n1) In player1 turn, player1 can win by picking either left or right side Hint: `||`. \n2) In player2 turn, player1 wins when player1 have larger score than player2 in both possibilities right and left. Hint: `&&`. \n3) Base case: when the range l < r."
                    },
                    {
                        "username": "nitissssh",
                        "content": "[@rayahemesh](/rayahemesh) Note the question says both player play optimally ie , if the player 2 has chance that of to make the \n        // the player one loose , then he will not choose the path in wich the player one wins , so to make sure the\n        // player one always wins no matter how cheeky is the player2 we use && , so that we only return true if there \n        // is no way that player2 ka loose the player1 "
                    },
                    {
                        "username": "stachofsky",
                        "content": "[@shashank-lol](/shashank-lol) sorry the base case... what does `when the range l < r` mean?"
                    },
                    {
                        "username": "pj1999",
                        "content": "[@rayahemesh](/rayahemesh)  for both possibilities of player 2 if either possibility returns in favour of player 2 (say false)  we have to return false as player 2 also plays optimally."
                    },
                    {
                        "username": "chandramani_lc",
                        "content": "[@rayahemesh](/rayahemesh) you have to write the recursion thinking of **can u make Player1 win** be it any possible way. So in the course of doing so u might come across the idea that if it's **player1** turn to pick then he can go with either end element and will declared winner if he wins in any of it's choice (so OR). If it's **Player2** turn then **Player1** can only win if **player1** value is greater than that of **player2** in any of the choices of **Player2**(so we need both true i.e &&). "
                    },
                    {
                        "username": "rayahemesh",
                        "content": "Thanks... can you explain bit clearly why && is for"
                    },
                    {
                        "username": "shashank-lol",
                        "content": "Thanks a lot buddy"
                    },
                    {
                        "username": "kng",
                        "content": "Input:\\n[0,0,7,6,5,6,1]\\nOutput:\\ntrue\\nExpected:\\nfalse\\n\\nI guess the answer should be true since Player 1 can bag 13 points as compared to Player 2 with 12."
                    },
                    {
                        "username": "gd4niele",
                        "content": "Assuming that both players are playing optimally, there can be two cases:\\nFirst case (starting from the first zero): P1 [0, 6, 6, 0] P2 [1, 5, 7]\\nSecond case (starting from 1): P1 [1, 5, 6, 0] P2 [6, 0, 7]\\nSo, in this case, the first player will always lose."
                    },
                    {
                        "username": "N00b_ME",
                        "content": "[@rakeshSharma19](/rakeshSharma19) thanks so much , this cleared my doubts "
                    },
                    {
                        "username": "rakeshSharma19",
                        "content": "Same thing happen to me, think about the case Player1 - [1,5,6,0] and player2 - [6,0,7] you will get your answer"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "Both the players playing optimally for overall game not optimal at each step. "
                    },
                    {
                        "username": "belayneh_12",
                        "content": "the correct answer should be False"
                    },
                    {
                        "username": "gentlezephyr95",
                        "content": "The key step is figuring out that both players will play to maximise the score. This translates the problem to an optimization problem which can be solved with DP.\\nI found this helpful: https://medium.com/algorithms-digest/predict-the-winner-16668e9c1cb8"
                    },
                    {
                        "username": "lolcharles",
                        "content": "[0,0,7,6,5,6,1]\\n\\nApparently player 1 can\\'t win here. Why? \\nOptimized steps for player 2 yields:\\nPlayer 1: 1\\nPlayer 2: 6\\nPlayer 1: 5\\nPlayer 2: 6\\nPlayer 1: 7\\n\\nWith the score 13-12 for player 1."
                    },
                    {
                        "username": "dheeraj2002_",
                        "content": "Try to see a video about min-max algorithm, you would be able to solve the question easily."
                    },
                    {
                        "username": "rakeshSharma19",
                        "content": "If I\\'m your competitor(player 2), Then the steps are\\n\\nPlayer1 chooses 1, array now - [0, 0, 7, 6, 5, 6] Player1: 1, Player2: 0\\nPlayer2 chooses 6, array now - [0, 0, 7, 6, 5] Player1: 1, Player2: 6\\nPlayer1 chooses 5, array now - [0, 0, 7, 6] Player1: 6, Player2: 6\\nPlayer2 chooses 0, array now - [0, 7, 6] Player1: 6, Player2: 6\\nPlayer1 chooses either 0 or 6, array now - [0, 7] Player1: 12, Player2: 6 if chooses 6 \\nPlayer2 chooses 7, array now - [0,] Player1: 12, Player2: 13\\nPlayer2 Will win\\n\\nHere Both the players playing optimally for overall game not optimal at each step.\\nUse DP here to get the solution."
                    },
                    {
                        "username": "enzo_cheng",
                        "content": "If i'm your competitor (Player 2), after this step:\n>>> Player 1 chooses 5 [0,0.7,6] Player1: 6, Player2: 6\nPlayer 2 will select 0,\n>>> Player 2 chooses 0 [0,7,6] Player1: 6, Player2: 6\n>>> Player 1 chooses 6 [0,7] Player1: 12, Player2: 6\n>>> Player 2 chooses 7 [0] Player1: 12, Player2: 13\n\nResult is that Player 2 wins always"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Game theory. 2 people contest. like chess game or go! Use DP to solve! Similar questions\n# Stone Game~  Stone Game IX"
                    },
                    {
                        "username": "riturajsingh487",
                        "content": "Player 1 can never lose in this test case (wrong test case).\\n\\nFact: if number of elements in an array are even , then whoever plays first will win (or tie if sum of elements at odd position is equal to sum of elements at even position).\\n\\nNow, player1 will take max(nums[0], nums[numsSize-1]) in first step.\\nin 2nd step: number of elements left in array becomes even. Now, since sum(elements at odd positions) == sum(elemenst at even positions) , if both players play optimally they will have same points after after 1st step.\\n\\nSo, player 1 will have more points (points of 1st step + equal points with player2).\\nClearly player1 shold be the winner."
                    },
                    {
                        "username": "adityadeokar123",
                        "content": "[@disturbedbrown1](/disturbedbrown1) Test Case = [0,1,0] ?"
                    },
                    {
                        "username": "Ilkhomjon",
                        "content": "[@disturbedbrown1](/disturbedbrown1) Nope, it depends the values of each element. So can\\'t tell the winner by only considering the number of elements."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Another pattern I noticed that if there are less than 3 elements, than whoever plays first will win."
                    },
                    {
                        "username": "pyoneerC",
                        "content": "Bro if both players are playing \"optimally\" you are not gonna choose 1 over 7 \\n\\n[1,5,233,7] should be false"
                    },
                    {
                        "username": "sikora92",
                        "content": "They see whole array, so do not behave greedy."
                    },
                    {
                        "username": "psionl0",
                        "content": "But if player 1 chooses 1 then no matter what player 2 chooses, player 1 gets the jackpot (233). So choosing 1 over 7 is the optimal strategy."
                    },
                    {
                        "username": "Harrywithcode",
                        "content": "So, I don't understand what author want to say from \" Player 1 picks one of the numbers from either end of the array followed by the player 2 and then player 1 and so on.\" Is there any mistake in this sentence?\\nPlayer 1 picks either end of the array or what?\\nWhy player 1 should followed by player 2? I think player 1 pick first, right?"
                    },
                    {
                        "username": "Dylan_Yifan",
                        "content": "the start of the array is \"one end\" of an array, while the end of the array is the \"other end\" of the array. So the sentence is correct that it\\'s picking \"either end of the array\""
                    }
                ]
            },
            {
                "id": 1989589,
                "content": [
                    {
                        "username": "deleted_user",
                        "content": "I did not understand what the question was asking exactly during the contest. I came up with multiple solutions based on what I thought was being asked, but they were all incorrect. Looks like I finally understood it. I wanted to clarify the question for people who may be confused like me.\\n\\nThe setup should be easy to understand. p1 and p2 take turns in picking a number from the input array, either the first item or the last item. When an item is picked by one of the player, that item cannot be used anymore; you can imagine it being removed from the array.\\n\\nWhat made me confused was the part \"... predict whether player 1 is the winner. You can assume each player plays to maximize his score.\" I was not sure what maximizing the score meant. Here is what it means.\\n\\nLet's say the initial array is [1, 5, 2]. It's p1's turn. p1 will pick either 1 or 2, but it wants to make sure that whichever one he picks will maximize his gain at the end. What if p1 picks 1? Now the array is [5, 2] and it's p2's turn to pick. p2 looks at the current array and thinks about how to maximize his gain at the end. Obviously, picking 5 will maximize his gains. So, p2 will pick 5, leaving 2 for p1. Resulting scores for p1 and p2 are 3 and 5 respectively. This one did not work out for p1.\\n\\nWhat if p1 picks 2 at the beginning? Then the array becomes [1, 5]. Again, p2 looks at the current array and thinks about how to maximize his gain at the end. Picking 5 will maximize his gains. So, p2 will pick 5, leaving 1 for p1. Resulting scores for p1 and p2 are 3 and 5 respectively. This one did not work out for p1 either. Those were the only two possibilities for game play. p1 can never win.\\n\\nWhat if the input array is [1, 5, 233, 7]? For this one, let me list all possibilities and explain which ones are valid and which ones are not.\\n\\n![0_1485064722628_upload-5137006d-197e-47b8-92a3-276224ff6f97](/uploads/files/1485064725743-upload-5137006d-197e-47b8-92a3-276224ff6f97.png) \\n\\nWhat clarified the question for me was realizing that in each step the current player takes a look at the current array as a whole and tries to make the best pick for maximizing it's gain (taking into consideration what the other player may do). \\n\\nI hope this helps someone."
                    },
                    {
                        "username": "watsonsherlock",
                        "content": "[@079_RISHABH](/079_RISHABH) No, the problem is not based on greedy. Greedy means choosing the current best. But it is evident from the second example that if you always choose the best options that is available to you in each step, you will loose the game."
                    },
                    {
                        "username": "786_Rishabh",
                        "content": "Thanks bro. Question was not very clear? But From your explaination I got  point that this  problem is using greedy approach to predict the winner. Earlier it was not clear from the question."
                    },
                    {
                        "username": "Rajat_Shukla",
                        "content": "Thank you for explaining the question :)"
                    },
                    {
                        "username": "luanct",
                        "content": "This is Bob and Alice with stone games. They keep playing even when knowing the winner. Bob has a crush on Alice ngl\\uD83D\\uDE02 "
                    },
                    {
                        "username": "RebelWithoutFlaws",
                        "content": "Who wouldnt fall in love with a girl who spends all of her time playing cryptographic games \\uD83E\\uDD13"
                    },
                    {
                        "username": "aruuu____",
                        "content": "lol\\uD83D\\uDE06\\uD83D\\uDE06"
                    },
                    {
                        "username": "JS00",
                        "content": "This might be the first time they are actually playing a fair game, Bob finally came to his senses!"
                    },
                    {
                        "username": "yjian012",
                        "content": "Yeah I can totally see [how the games go](https://postimg.cc/8f8QbhPF)."
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": "Tip for recursive solutions, the player 1 win on the following conditions:\n1) In player1 turn, player1 can win by picking either left or right side Hint: `||`. \n2) In player2 turn, player1 wins when player1 have larger score than player2 in both possibilities right and left. Hint: `&&`. \n3) Base case: when the range l < r."
                    },
                    {
                        "username": "nitissssh",
                        "content": "[@rayahemesh](/rayahemesh) Note the question says both player play optimally ie , if the player 2 has chance that of to make the \n        // the player one loose , then he will not choose the path in wich the player one wins , so to make sure the\n        // player one always wins no matter how cheeky is the player2 we use && , so that we only return true if there \n        // is no way that player2 ka loose the player1 "
                    },
                    {
                        "username": "stachofsky",
                        "content": "[@shashank-lol](/shashank-lol) sorry the base case... what does `when the range l < r` mean?"
                    },
                    {
                        "username": "pj1999",
                        "content": "[@rayahemesh](/rayahemesh)  for both possibilities of player 2 if either possibility returns in favour of player 2 (say false)  we have to return false as player 2 also plays optimally."
                    },
                    {
                        "username": "chandramani_lc",
                        "content": "[@rayahemesh](/rayahemesh) you have to write the recursion thinking of **can u make Player1 win** be it any possible way. So in the course of doing so u might come across the idea that if it's **player1** turn to pick then he can go with either end element and will declared winner if he wins in any of it's choice (so OR). If it's **Player2** turn then **Player1** can only win if **player1** value is greater than that of **player2** in any of the choices of **Player2**(so we need both true i.e &&). "
                    },
                    {
                        "username": "rayahemesh",
                        "content": "Thanks... can you explain bit clearly why && is for"
                    },
                    {
                        "username": "shashank-lol",
                        "content": "Thanks a lot buddy"
                    },
                    {
                        "username": "kng",
                        "content": "Input:\\n[0,0,7,6,5,6,1]\\nOutput:\\ntrue\\nExpected:\\nfalse\\n\\nI guess the answer should be true since Player 1 can bag 13 points as compared to Player 2 with 12."
                    },
                    {
                        "username": "gd4niele",
                        "content": "Assuming that both players are playing optimally, there can be two cases:\\nFirst case (starting from the first zero): P1 [0, 6, 6, 0] P2 [1, 5, 7]\\nSecond case (starting from 1): P1 [1, 5, 6, 0] P2 [6, 0, 7]\\nSo, in this case, the first player will always lose."
                    },
                    {
                        "username": "N00b_ME",
                        "content": "[@rakeshSharma19](/rakeshSharma19) thanks so much , this cleared my doubts "
                    },
                    {
                        "username": "rakeshSharma19",
                        "content": "Same thing happen to me, think about the case Player1 - [1,5,6,0] and player2 - [6,0,7] you will get your answer"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "Both the players playing optimally for overall game not optimal at each step. "
                    },
                    {
                        "username": "belayneh_12",
                        "content": "the correct answer should be False"
                    },
                    {
                        "username": "gentlezephyr95",
                        "content": "The key step is figuring out that both players will play to maximise the score. This translates the problem to an optimization problem which can be solved with DP.\\nI found this helpful: https://medium.com/algorithms-digest/predict-the-winner-16668e9c1cb8"
                    },
                    {
                        "username": "lolcharles",
                        "content": "[0,0,7,6,5,6,1]\\n\\nApparently player 1 can\\'t win here. Why? \\nOptimized steps for player 2 yields:\\nPlayer 1: 1\\nPlayer 2: 6\\nPlayer 1: 5\\nPlayer 2: 6\\nPlayer 1: 7\\n\\nWith the score 13-12 for player 1."
                    },
                    {
                        "username": "dheeraj2002_",
                        "content": "Try to see a video about min-max algorithm, you would be able to solve the question easily."
                    },
                    {
                        "username": "rakeshSharma19",
                        "content": "If I\\'m your competitor(player 2), Then the steps are\\n\\nPlayer1 chooses 1, array now - [0, 0, 7, 6, 5, 6] Player1: 1, Player2: 0\\nPlayer2 chooses 6, array now - [0, 0, 7, 6, 5] Player1: 1, Player2: 6\\nPlayer1 chooses 5, array now - [0, 0, 7, 6] Player1: 6, Player2: 6\\nPlayer2 chooses 0, array now - [0, 7, 6] Player1: 6, Player2: 6\\nPlayer1 chooses either 0 or 6, array now - [0, 7] Player1: 12, Player2: 6 if chooses 6 \\nPlayer2 chooses 7, array now - [0,] Player1: 12, Player2: 13\\nPlayer2 Will win\\n\\nHere Both the players playing optimally for overall game not optimal at each step.\\nUse DP here to get the solution."
                    },
                    {
                        "username": "enzo_cheng",
                        "content": "If i'm your competitor (Player 2), after this step:\n>>> Player 1 chooses 5 [0,0.7,6] Player1: 6, Player2: 6\nPlayer 2 will select 0,\n>>> Player 2 chooses 0 [0,7,6] Player1: 6, Player2: 6\n>>> Player 1 chooses 6 [0,7] Player1: 12, Player2: 6\n>>> Player 2 chooses 7 [0] Player1: 12, Player2: 13\n\nResult is that Player 2 wins always"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Game theory. 2 people contest. like chess game or go! Use DP to solve! Similar questions\n# Stone Game~  Stone Game IX"
                    },
                    {
                        "username": "riturajsingh487",
                        "content": "Player 1 can never lose in this test case (wrong test case).\\n\\nFact: if number of elements in an array are even , then whoever plays first will win (or tie if sum of elements at odd position is equal to sum of elements at even position).\\n\\nNow, player1 will take max(nums[0], nums[numsSize-1]) in first step.\\nin 2nd step: number of elements left in array becomes even. Now, since sum(elements at odd positions) == sum(elemenst at even positions) , if both players play optimally they will have same points after after 1st step.\\n\\nSo, player 1 will have more points (points of 1st step + equal points with player2).\\nClearly player1 shold be the winner."
                    },
                    {
                        "username": "adityadeokar123",
                        "content": "[@disturbedbrown1](/disturbedbrown1) Test Case = [0,1,0] ?"
                    },
                    {
                        "username": "Ilkhomjon",
                        "content": "[@disturbedbrown1](/disturbedbrown1) Nope, it depends the values of each element. So can\\'t tell the winner by only considering the number of elements."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Another pattern I noticed that if there are less than 3 elements, than whoever plays first will win."
                    },
                    {
                        "username": "pyoneerC",
                        "content": "Bro if both players are playing \"optimally\" you are not gonna choose 1 over 7 \\n\\n[1,5,233,7] should be false"
                    },
                    {
                        "username": "sikora92",
                        "content": "They see whole array, so do not behave greedy."
                    },
                    {
                        "username": "psionl0",
                        "content": "But if player 1 chooses 1 then no matter what player 2 chooses, player 1 gets the jackpot (233). So choosing 1 over 7 is the optimal strategy."
                    },
                    {
                        "username": "Harrywithcode",
                        "content": "So, I don't understand what author want to say from \" Player 1 picks one of the numbers from either end of the array followed by the player 2 and then player 1 and so on.\" Is there any mistake in this sentence?\\nPlayer 1 picks either end of the array or what?\\nWhy player 1 should followed by player 2? I think player 1 pick first, right?"
                    },
                    {
                        "username": "Dylan_Yifan",
                        "content": "the start of the array is \"one end\" of an array, while the end of the array is the \"other end\" of the array. So the sentence is correct that it\\'s picking \"either end of the array\""
                    }
                ]
            },
            {
                "id": 1569129,
                "content": [
                    {
                        "username": "deleted_user",
                        "content": "I did not understand what the question was asking exactly during the contest. I came up with multiple solutions based on what I thought was being asked, but they were all incorrect. Looks like I finally understood it. I wanted to clarify the question for people who may be confused like me.\\n\\nThe setup should be easy to understand. p1 and p2 take turns in picking a number from the input array, either the first item or the last item. When an item is picked by one of the player, that item cannot be used anymore; you can imagine it being removed from the array.\\n\\nWhat made me confused was the part \"... predict whether player 1 is the winner. You can assume each player plays to maximize his score.\" I was not sure what maximizing the score meant. Here is what it means.\\n\\nLet's say the initial array is [1, 5, 2]. It's p1's turn. p1 will pick either 1 or 2, but it wants to make sure that whichever one he picks will maximize his gain at the end. What if p1 picks 1? Now the array is [5, 2] and it's p2's turn to pick. p2 looks at the current array and thinks about how to maximize his gain at the end. Obviously, picking 5 will maximize his gains. So, p2 will pick 5, leaving 2 for p1. Resulting scores for p1 and p2 are 3 and 5 respectively. This one did not work out for p1.\\n\\nWhat if p1 picks 2 at the beginning? Then the array becomes [1, 5]. Again, p2 looks at the current array and thinks about how to maximize his gain at the end. Picking 5 will maximize his gains. So, p2 will pick 5, leaving 1 for p1. Resulting scores for p1 and p2 are 3 and 5 respectively. This one did not work out for p1 either. Those were the only two possibilities for game play. p1 can never win.\\n\\nWhat if the input array is [1, 5, 233, 7]? For this one, let me list all possibilities and explain which ones are valid and which ones are not.\\n\\n![0_1485064722628_upload-5137006d-197e-47b8-92a3-276224ff6f97](/uploads/files/1485064725743-upload-5137006d-197e-47b8-92a3-276224ff6f97.png) \\n\\nWhat clarified the question for me was realizing that in each step the current player takes a look at the current array as a whole and tries to make the best pick for maximizing it's gain (taking into consideration what the other player may do). \\n\\nI hope this helps someone."
                    },
                    {
                        "username": "watsonsherlock",
                        "content": "[@079_RISHABH](/079_RISHABH) No, the problem is not based on greedy. Greedy means choosing the current best. But it is evident from the second example that if you always choose the best options that is available to you in each step, you will loose the game."
                    },
                    {
                        "username": "786_Rishabh",
                        "content": "Thanks bro. Question was not very clear? But From your explaination I got  point that this  problem is using greedy approach to predict the winner. Earlier it was not clear from the question."
                    },
                    {
                        "username": "Rajat_Shukla",
                        "content": "Thank you for explaining the question :)"
                    },
                    {
                        "username": "luanct",
                        "content": "This is Bob and Alice with stone games. They keep playing even when knowing the winner. Bob has a crush on Alice ngl\\uD83D\\uDE02 "
                    },
                    {
                        "username": "RebelWithoutFlaws",
                        "content": "Who wouldnt fall in love with a girl who spends all of her time playing cryptographic games \\uD83E\\uDD13"
                    },
                    {
                        "username": "aruuu____",
                        "content": "lol\\uD83D\\uDE06\\uD83D\\uDE06"
                    },
                    {
                        "username": "JS00",
                        "content": "This might be the first time they are actually playing a fair game, Bob finally came to his senses!"
                    },
                    {
                        "username": "yjian012",
                        "content": "Yeah I can totally see [how the games go](https://postimg.cc/8f8QbhPF)."
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": "Tip for recursive solutions, the player 1 win on the following conditions:\n1) In player1 turn, player1 can win by picking either left or right side Hint: `||`. \n2) In player2 turn, player1 wins when player1 have larger score than player2 in both possibilities right and left. Hint: `&&`. \n3) Base case: when the range l < r."
                    },
                    {
                        "username": "nitissssh",
                        "content": "[@rayahemesh](/rayahemesh) Note the question says both player play optimally ie , if the player 2 has chance that of to make the \n        // the player one loose , then he will not choose the path in wich the player one wins , so to make sure the\n        // player one always wins no matter how cheeky is the player2 we use && , so that we only return true if there \n        // is no way that player2 ka loose the player1 "
                    },
                    {
                        "username": "stachofsky",
                        "content": "[@shashank-lol](/shashank-lol) sorry the base case... what does `when the range l < r` mean?"
                    },
                    {
                        "username": "pj1999",
                        "content": "[@rayahemesh](/rayahemesh)  for both possibilities of player 2 if either possibility returns in favour of player 2 (say false)  we have to return false as player 2 also plays optimally."
                    },
                    {
                        "username": "chandramani_lc",
                        "content": "[@rayahemesh](/rayahemesh) you have to write the recursion thinking of **can u make Player1 win** be it any possible way. So in the course of doing so u might come across the idea that if it's **player1** turn to pick then he can go with either end element and will declared winner if he wins in any of it's choice (so OR). If it's **Player2** turn then **Player1** can only win if **player1** value is greater than that of **player2** in any of the choices of **Player2**(so we need both true i.e &&). "
                    },
                    {
                        "username": "rayahemesh",
                        "content": "Thanks... can you explain bit clearly why && is for"
                    },
                    {
                        "username": "shashank-lol",
                        "content": "Thanks a lot buddy"
                    },
                    {
                        "username": "kng",
                        "content": "Input:\\n[0,0,7,6,5,6,1]\\nOutput:\\ntrue\\nExpected:\\nfalse\\n\\nI guess the answer should be true since Player 1 can bag 13 points as compared to Player 2 with 12."
                    },
                    {
                        "username": "gd4niele",
                        "content": "Assuming that both players are playing optimally, there can be two cases:\\nFirst case (starting from the first zero): P1 [0, 6, 6, 0] P2 [1, 5, 7]\\nSecond case (starting from 1): P1 [1, 5, 6, 0] P2 [6, 0, 7]\\nSo, in this case, the first player will always lose."
                    },
                    {
                        "username": "N00b_ME",
                        "content": "[@rakeshSharma19](/rakeshSharma19) thanks so much , this cleared my doubts "
                    },
                    {
                        "username": "rakeshSharma19",
                        "content": "Same thing happen to me, think about the case Player1 - [1,5,6,0] and player2 - [6,0,7] you will get your answer"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "Both the players playing optimally for overall game not optimal at each step. "
                    },
                    {
                        "username": "belayneh_12",
                        "content": "the correct answer should be False"
                    },
                    {
                        "username": "gentlezephyr95",
                        "content": "The key step is figuring out that both players will play to maximise the score. This translates the problem to an optimization problem which can be solved with DP.\\nI found this helpful: https://medium.com/algorithms-digest/predict-the-winner-16668e9c1cb8"
                    },
                    {
                        "username": "lolcharles",
                        "content": "[0,0,7,6,5,6,1]\\n\\nApparently player 1 can\\'t win here. Why? \\nOptimized steps for player 2 yields:\\nPlayer 1: 1\\nPlayer 2: 6\\nPlayer 1: 5\\nPlayer 2: 6\\nPlayer 1: 7\\n\\nWith the score 13-12 for player 1."
                    },
                    {
                        "username": "dheeraj2002_",
                        "content": "Try to see a video about min-max algorithm, you would be able to solve the question easily."
                    },
                    {
                        "username": "rakeshSharma19",
                        "content": "If I\\'m your competitor(player 2), Then the steps are\\n\\nPlayer1 chooses 1, array now - [0, 0, 7, 6, 5, 6] Player1: 1, Player2: 0\\nPlayer2 chooses 6, array now - [0, 0, 7, 6, 5] Player1: 1, Player2: 6\\nPlayer1 chooses 5, array now - [0, 0, 7, 6] Player1: 6, Player2: 6\\nPlayer2 chooses 0, array now - [0, 7, 6] Player1: 6, Player2: 6\\nPlayer1 chooses either 0 or 6, array now - [0, 7] Player1: 12, Player2: 6 if chooses 6 \\nPlayer2 chooses 7, array now - [0,] Player1: 12, Player2: 13\\nPlayer2 Will win\\n\\nHere Both the players playing optimally for overall game not optimal at each step.\\nUse DP here to get the solution."
                    },
                    {
                        "username": "enzo_cheng",
                        "content": "If i'm your competitor (Player 2), after this step:\n>>> Player 1 chooses 5 [0,0.7,6] Player1: 6, Player2: 6\nPlayer 2 will select 0,\n>>> Player 2 chooses 0 [0,7,6] Player1: 6, Player2: 6\n>>> Player 1 chooses 6 [0,7] Player1: 12, Player2: 6\n>>> Player 2 chooses 7 [0] Player1: 12, Player2: 13\n\nResult is that Player 2 wins always"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Game theory. 2 people contest. like chess game or go! Use DP to solve! Similar questions\n# Stone Game~  Stone Game IX"
                    },
                    {
                        "username": "riturajsingh487",
                        "content": "Player 1 can never lose in this test case (wrong test case).\\n\\nFact: if number of elements in an array are even , then whoever plays first will win (or tie if sum of elements at odd position is equal to sum of elements at even position).\\n\\nNow, player1 will take max(nums[0], nums[numsSize-1]) in first step.\\nin 2nd step: number of elements left in array becomes even. Now, since sum(elements at odd positions) == sum(elemenst at even positions) , if both players play optimally they will have same points after after 1st step.\\n\\nSo, player 1 will have more points (points of 1st step + equal points with player2).\\nClearly player1 shold be the winner."
                    },
                    {
                        "username": "adityadeokar123",
                        "content": "[@disturbedbrown1](/disturbedbrown1) Test Case = [0,1,0] ?"
                    },
                    {
                        "username": "Ilkhomjon",
                        "content": "[@disturbedbrown1](/disturbedbrown1) Nope, it depends the values of each element. So can\\'t tell the winner by only considering the number of elements."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Another pattern I noticed that if there are less than 3 elements, than whoever plays first will win."
                    },
                    {
                        "username": "pyoneerC",
                        "content": "Bro if both players are playing \"optimally\" you are not gonna choose 1 over 7 \\n\\n[1,5,233,7] should be false"
                    },
                    {
                        "username": "sikora92",
                        "content": "They see whole array, so do not behave greedy."
                    },
                    {
                        "username": "psionl0",
                        "content": "But if player 1 chooses 1 then no matter what player 2 chooses, player 1 gets the jackpot (233). So choosing 1 over 7 is the optimal strategy."
                    },
                    {
                        "username": "Harrywithcode",
                        "content": "So, I don't understand what author want to say from \" Player 1 picks one of the numbers from either end of the array followed by the player 2 and then player 1 and so on.\" Is there any mistake in this sentence?\\nPlayer 1 picks either end of the array or what?\\nWhy player 1 should followed by player 2? I think player 1 pick first, right?"
                    },
                    {
                        "username": "Dylan_Yifan",
                        "content": "the start of the array is \"one end\" of an array, while the end of the array is the \"other end\" of the array. So the sentence is correct that it\\'s picking \"either end of the array\""
                    }
                ]
            },
            {
                "id": 1569128,
                "content": [
                    {
                        "username": "wf94",
                        "content": "Hi, I am now stucked at the last testcase and can't figure out why \\n[0,0,7,6,5,6,1] should return False.\\n\\nHere's the reason I think it should return True.\\nPlayer 1 chooses 1 [0,0,7,6,5,6]  Player1: 1, Player2: 0\\nPlayer 2 chooses 6 [0,0,7,6,5] Player1: 1, Player2: 6\\nPlayer 1 chooses 5 [0,0.7,6] Player1: 6, Player2: 6\\nPlayer 2 chooses 6 [0,0,7] Player1: 6, Player2: 12\\nPlayer 1 chooses 7 [0,0] Player1: 13, Player2: 12\\n\\nThe Player 1 will eventually win. So it should return True."
                    },
                    {
                        "username": "rakeshSharma19",
                        "content": "If I\\'m your competitor(player 2), Then the steps are\\nPlayer1 chooses 1, array now - [0, 0, 7, 6, 5, 6] Player1: 1, Player2: 0\\nPlayer2 chooses 6, array now - [0, 0, 7, 6, 5] Player1: 1, Player2: 6\\nPlayer1 chooses 5, array now - [0, 0, 7, 6] Player1: 6, Player2: 6\\nPlayer2 chooses 0, array now - [0, 7, 6] Player1: 6, Player2: 6\\nPlayer1 chooses either 0 or 6, array now - [0, 7] Player1: 12, Player2: 6 if chooses 6 \\nPlayer2 chooses 7, array now - [0,] Player1: 12, Player2: 13\\nPlayer2 Will win\\nHere Both the players playing optimally for overall game not optimal at each step.\\nUse DP here to get the solution."
                    },
                    {
                        "username": "enzo_cheng",
                        "content": "If i'm your competitor (Player 2), after this step:\n    >>> Player 1 chooses 5 [0,0.7,6] Player1: 6, Player2: 6\nPlayer 2 will select 0,\n    >>> Player 2 chooses 0 [0,7,6] Player1: 6, Player2: 6\n    >>> Player 1 chooses 6 [0,7] Player1: 12, Player2: 6\n    >>> Player 2 chooses 7 [0] Player1: 12, Player2: 13\n\nResult is that Player 2 wins always\n"
                    },
                    {
                        "username": "JS00",
                        "content": "Real ones know the names of Player 1 and Player 2!!"
                    },
                    {
                        "username": "coder_pawn",
                        "content": "a test case:\\n[1,5,2,4,6]"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "You can assume player1 and player2 as Alice and bob.lol"
                    },
                    {
                        "username": "w-s",
                        "content": "Brute force passes, but better talk about DP if this comes up in interviews."
                    },
                    {
                        "username": "qqqxz",
                        "content": "How is it false?\\nA can pick 8, 55, 2\\nB picks 6,4"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "All players are playing  \"optimally\" to increase their own \"individual score\""
                    },
                    {
                        "username": "genericalAccount",
                        "content": "If player 1 starts taking the last element of the array, no matter which choice makes the player 2, he\\'ll have a advantage of 1, ending the game as 12 vs 13. What\\'s wrong with this logic?"
                    },
                    {
                        "username": "rakeshSharma19",
                        "content": "Think about this case [0, 0, 7, 6, 5, 6, 1] here Player2 will win, even though Player1 has advantage\\n\\nIf I\\'m your competitor(player 2), Then the steps are\\n\\nPlayer1 chooses 1, array now - [0, 0, 7, 6, 5, 6] Player1: 1, Player2: 0\\nPlayer2 chooses 6, array now - [0, 0, 7, 6, 5] Player1: 1, Player2: 6\\nPlayer1 chooses 5, array now - [0, 0, 7, 6] Player1: 6, Player2: 6\\nPlayer2 chooses 0, array now - [0, 7, 6] Player1: 6, Player2: 6\\nPlayer1 chooses either 0 or 6, array now - [0, 7] Player1: 12, Player2: 6 if chooses 6 \\nPlayer2 chooses 7, array now - [0,] Player1: 12, Player2: 13\\nPlayer2 Will win\\nHere Both the players playing optimally for overall game not optimal at each step.\\nUse DP here to get the solution."
                    },
                    {
                        "username": "vanni1212",
                        "content": "This problem has a test case\\n{2,4,55,6,8} of which the output is expected to be false. How is that so ? Because I understand that player 1 may choose 8,55,2 and thereby become the winner. Am I understanding the question wrong ?"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "[@math_pi](/math_pi) thanks bro I was looking for that."
                    },
                    {
                        "username": "math_pi",
                        "content": "The test case is correct, Here's How the Game Goes:\nLet's say P1(8) -> [2, 4, 55, 6]\nP2(2) -> [4, 55, 6]\nP1(6) -> [4, 55]\nP2(55) -> [4]\nP1(4) ->[]\nObviously P1 Takes an L.\nNow you could do the same thing if P1 chooses 2.\nThe main thing is P2 will choose a lesser element intentionally in order to not allow [55] to be at the end points of the array on P1 turn."
                    },
                    {
                        "username": "ashish2712",
                        "content": "No, the test case is correct.\\nif p1 choose 8, then p2 choose 2 and then 55.\\nif p1 choose 2, then p2 choose 8 and then 55. "
                    },
                    {
                        "username": "foodlover",
                        "content": "player 1 selects 8\\nPlayer 2 then selects 6\\nplayer 1 then selects 55\\nplaher 2 selects 4\\nplayer 1 selects 2\\n\\nDoesn\\'t player 1 win in this case ? The answer for this test case is false, but I feel that\\'s wrong [or have misunderstood the question]"
                    },
                    {
                        "username": "AniEthanHunt",
                        "content": "Player 1 can take 2 or 8.\\nP1 takes 2, then P2 will take 8 and P1 will lose as P2 will get 55 [4, 55, 6]\\nP1 takes 8, then P2 will take 2 and P1 will lose as P2 will get 55 [4, 55, 6]\\n\\nHere, both the player are playing optimally (game theory: min-max algorithm)."
                    },
                    {
                        "username": "Kharelg24",
                        "content": "Test_case2 = [1, 5, 233, 7]\\nI don\\'t understand why for this testcase, Player 1 would choose 1. Obviously 7 is bigger than 1 so shouldn\\'t player 1 choose 7 causing Player 2 to win at the end?"
                    },
                    {
                        "username": "Kharelg24",
                        "content": "[@rakeshSharma19](/rakeshSharma19) Thank you for your response rakesh, however my approach to this problem was to use the mini max algorithm which would take an optimal action in each step. Do you have any other recommendation for these problems?"
                    },
                    {
                        "username": "rakeshSharma19",
                        "content": "You need to understand, Here Both the players playing optimally for overall game not optimal at each step.\\nso If I\\'m player1, I have whole I look through the array and choose 1, because after this whatever player 2 will I have option to choose either 233 or the rest, so here each playing optimally for overall array not for the current step.\\nI hope I have cleared your doubt."
                    }
                ]
            },
            {
                "id": 1989825,
                "content": [
                    {
                        "username": "wf94",
                        "content": "Hi, I am now stucked at the last testcase and can't figure out why \\n[0,0,7,6,5,6,1] should return False.\\n\\nHere's the reason I think it should return True.\\nPlayer 1 chooses 1 [0,0,7,6,5,6]  Player1: 1, Player2: 0\\nPlayer 2 chooses 6 [0,0,7,6,5] Player1: 1, Player2: 6\\nPlayer 1 chooses 5 [0,0.7,6] Player1: 6, Player2: 6\\nPlayer 2 chooses 6 [0,0,7] Player1: 6, Player2: 12\\nPlayer 1 chooses 7 [0,0] Player1: 13, Player2: 12\\n\\nThe Player 1 will eventually win. So it should return True."
                    },
                    {
                        "username": "rakeshSharma19",
                        "content": "If I\\'m your competitor(player 2), Then the steps are\\nPlayer1 chooses 1, array now - [0, 0, 7, 6, 5, 6] Player1: 1, Player2: 0\\nPlayer2 chooses 6, array now - [0, 0, 7, 6, 5] Player1: 1, Player2: 6\\nPlayer1 chooses 5, array now - [0, 0, 7, 6] Player1: 6, Player2: 6\\nPlayer2 chooses 0, array now - [0, 7, 6] Player1: 6, Player2: 6\\nPlayer1 chooses either 0 or 6, array now - [0, 7] Player1: 12, Player2: 6 if chooses 6 \\nPlayer2 chooses 7, array now - [0,] Player1: 12, Player2: 13\\nPlayer2 Will win\\nHere Both the players playing optimally for overall game not optimal at each step.\\nUse DP here to get the solution."
                    },
                    {
                        "username": "enzo_cheng",
                        "content": "If i'm your competitor (Player 2), after this step:\n    >>> Player 1 chooses 5 [0,0.7,6] Player1: 6, Player2: 6\nPlayer 2 will select 0,\n    >>> Player 2 chooses 0 [0,7,6] Player1: 6, Player2: 6\n    >>> Player 1 chooses 6 [0,7] Player1: 12, Player2: 6\n    >>> Player 2 chooses 7 [0] Player1: 12, Player2: 13\n\nResult is that Player 2 wins always\n"
                    },
                    {
                        "username": "JS00",
                        "content": "Real ones know the names of Player 1 and Player 2!!"
                    },
                    {
                        "username": "coder_pawn",
                        "content": "a test case:\\n[1,5,2,4,6]"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "You can assume player1 and player2 as Alice and bob.lol"
                    },
                    {
                        "username": "w-s",
                        "content": "Brute force passes, but better talk about DP if this comes up in interviews."
                    },
                    {
                        "username": "qqqxz",
                        "content": "How is it false?\\nA can pick 8, 55, 2\\nB picks 6,4"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "All players are playing  \"optimally\" to increase their own \"individual score\""
                    },
                    {
                        "username": "genericalAccount",
                        "content": "If player 1 starts taking the last element of the array, no matter which choice makes the player 2, he\\'ll have a advantage of 1, ending the game as 12 vs 13. What\\'s wrong with this logic?"
                    },
                    {
                        "username": "rakeshSharma19",
                        "content": "Think about this case [0, 0, 7, 6, 5, 6, 1] here Player2 will win, even though Player1 has advantage\\n\\nIf I\\'m your competitor(player 2), Then the steps are\\n\\nPlayer1 chooses 1, array now - [0, 0, 7, 6, 5, 6] Player1: 1, Player2: 0\\nPlayer2 chooses 6, array now - [0, 0, 7, 6, 5] Player1: 1, Player2: 6\\nPlayer1 chooses 5, array now - [0, 0, 7, 6] Player1: 6, Player2: 6\\nPlayer2 chooses 0, array now - [0, 7, 6] Player1: 6, Player2: 6\\nPlayer1 chooses either 0 or 6, array now - [0, 7] Player1: 12, Player2: 6 if chooses 6 \\nPlayer2 chooses 7, array now - [0,] Player1: 12, Player2: 13\\nPlayer2 Will win\\nHere Both the players playing optimally for overall game not optimal at each step.\\nUse DP here to get the solution."
                    },
                    {
                        "username": "vanni1212",
                        "content": "This problem has a test case\\n{2,4,55,6,8} of which the output is expected to be false. How is that so ? Because I understand that player 1 may choose 8,55,2 and thereby become the winner. Am I understanding the question wrong ?"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "[@math_pi](/math_pi) thanks bro I was looking for that."
                    },
                    {
                        "username": "math_pi",
                        "content": "The test case is correct, Here's How the Game Goes:\nLet's say P1(8) -> [2, 4, 55, 6]\nP2(2) -> [4, 55, 6]\nP1(6) -> [4, 55]\nP2(55) -> [4]\nP1(4) ->[]\nObviously P1 Takes an L.\nNow you could do the same thing if P1 chooses 2.\nThe main thing is P2 will choose a lesser element intentionally in order to not allow [55] to be at the end points of the array on P1 turn."
                    },
                    {
                        "username": "ashish2712",
                        "content": "No, the test case is correct.\\nif p1 choose 8, then p2 choose 2 and then 55.\\nif p1 choose 2, then p2 choose 8 and then 55. "
                    },
                    {
                        "username": "foodlover",
                        "content": "player 1 selects 8\\nPlayer 2 then selects 6\\nplayer 1 then selects 55\\nplaher 2 selects 4\\nplayer 1 selects 2\\n\\nDoesn\\'t player 1 win in this case ? The answer for this test case is false, but I feel that\\'s wrong [or have misunderstood the question]"
                    },
                    {
                        "username": "AniEthanHunt",
                        "content": "Player 1 can take 2 or 8.\\nP1 takes 2, then P2 will take 8 and P1 will lose as P2 will get 55 [4, 55, 6]\\nP1 takes 8, then P2 will take 2 and P1 will lose as P2 will get 55 [4, 55, 6]\\n\\nHere, both the player are playing optimally (game theory: min-max algorithm)."
                    },
                    {
                        "username": "Kharelg24",
                        "content": "Test_case2 = [1, 5, 233, 7]\\nI don\\'t understand why for this testcase, Player 1 would choose 1. Obviously 7 is bigger than 1 so shouldn\\'t player 1 choose 7 causing Player 2 to win at the end?"
                    },
                    {
                        "username": "Kharelg24",
                        "content": "[@rakeshSharma19](/rakeshSharma19) Thank you for your response rakesh, however my approach to this problem was to use the mini max algorithm which would take an optimal action in each step. Do you have any other recommendation for these problems?"
                    },
                    {
                        "username": "rakeshSharma19",
                        "content": "You need to understand, Here Both the players playing optimally for overall game not optimal at each step.\\nso If I\\'m player1, I have whole I look through the array and choose 1, because after this whatever player 2 will I have option to choose either 233 or the rest, so here each playing optimally for overall array not for the current step.\\nI hope I have cleared your doubt."
                    }
                ]
            },
            {
                "id": 1989635,
                "content": [
                    {
                        "username": "wf94",
                        "content": "Hi, I am now stucked at the last testcase and can't figure out why \\n[0,0,7,6,5,6,1] should return False.\\n\\nHere's the reason I think it should return True.\\nPlayer 1 chooses 1 [0,0,7,6,5,6]  Player1: 1, Player2: 0\\nPlayer 2 chooses 6 [0,0,7,6,5] Player1: 1, Player2: 6\\nPlayer 1 chooses 5 [0,0.7,6] Player1: 6, Player2: 6\\nPlayer 2 chooses 6 [0,0,7] Player1: 6, Player2: 12\\nPlayer 1 chooses 7 [0,0] Player1: 13, Player2: 12\\n\\nThe Player 1 will eventually win. So it should return True."
                    },
                    {
                        "username": "rakeshSharma19",
                        "content": "If I\\'m your competitor(player 2), Then the steps are\\nPlayer1 chooses 1, array now - [0, 0, 7, 6, 5, 6] Player1: 1, Player2: 0\\nPlayer2 chooses 6, array now - [0, 0, 7, 6, 5] Player1: 1, Player2: 6\\nPlayer1 chooses 5, array now - [0, 0, 7, 6] Player1: 6, Player2: 6\\nPlayer2 chooses 0, array now - [0, 7, 6] Player1: 6, Player2: 6\\nPlayer1 chooses either 0 or 6, array now - [0, 7] Player1: 12, Player2: 6 if chooses 6 \\nPlayer2 chooses 7, array now - [0,] Player1: 12, Player2: 13\\nPlayer2 Will win\\nHere Both the players playing optimally for overall game not optimal at each step.\\nUse DP here to get the solution."
                    },
                    {
                        "username": "enzo_cheng",
                        "content": "If i'm your competitor (Player 2), after this step:\n    >>> Player 1 chooses 5 [0,0.7,6] Player1: 6, Player2: 6\nPlayer 2 will select 0,\n    >>> Player 2 chooses 0 [0,7,6] Player1: 6, Player2: 6\n    >>> Player 1 chooses 6 [0,7] Player1: 12, Player2: 6\n    >>> Player 2 chooses 7 [0] Player1: 12, Player2: 13\n\nResult is that Player 2 wins always\n"
                    },
                    {
                        "username": "JS00",
                        "content": "Real ones know the names of Player 1 and Player 2!!"
                    },
                    {
                        "username": "coder_pawn",
                        "content": "a test case:\\n[1,5,2,4,6]"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "You can assume player1 and player2 as Alice and bob.lol"
                    },
                    {
                        "username": "w-s",
                        "content": "Brute force passes, but better talk about DP if this comes up in interviews."
                    },
                    {
                        "username": "qqqxz",
                        "content": "How is it false?\\nA can pick 8, 55, 2\\nB picks 6,4"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "All players are playing  \"optimally\" to increase their own \"individual score\""
                    },
                    {
                        "username": "genericalAccount",
                        "content": "If player 1 starts taking the last element of the array, no matter which choice makes the player 2, he\\'ll have a advantage of 1, ending the game as 12 vs 13. What\\'s wrong with this logic?"
                    },
                    {
                        "username": "rakeshSharma19",
                        "content": "Think about this case [0, 0, 7, 6, 5, 6, 1] here Player2 will win, even though Player1 has advantage\\n\\nIf I\\'m your competitor(player 2), Then the steps are\\n\\nPlayer1 chooses 1, array now - [0, 0, 7, 6, 5, 6] Player1: 1, Player2: 0\\nPlayer2 chooses 6, array now - [0, 0, 7, 6, 5] Player1: 1, Player2: 6\\nPlayer1 chooses 5, array now - [0, 0, 7, 6] Player1: 6, Player2: 6\\nPlayer2 chooses 0, array now - [0, 7, 6] Player1: 6, Player2: 6\\nPlayer1 chooses either 0 or 6, array now - [0, 7] Player1: 12, Player2: 6 if chooses 6 \\nPlayer2 chooses 7, array now - [0,] Player1: 12, Player2: 13\\nPlayer2 Will win\\nHere Both the players playing optimally for overall game not optimal at each step.\\nUse DP here to get the solution."
                    },
                    {
                        "username": "vanni1212",
                        "content": "This problem has a test case\\n{2,4,55,6,8} of which the output is expected to be false. How is that so ? Because I understand that player 1 may choose 8,55,2 and thereby become the winner. Am I understanding the question wrong ?"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "[@math_pi](/math_pi) thanks bro I was looking for that."
                    },
                    {
                        "username": "math_pi",
                        "content": "The test case is correct, Here's How the Game Goes:\nLet's say P1(8) -> [2, 4, 55, 6]\nP2(2) -> [4, 55, 6]\nP1(6) -> [4, 55]\nP2(55) -> [4]\nP1(4) ->[]\nObviously P1 Takes an L.\nNow you could do the same thing if P1 chooses 2.\nThe main thing is P2 will choose a lesser element intentionally in order to not allow [55] to be at the end points of the array on P1 turn."
                    },
                    {
                        "username": "ashish2712",
                        "content": "No, the test case is correct.\\nif p1 choose 8, then p2 choose 2 and then 55.\\nif p1 choose 2, then p2 choose 8 and then 55. "
                    },
                    {
                        "username": "foodlover",
                        "content": "player 1 selects 8\\nPlayer 2 then selects 6\\nplayer 1 then selects 55\\nplaher 2 selects 4\\nplayer 1 selects 2\\n\\nDoesn\\'t player 1 win in this case ? The answer for this test case is false, but I feel that\\'s wrong [or have misunderstood the question]"
                    },
                    {
                        "username": "AniEthanHunt",
                        "content": "Player 1 can take 2 or 8.\\nP1 takes 2, then P2 will take 8 and P1 will lose as P2 will get 55 [4, 55, 6]\\nP1 takes 8, then P2 will take 2 and P1 will lose as P2 will get 55 [4, 55, 6]\\n\\nHere, both the player are playing optimally (game theory: min-max algorithm)."
                    },
                    {
                        "username": "Kharelg24",
                        "content": "Test_case2 = [1, 5, 233, 7]\\nI don\\'t understand why for this testcase, Player 1 would choose 1. Obviously 7 is bigger than 1 so shouldn\\'t player 1 choose 7 causing Player 2 to win at the end?"
                    },
                    {
                        "username": "Kharelg24",
                        "content": "[@rakeshSharma19](/rakeshSharma19) Thank you for your response rakesh, however my approach to this problem was to use the mini max algorithm which would take an optimal action in each step. Do you have any other recommendation for these problems?"
                    },
                    {
                        "username": "rakeshSharma19",
                        "content": "You need to understand, Here Both the players playing optimally for overall game not optimal at each step.\\nso If I\\'m player1, I have whole I look through the array and choose 1, because after this whatever player 2 will I have option to choose either 233 or the rest, so here each playing optimally for overall array not for the current step.\\nI hope I have cleared your doubt."
                    }
                ]
            },
            {
                "id": 1989565,
                "content": [
                    {
                        "username": "wf94",
                        "content": "Hi, I am now stucked at the last testcase and can't figure out why \\n[0,0,7,6,5,6,1] should return False.\\n\\nHere's the reason I think it should return True.\\nPlayer 1 chooses 1 [0,0,7,6,5,6]  Player1: 1, Player2: 0\\nPlayer 2 chooses 6 [0,0,7,6,5] Player1: 1, Player2: 6\\nPlayer 1 chooses 5 [0,0.7,6] Player1: 6, Player2: 6\\nPlayer 2 chooses 6 [0,0,7] Player1: 6, Player2: 12\\nPlayer 1 chooses 7 [0,0] Player1: 13, Player2: 12\\n\\nThe Player 1 will eventually win. So it should return True."
                    },
                    {
                        "username": "rakeshSharma19",
                        "content": "If I\\'m your competitor(player 2), Then the steps are\\nPlayer1 chooses 1, array now - [0, 0, 7, 6, 5, 6] Player1: 1, Player2: 0\\nPlayer2 chooses 6, array now - [0, 0, 7, 6, 5] Player1: 1, Player2: 6\\nPlayer1 chooses 5, array now - [0, 0, 7, 6] Player1: 6, Player2: 6\\nPlayer2 chooses 0, array now - [0, 7, 6] Player1: 6, Player2: 6\\nPlayer1 chooses either 0 or 6, array now - [0, 7] Player1: 12, Player2: 6 if chooses 6 \\nPlayer2 chooses 7, array now - [0,] Player1: 12, Player2: 13\\nPlayer2 Will win\\nHere Both the players playing optimally for overall game not optimal at each step.\\nUse DP here to get the solution."
                    },
                    {
                        "username": "enzo_cheng",
                        "content": "If i'm your competitor (Player 2), after this step:\n    >>> Player 1 chooses 5 [0,0.7,6] Player1: 6, Player2: 6\nPlayer 2 will select 0,\n    >>> Player 2 chooses 0 [0,7,6] Player1: 6, Player2: 6\n    >>> Player 1 chooses 6 [0,7] Player1: 12, Player2: 6\n    >>> Player 2 chooses 7 [0] Player1: 12, Player2: 13\n\nResult is that Player 2 wins always\n"
                    },
                    {
                        "username": "JS00",
                        "content": "Real ones know the names of Player 1 and Player 2!!"
                    },
                    {
                        "username": "coder_pawn",
                        "content": "a test case:\\n[1,5,2,4,6]"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "You can assume player1 and player2 as Alice and bob.lol"
                    },
                    {
                        "username": "w-s",
                        "content": "Brute force passes, but better talk about DP if this comes up in interviews."
                    },
                    {
                        "username": "qqqxz",
                        "content": "How is it false?\\nA can pick 8, 55, 2\\nB picks 6,4"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "All players are playing  \"optimally\" to increase their own \"individual score\""
                    },
                    {
                        "username": "genericalAccount",
                        "content": "If player 1 starts taking the last element of the array, no matter which choice makes the player 2, he\\'ll have a advantage of 1, ending the game as 12 vs 13. What\\'s wrong with this logic?"
                    },
                    {
                        "username": "rakeshSharma19",
                        "content": "Think about this case [0, 0, 7, 6, 5, 6, 1] here Player2 will win, even though Player1 has advantage\\n\\nIf I\\'m your competitor(player 2), Then the steps are\\n\\nPlayer1 chooses 1, array now - [0, 0, 7, 6, 5, 6] Player1: 1, Player2: 0\\nPlayer2 chooses 6, array now - [0, 0, 7, 6, 5] Player1: 1, Player2: 6\\nPlayer1 chooses 5, array now - [0, 0, 7, 6] Player1: 6, Player2: 6\\nPlayer2 chooses 0, array now - [0, 7, 6] Player1: 6, Player2: 6\\nPlayer1 chooses either 0 or 6, array now - [0, 7] Player1: 12, Player2: 6 if chooses 6 \\nPlayer2 chooses 7, array now - [0,] Player1: 12, Player2: 13\\nPlayer2 Will win\\nHere Both the players playing optimally for overall game not optimal at each step.\\nUse DP here to get the solution."
                    },
                    {
                        "username": "vanni1212",
                        "content": "This problem has a test case\\n{2,4,55,6,8} of which the output is expected to be false. How is that so ? Because I understand that player 1 may choose 8,55,2 and thereby become the winner. Am I understanding the question wrong ?"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "[@math_pi](/math_pi) thanks bro I was looking for that."
                    },
                    {
                        "username": "math_pi",
                        "content": "The test case is correct, Here's How the Game Goes:\nLet's say P1(8) -> [2, 4, 55, 6]\nP2(2) -> [4, 55, 6]\nP1(6) -> [4, 55]\nP2(55) -> [4]\nP1(4) ->[]\nObviously P1 Takes an L.\nNow you could do the same thing if P1 chooses 2.\nThe main thing is P2 will choose a lesser element intentionally in order to not allow [55] to be at the end points of the array on P1 turn."
                    },
                    {
                        "username": "ashish2712",
                        "content": "No, the test case is correct.\\nif p1 choose 8, then p2 choose 2 and then 55.\\nif p1 choose 2, then p2 choose 8 and then 55. "
                    },
                    {
                        "username": "foodlover",
                        "content": "player 1 selects 8\\nPlayer 2 then selects 6\\nplayer 1 then selects 55\\nplaher 2 selects 4\\nplayer 1 selects 2\\n\\nDoesn\\'t player 1 win in this case ? The answer for this test case is false, but I feel that\\'s wrong [or have misunderstood the question]"
                    },
                    {
                        "username": "AniEthanHunt",
                        "content": "Player 1 can take 2 or 8.\\nP1 takes 2, then P2 will take 8 and P1 will lose as P2 will get 55 [4, 55, 6]\\nP1 takes 8, then P2 will take 2 and P1 will lose as P2 will get 55 [4, 55, 6]\\n\\nHere, both the player are playing optimally (game theory: min-max algorithm)."
                    },
                    {
                        "username": "Kharelg24",
                        "content": "Test_case2 = [1, 5, 233, 7]\\nI don\\'t understand why for this testcase, Player 1 would choose 1. Obviously 7 is bigger than 1 so shouldn\\'t player 1 choose 7 causing Player 2 to win at the end?"
                    },
                    {
                        "username": "Kharelg24",
                        "content": "[@rakeshSharma19](/rakeshSharma19) Thank you for your response rakesh, however my approach to this problem was to use the mini max algorithm which would take an optimal action in each step. Do you have any other recommendation for these problems?"
                    },
                    {
                        "username": "rakeshSharma19",
                        "content": "You need to understand, Here Both the players playing optimally for overall game not optimal at each step.\\nso If I\\'m player1, I have whole I look through the array and choose 1, because after this whatever player 2 will I have option to choose either 233 or the rest, so here each playing optimally for overall array not for the current step.\\nI hope I have cleared your doubt."
                    }
                ]
            },
            {
                "id": 1989457,
                "content": [
                    {
                        "username": "wf94",
                        "content": "Hi, I am now stucked at the last testcase and can't figure out why \\n[0,0,7,6,5,6,1] should return False.\\n\\nHere's the reason I think it should return True.\\nPlayer 1 chooses 1 [0,0,7,6,5,6]  Player1: 1, Player2: 0\\nPlayer 2 chooses 6 [0,0,7,6,5] Player1: 1, Player2: 6\\nPlayer 1 chooses 5 [0,0.7,6] Player1: 6, Player2: 6\\nPlayer 2 chooses 6 [0,0,7] Player1: 6, Player2: 12\\nPlayer 1 chooses 7 [0,0] Player1: 13, Player2: 12\\n\\nThe Player 1 will eventually win. So it should return True."
                    },
                    {
                        "username": "rakeshSharma19",
                        "content": "If I\\'m your competitor(player 2), Then the steps are\\nPlayer1 chooses 1, array now - [0, 0, 7, 6, 5, 6] Player1: 1, Player2: 0\\nPlayer2 chooses 6, array now - [0, 0, 7, 6, 5] Player1: 1, Player2: 6\\nPlayer1 chooses 5, array now - [0, 0, 7, 6] Player1: 6, Player2: 6\\nPlayer2 chooses 0, array now - [0, 7, 6] Player1: 6, Player2: 6\\nPlayer1 chooses either 0 or 6, array now - [0, 7] Player1: 12, Player2: 6 if chooses 6 \\nPlayer2 chooses 7, array now - [0,] Player1: 12, Player2: 13\\nPlayer2 Will win\\nHere Both the players playing optimally for overall game not optimal at each step.\\nUse DP here to get the solution."
                    },
                    {
                        "username": "enzo_cheng",
                        "content": "If i'm your competitor (Player 2), after this step:\n    >>> Player 1 chooses 5 [0,0.7,6] Player1: 6, Player2: 6\nPlayer 2 will select 0,\n    >>> Player 2 chooses 0 [0,7,6] Player1: 6, Player2: 6\n    >>> Player 1 chooses 6 [0,7] Player1: 12, Player2: 6\n    >>> Player 2 chooses 7 [0] Player1: 12, Player2: 13\n\nResult is that Player 2 wins always\n"
                    },
                    {
                        "username": "JS00",
                        "content": "Real ones know the names of Player 1 and Player 2!!"
                    },
                    {
                        "username": "coder_pawn",
                        "content": "a test case:\\n[1,5,2,4,6]"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "You can assume player1 and player2 as Alice and bob.lol"
                    },
                    {
                        "username": "w-s",
                        "content": "Brute force passes, but better talk about DP if this comes up in interviews."
                    },
                    {
                        "username": "qqqxz",
                        "content": "How is it false?\\nA can pick 8, 55, 2\\nB picks 6,4"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "All players are playing  \"optimally\" to increase their own \"individual score\""
                    },
                    {
                        "username": "genericalAccount",
                        "content": "If player 1 starts taking the last element of the array, no matter which choice makes the player 2, he\\'ll have a advantage of 1, ending the game as 12 vs 13. What\\'s wrong with this logic?"
                    },
                    {
                        "username": "rakeshSharma19",
                        "content": "Think about this case [0, 0, 7, 6, 5, 6, 1] here Player2 will win, even though Player1 has advantage\\n\\nIf I\\'m your competitor(player 2), Then the steps are\\n\\nPlayer1 chooses 1, array now - [0, 0, 7, 6, 5, 6] Player1: 1, Player2: 0\\nPlayer2 chooses 6, array now - [0, 0, 7, 6, 5] Player1: 1, Player2: 6\\nPlayer1 chooses 5, array now - [0, 0, 7, 6] Player1: 6, Player2: 6\\nPlayer2 chooses 0, array now - [0, 7, 6] Player1: 6, Player2: 6\\nPlayer1 chooses either 0 or 6, array now - [0, 7] Player1: 12, Player2: 6 if chooses 6 \\nPlayer2 chooses 7, array now - [0,] Player1: 12, Player2: 13\\nPlayer2 Will win\\nHere Both the players playing optimally for overall game not optimal at each step.\\nUse DP here to get the solution."
                    },
                    {
                        "username": "vanni1212",
                        "content": "This problem has a test case\\n{2,4,55,6,8} of which the output is expected to be false. How is that so ? Because I understand that player 1 may choose 8,55,2 and thereby become the winner. Am I understanding the question wrong ?"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "[@math_pi](/math_pi) thanks bro I was looking for that."
                    },
                    {
                        "username": "math_pi",
                        "content": "The test case is correct, Here's How the Game Goes:\nLet's say P1(8) -> [2, 4, 55, 6]\nP2(2) -> [4, 55, 6]\nP1(6) -> [4, 55]\nP2(55) -> [4]\nP1(4) ->[]\nObviously P1 Takes an L.\nNow you could do the same thing if P1 chooses 2.\nThe main thing is P2 will choose a lesser element intentionally in order to not allow [55] to be at the end points of the array on P1 turn."
                    },
                    {
                        "username": "ashish2712",
                        "content": "No, the test case is correct.\\nif p1 choose 8, then p2 choose 2 and then 55.\\nif p1 choose 2, then p2 choose 8 and then 55. "
                    },
                    {
                        "username": "foodlover",
                        "content": "player 1 selects 8\\nPlayer 2 then selects 6\\nplayer 1 then selects 55\\nplaher 2 selects 4\\nplayer 1 selects 2\\n\\nDoesn\\'t player 1 win in this case ? The answer for this test case is false, but I feel that\\'s wrong [or have misunderstood the question]"
                    },
                    {
                        "username": "AniEthanHunt",
                        "content": "Player 1 can take 2 or 8.\\nP1 takes 2, then P2 will take 8 and P1 will lose as P2 will get 55 [4, 55, 6]\\nP1 takes 8, then P2 will take 2 and P1 will lose as P2 will get 55 [4, 55, 6]\\n\\nHere, both the player are playing optimally (game theory: min-max algorithm)."
                    },
                    {
                        "username": "Kharelg24",
                        "content": "Test_case2 = [1, 5, 233, 7]\\nI don\\'t understand why for this testcase, Player 1 would choose 1. Obviously 7 is bigger than 1 so shouldn\\'t player 1 choose 7 causing Player 2 to win at the end?"
                    },
                    {
                        "username": "Kharelg24",
                        "content": "[@rakeshSharma19](/rakeshSharma19) Thank you for your response rakesh, however my approach to this problem was to use the mini max algorithm which would take an optimal action in each step. Do you have any other recommendation for these problems?"
                    },
                    {
                        "username": "rakeshSharma19",
                        "content": "You need to understand, Here Both the players playing optimally for overall game not optimal at each step.\\nso If I\\'m player1, I have whole I look through the array and choose 1, because after this whatever player 2 will I have option to choose either 233 or the rest, so here each playing optimally for overall array not for the current step.\\nI hope I have cleared your doubt."
                    }
                ]
            },
            {
                "id": 1576797,
                "content": [
                    {
                        "username": "wf94",
                        "content": "Hi, I am now stucked at the last testcase and can't figure out why \\n[0,0,7,6,5,6,1] should return False.\\n\\nHere's the reason I think it should return True.\\nPlayer 1 chooses 1 [0,0,7,6,5,6]  Player1: 1, Player2: 0\\nPlayer 2 chooses 6 [0,0,7,6,5] Player1: 1, Player2: 6\\nPlayer 1 chooses 5 [0,0.7,6] Player1: 6, Player2: 6\\nPlayer 2 chooses 6 [0,0,7] Player1: 6, Player2: 12\\nPlayer 1 chooses 7 [0,0] Player1: 13, Player2: 12\\n\\nThe Player 1 will eventually win. So it should return True."
                    },
                    {
                        "username": "rakeshSharma19",
                        "content": "If I\\'m your competitor(player 2), Then the steps are\\nPlayer1 chooses 1, array now - [0, 0, 7, 6, 5, 6] Player1: 1, Player2: 0\\nPlayer2 chooses 6, array now - [0, 0, 7, 6, 5] Player1: 1, Player2: 6\\nPlayer1 chooses 5, array now - [0, 0, 7, 6] Player1: 6, Player2: 6\\nPlayer2 chooses 0, array now - [0, 7, 6] Player1: 6, Player2: 6\\nPlayer1 chooses either 0 or 6, array now - [0, 7] Player1: 12, Player2: 6 if chooses 6 \\nPlayer2 chooses 7, array now - [0,] Player1: 12, Player2: 13\\nPlayer2 Will win\\nHere Both the players playing optimally for overall game not optimal at each step.\\nUse DP here to get the solution."
                    },
                    {
                        "username": "enzo_cheng",
                        "content": "If i'm your competitor (Player 2), after this step:\n    >>> Player 1 chooses 5 [0,0.7,6] Player1: 6, Player2: 6\nPlayer 2 will select 0,\n    >>> Player 2 chooses 0 [0,7,6] Player1: 6, Player2: 6\n    >>> Player 1 chooses 6 [0,7] Player1: 12, Player2: 6\n    >>> Player 2 chooses 7 [0] Player1: 12, Player2: 13\n\nResult is that Player 2 wins always\n"
                    },
                    {
                        "username": "JS00",
                        "content": "Real ones know the names of Player 1 and Player 2!!"
                    },
                    {
                        "username": "coder_pawn",
                        "content": "a test case:\\n[1,5,2,4,6]"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "You can assume player1 and player2 as Alice and bob.lol"
                    },
                    {
                        "username": "w-s",
                        "content": "Brute force passes, but better talk about DP if this comes up in interviews."
                    },
                    {
                        "username": "qqqxz",
                        "content": "How is it false?\\nA can pick 8, 55, 2\\nB picks 6,4"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "All players are playing  \"optimally\" to increase their own \"individual score\""
                    },
                    {
                        "username": "genericalAccount",
                        "content": "If player 1 starts taking the last element of the array, no matter which choice makes the player 2, he\\'ll have a advantage of 1, ending the game as 12 vs 13. What\\'s wrong with this logic?"
                    },
                    {
                        "username": "rakeshSharma19",
                        "content": "Think about this case [0, 0, 7, 6, 5, 6, 1] here Player2 will win, even though Player1 has advantage\\n\\nIf I\\'m your competitor(player 2), Then the steps are\\n\\nPlayer1 chooses 1, array now - [0, 0, 7, 6, 5, 6] Player1: 1, Player2: 0\\nPlayer2 chooses 6, array now - [0, 0, 7, 6, 5] Player1: 1, Player2: 6\\nPlayer1 chooses 5, array now - [0, 0, 7, 6] Player1: 6, Player2: 6\\nPlayer2 chooses 0, array now - [0, 7, 6] Player1: 6, Player2: 6\\nPlayer1 chooses either 0 or 6, array now - [0, 7] Player1: 12, Player2: 6 if chooses 6 \\nPlayer2 chooses 7, array now - [0,] Player1: 12, Player2: 13\\nPlayer2 Will win\\nHere Both the players playing optimally for overall game not optimal at each step.\\nUse DP here to get the solution."
                    },
                    {
                        "username": "vanni1212",
                        "content": "This problem has a test case\\n{2,4,55,6,8} of which the output is expected to be false. How is that so ? Because I understand that player 1 may choose 8,55,2 and thereby become the winner. Am I understanding the question wrong ?"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "[@math_pi](/math_pi) thanks bro I was looking for that."
                    },
                    {
                        "username": "math_pi",
                        "content": "The test case is correct, Here's How the Game Goes:\nLet's say P1(8) -> [2, 4, 55, 6]\nP2(2) -> [4, 55, 6]\nP1(6) -> [4, 55]\nP2(55) -> [4]\nP1(4) ->[]\nObviously P1 Takes an L.\nNow you could do the same thing if P1 chooses 2.\nThe main thing is P2 will choose a lesser element intentionally in order to not allow [55] to be at the end points of the array on P1 turn."
                    },
                    {
                        "username": "ashish2712",
                        "content": "No, the test case is correct.\\nif p1 choose 8, then p2 choose 2 and then 55.\\nif p1 choose 2, then p2 choose 8 and then 55. "
                    },
                    {
                        "username": "foodlover",
                        "content": "player 1 selects 8\\nPlayer 2 then selects 6\\nplayer 1 then selects 55\\nplaher 2 selects 4\\nplayer 1 selects 2\\n\\nDoesn\\'t player 1 win in this case ? The answer for this test case is false, but I feel that\\'s wrong [or have misunderstood the question]"
                    },
                    {
                        "username": "AniEthanHunt",
                        "content": "Player 1 can take 2 or 8.\\nP1 takes 2, then P2 will take 8 and P1 will lose as P2 will get 55 [4, 55, 6]\\nP1 takes 8, then P2 will take 2 and P1 will lose as P2 will get 55 [4, 55, 6]\\n\\nHere, both the player are playing optimally (game theory: min-max algorithm)."
                    },
                    {
                        "username": "Kharelg24",
                        "content": "Test_case2 = [1, 5, 233, 7]\\nI don\\'t understand why for this testcase, Player 1 would choose 1. Obviously 7 is bigger than 1 so shouldn\\'t player 1 choose 7 causing Player 2 to win at the end?"
                    },
                    {
                        "username": "Kharelg24",
                        "content": "[@rakeshSharma19](/rakeshSharma19) Thank you for your response rakesh, however my approach to this problem was to use the mini max algorithm which would take an optimal action in each step. Do you have any other recommendation for these problems?"
                    },
                    {
                        "username": "rakeshSharma19",
                        "content": "You need to understand, Here Both the players playing optimally for overall game not optimal at each step.\\nso If I\\'m player1, I have whole I look through the array and choose 1, because after this whatever player 2 will I have option to choose either 233 or the rest, so here each playing optimally for overall array not for the current step.\\nI hope I have cleared your doubt."
                    }
                ]
            },
            {
                "id": 1576333,
                "content": [
                    {
                        "username": "wf94",
                        "content": "Hi, I am now stucked at the last testcase and can't figure out why \\n[0,0,7,6,5,6,1] should return False.\\n\\nHere's the reason I think it should return True.\\nPlayer 1 chooses 1 [0,0,7,6,5,6]  Player1: 1, Player2: 0\\nPlayer 2 chooses 6 [0,0,7,6,5] Player1: 1, Player2: 6\\nPlayer 1 chooses 5 [0,0.7,6] Player1: 6, Player2: 6\\nPlayer 2 chooses 6 [0,0,7] Player1: 6, Player2: 12\\nPlayer 1 chooses 7 [0,0] Player1: 13, Player2: 12\\n\\nThe Player 1 will eventually win. So it should return True."
                    },
                    {
                        "username": "rakeshSharma19",
                        "content": "If I\\'m your competitor(player 2), Then the steps are\\nPlayer1 chooses 1, array now - [0, 0, 7, 6, 5, 6] Player1: 1, Player2: 0\\nPlayer2 chooses 6, array now - [0, 0, 7, 6, 5] Player1: 1, Player2: 6\\nPlayer1 chooses 5, array now - [0, 0, 7, 6] Player1: 6, Player2: 6\\nPlayer2 chooses 0, array now - [0, 7, 6] Player1: 6, Player2: 6\\nPlayer1 chooses either 0 or 6, array now - [0, 7] Player1: 12, Player2: 6 if chooses 6 \\nPlayer2 chooses 7, array now - [0,] Player1: 12, Player2: 13\\nPlayer2 Will win\\nHere Both the players playing optimally for overall game not optimal at each step.\\nUse DP here to get the solution."
                    },
                    {
                        "username": "enzo_cheng",
                        "content": "If i'm your competitor (Player 2), after this step:\n    >>> Player 1 chooses 5 [0,0.7,6] Player1: 6, Player2: 6\nPlayer 2 will select 0,\n    >>> Player 2 chooses 0 [0,7,6] Player1: 6, Player2: 6\n    >>> Player 1 chooses 6 [0,7] Player1: 12, Player2: 6\n    >>> Player 2 chooses 7 [0] Player1: 12, Player2: 13\n\nResult is that Player 2 wins always\n"
                    },
                    {
                        "username": "JS00",
                        "content": "Real ones know the names of Player 1 and Player 2!!"
                    },
                    {
                        "username": "coder_pawn",
                        "content": "a test case:\\n[1,5,2,4,6]"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "You can assume player1 and player2 as Alice and bob.lol"
                    },
                    {
                        "username": "w-s",
                        "content": "Brute force passes, but better talk about DP if this comes up in interviews."
                    },
                    {
                        "username": "qqqxz",
                        "content": "How is it false?\\nA can pick 8, 55, 2\\nB picks 6,4"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "All players are playing  \"optimally\" to increase their own \"individual score\""
                    },
                    {
                        "username": "genericalAccount",
                        "content": "If player 1 starts taking the last element of the array, no matter which choice makes the player 2, he\\'ll have a advantage of 1, ending the game as 12 vs 13. What\\'s wrong with this logic?"
                    },
                    {
                        "username": "rakeshSharma19",
                        "content": "Think about this case [0, 0, 7, 6, 5, 6, 1] here Player2 will win, even though Player1 has advantage\\n\\nIf I\\'m your competitor(player 2), Then the steps are\\n\\nPlayer1 chooses 1, array now - [0, 0, 7, 6, 5, 6] Player1: 1, Player2: 0\\nPlayer2 chooses 6, array now - [0, 0, 7, 6, 5] Player1: 1, Player2: 6\\nPlayer1 chooses 5, array now - [0, 0, 7, 6] Player1: 6, Player2: 6\\nPlayer2 chooses 0, array now - [0, 7, 6] Player1: 6, Player2: 6\\nPlayer1 chooses either 0 or 6, array now - [0, 7] Player1: 12, Player2: 6 if chooses 6 \\nPlayer2 chooses 7, array now - [0,] Player1: 12, Player2: 13\\nPlayer2 Will win\\nHere Both the players playing optimally for overall game not optimal at each step.\\nUse DP here to get the solution."
                    },
                    {
                        "username": "vanni1212",
                        "content": "This problem has a test case\\n{2,4,55,6,8} of which the output is expected to be false. How is that so ? Because I understand that player 1 may choose 8,55,2 and thereby become the winner. Am I understanding the question wrong ?"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "[@math_pi](/math_pi) thanks bro I was looking for that."
                    },
                    {
                        "username": "math_pi",
                        "content": "The test case is correct, Here's How the Game Goes:\nLet's say P1(8) -> [2, 4, 55, 6]\nP2(2) -> [4, 55, 6]\nP1(6) -> [4, 55]\nP2(55) -> [4]\nP1(4) ->[]\nObviously P1 Takes an L.\nNow you could do the same thing if P1 chooses 2.\nThe main thing is P2 will choose a lesser element intentionally in order to not allow [55] to be at the end points of the array on P1 turn."
                    },
                    {
                        "username": "ashish2712",
                        "content": "No, the test case is correct.\\nif p1 choose 8, then p2 choose 2 and then 55.\\nif p1 choose 2, then p2 choose 8 and then 55. "
                    },
                    {
                        "username": "foodlover",
                        "content": "player 1 selects 8\\nPlayer 2 then selects 6\\nplayer 1 then selects 55\\nplaher 2 selects 4\\nplayer 1 selects 2\\n\\nDoesn\\'t player 1 win in this case ? The answer for this test case is false, but I feel that\\'s wrong [or have misunderstood the question]"
                    },
                    {
                        "username": "AniEthanHunt",
                        "content": "Player 1 can take 2 or 8.\\nP1 takes 2, then P2 will take 8 and P1 will lose as P2 will get 55 [4, 55, 6]\\nP1 takes 8, then P2 will take 2 and P1 will lose as P2 will get 55 [4, 55, 6]\\n\\nHere, both the player are playing optimally (game theory: min-max algorithm)."
                    },
                    {
                        "username": "Kharelg24",
                        "content": "Test_case2 = [1, 5, 233, 7]\\nI don\\'t understand why for this testcase, Player 1 would choose 1. Obviously 7 is bigger than 1 so shouldn\\'t player 1 choose 7 causing Player 2 to win at the end?"
                    },
                    {
                        "username": "Kharelg24",
                        "content": "[@rakeshSharma19](/rakeshSharma19) Thank you for your response rakesh, however my approach to this problem was to use the mini max algorithm which would take an optimal action in each step. Do you have any other recommendation for these problems?"
                    },
                    {
                        "username": "rakeshSharma19",
                        "content": "You need to understand, Here Both the players playing optimally for overall game not optimal at each step.\\nso If I\\'m player1, I have whole I look through the array and choose 1, because after this whatever player 2 will I have option to choose either 233 or the rest, so here each playing optimally for overall array not for the current step.\\nI hope I have cleared your doubt."
                    }
                ]
            },
            {
                "id": 1571884,
                "content": [
                    {
                        "username": "wf94",
                        "content": "Hi, I am now stucked at the last testcase and can't figure out why \\n[0,0,7,6,5,6,1] should return False.\\n\\nHere's the reason I think it should return True.\\nPlayer 1 chooses 1 [0,0,7,6,5,6]  Player1: 1, Player2: 0\\nPlayer 2 chooses 6 [0,0,7,6,5] Player1: 1, Player2: 6\\nPlayer 1 chooses 5 [0,0.7,6] Player1: 6, Player2: 6\\nPlayer 2 chooses 6 [0,0,7] Player1: 6, Player2: 12\\nPlayer 1 chooses 7 [0,0] Player1: 13, Player2: 12\\n\\nThe Player 1 will eventually win. So it should return True."
                    },
                    {
                        "username": "rakeshSharma19",
                        "content": "If I\\'m your competitor(player 2), Then the steps are\\nPlayer1 chooses 1, array now - [0, 0, 7, 6, 5, 6] Player1: 1, Player2: 0\\nPlayer2 chooses 6, array now - [0, 0, 7, 6, 5] Player1: 1, Player2: 6\\nPlayer1 chooses 5, array now - [0, 0, 7, 6] Player1: 6, Player2: 6\\nPlayer2 chooses 0, array now - [0, 7, 6] Player1: 6, Player2: 6\\nPlayer1 chooses either 0 or 6, array now - [0, 7] Player1: 12, Player2: 6 if chooses 6 \\nPlayer2 chooses 7, array now - [0,] Player1: 12, Player2: 13\\nPlayer2 Will win\\nHere Both the players playing optimally for overall game not optimal at each step.\\nUse DP here to get the solution."
                    },
                    {
                        "username": "enzo_cheng",
                        "content": "If i'm your competitor (Player 2), after this step:\n    >>> Player 1 chooses 5 [0,0.7,6] Player1: 6, Player2: 6\nPlayer 2 will select 0,\n    >>> Player 2 chooses 0 [0,7,6] Player1: 6, Player2: 6\n    >>> Player 1 chooses 6 [0,7] Player1: 12, Player2: 6\n    >>> Player 2 chooses 7 [0] Player1: 12, Player2: 13\n\nResult is that Player 2 wins always\n"
                    },
                    {
                        "username": "JS00",
                        "content": "Real ones know the names of Player 1 and Player 2!!"
                    },
                    {
                        "username": "coder_pawn",
                        "content": "a test case:\\n[1,5,2,4,6]"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "You can assume player1 and player2 as Alice and bob.lol"
                    },
                    {
                        "username": "w-s",
                        "content": "Brute force passes, but better talk about DP if this comes up in interviews."
                    },
                    {
                        "username": "qqqxz",
                        "content": "How is it false?\\nA can pick 8, 55, 2\\nB picks 6,4"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "All players are playing  \"optimally\" to increase their own \"individual score\""
                    },
                    {
                        "username": "genericalAccount",
                        "content": "If player 1 starts taking the last element of the array, no matter which choice makes the player 2, he\\'ll have a advantage of 1, ending the game as 12 vs 13. What\\'s wrong with this logic?"
                    },
                    {
                        "username": "rakeshSharma19",
                        "content": "Think about this case [0, 0, 7, 6, 5, 6, 1] here Player2 will win, even though Player1 has advantage\\n\\nIf I\\'m your competitor(player 2), Then the steps are\\n\\nPlayer1 chooses 1, array now - [0, 0, 7, 6, 5, 6] Player1: 1, Player2: 0\\nPlayer2 chooses 6, array now - [0, 0, 7, 6, 5] Player1: 1, Player2: 6\\nPlayer1 chooses 5, array now - [0, 0, 7, 6] Player1: 6, Player2: 6\\nPlayer2 chooses 0, array now - [0, 7, 6] Player1: 6, Player2: 6\\nPlayer1 chooses either 0 or 6, array now - [0, 7] Player1: 12, Player2: 6 if chooses 6 \\nPlayer2 chooses 7, array now - [0,] Player1: 12, Player2: 13\\nPlayer2 Will win\\nHere Both the players playing optimally for overall game not optimal at each step.\\nUse DP here to get the solution."
                    },
                    {
                        "username": "vanni1212",
                        "content": "This problem has a test case\\n{2,4,55,6,8} of which the output is expected to be false. How is that so ? Because I understand that player 1 may choose 8,55,2 and thereby become the winner. Am I understanding the question wrong ?"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "[@math_pi](/math_pi) thanks bro I was looking for that."
                    },
                    {
                        "username": "math_pi",
                        "content": "The test case is correct, Here's How the Game Goes:\nLet's say P1(8) -> [2, 4, 55, 6]\nP2(2) -> [4, 55, 6]\nP1(6) -> [4, 55]\nP2(55) -> [4]\nP1(4) ->[]\nObviously P1 Takes an L.\nNow you could do the same thing if P1 chooses 2.\nThe main thing is P2 will choose a lesser element intentionally in order to not allow [55] to be at the end points of the array on P1 turn."
                    },
                    {
                        "username": "ashish2712",
                        "content": "No, the test case is correct.\\nif p1 choose 8, then p2 choose 2 and then 55.\\nif p1 choose 2, then p2 choose 8 and then 55. "
                    },
                    {
                        "username": "foodlover",
                        "content": "player 1 selects 8\\nPlayer 2 then selects 6\\nplayer 1 then selects 55\\nplaher 2 selects 4\\nplayer 1 selects 2\\n\\nDoesn\\'t player 1 win in this case ? The answer for this test case is false, but I feel that\\'s wrong [or have misunderstood the question]"
                    },
                    {
                        "username": "AniEthanHunt",
                        "content": "Player 1 can take 2 or 8.\\nP1 takes 2, then P2 will take 8 and P1 will lose as P2 will get 55 [4, 55, 6]\\nP1 takes 8, then P2 will take 2 and P1 will lose as P2 will get 55 [4, 55, 6]\\n\\nHere, both the player are playing optimally (game theory: min-max algorithm)."
                    },
                    {
                        "username": "Kharelg24",
                        "content": "Test_case2 = [1, 5, 233, 7]\\nI don\\'t understand why for this testcase, Player 1 would choose 1. Obviously 7 is bigger than 1 so shouldn\\'t player 1 choose 7 causing Player 2 to win at the end?"
                    },
                    {
                        "username": "Kharelg24",
                        "content": "[@rakeshSharma19](/rakeshSharma19) Thank you for your response rakesh, however my approach to this problem was to use the mini max algorithm which would take an optimal action in each step. Do you have any other recommendation for these problems?"
                    },
                    {
                        "username": "rakeshSharma19",
                        "content": "You need to understand, Here Both the players playing optimally for overall game not optimal at each step.\\nso If I\\'m player1, I have whole I look through the array and choose 1, because after this whatever player 2 will I have option to choose either 233 or the rest, so here each playing optimally for overall array not for the current step.\\nI hope I have cleared your doubt."
                    }
                ]
            },
            {
                "id": 1567371,
                "content": [
                    {
                        "username": "wf94",
                        "content": "Hi, I am now stucked at the last testcase and can't figure out why \\n[0,0,7,6,5,6,1] should return False.\\n\\nHere's the reason I think it should return True.\\nPlayer 1 chooses 1 [0,0,7,6,5,6]  Player1: 1, Player2: 0\\nPlayer 2 chooses 6 [0,0,7,6,5] Player1: 1, Player2: 6\\nPlayer 1 chooses 5 [0,0.7,6] Player1: 6, Player2: 6\\nPlayer 2 chooses 6 [0,0,7] Player1: 6, Player2: 12\\nPlayer 1 chooses 7 [0,0] Player1: 13, Player2: 12\\n\\nThe Player 1 will eventually win. So it should return True."
                    },
                    {
                        "username": "rakeshSharma19",
                        "content": "If I\\'m your competitor(player 2), Then the steps are\\nPlayer1 chooses 1, array now - [0, 0, 7, 6, 5, 6] Player1: 1, Player2: 0\\nPlayer2 chooses 6, array now - [0, 0, 7, 6, 5] Player1: 1, Player2: 6\\nPlayer1 chooses 5, array now - [0, 0, 7, 6] Player1: 6, Player2: 6\\nPlayer2 chooses 0, array now - [0, 7, 6] Player1: 6, Player2: 6\\nPlayer1 chooses either 0 or 6, array now - [0, 7] Player1: 12, Player2: 6 if chooses 6 \\nPlayer2 chooses 7, array now - [0,] Player1: 12, Player2: 13\\nPlayer2 Will win\\nHere Both the players playing optimally for overall game not optimal at each step.\\nUse DP here to get the solution."
                    },
                    {
                        "username": "enzo_cheng",
                        "content": "If i'm your competitor (Player 2), after this step:\n    >>> Player 1 chooses 5 [0,0.7,6] Player1: 6, Player2: 6\nPlayer 2 will select 0,\n    >>> Player 2 chooses 0 [0,7,6] Player1: 6, Player2: 6\n    >>> Player 1 chooses 6 [0,7] Player1: 12, Player2: 6\n    >>> Player 2 chooses 7 [0] Player1: 12, Player2: 13\n\nResult is that Player 2 wins always\n"
                    },
                    {
                        "username": "JS00",
                        "content": "Real ones know the names of Player 1 and Player 2!!"
                    },
                    {
                        "username": "coder_pawn",
                        "content": "a test case:\\n[1,5,2,4,6]"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "You can assume player1 and player2 as Alice and bob.lol"
                    },
                    {
                        "username": "w-s",
                        "content": "Brute force passes, but better talk about DP if this comes up in interviews."
                    },
                    {
                        "username": "qqqxz",
                        "content": "How is it false?\\nA can pick 8, 55, 2\\nB picks 6,4"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "All players are playing  \"optimally\" to increase their own \"individual score\""
                    },
                    {
                        "username": "genericalAccount",
                        "content": "If player 1 starts taking the last element of the array, no matter which choice makes the player 2, he\\'ll have a advantage of 1, ending the game as 12 vs 13. What\\'s wrong with this logic?"
                    },
                    {
                        "username": "rakeshSharma19",
                        "content": "Think about this case [0, 0, 7, 6, 5, 6, 1] here Player2 will win, even though Player1 has advantage\\n\\nIf I\\'m your competitor(player 2), Then the steps are\\n\\nPlayer1 chooses 1, array now - [0, 0, 7, 6, 5, 6] Player1: 1, Player2: 0\\nPlayer2 chooses 6, array now - [0, 0, 7, 6, 5] Player1: 1, Player2: 6\\nPlayer1 chooses 5, array now - [0, 0, 7, 6] Player1: 6, Player2: 6\\nPlayer2 chooses 0, array now - [0, 7, 6] Player1: 6, Player2: 6\\nPlayer1 chooses either 0 or 6, array now - [0, 7] Player1: 12, Player2: 6 if chooses 6 \\nPlayer2 chooses 7, array now - [0,] Player1: 12, Player2: 13\\nPlayer2 Will win\\nHere Both the players playing optimally for overall game not optimal at each step.\\nUse DP here to get the solution."
                    },
                    {
                        "username": "vanni1212",
                        "content": "This problem has a test case\\n{2,4,55,6,8} of which the output is expected to be false. How is that so ? Because I understand that player 1 may choose 8,55,2 and thereby become the winner. Am I understanding the question wrong ?"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "[@math_pi](/math_pi) thanks bro I was looking for that."
                    },
                    {
                        "username": "math_pi",
                        "content": "The test case is correct, Here's How the Game Goes:\nLet's say P1(8) -> [2, 4, 55, 6]\nP2(2) -> [4, 55, 6]\nP1(6) -> [4, 55]\nP2(55) -> [4]\nP1(4) ->[]\nObviously P1 Takes an L.\nNow you could do the same thing if P1 chooses 2.\nThe main thing is P2 will choose a lesser element intentionally in order to not allow [55] to be at the end points of the array on P1 turn."
                    },
                    {
                        "username": "ashish2712",
                        "content": "No, the test case is correct.\\nif p1 choose 8, then p2 choose 2 and then 55.\\nif p1 choose 2, then p2 choose 8 and then 55. "
                    },
                    {
                        "username": "foodlover",
                        "content": "player 1 selects 8\\nPlayer 2 then selects 6\\nplayer 1 then selects 55\\nplaher 2 selects 4\\nplayer 1 selects 2\\n\\nDoesn\\'t player 1 win in this case ? The answer for this test case is false, but I feel that\\'s wrong [or have misunderstood the question]"
                    },
                    {
                        "username": "AniEthanHunt",
                        "content": "Player 1 can take 2 or 8.\\nP1 takes 2, then P2 will take 8 and P1 will lose as P2 will get 55 [4, 55, 6]\\nP1 takes 8, then P2 will take 2 and P1 will lose as P2 will get 55 [4, 55, 6]\\n\\nHere, both the player are playing optimally (game theory: min-max algorithm)."
                    },
                    {
                        "username": "Kharelg24",
                        "content": "Test_case2 = [1, 5, 233, 7]\\nI don\\'t understand why for this testcase, Player 1 would choose 1. Obviously 7 is bigger than 1 so shouldn\\'t player 1 choose 7 causing Player 2 to win at the end?"
                    },
                    {
                        "username": "Kharelg24",
                        "content": "[@rakeshSharma19](/rakeshSharma19) Thank you for your response rakesh, however my approach to this problem was to use the mini max algorithm which would take an optimal action in each step. Do you have any other recommendation for these problems?"
                    },
                    {
                        "username": "rakeshSharma19",
                        "content": "You need to understand, Here Both the players playing optimally for overall game not optimal at each step.\\nso If I\\'m player1, I have whole I look through the array and choose 1, because after this whatever player 2 will I have option to choose either 233 or the rest, so here each playing optimally for overall array not for the current step.\\nI hope I have cleared your doubt."
                    }
                ]
            },
            {
                "id": 2000107,
                "content": [
                    {
                        "username": "wf94",
                        "content": "Hi, I am now stucked at the last testcase and can't figure out why \\n[0,0,7,6,5,6,1] should return False.\\n\\nHere's the reason I think it should return True.\\nPlayer 1 chooses 1 [0,0,7,6,5,6]  Player1: 1, Player2: 0\\nPlayer 2 chooses 6 [0,0,7,6,5] Player1: 1, Player2: 6\\nPlayer 1 chooses 5 [0,0.7,6] Player1: 6, Player2: 6\\nPlayer 2 chooses 6 [0,0,7] Player1: 6, Player2: 12\\nPlayer 1 chooses 7 [0,0] Player1: 13, Player2: 12\\n\\nThe Player 1 will eventually win. So it should return True."
                    },
                    {
                        "username": "rakeshSharma19",
                        "content": "If I\\'m your competitor(player 2), Then the steps are\\nPlayer1 chooses 1, array now - [0, 0, 7, 6, 5, 6] Player1: 1, Player2: 0\\nPlayer2 chooses 6, array now - [0, 0, 7, 6, 5] Player1: 1, Player2: 6\\nPlayer1 chooses 5, array now - [0, 0, 7, 6] Player1: 6, Player2: 6\\nPlayer2 chooses 0, array now - [0, 7, 6] Player1: 6, Player2: 6\\nPlayer1 chooses either 0 or 6, array now - [0, 7] Player1: 12, Player2: 6 if chooses 6 \\nPlayer2 chooses 7, array now - [0,] Player1: 12, Player2: 13\\nPlayer2 Will win\\nHere Both the players playing optimally for overall game not optimal at each step.\\nUse DP here to get the solution."
                    },
                    {
                        "username": "enzo_cheng",
                        "content": "If i'm your competitor (Player 2), after this step:\n    >>> Player 1 chooses 5 [0,0.7,6] Player1: 6, Player2: 6\nPlayer 2 will select 0,\n    >>> Player 2 chooses 0 [0,7,6] Player1: 6, Player2: 6\n    >>> Player 1 chooses 6 [0,7] Player1: 12, Player2: 6\n    >>> Player 2 chooses 7 [0] Player1: 12, Player2: 13\n\nResult is that Player 2 wins always\n"
                    },
                    {
                        "username": "JS00",
                        "content": "Real ones know the names of Player 1 and Player 2!!"
                    },
                    {
                        "username": "coder_pawn",
                        "content": "a test case:\\n[1,5,2,4,6]"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "You can assume player1 and player2 as Alice and bob.lol"
                    },
                    {
                        "username": "w-s",
                        "content": "Brute force passes, but better talk about DP if this comes up in interviews."
                    },
                    {
                        "username": "qqqxz",
                        "content": "How is it false?\\nA can pick 8, 55, 2\\nB picks 6,4"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "All players are playing  \"optimally\" to increase their own \"individual score\""
                    },
                    {
                        "username": "genericalAccount",
                        "content": "If player 1 starts taking the last element of the array, no matter which choice makes the player 2, he\\'ll have a advantage of 1, ending the game as 12 vs 13. What\\'s wrong with this logic?"
                    },
                    {
                        "username": "rakeshSharma19",
                        "content": "Think about this case [0, 0, 7, 6, 5, 6, 1] here Player2 will win, even though Player1 has advantage\\n\\nIf I\\'m your competitor(player 2), Then the steps are\\n\\nPlayer1 chooses 1, array now - [0, 0, 7, 6, 5, 6] Player1: 1, Player2: 0\\nPlayer2 chooses 6, array now - [0, 0, 7, 6, 5] Player1: 1, Player2: 6\\nPlayer1 chooses 5, array now - [0, 0, 7, 6] Player1: 6, Player2: 6\\nPlayer2 chooses 0, array now - [0, 7, 6] Player1: 6, Player2: 6\\nPlayer1 chooses either 0 or 6, array now - [0, 7] Player1: 12, Player2: 6 if chooses 6 \\nPlayer2 chooses 7, array now - [0,] Player1: 12, Player2: 13\\nPlayer2 Will win\\nHere Both the players playing optimally for overall game not optimal at each step.\\nUse DP here to get the solution."
                    },
                    {
                        "username": "vanni1212",
                        "content": "This problem has a test case\\n{2,4,55,6,8} of which the output is expected to be false. How is that so ? Because I understand that player 1 may choose 8,55,2 and thereby become the winner. Am I understanding the question wrong ?"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "[@math_pi](/math_pi) thanks bro I was looking for that."
                    },
                    {
                        "username": "math_pi",
                        "content": "The test case is correct, Here's How the Game Goes:\nLet's say P1(8) -> [2, 4, 55, 6]\nP2(2) -> [4, 55, 6]\nP1(6) -> [4, 55]\nP2(55) -> [4]\nP1(4) ->[]\nObviously P1 Takes an L.\nNow you could do the same thing if P1 chooses 2.\nThe main thing is P2 will choose a lesser element intentionally in order to not allow [55] to be at the end points of the array on P1 turn."
                    },
                    {
                        "username": "ashish2712",
                        "content": "No, the test case is correct.\\nif p1 choose 8, then p2 choose 2 and then 55.\\nif p1 choose 2, then p2 choose 8 and then 55. "
                    },
                    {
                        "username": "foodlover",
                        "content": "player 1 selects 8\\nPlayer 2 then selects 6\\nplayer 1 then selects 55\\nplaher 2 selects 4\\nplayer 1 selects 2\\n\\nDoesn\\'t player 1 win in this case ? The answer for this test case is false, but I feel that\\'s wrong [or have misunderstood the question]"
                    },
                    {
                        "username": "AniEthanHunt",
                        "content": "Player 1 can take 2 or 8.\\nP1 takes 2, then P2 will take 8 and P1 will lose as P2 will get 55 [4, 55, 6]\\nP1 takes 8, then P2 will take 2 and P1 will lose as P2 will get 55 [4, 55, 6]\\n\\nHere, both the player are playing optimally (game theory: min-max algorithm)."
                    },
                    {
                        "username": "Kharelg24",
                        "content": "Test_case2 = [1, 5, 233, 7]\\nI don\\'t understand why for this testcase, Player 1 would choose 1. Obviously 7 is bigger than 1 so shouldn\\'t player 1 choose 7 causing Player 2 to win at the end?"
                    },
                    {
                        "username": "Kharelg24",
                        "content": "[@rakeshSharma19](/rakeshSharma19) Thank you for your response rakesh, however my approach to this problem was to use the mini max algorithm which would take an optimal action in each step. Do you have any other recommendation for these problems?"
                    },
                    {
                        "username": "rakeshSharma19",
                        "content": "You need to understand, Here Both the players playing optimally for overall game not optimal at each step.\\nso If I\\'m player1, I have whole I look through the array and choose 1, because after this whatever player 2 will I have option to choose either 233 or the rest, so here each playing optimally for overall array not for the current step.\\nI hope I have cleared your doubt."
                    }
                ]
            },
            {
                "id": 1990406,
                "content": [
                    {
                        "username": "azharsheikh760",
                        "content": "what **Dynamic Programming** all about \n`Memoization` with `Recursion`?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "No, generally you want to save states in a dp array, while you iterate through the array, building on your previously calculated values. \\nOften memo + recursion is an alternative to dp, since you also store calculations to prevent having to do them again. But they are not the same, they also have separate tags. I would suggest going through a couple of the problems where you can do both and read the editorials to read how they are different, it is too complicated to explain for me in one comment. Maybe somebody can explain it better"
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "This was supposed to be a Binary Search week and here we are solving DP questions."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you can see the topics for each date in the general discussion, it was only BS for 3 days, now it is DP till the end of the month"
                    },
                    {
                        "username": "programmer0073",
                        "content": "I think, I will never be able to get DP. :(\\n"
                    },
                    {
                        "username": "dikshawali",
                        "content": "same"
                    },
                    {
                        "username": "dheeraj2002_",
                        "content": "To start with the description says that the both players play optimally, some may interpret it wrongly as optimally per steps, which is not the case. It means the players are playing the game with the motive to win, and even if they select the lesser integer out of the two, if they see the next moves they will win, they will still select them. The question is quite similar to `min-max algorithm` where one player plays for` max utility`  and another player tries to decrease the overall utility of the player1. So if you had knowledge about min-max algorithm, after some changes, this question could be solved easily. "
                    },
                    {
                        "username": "colewinfield",
                        "content": "A good way to approach this problem is from the perspective of Player 1:\\n\\nAt each decision, what do you stand to gain and what do you stand to lose? You\\'re looking to maximize your choice between these 2 options."
                    },
                    {
                        "username": "Blackdot_11",
                        "content": "[0,0,7,6,5,6,1]\\noutput \\nfalse"
                    },
                    {
                        "username": "yzch1128",
                        "content": "This is the hardest type of DP question that would be asked in an interview. If you ever got asked a harder one during an interview, that means they did not want to hire you at all in the very beginning. "
                    },
                    {
                        "username": "DongmingShen",
                        "content": "AttributeError: \\'Solution\\' object has no attribute \\'predictTheWinner\\'. Did you mean: \\'PredictTheWinner\\'?\\nCode all correct but cannot run. Please fix this ASAP"
                    },
                    {
                        "username": "JacePhoenix",
                        "content": "I would say this is definitely a hard problem."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Amazing question!  This one was very hard for me, but I found it fun to work on."
                    }
                ]
            },
            {
                "id": 1990338,
                "content": [
                    {
                        "username": "azharsheikh760",
                        "content": "what **Dynamic Programming** all about \n`Memoization` with `Recursion`?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "No, generally you want to save states in a dp array, while you iterate through the array, building on your previously calculated values. \\nOften memo + recursion is an alternative to dp, since you also store calculations to prevent having to do them again. But they are not the same, they also have separate tags. I would suggest going through a couple of the problems where you can do both and read the editorials to read how they are different, it is too complicated to explain for me in one comment. Maybe somebody can explain it better"
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "This was supposed to be a Binary Search week and here we are solving DP questions."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you can see the topics for each date in the general discussion, it was only BS for 3 days, now it is DP till the end of the month"
                    },
                    {
                        "username": "programmer0073",
                        "content": "I think, I will never be able to get DP. :(\\n"
                    },
                    {
                        "username": "dikshawali",
                        "content": "same"
                    },
                    {
                        "username": "dheeraj2002_",
                        "content": "To start with the description says that the both players play optimally, some may interpret it wrongly as optimally per steps, which is not the case. It means the players are playing the game with the motive to win, and even if they select the lesser integer out of the two, if they see the next moves they will win, they will still select them. The question is quite similar to `min-max algorithm` where one player plays for` max utility`  and another player tries to decrease the overall utility of the player1. So if you had knowledge about min-max algorithm, after some changes, this question could be solved easily. "
                    },
                    {
                        "username": "colewinfield",
                        "content": "A good way to approach this problem is from the perspective of Player 1:\\n\\nAt each decision, what do you stand to gain and what do you stand to lose? You\\'re looking to maximize your choice between these 2 options."
                    },
                    {
                        "username": "Blackdot_11",
                        "content": "[0,0,7,6,5,6,1]\\noutput \\nfalse"
                    },
                    {
                        "username": "yzch1128",
                        "content": "This is the hardest type of DP question that would be asked in an interview. If you ever got asked a harder one during an interview, that means they did not want to hire you at all in the very beginning. "
                    },
                    {
                        "username": "DongmingShen",
                        "content": "AttributeError: \\'Solution\\' object has no attribute \\'predictTheWinner\\'. Did you mean: \\'PredictTheWinner\\'?\\nCode all correct but cannot run. Please fix this ASAP"
                    },
                    {
                        "username": "JacePhoenix",
                        "content": "I would say this is definitely a hard problem."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Amazing question!  This one was very hard for me, but I found it fun to work on."
                    }
                ]
            },
            {
                "id": 1990157,
                "content": [
                    {
                        "username": "azharsheikh760",
                        "content": "what **Dynamic Programming** all about \n`Memoization` with `Recursion`?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "No, generally you want to save states in a dp array, while you iterate through the array, building on your previously calculated values. \\nOften memo + recursion is an alternative to dp, since you also store calculations to prevent having to do them again. But they are not the same, they also have separate tags. I would suggest going through a couple of the problems where you can do both and read the editorials to read how they are different, it is too complicated to explain for me in one comment. Maybe somebody can explain it better"
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "This was supposed to be a Binary Search week and here we are solving DP questions."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you can see the topics for each date in the general discussion, it was only BS for 3 days, now it is DP till the end of the month"
                    },
                    {
                        "username": "programmer0073",
                        "content": "I think, I will never be able to get DP. :(\\n"
                    },
                    {
                        "username": "dikshawali",
                        "content": "same"
                    },
                    {
                        "username": "dheeraj2002_",
                        "content": "To start with the description says that the both players play optimally, some may interpret it wrongly as optimally per steps, which is not the case. It means the players are playing the game with the motive to win, and even if they select the lesser integer out of the two, if they see the next moves they will win, they will still select them. The question is quite similar to `min-max algorithm` where one player plays for` max utility`  and another player tries to decrease the overall utility of the player1. So if you had knowledge about min-max algorithm, after some changes, this question could be solved easily. "
                    },
                    {
                        "username": "colewinfield",
                        "content": "A good way to approach this problem is from the perspective of Player 1:\\n\\nAt each decision, what do you stand to gain and what do you stand to lose? You\\'re looking to maximize your choice between these 2 options."
                    },
                    {
                        "username": "Blackdot_11",
                        "content": "[0,0,7,6,5,6,1]\\noutput \\nfalse"
                    },
                    {
                        "username": "yzch1128",
                        "content": "This is the hardest type of DP question that would be asked in an interview. If you ever got asked a harder one during an interview, that means they did not want to hire you at all in the very beginning. "
                    },
                    {
                        "username": "DongmingShen",
                        "content": "AttributeError: \\'Solution\\' object has no attribute \\'predictTheWinner\\'. Did you mean: \\'PredictTheWinner\\'?\\nCode all correct but cannot run. Please fix this ASAP"
                    },
                    {
                        "username": "JacePhoenix",
                        "content": "I would say this is definitely a hard problem."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Amazing question!  This one was very hard for me, but I found it fun to work on."
                    }
                ]
            },
            {
                "id": 1990002,
                "content": [
                    {
                        "username": "azharsheikh760",
                        "content": "what **Dynamic Programming** all about \n`Memoization` with `Recursion`?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "No, generally you want to save states in a dp array, while you iterate through the array, building on your previously calculated values. \\nOften memo + recursion is an alternative to dp, since you also store calculations to prevent having to do them again. But they are not the same, they also have separate tags. I would suggest going through a couple of the problems where you can do both and read the editorials to read how they are different, it is too complicated to explain for me in one comment. Maybe somebody can explain it better"
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "This was supposed to be a Binary Search week and here we are solving DP questions."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you can see the topics for each date in the general discussion, it was only BS for 3 days, now it is DP till the end of the month"
                    },
                    {
                        "username": "programmer0073",
                        "content": "I think, I will never be able to get DP. :(\\n"
                    },
                    {
                        "username": "dikshawali",
                        "content": "same"
                    },
                    {
                        "username": "dheeraj2002_",
                        "content": "To start with the description says that the both players play optimally, some may interpret it wrongly as optimally per steps, which is not the case. It means the players are playing the game with the motive to win, and even if they select the lesser integer out of the two, if they see the next moves they will win, they will still select them. The question is quite similar to `min-max algorithm` where one player plays for` max utility`  and another player tries to decrease the overall utility of the player1. So if you had knowledge about min-max algorithm, after some changes, this question could be solved easily. "
                    },
                    {
                        "username": "colewinfield",
                        "content": "A good way to approach this problem is from the perspective of Player 1:\\n\\nAt each decision, what do you stand to gain and what do you stand to lose? You\\'re looking to maximize your choice between these 2 options."
                    },
                    {
                        "username": "Blackdot_11",
                        "content": "[0,0,7,6,5,6,1]\\noutput \\nfalse"
                    },
                    {
                        "username": "yzch1128",
                        "content": "This is the hardest type of DP question that would be asked in an interview. If you ever got asked a harder one during an interview, that means they did not want to hire you at all in the very beginning. "
                    },
                    {
                        "username": "DongmingShen",
                        "content": "AttributeError: \\'Solution\\' object has no attribute \\'predictTheWinner\\'. Did you mean: \\'PredictTheWinner\\'?\\nCode all correct but cannot run. Please fix this ASAP"
                    },
                    {
                        "username": "JacePhoenix",
                        "content": "I would say this is definitely a hard problem."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Amazing question!  This one was very hard for me, but I found it fun to work on."
                    }
                ]
            },
            {
                "id": 1989456,
                "content": [
                    {
                        "username": "azharsheikh760",
                        "content": "what **Dynamic Programming** all about \n`Memoization` with `Recursion`?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "No, generally you want to save states in a dp array, while you iterate through the array, building on your previously calculated values. \\nOften memo + recursion is an alternative to dp, since you also store calculations to prevent having to do them again. But they are not the same, they also have separate tags. I would suggest going through a couple of the problems where you can do both and read the editorials to read how they are different, it is too complicated to explain for me in one comment. Maybe somebody can explain it better"
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "This was supposed to be a Binary Search week and here we are solving DP questions."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you can see the topics for each date in the general discussion, it was only BS for 3 days, now it is DP till the end of the month"
                    },
                    {
                        "username": "programmer0073",
                        "content": "I think, I will never be able to get DP. :(\\n"
                    },
                    {
                        "username": "dikshawali",
                        "content": "same"
                    },
                    {
                        "username": "dheeraj2002_",
                        "content": "To start with the description says that the both players play optimally, some may interpret it wrongly as optimally per steps, which is not the case. It means the players are playing the game with the motive to win, and even if they select the lesser integer out of the two, if they see the next moves they will win, they will still select them. The question is quite similar to `min-max algorithm` where one player plays for` max utility`  and another player tries to decrease the overall utility of the player1. So if you had knowledge about min-max algorithm, after some changes, this question could be solved easily. "
                    },
                    {
                        "username": "colewinfield",
                        "content": "A good way to approach this problem is from the perspective of Player 1:\\n\\nAt each decision, what do you stand to gain and what do you stand to lose? You\\'re looking to maximize your choice between these 2 options."
                    },
                    {
                        "username": "Blackdot_11",
                        "content": "[0,0,7,6,5,6,1]\\noutput \\nfalse"
                    },
                    {
                        "username": "yzch1128",
                        "content": "This is the hardest type of DP question that would be asked in an interview. If you ever got asked a harder one during an interview, that means they did not want to hire you at all in the very beginning. "
                    },
                    {
                        "username": "DongmingShen",
                        "content": "AttributeError: \\'Solution\\' object has no attribute \\'predictTheWinner\\'. Did you mean: \\'PredictTheWinner\\'?\\nCode all correct but cannot run. Please fix this ASAP"
                    },
                    {
                        "username": "JacePhoenix",
                        "content": "I would say this is definitely a hard problem."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Amazing question!  This one was very hard for me, but I found it fun to work on."
                    }
                ]
            },
            {
                "id": 1574632,
                "content": [
                    {
                        "username": "azharsheikh760",
                        "content": "what **Dynamic Programming** all about \n`Memoization` with `Recursion`?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "No, generally you want to save states in a dp array, while you iterate through the array, building on your previously calculated values. \\nOften memo + recursion is an alternative to dp, since you also store calculations to prevent having to do them again. But they are not the same, they also have separate tags. I would suggest going through a couple of the problems where you can do both and read the editorials to read how they are different, it is too complicated to explain for me in one comment. Maybe somebody can explain it better"
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "This was supposed to be a Binary Search week and here we are solving DP questions."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you can see the topics for each date in the general discussion, it was only BS for 3 days, now it is DP till the end of the month"
                    },
                    {
                        "username": "programmer0073",
                        "content": "I think, I will never be able to get DP. :(\\n"
                    },
                    {
                        "username": "dikshawali",
                        "content": "same"
                    },
                    {
                        "username": "dheeraj2002_",
                        "content": "To start with the description says that the both players play optimally, some may interpret it wrongly as optimally per steps, which is not the case. It means the players are playing the game with the motive to win, and even if they select the lesser integer out of the two, if they see the next moves they will win, they will still select them. The question is quite similar to `min-max algorithm` where one player plays for` max utility`  and another player tries to decrease the overall utility of the player1. So if you had knowledge about min-max algorithm, after some changes, this question could be solved easily. "
                    },
                    {
                        "username": "colewinfield",
                        "content": "A good way to approach this problem is from the perspective of Player 1:\\n\\nAt each decision, what do you stand to gain and what do you stand to lose? You\\'re looking to maximize your choice between these 2 options."
                    },
                    {
                        "username": "Blackdot_11",
                        "content": "[0,0,7,6,5,6,1]\\noutput \\nfalse"
                    },
                    {
                        "username": "yzch1128",
                        "content": "This is the hardest type of DP question that would be asked in an interview. If you ever got asked a harder one during an interview, that means they did not want to hire you at all in the very beginning. "
                    },
                    {
                        "username": "DongmingShen",
                        "content": "AttributeError: \\'Solution\\' object has no attribute \\'predictTheWinner\\'. Did you mean: \\'PredictTheWinner\\'?\\nCode all correct but cannot run. Please fix this ASAP"
                    },
                    {
                        "username": "JacePhoenix",
                        "content": "I would say this is definitely a hard problem."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Amazing question!  This one was very hard for me, but I found it fun to work on."
                    }
                ]
            },
            {
                "id": 2057861,
                "content": [
                    {
                        "username": "azharsheikh760",
                        "content": "what **Dynamic Programming** all about \n`Memoization` with `Recursion`?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "No, generally you want to save states in a dp array, while you iterate through the array, building on your previously calculated values. \\nOften memo + recursion is an alternative to dp, since you also store calculations to prevent having to do them again. But they are not the same, they also have separate tags. I would suggest going through a couple of the problems where you can do both and read the editorials to read how they are different, it is too complicated to explain for me in one comment. Maybe somebody can explain it better"
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "This was supposed to be a Binary Search week and here we are solving DP questions."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you can see the topics for each date in the general discussion, it was only BS for 3 days, now it is DP till the end of the month"
                    },
                    {
                        "username": "programmer0073",
                        "content": "I think, I will never be able to get DP. :(\\n"
                    },
                    {
                        "username": "dikshawali",
                        "content": "same"
                    },
                    {
                        "username": "dheeraj2002_",
                        "content": "To start with the description says that the both players play optimally, some may interpret it wrongly as optimally per steps, which is not the case. It means the players are playing the game with the motive to win, and even if they select the lesser integer out of the two, if they see the next moves they will win, they will still select them. The question is quite similar to `min-max algorithm` where one player plays for` max utility`  and another player tries to decrease the overall utility of the player1. So if you had knowledge about min-max algorithm, after some changes, this question could be solved easily. "
                    },
                    {
                        "username": "colewinfield",
                        "content": "A good way to approach this problem is from the perspective of Player 1:\\n\\nAt each decision, what do you stand to gain and what do you stand to lose? You\\'re looking to maximize your choice between these 2 options."
                    },
                    {
                        "username": "Blackdot_11",
                        "content": "[0,0,7,6,5,6,1]\\noutput \\nfalse"
                    },
                    {
                        "username": "yzch1128",
                        "content": "This is the hardest type of DP question that would be asked in an interview. If you ever got asked a harder one during an interview, that means they did not want to hire you at all in the very beginning. "
                    },
                    {
                        "username": "DongmingShen",
                        "content": "AttributeError: \\'Solution\\' object has no attribute \\'predictTheWinner\\'. Did you mean: \\'PredictTheWinner\\'?\\nCode all correct but cannot run. Please fix this ASAP"
                    },
                    {
                        "username": "JacePhoenix",
                        "content": "I would say this is definitely a hard problem."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Amazing question!  This one was very hard for me, but I found it fun to work on."
                    }
                ]
            },
            {
                "id": 2026921,
                "content": [
                    {
                        "username": "azharsheikh760",
                        "content": "what **Dynamic Programming** all about \n`Memoization` with `Recursion`?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "No, generally you want to save states in a dp array, while you iterate through the array, building on your previously calculated values. \\nOften memo + recursion is an alternative to dp, since you also store calculations to prevent having to do them again. But they are not the same, they also have separate tags. I would suggest going through a couple of the problems where you can do both and read the editorials to read how they are different, it is too complicated to explain for me in one comment. Maybe somebody can explain it better"
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "This was supposed to be a Binary Search week and here we are solving DP questions."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you can see the topics for each date in the general discussion, it was only BS for 3 days, now it is DP till the end of the month"
                    },
                    {
                        "username": "programmer0073",
                        "content": "I think, I will never be able to get DP. :(\\n"
                    },
                    {
                        "username": "dikshawali",
                        "content": "same"
                    },
                    {
                        "username": "dheeraj2002_",
                        "content": "To start with the description says that the both players play optimally, some may interpret it wrongly as optimally per steps, which is not the case. It means the players are playing the game with the motive to win, and even if they select the lesser integer out of the two, if they see the next moves they will win, they will still select them. The question is quite similar to `min-max algorithm` where one player plays for` max utility`  and another player tries to decrease the overall utility of the player1. So if you had knowledge about min-max algorithm, after some changes, this question could be solved easily. "
                    },
                    {
                        "username": "colewinfield",
                        "content": "A good way to approach this problem is from the perspective of Player 1:\\n\\nAt each decision, what do you stand to gain and what do you stand to lose? You\\'re looking to maximize your choice between these 2 options."
                    },
                    {
                        "username": "Blackdot_11",
                        "content": "[0,0,7,6,5,6,1]\\noutput \\nfalse"
                    },
                    {
                        "username": "yzch1128",
                        "content": "This is the hardest type of DP question that would be asked in an interview. If you ever got asked a harder one during an interview, that means they did not want to hire you at all in the very beginning. "
                    },
                    {
                        "username": "DongmingShen",
                        "content": "AttributeError: \\'Solution\\' object has no attribute \\'predictTheWinner\\'. Did you mean: \\'PredictTheWinner\\'?\\nCode all correct but cannot run. Please fix this ASAP"
                    },
                    {
                        "username": "JacePhoenix",
                        "content": "I would say this is definitely a hard problem."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Amazing question!  This one was very hard for me, but I found it fun to work on."
                    }
                ]
            },
            {
                "id": 2026091,
                "content": [
                    {
                        "username": "azharsheikh760",
                        "content": "what **Dynamic Programming** all about \n`Memoization` with `Recursion`?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "No, generally you want to save states in a dp array, while you iterate through the array, building on your previously calculated values. \\nOften memo + recursion is an alternative to dp, since you also store calculations to prevent having to do them again. But they are not the same, they also have separate tags. I would suggest going through a couple of the problems where you can do both and read the editorials to read how they are different, it is too complicated to explain for me in one comment. Maybe somebody can explain it better"
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "This was supposed to be a Binary Search week and here we are solving DP questions."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you can see the topics for each date in the general discussion, it was only BS for 3 days, now it is DP till the end of the month"
                    },
                    {
                        "username": "programmer0073",
                        "content": "I think, I will never be able to get DP. :(\\n"
                    },
                    {
                        "username": "dikshawali",
                        "content": "same"
                    },
                    {
                        "username": "dheeraj2002_",
                        "content": "To start with the description says that the both players play optimally, some may interpret it wrongly as optimally per steps, which is not the case. It means the players are playing the game with the motive to win, and even if they select the lesser integer out of the two, if they see the next moves they will win, they will still select them. The question is quite similar to `min-max algorithm` where one player plays for` max utility`  and another player tries to decrease the overall utility of the player1. So if you had knowledge about min-max algorithm, after some changes, this question could be solved easily. "
                    },
                    {
                        "username": "colewinfield",
                        "content": "A good way to approach this problem is from the perspective of Player 1:\\n\\nAt each decision, what do you stand to gain and what do you stand to lose? You\\'re looking to maximize your choice between these 2 options."
                    },
                    {
                        "username": "Blackdot_11",
                        "content": "[0,0,7,6,5,6,1]\\noutput \\nfalse"
                    },
                    {
                        "username": "yzch1128",
                        "content": "This is the hardest type of DP question that would be asked in an interview. If you ever got asked a harder one during an interview, that means they did not want to hire you at all in the very beginning. "
                    },
                    {
                        "username": "DongmingShen",
                        "content": "AttributeError: \\'Solution\\' object has no attribute \\'predictTheWinner\\'. Did you mean: \\'PredictTheWinner\\'?\\nCode all correct but cannot run. Please fix this ASAP"
                    },
                    {
                        "username": "JacePhoenix",
                        "content": "I would say this is definitely a hard problem."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Amazing question!  This one was very hard for me, but I found it fun to work on."
                    }
                ]
            },
            {
                "id": 2002489,
                "content": [
                    {
                        "username": "azharsheikh760",
                        "content": "what **Dynamic Programming** all about \n`Memoization` with `Recursion`?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "No, generally you want to save states in a dp array, while you iterate through the array, building on your previously calculated values. \\nOften memo + recursion is an alternative to dp, since you also store calculations to prevent having to do them again. But they are not the same, they also have separate tags. I would suggest going through a couple of the problems where you can do both and read the editorials to read how they are different, it is too complicated to explain for me in one comment. Maybe somebody can explain it better"
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "This was supposed to be a Binary Search week and here we are solving DP questions."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you can see the topics for each date in the general discussion, it was only BS for 3 days, now it is DP till the end of the month"
                    },
                    {
                        "username": "programmer0073",
                        "content": "I think, I will never be able to get DP. :(\\n"
                    },
                    {
                        "username": "dikshawali",
                        "content": "same"
                    },
                    {
                        "username": "dheeraj2002_",
                        "content": "To start with the description says that the both players play optimally, some may interpret it wrongly as optimally per steps, which is not the case. It means the players are playing the game with the motive to win, and even if they select the lesser integer out of the two, if they see the next moves they will win, they will still select them. The question is quite similar to `min-max algorithm` where one player plays for` max utility`  and another player tries to decrease the overall utility of the player1. So if you had knowledge about min-max algorithm, after some changes, this question could be solved easily. "
                    },
                    {
                        "username": "colewinfield",
                        "content": "A good way to approach this problem is from the perspective of Player 1:\\n\\nAt each decision, what do you stand to gain and what do you stand to lose? You\\'re looking to maximize your choice between these 2 options."
                    },
                    {
                        "username": "Blackdot_11",
                        "content": "[0,0,7,6,5,6,1]\\noutput \\nfalse"
                    },
                    {
                        "username": "yzch1128",
                        "content": "This is the hardest type of DP question that would be asked in an interview. If you ever got asked a harder one during an interview, that means they did not want to hire you at all in the very beginning. "
                    },
                    {
                        "username": "DongmingShen",
                        "content": "AttributeError: \\'Solution\\' object has no attribute \\'predictTheWinner\\'. Did you mean: \\'PredictTheWinner\\'?\\nCode all correct but cannot run. Please fix this ASAP"
                    },
                    {
                        "username": "JacePhoenix",
                        "content": "I would say this is definitely a hard problem."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Amazing question!  This one was very hard for me, but I found it fun to work on."
                    }
                ]
            },
            {
                "id": 1997378,
                "content": [
                    {
                        "username": "user4262O",
                        "content": "for Java if got compile error, you need to change PredictTheWinner to predictTheWinner"
                    },
                    {
                        "username": "guyses",
                        "content": "what does `optimally` means in this question?\\n\\nin this test case - [2,4,55,6,8]\\nplayer1 can win, but the expected answer is `false`\\nplayer1 wins like this\\n\\nplayer1 take `2`\\nplayer2 takes `4`\\nplayer1 takes `55`\\nplayer2 takes `8`\\nplayer1 takes `6`\\n\\nin the end player1 = 2 + 55 + 6  > player2 = 4 + 8\\n\\nthere\\'s a reasoning to this, that i can think of, \\nwhy would player2 want to give the highest number in the array to player1? -> Is this what `optimally` means?"
                    },
                    {
                        "username": "dheeraj2002_",
                        "content": "Optimally doesn\\'t mean that at each step the player would be taking the biggest of the two, but to increase it\\'s score and decrease other person\\'s score. Watch min-max algorithm and it will help you to apply the logic more efficiently"
                    },
                    {
                        "username": "dikshawali",
                        "content": "I didn\\'t get it...in case of [1,5,2]\\nif player 1 chooses 1,\\nthen player 2 chooses 2,\\nafter which player1 chooses 5 making his score 6. Means there is one of the many ways in which player1 can become winner.\\nI am not sure why in each case player 2 is going to choose 5 to maximize his score, while player 1\\n\\nWhat I mean to say is - \\n[1,5,2]\\nplayer1 has been given 2 possibilities of choosing either 1 or 2. He doesnt care which one is bigger\\nwhile player2 cares, he always chooses 5. Why so? \\nCan anyone explain me this? Help will be appreciated."
                    },
                    {
                        "username": "huke0906",
                        "content": "So what does \"optimally\" mean? This problem seems poorly defined."
                    },
                    {
                        "username": "huke0906",
                        "content": "[@dheeraj2002_](/dheeraj2002_) Thank you! Now I see."
                    },
                    {
                        "username": "dheeraj2002_",
                        "content": "optimally means they will play to win, i.e. at each step the player will try to score such that it impacts his score as well as the score of the second player. Meaning a person may select a lesser score at a step but would do so to keep the higher score out of the range of the second player. I advice you to watch min-max algorithm for more insight to the problem. Also it is important not to confuse optimally with optimally per steps."
                    },
                    {
                        "username": "Zefick",
                        "content": "It's sad that so many people come up with a solution that runs in Python for more than 5 seconds.\nThe array is too small, so they were too lazy to optimize their exponential solutions even a little bit after they've been accepted."
                    },
                    {
                        "username": "Aaronearlerichardson",
                        "content": "Confused about a test case here:\\n\\n ```\\nnums = [3606449,6,5,9,452429,7,9580316,9857582,8514433,9,6,6614512,753594,5474165,4,2697293,8,7,1]\\n\\n{\\'p1\\': 3606449, \\'p2\\': 0} [6, 5, 9, 452429, 7, 9580316, 9857582, 8514433, 9, 6, 6614512, 753594, 5474165, 4, 2697293, 8, 7, 1]\\n\\n{\\'p1\\': 3606449, \\'p2\\': 6} [5, 9, 452429, 7, 9580316, 9857582, 8514433, 9, 6, 6614512, 753594, 5474165, 4, 2697293, 8, 7, 1]\\n\\n{\\'p1\\': 3606454, \\'p2\\': 6} [9, 452429, 7, 9580316, 9857582, 8514433, 9, 6, 6614512, 753594, 5474165, 4, 2697293, 8, 7, 1]\\n\\n{\\'p1\\': 3606454, \\'p2\\': 7} [9, 452429, 7, 9580316, 9857582, 8514433, 9, 6, 6614512, 753594, 5474165, 4, 2697293, 8, 7]\\n\\n{\\'p1\\': 3606461, \\'p2\\': 7} [9, 452429, 7, 9580316, 9857582, 8514433, 9, 6, 6614512, 753594, 5474165, 4, 2697293, 8]\\n\\n{\\'p1\\': 3606461, \\'p2\\': 16} [452429, 7, 9580316, 9857582, 8514433, 9, 6, 6614512, 753594, 5474165, 4, 2697293, 8]\\n\\n{\\'p1\\': 4058890, \\'p2\\': 16} [7, 9580316, 9857582, 8514433, 9, 6, 6614512, 753594, 5474165, 4, 2697293, 8]\\n\\n{\\'p1\\': 4058890, \\'p2\\': 24} [7, 9580316, 9857582, 8514433, 9, 6, 6614512, 753594, 5474165, 4, 2697293]\\n\\n{\\'p1\\': 6756183, \\'p2\\': 24} [7, 9580316, 9857582, 8514433, 9, 6, 6614512, 753594, 5474165, 4]\\n\\n{\\'p1\\': 6756183, \\'p2\\': 28} [7, 9580316, 9857582, 8514433, 9, 6, 6614512, 753594, 5474165]\\n\\n{\\'p1\\': 12230348, \\'p2\\': 28} [7, 9580316, 9857582, 8514433, 9, 6, 6614512, 753594]\\n\\n{\\'p1\\': 12230348, \\'p2\\': 753622} [7, 9580316, 9857582, 8514433, 9, 6, 6614512]\\n\\n{\\'p1\\': 18844860, \\'p2\\': 753622} [7, 9580316, 9857582, 8514433, 9, 6]\\n\\n{\\'p1\\': 18844860, \\'p2\\': 753628} [7, 9580316, 9857582, 8514433, 9]\\n\\n{\\'p1\\': 18844869, \\'p2\\': 753628} [7, 9580316, 9857582, 8514433]\\n\\n{\\'p1\\': 18844869, \\'p2\\': 9268061} [7, 9580316, 9857582]\\n\\n{\\'p1\\': 28702451, \\'p2\\': 9268061} [7, 9580316]\\n\\n{\\'p1\\': 28702451, \\'p2\\': 18848377} [7]\\n\\n{\\'p1\\': 28702458, \\'p2\\': 18848377} []\\n```\\n\\nSo I would expect the output to be true, but it isn\\'t. Why can\\'t player 1 win here?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The game played here is based on the Minimax algorithm, which is a kind of backtracking algorithm used in decision making and game theory to find the optimal move for a player, assuming that the opponent also plays optimally.\\n\\nIn your specific test case, even though Player 1 seems to have the upper hand at first glance due to higher score accumulation, the decision to pick the number is not based solely on the current highest available number. Instead, the algorithm looks ahead to evaluate potential future states of the game, trying to minimize the possible loss for a worst-case (maximum loss) scenario.\\n\\nThe selection of numbers for both players might seem counter-intuitive, but the decision-making process assumes that both players are playing optimally. This means that each player chooses their number not just based on the current state, but also on how their choice would influence the options available for the next player and, by extension, the options that would be available to themselves on the next round.\\n\\nThus, in some cases, a player might choose a lower number over a higher one because it leads to a future state where they would ultimately have the advantage.\\n\\nThe scenario you\\'ve posted shows the step-by-step decision-making process of the players under the Minimax algorithm, and it seems that even though Player 1 has more points throughout the game, Player 2 wins in the end when playing optimally. This is why the function returns `False`, meaning Player 1 (the first player to start the game) cannot win assuming both players play optimally."
                    },
                    {
                        "username": "dvijay96",
                        "content": "Could anyone please help me understand the fault in below approach.\\nApproach:-  I\\'m trying to find the max score each player can make by recursively making a choice to pick/not pick the 1st and the last element.\\n\\n `public boolean PredictTheWinner(int[] nums) {\\n        int[] winner = {0, 0};\\n        if(nums.length>1){\\n            LinkedList<Integer> list = new LinkedList<>();\\n\\n            for(int i : nums){\\n                list.add(i);\\n            }\\n\\n            simulateWinner(list, 0, 0, 1, winner);\\n        }\\n        return winner[0] >= winner[1];\\n    }\\n\\n    void simulateWinner(LinkedList<Integer> list, int score1, int score2,int player, int[] winner){\\n\\n        if(list.isEmpty()){\\n            winner[0] = Math.max(winner[0], score1);\\n            winner[1] = Math.max(winner[1], score2);\\n            return;\\n        }\\n\\n        if(player == 1){\\n            int num = list.pollFirst();\\n            simulateWinner(list, score1+num, score2, 2, winner);\\n            list.addFirst(num);\\n\\n            num = list.pollLast();\\n            simulateWinner(list, score1+num, score2, 2, winner);\\n            list.addLast(num);\\n        }else{\\n            int num = list.pollFirst();\\n            simulateWinner(list, score1, score2+num, 1, winner);\\n            list.addFirst(num);\\n\\n            num = list.pollLast();\\n            simulateWinner(list, score1, score2+num, 1, winner);\\n            list.addLast(num); \\n        }\\n    }`\\n\\nThanks in advance."
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach to recursively simulate both players picking the first and last numbers is a good start. However, there is a critical flaw in this approach. In a game where both players play optimally, each player, when making a choice, must consider not just the immediate gain, but also what the opponent will do in the next turn. In your code, each player only tries to maximize their own score in the current turn without considering the opponent\\'s possible moves in the next turn.\\n\\nIn your `simulateWinner` function, when a player chooses a number, you recursively call `simulateWinner` for the other player with the remaining numbers. However, the current player doesn\\'t take into consideration what the score would be after the other player makes their optimal move. \\n\\nTo fix this, you should change the function so that when a player is about to make a move, they consider both options (picking the first number and picking the last number), simulate the remaining game for both options (i.e., call `simulateWinner` twice for each option), and then choose the option that results in the maximum final score for themselves. \\n\\nTo do this, you need to change `simulateWinner` to return the final score difference (player 1\\'s score minus player 2\\'s score), and when simulating the game for each option, the current player should choose the option that maximizes this score difference. This is because a positive score difference means player 1 wins, and a negative score difference means player 2 wins.\\n\\nFinally, in `PredictTheWinner`, instead of checking if `winner[0] >= winner[1]`, you should check if the final score difference is greater than or equal to 0, as a non-negative score difference means player 1 can win or draw the game."
                    },
                    {
                        "username": "avneets2103",
                        "content": "oky gotta revise DP\\n"
                    },
                    {
                        "username": "satishvegisetti563",
                        "content": "Anyone please list out similar problems"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "some of the Stone game problems are all somewhat similar to this, and the game theory tag gives you all problems that are games, some of those are quite similar too"
                    },
                    {
                        "username": "7h3w17ch3r",
                        "content": "Cisco OA?\\n"
                    }
                ]
            },
            {
                "id": 1991735,
                "content": [
                    {
                        "username": "user4262O",
                        "content": "for Java if got compile error, you need to change PredictTheWinner to predictTheWinner"
                    },
                    {
                        "username": "guyses",
                        "content": "what does `optimally` means in this question?\\n\\nin this test case - [2,4,55,6,8]\\nplayer1 can win, but the expected answer is `false`\\nplayer1 wins like this\\n\\nplayer1 take `2`\\nplayer2 takes `4`\\nplayer1 takes `55`\\nplayer2 takes `8`\\nplayer1 takes `6`\\n\\nin the end player1 = 2 + 55 + 6  > player2 = 4 + 8\\n\\nthere\\'s a reasoning to this, that i can think of, \\nwhy would player2 want to give the highest number in the array to player1? -> Is this what `optimally` means?"
                    },
                    {
                        "username": "dheeraj2002_",
                        "content": "Optimally doesn\\'t mean that at each step the player would be taking the biggest of the two, but to increase it\\'s score and decrease other person\\'s score. Watch min-max algorithm and it will help you to apply the logic more efficiently"
                    },
                    {
                        "username": "dikshawali",
                        "content": "I didn\\'t get it...in case of [1,5,2]\\nif player 1 chooses 1,\\nthen player 2 chooses 2,\\nafter which player1 chooses 5 making his score 6. Means there is one of the many ways in which player1 can become winner.\\nI am not sure why in each case player 2 is going to choose 5 to maximize his score, while player 1\\n\\nWhat I mean to say is - \\n[1,5,2]\\nplayer1 has been given 2 possibilities of choosing either 1 or 2. He doesnt care which one is bigger\\nwhile player2 cares, he always chooses 5. Why so? \\nCan anyone explain me this? Help will be appreciated."
                    },
                    {
                        "username": "huke0906",
                        "content": "So what does \"optimally\" mean? This problem seems poorly defined."
                    },
                    {
                        "username": "huke0906",
                        "content": "[@dheeraj2002_](/dheeraj2002_) Thank you! Now I see."
                    },
                    {
                        "username": "dheeraj2002_",
                        "content": "optimally means they will play to win, i.e. at each step the player will try to score such that it impacts his score as well as the score of the second player. Meaning a person may select a lesser score at a step but would do so to keep the higher score out of the range of the second player. I advice you to watch min-max algorithm for more insight to the problem. Also it is important not to confuse optimally with optimally per steps."
                    },
                    {
                        "username": "Zefick",
                        "content": "It's sad that so many people come up with a solution that runs in Python for more than 5 seconds.\nThe array is too small, so they were too lazy to optimize their exponential solutions even a little bit after they've been accepted."
                    },
                    {
                        "username": "Aaronearlerichardson",
                        "content": "Confused about a test case here:\\n\\n ```\\nnums = [3606449,6,5,9,452429,7,9580316,9857582,8514433,9,6,6614512,753594,5474165,4,2697293,8,7,1]\\n\\n{\\'p1\\': 3606449, \\'p2\\': 0} [6, 5, 9, 452429, 7, 9580316, 9857582, 8514433, 9, 6, 6614512, 753594, 5474165, 4, 2697293, 8, 7, 1]\\n\\n{\\'p1\\': 3606449, \\'p2\\': 6} [5, 9, 452429, 7, 9580316, 9857582, 8514433, 9, 6, 6614512, 753594, 5474165, 4, 2697293, 8, 7, 1]\\n\\n{\\'p1\\': 3606454, \\'p2\\': 6} [9, 452429, 7, 9580316, 9857582, 8514433, 9, 6, 6614512, 753594, 5474165, 4, 2697293, 8, 7, 1]\\n\\n{\\'p1\\': 3606454, \\'p2\\': 7} [9, 452429, 7, 9580316, 9857582, 8514433, 9, 6, 6614512, 753594, 5474165, 4, 2697293, 8, 7]\\n\\n{\\'p1\\': 3606461, \\'p2\\': 7} [9, 452429, 7, 9580316, 9857582, 8514433, 9, 6, 6614512, 753594, 5474165, 4, 2697293, 8]\\n\\n{\\'p1\\': 3606461, \\'p2\\': 16} [452429, 7, 9580316, 9857582, 8514433, 9, 6, 6614512, 753594, 5474165, 4, 2697293, 8]\\n\\n{\\'p1\\': 4058890, \\'p2\\': 16} [7, 9580316, 9857582, 8514433, 9, 6, 6614512, 753594, 5474165, 4, 2697293, 8]\\n\\n{\\'p1\\': 4058890, \\'p2\\': 24} [7, 9580316, 9857582, 8514433, 9, 6, 6614512, 753594, 5474165, 4, 2697293]\\n\\n{\\'p1\\': 6756183, \\'p2\\': 24} [7, 9580316, 9857582, 8514433, 9, 6, 6614512, 753594, 5474165, 4]\\n\\n{\\'p1\\': 6756183, \\'p2\\': 28} [7, 9580316, 9857582, 8514433, 9, 6, 6614512, 753594, 5474165]\\n\\n{\\'p1\\': 12230348, \\'p2\\': 28} [7, 9580316, 9857582, 8514433, 9, 6, 6614512, 753594]\\n\\n{\\'p1\\': 12230348, \\'p2\\': 753622} [7, 9580316, 9857582, 8514433, 9, 6, 6614512]\\n\\n{\\'p1\\': 18844860, \\'p2\\': 753622} [7, 9580316, 9857582, 8514433, 9, 6]\\n\\n{\\'p1\\': 18844860, \\'p2\\': 753628} [7, 9580316, 9857582, 8514433, 9]\\n\\n{\\'p1\\': 18844869, \\'p2\\': 753628} [7, 9580316, 9857582, 8514433]\\n\\n{\\'p1\\': 18844869, \\'p2\\': 9268061} [7, 9580316, 9857582]\\n\\n{\\'p1\\': 28702451, \\'p2\\': 9268061} [7, 9580316]\\n\\n{\\'p1\\': 28702451, \\'p2\\': 18848377} [7]\\n\\n{\\'p1\\': 28702458, \\'p2\\': 18848377} []\\n```\\n\\nSo I would expect the output to be true, but it isn\\'t. Why can\\'t player 1 win here?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The game played here is based on the Minimax algorithm, which is a kind of backtracking algorithm used in decision making and game theory to find the optimal move for a player, assuming that the opponent also plays optimally.\\n\\nIn your specific test case, even though Player 1 seems to have the upper hand at first glance due to higher score accumulation, the decision to pick the number is not based solely on the current highest available number. Instead, the algorithm looks ahead to evaluate potential future states of the game, trying to minimize the possible loss for a worst-case (maximum loss) scenario.\\n\\nThe selection of numbers for both players might seem counter-intuitive, but the decision-making process assumes that both players are playing optimally. This means that each player chooses their number not just based on the current state, but also on how their choice would influence the options available for the next player and, by extension, the options that would be available to themselves on the next round.\\n\\nThus, in some cases, a player might choose a lower number over a higher one because it leads to a future state where they would ultimately have the advantage.\\n\\nThe scenario you\\'ve posted shows the step-by-step decision-making process of the players under the Minimax algorithm, and it seems that even though Player 1 has more points throughout the game, Player 2 wins in the end when playing optimally. This is why the function returns `False`, meaning Player 1 (the first player to start the game) cannot win assuming both players play optimally."
                    },
                    {
                        "username": "dvijay96",
                        "content": "Could anyone please help me understand the fault in below approach.\\nApproach:-  I\\'m trying to find the max score each player can make by recursively making a choice to pick/not pick the 1st and the last element.\\n\\n `public boolean PredictTheWinner(int[] nums) {\\n        int[] winner = {0, 0};\\n        if(nums.length>1){\\n            LinkedList<Integer> list = new LinkedList<>();\\n\\n            for(int i : nums){\\n                list.add(i);\\n            }\\n\\n            simulateWinner(list, 0, 0, 1, winner);\\n        }\\n        return winner[0] >= winner[1];\\n    }\\n\\n    void simulateWinner(LinkedList<Integer> list, int score1, int score2,int player, int[] winner){\\n\\n        if(list.isEmpty()){\\n            winner[0] = Math.max(winner[0], score1);\\n            winner[1] = Math.max(winner[1], score2);\\n            return;\\n        }\\n\\n        if(player == 1){\\n            int num = list.pollFirst();\\n            simulateWinner(list, score1+num, score2, 2, winner);\\n            list.addFirst(num);\\n\\n            num = list.pollLast();\\n            simulateWinner(list, score1+num, score2, 2, winner);\\n            list.addLast(num);\\n        }else{\\n            int num = list.pollFirst();\\n            simulateWinner(list, score1, score2+num, 1, winner);\\n            list.addFirst(num);\\n\\n            num = list.pollLast();\\n            simulateWinner(list, score1, score2+num, 1, winner);\\n            list.addLast(num); \\n        }\\n    }`\\n\\nThanks in advance."
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach to recursively simulate both players picking the first and last numbers is a good start. However, there is a critical flaw in this approach. In a game where both players play optimally, each player, when making a choice, must consider not just the immediate gain, but also what the opponent will do in the next turn. In your code, each player only tries to maximize their own score in the current turn without considering the opponent\\'s possible moves in the next turn.\\n\\nIn your `simulateWinner` function, when a player chooses a number, you recursively call `simulateWinner` for the other player with the remaining numbers. However, the current player doesn\\'t take into consideration what the score would be after the other player makes their optimal move. \\n\\nTo fix this, you should change the function so that when a player is about to make a move, they consider both options (picking the first number and picking the last number), simulate the remaining game for both options (i.e., call `simulateWinner` twice for each option), and then choose the option that results in the maximum final score for themselves. \\n\\nTo do this, you need to change `simulateWinner` to return the final score difference (player 1\\'s score minus player 2\\'s score), and when simulating the game for each option, the current player should choose the option that maximizes this score difference. This is because a positive score difference means player 1 wins, and a negative score difference means player 2 wins.\\n\\nFinally, in `PredictTheWinner`, instead of checking if `winner[0] >= winner[1]`, you should check if the final score difference is greater than or equal to 0, as a non-negative score difference means player 1 can win or draw the game."
                    },
                    {
                        "username": "avneets2103",
                        "content": "oky gotta revise DP\\n"
                    },
                    {
                        "username": "satishvegisetti563",
                        "content": "Anyone please list out similar problems"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "some of the Stone game problems are all somewhat similar to this, and the game theory tag gives you all problems that are games, some of those are quite similar too"
                    },
                    {
                        "username": "7h3w17ch3r",
                        "content": "Cisco OA?\\n"
                    }
                ]
            },
            {
                "id": 1991467,
                "content": [
                    {
                        "username": "user4262O",
                        "content": "for Java if got compile error, you need to change PredictTheWinner to predictTheWinner"
                    },
                    {
                        "username": "guyses",
                        "content": "what does `optimally` means in this question?\\n\\nin this test case - [2,4,55,6,8]\\nplayer1 can win, but the expected answer is `false`\\nplayer1 wins like this\\n\\nplayer1 take `2`\\nplayer2 takes `4`\\nplayer1 takes `55`\\nplayer2 takes `8`\\nplayer1 takes `6`\\n\\nin the end player1 = 2 + 55 + 6  > player2 = 4 + 8\\n\\nthere\\'s a reasoning to this, that i can think of, \\nwhy would player2 want to give the highest number in the array to player1? -> Is this what `optimally` means?"
                    },
                    {
                        "username": "dheeraj2002_",
                        "content": "Optimally doesn\\'t mean that at each step the player would be taking the biggest of the two, but to increase it\\'s score and decrease other person\\'s score. Watch min-max algorithm and it will help you to apply the logic more efficiently"
                    },
                    {
                        "username": "dikshawali",
                        "content": "I didn\\'t get it...in case of [1,5,2]\\nif player 1 chooses 1,\\nthen player 2 chooses 2,\\nafter which player1 chooses 5 making his score 6. Means there is one of the many ways in which player1 can become winner.\\nI am not sure why in each case player 2 is going to choose 5 to maximize his score, while player 1\\n\\nWhat I mean to say is - \\n[1,5,2]\\nplayer1 has been given 2 possibilities of choosing either 1 or 2. He doesnt care which one is bigger\\nwhile player2 cares, he always chooses 5. Why so? \\nCan anyone explain me this? Help will be appreciated."
                    },
                    {
                        "username": "huke0906",
                        "content": "So what does \"optimally\" mean? This problem seems poorly defined."
                    },
                    {
                        "username": "huke0906",
                        "content": "[@dheeraj2002_](/dheeraj2002_) Thank you! Now I see."
                    },
                    {
                        "username": "dheeraj2002_",
                        "content": "optimally means they will play to win, i.e. at each step the player will try to score such that it impacts his score as well as the score of the second player. Meaning a person may select a lesser score at a step but would do so to keep the higher score out of the range of the second player. I advice you to watch min-max algorithm for more insight to the problem. Also it is important not to confuse optimally with optimally per steps."
                    },
                    {
                        "username": "Zefick",
                        "content": "It's sad that so many people come up with a solution that runs in Python for more than 5 seconds.\nThe array is too small, so they were too lazy to optimize their exponential solutions even a little bit after they've been accepted."
                    },
                    {
                        "username": "Aaronearlerichardson",
                        "content": "Confused about a test case here:\\n\\n ```\\nnums = [3606449,6,5,9,452429,7,9580316,9857582,8514433,9,6,6614512,753594,5474165,4,2697293,8,7,1]\\n\\n{\\'p1\\': 3606449, \\'p2\\': 0} [6, 5, 9, 452429, 7, 9580316, 9857582, 8514433, 9, 6, 6614512, 753594, 5474165, 4, 2697293, 8, 7, 1]\\n\\n{\\'p1\\': 3606449, \\'p2\\': 6} [5, 9, 452429, 7, 9580316, 9857582, 8514433, 9, 6, 6614512, 753594, 5474165, 4, 2697293, 8, 7, 1]\\n\\n{\\'p1\\': 3606454, \\'p2\\': 6} [9, 452429, 7, 9580316, 9857582, 8514433, 9, 6, 6614512, 753594, 5474165, 4, 2697293, 8, 7, 1]\\n\\n{\\'p1\\': 3606454, \\'p2\\': 7} [9, 452429, 7, 9580316, 9857582, 8514433, 9, 6, 6614512, 753594, 5474165, 4, 2697293, 8, 7]\\n\\n{\\'p1\\': 3606461, \\'p2\\': 7} [9, 452429, 7, 9580316, 9857582, 8514433, 9, 6, 6614512, 753594, 5474165, 4, 2697293, 8]\\n\\n{\\'p1\\': 3606461, \\'p2\\': 16} [452429, 7, 9580316, 9857582, 8514433, 9, 6, 6614512, 753594, 5474165, 4, 2697293, 8]\\n\\n{\\'p1\\': 4058890, \\'p2\\': 16} [7, 9580316, 9857582, 8514433, 9, 6, 6614512, 753594, 5474165, 4, 2697293, 8]\\n\\n{\\'p1\\': 4058890, \\'p2\\': 24} [7, 9580316, 9857582, 8514433, 9, 6, 6614512, 753594, 5474165, 4, 2697293]\\n\\n{\\'p1\\': 6756183, \\'p2\\': 24} [7, 9580316, 9857582, 8514433, 9, 6, 6614512, 753594, 5474165, 4]\\n\\n{\\'p1\\': 6756183, \\'p2\\': 28} [7, 9580316, 9857582, 8514433, 9, 6, 6614512, 753594, 5474165]\\n\\n{\\'p1\\': 12230348, \\'p2\\': 28} [7, 9580316, 9857582, 8514433, 9, 6, 6614512, 753594]\\n\\n{\\'p1\\': 12230348, \\'p2\\': 753622} [7, 9580316, 9857582, 8514433, 9, 6, 6614512]\\n\\n{\\'p1\\': 18844860, \\'p2\\': 753622} [7, 9580316, 9857582, 8514433, 9, 6]\\n\\n{\\'p1\\': 18844860, \\'p2\\': 753628} [7, 9580316, 9857582, 8514433, 9]\\n\\n{\\'p1\\': 18844869, \\'p2\\': 753628} [7, 9580316, 9857582, 8514433]\\n\\n{\\'p1\\': 18844869, \\'p2\\': 9268061} [7, 9580316, 9857582]\\n\\n{\\'p1\\': 28702451, \\'p2\\': 9268061} [7, 9580316]\\n\\n{\\'p1\\': 28702451, \\'p2\\': 18848377} [7]\\n\\n{\\'p1\\': 28702458, \\'p2\\': 18848377} []\\n```\\n\\nSo I would expect the output to be true, but it isn\\'t. Why can\\'t player 1 win here?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The game played here is based on the Minimax algorithm, which is a kind of backtracking algorithm used in decision making and game theory to find the optimal move for a player, assuming that the opponent also plays optimally.\\n\\nIn your specific test case, even though Player 1 seems to have the upper hand at first glance due to higher score accumulation, the decision to pick the number is not based solely on the current highest available number. Instead, the algorithm looks ahead to evaluate potential future states of the game, trying to minimize the possible loss for a worst-case (maximum loss) scenario.\\n\\nThe selection of numbers for both players might seem counter-intuitive, but the decision-making process assumes that both players are playing optimally. This means that each player chooses their number not just based on the current state, but also on how their choice would influence the options available for the next player and, by extension, the options that would be available to themselves on the next round.\\n\\nThus, in some cases, a player might choose a lower number over a higher one because it leads to a future state where they would ultimately have the advantage.\\n\\nThe scenario you\\'ve posted shows the step-by-step decision-making process of the players under the Minimax algorithm, and it seems that even though Player 1 has more points throughout the game, Player 2 wins in the end when playing optimally. This is why the function returns `False`, meaning Player 1 (the first player to start the game) cannot win assuming both players play optimally."
                    },
                    {
                        "username": "dvijay96",
                        "content": "Could anyone please help me understand the fault in below approach.\\nApproach:-  I\\'m trying to find the max score each player can make by recursively making a choice to pick/not pick the 1st and the last element.\\n\\n `public boolean PredictTheWinner(int[] nums) {\\n        int[] winner = {0, 0};\\n        if(nums.length>1){\\n            LinkedList<Integer> list = new LinkedList<>();\\n\\n            for(int i : nums){\\n                list.add(i);\\n            }\\n\\n            simulateWinner(list, 0, 0, 1, winner);\\n        }\\n        return winner[0] >= winner[1];\\n    }\\n\\n    void simulateWinner(LinkedList<Integer> list, int score1, int score2,int player, int[] winner){\\n\\n        if(list.isEmpty()){\\n            winner[0] = Math.max(winner[0], score1);\\n            winner[1] = Math.max(winner[1], score2);\\n            return;\\n        }\\n\\n        if(player == 1){\\n            int num = list.pollFirst();\\n            simulateWinner(list, score1+num, score2, 2, winner);\\n            list.addFirst(num);\\n\\n            num = list.pollLast();\\n            simulateWinner(list, score1+num, score2, 2, winner);\\n            list.addLast(num);\\n        }else{\\n            int num = list.pollFirst();\\n            simulateWinner(list, score1, score2+num, 1, winner);\\n            list.addFirst(num);\\n\\n            num = list.pollLast();\\n            simulateWinner(list, score1, score2+num, 1, winner);\\n            list.addLast(num); \\n        }\\n    }`\\n\\nThanks in advance."
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach to recursively simulate both players picking the first and last numbers is a good start. However, there is a critical flaw in this approach. In a game where both players play optimally, each player, when making a choice, must consider not just the immediate gain, but also what the opponent will do in the next turn. In your code, each player only tries to maximize their own score in the current turn without considering the opponent\\'s possible moves in the next turn.\\n\\nIn your `simulateWinner` function, when a player chooses a number, you recursively call `simulateWinner` for the other player with the remaining numbers. However, the current player doesn\\'t take into consideration what the score would be after the other player makes their optimal move. \\n\\nTo fix this, you should change the function so that when a player is about to make a move, they consider both options (picking the first number and picking the last number), simulate the remaining game for both options (i.e., call `simulateWinner` twice for each option), and then choose the option that results in the maximum final score for themselves. \\n\\nTo do this, you need to change `simulateWinner` to return the final score difference (player 1\\'s score minus player 2\\'s score), and when simulating the game for each option, the current player should choose the option that maximizes this score difference. This is because a positive score difference means player 1 wins, and a negative score difference means player 2 wins.\\n\\nFinally, in `PredictTheWinner`, instead of checking if `winner[0] >= winner[1]`, you should check if the final score difference is greater than or equal to 0, as a non-negative score difference means player 1 can win or draw the game."
                    },
                    {
                        "username": "avneets2103",
                        "content": "oky gotta revise DP\\n"
                    },
                    {
                        "username": "satishvegisetti563",
                        "content": "Anyone please list out similar problems"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "some of the Stone game problems are all somewhat similar to this, and the game theory tag gives you all problems that are games, some of those are quite similar too"
                    },
                    {
                        "username": "7h3w17ch3r",
                        "content": "Cisco OA?\\n"
                    }
                ]
            },
            {
                "id": 1991257,
                "content": [
                    {
                        "username": "user4262O",
                        "content": "for Java if got compile error, you need to change PredictTheWinner to predictTheWinner"
                    },
                    {
                        "username": "guyses",
                        "content": "what does `optimally` means in this question?\\n\\nin this test case - [2,4,55,6,8]\\nplayer1 can win, but the expected answer is `false`\\nplayer1 wins like this\\n\\nplayer1 take `2`\\nplayer2 takes `4`\\nplayer1 takes `55`\\nplayer2 takes `8`\\nplayer1 takes `6`\\n\\nin the end player1 = 2 + 55 + 6  > player2 = 4 + 8\\n\\nthere\\'s a reasoning to this, that i can think of, \\nwhy would player2 want to give the highest number in the array to player1? -> Is this what `optimally` means?"
                    },
                    {
                        "username": "dheeraj2002_",
                        "content": "Optimally doesn\\'t mean that at each step the player would be taking the biggest of the two, but to increase it\\'s score and decrease other person\\'s score. Watch min-max algorithm and it will help you to apply the logic more efficiently"
                    },
                    {
                        "username": "dikshawali",
                        "content": "I didn\\'t get it...in case of [1,5,2]\\nif player 1 chooses 1,\\nthen player 2 chooses 2,\\nafter which player1 chooses 5 making his score 6. Means there is one of the many ways in which player1 can become winner.\\nI am not sure why in each case player 2 is going to choose 5 to maximize his score, while player 1\\n\\nWhat I mean to say is - \\n[1,5,2]\\nplayer1 has been given 2 possibilities of choosing either 1 or 2. He doesnt care which one is bigger\\nwhile player2 cares, he always chooses 5. Why so? \\nCan anyone explain me this? Help will be appreciated."
                    },
                    {
                        "username": "huke0906",
                        "content": "So what does \"optimally\" mean? This problem seems poorly defined."
                    },
                    {
                        "username": "huke0906",
                        "content": "[@dheeraj2002_](/dheeraj2002_) Thank you! Now I see."
                    },
                    {
                        "username": "dheeraj2002_",
                        "content": "optimally means they will play to win, i.e. at each step the player will try to score such that it impacts his score as well as the score of the second player. Meaning a person may select a lesser score at a step but would do so to keep the higher score out of the range of the second player. I advice you to watch min-max algorithm for more insight to the problem. Also it is important not to confuse optimally with optimally per steps."
                    },
                    {
                        "username": "Zefick",
                        "content": "It's sad that so many people come up with a solution that runs in Python for more than 5 seconds.\nThe array is too small, so they were too lazy to optimize their exponential solutions even a little bit after they've been accepted."
                    },
                    {
                        "username": "Aaronearlerichardson",
                        "content": "Confused about a test case here:\\n\\n ```\\nnums = [3606449,6,5,9,452429,7,9580316,9857582,8514433,9,6,6614512,753594,5474165,4,2697293,8,7,1]\\n\\n{\\'p1\\': 3606449, \\'p2\\': 0} [6, 5, 9, 452429, 7, 9580316, 9857582, 8514433, 9, 6, 6614512, 753594, 5474165, 4, 2697293, 8, 7, 1]\\n\\n{\\'p1\\': 3606449, \\'p2\\': 6} [5, 9, 452429, 7, 9580316, 9857582, 8514433, 9, 6, 6614512, 753594, 5474165, 4, 2697293, 8, 7, 1]\\n\\n{\\'p1\\': 3606454, \\'p2\\': 6} [9, 452429, 7, 9580316, 9857582, 8514433, 9, 6, 6614512, 753594, 5474165, 4, 2697293, 8, 7, 1]\\n\\n{\\'p1\\': 3606454, \\'p2\\': 7} [9, 452429, 7, 9580316, 9857582, 8514433, 9, 6, 6614512, 753594, 5474165, 4, 2697293, 8, 7]\\n\\n{\\'p1\\': 3606461, \\'p2\\': 7} [9, 452429, 7, 9580316, 9857582, 8514433, 9, 6, 6614512, 753594, 5474165, 4, 2697293, 8]\\n\\n{\\'p1\\': 3606461, \\'p2\\': 16} [452429, 7, 9580316, 9857582, 8514433, 9, 6, 6614512, 753594, 5474165, 4, 2697293, 8]\\n\\n{\\'p1\\': 4058890, \\'p2\\': 16} [7, 9580316, 9857582, 8514433, 9, 6, 6614512, 753594, 5474165, 4, 2697293, 8]\\n\\n{\\'p1\\': 4058890, \\'p2\\': 24} [7, 9580316, 9857582, 8514433, 9, 6, 6614512, 753594, 5474165, 4, 2697293]\\n\\n{\\'p1\\': 6756183, \\'p2\\': 24} [7, 9580316, 9857582, 8514433, 9, 6, 6614512, 753594, 5474165, 4]\\n\\n{\\'p1\\': 6756183, \\'p2\\': 28} [7, 9580316, 9857582, 8514433, 9, 6, 6614512, 753594, 5474165]\\n\\n{\\'p1\\': 12230348, \\'p2\\': 28} [7, 9580316, 9857582, 8514433, 9, 6, 6614512, 753594]\\n\\n{\\'p1\\': 12230348, \\'p2\\': 753622} [7, 9580316, 9857582, 8514433, 9, 6, 6614512]\\n\\n{\\'p1\\': 18844860, \\'p2\\': 753622} [7, 9580316, 9857582, 8514433, 9, 6]\\n\\n{\\'p1\\': 18844860, \\'p2\\': 753628} [7, 9580316, 9857582, 8514433, 9]\\n\\n{\\'p1\\': 18844869, \\'p2\\': 753628} [7, 9580316, 9857582, 8514433]\\n\\n{\\'p1\\': 18844869, \\'p2\\': 9268061} [7, 9580316, 9857582]\\n\\n{\\'p1\\': 28702451, \\'p2\\': 9268061} [7, 9580316]\\n\\n{\\'p1\\': 28702451, \\'p2\\': 18848377} [7]\\n\\n{\\'p1\\': 28702458, \\'p2\\': 18848377} []\\n```\\n\\nSo I would expect the output to be true, but it isn\\'t. Why can\\'t player 1 win here?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The game played here is based on the Minimax algorithm, which is a kind of backtracking algorithm used in decision making and game theory to find the optimal move for a player, assuming that the opponent also plays optimally.\\n\\nIn your specific test case, even though Player 1 seems to have the upper hand at first glance due to higher score accumulation, the decision to pick the number is not based solely on the current highest available number. Instead, the algorithm looks ahead to evaluate potential future states of the game, trying to minimize the possible loss for a worst-case (maximum loss) scenario.\\n\\nThe selection of numbers for both players might seem counter-intuitive, but the decision-making process assumes that both players are playing optimally. This means that each player chooses their number not just based on the current state, but also on how their choice would influence the options available for the next player and, by extension, the options that would be available to themselves on the next round.\\n\\nThus, in some cases, a player might choose a lower number over a higher one because it leads to a future state where they would ultimately have the advantage.\\n\\nThe scenario you\\'ve posted shows the step-by-step decision-making process of the players under the Minimax algorithm, and it seems that even though Player 1 has more points throughout the game, Player 2 wins in the end when playing optimally. This is why the function returns `False`, meaning Player 1 (the first player to start the game) cannot win assuming both players play optimally."
                    },
                    {
                        "username": "dvijay96",
                        "content": "Could anyone please help me understand the fault in below approach.\\nApproach:-  I\\'m trying to find the max score each player can make by recursively making a choice to pick/not pick the 1st and the last element.\\n\\n `public boolean PredictTheWinner(int[] nums) {\\n        int[] winner = {0, 0};\\n        if(nums.length>1){\\n            LinkedList<Integer> list = new LinkedList<>();\\n\\n            for(int i : nums){\\n                list.add(i);\\n            }\\n\\n            simulateWinner(list, 0, 0, 1, winner);\\n        }\\n        return winner[0] >= winner[1];\\n    }\\n\\n    void simulateWinner(LinkedList<Integer> list, int score1, int score2,int player, int[] winner){\\n\\n        if(list.isEmpty()){\\n            winner[0] = Math.max(winner[0], score1);\\n            winner[1] = Math.max(winner[1], score2);\\n            return;\\n        }\\n\\n        if(player == 1){\\n            int num = list.pollFirst();\\n            simulateWinner(list, score1+num, score2, 2, winner);\\n            list.addFirst(num);\\n\\n            num = list.pollLast();\\n            simulateWinner(list, score1+num, score2, 2, winner);\\n            list.addLast(num);\\n        }else{\\n            int num = list.pollFirst();\\n            simulateWinner(list, score1, score2+num, 1, winner);\\n            list.addFirst(num);\\n\\n            num = list.pollLast();\\n            simulateWinner(list, score1, score2+num, 1, winner);\\n            list.addLast(num); \\n        }\\n    }`\\n\\nThanks in advance."
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach to recursively simulate both players picking the first and last numbers is a good start. However, there is a critical flaw in this approach. In a game where both players play optimally, each player, when making a choice, must consider not just the immediate gain, but also what the opponent will do in the next turn. In your code, each player only tries to maximize their own score in the current turn without considering the opponent\\'s possible moves in the next turn.\\n\\nIn your `simulateWinner` function, when a player chooses a number, you recursively call `simulateWinner` for the other player with the remaining numbers. However, the current player doesn\\'t take into consideration what the score would be after the other player makes their optimal move. \\n\\nTo fix this, you should change the function so that when a player is about to make a move, they consider both options (picking the first number and picking the last number), simulate the remaining game for both options (i.e., call `simulateWinner` twice for each option), and then choose the option that results in the maximum final score for themselves. \\n\\nTo do this, you need to change `simulateWinner` to return the final score difference (player 1\\'s score minus player 2\\'s score), and when simulating the game for each option, the current player should choose the option that maximizes this score difference. This is because a positive score difference means player 1 wins, and a negative score difference means player 2 wins.\\n\\nFinally, in `PredictTheWinner`, instead of checking if `winner[0] >= winner[1]`, you should check if the final score difference is greater than or equal to 0, as a non-negative score difference means player 1 can win or draw the game."
                    },
                    {
                        "username": "avneets2103",
                        "content": "oky gotta revise DP\\n"
                    },
                    {
                        "username": "satishvegisetti563",
                        "content": "Anyone please list out similar problems"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "some of the Stone game problems are all somewhat similar to this, and the game theory tag gives you all problems that are games, some of those are quite similar too"
                    },
                    {
                        "username": "7h3w17ch3r",
                        "content": "Cisco OA?\\n"
                    }
                ]
            },
            {
                "id": 1990923,
                "content": [
                    {
                        "username": "user4262O",
                        "content": "for Java if got compile error, you need to change PredictTheWinner to predictTheWinner"
                    },
                    {
                        "username": "guyses",
                        "content": "what does `optimally` means in this question?\\n\\nin this test case - [2,4,55,6,8]\\nplayer1 can win, but the expected answer is `false`\\nplayer1 wins like this\\n\\nplayer1 take `2`\\nplayer2 takes `4`\\nplayer1 takes `55`\\nplayer2 takes `8`\\nplayer1 takes `6`\\n\\nin the end player1 = 2 + 55 + 6  > player2 = 4 + 8\\n\\nthere\\'s a reasoning to this, that i can think of, \\nwhy would player2 want to give the highest number in the array to player1? -> Is this what `optimally` means?"
                    },
                    {
                        "username": "dheeraj2002_",
                        "content": "Optimally doesn\\'t mean that at each step the player would be taking the biggest of the two, but to increase it\\'s score and decrease other person\\'s score. Watch min-max algorithm and it will help you to apply the logic more efficiently"
                    },
                    {
                        "username": "dikshawali",
                        "content": "I didn\\'t get it...in case of [1,5,2]\\nif player 1 chooses 1,\\nthen player 2 chooses 2,\\nafter which player1 chooses 5 making his score 6. Means there is one of the many ways in which player1 can become winner.\\nI am not sure why in each case player 2 is going to choose 5 to maximize his score, while player 1\\n\\nWhat I mean to say is - \\n[1,5,2]\\nplayer1 has been given 2 possibilities of choosing either 1 or 2. He doesnt care which one is bigger\\nwhile player2 cares, he always chooses 5. Why so? \\nCan anyone explain me this? Help will be appreciated."
                    },
                    {
                        "username": "huke0906",
                        "content": "So what does \"optimally\" mean? This problem seems poorly defined."
                    },
                    {
                        "username": "huke0906",
                        "content": "[@dheeraj2002_](/dheeraj2002_) Thank you! Now I see."
                    },
                    {
                        "username": "dheeraj2002_",
                        "content": "optimally means they will play to win, i.e. at each step the player will try to score such that it impacts his score as well as the score of the second player. Meaning a person may select a lesser score at a step but would do so to keep the higher score out of the range of the second player. I advice you to watch min-max algorithm for more insight to the problem. Also it is important not to confuse optimally with optimally per steps."
                    },
                    {
                        "username": "Zefick",
                        "content": "It's sad that so many people come up with a solution that runs in Python for more than 5 seconds.\nThe array is too small, so they were too lazy to optimize their exponential solutions even a little bit after they've been accepted."
                    },
                    {
                        "username": "Aaronearlerichardson",
                        "content": "Confused about a test case here:\\n\\n ```\\nnums = [3606449,6,5,9,452429,7,9580316,9857582,8514433,9,6,6614512,753594,5474165,4,2697293,8,7,1]\\n\\n{\\'p1\\': 3606449, \\'p2\\': 0} [6, 5, 9, 452429, 7, 9580316, 9857582, 8514433, 9, 6, 6614512, 753594, 5474165, 4, 2697293, 8, 7, 1]\\n\\n{\\'p1\\': 3606449, \\'p2\\': 6} [5, 9, 452429, 7, 9580316, 9857582, 8514433, 9, 6, 6614512, 753594, 5474165, 4, 2697293, 8, 7, 1]\\n\\n{\\'p1\\': 3606454, \\'p2\\': 6} [9, 452429, 7, 9580316, 9857582, 8514433, 9, 6, 6614512, 753594, 5474165, 4, 2697293, 8, 7, 1]\\n\\n{\\'p1\\': 3606454, \\'p2\\': 7} [9, 452429, 7, 9580316, 9857582, 8514433, 9, 6, 6614512, 753594, 5474165, 4, 2697293, 8, 7]\\n\\n{\\'p1\\': 3606461, \\'p2\\': 7} [9, 452429, 7, 9580316, 9857582, 8514433, 9, 6, 6614512, 753594, 5474165, 4, 2697293, 8]\\n\\n{\\'p1\\': 3606461, \\'p2\\': 16} [452429, 7, 9580316, 9857582, 8514433, 9, 6, 6614512, 753594, 5474165, 4, 2697293, 8]\\n\\n{\\'p1\\': 4058890, \\'p2\\': 16} [7, 9580316, 9857582, 8514433, 9, 6, 6614512, 753594, 5474165, 4, 2697293, 8]\\n\\n{\\'p1\\': 4058890, \\'p2\\': 24} [7, 9580316, 9857582, 8514433, 9, 6, 6614512, 753594, 5474165, 4, 2697293]\\n\\n{\\'p1\\': 6756183, \\'p2\\': 24} [7, 9580316, 9857582, 8514433, 9, 6, 6614512, 753594, 5474165, 4]\\n\\n{\\'p1\\': 6756183, \\'p2\\': 28} [7, 9580316, 9857582, 8514433, 9, 6, 6614512, 753594, 5474165]\\n\\n{\\'p1\\': 12230348, \\'p2\\': 28} [7, 9580316, 9857582, 8514433, 9, 6, 6614512, 753594]\\n\\n{\\'p1\\': 12230348, \\'p2\\': 753622} [7, 9580316, 9857582, 8514433, 9, 6, 6614512]\\n\\n{\\'p1\\': 18844860, \\'p2\\': 753622} [7, 9580316, 9857582, 8514433, 9, 6]\\n\\n{\\'p1\\': 18844860, \\'p2\\': 753628} [7, 9580316, 9857582, 8514433, 9]\\n\\n{\\'p1\\': 18844869, \\'p2\\': 753628} [7, 9580316, 9857582, 8514433]\\n\\n{\\'p1\\': 18844869, \\'p2\\': 9268061} [7, 9580316, 9857582]\\n\\n{\\'p1\\': 28702451, \\'p2\\': 9268061} [7, 9580316]\\n\\n{\\'p1\\': 28702451, \\'p2\\': 18848377} [7]\\n\\n{\\'p1\\': 28702458, \\'p2\\': 18848377} []\\n```\\n\\nSo I would expect the output to be true, but it isn\\'t. Why can\\'t player 1 win here?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The game played here is based on the Minimax algorithm, which is a kind of backtracking algorithm used in decision making and game theory to find the optimal move for a player, assuming that the opponent also plays optimally.\\n\\nIn your specific test case, even though Player 1 seems to have the upper hand at first glance due to higher score accumulation, the decision to pick the number is not based solely on the current highest available number. Instead, the algorithm looks ahead to evaluate potential future states of the game, trying to minimize the possible loss for a worst-case (maximum loss) scenario.\\n\\nThe selection of numbers for both players might seem counter-intuitive, but the decision-making process assumes that both players are playing optimally. This means that each player chooses their number not just based on the current state, but also on how their choice would influence the options available for the next player and, by extension, the options that would be available to themselves on the next round.\\n\\nThus, in some cases, a player might choose a lower number over a higher one because it leads to a future state where they would ultimately have the advantage.\\n\\nThe scenario you\\'ve posted shows the step-by-step decision-making process of the players under the Minimax algorithm, and it seems that even though Player 1 has more points throughout the game, Player 2 wins in the end when playing optimally. This is why the function returns `False`, meaning Player 1 (the first player to start the game) cannot win assuming both players play optimally."
                    },
                    {
                        "username": "dvijay96",
                        "content": "Could anyone please help me understand the fault in below approach.\\nApproach:-  I\\'m trying to find the max score each player can make by recursively making a choice to pick/not pick the 1st and the last element.\\n\\n `public boolean PredictTheWinner(int[] nums) {\\n        int[] winner = {0, 0};\\n        if(nums.length>1){\\n            LinkedList<Integer> list = new LinkedList<>();\\n\\n            for(int i : nums){\\n                list.add(i);\\n            }\\n\\n            simulateWinner(list, 0, 0, 1, winner);\\n        }\\n        return winner[0] >= winner[1];\\n    }\\n\\n    void simulateWinner(LinkedList<Integer> list, int score1, int score2,int player, int[] winner){\\n\\n        if(list.isEmpty()){\\n            winner[0] = Math.max(winner[0], score1);\\n            winner[1] = Math.max(winner[1], score2);\\n            return;\\n        }\\n\\n        if(player == 1){\\n            int num = list.pollFirst();\\n            simulateWinner(list, score1+num, score2, 2, winner);\\n            list.addFirst(num);\\n\\n            num = list.pollLast();\\n            simulateWinner(list, score1+num, score2, 2, winner);\\n            list.addLast(num);\\n        }else{\\n            int num = list.pollFirst();\\n            simulateWinner(list, score1, score2+num, 1, winner);\\n            list.addFirst(num);\\n\\n            num = list.pollLast();\\n            simulateWinner(list, score1, score2+num, 1, winner);\\n            list.addLast(num); \\n        }\\n    }`\\n\\nThanks in advance."
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach to recursively simulate both players picking the first and last numbers is a good start. However, there is a critical flaw in this approach. In a game where both players play optimally, each player, when making a choice, must consider not just the immediate gain, but also what the opponent will do in the next turn. In your code, each player only tries to maximize their own score in the current turn without considering the opponent\\'s possible moves in the next turn.\\n\\nIn your `simulateWinner` function, when a player chooses a number, you recursively call `simulateWinner` for the other player with the remaining numbers. However, the current player doesn\\'t take into consideration what the score would be after the other player makes their optimal move. \\n\\nTo fix this, you should change the function so that when a player is about to make a move, they consider both options (picking the first number and picking the last number), simulate the remaining game for both options (i.e., call `simulateWinner` twice for each option), and then choose the option that results in the maximum final score for themselves. \\n\\nTo do this, you need to change `simulateWinner` to return the final score difference (player 1\\'s score minus player 2\\'s score), and when simulating the game for each option, the current player should choose the option that maximizes this score difference. This is because a positive score difference means player 1 wins, and a negative score difference means player 2 wins.\\n\\nFinally, in `PredictTheWinner`, instead of checking if `winner[0] >= winner[1]`, you should check if the final score difference is greater than or equal to 0, as a non-negative score difference means player 1 can win or draw the game."
                    },
                    {
                        "username": "avneets2103",
                        "content": "oky gotta revise DP\\n"
                    },
                    {
                        "username": "satishvegisetti563",
                        "content": "Anyone please list out similar problems"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "some of the Stone game problems are all somewhat similar to this, and the game theory tag gives you all problems that are games, some of those are quite similar too"
                    },
                    {
                        "username": "7h3w17ch3r",
                        "content": "Cisco OA?\\n"
                    }
                ]
            },
            {
                "id": 1990812,
                "content": [
                    {
                        "username": "user4262O",
                        "content": "for Java if got compile error, you need to change PredictTheWinner to predictTheWinner"
                    },
                    {
                        "username": "guyses",
                        "content": "what does `optimally` means in this question?\\n\\nin this test case - [2,4,55,6,8]\\nplayer1 can win, but the expected answer is `false`\\nplayer1 wins like this\\n\\nplayer1 take `2`\\nplayer2 takes `4`\\nplayer1 takes `55`\\nplayer2 takes `8`\\nplayer1 takes `6`\\n\\nin the end player1 = 2 + 55 + 6  > player2 = 4 + 8\\n\\nthere\\'s a reasoning to this, that i can think of, \\nwhy would player2 want to give the highest number in the array to player1? -> Is this what `optimally` means?"
                    },
                    {
                        "username": "dheeraj2002_",
                        "content": "Optimally doesn\\'t mean that at each step the player would be taking the biggest of the two, but to increase it\\'s score and decrease other person\\'s score. Watch min-max algorithm and it will help you to apply the logic more efficiently"
                    },
                    {
                        "username": "dikshawali",
                        "content": "I didn\\'t get it...in case of [1,5,2]\\nif player 1 chooses 1,\\nthen player 2 chooses 2,\\nafter which player1 chooses 5 making his score 6. Means there is one of the many ways in which player1 can become winner.\\nI am not sure why in each case player 2 is going to choose 5 to maximize his score, while player 1\\n\\nWhat I mean to say is - \\n[1,5,2]\\nplayer1 has been given 2 possibilities of choosing either 1 or 2. He doesnt care which one is bigger\\nwhile player2 cares, he always chooses 5. Why so? \\nCan anyone explain me this? Help will be appreciated."
                    },
                    {
                        "username": "huke0906",
                        "content": "So what does \"optimally\" mean? This problem seems poorly defined."
                    },
                    {
                        "username": "huke0906",
                        "content": "[@dheeraj2002_](/dheeraj2002_) Thank you! Now I see."
                    },
                    {
                        "username": "dheeraj2002_",
                        "content": "optimally means they will play to win, i.e. at each step the player will try to score such that it impacts his score as well as the score of the second player. Meaning a person may select a lesser score at a step but would do so to keep the higher score out of the range of the second player. I advice you to watch min-max algorithm for more insight to the problem. Also it is important not to confuse optimally with optimally per steps."
                    },
                    {
                        "username": "Zefick",
                        "content": "It's sad that so many people come up with a solution that runs in Python for more than 5 seconds.\nThe array is too small, so they were too lazy to optimize their exponential solutions even a little bit after they've been accepted."
                    },
                    {
                        "username": "Aaronearlerichardson",
                        "content": "Confused about a test case here:\\n\\n ```\\nnums = [3606449,6,5,9,452429,7,9580316,9857582,8514433,9,6,6614512,753594,5474165,4,2697293,8,7,1]\\n\\n{\\'p1\\': 3606449, \\'p2\\': 0} [6, 5, 9, 452429, 7, 9580316, 9857582, 8514433, 9, 6, 6614512, 753594, 5474165, 4, 2697293, 8, 7, 1]\\n\\n{\\'p1\\': 3606449, \\'p2\\': 6} [5, 9, 452429, 7, 9580316, 9857582, 8514433, 9, 6, 6614512, 753594, 5474165, 4, 2697293, 8, 7, 1]\\n\\n{\\'p1\\': 3606454, \\'p2\\': 6} [9, 452429, 7, 9580316, 9857582, 8514433, 9, 6, 6614512, 753594, 5474165, 4, 2697293, 8, 7, 1]\\n\\n{\\'p1\\': 3606454, \\'p2\\': 7} [9, 452429, 7, 9580316, 9857582, 8514433, 9, 6, 6614512, 753594, 5474165, 4, 2697293, 8, 7]\\n\\n{\\'p1\\': 3606461, \\'p2\\': 7} [9, 452429, 7, 9580316, 9857582, 8514433, 9, 6, 6614512, 753594, 5474165, 4, 2697293, 8]\\n\\n{\\'p1\\': 3606461, \\'p2\\': 16} [452429, 7, 9580316, 9857582, 8514433, 9, 6, 6614512, 753594, 5474165, 4, 2697293, 8]\\n\\n{\\'p1\\': 4058890, \\'p2\\': 16} [7, 9580316, 9857582, 8514433, 9, 6, 6614512, 753594, 5474165, 4, 2697293, 8]\\n\\n{\\'p1\\': 4058890, \\'p2\\': 24} [7, 9580316, 9857582, 8514433, 9, 6, 6614512, 753594, 5474165, 4, 2697293]\\n\\n{\\'p1\\': 6756183, \\'p2\\': 24} [7, 9580316, 9857582, 8514433, 9, 6, 6614512, 753594, 5474165, 4]\\n\\n{\\'p1\\': 6756183, \\'p2\\': 28} [7, 9580316, 9857582, 8514433, 9, 6, 6614512, 753594, 5474165]\\n\\n{\\'p1\\': 12230348, \\'p2\\': 28} [7, 9580316, 9857582, 8514433, 9, 6, 6614512, 753594]\\n\\n{\\'p1\\': 12230348, \\'p2\\': 753622} [7, 9580316, 9857582, 8514433, 9, 6, 6614512]\\n\\n{\\'p1\\': 18844860, \\'p2\\': 753622} [7, 9580316, 9857582, 8514433, 9, 6]\\n\\n{\\'p1\\': 18844860, \\'p2\\': 753628} [7, 9580316, 9857582, 8514433, 9]\\n\\n{\\'p1\\': 18844869, \\'p2\\': 753628} [7, 9580316, 9857582, 8514433]\\n\\n{\\'p1\\': 18844869, \\'p2\\': 9268061} [7, 9580316, 9857582]\\n\\n{\\'p1\\': 28702451, \\'p2\\': 9268061} [7, 9580316]\\n\\n{\\'p1\\': 28702451, \\'p2\\': 18848377} [7]\\n\\n{\\'p1\\': 28702458, \\'p2\\': 18848377} []\\n```\\n\\nSo I would expect the output to be true, but it isn\\'t. Why can\\'t player 1 win here?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The game played here is based on the Minimax algorithm, which is a kind of backtracking algorithm used in decision making and game theory to find the optimal move for a player, assuming that the opponent also plays optimally.\\n\\nIn your specific test case, even though Player 1 seems to have the upper hand at first glance due to higher score accumulation, the decision to pick the number is not based solely on the current highest available number. Instead, the algorithm looks ahead to evaluate potential future states of the game, trying to minimize the possible loss for a worst-case (maximum loss) scenario.\\n\\nThe selection of numbers for both players might seem counter-intuitive, but the decision-making process assumes that both players are playing optimally. This means that each player chooses their number not just based on the current state, but also on how their choice would influence the options available for the next player and, by extension, the options that would be available to themselves on the next round.\\n\\nThus, in some cases, a player might choose a lower number over a higher one because it leads to a future state where they would ultimately have the advantage.\\n\\nThe scenario you\\'ve posted shows the step-by-step decision-making process of the players under the Minimax algorithm, and it seems that even though Player 1 has more points throughout the game, Player 2 wins in the end when playing optimally. This is why the function returns `False`, meaning Player 1 (the first player to start the game) cannot win assuming both players play optimally."
                    },
                    {
                        "username": "dvijay96",
                        "content": "Could anyone please help me understand the fault in below approach.\\nApproach:-  I\\'m trying to find the max score each player can make by recursively making a choice to pick/not pick the 1st and the last element.\\n\\n `public boolean PredictTheWinner(int[] nums) {\\n        int[] winner = {0, 0};\\n        if(nums.length>1){\\n            LinkedList<Integer> list = new LinkedList<>();\\n\\n            for(int i : nums){\\n                list.add(i);\\n            }\\n\\n            simulateWinner(list, 0, 0, 1, winner);\\n        }\\n        return winner[0] >= winner[1];\\n    }\\n\\n    void simulateWinner(LinkedList<Integer> list, int score1, int score2,int player, int[] winner){\\n\\n        if(list.isEmpty()){\\n            winner[0] = Math.max(winner[0], score1);\\n            winner[1] = Math.max(winner[1], score2);\\n            return;\\n        }\\n\\n        if(player == 1){\\n            int num = list.pollFirst();\\n            simulateWinner(list, score1+num, score2, 2, winner);\\n            list.addFirst(num);\\n\\n            num = list.pollLast();\\n            simulateWinner(list, score1+num, score2, 2, winner);\\n            list.addLast(num);\\n        }else{\\n            int num = list.pollFirst();\\n            simulateWinner(list, score1, score2+num, 1, winner);\\n            list.addFirst(num);\\n\\n            num = list.pollLast();\\n            simulateWinner(list, score1, score2+num, 1, winner);\\n            list.addLast(num); \\n        }\\n    }`\\n\\nThanks in advance."
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach to recursively simulate both players picking the first and last numbers is a good start. However, there is a critical flaw in this approach. In a game where both players play optimally, each player, when making a choice, must consider not just the immediate gain, but also what the opponent will do in the next turn. In your code, each player only tries to maximize their own score in the current turn without considering the opponent\\'s possible moves in the next turn.\\n\\nIn your `simulateWinner` function, when a player chooses a number, you recursively call `simulateWinner` for the other player with the remaining numbers. However, the current player doesn\\'t take into consideration what the score would be after the other player makes their optimal move. \\n\\nTo fix this, you should change the function so that when a player is about to make a move, they consider both options (picking the first number and picking the last number), simulate the remaining game for both options (i.e., call `simulateWinner` twice for each option), and then choose the option that results in the maximum final score for themselves. \\n\\nTo do this, you need to change `simulateWinner` to return the final score difference (player 1\\'s score minus player 2\\'s score), and when simulating the game for each option, the current player should choose the option that maximizes this score difference. This is because a positive score difference means player 1 wins, and a negative score difference means player 2 wins.\\n\\nFinally, in `PredictTheWinner`, instead of checking if `winner[0] >= winner[1]`, you should check if the final score difference is greater than or equal to 0, as a non-negative score difference means player 1 can win or draw the game."
                    },
                    {
                        "username": "avneets2103",
                        "content": "oky gotta revise DP\\n"
                    },
                    {
                        "username": "satishvegisetti563",
                        "content": "Anyone please list out similar problems"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "some of the Stone game problems are all somewhat similar to this, and the game theory tag gives you all problems that are games, some of those are quite similar too"
                    },
                    {
                        "username": "7h3w17ch3r",
                        "content": "Cisco OA?\\n"
                    }
                ]
            },
            {
                "id": 1990683,
                "content": [
                    {
                        "username": "user4262O",
                        "content": "for Java if got compile error, you need to change PredictTheWinner to predictTheWinner"
                    },
                    {
                        "username": "guyses",
                        "content": "what does `optimally` means in this question?\\n\\nin this test case - [2,4,55,6,8]\\nplayer1 can win, but the expected answer is `false`\\nplayer1 wins like this\\n\\nplayer1 take `2`\\nplayer2 takes `4`\\nplayer1 takes `55`\\nplayer2 takes `8`\\nplayer1 takes `6`\\n\\nin the end player1 = 2 + 55 + 6  > player2 = 4 + 8\\n\\nthere\\'s a reasoning to this, that i can think of, \\nwhy would player2 want to give the highest number in the array to player1? -> Is this what `optimally` means?"
                    },
                    {
                        "username": "dheeraj2002_",
                        "content": "Optimally doesn\\'t mean that at each step the player would be taking the biggest of the two, but to increase it\\'s score and decrease other person\\'s score. Watch min-max algorithm and it will help you to apply the logic more efficiently"
                    },
                    {
                        "username": "dikshawali",
                        "content": "I didn\\'t get it...in case of [1,5,2]\\nif player 1 chooses 1,\\nthen player 2 chooses 2,\\nafter which player1 chooses 5 making his score 6. Means there is one of the many ways in which player1 can become winner.\\nI am not sure why in each case player 2 is going to choose 5 to maximize his score, while player 1\\n\\nWhat I mean to say is - \\n[1,5,2]\\nplayer1 has been given 2 possibilities of choosing either 1 or 2. He doesnt care which one is bigger\\nwhile player2 cares, he always chooses 5. Why so? \\nCan anyone explain me this? Help will be appreciated."
                    },
                    {
                        "username": "huke0906",
                        "content": "So what does \"optimally\" mean? This problem seems poorly defined."
                    },
                    {
                        "username": "huke0906",
                        "content": "[@dheeraj2002_](/dheeraj2002_) Thank you! Now I see."
                    },
                    {
                        "username": "dheeraj2002_",
                        "content": "optimally means they will play to win, i.e. at each step the player will try to score such that it impacts his score as well as the score of the second player. Meaning a person may select a lesser score at a step but would do so to keep the higher score out of the range of the second player. I advice you to watch min-max algorithm for more insight to the problem. Also it is important not to confuse optimally with optimally per steps."
                    },
                    {
                        "username": "Zefick",
                        "content": "It's sad that so many people come up with a solution that runs in Python for more than 5 seconds.\nThe array is too small, so they were too lazy to optimize their exponential solutions even a little bit after they've been accepted."
                    },
                    {
                        "username": "Aaronearlerichardson",
                        "content": "Confused about a test case here:\\n\\n ```\\nnums = [3606449,6,5,9,452429,7,9580316,9857582,8514433,9,6,6614512,753594,5474165,4,2697293,8,7,1]\\n\\n{\\'p1\\': 3606449, \\'p2\\': 0} [6, 5, 9, 452429, 7, 9580316, 9857582, 8514433, 9, 6, 6614512, 753594, 5474165, 4, 2697293, 8, 7, 1]\\n\\n{\\'p1\\': 3606449, \\'p2\\': 6} [5, 9, 452429, 7, 9580316, 9857582, 8514433, 9, 6, 6614512, 753594, 5474165, 4, 2697293, 8, 7, 1]\\n\\n{\\'p1\\': 3606454, \\'p2\\': 6} [9, 452429, 7, 9580316, 9857582, 8514433, 9, 6, 6614512, 753594, 5474165, 4, 2697293, 8, 7, 1]\\n\\n{\\'p1\\': 3606454, \\'p2\\': 7} [9, 452429, 7, 9580316, 9857582, 8514433, 9, 6, 6614512, 753594, 5474165, 4, 2697293, 8, 7]\\n\\n{\\'p1\\': 3606461, \\'p2\\': 7} [9, 452429, 7, 9580316, 9857582, 8514433, 9, 6, 6614512, 753594, 5474165, 4, 2697293, 8]\\n\\n{\\'p1\\': 3606461, \\'p2\\': 16} [452429, 7, 9580316, 9857582, 8514433, 9, 6, 6614512, 753594, 5474165, 4, 2697293, 8]\\n\\n{\\'p1\\': 4058890, \\'p2\\': 16} [7, 9580316, 9857582, 8514433, 9, 6, 6614512, 753594, 5474165, 4, 2697293, 8]\\n\\n{\\'p1\\': 4058890, \\'p2\\': 24} [7, 9580316, 9857582, 8514433, 9, 6, 6614512, 753594, 5474165, 4, 2697293]\\n\\n{\\'p1\\': 6756183, \\'p2\\': 24} [7, 9580316, 9857582, 8514433, 9, 6, 6614512, 753594, 5474165, 4]\\n\\n{\\'p1\\': 6756183, \\'p2\\': 28} [7, 9580316, 9857582, 8514433, 9, 6, 6614512, 753594, 5474165]\\n\\n{\\'p1\\': 12230348, \\'p2\\': 28} [7, 9580316, 9857582, 8514433, 9, 6, 6614512, 753594]\\n\\n{\\'p1\\': 12230348, \\'p2\\': 753622} [7, 9580316, 9857582, 8514433, 9, 6, 6614512]\\n\\n{\\'p1\\': 18844860, \\'p2\\': 753622} [7, 9580316, 9857582, 8514433, 9, 6]\\n\\n{\\'p1\\': 18844860, \\'p2\\': 753628} [7, 9580316, 9857582, 8514433, 9]\\n\\n{\\'p1\\': 18844869, \\'p2\\': 753628} [7, 9580316, 9857582, 8514433]\\n\\n{\\'p1\\': 18844869, \\'p2\\': 9268061} [7, 9580316, 9857582]\\n\\n{\\'p1\\': 28702451, \\'p2\\': 9268061} [7, 9580316]\\n\\n{\\'p1\\': 28702451, \\'p2\\': 18848377} [7]\\n\\n{\\'p1\\': 28702458, \\'p2\\': 18848377} []\\n```\\n\\nSo I would expect the output to be true, but it isn\\'t. Why can\\'t player 1 win here?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The game played here is based on the Minimax algorithm, which is a kind of backtracking algorithm used in decision making and game theory to find the optimal move for a player, assuming that the opponent also plays optimally.\\n\\nIn your specific test case, even though Player 1 seems to have the upper hand at first glance due to higher score accumulation, the decision to pick the number is not based solely on the current highest available number. Instead, the algorithm looks ahead to evaluate potential future states of the game, trying to minimize the possible loss for a worst-case (maximum loss) scenario.\\n\\nThe selection of numbers for both players might seem counter-intuitive, but the decision-making process assumes that both players are playing optimally. This means that each player chooses their number not just based on the current state, but also on how their choice would influence the options available for the next player and, by extension, the options that would be available to themselves on the next round.\\n\\nThus, in some cases, a player might choose a lower number over a higher one because it leads to a future state where they would ultimately have the advantage.\\n\\nThe scenario you\\'ve posted shows the step-by-step decision-making process of the players under the Minimax algorithm, and it seems that even though Player 1 has more points throughout the game, Player 2 wins in the end when playing optimally. This is why the function returns `False`, meaning Player 1 (the first player to start the game) cannot win assuming both players play optimally."
                    },
                    {
                        "username": "dvijay96",
                        "content": "Could anyone please help me understand the fault in below approach.\\nApproach:-  I\\'m trying to find the max score each player can make by recursively making a choice to pick/not pick the 1st and the last element.\\n\\n `public boolean PredictTheWinner(int[] nums) {\\n        int[] winner = {0, 0};\\n        if(nums.length>1){\\n            LinkedList<Integer> list = new LinkedList<>();\\n\\n            for(int i : nums){\\n                list.add(i);\\n            }\\n\\n            simulateWinner(list, 0, 0, 1, winner);\\n        }\\n        return winner[0] >= winner[1];\\n    }\\n\\n    void simulateWinner(LinkedList<Integer> list, int score1, int score2,int player, int[] winner){\\n\\n        if(list.isEmpty()){\\n            winner[0] = Math.max(winner[0], score1);\\n            winner[1] = Math.max(winner[1], score2);\\n            return;\\n        }\\n\\n        if(player == 1){\\n            int num = list.pollFirst();\\n            simulateWinner(list, score1+num, score2, 2, winner);\\n            list.addFirst(num);\\n\\n            num = list.pollLast();\\n            simulateWinner(list, score1+num, score2, 2, winner);\\n            list.addLast(num);\\n        }else{\\n            int num = list.pollFirst();\\n            simulateWinner(list, score1, score2+num, 1, winner);\\n            list.addFirst(num);\\n\\n            num = list.pollLast();\\n            simulateWinner(list, score1, score2+num, 1, winner);\\n            list.addLast(num); \\n        }\\n    }`\\n\\nThanks in advance."
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach to recursively simulate both players picking the first and last numbers is a good start. However, there is a critical flaw in this approach. In a game where both players play optimally, each player, when making a choice, must consider not just the immediate gain, but also what the opponent will do in the next turn. In your code, each player only tries to maximize their own score in the current turn without considering the opponent\\'s possible moves in the next turn.\\n\\nIn your `simulateWinner` function, when a player chooses a number, you recursively call `simulateWinner` for the other player with the remaining numbers. However, the current player doesn\\'t take into consideration what the score would be after the other player makes their optimal move. \\n\\nTo fix this, you should change the function so that when a player is about to make a move, they consider both options (picking the first number and picking the last number), simulate the remaining game for both options (i.e., call `simulateWinner` twice for each option), and then choose the option that results in the maximum final score for themselves. \\n\\nTo do this, you need to change `simulateWinner` to return the final score difference (player 1\\'s score minus player 2\\'s score), and when simulating the game for each option, the current player should choose the option that maximizes this score difference. This is because a positive score difference means player 1 wins, and a negative score difference means player 2 wins.\\n\\nFinally, in `PredictTheWinner`, instead of checking if `winner[0] >= winner[1]`, you should check if the final score difference is greater than or equal to 0, as a non-negative score difference means player 1 can win or draw the game."
                    },
                    {
                        "username": "avneets2103",
                        "content": "oky gotta revise DP\\n"
                    },
                    {
                        "username": "satishvegisetti563",
                        "content": "Anyone please list out similar problems"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "some of the Stone game problems are all somewhat similar to this, and the game theory tag gives you all problems that are games, some of those are quite similar too"
                    },
                    {
                        "username": "7h3w17ch3r",
                        "content": "Cisco OA?\\n"
                    }
                ]
            },
            {
                "id": 1990606,
                "content": [
                    {
                        "username": "user4262O",
                        "content": "for Java if got compile error, you need to change PredictTheWinner to predictTheWinner"
                    },
                    {
                        "username": "guyses",
                        "content": "what does `optimally` means in this question?\\n\\nin this test case - [2,4,55,6,8]\\nplayer1 can win, but the expected answer is `false`\\nplayer1 wins like this\\n\\nplayer1 take `2`\\nplayer2 takes `4`\\nplayer1 takes `55`\\nplayer2 takes `8`\\nplayer1 takes `6`\\n\\nin the end player1 = 2 + 55 + 6  > player2 = 4 + 8\\n\\nthere\\'s a reasoning to this, that i can think of, \\nwhy would player2 want to give the highest number in the array to player1? -> Is this what `optimally` means?"
                    },
                    {
                        "username": "dheeraj2002_",
                        "content": "Optimally doesn\\'t mean that at each step the player would be taking the biggest of the two, but to increase it\\'s score and decrease other person\\'s score. Watch min-max algorithm and it will help you to apply the logic more efficiently"
                    },
                    {
                        "username": "dikshawali",
                        "content": "I didn\\'t get it...in case of [1,5,2]\\nif player 1 chooses 1,\\nthen player 2 chooses 2,\\nafter which player1 chooses 5 making his score 6. Means there is one of the many ways in which player1 can become winner.\\nI am not sure why in each case player 2 is going to choose 5 to maximize his score, while player 1\\n\\nWhat I mean to say is - \\n[1,5,2]\\nplayer1 has been given 2 possibilities of choosing either 1 or 2. He doesnt care which one is bigger\\nwhile player2 cares, he always chooses 5. Why so? \\nCan anyone explain me this? Help will be appreciated."
                    },
                    {
                        "username": "huke0906",
                        "content": "So what does \"optimally\" mean? This problem seems poorly defined."
                    },
                    {
                        "username": "huke0906",
                        "content": "[@dheeraj2002_](/dheeraj2002_) Thank you! Now I see."
                    },
                    {
                        "username": "dheeraj2002_",
                        "content": "optimally means they will play to win, i.e. at each step the player will try to score such that it impacts his score as well as the score of the second player. Meaning a person may select a lesser score at a step but would do so to keep the higher score out of the range of the second player. I advice you to watch min-max algorithm for more insight to the problem. Also it is important not to confuse optimally with optimally per steps."
                    },
                    {
                        "username": "Zefick",
                        "content": "It's sad that so many people come up with a solution that runs in Python for more than 5 seconds.\nThe array is too small, so they were too lazy to optimize their exponential solutions even a little bit after they've been accepted."
                    },
                    {
                        "username": "Aaronearlerichardson",
                        "content": "Confused about a test case here:\\n\\n ```\\nnums = [3606449,6,5,9,452429,7,9580316,9857582,8514433,9,6,6614512,753594,5474165,4,2697293,8,7,1]\\n\\n{\\'p1\\': 3606449, \\'p2\\': 0} [6, 5, 9, 452429, 7, 9580316, 9857582, 8514433, 9, 6, 6614512, 753594, 5474165, 4, 2697293, 8, 7, 1]\\n\\n{\\'p1\\': 3606449, \\'p2\\': 6} [5, 9, 452429, 7, 9580316, 9857582, 8514433, 9, 6, 6614512, 753594, 5474165, 4, 2697293, 8, 7, 1]\\n\\n{\\'p1\\': 3606454, \\'p2\\': 6} [9, 452429, 7, 9580316, 9857582, 8514433, 9, 6, 6614512, 753594, 5474165, 4, 2697293, 8, 7, 1]\\n\\n{\\'p1\\': 3606454, \\'p2\\': 7} [9, 452429, 7, 9580316, 9857582, 8514433, 9, 6, 6614512, 753594, 5474165, 4, 2697293, 8, 7]\\n\\n{\\'p1\\': 3606461, \\'p2\\': 7} [9, 452429, 7, 9580316, 9857582, 8514433, 9, 6, 6614512, 753594, 5474165, 4, 2697293, 8]\\n\\n{\\'p1\\': 3606461, \\'p2\\': 16} [452429, 7, 9580316, 9857582, 8514433, 9, 6, 6614512, 753594, 5474165, 4, 2697293, 8]\\n\\n{\\'p1\\': 4058890, \\'p2\\': 16} [7, 9580316, 9857582, 8514433, 9, 6, 6614512, 753594, 5474165, 4, 2697293, 8]\\n\\n{\\'p1\\': 4058890, \\'p2\\': 24} [7, 9580316, 9857582, 8514433, 9, 6, 6614512, 753594, 5474165, 4, 2697293]\\n\\n{\\'p1\\': 6756183, \\'p2\\': 24} [7, 9580316, 9857582, 8514433, 9, 6, 6614512, 753594, 5474165, 4]\\n\\n{\\'p1\\': 6756183, \\'p2\\': 28} [7, 9580316, 9857582, 8514433, 9, 6, 6614512, 753594, 5474165]\\n\\n{\\'p1\\': 12230348, \\'p2\\': 28} [7, 9580316, 9857582, 8514433, 9, 6, 6614512, 753594]\\n\\n{\\'p1\\': 12230348, \\'p2\\': 753622} [7, 9580316, 9857582, 8514433, 9, 6, 6614512]\\n\\n{\\'p1\\': 18844860, \\'p2\\': 753622} [7, 9580316, 9857582, 8514433, 9, 6]\\n\\n{\\'p1\\': 18844860, \\'p2\\': 753628} [7, 9580316, 9857582, 8514433, 9]\\n\\n{\\'p1\\': 18844869, \\'p2\\': 753628} [7, 9580316, 9857582, 8514433]\\n\\n{\\'p1\\': 18844869, \\'p2\\': 9268061} [7, 9580316, 9857582]\\n\\n{\\'p1\\': 28702451, \\'p2\\': 9268061} [7, 9580316]\\n\\n{\\'p1\\': 28702451, \\'p2\\': 18848377} [7]\\n\\n{\\'p1\\': 28702458, \\'p2\\': 18848377} []\\n```\\n\\nSo I would expect the output to be true, but it isn\\'t. Why can\\'t player 1 win here?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The game played here is based on the Minimax algorithm, which is a kind of backtracking algorithm used in decision making and game theory to find the optimal move for a player, assuming that the opponent also plays optimally.\\n\\nIn your specific test case, even though Player 1 seems to have the upper hand at first glance due to higher score accumulation, the decision to pick the number is not based solely on the current highest available number. Instead, the algorithm looks ahead to evaluate potential future states of the game, trying to minimize the possible loss for a worst-case (maximum loss) scenario.\\n\\nThe selection of numbers for both players might seem counter-intuitive, but the decision-making process assumes that both players are playing optimally. This means that each player chooses their number not just based on the current state, but also on how their choice would influence the options available for the next player and, by extension, the options that would be available to themselves on the next round.\\n\\nThus, in some cases, a player might choose a lower number over a higher one because it leads to a future state where they would ultimately have the advantage.\\n\\nThe scenario you\\'ve posted shows the step-by-step decision-making process of the players under the Minimax algorithm, and it seems that even though Player 1 has more points throughout the game, Player 2 wins in the end when playing optimally. This is why the function returns `False`, meaning Player 1 (the first player to start the game) cannot win assuming both players play optimally."
                    },
                    {
                        "username": "dvijay96",
                        "content": "Could anyone please help me understand the fault in below approach.\\nApproach:-  I\\'m trying to find the max score each player can make by recursively making a choice to pick/not pick the 1st and the last element.\\n\\n `public boolean PredictTheWinner(int[] nums) {\\n        int[] winner = {0, 0};\\n        if(nums.length>1){\\n            LinkedList<Integer> list = new LinkedList<>();\\n\\n            for(int i : nums){\\n                list.add(i);\\n            }\\n\\n            simulateWinner(list, 0, 0, 1, winner);\\n        }\\n        return winner[0] >= winner[1];\\n    }\\n\\n    void simulateWinner(LinkedList<Integer> list, int score1, int score2,int player, int[] winner){\\n\\n        if(list.isEmpty()){\\n            winner[0] = Math.max(winner[0], score1);\\n            winner[1] = Math.max(winner[1], score2);\\n            return;\\n        }\\n\\n        if(player == 1){\\n            int num = list.pollFirst();\\n            simulateWinner(list, score1+num, score2, 2, winner);\\n            list.addFirst(num);\\n\\n            num = list.pollLast();\\n            simulateWinner(list, score1+num, score2, 2, winner);\\n            list.addLast(num);\\n        }else{\\n            int num = list.pollFirst();\\n            simulateWinner(list, score1, score2+num, 1, winner);\\n            list.addFirst(num);\\n\\n            num = list.pollLast();\\n            simulateWinner(list, score1, score2+num, 1, winner);\\n            list.addLast(num); \\n        }\\n    }`\\n\\nThanks in advance."
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach to recursively simulate both players picking the first and last numbers is a good start. However, there is a critical flaw in this approach. In a game where both players play optimally, each player, when making a choice, must consider not just the immediate gain, but also what the opponent will do in the next turn. In your code, each player only tries to maximize their own score in the current turn without considering the opponent\\'s possible moves in the next turn.\\n\\nIn your `simulateWinner` function, when a player chooses a number, you recursively call `simulateWinner` for the other player with the remaining numbers. However, the current player doesn\\'t take into consideration what the score would be after the other player makes their optimal move. \\n\\nTo fix this, you should change the function so that when a player is about to make a move, they consider both options (picking the first number and picking the last number), simulate the remaining game for both options (i.e., call `simulateWinner` twice for each option), and then choose the option that results in the maximum final score for themselves. \\n\\nTo do this, you need to change `simulateWinner` to return the final score difference (player 1\\'s score minus player 2\\'s score), and when simulating the game for each option, the current player should choose the option that maximizes this score difference. This is because a positive score difference means player 1 wins, and a negative score difference means player 2 wins.\\n\\nFinally, in `PredictTheWinner`, instead of checking if `winner[0] >= winner[1]`, you should check if the final score difference is greater than or equal to 0, as a non-negative score difference means player 1 can win or draw the game."
                    },
                    {
                        "username": "avneets2103",
                        "content": "oky gotta revise DP\\n"
                    },
                    {
                        "username": "satishvegisetti563",
                        "content": "Anyone please list out similar problems"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "some of the Stone game problems are all somewhat similar to this, and the game theory tag gives you all problems that are games, some of those are quite similar too"
                    },
                    {
                        "username": "7h3w17ch3r",
                        "content": "Cisco OA?\\n"
                    }
                ]
            },
            {
                "id": 1990523,
                "content": [
                    {
                        "username": "user4262O",
                        "content": "for Java if got compile error, you need to change PredictTheWinner to predictTheWinner"
                    },
                    {
                        "username": "guyses",
                        "content": "what does `optimally` means in this question?\\n\\nin this test case - [2,4,55,6,8]\\nplayer1 can win, but the expected answer is `false`\\nplayer1 wins like this\\n\\nplayer1 take `2`\\nplayer2 takes `4`\\nplayer1 takes `55`\\nplayer2 takes `8`\\nplayer1 takes `6`\\n\\nin the end player1 = 2 + 55 + 6  > player2 = 4 + 8\\n\\nthere\\'s a reasoning to this, that i can think of, \\nwhy would player2 want to give the highest number in the array to player1? -> Is this what `optimally` means?"
                    },
                    {
                        "username": "dheeraj2002_",
                        "content": "Optimally doesn\\'t mean that at each step the player would be taking the biggest of the two, but to increase it\\'s score and decrease other person\\'s score. Watch min-max algorithm and it will help you to apply the logic more efficiently"
                    },
                    {
                        "username": "dikshawali",
                        "content": "I didn\\'t get it...in case of [1,5,2]\\nif player 1 chooses 1,\\nthen player 2 chooses 2,\\nafter which player1 chooses 5 making his score 6. Means there is one of the many ways in which player1 can become winner.\\nI am not sure why in each case player 2 is going to choose 5 to maximize his score, while player 1\\n\\nWhat I mean to say is - \\n[1,5,2]\\nplayer1 has been given 2 possibilities of choosing either 1 or 2. He doesnt care which one is bigger\\nwhile player2 cares, he always chooses 5. Why so? \\nCan anyone explain me this? Help will be appreciated."
                    },
                    {
                        "username": "huke0906",
                        "content": "So what does \"optimally\" mean? This problem seems poorly defined."
                    },
                    {
                        "username": "huke0906",
                        "content": "[@dheeraj2002_](/dheeraj2002_) Thank you! Now I see."
                    },
                    {
                        "username": "dheeraj2002_",
                        "content": "optimally means they will play to win, i.e. at each step the player will try to score such that it impacts his score as well as the score of the second player. Meaning a person may select a lesser score at a step but would do so to keep the higher score out of the range of the second player. I advice you to watch min-max algorithm for more insight to the problem. Also it is important not to confuse optimally with optimally per steps."
                    },
                    {
                        "username": "Zefick",
                        "content": "It's sad that so many people come up with a solution that runs in Python for more than 5 seconds.\nThe array is too small, so they were too lazy to optimize their exponential solutions even a little bit after they've been accepted."
                    },
                    {
                        "username": "Aaronearlerichardson",
                        "content": "Confused about a test case here:\\n\\n ```\\nnums = [3606449,6,5,9,452429,7,9580316,9857582,8514433,9,6,6614512,753594,5474165,4,2697293,8,7,1]\\n\\n{\\'p1\\': 3606449, \\'p2\\': 0} [6, 5, 9, 452429, 7, 9580316, 9857582, 8514433, 9, 6, 6614512, 753594, 5474165, 4, 2697293, 8, 7, 1]\\n\\n{\\'p1\\': 3606449, \\'p2\\': 6} [5, 9, 452429, 7, 9580316, 9857582, 8514433, 9, 6, 6614512, 753594, 5474165, 4, 2697293, 8, 7, 1]\\n\\n{\\'p1\\': 3606454, \\'p2\\': 6} [9, 452429, 7, 9580316, 9857582, 8514433, 9, 6, 6614512, 753594, 5474165, 4, 2697293, 8, 7, 1]\\n\\n{\\'p1\\': 3606454, \\'p2\\': 7} [9, 452429, 7, 9580316, 9857582, 8514433, 9, 6, 6614512, 753594, 5474165, 4, 2697293, 8, 7]\\n\\n{\\'p1\\': 3606461, \\'p2\\': 7} [9, 452429, 7, 9580316, 9857582, 8514433, 9, 6, 6614512, 753594, 5474165, 4, 2697293, 8]\\n\\n{\\'p1\\': 3606461, \\'p2\\': 16} [452429, 7, 9580316, 9857582, 8514433, 9, 6, 6614512, 753594, 5474165, 4, 2697293, 8]\\n\\n{\\'p1\\': 4058890, \\'p2\\': 16} [7, 9580316, 9857582, 8514433, 9, 6, 6614512, 753594, 5474165, 4, 2697293, 8]\\n\\n{\\'p1\\': 4058890, \\'p2\\': 24} [7, 9580316, 9857582, 8514433, 9, 6, 6614512, 753594, 5474165, 4, 2697293]\\n\\n{\\'p1\\': 6756183, \\'p2\\': 24} [7, 9580316, 9857582, 8514433, 9, 6, 6614512, 753594, 5474165, 4]\\n\\n{\\'p1\\': 6756183, \\'p2\\': 28} [7, 9580316, 9857582, 8514433, 9, 6, 6614512, 753594, 5474165]\\n\\n{\\'p1\\': 12230348, \\'p2\\': 28} [7, 9580316, 9857582, 8514433, 9, 6, 6614512, 753594]\\n\\n{\\'p1\\': 12230348, \\'p2\\': 753622} [7, 9580316, 9857582, 8514433, 9, 6, 6614512]\\n\\n{\\'p1\\': 18844860, \\'p2\\': 753622} [7, 9580316, 9857582, 8514433, 9, 6]\\n\\n{\\'p1\\': 18844860, \\'p2\\': 753628} [7, 9580316, 9857582, 8514433, 9]\\n\\n{\\'p1\\': 18844869, \\'p2\\': 753628} [7, 9580316, 9857582, 8514433]\\n\\n{\\'p1\\': 18844869, \\'p2\\': 9268061} [7, 9580316, 9857582]\\n\\n{\\'p1\\': 28702451, \\'p2\\': 9268061} [7, 9580316]\\n\\n{\\'p1\\': 28702451, \\'p2\\': 18848377} [7]\\n\\n{\\'p1\\': 28702458, \\'p2\\': 18848377} []\\n```\\n\\nSo I would expect the output to be true, but it isn\\'t. Why can\\'t player 1 win here?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The game played here is based on the Minimax algorithm, which is a kind of backtracking algorithm used in decision making and game theory to find the optimal move for a player, assuming that the opponent also plays optimally.\\n\\nIn your specific test case, even though Player 1 seems to have the upper hand at first glance due to higher score accumulation, the decision to pick the number is not based solely on the current highest available number. Instead, the algorithm looks ahead to evaluate potential future states of the game, trying to minimize the possible loss for a worst-case (maximum loss) scenario.\\n\\nThe selection of numbers for both players might seem counter-intuitive, but the decision-making process assumes that both players are playing optimally. This means that each player chooses their number not just based on the current state, but also on how their choice would influence the options available for the next player and, by extension, the options that would be available to themselves on the next round.\\n\\nThus, in some cases, a player might choose a lower number over a higher one because it leads to a future state where they would ultimately have the advantage.\\n\\nThe scenario you\\'ve posted shows the step-by-step decision-making process of the players under the Minimax algorithm, and it seems that even though Player 1 has more points throughout the game, Player 2 wins in the end when playing optimally. This is why the function returns `False`, meaning Player 1 (the first player to start the game) cannot win assuming both players play optimally."
                    },
                    {
                        "username": "dvijay96",
                        "content": "Could anyone please help me understand the fault in below approach.\\nApproach:-  I\\'m trying to find the max score each player can make by recursively making a choice to pick/not pick the 1st and the last element.\\n\\n `public boolean PredictTheWinner(int[] nums) {\\n        int[] winner = {0, 0};\\n        if(nums.length>1){\\n            LinkedList<Integer> list = new LinkedList<>();\\n\\n            for(int i : nums){\\n                list.add(i);\\n            }\\n\\n            simulateWinner(list, 0, 0, 1, winner);\\n        }\\n        return winner[0] >= winner[1];\\n    }\\n\\n    void simulateWinner(LinkedList<Integer> list, int score1, int score2,int player, int[] winner){\\n\\n        if(list.isEmpty()){\\n            winner[0] = Math.max(winner[0], score1);\\n            winner[1] = Math.max(winner[1], score2);\\n            return;\\n        }\\n\\n        if(player == 1){\\n            int num = list.pollFirst();\\n            simulateWinner(list, score1+num, score2, 2, winner);\\n            list.addFirst(num);\\n\\n            num = list.pollLast();\\n            simulateWinner(list, score1+num, score2, 2, winner);\\n            list.addLast(num);\\n        }else{\\n            int num = list.pollFirst();\\n            simulateWinner(list, score1, score2+num, 1, winner);\\n            list.addFirst(num);\\n\\n            num = list.pollLast();\\n            simulateWinner(list, score1, score2+num, 1, winner);\\n            list.addLast(num); \\n        }\\n    }`\\n\\nThanks in advance."
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach to recursively simulate both players picking the first and last numbers is a good start. However, there is a critical flaw in this approach. In a game where both players play optimally, each player, when making a choice, must consider not just the immediate gain, but also what the opponent will do in the next turn. In your code, each player only tries to maximize their own score in the current turn without considering the opponent\\'s possible moves in the next turn.\\n\\nIn your `simulateWinner` function, when a player chooses a number, you recursively call `simulateWinner` for the other player with the remaining numbers. However, the current player doesn\\'t take into consideration what the score would be after the other player makes their optimal move. \\n\\nTo fix this, you should change the function so that when a player is about to make a move, they consider both options (picking the first number and picking the last number), simulate the remaining game for both options (i.e., call `simulateWinner` twice for each option), and then choose the option that results in the maximum final score for themselves. \\n\\nTo do this, you need to change `simulateWinner` to return the final score difference (player 1\\'s score minus player 2\\'s score), and when simulating the game for each option, the current player should choose the option that maximizes this score difference. This is because a positive score difference means player 1 wins, and a negative score difference means player 2 wins.\\n\\nFinally, in `PredictTheWinner`, instead of checking if `winner[0] >= winner[1]`, you should check if the final score difference is greater than or equal to 0, as a non-negative score difference means player 1 can win or draw the game."
                    },
                    {
                        "username": "avneets2103",
                        "content": "oky gotta revise DP\\n"
                    },
                    {
                        "username": "satishvegisetti563",
                        "content": "Anyone please list out similar problems"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "some of the Stone game problems are all somewhat similar to this, and the game theory tag gives you all problems that are games, some of those are quite similar too"
                    },
                    {
                        "username": "7h3w17ch3r",
                        "content": "Cisco OA?\\n"
                    }
                ]
            },
            {
                "id": 1990398,
                "content": [
                    {
                        "username": "user4262O",
                        "content": "for Java if got compile error, you need to change PredictTheWinner to predictTheWinner"
                    },
                    {
                        "username": "guyses",
                        "content": "what does `optimally` means in this question?\\n\\nin this test case - [2,4,55,6,8]\\nplayer1 can win, but the expected answer is `false`\\nplayer1 wins like this\\n\\nplayer1 take `2`\\nplayer2 takes `4`\\nplayer1 takes `55`\\nplayer2 takes `8`\\nplayer1 takes `6`\\n\\nin the end player1 = 2 + 55 + 6  > player2 = 4 + 8\\n\\nthere\\'s a reasoning to this, that i can think of, \\nwhy would player2 want to give the highest number in the array to player1? -> Is this what `optimally` means?"
                    },
                    {
                        "username": "dheeraj2002_",
                        "content": "Optimally doesn\\'t mean that at each step the player would be taking the biggest of the two, but to increase it\\'s score and decrease other person\\'s score. Watch min-max algorithm and it will help you to apply the logic more efficiently"
                    },
                    {
                        "username": "dikshawali",
                        "content": "I didn\\'t get it...in case of [1,5,2]\\nif player 1 chooses 1,\\nthen player 2 chooses 2,\\nafter which player1 chooses 5 making his score 6. Means there is one of the many ways in which player1 can become winner.\\nI am not sure why in each case player 2 is going to choose 5 to maximize his score, while player 1\\n\\nWhat I mean to say is - \\n[1,5,2]\\nplayer1 has been given 2 possibilities of choosing either 1 or 2. He doesnt care which one is bigger\\nwhile player2 cares, he always chooses 5. Why so? \\nCan anyone explain me this? Help will be appreciated."
                    },
                    {
                        "username": "huke0906",
                        "content": "So what does \"optimally\" mean? This problem seems poorly defined."
                    },
                    {
                        "username": "huke0906",
                        "content": "[@dheeraj2002_](/dheeraj2002_) Thank you! Now I see."
                    },
                    {
                        "username": "dheeraj2002_",
                        "content": "optimally means they will play to win, i.e. at each step the player will try to score such that it impacts his score as well as the score of the second player. Meaning a person may select a lesser score at a step but would do so to keep the higher score out of the range of the second player. I advice you to watch min-max algorithm for more insight to the problem. Also it is important not to confuse optimally with optimally per steps."
                    },
                    {
                        "username": "Zefick",
                        "content": "It's sad that so many people come up with a solution that runs in Python for more than 5 seconds.\nThe array is too small, so they were too lazy to optimize their exponential solutions even a little bit after they've been accepted."
                    },
                    {
                        "username": "Aaronearlerichardson",
                        "content": "Confused about a test case here:\\n\\n ```\\nnums = [3606449,6,5,9,452429,7,9580316,9857582,8514433,9,6,6614512,753594,5474165,4,2697293,8,7,1]\\n\\n{\\'p1\\': 3606449, \\'p2\\': 0} [6, 5, 9, 452429, 7, 9580316, 9857582, 8514433, 9, 6, 6614512, 753594, 5474165, 4, 2697293, 8, 7, 1]\\n\\n{\\'p1\\': 3606449, \\'p2\\': 6} [5, 9, 452429, 7, 9580316, 9857582, 8514433, 9, 6, 6614512, 753594, 5474165, 4, 2697293, 8, 7, 1]\\n\\n{\\'p1\\': 3606454, \\'p2\\': 6} [9, 452429, 7, 9580316, 9857582, 8514433, 9, 6, 6614512, 753594, 5474165, 4, 2697293, 8, 7, 1]\\n\\n{\\'p1\\': 3606454, \\'p2\\': 7} [9, 452429, 7, 9580316, 9857582, 8514433, 9, 6, 6614512, 753594, 5474165, 4, 2697293, 8, 7]\\n\\n{\\'p1\\': 3606461, \\'p2\\': 7} [9, 452429, 7, 9580316, 9857582, 8514433, 9, 6, 6614512, 753594, 5474165, 4, 2697293, 8]\\n\\n{\\'p1\\': 3606461, \\'p2\\': 16} [452429, 7, 9580316, 9857582, 8514433, 9, 6, 6614512, 753594, 5474165, 4, 2697293, 8]\\n\\n{\\'p1\\': 4058890, \\'p2\\': 16} [7, 9580316, 9857582, 8514433, 9, 6, 6614512, 753594, 5474165, 4, 2697293, 8]\\n\\n{\\'p1\\': 4058890, \\'p2\\': 24} [7, 9580316, 9857582, 8514433, 9, 6, 6614512, 753594, 5474165, 4, 2697293]\\n\\n{\\'p1\\': 6756183, \\'p2\\': 24} [7, 9580316, 9857582, 8514433, 9, 6, 6614512, 753594, 5474165, 4]\\n\\n{\\'p1\\': 6756183, \\'p2\\': 28} [7, 9580316, 9857582, 8514433, 9, 6, 6614512, 753594, 5474165]\\n\\n{\\'p1\\': 12230348, \\'p2\\': 28} [7, 9580316, 9857582, 8514433, 9, 6, 6614512, 753594]\\n\\n{\\'p1\\': 12230348, \\'p2\\': 753622} [7, 9580316, 9857582, 8514433, 9, 6, 6614512]\\n\\n{\\'p1\\': 18844860, \\'p2\\': 753622} [7, 9580316, 9857582, 8514433, 9, 6]\\n\\n{\\'p1\\': 18844860, \\'p2\\': 753628} [7, 9580316, 9857582, 8514433, 9]\\n\\n{\\'p1\\': 18844869, \\'p2\\': 753628} [7, 9580316, 9857582, 8514433]\\n\\n{\\'p1\\': 18844869, \\'p2\\': 9268061} [7, 9580316, 9857582]\\n\\n{\\'p1\\': 28702451, \\'p2\\': 9268061} [7, 9580316]\\n\\n{\\'p1\\': 28702451, \\'p2\\': 18848377} [7]\\n\\n{\\'p1\\': 28702458, \\'p2\\': 18848377} []\\n```\\n\\nSo I would expect the output to be true, but it isn\\'t. Why can\\'t player 1 win here?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The game played here is based on the Minimax algorithm, which is a kind of backtracking algorithm used in decision making and game theory to find the optimal move for a player, assuming that the opponent also plays optimally.\\n\\nIn your specific test case, even though Player 1 seems to have the upper hand at first glance due to higher score accumulation, the decision to pick the number is not based solely on the current highest available number. Instead, the algorithm looks ahead to evaluate potential future states of the game, trying to minimize the possible loss for a worst-case (maximum loss) scenario.\\n\\nThe selection of numbers for both players might seem counter-intuitive, but the decision-making process assumes that both players are playing optimally. This means that each player chooses their number not just based on the current state, but also on how their choice would influence the options available for the next player and, by extension, the options that would be available to themselves on the next round.\\n\\nThus, in some cases, a player might choose a lower number over a higher one because it leads to a future state where they would ultimately have the advantage.\\n\\nThe scenario you\\'ve posted shows the step-by-step decision-making process of the players under the Minimax algorithm, and it seems that even though Player 1 has more points throughout the game, Player 2 wins in the end when playing optimally. This is why the function returns `False`, meaning Player 1 (the first player to start the game) cannot win assuming both players play optimally."
                    },
                    {
                        "username": "dvijay96",
                        "content": "Could anyone please help me understand the fault in below approach.\\nApproach:-  I\\'m trying to find the max score each player can make by recursively making a choice to pick/not pick the 1st and the last element.\\n\\n `public boolean PredictTheWinner(int[] nums) {\\n        int[] winner = {0, 0};\\n        if(nums.length>1){\\n            LinkedList<Integer> list = new LinkedList<>();\\n\\n            for(int i : nums){\\n                list.add(i);\\n            }\\n\\n            simulateWinner(list, 0, 0, 1, winner);\\n        }\\n        return winner[0] >= winner[1];\\n    }\\n\\n    void simulateWinner(LinkedList<Integer> list, int score1, int score2,int player, int[] winner){\\n\\n        if(list.isEmpty()){\\n            winner[0] = Math.max(winner[0], score1);\\n            winner[1] = Math.max(winner[1], score2);\\n            return;\\n        }\\n\\n        if(player == 1){\\n            int num = list.pollFirst();\\n            simulateWinner(list, score1+num, score2, 2, winner);\\n            list.addFirst(num);\\n\\n            num = list.pollLast();\\n            simulateWinner(list, score1+num, score2, 2, winner);\\n            list.addLast(num);\\n        }else{\\n            int num = list.pollFirst();\\n            simulateWinner(list, score1, score2+num, 1, winner);\\n            list.addFirst(num);\\n\\n            num = list.pollLast();\\n            simulateWinner(list, score1, score2+num, 1, winner);\\n            list.addLast(num); \\n        }\\n    }`\\n\\nThanks in advance."
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach to recursively simulate both players picking the first and last numbers is a good start. However, there is a critical flaw in this approach. In a game where both players play optimally, each player, when making a choice, must consider not just the immediate gain, but also what the opponent will do in the next turn. In your code, each player only tries to maximize their own score in the current turn without considering the opponent\\'s possible moves in the next turn.\\n\\nIn your `simulateWinner` function, when a player chooses a number, you recursively call `simulateWinner` for the other player with the remaining numbers. However, the current player doesn\\'t take into consideration what the score would be after the other player makes their optimal move. \\n\\nTo fix this, you should change the function so that when a player is about to make a move, they consider both options (picking the first number and picking the last number), simulate the remaining game for both options (i.e., call `simulateWinner` twice for each option), and then choose the option that results in the maximum final score for themselves. \\n\\nTo do this, you need to change `simulateWinner` to return the final score difference (player 1\\'s score minus player 2\\'s score), and when simulating the game for each option, the current player should choose the option that maximizes this score difference. This is because a positive score difference means player 1 wins, and a negative score difference means player 2 wins.\\n\\nFinally, in `PredictTheWinner`, instead of checking if `winner[0] >= winner[1]`, you should check if the final score difference is greater than or equal to 0, as a non-negative score difference means player 1 can win or draw the game."
                    },
                    {
                        "username": "avneets2103",
                        "content": "oky gotta revise DP\\n"
                    },
                    {
                        "username": "satishvegisetti563",
                        "content": "Anyone please list out similar problems"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "some of the Stone game problems are all somewhat similar to this, and the game theory tag gives you all problems that are games, some of those are quite similar too"
                    },
                    {
                        "username": "7h3w17ch3r",
                        "content": "Cisco OA?\\n"
                    }
                ]
            },
            {
                "id": 1990388,
                "content": [
                    {
                        "username": "halfengineer",
                        "content": "60/62 test case\\uD83D\\uDE29\\uD83D\\uDE29"
                    },
                    {
                        "username": "stuartYoung_",
                        "content": "Remember one thumb rule of these game based problems in which the winner or loser is asked and both playing optimally. (p1 and p2)\\n\\nsuppose you are p1 and and i am p2\\n\\n#at your chance, you will try your best to win\\n\\n#and at my chance I will do my best to make you loser, so prepare for the worst\\n\\ntherefore I give you the worst choices\\nand out of these worsts you have to pick the best\\n################################\\n\\nQuestion:\\n\\nsuppose you are with  i<---->j  range. \\nso either you will choose i or j right? (first or last)  and got nums[i] or nums[j]\\n\\n\\n1)\\nlet you chose i , now your opponent will also have two choice between (i+1<------>j) .so either he will choose i+1 or j , ok?\\nso now he will choose in such a way that he can make you loser  and you got minimum of his two choices i.e.  min(solve(i+2,j) , solve(i+1,j-1) )\\n\\nso finaly you got :\\nnums[i] + min(solve(i+2,j) , solve(i+1,j-1) )\\n\\n2)\\nNOW suppose you had chosen j at first step\\nso opponent left with range of  ( i<----->j-1 )\\n, he can choose either i+1 or j-1 \\n\\nand, ultimately  in similar fashion you got:\\nnums[j] + min(solve(i+1 , j-1) , solve(i , j-2) )\\n\\n\\nat beginning as i said , you also want to be a winner so you choose best of all minimums (worsts)\\n\\ni.e. max of 1st case and 2nd case...\\n\\n\\ntherefore ans=max(1st case,2nd case)\\n\\nrecursively do above approach.  \\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "harshitarmishra",
                        "content": "In example 1, if player 1 chooses 2 first , and then player 2 chooses 1, and then again player 1 chooses 5 then player 1 (total score 7) wins over player 2 (total score 1) then player 1 wins. So there is one case where player 1 wins so the output should be true, why is it given false??please solve my doubt"
                    },
                    {
                        "username": "codenameoxide_",
                        "content": "that is because while it is possibility, player 2 will not pick 2 when it can pick 5 to win the game. This question is not asking if there is a possibility for player 1 to win the game, but rather the outcome of player 1 when both of them play \"optimally\"."
                    },
                    {
                        "username": "mahesh105",
                        "content": "I was asked similar question \"BATTLE CLASH\" in my Sprinklr OA 2023. It\\'s bit tricky but yeah solvable and preety good question."
                    },
                    {
                        "username": "Shukla_Yash",
                        "content": "Can i solved this question without using dp\\n\\n\\ni am trying to solve with simple loop but only 30 test cases passed why it comes false for the input {1,1,1,1,1,1,1,1,1} \\n\\nif any one have any idea share with me plese \\nhere is my code :\\nclass Solution {\\npublic:\\n    bool PredictTheWinner(vector<int>& nums) {\\n        int n = nums.size();\\n        int sum,res;\\n        int count =0;\\n        int end = 1;\\n\\n        if(n ==2){\\n            if(nums[0] > nums[1]){\\n                sum +=nums[count];\\n                res += nums[end];\\n            }\\n            else{\\n                sum += nums[end];\\n                res += nums[count];\\n            }\\n        }\\n        if(sum > res){\\n            return true;\\n        }\\n        else if(res == sum){\\n            return true;\\n        }\\n\\n        while(count <n && end <n){\\n            sum +=nums[count];\\n            res += nums[end];\\n\\n            count +=2;\\n            end  += 2;\\n        }\\n        if(sum > res){\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "saeed355ahmed",
                        "content": "Why i cant solve any leetcode question(it my first time), even though they are labeled as easy??"
                    },
                    {
                        "username": "Ludacris2G",
                        "content": "bro trust me I\\'ve been using leetcode almost daily for like half a year to a year now and I\\'m still not able to solve almost anything."
                    },
                    {
                        "username": "schwemj",
                        "content": "pretty much anyone using leetcode for the first time has experienced this... and it's not your fault! here is what has helped others and myself: when looking at the list of problems, don't sort or filter them by \"difficulty\"; instead, you'll want to toggle the little \"acceptance\" button to show you the questions sorted by acceptance rates in *descending* order. that way you will see problems that many people have had an easier time solving right on the top of the list. \n\nthe thing is, some problems labeled as easy are a lot harder than others with the same easy label. i've even found that there are medium questions with a high acceptance rate that were way easier to solve than easy questions with a lower acceptance rate. one reason for the seemingly chaotic system is that by default, all problems will be shown in order of creation. another reason is that multiple people are working on creating the questions, and some will design puzzles in one category that are more complex than others in the same category (it's a spectrum!). \nit's also good to remember that the labels \"easy/medium/hard\" are chosen by humans (who are inherently biased) and therefore highly subjective, since not everyone will find the same problem as easy or as hard to solve as their peers do. \n\ndon't despair and keep on coding! "
                    },
                    {
                        "username": "r_o_xx_",
                        "content": "Trust me bro even I am not able to solve them"
                    },
                    {
                        "username": "MrEmirhan",
                        "content": "Behavior of player 2 is not described. It is not appropriate to say `player 1 will never be the winner and you need to return false.`\\nin the example 1 because if player 2 behaves different, player 1 can win. Please update/improve description."
                    },
                    {
                        "username": "wafsinc",
                        "content": "It says \"You may assume that both players are playing optimally\"."
                    },
                    {
                        "username": "codenameoxide_",
                        "content": "DP not necessary to get Accepted :)"
                    },
                    {
                        "username": "rakhikumari6602",
                        "content": "Please someone help,i am using 2 pointer approach and its faling some testcases.\\n\\n\\nclass Solution {\\n    public boolean PredictTheWinner(int[] nums) {\\n\\n        int n=nums.length;\\n        int left=0;\\n        int right = nums.length-1;\\n       \\n         int p1=0,p2=0;\\n         boolean flag=true;\\n        \\n\\n        while(left>right)\\n        {\\n        if(flag==true)          \\n         {\\n             p1+= Math.max(nums[left],nums[right]);\\n             if(nums[left] >nums[right])\\n             {\\n              left=left+1;\\n              \\n             }\\n\\n              else\\n              {\\n               right = right-1;\\n               \\n              }\\n\\n             flag=false;\\n         }\\n         \\n         else\\n         {\\n             p2+= Math.max(nums[left],nums[right]);\\n\\n              if(nums[left] >nums[right])\\n              {\\n              left=left+1;\\n            \\n              }\\n\\n              else\\n              {\\n               right = right-1;\\n               \\n              }\\n\\n             flag=true;\\n         }\\n         \\n        }\\n        \\n\\n        if(p1 >= p2) return true;\\n\\n        return false;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "dheeraj2002_",
                        "content": "To start with the description says that the both players play optimally, you interpreted it wrongly as optimally per step, which is not the case. It means the players are playing the game with the motive to win, and even if they select the lesser integer out of the two in a step, if they see the next moves they will win, they will still select them. The question is quite similar to min-max algorithm where one player plays for max utility and another player tries to decrease the overall utility of the player1. So if you had knowledge about min-max algorithm, after some changes, this question could be solved easily."
                    },
                    {
                        "username": "codenameoxide_",
                        "content": "This is more of a subset sum problem where u generate subsets by picking either leftmost or rightmost element. Subset category problems are solved by exploring all possible results. If in doubt, always see the constraints. Constraints are good hint of what type of algorithm pattern is expected. With ip as small as 20, generating all subsets and verifying it will not result in TLE. An ip size of 10^3 can\\'t be solved by recursion, but possible with 2D DP.\\n"
                    },
                    {
                        "username": "anuron_das",
                        "content": "Going by two pointers is like thinking greedily. It is not a greedy problem. I mean think about it, for the test case `[2,100,3,4,1]`, if you start off by taking the maximum from the ends then, the `100` at the `2nd` position will go to your opponent. \\n\\nYou will greedily go for `2`, then your opponent will straight up go for `100`, and now you have no way to defeat him. Better to go for all possible options, or algorithmically speaking, go for DP."
                    },
                    {
                        "username": "anuron_das",
                        "content": "This was actually asked in Cisco\\'s OA. Sadly the only question our team could solve..."
                    },
                    {
                        "username": "anantverma711",
                        "content": "Yes, they were shooting targets XD"
                    }
                ]
            },
            {
                "id": 1990340,
                "content": [
                    {
                        "username": "halfengineer",
                        "content": "60/62 test case\\uD83D\\uDE29\\uD83D\\uDE29"
                    },
                    {
                        "username": "stuartYoung_",
                        "content": "Remember one thumb rule of these game based problems in which the winner or loser is asked and both playing optimally. (p1 and p2)\\n\\nsuppose you are p1 and and i am p2\\n\\n#at your chance, you will try your best to win\\n\\n#and at my chance I will do my best to make you loser, so prepare for the worst\\n\\ntherefore I give you the worst choices\\nand out of these worsts you have to pick the best\\n################################\\n\\nQuestion:\\n\\nsuppose you are with  i<---->j  range. \\nso either you will choose i or j right? (first or last)  and got nums[i] or nums[j]\\n\\n\\n1)\\nlet you chose i , now your opponent will also have two choice between (i+1<------>j) .so either he will choose i+1 or j , ok?\\nso now he will choose in such a way that he can make you loser  and you got minimum of his two choices i.e.  min(solve(i+2,j) , solve(i+1,j-1) )\\n\\nso finaly you got :\\nnums[i] + min(solve(i+2,j) , solve(i+1,j-1) )\\n\\n2)\\nNOW suppose you had chosen j at first step\\nso opponent left with range of  ( i<----->j-1 )\\n, he can choose either i+1 or j-1 \\n\\nand, ultimately  in similar fashion you got:\\nnums[j] + min(solve(i+1 , j-1) , solve(i , j-2) )\\n\\n\\nat beginning as i said , you also want to be a winner so you choose best of all minimums (worsts)\\n\\ni.e. max of 1st case and 2nd case...\\n\\n\\ntherefore ans=max(1st case,2nd case)\\n\\nrecursively do above approach.  \\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "harshitarmishra",
                        "content": "In example 1, if player 1 chooses 2 first , and then player 2 chooses 1, and then again player 1 chooses 5 then player 1 (total score 7) wins over player 2 (total score 1) then player 1 wins. So there is one case where player 1 wins so the output should be true, why is it given false??please solve my doubt"
                    },
                    {
                        "username": "codenameoxide_",
                        "content": "that is because while it is possibility, player 2 will not pick 2 when it can pick 5 to win the game. This question is not asking if there is a possibility for player 1 to win the game, but rather the outcome of player 1 when both of them play \"optimally\"."
                    },
                    {
                        "username": "mahesh105",
                        "content": "I was asked similar question \"BATTLE CLASH\" in my Sprinklr OA 2023. It\\'s bit tricky but yeah solvable and preety good question."
                    },
                    {
                        "username": "Shukla_Yash",
                        "content": "Can i solved this question without using dp\\n\\n\\ni am trying to solve with simple loop but only 30 test cases passed why it comes false for the input {1,1,1,1,1,1,1,1,1} \\n\\nif any one have any idea share with me plese \\nhere is my code :\\nclass Solution {\\npublic:\\n    bool PredictTheWinner(vector<int>& nums) {\\n        int n = nums.size();\\n        int sum,res;\\n        int count =0;\\n        int end = 1;\\n\\n        if(n ==2){\\n            if(nums[0] > nums[1]){\\n                sum +=nums[count];\\n                res += nums[end];\\n            }\\n            else{\\n                sum += nums[end];\\n                res += nums[count];\\n            }\\n        }\\n        if(sum > res){\\n            return true;\\n        }\\n        else if(res == sum){\\n            return true;\\n        }\\n\\n        while(count <n && end <n){\\n            sum +=nums[count];\\n            res += nums[end];\\n\\n            count +=2;\\n            end  += 2;\\n        }\\n        if(sum > res){\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "saeed355ahmed",
                        "content": "Why i cant solve any leetcode question(it my first time), even though they are labeled as easy??"
                    },
                    {
                        "username": "Ludacris2G",
                        "content": "bro trust me I\\'ve been using leetcode almost daily for like half a year to a year now and I\\'m still not able to solve almost anything."
                    },
                    {
                        "username": "schwemj",
                        "content": "pretty much anyone using leetcode for the first time has experienced this... and it's not your fault! here is what has helped others and myself: when looking at the list of problems, don't sort or filter them by \"difficulty\"; instead, you'll want to toggle the little \"acceptance\" button to show you the questions sorted by acceptance rates in *descending* order. that way you will see problems that many people have had an easier time solving right on the top of the list. \n\nthe thing is, some problems labeled as easy are a lot harder than others with the same easy label. i've even found that there are medium questions with a high acceptance rate that were way easier to solve than easy questions with a lower acceptance rate. one reason for the seemingly chaotic system is that by default, all problems will be shown in order of creation. another reason is that multiple people are working on creating the questions, and some will design puzzles in one category that are more complex than others in the same category (it's a spectrum!). \nit's also good to remember that the labels \"easy/medium/hard\" are chosen by humans (who are inherently biased) and therefore highly subjective, since not everyone will find the same problem as easy or as hard to solve as their peers do. \n\ndon't despair and keep on coding! "
                    },
                    {
                        "username": "r_o_xx_",
                        "content": "Trust me bro even I am not able to solve them"
                    },
                    {
                        "username": "MrEmirhan",
                        "content": "Behavior of player 2 is not described. It is not appropriate to say `player 1 will never be the winner and you need to return false.`\\nin the example 1 because if player 2 behaves different, player 1 can win. Please update/improve description."
                    },
                    {
                        "username": "wafsinc",
                        "content": "It says \"You may assume that both players are playing optimally\"."
                    },
                    {
                        "username": "codenameoxide_",
                        "content": "DP not necessary to get Accepted :)"
                    },
                    {
                        "username": "rakhikumari6602",
                        "content": "Please someone help,i am using 2 pointer approach and its faling some testcases.\\n\\n\\nclass Solution {\\n    public boolean PredictTheWinner(int[] nums) {\\n\\n        int n=nums.length;\\n        int left=0;\\n        int right = nums.length-1;\\n       \\n         int p1=0,p2=0;\\n         boolean flag=true;\\n        \\n\\n        while(left>right)\\n        {\\n        if(flag==true)          \\n         {\\n             p1+= Math.max(nums[left],nums[right]);\\n             if(nums[left] >nums[right])\\n             {\\n              left=left+1;\\n              \\n             }\\n\\n              else\\n              {\\n               right = right-1;\\n               \\n              }\\n\\n             flag=false;\\n         }\\n         \\n         else\\n         {\\n             p2+= Math.max(nums[left],nums[right]);\\n\\n              if(nums[left] >nums[right])\\n              {\\n              left=left+1;\\n            \\n              }\\n\\n              else\\n              {\\n               right = right-1;\\n               \\n              }\\n\\n             flag=true;\\n         }\\n         \\n        }\\n        \\n\\n        if(p1 >= p2) return true;\\n\\n        return false;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "dheeraj2002_",
                        "content": "To start with the description says that the both players play optimally, you interpreted it wrongly as optimally per step, which is not the case. It means the players are playing the game with the motive to win, and even if they select the lesser integer out of the two in a step, if they see the next moves they will win, they will still select them. The question is quite similar to min-max algorithm where one player plays for max utility and another player tries to decrease the overall utility of the player1. So if you had knowledge about min-max algorithm, after some changes, this question could be solved easily."
                    },
                    {
                        "username": "codenameoxide_",
                        "content": "This is more of a subset sum problem where u generate subsets by picking either leftmost or rightmost element. Subset category problems are solved by exploring all possible results. If in doubt, always see the constraints. Constraints are good hint of what type of algorithm pattern is expected. With ip as small as 20, generating all subsets and verifying it will not result in TLE. An ip size of 10^3 can\\'t be solved by recursion, but possible with 2D DP.\\n"
                    },
                    {
                        "username": "anuron_das",
                        "content": "Going by two pointers is like thinking greedily. It is not a greedy problem. I mean think about it, for the test case `[2,100,3,4,1]`, if you start off by taking the maximum from the ends then, the `100` at the `2nd` position will go to your opponent. \\n\\nYou will greedily go for `2`, then your opponent will straight up go for `100`, and now you have no way to defeat him. Better to go for all possible options, or algorithmically speaking, go for DP."
                    },
                    {
                        "username": "anuron_das",
                        "content": "This was actually asked in Cisco\\'s OA. Sadly the only question our team could solve..."
                    },
                    {
                        "username": "anantverma711",
                        "content": "Yes, they were shooting targets XD"
                    }
                ]
            },
            {
                "id": 1990278,
                "content": [
                    {
                        "username": "halfengineer",
                        "content": "60/62 test case\\uD83D\\uDE29\\uD83D\\uDE29"
                    },
                    {
                        "username": "stuartYoung_",
                        "content": "Remember one thumb rule of these game based problems in which the winner or loser is asked and both playing optimally. (p1 and p2)\\n\\nsuppose you are p1 and and i am p2\\n\\n#at your chance, you will try your best to win\\n\\n#and at my chance I will do my best to make you loser, so prepare for the worst\\n\\ntherefore I give you the worst choices\\nand out of these worsts you have to pick the best\\n################################\\n\\nQuestion:\\n\\nsuppose you are with  i<---->j  range. \\nso either you will choose i or j right? (first or last)  and got nums[i] or nums[j]\\n\\n\\n1)\\nlet you chose i , now your opponent will also have two choice between (i+1<------>j) .so either he will choose i+1 or j , ok?\\nso now he will choose in such a way that he can make you loser  and you got minimum of his two choices i.e.  min(solve(i+2,j) , solve(i+1,j-1) )\\n\\nso finaly you got :\\nnums[i] + min(solve(i+2,j) , solve(i+1,j-1) )\\n\\n2)\\nNOW suppose you had chosen j at first step\\nso opponent left with range of  ( i<----->j-1 )\\n, he can choose either i+1 or j-1 \\n\\nand, ultimately  in similar fashion you got:\\nnums[j] + min(solve(i+1 , j-1) , solve(i , j-2) )\\n\\n\\nat beginning as i said , you also want to be a winner so you choose best of all minimums (worsts)\\n\\ni.e. max of 1st case and 2nd case...\\n\\n\\ntherefore ans=max(1st case,2nd case)\\n\\nrecursively do above approach.  \\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "harshitarmishra",
                        "content": "In example 1, if player 1 chooses 2 first , and then player 2 chooses 1, and then again player 1 chooses 5 then player 1 (total score 7) wins over player 2 (total score 1) then player 1 wins. So there is one case where player 1 wins so the output should be true, why is it given false??please solve my doubt"
                    },
                    {
                        "username": "codenameoxide_",
                        "content": "that is because while it is possibility, player 2 will not pick 2 when it can pick 5 to win the game. This question is not asking if there is a possibility for player 1 to win the game, but rather the outcome of player 1 when both of them play \"optimally\"."
                    },
                    {
                        "username": "mahesh105",
                        "content": "I was asked similar question \"BATTLE CLASH\" in my Sprinklr OA 2023. It\\'s bit tricky but yeah solvable and preety good question."
                    },
                    {
                        "username": "Shukla_Yash",
                        "content": "Can i solved this question without using dp\\n\\n\\ni am trying to solve with simple loop but only 30 test cases passed why it comes false for the input {1,1,1,1,1,1,1,1,1} \\n\\nif any one have any idea share with me plese \\nhere is my code :\\nclass Solution {\\npublic:\\n    bool PredictTheWinner(vector<int>& nums) {\\n        int n = nums.size();\\n        int sum,res;\\n        int count =0;\\n        int end = 1;\\n\\n        if(n ==2){\\n            if(nums[0] > nums[1]){\\n                sum +=nums[count];\\n                res += nums[end];\\n            }\\n            else{\\n                sum += nums[end];\\n                res += nums[count];\\n            }\\n        }\\n        if(sum > res){\\n            return true;\\n        }\\n        else if(res == sum){\\n            return true;\\n        }\\n\\n        while(count <n && end <n){\\n            sum +=nums[count];\\n            res += nums[end];\\n\\n            count +=2;\\n            end  += 2;\\n        }\\n        if(sum > res){\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "saeed355ahmed",
                        "content": "Why i cant solve any leetcode question(it my first time), even though they are labeled as easy??"
                    },
                    {
                        "username": "Ludacris2G",
                        "content": "bro trust me I\\'ve been using leetcode almost daily for like half a year to a year now and I\\'m still not able to solve almost anything."
                    },
                    {
                        "username": "schwemj",
                        "content": "pretty much anyone using leetcode for the first time has experienced this... and it's not your fault! here is what has helped others and myself: when looking at the list of problems, don't sort or filter them by \"difficulty\"; instead, you'll want to toggle the little \"acceptance\" button to show you the questions sorted by acceptance rates in *descending* order. that way you will see problems that many people have had an easier time solving right on the top of the list. \n\nthe thing is, some problems labeled as easy are a lot harder than others with the same easy label. i've even found that there are medium questions with a high acceptance rate that were way easier to solve than easy questions with a lower acceptance rate. one reason for the seemingly chaotic system is that by default, all problems will be shown in order of creation. another reason is that multiple people are working on creating the questions, and some will design puzzles in one category that are more complex than others in the same category (it's a spectrum!). \nit's also good to remember that the labels \"easy/medium/hard\" are chosen by humans (who are inherently biased) and therefore highly subjective, since not everyone will find the same problem as easy or as hard to solve as their peers do. \n\ndon't despair and keep on coding! "
                    },
                    {
                        "username": "r_o_xx_",
                        "content": "Trust me bro even I am not able to solve them"
                    },
                    {
                        "username": "MrEmirhan",
                        "content": "Behavior of player 2 is not described. It is not appropriate to say `player 1 will never be the winner and you need to return false.`\\nin the example 1 because if player 2 behaves different, player 1 can win. Please update/improve description."
                    },
                    {
                        "username": "wafsinc",
                        "content": "It says \"You may assume that both players are playing optimally\"."
                    },
                    {
                        "username": "codenameoxide_",
                        "content": "DP not necessary to get Accepted :)"
                    },
                    {
                        "username": "rakhikumari6602",
                        "content": "Please someone help,i am using 2 pointer approach and its faling some testcases.\\n\\n\\nclass Solution {\\n    public boolean PredictTheWinner(int[] nums) {\\n\\n        int n=nums.length;\\n        int left=0;\\n        int right = nums.length-1;\\n       \\n         int p1=0,p2=0;\\n         boolean flag=true;\\n        \\n\\n        while(left>right)\\n        {\\n        if(flag==true)          \\n         {\\n             p1+= Math.max(nums[left],nums[right]);\\n             if(nums[left] >nums[right])\\n             {\\n              left=left+1;\\n              \\n             }\\n\\n              else\\n              {\\n               right = right-1;\\n               \\n              }\\n\\n             flag=false;\\n         }\\n         \\n         else\\n         {\\n             p2+= Math.max(nums[left],nums[right]);\\n\\n              if(nums[left] >nums[right])\\n              {\\n              left=left+1;\\n            \\n              }\\n\\n              else\\n              {\\n               right = right-1;\\n               \\n              }\\n\\n             flag=true;\\n         }\\n         \\n        }\\n        \\n\\n        if(p1 >= p2) return true;\\n\\n        return false;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "dheeraj2002_",
                        "content": "To start with the description says that the both players play optimally, you interpreted it wrongly as optimally per step, which is not the case. It means the players are playing the game with the motive to win, and even if they select the lesser integer out of the two in a step, if they see the next moves they will win, they will still select them. The question is quite similar to min-max algorithm where one player plays for max utility and another player tries to decrease the overall utility of the player1. So if you had knowledge about min-max algorithm, after some changes, this question could be solved easily."
                    },
                    {
                        "username": "codenameoxide_",
                        "content": "This is more of a subset sum problem where u generate subsets by picking either leftmost or rightmost element. Subset category problems are solved by exploring all possible results. If in doubt, always see the constraints. Constraints are good hint of what type of algorithm pattern is expected. With ip as small as 20, generating all subsets and verifying it will not result in TLE. An ip size of 10^3 can\\'t be solved by recursion, but possible with 2D DP.\\n"
                    },
                    {
                        "username": "anuron_das",
                        "content": "Going by two pointers is like thinking greedily. It is not a greedy problem. I mean think about it, for the test case `[2,100,3,4,1]`, if you start off by taking the maximum from the ends then, the `100` at the `2nd` position will go to your opponent. \\n\\nYou will greedily go for `2`, then your opponent will straight up go for `100`, and now you have no way to defeat him. Better to go for all possible options, or algorithmically speaking, go for DP."
                    },
                    {
                        "username": "anuron_das",
                        "content": "This was actually asked in Cisco\\'s OA. Sadly the only question our team could solve..."
                    },
                    {
                        "username": "anantverma711",
                        "content": "Yes, they were shooting targets XD"
                    }
                ]
            },
            {
                "id": 1990262,
                "content": [
                    {
                        "username": "halfengineer",
                        "content": "60/62 test case\\uD83D\\uDE29\\uD83D\\uDE29"
                    },
                    {
                        "username": "stuartYoung_",
                        "content": "Remember one thumb rule of these game based problems in which the winner or loser is asked and both playing optimally. (p1 and p2)\\n\\nsuppose you are p1 and and i am p2\\n\\n#at your chance, you will try your best to win\\n\\n#and at my chance I will do my best to make you loser, so prepare for the worst\\n\\ntherefore I give you the worst choices\\nand out of these worsts you have to pick the best\\n################################\\n\\nQuestion:\\n\\nsuppose you are with  i<---->j  range. \\nso either you will choose i or j right? (first or last)  and got nums[i] or nums[j]\\n\\n\\n1)\\nlet you chose i , now your opponent will also have two choice between (i+1<------>j) .so either he will choose i+1 or j , ok?\\nso now he will choose in such a way that he can make you loser  and you got minimum of his two choices i.e.  min(solve(i+2,j) , solve(i+1,j-1) )\\n\\nso finaly you got :\\nnums[i] + min(solve(i+2,j) , solve(i+1,j-1) )\\n\\n2)\\nNOW suppose you had chosen j at first step\\nso opponent left with range of  ( i<----->j-1 )\\n, he can choose either i+1 or j-1 \\n\\nand, ultimately  in similar fashion you got:\\nnums[j] + min(solve(i+1 , j-1) , solve(i , j-2) )\\n\\n\\nat beginning as i said , you also want to be a winner so you choose best of all minimums (worsts)\\n\\ni.e. max of 1st case and 2nd case...\\n\\n\\ntherefore ans=max(1st case,2nd case)\\n\\nrecursively do above approach.  \\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "harshitarmishra",
                        "content": "In example 1, if player 1 chooses 2 first , and then player 2 chooses 1, and then again player 1 chooses 5 then player 1 (total score 7) wins over player 2 (total score 1) then player 1 wins. So there is one case where player 1 wins so the output should be true, why is it given false??please solve my doubt"
                    },
                    {
                        "username": "codenameoxide_",
                        "content": "that is because while it is possibility, player 2 will not pick 2 when it can pick 5 to win the game. This question is not asking if there is a possibility for player 1 to win the game, but rather the outcome of player 1 when both of them play \"optimally\"."
                    },
                    {
                        "username": "mahesh105",
                        "content": "I was asked similar question \"BATTLE CLASH\" in my Sprinklr OA 2023. It\\'s bit tricky but yeah solvable and preety good question."
                    },
                    {
                        "username": "Shukla_Yash",
                        "content": "Can i solved this question without using dp\\n\\n\\ni am trying to solve with simple loop but only 30 test cases passed why it comes false for the input {1,1,1,1,1,1,1,1,1} \\n\\nif any one have any idea share with me plese \\nhere is my code :\\nclass Solution {\\npublic:\\n    bool PredictTheWinner(vector<int>& nums) {\\n        int n = nums.size();\\n        int sum,res;\\n        int count =0;\\n        int end = 1;\\n\\n        if(n ==2){\\n            if(nums[0] > nums[1]){\\n                sum +=nums[count];\\n                res += nums[end];\\n            }\\n            else{\\n                sum += nums[end];\\n                res += nums[count];\\n            }\\n        }\\n        if(sum > res){\\n            return true;\\n        }\\n        else if(res == sum){\\n            return true;\\n        }\\n\\n        while(count <n && end <n){\\n            sum +=nums[count];\\n            res += nums[end];\\n\\n            count +=2;\\n            end  += 2;\\n        }\\n        if(sum > res){\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "saeed355ahmed",
                        "content": "Why i cant solve any leetcode question(it my first time), even though they are labeled as easy??"
                    },
                    {
                        "username": "Ludacris2G",
                        "content": "bro trust me I\\'ve been using leetcode almost daily for like half a year to a year now and I\\'m still not able to solve almost anything."
                    },
                    {
                        "username": "schwemj",
                        "content": "pretty much anyone using leetcode for the first time has experienced this... and it's not your fault! here is what has helped others and myself: when looking at the list of problems, don't sort or filter them by \"difficulty\"; instead, you'll want to toggle the little \"acceptance\" button to show you the questions sorted by acceptance rates in *descending* order. that way you will see problems that many people have had an easier time solving right on the top of the list. \n\nthe thing is, some problems labeled as easy are a lot harder than others with the same easy label. i've even found that there are medium questions with a high acceptance rate that were way easier to solve than easy questions with a lower acceptance rate. one reason for the seemingly chaotic system is that by default, all problems will be shown in order of creation. another reason is that multiple people are working on creating the questions, and some will design puzzles in one category that are more complex than others in the same category (it's a spectrum!). \nit's also good to remember that the labels \"easy/medium/hard\" are chosen by humans (who are inherently biased) and therefore highly subjective, since not everyone will find the same problem as easy or as hard to solve as their peers do. \n\ndon't despair and keep on coding! "
                    },
                    {
                        "username": "r_o_xx_",
                        "content": "Trust me bro even I am not able to solve them"
                    },
                    {
                        "username": "MrEmirhan",
                        "content": "Behavior of player 2 is not described. It is not appropriate to say `player 1 will never be the winner and you need to return false.`\\nin the example 1 because if player 2 behaves different, player 1 can win. Please update/improve description."
                    },
                    {
                        "username": "wafsinc",
                        "content": "It says \"You may assume that both players are playing optimally\"."
                    },
                    {
                        "username": "codenameoxide_",
                        "content": "DP not necessary to get Accepted :)"
                    },
                    {
                        "username": "rakhikumari6602",
                        "content": "Please someone help,i am using 2 pointer approach and its faling some testcases.\\n\\n\\nclass Solution {\\n    public boolean PredictTheWinner(int[] nums) {\\n\\n        int n=nums.length;\\n        int left=0;\\n        int right = nums.length-1;\\n       \\n         int p1=0,p2=0;\\n         boolean flag=true;\\n        \\n\\n        while(left>right)\\n        {\\n        if(flag==true)          \\n         {\\n             p1+= Math.max(nums[left],nums[right]);\\n             if(nums[left] >nums[right])\\n             {\\n              left=left+1;\\n              \\n             }\\n\\n              else\\n              {\\n               right = right-1;\\n               \\n              }\\n\\n             flag=false;\\n         }\\n         \\n         else\\n         {\\n             p2+= Math.max(nums[left],nums[right]);\\n\\n              if(nums[left] >nums[right])\\n              {\\n              left=left+1;\\n            \\n              }\\n\\n              else\\n              {\\n               right = right-1;\\n               \\n              }\\n\\n             flag=true;\\n         }\\n         \\n        }\\n        \\n\\n        if(p1 >= p2) return true;\\n\\n        return false;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "dheeraj2002_",
                        "content": "To start with the description says that the both players play optimally, you interpreted it wrongly as optimally per step, which is not the case. It means the players are playing the game with the motive to win, and even if they select the lesser integer out of the two in a step, if they see the next moves they will win, they will still select them. The question is quite similar to min-max algorithm where one player plays for max utility and another player tries to decrease the overall utility of the player1. So if you had knowledge about min-max algorithm, after some changes, this question could be solved easily."
                    },
                    {
                        "username": "codenameoxide_",
                        "content": "This is more of a subset sum problem where u generate subsets by picking either leftmost or rightmost element. Subset category problems are solved by exploring all possible results. If in doubt, always see the constraints. Constraints are good hint of what type of algorithm pattern is expected. With ip as small as 20, generating all subsets and verifying it will not result in TLE. An ip size of 10^3 can\\'t be solved by recursion, but possible with 2D DP.\\n"
                    },
                    {
                        "username": "anuron_das",
                        "content": "Going by two pointers is like thinking greedily. It is not a greedy problem. I mean think about it, for the test case `[2,100,3,4,1]`, if you start off by taking the maximum from the ends then, the `100` at the `2nd` position will go to your opponent. \\n\\nYou will greedily go for `2`, then your opponent will straight up go for `100`, and now you have no way to defeat him. Better to go for all possible options, or algorithmically speaking, go for DP."
                    },
                    {
                        "username": "anuron_das",
                        "content": "This was actually asked in Cisco\\'s OA. Sadly the only question our team could solve..."
                    },
                    {
                        "username": "anantverma711",
                        "content": "Yes, they were shooting targets XD"
                    }
                ]
            },
            {
                "id": 1990253,
                "content": [
                    {
                        "username": "halfengineer",
                        "content": "60/62 test case\\uD83D\\uDE29\\uD83D\\uDE29"
                    },
                    {
                        "username": "stuartYoung_",
                        "content": "Remember one thumb rule of these game based problems in which the winner or loser is asked and both playing optimally. (p1 and p2)\\n\\nsuppose you are p1 and and i am p2\\n\\n#at your chance, you will try your best to win\\n\\n#and at my chance I will do my best to make you loser, so prepare for the worst\\n\\ntherefore I give you the worst choices\\nand out of these worsts you have to pick the best\\n################################\\n\\nQuestion:\\n\\nsuppose you are with  i<---->j  range. \\nso either you will choose i or j right? (first or last)  and got nums[i] or nums[j]\\n\\n\\n1)\\nlet you chose i , now your opponent will also have two choice between (i+1<------>j) .so either he will choose i+1 or j , ok?\\nso now he will choose in such a way that he can make you loser  and you got minimum of his two choices i.e.  min(solve(i+2,j) , solve(i+1,j-1) )\\n\\nso finaly you got :\\nnums[i] + min(solve(i+2,j) , solve(i+1,j-1) )\\n\\n2)\\nNOW suppose you had chosen j at first step\\nso opponent left with range of  ( i<----->j-1 )\\n, he can choose either i+1 or j-1 \\n\\nand, ultimately  in similar fashion you got:\\nnums[j] + min(solve(i+1 , j-1) , solve(i , j-2) )\\n\\n\\nat beginning as i said , you also want to be a winner so you choose best of all minimums (worsts)\\n\\ni.e. max of 1st case and 2nd case...\\n\\n\\ntherefore ans=max(1st case,2nd case)\\n\\nrecursively do above approach.  \\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "harshitarmishra",
                        "content": "In example 1, if player 1 chooses 2 first , and then player 2 chooses 1, and then again player 1 chooses 5 then player 1 (total score 7) wins over player 2 (total score 1) then player 1 wins. So there is one case where player 1 wins so the output should be true, why is it given false??please solve my doubt"
                    },
                    {
                        "username": "codenameoxide_",
                        "content": "that is because while it is possibility, player 2 will not pick 2 when it can pick 5 to win the game. This question is not asking if there is a possibility for player 1 to win the game, but rather the outcome of player 1 when both of them play \"optimally\"."
                    },
                    {
                        "username": "mahesh105",
                        "content": "I was asked similar question \"BATTLE CLASH\" in my Sprinklr OA 2023. It\\'s bit tricky but yeah solvable and preety good question."
                    },
                    {
                        "username": "Shukla_Yash",
                        "content": "Can i solved this question without using dp\\n\\n\\ni am trying to solve with simple loop but only 30 test cases passed why it comes false for the input {1,1,1,1,1,1,1,1,1} \\n\\nif any one have any idea share with me plese \\nhere is my code :\\nclass Solution {\\npublic:\\n    bool PredictTheWinner(vector<int>& nums) {\\n        int n = nums.size();\\n        int sum,res;\\n        int count =0;\\n        int end = 1;\\n\\n        if(n ==2){\\n            if(nums[0] > nums[1]){\\n                sum +=nums[count];\\n                res += nums[end];\\n            }\\n            else{\\n                sum += nums[end];\\n                res += nums[count];\\n            }\\n        }\\n        if(sum > res){\\n            return true;\\n        }\\n        else if(res == sum){\\n            return true;\\n        }\\n\\n        while(count <n && end <n){\\n            sum +=nums[count];\\n            res += nums[end];\\n\\n            count +=2;\\n            end  += 2;\\n        }\\n        if(sum > res){\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "saeed355ahmed",
                        "content": "Why i cant solve any leetcode question(it my first time), even though they are labeled as easy??"
                    },
                    {
                        "username": "Ludacris2G",
                        "content": "bro trust me I\\'ve been using leetcode almost daily for like half a year to a year now and I\\'m still not able to solve almost anything."
                    },
                    {
                        "username": "schwemj",
                        "content": "pretty much anyone using leetcode for the first time has experienced this... and it's not your fault! here is what has helped others and myself: when looking at the list of problems, don't sort or filter them by \"difficulty\"; instead, you'll want to toggle the little \"acceptance\" button to show you the questions sorted by acceptance rates in *descending* order. that way you will see problems that many people have had an easier time solving right on the top of the list. \n\nthe thing is, some problems labeled as easy are a lot harder than others with the same easy label. i've even found that there are medium questions with a high acceptance rate that were way easier to solve than easy questions with a lower acceptance rate. one reason for the seemingly chaotic system is that by default, all problems will be shown in order of creation. another reason is that multiple people are working on creating the questions, and some will design puzzles in one category that are more complex than others in the same category (it's a spectrum!). \nit's also good to remember that the labels \"easy/medium/hard\" are chosen by humans (who are inherently biased) and therefore highly subjective, since not everyone will find the same problem as easy or as hard to solve as their peers do. \n\ndon't despair and keep on coding! "
                    },
                    {
                        "username": "r_o_xx_",
                        "content": "Trust me bro even I am not able to solve them"
                    },
                    {
                        "username": "MrEmirhan",
                        "content": "Behavior of player 2 is not described. It is not appropriate to say `player 1 will never be the winner and you need to return false.`\\nin the example 1 because if player 2 behaves different, player 1 can win. Please update/improve description."
                    },
                    {
                        "username": "wafsinc",
                        "content": "It says \"You may assume that both players are playing optimally\"."
                    },
                    {
                        "username": "codenameoxide_",
                        "content": "DP not necessary to get Accepted :)"
                    },
                    {
                        "username": "rakhikumari6602",
                        "content": "Please someone help,i am using 2 pointer approach and its faling some testcases.\\n\\n\\nclass Solution {\\n    public boolean PredictTheWinner(int[] nums) {\\n\\n        int n=nums.length;\\n        int left=0;\\n        int right = nums.length-1;\\n       \\n         int p1=0,p2=0;\\n         boolean flag=true;\\n        \\n\\n        while(left>right)\\n        {\\n        if(flag==true)          \\n         {\\n             p1+= Math.max(nums[left],nums[right]);\\n             if(nums[left] >nums[right])\\n             {\\n              left=left+1;\\n              \\n             }\\n\\n              else\\n              {\\n               right = right-1;\\n               \\n              }\\n\\n             flag=false;\\n         }\\n         \\n         else\\n         {\\n             p2+= Math.max(nums[left],nums[right]);\\n\\n              if(nums[left] >nums[right])\\n              {\\n              left=left+1;\\n            \\n              }\\n\\n              else\\n              {\\n               right = right-1;\\n               \\n              }\\n\\n             flag=true;\\n         }\\n         \\n        }\\n        \\n\\n        if(p1 >= p2) return true;\\n\\n        return false;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "dheeraj2002_",
                        "content": "To start with the description says that the both players play optimally, you interpreted it wrongly as optimally per step, which is not the case. It means the players are playing the game with the motive to win, and even if they select the lesser integer out of the two in a step, if they see the next moves they will win, they will still select them. The question is quite similar to min-max algorithm where one player plays for max utility and another player tries to decrease the overall utility of the player1. So if you had knowledge about min-max algorithm, after some changes, this question could be solved easily."
                    },
                    {
                        "username": "codenameoxide_",
                        "content": "This is more of a subset sum problem where u generate subsets by picking either leftmost or rightmost element. Subset category problems are solved by exploring all possible results. If in doubt, always see the constraints. Constraints are good hint of what type of algorithm pattern is expected. With ip as small as 20, generating all subsets and verifying it will not result in TLE. An ip size of 10^3 can\\'t be solved by recursion, but possible with 2D DP.\\n"
                    },
                    {
                        "username": "anuron_das",
                        "content": "Going by two pointers is like thinking greedily. It is not a greedy problem. I mean think about it, for the test case `[2,100,3,4,1]`, if you start off by taking the maximum from the ends then, the `100` at the `2nd` position will go to your opponent. \\n\\nYou will greedily go for `2`, then your opponent will straight up go for `100`, and now you have no way to defeat him. Better to go for all possible options, or algorithmically speaking, go for DP."
                    },
                    {
                        "username": "anuron_das",
                        "content": "This was actually asked in Cisco\\'s OA. Sadly the only question our team could solve..."
                    },
                    {
                        "username": "anantverma711",
                        "content": "Yes, they were shooting targets XD"
                    }
                ]
            },
            {
                "id": 1990199,
                "content": [
                    {
                        "username": "halfengineer",
                        "content": "60/62 test case\\uD83D\\uDE29\\uD83D\\uDE29"
                    },
                    {
                        "username": "stuartYoung_",
                        "content": "Remember one thumb rule of these game based problems in which the winner or loser is asked and both playing optimally. (p1 and p2)\\n\\nsuppose you are p1 and and i am p2\\n\\n#at your chance, you will try your best to win\\n\\n#and at my chance I will do my best to make you loser, so prepare for the worst\\n\\ntherefore I give you the worst choices\\nand out of these worsts you have to pick the best\\n################################\\n\\nQuestion:\\n\\nsuppose you are with  i<---->j  range. \\nso either you will choose i or j right? (first or last)  and got nums[i] or nums[j]\\n\\n\\n1)\\nlet you chose i , now your opponent will also have two choice between (i+1<------>j) .so either he will choose i+1 or j , ok?\\nso now he will choose in such a way that he can make you loser  and you got minimum of his two choices i.e.  min(solve(i+2,j) , solve(i+1,j-1) )\\n\\nso finaly you got :\\nnums[i] + min(solve(i+2,j) , solve(i+1,j-1) )\\n\\n2)\\nNOW suppose you had chosen j at first step\\nso opponent left with range of  ( i<----->j-1 )\\n, he can choose either i+1 or j-1 \\n\\nand, ultimately  in similar fashion you got:\\nnums[j] + min(solve(i+1 , j-1) , solve(i , j-2) )\\n\\n\\nat beginning as i said , you also want to be a winner so you choose best of all minimums (worsts)\\n\\ni.e. max of 1st case and 2nd case...\\n\\n\\ntherefore ans=max(1st case,2nd case)\\n\\nrecursively do above approach.  \\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "harshitarmishra",
                        "content": "In example 1, if player 1 chooses 2 first , and then player 2 chooses 1, and then again player 1 chooses 5 then player 1 (total score 7) wins over player 2 (total score 1) then player 1 wins. So there is one case where player 1 wins so the output should be true, why is it given false??please solve my doubt"
                    },
                    {
                        "username": "codenameoxide_",
                        "content": "that is because while it is possibility, player 2 will not pick 2 when it can pick 5 to win the game. This question is not asking if there is a possibility for player 1 to win the game, but rather the outcome of player 1 when both of them play \"optimally\"."
                    },
                    {
                        "username": "mahesh105",
                        "content": "I was asked similar question \"BATTLE CLASH\" in my Sprinklr OA 2023. It\\'s bit tricky but yeah solvable and preety good question."
                    },
                    {
                        "username": "Shukla_Yash",
                        "content": "Can i solved this question without using dp\\n\\n\\ni am trying to solve with simple loop but only 30 test cases passed why it comes false for the input {1,1,1,1,1,1,1,1,1} \\n\\nif any one have any idea share with me plese \\nhere is my code :\\nclass Solution {\\npublic:\\n    bool PredictTheWinner(vector<int>& nums) {\\n        int n = nums.size();\\n        int sum,res;\\n        int count =0;\\n        int end = 1;\\n\\n        if(n ==2){\\n            if(nums[0] > nums[1]){\\n                sum +=nums[count];\\n                res += nums[end];\\n            }\\n            else{\\n                sum += nums[end];\\n                res += nums[count];\\n            }\\n        }\\n        if(sum > res){\\n            return true;\\n        }\\n        else if(res == sum){\\n            return true;\\n        }\\n\\n        while(count <n && end <n){\\n            sum +=nums[count];\\n            res += nums[end];\\n\\n            count +=2;\\n            end  += 2;\\n        }\\n        if(sum > res){\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "saeed355ahmed",
                        "content": "Why i cant solve any leetcode question(it my first time), even though they are labeled as easy??"
                    },
                    {
                        "username": "Ludacris2G",
                        "content": "bro trust me I\\'ve been using leetcode almost daily for like half a year to a year now and I\\'m still not able to solve almost anything."
                    },
                    {
                        "username": "schwemj",
                        "content": "pretty much anyone using leetcode for the first time has experienced this... and it's not your fault! here is what has helped others and myself: when looking at the list of problems, don't sort or filter them by \"difficulty\"; instead, you'll want to toggle the little \"acceptance\" button to show you the questions sorted by acceptance rates in *descending* order. that way you will see problems that many people have had an easier time solving right on the top of the list. \n\nthe thing is, some problems labeled as easy are a lot harder than others with the same easy label. i've even found that there are medium questions with a high acceptance rate that were way easier to solve than easy questions with a lower acceptance rate. one reason for the seemingly chaotic system is that by default, all problems will be shown in order of creation. another reason is that multiple people are working on creating the questions, and some will design puzzles in one category that are more complex than others in the same category (it's a spectrum!). \nit's also good to remember that the labels \"easy/medium/hard\" are chosen by humans (who are inherently biased) and therefore highly subjective, since not everyone will find the same problem as easy or as hard to solve as their peers do. \n\ndon't despair and keep on coding! "
                    },
                    {
                        "username": "r_o_xx_",
                        "content": "Trust me bro even I am not able to solve them"
                    },
                    {
                        "username": "MrEmirhan",
                        "content": "Behavior of player 2 is not described. It is not appropriate to say `player 1 will never be the winner and you need to return false.`\\nin the example 1 because if player 2 behaves different, player 1 can win. Please update/improve description."
                    },
                    {
                        "username": "wafsinc",
                        "content": "It says \"You may assume that both players are playing optimally\"."
                    },
                    {
                        "username": "codenameoxide_",
                        "content": "DP not necessary to get Accepted :)"
                    },
                    {
                        "username": "rakhikumari6602",
                        "content": "Please someone help,i am using 2 pointer approach and its faling some testcases.\\n\\n\\nclass Solution {\\n    public boolean PredictTheWinner(int[] nums) {\\n\\n        int n=nums.length;\\n        int left=0;\\n        int right = nums.length-1;\\n       \\n         int p1=0,p2=0;\\n         boolean flag=true;\\n        \\n\\n        while(left>right)\\n        {\\n        if(flag==true)          \\n         {\\n             p1+= Math.max(nums[left],nums[right]);\\n             if(nums[left] >nums[right])\\n             {\\n              left=left+1;\\n              \\n             }\\n\\n              else\\n              {\\n               right = right-1;\\n               \\n              }\\n\\n             flag=false;\\n         }\\n         \\n         else\\n         {\\n             p2+= Math.max(nums[left],nums[right]);\\n\\n              if(nums[left] >nums[right])\\n              {\\n              left=left+1;\\n            \\n              }\\n\\n              else\\n              {\\n               right = right-1;\\n               \\n              }\\n\\n             flag=true;\\n         }\\n         \\n        }\\n        \\n\\n        if(p1 >= p2) return true;\\n\\n        return false;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "dheeraj2002_",
                        "content": "To start with the description says that the both players play optimally, you interpreted it wrongly as optimally per step, which is not the case. It means the players are playing the game with the motive to win, and even if they select the lesser integer out of the two in a step, if they see the next moves they will win, they will still select them. The question is quite similar to min-max algorithm where one player plays for max utility and another player tries to decrease the overall utility of the player1. So if you had knowledge about min-max algorithm, after some changes, this question could be solved easily."
                    },
                    {
                        "username": "codenameoxide_",
                        "content": "This is more of a subset sum problem where u generate subsets by picking either leftmost or rightmost element. Subset category problems are solved by exploring all possible results. If in doubt, always see the constraints. Constraints are good hint of what type of algorithm pattern is expected. With ip as small as 20, generating all subsets and verifying it will not result in TLE. An ip size of 10^3 can\\'t be solved by recursion, but possible with 2D DP.\\n"
                    },
                    {
                        "username": "anuron_das",
                        "content": "Going by two pointers is like thinking greedily. It is not a greedy problem. I mean think about it, for the test case `[2,100,3,4,1]`, if you start off by taking the maximum from the ends then, the `100` at the `2nd` position will go to your opponent. \\n\\nYou will greedily go for `2`, then your opponent will straight up go for `100`, and now you have no way to defeat him. Better to go for all possible options, or algorithmically speaking, go for DP."
                    },
                    {
                        "username": "anuron_das",
                        "content": "This was actually asked in Cisco\\'s OA. Sadly the only question our team could solve..."
                    },
                    {
                        "username": "anantverma711",
                        "content": "Yes, they were shooting targets XD"
                    }
                ]
            },
            {
                "id": 1990038,
                "content": [
                    {
                        "username": "halfengineer",
                        "content": "60/62 test case\\uD83D\\uDE29\\uD83D\\uDE29"
                    },
                    {
                        "username": "stuartYoung_",
                        "content": "Remember one thumb rule of these game based problems in which the winner or loser is asked and both playing optimally. (p1 and p2)\\n\\nsuppose you are p1 and and i am p2\\n\\n#at your chance, you will try your best to win\\n\\n#and at my chance I will do my best to make you loser, so prepare for the worst\\n\\ntherefore I give you the worst choices\\nand out of these worsts you have to pick the best\\n################################\\n\\nQuestion:\\n\\nsuppose you are with  i<---->j  range. \\nso either you will choose i or j right? (first or last)  and got nums[i] or nums[j]\\n\\n\\n1)\\nlet you chose i , now your opponent will also have two choice between (i+1<------>j) .so either he will choose i+1 or j , ok?\\nso now he will choose in such a way that he can make you loser  and you got minimum of his two choices i.e.  min(solve(i+2,j) , solve(i+1,j-1) )\\n\\nso finaly you got :\\nnums[i] + min(solve(i+2,j) , solve(i+1,j-1) )\\n\\n2)\\nNOW suppose you had chosen j at first step\\nso opponent left with range of  ( i<----->j-1 )\\n, he can choose either i+1 or j-1 \\n\\nand, ultimately  in similar fashion you got:\\nnums[j] + min(solve(i+1 , j-1) , solve(i , j-2) )\\n\\n\\nat beginning as i said , you also want to be a winner so you choose best of all minimums (worsts)\\n\\ni.e. max of 1st case and 2nd case...\\n\\n\\ntherefore ans=max(1st case,2nd case)\\n\\nrecursively do above approach.  \\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "harshitarmishra",
                        "content": "In example 1, if player 1 chooses 2 first , and then player 2 chooses 1, and then again player 1 chooses 5 then player 1 (total score 7) wins over player 2 (total score 1) then player 1 wins. So there is one case where player 1 wins so the output should be true, why is it given false??please solve my doubt"
                    },
                    {
                        "username": "codenameoxide_",
                        "content": "that is because while it is possibility, player 2 will not pick 2 when it can pick 5 to win the game. This question is not asking if there is a possibility for player 1 to win the game, but rather the outcome of player 1 when both of them play \"optimally\"."
                    },
                    {
                        "username": "mahesh105",
                        "content": "I was asked similar question \"BATTLE CLASH\" in my Sprinklr OA 2023. It\\'s bit tricky but yeah solvable and preety good question."
                    },
                    {
                        "username": "Shukla_Yash",
                        "content": "Can i solved this question without using dp\\n\\n\\ni am trying to solve with simple loop but only 30 test cases passed why it comes false for the input {1,1,1,1,1,1,1,1,1} \\n\\nif any one have any idea share with me plese \\nhere is my code :\\nclass Solution {\\npublic:\\n    bool PredictTheWinner(vector<int>& nums) {\\n        int n = nums.size();\\n        int sum,res;\\n        int count =0;\\n        int end = 1;\\n\\n        if(n ==2){\\n            if(nums[0] > nums[1]){\\n                sum +=nums[count];\\n                res += nums[end];\\n            }\\n            else{\\n                sum += nums[end];\\n                res += nums[count];\\n            }\\n        }\\n        if(sum > res){\\n            return true;\\n        }\\n        else if(res == sum){\\n            return true;\\n        }\\n\\n        while(count <n && end <n){\\n            sum +=nums[count];\\n            res += nums[end];\\n\\n            count +=2;\\n            end  += 2;\\n        }\\n        if(sum > res){\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "saeed355ahmed",
                        "content": "Why i cant solve any leetcode question(it my first time), even though they are labeled as easy??"
                    },
                    {
                        "username": "Ludacris2G",
                        "content": "bro trust me I\\'ve been using leetcode almost daily for like half a year to a year now and I\\'m still not able to solve almost anything."
                    },
                    {
                        "username": "schwemj",
                        "content": "pretty much anyone using leetcode for the first time has experienced this... and it's not your fault! here is what has helped others and myself: when looking at the list of problems, don't sort or filter them by \"difficulty\"; instead, you'll want to toggle the little \"acceptance\" button to show you the questions sorted by acceptance rates in *descending* order. that way you will see problems that many people have had an easier time solving right on the top of the list. \n\nthe thing is, some problems labeled as easy are a lot harder than others with the same easy label. i've even found that there are medium questions with a high acceptance rate that were way easier to solve than easy questions with a lower acceptance rate. one reason for the seemingly chaotic system is that by default, all problems will be shown in order of creation. another reason is that multiple people are working on creating the questions, and some will design puzzles in one category that are more complex than others in the same category (it's a spectrum!). \nit's also good to remember that the labels \"easy/medium/hard\" are chosen by humans (who are inherently biased) and therefore highly subjective, since not everyone will find the same problem as easy or as hard to solve as their peers do. \n\ndon't despair and keep on coding! "
                    },
                    {
                        "username": "r_o_xx_",
                        "content": "Trust me bro even I am not able to solve them"
                    },
                    {
                        "username": "MrEmirhan",
                        "content": "Behavior of player 2 is not described. It is not appropriate to say `player 1 will never be the winner and you need to return false.`\\nin the example 1 because if player 2 behaves different, player 1 can win. Please update/improve description."
                    },
                    {
                        "username": "wafsinc",
                        "content": "It says \"You may assume that both players are playing optimally\"."
                    },
                    {
                        "username": "codenameoxide_",
                        "content": "DP not necessary to get Accepted :)"
                    },
                    {
                        "username": "rakhikumari6602",
                        "content": "Please someone help,i am using 2 pointer approach and its faling some testcases.\\n\\n\\nclass Solution {\\n    public boolean PredictTheWinner(int[] nums) {\\n\\n        int n=nums.length;\\n        int left=0;\\n        int right = nums.length-1;\\n       \\n         int p1=0,p2=0;\\n         boolean flag=true;\\n        \\n\\n        while(left>right)\\n        {\\n        if(flag==true)          \\n         {\\n             p1+= Math.max(nums[left],nums[right]);\\n             if(nums[left] >nums[right])\\n             {\\n              left=left+1;\\n              \\n             }\\n\\n              else\\n              {\\n               right = right-1;\\n               \\n              }\\n\\n             flag=false;\\n         }\\n         \\n         else\\n         {\\n             p2+= Math.max(nums[left],nums[right]);\\n\\n              if(nums[left] >nums[right])\\n              {\\n              left=left+1;\\n            \\n              }\\n\\n              else\\n              {\\n               right = right-1;\\n               \\n              }\\n\\n             flag=true;\\n         }\\n         \\n        }\\n        \\n\\n        if(p1 >= p2) return true;\\n\\n        return false;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "dheeraj2002_",
                        "content": "To start with the description says that the both players play optimally, you interpreted it wrongly as optimally per step, which is not the case. It means the players are playing the game with the motive to win, and even if they select the lesser integer out of the two in a step, if they see the next moves they will win, they will still select them. The question is quite similar to min-max algorithm where one player plays for max utility and another player tries to decrease the overall utility of the player1. So if you had knowledge about min-max algorithm, after some changes, this question could be solved easily."
                    },
                    {
                        "username": "codenameoxide_",
                        "content": "This is more of a subset sum problem where u generate subsets by picking either leftmost or rightmost element. Subset category problems are solved by exploring all possible results. If in doubt, always see the constraints. Constraints are good hint of what type of algorithm pattern is expected. With ip as small as 20, generating all subsets and verifying it will not result in TLE. An ip size of 10^3 can\\'t be solved by recursion, but possible with 2D DP.\\n"
                    },
                    {
                        "username": "anuron_das",
                        "content": "Going by two pointers is like thinking greedily. It is not a greedy problem. I mean think about it, for the test case `[2,100,3,4,1]`, if you start off by taking the maximum from the ends then, the `100` at the `2nd` position will go to your opponent. \\n\\nYou will greedily go for `2`, then your opponent will straight up go for `100`, and now you have no way to defeat him. Better to go for all possible options, or algorithmically speaking, go for DP."
                    },
                    {
                        "username": "anuron_das",
                        "content": "This was actually asked in Cisco\\'s OA. Sadly the only question our team could solve..."
                    },
                    {
                        "username": "anantverma711",
                        "content": "Yes, they were shooting targets XD"
                    }
                ]
            },
            {
                "id": 1989956,
                "content": [
                    {
                        "username": "halfengineer",
                        "content": "60/62 test case\\uD83D\\uDE29\\uD83D\\uDE29"
                    },
                    {
                        "username": "stuartYoung_",
                        "content": "Remember one thumb rule of these game based problems in which the winner or loser is asked and both playing optimally. (p1 and p2)\\n\\nsuppose you are p1 and and i am p2\\n\\n#at your chance, you will try your best to win\\n\\n#and at my chance I will do my best to make you loser, so prepare for the worst\\n\\ntherefore I give you the worst choices\\nand out of these worsts you have to pick the best\\n################################\\n\\nQuestion:\\n\\nsuppose you are with  i<---->j  range. \\nso either you will choose i or j right? (first or last)  and got nums[i] or nums[j]\\n\\n\\n1)\\nlet you chose i , now your opponent will also have two choice between (i+1<------>j) .so either he will choose i+1 or j , ok?\\nso now he will choose in such a way that he can make you loser  and you got minimum of his two choices i.e.  min(solve(i+2,j) , solve(i+1,j-1) )\\n\\nso finaly you got :\\nnums[i] + min(solve(i+2,j) , solve(i+1,j-1) )\\n\\n2)\\nNOW suppose you had chosen j at first step\\nso opponent left with range of  ( i<----->j-1 )\\n, he can choose either i+1 or j-1 \\n\\nand, ultimately  in similar fashion you got:\\nnums[j] + min(solve(i+1 , j-1) , solve(i , j-2) )\\n\\n\\nat beginning as i said , you also want to be a winner so you choose best of all minimums (worsts)\\n\\ni.e. max of 1st case and 2nd case...\\n\\n\\ntherefore ans=max(1st case,2nd case)\\n\\nrecursively do above approach.  \\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "harshitarmishra",
                        "content": "In example 1, if player 1 chooses 2 first , and then player 2 chooses 1, and then again player 1 chooses 5 then player 1 (total score 7) wins over player 2 (total score 1) then player 1 wins. So there is one case where player 1 wins so the output should be true, why is it given false??please solve my doubt"
                    },
                    {
                        "username": "codenameoxide_",
                        "content": "that is because while it is possibility, player 2 will not pick 2 when it can pick 5 to win the game. This question is not asking if there is a possibility for player 1 to win the game, but rather the outcome of player 1 when both of them play \"optimally\"."
                    },
                    {
                        "username": "mahesh105",
                        "content": "I was asked similar question \"BATTLE CLASH\" in my Sprinklr OA 2023. It\\'s bit tricky but yeah solvable and preety good question."
                    },
                    {
                        "username": "Shukla_Yash",
                        "content": "Can i solved this question without using dp\\n\\n\\ni am trying to solve with simple loop but only 30 test cases passed why it comes false for the input {1,1,1,1,1,1,1,1,1} \\n\\nif any one have any idea share with me plese \\nhere is my code :\\nclass Solution {\\npublic:\\n    bool PredictTheWinner(vector<int>& nums) {\\n        int n = nums.size();\\n        int sum,res;\\n        int count =0;\\n        int end = 1;\\n\\n        if(n ==2){\\n            if(nums[0] > nums[1]){\\n                sum +=nums[count];\\n                res += nums[end];\\n            }\\n            else{\\n                sum += nums[end];\\n                res += nums[count];\\n            }\\n        }\\n        if(sum > res){\\n            return true;\\n        }\\n        else if(res == sum){\\n            return true;\\n        }\\n\\n        while(count <n && end <n){\\n            sum +=nums[count];\\n            res += nums[end];\\n\\n            count +=2;\\n            end  += 2;\\n        }\\n        if(sum > res){\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "saeed355ahmed",
                        "content": "Why i cant solve any leetcode question(it my first time), even though they are labeled as easy??"
                    },
                    {
                        "username": "Ludacris2G",
                        "content": "bro trust me I\\'ve been using leetcode almost daily for like half a year to a year now and I\\'m still not able to solve almost anything."
                    },
                    {
                        "username": "schwemj",
                        "content": "pretty much anyone using leetcode for the first time has experienced this... and it's not your fault! here is what has helped others and myself: when looking at the list of problems, don't sort or filter them by \"difficulty\"; instead, you'll want to toggle the little \"acceptance\" button to show you the questions sorted by acceptance rates in *descending* order. that way you will see problems that many people have had an easier time solving right on the top of the list. \n\nthe thing is, some problems labeled as easy are a lot harder than others with the same easy label. i've even found that there are medium questions with a high acceptance rate that were way easier to solve than easy questions with a lower acceptance rate. one reason for the seemingly chaotic system is that by default, all problems will be shown in order of creation. another reason is that multiple people are working on creating the questions, and some will design puzzles in one category that are more complex than others in the same category (it's a spectrum!). \nit's also good to remember that the labels \"easy/medium/hard\" are chosen by humans (who are inherently biased) and therefore highly subjective, since not everyone will find the same problem as easy or as hard to solve as their peers do. \n\ndon't despair and keep on coding! "
                    },
                    {
                        "username": "r_o_xx_",
                        "content": "Trust me bro even I am not able to solve them"
                    },
                    {
                        "username": "MrEmirhan",
                        "content": "Behavior of player 2 is not described. It is not appropriate to say `player 1 will never be the winner and you need to return false.`\\nin the example 1 because if player 2 behaves different, player 1 can win. Please update/improve description."
                    },
                    {
                        "username": "wafsinc",
                        "content": "It says \"You may assume that both players are playing optimally\"."
                    },
                    {
                        "username": "codenameoxide_",
                        "content": "DP not necessary to get Accepted :)"
                    },
                    {
                        "username": "rakhikumari6602",
                        "content": "Please someone help,i am using 2 pointer approach and its faling some testcases.\\n\\n\\nclass Solution {\\n    public boolean PredictTheWinner(int[] nums) {\\n\\n        int n=nums.length;\\n        int left=0;\\n        int right = nums.length-1;\\n       \\n         int p1=0,p2=0;\\n         boolean flag=true;\\n        \\n\\n        while(left>right)\\n        {\\n        if(flag==true)          \\n         {\\n             p1+= Math.max(nums[left],nums[right]);\\n             if(nums[left] >nums[right])\\n             {\\n              left=left+1;\\n              \\n             }\\n\\n              else\\n              {\\n               right = right-1;\\n               \\n              }\\n\\n             flag=false;\\n         }\\n         \\n         else\\n         {\\n             p2+= Math.max(nums[left],nums[right]);\\n\\n              if(nums[left] >nums[right])\\n              {\\n              left=left+1;\\n            \\n              }\\n\\n              else\\n              {\\n               right = right-1;\\n               \\n              }\\n\\n             flag=true;\\n         }\\n         \\n        }\\n        \\n\\n        if(p1 >= p2) return true;\\n\\n        return false;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "dheeraj2002_",
                        "content": "To start with the description says that the both players play optimally, you interpreted it wrongly as optimally per step, which is not the case. It means the players are playing the game with the motive to win, and even if they select the lesser integer out of the two in a step, if they see the next moves they will win, they will still select them. The question is quite similar to min-max algorithm where one player plays for max utility and another player tries to decrease the overall utility of the player1. So if you had knowledge about min-max algorithm, after some changes, this question could be solved easily."
                    },
                    {
                        "username": "codenameoxide_",
                        "content": "This is more of a subset sum problem where u generate subsets by picking either leftmost or rightmost element. Subset category problems are solved by exploring all possible results. If in doubt, always see the constraints. Constraints are good hint of what type of algorithm pattern is expected. With ip as small as 20, generating all subsets and verifying it will not result in TLE. An ip size of 10^3 can\\'t be solved by recursion, but possible with 2D DP.\\n"
                    },
                    {
                        "username": "anuron_das",
                        "content": "Going by two pointers is like thinking greedily. It is not a greedy problem. I mean think about it, for the test case `[2,100,3,4,1]`, if you start off by taking the maximum from the ends then, the `100` at the `2nd` position will go to your opponent. \\n\\nYou will greedily go for `2`, then your opponent will straight up go for `100`, and now you have no way to defeat him. Better to go for all possible options, or algorithmically speaking, go for DP."
                    },
                    {
                        "username": "anuron_das",
                        "content": "This was actually asked in Cisco\\'s OA. Sadly the only question our team could solve..."
                    },
                    {
                        "username": "anantverma711",
                        "content": "Yes, they were shooting targets XD"
                    }
                ]
            },
            {
                "id": 1989953,
                "content": [
                    {
                        "username": "halfengineer",
                        "content": "60/62 test case\\uD83D\\uDE29\\uD83D\\uDE29"
                    },
                    {
                        "username": "stuartYoung_",
                        "content": "Remember one thumb rule of these game based problems in which the winner or loser is asked and both playing optimally. (p1 and p2)\\n\\nsuppose you are p1 and and i am p2\\n\\n#at your chance, you will try your best to win\\n\\n#and at my chance I will do my best to make you loser, so prepare for the worst\\n\\ntherefore I give you the worst choices\\nand out of these worsts you have to pick the best\\n################################\\n\\nQuestion:\\n\\nsuppose you are with  i<---->j  range. \\nso either you will choose i or j right? (first or last)  and got nums[i] or nums[j]\\n\\n\\n1)\\nlet you chose i , now your opponent will also have two choice between (i+1<------>j) .so either he will choose i+1 or j , ok?\\nso now he will choose in such a way that he can make you loser  and you got minimum of his two choices i.e.  min(solve(i+2,j) , solve(i+1,j-1) )\\n\\nso finaly you got :\\nnums[i] + min(solve(i+2,j) , solve(i+1,j-1) )\\n\\n2)\\nNOW suppose you had chosen j at first step\\nso opponent left with range of  ( i<----->j-1 )\\n, he can choose either i+1 or j-1 \\n\\nand, ultimately  in similar fashion you got:\\nnums[j] + min(solve(i+1 , j-1) , solve(i , j-2) )\\n\\n\\nat beginning as i said , you also want to be a winner so you choose best of all minimums (worsts)\\n\\ni.e. max of 1st case and 2nd case...\\n\\n\\ntherefore ans=max(1st case,2nd case)\\n\\nrecursively do above approach.  \\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "harshitarmishra",
                        "content": "In example 1, if player 1 chooses 2 first , and then player 2 chooses 1, and then again player 1 chooses 5 then player 1 (total score 7) wins over player 2 (total score 1) then player 1 wins. So there is one case where player 1 wins so the output should be true, why is it given false??please solve my doubt"
                    },
                    {
                        "username": "codenameoxide_",
                        "content": "that is because while it is possibility, player 2 will not pick 2 when it can pick 5 to win the game. This question is not asking if there is a possibility for player 1 to win the game, but rather the outcome of player 1 when both of them play \"optimally\"."
                    },
                    {
                        "username": "mahesh105",
                        "content": "I was asked similar question \"BATTLE CLASH\" in my Sprinklr OA 2023. It\\'s bit tricky but yeah solvable and preety good question."
                    },
                    {
                        "username": "Shukla_Yash",
                        "content": "Can i solved this question without using dp\\n\\n\\ni am trying to solve with simple loop but only 30 test cases passed why it comes false for the input {1,1,1,1,1,1,1,1,1} \\n\\nif any one have any idea share with me plese \\nhere is my code :\\nclass Solution {\\npublic:\\n    bool PredictTheWinner(vector<int>& nums) {\\n        int n = nums.size();\\n        int sum,res;\\n        int count =0;\\n        int end = 1;\\n\\n        if(n ==2){\\n            if(nums[0] > nums[1]){\\n                sum +=nums[count];\\n                res += nums[end];\\n            }\\n            else{\\n                sum += nums[end];\\n                res += nums[count];\\n            }\\n        }\\n        if(sum > res){\\n            return true;\\n        }\\n        else if(res == sum){\\n            return true;\\n        }\\n\\n        while(count <n && end <n){\\n            sum +=nums[count];\\n            res += nums[end];\\n\\n            count +=2;\\n            end  += 2;\\n        }\\n        if(sum > res){\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "saeed355ahmed",
                        "content": "Why i cant solve any leetcode question(it my first time), even though they are labeled as easy??"
                    },
                    {
                        "username": "Ludacris2G",
                        "content": "bro trust me I\\'ve been using leetcode almost daily for like half a year to a year now and I\\'m still not able to solve almost anything."
                    },
                    {
                        "username": "schwemj",
                        "content": "pretty much anyone using leetcode for the first time has experienced this... and it's not your fault! here is what has helped others and myself: when looking at the list of problems, don't sort or filter them by \"difficulty\"; instead, you'll want to toggle the little \"acceptance\" button to show you the questions sorted by acceptance rates in *descending* order. that way you will see problems that many people have had an easier time solving right on the top of the list. \n\nthe thing is, some problems labeled as easy are a lot harder than others with the same easy label. i've even found that there are medium questions with a high acceptance rate that were way easier to solve than easy questions with a lower acceptance rate. one reason for the seemingly chaotic system is that by default, all problems will be shown in order of creation. another reason is that multiple people are working on creating the questions, and some will design puzzles in one category that are more complex than others in the same category (it's a spectrum!). \nit's also good to remember that the labels \"easy/medium/hard\" are chosen by humans (who are inherently biased) and therefore highly subjective, since not everyone will find the same problem as easy or as hard to solve as their peers do. \n\ndon't despair and keep on coding! "
                    },
                    {
                        "username": "r_o_xx_",
                        "content": "Trust me bro even I am not able to solve them"
                    },
                    {
                        "username": "MrEmirhan",
                        "content": "Behavior of player 2 is not described. It is not appropriate to say `player 1 will never be the winner and you need to return false.`\\nin the example 1 because if player 2 behaves different, player 1 can win. Please update/improve description."
                    },
                    {
                        "username": "wafsinc",
                        "content": "It says \"You may assume that both players are playing optimally\"."
                    },
                    {
                        "username": "codenameoxide_",
                        "content": "DP not necessary to get Accepted :)"
                    },
                    {
                        "username": "rakhikumari6602",
                        "content": "Please someone help,i am using 2 pointer approach and its faling some testcases.\\n\\n\\nclass Solution {\\n    public boolean PredictTheWinner(int[] nums) {\\n\\n        int n=nums.length;\\n        int left=0;\\n        int right = nums.length-1;\\n       \\n         int p1=0,p2=0;\\n         boolean flag=true;\\n        \\n\\n        while(left>right)\\n        {\\n        if(flag==true)          \\n         {\\n             p1+= Math.max(nums[left],nums[right]);\\n             if(nums[left] >nums[right])\\n             {\\n              left=left+1;\\n              \\n             }\\n\\n              else\\n              {\\n               right = right-1;\\n               \\n              }\\n\\n             flag=false;\\n         }\\n         \\n         else\\n         {\\n             p2+= Math.max(nums[left],nums[right]);\\n\\n              if(nums[left] >nums[right])\\n              {\\n              left=left+1;\\n            \\n              }\\n\\n              else\\n              {\\n               right = right-1;\\n               \\n              }\\n\\n             flag=true;\\n         }\\n         \\n        }\\n        \\n\\n        if(p1 >= p2) return true;\\n\\n        return false;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "dheeraj2002_",
                        "content": "To start with the description says that the both players play optimally, you interpreted it wrongly as optimally per step, which is not the case. It means the players are playing the game with the motive to win, and even if they select the lesser integer out of the two in a step, if they see the next moves they will win, they will still select them. The question is quite similar to min-max algorithm where one player plays for max utility and another player tries to decrease the overall utility of the player1. So if you had knowledge about min-max algorithm, after some changes, this question could be solved easily."
                    },
                    {
                        "username": "codenameoxide_",
                        "content": "This is more of a subset sum problem where u generate subsets by picking either leftmost or rightmost element. Subset category problems are solved by exploring all possible results. If in doubt, always see the constraints. Constraints are good hint of what type of algorithm pattern is expected. With ip as small as 20, generating all subsets and verifying it will not result in TLE. An ip size of 10^3 can\\'t be solved by recursion, but possible with 2D DP.\\n"
                    },
                    {
                        "username": "anuron_das",
                        "content": "Going by two pointers is like thinking greedily. It is not a greedy problem. I mean think about it, for the test case `[2,100,3,4,1]`, if you start off by taking the maximum from the ends then, the `100` at the `2nd` position will go to your opponent. \\n\\nYou will greedily go for `2`, then your opponent will straight up go for `100`, and now you have no way to defeat him. Better to go for all possible options, or algorithmically speaking, go for DP."
                    },
                    {
                        "username": "anuron_das",
                        "content": "This was actually asked in Cisco\\'s OA. Sadly the only question our team could solve..."
                    },
                    {
                        "username": "anantverma711",
                        "content": "Yes, they were shooting targets XD"
                    }
                ]
            },
            {
                "id": 1989896,
                "content": [
                    {
                        "username": "halfengineer",
                        "content": "60/62 test case\\uD83D\\uDE29\\uD83D\\uDE29"
                    },
                    {
                        "username": "stuartYoung_",
                        "content": "Remember one thumb rule of these game based problems in which the winner or loser is asked and both playing optimally. (p1 and p2)\\n\\nsuppose you are p1 and and i am p2\\n\\n#at your chance, you will try your best to win\\n\\n#and at my chance I will do my best to make you loser, so prepare for the worst\\n\\ntherefore I give you the worst choices\\nand out of these worsts you have to pick the best\\n################################\\n\\nQuestion:\\n\\nsuppose you are with  i<---->j  range. \\nso either you will choose i or j right? (first or last)  and got nums[i] or nums[j]\\n\\n\\n1)\\nlet you chose i , now your opponent will also have two choice between (i+1<------>j) .so either he will choose i+1 or j , ok?\\nso now he will choose in such a way that he can make you loser  and you got minimum of his two choices i.e.  min(solve(i+2,j) , solve(i+1,j-1) )\\n\\nso finaly you got :\\nnums[i] + min(solve(i+2,j) , solve(i+1,j-1) )\\n\\n2)\\nNOW suppose you had chosen j at first step\\nso opponent left with range of  ( i<----->j-1 )\\n, he can choose either i+1 or j-1 \\n\\nand, ultimately  in similar fashion you got:\\nnums[j] + min(solve(i+1 , j-1) , solve(i , j-2) )\\n\\n\\nat beginning as i said , you also want to be a winner so you choose best of all minimums (worsts)\\n\\ni.e. max of 1st case and 2nd case...\\n\\n\\ntherefore ans=max(1st case,2nd case)\\n\\nrecursively do above approach.  \\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "harshitarmishra",
                        "content": "In example 1, if player 1 chooses 2 first , and then player 2 chooses 1, and then again player 1 chooses 5 then player 1 (total score 7) wins over player 2 (total score 1) then player 1 wins. So there is one case where player 1 wins so the output should be true, why is it given false??please solve my doubt"
                    },
                    {
                        "username": "codenameoxide_",
                        "content": "that is because while it is possibility, player 2 will not pick 2 when it can pick 5 to win the game. This question is not asking if there is a possibility for player 1 to win the game, but rather the outcome of player 1 when both of them play \"optimally\"."
                    },
                    {
                        "username": "mahesh105",
                        "content": "I was asked similar question \"BATTLE CLASH\" in my Sprinklr OA 2023. It\\'s bit tricky but yeah solvable and preety good question."
                    },
                    {
                        "username": "Shukla_Yash",
                        "content": "Can i solved this question without using dp\\n\\n\\ni am trying to solve with simple loop but only 30 test cases passed why it comes false for the input {1,1,1,1,1,1,1,1,1} \\n\\nif any one have any idea share with me plese \\nhere is my code :\\nclass Solution {\\npublic:\\n    bool PredictTheWinner(vector<int>& nums) {\\n        int n = nums.size();\\n        int sum,res;\\n        int count =0;\\n        int end = 1;\\n\\n        if(n ==2){\\n            if(nums[0] > nums[1]){\\n                sum +=nums[count];\\n                res += nums[end];\\n            }\\n            else{\\n                sum += nums[end];\\n                res += nums[count];\\n            }\\n        }\\n        if(sum > res){\\n            return true;\\n        }\\n        else if(res == sum){\\n            return true;\\n        }\\n\\n        while(count <n && end <n){\\n            sum +=nums[count];\\n            res += nums[end];\\n\\n            count +=2;\\n            end  += 2;\\n        }\\n        if(sum > res){\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "saeed355ahmed",
                        "content": "Why i cant solve any leetcode question(it my first time), even though they are labeled as easy??"
                    },
                    {
                        "username": "Ludacris2G",
                        "content": "bro trust me I\\'ve been using leetcode almost daily for like half a year to a year now and I\\'m still not able to solve almost anything."
                    },
                    {
                        "username": "schwemj",
                        "content": "pretty much anyone using leetcode for the first time has experienced this... and it's not your fault! here is what has helped others and myself: when looking at the list of problems, don't sort or filter them by \"difficulty\"; instead, you'll want to toggle the little \"acceptance\" button to show you the questions sorted by acceptance rates in *descending* order. that way you will see problems that many people have had an easier time solving right on the top of the list. \n\nthe thing is, some problems labeled as easy are a lot harder than others with the same easy label. i've even found that there are medium questions with a high acceptance rate that were way easier to solve than easy questions with a lower acceptance rate. one reason for the seemingly chaotic system is that by default, all problems will be shown in order of creation. another reason is that multiple people are working on creating the questions, and some will design puzzles in one category that are more complex than others in the same category (it's a spectrum!). \nit's also good to remember that the labels \"easy/medium/hard\" are chosen by humans (who are inherently biased) and therefore highly subjective, since not everyone will find the same problem as easy or as hard to solve as their peers do. \n\ndon't despair and keep on coding! "
                    },
                    {
                        "username": "r_o_xx_",
                        "content": "Trust me bro even I am not able to solve them"
                    },
                    {
                        "username": "MrEmirhan",
                        "content": "Behavior of player 2 is not described. It is not appropriate to say `player 1 will never be the winner and you need to return false.`\\nin the example 1 because if player 2 behaves different, player 1 can win. Please update/improve description."
                    },
                    {
                        "username": "wafsinc",
                        "content": "It says \"You may assume that both players are playing optimally\"."
                    },
                    {
                        "username": "codenameoxide_",
                        "content": "DP not necessary to get Accepted :)"
                    },
                    {
                        "username": "rakhikumari6602",
                        "content": "Please someone help,i am using 2 pointer approach and its faling some testcases.\\n\\n\\nclass Solution {\\n    public boolean PredictTheWinner(int[] nums) {\\n\\n        int n=nums.length;\\n        int left=0;\\n        int right = nums.length-1;\\n       \\n         int p1=0,p2=0;\\n         boolean flag=true;\\n        \\n\\n        while(left>right)\\n        {\\n        if(flag==true)          \\n         {\\n             p1+= Math.max(nums[left],nums[right]);\\n             if(nums[left] >nums[right])\\n             {\\n              left=left+1;\\n              \\n             }\\n\\n              else\\n              {\\n               right = right-1;\\n               \\n              }\\n\\n             flag=false;\\n         }\\n         \\n         else\\n         {\\n             p2+= Math.max(nums[left],nums[right]);\\n\\n              if(nums[left] >nums[right])\\n              {\\n              left=left+1;\\n            \\n              }\\n\\n              else\\n              {\\n               right = right-1;\\n               \\n              }\\n\\n             flag=true;\\n         }\\n         \\n        }\\n        \\n\\n        if(p1 >= p2) return true;\\n\\n        return false;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "dheeraj2002_",
                        "content": "To start with the description says that the both players play optimally, you interpreted it wrongly as optimally per step, which is not the case. It means the players are playing the game with the motive to win, and even if they select the lesser integer out of the two in a step, if they see the next moves they will win, they will still select them. The question is quite similar to min-max algorithm where one player plays for max utility and another player tries to decrease the overall utility of the player1. So if you had knowledge about min-max algorithm, after some changes, this question could be solved easily."
                    },
                    {
                        "username": "codenameoxide_",
                        "content": "This is more of a subset sum problem where u generate subsets by picking either leftmost or rightmost element. Subset category problems are solved by exploring all possible results. If in doubt, always see the constraints. Constraints are good hint of what type of algorithm pattern is expected. With ip as small as 20, generating all subsets and verifying it will not result in TLE. An ip size of 10^3 can\\'t be solved by recursion, but possible with 2D DP.\\n"
                    },
                    {
                        "username": "anuron_das",
                        "content": "Going by two pointers is like thinking greedily. It is not a greedy problem. I mean think about it, for the test case `[2,100,3,4,1]`, if you start off by taking the maximum from the ends then, the `100` at the `2nd` position will go to your opponent. \\n\\nYou will greedily go for `2`, then your opponent will straight up go for `100`, and now you have no way to defeat him. Better to go for all possible options, or algorithmically speaking, go for DP."
                    },
                    {
                        "username": "anuron_das",
                        "content": "This was actually asked in Cisco\\'s OA. Sadly the only question our team could solve..."
                    },
                    {
                        "username": "anantverma711",
                        "content": "Yes, they were shooting targets XD"
                    }
                ]
            },
            {
                "id": 1989856,
                "content": [
                    {
                        "username": "Charlemagne5t",
                        "content": "The guys are perfect machines, finding local maximum would not work. Think of DP."
                    },
                    {
                        "username": "psionl0",
                        "content": "With the constraints given (``1 <= nums.length <= 20``) a brute force solution will work. However, it is still worthwhile adding memoization if just for the practice.\\nI would have thought that the need to initialize the dp matrix (which takes O(n^2) time) would have reduced the time difference considerably but that shows what I know: 2 ms vs 79 ms."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "can anybody explain me these two testcases?\\nTestcase -> Expected outcome\\n[1,5,233,7] -> true\\n[2,4,55,6,8] -> false\\n\\nif Both player optimally than T2 would be true and if not than T1 would be false!!!  \\uD83D\\uDE35\\u200D\\uD83D\\uDCAB\\uD83D\\uDE35\\u200D\\uD83D\\uDCAB\\nEither my code fail for 1 or 2"
                    },
                    {
                        "username": "psionl0",
                        "content": "For [1,5,233,7] if player1 chooses 1 then no matter what player2 chooses, it exposes 233 for player1 to take so this is true.\\nFor [2,4,55,6,8], whatever end player1 chooses, player2 chooses the opposite end. Now we are left with [4,55,6] and whichever choice player1 makes, leaves 55 for player2 to grab so this is false."
                    },
                    {
                        "username": "rakeshSharma19",
                        "content": "Here You have to understand that, optimally according to present array,  on each step both are seeing complete array and according to that they will pick the element to become winner.\\nFor array = [1, 5, 233, 7]\\nat step 1 Player1 have 2 option either choose array[0] or array[-1],\\n If player1 array[0] then new array will be [5, 233, 7] and in this case player2 whatever choose Player1 has option to choose 233.\\nif player1 will array[-1] which is 7, then new array will be [1, 5, 233] here player2 has option to choose 233. Here we have to choose optimal value after each step to maximize end result.\\n\\nI hope you have understand the problem."
                    },
                    {
                        "username": "nizam_0134",
                        "content": "[2,4,55,6,8]\\nWhy this test case is False. \\n"
                    },
                    {
                        "username": "nizam_0134",
                        "content": "[@AniEthanHunt](/AniEthanHunt) thanks buddy I get it now "
                    },
                    {
                        "username": "AniEthanHunt",
                        "content": "Player 1 can take 2 or 8.\\nP1 takes 2, then P2 will take 8 and P1 will lose as P2 will get 55 [4, 55, 6]\\nP1 takes 8, then P2 will take 2 and P1 will lose as P2 will get 55 [4, 55, 6]\\n\\nHere, both the player are playing optimally (game theory: min-max algorithm)."
                    },
                    {
                        "username": "pepjaggu2022",
                        "content": "You may assume that both players are playing optimally.\\ncompletely changed the question :("
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "You really thought you could just `return true` and be done with it didn\\'t you?"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "Haha, how did you know? :) I thought I have already solved that before and remembered the super greedy solution, but seems like it was one of the Stone Games..."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Who guys try the codes \"return true\" on the first eye?  :p"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Greate problem! BTW, I wonder why the nums.length is limited in a small region [1, 20]? As for a o(n2) solution, the nums.length can be 1e3 level. "
                    },
                    {
                        "username": "Dhiraj_Mohata",
                        "content": "i haven\\'t seen graph , stack ,queue , tree can i start directly with DP.\\nand how much time it takes to complete complete DSA basics"
                    },
                    {
                        "username": "Dhiraj_Mohata",
                        "content": "[@luanct](/luanct) okay "
                    },
                    {
                        "username": "luanct",
                        "content": "it\\'s still fine but I think you better learn basic DSA and Algo first before learning DP. DP required more skills and experiences. "
                    },
                    {
                        "username": "sagijagadish",
                        "content": "Similar to the Problem: https://leetcode.com/problems/stone-game-iii/description"
                    }
                ]
            },
            {
                "id": 1989792,
                "content": [
                    {
                        "username": "Charlemagne5t",
                        "content": "The guys are perfect machines, finding local maximum would not work. Think of DP."
                    },
                    {
                        "username": "psionl0",
                        "content": "With the constraints given (``1 <= nums.length <= 20``) a brute force solution will work. However, it is still worthwhile adding memoization if just for the practice.\\nI would have thought that the need to initialize the dp matrix (which takes O(n^2) time) would have reduced the time difference considerably but that shows what I know: 2 ms vs 79 ms."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "can anybody explain me these two testcases?\\nTestcase -> Expected outcome\\n[1,5,233,7] -> true\\n[2,4,55,6,8] -> false\\n\\nif Both player optimally than T2 would be true and if not than T1 would be false!!!  \\uD83D\\uDE35\\u200D\\uD83D\\uDCAB\\uD83D\\uDE35\\u200D\\uD83D\\uDCAB\\nEither my code fail for 1 or 2"
                    },
                    {
                        "username": "psionl0",
                        "content": "For [1,5,233,7] if player1 chooses 1 then no matter what player2 chooses, it exposes 233 for player1 to take so this is true.\\nFor [2,4,55,6,8], whatever end player1 chooses, player2 chooses the opposite end. Now we are left with [4,55,6] and whichever choice player1 makes, leaves 55 for player2 to grab so this is false."
                    },
                    {
                        "username": "rakeshSharma19",
                        "content": "Here You have to understand that, optimally according to present array,  on each step both are seeing complete array and according to that they will pick the element to become winner.\\nFor array = [1, 5, 233, 7]\\nat step 1 Player1 have 2 option either choose array[0] or array[-1],\\n If player1 array[0] then new array will be [5, 233, 7] and in this case player2 whatever choose Player1 has option to choose 233.\\nif player1 will array[-1] which is 7, then new array will be [1, 5, 233] here player2 has option to choose 233. Here we have to choose optimal value after each step to maximize end result.\\n\\nI hope you have understand the problem."
                    },
                    {
                        "username": "nizam_0134",
                        "content": "[2,4,55,6,8]\\nWhy this test case is False. \\n"
                    },
                    {
                        "username": "nizam_0134",
                        "content": "[@AniEthanHunt](/AniEthanHunt) thanks buddy I get it now "
                    },
                    {
                        "username": "AniEthanHunt",
                        "content": "Player 1 can take 2 or 8.\\nP1 takes 2, then P2 will take 8 and P1 will lose as P2 will get 55 [4, 55, 6]\\nP1 takes 8, then P2 will take 2 and P1 will lose as P2 will get 55 [4, 55, 6]\\n\\nHere, both the player are playing optimally (game theory: min-max algorithm)."
                    },
                    {
                        "username": "pepjaggu2022",
                        "content": "You may assume that both players are playing optimally.\\ncompletely changed the question :("
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "You really thought you could just `return true` and be done with it didn\\'t you?"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "Haha, how did you know? :) I thought I have already solved that before and remembered the super greedy solution, but seems like it was one of the Stone Games..."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Who guys try the codes \"return true\" on the first eye?  :p"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Greate problem! BTW, I wonder why the nums.length is limited in a small region [1, 20]? As for a o(n2) solution, the nums.length can be 1e3 level. "
                    },
                    {
                        "username": "Dhiraj_Mohata",
                        "content": "i haven\\'t seen graph , stack ,queue , tree can i start directly with DP.\\nand how much time it takes to complete complete DSA basics"
                    },
                    {
                        "username": "Dhiraj_Mohata",
                        "content": "[@luanct](/luanct) okay "
                    },
                    {
                        "username": "luanct",
                        "content": "it\\'s still fine but I think you better learn basic DSA and Algo first before learning DP. DP required more skills and experiences. "
                    },
                    {
                        "username": "sagijagadish",
                        "content": "Similar to the Problem: https://leetcode.com/problems/stone-game-iii/description"
                    }
                ]
            },
            {
                "id": 1989707,
                "content": [
                    {
                        "username": "Charlemagne5t",
                        "content": "The guys are perfect machines, finding local maximum would not work. Think of DP."
                    },
                    {
                        "username": "psionl0",
                        "content": "With the constraints given (``1 <= nums.length <= 20``) a brute force solution will work. However, it is still worthwhile adding memoization if just for the practice.\\nI would have thought that the need to initialize the dp matrix (which takes O(n^2) time) would have reduced the time difference considerably but that shows what I know: 2 ms vs 79 ms."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "can anybody explain me these two testcases?\\nTestcase -> Expected outcome\\n[1,5,233,7] -> true\\n[2,4,55,6,8] -> false\\n\\nif Both player optimally than T2 would be true and if not than T1 would be false!!!  \\uD83D\\uDE35\\u200D\\uD83D\\uDCAB\\uD83D\\uDE35\\u200D\\uD83D\\uDCAB\\nEither my code fail for 1 or 2"
                    },
                    {
                        "username": "psionl0",
                        "content": "For [1,5,233,7] if player1 chooses 1 then no matter what player2 chooses, it exposes 233 for player1 to take so this is true.\\nFor [2,4,55,6,8], whatever end player1 chooses, player2 chooses the opposite end. Now we are left with [4,55,6] and whichever choice player1 makes, leaves 55 for player2 to grab so this is false."
                    },
                    {
                        "username": "rakeshSharma19",
                        "content": "Here You have to understand that, optimally according to present array,  on each step both are seeing complete array and according to that they will pick the element to become winner.\\nFor array = [1, 5, 233, 7]\\nat step 1 Player1 have 2 option either choose array[0] or array[-1],\\n If player1 array[0] then new array will be [5, 233, 7] and in this case player2 whatever choose Player1 has option to choose 233.\\nif player1 will array[-1] which is 7, then new array will be [1, 5, 233] here player2 has option to choose 233. Here we have to choose optimal value after each step to maximize end result.\\n\\nI hope you have understand the problem."
                    },
                    {
                        "username": "nizam_0134",
                        "content": "[2,4,55,6,8]\\nWhy this test case is False. \\n"
                    },
                    {
                        "username": "nizam_0134",
                        "content": "[@AniEthanHunt](/AniEthanHunt) thanks buddy I get it now "
                    },
                    {
                        "username": "AniEthanHunt",
                        "content": "Player 1 can take 2 or 8.\\nP1 takes 2, then P2 will take 8 and P1 will lose as P2 will get 55 [4, 55, 6]\\nP1 takes 8, then P2 will take 2 and P1 will lose as P2 will get 55 [4, 55, 6]\\n\\nHere, both the player are playing optimally (game theory: min-max algorithm)."
                    },
                    {
                        "username": "pepjaggu2022",
                        "content": "You may assume that both players are playing optimally.\\ncompletely changed the question :("
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "You really thought you could just `return true` and be done with it didn\\'t you?"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "Haha, how did you know? :) I thought I have already solved that before and remembered the super greedy solution, but seems like it was one of the Stone Games..."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Who guys try the codes \"return true\" on the first eye?  :p"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Greate problem! BTW, I wonder why the nums.length is limited in a small region [1, 20]? As for a o(n2) solution, the nums.length can be 1e3 level. "
                    },
                    {
                        "username": "Dhiraj_Mohata",
                        "content": "i haven\\'t seen graph , stack ,queue , tree can i start directly with DP.\\nand how much time it takes to complete complete DSA basics"
                    },
                    {
                        "username": "Dhiraj_Mohata",
                        "content": "[@luanct](/luanct) okay "
                    },
                    {
                        "username": "luanct",
                        "content": "it\\'s still fine but I think you better learn basic DSA and Algo first before learning DP. DP required more skills and experiences. "
                    },
                    {
                        "username": "sagijagadish",
                        "content": "Similar to the Problem: https://leetcode.com/problems/stone-game-iii/description"
                    }
                ]
            },
            {
                "id": 1989685,
                "content": [
                    {
                        "username": "Charlemagne5t",
                        "content": "The guys are perfect machines, finding local maximum would not work. Think of DP."
                    },
                    {
                        "username": "psionl0",
                        "content": "With the constraints given (``1 <= nums.length <= 20``) a brute force solution will work. However, it is still worthwhile adding memoization if just for the practice.\\nI would have thought that the need to initialize the dp matrix (which takes O(n^2) time) would have reduced the time difference considerably but that shows what I know: 2 ms vs 79 ms."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "can anybody explain me these two testcases?\\nTestcase -> Expected outcome\\n[1,5,233,7] -> true\\n[2,4,55,6,8] -> false\\n\\nif Both player optimally than T2 would be true and if not than T1 would be false!!!  \\uD83D\\uDE35\\u200D\\uD83D\\uDCAB\\uD83D\\uDE35\\u200D\\uD83D\\uDCAB\\nEither my code fail for 1 or 2"
                    },
                    {
                        "username": "psionl0",
                        "content": "For [1,5,233,7] if player1 chooses 1 then no matter what player2 chooses, it exposes 233 for player1 to take so this is true.\\nFor [2,4,55,6,8], whatever end player1 chooses, player2 chooses the opposite end. Now we are left with [4,55,6] and whichever choice player1 makes, leaves 55 for player2 to grab so this is false."
                    },
                    {
                        "username": "rakeshSharma19",
                        "content": "Here You have to understand that, optimally according to present array,  on each step both are seeing complete array and according to that they will pick the element to become winner.\\nFor array = [1, 5, 233, 7]\\nat step 1 Player1 have 2 option either choose array[0] or array[-1],\\n If player1 array[0] then new array will be [5, 233, 7] and in this case player2 whatever choose Player1 has option to choose 233.\\nif player1 will array[-1] which is 7, then new array will be [1, 5, 233] here player2 has option to choose 233. Here we have to choose optimal value after each step to maximize end result.\\n\\nI hope you have understand the problem."
                    },
                    {
                        "username": "nizam_0134",
                        "content": "[2,4,55,6,8]\\nWhy this test case is False. \\n"
                    },
                    {
                        "username": "nizam_0134",
                        "content": "[@AniEthanHunt](/AniEthanHunt) thanks buddy I get it now "
                    },
                    {
                        "username": "AniEthanHunt",
                        "content": "Player 1 can take 2 or 8.\\nP1 takes 2, then P2 will take 8 and P1 will lose as P2 will get 55 [4, 55, 6]\\nP1 takes 8, then P2 will take 2 and P1 will lose as P2 will get 55 [4, 55, 6]\\n\\nHere, both the player are playing optimally (game theory: min-max algorithm)."
                    },
                    {
                        "username": "pepjaggu2022",
                        "content": "You may assume that both players are playing optimally.\\ncompletely changed the question :("
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "You really thought you could just `return true` and be done with it didn\\'t you?"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "Haha, how did you know? :) I thought I have already solved that before and remembered the super greedy solution, but seems like it was one of the Stone Games..."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Who guys try the codes \"return true\" on the first eye?  :p"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Greate problem! BTW, I wonder why the nums.length is limited in a small region [1, 20]? As for a o(n2) solution, the nums.length can be 1e3 level. "
                    },
                    {
                        "username": "Dhiraj_Mohata",
                        "content": "i haven\\'t seen graph , stack ,queue , tree can i start directly with DP.\\nand how much time it takes to complete complete DSA basics"
                    },
                    {
                        "username": "Dhiraj_Mohata",
                        "content": "[@luanct](/luanct) okay "
                    },
                    {
                        "username": "luanct",
                        "content": "it\\'s still fine but I think you better learn basic DSA and Algo first before learning DP. DP required more skills and experiences. "
                    },
                    {
                        "username": "sagijagadish",
                        "content": "Similar to the Problem: https://leetcode.com/problems/stone-game-iii/description"
                    }
                ]
            },
            {
                "id": 1989599,
                "content": [
                    {
                        "username": "Charlemagne5t",
                        "content": "The guys are perfect machines, finding local maximum would not work. Think of DP."
                    },
                    {
                        "username": "psionl0",
                        "content": "With the constraints given (``1 <= nums.length <= 20``) a brute force solution will work. However, it is still worthwhile adding memoization if just for the practice.\\nI would have thought that the need to initialize the dp matrix (which takes O(n^2) time) would have reduced the time difference considerably but that shows what I know: 2 ms vs 79 ms."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "can anybody explain me these two testcases?\\nTestcase -> Expected outcome\\n[1,5,233,7] -> true\\n[2,4,55,6,8] -> false\\n\\nif Both player optimally than T2 would be true and if not than T1 would be false!!!  \\uD83D\\uDE35\\u200D\\uD83D\\uDCAB\\uD83D\\uDE35\\u200D\\uD83D\\uDCAB\\nEither my code fail for 1 or 2"
                    },
                    {
                        "username": "psionl0",
                        "content": "For [1,5,233,7] if player1 chooses 1 then no matter what player2 chooses, it exposes 233 for player1 to take so this is true.\\nFor [2,4,55,6,8], whatever end player1 chooses, player2 chooses the opposite end. Now we are left with [4,55,6] and whichever choice player1 makes, leaves 55 for player2 to grab so this is false."
                    },
                    {
                        "username": "rakeshSharma19",
                        "content": "Here You have to understand that, optimally according to present array,  on each step both are seeing complete array and according to that they will pick the element to become winner.\\nFor array = [1, 5, 233, 7]\\nat step 1 Player1 have 2 option either choose array[0] or array[-1],\\n If player1 array[0] then new array will be [5, 233, 7] and in this case player2 whatever choose Player1 has option to choose 233.\\nif player1 will array[-1] which is 7, then new array will be [1, 5, 233] here player2 has option to choose 233. Here we have to choose optimal value after each step to maximize end result.\\n\\nI hope you have understand the problem."
                    },
                    {
                        "username": "nizam_0134",
                        "content": "[2,4,55,6,8]\\nWhy this test case is False. \\n"
                    },
                    {
                        "username": "nizam_0134",
                        "content": "[@AniEthanHunt](/AniEthanHunt) thanks buddy I get it now "
                    },
                    {
                        "username": "AniEthanHunt",
                        "content": "Player 1 can take 2 or 8.\\nP1 takes 2, then P2 will take 8 and P1 will lose as P2 will get 55 [4, 55, 6]\\nP1 takes 8, then P2 will take 2 and P1 will lose as P2 will get 55 [4, 55, 6]\\n\\nHere, both the player are playing optimally (game theory: min-max algorithm)."
                    },
                    {
                        "username": "pepjaggu2022",
                        "content": "You may assume that both players are playing optimally.\\ncompletely changed the question :("
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "You really thought you could just `return true` and be done with it didn\\'t you?"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "Haha, how did you know? :) I thought I have already solved that before and remembered the super greedy solution, but seems like it was one of the Stone Games..."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Who guys try the codes \"return true\" on the first eye?  :p"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Greate problem! BTW, I wonder why the nums.length is limited in a small region [1, 20]? As for a o(n2) solution, the nums.length can be 1e3 level. "
                    },
                    {
                        "username": "Dhiraj_Mohata",
                        "content": "i haven\\'t seen graph , stack ,queue , tree can i start directly with DP.\\nand how much time it takes to complete complete DSA basics"
                    },
                    {
                        "username": "Dhiraj_Mohata",
                        "content": "[@luanct](/luanct) okay "
                    },
                    {
                        "username": "luanct",
                        "content": "it\\'s still fine but I think you better learn basic DSA and Algo first before learning DP. DP required more skills and experiences. "
                    },
                    {
                        "username": "sagijagadish",
                        "content": "Similar to the Problem: https://leetcode.com/problems/stone-game-iii/description"
                    }
                ]
            },
            {
                "id": 1989569,
                "content": [
                    {
                        "username": "Charlemagne5t",
                        "content": "The guys are perfect machines, finding local maximum would not work. Think of DP."
                    },
                    {
                        "username": "psionl0",
                        "content": "With the constraints given (``1 <= nums.length <= 20``) a brute force solution will work. However, it is still worthwhile adding memoization if just for the practice.\\nI would have thought that the need to initialize the dp matrix (which takes O(n^2) time) would have reduced the time difference considerably but that shows what I know: 2 ms vs 79 ms."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "can anybody explain me these two testcases?\\nTestcase -> Expected outcome\\n[1,5,233,7] -> true\\n[2,4,55,6,8] -> false\\n\\nif Both player optimally than T2 would be true and if not than T1 would be false!!!  \\uD83D\\uDE35\\u200D\\uD83D\\uDCAB\\uD83D\\uDE35\\u200D\\uD83D\\uDCAB\\nEither my code fail for 1 or 2"
                    },
                    {
                        "username": "psionl0",
                        "content": "For [1,5,233,7] if player1 chooses 1 then no matter what player2 chooses, it exposes 233 for player1 to take so this is true.\\nFor [2,4,55,6,8], whatever end player1 chooses, player2 chooses the opposite end. Now we are left with [4,55,6] and whichever choice player1 makes, leaves 55 for player2 to grab so this is false."
                    },
                    {
                        "username": "rakeshSharma19",
                        "content": "Here You have to understand that, optimally according to present array,  on each step both are seeing complete array and according to that they will pick the element to become winner.\\nFor array = [1, 5, 233, 7]\\nat step 1 Player1 have 2 option either choose array[0] or array[-1],\\n If player1 array[0] then new array will be [5, 233, 7] and in this case player2 whatever choose Player1 has option to choose 233.\\nif player1 will array[-1] which is 7, then new array will be [1, 5, 233] here player2 has option to choose 233. Here we have to choose optimal value after each step to maximize end result.\\n\\nI hope you have understand the problem."
                    },
                    {
                        "username": "nizam_0134",
                        "content": "[2,4,55,6,8]\\nWhy this test case is False. \\n"
                    },
                    {
                        "username": "nizam_0134",
                        "content": "[@AniEthanHunt](/AniEthanHunt) thanks buddy I get it now "
                    },
                    {
                        "username": "AniEthanHunt",
                        "content": "Player 1 can take 2 or 8.\\nP1 takes 2, then P2 will take 8 and P1 will lose as P2 will get 55 [4, 55, 6]\\nP1 takes 8, then P2 will take 2 and P1 will lose as P2 will get 55 [4, 55, 6]\\n\\nHere, both the player are playing optimally (game theory: min-max algorithm)."
                    },
                    {
                        "username": "pepjaggu2022",
                        "content": "You may assume that both players are playing optimally.\\ncompletely changed the question :("
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "You really thought you could just `return true` and be done with it didn\\'t you?"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "Haha, how did you know? :) I thought I have already solved that before and remembered the super greedy solution, but seems like it was one of the Stone Games..."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Who guys try the codes \"return true\" on the first eye?  :p"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Greate problem! BTW, I wonder why the nums.length is limited in a small region [1, 20]? As for a o(n2) solution, the nums.length can be 1e3 level. "
                    },
                    {
                        "username": "Dhiraj_Mohata",
                        "content": "i haven\\'t seen graph , stack ,queue , tree can i start directly with DP.\\nand how much time it takes to complete complete DSA basics"
                    },
                    {
                        "username": "Dhiraj_Mohata",
                        "content": "[@luanct](/luanct) okay "
                    },
                    {
                        "username": "luanct",
                        "content": "it\\'s still fine but I think you better learn basic DSA and Algo first before learning DP. DP required more skills and experiences. "
                    },
                    {
                        "username": "sagijagadish",
                        "content": "Similar to the Problem: https://leetcode.com/problems/stone-game-iii/description"
                    }
                ]
            },
            {
                "id": 1989548,
                "content": [
                    {
                        "username": "Charlemagne5t",
                        "content": "The guys are perfect machines, finding local maximum would not work. Think of DP."
                    },
                    {
                        "username": "psionl0",
                        "content": "With the constraints given (``1 <= nums.length <= 20``) a brute force solution will work. However, it is still worthwhile adding memoization if just for the practice.\\nI would have thought that the need to initialize the dp matrix (which takes O(n^2) time) would have reduced the time difference considerably but that shows what I know: 2 ms vs 79 ms."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "can anybody explain me these two testcases?\\nTestcase -> Expected outcome\\n[1,5,233,7] -> true\\n[2,4,55,6,8] -> false\\n\\nif Both player optimally than T2 would be true and if not than T1 would be false!!!  \\uD83D\\uDE35\\u200D\\uD83D\\uDCAB\\uD83D\\uDE35\\u200D\\uD83D\\uDCAB\\nEither my code fail for 1 or 2"
                    },
                    {
                        "username": "psionl0",
                        "content": "For [1,5,233,7] if player1 chooses 1 then no matter what player2 chooses, it exposes 233 for player1 to take so this is true.\\nFor [2,4,55,6,8], whatever end player1 chooses, player2 chooses the opposite end. Now we are left with [4,55,6] and whichever choice player1 makes, leaves 55 for player2 to grab so this is false."
                    },
                    {
                        "username": "rakeshSharma19",
                        "content": "Here You have to understand that, optimally according to present array,  on each step both are seeing complete array and according to that they will pick the element to become winner.\\nFor array = [1, 5, 233, 7]\\nat step 1 Player1 have 2 option either choose array[0] or array[-1],\\n If player1 array[0] then new array will be [5, 233, 7] and in this case player2 whatever choose Player1 has option to choose 233.\\nif player1 will array[-1] which is 7, then new array will be [1, 5, 233] here player2 has option to choose 233. Here we have to choose optimal value after each step to maximize end result.\\n\\nI hope you have understand the problem."
                    },
                    {
                        "username": "nizam_0134",
                        "content": "[2,4,55,6,8]\\nWhy this test case is False. \\n"
                    },
                    {
                        "username": "nizam_0134",
                        "content": "[@AniEthanHunt](/AniEthanHunt) thanks buddy I get it now "
                    },
                    {
                        "username": "AniEthanHunt",
                        "content": "Player 1 can take 2 or 8.\\nP1 takes 2, then P2 will take 8 and P1 will lose as P2 will get 55 [4, 55, 6]\\nP1 takes 8, then P2 will take 2 and P1 will lose as P2 will get 55 [4, 55, 6]\\n\\nHere, both the player are playing optimally (game theory: min-max algorithm)."
                    },
                    {
                        "username": "pepjaggu2022",
                        "content": "You may assume that both players are playing optimally.\\ncompletely changed the question :("
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "You really thought you could just `return true` and be done with it didn\\'t you?"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "Haha, how did you know? :) I thought I have already solved that before and remembered the super greedy solution, but seems like it was one of the Stone Games..."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Who guys try the codes \"return true\" on the first eye?  :p"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Greate problem! BTW, I wonder why the nums.length is limited in a small region [1, 20]? As for a o(n2) solution, the nums.length can be 1e3 level. "
                    },
                    {
                        "username": "Dhiraj_Mohata",
                        "content": "i haven\\'t seen graph , stack ,queue , tree can i start directly with DP.\\nand how much time it takes to complete complete DSA basics"
                    },
                    {
                        "username": "Dhiraj_Mohata",
                        "content": "[@luanct](/luanct) okay "
                    },
                    {
                        "username": "luanct",
                        "content": "it\\'s still fine but I think you better learn basic DSA and Algo first before learning DP. DP required more skills and experiences. "
                    },
                    {
                        "username": "sagijagadish",
                        "content": "Similar to the Problem: https://leetcode.com/problems/stone-game-iii/description"
                    }
                ]
            },
            {
                "id": 1989546,
                "content": [
                    {
                        "username": "Charlemagne5t",
                        "content": "The guys are perfect machines, finding local maximum would not work. Think of DP."
                    },
                    {
                        "username": "psionl0",
                        "content": "With the constraints given (``1 <= nums.length <= 20``) a brute force solution will work. However, it is still worthwhile adding memoization if just for the practice.\\nI would have thought that the need to initialize the dp matrix (which takes O(n^2) time) would have reduced the time difference considerably but that shows what I know: 2 ms vs 79 ms."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "can anybody explain me these two testcases?\\nTestcase -> Expected outcome\\n[1,5,233,7] -> true\\n[2,4,55,6,8] -> false\\n\\nif Both player optimally than T2 would be true and if not than T1 would be false!!!  \\uD83D\\uDE35\\u200D\\uD83D\\uDCAB\\uD83D\\uDE35\\u200D\\uD83D\\uDCAB\\nEither my code fail for 1 or 2"
                    },
                    {
                        "username": "psionl0",
                        "content": "For [1,5,233,7] if player1 chooses 1 then no matter what player2 chooses, it exposes 233 for player1 to take so this is true.\\nFor [2,4,55,6,8], whatever end player1 chooses, player2 chooses the opposite end. Now we are left with [4,55,6] and whichever choice player1 makes, leaves 55 for player2 to grab so this is false."
                    },
                    {
                        "username": "rakeshSharma19",
                        "content": "Here You have to understand that, optimally according to present array,  on each step both are seeing complete array and according to that they will pick the element to become winner.\\nFor array = [1, 5, 233, 7]\\nat step 1 Player1 have 2 option either choose array[0] or array[-1],\\n If player1 array[0] then new array will be [5, 233, 7] and in this case player2 whatever choose Player1 has option to choose 233.\\nif player1 will array[-1] which is 7, then new array will be [1, 5, 233] here player2 has option to choose 233. Here we have to choose optimal value after each step to maximize end result.\\n\\nI hope you have understand the problem."
                    },
                    {
                        "username": "nizam_0134",
                        "content": "[2,4,55,6,8]\\nWhy this test case is False. \\n"
                    },
                    {
                        "username": "nizam_0134",
                        "content": "[@AniEthanHunt](/AniEthanHunt) thanks buddy I get it now "
                    },
                    {
                        "username": "AniEthanHunt",
                        "content": "Player 1 can take 2 or 8.\\nP1 takes 2, then P2 will take 8 and P1 will lose as P2 will get 55 [4, 55, 6]\\nP1 takes 8, then P2 will take 2 and P1 will lose as P2 will get 55 [4, 55, 6]\\n\\nHere, both the player are playing optimally (game theory: min-max algorithm)."
                    },
                    {
                        "username": "pepjaggu2022",
                        "content": "You may assume that both players are playing optimally.\\ncompletely changed the question :("
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "You really thought you could just `return true` and be done with it didn\\'t you?"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "Haha, how did you know? :) I thought I have already solved that before and remembered the super greedy solution, but seems like it was one of the Stone Games..."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Who guys try the codes \"return true\" on the first eye?  :p"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Greate problem! BTW, I wonder why the nums.length is limited in a small region [1, 20]? As for a o(n2) solution, the nums.length can be 1e3 level. "
                    },
                    {
                        "username": "Dhiraj_Mohata",
                        "content": "i haven\\'t seen graph , stack ,queue , tree can i start directly with DP.\\nand how much time it takes to complete complete DSA basics"
                    },
                    {
                        "username": "Dhiraj_Mohata",
                        "content": "[@luanct](/luanct) okay "
                    },
                    {
                        "username": "luanct",
                        "content": "it\\'s still fine but I think you better learn basic DSA and Algo first before learning DP. DP required more skills and experiences. "
                    },
                    {
                        "username": "sagijagadish",
                        "content": "Similar to the Problem: https://leetcode.com/problems/stone-game-iii/description"
                    }
                ]
            },
            {
                "id": 1989470,
                "content": [
                    {
                        "username": "Charlemagne5t",
                        "content": "The guys are perfect machines, finding local maximum would not work. Think of DP."
                    },
                    {
                        "username": "psionl0",
                        "content": "With the constraints given (``1 <= nums.length <= 20``) a brute force solution will work. However, it is still worthwhile adding memoization if just for the practice.\\nI would have thought that the need to initialize the dp matrix (which takes O(n^2) time) would have reduced the time difference considerably but that shows what I know: 2 ms vs 79 ms."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "can anybody explain me these two testcases?\\nTestcase -> Expected outcome\\n[1,5,233,7] -> true\\n[2,4,55,6,8] -> false\\n\\nif Both player optimally than T2 would be true and if not than T1 would be false!!!  \\uD83D\\uDE35\\u200D\\uD83D\\uDCAB\\uD83D\\uDE35\\u200D\\uD83D\\uDCAB\\nEither my code fail for 1 or 2"
                    },
                    {
                        "username": "psionl0",
                        "content": "For [1,5,233,7] if player1 chooses 1 then no matter what player2 chooses, it exposes 233 for player1 to take so this is true.\\nFor [2,4,55,6,8], whatever end player1 chooses, player2 chooses the opposite end. Now we are left with [4,55,6] and whichever choice player1 makes, leaves 55 for player2 to grab so this is false."
                    },
                    {
                        "username": "rakeshSharma19",
                        "content": "Here You have to understand that, optimally according to present array,  on each step both are seeing complete array and according to that they will pick the element to become winner.\\nFor array = [1, 5, 233, 7]\\nat step 1 Player1 have 2 option either choose array[0] or array[-1],\\n If player1 array[0] then new array will be [5, 233, 7] and in this case player2 whatever choose Player1 has option to choose 233.\\nif player1 will array[-1] which is 7, then new array will be [1, 5, 233] here player2 has option to choose 233. Here we have to choose optimal value after each step to maximize end result.\\n\\nI hope you have understand the problem."
                    },
                    {
                        "username": "nizam_0134",
                        "content": "[2,4,55,6,8]\\nWhy this test case is False. \\n"
                    },
                    {
                        "username": "nizam_0134",
                        "content": "[@AniEthanHunt](/AniEthanHunt) thanks buddy I get it now "
                    },
                    {
                        "username": "AniEthanHunt",
                        "content": "Player 1 can take 2 or 8.\\nP1 takes 2, then P2 will take 8 and P1 will lose as P2 will get 55 [4, 55, 6]\\nP1 takes 8, then P2 will take 2 and P1 will lose as P2 will get 55 [4, 55, 6]\\n\\nHere, both the player are playing optimally (game theory: min-max algorithm)."
                    },
                    {
                        "username": "pepjaggu2022",
                        "content": "You may assume that both players are playing optimally.\\ncompletely changed the question :("
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "You really thought you could just `return true` and be done with it didn\\'t you?"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "Haha, how did you know? :) I thought I have already solved that before and remembered the super greedy solution, but seems like it was one of the Stone Games..."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Who guys try the codes \"return true\" on the first eye?  :p"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Greate problem! BTW, I wonder why the nums.length is limited in a small region [1, 20]? As for a o(n2) solution, the nums.length can be 1e3 level. "
                    },
                    {
                        "username": "Dhiraj_Mohata",
                        "content": "i haven\\'t seen graph , stack ,queue , tree can i start directly with DP.\\nand how much time it takes to complete complete DSA basics"
                    },
                    {
                        "username": "Dhiraj_Mohata",
                        "content": "[@luanct](/luanct) okay "
                    },
                    {
                        "username": "luanct",
                        "content": "it\\'s still fine but I think you better learn basic DSA and Algo first before learning DP. DP required more skills and experiences. "
                    },
                    {
                        "username": "sagijagadish",
                        "content": "Similar to the Problem: https://leetcode.com/problems/stone-game-iii/description"
                    }
                ]
            },
            {
                "id": 1989469,
                "content": [
                    {
                        "username": "Charlemagne5t",
                        "content": "The guys are perfect machines, finding local maximum would not work. Think of DP."
                    },
                    {
                        "username": "psionl0",
                        "content": "With the constraints given (``1 <= nums.length <= 20``) a brute force solution will work. However, it is still worthwhile adding memoization if just for the practice.\\nI would have thought that the need to initialize the dp matrix (which takes O(n^2) time) would have reduced the time difference considerably but that shows what I know: 2 ms vs 79 ms."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "can anybody explain me these two testcases?\\nTestcase -> Expected outcome\\n[1,5,233,7] -> true\\n[2,4,55,6,8] -> false\\n\\nif Both player optimally than T2 would be true and if not than T1 would be false!!!  \\uD83D\\uDE35\\u200D\\uD83D\\uDCAB\\uD83D\\uDE35\\u200D\\uD83D\\uDCAB\\nEither my code fail for 1 or 2"
                    },
                    {
                        "username": "psionl0",
                        "content": "For [1,5,233,7] if player1 chooses 1 then no matter what player2 chooses, it exposes 233 for player1 to take so this is true.\\nFor [2,4,55,6,8], whatever end player1 chooses, player2 chooses the opposite end. Now we are left with [4,55,6] and whichever choice player1 makes, leaves 55 for player2 to grab so this is false."
                    },
                    {
                        "username": "rakeshSharma19",
                        "content": "Here You have to understand that, optimally according to present array,  on each step both are seeing complete array and according to that they will pick the element to become winner.\\nFor array = [1, 5, 233, 7]\\nat step 1 Player1 have 2 option either choose array[0] or array[-1],\\n If player1 array[0] then new array will be [5, 233, 7] and in this case player2 whatever choose Player1 has option to choose 233.\\nif player1 will array[-1] which is 7, then new array will be [1, 5, 233] here player2 has option to choose 233. Here we have to choose optimal value after each step to maximize end result.\\n\\nI hope you have understand the problem."
                    },
                    {
                        "username": "nizam_0134",
                        "content": "[2,4,55,6,8]\\nWhy this test case is False. \\n"
                    },
                    {
                        "username": "nizam_0134",
                        "content": "[@AniEthanHunt](/AniEthanHunt) thanks buddy I get it now "
                    },
                    {
                        "username": "AniEthanHunt",
                        "content": "Player 1 can take 2 or 8.\\nP1 takes 2, then P2 will take 8 and P1 will lose as P2 will get 55 [4, 55, 6]\\nP1 takes 8, then P2 will take 2 and P1 will lose as P2 will get 55 [4, 55, 6]\\n\\nHere, both the player are playing optimally (game theory: min-max algorithm)."
                    },
                    {
                        "username": "pepjaggu2022",
                        "content": "You may assume that both players are playing optimally.\\ncompletely changed the question :("
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "You really thought you could just `return true` and be done with it didn\\'t you?"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "Haha, how did you know? :) I thought I have already solved that before and remembered the super greedy solution, but seems like it was one of the Stone Games..."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Who guys try the codes \"return true\" on the first eye?  :p"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Greate problem! BTW, I wonder why the nums.length is limited in a small region [1, 20]? As for a o(n2) solution, the nums.length can be 1e3 level. "
                    },
                    {
                        "username": "Dhiraj_Mohata",
                        "content": "i haven\\'t seen graph , stack ,queue , tree can i start directly with DP.\\nand how much time it takes to complete complete DSA basics"
                    },
                    {
                        "username": "Dhiraj_Mohata",
                        "content": "[@luanct](/luanct) okay "
                    },
                    {
                        "username": "luanct",
                        "content": "it\\'s still fine but I think you better learn basic DSA and Algo first before learning DP. DP required more skills and experiences. "
                    },
                    {
                        "username": "sagijagadish",
                        "content": "Similar to the Problem: https://leetcode.com/problems/stone-game-iii/description"
                    }
                ]
            },
            {
                "id": 1989450,
                "content": [
                    {
                        "username": "math_pi",
                        "content": "After Translating the Problem into Maximal Sum Difference b/w [A, B]. This problem becomes exactly similar to this one: https://leetcode.com/problems/stone-game-vii/"
                    },
                    {
                        "username": "math_pi",
                        "content": "Can Bitmask DP be used to attack this problem?"
                    },
                    {
                        "username": "metaphysicalist",
                        "content": "Yes, the state of the game can be defined by using bitmask for representing the remaining elements. But this problem is easier that the remaining elements can be simply represented by using the range (l, r) because the players can only take the leftmost or the rightmost elements. "
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, Bitmask Dynamic Programming (DP) can indeed be used to solve this problem. \\n\\nThe basic idea is that we maintain a state for each possible subset of the numbers in the game (represented as a binary mask), and for each state, we keep track of the maximum possible score difference between the two players if they play optimally.\\n\\nTo start, we initialize a DP array of size 2^n (where n is the length of the input array), and set all elements to a large negative value. We then set DP[0] to 0, because when there are no elements left in the game, the score difference is 0.\\n\\nThen, for each subset (represented as a binary mask), we iterate through all its elements (represented as bits in the binary mask). For each element, we consider two scenarios: the current player picks it, or they don\\'t. \\n\\nIf the current player picks it, the score difference changes by the value of the element (if it\\'s player 1\\'s turn) or by the negative of the value of the element (if it\\'s player 2\\'s turn). We then recursively call our DP function on the remaining elements, and update our DP array with the maximum score difference.\\n\\nIn the end, we return whether DP[2^n - 1] is non-negative. This represents the maximum score difference when all elements have been picked, and if it\\'s non-negative, player 1 can win or tie.\\n\\nPlease note that the Bitmask DP approach to this problem has a time complexity of O(n*2^n), which can be quite slow for large n. Therefore, it\\'s more suitable for cases where the length of the input array is small. If the length of the input array is large, a more efficient approach might be needed."
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "the most intuitive way to go about this problem is using recursion. definitely not the most optimal way, (crude recursion is basically brute forcing), but its the best way to start and build more sophisticated algorithms from (the pure dp approach). the constraints allow the recursive approach and i highly encourage to look out for it"
                    },
                    {
                        "username": "mm541145",
                        "content": "it looks similar to 877(stone game)"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "Can anyone tell the error in this,, thanks in advance\\n\\n\\nclass Solution {\\npublic:\\n                  \\n    int dp[501][501];\\n    int maxStone(int i, int n, int AliceTurn, vector<int>&arr){\\n        if(i > n)return 0;\\n        if(dp[i][n] != -1)return dp[i][n];\\n\\n        int first = 0, last = 0;\\n        if(AliceTurn)\\n        {\\n            return dp[i][n] = arr[i] + max(maxStone(i+1, n, 0, arr), maxStone(i, n-1, 0, arr));\\n        }\\n        else\\n        {\\n            // AS ALICE IS NOT TAKING THE ELEMENT SO WE WILL NOT ADD THIS TO OUR SUM\\n            return dp[i][n] = max(maxStone(i+1, n, 0, arr), maxStone(i, n-1, 1, arr));\\n        }\\n    }\\n    bool PredictTheWinner(vector<int>& nums) {\\n        int n = piles.size();\\n        memset(dp, -1, sizeof(dp));\\n        \\n            // TURN ==1 - > MEAN ALICE\\n        int sumAlice = maxStone(0,n-1, 1, piles);\\n        int sum =0;\\n        for(int i=0; i <n; i++)sum += piles[i];\\n        int sumBon = sum - sumAlice;\\n        cout<<sumAlice<<\" \"<<sumBon;\\n        return ( sumAlice >= sumBon);\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your function is looking quite right, but there are a few minor issues:\\n\\n1. It looks like you have mixed variable names. In your `PredictTheWinner` function, you\\'re using the variable `piles` which hasn\\'t been defined anywhere. You probably meant to use `nums`, which is the input to your function.\\n\\n2. In your `maxStone` function, you\\'re recursively calling it with `0` for `AliceTurn` in both cases within your `if (AliceTurn)` block. In the `else` condition, you should call `maxStone(i+1, n, 1, arr)` and `maxStone(i, n-1, 1, arr)`, otherwise you\\'re effectively making it always Alice\\'s turn and Bob will never play.\\n\\nHere is the corrected code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n\\n    int dp[501][501];\\n    int maxStone(int i, int n, int AliceTurn, vector<int>&arr){\\n        if(i > n)return 0;\\n        if(dp[i][n] != -1)return dp[i][n];\\n\\n        if(AliceTurn)\\n        {\\n            return dp[i][n] = arr[i] + max(maxStone(i+1, n, 0, arr), maxStone(i, n-1, 0, arr));\\n        }\\n        else\\n        {\\n            return dp[i][n] = max(maxStone(i+1, n, 1, arr), maxStone(i, n-1, 1, arr));\\n        }\\n    }\\n    bool PredictTheWinner(vector<int>& nums) {\\n        int n = nums.size();\\n        memset(dp, -1, sizeof(dp));\\n        int sumAlice = maxStone(0,n-1, 1, nums);\\n        int sum =0;\\n        for(int i=0; i <n; i++) sum += nums[i];\\n        int sumBon = sum - sumAlice;\\n        cout<<sumAlice<<\" \"<<sumBon;\\n        return ( sumAlice >= sumBon);\\n    }\\n};\\n```\\n\\nRemember, it\\'s important to maintain consistency in your variable names to avoid these types of errors. Also, make sure you\\'re setting the right parameters in your recursive calls.\\n"
                    },
                    {
                        "username": "enzo_cheng",
                        "content": "Test Case # 60 answer is wrong?!\\n\\nnums =\\n[3606449,6,5,9,452429,7,9580316,9857582,8514433,9,6,6614512,753594,5474165,4,2697293,8,7,1]\\n\\nA selection: [3606449, 5, 7, 452429, 2697293, 5474165, 6614512, 9, 9857582, 7]\\nB selection: [6, 1, 9, 8, 4, 753594, 6, 8514433, 9580316]\\n\\nA must be winner.\\n\\nAnswer is True, but test case is False.\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The provided test case is a demonstration of the fact that both players are playing optimally. They\\'re not just picking the largest value from either end, they\\'re thinking ahead to ensure the highest possible score for themselves. \\n\\nTo make it clearer, let\\'s run through the first few steps of this game with both players playing optimally:\\n\\n1. Player 1 (P1) can choose from 3606449 and 1. P1 picks 3606449, because it\\'s larger.\\n2. Player 2 (P2) can choose from 6 and 1. P2 picks 6, because it\\'s larger.\\n3. P1 can choose from 5 and 1. P1 picks 5, because it\\'s larger.\\n4. P2 can choose from 9 and 1. P2 picks 9, because it\\'s larger.\\n5. P1 can choose from 452429 and 1. P1 picks 452429, because it\\'s larger.\\n6. P2 can choose from 7 and 1. P2 picks 7, because it\\'s larger.\\n\\nWe can see that both players are taking the higher value available to them, and are not considering future moves. However, optimal play isn\\'t about maximizing the immediate gain. It\\'s about thinking ahead and choosing values that will lead to a higher final score. \\n\\nIn the given case, the returned answer is false because with optimal play, Player 1 does not win. Even though it seems like Player 1 can win with the selected values, keep in mind that the order of the choices and the strategy used to make these choices matter significantly, which is why your test case returns False. \\n\\nLet\\'s illustrate the decision process with a small example, [1, 5, 233, 7], where we already know that Player 1 can win. The process can be represented in the following table:\\n\\n| Turn   | Player | Available Choices | Choice | Player 1 Score | Player 2 Score |\\n|--------|--------|-------------------|--------|----------------|----------------|\\n| 1      | 1      | 1, 7              | 1      | 1              | 0              |\\n| 2      | 2      | 5, 7              | 7      | 1              | 7              |\\n| 3      | 1      | 5, 233            | 233    | 234            | 7              |\\n| 4      | 2      | 5                 | 5      | 234            | 12             |\\n\\nPlayer 1 is making their choices to ensure that Player 2 always has to choose between two numbers where one is significantly smaller than the other. In the second round, Player 1 forces Player 2 to choose between 5 and 7 instead of, say, 7 and 233, thus ensuring that they can grab the large number in the third round.\\n\\nThis is a simplified example, and the real game has more rounds and requires more complex strategic thinking. But it illustrates the basic idea: Playing optimally isn\\'t just about grabbing the largest available number, it\\'s also about controlling the choices available to the other player.\\n\\nIf you want to create a similar table for a larger array, the table will have more rows and the strategic decisions will be more complex, but the basic principle is the same."
                    },
                    {
                        "username": "amanag029",
                        "content": "nums =\\n[2,4,55,6,8] \\nfor the above nums , expected ans if False but it should be True?\\nAnalsis : P1 chooses max of possible options on its own turn while assuming P2 will left min for P1\\nTherefore, P1 chooses 8 > P2 chooses 6 > P1 chooses 55....\\n"
                    },
                    {
                        "username": "amitbansal13",
                        "content": "Can anyone help me understand what is wrong in this approach? Thanks in Advance.\n\n\n```\ndef PredictTheWinner(self, nums: List[int]) -> bool:\n        # d = {}\n        total = sum(nums)\n        @cache\n        def check(left, i, j, turn):\n            if i > j:\n                return left >= total - left\n            if turn:\n                return check(left+nums[i], i+1, j, not turn) or check(left+nums[j], i, j-1, not turn)\n            else:\n                return check(left, i+1, j, not turn) or check(left, i, j-1, not turn)\n            \n        return check(0, 0, len(nums)-1, True)\n```"
                    },
                    {
                        "username": "PrinceTp",
                        "content": "[2,4,55,6,8]\\n\\nPlayer 1 will win ,the answer must be TRUE for this test case,but the expected answer is FALSE ,any idea ?"
                    },
                    {
                        "username": "anil_kumar_2002",
                        "content": "bool PredictTheWinner(vector<int>& nums) {\\n        int s1=0; \\n        int s2=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(i%2==0){\\n                s1+=nums[i]; \\n            }\\n            else{\\n                s2+=nums[i]; \\n            }\\n        }\\n        if(s1>=s2){\\n            return true ; \\n        }\\n        return false;\\n    }\\nfor this code , {1,2} , it should return false, but compiler showing true , \\ncan anyone tell the problem , please? "
                    }
                ]
            },
            {
                "id": 1989445,
                "content": [
                    {
                        "username": "math_pi",
                        "content": "After Translating the Problem into Maximal Sum Difference b/w [A, B]. This problem becomes exactly similar to this one: https://leetcode.com/problems/stone-game-vii/"
                    },
                    {
                        "username": "math_pi",
                        "content": "Can Bitmask DP be used to attack this problem?"
                    },
                    {
                        "username": "metaphysicalist",
                        "content": "Yes, the state of the game can be defined by using bitmask for representing the remaining elements. But this problem is easier that the remaining elements can be simply represented by using the range (l, r) because the players can only take the leftmost or the rightmost elements. "
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, Bitmask Dynamic Programming (DP) can indeed be used to solve this problem. \\n\\nThe basic idea is that we maintain a state for each possible subset of the numbers in the game (represented as a binary mask), and for each state, we keep track of the maximum possible score difference between the two players if they play optimally.\\n\\nTo start, we initialize a DP array of size 2^n (where n is the length of the input array), and set all elements to a large negative value. We then set DP[0] to 0, because when there are no elements left in the game, the score difference is 0.\\n\\nThen, for each subset (represented as a binary mask), we iterate through all its elements (represented as bits in the binary mask). For each element, we consider two scenarios: the current player picks it, or they don\\'t. \\n\\nIf the current player picks it, the score difference changes by the value of the element (if it\\'s player 1\\'s turn) or by the negative of the value of the element (if it\\'s player 2\\'s turn). We then recursively call our DP function on the remaining elements, and update our DP array with the maximum score difference.\\n\\nIn the end, we return whether DP[2^n - 1] is non-negative. This represents the maximum score difference when all elements have been picked, and if it\\'s non-negative, player 1 can win or tie.\\n\\nPlease note that the Bitmask DP approach to this problem has a time complexity of O(n*2^n), which can be quite slow for large n. Therefore, it\\'s more suitable for cases where the length of the input array is small. If the length of the input array is large, a more efficient approach might be needed."
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "the most intuitive way to go about this problem is using recursion. definitely not the most optimal way, (crude recursion is basically brute forcing), but its the best way to start and build more sophisticated algorithms from (the pure dp approach). the constraints allow the recursive approach and i highly encourage to look out for it"
                    },
                    {
                        "username": "mm541145",
                        "content": "it looks similar to 877(stone game)"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "Can anyone tell the error in this,, thanks in advance\\n\\n\\nclass Solution {\\npublic:\\n                  \\n    int dp[501][501];\\n    int maxStone(int i, int n, int AliceTurn, vector<int>&arr){\\n        if(i > n)return 0;\\n        if(dp[i][n] != -1)return dp[i][n];\\n\\n        int first = 0, last = 0;\\n        if(AliceTurn)\\n        {\\n            return dp[i][n] = arr[i] + max(maxStone(i+1, n, 0, arr), maxStone(i, n-1, 0, arr));\\n        }\\n        else\\n        {\\n            // AS ALICE IS NOT TAKING THE ELEMENT SO WE WILL NOT ADD THIS TO OUR SUM\\n            return dp[i][n] = max(maxStone(i+1, n, 0, arr), maxStone(i, n-1, 1, arr));\\n        }\\n    }\\n    bool PredictTheWinner(vector<int>& nums) {\\n        int n = piles.size();\\n        memset(dp, -1, sizeof(dp));\\n        \\n            // TURN ==1 - > MEAN ALICE\\n        int sumAlice = maxStone(0,n-1, 1, piles);\\n        int sum =0;\\n        for(int i=0; i <n; i++)sum += piles[i];\\n        int sumBon = sum - sumAlice;\\n        cout<<sumAlice<<\" \"<<sumBon;\\n        return ( sumAlice >= sumBon);\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your function is looking quite right, but there are a few minor issues:\\n\\n1. It looks like you have mixed variable names. In your `PredictTheWinner` function, you\\'re using the variable `piles` which hasn\\'t been defined anywhere. You probably meant to use `nums`, which is the input to your function.\\n\\n2. In your `maxStone` function, you\\'re recursively calling it with `0` for `AliceTurn` in both cases within your `if (AliceTurn)` block. In the `else` condition, you should call `maxStone(i+1, n, 1, arr)` and `maxStone(i, n-1, 1, arr)`, otherwise you\\'re effectively making it always Alice\\'s turn and Bob will never play.\\n\\nHere is the corrected code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n\\n    int dp[501][501];\\n    int maxStone(int i, int n, int AliceTurn, vector<int>&arr){\\n        if(i > n)return 0;\\n        if(dp[i][n] != -1)return dp[i][n];\\n\\n        if(AliceTurn)\\n        {\\n            return dp[i][n] = arr[i] + max(maxStone(i+1, n, 0, arr), maxStone(i, n-1, 0, arr));\\n        }\\n        else\\n        {\\n            return dp[i][n] = max(maxStone(i+1, n, 1, arr), maxStone(i, n-1, 1, arr));\\n        }\\n    }\\n    bool PredictTheWinner(vector<int>& nums) {\\n        int n = nums.size();\\n        memset(dp, -1, sizeof(dp));\\n        int sumAlice = maxStone(0,n-1, 1, nums);\\n        int sum =0;\\n        for(int i=0; i <n; i++) sum += nums[i];\\n        int sumBon = sum - sumAlice;\\n        cout<<sumAlice<<\" \"<<sumBon;\\n        return ( sumAlice >= sumBon);\\n    }\\n};\\n```\\n\\nRemember, it\\'s important to maintain consistency in your variable names to avoid these types of errors. Also, make sure you\\'re setting the right parameters in your recursive calls.\\n"
                    },
                    {
                        "username": "enzo_cheng",
                        "content": "Test Case # 60 answer is wrong?!\\n\\nnums =\\n[3606449,6,5,9,452429,7,9580316,9857582,8514433,9,6,6614512,753594,5474165,4,2697293,8,7,1]\\n\\nA selection: [3606449, 5, 7, 452429, 2697293, 5474165, 6614512, 9, 9857582, 7]\\nB selection: [6, 1, 9, 8, 4, 753594, 6, 8514433, 9580316]\\n\\nA must be winner.\\n\\nAnswer is True, but test case is False.\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The provided test case is a demonstration of the fact that both players are playing optimally. They\\'re not just picking the largest value from either end, they\\'re thinking ahead to ensure the highest possible score for themselves. \\n\\nTo make it clearer, let\\'s run through the first few steps of this game with both players playing optimally:\\n\\n1. Player 1 (P1) can choose from 3606449 and 1. P1 picks 3606449, because it\\'s larger.\\n2. Player 2 (P2) can choose from 6 and 1. P2 picks 6, because it\\'s larger.\\n3. P1 can choose from 5 and 1. P1 picks 5, because it\\'s larger.\\n4. P2 can choose from 9 and 1. P2 picks 9, because it\\'s larger.\\n5. P1 can choose from 452429 and 1. P1 picks 452429, because it\\'s larger.\\n6. P2 can choose from 7 and 1. P2 picks 7, because it\\'s larger.\\n\\nWe can see that both players are taking the higher value available to them, and are not considering future moves. However, optimal play isn\\'t about maximizing the immediate gain. It\\'s about thinking ahead and choosing values that will lead to a higher final score. \\n\\nIn the given case, the returned answer is false because with optimal play, Player 1 does not win. Even though it seems like Player 1 can win with the selected values, keep in mind that the order of the choices and the strategy used to make these choices matter significantly, which is why your test case returns False. \\n\\nLet\\'s illustrate the decision process with a small example, [1, 5, 233, 7], where we already know that Player 1 can win. The process can be represented in the following table:\\n\\n| Turn   | Player | Available Choices | Choice | Player 1 Score | Player 2 Score |\\n|--------|--------|-------------------|--------|----------------|----------------|\\n| 1      | 1      | 1, 7              | 1      | 1              | 0              |\\n| 2      | 2      | 5, 7              | 7      | 1              | 7              |\\n| 3      | 1      | 5, 233            | 233    | 234            | 7              |\\n| 4      | 2      | 5                 | 5      | 234            | 12             |\\n\\nPlayer 1 is making their choices to ensure that Player 2 always has to choose between two numbers where one is significantly smaller than the other. In the second round, Player 1 forces Player 2 to choose between 5 and 7 instead of, say, 7 and 233, thus ensuring that they can grab the large number in the third round.\\n\\nThis is a simplified example, and the real game has more rounds and requires more complex strategic thinking. But it illustrates the basic idea: Playing optimally isn\\'t just about grabbing the largest available number, it\\'s also about controlling the choices available to the other player.\\n\\nIf you want to create a similar table for a larger array, the table will have more rows and the strategic decisions will be more complex, but the basic principle is the same."
                    },
                    {
                        "username": "amanag029",
                        "content": "nums =\\n[2,4,55,6,8] \\nfor the above nums , expected ans if False but it should be True?\\nAnalsis : P1 chooses max of possible options on its own turn while assuming P2 will left min for P1\\nTherefore, P1 chooses 8 > P2 chooses 6 > P1 chooses 55....\\n"
                    },
                    {
                        "username": "amitbansal13",
                        "content": "Can anyone help me understand what is wrong in this approach? Thanks in Advance.\n\n\n```\ndef PredictTheWinner(self, nums: List[int]) -> bool:\n        # d = {}\n        total = sum(nums)\n        @cache\n        def check(left, i, j, turn):\n            if i > j:\n                return left >= total - left\n            if turn:\n                return check(left+nums[i], i+1, j, not turn) or check(left+nums[j], i, j-1, not turn)\n            else:\n                return check(left, i+1, j, not turn) or check(left, i, j-1, not turn)\n            \n        return check(0, 0, len(nums)-1, True)\n```"
                    },
                    {
                        "username": "PrinceTp",
                        "content": "[2,4,55,6,8]\\n\\nPlayer 1 will win ,the answer must be TRUE for this test case,but the expected answer is FALSE ,any idea ?"
                    },
                    {
                        "username": "anil_kumar_2002",
                        "content": "bool PredictTheWinner(vector<int>& nums) {\\n        int s1=0; \\n        int s2=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(i%2==0){\\n                s1+=nums[i]; \\n            }\\n            else{\\n                s2+=nums[i]; \\n            }\\n        }\\n        if(s1>=s2){\\n            return true ; \\n        }\\n        return false;\\n    }\\nfor this code , {1,2} , it should return false, but compiler showing true , \\ncan anyone tell the problem , please? "
                    }
                ]
            },
            {
                "id": 1969132,
                "content": [
                    {
                        "username": "math_pi",
                        "content": "After Translating the Problem into Maximal Sum Difference b/w [A, B]. This problem becomes exactly similar to this one: https://leetcode.com/problems/stone-game-vii/"
                    },
                    {
                        "username": "math_pi",
                        "content": "Can Bitmask DP be used to attack this problem?"
                    },
                    {
                        "username": "metaphysicalist",
                        "content": "Yes, the state of the game can be defined by using bitmask for representing the remaining elements. But this problem is easier that the remaining elements can be simply represented by using the range (l, r) because the players can only take the leftmost or the rightmost elements. "
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, Bitmask Dynamic Programming (DP) can indeed be used to solve this problem. \\n\\nThe basic idea is that we maintain a state for each possible subset of the numbers in the game (represented as a binary mask), and for each state, we keep track of the maximum possible score difference between the two players if they play optimally.\\n\\nTo start, we initialize a DP array of size 2^n (where n is the length of the input array), and set all elements to a large negative value. We then set DP[0] to 0, because when there are no elements left in the game, the score difference is 0.\\n\\nThen, for each subset (represented as a binary mask), we iterate through all its elements (represented as bits in the binary mask). For each element, we consider two scenarios: the current player picks it, or they don\\'t. \\n\\nIf the current player picks it, the score difference changes by the value of the element (if it\\'s player 1\\'s turn) or by the negative of the value of the element (if it\\'s player 2\\'s turn). We then recursively call our DP function on the remaining elements, and update our DP array with the maximum score difference.\\n\\nIn the end, we return whether DP[2^n - 1] is non-negative. This represents the maximum score difference when all elements have been picked, and if it\\'s non-negative, player 1 can win or tie.\\n\\nPlease note that the Bitmask DP approach to this problem has a time complexity of O(n*2^n), which can be quite slow for large n. Therefore, it\\'s more suitable for cases where the length of the input array is small. If the length of the input array is large, a more efficient approach might be needed."
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "the most intuitive way to go about this problem is using recursion. definitely not the most optimal way, (crude recursion is basically brute forcing), but its the best way to start and build more sophisticated algorithms from (the pure dp approach). the constraints allow the recursive approach and i highly encourage to look out for it"
                    },
                    {
                        "username": "mm541145",
                        "content": "it looks similar to 877(stone game)"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "Can anyone tell the error in this,, thanks in advance\\n\\n\\nclass Solution {\\npublic:\\n                  \\n    int dp[501][501];\\n    int maxStone(int i, int n, int AliceTurn, vector<int>&arr){\\n        if(i > n)return 0;\\n        if(dp[i][n] != -1)return dp[i][n];\\n\\n        int first = 0, last = 0;\\n        if(AliceTurn)\\n        {\\n            return dp[i][n] = arr[i] + max(maxStone(i+1, n, 0, arr), maxStone(i, n-1, 0, arr));\\n        }\\n        else\\n        {\\n            // AS ALICE IS NOT TAKING THE ELEMENT SO WE WILL NOT ADD THIS TO OUR SUM\\n            return dp[i][n] = max(maxStone(i+1, n, 0, arr), maxStone(i, n-1, 1, arr));\\n        }\\n    }\\n    bool PredictTheWinner(vector<int>& nums) {\\n        int n = piles.size();\\n        memset(dp, -1, sizeof(dp));\\n        \\n            // TURN ==1 - > MEAN ALICE\\n        int sumAlice = maxStone(0,n-1, 1, piles);\\n        int sum =0;\\n        for(int i=0; i <n; i++)sum += piles[i];\\n        int sumBon = sum - sumAlice;\\n        cout<<sumAlice<<\" \"<<sumBon;\\n        return ( sumAlice >= sumBon);\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your function is looking quite right, but there are a few minor issues:\\n\\n1. It looks like you have mixed variable names. In your `PredictTheWinner` function, you\\'re using the variable `piles` which hasn\\'t been defined anywhere. You probably meant to use `nums`, which is the input to your function.\\n\\n2. In your `maxStone` function, you\\'re recursively calling it with `0` for `AliceTurn` in both cases within your `if (AliceTurn)` block. In the `else` condition, you should call `maxStone(i+1, n, 1, arr)` and `maxStone(i, n-1, 1, arr)`, otherwise you\\'re effectively making it always Alice\\'s turn and Bob will never play.\\n\\nHere is the corrected code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n\\n    int dp[501][501];\\n    int maxStone(int i, int n, int AliceTurn, vector<int>&arr){\\n        if(i > n)return 0;\\n        if(dp[i][n] != -1)return dp[i][n];\\n\\n        if(AliceTurn)\\n        {\\n            return dp[i][n] = arr[i] + max(maxStone(i+1, n, 0, arr), maxStone(i, n-1, 0, arr));\\n        }\\n        else\\n        {\\n            return dp[i][n] = max(maxStone(i+1, n, 1, arr), maxStone(i, n-1, 1, arr));\\n        }\\n    }\\n    bool PredictTheWinner(vector<int>& nums) {\\n        int n = nums.size();\\n        memset(dp, -1, sizeof(dp));\\n        int sumAlice = maxStone(0,n-1, 1, nums);\\n        int sum =0;\\n        for(int i=0; i <n; i++) sum += nums[i];\\n        int sumBon = sum - sumAlice;\\n        cout<<sumAlice<<\" \"<<sumBon;\\n        return ( sumAlice >= sumBon);\\n    }\\n};\\n```\\n\\nRemember, it\\'s important to maintain consistency in your variable names to avoid these types of errors. Also, make sure you\\'re setting the right parameters in your recursive calls.\\n"
                    },
                    {
                        "username": "enzo_cheng",
                        "content": "Test Case # 60 answer is wrong?!\\n\\nnums =\\n[3606449,6,5,9,452429,7,9580316,9857582,8514433,9,6,6614512,753594,5474165,4,2697293,8,7,1]\\n\\nA selection: [3606449, 5, 7, 452429, 2697293, 5474165, 6614512, 9, 9857582, 7]\\nB selection: [6, 1, 9, 8, 4, 753594, 6, 8514433, 9580316]\\n\\nA must be winner.\\n\\nAnswer is True, but test case is False.\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The provided test case is a demonstration of the fact that both players are playing optimally. They\\'re not just picking the largest value from either end, they\\'re thinking ahead to ensure the highest possible score for themselves. \\n\\nTo make it clearer, let\\'s run through the first few steps of this game with both players playing optimally:\\n\\n1. Player 1 (P1) can choose from 3606449 and 1. P1 picks 3606449, because it\\'s larger.\\n2. Player 2 (P2) can choose from 6 and 1. P2 picks 6, because it\\'s larger.\\n3. P1 can choose from 5 and 1. P1 picks 5, because it\\'s larger.\\n4. P2 can choose from 9 and 1. P2 picks 9, because it\\'s larger.\\n5. P1 can choose from 452429 and 1. P1 picks 452429, because it\\'s larger.\\n6. P2 can choose from 7 and 1. P2 picks 7, because it\\'s larger.\\n\\nWe can see that both players are taking the higher value available to them, and are not considering future moves. However, optimal play isn\\'t about maximizing the immediate gain. It\\'s about thinking ahead and choosing values that will lead to a higher final score. \\n\\nIn the given case, the returned answer is false because with optimal play, Player 1 does not win. Even though it seems like Player 1 can win with the selected values, keep in mind that the order of the choices and the strategy used to make these choices matter significantly, which is why your test case returns False. \\n\\nLet\\'s illustrate the decision process with a small example, [1, 5, 233, 7], where we already know that Player 1 can win. The process can be represented in the following table:\\n\\n| Turn   | Player | Available Choices | Choice | Player 1 Score | Player 2 Score |\\n|--------|--------|-------------------|--------|----------------|----------------|\\n| 1      | 1      | 1, 7              | 1      | 1              | 0              |\\n| 2      | 2      | 5, 7              | 7      | 1              | 7              |\\n| 3      | 1      | 5, 233            | 233    | 234            | 7              |\\n| 4      | 2      | 5                 | 5      | 234            | 12             |\\n\\nPlayer 1 is making their choices to ensure that Player 2 always has to choose between two numbers where one is significantly smaller than the other. In the second round, Player 1 forces Player 2 to choose between 5 and 7 instead of, say, 7 and 233, thus ensuring that they can grab the large number in the third round.\\n\\nThis is a simplified example, and the real game has more rounds and requires more complex strategic thinking. But it illustrates the basic idea: Playing optimally isn\\'t just about grabbing the largest available number, it\\'s also about controlling the choices available to the other player.\\n\\nIf you want to create a similar table for a larger array, the table will have more rows and the strategic decisions will be more complex, but the basic principle is the same."
                    },
                    {
                        "username": "amanag029",
                        "content": "nums =\\n[2,4,55,6,8] \\nfor the above nums , expected ans if False but it should be True?\\nAnalsis : P1 chooses max of possible options on its own turn while assuming P2 will left min for P1\\nTherefore, P1 chooses 8 > P2 chooses 6 > P1 chooses 55....\\n"
                    },
                    {
                        "username": "amitbansal13",
                        "content": "Can anyone help me understand what is wrong in this approach? Thanks in Advance.\n\n\n```\ndef PredictTheWinner(self, nums: List[int]) -> bool:\n        # d = {}\n        total = sum(nums)\n        @cache\n        def check(left, i, j, turn):\n            if i > j:\n                return left >= total - left\n            if turn:\n                return check(left+nums[i], i+1, j, not turn) or check(left+nums[j], i, j-1, not turn)\n            else:\n                return check(left, i+1, j, not turn) or check(left, i, j-1, not turn)\n            \n        return check(0, 0, len(nums)-1, True)\n```"
                    },
                    {
                        "username": "PrinceTp",
                        "content": "[2,4,55,6,8]\\n\\nPlayer 1 will win ,the answer must be TRUE for this test case,but the expected answer is FALSE ,any idea ?"
                    },
                    {
                        "username": "anil_kumar_2002",
                        "content": "bool PredictTheWinner(vector<int>& nums) {\\n        int s1=0; \\n        int s2=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(i%2==0){\\n                s1+=nums[i]; \\n            }\\n            else{\\n                s2+=nums[i]; \\n            }\\n        }\\n        if(s1>=s2){\\n            return true ; \\n        }\\n        return false;\\n    }\\nfor this code , {1,2} , it should return false, but compiler showing true , \\ncan anyone tell the problem , please? "
                    }
                ]
            },
            {
                "id": 1960772,
                "content": [
                    {
                        "username": "math_pi",
                        "content": "After Translating the Problem into Maximal Sum Difference b/w [A, B]. This problem becomes exactly similar to this one: https://leetcode.com/problems/stone-game-vii/"
                    },
                    {
                        "username": "math_pi",
                        "content": "Can Bitmask DP be used to attack this problem?"
                    },
                    {
                        "username": "metaphysicalist",
                        "content": "Yes, the state of the game can be defined by using bitmask for representing the remaining elements. But this problem is easier that the remaining elements can be simply represented by using the range (l, r) because the players can only take the leftmost or the rightmost elements. "
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, Bitmask Dynamic Programming (DP) can indeed be used to solve this problem. \\n\\nThe basic idea is that we maintain a state for each possible subset of the numbers in the game (represented as a binary mask), and for each state, we keep track of the maximum possible score difference between the two players if they play optimally.\\n\\nTo start, we initialize a DP array of size 2^n (where n is the length of the input array), and set all elements to a large negative value. We then set DP[0] to 0, because when there are no elements left in the game, the score difference is 0.\\n\\nThen, for each subset (represented as a binary mask), we iterate through all its elements (represented as bits in the binary mask). For each element, we consider two scenarios: the current player picks it, or they don\\'t. \\n\\nIf the current player picks it, the score difference changes by the value of the element (if it\\'s player 1\\'s turn) or by the negative of the value of the element (if it\\'s player 2\\'s turn). We then recursively call our DP function on the remaining elements, and update our DP array with the maximum score difference.\\n\\nIn the end, we return whether DP[2^n - 1] is non-negative. This represents the maximum score difference when all elements have been picked, and if it\\'s non-negative, player 1 can win or tie.\\n\\nPlease note that the Bitmask DP approach to this problem has a time complexity of O(n*2^n), which can be quite slow for large n. Therefore, it\\'s more suitable for cases where the length of the input array is small. If the length of the input array is large, a more efficient approach might be needed."
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "the most intuitive way to go about this problem is using recursion. definitely not the most optimal way, (crude recursion is basically brute forcing), but its the best way to start and build more sophisticated algorithms from (the pure dp approach). the constraints allow the recursive approach and i highly encourage to look out for it"
                    },
                    {
                        "username": "mm541145",
                        "content": "it looks similar to 877(stone game)"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "Can anyone tell the error in this,, thanks in advance\\n\\n\\nclass Solution {\\npublic:\\n                  \\n    int dp[501][501];\\n    int maxStone(int i, int n, int AliceTurn, vector<int>&arr){\\n        if(i > n)return 0;\\n        if(dp[i][n] != -1)return dp[i][n];\\n\\n        int first = 0, last = 0;\\n        if(AliceTurn)\\n        {\\n            return dp[i][n] = arr[i] + max(maxStone(i+1, n, 0, arr), maxStone(i, n-1, 0, arr));\\n        }\\n        else\\n        {\\n            // AS ALICE IS NOT TAKING THE ELEMENT SO WE WILL NOT ADD THIS TO OUR SUM\\n            return dp[i][n] = max(maxStone(i+1, n, 0, arr), maxStone(i, n-1, 1, arr));\\n        }\\n    }\\n    bool PredictTheWinner(vector<int>& nums) {\\n        int n = piles.size();\\n        memset(dp, -1, sizeof(dp));\\n        \\n            // TURN ==1 - > MEAN ALICE\\n        int sumAlice = maxStone(0,n-1, 1, piles);\\n        int sum =0;\\n        for(int i=0; i <n; i++)sum += piles[i];\\n        int sumBon = sum - sumAlice;\\n        cout<<sumAlice<<\" \"<<sumBon;\\n        return ( sumAlice >= sumBon);\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your function is looking quite right, but there are a few minor issues:\\n\\n1. It looks like you have mixed variable names. In your `PredictTheWinner` function, you\\'re using the variable `piles` which hasn\\'t been defined anywhere. You probably meant to use `nums`, which is the input to your function.\\n\\n2. In your `maxStone` function, you\\'re recursively calling it with `0` for `AliceTurn` in both cases within your `if (AliceTurn)` block. In the `else` condition, you should call `maxStone(i+1, n, 1, arr)` and `maxStone(i, n-1, 1, arr)`, otherwise you\\'re effectively making it always Alice\\'s turn and Bob will never play.\\n\\nHere is the corrected code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n\\n    int dp[501][501];\\n    int maxStone(int i, int n, int AliceTurn, vector<int>&arr){\\n        if(i > n)return 0;\\n        if(dp[i][n] != -1)return dp[i][n];\\n\\n        if(AliceTurn)\\n        {\\n            return dp[i][n] = arr[i] + max(maxStone(i+1, n, 0, arr), maxStone(i, n-1, 0, arr));\\n        }\\n        else\\n        {\\n            return dp[i][n] = max(maxStone(i+1, n, 1, arr), maxStone(i, n-1, 1, arr));\\n        }\\n    }\\n    bool PredictTheWinner(vector<int>& nums) {\\n        int n = nums.size();\\n        memset(dp, -1, sizeof(dp));\\n        int sumAlice = maxStone(0,n-1, 1, nums);\\n        int sum =0;\\n        for(int i=0; i <n; i++) sum += nums[i];\\n        int sumBon = sum - sumAlice;\\n        cout<<sumAlice<<\" \"<<sumBon;\\n        return ( sumAlice >= sumBon);\\n    }\\n};\\n```\\n\\nRemember, it\\'s important to maintain consistency in your variable names to avoid these types of errors. Also, make sure you\\'re setting the right parameters in your recursive calls.\\n"
                    },
                    {
                        "username": "enzo_cheng",
                        "content": "Test Case # 60 answer is wrong?!\\n\\nnums =\\n[3606449,6,5,9,452429,7,9580316,9857582,8514433,9,6,6614512,753594,5474165,4,2697293,8,7,1]\\n\\nA selection: [3606449, 5, 7, 452429, 2697293, 5474165, 6614512, 9, 9857582, 7]\\nB selection: [6, 1, 9, 8, 4, 753594, 6, 8514433, 9580316]\\n\\nA must be winner.\\n\\nAnswer is True, but test case is False.\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The provided test case is a demonstration of the fact that both players are playing optimally. They\\'re not just picking the largest value from either end, they\\'re thinking ahead to ensure the highest possible score for themselves. \\n\\nTo make it clearer, let\\'s run through the first few steps of this game with both players playing optimally:\\n\\n1. Player 1 (P1) can choose from 3606449 and 1. P1 picks 3606449, because it\\'s larger.\\n2. Player 2 (P2) can choose from 6 and 1. P2 picks 6, because it\\'s larger.\\n3. P1 can choose from 5 and 1. P1 picks 5, because it\\'s larger.\\n4. P2 can choose from 9 and 1. P2 picks 9, because it\\'s larger.\\n5. P1 can choose from 452429 and 1. P1 picks 452429, because it\\'s larger.\\n6. P2 can choose from 7 and 1. P2 picks 7, because it\\'s larger.\\n\\nWe can see that both players are taking the higher value available to them, and are not considering future moves. However, optimal play isn\\'t about maximizing the immediate gain. It\\'s about thinking ahead and choosing values that will lead to a higher final score. \\n\\nIn the given case, the returned answer is false because with optimal play, Player 1 does not win. Even though it seems like Player 1 can win with the selected values, keep in mind that the order of the choices and the strategy used to make these choices matter significantly, which is why your test case returns False. \\n\\nLet\\'s illustrate the decision process with a small example, [1, 5, 233, 7], where we already know that Player 1 can win. The process can be represented in the following table:\\n\\n| Turn   | Player | Available Choices | Choice | Player 1 Score | Player 2 Score |\\n|--------|--------|-------------------|--------|----------------|----------------|\\n| 1      | 1      | 1, 7              | 1      | 1              | 0              |\\n| 2      | 2      | 5, 7              | 7      | 1              | 7              |\\n| 3      | 1      | 5, 233            | 233    | 234            | 7              |\\n| 4      | 2      | 5                 | 5      | 234            | 12             |\\n\\nPlayer 1 is making their choices to ensure that Player 2 always has to choose between two numbers where one is significantly smaller than the other. In the second round, Player 1 forces Player 2 to choose between 5 and 7 instead of, say, 7 and 233, thus ensuring that they can grab the large number in the third round.\\n\\nThis is a simplified example, and the real game has more rounds and requires more complex strategic thinking. But it illustrates the basic idea: Playing optimally isn\\'t just about grabbing the largest available number, it\\'s also about controlling the choices available to the other player.\\n\\nIf you want to create a similar table for a larger array, the table will have more rows and the strategic decisions will be more complex, but the basic principle is the same."
                    },
                    {
                        "username": "amanag029",
                        "content": "nums =\\n[2,4,55,6,8] \\nfor the above nums , expected ans if False but it should be True?\\nAnalsis : P1 chooses max of possible options on its own turn while assuming P2 will left min for P1\\nTherefore, P1 chooses 8 > P2 chooses 6 > P1 chooses 55....\\n"
                    },
                    {
                        "username": "amitbansal13",
                        "content": "Can anyone help me understand what is wrong in this approach? Thanks in Advance.\n\n\n```\ndef PredictTheWinner(self, nums: List[int]) -> bool:\n        # d = {}\n        total = sum(nums)\n        @cache\n        def check(left, i, j, turn):\n            if i > j:\n                return left >= total - left\n            if turn:\n                return check(left+nums[i], i+1, j, not turn) or check(left+nums[j], i, j-1, not turn)\n            else:\n                return check(left, i+1, j, not turn) or check(left, i, j-1, not turn)\n            \n        return check(0, 0, len(nums)-1, True)\n```"
                    },
                    {
                        "username": "PrinceTp",
                        "content": "[2,4,55,6,8]\\n\\nPlayer 1 will win ,the answer must be TRUE for this test case,but the expected answer is FALSE ,any idea ?"
                    },
                    {
                        "username": "anil_kumar_2002",
                        "content": "bool PredictTheWinner(vector<int>& nums) {\\n        int s1=0; \\n        int s2=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(i%2==0){\\n                s1+=nums[i]; \\n            }\\n            else{\\n                s2+=nums[i]; \\n            }\\n        }\\n        if(s1>=s2){\\n            return true ; \\n        }\\n        return false;\\n    }\\nfor this code , {1,2} , it should return false, but compiler showing true , \\ncan anyone tell the problem , please? "
                    }
                ]
            },
            {
                "id": 1903159,
                "content": [
                    {
                        "username": "math_pi",
                        "content": "After Translating the Problem into Maximal Sum Difference b/w [A, B]. This problem becomes exactly similar to this one: https://leetcode.com/problems/stone-game-vii/"
                    },
                    {
                        "username": "math_pi",
                        "content": "Can Bitmask DP be used to attack this problem?"
                    },
                    {
                        "username": "metaphysicalist",
                        "content": "Yes, the state of the game can be defined by using bitmask for representing the remaining elements. But this problem is easier that the remaining elements can be simply represented by using the range (l, r) because the players can only take the leftmost or the rightmost elements. "
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, Bitmask Dynamic Programming (DP) can indeed be used to solve this problem. \\n\\nThe basic idea is that we maintain a state for each possible subset of the numbers in the game (represented as a binary mask), and for each state, we keep track of the maximum possible score difference between the two players if they play optimally.\\n\\nTo start, we initialize a DP array of size 2^n (where n is the length of the input array), and set all elements to a large negative value. We then set DP[0] to 0, because when there are no elements left in the game, the score difference is 0.\\n\\nThen, for each subset (represented as a binary mask), we iterate through all its elements (represented as bits in the binary mask). For each element, we consider two scenarios: the current player picks it, or they don\\'t. \\n\\nIf the current player picks it, the score difference changes by the value of the element (if it\\'s player 1\\'s turn) or by the negative of the value of the element (if it\\'s player 2\\'s turn). We then recursively call our DP function on the remaining elements, and update our DP array with the maximum score difference.\\n\\nIn the end, we return whether DP[2^n - 1] is non-negative. This represents the maximum score difference when all elements have been picked, and if it\\'s non-negative, player 1 can win or tie.\\n\\nPlease note that the Bitmask DP approach to this problem has a time complexity of O(n*2^n), which can be quite slow for large n. Therefore, it\\'s more suitable for cases where the length of the input array is small. If the length of the input array is large, a more efficient approach might be needed."
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "the most intuitive way to go about this problem is using recursion. definitely not the most optimal way, (crude recursion is basically brute forcing), but its the best way to start and build more sophisticated algorithms from (the pure dp approach). the constraints allow the recursive approach and i highly encourage to look out for it"
                    },
                    {
                        "username": "mm541145",
                        "content": "it looks similar to 877(stone game)"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "Can anyone tell the error in this,, thanks in advance\\n\\n\\nclass Solution {\\npublic:\\n                  \\n    int dp[501][501];\\n    int maxStone(int i, int n, int AliceTurn, vector<int>&arr){\\n        if(i > n)return 0;\\n        if(dp[i][n] != -1)return dp[i][n];\\n\\n        int first = 0, last = 0;\\n        if(AliceTurn)\\n        {\\n            return dp[i][n] = arr[i] + max(maxStone(i+1, n, 0, arr), maxStone(i, n-1, 0, arr));\\n        }\\n        else\\n        {\\n            // AS ALICE IS NOT TAKING THE ELEMENT SO WE WILL NOT ADD THIS TO OUR SUM\\n            return dp[i][n] = max(maxStone(i+1, n, 0, arr), maxStone(i, n-1, 1, arr));\\n        }\\n    }\\n    bool PredictTheWinner(vector<int>& nums) {\\n        int n = piles.size();\\n        memset(dp, -1, sizeof(dp));\\n        \\n            // TURN ==1 - > MEAN ALICE\\n        int sumAlice = maxStone(0,n-1, 1, piles);\\n        int sum =0;\\n        for(int i=0; i <n; i++)sum += piles[i];\\n        int sumBon = sum - sumAlice;\\n        cout<<sumAlice<<\" \"<<sumBon;\\n        return ( sumAlice >= sumBon);\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your function is looking quite right, but there are a few minor issues:\\n\\n1. It looks like you have mixed variable names. In your `PredictTheWinner` function, you\\'re using the variable `piles` which hasn\\'t been defined anywhere. You probably meant to use `nums`, which is the input to your function.\\n\\n2. In your `maxStone` function, you\\'re recursively calling it with `0` for `AliceTurn` in both cases within your `if (AliceTurn)` block. In the `else` condition, you should call `maxStone(i+1, n, 1, arr)` and `maxStone(i, n-1, 1, arr)`, otherwise you\\'re effectively making it always Alice\\'s turn and Bob will never play.\\n\\nHere is the corrected code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n\\n    int dp[501][501];\\n    int maxStone(int i, int n, int AliceTurn, vector<int>&arr){\\n        if(i > n)return 0;\\n        if(dp[i][n] != -1)return dp[i][n];\\n\\n        if(AliceTurn)\\n        {\\n            return dp[i][n] = arr[i] + max(maxStone(i+1, n, 0, arr), maxStone(i, n-1, 0, arr));\\n        }\\n        else\\n        {\\n            return dp[i][n] = max(maxStone(i+1, n, 1, arr), maxStone(i, n-1, 1, arr));\\n        }\\n    }\\n    bool PredictTheWinner(vector<int>& nums) {\\n        int n = nums.size();\\n        memset(dp, -1, sizeof(dp));\\n        int sumAlice = maxStone(0,n-1, 1, nums);\\n        int sum =0;\\n        for(int i=0; i <n; i++) sum += nums[i];\\n        int sumBon = sum - sumAlice;\\n        cout<<sumAlice<<\" \"<<sumBon;\\n        return ( sumAlice >= sumBon);\\n    }\\n};\\n```\\n\\nRemember, it\\'s important to maintain consistency in your variable names to avoid these types of errors. Also, make sure you\\'re setting the right parameters in your recursive calls.\\n"
                    },
                    {
                        "username": "enzo_cheng",
                        "content": "Test Case # 60 answer is wrong?!\\n\\nnums =\\n[3606449,6,5,9,452429,7,9580316,9857582,8514433,9,6,6614512,753594,5474165,4,2697293,8,7,1]\\n\\nA selection: [3606449, 5, 7, 452429, 2697293, 5474165, 6614512, 9, 9857582, 7]\\nB selection: [6, 1, 9, 8, 4, 753594, 6, 8514433, 9580316]\\n\\nA must be winner.\\n\\nAnswer is True, but test case is False.\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The provided test case is a demonstration of the fact that both players are playing optimally. They\\'re not just picking the largest value from either end, they\\'re thinking ahead to ensure the highest possible score for themselves. \\n\\nTo make it clearer, let\\'s run through the first few steps of this game with both players playing optimally:\\n\\n1. Player 1 (P1) can choose from 3606449 and 1. P1 picks 3606449, because it\\'s larger.\\n2. Player 2 (P2) can choose from 6 and 1. P2 picks 6, because it\\'s larger.\\n3. P1 can choose from 5 and 1. P1 picks 5, because it\\'s larger.\\n4. P2 can choose from 9 and 1. P2 picks 9, because it\\'s larger.\\n5. P1 can choose from 452429 and 1. P1 picks 452429, because it\\'s larger.\\n6. P2 can choose from 7 and 1. P2 picks 7, because it\\'s larger.\\n\\nWe can see that both players are taking the higher value available to them, and are not considering future moves. However, optimal play isn\\'t about maximizing the immediate gain. It\\'s about thinking ahead and choosing values that will lead to a higher final score. \\n\\nIn the given case, the returned answer is false because with optimal play, Player 1 does not win. Even though it seems like Player 1 can win with the selected values, keep in mind that the order of the choices and the strategy used to make these choices matter significantly, which is why your test case returns False. \\n\\nLet\\'s illustrate the decision process with a small example, [1, 5, 233, 7], where we already know that Player 1 can win. The process can be represented in the following table:\\n\\n| Turn   | Player | Available Choices | Choice | Player 1 Score | Player 2 Score |\\n|--------|--------|-------------------|--------|----------------|----------------|\\n| 1      | 1      | 1, 7              | 1      | 1              | 0              |\\n| 2      | 2      | 5, 7              | 7      | 1              | 7              |\\n| 3      | 1      | 5, 233            | 233    | 234            | 7              |\\n| 4      | 2      | 5                 | 5      | 234            | 12             |\\n\\nPlayer 1 is making their choices to ensure that Player 2 always has to choose between two numbers where one is significantly smaller than the other. In the second round, Player 1 forces Player 2 to choose between 5 and 7 instead of, say, 7 and 233, thus ensuring that they can grab the large number in the third round.\\n\\nThis is a simplified example, and the real game has more rounds and requires more complex strategic thinking. But it illustrates the basic idea: Playing optimally isn\\'t just about grabbing the largest available number, it\\'s also about controlling the choices available to the other player.\\n\\nIf you want to create a similar table for a larger array, the table will have more rows and the strategic decisions will be more complex, but the basic principle is the same."
                    },
                    {
                        "username": "amanag029",
                        "content": "nums =\\n[2,4,55,6,8] \\nfor the above nums , expected ans if False but it should be True?\\nAnalsis : P1 chooses max of possible options on its own turn while assuming P2 will left min for P1\\nTherefore, P1 chooses 8 > P2 chooses 6 > P1 chooses 55....\\n"
                    },
                    {
                        "username": "amitbansal13",
                        "content": "Can anyone help me understand what is wrong in this approach? Thanks in Advance.\n\n\n```\ndef PredictTheWinner(self, nums: List[int]) -> bool:\n        # d = {}\n        total = sum(nums)\n        @cache\n        def check(left, i, j, turn):\n            if i > j:\n                return left >= total - left\n            if turn:\n                return check(left+nums[i], i+1, j, not turn) or check(left+nums[j], i, j-1, not turn)\n            else:\n                return check(left, i+1, j, not turn) or check(left, i, j-1, not turn)\n            \n        return check(0, 0, len(nums)-1, True)\n```"
                    },
                    {
                        "username": "PrinceTp",
                        "content": "[2,4,55,6,8]\\n\\nPlayer 1 will win ,the answer must be TRUE for this test case,but the expected answer is FALSE ,any idea ?"
                    },
                    {
                        "username": "anil_kumar_2002",
                        "content": "bool PredictTheWinner(vector<int>& nums) {\\n        int s1=0; \\n        int s2=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(i%2==0){\\n                s1+=nums[i]; \\n            }\\n            else{\\n                s2+=nums[i]; \\n            }\\n        }\\n        if(s1>=s2){\\n            return true ; \\n        }\\n        return false;\\n    }\\nfor this code , {1,2} , it should return false, but compiler showing true , \\ncan anyone tell the problem , please? "
                    }
                ]
            },
            {
                "id": 1862659,
                "content": [
                    {
                        "username": "math_pi",
                        "content": "After Translating the Problem into Maximal Sum Difference b/w [A, B]. This problem becomes exactly similar to this one: https://leetcode.com/problems/stone-game-vii/"
                    },
                    {
                        "username": "math_pi",
                        "content": "Can Bitmask DP be used to attack this problem?"
                    },
                    {
                        "username": "metaphysicalist",
                        "content": "Yes, the state of the game can be defined by using bitmask for representing the remaining elements. But this problem is easier that the remaining elements can be simply represented by using the range (l, r) because the players can only take the leftmost or the rightmost elements. "
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, Bitmask Dynamic Programming (DP) can indeed be used to solve this problem. \\n\\nThe basic idea is that we maintain a state for each possible subset of the numbers in the game (represented as a binary mask), and for each state, we keep track of the maximum possible score difference between the two players if they play optimally.\\n\\nTo start, we initialize a DP array of size 2^n (where n is the length of the input array), and set all elements to a large negative value. We then set DP[0] to 0, because when there are no elements left in the game, the score difference is 0.\\n\\nThen, for each subset (represented as a binary mask), we iterate through all its elements (represented as bits in the binary mask). For each element, we consider two scenarios: the current player picks it, or they don\\'t. \\n\\nIf the current player picks it, the score difference changes by the value of the element (if it\\'s player 1\\'s turn) or by the negative of the value of the element (if it\\'s player 2\\'s turn). We then recursively call our DP function on the remaining elements, and update our DP array with the maximum score difference.\\n\\nIn the end, we return whether DP[2^n - 1] is non-negative. This represents the maximum score difference when all elements have been picked, and if it\\'s non-negative, player 1 can win or tie.\\n\\nPlease note that the Bitmask DP approach to this problem has a time complexity of O(n*2^n), which can be quite slow for large n. Therefore, it\\'s more suitable for cases where the length of the input array is small. If the length of the input array is large, a more efficient approach might be needed."
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "the most intuitive way to go about this problem is using recursion. definitely not the most optimal way, (crude recursion is basically brute forcing), but its the best way to start and build more sophisticated algorithms from (the pure dp approach). the constraints allow the recursive approach and i highly encourage to look out for it"
                    },
                    {
                        "username": "mm541145",
                        "content": "it looks similar to 877(stone game)"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "Can anyone tell the error in this,, thanks in advance\\n\\n\\nclass Solution {\\npublic:\\n                  \\n    int dp[501][501];\\n    int maxStone(int i, int n, int AliceTurn, vector<int>&arr){\\n        if(i > n)return 0;\\n        if(dp[i][n] != -1)return dp[i][n];\\n\\n        int first = 0, last = 0;\\n        if(AliceTurn)\\n        {\\n            return dp[i][n] = arr[i] + max(maxStone(i+1, n, 0, arr), maxStone(i, n-1, 0, arr));\\n        }\\n        else\\n        {\\n            // AS ALICE IS NOT TAKING THE ELEMENT SO WE WILL NOT ADD THIS TO OUR SUM\\n            return dp[i][n] = max(maxStone(i+1, n, 0, arr), maxStone(i, n-1, 1, arr));\\n        }\\n    }\\n    bool PredictTheWinner(vector<int>& nums) {\\n        int n = piles.size();\\n        memset(dp, -1, sizeof(dp));\\n        \\n            // TURN ==1 - > MEAN ALICE\\n        int sumAlice = maxStone(0,n-1, 1, piles);\\n        int sum =0;\\n        for(int i=0; i <n; i++)sum += piles[i];\\n        int sumBon = sum - sumAlice;\\n        cout<<sumAlice<<\" \"<<sumBon;\\n        return ( sumAlice >= sumBon);\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your function is looking quite right, but there are a few minor issues:\\n\\n1. It looks like you have mixed variable names. In your `PredictTheWinner` function, you\\'re using the variable `piles` which hasn\\'t been defined anywhere. You probably meant to use `nums`, which is the input to your function.\\n\\n2. In your `maxStone` function, you\\'re recursively calling it with `0` for `AliceTurn` in both cases within your `if (AliceTurn)` block. In the `else` condition, you should call `maxStone(i+1, n, 1, arr)` and `maxStone(i, n-1, 1, arr)`, otherwise you\\'re effectively making it always Alice\\'s turn and Bob will never play.\\n\\nHere is the corrected code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n\\n    int dp[501][501];\\n    int maxStone(int i, int n, int AliceTurn, vector<int>&arr){\\n        if(i > n)return 0;\\n        if(dp[i][n] != -1)return dp[i][n];\\n\\n        if(AliceTurn)\\n        {\\n            return dp[i][n] = arr[i] + max(maxStone(i+1, n, 0, arr), maxStone(i, n-1, 0, arr));\\n        }\\n        else\\n        {\\n            return dp[i][n] = max(maxStone(i+1, n, 1, arr), maxStone(i, n-1, 1, arr));\\n        }\\n    }\\n    bool PredictTheWinner(vector<int>& nums) {\\n        int n = nums.size();\\n        memset(dp, -1, sizeof(dp));\\n        int sumAlice = maxStone(0,n-1, 1, nums);\\n        int sum =0;\\n        for(int i=0; i <n; i++) sum += nums[i];\\n        int sumBon = sum - sumAlice;\\n        cout<<sumAlice<<\" \"<<sumBon;\\n        return ( sumAlice >= sumBon);\\n    }\\n};\\n```\\n\\nRemember, it\\'s important to maintain consistency in your variable names to avoid these types of errors. Also, make sure you\\'re setting the right parameters in your recursive calls.\\n"
                    },
                    {
                        "username": "enzo_cheng",
                        "content": "Test Case # 60 answer is wrong?!\\n\\nnums =\\n[3606449,6,5,9,452429,7,9580316,9857582,8514433,9,6,6614512,753594,5474165,4,2697293,8,7,1]\\n\\nA selection: [3606449, 5, 7, 452429, 2697293, 5474165, 6614512, 9, 9857582, 7]\\nB selection: [6, 1, 9, 8, 4, 753594, 6, 8514433, 9580316]\\n\\nA must be winner.\\n\\nAnswer is True, but test case is False.\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The provided test case is a demonstration of the fact that both players are playing optimally. They\\'re not just picking the largest value from either end, they\\'re thinking ahead to ensure the highest possible score for themselves. \\n\\nTo make it clearer, let\\'s run through the first few steps of this game with both players playing optimally:\\n\\n1. Player 1 (P1) can choose from 3606449 and 1. P1 picks 3606449, because it\\'s larger.\\n2. Player 2 (P2) can choose from 6 and 1. P2 picks 6, because it\\'s larger.\\n3. P1 can choose from 5 and 1. P1 picks 5, because it\\'s larger.\\n4. P2 can choose from 9 and 1. P2 picks 9, because it\\'s larger.\\n5. P1 can choose from 452429 and 1. P1 picks 452429, because it\\'s larger.\\n6. P2 can choose from 7 and 1. P2 picks 7, because it\\'s larger.\\n\\nWe can see that both players are taking the higher value available to them, and are not considering future moves. However, optimal play isn\\'t about maximizing the immediate gain. It\\'s about thinking ahead and choosing values that will lead to a higher final score. \\n\\nIn the given case, the returned answer is false because with optimal play, Player 1 does not win. Even though it seems like Player 1 can win with the selected values, keep in mind that the order of the choices and the strategy used to make these choices matter significantly, which is why your test case returns False. \\n\\nLet\\'s illustrate the decision process with a small example, [1, 5, 233, 7], where we already know that Player 1 can win. The process can be represented in the following table:\\n\\n| Turn   | Player | Available Choices | Choice | Player 1 Score | Player 2 Score |\\n|--------|--------|-------------------|--------|----------------|----------------|\\n| 1      | 1      | 1, 7              | 1      | 1              | 0              |\\n| 2      | 2      | 5, 7              | 7      | 1              | 7              |\\n| 3      | 1      | 5, 233            | 233    | 234            | 7              |\\n| 4      | 2      | 5                 | 5      | 234            | 12             |\\n\\nPlayer 1 is making their choices to ensure that Player 2 always has to choose between two numbers where one is significantly smaller than the other. In the second round, Player 1 forces Player 2 to choose between 5 and 7 instead of, say, 7 and 233, thus ensuring that they can grab the large number in the third round.\\n\\nThis is a simplified example, and the real game has more rounds and requires more complex strategic thinking. But it illustrates the basic idea: Playing optimally isn\\'t just about grabbing the largest available number, it\\'s also about controlling the choices available to the other player.\\n\\nIf you want to create a similar table for a larger array, the table will have more rows and the strategic decisions will be more complex, but the basic principle is the same."
                    },
                    {
                        "username": "amanag029",
                        "content": "nums =\\n[2,4,55,6,8] \\nfor the above nums , expected ans if False but it should be True?\\nAnalsis : P1 chooses max of possible options on its own turn while assuming P2 will left min for P1\\nTherefore, P1 chooses 8 > P2 chooses 6 > P1 chooses 55....\\n"
                    },
                    {
                        "username": "amitbansal13",
                        "content": "Can anyone help me understand what is wrong in this approach? Thanks in Advance.\n\n\n```\ndef PredictTheWinner(self, nums: List[int]) -> bool:\n        # d = {}\n        total = sum(nums)\n        @cache\n        def check(left, i, j, turn):\n            if i > j:\n                return left >= total - left\n            if turn:\n                return check(left+nums[i], i+1, j, not turn) or check(left+nums[j], i, j-1, not turn)\n            else:\n                return check(left, i+1, j, not turn) or check(left, i, j-1, not turn)\n            \n        return check(0, 0, len(nums)-1, True)\n```"
                    },
                    {
                        "username": "PrinceTp",
                        "content": "[2,4,55,6,8]\\n\\nPlayer 1 will win ,the answer must be TRUE for this test case,but the expected answer is FALSE ,any idea ?"
                    },
                    {
                        "username": "anil_kumar_2002",
                        "content": "bool PredictTheWinner(vector<int>& nums) {\\n        int s1=0; \\n        int s2=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(i%2==0){\\n                s1+=nums[i]; \\n            }\\n            else{\\n                s2+=nums[i]; \\n            }\\n        }\\n        if(s1>=s2){\\n            return true ; \\n        }\\n        return false;\\n    }\\nfor this code , {1,2} , it should return false, but compiler showing true , \\ncan anyone tell the problem , please? "
                    }
                ]
            },
            {
                "id": 1846014,
                "content": [
                    {
                        "username": "math_pi",
                        "content": "After Translating the Problem into Maximal Sum Difference b/w [A, B]. This problem becomes exactly similar to this one: https://leetcode.com/problems/stone-game-vii/"
                    },
                    {
                        "username": "math_pi",
                        "content": "Can Bitmask DP be used to attack this problem?"
                    },
                    {
                        "username": "metaphysicalist",
                        "content": "Yes, the state of the game can be defined by using bitmask for representing the remaining elements. But this problem is easier that the remaining elements can be simply represented by using the range (l, r) because the players can only take the leftmost or the rightmost elements. "
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, Bitmask Dynamic Programming (DP) can indeed be used to solve this problem. \\n\\nThe basic idea is that we maintain a state for each possible subset of the numbers in the game (represented as a binary mask), and for each state, we keep track of the maximum possible score difference between the two players if they play optimally.\\n\\nTo start, we initialize a DP array of size 2^n (where n is the length of the input array), and set all elements to a large negative value. We then set DP[0] to 0, because when there are no elements left in the game, the score difference is 0.\\n\\nThen, for each subset (represented as a binary mask), we iterate through all its elements (represented as bits in the binary mask). For each element, we consider two scenarios: the current player picks it, or they don\\'t. \\n\\nIf the current player picks it, the score difference changes by the value of the element (if it\\'s player 1\\'s turn) or by the negative of the value of the element (if it\\'s player 2\\'s turn). We then recursively call our DP function on the remaining elements, and update our DP array with the maximum score difference.\\n\\nIn the end, we return whether DP[2^n - 1] is non-negative. This represents the maximum score difference when all elements have been picked, and if it\\'s non-negative, player 1 can win or tie.\\n\\nPlease note that the Bitmask DP approach to this problem has a time complexity of O(n*2^n), which can be quite slow for large n. Therefore, it\\'s more suitable for cases where the length of the input array is small. If the length of the input array is large, a more efficient approach might be needed."
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "the most intuitive way to go about this problem is using recursion. definitely not the most optimal way, (crude recursion is basically brute forcing), but its the best way to start and build more sophisticated algorithms from (the pure dp approach). the constraints allow the recursive approach and i highly encourage to look out for it"
                    },
                    {
                        "username": "mm541145",
                        "content": "it looks similar to 877(stone game)"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "Can anyone tell the error in this,, thanks in advance\\n\\n\\nclass Solution {\\npublic:\\n                  \\n    int dp[501][501];\\n    int maxStone(int i, int n, int AliceTurn, vector<int>&arr){\\n        if(i > n)return 0;\\n        if(dp[i][n] != -1)return dp[i][n];\\n\\n        int first = 0, last = 0;\\n        if(AliceTurn)\\n        {\\n            return dp[i][n] = arr[i] + max(maxStone(i+1, n, 0, arr), maxStone(i, n-1, 0, arr));\\n        }\\n        else\\n        {\\n            // AS ALICE IS NOT TAKING THE ELEMENT SO WE WILL NOT ADD THIS TO OUR SUM\\n            return dp[i][n] = max(maxStone(i+1, n, 0, arr), maxStone(i, n-1, 1, arr));\\n        }\\n    }\\n    bool PredictTheWinner(vector<int>& nums) {\\n        int n = piles.size();\\n        memset(dp, -1, sizeof(dp));\\n        \\n            // TURN ==1 - > MEAN ALICE\\n        int sumAlice = maxStone(0,n-1, 1, piles);\\n        int sum =0;\\n        for(int i=0; i <n; i++)sum += piles[i];\\n        int sumBon = sum - sumAlice;\\n        cout<<sumAlice<<\" \"<<sumBon;\\n        return ( sumAlice >= sumBon);\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your function is looking quite right, but there are a few minor issues:\\n\\n1. It looks like you have mixed variable names. In your `PredictTheWinner` function, you\\'re using the variable `piles` which hasn\\'t been defined anywhere. You probably meant to use `nums`, which is the input to your function.\\n\\n2. In your `maxStone` function, you\\'re recursively calling it with `0` for `AliceTurn` in both cases within your `if (AliceTurn)` block. In the `else` condition, you should call `maxStone(i+1, n, 1, arr)` and `maxStone(i, n-1, 1, arr)`, otherwise you\\'re effectively making it always Alice\\'s turn and Bob will never play.\\n\\nHere is the corrected code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n\\n    int dp[501][501];\\n    int maxStone(int i, int n, int AliceTurn, vector<int>&arr){\\n        if(i > n)return 0;\\n        if(dp[i][n] != -1)return dp[i][n];\\n\\n        if(AliceTurn)\\n        {\\n            return dp[i][n] = arr[i] + max(maxStone(i+1, n, 0, arr), maxStone(i, n-1, 0, arr));\\n        }\\n        else\\n        {\\n            return dp[i][n] = max(maxStone(i+1, n, 1, arr), maxStone(i, n-1, 1, arr));\\n        }\\n    }\\n    bool PredictTheWinner(vector<int>& nums) {\\n        int n = nums.size();\\n        memset(dp, -1, sizeof(dp));\\n        int sumAlice = maxStone(0,n-1, 1, nums);\\n        int sum =0;\\n        for(int i=0; i <n; i++) sum += nums[i];\\n        int sumBon = sum - sumAlice;\\n        cout<<sumAlice<<\" \"<<sumBon;\\n        return ( sumAlice >= sumBon);\\n    }\\n};\\n```\\n\\nRemember, it\\'s important to maintain consistency in your variable names to avoid these types of errors. Also, make sure you\\'re setting the right parameters in your recursive calls.\\n"
                    },
                    {
                        "username": "enzo_cheng",
                        "content": "Test Case # 60 answer is wrong?!\\n\\nnums =\\n[3606449,6,5,9,452429,7,9580316,9857582,8514433,9,6,6614512,753594,5474165,4,2697293,8,7,1]\\n\\nA selection: [3606449, 5, 7, 452429, 2697293, 5474165, 6614512, 9, 9857582, 7]\\nB selection: [6, 1, 9, 8, 4, 753594, 6, 8514433, 9580316]\\n\\nA must be winner.\\n\\nAnswer is True, but test case is False.\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The provided test case is a demonstration of the fact that both players are playing optimally. They\\'re not just picking the largest value from either end, they\\'re thinking ahead to ensure the highest possible score for themselves. \\n\\nTo make it clearer, let\\'s run through the first few steps of this game with both players playing optimally:\\n\\n1. Player 1 (P1) can choose from 3606449 and 1. P1 picks 3606449, because it\\'s larger.\\n2. Player 2 (P2) can choose from 6 and 1. P2 picks 6, because it\\'s larger.\\n3. P1 can choose from 5 and 1. P1 picks 5, because it\\'s larger.\\n4. P2 can choose from 9 and 1. P2 picks 9, because it\\'s larger.\\n5. P1 can choose from 452429 and 1. P1 picks 452429, because it\\'s larger.\\n6. P2 can choose from 7 and 1. P2 picks 7, because it\\'s larger.\\n\\nWe can see that both players are taking the higher value available to them, and are not considering future moves. However, optimal play isn\\'t about maximizing the immediate gain. It\\'s about thinking ahead and choosing values that will lead to a higher final score. \\n\\nIn the given case, the returned answer is false because with optimal play, Player 1 does not win. Even though it seems like Player 1 can win with the selected values, keep in mind that the order of the choices and the strategy used to make these choices matter significantly, which is why your test case returns False. \\n\\nLet\\'s illustrate the decision process with a small example, [1, 5, 233, 7], where we already know that Player 1 can win. The process can be represented in the following table:\\n\\n| Turn   | Player | Available Choices | Choice | Player 1 Score | Player 2 Score |\\n|--------|--------|-------------------|--------|----------------|----------------|\\n| 1      | 1      | 1, 7              | 1      | 1              | 0              |\\n| 2      | 2      | 5, 7              | 7      | 1              | 7              |\\n| 3      | 1      | 5, 233            | 233    | 234            | 7              |\\n| 4      | 2      | 5                 | 5      | 234            | 12             |\\n\\nPlayer 1 is making their choices to ensure that Player 2 always has to choose between two numbers where one is significantly smaller than the other. In the second round, Player 1 forces Player 2 to choose between 5 and 7 instead of, say, 7 and 233, thus ensuring that they can grab the large number in the third round.\\n\\nThis is a simplified example, and the real game has more rounds and requires more complex strategic thinking. But it illustrates the basic idea: Playing optimally isn\\'t just about grabbing the largest available number, it\\'s also about controlling the choices available to the other player.\\n\\nIf you want to create a similar table for a larger array, the table will have more rows and the strategic decisions will be more complex, but the basic principle is the same."
                    },
                    {
                        "username": "amanag029",
                        "content": "nums =\\n[2,4,55,6,8] \\nfor the above nums , expected ans if False but it should be True?\\nAnalsis : P1 chooses max of possible options on its own turn while assuming P2 will left min for P1\\nTherefore, P1 chooses 8 > P2 chooses 6 > P1 chooses 55....\\n"
                    },
                    {
                        "username": "amitbansal13",
                        "content": "Can anyone help me understand what is wrong in this approach? Thanks in Advance.\n\n\n```\ndef PredictTheWinner(self, nums: List[int]) -> bool:\n        # d = {}\n        total = sum(nums)\n        @cache\n        def check(left, i, j, turn):\n            if i > j:\n                return left >= total - left\n            if turn:\n                return check(left+nums[i], i+1, j, not turn) or check(left+nums[j], i, j-1, not turn)\n            else:\n                return check(left, i+1, j, not turn) or check(left, i, j-1, not turn)\n            \n        return check(0, 0, len(nums)-1, True)\n```"
                    },
                    {
                        "username": "PrinceTp",
                        "content": "[2,4,55,6,8]\\n\\nPlayer 1 will win ,the answer must be TRUE for this test case,but the expected answer is FALSE ,any idea ?"
                    },
                    {
                        "username": "anil_kumar_2002",
                        "content": "bool PredictTheWinner(vector<int>& nums) {\\n        int s1=0; \\n        int s2=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(i%2==0){\\n                s1+=nums[i]; \\n            }\\n            else{\\n                s2+=nums[i]; \\n            }\\n        }\\n        if(s1>=s2){\\n            return true ; \\n        }\\n        return false;\\n    }\\nfor this code , {1,2} , it should return false, but compiler showing true , \\ncan anyone tell the problem , please? "
                    }
                ]
            },
            {
                "id": 1830574,
                "content": [
                    {
                        "username": "math_pi",
                        "content": "After Translating the Problem into Maximal Sum Difference b/w [A, B]. This problem becomes exactly similar to this one: https://leetcode.com/problems/stone-game-vii/"
                    },
                    {
                        "username": "math_pi",
                        "content": "Can Bitmask DP be used to attack this problem?"
                    },
                    {
                        "username": "metaphysicalist",
                        "content": "Yes, the state of the game can be defined by using bitmask for representing the remaining elements. But this problem is easier that the remaining elements can be simply represented by using the range (l, r) because the players can only take the leftmost or the rightmost elements. "
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, Bitmask Dynamic Programming (DP) can indeed be used to solve this problem. \\n\\nThe basic idea is that we maintain a state for each possible subset of the numbers in the game (represented as a binary mask), and for each state, we keep track of the maximum possible score difference between the two players if they play optimally.\\n\\nTo start, we initialize a DP array of size 2^n (where n is the length of the input array), and set all elements to a large negative value. We then set DP[0] to 0, because when there are no elements left in the game, the score difference is 0.\\n\\nThen, for each subset (represented as a binary mask), we iterate through all its elements (represented as bits in the binary mask). For each element, we consider two scenarios: the current player picks it, or they don\\'t. \\n\\nIf the current player picks it, the score difference changes by the value of the element (if it\\'s player 1\\'s turn) or by the negative of the value of the element (if it\\'s player 2\\'s turn). We then recursively call our DP function on the remaining elements, and update our DP array with the maximum score difference.\\n\\nIn the end, we return whether DP[2^n - 1] is non-negative. This represents the maximum score difference when all elements have been picked, and if it\\'s non-negative, player 1 can win or tie.\\n\\nPlease note that the Bitmask DP approach to this problem has a time complexity of O(n*2^n), which can be quite slow for large n. Therefore, it\\'s more suitable for cases where the length of the input array is small. If the length of the input array is large, a more efficient approach might be needed."
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "the most intuitive way to go about this problem is using recursion. definitely not the most optimal way, (crude recursion is basically brute forcing), but its the best way to start and build more sophisticated algorithms from (the pure dp approach). the constraints allow the recursive approach and i highly encourage to look out for it"
                    },
                    {
                        "username": "mm541145",
                        "content": "it looks similar to 877(stone game)"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "Can anyone tell the error in this,, thanks in advance\\n\\n\\nclass Solution {\\npublic:\\n                  \\n    int dp[501][501];\\n    int maxStone(int i, int n, int AliceTurn, vector<int>&arr){\\n        if(i > n)return 0;\\n        if(dp[i][n] != -1)return dp[i][n];\\n\\n        int first = 0, last = 0;\\n        if(AliceTurn)\\n        {\\n            return dp[i][n] = arr[i] + max(maxStone(i+1, n, 0, arr), maxStone(i, n-1, 0, arr));\\n        }\\n        else\\n        {\\n            // AS ALICE IS NOT TAKING THE ELEMENT SO WE WILL NOT ADD THIS TO OUR SUM\\n            return dp[i][n] = max(maxStone(i+1, n, 0, arr), maxStone(i, n-1, 1, arr));\\n        }\\n    }\\n    bool PredictTheWinner(vector<int>& nums) {\\n        int n = piles.size();\\n        memset(dp, -1, sizeof(dp));\\n        \\n            // TURN ==1 - > MEAN ALICE\\n        int sumAlice = maxStone(0,n-1, 1, piles);\\n        int sum =0;\\n        for(int i=0; i <n; i++)sum += piles[i];\\n        int sumBon = sum - sumAlice;\\n        cout<<sumAlice<<\" \"<<sumBon;\\n        return ( sumAlice >= sumBon);\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your function is looking quite right, but there are a few minor issues:\\n\\n1. It looks like you have mixed variable names. In your `PredictTheWinner` function, you\\'re using the variable `piles` which hasn\\'t been defined anywhere. You probably meant to use `nums`, which is the input to your function.\\n\\n2. In your `maxStone` function, you\\'re recursively calling it with `0` for `AliceTurn` in both cases within your `if (AliceTurn)` block. In the `else` condition, you should call `maxStone(i+1, n, 1, arr)` and `maxStone(i, n-1, 1, arr)`, otherwise you\\'re effectively making it always Alice\\'s turn and Bob will never play.\\n\\nHere is the corrected code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n\\n    int dp[501][501];\\n    int maxStone(int i, int n, int AliceTurn, vector<int>&arr){\\n        if(i > n)return 0;\\n        if(dp[i][n] != -1)return dp[i][n];\\n\\n        if(AliceTurn)\\n        {\\n            return dp[i][n] = arr[i] + max(maxStone(i+1, n, 0, arr), maxStone(i, n-1, 0, arr));\\n        }\\n        else\\n        {\\n            return dp[i][n] = max(maxStone(i+1, n, 1, arr), maxStone(i, n-1, 1, arr));\\n        }\\n    }\\n    bool PredictTheWinner(vector<int>& nums) {\\n        int n = nums.size();\\n        memset(dp, -1, sizeof(dp));\\n        int sumAlice = maxStone(0,n-1, 1, nums);\\n        int sum =0;\\n        for(int i=0; i <n; i++) sum += nums[i];\\n        int sumBon = sum - sumAlice;\\n        cout<<sumAlice<<\" \"<<sumBon;\\n        return ( sumAlice >= sumBon);\\n    }\\n};\\n```\\n\\nRemember, it\\'s important to maintain consistency in your variable names to avoid these types of errors. Also, make sure you\\'re setting the right parameters in your recursive calls.\\n"
                    },
                    {
                        "username": "enzo_cheng",
                        "content": "Test Case # 60 answer is wrong?!\\n\\nnums =\\n[3606449,6,5,9,452429,7,9580316,9857582,8514433,9,6,6614512,753594,5474165,4,2697293,8,7,1]\\n\\nA selection: [3606449, 5, 7, 452429, 2697293, 5474165, 6614512, 9, 9857582, 7]\\nB selection: [6, 1, 9, 8, 4, 753594, 6, 8514433, 9580316]\\n\\nA must be winner.\\n\\nAnswer is True, but test case is False.\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The provided test case is a demonstration of the fact that both players are playing optimally. They\\'re not just picking the largest value from either end, they\\'re thinking ahead to ensure the highest possible score for themselves. \\n\\nTo make it clearer, let\\'s run through the first few steps of this game with both players playing optimally:\\n\\n1. Player 1 (P1) can choose from 3606449 and 1. P1 picks 3606449, because it\\'s larger.\\n2. Player 2 (P2) can choose from 6 and 1. P2 picks 6, because it\\'s larger.\\n3. P1 can choose from 5 and 1. P1 picks 5, because it\\'s larger.\\n4. P2 can choose from 9 and 1. P2 picks 9, because it\\'s larger.\\n5. P1 can choose from 452429 and 1. P1 picks 452429, because it\\'s larger.\\n6. P2 can choose from 7 and 1. P2 picks 7, because it\\'s larger.\\n\\nWe can see that both players are taking the higher value available to them, and are not considering future moves. However, optimal play isn\\'t about maximizing the immediate gain. It\\'s about thinking ahead and choosing values that will lead to a higher final score. \\n\\nIn the given case, the returned answer is false because with optimal play, Player 1 does not win. Even though it seems like Player 1 can win with the selected values, keep in mind that the order of the choices and the strategy used to make these choices matter significantly, which is why your test case returns False. \\n\\nLet\\'s illustrate the decision process with a small example, [1, 5, 233, 7], where we already know that Player 1 can win. The process can be represented in the following table:\\n\\n| Turn   | Player | Available Choices | Choice | Player 1 Score | Player 2 Score |\\n|--------|--------|-------------------|--------|----------------|----------------|\\n| 1      | 1      | 1, 7              | 1      | 1              | 0              |\\n| 2      | 2      | 5, 7              | 7      | 1              | 7              |\\n| 3      | 1      | 5, 233            | 233    | 234            | 7              |\\n| 4      | 2      | 5                 | 5      | 234            | 12             |\\n\\nPlayer 1 is making their choices to ensure that Player 2 always has to choose between two numbers where one is significantly smaller than the other. In the second round, Player 1 forces Player 2 to choose between 5 and 7 instead of, say, 7 and 233, thus ensuring that they can grab the large number in the third round.\\n\\nThis is a simplified example, and the real game has more rounds and requires more complex strategic thinking. But it illustrates the basic idea: Playing optimally isn\\'t just about grabbing the largest available number, it\\'s also about controlling the choices available to the other player.\\n\\nIf you want to create a similar table for a larger array, the table will have more rows and the strategic decisions will be more complex, but the basic principle is the same."
                    },
                    {
                        "username": "amanag029",
                        "content": "nums =\\n[2,4,55,6,8] \\nfor the above nums , expected ans if False but it should be True?\\nAnalsis : P1 chooses max of possible options on its own turn while assuming P2 will left min for P1\\nTherefore, P1 chooses 8 > P2 chooses 6 > P1 chooses 55....\\n"
                    },
                    {
                        "username": "amitbansal13",
                        "content": "Can anyone help me understand what is wrong in this approach? Thanks in Advance.\n\n\n```\ndef PredictTheWinner(self, nums: List[int]) -> bool:\n        # d = {}\n        total = sum(nums)\n        @cache\n        def check(left, i, j, turn):\n            if i > j:\n                return left >= total - left\n            if turn:\n                return check(left+nums[i], i+1, j, not turn) or check(left+nums[j], i, j-1, not turn)\n            else:\n                return check(left, i+1, j, not turn) or check(left, i, j-1, not turn)\n            \n        return check(0, 0, len(nums)-1, True)\n```"
                    },
                    {
                        "username": "PrinceTp",
                        "content": "[2,4,55,6,8]\\n\\nPlayer 1 will win ,the answer must be TRUE for this test case,but the expected answer is FALSE ,any idea ?"
                    },
                    {
                        "username": "anil_kumar_2002",
                        "content": "bool PredictTheWinner(vector<int>& nums) {\\n        int s1=0; \\n        int s2=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(i%2==0){\\n                s1+=nums[i]; \\n            }\\n            else{\\n                s2+=nums[i]; \\n            }\\n        }\\n        if(s1>=s2){\\n            return true ; \\n        }\\n        return false;\\n    }\\nfor this code , {1,2} , it should return false, but compiler showing true , \\ncan anyone tell the problem , please? "
                    }
                ]
            },
            {
                "id": 1763514,
                "content": [
                    {
                        "username": "math_pi",
                        "content": "After Translating the Problem into Maximal Sum Difference b/w [A, B]. This problem becomes exactly similar to this one: https://leetcode.com/problems/stone-game-vii/"
                    },
                    {
                        "username": "math_pi",
                        "content": "Can Bitmask DP be used to attack this problem?"
                    },
                    {
                        "username": "metaphysicalist",
                        "content": "Yes, the state of the game can be defined by using bitmask for representing the remaining elements. But this problem is easier that the remaining elements can be simply represented by using the range (l, r) because the players can only take the leftmost or the rightmost elements. "
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, Bitmask Dynamic Programming (DP) can indeed be used to solve this problem. \\n\\nThe basic idea is that we maintain a state for each possible subset of the numbers in the game (represented as a binary mask), and for each state, we keep track of the maximum possible score difference between the two players if they play optimally.\\n\\nTo start, we initialize a DP array of size 2^n (where n is the length of the input array), and set all elements to a large negative value. We then set DP[0] to 0, because when there are no elements left in the game, the score difference is 0.\\n\\nThen, for each subset (represented as a binary mask), we iterate through all its elements (represented as bits in the binary mask). For each element, we consider two scenarios: the current player picks it, or they don\\'t. \\n\\nIf the current player picks it, the score difference changes by the value of the element (if it\\'s player 1\\'s turn) or by the negative of the value of the element (if it\\'s player 2\\'s turn). We then recursively call our DP function on the remaining elements, and update our DP array with the maximum score difference.\\n\\nIn the end, we return whether DP[2^n - 1] is non-negative. This represents the maximum score difference when all elements have been picked, and if it\\'s non-negative, player 1 can win or tie.\\n\\nPlease note that the Bitmask DP approach to this problem has a time complexity of O(n*2^n), which can be quite slow for large n. Therefore, it\\'s more suitable for cases where the length of the input array is small. If the length of the input array is large, a more efficient approach might be needed."
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "the most intuitive way to go about this problem is using recursion. definitely not the most optimal way, (crude recursion is basically brute forcing), but its the best way to start and build more sophisticated algorithms from (the pure dp approach). the constraints allow the recursive approach and i highly encourage to look out for it"
                    },
                    {
                        "username": "mm541145",
                        "content": "it looks similar to 877(stone game)"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "Can anyone tell the error in this,, thanks in advance\\n\\n\\nclass Solution {\\npublic:\\n                  \\n    int dp[501][501];\\n    int maxStone(int i, int n, int AliceTurn, vector<int>&arr){\\n        if(i > n)return 0;\\n        if(dp[i][n] != -1)return dp[i][n];\\n\\n        int first = 0, last = 0;\\n        if(AliceTurn)\\n        {\\n            return dp[i][n] = arr[i] + max(maxStone(i+1, n, 0, arr), maxStone(i, n-1, 0, arr));\\n        }\\n        else\\n        {\\n            // AS ALICE IS NOT TAKING THE ELEMENT SO WE WILL NOT ADD THIS TO OUR SUM\\n            return dp[i][n] = max(maxStone(i+1, n, 0, arr), maxStone(i, n-1, 1, arr));\\n        }\\n    }\\n    bool PredictTheWinner(vector<int>& nums) {\\n        int n = piles.size();\\n        memset(dp, -1, sizeof(dp));\\n        \\n            // TURN ==1 - > MEAN ALICE\\n        int sumAlice = maxStone(0,n-1, 1, piles);\\n        int sum =0;\\n        for(int i=0; i <n; i++)sum += piles[i];\\n        int sumBon = sum - sumAlice;\\n        cout<<sumAlice<<\" \"<<sumBon;\\n        return ( sumAlice >= sumBon);\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your function is looking quite right, but there are a few minor issues:\\n\\n1. It looks like you have mixed variable names. In your `PredictTheWinner` function, you\\'re using the variable `piles` which hasn\\'t been defined anywhere. You probably meant to use `nums`, which is the input to your function.\\n\\n2. In your `maxStone` function, you\\'re recursively calling it with `0` for `AliceTurn` in both cases within your `if (AliceTurn)` block. In the `else` condition, you should call `maxStone(i+1, n, 1, arr)` and `maxStone(i, n-1, 1, arr)`, otherwise you\\'re effectively making it always Alice\\'s turn and Bob will never play.\\n\\nHere is the corrected code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n\\n    int dp[501][501];\\n    int maxStone(int i, int n, int AliceTurn, vector<int>&arr){\\n        if(i > n)return 0;\\n        if(dp[i][n] != -1)return dp[i][n];\\n\\n        if(AliceTurn)\\n        {\\n            return dp[i][n] = arr[i] + max(maxStone(i+1, n, 0, arr), maxStone(i, n-1, 0, arr));\\n        }\\n        else\\n        {\\n            return dp[i][n] = max(maxStone(i+1, n, 1, arr), maxStone(i, n-1, 1, arr));\\n        }\\n    }\\n    bool PredictTheWinner(vector<int>& nums) {\\n        int n = nums.size();\\n        memset(dp, -1, sizeof(dp));\\n        int sumAlice = maxStone(0,n-1, 1, nums);\\n        int sum =0;\\n        for(int i=0; i <n; i++) sum += nums[i];\\n        int sumBon = sum - sumAlice;\\n        cout<<sumAlice<<\" \"<<sumBon;\\n        return ( sumAlice >= sumBon);\\n    }\\n};\\n```\\n\\nRemember, it\\'s important to maintain consistency in your variable names to avoid these types of errors. Also, make sure you\\'re setting the right parameters in your recursive calls.\\n"
                    },
                    {
                        "username": "enzo_cheng",
                        "content": "Test Case # 60 answer is wrong?!\\n\\nnums =\\n[3606449,6,5,9,452429,7,9580316,9857582,8514433,9,6,6614512,753594,5474165,4,2697293,8,7,1]\\n\\nA selection: [3606449, 5, 7, 452429, 2697293, 5474165, 6614512, 9, 9857582, 7]\\nB selection: [6, 1, 9, 8, 4, 753594, 6, 8514433, 9580316]\\n\\nA must be winner.\\n\\nAnswer is True, but test case is False.\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The provided test case is a demonstration of the fact that both players are playing optimally. They\\'re not just picking the largest value from either end, they\\'re thinking ahead to ensure the highest possible score for themselves. \\n\\nTo make it clearer, let\\'s run through the first few steps of this game with both players playing optimally:\\n\\n1. Player 1 (P1) can choose from 3606449 and 1. P1 picks 3606449, because it\\'s larger.\\n2. Player 2 (P2) can choose from 6 and 1. P2 picks 6, because it\\'s larger.\\n3. P1 can choose from 5 and 1. P1 picks 5, because it\\'s larger.\\n4. P2 can choose from 9 and 1. P2 picks 9, because it\\'s larger.\\n5. P1 can choose from 452429 and 1. P1 picks 452429, because it\\'s larger.\\n6. P2 can choose from 7 and 1. P2 picks 7, because it\\'s larger.\\n\\nWe can see that both players are taking the higher value available to them, and are not considering future moves. However, optimal play isn\\'t about maximizing the immediate gain. It\\'s about thinking ahead and choosing values that will lead to a higher final score. \\n\\nIn the given case, the returned answer is false because with optimal play, Player 1 does not win. Even though it seems like Player 1 can win with the selected values, keep in mind that the order of the choices and the strategy used to make these choices matter significantly, which is why your test case returns False. \\n\\nLet\\'s illustrate the decision process with a small example, [1, 5, 233, 7], where we already know that Player 1 can win. The process can be represented in the following table:\\n\\n| Turn   | Player | Available Choices | Choice | Player 1 Score | Player 2 Score |\\n|--------|--------|-------------------|--------|----------------|----------------|\\n| 1      | 1      | 1, 7              | 1      | 1              | 0              |\\n| 2      | 2      | 5, 7              | 7      | 1              | 7              |\\n| 3      | 1      | 5, 233            | 233    | 234            | 7              |\\n| 4      | 2      | 5                 | 5      | 234            | 12             |\\n\\nPlayer 1 is making their choices to ensure that Player 2 always has to choose between two numbers where one is significantly smaller than the other. In the second round, Player 1 forces Player 2 to choose between 5 and 7 instead of, say, 7 and 233, thus ensuring that they can grab the large number in the third round.\\n\\nThis is a simplified example, and the real game has more rounds and requires more complex strategic thinking. But it illustrates the basic idea: Playing optimally isn\\'t just about grabbing the largest available number, it\\'s also about controlling the choices available to the other player.\\n\\nIf you want to create a similar table for a larger array, the table will have more rows and the strategic decisions will be more complex, but the basic principle is the same."
                    },
                    {
                        "username": "amanag029",
                        "content": "nums =\\n[2,4,55,6,8] \\nfor the above nums , expected ans if False but it should be True?\\nAnalsis : P1 chooses max of possible options on its own turn while assuming P2 will left min for P1\\nTherefore, P1 chooses 8 > P2 chooses 6 > P1 chooses 55....\\n"
                    },
                    {
                        "username": "amitbansal13",
                        "content": "Can anyone help me understand what is wrong in this approach? Thanks in Advance.\n\n\n```\ndef PredictTheWinner(self, nums: List[int]) -> bool:\n        # d = {}\n        total = sum(nums)\n        @cache\n        def check(left, i, j, turn):\n            if i > j:\n                return left >= total - left\n            if turn:\n                return check(left+nums[i], i+1, j, not turn) or check(left+nums[j], i, j-1, not turn)\n            else:\n                return check(left, i+1, j, not turn) or check(left, i, j-1, not turn)\n            \n        return check(0, 0, len(nums)-1, True)\n```"
                    },
                    {
                        "username": "PrinceTp",
                        "content": "[2,4,55,6,8]\\n\\nPlayer 1 will win ,the answer must be TRUE for this test case,but the expected answer is FALSE ,any idea ?"
                    },
                    {
                        "username": "anil_kumar_2002",
                        "content": "bool PredictTheWinner(vector<int>& nums) {\\n        int s1=0; \\n        int s2=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(i%2==0){\\n                s1+=nums[i]; \\n            }\\n            else{\\n                s2+=nums[i]; \\n            }\\n        }\\n        if(s1>=s2){\\n            return true ; \\n        }\\n        return false;\\n    }\\nfor this code , {1,2} , it should return false, but compiler showing true , \\ncan anyone tell the problem , please? "
                    }
                ]
            },
            {
                "id": 1760620,
                "content": [
                    {
                        "username": "math_pi",
                        "content": "After Translating the Problem into Maximal Sum Difference b/w [A, B]. This problem becomes exactly similar to this one: https://leetcode.com/problems/stone-game-vii/"
                    },
                    {
                        "username": "math_pi",
                        "content": "Can Bitmask DP be used to attack this problem?"
                    },
                    {
                        "username": "metaphysicalist",
                        "content": "Yes, the state of the game can be defined by using bitmask for representing the remaining elements. But this problem is easier that the remaining elements can be simply represented by using the range (l, r) because the players can only take the leftmost or the rightmost elements. "
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, Bitmask Dynamic Programming (DP) can indeed be used to solve this problem. \\n\\nThe basic idea is that we maintain a state for each possible subset of the numbers in the game (represented as a binary mask), and for each state, we keep track of the maximum possible score difference between the two players if they play optimally.\\n\\nTo start, we initialize a DP array of size 2^n (where n is the length of the input array), and set all elements to a large negative value. We then set DP[0] to 0, because when there are no elements left in the game, the score difference is 0.\\n\\nThen, for each subset (represented as a binary mask), we iterate through all its elements (represented as bits in the binary mask). For each element, we consider two scenarios: the current player picks it, or they don\\'t. \\n\\nIf the current player picks it, the score difference changes by the value of the element (if it\\'s player 1\\'s turn) or by the negative of the value of the element (if it\\'s player 2\\'s turn). We then recursively call our DP function on the remaining elements, and update our DP array with the maximum score difference.\\n\\nIn the end, we return whether DP[2^n - 1] is non-negative. This represents the maximum score difference when all elements have been picked, and if it\\'s non-negative, player 1 can win or tie.\\n\\nPlease note that the Bitmask DP approach to this problem has a time complexity of O(n*2^n), which can be quite slow for large n. Therefore, it\\'s more suitable for cases where the length of the input array is small. If the length of the input array is large, a more efficient approach might be needed."
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "the most intuitive way to go about this problem is using recursion. definitely not the most optimal way, (crude recursion is basically brute forcing), but its the best way to start and build more sophisticated algorithms from (the pure dp approach). the constraints allow the recursive approach and i highly encourage to look out for it"
                    },
                    {
                        "username": "mm541145",
                        "content": "it looks similar to 877(stone game)"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "Can anyone tell the error in this,, thanks in advance\\n\\n\\nclass Solution {\\npublic:\\n                  \\n    int dp[501][501];\\n    int maxStone(int i, int n, int AliceTurn, vector<int>&arr){\\n        if(i > n)return 0;\\n        if(dp[i][n] != -1)return dp[i][n];\\n\\n        int first = 0, last = 0;\\n        if(AliceTurn)\\n        {\\n            return dp[i][n] = arr[i] + max(maxStone(i+1, n, 0, arr), maxStone(i, n-1, 0, arr));\\n        }\\n        else\\n        {\\n            // AS ALICE IS NOT TAKING THE ELEMENT SO WE WILL NOT ADD THIS TO OUR SUM\\n            return dp[i][n] = max(maxStone(i+1, n, 0, arr), maxStone(i, n-1, 1, arr));\\n        }\\n    }\\n    bool PredictTheWinner(vector<int>& nums) {\\n        int n = piles.size();\\n        memset(dp, -1, sizeof(dp));\\n        \\n            // TURN ==1 - > MEAN ALICE\\n        int sumAlice = maxStone(0,n-1, 1, piles);\\n        int sum =0;\\n        for(int i=0; i <n; i++)sum += piles[i];\\n        int sumBon = sum - sumAlice;\\n        cout<<sumAlice<<\" \"<<sumBon;\\n        return ( sumAlice >= sumBon);\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your function is looking quite right, but there are a few minor issues:\\n\\n1. It looks like you have mixed variable names. In your `PredictTheWinner` function, you\\'re using the variable `piles` which hasn\\'t been defined anywhere. You probably meant to use `nums`, which is the input to your function.\\n\\n2. In your `maxStone` function, you\\'re recursively calling it with `0` for `AliceTurn` in both cases within your `if (AliceTurn)` block. In the `else` condition, you should call `maxStone(i+1, n, 1, arr)` and `maxStone(i, n-1, 1, arr)`, otherwise you\\'re effectively making it always Alice\\'s turn and Bob will never play.\\n\\nHere is the corrected code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n\\n    int dp[501][501];\\n    int maxStone(int i, int n, int AliceTurn, vector<int>&arr){\\n        if(i > n)return 0;\\n        if(dp[i][n] != -1)return dp[i][n];\\n\\n        if(AliceTurn)\\n        {\\n            return dp[i][n] = arr[i] + max(maxStone(i+1, n, 0, arr), maxStone(i, n-1, 0, arr));\\n        }\\n        else\\n        {\\n            return dp[i][n] = max(maxStone(i+1, n, 1, arr), maxStone(i, n-1, 1, arr));\\n        }\\n    }\\n    bool PredictTheWinner(vector<int>& nums) {\\n        int n = nums.size();\\n        memset(dp, -1, sizeof(dp));\\n        int sumAlice = maxStone(0,n-1, 1, nums);\\n        int sum =0;\\n        for(int i=0; i <n; i++) sum += nums[i];\\n        int sumBon = sum - sumAlice;\\n        cout<<sumAlice<<\" \"<<sumBon;\\n        return ( sumAlice >= sumBon);\\n    }\\n};\\n```\\n\\nRemember, it\\'s important to maintain consistency in your variable names to avoid these types of errors. Also, make sure you\\'re setting the right parameters in your recursive calls.\\n"
                    },
                    {
                        "username": "enzo_cheng",
                        "content": "Test Case # 60 answer is wrong?!\\n\\nnums =\\n[3606449,6,5,9,452429,7,9580316,9857582,8514433,9,6,6614512,753594,5474165,4,2697293,8,7,1]\\n\\nA selection: [3606449, 5, 7, 452429, 2697293, 5474165, 6614512, 9, 9857582, 7]\\nB selection: [6, 1, 9, 8, 4, 753594, 6, 8514433, 9580316]\\n\\nA must be winner.\\n\\nAnswer is True, but test case is False.\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The provided test case is a demonstration of the fact that both players are playing optimally. They\\'re not just picking the largest value from either end, they\\'re thinking ahead to ensure the highest possible score for themselves. \\n\\nTo make it clearer, let\\'s run through the first few steps of this game with both players playing optimally:\\n\\n1. Player 1 (P1) can choose from 3606449 and 1. P1 picks 3606449, because it\\'s larger.\\n2. Player 2 (P2) can choose from 6 and 1. P2 picks 6, because it\\'s larger.\\n3. P1 can choose from 5 and 1. P1 picks 5, because it\\'s larger.\\n4. P2 can choose from 9 and 1. P2 picks 9, because it\\'s larger.\\n5. P1 can choose from 452429 and 1. P1 picks 452429, because it\\'s larger.\\n6. P2 can choose from 7 and 1. P2 picks 7, because it\\'s larger.\\n\\nWe can see that both players are taking the higher value available to them, and are not considering future moves. However, optimal play isn\\'t about maximizing the immediate gain. It\\'s about thinking ahead and choosing values that will lead to a higher final score. \\n\\nIn the given case, the returned answer is false because with optimal play, Player 1 does not win. Even though it seems like Player 1 can win with the selected values, keep in mind that the order of the choices and the strategy used to make these choices matter significantly, which is why your test case returns False. \\n\\nLet\\'s illustrate the decision process with a small example, [1, 5, 233, 7], where we already know that Player 1 can win. The process can be represented in the following table:\\n\\n| Turn   | Player | Available Choices | Choice | Player 1 Score | Player 2 Score |\\n|--------|--------|-------------------|--------|----------------|----------------|\\n| 1      | 1      | 1, 7              | 1      | 1              | 0              |\\n| 2      | 2      | 5, 7              | 7      | 1              | 7              |\\n| 3      | 1      | 5, 233            | 233    | 234            | 7              |\\n| 4      | 2      | 5                 | 5      | 234            | 12             |\\n\\nPlayer 1 is making their choices to ensure that Player 2 always has to choose between two numbers where one is significantly smaller than the other. In the second round, Player 1 forces Player 2 to choose between 5 and 7 instead of, say, 7 and 233, thus ensuring that they can grab the large number in the third round.\\n\\nThis is a simplified example, and the real game has more rounds and requires more complex strategic thinking. But it illustrates the basic idea: Playing optimally isn\\'t just about grabbing the largest available number, it\\'s also about controlling the choices available to the other player.\\n\\nIf you want to create a similar table for a larger array, the table will have more rows and the strategic decisions will be more complex, but the basic principle is the same."
                    },
                    {
                        "username": "amanag029",
                        "content": "nums =\\n[2,4,55,6,8] \\nfor the above nums , expected ans if False but it should be True?\\nAnalsis : P1 chooses max of possible options on its own turn while assuming P2 will left min for P1\\nTherefore, P1 chooses 8 > P2 chooses 6 > P1 chooses 55....\\n"
                    },
                    {
                        "username": "amitbansal13",
                        "content": "Can anyone help me understand what is wrong in this approach? Thanks in Advance.\n\n\n```\ndef PredictTheWinner(self, nums: List[int]) -> bool:\n        # d = {}\n        total = sum(nums)\n        @cache\n        def check(left, i, j, turn):\n            if i > j:\n                return left >= total - left\n            if turn:\n                return check(left+nums[i], i+1, j, not turn) or check(left+nums[j], i, j-1, not turn)\n            else:\n                return check(left, i+1, j, not turn) or check(left, i, j-1, not turn)\n            \n        return check(0, 0, len(nums)-1, True)\n```"
                    },
                    {
                        "username": "PrinceTp",
                        "content": "[2,4,55,6,8]\\n\\nPlayer 1 will win ,the answer must be TRUE for this test case,but the expected answer is FALSE ,any idea ?"
                    },
                    {
                        "username": "anil_kumar_2002",
                        "content": "bool PredictTheWinner(vector<int>& nums) {\\n        int s1=0; \\n        int s2=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(i%2==0){\\n                s1+=nums[i]; \\n            }\\n            else{\\n                s2+=nums[i]; \\n            }\\n        }\\n        if(s1>=s2){\\n            return true ; \\n        }\\n        return false;\\n    }\\nfor this code , {1,2} , it should return false, but compiler showing true , \\ncan anyone tell the problem , please? "
                    }
                ]
            }
        ]
    },
    {
        "title": "Customer Placing the Largest Number of Orders",
        "question_content": "<p>Table: <code>Orders</code></p>\n\n<pre>\n+-----------------+----------+\n| Column Name     | Type     |\n+-----------------+----------+\n| order_number    | int      |\n| customer_number | int      |\n+-----------------+----------+\norder_number is the primary key (column with unique values) for this table.\nThis table contains information about the order ID and the customer ID.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Write a solution to find the <code>customer_number</code> for the customer who has placed <strong>the largest number of orders</strong>.</p>\n\n<p>The test cases are generated so that <strong>exactly one customer</strong> will have placed more orders than any other customer.</p>\n\n<p>The result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nOrders table:\n+--------------+-----------------+\n| order_number | customer_number |\n+--------------+-----------------+\n| 1            | 1               |\n| 2            | 2               |\n| 3            | 3               |\n| 4            | 3               |\n+--------------+-----------------+\n<strong>Output:</strong> \n+-----------------+\n| customer_number |\n+-----------------+\n| 3               |\n+-----------------+\n<strong>Explanation:</strong> \nThe customer with number 3 has two orders, which is greater than either customer 1 or 2 because each of them only has one order. \nSo the result is customer_number 3.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> What if more than one customer has the largest number of orders, can you find all the <code>customer_number</code> in this case?</p>\n",
        "solutions": [
            {
                "id": 1916054,
                "title": "mysql-database",
                "content": "```\\nselect customer_number from Orders group by customer_number order by count(customer_number) desc limit 1;\\n\\nExplanation:\\n// First we need to select customer_number from Orders\\n// Then we need to group by the same column i.e customer_number \\n// After that count the occurences of values in customer_number and then with the help of desc (descending) keyword I have converted it into descending order\\n// In the end I have used limit 1 so that only the max occurring element is shown in the output table\\n\\n\\nIf this solution was helpful then do not forget to upvote :)",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect customer_number from Orders group by customer_number order by count(customer_number) desc limit 1;\\n\\nExplanation:\\n// First we need to select customer_number from Orders\\n// Then we need to group by the same column i.e customer_number \\n// After that count the occurences of values in customer_number and then with the help of desc (descending) keyword I have converted it into descending order\\n// In the end I have used limit 1 so that only the max occurring element is shown in the output table\\n\\n\\nIf this solution was helpful then do not forget to upvote :)",
                "codeTag": "Unknown"
            },
            {
                "id": 103297,
                "title": "simple-solution-using-group-by",
                "content": "```\\nselect customer_number from orders\\ngroup by customer_number\\norder by count(*) desc limit 1;\\n```",
                "solutionTags": [],
                "code": "```\\nselect customer_number from orders\\ngroup by customer_number\\norder by count(*) desc limit 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3863257,
                "title": "pandas-vs-sql-elegant-short-all-30-days-of-pandas-solutions",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```Python []\\ndef largest_orders(orders: pd.DataFrame) -> pd.DataFrame:\\n    return orders[\\'customer_number\\'].mode().to_frame()\\n```\\n```SQL []\\nSELECT customer_number\\n  FROM Orders\\n GROUP BY customer_number\\n ORDER BY count(*) DESC\\n LIMIT 1; \\n```\\n\\n# Important!\\n###### If you like the solution or find it useful, feel free to **upvote** for it, it will support me in creating high quality solutions)\\n\\n# 30 Days of Pandas solutions\\n\\n### Data Filtering \\u2705\\n- [Big Countries](https://leetcode.com/problems/big-countries/solutions/3848474/pandas-elegant-short-1-line/)\\n- [Recyclable and Low Fat Products](https://leetcode.com/problems/recyclable-and-low-fat-products/solutions/3848500/pandas-elegant-short-1-line/)\\n- [Customers Who Never Order](https://leetcode.com/problems/customers-who-never-order/solutions/3848527/pandas-elegant-short-1-line/)\\n- [Article Views I](https://leetcode.com/problems/article-views-i/solutions/3867192/pandas-elegant-short-1-line/)\\n\\n\\n### String Methods \\u2705\\n- [Invalid Tweets](https://leetcode.com/problems/invalid-tweets/solutions/3849121/pandas-elegant-short-1-line/)\\n- [Calculate Special Bonus](https://leetcode.com/problems/calculate-special-bonus/solutions/3867209/pandas-elegant-short-1-line/)\\n- [Fix Names in a Table](https://leetcode.com/problems/fix-names-in-a-table/solutions/3849167/pandas-elegant-short-1-line/)\\n- [Find Users With Valid E-Mails](https://leetcode.com/problems/find-users-with-valid-e-mails/solutions/3849177/pandas-elegant-short-1-line/)\\n- [Patients With a Condition](https://leetcode.com/problems/patients-with-a-condition/solutions/3849196/pandas-elegant-short-1-line-regex/)\\n\\n\\n### Data Manipulation \\u2705\\n- [Nth Highest Salary](https://leetcode.com/problems/nth-highest-salary/solutions/3867257/pandas-elegant-short-1-line/)\\n- [Second Highest Salary](https://leetcode.com/problems/second-highest-salary/solutions/3867278/pandas-elegant-short/)\\n- [Department Highest Salary](https://leetcode.com/problems/department-highest-salary/solutions/3867312/pandas-elegant-short-1-line/)\\n- [Rank Scores](https://leetcode.com/problems/rank-scores/solutions/3872817/pandas-elegant-short-1-line-all-30-days-of-pandas-solutions/)\\n- [Delete Duplicate Emails](https://leetcode.com/problems/delete-duplicate-emails/solutions/3849211/pandas-elegant-short/)\\n- [Rearrange Products Table](https://leetcode.com/problems/rearrange-products-table/solutions/3849226/pandas-elegant-short-1-line/)\\n\\n\\n### Statistics \\u2705\\n- [The Number of Rich Customers](https://leetcode.com/problems/the-number-of-rich-customers/solutions/3849251/pandas-elegant-short-1-line/)\\n- [Immediate Food Delivery I](https://leetcode.com/problems/immediate-food-delivery-i/solutions/3872719/pandas-elegant-short-1-line-all-30-days-of-pandas-solutions/)\\n- [Count Salary Categories](https://leetcode.com/problems/count-salary-categories/solutions/3872801/pandas-elegant-short-1-line-all-30-days-of-pandas-solutions/)\\n\\n\\n### Data Aggregation \\u2705\\n- [Find Total Time Spent by Each Employee](https://leetcode.com/problems/find-total-time-spent-by-each-employee/solutions/3872715/pandas-elegant-short-1-line-all-30-days-of-pandas-solutions/)\\n- [Game Play Analysis I](https://leetcode.com/problems/game-play-analysis-i/solutions/3863223/pandas-elegant-short-1-line/)\\n- [Number of Unique Subjects Taught by Each Teacher](https://leetcode.com/problems/number-of-unique-subjects-taught-by-each-teacher/solutions/3863239/pandas-elegant-short-1-line/)\\n- [Classes More Than 5 Students](https://leetcode.com/problems/classes-more-than-5-students/solutions/3863249/pandas-elegant-short/)\\n- [Customer Placing the Largest Number of Orders](https://leetcode.com/problems/customer-placing-the-largest-number-of-orders/solutions/3863257/pandas-elegant-short-1-line/)\\n- [Group Sold Products By The Date](https://leetcode.com/problems/group-sold-products-by-the-date/solutions/3863267/pandas-elegant-short-1-line/)\\n- [Daily Leads and Partners](https://leetcode.com/problems/daily-leads-and-partners/solutions/3863279/pandas-elegant-short-1-line/)\\n\\n\\n### Data Aggregation \\u2705\\n- [Actors and Directors Who Cooperated At Least Three Times](https://leetcode.com/problems/actors-and-directors-who-cooperated-at-least-three-times/solutions/3863309/pandas-elegant-short/)\\n- [Replace Employee ID With The Unique Identifier](https://leetcode.com/problems/replace-employee-id-with-the-unique-identifier/solutions/3872822/pandas-elegant-short-1-line-all-30-days-of-pandas-solutions/)\\n- [Students and Examinations](https://leetcode.com/problems/students-and-examinations/solutions/3872699/pandas-elegant-short-1-line-all-30-days-of-pandas-solutions/)\\n- [Managers with at Least 5 Direct Reports](https://leetcode.com/problems/managers-with-at-least-5-direct-reports/solutions/3872861/pandas-elegant-short/)\\n- [Sales Person](https://leetcode.com/problems/sales-person/solutions/3872712/pandas-elegant-short-1-line-all-30-days-of-pandas-solutions/)\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "MySQL",
                    "Pandas"
                ],
                "code": "```Python []\\ndef largest_orders(orders: pd.DataFrame) -> pd.DataFrame:\\n    return orders[\\'customer_number\\'].mode().to_frame()\\n```\n```SQL []\\nSELECT customer_number\\n  FROM Orders\\n GROUP BY customer_number\\n ORDER BY count(*) DESC\\n LIMIT 1; \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2694601,
                "title": "simple-solution-with-pictorial-illustration",
                "content": "\\n```\\nSELECT customer_number \\nFROM Orders\\nGROUP BY customer_number\\nORDER BY COUNT(customer_number) DESC\\nLIMIT 1;\\n// thumbs up if helpful\\n```\\n\\n![fotor_2023-5-30_17_12_44.png](https://assets.leetcode.com/users/images/ff5c6587-9aac-4940-bb39-46bc1b1df942_1685463219.007482.png)\\n\\n\\n\\n![leetcode-upvote-it-works.jpeg](https://assets.leetcode.com/users/images/70ea1d9d-4817-41b0-a8ed-d577f712a206_1685462614.8430135.jpeg)\\n\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT customer_number \\nFROM Orders\\nGROUP BY customer_number\\nORDER BY COUNT(customer_number) DESC\\nLIMIT 1;\\n// thumbs up if helpful\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 151018,
                "title": "follow-up-group-by-having-count-subquery-without-using-max",
                "content": "```\\nSELECT customer_number\\nFROM orders\\nGROUP BY customer_number\\nHAVING COUNT(order_number) = (\\n\\tSELECT COUNT(order_number) cnt\\n\\tFROM orders\\n\\tGROUP BY customer_number\\n\\tORDER BY cnt DESC\\n\\tLIMIT 1\\n)\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT customer_number\\nFROM orders\\nGROUP BY customer_number\\nHAVING COUNT(order_number) = (\\n\\tSELECT COUNT(order_number) cnt\\n\\tFROM orders\\n\\tGROUP BY customer_number\\n\\tORDER BY cnt DESC\\n\\tLIMIT 1\\n)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2335261,
                "title": "better-than-99-96-mssql-easiest",
                "content": "```\\nselect top 1 customer_number\\n from orders\\n group by customer_number\\n order by count(customer_number) desc\\n \\n ```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\nselect top 1 customer_number\\n from orders\\n group by customer_number\\n order by count(customer_number) desc\\n \\n ```",
                "codeTag": "Unknown"
            },
            {
                "id": 3899213,
                "title": "pandas-2-liner-very-straightforward",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Group the DataFrame by customer_number using the groupby function.\\n- Count the number of orders for each customer by using the count function on the grouped DataFrame and resetting the index.\\n- Find the customer with the largest number of orders by filtering the customer_order_counts DataFrame for the row where the order count is equal to the maximum order count.\\n- Return the resulting DataFrame containing the customer with the largest number of orders.\\n# Code\\n```\\nimport pandas as pd\\n\\ndef largest_orders(orders: pd.DataFrame) -> pd.DataFrame:\\n    # Group by customer_number and count the number of orders for each customer\\n    customer_order_counts = orders.groupby(\\'customer_number\\')[\\'order_number\\'].count().reset_index()\\n    \\n    # Find the customer with the largest number of orders\\n    max_orders_customer = customer_order_counts[customer_order_counts[\\'order_number\\'] == customer_order_counts[\\'order_number\\'].max()][[\\'customer_number\\']]\\n    \\n    return max_orders_customer\\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef largest_orders(orders: pd.DataFrame) -> pd.DataFrame:\\n    # Group by customer_number and count the number of orders for each customer\\n    customer_order_counts = orders.groupby(\\'customer_number\\')[\\'order_number\\'].count().reset_index()\\n    \\n    # Find the customer with the largest number of orders\\n    max_orders_customer = customer_order_counts[customer_order_counts[\\'order_number\\'] == customer_order_counts[\\'order_number\\'].max()][[\\'customer_number\\']]\\n    \\n    return max_orders_customer\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 384220,
                "title": "3-simple-mysql-solutions",
                "content": "-- Query the customer_number from the orders table for the customer who has placed the largest number of orders.\\n\\n-- Method 1: doesn\\'t handle multiple customers with same highest orders\\n```\\nselect sub.cust as customer_number\\nfrom (\\n      select customer_number as cust,\\n      count(*) as \\'customer_number\\'\\n      from orders\\n      group by customer_number order by customer_number desc limit 1\\n      ) as sub;\\n```\\t  \\n\\n-- Method 2 : without using limit. uses window functions. handles the follow up question\\n```\\nselect customer_number\\nfrom (select customer_number, DENSE_RANK() over (order by count desc) as \\'ranking\\'\\n      from (select customer_number, count(customer_number) as count from orders group by customer_number)sub1\\n      ) sub2  \\nwhere sub2.ranking = 1;\\n```\\n\\n-- Method 3: handles the follow up question: returns all the customers with highest orders\\n```\\nselect customer_number\\nfrom orders\\ngroup by customer_number\\nhaving count(order_number) = (select count(*) as count\\n                              from orders\\n                              group by customer_number\\n                              order by count desc limit 1);\\n```\\t\\t\\t\\t\\t\\t\\t",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect sub.cust as customer_number\\nfrom (\\n      select customer_number as cust,\\n      count(*) as \\'customer_number\\'\\n      from orders\\n      group by customer_number order by customer_number desc limit 1\\n      ) as sub;\\n```\n```\\nselect customer_number\\nfrom (select customer_number, DENSE_RANK() over (order by count desc) as \\'ranking\\'\\n      from (select customer_number, count(customer_number) as count from orders group by customer_number)sub1\\n      ) sub2  \\nwhere sub2.ranking = 1;\\n```\n```\\nselect customer_number\\nfrom orders\\ngroup by customer_number\\nhaving count(order_number) = (select count(*) as count\\n                              from orders\\n                              group by customer_number\\n                              order by count desc limit 1);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 103296,
                "title": "solution-with-group-by-and-order-by",
                "content": "```\\nSELECT  customer_number\\nFROM    orders\\nGROUP BY customer_number\\nORDER BY COUNT(order_number) DESC \\nLIMIT 1\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT  customer_number\\nFROM    orders\\nGROUP BY customer_number\\nORDER BY COUNT(order_number) DESC \\nLIMIT 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2237363,
                "title": "sql-two-approaches-beginner-friendly-using-limit",
                "content": "Beginner Freindly-\\n```\\nSELECT customer_number \\n\\tFROM (SELECT customer_number,order_number ,COUNT(*) as C FROM Orders GROUP BY customer_number) AS T \\nWHERE C=(SELECT MAX(C) FROM \\n\\t(SELECT customer_number,order_number ,COUNT(*) as C FROM Orders GROUP BY customer_number) AS S);\\n\\n```\\n\\nUsing LIMIT-\\n```\\nSELECT\\n    customer_number\\nFROM\\n    orders\\n\\tGROUP BY customer_number\\n\\tORDER BY COUNT(*) DESC\\nLIMIT 1\\n;\\n```\\nPlease upvote if you found this useful :)",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT customer_number \\n\\tFROM (SELECT customer_number,order_number ,COUNT(*) as C FROM Orders GROUP BY customer_number) AS T \\nWHERE C=(SELECT MAX(C) FROM \\n\\t(SELECT customer_number,order_number ,COUNT(*) as C FROM Orders GROUP BY customer_number) AS S);\\n\\n```\n```\\nSELECT\\n    customer_number\\nFROM\\n    orders\\n\\tGROUP BY customer_number\\n\\tORDER BY COUNT(*) DESC\\nLIMIT 1\\n;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3357074,
                "title": "mysql-subquery-vs-no-subquery-99-vs-95",
                "content": "In this example, we can speed things up by eliminating the subquery. In terms of evaluation and execution time, this can shave off a few seconds depending on the size of the dataset.\\n\\nWhy are subqueries bad? They\\'re good for readability and often for interviewing.  However, in real life subqueries increase the amount of scans taken from the original tables.  \\n\\nFrom a performance tuning perspective, it\\'s often a good idea to reduce the number of subqueries firing every second on the backend.  \\n\\nFor interviews, it\\'s often a good idea to go with the subquery.  \\n\\nThat really is my voice in the video.  I sound like an international robot.\\n\\n[@easyCodingSolutions](https://youtu.be/wCkWZEBXu5A)\\n\\nhttps://youtu.be/wCkWZEBXu5A\\n\\n# No Subquery - Faster than 99%\\n```\\nSELECT\\n    customer_number\\nFROM Orders\\n    GROUP BY customer_number\\n    ORDER BY COUNT(*) DESC\\nLIMIT 1\\n```\\n\\n# With Subquery - Faster than 95%\\n```\\nWITH subquery AS (\\n    SELECT\\n        customer_number\\n        , COUNT(*) counts\\n    FROM Orders\\n        GROUP BY customer_number)\\n\\nSELECT \\n    customer_number \\nFROM subquery\\n    ORDER BY counts DESC\\nLIMIT 1\\n```",
                "solutionTags": [
                    "MySQL",
                    "Database"
                ],
                "code": "```\\nSELECT\\n    customer_number\\nFROM Orders\\n    GROUP BY customer_number\\n    ORDER BY COUNT(*) DESC\\nLIMIT 1\\n```\n```\\nWITH subquery AS (\\n    SELECT\\n        customer_number\\n        , COUNT(*) counts\\n    FROM Orders\\n        GROUP BY customer_number)\\n\\nSELECT \\n    customer_number \\nFROM subquery\\n    ORDER BY counts DESC\\nLIMIT 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2545953,
                "title": "586-customer-placing-the-largest-number-of-orders",
                "content": "```\\nSELECT customer_number FROM Orders\\nGROUP BY customer_number\\nORDER BY COUNT(order_number) DESC\\nLIMIT 1;",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT customer_number FROM Orders\\nGROUP BY customer_number\\nORDER BY COUNT(order_number) DESC\\nLIMIT 1;",
                "codeTag": "Unknown"
            },
            {
                "id": 1958416,
                "title": "mysql-straightforward-solution-using-with-group-by-and-max-handles-duplicates",
                "content": "```\\nWITH Counts AS (\\n    SELECT customer_number, COUNT(*) c FROM Orders\\n    GROUP BY customer_number\\n)\\n\\nSELECT customer_number FROM Counts\\nWHERE c = (SELECT MAX(c) FROM Counts)\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nWITH Counts AS (\\n    SELECT customer_number, COUNT(*) c FROM Orders\\n    GROUP BY customer_number\\n)\\n\\nSELECT customer_number FROM Counts\\nWHERE c = (SELECT MAX(c) FROM Counts)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 103295,
                "title": "subquery-solution-handle-more-than-one-numbers-occurring-the-same-number-of-max-times",
                "content": "I think this can handle more than one numbers occurring the same number of max times:\\n```\\nSELECT customer_number FROM orders\\nGROUP BY customer_number\\nhaving count(distinct order_number) IN\\n(SELECT MAX(countn) FROM (select count(distinct order_number) as countn FROM orders GROUP BY customer_number) sub)\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT customer_number FROM orders\\nGROUP BY customer_number\\nhaving count(distinct order_number) IN\\n(SELECT MAX(countn) FROM (select count(distinct order_number) as countn FROM orders GROUP BY customer_number) sub)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3446416,
                "title": "super-logic-mysql",
                "content": "# Logic is order by count(order_number) limit 1\\n```\\nSELECT customer_number from orders\\ngroup by customer_number\\norder by count(order_number) desc limit 1\\n```\\n# please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT customer_number from orders\\ngroup by customer_number\\norder by count(order_number) desc limit 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3377586,
                "title": "mysql-super-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect customer_number from Orders group by customer_number order by count(customer_number) desc limit 1;\\n```\\n```\\nMake sure to give an UPVOTE\\u2705\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect customer_number from Orders group by customer_number order by count(customer_number) desc limit 1;\\n```\n```\\nMake sure to give an UPVOTE\\u2705\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2705573,
                "title": "mysql-simple-query",
                "content": "```\\nSELECT customer_number \\nFROM Orders \\nGROUP BY customer_number \\nORDER BY COUNT(customer_number) DESC LIMIT 0,1\\n```\\n\\n**please Upvote**",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT customer_number \\nFROM Orders \\nGROUP BY customer_number \\nORDER BY COUNT(customer_number) DESC LIMIT 0,1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2254212,
                "title": "oracle-best-solution",
                "content": "```\\n/* Write your PL/SQL query statement below */\\n\\nSELECT customer_number FROM \\n(\\n    SELECT customer_number, COUNT(customer_number) AS order_count\\n    FROM orders\\n    GROUP BY customer_number\\n    ORDER BY order_count DESC NULLS LAST\\n) WHERE rownum = 1;\\n```\\n",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\n/* Write your PL/SQL query statement below */\\n\\nSELECT customer_number FROM \\n(\\n    SELECT customer_number, COUNT(customer_number) AS order_count\\n    FROM orders\\n    GROUP BY customer_number\\n    ORDER BY order_count DESC NULLS LAST\\n) WHERE rownum = 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 480044,
                "title": "simple-mysql-solution-70-93",
                "content": "```\\nSELECT customer_number\\nFROM orders\\nGROUP BY 1\\nHAVING COUNT(order_number) >= ALL (SELECT COUNT(order_number)\\n                                  FROM orders\\n                                  GROUP BY customer_number)\\n```\\nThis will also work for situations where more than one customers have ordered the most.",
                "solutionTags": [],
                "code": "```\\nSELECT customer_number\\nFROM orders\\nGROUP BY 1\\nHAVING COUNT(order_number) >= ALL (SELECT COUNT(order_number)\\n                                  FROM orders\\n                                  GROUP BY customer_number)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3896447,
                "title": "clean-mysql-and-pandas-using-count",
                "content": "# My SQL\\n\\n``` sql []\\n# Write your MySQL query statement below\\nSELECT customer_number\\nFROM Orders\\nGROUP BY customer_number\\nORDER BY COUNT(*) DESC LIMIT 1\\n```\\n\\n# Pandas\\n\\n``` python3 []\\nimport pandas as pd\\n\\ndef largest_orders(orders: pd.DataFrame) -> pd.DataFrame:\\n  if orders.empty:\\n    return pd.DataFrame({\\'customer_number\\': []})\\n\\n  df = orders.groupby(\\'customer_number\\').count().reset_index()\\n  df.sort_values(by=\\'order_number\\', ascending=False, inplace=True)\\n  return df[[\\'customer_number\\']][0:1]\\n```",
                "solutionTags": [
                    "MySQL",
                    "Pandas"
                ],
                "code": "``` sql []\\n# Write your MySQL query statement below\\nSELECT customer_number\\nFROM Orders\\nGROUP BY customer_number\\nORDER BY COUNT(*) DESC LIMIT 1\\n```\n``` python3 []\\nimport pandas as pd\\n\\ndef largest_orders(orders: pd.DataFrame) -> pd.DataFrame:\\n  if orders.empty:\\n    return pd.DataFrame({\\'customer_number\\': []})\\n\\n  df = orders.groupby(\\'customer_number\\').count().reset_index()\\n  df.sort_values(by=\\'order_number\\', ascending=False, inplace=True)\\n  return df[[\\'customer_number\\']][0:1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3849205,
                "title": "simple-solution-mysql-pandas-beats-100",
                "content": "\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT customer_number \\nFROM Orders \\nGROUP BY customer_number \\nORDER BY count(customer_number) DESC LIMIT 1;\\n```\\n```\\nimport pandas as pd\\n\\ndef largest_orders(orders: pd.DataFrame) -> pd.DataFrame:\\n    return orders[\\'customer_number\\'].mode().to_frame()\\n```",
                "solutionTags": [
                    "MySQL",
                    "Pandas"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT customer_number \\nFROM Orders \\nGROUP BY customer_number \\nORDER BY count(customer_number) DESC LIMIT 1;\\n```\n```\\nimport pandas as pd\\n\\ndef largest_orders(orders: pd.DataFrame) -> pd.DataFrame:\\n    return orders[\\'customer_number\\'].mode().to_frame()\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3798093,
                "title": "pandas-one-liner",
                "content": "find mode for customer_number and convert to data frame for submission.\\n\\n# Code\\n```\\nimport pandas as pd\\n\\ndef largest_orders(orders: pd.DataFrame) -> pd.DataFrame:\\n    return orders[\\'customer_number\\'].mode().to_frame()\\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef largest_orders(orders: pd.DataFrame) -> pd.DataFrame:\\n    return orders[\\'customer_number\\'].mode().to_frame()\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2041382,
                "title": "simple-oracle-solution-96-faster",
                "content": "\\'\\'\\'\\nSELECT customer_number FROM\\n    (\\n    SELECT customer_number, count(order_number) as count\\n     FROM orders\\n     GROUP BY customer_number\\n     ORDER BY count(order_number) DESC\\n    )\\n     WHERE ROWNUM = 1;\\n\\'\\'\\'",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "\\'\\'\\'\\nSELECT customer_number FROM\\n    (\\n    SELECT customer_number, count(order_number) as count\\n     FROM orders\\n     GROUP BY customer_number\\n     ORDER BY count(order_number) DESC\\n    )\\n     WHERE ROWNUM = 1;\\n\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 420224,
                "title": "ms-sql-3-ways",
                "content": "option1 - by sorting the aggregates and using top clause\\n```\\nselect top 1 customer_number\\nfrom orders group by customer_number order by count(order_number) desc\\n```\\n\\noption 2 - aggregate in a cte and using max\\n```\\n; with cte as\\n(select customer_number, count(1) as order_count \\nfrom orders\\ngroup by customer_number)\\nselect distinct customer_number from cte\\nwhere order_count = (select max(order_count) from cte)\\n```\\n\\noption 3 - using window function\\n```\\n;with cte as\\n(select customer_number, rank() over (partition by customer_number order by order_number) rnk from orders)\\nselect distinct customer_number from cte where\\nrnk = (select max(rnk) from cte)\\n```\\n\\nthere could be other better ways too... :)",
                "solutionTags": [],
                "code": "```\\nselect top 1 customer_number\\nfrom orders group by customer_number order by count(order_number) desc\\n```\n```\\n; with cte as\\n(select customer_number, count(1) as order_count \\nfrom orders\\ngroup by customer_number)\\nselect distinct customer_number from cte\\nwhere order_count = (select max(order_count) from cte)\\n```\n```\\n;with cte as\\n(select customer_number, rank() over (partition by customer_number order by order_number) rnk from orders)\\nselect distinct customer_number from cte where\\nrnk = (select max(rnk) from cte)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3857862,
                "title": "simple-mysql-solution",
                "content": "\\n```\\nselect customer_number \\nfrom Orders\\ngroup by customer_number \\norder by count(customer_number) desc\\nlimit 1;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect customer_number \\nfrom Orders\\ngroup by customer_number \\norder by count(customer_number) desc\\nlimit 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3857346,
                "title": "100-easy-fast-clean-solution",
                "content": "IF THIS WILL BE HELPFUL TO YOU, PLEASE UPVOTE !\\n\\n\\n# Code\\n```\\n/* Write your PL/SQL query statement below */\\nSELECT  customer_number FROM (SELECT customer_number, COUNT(*)\\n\\nFROM orders GROUP BY  customer_number  ORDER BY  2 DESC)\\n\\nWHERE  ROWNUM = 1;\\n```\\n![5kej8w.jpg](https://assets.leetcode.com/users/images/b47380d4-518b-46ce-9d9e-ad49e9717cfc_1691054200.5423808.jpeg)",
                "solutionTags": [
                    "Oracle",
                    "Database"
                ],
                "code": "```\\n/* Write your PL/SQL query statement below */\\nSELECT  customer_number FROM (SELECT customer_number, COUNT(*)\\n\\nFROM orders GROUP BY  customer_number  ORDER BY  2 DESC)\\n\\nWHERE  ROWNUM = 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3529237,
                "title": "mysql-solution-for-customer-placing-the-largest-number-of-orders-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe given query selects the customer_number from the \"orders\" table for the customer with the highest count of orders. It calculates the count of orders for each customer, sorts them in descending order, and selects the customer with the highest count.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. The inner subquery selects the customer_number and calculates the count of orders for each customer from the \"orders\" table.\\n2. It groups the records by customer_number using the group by clause.\\n3. The count(*) as cnt expression calculates the count of orders for each customer.\\n4. The outer query selects the customer_number from the subquery result.\\n5. It orders the result by the count (cnt) in descending order.\\n6. The limit 1 clause ensures that only the customer with the highest count is returned.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this query depends on the size of the \"orders\" table and the efficiency of indexing on the customer_number column. The inner subquery involves a group-by operation, which can have a time complexity of O(N log N), where N is the number of rows in the \"orders\" table. The outer query\\'s time complexity depends on the number of distinct customer_numbers and the efficiency of sorting and limiting the result set. Overall, the time complexity is typically linear or sublinear, but it can be influenced by the indexing and sort performance.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of this query is determined by the memory required to process the subquery and store the result set. The subquery may require additional memory to store intermediate results, such as the grouped customer_numbers and their corresponding counts. The size of the result set depends on the number of customers in the table. The space complexity is typically proportional to the size of the result set, but since we are using limit 1, the impact on space complexity is minimal.\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect customer_number from \\n(\\n    select customer_number, count(*) as cnt from orders group by customer_number\\n) as e\\norder by e.cnt desc\\nlimit 1\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect customer_number from \\n(\\n    select customer_number, count(*) as cnt from orders group by customer_number\\n) as e\\norder by e.cnt desc\\nlimit 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3302420,
                "title": "586-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Begin by writing the SQL query using the SELECT statement to retrieve the customer_number column from the orders table.\\n2. Use the GROUP BY clause to group the results by customer_number.\\n3. Use the COUNT(*) function to count the number of orders for each customer.\\n4. Use the ORDER BY clause to sort the results in descending order based on the count of orders.\\n5. Use the LIMIT clause to limit the number of results to 1.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nSELECT customer_number\\nFROM orders\\nGROUP BY customer_number\\nORDER BY COUNT(*) DESC\\nLIMIT 1;\\n\\n```",
                "solutionTags": [
                    "MySQL",
                    "Database"
                ],
                "code": "```\\nSELECT customer_number\\nFROM orders\\nGROUP BY customer_number\\nORDER BY COUNT(*) DESC\\nLIMIT 1;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3249855,
                "title": "mysql-simple-solution-uwu",
                "content": "\\n```\\nSELECT customer_number \\nFROM orders o\\nGROUP BY customer_number \\nHAVING COUNT(*) = (\\n   SELECT COUNT(*) \\n   FROM orders \\n   GROUP BY customer_number \\n   ORDER BY COUNT(*) DESC \\n   LIMIT 1\\n);\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT customer_number \\nFROM orders o\\nGROUP BY customer_number \\nHAVING COUNT(*) = (\\n   SELECT COUNT(*) \\n   FROM orders \\n   GROUP BY customer_number \\n   ORDER BY COUNT(*) DESC \\n   LIMIT 1\\n);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3093889,
                "title": "simple-query-customer-placing-the-largest-number-of-orders",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect customer_number  from Orders group by customer_number order by count(customer_number) desc limit 1;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect customer_number  from Orders group by customer_number order by count(customer_number) desc limit 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2716782,
                "title": "easy-mysql-solution",
                "content": "```\\nSELECT customer_number\\nFROM Orders\\nGROUP BY customer_number\\nORDER BY COUNT(order_number) DESC\\nLIMIT 1\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT customer_number\\nFROM Orders\\nGROUP BY customer_number\\nORDER BY COUNT(order_number) DESC\\nLIMIT 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2593849,
                "title": "one-line-query-in-mysql",
                "content": "```\\nselect customer_number \\nfrom orders \\ngroup by 1 \\norder by (count(*)) desc\\nlimit 1\\n```\\nIf you understood the query , Kindly upvote and help others to understand the logic",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect customer_number \\nfrom orders \\ngroup by 1 \\norder by (count(*)) desc\\nlimit 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2396458,
                "title": "why-this-do-not-work",
                "content": "select customer_number \\nfrom (\\nselect customer_number, count(customer_number) as ct \\nfrom orders \\ngroup by customer_number) as tb  \\nhaving ct = max(ct)",
                "solutionTags": [],
                "code": "select customer_number \\nfrom (\\nselect customer_number, count(customer_number) as ct \\nfrom orders \\ngroup by customer_number) as tb  \\nhaving ct = max(ct)",
                "codeTag": "Unknown"
            },
            {
                "id": 2356452,
                "title": "2-approaches-subquery-and-group-by",
                "content": "Using Subquery\\n```\\nSELECT CUSTOMER_NUMBER\\nFROM \\n    ( SELECT CUSTOMER_NUMBER, COUNT(CUSTOMER_NUMBER) AS C\\n        FROM ORDERS\\n        GROUP BY CUSTOMER_NUMBER\\n        ORDER BY C DESC\\n        LIMIT 1\\n    ) T\\n```\\nSimple Approach\\n```\\nSELECT CUSTOMER_NUMBER\\nFROM ORDERS\\nGROUP BY CUSTOMER_NUMBER\\nORDER BY COUNT(*) DESC LIMIT 1\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT CUSTOMER_NUMBER\\nFROM \\n    ( SELECT CUSTOMER_NUMBER, COUNT(CUSTOMER_NUMBER) AS C\\n        FROM ORDERS\\n        GROUP BY CUSTOMER_NUMBER\\n        ORDER BY C DESC\\n        LIMIT 1\\n    ) T\\n```\n```\\nSELECT CUSTOMER_NUMBER\\nFROM ORDERS\\nGROUP BY CUSTOMER_NUMBER\\nORDER BY COUNT(*) DESC LIMIT 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1890130,
                "title": "mysql-solution",
                "content": "```\\nSELECT customer_number\\nFROM Orders\\nGROUP BY customer_number\\nORDER BY COUNT(customer_number) DESC LIMIT 1;\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT customer_number\\nFROM Orders\\nGROUP BY customer_number\\nORDER BY COUNT(customer_number) DESC LIMIT 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1380697,
                "title": "simple-succinct-and-straightforward-solution",
                "content": "```\\nSELECT customer_number\\nFROM Orders\\nGROUP BY customer_number\\nORDER BY COUNT(order_number) DESC\\nLIMIT 1\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nSELECT customer_number\\nFROM Orders\\nGROUP BY customer_number\\nORDER BY COUNT(order_number) DESC\\nLIMIT 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1017373,
                "title": "mysql-works-for-the-situation-more-than-one-customer-have-maximum-number-of-orders",
                "content": "```\\nSELECT customer_number\\n  FROM orders\\nGROUP BY customer_number\\nHAVING COUNT(order_number) =\\n       (SELECT COUNT(order_number)\\n          FROM orders\\n        GROUP BY customer_number\\n        ORDER BY COUNT(order_number) DESC\\n        LIMIT 1\\n       ) \\n```\\n\\n\\n```\\nSELECT customer_number\\n  FROM orders\\nGROUP BY customer_number\\nHAVING COUNT(order_number) =\\n       (SELECT MAX(ct)\\n          FROM (SELECT COUNT(order_number) AS ct\\n                  FROM orders\\n                GROUP BY customer_number) temp\\n        ) \\n```\\n\\n\\n```\\nSELECT customer_number\\n  FROM orders\\nGROUP BY customer_number\\nHAVING COUNT(*) >= ALL\\n(SELECT COUNT(customer_number)\\n   FROM orders\\n   GROUP BY customer_number)\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT customer_number\\n  FROM orders\\nGROUP BY customer_number\\nHAVING COUNT(order_number) =\\n       (SELECT COUNT(order_number)\\n          FROM orders\\n        GROUP BY customer_number\\n        ORDER BY COUNT(order_number) DESC\\n        LIMIT 1\\n       ) \\n```\n```\\nSELECT customer_number\\n  FROM orders\\nGROUP BY customer_number\\nHAVING COUNT(order_number) =\\n       (SELECT MAX(ct)\\n          FROM (SELECT COUNT(order_number) AS ct\\n                  FROM orders\\n                GROUP BY customer_number) temp\\n        ) \\n```\n```\\nSELECT customer_number\\n  FROM orders\\nGROUP BY customer_number\\nHAVING COUNT(*) >= ALL\\n(SELECT COUNT(customer_number)\\n   FROM orders\\n   GROUP BY customer_number)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 759652,
                "title": "using-window-function",
                "content": "select a.customer_number\\nfrom\\n(select customer_number, rank() over (order by count(order_number) desc) as rnk\\nfrom orders\\ngroup by customer_number)a\\nwhere a.rnk = 1\\n",
                "solutionTags": [],
                "code": "select a.customer_number\\nfrom\\n(select customer_number, rank() over (order by count(order_number) desc) as rnk\\nfrom orders\\ngroup by customer_number)a\\nwhere a.rnk = 1\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3399732,
                "title": "getting-multiple-max-same-orders-by-customers",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst find the max orders from the table.\\nThen get the customer_number from the original table.\\nThis will be helpful to get same max orders by customers.\\n\\n# Code\\n```\\n/* Write your T-SQL query statement below */\\nwith cte as ( --counting the max orders by customer\\n  select max(cnt) mx from (\\n    select customer_number, count(customer_number) cnt from orders group by customer_number\\n    ) temp \\n)\\nselect \\n  customer_number \\nfrom orders \\ngroup by customer_number\\nhaving count(customer_number)=(select mx from cte) \\n\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\nwith cte as ( --counting the max orders by customer\\n  select max(cnt) mx from (\\n    select customer_number, count(customer_number) cnt from orders group by customer_number\\n    ) temp \\n)\\nselect \\n  customer_number \\nfrom orders \\ngroup by customer_number\\nhaving count(customer_number)=(select mx from cte) \\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3326692,
                "title": "mysql-temporary-table",
                "content": "\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\nWITH t1 as (\\n    SELECT customer_number, count(customer_number) AS c \\n    FROM orders \\n    GROUP BY \\n    customer_number\\n)\\n\\nSELECT customer_number FROM t1 WHERE c IN \\n(\\n    SELECT MAX(c) FROM t1\\n)\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nWITH t1 as (\\n    SELECT customer_number, count(customer_number) AS c \\n    FROM orders \\n    GROUP BY \\n    customer_number\\n)\\n\\nSELECT customer_number FROM t1 WHERE c IN \\n(\\n    SELECT MAX(c) FROM t1\\n)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3292635,
                "title": "mysql-solution",
                "content": "# Code\\n```\\n# Write your MySQL query statement below\\nselect customer_number from orders group by customer_number\\norder by count(customer_number) desc limit 0, 1;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect customer_number from orders group by customer_number\\norder by count(customer_number) desc limit 0, 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3267262,
                "title": "easy-to-understand-sql",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nWITH cte AS\\n(SELECT customer_number, COUNT(order_number) AS OrderNum\\nFROM ORDERS\\nGROUP BY customer_number)\\n\\nSELECT customer_number\\nFROM cte \\nWHERE OrderNum = (SELECT MAX(OrderNum) FROM cte);\\n```",
                "solutionTags": [
                    "MySQL",
                    "Database"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nWITH cte AS\\n(SELECT customer_number, COUNT(order_number) AS OrderNum\\nFROM ORDERS\\nGROUP BY customer_number)\\n\\nSELECT customer_number\\nFROM cte \\nWHERE OrderNum = (SELECT MAX(OrderNum) FROM cte);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3262577,
                "title": "easy-mysql-solution-comman-table-expression",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\nWITH cte AS\\n(SELECT customer_number, COUNT(order_number) AS OrderNum\\nFROM ORDERS\\nGROUP BY customer_number)\\n\\nSELECT customer_number\\nFROM cte \\nWHERE OrderNum = (SELECT MAX(OrderNum) FROM cte);\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nWITH cte AS\\n(SELECT customer_number, COUNT(order_number) AS OrderNum\\nFROM ORDERS\\nGROUP BY customer_number)\\n\\nSELECT customer_number\\nFROM cte \\nWHERE OrderNum = (SELECT MAX(OrderNum) FROM cte);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2910385,
                "title": "mysql-group-by-order-by-count-limit",
                "content": "https://leetcode.com/submissions/detail/859588234/\\n```\\n# Write your MySQL query statement below\\nselect customer_number\\nfrom Orders\\ngroup by customer_number\\norder by count(order_number) desc\\nlimit 1\\n```",
                "solutionTags": [],
                "code": "```\\n# Write your MySQL query statement below\\nselect customer_number\\nfrom Orders\\ngroup by customer_number\\norder by count(order_number) desc\\nlimit 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2779657,
                "title": "mysql-customer-placing-the-largest-number-of-orders",
                "content": "```\\n# Write your MySQL query statement below\\nselect  max(customer_number) as customer_number\\nfrom Orders\\ngroup by customer_number\\norder by count(customer_number) desc\\nlimit 1;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect  max(customer_number) as customer_number\\nfrom Orders\\ngroup by customer_number\\norder by count(customer_number) desc\\nlimit 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2540637,
                "title": "sql-solution-using-window-function",
                "content": "```\\nwith t as \\n(select distinct customer_number , count(order_number) over(partition by customer_number) as \\'count\\' from orders c)\\n\\nselect customer_number from(select customer_number, dense_rank() over(order by count desc) as dnk from t)x where x.dnk =1\\n\\n```\\nPlease upvote!!!",
                "solutionTags": [],
                "code": "```\\nwith t as \\n(select distinct customer_number , count(order_number) over(partition by customer_number) as \\'count\\' from orders c)\\n\\nselect customer_number from(select customer_number, dense_rank() over(order by count desc) as dnk from t)x where x.dnk =1\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2431310,
                "title": "mysql-1-liner-solution-beginner-level-simple-short-solution",
                "content": "***Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)\\nAny suggestions and improvements are always welcome**.*\\n______________________\\n\\u2705 **MySQL Code :**\\n**Runtime:** 567 ms, faster than 68.58% of MySQL online submissions for Customer Placing the Largest Number of Orders.\\n```\\nSELECT customer_number FROM orders GROUP BY customer_number ORDER BY COUNT(*) DESC LIMIT 1;\\n```\\n**Runtime:** 567 ms\\n**Memory Usage:**  0B\\n________________________________\\n__________________________________\\n\\nIf you like the solution, please upvote \\uD83D\\uDD3C\\nFor any questions, or discussions, comment below. \\uD83D\\uDC47\\uFE0F",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT customer_number FROM orders GROUP BY customer_number ORDER BY COUNT(*) DESC LIMIT 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2210831,
                "title": "4-different-approaches",
                "content": "```\\n\\nselect customer_number\\nfrom orders\\ngroup by customer_number\\norder by count(*) desc\\nlimit 1;\\n\\n```\\n\\n```\\nselect customer_number\\nfrom orders\\ngroup by customer_number\\nhaving count(order_number) = (\\nselect max(numOfOrder)\\n    from (\\n    select customer_number,count(order_number) as numOfOrder\\n        from orders\\n        group by customer_number\\n    ) as temp\\n);\\n```\\n\\n```\\nselect customer_number\\nfrom orders\\ngroup by customer_number\\nhaving count(order_number) = (\\n    select count(order_number)\\n    from orders\\n    group by customer_number\\n    order by count(order_number) desc limit 1\\n)\\n```\\n\\n```\\nselect customer_number\\nfrom orders \\ngroup by customer_number\\nhaving count(customer_number) >= all(\\n    select count(customer_number) \\n    from orders\\n    group by customer_number\\n);\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n\\nselect customer_number\\nfrom orders\\ngroup by customer_number\\norder by count(*) desc\\nlimit 1;\\n\\n```\n```\\nselect customer_number\\nfrom orders\\ngroup by customer_number\\nhaving count(order_number) = (\\nselect max(numOfOrder)\\n    from (\\n    select customer_number,count(order_number) as numOfOrder\\n        from orders\\n        group by customer_number\\n    ) as temp\\n);\\n```\n```\\nselect customer_number\\nfrom orders\\ngroup by customer_number\\nhaving count(order_number) = (\\n    select count(order_number)\\n    from orders\\n    group by customer_number\\n    order by count(order_number) desc limit 1\\n)\\n```\n```\\nselect customer_number\\nfrom orders \\ngroup by customer_number\\nhaving count(customer_number) >= all(\\n    select count(customer_number) \\n    from orders\\n    group by customer_number\\n);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2165557,
                "title": "gotta-do-it-beginner-level",
                "content": "\\n![image](https://assets.leetcode.com/users/images/8d1a855a-5854-4051-b194-3e5b5f031c84_1655546980.487162.gif)\\n\\n\\n```\\nSELECT customer_number\\nFROM orders\\nGROUP BY customer_number\\nORDER BY COUNT(order_number) DESC\\nLIMIT 1\\n;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT customer_number\\nFROM orders\\nGROUP BY customer_number\\nORDER BY COUNT(order_number) DESC\\nLIMIT 1\\n;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2039069,
                "title": "mysql-3-solutions-group-by-limit-count-subquery-or-rank",
                "content": "Solution 1: A simple group by and limit will do the job. This is only the case when there will be only one customer with the highest number of orders, which is stated in the question. \\n``` \\nSELECT customer_number\\nFROM Orders\\nGROUP BY customer_number\\nORDER BY COUNT(order_number) DESC\\nLIMIT 1; \\n```\\n\\nSolution 2: Window function using count. \\n```\\n-- This first table does not change number of rows in the table (i.e., no collapse by customer_number). \\nWITH order_per_customer AS(\\n\\tSELECT  \\n\\t\\tcustomer_number,\\n\\t\\tCOUNT(order_number) OVER(PARTITION BY customer_number) AS cnt_customer\\n\\tFROM Orders)\\n\\n-- The second table select the customer number whose total order is equal to the max order cnt\\n\\tSELECT DISTINCT customer_number\\n\\tFROM order_per_customer\\n\\tWHERE cnt_customer = (SELECT MAX(cnt_customer) FROM order_per_customer)\\n```\\nSolution 3: Window function using rnk\\n``` \\n-- The rank is generated on the count of order placed for each user, and the user with the highset number of orders placed will rank 1. \\nWITH temp AS(\\n    SELECT customer_number,\\n        RANK() OVER(ORDER BY COUNT(order_number) DESC) AS rnk\\n    FROM Orders\\n    GROUP BY customer_number)\\n\\nSELECT customer_number\\nFROM temp\\nWHERE rnk = 1; \\n",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "``` \\nSELECT customer_number\\nFROM Orders\\nGROUP BY customer_number\\nORDER BY COUNT(order_number) DESC\\nLIMIT 1; \\n```\n```\\n-- This first table does not change number of rows in the table (i.e., no collapse by customer_number). \\nWITH order_per_customer AS(\\n\\tSELECT  \\n\\t\\tcustomer_number,\\n\\t\\tCOUNT(order_number) OVER(PARTITION BY customer_number) AS cnt_customer\\n\\tFROM Orders)\\n\\n-- The second table select the customer number whose total order is equal to the max order cnt\\n\\tSELECT DISTINCT customer_number\\n\\tFROM order_per_customer\\n\\tWHERE cnt_customer = (SELECT MAX(cnt_customer) FROM order_per_customer)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1990004,
                "title": "mysql-o-n-time-beats-99-97-memory-speed-0ms-april-2022",
                "content": "***Hello it would be my pleasure to introduce myself Darian.***\\n\\n***MySQL***\\n```\\nSELECT customer_number\\nFROM Orders\\nGROUP BY customer_number\\nORDER BY COUNT(customer_number) DESC LIMIT 1;\\n```\\n\\n***Consider upvote if useful! Hopefully it can be used in your advantage!***\\n***Take care brother, peace, love!***\\n***\"Open your eyes.\"***",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT customer_number\\nFROM Orders\\nGROUP BY customer_number\\nORDER BY COUNT(customer_number) DESC LIMIT 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1155422,
                "title": "mysql-easy-solution-without-subqueries",
                "content": "```\\nSELECT\\n    customer_number\\nFROM Orders \\nGROUP BY customer_number\\nORDER BY COUNT(customer_number) DESC\\nLIMIT 1\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT\\n    customer_number\\nFROM Orders \\nGROUP BY customer_number\\nORDER BY COUNT(customer_number) DESC\\nLIMIT 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 382024,
                "title": "oracle-rownum-solution",
                "content": "```\\nSELECT customer_number FROM\\n(SELECT customer_number, COUNT(order_number) AS COUNT\\nFROM Orders\\nGROUP BY customer_number\\nORDER BY COUNT(order_number) DESC)\\nWHERE ROWNUM = 1;\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT customer_number FROM\\n(SELECT customer_number, COUNT(order_number) AS COUNT\\nFROM Orders\\nGROUP BY customer_number\\nORDER BY COUNT(order_number) DESC)\\nWHERE ROWNUM = 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3973181,
                "title": "pandas-solution-using-value-counts-and-mode",
                "content": "```\\nimport pandas as pd\\n\\ndef largest_orders(orders: pd.DataFrame) -> pd.DataFrame:\\n    cnt = orders[\"customer_number\"].value_counts().reset_index()\\n    max_order = cnt[\"count\"].max()\\n    return cnt[cnt[\"count\"] == max_order][\"customer_number\"].to_frame()\\n\\n\\ndef largest_orders2(orders: pd.DataFrame) -> pd.DataFrame:\\n    return orders[\"customer_number\"].mode().to_frame()\\n```",
                "solutionTags": [],
                "code": "```\\nimport pandas as pd\\n\\ndef largest_orders(orders: pd.DataFrame) -> pd.DataFrame:\\n    cnt = orders[\"customer_number\"].value_counts().reset_index()\\n    max_order = cnt[\"count\"].max()\\n    return cnt[cnt[\"count\"] == max_order][\"customer_number\"].to_frame()\\n\\n\\ndef largest_orders2(orders: pd.DataFrame) -> pd.DataFrame:\\n    return orders[\"customer_number\"].mode().to_frame()\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3887483,
                "title": "mysql-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect customer_number from Orders group by customer_number order by count(customer_number) desc limit 1;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect customer_number from Orders group by customer_number order by count(customer_number) desc limit 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3562176,
                "title": "select-top-query-beginner-friendly",
                "content": "# Code\\n```\\nSELECT TOP 1 customer_number \\nFROM orders GROUP BY customer_number\\nORDER BY count(customer_number) desc;\\n```",
                "solutionTags": [
                    "MS SQL Server",
                    "Database"
                ],
                "code": "```\\nSELECT TOP 1 customer_number \\nFROM orders GROUP BY customer_number\\nORDER BY count(customer_number) desc;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3306845,
                "title": "sql-server-clean-easy",
                "content": "```\\nSELECT TOP 1 customer_number\\nFROM Orders\\nGROUP BY customer_number\\nORDER BY COUNT(order_number) DESC;\\n\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT TOP 1 customer_number\\nFROM Orders\\nGROUP BY customer_number\\nORDER BY COUNT(order_number) DESC;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3218506,
                "title": "mysql-easy-approach",
                "content": "Here is my cMYSQL code for this problem.\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nwith tb as (select customer_number, count(order_number) as maxi from Orders group by customer_number)\\nselect customer_number from tb where maxi=(select max(maxi) from tb)\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nwith tb as (select customer_number, count(order_number) as maxi from Orders group by customer_number)\\nselect customer_number from tb where maxi=(select max(maxi) from tb)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3101471,
                "title": "mysql-solution",
                "content": "# Code\\n```\\nselect customer_number from orders\\ngroup by customer_number\\norder by count(*) desc limit 1;\\n```",
                "solutionTags": [
                    "MySQL",
                    "Database"
                ],
                "code": "```\\nselect customer_number from orders\\ngroup by customer_number\\norder by count(*) desc limit 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3050839,
                "title": "easiest-mysql-solution",
                "content": "\\n\\n# Code\\n```\\nSelect customer_number \\nFrom Orders \\nGroup by customer_number \\nOrder by count(customer_number) desc limit 1;\\n\\n\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSelect customer_number \\nFrom Orders \\nGroup by customer_number \\nOrder by count(customer_number) desc limit 1;\\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2680148,
                "title": "mysql-with-stepwise-explanation-mysql",
                "content": "First prepare a table where count of orders for each customers are done.\\nExample - \\n```\\n+--------------+-----------------+\\n| order_number | customer_number |\\n+--------------+-----------------+\\n| 1            | 1               |\\n| 2            | 2               |\\n| 3            | 3               |\\n| 4            | 3               |\\n+--------------+-----------------+\\n```\\n\\nTable with customer_number followed by count of orders in descending order.\\n\\n```\\nwith cte as(select customer_number, count(order_number) as count1 from Orders   group by customer_number order by count1 desc)\\n\\n+-----------------+-----------------+\\n| customer_number |  count1         |\\n+-----------------+-----------------+\\n| 3               | 2               |\\n| 2               | 1               |\\n| 1               | 1               |\\n+-----------------+-----------------+\\n```\\n\\nsince we can see customer_number = 3 has maximum orders from above table **cte**.\\nSo we can pick first row from table which is having maximum orders .\\n\\n```\\nselect customer_number from cte limit 1\\n```\\n\\nOutput - \\n\\n```\\n+-----------------+\\n| customer_number |\\n+-----------------+\\n|     3           |\\n+-----------------+\\n```\\n\\n***Final code:-***\\n```\\nwith cte as(select customer_number, count(order_number) as count1 from Orders   group by customer_number order by count1 desc)\\nselect customer_number from cte limit 1\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n+--------------+-----------------+\\n| order_number | customer_number |\\n+--------------+-----------------+\\n| 1            | 1               |\\n| 2            | 2               |\\n| 3            | 3               |\\n| 4            | 3               |\\n+--------------+-----------------+\\n```\n```\\nwith cte as(select customer_number, count(order_number) as count1 from Orders   group by customer_number order by count1 desc)\\n\\n+-----------------+-----------------+\\n| customer_number |  count1         |\\n+-----------------+-----------------+\\n| 3               | 2               |\\n| 2               | 1               |\\n| 1               | 1               |\\n+-----------------+-----------------+\\n```\n```\\nselect customer_number from cte limit 1\\n```\n```\\n+-----------------+\\n| customer_number |\\n+-----------------+\\n|     3           |\\n+-----------------+\\n```\n```\\nwith cte as(select customer_number, count(order_number) as count1 from Orders   group by customer_number order by count1 desc)\\nselect customer_number from cte limit 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2580499,
                "title": "simple-solution-using-top-clause-in-sql-server",
                "content": "**Upvote if you feel it easy :)**\\n```\\nSELECT TOP 1 customer_number \\nFROM Orders\\nGROUP BY customer_number\\nORDER BY count(order_number) DESC;\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\nSELECT TOP 1 customer_number \\nFROM Orders\\nGROUP BY customer_number\\nORDER BY count(order_number) DESC;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2408984,
                "title": "easy-oracle-sol-without-limit-and-follow-up-with-comments",
                "content": "```\\n\\n-- Github.com/ShahJugalR\\n\\nSELECT customer_number                            -- Step 2.   Get the customerNumber who ordered exactly maxorderCount times.\\nFROM orders\\nGROUP BY customer_number\\nHAVING count(*) = (\\n    SELECT max(count(*))                               -- Step 1.  Get maxorderCount for any customer.\\n    FROM orders\\n    GROUP BY customer_number\\n)\\n\\n```\\n\\n![image](https://assets.leetcode.com/users/images/148e5c06-7fb7-417b-adb3-8af35b1539a1_1660178874.500545.png)\\n\\n\\n**Consider Upvoting if you think this solution works well and easy to understand.\\nAnd Don\\'t hesitate to Downvote if it was trash.**\\n\\n**I tried my best to explain as but if you think somewhere there\\'s need for any change please let me know.(And Sorry for my bad English.)**",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\n\\n-- Github.com/ShahJugalR\\n\\nSELECT customer_number                            -- Step 2.   Get the customerNumber who ordered exactly maxorderCount times.\\nFROM orders\\nGROUP BY customer_number\\nHAVING count(*) = (\\n    SELECT max(count(*))                               -- Step 1.  Get maxorderCount for any customer.\\n    FROM orders\\n    GROUP BY customer_number\\n)\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2356255,
                "title": "mysql-easy-sol",
                "content": "```\\nselect customer_number from Orders\\ngroup by customer_number\\nORDER BY COUNT(customer_number) DESC\\nlimit 1 ;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect customer_number from Orders\\ngroup by customer_number\\nORDER BY COUNT(customer_number) DESC\\nlimit 1 ;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1944599,
                "title": "ms-sql",
                "content": "```\\nwith cte\\nas\\n(select customer_number, count(*) cnt\\nfrom orders\\n group by customer_number\\n)\\nselect top 1 customer_number from cte\\norder by cnt desc\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\nwith cte\\nas\\n(select customer_number, count(*) cnt\\nfrom orders\\n group by customer_number\\n)\\nselect top 1 customer_number from cte\\norder by cnt desc\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1539229,
                "title": "why-this-is-not-working-help-needed",
                "content": "SELECT MAX(Price) AS LargestPrice\\nFROM Products;\\n",
                "solutionTags": [],
                "code": "SELECT MAX(Price) AS LargestPrice\\nFROM Products;\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1515211,
                "title": "ms-sql",
                "content": "#### Question\\n```\\n586. Customer Placing the Largest Number of Orders\\nEasy\\n\\nSQL Schema\\nTable: Orders\\n\\n+-----------------+----------+\\n| Column Name     | Type     |\\n+-----------------+----------+\\n| order_number    | int      |\\n| customer_number | int      |\\n+-----------------+----------+\\norder_number is the primary key for this table.\\nThis table contains information about the order ID and the customer ID.\\n \\n\\nWrite an SQL query to find the customer_number for the customer who has placed the largest number of orders.\\n\\nIt is guaranteed that exactly one customer will have placed more orders than any other customer.\\n\\nThe query result format is in the following example:\\n\\n \\n\\nOrders table:\\n+--------------+-----------------+\\n| order_number | customer_number |\\n+--------------+-----------------+\\n| 1            | 1               |\\n| 2            | 2               |\\n| 3            | 3               |\\n| 4            | 3               |\\n+--------------+-----------------+\\n\\nResult table:\\n+-----------------+\\n| customer_number |\\n+-----------------+\\n| 3               |\\n+-----------------+\\nThe customer with number 3 has two orders, which is greater than either customer 1 or 2 because each of them only has one order. \\nSo the result is customer_number 3.\\n \\n\\nFollow up: What if more than one customer have the largest number of orders, can you find all the customer_number in this case?\\n```\\n\\n#### Answer 1\\n```SQL\\n/* Write your T-SQL query statement below */\\nwith ranking as (select customer_number, dense_rank() over (order by count(*) desc) rn \\n                 from Orders \\n                 group by customer_number\\n                )\\n\\nselect customer_number from ranking where rn = 1\\n```\\n#### Answer 2\\n```SQL\\nselect top(1)customer_number from orders \\ngroup by customer_number\\norder by count(order_number) desc\\n\\n```\\n",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n586. Customer Placing the Largest Number of Orders\\nEasy\\n\\nSQL Schema\\nTable: Orders\\n\\n+-----------------+----------+\\n| Column Name     | Type     |\\n+-----------------+----------+\\n| order_number    | int      |\\n| customer_number | int      |\\n+-----------------+----------+\\norder_number is the primary key for this table.\\nThis table contains information about the order ID and the customer ID.\\n \\n\\nWrite an SQL query to find the customer_number for the customer who has placed the largest number of orders.\\n\\nIt is guaranteed that exactly one customer will have placed more orders than any other customer.\\n\\nThe query result format is in the following example:\\n\\n \\n\\nOrders table:\\n+--------------+-----------------+\\n| order_number | customer_number |\\n+--------------+-----------------+\\n| 1            | 1               |\\n| 2            | 2               |\\n| 3            | 3               |\\n| 4            | 3               |\\n+--------------+-----------------+\\n\\nResult table:\\n+-----------------+\\n| customer_number |\\n+-----------------+\\n| 3               |\\n+-----------------+\\nThe customer with number 3 has two orders, which is greater than either customer 1 or 2 because each of them only has one order. \\nSo the result is customer_number 3.\\n \\n\\nFollow up: What if more than one customer have the largest number of orders, can you find all the customer_number in this case?\\n```\n```SQL\\n/* Write your T-SQL query statement below */\\nwith ranking as (select customer_number, dense_rank() over (order by count(*) desc) rn \\n                 from Orders \\n                 group by customer_number\\n                )\\n\\nselect customer_number from ranking where rn = 1\\n```\n```SQL\\nselect top(1)customer_number from orders \\ngroup by customer_number\\norder by count(order_number) desc\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 762663,
                "title": "mssql",
                "content": "```SQL\\nselect customer_number from (select customer_number, row_number() over (order by count(distinct order_number) desc) rn from orders \\ngroup by customer_number\\n) a\\nwhere rn = 1",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```SQL\\nselect customer_number from (select customer_number, row_number() over (order by count(distinct order_number) desc) rn from orders \\ngroup by customer_number\\n) a\\nwhere rn = 1",
                "codeTag": "Unknown"
            },
            {
                "id": 176373,
                "title": "follow-up-solution-beats-all-test-cases",
                "content": "First Approach: using Having clause:\\n```\\nSELECT customer_number\\nFROM orders\\ngroup by customer_number\\nHaving count(*)=(SELECT count(*)\\nFROM orders\\ngroup by customer_number\\n                order by count(*) desc limit 1)\\n```\\nSecond Approach using Max\\n```\\nSELECT customer_number\\nFROM \\n(SELECT *, COUNT(*) as num FROM orders GROUP BY customer_number)t\\nWHERE num in \\n(\\nSELECT MAX(num) FROM \\n(SELECT *, COUNT(*) as num FROM orders GROUP BY customer_number)t\\n)\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT customer_number\\nFROM orders\\ngroup by customer_number\\nHaving count(*)=(SELECT count(*)\\nFROM orders\\ngroup by customer_number\\n                order by count(*) desc limit 1)\\n```\n```\\nSELECT customer_number\\nFROM \\n(SELECT *, COUNT(*) as num FROM orders GROUP BY customer_number)t\\nWHERE num in \\n(\\nSELECT MAX(num) FROM \\n(SELECT *, COUNT(*) as num FROM orders GROUP BY customer_number)t\\n)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4068822,
                "title": "pandas-sql-easy-explained-step-by-step-customer-placing-the-largest-number-of-orders",
                "content": "[see the successfully Accepted Submission](https://leetcode.com/submissions/detail/1054295230/)\\n```\\nimport pandas as pd\\n\\ndef largest_orders(orders: pd.DataFrame) -> pd.DataFrame:\\n    \\n    # First, group rows in a DataFrame based on the unique values in the \\'customer_number\\' column. \\n    grouped = orders.groupby(\\'customer_number\\')\\n    \\n    # After performing a groupby operation, we get the count of elements in each group.\\n    get_size=grouped.size()\\n    \\n    # Performing groupby operations changes the structure, so must resets the index of the sales_counts Series and name the new column \\'count\\' to indicate that it represents the count of sales for each salesperson.\\n    resetIndex_byCount=get_size.reset_index(name=\\'count\\')\\n    \\n    # Then, we sort the rows of a DataFrame or Series based on the values in the \\'count\\' column. \\n    sorted_df = resetIndex_byCount.sort_values(\\'count\\', ascending=False)\\n    \\n    # Now, we need to get the value in the \\'customer_number\\' column for the top row (which is a Largest Number) of the sorted DataFrame. \\n    customer_more_orders = sorted_df.head(1)[\\'customer_number\\']\\n    \\n    # Finally, we create a new DataFrame from an existing object called customer_more_orders.\\n    customer_more_orders = pd.DataFrame(customer_more_orders)\\n\\n    return customer_more_orders\\n```\\n\\n**SQL**\\n[see the successfully Accepted Submission](https://leetcode.com/submissions/detail/1061709613/)\\n\\n```\\nSELECT customer_number\\nFROM Orders \\nGROUP BY customer_number \\nORDER BY COUNT(DISTINCT order_number) DESC \\nLIMIT 1\\n```\\n\\n\\n```\\n-- Select the \\'customer_number\\' column\\nSELECT customer_number\\n-- Retrieve data from the \\'Orders\\' table\\nFROM Orders\\n\\n-- Group the results by \\'customer_number\\' to aggregate orders for each customer\\nGROUP BY customer_number\\n\\n-- Order the groups by the count of distinct \\'order_number\\' in descending order\\nORDER BY COUNT(DISTINCT order_number) DESC\\n\\n-- Limit the result to the top row (customer with the most distinct orders)\\nLIMIT 1;\\n```\\n\\n![image](https://assets.leetcode.com/users/images/c88cddbb-2eeb-4948-9d80-145246a06455_1695194562.9794636.jpeg)\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef largest_orders(orders: pd.DataFrame) -> pd.DataFrame:\\n    \\n    # First, group rows in a DataFrame based on the unique values in the \\'customer_number\\' column. \\n    grouped = orders.groupby(\\'customer_number\\')\\n    \\n    # After performing a groupby operation, we get the count of elements in each group.\\n    get_size=grouped.size()\\n    \\n    # Performing groupby operations changes the structure, so must resets the index of the sales_counts Series and name the new column \\'count\\' to indicate that it represents the count of sales for each salesperson.\\n    resetIndex_byCount=get_size.reset_index(name=\\'count\\')\\n    \\n    # Then, we sort the rows of a DataFrame or Series based on the values in the \\'count\\' column. \\n    sorted_df = resetIndex_byCount.sort_values(\\'count\\', ascending=False)\\n    \\n    # Now, we need to get the value in the \\'customer_number\\' column for the top row (which is a Largest Number) of the sorted DataFrame. \\n    customer_more_orders = sorted_df.head(1)[\\'customer_number\\']\\n    \\n    # Finally, we create a new DataFrame from an existing object called customer_more_orders.\\n    customer_more_orders = pd.DataFrame(customer_more_orders)\\n\\n    return customer_more_orders\\n```\n```\\nSELECT customer_number\\nFROM Orders \\nGROUP BY customer_number \\nORDER BY COUNT(DISTINCT order_number) DESC \\nLIMIT 1\\n```\n```\\n-- Select the \\'customer_number\\' column\\nSELECT customer_number\\n-- Retrieve data from the \\'Orders\\' table\\nFROM Orders\\n\\n-- Group the results by \\'customer_number\\' to aggregate orders for each customer\\nGROUP BY customer_number\\n\\n-- Order the groups by the count of distinct \\'order_number\\' in descending order\\nORDER BY COUNT(DISTINCT order_number) DESC\\n\\n-- Limit the result to the top row (customer with the most distinct orders)\\nLIMIT 1;\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3980812,
                "title": "python3-pandas-identifying-the-customer-with-the-largest-number-of-orders-beats-99-13",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem involves identifying the customer with the largest number of orders in a given DataFrame. The intuition is to group the DataFrame by \\'customer_number\\', count the number of orders for each customer, and find the customer with the largest count.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Group the orders DataFrame by the \\'customer_number\\' column.\\n- Use the .value_counts() function to count the number of orders for each customer. This creates a Series with customer numbers as indices and order counts as values.\\n- Reset the index to convert the Series into a DataFrame with columns \\'customer_number\\' and \\'order_count\\'.\\n- Check if the DataFrame is empty (in case there are no orders). If it\\'s not empty, find the customer with the largest number of orders using .iloc[0].\\n- Create a DataFrame with a single column \\'customer_number\\' containing the largest customer number.\\n- Return the resulting DataFrame.\\n# Complexity\\n1. **Time complexity:**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- Grouping the DataFrame by \\'customer_number\\' and counting orders using value_counts() takes O(n) time, where n is the number of rows in the DataFrame.\\n- The sorting step, .sort_values(), has a time complexity of O(m * log(m)), where m is the number of unique customer numbers. However, this step is avoided in the optimized solution, so the overall time complexity is O(n).\\n- The code then checks if the DataFrame is empty and creates a DataFrame with a single row, which has negligible time complexity.\\n- Overall, the time complexity is **O(n)**.\\n2. Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n- The space complexity is mainly determined by the size of the resulting DataFrame, which holds the largest customer number.\\n- Other memory usage within the code is minimal and can be considered constant.\\n- Therefore, the space complexity is **O(1)**, as the size of the DataFrame does not depend on the input size.\\n# Code\\n```\\nimport pandas as pd\\n\\ndef largest_orders(orders: pd.DataFrame) -> pd.DataFrame:\\n    # Group the orders DataFrame by \\'customer_number\\' and count the orders, then sort\\n    result = orders[\\'customer_number\\'].value_counts().reset_index()\\n    result.columns = [\\'customer_number\\', \\'order_count\\']\\n    \\n    if not result.empty:\\n        # Find the customer with the largest number of orders\\n        largest_customer = result.iloc[0]\\n        \\n        # Create a DataFrame with a single column \\'customer_number\\' containing the largest customer number\\n        result_table = pd.DataFrame({\\'customer_number\\': [largest_customer[\\'customer_number\\']]})\\n    else:\\n        # If the result DataFrame is empty, create an empty DataFrame\\n        result_table = pd.DataFrame(columns=[\\'customer_number\\'])\\n    \\n    return result_table\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef largest_orders(orders: pd.DataFrame) -> pd.DataFrame:\\n    # Group the orders DataFrame by \\'customer_number\\' and count the orders, then sort\\n    result = orders[\\'customer_number\\'].value_counts().reset_index()\\n    result.columns = [\\'customer_number\\', \\'order_count\\']\\n    \\n    if not result.empty:\\n        # Find the customer with the largest number of orders\\n        largest_customer = result.iloc[0]\\n        \\n        # Create a DataFrame with a single column \\'customer_number\\' containing the largest customer number\\n        result_table = pd.DataFrame({\\'customer_number\\': [largest_customer[\\'customer_number\\']]})\\n    else:\\n        # If the result DataFrame is empty, create an empty DataFrame\\n        result_table = pd.DataFrame(columns=[\\'customer_number\\'])\\n    \\n    return result_table\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3967085,
                "title": "pandas-simple-solution-self-exlainatory",
                "content": "**\\uD83D\\uDD3C IF YOU FIND THIS POST HELPFUL PLEASE UPVOTE \\uD83D\\uDC4D**\\n```\\nimport pandas as pd\\n\\ndef largest_orders(orders: pd.DataFrame) -> pd.DataFrame:\\n    \\n    result = orders.groupby([\\'customer_number\\']).count().reset_index()\\n    \\n    result.sort_values(by=\\'order_number\\', ascending=False, inplace=True)\\n    \\n    return result[[\\'customer_number\\']][0:1]\\n```\\n**Thank you for reading! \\uD83D\\uDE04 Comment if you have any questions or feedback.**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef largest_orders(orders: pd.DataFrame) -> pd.DataFrame:\\n    \\n    result = orders.groupby([\\'customer_number\\']).count().reset_index()\\n    \\n    result.sort_values(by=\\'order_number\\', ascending=False, inplace=True)\\n    \\n    return result[[\\'customer_number\\']][0:1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3942604,
                "title": "pandas-simple-groupby",
                "content": "\\n# Code\\n```\\nimport pandas as pd\\n\\ndef largest_orders(orders: pd.DataFrame) -> pd.DataFrame:\\n    ords = orders.groupby(by=[\\'customer_number\\'],as_index=False).count()\\n    # print()\\n    return ords[ords[\\'order_number\\'] == ords[\\'order_number\\'].max()][[\\'customer_number\\']]\\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef largest_orders(orders: pd.DataFrame) -> pd.DataFrame:\\n    ords = orders.groupby(by=[\\'customer_number\\'],as_index=False).count()\\n    # print()\\n    return ords[ords[\\'order_number\\'] == ords[\\'order_number\\'].max()][[\\'customer_number\\']]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2792826,
                "title": "mssql-faster-than-78-99",
                "content": "# Details\\nCustomer Placing the Largest Number of Orders\\n\\n\\n# Code\\n```\\n/* Write your T-SQL query statement below */\\n\\nselect top 1 customer_number from(\\nselect customer_number, count(customer_number) total from Orders group by customer_number\\n) a  order by total desc\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\n\\nselect top 1 customer_number from(\\nselect customer_number, count(customer_number) total from Orders group by customer_number\\n) a  order by total desc\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2727992,
                "title": "ms-sql-having-where-non-correlated-subquery-simple-order-by-window-function",
                "content": "```\\n/*\\nQuery Process Steps\\n1. Getting Data (From, Join)\\n2. Row Filter (Where)\\n3. Grouping (Group by)\\n4. Group Filter (Having)\\n5. Return Expressions (Select)\\n6. Distinct\\n7. Order & Paging (Order by & Limit / Offset)\\n*/\\n/*\\n--note that \"order by\" is processed in a phase after select so column alias in select list can be used here, but it also has access to the columns of underlying table by name and to columns in select list by name or number!\\nselect customer_number  -- top 1 customer_number works too\\nfrom ( select customer_number, count(*) a  from Orders group by customer_number ) t\\norder by a desc,1 \\noffset 0 rows fetch first 1 rows only \\n\\n--use having and non-correlated subquery\\nselect customer_number \\nfrom Orders\\ngroup by customer_number\\nhaving count(*)=(select max(cnt) from (select count(order_number) cnt from Orders group by customer_number) t)\\n\\n*/\\n/*\\n-- using non-correlated subquery in WHERE CLAUSE and CTE\\nwith t as (select customer_number, count(*) cnt from Orders group by customer_number)\\nselect customer_number \\nfrom  t\\nwhere cnt=(select max(cnt) from t ) -- if t is not declared in CTE, where clause can\\'t access it even its processing order is after the table expression, also \"where cnt=(select max(cnt))\" is a syntax error because an aggregate may not appear in the Where clause unless it\\'s in a subquery in a Having clause or a select list and the column being aggregated is an outer reference!\\n\\n--using window function, note that max(count(*)) over() works\\nwith t as (\\nselect customer_number, count(*) ct, max(count(*)) over () mx from Orders group by customer_number\\n)\\nselect customer_number from t where ct=mx\\n\\n--my preference goes to order by count(*) due to its succinctness\\nselect top 1 customer_number from orders\\ngroup by customer_number\\norder by count(*) desc \\n\\n*/\\nwith t as ( select customer_number, count(distinct order_number) cnt from Orders group by customer_number)\\nselect customer_number\\nfrom t  where cnt=(select max(cnt) from t) -- from t where cnt=max(cnt) not allowed aggregate func in Where clause\\n--using group by having min(cnt)=(select max(cnt) from t) also works\\n--group by customer_number\\n--having min(cnt)=(select max(cnt) from t) -- having min(cnt)==max(cnt) has different semantics\\n\\n/*\\n--testing syntax: aggregate function are allowed in having clause and select list, although it does not make business sense for this problem\\n--note that all table expressions are accessible in later phases like select max(t2...)\\nselect t.customer_number ,max(t2.order_number) -- max(count(*)) : can not perform aggregate function on an expression containing an aggregate or a subquery\\nfrom Orders t\\njoin Orders t2 on t.customer_number=t2.customer_number\\n--where t.customer_number=max(order_number) -- An aggregate may not appear in the WHERE clause unless it is in a subquery contained in a HAVING clause or a select list, and the column being aggregated is an outer reference. (147) (SQLExecDirectW)\\n--where t.customer_number=(select max(customer_number) from t) --Syntax error: invalid object \\'t\\':  t can not be used as table expr in Where clause but t.column_name is accessible\\ngroup by t.customer_number\\nhaving min(t.customer_number)=max(t2.customer_number)\\norder by count(distinct t.order_number)\\n*/\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\nQuery Process Steps\\n1. Getting Data (From, Join)\\n2. Row Filter (Where)\\n3. Grouping (Group by)\\n4. Group Filter (Having)\\n5. Return Expressions (Select)\\n6. Distinct\\n7. Order & Paging (Order by & Limit / Offset)\\n*/\\n/*\\n--note that \"order by\" is processed in a phase after select so column alias in select list can be used here, but it also has access to the columns of underlying table by name and to columns in select list by name or number!\\nselect customer_number  -- top 1 customer_number works too\\nfrom ( select customer_number, count(*) a  from Orders group by customer_number ) t\\norder by a desc,1 \\noffset 0 rows fetch first 1 rows only \\n\\n--use having and non-correlated subquery\\nselect customer_number \\nfrom Orders\\ngroup by customer_number\\nhaving count(*)=(select max(cnt) from (select count(order_number) cnt from Orders group by customer_number) t)\\n\\n*/\\n/*\\n-- using non-correlated subquery in WHERE CLAUSE and CTE\\nwith t as (select customer_number, count(*) cnt from Orders group by customer_number)\\nselect customer_number \\nfrom  t\\nwhere cnt=(select max(cnt) from t ) -- if t is not declared in CTE, where clause can\\'t access it even its processing order is after the table expression, also \"where cnt=(select max(cnt))\" is a syntax error because an aggregate may not appear in the Where clause unless it\\'s in a subquery in a Having clause or a select list and the column being aggregated is an outer reference!\\n\\n--using window function, note that max(count(*)) over() works\\nwith t as (\\nselect customer_number, count(*) ct, max(count(*)) over () mx from Orders group by customer_number\\n)\\nselect customer_number from t where ct=mx\\n\\n--my preference goes to order by count(*) due to its succinctness\\nselect top 1 customer_number from orders\\ngroup by customer_number\\norder by count(*) desc \\n\\n*/\\nwith t as ( select customer_number, count(distinct order_number) cnt from Orders group by customer_number)\\nselect customer_number\\nfrom t  where cnt=(select max(cnt) from t) -- from t where cnt=max(cnt) not allowed aggregate func in Where clause\\n--using group by having min(cnt)=(select max(cnt) from t) also works\\n--group by customer_number\\n--having min(cnt)=(select max(cnt) from t) -- having min(cnt)==max(cnt) has different semantics\\n\\n/*\\n--testing syntax: aggregate function are allowed in having clause and select list, although it does not make business sense for this problem\\n--note that all table expressions are accessible in later phases like select max(t2...)\\nselect t.customer_number ,max(t2.order_number) -- max(count(*)) : can not perform aggregate function on an expression containing an aggregate or a subquery\\nfrom Orders t\\njoin Orders t2 on t.customer_number=t2.customer_number\\n--where t.customer_number=max(order_number) -- An aggregate may not appear in the WHERE clause unless it is in a subquery contained in a HAVING clause or a select list, and the column being aggregated is an outer reference. (147) (SQLExecDirectW)\\n--where t.customer_number=(select max(customer_number) from t) --Syntax error: invalid object \\'t\\':  t can not be used as table expr in Where clause but t.column_name is accessible\\ngroup by t.customer_number\\nhaving min(t.customer_number)=max(t2.customer_number)\\norder by count(distinct t.order_number)\\n*/\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2713257,
                "title": "easy-to-understand-for-beginners-mysql-solution",
                "content": "```\\nSELECT customer_number FROM Orders \\nGROUP BY customer_number\\nORDER BY COUNT(customer_number) DESC LIMIT 1\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT customer_number FROM Orders \\nGROUP BY customer_number\\nORDER BY COUNT(customer_number) DESC LIMIT 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2568349,
                "title": "easy-mysql-solution-simple-to-understand",
                "content": "\\tselect customer_number\\n\\tfrom Orders\\n\\tgroup by customer_number \\n\\torder by count(*) desc limit 1;\\nI hope that you\\'ve found the solution useful.\\nIn that case, please do upvote. Happy Coding :)",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "\\tselect customer_number\\n\\tfrom Orders\\n\\tgroup by customer_number \\n\\torder by count(*) desc limit 1;\\nI hope that you\\'ve found the solution useful.\\nIn that case, please do upvote. Happy Coding :)",
                "codeTag": "Unknown"
            },
            {
                "id": 2559662,
                "title": "ms-sql-server-order-by-count",
                "content": "```\\nselect top 1 customer_number from orders\\ngroup by customer_number\\norder by count(customer_number) desc\\n```",
                "solutionTags": [],
                "code": "```\\nselect top 1 customer_number from orders\\ngroup by customer_number\\norder by count(customer_number) desc\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2522738,
                "title": "easiest",
                "content": "```\\nSelect customer_number from Orders\\ngroup by customer_number\\norder by count(customer_number) desc\\nlimit 1;\\n\\n```",
                "solutionTags": [],
                "code": "```\\nSelect customer_number from Orders\\ngroup by customer_number\\norder by count(customer_number) desc\\nlimit 1;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2507840,
                "title": "my-first-share",
                "content": "select customer_number from orders \\ngroup by customer_number \\norder by count(customer_number) desc\\nlimit 1",
                "solutionTags": [],
                "code": "select customer_number from orders \\ngroup by customer_number \\norder by count(customer_number) desc\\nlimit 1",
                "codeTag": "Unknown"
            },
            {
                "id": 2499523,
                "title": "easy-solution-using-nested-query",
                "content": "```\\nSELECT customer_number \\nFROM Orders \\nGROUP BY customer_number\\nHAVING COUNT(order_number)=\\n    (SELECT COUNT(order_number) cnt\\n     FROM Orders\\n     GROUP BY customer_number\\n\\t ORDER BY cnt DESC\\n\\t LIMIT 1 \\n    )\\n\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT customer_number \\nFROM Orders \\nGROUP BY customer_number\\nHAVING COUNT(order_number)=\\n    (SELECT COUNT(order_number) cnt\\n     FROM Orders\\n     GROUP BY customer_number\\n\\t ORDER BY cnt DESC\\n\\t LIMIT 1 \\n    )\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2474266,
                "title": "my-sql-solution-using-group-by-order-by-and-limit",
                "content": "**Approach:**\\n\\nApply **`GROUP BY`** on the column **`customer_number`** and **`COUNT`** the number of orders a customer has made. Then **sort** the data in the **descending order** of order count and display the **`customer_number`** of first row using **`LIMIT`**.\\n\\n**Solution:**\\n```\\n# Write your MySQL query statement below\\nSELECT customer_number\\nFROM (\\n        SELECT COUNT(order_number) as ord, customer_number \\n        FROM Orders\\n        GROUP BY customer_number\\n     ) AS myTable\\nORDER BY ord DESC \\nLIMIT 1;\\n```\\n\\nPlease **upvote**. Thank you :)",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT customer_number\\nFROM (\\n        SELECT COUNT(order_number) as ord, customer_number \\n        FROM Orders\\n        GROUP BY customer_number\\n     ) AS myTable\\nORDER BY ord DESC \\nLIMIT 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2473167,
                "title": "using-count-and-limit",
                "content": "```\\n# Write your MySQL query statement below\\nselect customer_number\\nfrom Orders\\ngroup by customer_number\\norder by count(*) desc limit 1;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect customer_number\\nfrom Orders\\ngroup by customer_number\\norder by count(*) desc limit 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2473149,
                "title": "mysql-solution-group-by-statement-easy-understanding-faster-than-90",
                "content": "```\\nSELECT customer_number\\nFROM Orders \\nGROUP BY customer_number\\nORDER BY COUNT(customer_number) DESC\\nLIMIT 1\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT customer_number\\nFROM Orders \\nGROUP BY customer_number\\nORDER BY COUNT(customer_number) DESC\\nLIMIT 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2471365,
                "title": "mysql-faster-than-99-97",
                "content": "- GROUP BY customer_number in a subquery\\n- ORDER BY DESC\\n- Return the first row\\n```\\nSELECT customer_number\\nFROM (\\n    SELECT \\n        customer_number, \\n        COUNT(order_number) AS cnt\\n    FROM Orders\\n    GROUP BY 1\\n) subq\\nORDER BY cnt DESC\\nLIMIT 1\\n```\\nRuntime: 342 ms, faster than 99.97%\\nMemory Usage: 0B, less than 100.00%",
                "solutionTags": [],
                "code": "```\\nSELECT customer_number\\nFROM (\\n    SELECT \\n        customer_number, \\n        COUNT(order_number) AS cnt\\n    FROM Orders\\n    GROUP BY 1\\n) subq\\nORDER BY cnt DESC\\nLIMIT 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2470053,
                "title": "simple-solution-with-proper-explanation",
                "content": "GROUP BY , ORDER BY ONLY\\nLIMIT for displaying top one value\\n```\\nSELECT customer_number \\nFROM Orders\\nGROUP BY customer_number\\nORDER BY COUNT(order_number) DESC\\nLIMIT 1\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT customer_number \\nFROM Orders\\nGROUP BY customer_number\\nORDER BY COUNT(order_number) DESC\\nLIMIT 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2469488,
                "title": "simple-solution-follow-up",
                "content": "<b> First Basic Approach:- </b>\\n> We can group by customer number and then order the count in decreasing order,\\n> Finally we have the customer no with highest count of orders on top, so we return 1 using limit 1\\n<b> Code: </b>\\n```\\nselect customer_number \\nfrom orders\\ngroup by customer_number\\norder by count(order_number) \\ndesc limit 1\\n```\\n\\n<b> To handle follow up:- </b>\\n> We can group by customer number and calculate the count of each group i.e number of orders by each customer\\n> Next step is to select the max out of these count\\n> Now its time to use the above result i.e maximum count of orders by any customer\\n> Select all those customers group by orders and the count of orders is eqal to max no of orders\\n<b> Code: </b>\\n```\\nselect customer_number \\nfrom orders\\ngroup by customer_number\\nhaving count(order_number) = \\n\\t(select max(ct) from (\\n\\t\\tselect count(order_number) as ct from orders\\n\\t\\tgroup by customer_number\\n\\t) as temp)\\n```\\n\\n<b> Explaination </b>\\n```\\n> Selecting customer number from orders grouping them by customer no where the count of order_number is max\\n> Nested selct query returns max count \\n> yet another nested query return a new temporary table temp that has count of orders of all customers\\n```\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect customer_number \\nfrom orders\\ngroup by customer_number\\norder by count(order_number) \\ndesc limit 1\\n```\n```\\nselect customer_number \\nfrom orders\\ngroup by customer_number\\nhaving count(order_number) = \\n\\t(select max(ct) from (\\n\\t\\tselect count(order_number) as ct from orders\\n\\t\\tgroup by customer_number\\n\\t) as temp)\\n```\n```\\n> Selecting customer number from orders grouping them by customer no where the count of order_number is max\\n> Nested selct query returns max count \\n> yet another nested query return a new temporary table temp that has count of orders of all customers\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2441793,
                "title": "simple-window-function",
                "content": "```\\n# Write your MySQL query statement below\\nwith cte as \\n(select *, count(customer_number) over (partition by customer_number)\\nas \"total\" from orders )\\n\\nselect distinct customer_number from cte \\norder by total desc \\nlimit 1 \\n```",
                "solutionTags": [
                    "MySQL",
                    "Sliding Window"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nwith cte as \\n(select *, count(customer_number) over (partition by customer_number)\\nas \"total\" from orders )\\n\\nselect distinct customer_number from cte \\norder by total desc \\nlimit 1 \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2385707,
                "title": "mysql-easy-solution",
                "content": "select customer_number from Orders group by customer_number order by count(order_number) desc \\nlimit 1",
                "solutionTags": [],
                "code": "select customer_number from Orders group by customer_number order by count(order_number) desc \\nlimit 1",
                "codeTag": "Unknown"
            },
            {
                "id": 2381087,
                "title": "easy-sql-solution",
                "content": "* SELECT customer_number FROM orders\\n* GROUP BY customer_number\\n* ORDER BY COUNT(*) DESC LIMIT 1;",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "* SELECT customer_number FROM orders\\n* GROUP BY customer_number\\n* ORDER BY COUNT(*) DESC LIMIT 1;",
                "codeTag": "Unknown"
            },
            {
                "id": 2379381,
                "title": "mysql-simple-solution",
                "content": "```\\n# Write your MySQL query statement below\\nselect customer_number\\nfrom Orders \\ngroup by customer_number \\norder by count(*) desc \\nlimit 1\\n```",
                "solutionTags": [],
                "code": "```\\n# Write your MySQL query statement below\\nselect customer_number\\nfrom Orders \\ngroup by customer_number \\norder by count(*) desc \\nlimit 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2373225,
                "title": "mysql-group-by-order-by-limit",
                "content": "\\n```\\nSELECT customer_number\\nFROM Orders\\nGROUP BY customer_number\\nORDER BY COUNT(order_number) DESC\\nLIMIT 1\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT customer_number\\nFROM Orders\\nGROUP BY customer_number\\nORDER BY COUNT(order_number) DESC\\nLIMIT 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2350749,
                "title": "group-by",
                "content": "```\\nSELECT customer_number\\nFROM Orders\\nGROUP BY customer_number\\nORDER BY COUNT(order_number) DESC \\nLIMIT 1\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT customer_number\\nFROM Orders\\nGROUP BY customer_number\\nORDER BY COUNT(order_number) DESC \\nLIMIT 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2347188,
                "title": "faster-than-64-36-of-mysql-online-submissions-for-customer-placing-the-largest-number-of-orders",
                "content": "```\\nSELECT customer_number\\nFROM Orders\\nGROUP BY customer_number\\nORDER BY count(order_number) DESC\\nLIMIT 1\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT customer_number\\nFROM Orders\\nGROUP BY customer_number\\nORDER BY count(order_number) DESC\\nLIMIT 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2333878,
                "title": "simple-mysql-solution",
                "content": "SELECT customer_number\\nFROM Orders \\nGROUP BY customer_number\\nORDER BY COUNT(order_number) DESC\\nLIMIT 1;",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "SELECT customer_number\\nFROM Orders \\nGROUP BY customer_number\\nORDER BY COUNT(order_number) DESC\\nLIMIT 1;",
                "codeTag": "Unknown"
            },
            {
                "id": 2321221,
                "title": "multiple-answers-oracle-and-mysql",
                "content": "* **MYSQL and Oracle solution :**\\n```\\nselect customer_number from Orders \\ngroup by customer_number\\nhaving count(*)>= all(select count(*) from orders group by customer_number  )\\n```\\n* **Oracle Solution :**\\n```\\nselect *from (\\nSELECT\\n    customer_number\\nFROM\\n    orders\\nGROUP BY customer_number\\nORDER BY COUNT(*) DESC)\\nwhere ROWNUM <=1\\n;\\n```\\n* **MYSQL solution :**\\n```\\nSELECT\\n    customer_number\\nFROM\\n    orders\\nGROUP BY customer_number\\nORDER BY COUNT(*) DESC\\nLIMIT 1\\n;\\n```",
                "solutionTags": [
                    "MySQL",
                    "Oracle"
                ],
                "code": "```\\nselect customer_number from Orders \\ngroup by customer_number\\nhaving count(*)>= all(select count(*) from orders group by customer_number  )\\n```\n```\\nselect *from (\\nSELECT\\n    customer_number\\nFROM\\n    orders\\nGROUP BY customer_number\\nORDER BY COUNT(*) DESC)\\nwhere ROWNUM <=1\\n;\\n```\n```\\nSELECT\\n    customer_number\\nFROM\\n    orders\\nGROUP BY customer_number\\nORDER BY COUNT(*) DESC\\nLIMIT 1\\n;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2295317,
                "title": "mysql-simple-solution",
                "content": "```\\n\\nselect customer_number from Orders group by customer_number order by count(order_number) desc limit 1;\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n\\nselect customer_number from Orders group by customer_number order by count(order_number) desc limit 1;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2278149,
                "title": "sub-query-group-by-mysql",
                "content": "```\\nselect customer_number from\\n(select customer_number, count(customer_number) from Orders group by customer_number order by count(customer_number) desc)A\\nlimit 1;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect customer_number from\\n(select customer_number, count(customer_number) from Orders group by customer_number order by count(customer_number) desc)A\\nlimit 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2267349,
                "title": "simple-and-easy-mysql-solution",
                "content": "```\\n# Write your MySQL query statement below\\nselect customer_number from Orders \\ngroup by customer_number\\norder by count(customer_number) desc\\nlimit 1\\n```\\n\\n**Please UpVote if it was Helpful :)**",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect customer_number from Orders \\ngroup by customer_number\\norder by count(customer_number) desc\\nlimit 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2256837,
                "title": "simple-query-using-group-by-and-order-by",
                "content": "\\tselect customer_number from orders\\n\\tgroup by customer_number order by count(*) desc limit 1",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "\\tselect customer_number from orders\\n\\tgroup by customer_number order by count(*) desc limit 1",
                "codeTag": "Unknown"
            },
            {
                "id": 2232404,
                "title": "one-line-code",
                "content": "```\\n# Write your MySQL query statement below\\nselect customer_number from orders\\ngroup by customer_number\\norder by count(*) desc\\nlimit 1;\\n```",
                "solutionTags": [],
                "code": "```\\n# Write your MySQL query statement below\\nselect customer_number from orders\\ngroup by customer_number\\norder by count(*) desc\\nlimit 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2204160,
                "title": "a-simple-sql-query",
                "content": "```\\nselect customer_number\\nfrom Orders \\ngroup by customer_number \\norder by  count( order_number) desc\\nlimit 1",
                "solutionTags": [],
                "code": "```\\nselect customer_number\\nfrom Orders \\ngroup by customer_number \\norder by  count( order_number) desc\\nlimit 1",
                "codeTag": "Unknown"
            },
            {
                "id": 2188507,
                "title": "simple-fast-solution",
                "content": "```\\n\\nselect customer_number from Orders\\ngroup by customer_number\\norder by count(customer_number) DESC\\nlimit 1\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nselect customer_number from Orders\\ngroup by customer_number\\norder by count(customer_number) DESC\\nlimit 1\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2171610,
                "title": "elegant-sql",
                "content": "```\\nselect TOP 1\\n    customer_number\\nfrom Orders \\nGROUP BY  customer_number \\nORDER BY COUNT(customer_number) DESC\\n```",
                "solutionTags": [
                    "MySQL",
                    "MS SQL Server"
                ],
                "code": "```\\nselect TOP 1\\n    customer_number\\nfrom Orders \\nGROUP BY  customer_number \\nORDER BY COUNT(customer_number) DESC\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2164644,
                "title": "just-check-it-once-easy-simple",
                "content": "# ***For ALL solutions of MYSQL-1 STUDY PLAN  refer  https://github.com/its-red-eagle/LEETCODE-MYSQL-I-STUDY-PLAN-SOLUTIONS***\\n```\\nselect customer_number from Orders\\ngroup by customer_number\\norder by count(customer_number) desc limit 1;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect customer_number from Orders\\ngroup by customer_number\\norder by count(customer_number) desc limit 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2153122,
                "title": "mysql-cte-and-max",
                "content": "```\\nwith biggest_order_cte as (\\nselect customer_number, \\n        COUNT(*) OVER (PARTITION BY customer_number) as total_order\\nFROM Orders)\\n\\nselect  distinct customer_number\\nfrom biggest_order_cte\\nwhere total_order = (\\nselect max(total_order) from biggest_order_cte )\\n```",
                "solutionTags": [],
                "code": "```\\nwith biggest_order_cte as (\\nselect customer_number, \\n        COUNT(*) OVER (PARTITION BY customer_number) as total_order\\nFROM Orders)\\n\\nselect  distinct customer_number\\nfrom biggest_order_cte\\nwhere total_order = (\\nselect max(total_order) from biggest_order_cte )\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2150950,
                "title": "mssql-easy-solution",
                "content": "```\\nSELECT TOP 1\\n    customer_number\\nFROM\\n    Orders\\nGROUP BY\\n    customer_number\\nORDER BY\\n    COUNT(*) DESC\\n```",
                "solutionTags": [
                    "MySQL",
                    "MS SQL Server"
                ],
                "code": "```\\nSELECT TOP 1\\n    customer_number\\nFROM\\n    Orders\\nGROUP BY\\n    customer_number\\nORDER BY\\n    COUNT(*) DESC\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2103508,
                "title": "sql-easy-solution-solves-the-follow-up-question-as-well",
                "content": "```\\n\\nselect customer_number from orders group by customer_number having count(order_number) = (\\nselect max(customer_orders) from (\\nselect count(order_number) as customer_orders, customer_number from orders\\ngroup by customer_number)A)\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nselect customer_number from orders group by customer_number having count(order_number) = (\\nselect max(customer_orders) from (\\nselect count(order_number) as customer_orders, customer_number from orders\\ngroup by customer_number)A)\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2086247,
                "title": "mysql-simple-and-intermediate-solution",
                "content": "* Simple Solution:\\n```\\nselect customer_number from Orders\\ngroup by customer_number\\norder by count(customer_number) desc \\nlimit 1;\\n```\\n\\n* Intermediate solution using HAVING and INNER QUERRY\\n```\\nSELECT customer_number\\nFROM orders\\nGROUP BY customer_number\\nHAVING COUNT(order_number) = (\\n\\tSELECT COUNT(order_number) cnt\\n\\tFROM orders\\n\\tGROUP BY customer_number\\n\\tORDER BY cnt DESC\\n\\tLIMIT 1\\n)\\n```\\n\\nPlease Upvote if you like the Solution.",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect customer_number from Orders\\ngroup by customer_number\\norder by count(customer_number) desc \\nlimit 1;\\n```\n```\\nSELECT customer_number\\nFROM orders\\nGROUP BY customer_number\\nHAVING COUNT(order_number) = (\\n\\tSELECT COUNT(order_number) cnt\\n\\tFROM orders\\n\\tGROUP BY customer_number\\n\\tORDER BY cnt DESC\\n\\tLIMIT 1\\n)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2047483,
                "title": "simple-sql-solution-94-faster",
                "content": "select b.customer_number \\nfrom\\n(select a.customer_number,rank() over(order by a.cnt desc) as rnk \\nfrom \\n(select customer_number ,count(*) as cnt from Orders group by 1)a)b\\nwhere b.rnk=1",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "select b.customer_number \\nfrom\\n(select a.customer_number,rank() over(order by a.cnt desc) as rnk \\nfrom \\n(select customer_number ,count(*) as cnt from Orders group by 1)a)b\\nwhere b.rnk=1",
                "codeTag": "Unknown"
            },
            {
                "id": 2023036,
                "title": "using-max-and-with-clause",
                "content": "WITH A as (select customer_number, count(customer_number) as c_n from orders\\ngroup by customer_number)\\nselect customer_number from A where c_n = (select max(c_n) from A)",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "WITH A as (select customer_number, count(customer_number) as c_n from orders\\ngroup by customer_number)\\nselect customer_number from A where c_n = (select max(c_n) from A)",
                "codeTag": "Unknown"
            },
            {
                "id": 2022270,
                "title": "very-easy-using-group-by-and-with-statement",
                "content": "with temp as (\\n    select customer_number, count(order_number) as count_order from orders\\n    group by customer_number\\n    )\\n    select top 1 customer_number from temp\\n    order by count_order desc",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "with temp as (\\n    select customer_number, count(order_number) as count_order from orders\\n    group by customer_number\\n    )\\n    select top 1 customer_number from temp\\n    order by count_order desc",
                "codeTag": "Unknown"
            },
            {
                "id": 2019068,
                "title": "simple-sql-query",
                "content": "```\\nselect customer_number from Orders\\nGROUP BY customer_number\\nORDER BY COUNT(*) DESC\\nLIMIT 1;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect customer_number from Orders\\nGROUP BY customer_number\\nORDER BY COUNT(*) DESC\\nLIMIT 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1993962,
                "title": "60-faster-than-all-results-and-easy-too",
                "content": "```\\nselect customer_number\\nfrom Orders\\ngroup by customer_number\\norder by count(order_number) desc limit 1\\n```",
                "solutionTags": [],
                "code": "```\\nselect customer_number\\nfrom Orders\\ngroup by customer_number\\norder by count(order_number) desc limit 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1986779,
                "title": "sql-3-methods",
                "content": "```\\n#When there is only one cutomer with maximum orders\\nSELECT customer_number\\nFROM Orders \\nGROUP BY customer_number\\nORDER BY COUNT(order_number) DESC\\nLIMIT 1;\\n\\n#When more than 1 customer can have maximum orders, without using LIMIT\\nSELECT customer_number\\nFROM Orders\\nGROUP BY customer_number\\nHAVING COUNT(order_number)=\\n(SELECT MAX(num_orders) FROM \\n(SELECT COUNT(order_number) as num_orders FROM Orders AS Counts GROUP BY customer_number)\\n AS Maxfreq);\\n\\n#When more than 1 customer can have maximum orders, using LIMIT\\nSELECT customer_number\\nFROM Orders\\nGROUP BY customer_number\\nHAVING COUNT(order_number)=\\n(SELECT COUNT(order_number) FROM Orders AS Counts GROUP BY customer_number ORDER BY COUNT(order_number) DESC LIMIT 1);\\n```",
                "solutionTags": [],
                "code": "```\\n#When there is only one cutomer with maximum orders\\nSELECT customer_number\\nFROM Orders \\nGROUP BY customer_number\\nORDER BY COUNT(order_number) DESC\\nLIMIT 1;\\n\\n#When more than 1 customer can have maximum orders, without using LIMIT\\nSELECT customer_number\\nFROM Orders\\nGROUP BY customer_number\\nHAVING COUNT(order_number)=\\n(SELECT MAX(num_orders) FROM \\n(SELECT COUNT(order_number) as num_orders FROM Orders AS Counts GROUP BY customer_number)\\n AS Maxfreq);\\n\\n#When more than 1 customer can have maximum orders, using LIMIT\\nSELECT customer_number\\nFROM Orders\\nGROUP BY customer_number\\nHAVING COUNT(order_number)=\\n(SELECT COUNT(order_number) FROM Orders AS Counts GROUP BY customer_number ORDER BY COUNT(order_number) DESC LIMIT 1);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1977095,
                "title": "easy-to-understand-sql",
                "content": "```\\nselect\\n    customer_number\\nfrom\\n    orders\\ngroup by\\n    customer_number\\norder by\\n    count(*)\\ndesc\\nlimit 1;\\n```\\n\\nIf you have any **doubts**, feel **free to ask**...\\nIf you understand the **concept**. Don\\'t Forget to **upvote** \\uD83D\\uDE0A\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect\\n    customer_number\\nfrom\\n    orders\\ngroup by\\n    customer_number\\norder by\\n    count(*)\\ndesc\\nlimit 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1966125,
                "title": "mysql-solution",
                "content": "# Solution\\n```\\nSELECT customer_number\\nFROM Orders\\nGROUP BY customer_number\\nORDER BY COUNT(*) DESC \\nLIMIT 1\\n```\\n**COUNT** - The **COUNT()** function returns the number of rows that matches a specified criterion.\\n**ORDER BY** - The **ORDER BY** keyword is used to sort the result-set in ascending or descending order.\\nThe ORDER BY keyword sorts the records in ascending order by default. To sort the records in descending order, use the DESC keyword.\\n**LIMIT** - The **LIMIT** statement is used to retrieve records from one or more tables in a database and limit the number of records returned based on a limit value.\\nIf you find this **solution** and **explanation** helpful, please **upvote** it for others people.\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT customer_number\\nFROM Orders\\nGROUP BY customer_number\\nORDER BY COUNT(*) DESC \\nLIMIT 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1964447,
                "title": "mysql-easy-implementation",
                "content": "```\\nWITH cte AS \\n(SELECT customer_number, COUNT(order_number) AS orderCount\\nFROM Orders\\nGROUP BY customer_number)\\n\\nSELECT customer_number\\nFROM cte\\nWHERE orderCount = (SELECT MAX(orderCount) FROM cte)\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nWITH cte AS \\n(SELECT customer_number, COUNT(order_number) AS orderCount\\nFROM Orders\\nGROUP BY customer_number)\\n\\nSELECT customer_number\\nFROM cte\\nWHERE orderCount = (SELECT MAX(orderCount) FROM cte)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1946248,
                "title": "accepted-solution-for-mysql",
                "content": "```sql\\nSELECT customer_number FROM orders GROUP BY customer_number\\nORDER BY COUNT(*) DESC LIMIT 1;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```sql\\nSELECT customer_number FROM orders GROUP BY customer_number\\nORDER BY COUNT(*) DESC LIMIT 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1927986,
                "title": "ms-sql-server-using-group-by-and-order-by-clause",
                "content": "```\\n/* Write your T-SQL query statement below */\\nSELECT TOP 1 customer_number FROM Orders\\nGROUP BY customer_number\\nORDER BY COUNT(order_number) DESC;\\n```",
                "solutionTags": [],
                "code": "```\\n/* Write your T-SQL query statement below */\\nSELECT TOP 1 customer_number FROM Orders\\nGROUP BY customer_number\\nORDER BY COUNT(order_number) DESC;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1919952,
                "title": "easy-to-follow-solution-using-a-simple-cte-group-by",
                "content": "```sql\\nWITH orders_per_customer AS (\\n    SELECT customer_number, COUNT(*) AS \\'num_of_orders\\'\\n    FROM Orders\\n    GROUP BY customer_number\\n)\\n\\nSELECT customer_number\\nFROM orders_per_customer\\nWHERE num_of_orders = (\\n    SELECT MAX(num_of_orders)\\n    FROM orders_per_customer\\n);\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```sql\\nWITH orders_per_customer AS (\\n    SELECT customer_number, COUNT(*) AS \\'num_of_orders\\'\\n    FROM Orders\\n    GROUP BY customer_number\\n)\\n\\nSELECT customer_number\\nFROM orders_per_customer\\nWHERE num_of_orders = (\\n    SELECT MAX(num_of_orders)\\n    FROM orders_per_customer\\n);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1918273,
                "title": "simple-mssql-solution",
                "content": "```\\nwith temp as(\\n    select customer_number, count(order_number) as cn\\n\\tfrom orders\\n    group by customer_number\\n\\t)\\nselect customer_number\\nfrom temp\\nwhere cn=(select max(cn) from temp)\\n```",
                "solutionTags": [
                    "MySQL",
                    "MS SQL Server"
                ],
                "code": "```\\nwith temp as(\\n    select customer_number, count(order_number) as cn\\n\\tfrom orders\\n    group by customer_number\\n\\t)\\nselect customer_number\\nfrom temp\\nwhere cn=(select max(cn) from temp)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1905409,
                "title": "simple-mysql-solution-with-the-follow-up-query",
                "content": "```\\nselect customer_number from orders\\ngroup by customer_number\\norder by COUNT(*) DESC\\nlimit 1\\n\\n# Folllow Up question\\nselect customer_number from orders\\ngroup by customer_number\\nhaving COUNT(*) = (select max(cou) as cou from (select customer_number, count(*) as cou \\n                                                from orders group by customer_number ) temp)\\n               \\nselect customer_number from orders\\ngroup by customer_number\\nhaving COUNT(*) = \\n(select COUNT(*) from orders group by customer_number\\norder by COUNT(*) DESC LIMIT 1)",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect customer_number from orders\\ngroup by customer_number\\norder by COUNT(*) DESC\\nlimit 1\\n\\n# Folllow Up question\\nselect customer_number from orders\\ngroup by customer_number\\nhaving COUNT(*) = (select max(cou) as cou from (select customer_number, count(*) as cou \\n                                                from orders group by customer_number ) temp)\\n               \\nselect customer_number from orders\\ngroup by customer_number\\nhaving COUNT(*) = \\n(select COUNT(*) from orders group by customer_number\\norder by COUNT(*) DESC LIMIT 1)",
                "codeTag": "Unknown"
            },
            {
                "id": 1903556,
                "title": "group-by-subquery-order-by-easy-to-understand",
                "content": "```\\nselect customer_number\\nfrom (select customer_number, count(order_number) as total_orders\\n      from Orders\\n      group by customer_number) S\\norder by total_orders desc \\nlimit 1\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect customer_number\\nfrom (select customer_number, count(order_number) as total_orders\\n      from Orders\\n      group by customer_number) S\\norder by total_orders desc \\nlimit 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1899617,
                "title": "mysql-solution",
                "content": "```\\nSELECT customer_number\\nFROM orders \\nGROUP BY customer_number\\nORDER BY COUNT(order_number) DESC\\nLIMIT 1\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT customer_number\\nFROM orders \\nGROUP BY customer_number\\nORDER BY COUNT(order_number) DESC\\nLIMIT 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1882841,
                "title": "oracle-mysql-fast-clean-short",
                "content": "### Oracle\\n```\\nSELECT customer_number FROM (SELECT customer_number \\n                               FROM Orders \\n                              GROUP BY customer_number \\n                              ORDER BY count(*) DESC)\\n WHERE ROWNUM = 1\\n```\\n\\n###  MySQL\\n \\n```\\n SELECT customer_number \\n   FROM Orders\\n  GROUP BY customer_number \\n  ORDER BY count(*) DESC LIMIT 1\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT customer_number FROM (SELECT customer_number \\n                               FROM Orders \\n                              GROUP BY customer_number \\n                              ORDER BY count(*) DESC)\\n WHERE ROWNUM = 1\\n```\n```\\n SELECT customer_number \\n   FROM Orders\\n  GROUP BY customer_number \\n  ORDER BY count(*) DESC LIMIT 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1868533,
                "title": "simple-easy-with-group-by-count-order-by-limit",
                "content": "```\\n\\n# steps:\\n# 1. count of orders per customer\\n# 2. ORDER BY count(*) DESC LIMIT 1;\\n\\nSELECT customer_number \\nFROM orders\\nGROUP BY customer_number\\nORDER BY COUNT(DISTINCT order_number) DESC\\nLIMIT 1;\\n```",
                "solutionTags": [],
                "code": "```\\n\\n# steps:\\n# 1. count of orders per customer\\n# 2. ORDER BY count(*) DESC LIMIT 1;\\n\\nSELECT customer_number \\nFROM orders\\nGROUP BY customer_number\\nORDER BY COUNT(DISTINCT order_number) DESC\\nLIMIT 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1862713,
                "title": "using-window-function",
                "content": "```\\nselect a.customer_number\\nfrom (\\n    select customer_number, \\n            count(order_number) order_count,\\n            rank() over(order by count(order_number) desc) order_rank\\n    from orders\\n    group by customer_number ) a\\nwhere order_rank = 1\\n```",
                "solutionTags": [],
                "code": "```\\nselect a.customer_number\\nfrom (\\n    select customer_number, \\n            count(order_number) order_count,\\n            rank() over(order by count(order_number) desc) order_rank\\n    from orders\\n    group by customer_number ) a\\nwhere order_rank = 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1683606,
                "title": "mysql-group-by-memory-0-faster-than-100",
                "content": "```\\n#use group by to select customer numer and order counts\\n\\nselect customer_number from orders\\ngroup by customer_number\\norder by count(*) desc\\nlimit 1;\\n``",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n#use group by to select customer numer and order counts\\n\\nselect customer_number from orders\\ngroup by customer_number\\norder by count(*) desc\\nlimit 1;\\n``",
                "codeTag": "Unknown"
            },
            {
                "id": 1605696,
                "title": "follow-up-top-with-ties-for-ms-sql-only",
                "content": "ms sql has this `TOP WITH TIES` to return the rows that tie. \\n```\\nSELECT\\n    TOP 1 WITH TIES customer_number\\nFROM Orders\\nGROUP BY customer_number\\nORDER BY COUNT(*) DESC\\n```",
                "solutionTags": [
                    "MySQL",
                    "MS SQL Server"
                ],
                "code": "```\\nSELECT\\n    TOP 1 WITH TIES customer_number\\nFROM Orders\\nGROUP BY customer_number\\nORDER BY COUNT(*) DESC\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1521671,
                "title": "without-limit",
                "content": "```\\nwith customerWithOrdersNumber as (\\nselect customer_number, count(1) number_of_orders\\nfrom orders \\ngroup by customer_number \\n)\\nselect customer_number \\nfrom customerWithOrdersNumber \\nwhere number_of_orders in (select max(number_of_orders) from customerWithOrdersNumber)\\n```",
                "solutionTags": [
                    "MySQL",
                    "Oracle"
                ],
                "code": "```\\nwith customerWithOrdersNumber as (\\nselect customer_number, count(1) number_of_orders\\nfrom orders \\ngroup by customer_number \\n)\\nselect customer_number \\nfrom customerWithOrdersNumber \\nwhere number_of_orders in (select max(number_of_orders) from customerWithOrdersNumber)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1465184,
                "title": "working-solution",
                "content": "select customer_number\\nfrom Orders\\ngroup by customer_number\\norder by count(*) desc\\nlimit 1",
                "solutionTags": [],
                "code": "select customer_number\\nfrom Orders\\ngroup by customer_number\\norder by count(*) desc\\nlimit 1",
                "codeTag": "Unknown"
            },
            {
                "id": 1374888,
                "title": "using-rank",
                "content": "select customer_number from (\\nselect customer_number, count(order_number) as cnt_order, rank() over (order by count(order_number) desc) as rnk\\nfrom Orders\\ngroup by customer_number\\n)t\\nwhere t.rnk = 1",
                "solutionTags": [],
                "code": "select customer_number from (\\nselect customer_number, count(order_number) as cnt_order, rank() over (order by count(order_number) desc) as rnk\\nfrom Orders\\ngroup by customer_number\\n)t\\nwhere t.rnk = 1",
                "codeTag": "Unknown"
            },
            {
                "id": 1273007,
                "title": "simple-t-sql",
                "content": "```\\n/* Write your T-SQL query statement below */\\nSELECT TOP 1 customer_number\\nFROM Orders\\nGROUP BY customer_number\\nORDER BY COUNT(*) DESC\\n```",
                "solutionTags": [
                    "MySQL",
                    "MS SQL Server"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\nSELECT TOP 1 customer_number\\nFROM Orders\\nGROUP BY customer_number\\nORDER BY COUNT(*) DESC\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1250393,
                "title": "mysql",
                "content": "```\\nWITH cte\\nAS (SELECT customer_number, COUNT(order_number) AS cnt\\nFROM Orders\\nGROUP BY 1)\\n\\nSELECT customer_number \\nFROM cte \\nWHERE cnt IN (SELECT MAX(cnt)\\n              FROM cte)\\n```\\t\\t\\t",
                "solutionTags": [],
                "code": "```\\nWITH cte\\nAS (SELECT customer_number, COUNT(order_number) AS cnt\\nFROM Orders\\nGROUP BY 1)\\n\\nSELECT customer_number \\nFROM cte \\nWHERE cnt IN (SELECT MAX(cnt)\\n              FROM cte)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 993505,
                "title": "simple-solutions-mysql-mssql-oracle",
                "content": "MySQL\\n```\\nselect customer_number from orders\\ngroup by customer_number\\nhaving count(customer_number)=(select count(customer_number) from orders group by customer_number order by count(customer_number) desc limit 1)\\n```\\nMSSQL\\n```\\nselect customer_number from orders\\ngroup by customer_number\\nhaving count(customer_number)=(select top 1 count(customer_number) from orders group by customer_number order by count(customer_number) desc)\\n```\\nOracle\\n```\\nselect customer_number from orders\\ngroup by customer_number\\nhaving count(customer_number)=(select max(count(customer_number)) from orders group by customer_number)\\n```",
                "solutionTags": [],
                "code": "```\\nselect customer_number from orders\\ngroup by customer_number\\nhaving count(customer_number)=(select count(customer_number) from orders group by customer_number order by count(customer_number) desc limit 1)\\n```\n```\\nselect customer_number from orders\\ngroup by customer_number\\nhaving count(customer_number)=(select top 1 count(customer_number) from orders group by customer_number order by count(customer_number) desc)\\n```\n```\\nselect customer_number from orders\\ngroup by customer_number\\nhaving count(customer_number)=(select max(count(customer_number)) from orders group by customer_number)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 903566,
                "title": "solution-using-group-by-and-limit",
                "content": "select  customer_number from orders group by customer_number\\nhaving count(customer_number)>=2 order by count(customer_number) desc limit 1;",
                "solutionTags": [],
                "code": "select  customer_number from orders group by customer_number\\nhaving count(customer_number)>=2 order by count(customer_number) desc limit 1;",
                "codeTag": "Unknown"
            },
            {
                "id": 872889,
                "title": "simple-mysql-solution",
                "content": "```\\nselect customer_number\\nfrom Orders\\ngroup by customer_number\\norder by count(customer_number) desc\\nlimit 1\\n```",
                "solutionTags": [],
                "code": "```\\nselect customer_number\\nfrom Orders\\ngroup by customer_number\\norder by count(customer_number) desc\\nlimit 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 829375,
                "title": "ms-sql-server",
                "content": "```\\n/* Write your T-SQL query statement below */\\nselect top 1 customer_number from orders group by customer_number order by count(customer_number) desc\\n```",
                "solutionTags": [],
                "code": "```\\n/* Write your T-SQL query statement below */\\nselect top 1 customer_number from orders group by customer_number order by count(customer_number) desc\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 586189,
                "title": "mysql-having-subquery-where-there-may-be-multiple-matches-to-max",
                "content": "```\\nselect customer_number from orders\\ngroup by customer_number\\nhaving count(distinct order_number) = \\n\\t(\\n\\t\\tselect count(distinct order_number) as cdon \\n\\t\\tfrom orders\\n\\t\\tgroup by customer_number\\n\\t\\torder by cdon desc\\n\\t\\tlimit 1 \\n\\t)\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect customer_number from orders\\ngroup by customer_number\\nhaving count(distinct order_number) = \\n\\t(\\n\\t\\tselect count(distinct order_number) as cdon \\n\\t\\tfrom orders\\n\\t\\tgroup by customer_number\\n\\t\\torder by cdon desc\\n\\t\\tlimit 1 \\n\\t)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 527816,
                "title": "mssql-solution",
                "content": "```\\nselect customer_number from(\\nselect customer_number, row_number() over(order by count(customer_number) desc) rn from orders group by customer_number)a where rn=1\\n```",
                "solutionTags": [],
                "code": "```\\nselect customer_number from(\\nselect customer_number, row_number() over(order by count(customer_number) desc) rn from orders group by customer_number)a where rn=1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 455384,
                "title": "simple-solution",
                "content": "select customer_number from orders\\ngroup by customer_number \\norder by count(order_number) desc\\nlimit 1 ;",
                "solutionTags": [],
                "code": "select customer_number from orders\\ngroup by customer_number \\norder by count(order_number) desc\\nlimit 1 ;",
                "codeTag": "Unknown"
            },
            {
                "id": 400841,
                "title": "simple-mysql-explanation",
                "content": "To break up/simplify the question, we first should define what exactly we are looking for.\\nWe need the person (customer_number) and how many orders has he/she placed (count of order_number).\\n\\nGrouping by each individual customer, we will find how many orders this person has placed using count function.\\n```\\nselect customer_number from orders\\ngroup by customer_number\\n```\\n\\nThen the problem is to identifine who has the max number of orders:\\n```\\norder by count(order_number) desc\\nlimit  1\\n```\\n\\nCombine them, we get:\\n```\\nselect customer_number from orders\\ngroup by customer_number\\norder by count(order_number) desc\\nlimit 1\\n```",
                "solutionTags": [],
                "code": "```\\nselect customer_number from orders\\ngroup by customer_number\\n```\n```\\norder by count(order_number) desc\\nlimit  1\\n```\n```\\nselect customer_number from orders\\ngroup by customer_number\\norder by count(order_number) desc\\nlimit 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 359454,
                "title": "simple-solution-using-order-by",
                "content": "select top 1 customer_number\\nfrom orders\\ngroup by customer_number\\norder by count(order_number) desc",
                "solutionTags": [],
                "code": "select top 1 customer_number\\nfrom orders\\ngroup by customer_number\\norder by count(order_number) desc",
                "codeTag": "Unknown"
            },
            {
                "id": 334365,
                "title": "mssql-solution-this-should-work-good",
                "content": "SELECT top 1\\n    customer_number\\nFROM\\n    orders\\nGROUP BY customer_number\\norder by count(*) desc",
                "solutionTags": [],
                "code": "SELECT top 1\\n    customer_number\\nFROM\\n    orders\\nGROUP BY customer_number\\norder by count(*) desc",
                "codeTag": "Unknown"
            },
            {
                "id": 285517,
                "title": "solve-follow-up",
                "content": "select customer_number\\nfrom (select customer_number,\\n             count(order_number) as order_counts\\n      from orders\\n      group by 1\\n      order by order_counts DESC\\n      ) subq\\nhaving max(order_counts)",
                "solutionTags": [],
                "code": "select customer_number\\nfrom (select customer_number,\\n             count(order_number) as order_counts\\n      from orders\\n      group by 1\\n      order by order_counts DESC\\n      ) subq\\nhaving max(order_counts)",
                "codeTag": "Unknown"
            },
            {
                "id": 224919,
                "title": "mysql-clean-correct",
                "content": "Let me know if you have any questions!\\n```sql\\nSELECT customer_number \\n  FROM orders\\n GROUP BY customer_number\\n ORDER BY COUNT(*) DESC\\n LIMIT 1;\\n```",
                "solutionTags": [],
                "code": "```sql\\nSELECT customer_number \\n  FROM orders\\n GROUP BY customer_number\\n ORDER BY COUNT(*) DESC\\n LIMIT 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 129671,
                "title": "mysql-doesn-t-support-dense-rank-for-followup",
                "content": "shocked to learn that MySQL doesn\\'t support DENSE_RANK()  (being primarily worked on SQL Server)\\n```sql\\nSELECT customer_number\\nFROM (\\n\\tSELECT customer_number\\n\\t\\t,DENSE_RANK() OVER (ORDER BY order_count DESC) AS Rank\\n\\tFROM (\\n\\t\\tSELECT customer_number, count(*) AS order_count\\n\\t\\tFROM orders\\n\\t\\tGROUP BY customer_number) CTE\\n\\t) C\\nWHERE C.Rank = 1\\n```",
                "solutionTags": [],
                "code": "```sql\\nSELECT customer_number\\nFROM (\\n\\tSELECT customer_number\\n\\t\\t,DENSE_RANK() OVER (ORDER BY order_count DESC) AS Rank\\n\\tFROM (\\n\\t\\tSELECT customer_number, count(*) AS order_count\\n\\t\\tFROM orders\\n\\t\\tGROUP BY customer_number) CTE\\n\\t) C\\nWHERE C.Rank = 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 103298,
                "title": "solution",
                "content": "select customer_number from(select customer_number ,count(*) cnt from test.orders group by customer_number order by cnt desc limit 1) a ;",
                "solutionTags": [],
                "code": "select customer_number from(select customer_number ,count(*) cnt from test.orders group by customer_number order by cnt desc limit 1) a ;",
                "codeTag": "Unknown"
            },
            {
                "id": 4104108,
                "title": "why-didn-t-it-work",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nGroupby then sort, and lastly pick up the 1st value in the column \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport pandas as pd\\n\\ndef largest_orders(orders: pd.DataFrame) -> pd.DataFrame:\\n    df = orders.groupby(\\'customer_number\\')[\\'order_number\\'].count().reset_index().sort_values(by = \\'order_number\\', ascending = False).reset_index(drop = True)\\n\\n    return pd.DataFrame([{\\'customer_number\\': [int(df[\\'customer_number\\'][0])]}])\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef largest_orders(orders: pd.DataFrame) -> pd.DataFrame:\\n    df = orders.groupby(\\'customer_number\\')[\\'order_number\\'].count().reset_index().sort_values(by = \\'order_number\\', ascending = False).reset_index(drop = True)\\n\\n    return pd.DataFrame([{\\'customer_number\\': [int(df[\\'customer_number\\'][0])]}])\\n\\n\\n\\n\\n```",
                "codeTag": "Python3"
            }
        ],
        "discussions": [
            {
                "id": 1570852,
                "content": [
                    {
                        "username": "pritiprajapati314",
                        "content": "\\tSELECT customer_number \\n\\tFROM Orders\\n\\tGROUP BY customer_number\\n\\tORDER BY COUNT(order_number) DESC\\n\\tLIMIT 1;"
                    },
                    {
                        "username": "chiratsxki",
                        "content": "thank you pritiprajapati314"
                    },
                    {
                        "username": "bhupendra786",
                        "content": "# Write your MySQL query statement below\\n\\nSELECT\\n    customer_number\\nFROM\\n    orders\\nGROUP BY customer_number\\nORDER BY COUNT(*) DESC\\nLIMIT 1"
                    },
                    {
                        "username": "aswinsureshk",
                        "content": "`SELECT customer_number FROM orders GROUP BY customer_number HAVING count(*)>=ALL(SELECT count(*) FROM orders GROUP BY customer_number);`"
                    },
                    {
                        "username": "JaswanthP",
                        "content": "with cte as(\\nselect customer_number, rank() over (order by count(customer_number) desc) rnk from Orders group by customer_number)\\nselect customer_number from cte where rnk=1"
                    },
                    {
                        "username": "Mehul1997",
                        "content": "There was no need to make it this complicated"
                    },
                    {
                        "username": "bbbbeetroot",
                        "content": "Not sure what is wrong. I get the expected output in the test case but it says wrong answer.\\n\\nHere is my code:\\n```\\nimport pandas as pd\\n\\ndef largest_orders(orders: pd.DataFrame) -> pd.DataFrame:\\n    df = orders.groupby(\\'customer_number\\').size().reset_index()\\n    df = df.sort_values(by=0, ascending=False)\\n    return pd.DataFrame(\\n        {\"customer_number\" : [df[\\'customer_number\\'].head(1)]}\\n    )\\n```\\n\\nHere is my Output for the test case:\\n```\\n| customer_number |\\n| --------------- |\\n| 3               |\\n```\\n\\nHere is the expected output\\n```\\n| customer_number |\\n| --------------- |\\n| 3               |\\n```"
                    },
                    {
                        "username": "allispaul",
                        "content": "The problem is that `df[\\'customer_number\\'].head(1)` is returning a Series (of length 1), and the problem is expecting an int. Your code will work if you replace that with `df[\\'customer_number\\'].iloc[0]`."
                    },
                    {
                        "username": "quanghm",
                        "content": "Description **The test cases are generated so that exactly one customer will have placed more orders than any other customer.**\\nTest case:\\n```\\n| order_number | customer_number |\\n| ------------ | --------------- |\\n```\\n???"
                    },
                    {
                        "username": "ebrycez",
                        "content": "Can anyone explain why both `order by count(order_number) desc` and  `order by count(customer_number) desc` works after group by customer number?\\n"
                    },
                    {
                        "username": "clone8en",
                        "content": "Yes, I can. Count simply counts the number of non-null values in a field, that\\'s it. Not unique values. So whether you count rows with count(*), or the number of rows that don\\'t have NULL in a particular field, it\\'s the same logic. "
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "exactly i also want to know why aren\\'t we comparing order_number "
                    },
                    {
                        "username": "dafulu",
                        "content": "\"\"\"\\nselect customer_number\\nfrom orders \\ngroup by customer_number\\norder by count(customer_number) desc\\nlimit 1\\n\"\"\""
                    },
                    {
                        "username": "Fful",
                        "content": "*Task:*\\nThe test cases are **generated** so that exactly **one customer** will have placed more orders than any other customer.\\n\\n*Test_case #2:*\\n `| order_number | customer_number |`\\n`| ------------ | --------------- |`\\n\\nam i joke to you\\u2754\\u2754\\u2754\\nValueError: max() arg is an empty sequence "
                    },
                    {
                        "username": "user7071nM",
                        "content": "select customer_number from (select customer_number, row_number() over( order by count(customer_number) desc) as rn from orders group by customer_number)t\\nwhere rn=1;\\n\\nby using sub_queries"
                    }
                ]
            },
            {
                "id": 1570827,
                "content": [
                    {
                        "username": "pritiprajapati314",
                        "content": "\\tSELECT customer_number \\n\\tFROM Orders\\n\\tGROUP BY customer_number\\n\\tORDER BY COUNT(order_number) DESC\\n\\tLIMIT 1;"
                    },
                    {
                        "username": "chiratsxki",
                        "content": "thank you pritiprajapati314"
                    },
                    {
                        "username": "bhupendra786",
                        "content": "# Write your MySQL query statement below\\n\\nSELECT\\n    customer_number\\nFROM\\n    orders\\nGROUP BY customer_number\\nORDER BY COUNT(*) DESC\\nLIMIT 1"
                    },
                    {
                        "username": "aswinsureshk",
                        "content": "`SELECT customer_number FROM orders GROUP BY customer_number HAVING count(*)>=ALL(SELECT count(*) FROM orders GROUP BY customer_number);`"
                    },
                    {
                        "username": "JaswanthP",
                        "content": "with cte as(\\nselect customer_number, rank() over (order by count(customer_number) desc) rnk from Orders group by customer_number)\\nselect customer_number from cte where rnk=1"
                    },
                    {
                        "username": "Mehul1997",
                        "content": "There was no need to make it this complicated"
                    },
                    {
                        "username": "bbbbeetroot",
                        "content": "Not sure what is wrong. I get the expected output in the test case but it says wrong answer.\\n\\nHere is my code:\\n```\\nimport pandas as pd\\n\\ndef largest_orders(orders: pd.DataFrame) -> pd.DataFrame:\\n    df = orders.groupby(\\'customer_number\\').size().reset_index()\\n    df = df.sort_values(by=0, ascending=False)\\n    return pd.DataFrame(\\n        {\"customer_number\" : [df[\\'customer_number\\'].head(1)]}\\n    )\\n```\\n\\nHere is my Output for the test case:\\n```\\n| customer_number |\\n| --------------- |\\n| 3               |\\n```\\n\\nHere is the expected output\\n```\\n| customer_number |\\n| --------------- |\\n| 3               |\\n```"
                    },
                    {
                        "username": "allispaul",
                        "content": "The problem is that `df[\\'customer_number\\'].head(1)` is returning a Series (of length 1), and the problem is expecting an int. Your code will work if you replace that with `df[\\'customer_number\\'].iloc[0]`."
                    },
                    {
                        "username": "quanghm",
                        "content": "Description **The test cases are generated so that exactly one customer will have placed more orders than any other customer.**\\nTest case:\\n```\\n| order_number | customer_number |\\n| ------------ | --------------- |\\n```\\n???"
                    },
                    {
                        "username": "ebrycez",
                        "content": "Can anyone explain why both `order by count(order_number) desc` and  `order by count(customer_number) desc` works after group by customer number?\\n"
                    },
                    {
                        "username": "clone8en",
                        "content": "Yes, I can. Count simply counts the number of non-null values in a field, that\\'s it. Not unique values. So whether you count rows with count(*), or the number of rows that don\\'t have NULL in a particular field, it\\'s the same logic. "
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "exactly i also want to know why aren\\'t we comparing order_number "
                    },
                    {
                        "username": "dafulu",
                        "content": "\"\"\"\\nselect customer_number\\nfrom orders \\ngroup by customer_number\\norder by count(customer_number) desc\\nlimit 1\\n\"\"\""
                    },
                    {
                        "username": "Fful",
                        "content": "*Task:*\\nThe test cases are **generated** so that exactly **one customer** will have placed more orders than any other customer.\\n\\n*Test_case #2:*\\n `| order_number | customer_number |`\\n`| ------------ | --------------- |`\\n\\nam i joke to you\\u2754\\u2754\\u2754\\nValueError: max() arg is an empty sequence "
                    },
                    {
                        "username": "user7071nM",
                        "content": "select customer_number from (select customer_number, row_number() over( order by count(customer_number) desc) as rn from orders group by customer_number)t\\nwhere rn=1;\\n\\nby using sub_queries"
                    }
                ]
            },
            {
                "id": 1568149,
                "content": [
                    {
                        "username": "pritiprajapati314",
                        "content": "\\tSELECT customer_number \\n\\tFROM Orders\\n\\tGROUP BY customer_number\\n\\tORDER BY COUNT(order_number) DESC\\n\\tLIMIT 1;"
                    },
                    {
                        "username": "chiratsxki",
                        "content": "thank you pritiprajapati314"
                    },
                    {
                        "username": "bhupendra786",
                        "content": "# Write your MySQL query statement below\\n\\nSELECT\\n    customer_number\\nFROM\\n    orders\\nGROUP BY customer_number\\nORDER BY COUNT(*) DESC\\nLIMIT 1"
                    },
                    {
                        "username": "aswinsureshk",
                        "content": "`SELECT customer_number FROM orders GROUP BY customer_number HAVING count(*)>=ALL(SELECT count(*) FROM orders GROUP BY customer_number);`"
                    },
                    {
                        "username": "JaswanthP",
                        "content": "with cte as(\\nselect customer_number, rank() over (order by count(customer_number) desc) rnk from Orders group by customer_number)\\nselect customer_number from cte where rnk=1"
                    },
                    {
                        "username": "Mehul1997",
                        "content": "There was no need to make it this complicated"
                    },
                    {
                        "username": "bbbbeetroot",
                        "content": "Not sure what is wrong. I get the expected output in the test case but it says wrong answer.\\n\\nHere is my code:\\n```\\nimport pandas as pd\\n\\ndef largest_orders(orders: pd.DataFrame) -> pd.DataFrame:\\n    df = orders.groupby(\\'customer_number\\').size().reset_index()\\n    df = df.sort_values(by=0, ascending=False)\\n    return pd.DataFrame(\\n        {\"customer_number\" : [df[\\'customer_number\\'].head(1)]}\\n    )\\n```\\n\\nHere is my Output for the test case:\\n```\\n| customer_number |\\n| --------------- |\\n| 3               |\\n```\\n\\nHere is the expected output\\n```\\n| customer_number |\\n| --------------- |\\n| 3               |\\n```"
                    },
                    {
                        "username": "allispaul",
                        "content": "The problem is that `df[\\'customer_number\\'].head(1)` is returning a Series (of length 1), and the problem is expecting an int. Your code will work if you replace that with `df[\\'customer_number\\'].iloc[0]`."
                    },
                    {
                        "username": "quanghm",
                        "content": "Description **The test cases are generated so that exactly one customer will have placed more orders than any other customer.**\\nTest case:\\n```\\n| order_number | customer_number |\\n| ------------ | --------------- |\\n```\\n???"
                    },
                    {
                        "username": "ebrycez",
                        "content": "Can anyone explain why both `order by count(order_number) desc` and  `order by count(customer_number) desc` works after group by customer number?\\n"
                    },
                    {
                        "username": "clone8en",
                        "content": "Yes, I can. Count simply counts the number of non-null values in a field, that\\'s it. Not unique values. So whether you count rows with count(*), or the number of rows that don\\'t have NULL in a particular field, it\\'s the same logic. "
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "exactly i also want to know why aren\\'t we comparing order_number "
                    },
                    {
                        "username": "dafulu",
                        "content": "\"\"\"\\nselect customer_number\\nfrom orders \\ngroup by customer_number\\norder by count(customer_number) desc\\nlimit 1\\n\"\"\""
                    },
                    {
                        "username": "Fful",
                        "content": "*Task:*\\nThe test cases are **generated** so that exactly **one customer** will have placed more orders than any other customer.\\n\\n*Test_case #2:*\\n `| order_number | customer_number |`\\n`| ------------ | --------------- |`\\n\\nam i joke to you\\u2754\\u2754\\u2754\\nValueError: max() arg is an empty sequence "
                    },
                    {
                        "username": "user7071nM",
                        "content": "select customer_number from (select customer_number, row_number() over( order by count(customer_number) desc) as rn from orders group by customer_number)t\\nwhere rn=1;\\n\\nby using sub_queries"
                    }
                ]
            },
            {
                "id": 1575219,
                "content": [
                    {
                        "username": "pritiprajapati314",
                        "content": "\\tSELECT customer_number \\n\\tFROM Orders\\n\\tGROUP BY customer_number\\n\\tORDER BY COUNT(order_number) DESC\\n\\tLIMIT 1;"
                    },
                    {
                        "username": "chiratsxki",
                        "content": "thank you pritiprajapati314"
                    },
                    {
                        "username": "bhupendra786",
                        "content": "# Write your MySQL query statement below\\n\\nSELECT\\n    customer_number\\nFROM\\n    orders\\nGROUP BY customer_number\\nORDER BY COUNT(*) DESC\\nLIMIT 1"
                    },
                    {
                        "username": "aswinsureshk",
                        "content": "`SELECT customer_number FROM orders GROUP BY customer_number HAVING count(*)>=ALL(SELECT count(*) FROM orders GROUP BY customer_number);`"
                    },
                    {
                        "username": "JaswanthP",
                        "content": "with cte as(\\nselect customer_number, rank() over (order by count(customer_number) desc) rnk from Orders group by customer_number)\\nselect customer_number from cte where rnk=1"
                    },
                    {
                        "username": "Mehul1997",
                        "content": "There was no need to make it this complicated"
                    },
                    {
                        "username": "bbbbeetroot",
                        "content": "Not sure what is wrong. I get the expected output in the test case but it says wrong answer.\\n\\nHere is my code:\\n```\\nimport pandas as pd\\n\\ndef largest_orders(orders: pd.DataFrame) -> pd.DataFrame:\\n    df = orders.groupby(\\'customer_number\\').size().reset_index()\\n    df = df.sort_values(by=0, ascending=False)\\n    return pd.DataFrame(\\n        {\"customer_number\" : [df[\\'customer_number\\'].head(1)]}\\n    )\\n```\\n\\nHere is my Output for the test case:\\n```\\n| customer_number |\\n| --------------- |\\n| 3               |\\n```\\n\\nHere is the expected output\\n```\\n| customer_number |\\n| --------------- |\\n| 3               |\\n```"
                    },
                    {
                        "username": "allispaul",
                        "content": "The problem is that `df[\\'customer_number\\'].head(1)` is returning a Series (of length 1), and the problem is expecting an int. Your code will work if you replace that with `df[\\'customer_number\\'].iloc[0]`."
                    },
                    {
                        "username": "quanghm",
                        "content": "Description **The test cases are generated so that exactly one customer will have placed more orders than any other customer.**\\nTest case:\\n```\\n| order_number | customer_number |\\n| ------------ | --------------- |\\n```\\n???"
                    },
                    {
                        "username": "ebrycez",
                        "content": "Can anyone explain why both `order by count(order_number) desc` and  `order by count(customer_number) desc` works after group by customer number?\\n"
                    },
                    {
                        "username": "clone8en",
                        "content": "Yes, I can. Count simply counts the number of non-null values in a field, that\\'s it. Not unique values. So whether you count rows with count(*), or the number of rows that don\\'t have NULL in a particular field, it\\'s the same logic. "
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "exactly i also want to know why aren\\'t we comparing order_number "
                    },
                    {
                        "username": "dafulu",
                        "content": "\"\"\"\\nselect customer_number\\nfrom orders \\ngroup by customer_number\\norder by count(customer_number) desc\\nlimit 1\\n\"\"\""
                    },
                    {
                        "username": "Fful",
                        "content": "*Task:*\\nThe test cases are **generated** so that exactly **one customer** will have placed more orders than any other customer.\\n\\n*Test_case #2:*\\n `| order_number | customer_number |`\\n`| ------------ | --------------- |`\\n\\nam i joke to you\\u2754\\u2754\\u2754\\nValueError: max() arg is an empty sequence "
                    },
                    {
                        "username": "user7071nM",
                        "content": "select customer_number from (select customer_number, row_number() over( order by count(customer_number) desc) as rn from orders group by customer_number)t\\nwhere rn=1;\\n\\nby using sub_queries"
                    }
                ]
            },
            {
                "id": 1997933,
                "content": [
                    {
                        "username": "pritiprajapati314",
                        "content": "\\tSELECT customer_number \\n\\tFROM Orders\\n\\tGROUP BY customer_number\\n\\tORDER BY COUNT(order_number) DESC\\n\\tLIMIT 1;"
                    },
                    {
                        "username": "chiratsxki",
                        "content": "thank you pritiprajapati314"
                    },
                    {
                        "username": "bhupendra786",
                        "content": "# Write your MySQL query statement below\\n\\nSELECT\\n    customer_number\\nFROM\\n    orders\\nGROUP BY customer_number\\nORDER BY COUNT(*) DESC\\nLIMIT 1"
                    },
                    {
                        "username": "aswinsureshk",
                        "content": "`SELECT customer_number FROM orders GROUP BY customer_number HAVING count(*)>=ALL(SELECT count(*) FROM orders GROUP BY customer_number);`"
                    },
                    {
                        "username": "JaswanthP",
                        "content": "with cte as(\\nselect customer_number, rank() over (order by count(customer_number) desc) rnk from Orders group by customer_number)\\nselect customer_number from cte where rnk=1"
                    },
                    {
                        "username": "Mehul1997",
                        "content": "There was no need to make it this complicated"
                    },
                    {
                        "username": "bbbbeetroot",
                        "content": "Not sure what is wrong. I get the expected output in the test case but it says wrong answer.\\n\\nHere is my code:\\n```\\nimport pandas as pd\\n\\ndef largest_orders(orders: pd.DataFrame) -> pd.DataFrame:\\n    df = orders.groupby(\\'customer_number\\').size().reset_index()\\n    df = df.sort_values(by=0, ascending=False)\\n    return pd.DataFrame(\\n        {\"customer_number\" : [df[\\'customer_number\\'].head(1)]}\\n    )\\n```\\n\\nHere is my Output for the test case:\\n```\\n| customer_number |\\n| --------------- |\\n| 3               |\\n```\\n\\nHere is the expected output\\n```\\n| customer_number |\\n| --------------- |\\n| 3               |\\n```"
                    },
                    {
                        "username": "allispaul",
                        "content": "The problem is that `df[\\'customer_number\\'].head(1)` is returning a Series (of length 1), and the problem is expecting an int. Your code will work if you replace that with `df[\\'customer_number\\'].iloc[0]`."
                    },
                    {
                        "username": "quanghm",
                        "content": "Description **The test cases are generated so that exactly one customer will have placed more orders than any other customer.**\\nTest case:\\n```\\n| order_number | customer_number |\\n| ------------ | --------------- |\\n```\\n???"
                    },
                    {
                        "username": "ebrycez",
                        "content": "Can anyone explain why both `order by count(order_number) desc` and  `order by count(customer_number) desc` works after group by customer number?\\n"
                    },
                    {
                        "username": "clone8en",
                        "content": "Yes, I can. Count simply counts the number of non-null values in a field, that\\'s it. Not unique values. So whether you count rows with count(*), or the number of rows that don\\'t have NULL in a particular field, it\\'s the same logic. "
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "exactly i also want to know why aren\\'t we comparing order_number "
                    },
                    {
                        "username": "dafulu",
                        "content": "\"\"\"\\nselect customer_number\\nfrom orders \\ngroup by customer_number\\norder by count(customer_number) desc\\nlimit 1\\n\"\"\""
                    },
                    {
                        "username": "Fful",
                        "content": "*Task:*\\nThe test cases are **generated** so that exactly **one customer** will have placed more orders than any other customer.\\n\\n*Test_case #2:*\\n `| order_number | customer_number |`\\n`| ------------ | --------------- |`\\n\\nam i joke to you\\u2754\\u2754\\u2754\\nValueError: max() arg is an empty sequence "
                    },
                    {
                        "username": "user7071nM",
                        "content": "select customer_number from (select customer_number, row_number() over( order by count(customer_number) desc) as rn from orders group by customer_number)t\\nwhere rn=1;\\n\\nby using sub_queries"
                    }
                ]
            },
            {
                "id": 2034708,
                "content": [
                    {
                        "username": "pritiprajapati314",
                        "content": "\\tSELECT customer_number \\n\\tFROM Orders\\n\\tGROUP BY customer_number\\n\\tORDER BY COUNT(order_number) DESC\\n\\tLIMIT 1;"
                    },
                    {
                        "username": "chiratsxki",
                        "content": "thank you pritiprajapati314"
                    },
                    {
                        "username": "bhupendra786",
                        "content": "# Write your MySQL query statement below\\n\\nSELECT\\n    customer_number\\nFROM\\n    orders\\nGROUP BY customer_number\\nORDER BY COUNT(*) DESC\\nLIMIT 1"
                    },
                    {
                        "username": "aswinsureshk",
                        "content": "`SELECT customer_number FROM orders GROUP BY customer_number HAVING count(*)>=ALL(SELECT count(*) FROM orders GROUP BY customer_number);`"
                    },
                    {
                        "username": "JaswanthP",
                        "content": "with cte as(\\nselect customer_number, rank() over (order by count(customer_number) desc) rnk from Orders group by customer_number)\\nselect customer_number from cte where rnk=1"
                    },
                    {
                        "username": "Mehul1997",
                        "content": "There was no need to make it this complicated"
                    },
                    {
                        "username": "bbbbeetroot",
                        "content": "Not sure what is wrong. I get the expected output in the test case but it says wrong answer.\\n\\nHere is my code:\\n```\\nimport pandas as pd\\n\\ndef largest_orders(orders: pd.DataFrame) -> pd.DataFrame:\\n    df = orders.groupby(\\'customer_number\\').size().reset_index()\\n    df = df.sort_values(by=0, ascending=False)\\n    return pd.DataFrame(\\n        {\"customer_number\" : [df[\\'customer_number\\'].head(1)]}\\n    )\\n```\\n\\nHere is my Output for the test case:\\n```\\n| customer_number |\\n| --------------- |\\n| 3               |\\n```\\n\\nHere is the expected output\\n```\\n| customer_number |\\n| --------------- |\\n| 3               |\\n```"
                    },
                    {
                        "username": "allispaul",
                        "content": "The problem is that `df[\\'customer_number\\'].head(1)` is returning a Series (of length 1), and the problem is expecting an int. Your code will work if you replace that with `df[\\'customer_number\\'].iloc[0]`."
                    },
                    {
                        "username": "quanghm",
                        "content": "Description **The test cases are generated so that exactly one customer will have placed more orders than any other customer.**\\nTest case:\\n```\\n| order_number | customer_number |\\n| ------------ | --------------- |\\n```\\n???"
                    },
                    {
                        "username": "ebrycez",
                        "content": "Can anyone explain why both `order by count(order_number) desc` and  `order by count(customer_number) desc` works after group by customer number?\\n"
                    },
                    {
                        "username": "clone8en",
                        "content": "Yes, I can. Count simply counts the number of non-null values in a field, that\\'s it. Not unique values. So whether you count rows with count(*), or the number of rows that don\\'t have NULL in a particular field, it\\'s the same logic. "
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "exactly i also want to know why aren\\'t we comparing order_number "
                    },
                    {
                        "username": "dafulu",
                        "content": "\"\"\"\\nselect customer_number\\nfrom orders \\ngroup by customer_number\\norder by count(customer_number) desc\\nlimit 1\\n\"\"\""
                    },
                    {
                        "username": "Fful",
                        "content": "*Task:*\\nThe test cases are **generated** so that exactly **one customer** will have placed more orders than any other customer.\\n\\n*Test_case #2:*\\n `| order_number | customer_number |`\\n`| ------------ | --------------- |`\\n\\nam i joke to you\\u2754\\u2754\\u2754\\nValueError: max() arg is an empty sequence "
                    },
                    {
                        "username": "user7071nM",
                        "content": "select customer_number from (select customer_number, row_number() over( order by count(customer_number) desc) as rn from orders group by customer_number)t\\nwhere rn=1;\\n\\nby using sub_queries"
                    }
                ]
            },
            {
                "id": 1760915,
                "content": [
                    {
                        "username": "pritiprajapati314",
                        "content": "\\tSELECT customer_number \\n\\tFROM Orders\\n\\tGROUP BY customer_number\\n\\tORDER BY COUNT(order_number) DESC\\n\\tLIMIT 1;"
                    },
                    {
                        "username": "chiratsxki",
                        "content": "thank you pritiprajapati314"
                    },
                    {
                        "username": "bhupendra786",
                        "content": "# Write your MySQL query statement below\\n\\nSELECT\\n    customer_number\\nFROM\\n    orders\\nGROUP BY customer_number\\nORDER BY COUNT(*) DESC\\nLIMIT 1"
                    },
                    {
                        "username": "aswinsureshk",
                        "content": "`SELECT customer_number FROM orders GROUP BY customer_number HAVING count(*)>=ALL(SELECT count(*) FROM orders GROUP BY customer_number);`"
                    },
                    {
                        "username": "JaswanthP",
                        "content": "with cte as(\\nselect customer_number, rank() over (order by count(customer_number) desc) rnk from Orders group by customer_number)\\nselect customer_number from cte where rnk=1"
                    },
                    {
                        "username": "Mehul1997",
                        "content": "There was no need to make it this complicated"
                    },
                    {
                        "username": "bbbbeetroot",
                        "content": "Not sure what is wrong. I get the expected output in the test case but it says wrong answer.\\n\\nHere is my code:\\n```\\nimport pandas as pd\\n\\ndef largest_orders(orders: pd.DataFrame) -> pd.DataFrame:\\n    df = orders.groupby(\\'customer_number\\').size().reset_index()\\n    df = df.sort_values(by=0, ascending=False)\\n    return pd.DataFrame(\\n        {\"customer_number\" : [df[\\'customer_number\\'].head(1)]}\\n    )\\n```\\n\\nHere is my Output for the test case:\\n```\\n| customer_number |\\n| --------------- |\\n| 3               |\\n```\\n\\nHere is the expected output\\n```\\n| customer_number |\\n| --------------- |\\n| 3               |\\n```"
                    },
                    {
                        "username": "allispaul",
                        "content": "The problem is that `df[\\'customer_number\\'].head(1)` is returning a Series (of length 1), and the problem is expecting an int. Your code will work if you replace that with `df[\\'customer_number\\'].iloc[0]`."
                    },
                    {
                        "username": "quanghm",
                        "content": "Description **The test cases are generated so that exactly one customer will have placed more orders than any other customer.**\\nTest case:\\n```\\n| order_number | customer_number |\\n| ------------ | --------------- |\\n```\\n???"
                    },
                    {
                        "username": "ebrycez",
                        "content": "Can anyone explain why both `order by count(order_number) desc` and  `order by count(customer_number) desc` works after group by customer number?\\n"
                    },
                    {
                        "username": "clone8en",
                        "content": "Yes, I can. Count simply counts the number of non-null values in a field, that\\'s it. Not unique values. So whether you count rows with count(*), or the number of rows that don\\'t have NULL in a particular field, it\\'s the same logic. "
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "exactly i also want to know why aren\\'t we comparing order_number "
                    },
                    {
                        "username": "dafulu",
                        "content": "\"\"\"\\nselect customer_number\\nfrom orders \\ngroup by customer_number\\norder by count(customer_number) desc\\nlimit 1\\n\"\"\""
                    },
                    {
                        "username": "Fful",
                        "content": "*Task:*\\nThe test cases are **generated** so that exactly **one customer** will have placed more orders than any other customer.\\n\\n*Test_case #2:*\\n `| order_number | customer_number |`\\n`| ------------ | --------------- |`\\n\\nam i joke to you\\u2754\\u2754\\u2754\\nValueError: max() arg is an empty sequence "
                    },
                    {
                        "username": "user7071nM",
                        "content": "select customer_number from (select customer_number, row_number() over( order by count(customer_number) desc) as rn from orders group by customer_number)t\\nwhere rn=1;\\n\\nby using sub_queries"
                    }
                ]
            },
            {
                "id": 1569633,
                "content": [
                    {
                        "username": "pritiprajapati314",
                        "content": "\\tSELECT customer_number \\n\\tFROM Orders\\n\\tGROUP BY customer_number\\n\\tORDER BY COUNT(order_number) DESC\\n\\tLIMIT 1;"
                    },
                    {
                        "username": "chiratsxki",
                        "content": "thank you pritiprajapati314"
                    },
                    {
                        "username": "bhupendra786",
                        "content": "# Write your MySQL query statement below\\n\\nSELECT\\n    customer_number\\nFROM\\n    orders\\nGROUP BY customer_number\\nORDER BY COUNT(*) DESC\\nLIMIT 1"
                    },
                    {
                        "username": "aswinsureshk",
                        "content": "`SELECT customer_number FROM orders GROUP BY customer_number HAVING count(*)>=ALL(SELECT count(*) FROM orders GROUP BY customer_number);`"
                    },
                    {
                        "username": "JaswanthP",
                        "content": "with cte as(\\nselect customer_number, rank() over (order by count(customer_number) desc) rnk from Orders group by customer_number)\\nselect customer_number from cte where rnk=1"
                    },
                    {
                        "username": "Mehul1997",
                        "content": "There was no need to make it this complicated"
                    },
                    {
                        "username": "bbbbeetroot",
                        "content": "Not sure what is wrong. I get the expected output in the test case but it says wrong answer.\\n\\nHere is my code:\\n```\\nimport pandas as pd\\n\\ndef largest_orders(orders: pd.DataFrame) -> pd.DataFrame:\\n    df = orders.groupby(\\'customer_number\\').size().reset_index()\\n    df = df.sort_values(by=0, ascending=False)\\n    return pd.DataFrame(\\n        {\"customer_number\" : [df[\\'customer_number\\'].head(1)]}\\n    )\\n```\\n\\nHere is my Output for the test case:\\n```\\n| customer_number |\\n| --------------- |\\n| 3               |\\n```\\n\\nHere is the expected output\\n```\\n| customer_number |\\n| --------------- |\\n| 3               |\\n```"
                    },
                    {
                        "username": "allispaul",
                        "content": "The problem is that `df[\\'customer_number\\'].head(1)` is returning a Series (of length 1), and the problem is expecting an int. Your code will work if you replace that with `df[\\'customer_number\\'].iloc[0]`."
                    },
                    {
                        "username": "quanghm",
                        "content": "Description **The test cases are generated so that exactly one customer will have placed more orders than any other customer.**\\nTest case:\\n```\\n| order_number | customer_number |\\n| ------------ | --------------- |\\n```\\n???"
                    },
                    {
                        "username": "ebrycez",
                        "content": "Can anyone explain why both `order by count(order_number) desc` and  `order by count(customer_number) desc` works after group by customer number?\\n"
                    },
                    {
                        "username": "clone8en",
                        "content": "Yes, I can. Count simply counts the number of non-null values in a field, that\\'s it. Not unique values. So whether you count rows with count(*), or the number of rows that don\\'t have NULL in a particular field, it\\'s the same logic. "
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "exactly i also want to know why aren\\'t we comparing order_number "
                    },
                    {
                        "username": "dafulu",
                        "content": "\"\"\"\\nselect customer_number\\nfrom orders \\ngroup by customer_number\\norder by count(customer_number) desc\\nlimit 1\\n\"\"\""
                    },
                    {
                        "username": "Fful",
                        "content": "*Task:*\\nThe test cases are **generated** so that exactly **one customer** will have placed more orders than any other customer.\\n\\n*Test_case #2:*\\n `| order_number | customer_number |`\\n`| ------------ | --------------- |`\\n\\nam i joke to you\\u2754\\u2754\\u2754\\nValueError: max() arg is an empty sequence "
                    },
                    {
                        "username": "user7071nM",
                        "content": "select customer_number from (select customer_number, row_number() over( order by count(customer_number) desc) as rn from orders group by customer_number)t\\nwhere rn=1;\\n\\nby using sub_queries"
                    }
                ]
            },
            {
                "id": 2025247,
                "content": [
                    {
                        "username": "pritiprajapati314",
                        "content": "\\tSELECT customer_number \\n\\tFROM Orders\\n\\tGROUP BY customer_number\\n\\tORDER BY COUNT(order_number) DESC\\n\\tLIMIT 1;"
                    },
                    {
                        "username": "chiratsxki",
                        "content": "thank you pritiprajapati314"
                    },
                    {
                        "username": "bhupendra786",
                        "content": "# Write your MySQL query statement below\\n\\nSELECT\\n    customer_number\\nFROM\\n    orders\\nGROUP BY customer_number\\nORDER BY COUNT(*) DESC\\nLIMIT 1"
                    },
                    {
                        "username": "aswinsureshk",
                        "content": "`SELECT customer_number FROM orders GROUP BY customer_number HAVING count(*)>=ALL(SELECT count(*) FROM orders GROUP BY customer_number);`"
                    },
                    {
                        "username": "JaswanthP",
                        "content": "with cte as(\\nselect customer_number, rank() over (order by count(customer_number) desc) rnk from Orders group by customer_number)\\nselect customer_number from cte where rnk=1"
                    },
                    {
                        "username": "Mehul1997",
                        "content": "There was no need to make it this complicated"
                    },
                    {
                        "username": "bbbbeetroot",
                        "content": "Not sure what is wrong. I get the expected output in the test case but it says wrong answer.\\n\\nHere is my code:\\n```\\nimport pandas as pd\\n\\ndef largest_orders(orders: pd.DataFrame) -> pd.DataFrame:\\n    df = orders.groupby(\\'customer_number\\').size().reset_index()\\n    df = df.sort_values(by=0, ascending=False)\\n    return pd.DataFrame(\\n        {\"customer_number\" : [df[\\'customer_number\\'].head(1)]}\\n    )\\n```\\n\\nHere is my Output for the test case:\\n```\\n| customer_number |\\n| --------------- |\\n| 3               |\\n```\\n\\nHere is the expected output\\n```\\n| customer_number |\\n| --------------- |\\n| 3               |\\n```"
                    },
                    {
                        "username": "allispaul",
                        "content": "The problem is that `df[\\'customer_number\\'].head(1)` is returning a Series (of length 1), and the problem is expecting an int. Your code will work if you replace that with `df[\\'customer_number\\'].iloc[0]`."
                    },
                    {
                        "username": "quanghm",
                        "content": "Description **The test cases are generated so that exactly one customer will have placed more orders than any other customer.**\\nTest case:\\n```\\n| order_number | customer_number |\\n| ------------ | --------------- |\\n```\\n???"
                    },
                    {
                        "username": "ebrycez",
                        "content": "Can anyone explain why both `order by count(order_number) desc` and  `order by count(customer_number) desc` works after group by customer number?\\n"
                    },
                    {
                        "username": "clone8en",
                        "content": "Yes, I can. Count simply counts the number of non-null values in a field, that\\'s it. Not unique values. So whether you count rows with count(*), or the number of rows that don\\'t have NULL in a particular field, it\\'s the same logic. "
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "exactly i also want to know why aren\\'t we comparing order_number "
                    },
                    {
                        "username": "dafulu",
                        "content": "\"\"\"\\nselect customer_number\\nfrom orders \\ngroup by customer_number\\norder by count(customer_number) desc\\nlimit 1\\n\"\"\""
                    },
                    {
                        "username": "Fful",
                        "content": "*Task:*\\nThe test cases are **generated** so that exactly **one customer** will have placed more orders than any other customer.\\n\\n*Test_case #2:*\\n `| order_number | customer_number |`\\n`| ------------ | --------------- |`\\n\\nam i joke to you\\u2754\\u2754\\u2754\\nValueError: max() arg is an empty sequence "
                    },
                    {
                        "username": "user7071nM",
                        "content": "select customer_number from (select customer_number, row_number() over( order by count(customer_number) desc) as rn from orders group by customer_number)t\\nwhere rn=1;\\n\\nby using sub_queries"
                    }
                ]
            },
            {
                "id": 1692985,
                "content": [
                    {
                        "username": "pritiprajapati314",
                        "content": "\\tSELECT customer_number \\n\\tFROM Orders\\n\\tGROUP BY customer_number\\n\\tORDER BY COUNT(order_number) DESC\\n\\tLIMIT 1;"
                    },
                    {
                        "username": "chiratsxki",
                        "content": "thank you pritiprajapati314"
                    },
                    {
                        "username": "bhupendra786",
                        "content": "# Write your MySQL query statement below\\n\\nSELECT\\n    customer_number\\nFROM\\n    orders\\nGROUP BY customer_number\\nORDER BY COUNT(*) DESC\\nLIMIT 1"
                    },
                    {
                        "username": "aswinsureshk",
                        "content": "`SELECT customer_number FROM orders GROUP BY customer_number HAVING count(*)>=ALL(SELECT count(*) FROM orders GROUP BY customer_number);`"
                    },
                    {
                        "username": "JaswanthP",
                        "content": "with cte as(\\nselect customer_number, rank() over (order by count(customer_number) desc) rnk from Orders group by customer_number)\\nselect customer_number from cte where rnk=1"
                    },
                    {
                        "username": "Mehul1997",
                        "content": "There was no need to make it this complicated"
                    },
                    {
                        "username": "bbbbeetroot",
                        "content": "Not sure what is wrong. I get the expected output in the test case but it says wrong answer.\\n\\nHere is my code:\\n```\\nimport pandas as pd\\n\\ndef largest_orders(orders: pd.DataFrame) -> pd.DataFrame:\\n    df = orders.groupby(\\'customer_number\\').size().reset_index()\\n    df = df.sort_values(by=0, ascending=False)\\n    return pd.DataFrame(\\n        {\"customer_number\" : [df[\\'customer_number\\'].head(1)]}\\n    )\\n```\\n\\nHere is my Output for the test case:\\n```\\n| customer_number |\\n| --------------- |\\n| 3               |\\n```\\n\\nHere is the expected output\\n```\\n| customer_number |\\n| --------------- |\\n| 3               |\\n```"
                    },
                    {
                        "username": "allispaul",
                        "content": "The problem is that `df[\\'customer_number\\'].head(1)` is returning a Series (of length 1), and the problem is expecting an int. Your code will work if you replace that with `df[\\'customer_number\\'].iloc[0]`."
                    },
                    {
                        "username": "quanghm",
                        "content": "Description **The test cases are generated so that exactly one customer will have placed more orders than any other customer.**\\nTest case:\\n```\\n| order_number | customer_number |\\n| ------------ | --------------- |\\n```\\n???"
                    },
                    {
                        "username": "ebrycez",
                        "content": "Can anyone explain why both `order by count(order_number) desc` and  `order by count(customer_number) desc` works after group by customer number?\\n"
                    },
                    {
                        "username": "clone8en",
                        "content": "Yes, I can. Count simply counts the number of non-null values in a field, that\\'s it. Not unique values. So whether you count rows with count(*), or the number of rows that don\\'t have NULL in a particular field, it\\'s the same logic. "
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "exactly i also want to know why aren\\'t we comparing order_number "
                    },
                    {
                        "username": "dafulu",
                        "content": "\"\"\"\\nselect customer_number\\nfrom orders \\ngroup by customer_number\\norder by count(customer_number) desc\\nlimit 1\\n\"\"\""
                    },
                    {
                        "username": "Fful",
                        "content": "*Task:*\\nThe test cases are **generated** so that exactly **one customer** will have placed more orders than any other customer.\\n\\n*Test_case #2:*\\n `| order_number | customer_number |`\\n`| ------------ | --------------- |`\\n\\nam i joke to you\\u2754\\u2754\\u2754\\nValueError: max() arg is an empty sequence "
                    },
                    {
                        "username": "user7071nM",
                        "content": "select customer_number from (select customer_number, row_number() over( order by count(customer_number) desc) as rn from orders group by customer_number)t\\nwhere rn=1;\\n\\nby using sub_queries"
                    }
                ]
            },
            {
                "id": 1570852,
                "content": [
                    {
                        "username": "pritiprajapati314",
                        "content": "\\tSELECT customer_number \\n\\tFROM Orders\\n\\tGROUP BY customer_number\\n\\tORDER BY COUNT(order_number) DESC\\n\\tLIMIT 1;"
                    },
                    {
                        "username": "chiratsxki",
                        "content": "thank you pritiprajapati314"
                    },
                    {
                        "username": "bhupendra786",
                        "content": "# Write your MySQL query statement below\\n\\nSELECT\\n    customer_number\\nFROM\\n    orders\\nGROUP BY customer_number\\nORDER BY COUNT(*) DESC\\nLIMIT 1"
                    },
                    {
                        "username": "aswinsureshk",
                        "content": "`SELECT customer_number FROM orders GROUP BY customer_number HAVING count(*)>=ALL(SELECT count(*) FROM orders GROUP BY customer_number);`"
                    },
                    {
                        "username": "JaswanthP",
                        "content": "with cte as(\\nselect customer_number, rank() over (order by count(customer_number) desc) rnk from Orders group by customer_number)\\nselect customer_number from cte where rnk=1"
                    },
                    {
                        "username": "Mehul1997",
                        "content": "There was no need to make it this complicated"
                    },
                    {
                        "username": "bbbbeetroot",
                        "content": "Not sure what is wrong. I get the expected output in the test case but it says wrong answer.\\n\\nHere is my code:\\n```\\nimport pandas as pd\\n\\ndef largest_orders(orders: pd.DataFrame) -> pd.DataFrame:\\n    df = orders.groupby(\\'customer_number\\').size().reset_index()\\n    df = df.sort_values(by=0, ascending=False)\\n    return pd.DataFrame(\\n        {\"customer_number\" : [df[\\'customer_number\\'].head(1)]}\\n    )\\n```\\n\\nHere is my Output for the test case:\\n```\\n| customer_number |\\n| --------------- |\\n| 3               |\\n```\\n\\nHere is the expected output\\n```\\n| customer_number |\\n| --------------- |\\n| 3               |\\n```"
                    },
                    {
                        "username": "allispaul",
                        "content": "The problem is that `df[\\'customer_number\\'].head(1)` is returning a Series (of length 1), and the problem is expecting an int. Your code will work if you replace that with `df[\\'customer_number\\'].iloc[0]`."
                    },
                    {
                        "username": "quanghm",
                        "content": "Description **The test cases are generated so that exactly one customer will have placed more orders than any other customer.**\\nTest case:\\n```\\n| order_number | customer_number |\\n| ------------ | --------------- |\\n```\\n???"
                    },
                    {
                        "username": "ebrycez",
                        "content": "Can anyone explain why both `order by count(order_number) desc` and  `order by count(customer_number) desc` works after group by customer number?\\n"
                    },
                    {
                        "username": "clone8en",
                        "content": "Yes, I can. Count simply counts the number of non-null values in a field, that\\'s it. Not unique values. So whether you count rows with count(*), or the number of rows that don\\'t have NULL in a particular field, it\\'s the same logic. "
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "exactly i also want to know why aren\\'t we comparing order_number "
                    },
                    {
                        "username": "dafulu",
                        "content": "\"\"\"\\nselect customer_number\\nfrom orders \\ngroup by customer_number\\norder by count(customer_number) desc\\nlimit 1\\n\"\"\""
                    },
                    {
                        "username": "Fful",
                        "content": "*Task:*\\nThe test cases are **generated** so that exactly **one customer** will have placed more orders than any other customer.\\n\\n*Test_case #2:*\\n `| order_number | customer_number |`\\n`| ------------ | --------------- |`\\n\\nam i joke to you\\u2754\\u2754\\u2754\\nValueError: max() arg is an empty sequence "
                    },
                    {
                        "username": "user7071nM",
                        "content": "select customer_number from (select customer_number, row_number() over( order by count(customer_number) desc) as rn from orders group by customer_number)t\\nwhere rn=1;\\n\\nby using sub_queries"
                    }
                ]
            },
            {
                "id": 1570827,
                "content": [
                    {
                        "username": "pritiprajapati314",
                        "content": "\\tSELECT customer_number \\n\\tFROM Orders\\n\\tGROUP BY customer_number\\n\\tORDER BY COUNT(order_number) DESC\\n\\tLIMIT 1;"
                    },
                    {
                        "username": "chiratsxki",
                        "content": "thank you pritiprajapati314"
                    },
                    {
                        "username": "bhupendra786",
                        "content": "# Write your MySQL query statement below\\n\\nSELECT\\n    customer_number\\nFROM\\n    orders\\nGROUP BY customer_number\\nORDER BY COUNT(*) DESC\\nLIMIT 1"
                    },
                    {
                        "username": "aswinsureshk",
                        "content": "`SELECT customer_number FROM orders GROUP BY customer_number HAVING count(*)>=ALL(SELECT count(*) FROM orders GROUP BY customer_number);`"
                    },
                    {
                        "username": "JaswanthP",
                        "content": "with cte as(\\nselect customer_number, rank() over (order by count(customer_number) desc) rnk from Orders group by customer_number)\\nselect customer_number from cte where rnk=1"
                    },
                    {
                        "username": "Mehul1997",
                        "content": "There was no need to make it this complicated"
                    },
                    {
                        "username": "bbbbeetroot",
                        "content": "Not sure what is wrong. I get the expected output in the test case but it says wrong answer.\\n\\nHere is my code:\\n```\\nimport pandas as pd\\n\\ndef largest_orders(orders: pd.DataFrame) -> pd.DataFrame:\\n    df = orders.groupby(\\'customer_number\\').size().reset_index()\\n    df = df.sort_values(by=0, ascending=False)\\n    return pd.DataFrame(\\n        {\"customer_number\" : [df[\\'customer_number\\'].head(1)]}\\n    )\\n```\\n\\nHere is my Output for the test case:\\n```\\n| customer_number |\\n| --------------- |\\n| 3               |\\n```\\n\\nHere is the expected output\\n```\\n| customer_number |\\n| --------------- |\\n| 3               |\\n```"
                    },
                    {
                        "username": "allispaul",
                        "content": "The problem is that `df[\\'customer_number\\'].head(1)` is returning a Series (of length 1), and the problem is expecting an int. Your code will work if you replace that with `df[\\'customer_number\\'].iloc[0]`."
                    },
                    {
                        "username": "quanghm",
                        "content": "Description **The test cases are generated so that exactly one customer will have placed more orders than any other customer.**\\nTest case:\\n```\\n| order_number | customer_number |\\n| ------------ | --------------- |\\n```\\n???"
                    },
                    {
                        "username": "ebrycez",
                        "content": "Can anyone explain why both `order by count(order_number) desc` and  `order by count(customer_number) desc` works after group by customer number?\\n"
                    },
                    {
                        "username": "clone8en",
                        "content": "Yes, I can. Count simply counts the number of non-null values in a field, that\\'s it. Not unique values. So whether you count rows with count(*), or the number of rows that don\\'t have NULL in a particular field, it\\'s the same logic. "
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "exactly i also want to know why aren\\'t we comparing order_number "
                    },
                    {
                        "username": "dafulu",
                        "content": "\"\"\"\\nselect customer_number\\nfrom orders \\ngroup by customer_number\\norder by count(customer_number) desc\\nlimit 1\\n\"\"\""
                    },
                    {
                        "username": "Fful",
                        "content": "*Task:*\\nThe test cases are **generated** so that exactly **one customer** will have placed more orders than any other customer.\\n\\n*Test_case #2:*\\n `| order_number | customer_number |`\\n`| ------------ | --------------- |`\\n\\nam i joke to you\\u2754\\u2754\\u2754\\nValueError: max() arg is an empty sequence "
                    },
                    {
                        "username": "user7071nM",
                        "content": "select customer_number from (select customer_number, row_number() over( order by count(customer_number) desc) as rn from orders group by customer_number)t\\nwhere rn=1;\\n\\nby using sub_queries"
                    }
                ]
            },
            {
                "id": 1568149,
                "content": [
                    {
                        "username": "pritiprajapati314",
                        "content": "\\tSELECT customer_number \\n\\tFROM Orders\\n\\tGROUP BY customer_number\\n\\tORDER BY COUNT(order_number) DESC\\n\\tLIMIT 1;"
                    },
                    {
                        "username": "chiratsxki",
                        "content": "thank you pritiprajapati314"
                    },
                    {
                        "username": "bhupendra786",
                        "content": "# Write your MySQL query statement below\\n\\nSELECT\\n    customer_number\\nFROM\\n    orders\\nGROUP BY customer_number\\nORDER BY COUNT(*) DESC\\nLIMIT 1"
                    },
                    {
                        "username": "aswinsureshk",
                        "content": "`SELECT customer_number FROM orders GROUP BY customer_number HAVING count(*)>=ALL(SELECT count(*) FROM orders GROUP BY customer_number);`"
                    },
                    {
                        "username": "JaswanthP",
                        "content": "with cte as(\\nselect customer_number, rank() over (order by count(customer_number) desc) rnk from Orders group by customer_number)\\nselect customer_number from cte where rnk=1"
                    },
                    {
                        "username": "Mehul1997",
                        "content": "There was no need to make it this complicated"
                    },
                    {
                        "username": "bbbbeetroot",
                        "content": "Not sure what is wrong. I get the expected output in the test case but it says wrong answer.\\n\\nHere is my code:\\n```\\nimport pandas as pd\\n\\ndef largest_orders(orders: pd.DataFrame) -> pd.DataFrame:\\n    df = orders.groupby(\\'customer_number\\').size().reset_index()\\n    df = df.sort_values(by=0, ascending=False)\\n    return pd.DataFrame(\\n        {\"customer_number\" : [df[\\'customer_number\\'].head(1)]}\\n    )\\n```\\n\\nHere is my Output for the test case:\\n```\\n| customer_number |\\n| --------------- |\\n| 3               |\\n```\\n\\nHere is the expected output\\n```\\n| customer_number |\\n| --------------- |\\n| 3               |\\n```"
                    },
                    {
                        "username": "allispaul",
                        "content": "The problem is that `df[\\'customer_number\\'].head(1)` is returning a Series (of length 1), and the problem is expecting an int. Your code will work if you replace that with `df[\\'customer_number\\'].iloc[0]`."
                    },
                    {
                        "username": "quanghm",
                        "content": "Description **The test cases are generated so that exactly one customer will have placed more orders than any other customer.**\\nTest case:\\n```\\n| order_number | customer_number |\\n| ------------ | --------------- |\\n```\\n???"
                    },
                    {
                        "username": "ebrycez",
                        "content": "Can anyone explain why both `order by count(order_number) desc` and  `order by count(customer_number) desc` works after group by customer number?\\n"
                    },
                    {
                        "username": "clone8en",
                        "content": "Yes, I can. Count simply counts the number of non-null values in a field, that\\'s it. Not unique values. So whether you count rows with count(*), or the number of rows that don\\'t have NULL in a particular field, it\\'s the same logic. "
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "exactly i also want to know why aren\\'t we comparing order_number "
                    },
                    {
                        "username": "dafulu",
                        "content": "\"\"\"\\nselect customer_number\\nfrom orders \\ngroup by customer_number\\norder by count(customer_number) desc\\nlimit 1\\n\"\"\""
                    },
                    {
                        "username": "Fful",
                        "content": "*Task:*\\nThe test cases are **generated** so that exactly **one customer** will have placed more orders than any other customer.\\n\\n*Test_case #2:*\\n `| order_number | customer_number |`\\n`| ------------ | --------------- |`\\n\\nam i joke to you\\u2754\\u2754\\u2754\\nValueError: max() arg is an empty sequence "
                    },
                    {
                        "username": "user7071nM",
                        "content": "select customer_number from (select customer_number, row_number() over( order by count(customer_number) desc) as rn from orders group by customer_number)t\\nwhere rn=1;\\n\\nby using sub_queries"
                    }
                ]
            },
            {
                "id": 1575219,
                "content": [
                    {
                        "username": "pritiprajapati314",
                        "content": "\\tSELECT customer_number \\n\\tFROM Orders\\n\\tGROUP BY customer_number\\n\\tORDER BY COUNT(order_number) DESC\\n\\tLIMIT 1;"
                    },
                    {
                        "username": "chiratsxki",
                        "content": "thank you pritiprajapati314"
                    },
                    {
                        "username": "bhupendra786",
                        "content": "# Write your MySQL query statement below\\n\\nSELECT\\n    customer_number\\nFROM\\n    orders\\nGROUP BY customer_number\\nORDER BY COUNT(*) DESC\\nLIMIT 1"
                    },
                    {
                        "username": "aswinsureshk",
                        "content": "`SELECT customer_number FROM orders GROUP BY customer_number HAVING count(*)>=ALL(SELECT count(*) FROM orders GROUP BY customer_number);`"
                    },
                    {
                        "username": "JaswanthP",
                        "content": "with cte as(\\nselect customer_number, rank() over (order by count(customer_number) desc) rnk from Orders group by customer_number)\\nselect customer_number from cte where rnk=1"
                    },
                    {
                        "username": "Mehul1997",
                        "content": "There was no need to make it this complicated"
                    },
                    {
                        "username": "bbbbeetroot",
                        "content": "Not sure what is wrong. I get the expected output in the test case but it says wrong answer.\\n\\nHere is my code:\\n```\\nimport pandas as pd\\n\\ndef largest_orders(orders: pd.DataFrame) -> pd.DataFrame:\\n    df = orders.groupby(\\'customer_number\\').size().reset_index()\\n    df = df.sort_values(by=0, ascending=False)\\n    return pd.DataFrame(\\n        {\"customer_number\" : [df[\\'customer_number\\'].head(1)]}\\n    )\\n```\\n\\nHere is my Output for the test case:\\n```\\n| customer_number |\\n| --------------- |\\n| 3               |\\n```\\n\\nHere is the expected output\\n```\\n| customer_number |\\n| --------------- |\\n| 3               |\\n```"
                    },
                    {
                        "username": "allispaul",
                        "content": "The problem is that `df[\\'customer_number\\'].head(1)` is returning a Series (of length 1), and the problem is expecting an int. Your code will work if you replace that with `df[\\'customer_number\\'].iloc[0]`."
                    },
                    {
                        "username": "quanghm",
                        "content": "Description **The test cases are generated so that exactly one customer will have placed more orders than any other customer.**\\nTest case:\\n```\\n| order_number | customer_number |\\n| ------------ | --------------- |\\n```\\n???"
                    },
                    {
                        "username": "ebrycez",
                        "content": "Can anyone explain why both `order by count(order_number) desc` and  `order by count(customer_number) desc` works after group by customer number?\\n"
                    },
                    {
                        "username": "clone8en",
                        "content": "Yes, I can. Count simply counts the number of non-null values in a field, that\\'s it. Not unique values. So whether you count rows with count(*), or the number of rows that don\\'t have NULL in a particular field, it\\'s the same logic. "
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "exactly i also want to know why aren\\'t we comparing order_number "
                    },
                    {
                        "username": "dafulu",
                        "content": "\"\"\"\\nselect customer_number\\nfrom orders \\ngroup by customer_number\\norder by count(customer_number) desc\\nlimit 1\\n\"\"\""
                    },
                    {
                        "username": "Fful",
                        "content": "*Task:*\\nThe test cases are **generated** so that exactly **one customer** will have placed more orders than any other customer.\\n\\n*Test_case #2:*\\n `| order_number | customer_number |`\\n`| ------------ | --------------- |`\\n\\nam i joke to you\\u2754\\u2754\\u2754\\nValueError: max() arg is an empty sequence "
                    },
                    {
                        "username": "user7071nM",
                        "content": "select customer_number from (select customer_number, row_number() over( order by count(customer_number) desc) as rn from orders group by customer_number)t\\nwhere rn=1;\\n\\nby using sub_queries"
                    }
                ]
            },
            {
                "id": 1997933,
                "content": [
                    {
                        "username": "pritiprajapati314",
                        "content": "\\tSELECT customer_number \\n\\tFROM Orders\\n\\tGROUP BY customer_number\\n\\tORDER BY COUNT(order_number) DESC\\n\\tLIMIT 1;"
                    },
                    {
                        "username": "chiratsxki",
                        "content": "thank you pritiprajapati314"
                    },
                    {
                        "username": "bhupendra786",
                        "content": "# Write your MySQL query statement below\\n\\nSELECT\\n    customer_number\\nFROM\\n    orders\\nGROUP BY customer_number\\nORDER BY COUNT(*) DESC\\nLIMIT 1"
                    },
                    {
                        "username": "aswinsureshk",
                        "content": "`SELECT customer_number FROM orders GROUP BY customer_number HAVING count(*)>=ALL(SELECT count(*) FROM orders GROUP BY customer_number);`"
                    },
                    {
                        "username": "JaswanthP",
                        "content": "with cte as(\\nselect customer_number, rank() over (order by count(customer_number) desc) rnk from Orders group by customer_number)\\nselect customer_number from cte where rnk=1"
                    },
                    {
                        "username": "Mehul1997",
                        "content": "There was no need to make it this complicated"
                    },
                    {
                        "username": "bbbbeetroot",
                        "content": "Not sure what is wrong. I get the expected output in the test case but it says wrong answer.\\n\\nHere is my code:\\n```\\nimport pandas as pd\\n\\ndef largest_orders(orders: pd.DataFrame) -> pd.DataFrame:\\n    df = orders.groupby(\\'customer_number\\').size().reset_index()\\n    df = df.sort_values(by=0, ascending=False)\\n    return pd.DataFrame(\\n        {\"customer_number\" : [df[\\'customer_number\\'].head(1)]}\\n    )\\n```\\n\\nHere is my Output for the test case:\\n```\\n| customer_number |\\n| --------------- |\\n| 3               |\\n```\\n\\nHere is the expected output\\n```\\n| customer_number |\\n| --------------- |\\n| 3               |\\n```"
                    },
                    {
                        "username": "allispaul",
                        "content": "The problem is that `df[\\'customer_number\\'].head(1)` is returning a Series (of length 1), and the problem is expecting an int. Your code will work if you replace that with `df[\\'customer_number\\'].iloc[0]`."
                    },
                    {
                        "username": "quanghm",
                        "content": "Description **The test cases are generated so that exactly one customer will have placed more orders than any other customer.**\\nTest case:\\n```\\n| order_number | customer_number |\\n| ------------ | --------------- |\\n```\\n???"
                    },
                    {
                        "username": "ebrycez",
                        "content": "Can anyone explain why both `order by count(order_number) desc` and  `order by count(customer_number) desc` works after group by customer number?\\n"
                    },
                    {
                        "username": "clone8en",
                        "content": "Yes, I can. Count simply counts the number of non-null values in a field, that\\'s it. Not unique values. So whether you count rows with count(*), or the number of rows that don\\'t have NULL in a particular field, it\\'s the same logic. "
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "exactly i also want to know why aren\\'t we comparing order_number "
                    },
                    {
                        "username": "dafulu",
                        "content": "\"\"\"\\nselect customer_number\\nfrom orders \\ngroup by customer_number\\norder by count(customer_number) desc\\nlimit 1\\n\"\"\""
                    },
                    {
                        "username": "Fful",
                        "content": "*Task:*\\nThe test cases are **generated** so that exactly **one customer** will have placed more orders than any other customer.\\n\\n*Test_case #2:*\\n `| order_number | customer_number |`\\n`| ------------ | --------------- |`\\n\\nam i joke to you\\u2754\\u2754\\u2754\\nValueError: max() arg is an empty sequence "
                    },
                    {
                        "username": "user7071nM",
                        "content": "select customer_number from (select customer_number, row_number() over( order by count(customer_number) desc) as rn from orders group by customer_number)t\\nwhere rn=1;\\n\\nby using sub_queries"
                    }
                ]
            },
            {
                "id": 2034708,
                "content": [
                    {
                        "username": "pritiprajapati314",
                        "content": "\\tSELECT customer_number \\n\\tFROM Orders\\n\\tGROUP BY customer_number\\n\\tORDER BY COUNT(order_number) DESC\\n\\tLIMIT 1;"
                    },
                    {
                        "username": "chiratsxki",
                        "content": "thank you pritiprajapati314"
                    },
                    {
                        "username": "bhupendra786",
                        "content": "# Write your MySQL query statement below\\n\\nSELECT\\n    customer_number\\nFROM\\n    orders\\nGROUP BY customer_number\\nORDER BY COUNT(*) DESC\\nLIMIT 1"
                    },
                    {
                        "username": "aswinsureshk",
                        "content": "`SELECT customer_number FROM orders GROUP BY customer_number HAVING count(*)>=ALL(SELECT count(*) FROM orders GROUP BY customer_number);`"
                    },
                    {
                        "username": "JaswanthP",
                        "content": "with cte as(\\nselect customer_number, rank() over (order by count(customer_number) desc) rnk from Orders group by customer_number)\\nselect customer_number from cte where rnk=1"
                    },
                    {
                        "username": "Mehul1997",
                        "content": "There was no need to make it this complicated"
                    },
                    {
                        "username": "bbbbeetroot",
                        "content": "Not sure what is wrong. I get the expected output in the test case but it says wrong answer.\\n\\nHere is my code:\\n```\\nimport pandas as pd\\n\\ndef largest_orders(orders: pd.DataFrame) -> pd.DataFrame:\\n    df = orders.groupby(\\'customer_number\\').size().reset_index()\\n    df = df.sort_values(by=0, ascending=False)\\n    return pd.DataFrame(\\n        {\"customer_number\" : [df[\\'customer_number\\'].head(1)]}\\n    )\\n```\\n\\nHere is my Output for the test case:\\n```\\n| customer_number |\\n| --------------- |\\n| 3               |\\n```\\n\\nHere is the expected output\\n```\\n| customer_number |\\n| --------------- |\\n| 3               |\\n```"
                    },
                    {
                        "username": "allispaul",
                        "content": "The problem is that `df[\\'customer_number\\'].head(1)` is returning a Series (of length 1), and the problem is expecting an int. Your code will work if you replace that with `df[\\'customer_number\\'].iloc[0]`."
                    },
                    {
                        "username": "quanghm",
                        "content": "Description **The test cases are generated so that exactly one customer will have placed more orders than any other customer.**\\nTest case:\\n```\\n| order_number | customer_number |\\n| ------------ | --------------- |\\n```\\n???"
                    },
                    {
                        "username": "ebrycez",
                        "content": "Can anyone explain why both `order by count(order_number) desc` and  `order by count(customer_number) desc` works after group by customer number?\\n"
                    },
                    {
                        "username": "clone8en",
                        "content": "Yes, I can. Count simply counts the number of non-null values in a field, that\\'s it. Not unique values. So whether you count rows with count(*), or the number of rows that don\\'t have NULL in a particular field, it\\'s the same logic. "
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "exactly i also want to know why aren\\'t we comparing order_number "
                    },
                    {
                        "username": "dafulu",
                        "content": "\"\"\"\\nselect customer_number\\nfrom orders \\ngroup by customer_number\\norder by count(customer_number) desc\\nlimit 1\\n\"\"\""
                    },
                    {
                        "username": "Fful",
                        "content": "*Task:*\\nThe test cases are **generated** so that exactly **one customer** will have placed more orders than any other customer.\\n\\n*Test_case #2:*\\n `| order_number | customer_number |`\\n`| ------------ | --------------- |`\\n\\nam i joke to you\\u2754\\u2754\\u2754\\nValueError: max() arg is an empty sequence "
                    },
                    {
                        "username": "user7071nM",
                        "content": "select customer_number from (select customer_number, row_number() over( order by count(customer_number) desc) as rn from orders group by customer_number)t\\nwhere rn=1;\\n\\nby using sub_queries"
                    }
                ]
            },
            {
                "id": 1760915,
                "content": [
                    {
                        "username": "pritiprajapati314",
                        "content": "\\tSELECT customer_number \\n\\tFROM Orders\\n\\tGROUP BY customer_number\\n\\tORDER BY COUNT(order_number) DESC\\n\\tLIMIT 1;"
                    },
                    {
                        "username": "chiratsxki",
                        "content": "thank you pritiprajapati314"
                    },
                    {
                        "username": "bhupendra786",
                        "content": "# Write your MySQL query statement below\\n\\nSELECT\\n    customer_number\\nFROM\\n    orders\\nGROUP BY customer_number\\nORDER BY COUNT(*) DESC\\nLIMIT 1"
                    },
                    {
                        "username": "aswinsureshk",
                        "content": "`SELECT customer_number FROM orders GROUP BY customer_number HAVING count(*)>=ALL(SELECT count(*) FROM orders GROUP BY customer_number);`"
                    },
                    {
                        "username": "JaswanthP",
                        "content": "with cte as(\\nselect customer_number, rank() over (order by count(customer_number) desc) rnk from Orders group by customer_number)\\nselect customer_number from cte where rnk=1"
                    },
                    {
                        "username": "Mehul1997",
                        "content": "There was no need to make it this complicated"
                    },
                    {
                        "username": "bbbbeetroot",
                        "content": "Not sure what is wrong. I get the expected output in the test case but it says wrong answer.\\n\\nHere is my code:\\n```\\nimport pandas as pd\\n\\ndef largest_orders(orders: pd.DataFrame) -> pd.DataFrame:\\n    df = orders.groupby(\\'customer_number\\').size().reset_index()\\n    df = df.sort_values(by=0, ascending=False)\\n    return pd.DataFrame(\\n        {\"customer_number\" : [df[\\'customer_number\\'].head(1)]}\\n    )\\n```\\n\\nHere is my Output for the test case:\\n```\\n| customer_number |\\n| --------------- |\\n| 3               |\\n```\\n\\nHere is the expected output\\n```\\n| customer_number |\\n| --------------- |\\n| 3               |\\n```"
                    },
                    {
                        "username": "allispaul",
                        "content": "The problem is that `df[\\'customer_number\\'].head(1)` is returning a Series (of length 1), and the problem is expecting an int. Your code will work if you replace that with `df[\\'customer_number\\'].iloc[0]`."
                    },
                    {
                        "username": "quanghm",
                        "content": "Description **The test cases are generated so that exactly one customer will have placed more orders than any other customer.**\\nTest case:\\n```\\n| order_number | customer_number |\\n| ------------ | --------------- |\\n```\\n???"
                    },
                    {
                        "username": "ebrycez",
                        "content": "Can anyone explain why both `order by count(order_number) desc` and  `order by count(customer_number) desc` works after group by customer number?\\n"
                    },
                    {
                        "username": "clone8en",
                        "content": "Yes, I can. Count simply counts the number of non-null values in a field, that\\'s it. Not unique values. So whether you count rows with count(*), or the number of rows that don\\'t have NULL in a particular field, it\\'s the same logic. "
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "exactly i also want to know why aren\\'t we comparing order_number "
                    },
                    {
                        "username": "dafulu",
                        "content": "\"\"\"\\nselect customer_number\\nfrom orders \\ngroup by customer_number\\norder by count(customer_number) desc\\nlimit 1\\n\"\"\""
                    },
                    {
                        "username": "Fful",
                        "content": "*Task:*\\nThe test cases are **generated** so that exactly **one customer** will have placed more orders than any other customer.\\n\\n*Test_case #2:*\\n `| order_number | customer_number |`\\n`| ------------ | --------------- |`\\n\\nam i joke to you\\u2754\\u2754\\u2754\\nValueError: max() arg is an empty sequence "
                    },
                    {
                        "username": "user7071nM",
                        "content": "select customer_number from (select customer_number, row_number() over( order by count(customer_number) desc) as rn from orders group by customer_number)t\\nwhere rn=1;\\n\\nby using sub_queries"
                    }
                ]
            },
            {
                "id": 1569633,
                "content": [
                    {
                        "username": "pritiprajapati314",
                        "content": "\\tSELECT customer_number \\n\\tFROM Orders\\n\\tGROUP BY customer_number\\n\\tORDER BY COUNT(order_number) DESC\\n\\tLIMIT 1;"
                    },
                    {
                        "username": "chiratsxki",
                        "content": "thank you pritiprajapati314"
                    },
                    {
                        "username": "bhupendra786",
                        "content": "# Write your MySQL query statement below\\n\\nSELECT\\n    customer_number\\nFROM\\n    orders\\nGROUP BY customer_number\\nORDER BY COUNT(*) DESC\\nLIMIT 1"
                    },
                    {
                        "username": "aswinsureshk",
                        "content": "`SELECT customer_number FROM orders GROUP BY customer_number HAVING count(*)>=ALL(SELECT count(*) FROM orders GROUP BY customer_number);`"
                    },
                    {
                        "username": "JaswanthP",
                        "content": "with cte as(\\nselect customer_number, rank() over (order by count(customer_number) desc) rnk from Orders group by customer_number)\\nselect customer_number from cte where rnk=1"
                    },
                    {
                        "username": "Mehul1997",
                        "content": "There was no need to make it this complicated"
                    },
                    {
                        "username": "bbbbeetroot",
                        "content": "Not sure what is wrong. I get the expected output in the test case but it says wrong answer.\\n\\nHere is my code:\\n```\\nimport pandas as pd\\n\\ndef largest_orders(orders: pd.DataFrame) -> pd.DataFrame:\\n    df = orders.groupby(\\'customer_number\\').size().reset_index()\\n    df = df.sort_values(by=0, ascending=False)\\n    return pd.DataFrame(\\n        {\"customer_number\" : [df[\\'customer_number\\'].head(1)]}\\n    )\\n```\\n\\nHere is my Output for the test case:\\n```\\n| customer_number |\\n| --------------- |\\n| 3               |\\n```\\n\\nHere is the expected output\\n```\\n| customer_number |\\n| --------------- |\\n| 3               |\\n```"
                    },
                    {
                        "username": "allispaul",
                        "content": "The problem is that `df[\\'customer_number\\'].head(1)` is returning a Series (of length 1), and the problem is expecting an int. Your code will work if you replace that with `df[\\'customer_number\\'].iloc[0]`."
                    },
                    {
                        "username": "quanghm",
                        "content": "Description **The test cases are generated so that exactly one customer will have placed more orders than any other customer.**\\nTest case:\\n```\\n| order_number | customer_number |\\n| ------------ | --------------- |\\n```\\n???"
                    },
                    {
                        "username": "ebrycez",
                        "content": "Can anyone explain why both `order by count(order_number) desc` and  `order by count(customer_number) desc` works after group by customer number?\\n"
                    },
                    {
                        "username": "clone8en",
                        "content": "Yes, I can. Count simply counts the number of non-null values in a field, that\\'s it. Not unique values. So whether you count rows with count(*), or the number of rows that don\\'t have NULL in a particular field, it\\'s the same logic. "
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "exactly i also want to know why aren\\'t we comparing order_number "
                    },
                    {
                        "username": "dafulu",
                        "content": "\"\"\"\\nselect customer_number\\nfrom orders \\ngroup by customer_number\\norder by count(customer_number) desc\\nlimit 1\\n\"\"\""
                    },
                    {
                        "username": "Fful",
                        "content": "*Task:*\\nThe test cases are **generated** so that exactly **one customer** will have placed more orders than any other customer.\\n\\n*Test_case #2:*\\n `| order_number | customer_number |`\\n`| ------------ | --------------- |`\\n\\nam i joke to you\\u2754\\u2754\\u2754\\nValueError: max() arg is an empty sequence "
                    },
                    {
                        "username": "user7071nM",
                        "content": "select customer_number from (select customer_number, row_number() over( order by count(customer_number) desc) as rn from orders group by customer_number)t\\nwhere rn=1;\\n\\nby using sub_queries"
                    }
                ]
            },
            {
                "id": 2025247,
                "content": [
                    {
                        "username": "pritiprajapati314",
                        "content": "\\tSELECT customer_number \\n\\tFROM Orders\\n\\tGROUP BY customer_number\\n\\tORDER BY COUNT(order_number) DESC\\n\\tLIMIT 1;"
                    },
                    {
                        "username": "chiratsxki",
                        "content": "thank you pritiprajapati314"
                    },
                    {
                        "username": "bhupendra786",
                        "content": "# Write your MySQL query statement below\\n\\nSELECT\\n    customer_number\\nFROM\\n    orders\\nGROUP BY customer_number\\nORDER BY COUNT(*) DESC\\nLIMIT 1"
                    },
                    {
                        "username": "aswinsureshk",
                        "content": "`SELECT customer_number FROM orders GROUP BY customer_number HAVING count(*)>=ALL(SELECT count(*) FROM orders GROUP BY customer_number);`"
                    },
                    {
                        "username": "JaswanthP",
                        "content": "with cte as(\\nselect customer_number, rank() over (order by count(customer_number) desc) rnk from Orders group by customer_number)\\nselect customer_number from cte where rnk=1"
                    },
                    {
                        "username": "Mehul1997",
                        "content": "There was no need to make it this complicated"
                    },
                    {
                        "username": "bbbbeetroot",
                        "content": "Not sure what is wrong. I get the expected output in the test case but it says wrong answer.\\n\\nHere is my code:\\n```\\nimport pandas as pd\\n\\ndef largest_orders(orders: pd.DataFrame) -> pd.DataFrame:\\n    df = orders.groupby(\\'customer_number\\').size().reset_index()\\n    df = df.sort_values(by=0, ascending=False)\\n    return pd.DataFrame(\\n        {\"customer_number\" : [df[\\'customer_number\\'].head(1)]}\\n    )\\n```\\n\\nHere is my Output for the test case:\\n```\\n| customer_number |\\n| --------------- |\\n| 3               |\\n```\\n\\nHere is the expected output\\n```\\n| customer_number |\\n| --------------- |\\n| 3               |\\n```"
                    },
                    {
                        "username": "allispaul",
                        "content": "The problem is that `df[\\'customer_number\\'].head(1)` is returning a Series (of length 1), and the problem is expecting an int. Your code will work if you replace that with `df[\\'customer_number\\'].iloc[0]`."
                    },
                    {
                        "username": "quanghm",
                        "content": "Description **The test cases are generated so that exactly one customer will have placed more orders than any other customer.**\\nTest case:\\n```\\n| order_number | customer_number |\\n| ------------ | --------------- |\\n```\\n???"
                    },
                    {
                        "username": "ebrycez",
                        "content": "Can anyone explain why both `order by count(order_number) desc` and  `order by count(customer_number) desc` works after group by customer number?\\n"
                    },
                    {
                        "username": "clone8en",
                        "content": "Yes, I can. Count simply counts the number of non-null values in a field, that\\'s it. Not unique values. So whether you count rows with count(*), or the number of rows that don\\'t have NULL in a particular field, it\\'s the same logic. "
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "exactly i also want to know why aren\\'t we comparing order_number "
                    },
                    {
                        "username": "dafulu",
                        "content": "\"\"\"\\nselect customer_number\\nfrom orders \\ngroup by customer_number\\norder by count(customer_number) desc\\nlimit 1\\n\"\"\""
                    },
                    {
                        "username": "Fful",
                        "content": "*Task:*\\nThe test cases are **generated** so that exactly **one customer** will have placed more orders than any other customer.\\n\\n*Test_case #2:*\\n `| order_number | customer_number |`\\n`| ------------ | --------------- |`\\n\\nam i joke to you\\u2754\\u2754\\u2754\\nValueError: max() arg is an empty sequence "
                    },
                    {
                        "username": "user7071nM",
                        "content": "select customer_number from (select customer_number, row_number() over( order by count(customer_number) desc) as rn from orders group by customer_number)t\\nwhere rn=1;\\n\\nby using sub_queries"
                    }
                ]
            },
            {
                "id": 1692985,
                "content": [
                    {
                        "username": "pritiprajapati314",
                        "content": "\\tSELECT customer_number \\n\\tFROM Orders\\n\\tGROUP BY customer_number\\n\\tORDER BY COUNT(order_number) DESC\\n\\tLIMIT 1;"
                    },
                    {
                        "username": "chiratsxki",
                        "content": "thank you pritiprajapati314"
                    },
                    {
                        "username": "bhupendra786",
                        "content": "# Write your MySQL query statement below\\n\\nSELECT\\n    customer_number\\nFROM\\n    orders\\nGROUP BY customer_number\\nORDER BY COUNT(*) DESC\\nLIMIT 1"
                    },
                    {
                        "username": "aswinsureshk",
                        "content": "`SELECT customer_number FROM orders GROUP BY customer_number HAVING count(*)>=ALL(SELECT count(*) FROM orders GROUP BY customer_number);`"
                    },
                    {
                        "username": "JaswanthP",
                        "content": "with cte as(\\nselect customer_number, rank() over (order by count(customer_number) desc) rnk from Orders group by customer_number)\\nselect customer_number from cte where rnk=1"
                    },
                    {
                        "username": "Mehul1997",
                        "content": "There was no need to make it this complicated"
                    },
                    {
                        "username": "bbbbeetroot",
                        "content": "Not sure what is wrong. I get the expected output in the test case but it says wrong answer.\\n\\nHere is my code:\\n```\\nimport pandas as pd\\n\\ndef largest_orders(orders: pd.DataFrame) -> pd.DataFrame:\\n    df = orders.groupby(\\'customer_number\\').size().reset_index()\\n    df = df.sort_values(by=0, ascending=False)\\n    return pd.DataFrame(\\n        {\"customer_number\" : [df[\\'customer_number\\'].head(1)]}\\n    )\\n```\\n\\nHere is my Output for the test case:\\n```\\n| customer_number |\\n| --------------- |\\n| 3               |\\n```\\n\\nHere is the expected output\\n```\\n| customer_number |\\n| --------------- |\\n| 3               |\\n```"
                    },
                    {
                        "username": "allispaul",
                        "content": "The problem is that `df[\\'customer_number\\'].head(1)` is returning a Series (of length 1), and the problem is expecting an int. Your code will work if you replace that with `df[\\'customer_number\\'].iloc[0]`."
                    },
                    {
                        "username": "quanghm",
                        "content": "Description **The test cases are generated so that exactly one customer will have placed more orders than any other customer.**\\nTest case:\\n```\\n| order_number | customer_number |\\n| ------------ | --------------- |\\n```\\n???"
                    },
                    {
                        "username": "ebrycez",
                        "content": "Can anyone explain why both `order by count(order_number) desc` and  `order by count(customer_number) desc` works after group by customer number?\\n"
                    },
                    {
                        "username": "clone8en",
                        "content": "Yes, I can. Count simply counts the number of non-null values in a field, that\\'s it. Not unique values. So whether you count rows with count(*), or the number of rows that don\\'t have NULL in a particular field, it\\'s the same logic. "
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "exactly i also want to know why aren\\'t we comparing order_number "
                    },
                    {
                        "username": "dafulu",
                        "content": "\"\"\"\\nselect customer_number\\nfrom orders \\ngroup by customer_number\\norder by count(customer_number) desc\\nlimit 1\\n\"\"\""
                    },
                    {
                        "username": "Fful",
                        "content": "*Task:*\\nThe test cases are **generated** so that exactly **one customer** will have placed more orders than any other customer.\\n\\n*Test_case #2:*\\n `| order_number | customer_number |`\\n`| ------------ | --------------- |`\\n\\nam i joke to you\\u2754\\u2754\\u2754\\nValueError: max() arg is an empty sequence "
                    },
                    {
                        "username": "user7071nM",
                        "content": "select customer_number from (select customer_number, row_number() over( order by count(customer_number) desc) as rn from orders group by customer_number)t\\nwhere rn=1;\\n\\nby using sub_queries"
                    }
                ]
            },
            {
                "id": 1576933,
                "content": [
                    {
                        "username": "imuradli",
                        "content": "\\'\\'\\' \\nwith sb as (\\nselect\\ncustomer_number,\\ncount(distinct order_number) as num\\nfrom orders\\ngroup by customer_number\\norder by num desc\\nlimit 1)\\nselect customer_number from sb"
                    },
                    {
                        "username": "Saniyabubere",
                        "content": "-- Selecting the customer_number for the customer who has placed the largest number of orders\\nSELECT customer_number  -- Selecting the customer_number column\\nFROM orders  -- From the \\'orders\\' table\\n\\n-- Grouping the rows by customer_number to count the orders for each customer\\nGROUP BY customer_number\\n\\n-- Ordering the results in descending order based on the count of orders\\nORDER BY COUNT(*) DESC\\n\\n-- Limiting the result to only the customer with the highest order count\\nLIMIT 1;\\n"
                    },
                    {
                        "username": "Saniyabubere",
                        "content": "-- Selecting the maximum customer number from the \\'orders\\' table\\nSELECT MAX(customer_number) AS customer_number\\nFROM orders;\\n"
                    },
                    {
                        "username": "vivekgangwar02",
                        "content": "wrong!\\nIt asks for most occuring id NOT largest id."
                    },
                    {
                        "username": "arck1409",
                        "content": "Can someone explain why can\\'t we use the below code:\\nselect max(customer_number)  as customer_number from orders"
                    },
                    {
                        "username": "vivekgangwar02",
                        "content": "It asks for most occuring id NOT largest id."
                    },
                    {
                        "username": "peter_troitsky",
                        "content": "Output and Expected are the same AGAIN\\n\\ndef largest_orders(orders: pd.DataFrame) -> pd.DataFrame:\\n    df = orders\\n    df = df.groupby(\\'customer_number\\', as_index = False).agg({\\'order_number\\': \\'nunique\\'}).rename(columns={\\'order_number\\':\\'cnt\\'}).sort_values(\\'cnt\\', ascending = False)\\n    n = df.head(1).customer_number\\n    return pd.DataFrame({\\'customer_number\\': [n]})"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Pandas\\n\\nA DataFrameGroupBy returned by .groupby() has a menthod `.size()` which returns the number of rows in each group."
                    },
                    {
                        "username": "usama27muneer",
                        "content": "This Solutions is done using the ChatGPT. But I understood all the concepts to apply again in the future so that I won\\'t have to take the help of ChatGPT.\\n\\nSELECT o.customer_number\\nFROM Orders o\\nJOIN (\\n    SELECT customer_number, COUNT(order_number) AS order_count\\n    FROM Orders\\n    GROUP BY customer_number\\n) counts\\nON o.customer_number = counts.customer_number\\nORDER BY counts.order_count DESC\\nLIMIT 1;"
                    },
                    {
                        "username": "uaoiuaoi",
                        "content": "For pandasman. For empty input output is pd.DataFrame({'customer_number': []})\nI can't to solve by orders.groupby('customer_number').count().idxmax(). Why? value_counts() works"
                    },
                    {
                        "username": "aleh_dalzh",
                        "content": "T-SQL\\n\\nSELECT TOP(1)\\n    ords.customer_number\\nFROM Orders AS ords\\n    GROUP BY ords.customer_number\\n    ORDER BY COUNT(ords.customer_number) DESC"
                    },
                    {
                        "username": "edithi",
                        "content": "You can use the value_counts() function to calculate the count of each unique customer number in the \\'orders\\' DataFrame. Then, you can use the idxmax() function to find the customer number with the largest count. Make sure to handle the case when the DataFrame is empty to avoid errors."
                    }
                ]
            },
            {
                "id": 2043844,
                "content": [
                    {
                        "username": "imuradli",
                        "content": "\\'\\'\\' \\nwith sb as (\\nselect\\ncustomer_number,\\ncount(distinct order_number) as num\\nfrom orders\\ngroup by customer_number\\norder by num desc\\nlimit 1)\\nselect customer_number from sb"
                    },
                    {
                        "username": "Saniyabubere",
                        "content": "-- Selecting the customer_number for the customer who has placed the largest number of orders\\nSELECT customer_number  -- Selecting the customer_number column\\nFROM orders  -- From the \\'orders\\' table\\n\\n-- Grouping the rows by customer_number to count the orders for each customer\\nGROUP BY customer_number\\n\\n-- Ordering the results in descending order based on the count of orders\\nORDER BY COUNT(*) DESC\\n\\n-- Limiting the result to only the customer with the highest order count\\nLIMIT 1;\\n"
                    },
                    {
                        "username": "Saniyabubere",
                        "content": "-- Selecting the maximum customer number from the \\'orders\\' table\\nSELECT MAX(customer_number) AS customer_number\\nFROM orders;\\n"
                    },
                    {
                        "username": "vivekgangwar02",
                        "content": "wrong!\\nIt asks for most occuring id NOT largest id."
                    },
                    {
                        "username": "arck1409",
                        "content": "Can someone explain why can\\'t we use the below code:\\nselect max(customer_number)  as customer_number from orders"
                    },
                    {
                        "username": "vivekgangwar02",
                        "content": "It asks for most occuring id NOT largest id."
                    },
                    {
                        "username": "peter_troitsky",
                        "content": "Output and Expected are the same AGAIN\\n\\ndef largest_orders(orders: pd.DataFrame) -> pd.DataFrame:\\n    df = orders\\n    df = df.groupby(\\'customer_number\\', as_index = False).agg({\\'order_number\\': \\'nunique\\'}).rename(columns={\\'order_number\\':\\'cnt\\'}).sort_values(\\'cnt\\', ascending = False)\\n    n = df.head(1).customer_number\\n    return pd.DataFrame({\\'customer_number\\': [n]})"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Pandas\\n\\nA DataFrameGroupBy returned by .groupby() has a menthod `.size()` which returns the number of rows in each group."
                    },
                    {
                        "username": "usama27muneer",
                        "content": "This Solutions is done using the ChatGPT. But I understood all the concepts to apply again in the future so that I won\\'t have to take the help of ChatGPT.\\n\\nSELECT o.customer_number\\nFROM Orders o\\nJOIN (\\n    SELECT customer_number, COUNT(order_number) AS order_count\\n    FROM Orders\\n    GROUP BY customer_number\\n) counts\\nON o.customer_number = counts.customer_number\\nORDER BY counts.order_count DESC\\nLIMIT 1;"
                    },
                    {
                        "username": "uaoiuaoi",
                        "content": "For pandasman. For empty input output is pd.DataFrame({'customer_number': []})\nI can't to solve by orders.groupby('customer_number').count().idxmax(). Why? value_counts() works"
                    },
                    {
                        "username": "aleh_dalzh",
                        "content": "T-SQL\\n\\nSELECT TOP(1)\\n    ords.customer_number\\nFROM Orders AS ords\\n    GROUP BY ords.customer_number\\n    ORDER BY COUNT(ords.customer_number) DESC"
                    },
                    {
                        "username": "edithi",
                        "content": "You can use the value_counts() function to calculate the count of each unique customer number in the \\'orders\\' DataFrame. Then, you can use the idxmax() function to find the customer number with the largest count. Make sure to handle the case when the DataFrame is empty to avoid errors."
                    }
                ]
            },
            {
                "id": 2043837,
                "content": [
                    {
                        "username": "imuradli",
                        "content": "\\'\\'\\' \\nwith sb as (\\nselect\\ncustomer_number,\\ncount(distinct order_number) as num\\nfrom orders\\ngroup by customer_number\\norder by num desc\\nlimit 1)\\nselect customer_number from sb"
                    },
                    {
                        "username": "Saniyabubere",
                        "content": "-- Selecting the customer_number for the customer who has placed the largest number of orders\\nSELECT customer_number  -- Selecting the customer_number column\\nFROM orders  -- From the \\'orders\\' table\\n\\n-- Grouping the rows by customer_number to count the orders for each customer\\nGROUP BY customer_number\\n\\n-- Ordering the results in descending order based on the count of orders\\nORDER BY COUNT(*) DESC\\n\\n-- Limiting the result to only the customer with the highest order count\\nLIMIT 1;\\n"
                    },
                    {
                        "username": "Saniyabubere",
                        "content": "-- Selecting the maximum customer number from the \\'orders\\' table\\nSELECT MAX(customer_number) AS customer_number\\nFROM orders;\\n"
                    },
                    {
                        "username": "vivekgangwar02",
                        "content": "wrong!\\nIt asks for most occuring id NOT largest id."
                    },
                    {
                        "username": "arck1409",
                        "content": "Can someone explain why can\\'t we use the below code:\\nselect max(customer_number)  as customer_number from orders"
                    },
                    {
                        "username": "vivekgangwar02",
                        "content": "It asks for most occuring id NOT largest id."
                    },
                    {
                        "username": "peter_troitsky",
                        "content": "Output and Expected are the same AGAIN\\n\\ndef largest_orders(orders: pd.DataFrame) -> pd.DataFrame:\\n    df = orders\\n    df = df.groupby(\\'customer_number\\', as_index = False).agg({\\'order_number\\': \\'nunique\\'}).rename(columns={\\'order_number\\':\\'cnt\\'}).sort_values(\\'cnt\\', ascending = False)\\n    n = df.head(1).customer_number\\n    return pd.DataFrame({\\'customer_number\\': [n]})"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Pandas\\n\\nA DataFrameGroupBy returned by .groupby() has a menthod `.size()` which returns the number of rows in each group."
                    },
                    {
                        "username": "usama27muneer",
                        "content": "This Solutions is done using the ChatGPT. But I understood all the concepts to apply again in the future so that I won\\'t have to take the help of ChatGPT.\\n\\nSELECT o.customer_number\\nFROM Orders o\\nJOIN (\\n    SELECT customer_number, COUNT(order_number) AS order_count\\n    FROM Orders\\n    GROUP BY customer_number\\n) counts\\nON o.customer_number = counts.customer_number\\nORDER BY counts.order_count DESC\\nLIMIT 1;"
                    },
                    {
                        "username": "uaoiuaoi",
                        "content": "For pandasman. For empty input output is pd.DataFrame({'customer_number': []})\nI can't to solve by orders.groupby('customer_number').count().idxmax(). Why? value_counts() works"
                    },
                    {
                        "username": "aleh_dalzh",
                        "content": "T-SQL\\n\\nSELECT TOP(1)\\n    ords.customer_number\\nFROM Orders AS ords\\n    GROUP BY ords.customer_number\\n    ORDER BY COUNT(ords.customer_number) DESC"
                    },
                    {
                        "username": "edithi",
                        "content": "You can use the value_counts() function to calculate the count of each unique customer number in the \\'orders\\' DataFrame. Then, you can use the idxmax() function to find the customer number with the largest count. Make sure to handle the case when the DataFrame is empty to avoid errors."
                    }
                ]
            },
            {
                "id": 2037616,
                "content": [
                    {
                        "username": "imuradli",
                        "content": "\\'\\'\\' \\nwith sb as (\\nselect\\ncustomer_number,\\ncount(distinct order_number) as num\\nfrom orders\\ngroup by customer_number\\norder by num desc\\nlimit 1)\\nselect customer_number from sb"
                    },
                    {
                        "username": "Saniyabubere",
                        "content": "-- Selecting the customer_number for the customer who has placed the largest number of orders\\nSELECT customer_number  -- Selecting the customer_number column\\nFROM orders  -- From the \\'orders\\' table\\n\\n-- Grouping the rows by customer_number to count the orders for each customer\\nGROUP BY customer_number\\n\\n-- Ordering the results in descending order based on the count of orders\\nORDER BY COUNT(*) DESC\\n\\n-- Limiting the result to only the customer with the highest order count\\nLIMIT 1;\\n"
                    },
                    {
                        "username": "Saniyabubere",
                        "content": "-- Selecting the maximum customer number from the \\'orders\\' table\\nSELECT MAX(customer_number) AS customer_number\\nFROM orders;\\n"
                    },
                    {
                        "username": "vivekgangwar02",
                        "content": "wrong!\\nIt asks for most occuring id NOT largest id."
                    },
                    {
                        "username": "arck1409",
                        "content": "Can someone explain why can\\'t we use the below code:\\nselect max(customer_number)  as customer_number from orders"
                    },
                    {
                        "username": "vivekgangwar02",
                        "content": "It asks for most occuring id NOT largest id."
                    },
                    {
                        "username": "peter_troitsky",
                        "content": "Output and Expected are the same AGAIN\\n\\ndef largest_orders(orders: pd.DataFrame) -> pd.DataFrame:\\n    df = orders\\n    df = df.groupby(\\'customer_number\\', as_index = False).agg({\\'order_number\\': \\'nunique\\'}).rename(columns={\\'order_number\\':\\'cnt\\'}).sort_values(\\'cnt\\', ascending = False)\\n    n = df.head(1).customer_number\\n    return pd.DataFrame({\\'customer_number\\': [n]})"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Pandas\\n\\nA DataFrameGroupBy returned by .groupby() has a menthod `.size()` which returns the number of rows in each group."
                    },
                    {
                        "username": "usama27muneer",
                        "content": "This Solutions is done using the ChatGPT. But I understood all the concepts to apply again in the future so that I won\\'t have to take the help of ChatGPT.\\n\\nSELECT o.customer_number\\nFROM Orders o\\nJOIN (\\n    SELECT customer_number, COUNT(order_number) AS order_count\\n    FROM Orders\\n    GROUP BY customer_number\\n) counts\\nON o.customer_number = counts.customer_number\\nORDER BY counts.order_count DESC\\nLIMIT 1;"
                    },
                    {
                        "username": "uaoiuaoi",
                        "content": "For pandasman. For empty input output is pd.DataFrame({'customer_number': []})\nI can't to solve by orders.groupby('customer_number').count().idxmax(). Why? value_counts() works"
                    },
                    {
                        "username": "aleh_dalzh",
                        "content": "T-SQL\\n\\nSELECT TOP(1)\\n    ords.customer_number\\nFROM Orders AS ords\\n    GROUP BY ords.customer_number\\n    ORDER BY COUNT(ords.customer_number) DESC"
                    },
                    {
                        "username": "edithi",
                        "content": "You can use the value_counts() function to calculate the count of each unique customer number in the \\'orders\\' DataFrame. Then, you can use the idxmax() function to find the customer number with the largest count. Make sure to handle the case when the DataFrame is empty to avoid errors."
                    }
                ]
            },
            {
                "id": 2037599,
                "content": [
                    {
                        "username": "imuradli",
                        "content": "\\'\\'\\' \\nwith sb as (\\nselect\\ncustomer_number,\\ncount(distinct order_number) as num\\nfrom orders\\ngroup by customer_number\\norder by num desc\\nlimit 1)\\nselect customer_number from sb"
                    },
                    {
                        "username": "Saniyabubere",
                        "content": "-- Selecting the customer_number for the customer who has placed the largest number of orders\\nSELECT customer_number  -- Selecting the customer_number column\\nFROM orders  -- From the \\'orders\\' table\\n\\n-- Grouping the rows by customer_number to count the orders for each customer\\nGROUP BY customer_number\\n\\n-- Ordering the results in descending order based on the count of orders\\nORDER BY COUNT(*) DESC\\n\\n-- Limiting the result to only the customer with the highest order count\\nLIMIT 1;\\n"
                    },
                    {
                        "username": "Saniyabubere",
                        "content": "-- Selecting the maximum customer number from the \\'orders\\' table\\nSELECT MAX(customer_number) AS customer_number\\nFROM orders;\\n"
                    },
                    {
                        "username": "vivekgangwar02",
                        "content": "wrong!\\nIt asks for most occuring id NOT largest id."
                    },
                    {
                        "username": "arck1409",
                        "content": "Can someone explain why can\\'t we use the below code:\\nselect max(customer_number)  as customer_number from orders"
                    },
                    {
                        "username": "vivekgangwar02",
                        "content": "It asks for most occuring id NOT largest id."
                    },
                    {
                        "username": "peter_troitsky",
                        "content": "Output and Expected are the same AGAIN\\n\\ndef largest_orders(orders: pd.DataFrame) -> pd.DataFrame:\\n    df = orders\\n    df = df.groupby(\\'customer_number\\', as_index = False).agg({\\'order_number\\': \\'nunique\\'}).rename(columns={\\'order_number\\':\\'cnt\\'}).sort_values(\\'cnt\\', ascending = False)\\n    n = df.head(1).customer_number\\n    return pd.DataFrame({\\'customer_number\\': [n]})"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Pandas\\n\\nA DataFrameGroupBy returned by .groupby() has a menthod `.size()` which returns the number of rows in each group."
                    },
                    {
                        "username": "usama27muneer",
                        "content": "This Solutions is done using the ChatGPT. But I understood all the concepts to apply again in the future so that I won\\'t have to take the help of ChatGPT.\\n\\nSELECT o.customer_number\\nFROM Orders o\\nJOIN (\\n    SELECT customer_number, COUNT(order_number) AS order_count\\n    FROM Orders\\n    GROUP BY customer_number\\n) counts\\nON o.customer_number = counts.customer_number\\nORDER BY counts.order_count DESC\\nLIMIT 1;"
                    },
                    {
                        "username": "uaoiuaoi",
                        "content": "For pandasman. For empty input output is pd.DataFrame({'customer_number': []})\nI can't to solve by orders.groupby('customer_number').count().idxmax(). Why? value_counts() works"
                    },
                    {
                        "username": "aleh_dalzh",
                        "content": "T-SQL\\n\\nSELECT TOP(1)\\n    ords.customer_number\\nFROM Orders AS ords\\n    GROUP BY ords.customer_number\\n    ORDER BY COUNT(ords.customer_number) DESC"
                    },
                    {
                        "username": "edithi",
                        "content": "You can use the value_counts() function to calculate the count of each unique customer number in the \\'orders\\' DataFrame. Then, you can use the idxmax() function to find the customer number with the largest count. Make sure to handle the case when the DataFrame is empty to avoid errors."
                    }
                ]
            },
            {
                "id": 2028931,
                "content": [
                    {
                        "username": "imuradli",
                        "content": "\\'\\'\\' \\nwith sb as (\\nselect\\ncustomer_number,\\ncount(distinct order_number) as num\\nfrom orders\\ngroup by customer_number\\norder by num desc\\nlimit 1)\\nselect customer_number from sb"
                    },
                    {
                        "username": "Saniyabubere",
                        "content": "-- Selecting the customer_number for the customer who has placed the largest number of orders\\nSELECT customer_number  -- Selecting the customer_number column\\nFROM orders  -- From the \\'orders\\' table\\n\\n-- Grouping the rows by customer_number to count the orders for each customer\\nGROUP BY customer_number\\n\\n-- Ordering the results in descending order based on the count of orders\\nORDER BY COUNT(*) DESC\\n\\n-- Limiting the result to only the customer with the highest order count\\nLIMIT 1;\\n"
                    },
                    {
                        "username": "Saniyabubere",
                        "content": "-- Selecting the maximum customer number from the \\'orders\\' table\\nSELECT MAX(customer_number) AS customer_number\\nFROM orders;\\n"
                    },
                    {
                        "username": "vivekgangwar02",
                        "content": "wrong!\\nIt asks for most occuring id NOT largest id."
                    },
                    {
                        "username": "arck1409",
                        "content": "Can someone explain why can\\'t we use the below code:\\nselect max(customer_number)  as customer_number from orders"
                    },
                    {
                        "username": "vivekgangwar02",
                        "content": "It asks for most occuring id NOT largest id."
                    },
                    {
                        "username": "peter_troitsky",
                        "content": "Output and Expected are the same AGAIN\\n\\ndef largest_orders(orders: pd.DataFrame) -> pd.DataFrame:\\n    df = orders\\n    df = df.groupby(\\'customer_number\\', as_index = False).agg({\\'order_number\\': \\'nunique\\'}).rename(columns={\\'order_number\\':\\'cnt\\'}).sort_values(\\'cnt\\', ascending = False)\\n    n = df.head(1).customer_number\\n    return pd.DataFrame({\\'customer_number\\': [n]})"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Pandas\\n\\nA DataFrameGroupBy returned by .groupby() has a menthod `.size()` which returns the number of rows in each group."
                    },
                    {
                        "username": "usama27muneer",
                        "content": "This Solutions is done using the ChatGPT. But I understood all the concepts to apply again in the future so that I won\\'t have to take the help of ChatGPT.\\n\\nSELECT o.customer_number\\nFROM Orders o\\nJOIN (\\n    SELECT customer_number, COUNT(order_number) AS order_count\\n    FROM Orders\\n    GROUP BY customer_number\\n) counts\\nON o.customer_number = counts.customer_number\\nORDER BY counts.order_count DESC\\nLIMIT 1;"
                    },
                    {
                        "username": "uaoiuaoi",
                        "content": "For pandasman. For empty input output is pd.DataFrame({'customer_number': []})\nI can't to solve by orders.groupby('customer_number').count().idxmax(). Why? value_counts() works"
                    },
                    {
                        "username": "aleh_dalzh",
                        "content": "T-SQL\\n\\nSELECT TOP(1)\\n    ords.customer_number\\nFROM Orders AS ords\\n    GROUP BY ords.customer_number\\n    ORDER BY COUNT(ords.customer_number) DESC"
                    },
                    {
                        "username": "edithi",
                        "content": "You can use the value_counts() function to calculate the count of each unique customer number in the \\'orders\\' DataFrame. Then, you can use the idxmax() function to find the customer number with the largest count. Make sure to handle the case when the DataFrame is empty to avoid errors."
                    }
                ]
            },
            {
                "id": 2024402,
                "content": [
                    {
                        "username": "imuradli",
                        "content": "\\'\\'\\' \\nwith sb as (\\nselect\\ncustomer_number,\\ncount(distinct order_number) as num\\nfrom orders\\ngroup by customer_number\\norder by num desc\\nlimit 1)\\nselect customer_number from sb"
                    },
                    {
                        "username": "Saniyabubere",
                        "content": "-- Selecting the customer_number for the customer who has placed the largest number of orders\\nSELECT customer_number  -- Selecting the customer_number column\\nFROM orders  -- From the \\'orders\\' table\\n\\n-- Grouping the rows by customer_number to count the orders for each customer\\nGROUP BY customer_number\\n\\n-- Ordering the results in descending order based on the count of orders\\nORDER BY COUNT(*) DESC\\n\\n-- Limiting the result to only the customer with the highest order count\\nLIMIT 1;\\n"
                    },
                    {
                        "username": "Saniyabubere",
                        "content": "-- Selecting the maximum customer number from the \\'orders\\' table\\nSELECT MAX(customer_number) AS customer_number\\nFROM orders;\\n"
                    },
                    {
                        "username": "vivekgangwar02",
                        "content": "wrong!\\nIt asks for most occuring id NOT largest id."
                    },
                    {
                        "username": "arck1409",
                        "content": "Can someone explain why can\\'t we use the below code:\\nselect max(customer_number)  as customer_number from orders"
                    },
                    {
                        "username": "vivekgangwar02",
                        "content": "It asks for most occuring id NOT largest id."
                    },
                    {
                        "username": "peter_troitsky",
                        "content": "Output and Expected are the same AGAIN\\n\\ndef largest_orders(orders: pd.DataFrame) -> pd.DataFrame:\\n    df = orders\\n    df = df.groupby(\\'customer_number\\', as_index = False).agg({\\'order_number\\': \\'nunique\\'}).rename(columns={\\'order_number\\':\\'cnt\\'}).sort_values(\\'cnt\\', ascending = False)\\n    n = df.head(1).customer_number\\n    return pd.DataFrame({\\'customer_number\\': [n]})"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Pandas\\n\\nA DataFrameGroupBy returned by .groupby() has a menthod `.size()` which returns the number of rows in each group."
                    },
                    {
                        "username": "usama27muneer",
                        "content": "This Solutions is done using the ChatGPT. But I understood all the concepts to apply again in the future so that I won\\'t have to take the help of ChatGPT.\\n\\nSELECT o.customer_number\\nFROM Orders o\\nJOIN (\\n    SELECT customer_number, COUNT(order_number) AS order_count\\n    FROM Orders\\n    GROUP BY customer_number\\n) counts\\nON o.customer_number = counts.customer_number\\nORDER BY counts.order_count DESC\\nLIMIT 1;"
                    },
                    {
                        "username": "uaoiuaoi",
                        "content": "For pandasman. For empty input output is pd.DataFrame({'customer_number': []})\nI can't to solve by orders.groupby('customer_number').count().idxmax(). Why? value_counts() works"
                    },
                    {
                        "username": "aleh_dalzh",
                        "content": "T-SQL\\n\\nSELECT TOP(1)\\n    ords.customer_number\\nFROM Orders AS ords\\n    GROUP BY ords.customer_number\\n    ORDER BY COUNT(ords.customer_number) DESC"
                    },
                    {
                        "username": "edithi",
                        "content": "You can use the value_counts() function to calculate the count of each unique customer number in the \\'orders\\' DataFrame. Then, you can use the idxmax() function to find the customer number with the largest count. Make sure to handle the case when the DataFrame is empty to avoid errors."
                    }
                ]
            },
            {
                "id": 2024311,
                "content": [
                    {
                        "username": "imuradli",
                        "content": "\\'\\'\\' \\nwith sb as (\\nselect\\ncustomer_number,\\ncount(distinct order_number) as num\\nfrom orders\\ngroup by customer_number\\norder by num desc\\nlimit 1)\\nselect customer_number from sb"
                    },
                    {
                        "username": "Saniyabubere",
                        "content": "-- Selecting the customer_number for the customer who has placed the largest number of orders\\nSELECT customer_number  -- Selecting the customer_number column\\nFROM orders  -- From the \\'orders\\' table\\n\\n-- Grouping the rows by customer_number to count the orders for each customer\\nGROUP BY customer_number\\n\\n-- Ordering the results in descending order based on the count of orders\\nORDER BY COUNT(*) DESC\\n\\n-- Limiting the result to only the customer with the highest order count\\nLIMIT 1;\\n"
                    },
                    {
                        "username": "Saniyabubere",
                        "content": "-- Selecting the maximum customer number from the \\'orders\\' table\\nSELECT MAX(customer_number) AS customer_number\\nFROM orders;\\n"
                    },
                    {
                        "username": "vivekgangwar02",
                        "content": "wrong!\\nIt asks for most occuring id NOT largest id."
                    },
                    {
                        "username": "arck1409",
                        "content": "Can someone explain why can\\'t we use the below code:\\nselect max(customer_number)  as customer_number from orders"
                    },
                    {
                        "username": "vivekgangwar02",
                        "content": "It asks for most occuring id NOT largest id."
                    },
                    {
                        "username": "peter_troitsky",
                        "content": "Output and Expected are the same AGAIN\\n\\ndef largest_orders(orders: pd.DataFrame) -> pd.DataFrame:\\n    df = orders\\n    df = df.groupby(\\'customer_number\\', as_index = False).agg({\\'order_number\\': \\'nunique\\'}).rename(columns={\\'order_number\\':\\'cnt\\'}).sort_values(\\'cnt\\', ascending = False)\\n    n = df.head(1).customer_number\\n    return pd.DataFrame({\\'customer_number\\': [n]})"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Pandas\\n\\nA DataFrameGroupBy returned by .groupby() has a menthod `.size()` which returns the number of rows in each group."
                    },
                    {
                        "username": "usama27muneer",
                        "content": "This Solutions is done using the ChatGPT. But I understood all the concepts to apply again in the future so that I won\\'t have to take the help of ChatGPT.\\n\\nSELECT o.customer_number\\nFROM Orders o\\nJOIN (\\n    SELECT customer_number, COUNT(order_number) AS order_count\\n    FROM Orders\\n    GROUP BY customer_number\\n) counts\\nON o.customer_number = counts.customer_number\\nORDER BY counts.order_count DESC\\nLIMIT 1;"
                    },
                    {
                        "username": "uaoiuaoi",
                        "content": "For pandasman. For empty input output is pd.DataFrame({'customer_number': []})\nI can't to solve by orders.groupby('customer_number').count().idxmax(). Why? value_counts() works"
                    },
                    {
                        "username": "aleh_dalzh",
                        "content": "T-SQL\\n\\nSELECT TOP(1)\\n    ords.customer_number\\nFROM Orders AS ords\\n    GROUP BY ords.customer_number\\n    ORDER BY COUNT(ords.customer_number) DESC"
                    },
                    {
                        "username": "edithi",
                        "content": "You can use the value_counts() function to calculate the count of each unique customer number in the \\'orders\\' DataFrame. Then, you can use the idxmax() function to find the customer number with the largest count. Make sure to handle the case when the DataFrame is empty to avoid errors."
                    }
                ]
            },
            {
                "id": 2010780,
                "content": [
                    {
                        "username": "imuradli",
                        "content": "\\'\\'\\' \\nwith sb as (\\nselect\\ncustomer_number,\\ncount(distinct order_number) as num\\nfrom orders\\ngroup by customer_number\\norder by num desc\\nlimit 1)\\nselect customer_number from sb"
                    },
                    {
                        "username": "Saniyabubere",
                        "content": "-- Selecting the customer_number for the customer who has placed the largest number of orders\\nSELECT customer_number  -- Selecting the customer_number column\\nFROM orders  -- From the \\'orders\\' table\\n\\n-- Grouping the rows by customer_number to count the orders for each customer\\nGROUP BY customer_number\\n\\n-- Ordering the results in descending order based on the count of orders\\nORDER BY COUNT(*) DESC\\n\\n-- Limiting the result to only the customer with the highest order count\\nLIMIT 1;\\n"
                    },
                    {
                        "username": "Saniyabubere",
                        "content": "-- Selecting the maximum customer number from the \\'orders\\' table\\nSELECT MAX(customer_number) AS customer_number\\nFROM orders;\\n"
                    },
                    {
                        "username": "vivekgangwar02",
                        "content": "wrong!\\nIt asks for most occuring id NOT largest id."
                    },
                    {
                        "username": "arck1409",
                        "content": "Can someone explain why can\\'t we use the below code:\\nselect max(customer_number)  as customer_number from orders"
                    },
                    {
                        "username": "vivekgangwar02",
                        "content": "It asks for most occuring id NOT largest id."
                    },
                    {
                        "username": "peter_troitsky",
                        "content": "Output and Expected are the same AGAIN\\n\\ndef largest_orders(orders: pd.DataFrame) -> pd.DataFrame:\\n    df = orders\\n    df = df.groupby(\\'customer_number\\', as_index = False).agg({\\'order_number\\': \\'nunique\\'}).rename(columns={\\'order_number\\':\\'cnt\\'}).sort_values(\\'cnt\\', ascending = False)\\n    n = df.head(1).customer_number\\n    return pd.DataFrame({\\'customer_number\\': [n]})"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Pandas\\n\\nA DataFrameGroupBy returned by .groupby() has a menthod `.size()` which returns the number of rows in each group."
                    },
                    {
                        "username": "usama27muneer",
                        "content": "This Solutions is done using the ChatGPT. But I understood all the concepts to apply again in the future so that I won\\'t have to take the help of ChatGPT.\\n\\nSELECT o.customer_number\\nFROM Orders o\\nJOIN (\\n    SELECT customer_number, COUNT(order_number) AS order_count\\n    FROM Orders\\n    GROUP BY customer_number\\n) counts\\nON o.customer_number = counts.customer_number\\nORDER BY counts.order_count DESC\\nLIMIT 1;"
                    },
                    {
                        "username": "uaoiuaoi",
                        "content": "For pandasman. For empty input output is pd.DataFrame({'customer_number': []})\nI can't to solve by orders.groupby('customer_number').count().idxmax(). Why? value_counts() works"
                    },
                    {
                        "username": "aleh_dalzh",
                        "content": "T-SQL\\n\\nSELECT TOP(1)\\n    ords.customer_number\\nFROM Orders AS ords\\n    GROUP BY ords.customer_number\\n    ORDER BY COUNT(ords.customer_number) DESC"
                    },
                    {
                        "username": "edithi",
                        "content": "You can use the value_counts() function to calculate the count of each unique customer number in the \\'orders\\' DataFrame. Then, you can use the idxmax() function to find the customer number with the largest count. Make sure to handle the case when the DataFrame is empty to avoid errors."
                    }
                ]
            },
            {
                "id": 2010142,
                "content": [
                    {
                        "username": "imuradli",
                        "content": "\\'\\'\\' \\nwith sb as (\\nselect\\ncustomer_number,\\ncount(distinct order_number) as num\\nfrom orders\\ngroup by customer_number\\norder by num desc\\nlimit 1)\\nselect customer_number from sb"
                    },
                    {
                        "username": "Saniyabubere",
                        "content": "-- Selecting the customer_number for the customer who has placed the largest number of orders\\nSELECT customer_number  -- Selecting the customer_number column\\nFROM orders  -- From the \\'orders\\' table\\n\\n-- Grouping the rows by customer_number to count the orders for each customer\\nGROUP BY customer_number\\n\\n-- Ordering the results in descending order based on the count of orders\\nORDER BY COUNT(*) DESC\\n\\n-- Limiting the result to only the customer with the highest order count\\nLIMIT 1;\\n"
                    },
                    {
                        "username": "Saniyabubere",
                        "content": "-- Selecting the maximum customer number from the \\'orders\\' table\\nSELECT MAX(customer_number) AS customer_number\\nFROM orders;\\n"
                    },
                    {
                        "username": "vivekgangwar02",
                        "content": "wrong!\\nIt asks for most occuring id NOT largest id."
                    },
                    {
                        "username": "arck1409",
                        "content": "Can someone explain why can\\'t we use the below code:\\nselect max(customer_number)  as customer_number from orders"
                    },
                    {
                        "username": "vivekgangwar02",
                        "content": "It asks for most occuring id NOT largest id."
                    },
                    {
                        "username": "peter_troitsky",
                        "content": "Output and Expected are the same AGAIN\\n\\ndef largest_orders(orders: pd.DataFrame) -> pd.DataFrame:\\n    df = orders\\n    df = df.groupby(\\'customer_number\\', as_index = False).agg({\\'order_number\\': \\'nunique\\'}).rename(columns={\\'order_number\\':\\'cnt\\'}).sort_values(\\'cnt\\', ascending = False)\\n    n = df.head(1).customer_number\\n    return pd.DataFrame({\\'customer_number\\': [n]})"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Pandas\\n\\nA DataFrameGroupBy returned by .groupby() has a menthod `.size()` which returns the number of rows in each group."
                    },
                    {
                        "username": "usama27muneer",
                        "content": "This Solutions is done using the ChatGPT. But I understood all the concepts to apply again in the future so that I won\\'t have to take the help of ChatGPT.\\n\\nSELECT o.customer_number\\nFROM Orders o\\nJOIN (\\n    SELECT customer_number, COUNT(order_number) AS order_count\\n    FROM Orders\\n    GROUP BY customer_number\\n) counts\\nON o.customer_number = counts.customer_number\\nORDER BY counts.order_count DESC\\nLIMIT 1;"
                    },
                    {
                        "username": "uaoiuaoi",
                        "content": "For pandasman. For empty input output is pd.DataFrame({'customer_number': []})\nI can't to solve by orders.groupby('customer_number').count().idxmax(). Why? value_counts() works"
                    },
                    {
                        "username": "aleh_dalzh",
                        "content": "T-SQL\\n\\nSELECT TOP(1)\\n    ords.customer_number\\nFROM Orders AS ords\\n    GROUP BY ords.customer_number\\n    ORDER BY COUNT(ords.customer_number) DESC"
                    },
                    {
                        "username": "edithi",
                        "content": "You can use the value_counts() function to calculate the count of each unique customer number in the \\'orders\\' DataFrame. Then, you can use the idxmax() function to find the customer number with the largest count. Make sure to handle the case when the DataFrame is empty to avoid errors."
                    }
                ]
            },
            {
                "id": 2004926,
                "content": [
                    {
                        "username": "allispaul",
                        "content": "Testcase 1 for me is an empty table, which contradicts the problem constraint (that there\\'s exactly one customer who\\'s placed the most orders). Is this intentional?"
                    },
                    {
                        "username": "Sathya_Bala",
                        "content": " select customer_number from orders \\nwhere customer_number > 2\\ngroup by  customer_number;"
                    },
                    {
                        "username": "Zivko",
                        "content": "WITH CTE AS\\n(SELECT customer_number, COUNT(order_number) AS OrderCount\\nFROM Orders\\nGROUP BY customer_number)\\n\\nSELECT customer_number\\nFROM CTE\\nWHERE OrderCount IN (SELECT MAX(OrderCount) FROM CTE)"
                    },
                    {
                        "username": "karanbhosale753",
                        "content": "select customer_number from\\n(select count(order_number) as cnt,customer_number\\nfrom Orders \\ngroup by customer_number\\nhaving cnt > 1) as a"
                    },
                    {
                        "username": "shahulaslam13",
                        "content": "select customer_number from orders\\ngroup by customer_number\\nhaving count(customer_number)>1;"
                    },
                    {
                        "username": "Zivko",
                        "content": "What would be if you have customer_number with 2 and 3 order_number?"
                    },
                    {
                        "username": "wjd2197",
                        "content": "SELECT customer_number\\nFROM Orders\\nGROUP BY customer_number\\nORDER BY COUNT(*) DESC\\nLIMIT 1"
                    },
                    {
                        "username": "priyankamanocha246",
                        "content": "select customer_number \\nfrom Orders\\ngroup by customer_number\\norder by customer_number desc\\nlimit 1;"
                    },
                    {
                        "username": "Vucius",
                        "content": "Can someone tell me why these two statements failed the test?\n```\nSELECT COALESCE(MAX(customer_number), '') AS customer_number\nFROM Orders;\n```\nand\n```\nSELECT IFNULL(MAX(Orders.customer_number), '') AS customer_number\nFROM Orders;\n```"
                    },
                    {
                        "username": "rodneirpo",
                        "content": "The answer of MAX(customer_number)  is 3 too. Because in this database, the number\\'s max is 3, BUT it is a coincidence. You must obtain the biggest frequency and not the bigger number in the column. So first you have to count how many times the customer did order and sort by the number of orders\\n\\n\\n\\nwith sb as (\\nselect\\ncustomer_number,\\ncount(distinct order_number) as num\\nfrom orders\\ngroup by customer_number\\norder by num desc\\nlimit 1)\\nselect customer_number from sb"
                    },
                    {
                        "username": "Anmol_29",
                        "content": "with cte as(\\n    select *, count(*) over(partition by customer_number) as cnt from Orders\\n)\\nselect distinct customer_number from cte where cnt = (select max(cnt) from cte )"
                    },
                    {
                        "username": "nainarahangdale",
                        "content": "select customer_number\\nfrom orders\\ngroup by customer_number\\nhaving count(*)>1\\nlimit 1"
                    }
                ]
            },
            {
                "id": 1994365,
                "content": [
                    {
                        "username": "allispaul",
                        "content": "Testcase 1 for me is an empty table, which contradicts the problem constraint (that there\\'s exactly one customer who\\'s placed the most orders). Is this intentional?"
                    },
                    {
                        "username": "Sathya_Bala",
                        "content": " select customer_number from orders \\nwhere customer_number > 2\\ngroup by  customer_number;"
                    },
                    {
                        "username": "Zivko",
                        "content": "WITH CTE AS\\n(SELECT customer_number, COUNT(order_number) AS OrderCount\\nFROM Orders\\nGROUP BY customer_number)\\n\\nSELECT customer_number\\nFROM CTE\\nWHERE OrderCount IN (SELECT MAX(OrderCount) FROM CTE)"
                    },
                    {
                        "username": "karanbhosale753",
                        "content": "select customer_number from\\n(select count(order_number) as cnt,customer_number\\nfrom Orders \\ngroup by customer_number\\nhaving cnt > 1) as a"
                    },
                    {
                        "username": "shahulaslam13",
                        "content": "select customer_number from orders\\ngroup by customer_number\\nhaving count(customer_number)>1;"
                    },
                    {
                        "username": "Zivko",
                        "content": "What would be if you have customer_number with 2 and 3 order_number?"
                    },
                    {
                        "username": "wjd2197",
                        "content": "SELECT customer_number\\nFROM Orders\\nGROUP BY customer_number\\nORDER BY COUNT(*) DESC\\nLIMIT 1"
                    },
                    {
                        "username": "priyankamanocha246",
                        "content": "select customer_number \\nfrom Orders\\ngroup by customer_number\\norder by customer_number desc\\nlimit 1;"
                    },
                    {
                        "username": "Vucius",
                        "content": "Can someone tell me why these two statements failed the test?\n```\nSELECT COALESCE(MAX(customer_number), '') AS customer_number\nFROM Orders;\n```\nand\n```\nSELECT IFNULL(MAX(Orders.customer_number), '') AS customer_number\nFROM Orders;\n```"
                    },
                    {
                        "username": "rodneirpo",
                        "content": "The answer of MAX(customer_number)  is 3 too. Because in this database, the number\\'s max is 3, BUT it is a coincidence. You must obtain the biggest frequency and not the bigger number in the column. So first you have to count how many times the customer did order and sort by the number of orders\\n\\n\\n\\nwith sb as (\\nselect\\ncustomer_number,\\ncount(distinct order_number) as num\\nfrom orders\\ngroup by customer_number\\norder by num desc\\nlimit 1)\\nselect customer_number from sb"
                    },
                    {
                        "username": "Anmol_29",
                        "content": "with cte as(\\n    select *, count(*) over(partition by customer_number) as cnt from Orders\\n)\\nselect distinct customer_number from cte where cnt = (select max(cnt) from cte )"
                    },
                    {
                        "username": "nainarahangdale",
                        "content": "select customer_number\\nfrom orders\\ngroup by customer_number\\nhaving count(*)>1\\nlimit 1"
                    }
                ]
            },
            {
                "id": 1988737,
                "content": [
                    {
                        "username": "allispaul",
                        "content": "Testcase 1 for me is an empty table, which contradicts the problem constraint (that there\\'s exactly one customer who\\'s placed the most orders). Is this intentional?"
                    },
                    {
                        "username": "Sathya_Bala",
                        "content": " select customer_number from orders \\nwhere customer_number > 2\\ngroup by  customer_number;"
                    },
                    {
                        "username": "Zivko",
                        "content": "WITH CTE AS\\n(SELECT customer_number, COUNT(order_number) AS OrderCount\\nFROM Orders\\nGROUP BY customer_number)\\n\\nSELECT customer_number\\nFROM CTE\\nWHERE OrderCount IN (SELECT MAX(OrderCount) FROM CTE)"
                    },
                    {
                        "username": "karanbhosale753",
                        "content": "select customer_number from\\n(select count(order_number) as cnt,customer_number\\nfrom Orders \\ngroup by customer_number\\nhaving cnt > 1) as a"
                    },
                    {
                        "username": "shahulaslam13",
                        "content": "select customer_number from orders\\ngroup by customer_number\\nhaving count(customer_number)>1;"
                    },
                    {
                        "username": "Zivko",
                        "content": "What would be if you have customer_number with 2 and 3 order_number?"
                    },
                    {
                        "username": "wjd2197",
                        "content": "SELECT customer_number\\nFROM Orders\\nGROUP BY customer_number\\nORDER BY COUNT(*) DESC\\nLIMIT 1"
                    },
                    {
                        "username": "priyankamanocha246",
                        "content": "select customer_number \\nfrom Orders\\ngroup by customer_number\\norder by customer_number desc\\nlimit 1;"
                    },
                    {
                        "username": "Vucius",
                        "content": "Can someone tell me why these two statements failed the test?\n```\nSELECT COALESCE(MAX(customer_number), '') AS customer_number\nFROM Orders;\n```\nand\n```\nSELECT IFNULL(MAX(Orders.customer_number), '') AS customer_number\nFROM Orders;\n```"
                    },
                    {
                        "username": "rodneirpo",
                        "content": "The answer of MAX(customer_number)  is 3 too. Because in this database, the number\\'s max is 3, BUT it is a coincidence. You must obtain the biggest frequency and not the bigger number in the column. So first you have to count how many times the customer did order and sort by the number of orders\\n\\n\\n\\nwith sb as (\\nselect\\ncustomer_number,\\ncount(distinct order_number) as num\\nfrom orders\\ngroup by customer_number\\norder by num desc\\nlimit 1)\\nselect customer_number from sb"
                    },
                    {
                        "username": "Anmol_29",
                        "content": "with cte as(\\n    select *, count(*) over(partition by customer_number) as cnt from Orders\\n)\\nselect distinct customer_number from cte where cnt = (select max(cnt) from cte )"
                    },
                    {
                        "username": "nainarahangdale",
                        "content": "select customer_number\\nfrom orders\\ngroup by customer_number\\nhaving count(*)>1\\nlimit 1"
                    }
                ]
            },
            {
                "id": 1972834,
                "content": [
                    {
                        "username": "allispaul",
                        "content": "Testcase 1 for me is an empty table, which contradicts the problem constraint (that there\\'s exactly one customer who\\'s placed the most orders). Is this intentional?"
                    },
                    {
                        "username": "Sathya_Bala",
                        "content": " select customer_number from orders \\nwhere customer_number > 2\\ngroup by  customer_number;"
                    },
                    {
                        "username": "Zivko",
                        "content": "WITH CTE AS\\n(SELECT customer_number, COUNT(order_number) AS OrderCount\\nFROM Orders\\nGROUP BY customer_number)\\n\\nSELECT customer_number\\nFROM CTE\\nWHERE OrderCount IN (SELECT MAX(OrderCount) FROM CTE)"
                    },
                    {
                        "username": "karanbhosale753",
                        "content": "select customer_number from\\n(select count(order_number) as cnt,customer_number\\nfrom Orders \\ngroup by customer_number\\nhaving cnt > 1) as a"
                    },
                    {
                        "username": "shahulaslam13",
                        "content": "select customer_number from orders\\ngroup by customer_number\\nhaving count(customer_number)>1;"
                    },
                    {
                        "username": "Zivko",
                        "content": "What would be if you have customer_number with 2 and 3 order_number?"
                    },
                    {
                        "username": "wjd2197",
                        "content": "SELECT customer_number\\nFROM Orders\\nGROUP BY customer_number\\nORDER BY COUNT(*) DESC\\nLIMIT 1"
                    },
                    {
                        "username": "priyankamanocha246",
                        "content": "select customer_number \\nfrom Orders\\ngroup by customer_number\\norder by customer_number desc\\nlimit 1;"
                    },
                    {
                        "username": "Vucius",
                        "content": "Can someone tell me why these two statements failed the test?\n```\nSELECT COALESCE(MAX(customer_number), '') AS customer_number\nFROM Orders;\n```\nand\n```\nSELECT IFNULL(MAX(Orders.customer_number), '') AS customer_number\nFROM Orders;\n```"
                    },
                    {
                        "username": "rodneirpo",
                        "content": "The answer of MAX(customer_number)  is 3 too. Because in this database, the number\\'s max is 3, BUT it is a coincidence. You must obtain the biggest frequency and not the bigger number in the column. So first you have to count how many times the customer did order and sort by the number of orders\\n\\n\\n\\nwith sb as (\\nselect\\ncustomer_number,\\ncount(distinct order_number) as num\\nfrom orders\\ngroup by customer_number\\norder by num desc\\nlimit 1)\\nselect customer_number from sb"
                    },
                    {
                        "username": "Anmol_29",
                        "content": "with cte as(\\n    select *, count(*) over(partition by customer_number) as cnt from Orders\\n)\\nselect distinct customer_number from cte where cnt = (select max(cnt) from cte )"
                    },
                    {
                        "username": "nainarahangdale",
                        "content": "select customer_number\\nfrom orders\\ngroup by customer_number\\nhaving count(*)>1\\nlimit 1"
                    }
                ]
            },
            {
                "id": 1968176,
                "content": [
                    {
                        "username": "allispaul",
                        "content": "Testcase 1 for me is an empty table, which contradicts the problem constraint (that there\\'s exactly one customer who\\'s placed the most orders). Is this intentional?"
                    },
                    {
                        "username": "Sathya_Bala",
                        "content": " select customer_number from orders \\nwhere customer_number > 2\\ngroup by  customer_number;"
                    },
                    {
                        "username": "Zivko",
                        "content": "WITH CTE AS\\n(SELECT customer_number, COUNT(order_number) AS OrderCount\\nFROM Orders\\nGROUP BY customer_number)\\n\\nSELECT customer_number\\nFROM CTE\\nWHERE OrderCount IN (SELECT MAX(OrderCount) FROM CTE)"
                    },
                    {
                        "username": "karanbhosale753",
                        "content": "select customer_number from\\n(select count(order_number) as cnt,customer_number\\nfrom Orders \\ngroup by customer_number\\nhaving cnt > 1) as a"
                    },
                    {
                        "username": "shahulaslam13",
                        "content": "select customer_number from orders\\ngroup by customer_number\\nhaving count(customer_number)>1;"
                    },
                    {
                        "username": "Zivko",
                        "content": "What would be if you have customer_number with 2 and 3 order_number?"
                    },
                    {
                        "username": "wjd2197",
                        "content": "SELECT customer_number\\nFROM Orders\\nGROUP BY customer_number\\nORDER BY COUNT(*) DESC\\nLIMIT 1"
                    },
                    {
                        "username": "priyankamanocha246",
                        "content": "select customer_number \\nfrom Orders\\ngroup by customer_number\\norder by customer_number desc\\nlimit 1;"
                    },
                    {
                        "username": "Vucius",
                        "content": "Can someone tell me why these two statements failed the test?\n```\nSELECT COALESCE(MAX(customer_number), '') AS customer_number\nFROM Orders;\n```\nand\n```\nSELECT IFNULL(MAX(Orders.customer_number), '') AS customer_number\nFROM Orders;\n```"
                    },
                    {
                        "username": "rodneirpo",
                        "content": "The answer of MAX(customer_number)  is 3 too. Because in this database, the number\\'s max is 3, BUT it is a coincidence. You must obtain the biggest frequency and not the bigger number in the column. So first you have to count how many times the customer did order and sort by the number of orders\\n\\n\\n\\nwith sb as (\\nselect\\ncustomer_number,\\ncount(distinct order_number) as num\\nfrom orders\\ngroup by customer_number\\norder by num desc\\nlimit 1)\\nselect customer_number from sb"
                    },
                    {
                        "username": "Anmol_29",
                        "content": "with cte as(\\n    select *, count(*) over(partition by customer_number) as cnt from Orders\\n)\\nselect distinct customer_number from cte where cnt = (select max(cnt) from cte )"
                    },
                    {
                        "username": "nainarahangdale",
                        "content": "select customer_number\\nfrom orders\\ngroup by customer_number\\nhaving count(*)>1\\nlimit 1"
                    }
                ]
            },
            {
                "id": 1960523,
                "content": [
                    {
                        "username": "allispaul",
                        "content": "Testcase 1 for me is an empty table, which contradicts the problem constraint (that there\\'s exactly one customer who\\'s placed the most orders). Is this intentional?"
                    },
                    {
                        "username": "Sathya_Bala",
                        "content": " select customer_number from orders \\nwhere customer_number > 2\\ngroup by  customer_number;"
                    },
                    {
                        "username": "Zivko",
                        "content": "WITH CTE AS\\n(SELECT customer_number, COUNT(order_number) AS OrderCount\\nFROM Orders\\nGROUP BY customer_number)\\n\\nSELECT customer_number\\nFROM CTE\\nWHERE OrderCount IN (SELECT MAX(OrderCount) FROM CTE)"
                    },
                    {
                        "username": "karanbhosale753",
                        "content": "select customer_number from\\n(select count(order_number) as cnt,customer_number\\nfrom Orders \\ngroup by customer_number\\nhaving cnt > 1) as a"
                    },
                    {
                        "username": "shahulaslam13",
                        "content": "select customer_number from orders\\ngroup by customer_number\\nhaving count(customer_number)>1;"
                    },
                    {
                        "username": "Zivko",
                        "content": "What would be if you have customer_number with 2 and 3 order_number?"
                    },
                    {
                        "username": "wjd2197",
                        "content": "SELECT customer_number\\nFROM Orders\\nGROUP BY customer_number\\nORDER BY COUNT(*) DESC\\nLIMIT 1"
                    },
                    {
                        "username": "priyankamanocha246",
                        "content": "select customer_number \\nfrom Orders\\ngroup by customer_number\\norder by customer_number desc\\nlimit 1;"
                    },
                    {
                        "username": "Vucius",
                        "content": "Can someone tell me why these two statements failed the test?\n```\nSELECT COALESCE(MAX(customer_number), '') AS customer_number\nFROM Orders;\n```\nand\n```\nSELECT IFNULL(MAX(Orders.customer_number), '') AS customer_number\nFROM Orders;\n```"
                    },
                    {
                        "username": "rodneirpo",
                        "content": "The answer of MAX(customer_number)  is 3 too. Because in this database, the number\\'s max is 3, BUT it is a coincidence. You must obtain the biggest frequency and not the bigger number in the column. So first you have to count how many times the customer did order and sort by the number of orders\\n\\n\\n\\nwith sb as (\\nselect\\ncustomer_number,\\ncount(distinct order_number) as num\\nfrom orders\\ngroup by customer_number\\norder by num desc\\nlimit 1)\\nselect customer_number from sb"
                    },
                    {
                        "username": "Anmol_29",
                        "content": "with cte as(\\n    select *, count(*) over(partition by customer_number) as cnt from Orders\\n)\\nselect distinct customer_number from cte where cnt = (select max(cnt) from cte )"
                    },
                    {
                        "username": "nainarahangdale",
                        "content": "select customer_number\\nfrom orders\\ngroup by customer_number\\nhaving count(*)>1\\nlimit 1"
                    }
                ]
            },
            {
                "id": 1918861,
                "content": [
                    {
                        "username": "allispaul",
                        "content": "Testcase 1 for me is an empty table, which contradicts the problem constraint (that there\\'s exactly one customer who\\'s placed the most orders). Is this intentional?"
                    },
                    {
                        "username": "Sathya_Bala",
                        "content": " select customer_number from orders \\nwhere customer_number > 2\\ngroup by  customer_number;"
                    },
                    {
                        "username": "Zivko",
                        "content": "WITH CTE AS\\n(SELECT customer_number, COUNT(order_number) AS OrderCount\\nFROM Orders\\nGROUP BY customer_number)\\n\\nSELECT customer_number\\nFROM CTE\\nWHERE OrderCount IN (SELECT MAX(OrderCount) FROM CTE)"
                    },
                    {
                        "username": "karanbhosale753",
                        "content": "select customer_number from\\n(select count(order_number) as cnt,customer_number\\nfrom Orders \\ngroup by customer_number\\nhaving cnt > 1) as a"
                    },
                    {
                        "username": "shahulaslam13",
                        "content": "select customer_number from orders\\ngroup by customer_number\\nhaving count(customer_number)>1;"
                    },
                    {
                        "username": "Zivko",
                        "content": "What would be if you have customer_number with 2 and 3 order_number?"
                    },
                    {
                        "username": "wjd2197",
                        "content": "SELECT customer_number\\nFROM Orders\\nGROUP BY customer_number\\nORDER BY COUNT(*) DESC\\nLIMIT 1"
                    },
                    {
                        "username": "priyankamanocha246",
                        "content": "select customer_number \\nfrom Orders\\ngroup by customer_number\\norder by customer_number desc\\nlimit 1;"
                    },
                    {
                        "username": "Vucius",
                        "content": "Can someone tell me why these two statements failed the test?\n```\nSELECT COALESCE(MAX(customer_number), '') AS customer_number\nFROM Orders;\n```\nand\n```\nSELECT IFNULL(MAX(Orders.customer_number), '') AS customer_number\nFROM Orders;\n```"
                    },
                    {
                        "username": "rodneirpo",
                        "content": "The answer of MAX(customer_number)  is 3 too. Because in this database, the number\\'s max is 3, BUT it is a coincidence. You must obtain the biggest frequency and not the bigger number in the column. So first you have to count how many times the customer did order and sort by the number of orders\\n\\n\\n\\nwith sb as (\\nselect\\ncustomer_number,\\ncount(distinct order_number) as num\\nfrom orders\\ngroup by customer_number\\norder by num desc\\nlimit 1)\\nselect customer_number from sb"
                    },
                    {
                        "username": "Anmol_29",
                        "content": "with cte as(\\n    select *, count(*) over(partition by customer_number) as cnt from Orders\\n)\\nselect distinct customer_number from cte where cnt = (select max(cnt) from cte )"
                    },
                    {
                        "username": "nainarahangdale",
                        "content": "select customer_number\\nfrom orders\\ngroup by customer_number\\nhaving count(*)>1\\nlimit 1"
                    }
                ]
            },
            {
                "id": 1913952,
                "content": [
                    {
                        "username": "allispaul",
                        "content": "Testcase 1 for me is an empty table, which contradicts the problem constraint (that there\\'s exactly one customer who\\'s placed the most orders). Is this intentional?"
                    },
                    {
                        "username": "Sathya_Bala",
                        "content": " select customer_number from orders \\nwhere customer_number > 2\\ngroup by  customer_number;"
                    },
                    {
                        "username": "Zivko",
                        "content": "WITH CTE AS\\n(SELECT customer_number, COUNT(order_number) AS OrderCount\\nFROM Orders\\nGROUP BY customer_number)\\n\\nSELECT customer_number\\nFROM CTE\\nWHERE OrderCount IN (SELECT MAX(OrderCount) FROM CTE)"
                    },
                    {
                        "username": "karanbhosale753",
                        "content": "select customer_number from\\n(select count(order_number) as cnt,customer_number\\nfrom Orders \\ngroup by customer_number\\nhaving cnt > 1) as a"
                    },
                    {
                        "username": "shahulaslam13",
                        "content": "select customer_number from orders\\ngroup by customer_number\\nhaving count(customer_number)>1;"
                    },
                    {
                        "username": "Zivko",
                        "content": "What would be if you have customer_number with 2 and 3 order_number?"
                    },
                    {
                        "username": "wjd2197",
                        "content": "SELECT customer_number\\nFROM Orders\\nGROUP BY customer_number\\nORDER BY COUNT(*) DESC\\nLIMIT 1"
                    },
                    {
                        "username": "priyankamanocha246",
                        "content": "select customer_number \\nfrom Orders\\ngroup by customer_number\\norder by customer_number desc\\nlimit 1;"
                    },
                    {
                        "username": "Vucius",
                        "content": "Can someone tell me why these two statements failed the test?\n```\nSELECT COALESCE(MAX(customer_number), '') AS customer_number\nFROM Orders;\n```\nand\n```\nSELECT IFNULL(MAX(Orders.customer_number), '') AS customer_number\nFROM Orders;\n```"
                    },
                    {
                        "username": "rodneirpo",
                        "content": "The answer of MAX(customer_number)  is 3 too. Because in this database, the number\\'s max is 3, BUT it is a coincidence. You must obtain the biggest frequency and not the bigger number in the column. So first you have to count how many times the customer did order and sort by the number of orders\\n\\n\\n\\nwith sb as (\\nselect\\ncustomer_number,\\ncount(distinct order_number) as num\\nfrom orders\\ngroup by customer_number\\norder by num desc\\nlimit 1)\\nselect customer_number from sb"
                    },
                    {
                        "username": "Anmol_29",
                        "content": "with cte as(\\n    select *, count(*) over(partition by customer_number) as cnt from Orders\\n)\\nselect distinct customer_number from cte where cnt = (select max(cnt) from cte )"
                    },
                    {
                        "username": "nainarahangdale",
                        "content": "select customer_number\\nfrom orders\\ngroup by customer_number\\nhaving count(*)>1\\nlimit 1"
                    }
                ]
            },
            {
                "id": 1873588,
                "content": [
                    {
                        "username": "allispaul",
                        "content": "Testcase 1 for me is an empty table, which contradicts the problem constraint (that there\\'s exactly one customer who\\'s placed the most orders). Is this intentional?"
                    },
                    {
                        "username": "Sathya_Bala",
                        "content": " select customer_number from orders \\nwhere customer_number > 2\\ngroup by  customer_number;"
                    },
                    {
                        "username": "Zivko",
                        "content": "WITH CTE AS\\n(SELECT customer_number, COUNT(order_number) AS OrderCount\\nFROM Orders\\nGROUP BY customer_number)\\n\\nSELECT customer_number\\nFROM CTE\\nWHERE OrderCount IN (SELECT MAX(OrderCount) FROM CTE)"
                    },
                    {
                        "username": "karanbhosale753",
                        "content": "select customer_number from\\n(select count(order_number) as cnt,customer_number\\nfrom Orders \\ngroup by customer_number\\nhaving cnt > 1) as a"
                    },
                    {
                        "username": "shahulaslam13",
                        "content": "select customer_number from orders\\ngroup by customer_number\\nhaving count(customer_number)>1;"
                    },
                    {
                        "username": "Zivko",
                        "content": "What would be if you have customer_number with 2 and 3 order_number?"
                    },
                    {
                        "username": "wjd2197",
                        "content": "SELECT customer_number\\nFROM Orders\\nGROUP BY customer_number\\nORDER BY COUNT(*) DESC\\nLIMIT 1"
                    },
                    {
                        "username": "priyankamanocha246",
                        "content": "select customer_number \\nfrom Orders\\ngroup by customer_number\\norder by customer_number desc\\nlimit 1;"
                    },
                    {
                        "username": "Vucius",
                        "content": "Can someone tell me why these two statements failed the test?\n```\nSELECT COALESCE(MAX(customer_number), '') AS customer_number\nFROM Orders;\n```\nand\n```\nSELECT IFNULL(MAX(Orders.customer_number), '') AS customer_number\nFROM Orders;\n```"
                    },
                    {
                        "username": "rodneirpo",
                        "content": "The answer of MAX(customer_number)  is 3 too. Because in this database, the number\\'s max is 3, BUT it is a coincidence. You must obtain the biggest frequency and not the bigger number in the column. So first you have to count how many times the customer did order and sort by the number of orders\\n\\n\\n\\nwith sb as (\\nselect\\ncustomer_number,\\ncount(distinct order_number) as num\\nfrom orders\\ngroup by customer_number\\norder by num desc\\nlimit 1)\\nselect customer_number from sb"
                    },
                    {
                        "username": "Anmol_29",
                        "content": "with cte as(\\n    select *, count(*) over(partition by customer_number) as cnt from Orders\\n)\\nselect distinct customer_number from cte where cnt = (select max(cnt) from cte )"
                    },
                    {
                        "username": "nainarahangdale",
                        "content": "select customer_number\\nfrom orders\\ngroup by customer_number\\nhaving count(*)>1\\nlimit 1"
                    }
                ]
            },
            {
                "id": 1868617,
                "content": [
                    {
                        "username": "allispaul",
                        "content": "Testcase 1 for me is an empty table, which contradicts the problem constraint (that there\\'s exactly one customer who\\'s placed the most orders). Is this intentional?"
                    },
                    {
                        "username": "Sathya_Bala",
                        "content": " select customer_number from orders \\nwhere customer_number > 2\\ngroup by  customer_number;"
                    },
                    {
                        "username": "Zivko",
                        "content": "WITH CTE AS\\n(SELECT customer_number, COUNT(order_number) AS OrderCount\\nFROM Orders\\nGROUP BY customer_number)\\n\\nSELECT customer_number\\nFROM CTE\\nWHERE OrderCount IN (SELECT MAX(OrderCount) FROM CTE)"
                    },
                    {
                        "username": "karanbhosale753",
                        "content": "select customer_number from\\n(select count(order_number) as cnt,customer_number\\nfrom Orders \\ngroup by customer_number\\nhaving cnt > 1) as a"
                    },
                    {
                        "username": "shahulaslam13",
                        "content": "select customer_number from orders\\ngroup by customer_number\\nhaving count(customer_number)>1;"
                    },
                    {
                        "username": "Zivko",
                        "content": "What would be if you have customer_number with 2 and 3 order_number?"
                    },
                    {
                        "username": "wjd2197",
                        "content": "SELECT customer_number\\nFROM Orders\\nGROUP BY customer_number\\nORDER BY COUNT(*) DESC\\nLIMIT 1"
                    },
                    {
                        "username": "priyankamanocha246",
                        "content": "select customer_number \\nfrom Orders\\ngroup by customer_number\\norder by customer_number desc\\nlimit 1;"
                    },
                    {
                        "username": "Vucius",
                        "content": "Can someone tell me why these two statements failed the test?\n```\nSELECT COALESCE(MAX(customer_number), '') AS customer_number\nFROM Orders;\n```\nand\n```\nSELECT IFNULL(MAX(Orders.customer_number), '') AS customer_number\nFROM Orders;\n```"
                    },
                    {
                        "username": "rodneirpo",
                        "content": "The answer of MAX(customer_number)  is 3 too. Because in this database, the number\\'s max is 3, BUT it is a coincidence. You must obtain the biggest frequency and not the bigger number in the column. So first you have to count how many times the customer did order and sort by the number of orders\\n\\n\\n\\nwith sb as (\\nselect\\ncustomer_number,\\ncount(distinct order_number) as num\\nfrom orders\\ngroup by customer_number\\norder by num desc\\nlimit 1)\\nselect customer_number from sb"
                    },
                    {
                        "username": "Anmol_29",
                        "content": "with cte as(\\n    select *, count(*) over(partition by customer_number) as cnt from Orders\\n)\\nselect distinct customer_number from cte where cnt = (select max(cnt) from cte )"
                    },
                    {
                        "username": "nainarahangdale",
                        "content": "select customer_number\\nfrom orders\\ngroup by customer_number\\nhaving count(*)>1\\nlimit 1"
                    }
                ]
            },
            {
                "id": 1856134,
                "content": [
                    {
                        "username": "priyarb96",
                        "content": "with cte as\\n(\\nselect\\ncustomer_number\\n,count(*) as count_orders\\nfrom \\norders\\ngroup by customer_number\\n)\\n\\nselect customer_number from cte\\nwhere count_orders = (select max(count_orders) from cte)"
                    },
                    {
                        "username": "Vaibhav_124",
                        "content": " `SELECT CUSTOMER_NUMBER FROM orders\\nGROUP BY CUSTOMER_NUMBER ORDER BY COUNT(ORDER_NUMBER) DESC\\nLIMIT 1;`"
                    },
                    {
                        "username": "arthireddy",
                        "content": "SELECT IFNULL((SELECT MAX(customer_number) FROM Orders), \\'\\') AS customer_number;\\nwhy does the above code gives me wrong answer even though the code is correct and the output looks same as expected.?"
                    },
                    {
                        "username": "Dibayranjan",
                        "content": "SELECT top 1 customer_number\\nFROM orders\\nGROUP BY customer_number\\nORDER BY COUNT(*) DESC\\n\\n"
                    },
                    {
                        "username": "user2392CP",
                        "content": "select customer_number\\nfrom Orders\\ngroup by customer_number\\norder by count(customer_number) desc limit 1;"
                    },
                    {
                        "username": "sulata123",
                        "content": "select customer_number from Orders o , (select customer_number,count(order_number) as m from Orders group by customer_number )t where t.customer_number=o.customer_number and t.m=max(t.m) ;      why this throws error"
                    },
                    {
                        "username": "Nishantvohra",
                        "content": "Select Customer_number from orders group by Customer_number having Count(order_number)= \\n(Select Max(a.Count) from (Select Count(order_number) as \\'Count\\' from orders group by customer_number)a);"
                    },
                    {
                        "username": "Nayeem4080",
                        "content": "with cte as (select customer_number,count(customer_number) as counts\\nfrom Orders\\ngroup by customer_number)\\nselect customer_number\\nfrom cte\\nhaving counts = (select max(counts)\\nfrom cte)\\n\\nwhy doesn\\'t this work?\\n"
                    },
                    {
                        "username": "Hopkins666",
                        "content": "I created a table but not able to use it.\\n\\nCreate Table YYY AS\\nselect customer_number, count(order_number) as \"quantity\" from Orders\\nGroup by customer_number\\n\\nSelect * from YYY\\n\\nGot error message."
                    },
                    {
                        "username": "ceciliabababa",
                        "content": "Could anyone tell me why does my code return the wrong result please?\\n\\nSelect t.customer_number\\nFrom (\\n    Select o.customer_number, count(o.order_number) AS sumorder\\n    From orders o\\n    Group By o.customer_number ) As t\\nHaving max(t.sumorder)\\n"
                    }
                ]
            },
            {
                "id": 1818784,
                "content": [
                    {
                        "username": "priyarb96",
                        "content": "with cte as\\n(\\nselect\\ncustomer_number\\n,count(*) as count_orders\\nfrom \\norders\\ngroup by customer_number\\n)\\n\\nselect customer_number from cte\\nwhere count_orders = (select max(count_orders) from cte)"
                    },
                    {
                        "username": "Vaibhav_124",
                        "content": " `SELECT CUSTOMER_NUMBER FROM orders\\nGROUP BY CUSTOMER_NUMBER ORDER BY COUNT(ORDER_NUMBER) DESC\\nLIMIT 1;`"
                    },
                    {
                        "username": "arthireddy",
                        "content": "SELECT IFNULL((SELECT MAX(customer_number) FROM Orders), \\'\\') AS customer_number;\\nwhy does the above code gives me wrong answer even though the code is correct and the output looks same as expected.?"
                    },
                    {
                        "username": "Dibayranjan",
                        "content": "SELECT top 1 customer_number\\nFROM orders\\nGROUP BY customer_number\\nORDER BY COUNT(*) DESC\\n\\n"
                    },
                    {
                        "username": "user2392CP",
                        "content": "select customer_number\\nfrom Orders\\ngroup by customer_number\\norder by count(customer_number) desc limit 1;"
                    },
                    {
                        "username": "sulata123",
                        "content": "select customer_number from Orders o , (select customer_number,count(order_number) as m from Orders group by customer_number )t where t.customer_number=o.customer_number and t.m=max(t.m) ;      why this throws error"
                    },
                    {
                        "username": "Nishantvohra",
                        "content": "Select Customer_number from orders group by Customer_number having Count(order_number)= \\n(Select Max(a.Count) from (Select Count(order_number) as \\'Count\\' from orders group by customer_number)a);"
                    },
                    {
                        "username": "Nayeem4080",
                        "content": "with cte as (select customer_number,count(customer_number) as counts\\nfrom Orders\\ngroup by customer_number)\\nselect customer_number\\nfrom cte\\nhaving counts = (select max(counts)\\nfrom cte)\\n\\nwhy doesn\\'t this work?\\n"
                    },
                    {
                        "username": "Hopkins666",
                        "content": "I created a table but not able to use it.\\n\\nCreate Table YYY AS\\nselect customer_number, count(order_number) as \"quantity\" from Orders\\nGroup by customer_number\\n\\nSelect * from YYY\\n\\nGot error message."
                    },
                    {
                        "username": "ceciliabababa",
                        "content": "Could anyone tell me why does my code return the wrong result please?\\n\\nSelect t.customer_number\\nFrom (\\n    Select o.customer_number, count(o.order_number) AS sumorder\\n    From orders o\\n    Group By o.customer_number ) As t\\nHaving max(t.sumorder)\\n"
                    }
                ]
            },
            {
                "id": 1809301,
                "content": [
                    {
                        "username": "priyarb96",
                        "content": "with cte as\\n(\\nselect\\ncustomer_number\\n,count(*) as count_orders\\nfrom \\norders\\ngroup by customer_number\\n)\\n\\nselect customer_number from cte\\nwhere count_orders = (select max(count_orders) from cte)"
                    },
                    {
                        "username": "Vaibhav_124",
                        "content": " `SELECT CUSTOMER_NUMBER FROM orders\\nGROUP BY CUSTOMER_NUMBER ORDER BY COUNT(ORDER_NUMBER) DESC\\nLIMIT 1;`"
                    },
                    {
                        "username": "arthireddy",
                        "content": "SELECT IFNULL((SELECT MAX(customer_number) FROM Orders), \\'\\') AS customer_number;\\nwhy does the above code gives me wrong answer even though the code is correct and the output looks same as expected.?"
                    },
                    {
                        "username": "Dibayranjan",
                        "content": "SELECT top 1 customer_number\\nFROM orders\\nGROUP BY customer_number\\nORDER BY COUNT(*) DESC\\n\\n"
                    },
                    {
                        "username": "user2392CP",
                        "content": "select customer_number\\nfrom Orders\\ngroup by customer_number\\norder by count(customer_number) desc limit 1;"
                    },
                    {
                        "username": "sulata123",
                        "content": "select customer_number from Orders o , (select customer_number,count(order_number) as m from Orders group by customer_number )t where t.customer_number=o.customer_number and t.m=max(t.m) ;      why this throws error"
                    },
                    {
                        "username": "Nishantvohra",
                        "content": "Select Customer_number from orders group by Customer_number having Count(order_number)= \\n(Select Max(a.Count) from (Select Count(order_number) as \\'Count\\' from orders group by customer_number)a);"
                    },
                    {
                        "username": "Nayeem4080",
                        "content": "with cte as (select customer_number,count(customer_number) as counts\\nfrom Orders\\ngroup by customer_number)\\nselect customer_number\\nfrom cte\\nhaving counts = (select max(counts)\\nfrom cte)\\n\\nwhy doesn\\'t this work?\\n"
                    },
                    {
                        "username": "Hopkins666",
                        "content": "I created a table but not able to use it.\\n\\nCreate Table YYY AS\\nselect customer_number, count(order_number) as \"quantity\" from Orders\\nGroup by customer_number\\n\\nSelect * from YYY\\n\\nGot error message."
                    },
                    {
                        "username": "ceciliabababa",
                        "content": "Could anyone tell me why does my code return the wrong result please?\\n\\nSelect t.customer_number\\nFrom (\\n    Select o.customer_number, count(o.order_number) AS sumorder\\n    From orders o\\n    Group By o.customer_number ) As t\\nHaving max(t.sumorder)\\n"
                    }
                ]
            },
            {
                "id": 1805201,
                "content": [
                    {
                        "username": "priyarb96",
                        "content": "with cte as\\n(\\nselect\\ncustomer_number\\n,count(*) as count_orders\\nfrom \\norders\\ngroup by customer_number\\n)\\n\\nselect customer_number from cte\\nwhere count_orders = (select max(count_orders) from cte)"
                    },
                    {
                        "username": "Vaibhav_124",
                        "content": " `SELECT CUSTOMER_NUMBER FROM orders\\nGROUP BY CUSTOMER_NUMBER ORDER BY COUNT(ORDER_NUMBER) DESC\\nLIMIT 1;`"
                    },
                    {
                        "username": "arthireddy",
                        "content": "SELECT IFNULL((SELECT MAX(customer_number) FROM Orders), \\'\\') AS customer_number;\\nwhy does the above code gives me wrong answer even though the code is correct and the output looks same as expected.?"
                    },
                    {
                        "username": "Dibayranjan",
                        "content": "SELECT top 1 customer_number\\nFROM orders\\nGROUP BY customer_number\\nORDER BY COUNT(*) DESC\\n\\n"
                    },
                    {
                        "username": "user2392CP",
                        "content": "select customer_number\\nfrom Orders\\ngroup by customer_number\\norder by count(customer_number) desc limit 1;"
                    },
                    {
                        "username": "sulata123",
                        "content": "select customer_number from Orders o , (select customer_number,count(order_number) as m from Orders group by customer_number )t where t.customer_number=o.customer_number and t.m=max(t.m) ;      why this throws error"
                    },
                    {
                        "username": "Nishantvohra",
                        "content": "Select Customer_number from orders group by Customer_number having Count(order_number)= \\n(Select Max(a.Count) from (Select Count(order_number) as \\'Count\\' from orders group by customer_number)a);"
                    },
                    {
                        "username": "Nayeem4080",
                        "content": "with cte as (select customer_number,count(customer_number) as counts\\nfrom Orders\\ngroup by customer_number)\\nselect customer_number\\nfrom cte\\nhaving counts = (select max(counts)\\nfrom cte)\\n\\nwhy doesn\\'t this work?\\n"
                    },
                    {
                        "username": "Hopkins666",
                        "content": "I created a table but not able to use it.\\n\\nCreate Table YYY AS\\nselect customer_number, count(order_number) as \"quantity\" from Orders\\nGroup by customer_number\\n\\nSelect * from YYY\\n\\nGot error message."
                    },
                    {
                        "username": "ceciliabababa",
                        "content": "Could anyone tell me why does my code return the wrong result please?\\n\\nSelect t.customer_number\\nFrom (\\n    Select o.customer_number, count(o.order_number) AS sumorder\\n    From orders o\\n    Group By o.customer_number ) As t\\nHaving max(t.sumorder)\\n"
                    }
                ]
            },
            {
                "id": 1792147,
                "content": [
                    {
                        "username": "priyarb96",
                        "content": "with cte as\\n(\\nselect\\ncustomer_number\\n,count(*) as count_orders\\nfrom \\norders\\ngroup by customer_number\\n)\\n\\nselect customer_number from cte\\nwhere count_orders = (select max(count_orders) from cte)"
                    },
                    {
                        "username": "Vaibhav_124",
                        "content": " `SELECT CUSTOMER_NUMBER FROM orders\\nGROUP BY CUSTOMER_NUMBER ORDER BY COUNT(ORDER_NUMBER) DESC\\nLIMIT 1;`"
                    },
                    {
                        "username": "arthireddy",
                        "content": "SELECT IFNULL((SELECT MAX(customer_number) FROM Orders), \\'\\') AS customer_number;\\nwhy does the above code gives me wrong answer even though the code is correct and the output looks same as expected.?"
                    },
                    {
                        "username": "Dibayranjan",
                        "content": "SELECT top 1 customer_number\\nFROM orders\\nGROUP BY customer_number\\nORDER BY COUNT(*) DESC\\n\\n"
                    },
                    {
                        "username": "user2392CP",
                        "content": "select customer_number\\nfrom Orders\\ngroup by customer_number\\norder by count(customer_number) desc limit 1;"
                    },
                    {
                        "username": "sulata123",
                        "content": "select customer_number from Orders o , (select customer_number,count(order_number) as m from Orders group by customer_number )t where t.customer_number=o.customer_number and t.m=max(t.m) ;      why this throws error"
                    },
                    {
                        "username": "Nishantvohra",
                        "content": "Select Customer_number from orders group by Customer_number having Count(order_number)= \\n(Select Max(a.Count) from (Select Count(order_number) as \\'Count\\' from orders group by customer_number)a);"
                    },
                    {
                        "username": "Nayeem4080",
                        "content": "with cte as (select customer_number,count(customer_number) as counts\\nfrom Orders\\ngroup by customer_number)\\nselect customer_number\\nfrom cte\\nhaving counts = (select max(counts)\\nfrom cte)\\n\\nwhy doesn\\'t this work?\\n"
                    },
                    {
                        "username": "Hopkins666",
                        "content": "I created a table but not able to use it.\\n\\nCreate Table YYY AS\\nselect customer_number, count(order_number) as \"quantity\" from Orders\\nGroup by customer_number\\n\\nSelect * from YYY\\n\\nGot error message."
                    },
                    {
                        "username": "ceciliabababa",
                        "content": "Could anyone tell me why does my code return the wrong result please?\\n\\nSelect t.customer_number\\nFrom (\\n    Select o.customer_number, count(o.order_number) AS sumorder\\n    From orders o\\n    Group By o.customer_number ) As t\\nHaving max(t.sumorder)\\n"
                    }
                ]
            },
            {
                "id": 1784259,
                "content": [
                    {
                        "username": "priyarb96",
                        "content": "with cte as\\n(\\nselect\\ncustomer_number\\n,count(*) as count_orders\\nfrom \\norders\\ngroup by customer_number\\n)\\n\\nselect customer_number from cte\\nwhere count_orders = (select max(count_orders) from cte)"
                    },
                    {
                        "username": "Vaibhav_124",
                        "content": " `SELECT CUSTOMER_NUMBER FROM orders\\nGROUP BY CUSTOMER_NUMBER ORDER BY COUNT(ORDER_NUMBER) DESC\\nLIMIT 1;`"
                    },
                    {
                        "username": "arthireddy",
                        "content": "SELECT IFNULL((SELECT MAX(customer_number) FROM Orders), \\'\\') AS customer_number;\\nwhy does the above code gives me wrong answer even though the code is correct and the output looks same as expected.?"
                    },
                    {
                        "username": "Dibayranjan",
                        "content": "SELECT top 1 customer_number\\nFROM orders\\nGROUP BY customer_number\\nORDER BY COUNT(*) DESC\\n\\n"
                    },
                    {
                        "username": "user2392CP",
                        "content": "select customer_number\\nfrom Orders\\ngroup by customer_number\\norder by count(customer_number) desc limit 1;"
                    },
                    {
                        "username": "sulata123",
                        "content": "select customer_number from Orders o , (select customer_number,count(order_number) as m from Orders group by customer_number )t where t.customer_number=o.customer_number and t.m=max(t.m) ;      why this throws error"
                    },
                    {
                        "username": "Nishantvohra",
                        "content": "Select Customer_number from orders group by Customer_number having Count(order_number)= \\n(Select Max(a.Count) from (Select Count(order_number) as \\'Count\\' from orders group by customer_number)a);"
                    },
                    {
                        "username": "Nayeem4080",
                        "content": "with cte as (select customer_number,count(customer_number) as counts\\nfrom Orders\\ngroup by customer_number)\\nselect customer_number\\nfrom cte\\nhaving counts = (select max(counts)\\nfrom cte)\\n\\nwhy doesn\\'t this work?\\n"
                    },
                    {
                        "username": "Hopkins666",
                        "content": "I created a table but not able to use it.\\n\\nCreate Table YYY AS\\nselect customer_number, count(order_number) as \"quantity\" from Orders\\nGroup by customer_number\\n\\nSelect * from YYY\\n\\nGot error message."
                    },
                    {
                        "username": "ceciliabababa",
                        "content": "Could anyone tell me why does my code return the wrong result please?\\n\\nSelect t.customer_number\\nFrom (\\n    Select o.customer_number, count(o.order_number) AS sumorder\\n    From orders o\\n    Group By o.customer_number ) As t\\nHaving max(t.sumorder)\\n"
                    }
                ]
            },
            {
                "id": 1782510,
                "content": [
                    {
                        "username": "priyarb96",
                        "content": "with cte as\\n(\\nselect\\ncustomer_number\\n,count(*) as count_orders\\nfrom \\norders\\ngroup by customer_number\\n)\\n\\nselect customer_number from cte\\nwhere count_orders = (select max(count_orders) from cte)"
                    },
                    {
                        "username": "Vaibhav_124",
                        "content": " `SELECT CUSTOMER_NUMBER FROM orders\\nGROUP BY CUSTOMER_NUMBER ORDER BY COUNT(ORDER_NUMBER) DESC\\nLIMIT 1;`"
                    },
                    {
                        "username": "arthireddy",
                        "content": "SELECT IFNULL((SELECT MAX(customer_number) FROM Orders), \\'\\') AS customer_number;\\nwhy does the above code gives me wrong answer even though the code is correct and the output looks same as expected.?"
                    },
                    {
                        "username": "Dibayranjan",
                        "content": "SELECT top 1 customer_number\\nFROM orders\\nGROUP BY customer_number\\nORDER BY COUNT(*) DESC\\n\\n"
                    },
                    {
                        "username": "user2392CP",
                        "content": "select customer_number\\nfrom Orders\\ngroup by customer_number\\norder by count(customer_number) desc limit 1;"
                    },
                    {
                        "username": "sulata123",
                        "content": "select customer_number from Orders o , (select customer_number,count(order_number) as m from Orders group by customer_number )t where t.customer_number=o.customer_number and t.m=max(t.m) ;      why this throws error"
                    },
                    {
                        "username": "Nishantvohra",
                        "content": "Select Customer_number from orders group by Customer_number having Count(order_number)= \\n(Select Max(a.Count) from (Select Count(order_number) as \\'Count\\' from orders group by customer_number)a);"
                    },
                    {
                        "username": "Nayeem4080",
                        "content": "with cte as (select customer_number,count(customer_number) as counts\\nfrom Orders\\ngroup by customer_number)\\nselect customer_number\\nfrom cte\\nhaving counts = (select max(counts)\\nfrom cte)\\n\\nwhy doesn\\'t this work?\\n"
                    },
                    {
                        "username": "Hopkins666",
                        "content": "I created a table but not able to use it.\\n\\nCreate Table YYY AS\\nselect customer_number, count(order_number) as \"quantity\" from Orders\\nGroup by customer_number\\n\\nSelect * from YYY\\n\\nGot error message."
                    },
                    {
                        "username": "ceciliabababa",
                        "content": "Could anyone tell me why does my code return the wrong result please?\\n\\nSelect t.customer_number\\nFrom (\\n    Select o.customer_number, count(o.order_number) AS sumorder\\n    From orders o\\n    Group By o.customer_number ) As t\\nHaving max(t.sumorder)\\n"
                    }
                ]
            },
            {
                "id": 1775026,
                "content": [
                    {
                        "username": "priyarb96",
                        "content": "with cte as\\n(\\nselect\\ncustomer_number\\n,count(*) as count_orders\\nfrom \\norders\\ngroup by customer_number\\n)\\n\\nselect customer_number from cte\\nwhere count_orders = (select max(count_orders) from cte)"
                    },
                    {
                        "username": "Vaibhav_124",
                        "content": " `SELECT CUSTOMER_NUMBER FROM orders\\nGROUP BY CUSTOMER_NUMBER ORDER BY COUNT(ORDER_NUMBER) DESC\\nLIMIT 1;`"
                    },
                    {
                        "username": "arthireddy",
                        "content": "SELECT IFNULL((SELECT MAX(customer_number) FROM Orders), \\'\\') AS customer_number;\\nwhy does the above code gives me wrong answer even though the code is correct and the output looks same as expected.?"
                    },
                    {
                        "username": "Dibayranjan",
                        "content": "SELECT top 1 customer_number\\nFROM orders\\nGROUP BY customer_number\\nORDER BY COUNT(*) DESC\\n\\n"
                    },
                    {
                        "username": "user2392CP",
                        "content": "select customer_number\\nfrom Orders\\ngroup by customer_number\\norder by count(customer_number) desc limit 1;"
                    },
                    {
                        "username": "sulata123",
                        "content": "select customer_number from Orders o , (select customer_number,count(order_number) as m from Orders group by customer_number )t where t.customer_number=o.customer_number and t.m=max(t.m) ;      why this throws error"
                    },
                    {
                        "username": "Nishantvohra",
                        "content": "Select Customer_number from orders group by Customer_number having Count(order_number)= \\n(Select Max(a.Count) from (Select Count(order_number) as \\'Count\\' from orders group by customer_number)a);"
                    },
                    {
                        "username": "Nayeem4080",
                        "content": "with cte as (select customer_number,count(customer_number) as counts\\nfrom Orders\\ngroup by customer_number)\\nselect customer_number\\nfrom cte\\nhaving counts = (select max(counts)\\nfrom cte)\\n\\nwhy doesn\\'t this work?\\n"
                    },
                    {
                        "username": "Hopkins666",
                        "content": "I created a table but not able to use it.\\n\\nCreate Table YYY AS\\nselect customer_number, count(order_number) as \"quantity\" from Orders\\nGroup by customer_number\\n\\nSelect * from YYY\\n\\nGot error message."
                    },
                    {
                        "username": "ceciliabababa",
                        "content": "Could anyone tell me why does my code return the wrong result please?\\n\\nSelect t.customer_number\\nFrom (\\n    Select o.customer_number, count(o.order_number) AS sumorder\\n    From orders o\\n    Group By o.customer_number ) As t\\nHaving max(t.sumorder)\\n"
                    }
                ]
            },
            {
                "id": 1774765,
                "content": [
                    {
                        "username": "priyarb96",
                        "content": "with cte as\\n(\\nselect\\ncustomer_number\\n,count(*) as count_orders\\nfrom \\norders\\ngroup by customer_number\\n)\\n\\nselect customer_number from cte\\nwhere count_orders = (select max(count_orders) from cte)"
                    },
                    {
                        "username": "Vaibhav_124",
                        "content": " `SELECT CUSTOMER_NUMBER FROM orders\\nGROUP BY CUSTOMER_NUMBER ORDER BY COUNT(ORDER_NUMBER) DESC\\nLIMIT 1;`"
                    },
                    {
                        "username": "arthireddy",
                        "content": "SELECT IFNULL((SELECT MAX(customer_number) FROM Orders), \\'\\') AS customer_number;\\nwhy does the above code gives me wrong answer even though the code is correct and the output looks same as expected.?"
                    },
                    {
                        "username": "Dibayranjan",
                        "content": "SELECT top 1 customer_number\\nFROM orders\\nGROUP BY customer_number\\nORDER BY COUNT(*) DESC\\n\\n"
                    },
                    {
                        "username": "user2392CP",
                        "content": "select customer_number\\nfrom Orders\\ngroup by customer_number\\norder by count(customer_number) desc limit 1;"
                    },
                    {
                        "username": "sulata123",
                        "content": "select customer_number from Orders o , (select customer_number,count(order_number) as m from Orders group by customer_number )t where t.customer_number=o.customer_number and t.m=max(t.m) ;      why this throws error"
                    },
                    {
                        "username": "Nishantvohra",
                        "content": "Select Customer_number from orders group by Customer_number having Count(order_number)= \\n(Select Max(a.Count) from (Select Count(order_number) as \\'Count\\' from orders group by customer_number)a);"
                    },
                    {
                        "username": "Nayeem4080",
                        "content": "with cte as (select customer_number,count(customer_number) as counts\\nfrom Orders\\ngroup by customer_number)\\nselect customer_number\\nfrom cte\\nhaving counts = (select max(counts)\\nfrom cte)\\n\\nwhy doesn\\'t this work?\\n"
                    },
                    {
                        "username": "Hopkins666",
                        "content": "I created a table but not able to use it.\\n\\nCreate Table YYY AS\\nselect customer_number, count(order_number) as \"quantity\" from Orders\\nGroup by customer_number\\n\\nSelect * from YYY\\n\\nGot error message."
                    },
                    {
                        "username": "ceciliabababa",
                        "content": "Could anyone tell me why does my code return the wrong result please?\\n\\nSelect t.customer_number\\nFrom (\\n    Select o.customer_number, count(o.order_number) AS sumorder\\n    From orders o\\n    Group By o.customer_number ) As t\\nHaving max(t.sumorder)\\n"
                    }
                ]
            },
            {
                "id": 1774674,
                "content": [
                    {
                        "username": "priyarb96",
                        "content": "with cte as\\n(\\nselect\\ncustomer_number\\n,count(*) as count_orders\\nfrom \\norders\\ngroup by customer_number\\n)\\n\\nselect customer_number from cte\\nwhere count_orders = (select max(count_orders) from cte)"
                    },
                    {
                        "username": "Vaibhav_124",
                        "content": " `SELECT CUSTOMER_NUMBER FROM orders\\nGROUP BY CUSTOMER_NUMBER ORDER BY COUNT(ORDER_NUMBER) DESC\\nLIMIT 1;`"
                    },
                    {
                        "username": "arthireddy",
                        "content": "SELECT IFNULL((SELECT MAX(customer_number) FROM Orders), \\'\\') AS customer_number;\\nwhy does the above code gives me wrong answer even though the code is correct and the output looks same as expected.?"
                    },
                    {
                        "username": "Dibayranjan",
                        "content": "SELECT top 1 customer_number\\nFROM orders\\nGROUP BY customer_number\\nORDER BY COUNT(*) DESC\\n\\n"
                    },
                    {
                        "username": "user2392CP",
                        "content": "select customer_number\\nfrom Orders\\ngroup by customer_number\\norder by count(customer_number) desc limit 1;"
                    },
                    {
                        "username": "sulata123",
                        "content": "select customer_number from Orders o , (select customer_number,count(order_number) as m from Orders group by customer_number )t where t.customer_number=o.customer_number and t.m=max(t.m) ;      why this throws error"
                    },
                    {
                        "username": "Nishantvohra",
                        "content": "Select Customer_number from orders group by Customer_number having Count(order_number)= \\n(Select Max(a.Count) from (Select Count(order_number) as \\'Count\\' from orders group by customer_number)a);"
                    },
                    {
                        "username": "Nayeem4080",
                        "content": "with cte as (select customer_number,count(customer_number) as counts\\nfrom Orders\\ngroup by customer_number)\\nselect customer_number\\nfrom cte\\nhaving counts = (select max(counts)\\nfrom cte)\\n\\nwhy doesn\\'t this work?\\n"
                    },
                    {
                        "username": "Hopkins666",
                        "content": "I created a table but not able to use it.\\n\\nCreate Table YYY AS\\nselect customer_number, count(order_number) as \"quantity\" from Orders\\nGroup by customer_number\\n\\nSelect * from YYY\\n\\nGot error message."
                    },
                    {
                        "username": "ceciliabababa",
                        "content": "Could anyone tell me why does my code return the wrong result please?\\n\\nSelect t.customer_number\\nFrom (\\n    Select o.customer_number, count(o.order_number) AS sumorder\\n    From orders o\\n    Group By o.customer_number ) As t\\nHaving max(t.sumorder)\\n"
                    }
                ]
            },
            {
                "id": 1772293,
                "content": [
                    {
                        "username": "omehdiakram",
                        "content": "SELECT customer_number FROM ORDERS\\nGROUP BY customer_number\\nORDER BY count(*) DESC\\nLIMIT 1;"
                    },
                    {
                        "username": "Sohail17",
                        "content": "select top 1 customer_number  \\nfrom Orders \\ngroup by customer_number\\norder by count(order_number) desc \\n\\nI used top clause instead of limit "
                    },
                    {
                        "username": "atharva09",
                        "content": " So easy  \\n select customer_number from orders group by customer_number\\norder by count(*) desc limit 0,1"
                    },
                    {
                        "username": "RKondratov",
                        "content": "Why is it not wright answer? (Oracle)\nselect max(customer_number) customer_number from Orders;"
                    },
                    {
                        "username": "vinayshrestha555",
                        "content": "Because max returns the maximum value the customer_number column has. \\nFor e.g if the customer_number column has the values say 1, 4, 2, 8, it will return the row with the value 8 not the result with the largest number of orders.\\n\\nhttps://docs.oracle.com/javadb/10.6.2.1/ref/rrefsqlj27781.html"
                    },
                    {
                        "username": "karenstephh29",
                        "content": "with T as (\\n    select \\n     customer_number,\\ndense_rank() over(partition by customer_number order by order_number asc) as rank_num\\nfrom Orders)\\nselect customer_number\\nfrom T\\nwhere rank_num=2;\\n"
                    },
                    {
                        "username": "user0160Kj",
                        "content": "LPT: user0160Kj / Jan 12, 2023 10:38\\n\\nMySQL Runtime 434 ms Beats 89.67%\\n\\nWITH T AS (\\nSELECT customer_number, count(order_number) AS count_order\\nFROM orders\\nGROUP BY customer_number\\nORDER BY count_order DESC\\nLIMIT 1)\\n\\nSelect customer_number from T\\n"
                    },
                    {
                        "username": "tuneer_bhattacharya",
                        "content": "# Write your MySQL query statement below\\nSELECT customer_number from Orders\\nGROUP BY customer_number\\nORDER BY COUNT(DISTINCT order_number) DESC\\nLIMIT 1"
                    },
                    {
                        "username": "user9736uM",
                        "content": "I think there is a bug in the table below:\\n| order_number | customer_number |\\n| ------------ | --------------- |\\n| 3            | 5               |\\n| 5            | 1               |\\n| 6            | 5               |\\n| 7            | 4               |\\n| 8            | 6               |\\n| 9            | 2               |\\n| 10           | 4               |\\n| 11           | 16              |\\n| 12           | 3               |\\n| 13           | 5               |\\n| 14           | 3               |\\n| 15           | 16              |\\nMy query works well for a table before,but here it says that expected output is 5 but the customer with the most orders is 3?"
                    },
                    {
                        "username": "Sultan_Aslam",
                        "content": "select TOP(1) p.customer_number from (select customer_number,count(customer_number) count\\nfrom Orders \\ngroup by customer_number\\n) AS p\\norder by p.count DESC\\n"
                    },
                    {
                        "username": "abro_01",
                        "content": "select customer_number from Orders group by customer_number order by count(*) desc limit 1"
                    }
                ]
            },
            {
                "id": 1767170,
                "content": [
                    {
                        "username": "omehdiakram",
                        "content": "SELECT customer_number FROM ORDERS\\nGROUP BY customer_number\\nORDER BY count(*) DESC\\nLIMIT 1;"
                    },
                    {
                        "username": "Sohail17",
                        "content": "select top 1 customer_number  \\nfrom Orders \\ngroup by customer_number\\norder by count(order_number) desc \\n\\nI used top clause instead of limit "
                    },
                    {
                        "username": "atharva09",
                        "content": " So easy  \\n select customer_number from orders group by customer_number\\norder by count(*) desc limit 0,1"
                    },
                    {
                        "username": "RKondratov",
                        "content": "Why is it not wright answer? (Oracle)\nselect max(customer_number) customer_number from Orders;"
                    },
                    {
                        "username": "vinayshrestha555",
                        "content": "Because max returns the maximum value the customer_number column has. \\nFor e.g if the customer_number column has the values say 1, 4, 2, 8, it will return the row with the value 8 not the result with the largest number of orders.\\n\\nhttps://docs.oracle.com/javadb/10.6.2.1/ref/rrefsqlj27781.html"
                    },
                    {
                        "username": "karenstephh29",
                        "content": "with T as (\\n    select \\n     customer_number,\\ndense_rank() over(partition by customer_number order by order_number asc) as rank_num\\nfrom Orders)\\nselect customer_number\\nfrom T\\nwhere rank_num=2;\\n"
                    },
                    {
                        "username": "user0160Kj",
                        "content": "LPT: user0160Kj / Jan 12, 2023 10:38\\n\\nMySQL Runtime 434 ms Beats 89.67%\\n\\nWITH T AS (\\nSELECT customer_number, count(order_number) AS count_order\\nFROM orders\\nGROUP BY customer_number\\nORDER BY count_order DESC\\nLIMIT 1)\\n\\nSelect customer_number from T\\n"
                    },
                    {
                        "username": "tuneer_bhattacharya",
                        "content": "# Write your MySQL query statement below\\nSELECT customer_number from Orders\\nGROUP BY customer_number\\nORDER BY COUNT(DISTINCT order_number) DESC\\nLIMIT 1"
                    },
                    {
                        "username": "user9736uM",
                        "content": "I think there is a bug in the table below:\\n| order_number | customer_number |\\n| ------------ | --------------- |\\n| 3            | 5               |\\n| 5            | 1               |\\n| 6            | 5               |\\n| 7            | 4               |\\n| 8            | 6               |\\n| 9            | 2               |\\n| 10           | 4               |\\n| 11           | 16              |\\n| 12           | 3               |\\n| 13           | 5               |\\n| 14           | 3               |\\n| 15           | 16              |\\nMy query works well for a table before,but here it says that expected output is 5 but the customer with the most orders is 3?"
                    },
                    {
                        "username": "Sultan_Aslam",
                        "content": "select TOP(1) p.customer_number from (select customer_number,count(customer_number) count\\nfrom Orders \\ngroup by customer_number\\n) AS p\\norder by p.count DESC\\n"
                    },
                    {
                        "username": "abro_01",
                        "content": "select customer_number from Orders group by customer_number order by count(*) desc limit 1"
                    }
                ]
            },
            {
                "id": 1763519,
                "content": [
                    {
                        "username": "omehdiakram",
                        "content": "SELECT customer_number FROM ORDERS\\nGROUP BY customer_number\\nORDER BY count(*) DESC\\nLIMIT 1;"
                    },
                    {
                        "username": "Sohail17",
                        "content": "select top 1 customer_number  \\nfrom Orders \\ngroup by customer_number\\norder by count(order_number) desc \\n\\nI used top clause instead of limit "
                    },
                    {
                        "username": "atharva09",
                        "content": " So easy  \\n select customer_number from orders group by customer_number\\norder by count(*) desc limit 0,1"
                    },
                    {
                        "username": "RKondratov",
                        "content": "Why is it not wright answer? (Oracle)\nselect max(customer_number) customer_number from Orders;"
                    },
                    {
                        "username": "vinayshrestha555",
                        "content": "Because max returns the maximum value the customer_number column has. \\nFor e.g if the customer_number column has the values say 1, 4, 2, 8, it will return the row with the value 8 not the result with the largest number of orders.\\n\\nhttps://docs.oracle.com/javadb/10.6.2.1/ref/rrefsqlj27781.html"
                    },
                    {
                        "username": "karenstephh29",
                        "content": "with T as (\\n    select \\n     customer_number,\\ndense_rank() over(partition by customer_number order by order_number asc) as rank_num\\nfrom Orders)\\nselect customer_number\\nfrom T\\nwhere rank_num=2;\\n"
                    },
                    {
                        "username": "user0160Kj",
                        "content": "LPT: user0160Kj / Jan 12, 2023 10:38\\n\\nMySQL Runtime 434 ms Beats 89.67%\\n\\nWITH T AS (\\nSELECT customer_number, count(order_number) AS count_order\\nFROM orders\\nGROUP BY customer_number\\nORDER BY count_order DESC\\nLIMIT 1)\\n\\nSelect customer_number from T\\n"
                    },
                    {
                        "username": "tuneer_bhattacharya",
                        "content": "# Write your MySQL query statement below\\nSELECT customer_number from Orders\\nGROUP BY customer_number\\nORDER BY COUNT(DISTINCT order_number) DESC\\nLIMIT 1"
                    },
                    {
                        "username": "user9736uM",
                        "content": "I think there is a bug in the table below:\\n| order_number | customer_number |\\n| ------------ | --------------- |\\n| 3            | 5               |\\n| 5            | 1               |\\n| 6            | 5               |\\n| 7            | 4               |\\n| 8            | 6               |\\n| 9            | 2               |\\n| 10           | 4               |\\n| 11           | 16              |\\n| 12           | 3               |\\n| 13           | 5               |\\n| 14           | 3               |\\n| 15           | 16              |\\nMy query works well for a table before,but here it says that expected output is 5 but the customer with the most orders is 3?"
                    },
                    {
                        "username": "Sultan_Aslam",
                        "content": "select TOP(1) p.customer_number from (select customer_number,count(customer_number) count\\nfrom Orders \\ngroup by customer_number\\n) AS p\\norder by p.count DESC\\n"
                    },
                    {
                        "username": "abro_01",
                        "content": "select customer_number from Orders group by customer_number order by count(*) desc limit 1"
                    }
                ]
            },
            {
                "id": 1760559,
                "content": [
                    {
                        "username": "omehdiakram",
                        "content": "SELECT customer_number FROM ORDERS\\nGROUP BY customer_number\\nORDER BY count(*) DESC\\nLIMIT 1;"
                    },
                    {
                        "username": "Sohail17",
                        "content": "select top 1 customer_number  \\nfrom Orders \\ngroup by customer_number\\norder by count(order_number) desc \\n\\nI used top clause instead of limit "
                    },
                    {
                        "username": "atharva09",
                        "content": " So easy  \\n select customer_number from orders group by customer_number\\norder by count(*) desc limit 0,1"
                    },
                    {
                        "username": "RKondratov",
                        "content": "Why is it not wright answer? (Oracle)\nselect max(customer_number) customer_number from Orders;"
                    },
                    {
                        "username": "vinayshrestha555",
                        "content": "Because max returns the maximum value the customer_number column has. \\nFor e.g if the customer_number column has the values say 1, 4, 2, 8, it will return the row with the value 8 not the result with the largest number of orders.\\n\\nhttps://docs.oracle.com/javadb/10.6.2.1/ref/rrefsqlj27781.html"
                    },
                    {
                        "username": "karenstephh29",
                        "content": "with T as (\\n    select \\n     customer_number,\\ndense_rank() over(partition by customer_number order by order_number asc) as rank_num\\nfrom Orders)\\nselect customer_number\\nfrom T\\nwhere rank_num=2;\\n"
                    },
                    {
                        "username": "user0160Kj",
                        "content": "LPT: user0160Kj / Jan 12, 2023 10:38\\n\\nMySQL Runtime 434 ms Beats 89.67%\\n\\nWITH T AS (\\nSELECT customer_number, count(order_number) AS count_order\\nFROM orders\\nGROUP BY customer_number\\nORDER BY count_order DESC\\nLIMIT 1)\\n\\nSelect customer_number from T\\n"
                    },
                    {
                        "username": "tuneer_bhattacharya",
                        "content": "# Write your MySQL query statement below\\nSELECT customer_number from Orders\\nGROUP BY customer_number\\nORDER BY COUNT(DISTINCT order_number) DESC\\nLIMIT 1"
                    },
                    {
                        "username": "user9736uM",
                        "content": "I think there is a bug in the table below:\\n| order_number | customer_number |\\n| ------------ | --------------- |\\n| 3            | 5               |\\n| 5            | 1               |\\n| 6            | 5               |\\n| 7            | 4               |\\n| 8            | 6               |\\n| 9            | 2               |\\n| 10           | 4               |\\n| 11           | 16              |\\n| 12           | 3               |\\n| 13           | 5               |\\n| 14           | 3               |\\n| 15           | 16              |\\nMy query works well for a table before,but here it says that expected output is 5 but the customer with the most orders is 3?"
                    },
                    {
                        "username": "Sultan_Aslam",
                        "content": "select TOP(1) p.customer_number from (select customer_number,count(customer_number) count\\nfrom Orders \\ngroup by customer_number\\n) AS p\\norder by p.count DESC\\n"
                    },
                    {
                        "username": "abro_01",
                        "content": "select customer_number from Orders group by customer_number order by count(*) desc limit 1"
                    }
                ]
            },
            {
                "id": 1760467,
                "content": [
                    {
                        "username": "omehdiakram",
                        "content": "SELECT customer_number FROM ORDERS\\nGROUP BY customer_number\\nORDER BY count(*) DESC\\nLIMIT 1;"
                    },
                    {
                        "username": "Sohail17",
                        "content": "select top 1 customer_number  \\nfrom Orders \\ngroup by customer_number\\norder by count(order_number) desc \\n\\nI used top clause instead of limit "
                    },
                    {
                        "username": "atharva09",
                        "content": " So easy  \\n select customer_number from orders group by customer_number\\norder by count(*) desc limit 0,1"
                    },
                    {
                        "username": "RKondratov",
                        "content": "Why is it not wright answer? (Oracle)\nselect max(customer_number) customer_number from Orders;"
                    },
                    {
                        "username": "vinayshrestha555",
                        "content": "Because max returns the maximum value the customer_number column has. \\nFor e.g if the customer_number column has the values say 1, 4, 2, 8, it will return the row with the value 8 not the result with the largest number of orders.\\n\\nhttps://docs.oracle.com/javadb/10.6.2.1/ref/rrefsqlj27781.html"
                    },
                    {
                        "username": "karenstephh29",
                        "content": "with T as (\\n    select \\n     customer_number,\\ndense_rank() over(partition by customer_number order by order_number asc) as rank_num\\nfrom Orders)\\nselect customer_number\\nfrom T\\nwhere rank_num=2;\\n"
                    },
                    {
                        "username": "user0160Kj",
                        "content": "LPT: user0160Kj / Jan 12, 2023 10:38\\n\\nMySQL Runtime 434 ms Beats 89.67%\\n\\nWITH T AS (\\nSELECT customer_number, count(order_number) AS count_order\\nFROM orders\\nGROUP BY customer_number\\nORDER BY count_order DESC\\nLIMIT 1)\\n\\nSelect customer_number from T\\n"
                    },
                    {
                        "username": "tuneer_bhattacharya",
                        "content": "# Write your MySQL query statement below\\nSELECT customer_number from Orders\\nGROUP BY customer_number\\nORDER BY COUNT(DISTINCT order_number) DESC\\nLIMIT 1"
                    },
                    {
                        "username": "user9736uM",
                        "content": "I think there is a bug in the table below:\\n| order_number | customer_number |\\n| ------------ | --------------- |\\n| 3            | 5               |\\n| 5            | 1               |\\n| 6            | 5               |\\n| 7            | 4               |\\n| 8            | 6               |\\n| 9            | 2               |\\n| 10           | 4               |\\n| 11           | 16              |\\n| 12           | 3               |\\n| 13           | 5               |\\n| 14           | 3               |\\n| 15           | 16              |\\nMy query works well for a table before,but here it says that expected output is 5 but the customer with the most orders is 3?"
                    },
                    {
                        "username": "Sultan_Aslam",
                        "content": "select TOP(1) p.customer_number from (select customer_number,count(customer_number) count\\nfrom Orders \\ngroup by customer_number\\n) AS p\\norder by p.count DESC\\n"
                    },
                    {
                        "username": "abro_01",
                        "content": "select customer_number from Orders group by customer_number order by count(*) desc limit 1"
                    }
                ]
            },
            {
                "id": 1753916,
                "content": [
                    {
                        "username": "omehdiakram",
                        "content": "SELECT customer_number FROM ORDERS\\nGROUP BY customer_number\\nORDER BY count(*) DESC\\nLIMIT 1;"
                    },
                    {
                        "username": "Sohail17",
                        "content": "select top 1 customer_number  \\nfrom Orders \\ngroup by customer_number\\norder by count(order_number) desc \\n\\nI used top clause instead of limit "
                    },
                    {
                        "username": "atharva09",
                        "content": " So easy  \\n select customer_number from orders group by customer_number\\norder by count(*) desc limit 0,1"
                    },
                    {
                        "username": "RKondratov",
                        "content": "Why is it not wright answer? (Oracle)\nselect max(customer_number) customer_number from Orders;"
                    },
                    {
                        "username": "vinayshrestha555",
                        "content": "Because max returns the maximum value the customer_number column has. \\nFor e.g if the customer_number column has the values say 1, 4, 2, 8, it will return the row with the value 8 not the result with the largest number of orders.\\n\\nhttps://docs.oracle.com/javadb/10.6.2.1/ref/rrefsqlj27781.html"
                    },
                    {
                        "username": "karenstephh29",
                        "content": "with T as (\\n    select \\n     customer_number,\\ndense_rank() over(partition by customer_number order by order_number asc) as rank_num\\nfrom Orders)\\nselect customer_number\\nfrom T\\nwhere rank_num=2;\\n"
                    },
                    {
                        "username": "user0160Kj",
                        "content": "LPT: user0160Kj / Jan 12, 2023 10:38\\n\\nMySQL Runtime 434 ms Beats 89.67%\\n\\nWITH T AS (\\nSELECT customer_number, count(order_number) AS count_order\\nFROM orders\\nGROUP BY customer_number\\nORDER BY count_order DESC\\nLIMIT 1)\\n\\nSelect customer_number from T\\n"
                    },
                    {
                        "username": "tuneer_bhattacharya",
                        "content": "# Write your MySQL query statement below\\nSELECT customer_number from Orders\\nGROUP BY customer_number\\nORDER BY COUNT(DISTINCT order_number) DESC\\nLIMIT 1"
                    },
                    {
                        "username": "user9736uM",
                        "content": "I think there is a bug in the table below:\\n| order_number | customer_number |\\n| ------------ | --------------- |\\n| 3            | 5               |\\n| 5            | 1               |\\n| 6            | 5               |\\n| 7            | 4               |\\n| 8            | 6               |\\n| 9            | 2               |\\n| 10           | 4               |\\n| 11           | 16              |\\n| 12           | 3               |\\n| 13           | 5               |\\n| 14           | 3               |\\n| 15           | 16              |\\nMy query works well for a table before,but here it says that expected output is 5 but the customer with the most orders is 3?"
                    },
                    {
                        "username": "Sultan_Aslam",
                        "content": "select TOP(1) p.customer_number from (select customer_number,count(customer_number) count\\nfrom Orders \\ngroup by customer_number\\n) AS p\\norder by p.count DESC\\n"
                    },
                    {
                        "username": "abro_01",
                        "content": "select customer_number from Orders group by customer_number order by count(*) desc limit 1"
                    }
                ]
            },
            {
                "id": 1749917,
                "content": [
                    {
                        "username": "omehdiakram",
                        "content": "SELECT customer_number FROM ORDERS\\nGROUP BY customer_number\\nORDER BY count(*) DESC\\nLIMIT 1;"
                    },
                    {
                        "username": "Sohail17",
                        "content": "select top 1 customer_number  \\nfrom Orders \\ngroup by customer_number\\norder by count(order_number) desc \\n\\nI used top clause instead of limit "
                    },
                    {
                        "username": "atharva09",
                        "content": " So easy  \\n select customer_number from orders group by customer_number\\norder by count(*) desc limit 0,1"
                    },
                    {
                        "username": "RKondratov",
                        "content": "Why is it not wright answer? (Oracle)\nselect max(customer_number) customer_number from Orders;"
                    },
                    {
                        "username": "vinayshrestha555",
                        "content": "Because max returns the maximum value the customer_number column has. \\nFor e.g if the customer_number column has the values say 1, 4, 2, 8, it will return the row with the value 8 not the result with the largest number of orders.\\n\\nhttps://docs.oracle.com/javadb/10.6.2.1/ref/rrefsqlj27781.html"
                    },
                    {
                        "username": "karenstephh29",
                        "content": "with T as (\\n    select \\n     customer_number,\\ndense_rank() over(partition by customer_number order by order_number asc) as rank_num\\nfrom Orders)\\nselect customer_number\\nfrom T\\nwhere rank_num=2;\\n"
                    },
                    {
                        "username": "user0160Kj",
                        "content": "LPT: user0160Kj / Jan 12, 2023 10:38\\n\\nMySQL Runtime 434 ms Beats 89.67%\\n\\nWITH T AS (\\nSELECT customer_number, count(order_number) AS count_order\\nFROM orders\\nGROUP BY customer_number\\nORDER BY count_order DESC\\nLIMIT 1)\\n\\nSelect customer_number from T\\n"
                    },
                    {
                        "username": "tuneer_bhattacharya",
                        "content": "# Write your MySQL query statement below\\nSELECT customer_number from Orders\\nGROUP BY customer_number\\nORDER BY COUNT(DISTINCT order_number) DESC\\nLIMIT 1"
                    },
                    {
                        "username": "user9736uM",
                        "content": "I think there is a bug in the table below:\\n| order_number | customer_number |\\n| ------------ | --------------- |\\n| 3            | 5               |\\n| 5            | 1               |\\n| 6            | 5               |\\n| 7            | 4               |\\n| 8            | 6               |\\n| 9            | 2               |\\n| 10           | 4               |\\n| 11           | 16              |\\n| 12           | 3               |\\n| 13           | 5               |\\n| 14           | 3               |\\n| 15           | 16              |\\nMy query works well for a table before,but here it says that expected output is 5 but the customer with the most orders is 3?"
                    },
                    {
                        "username": "Sultan_Aslam",
                        "content": "select TOP(1) p.customer_number from (select customer_number,count(customer_number) count\\nfrom Orders \\ngroup by customer_number\\n) AS p\\norder by p.count DESC\\n"
                    },
                    {
                        "username": "abro_01",
                        "content": "select customer_number from Orders group by customer_number order by count(*) desc limit 1"
                    }
                ]
            },
            {
                "id": 1746525,
                "content": [
                    {
                        "username": "omehdiakram",
                        "content": "SELECT customer_number FROM ORDERS\\nGROUP BY customer_number\\nORDER BY count(*) DESC\\nLIMIT 1;"
                    },
                    {
                        "username": "Sohail17",
                        "content": "select top 1 customer_number  \\nfrom Orders \\ngroup by customer_number\\norder by count(order_number) desc \\n\\nI used top clause instead of limit "
                    },
                    {
                        "username": "atharva09",
                        "content": " So easy  \\n select customer_number from orders group by customer_number\\norder by count(*) desc limit 0,1"
                    },
                    {
                        "username": "RKondratov",
                        "content": "Why is it not wright answer? (Oracle)\nselect max(customer_number) customer_number from Orders;"
                    },
                    {
                        "username": "vinayshrestha555",
                        "content": "Because max returns the maximum value the customer_number column has. \\nFor e.g if the customer_number column has the values say 1, 4, 2, 8, it will return the row with the value 8 not the result with the largest number of orders.\\n\\nhttps://docs.oracle.com/javadb/10.6.2.1/ref/rrefsqlj27781.html"
                    },
                    {
                        "username": "karenstephh29",
                        "content": "with T as (\\n    select \\n     customer_number,\\ndense_rank() over(partition by customer_number order by order_number asc) as rank_num\\nfrom Orders)\\nselect customer_number\\nfrom T\\nwhere rank_num=2;\\n"
                    },
                    {
                        "username": "user0160Kj",
                        "content": "LPT: user0160Kj / Jan 12, 2023 10:38\\n\\nMySQL Runtime 434 ms Beats 89.67%\\n\\nWITH T AS (\\nSELECT customer_number, count(order_number) AS count_order\\nFROM orders\\nGROUP BY customer_number\\nORDER BY count_order DESC\\nLIMIT 1)\\n\\nSelect customer_number from T\\n"
                    },
                    {
                        "username": "tuneer_bhattacharya",
                        "content": "# Write your MySQL query statement below\\nSELECT customer_number from Orders\\nGROUP BY customer_number\\nORDER BY COUNT(DISTINCT order_number) DESC\\nLIMIT 1"
                    },
                    {
                        "username": "user9736uM",
                        "content": "I think there is a bug in the table below:\\n| order_number | customer_number |\\n| ------------ | --------------- |\\n| 3            | 5               |\\n| 5            | 1               |\\n| 6            | 5               |\\n| 7            | 4               |\\n| 8            | 6               |\\n| 9            | 2               |\\n| 10           | 4               |\\n| 11           | 16              |\\n| 12           | 3               |\\n| 13           | 5               |\\n| 14           | 3               |\\n| 15           | 16              |\\nMy query works well for a table before,but here it says that expected output is 5 but the customer with the most orders is 3?"
                    },
                    {
                        "username": "Sultan_Aslam",
                        "content": "select TOP(1) p.customer_number from (select customer_number,count(customer_number) count\\nfrom Orders \\ngroup by customer_number\\n) AS p\\norder by p.count DESC\\n"
                    },
                    {
                        "username": "abro_01",
                        "content": "select customer_number from Orders group by customer_number order by count(*) desc limit 1"
                    }
                ]
            },
            {
                "id": 1707428,
                "content": [
                    {
                        "username": "omehdiakram",
                        "content": "SELECT customer_number FROM ORDERS\\nGROUP BY customer_number\\nORDER BY count(*) DESC\\nLIMIT 1;"
                    },
                    {
                        "username": "Sohail17",
                        "content": "select top 1 customer_number  \\nfrom Orders \\ngroup by customer_number\\norder by count(order_number) desc \\n\\nI used top clause instead of limit "
                    },
                    {
                        "username": "atharva09",
                        "content": " So easy  \\n select customer_number from orders group by customer_number\\norder by count(*) desc limit 0,1"
                    },
                    {
                        "username": "RKondratov",
                        "content": "Why is it not wright answer? (Oracle)\nselect max(customer_number) customer_number from Orders;"
                    },
                    {
                        "username": "vinayshrestha555",
                        "content": "Because max returns the maximum value the customer_number column has. \\nFor e.g if the customer_number column has the values say 1, 4, 2, 8, it will return the row with the value 8 not the result with the largest number of orders.\\n\\nhttps://docs.oracle.com/javadb/10.6.2.1/ref/rrefsqlj27781.html"
                    },
                    {
                        "username": "karenstephh29",
                        "content": "with T as (\\n    select \\n     customer_number,\\ndense_rank() over(partition by customer_number order by order_number asc) as rank_num\\nfrom Orders)\\nselect customer_number\\nfrom T\\nwhere rank_num=2;\\n"
                    },
                    {
                        "username": "user0160Kj",
                        "content": "LPT: user0160Kj / Jan 12, 2023 10:38\\n\\nMySQL Runtime 434 ms Beats 89.67%\\n\\nWITH T AS (\\nSELECT customer_number, count(order_number) AS count_order\\nFROM orders\\nGROUP BY customer_number\\nORDER BY count_order DESC\\nLIMIT 1)\\n\\nSelect customer_number from T\\n"
                    },
                    {
                        "username": "tuneer_bhattacharya",
                        "content": "# Write your MySQL query statement below\\nSELECT customer_number from Orders\\nGROUP BY customer_number\\nORDER BY COUNT(DISTINCT order_number) DESC\\nLIMIT 1"
                    },
                    {
                        "username": "user9736uM",
                        "content": "I think there is a bug in the table below:\\n| order_number | customer_number |\\n| ------------ | --------------- |\\n| 3            | 5               |\\n| 5            | 1               |\\n| 6            | 5               |\\n| 7            | 4               |\\n| 8            | 6               |\\n| 9            | 2               |\\n| 10           | 4               |\\n| 11           | 16              |\\n| 12           | 3               |\\n| 13           | 5               |\\n| 14           | 3               |\\n| 15           | 16              |\\nMy query works well for a table before,but here it says that expected output is 5 but the customer with the most orders is 3?"
                    },
                    {
                        "username": "Sultan_Aslam",
                        "content": "select TOP(1) p.customer_number from (select customer_number,count(customer_number) count\\nfrom Orders \\ngroup by customer_number\\n) AS p\\norder by p.count DESC\\n"
                    },
                    {
                        "username": "abro_01",
                        "content": "select customer_number from Orders group by customer_number order by count(*) desc limit 1"
                    }
                ]
            },
            {
                "id": 1704110,
                "content": [
                    {
                        "username": "omehdiakram",
                        "content": "SELECT customer_number FROM ORDERS\\nGROUP BY customer_number\\nORDER BY count(*) DESC\\nLIMIT 1;"
                    },
                    {
                        "username": "Sohail17",
                        "content": "select top 1 customer_number  \\nfrom Orders \\ngroup by customer_number\\norder by count(order_number) desc \\n\\nI used top clause instead of limit "
                    },
                    {
                        "username": "atharva09",
                        "content": " So easy  \\n select customer_number from orders group by customer_number\\norder by count(*) desc limit 0,1"
                    },
                    {
                        "username": "RKondratov",
                        "content": "Why is it not wright answer? (Oracle)\nselect max(customer_number) customer_number from Orders;"
                    },
                    {
                        "username": "vinayshrestha555",
                        "content": "Because max returns the maximum value the customer_number column has. \\nFor e.g if the customer_number column has the values say 1, 4, 2, 8, it will return the row with the value 8 not the result with the largest number of orders.\\n\\nhttps://docs.oracle.com/javadb/10.6.2.1/ref/rrefsqlj27781.html"
                    },
                    {
                        "username": "karenstephh29",
                        "content": "with T as (\\n    select \\n     customer_number,\\ndense_rank() over(partition by customer_number order by order_number asc) as rank_num\\nfrom Orders)\\nselect customer_number\\nfrom T\\nwhere rank_num=2;\\n"
                    },
                    {
                        "username": "user0160Kj",
                        "content": "LPT: user0160Kj / Jan 12, 2023 10:38\\n\\nMySQL Runtime 434 ms Beats 89.67%\\n\\nWITH T AS (\\nSELECT customer_number, count(order_number) AS count_order\\nFROM orders\\nGROUP BY customer_number\\nORDER BY count_order DESC\\nLIMIT 1)\\n\\nSelect customer_number from T\\n"
                    },
                    {
                        "username": "tuneer_bhattacharya",
                        "content": "# Write your MySQL query statement below\\nSELECT customer_number from Orders\\nGROUP BY customer_number\\nORDER BY COUNT(DISTINCT order_number) DESC\\nLIMIT 1"
                    },
                    {
                        "username": "user9736uM",
                        "content": "I think there is a bug in the table below:\\n| order_number | customer_number |\\n| ------------ | --------------- |\\n| 3            | 5               |\\n| 5            | 1               |\\n| 6            | 5               |\\n| 7            | 4               |\\n| 8            | 6               |\\n| 9            | 2               |\\n| 10           | 4               |\\n| 11           | 16              |\\n| 12           | 3               |\\n| 13           | 5               |\\n| 14           | 3               |\\n| 15           | 16              |\\nMy query works well for a table before,but here it says that expected output is 5 but the customer with the most orders is 3?"
                    },
                    {
                        "username": "Sultan_Aslam",
                        "content": "select TOP(1) p.customer_number from (select customer_number,count(customer_number) count\\nfrom Orders \\ngroup by customer_number\\n) AS p\\norder by p.count DESC\\n"
                    },
                    {
                        "username": "abro_01",
                        "content": "select customer_number from Orders group by customer_number order by count(*) desc limit 1"
                    }
                ]
            }
        ]
    }
]