[
    {
        "title": "Count Subarrays With Fixed Bounds",
        "question_content": "You are given an integer array nums and two integers minK and maxK.\nA fixed-bound subarray of nums is a subarray that satisfies the following conditions:\n\n\tThe minimum value in the subarray is equal to minK.\n\tThe maximum value in the subarray is equal to maxK.\n\nReturn the number of fixed-bound subarrays.\nA subarray is a contiguous part of an array.\n&nbsp;\nExample 1:\n\nInput: nums = [1,3,5,2,7,5], minK = 1, maxK = 5\nOutput: 2\nExplanation: The fixed-bound subarrays are [1,3,5] and [1,3,5,2].\n\nExample 2:\n\nInput: nums = [1,1,1,1], minK = 1, maxK = 1\nOutput: 10\nExplanation: Every subarray of nums is a fixed-bound subarray. There are 10 possible subarrays.\n\n&nbsp;\nConstraints:\n\n\t2 <= nums.length <= 105\n\t1 <= nums[i], minK, maxK <= 106",
        "solutions": [
            {
                "id": 2708099,
                "title": "java-c-python-sliding-window-with-explanation",
                "content": "# **Intuition**\\nCount the number of subarrays,\\nusing sliding window(three pointers).\\n<br>\\n\\n# **Explanation**\\nWe maintain a maximum sliding window\\nwith alll elements in range `[minK, maxK]`,\\nFor all `A[i]` as rightmost element of the subarray,\\nwe find the three indices `j`, where:\\n`jbad` is index of last seen `A[jbad] < minK || A[jbad] > maxK`\\n`jmin` is index of last seen `A[jmin] = mink`\\n`jmax` is index of last seen `A[jmax] = maxk`\\n\\nItearte the `A[i]`,\\nif `A[i] < minK || A[i] > maxK`, update `jbad = i`.\\nif `A[i] == minK`, update `jmin = i`.\\nif `A[i] == maxK`, update `jmax = i`.\\n\\nIn the end of each iteration,\\nthe subarray ends at `A[i]`\\nthe starting element of the subarray,\\ncan be choosen in interval `[jbad + 1, min(jmin, jmax)]`\\nThere are `min(jmin, jmax) - jbad` choices,\\nso we update `res += max(0, min(jmin, jmax) - jbad)`.\\n<br>\\n\\n# **Complexity**\\nTime `O(n)`\\nSpace `O(1)`\\n<br>\\n\\n**Java**\\n```java\\n    public long countSubarrays(int[] A, int minK, int maxK) {\\n        long res = 0, jbad = -1, jmin = -1, jmax = -1, n = A.length;\\n        for (int i = 0; i < n; ++i) {\\n            if (A[i] < minK || A[i] > maxK) jbad = i;\\n            if (A[i] == minK) jmin = i;\\n            if (A[i] == maxK) jmax = i;\\n            res += Math.max(0L, Math.min(jmin, jmax) - jbad);\\n        }\\n        return res;\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    long long countSubarrays(vector<int>& A, int minK, int maxK) {\\n        long res = 0, jbad = -1, jmin = -1, jmax = -1, n = A.size();\\n        for (int i = 0; i < n; ++i) {\\n            if (A[i] < minK || A[i] > maxK) jbad = i;\\n            if (A[i] == minK) jmin = i;\\n            if (A[i] == maxK) jmax = i;\\n            res += max(0L, min(jmin, jmax) - jbad);\\n        }\\n        return res;\\n    }\\n```\\n\\n**Python**\\n```py\\n    def countSubarrays(self, A: List[int], minK: int, maxK: int) -> int:\\n        res = 0\\n        jmin = jmax = jbad = -1\\n        for i,a in enumerate(A):\\n            if not minK <= a <= maxK: jbad = i\\n            if a == minK: jmin = i\\n            if a == maxK: jmax = i\\n            res += max(0, min(jmin, jmax) - jbad)\\n        return res\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    public long countSubarrays(int[] A, int minK, int maxK) {\\n        long res = 0, jbad = -1, jmin = -1, jmax = -1, n = A.length;\\n        for (int i = 0; i < n; ++i) {\\n            if (A[i] < minK || A[i] > maxK) jbad = i;\\n            if (A[i] == minK) jmin = i;\\n            if (A[i] == maxK) jmax = i;\\n            res += Math.max(0L, Math.min(jmin, jmax) - jbad);\\n        }\\n        return res;\\n    }\\n```\n```cpp\\n    long long countSubarrays(vector<int>& A, int minK, int maxK) {\\n        long res = 0, jbad = -1, jmin = -1, jmax = -1, n = A.size();\\n        for (int i = 0; i < n; ++i) {\\n            if (A[i] < minK || A[i] > maxK) jbad = i;\\n            if (A[i] == minK) jmin = i;\\n            if (A[i] == maxK) jmax = i;\\n            res += max(0L, min(jmin, jmax) - jbad);\\n        }\\n        return res;\\n    }\\n```\n```py\\n    def countSubarrays(self, A: List[int], minK: int, maxK: int) -> int:\\n        res = 0\\n        jmin = jmax = jbad = -1\\n        for i,a in enumerate(A):\\n            if not minK <= a <= maxK: jbad = i\\n            if a == minK: jmin = i\\n            if a == maxK: jmax = i\\n            res += max(0, min(jmin, jmax) - jbad)\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2707995,
                "title": "simple-o-n-c-solution",
                "content": "Consider value at each index and count valid subarrays from left side.\\nValid subarrays will contain indices of latest seen `minK` , `maxK`  and begin at `start`.\\nIf current value is less than `minK` or greater than `maxK`, new subarray starts from next index.\\n```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n        long res = 0;\\n        bool minFound = false, maxFound = false;\\n        int start = 0, minStart = 0, maxStart = 0;\\n        for (int i = 0; i < nums.size(); i++) {\\n            int num = nums[i];\\n            if (num < minK || num > maxK) {\\n                minFound = false;\\n                maxFound = false;\\n                start = i+1;\\n            }\\n            if (num == minK) {\\n                minFound = true;\\n                minStart = i;\\n            }\\n            if (num == maxK) {\\n                maxFound = true;\\n                maxStart = i;\\n            }\\n            if (minFound && maxFound) {\\n                res += (min(minStart, maxStart) - start + 1);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n        long res = 0;\\n        bool minFound = false, maxFound = false;\\n        int start = 0, minStart = 0, maxStart = 0;\\n        for (int i = 0; i < nums.size(); i++) {\\n            int num = nums[i];\\n            if (num < minK || num > maxK) {\\n                minFound = false;\\n                maxFound = false;\\n                start = i+1;\\n            }\\n            if (num == minK) {\\n                minFound = true;\\n                minStart = i;\\n            }\\n            if (num == maxK) {\\n                maxFound = true;\\n                maxStart = i;\\n            }\\n            if (minFound && maxFound) {\\n                res += (min(minStart, maxStart) - start + 1);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3253917,
                "title": "easy-solutions-in-java-python-and-c-look-at-once",
                "content": "# Intuition\\nWe can use a sliding window approach to find all subarrays with minimum value `minK` and maximum value `maxK`. We can keep track of the start index of the current subarray and update it whenever we encounter a value that is less than `minK` or greater than `maxK`.\\nWhen we find a subarray with both `minK` and `maxK`, we can count the number of subarrays that can be formed by taking the minimum index of `minK` and `maxK` as the starting point and the current index as the ending point.\\n# Approach\\n1. Initialize `res` to 0, `start` to 0, and `minFound` and `maxFound` to false.\\n2. Iterate over the array `nums`.\\n3. If the current value `num` is less than `minK` or greater than `maxK`, set `minFound` and `maxFound` to false and update `start` to `i+1`.\\n4. If `num` is equal to `minK`, set `minFound` to true and update `minStart` to `i`.\\n5. If `num` is equal to `maxK`, set `maxFound` to true and update `maxStart` to `i`.\\n6. If `minFound` and `maxFound` are both true, add `(min(minStart, maxStart) - start + 1)` to `res`.\\n7. Return `res`.\\n \\n# Complexity\\n- Time complexity: $$O(n)$$, where n is the length of `nums`.\\n- Space complexity: $$O(1)$$.\\n\\n![image.png](https://assets.leetcode.com/users/images/b427e686-2e5d-469a-8e7a-db5140022a6b_1677715904.0948765.png)\\n\\n\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\\n\\n# Code\\n``` Java []\\nclass Solution {\\n    public long countSubarrays(int[] nums, int minK, int maxK) {\\n        long res = 0;\\n        boolean minFound = false, maxFound = false;\\n        int start = 0, minStart = 0, maxStart = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            int num = nums[i];\\n            if (num < minK || num > maxK) {\\n                minFound = false;\\n                maxFound = false;\\n                start = i+1;\\n            }\\n            if (num == minK) {\\n                minFound = true;\\n                minStart = i;\\n            }\\n            if (num == maxK) {\\n                maxFound = true;\\n                maxStart = i;\\n            }\\n            if (minFound && maxFound) {\\n                res += (Math.min(minStart, maxStart) - start + 1);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n\\n```\\n``` Python []\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], minK: int, maxK: int) -> int:\\n        res = 0\\n        minFound = False\\n        maxFound = False\\n        start = 0\\n        minStart = 0\\n        maxStart = 0\\n        for i in range(len(nums)):\\n            num = nums[i]\\n            if num < minK or num > maxK:\\n                minFound = False\\n                maxFound = False\\n                start = i+1\\n            if num == minK:\\n                minFound = True\\n                minStart = i\\n            if num == maxK:\\n                maxFound = True\\n                maxStart = i\\n            if minFound and maxFound:\\n                res += (min(minStart, maxStart) - start + 1)\\n        return res\\n\\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n        long res = 0;\\n        bool minFound = false, maxFound = false;\\n        int start = 0, minStart = 0, maxStart = 0;\\n        for (int i = 0; i < nums.size(); i++) {\\n            int num = nums[i];\\n            if (num < minK || num > maxK) {\\n                minFound = false;\\n                maxFound = false;\\n                start = i+1;\\n            }\\n            if (num == minK) {\\n                minFound = true;\\n                minStart = i;\\n            }\\n            if (num == maxK) {\\n                maxFound = true;\\n                maxStart = i;\\n            }\\n            if (minFound && maxFound) {\\n                res += (min(minStart, maxStart) - start + 1);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n```\\nTable Representation of the iteration for given example\\nI hope you will like it \\uD83D\\uDE0A\\n----------------------------------------------------------------------\\n\\nExample 1\\t\\t\\t\\n\\t\\t\\t\\nnums = [1,3,5,2,7,5], minK = 1, maxK = 5\\t\\t\\n\\t\\ni   num   minFound   maxFound   minStart   maxStart   start   res\\t\\t\\t\\n0   1     true       false      0          0          0       0\\t\\t\\t\\n1   3     true       false      0          0          0       0\\t\\t\\t\\n2   5     true       true       0          2          0       3\\t\\t\\t\\n3   2     false      true       0          2          4       3\\t\\t\\t\\n4   7     false      true       0          2          4       3\\t\\t\\t\\n5   5     false      true       0          2          4       3\\t\\n\\n----------------------------------------------------------------------\\t\\t\\nExample 2\\t\\t\\t\\n\\t\\t\\t\\nnums = [1,1,1,1], minK = 1, maxK = 1\\t\\n\\t\\t\\ni   num   minFound   maxFound   minStart   maxStart   start   res\\t\\t\\t\\n0   1     true       true       0          0          0       1\\t\\t\\t\\n1   1     true       true       0          1          0       3\\t\\t\\t\\n2   1     true       true       0          2          0       6\\t\\t\\t\\n3   1     true       true       0          3          0       10\\t\\n\\n\\t\\t\\n```\\n\\n\\n# Please Comment\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution comment below if you like it.\\uD83D\\uDE0A\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Array",
                    "Sliding Window"
                ],
                "code": "```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\n``` Java []\\nclass Solution {\\n    public long countSubarrays(int[] nums, int minK, int maxK) {\\n        long res = 0;\\n        boolean minFound = false, maxFound = false;\\n        int start = 0, minStart = 0, maxStart = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            int num = nums[i];\\n            if (num < minK || num > maxK) {\\n                minFound = false;\\n                maxFound = false;\\n                start = i+1;\\n            }\\n            if (num == minK) {\\n                minFound = true;\\n                minStart = i;\\n            }\\n            if (num == maxK) {\\n                maxFound = true;\\n                maxStart = i;\\n            }\\n            if (minFound && maxFound) {\\n                res += (Math.min(minStart, maxStart) - start + 1);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n\\n```\n``` Python []\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], minK: int, maxK: int) -> int:\\n        res = 0\\n        minFound = False\\n        maxFound = False\\n        start = 0\\n        minStart = 0\\n        maxStart = 0\\n        for i in range(len(nums)):\\n            num = nums[i]\\n            if num < minK or num > maxK:\\n                minFound = False\\n                maxFound = False\\n                start = i+1\\n            if num == minK:\\n                minFound = True\\n                minStart = i\\n            if num == maxK:\\n                maxFound = True\\n                maxStart = i\\n            if minFound and maxFound:\\n                res += (min(minStart, maxStart) - start + 1)\\n        return res\\n\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n        long res = 0;\\n        bool minFound = false, maxFound = false;\\n        int start = 0, minStart = 0, maxStart = 0;\\n        for (int i = 0; i < nums.size(); i++) {\\n            int num = nums[i];\\n            if (num < minK || num > maxK) {\\n                minFound = false;\\n                maxFound = false;\\n                start = i+1;\\n            }\\n            if (num == minK) {\\n                minFound = true;\\n                minStart = i;\\n            }\\n            if (num == maxK) {\\n                maxFound = true;\\n                maxStart = i;\\n            }\\n            if (minFound && maxFound) {\\n                res += (min(minStart, maxStart) - start + 1);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nTable Representation of the iteration for given example\\nI hope you will like it \\uD83D\\uDE0A\\n----------------------------------------------------------------------\\n\\nExample 1\\t\\t\\t\\n\\t\\t\\t\\nnums = [1,3,5,2,7,5], minK = 1, maxK = 5\\t\\t\\n\\t\\ni   num   minFound   maxFound   minStart   maxStart   start   res\\t\\t\\t\\n0   1     true       false      0          0          0       0\\t\\t\\t\\n1   3     true       false      0          0          0       0\\t\\t\\t\\n2   5     true       true       0          2          0       3\\t\\t\\t\\n3   2     false      true       0          2          4       3\\t\\t\\t\\n4   7     false      true       0          2          4       3\\t\\t\\t\\n5   5     false      true       0          2          4       3\\t\\n\\n----------------------------------------------------------------------\\t\\t\\nExample 2\\t\\t\\t\\n\\t\\t\\t\\nnums = [1,1,1,1], minK = 1, maxK = 1\\t\\n\\t\\t\\ni   num   minFound   maxFound   minStart   maxStart   start   res\\t\\t\\t\\n0   1     true       true       0          0          0       1\\t\\t\\t\\n1   1     true       true       0          1          0       3\\t\\t\\t\\n2   1     true       true       0          2          0       6\\t\\t\\t\\n3   1     true       true       0          3          0       10\\t\\n\\n\\t\\t\\n```\n```\\nThanks for visiting my solution comment below if you like it.\\uD83D\\uDE0A\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3254078,
                "title": "clean-codes-full-explanation-sliding-window-c-java-python3",
                "content": "# Intuition :\\n- Here we have to count subarrays in an array of integers `nums` where the minimum value of the subarray is `minK` and the maximum value is `maxK`.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Detail Explanation to Approach :\\n- So, here we are using a **sliding window** approach, where `j` is the starting index of the current subarray and `i` is the ending index\\n- Whenever an element outside of the range` [minK, maxK]` is encountered, `j` is moved to the right of that element since any subarray that includes that element will not satisfy the conditions.\\n- We keep track of the indices of the most recent occurrences of `minK` and `maxK` using `prevMinKIndex` and `prevMaxKIndex`, respectively\\n```\\npublic long countSubarrays(int[] nums, int minK, int maxK) {\\n    long ans = 0;\\n    int j = -1;\\n    int prevMinKIndex = -1;\\n    int prevMaxKIndex = -1;\\n\\n```\\n- Use a for loop that iterates through each element `nums[i]` in `nums`\\n1. If `nums[i]` is less than `minK` or greater than `maxK`, then the starting index `j` is moved to `i`, since any subarray that includes `nums[i]` will not satisfy the conditions.\\n2. If `nums[i]` is equal to `minK`, then `prevMinKIndex` is updated to `i`. If `nums[i]` is equal to `maxK`, then `prevMaxKIndex` is updated to i.\\n```\\nfor (int i = 0; i < nums.length; ++i) {\\n      if (nums[i] < minK || nums[i] > maxK)\\n        j = i;\\n      if (nums[i] == minK)\\n        prevMinKIndex = i;\\n      if (nums[i] == maxK)\\n        prevMaxKIndex = i;\\n```\\n- Now, we calculate the number of valid subarrays using the **formula** `Math.max(0, Math.min(prevMinKIndex, prevMaxKIndex) - j)`. This calculates the number of valid starting indices for the subarray that ends at index i.\\n- The `Math.min(prevMinKIndex, prevMaxKIndex) - j` expression calculates the distance between the current ending index `i` and the closest valid starting index `k` in the range `[j+1, Math.min(prevMinKIndex, prevMaxKIndex)]. `\\n- This distance is then passed to `Math.max` with 0, since the minimum value of this distance is 0, and any negative values represent invalid subarrays.\\n- The result of this calculation is added to `ans` to keep a running count of the total number of valid subarrays.\\n```\\nans += Math.max(0, Math.min(prevMinKIndex, prevMaxKIndex) - j);\\n\\n```\\n- Finally return the total count of valid subarrays.\\n```\\nreturn ans;\\n\\n```\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity : O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution.\\uD83D\\uDE0A\\n```\\n# Codes [C++ |Java |Python3] : With Comments\\n```C++ []\\nlong long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n    long long ans = 0; // initialize answer variable to 0\\n    int j = -1; // initialize starting index of current subarray to -1\\n    int prevMinKIndex = -1; // initialize most recent index of minK to -1\\n    int prevMaxKIndex = -1; // initialize most recent index of maxK to -1\\n\\n    for (int i = 0; i < nums.size(); ++i) { // iterate over every element in nums\\n      if (nums[i] < minK || nums[i] > maxK)\\n        j = i; // if nums[i] is out of range, move starting index of current subarray to i\\n      if (nums[i] == minK)\\n        prevMinKIndex = i; // if nums[i] is minK, update most recent index of minK to i\\n      if (nums[i] == maxK)\\n        prevMaxKIndex = i; // if nums[i] is maxK, update most recent index of maxK to i\\n\\n      // calculate number of valid subarrays that end at index i and add to answer\\n      ans += max(0, min(prevMinKIndex, prevMaxKIndex) - j);\\n    }\\n\\n    return ans; // return the total count of valid subarrays\\n}\\n\\n```\\n```Java []\\npublic long countSubarrays(int[] nums, int minK, int maxK) {\\n    long ans = 0; // initialize answer variable to 0\\n    int j = -1; // initialize starting index of current subarray to -1\\n    int prevMinKIndex = -1; // initialize most recent index of minK to -1\\n    int prevMaxKIndex = -1; // initialize most recent index of maxK to -1\\n\\n    for (int i = 0; i < nums.length; ++i) { // iterate over every element in nums\\n      if (nums[i] < minK || nums[i] > maxK)\\n        j = i; // if nums[i] is out of range, move starting index of current subarray to i\\n      if (nums[i] == minK)\\n        prevMinKIndex = i; // if nums[i] is minK, update most recent index of minK to i\\n      if (nums[i] == maxK)\\n        prevMaxKIndex = i; // if nums[i] is maxK, update most recent index of maxK to i\\n\\n      // calculate number of valid subarrays that end at index i and add to answer\\n      ans += Math.max(0, Math.min(prevMinKIndex, prevMaxKIndex) - j);\\n    }\\n\\n    return ans; // return the total count of valid subarrays\\n}\\n\\n```\\n```Python []\\ndef countSubarrays(self, nums: List[int], minK: int, maxK: int) -> int:\\n    ans = 0 # initialize answer variable to 0\\n    j = -1 # initialize starting index of current subarray to -1\\n    prevMinKIndex = -1 # initialize most recent index of minK to -1\\n    prevMaxKIndex = -1 # initialize most recent index of maxK to -1\\n\\n    for i, num in enumerate(nums): # iterate over every element in nums with their index\\n      if num < minK or num > maxK:\\n        j = i # if nums[i] is out of range, move starting index of current subarray to i\\n      if num == minK:\\n        prevMinKIndex = i # if nums[i] is minK, update most recent index of minK to i\\n      if num == maxK:\\n        prevMaxKIndex = i # if nums[i] is maxK, update most recent index of maxK to i\\n\\n      # calculate number of valid subarrays that end at index i and add to answer\\n      ans += max(0, min(prevMinKIndex, prevMaxKIndex) - j)\\n\\n    return ans # return the total count of valid subarrays\\n\\n```\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n![ezgif-3-22a360561c.gif](https://assets.leetcode.com/users/images/d994c7f0-bd84-4e25-882c-25e146c79cd0_1677898171.4917493.gif)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\npublic long countSubarrays(int[] nums, int minK, int maxK) {\\n    long ans = 0;\\n    int j = -1;\\n    int prevMinKIndex = -1;\\n    int prevMaxKIndex = -1;\\n\\n```\n```\\nfor (int i = 0; i < nums.length; ++i) {\\n      if (nums[i] < minK || nums[i] > maxK)\\n        j = i;\\n      if (nums[i] == minK)\\n        prevMinKIndex = i;\\n      if (nums[i] == maxK)\\n        prevMaxKIndex = i;\\n```\n```\\nans += Math.max(0, Math.min(prevMinKIndex, prevMaxKIndex) - j);\\n\\n```\n```\\nreturn ans;\\n\\n```\n```\\nThanks for visiting my solution.\\uD83D\\uDE0A\\n```\n```C++ []\\nlong long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n    long long ans = 0; // initialize answer variable to 0\\n    int j = -1; // initialize starting index of current subarray to -1\\n    int prevMinKIndex = -1; // initialize most recent index of minK to -1\\n    int prevMaxKIndex = -1; // initialize most recent index of maxK to -1\\n\\n    for (int i = 0; i < nums.size(); ++i) { // iterate over every element in nums\\n      if (nums[i] < minK || nums[i] > maxK)\\n        j = i; // if nums[i] is out of range, move starting index of current subarray to i\\n      if (nums[i] == minK)\\n        prevMinKIndex = i; // if nums[i] is minK, update most recent index of minK to i\\n      if (nums[i] == maxK)\\n        prevMaxKIndex = i; // if nums[i] is maxK, update most recent index of maxK to i\\n\\n      // calculate number of valid subarrays that end at index i and add to answer\\n      ans += max(0, min(prevMinKIndex, prevMaxKIndex) - j);\\n    }\\n\\n    return ans; // return the total count of valid subarrays\\n}\\n\\n```\n```Java []\\npublic long countSubarrays(int[] nums, int minK, int maxK) {\\n    long ans = 0; // initialize answer variable to 0\\n    int j = -1; // initialize starting index of current subarray to -1\\n    int prevMinKIndex = -1; // initialize most recent index of minK to -1\\n    int prevMaxKIndex = -1; // initialize most recent index of maxK to -1\\n\\n    for (int i = 0; i < nums.length; ++i) { // iterate over every element in nums\\n      if (nums[i] < minK || nums[i] > maxK)\\n        j = i; // if nums[i] is out of range, move starting index of current subarray to i\\n      if (nums[i] == minK)\\n        prevMinKIndex = i; // if nums[i] is minK, update most recent index of minK to i\\n      if (nums[i] == maxK)\\n        prevMaxKIndex = i; // if nums[i] is maxK, update most recent index of maxK to i\\n\\n      // calculate number of valid subarrays that end at index i and add to answer\\n      ans += Math.max(0, Math.min(prevMinKIndex, prevMaxKIndex) - j);\\n    }\\n\\n    return ans; // return the total count of valid subarrays\\n}\\n\\n```\n```Python []\\ndef countSubarrays(self, nums: List[int], minK: int, maxK: int) -> int:\\n    ans = 0 # initialize answer variable to 0\\n    j = -1 # initialize starting index of current subarray to -1\\n    prevMinKIndex = -1 # initialize most recent index of minK to -1\\n    prevMaxKIndex = -1 # initialize most recent index of maxK to -1\\n\\n    for i, num in enumerate(nums): # iterate over every element in nums with their index\\n      if num < minK or num > maxK:\\n        j = i # if nums[i] is out of range, move starting index of current subarray to i\\n      if num == minK:\\n        prevMinKIndex = i # if nums[i] is minK, update most recent index of minK to i\\n      if num == maxK:\\n        prevMaxKIndex = i # if nums[i] is maxK, update most recent index of maxK to i\\n\\n      # calculate number of valid subarrays that end at index i and add to answer\\n      ans += max(0, min(prevMinKIndex, prevMaxKIndex) - j)\\n\\n    return ans # return the total count of valid subarrays\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2708079,
                "title": "easy-2-pointers-o-n-time-o-1-space-count-valid-subarrays-ending-at-every-valid-index-java-code",
                "content": "This is a common pattern of counting subarrays which satisfies some conditions, minK and maxK in this problem.\\n\\nWe have to iterate over the array (i from 0 to N-1) and consider the subarrays ending at each index if they can be included in the count or more precisely how many of them can be included in the final count.\\n\\nFor this particular problem, for an index i we can only include those subarrays which contains at least one mink and at least one maxK and we have to discard the rest.\\n\\nExample- consider nums = [1,2,5,1,2,3,7,5], minK = 1, maxK = 5, we keep track of  start = 0 (we also need to track start, explained later), miniK = -1 (latest index of minK), maxi = -1 (latest index of maxK)\\nConsider i = 5(0 based indexing) (nums[i] = 3)\\n\\nTotal subarrays ending at index 5 = i \\u2013 start+1 = 5-0+1 = 6 ([3], [2,3],[1,2,3],[5,1,2,3],[2,5,1,2,3],[1,2,5,1,2,3])\\n\\nBut notice that we cannot take subarrays from index 3 to index 5 as they do not contains both a 1(minK) and a 5(maxK), so we have to remove (([3], [2,3],[1,2,3])\\n\\nNow to know how many subarrays to remove we need to track of the least index among the latest minK and maxK. So we also have to keep updating whenever we see a minK or maxK.\\n\\nSo count which will be added to total will be- (i \\u2013 start + 1)(all subarrays ending at index i) \\u2013 (i \\u2013 Math.min(mini, maxi) + 1)(invalid subarrays ending at index i)\\n\\nSo we have keep track of latest index of minK, latest index of maxK and our start position.\\n\\nNow, the case where at index i we have a nums[i]>maxK or nums[i]<minK, clearly this element cannot be part of any subarray and the good thing with subarrays is that whenever there is an element which do not satisfy the condition, all our previous progress is just reset (except the total count of course) and from this index we have to start fresh. So now we just update everything back to default, so now our new start will be i+1, and minK index and maxK index will be i.\\n\\nJava Code-\\n```\\nclass Solution {\\n    public long countSubarrays(int[] nums, int minK, int maxK) {\\n        int mini=-1;\\n        int maxi=-1;\\n        int start=0;\\n        long count=0;\\n        for(int i=0; i<nums.length; i++){\\n            if(nums[i]<minK || nums[i]>maxK){\\n                start = i+1;\\n                mini = i;\\n                maxi = i;\\n                continue;\\n            }\\n            if(nums[i] == minK){\\n                mini = i;\\n            }\\n            if(nums[i] == maxK){\\n                maxi = i;\\n            }\\n            count+= (i-start+1) - (i - (Math.min(mini,maxi)+1)+1);\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public long countSubarrays(int[] nums, int minK, int maxK) {\\n        int mini=-1;\\n        int maxi=-1;\\n        int start=0;\\n        long count=0;\\n        for(int i=0; i<nums.length; i++){\\n            if(nums[i]<minK || nums[i]>maxK){\\n                start = i+1;\\n                mini = i;\\n                maxi = i;\\n                continue;\\n            }\\n            if(nums[i] == minK){\\n                mini = i;\\n            }\\n            if(nums[i] == maxK){\\n                maxi = i;\\n            }\\n            count+= (i-start+1) - (i - (Math.min(mini,maxi)+1)+1);\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2707997,
                "title": "python-two-pointer-o-n-time-and-o-1-space",
                "content": "```\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], minK: int, maxK: int) -> int:\\n        left = 0\\n        last_min_k_index = -1\\n        last_max_k_index = -1\\n        fixed_bounds_subarrays = 0\\n\\n        for right, v in enumerate(nums):\\n            if v < minK or v > maxK:\\n                left = right + 1\\n            else:\\n                if v == minK:\\n                    last_min_k_index = right\\n                if v == maxK:\\n                    last_max_k_index = right\\n                if last_min_k_index >= left and last_max_k_index >= left:\\n                    fixed_bounds_subarrays += min(last_min_k_index, last_max_k_index) - left + 1\\n\\n        return fixed_bounds_subarrays\\n```",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], minK: int, maxK: int) -> int:\\n        left = 0\\n        last_min_k_index = -1\\n        last_max_k_index = -1\\n        fixed_bounds_subarrays = 0\\n\\n        for right, v in enumerate(nums):\\n            if v < minK or v > maxK:\\n                left = right + 1\\n            else:\\n                if v == minK:\\n                    last_min_k_index = right\\n                if v == maxK:\\n                    last_max_k_index = right\\n                if last_min_k_index >= left and last_max_k_index >= left:\\n                    fixed_bounds_subarrays += min(last_min_k_index, last_max_k_index) - left + 1\\n\\n        return fixed_bounds_subarrays\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3255114,
                "title": "very-easy-100-easiest-logic-ever-fully-explained-step-by-step-c-javascript-java-python",
                "content": "# Intuition\\nWe can use a sliding window approach to find all subarrays with minimum value minK and maximum value maxK. We can keep track of the start index of the current subarray and update it whenever we encounter a value that is less than minK or greater than maxK.\\nWhen we find a subarray with both minK and maxK, we can count the number of subarrays that can be formed by taking the minimum index of minK and maxK as the starting point and the current index as the ending point.\\n\\n# Approach\\nInitialize res to 0, start to 0, and minFound and maxFound to false.\\nIterate over the array nums.\\n\\nIf the current value num is less than minK or greater than maxK, set minFound and maxFound to false and update start to i+1.\\n\\nIf num is equal to minK, set minFound to true and update minStart to i.\\n\\nIf num is equal to maxK, set maxFound to true and update maxStart to i.\\n\\nIf minFound and maxFound are both true, add (min(minStart, maxStart) - start + 1) to res.\\n\\nReturn res.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} minK\\n * @param {number} maxK\\n * @return {number}\\n */\\nvar countSubarrays = function(nums, minK, maxK) {\\n   let sum = 0;\\n   let start = 0, minStart = 0, maxStart = 0;\\n   let minf = false, maxf = false;\\n\\n   for(let i = 0; i < nums.length; i++){\\n       let num = nums[i]\\n       if(num < minK || num > maxK){\\n           minf = false;\\n           maxf = false;\\n           start = i+1;\\n       }\\n\\n       if(num === minK){\\n           minf = true\\n           minStart = i;\\n       }\\n\\n       if(num === maxK){\\n           maxf = true\\n           maxStart = i;\\n       }\\n\\n       if(minf && maxf){\\n           sum += (Math.min(minStart, maxStart) - start+1)\\n       }\\n   } \\n\\n   return sum\\n};\\n```\\n![image.png](https://assets.leetcode.com/users/images/fc496d72-3165-404f-bfd5-ae8be105861e_1677922508.2982626.png)\\n\\n# Please Upvote \\n```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} minK\\n * @param {number} maxK\\n * @return {number}\\n */\\nvar countSubarrays = function(nums, minK, maxK) {\\n   let sum = 0;\\n   let start = 0, minStart = 0, maxStart = 0;\\n   let minf = false, maxf = false;\\n\\n   for(let i = 0; i < nums.length; i++){\\n       let num = nums[i]\\n       if(num < minK || num > maxK){\\n           minf = false;\\n           maxf = false;\\n           start = i+1;\\n       }\\n\\n       if(num === minK){\\n           minf = true\\n           minStart = i;\\n       }\\n\\n       if(num === maxK){\\n           maxf = true\\n           maxStart = i;\\n       }\\n\\n       if(minf && maxf){\\n           sum += (Math.min(minStart, maxStart) - start+1)\\n       }\\n   } \\n\\n   return sum\\n};\\n```\n```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2709045,
                "title": "explained-o-n-java-maths-solution",
                "content": "In this approach we\\'ll calculate all the possible subarrays the fall in the window where max and min are ***between*** a certain window.\\n\\n\\n\\n\\n\\nSo,\\ncount _1 will store the subarrays are in the window `>=minK` and `<=maxK `.\\ncount _2 will store the subarrays are in the window `>minK` and `<=maxK `.\\ncount _3 will store the subarrays are in the window `>=minK` and `<maxK `.\\ncount _4 will store the subarrays are in the window `>minK` and `<maxK `.\\n\\n<img src=\"https://assets.leetcode.com/users/images/d68ffe01-f607-410d-9760-1189cc7d7423_1665903316.3430128.png\" alt=\"diagram\" width=\"500\">\\n\\nTo calculate the number of subarrays that have `min=minK` and `max=maxK`, we use `count_1 - count_2 - count_3 + count_4`.\\n\\ncount_4 is beacause this window is present in both count_2 and count_3, and is subtracted 2 times. Hence it has to be added 1 time to get the correct answer.\\n\\n\\n\\n```\\nclass Solution {\\n    public long countSubarrays(int[] nums, int minK, int maxK) \\n    {\\n        int n = nums.length;\\n        long count1 = totalSubarrays(nums, n, maxK, minK);\\n\\t\\tlong count2 = totalSubarrays(nums, n, maxK, minK+1);\\n        long count3 = totalSubarrays(nums, n, maxK - 1, minK);\\n        long count4 = totalSubarrays(nums, n, maxK-1, minK+1);\\n        //System.out.println(count +\" \"+count1+\" \"+count2+\" \"+count3);\\n        long ans = count - count2 - count1 + count3;\\n \\n        return ans;\\n        \\n    }\\n    public long totalSubarrays(int arr[], int n, int k,int l)\\n    {\\n        long ans = 0;\\n        int i = 0;\\n        while (i < n) {        \\n            if (arr[i] > k || arr[i]< l) \\n            {\\n                i++;\\n                continue;\\n            } \\n            long count = 0;\\n            while (i < n && (arr[i] <= k && arr[i] >= l))\\n            {\\n                i++;\\n                count++;\\n            }\\n            ans += ((count * (count + 1)) / 2);\\n        }\\n        return ans;\\n    }\\n}\\n```\\nTime : O(n)",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public long countSubarrays(int[] nums, int minK, int maxK) \\n    {\\n        int n = nums.length;\\n        long count1 = totalSubarrays(nums, n, maxK, minK);\\n\\t\\tlong count2 = totalSubarrays(nums, n, maxK, minK+1);\\n        long count3 = totalSubarrays(nums, n, maxK - 1, minK);\\n        long count4 = totalSubarrays(nums, n, maxK-1, minK+1);\\n        //System.out.println(count +\" \"+count1+\" \"+count2+\" \"+count3);\\n        long ans = count - count2 - count1 + count3;\\n \\n        return ans;\\n        \\n    }\\n    public long totalSubarrays(int arr[], int n, int k,int l)\\n    {\\n        long ans = 0;\\n        int i = 0;\\n        while (i < n) {        \\n            if (arr[i] > k || arr[i]< l) \\n            {\\n                i++;\\n                continue;\\n            } \\n            long count = 0;\\n            while (i < n && (arr[i] <= k && arr[i] >= l))\\n            {\\n                i++;\\n                count++;\\n            }\\n            ans += ((count * (count + 1)) / 2);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2708018,
                "title": "four-pointers",
                "content": "We use the sliding window approach, where the current window is `[j, i)`.\\n\\nThere are two additional pointers (`p1` and `p2`) to track the elements equeal to `minK` and `maxK`.\\n\\n#### Catch-Up\\n\\nFirst, we find subarrays `[j, i)` where all elements are within the limits.\\n    \\nThen, for each `j`, we track two closest positions `p1` (minK) and `p2` (maxK) greater than `j`.\\n \\nThe number of subarrays for each `j` is `i - max(p1, p2)`. This is how it works for this test case:\\n\\n```\\n[5,2,1,2,3,2,1,2,5]\\n1\\n3\\n```\\n\\n![image](https://assets.leetcode.com/users/images/b7f3255a-3129-4fcc-aba0-67c1aea12245_1665966157.317106.png)\\n\\n**C++**\\n```cpp\\nlong long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n    long long res = 0, n = nums.size();\\n    for (int i = 0, j = 0; i <= n; ++i)\\n        if (i == n || nums[i] < minK || nums[i] > maxK)\\n            for (int p1 = j, p2 = j; j <= i; ++j) {\\n                while (p1 < i && (p1 < j || nums[p1] != minK))\\n                    ++p1;\\n                while (p2 < i && (p2 < j || nums[p2] != maxK))\\n                    ++p2;\\n                res += i - max(p1, p2);\\n            }\\n    return res;\\n}\\n```\\n\\n#### Extend\\nThe logic can be simplified if we track subarrays on the left. The number of subarrays for each `i` would be`min(p1, p2) - j`.\\n\\n![image](https://assets.leetcode.com/users/images/ed9cfc10-02d9-4329-8bc2-f79d0cc391cc_1665966478.258106.png)\\n\\n**C++**\\n```cpp\\nlong long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n    long long res = 0, n = nums.size();\\n    for (int i = 0, j = -1, p1 = -1, p2 = -1; i < n; ++i) {\\n        if (nums[i] < minK || nums[i] > maxK)\\n            p1 = p2 = j = i;\\n        p1 = nums[i] == minK ? i : p1;\\n        p2 = nums[i] == maxK ? i : p2;\\n        res += min(p1, p2) - j;\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n[5,2,1,2,3,2,1,2,5]\\n1\\n3\\n```\n```cpp\\nlong long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n    long long res = 0, n = nums.size();\\n    for (int i = 0, j = 0; i <= n; ++i)\\n        if (i == n || nums[i] < minK || nums[i] > maxK)\\n            for (int p1 = j, p2 = j; j <= i; ++j) {\\n                while (p1 < i && (p1 < j || nums[p1] != minK))\\n                    ++p1;\\n                while (p2 < i && (p2 < j || nums[p2] != maxK))\\n                    ++p2;\\n                res += i - max(p1, p2);\\n            }\\n    return res;\\n}\\n```\n```cpp\\nlong long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n    long long res = 0, n = nums.size();\\n    for (int i = 0, j = -1, p1 = -1, p2 = -1; i < n; ++i) {\\n        if (nums[i] < minK || nums[i] > maxK)\\n            p1 = p2 = j = i;\\n        p1 = nums[i] == minK ? i : p1;\\n        p2 = nums[i] == maxK ? i : p2;\\n        res += min(p1, p2) - j;\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2708008,
                "title": "o-n-solution-java",
                "content": "```\\npublic long countSubarrays(int[] nums, int minK, int maxK) {\\n    long ans = 0;\\n    int mini = 0, maxi = 0, c = 0;\\n    for (int i = 0; i < nums.length; i++) {\\n        if (nums[i] == minK)  mini = i;\\n        if (nums[i] == maxK)  maxi = i;\\n        if (nums[i] < minK || nums[i] > maxK) {\\n            c = i + 1;\\n            mini = maxi = i;\\n        }\\n        if (nums[mini] == minK && nums[maxi] == maxK)\\n            ans += Math.min(mini - c, maxi - c) + 1;\\n    }\\n    return ans;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic long countSubarrays(int[] nums, int minK, int maxK) {\\n    long ans = 0;\\n    int mini = 0, maxi = 0, c = 0;\\n    for (int i = 0; i < nums.length; i++) {\\n        if (nums[i] == minK)  mini = i;\\n        if (nums[i] == maxK)  maxi = i;\\n        if (nums[i] < minK || nums[i] > maxK) {\\n            c = i + 1;\\n            mini = maxi = i;\\n        }\\n        if (nums[mini] == minK && nums[maxi] == maxK)\\n            ans += Math.min(mini - c, maxi - c) + 1;\\n    }\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3254524,
                "title": "white-board-solution-using-sliding-window",
                "content": "# Video Solution\\nhttps://www.youtube.com/watch?v=Bk-HxzaooqM\\n\\n# Intution\\nCount the number of subarrays,\\nusing sliding window(three pointers).\\n\\n# Explanation\\n![image.png](https://assets.leetcode.com/users/images/49f7697e-504f-40b2-92a0-48c5f287e418_1677909700.5379775.png)\\n![image.png](https://assets.leetcode.com/users/images/b342100e-340a-4093-aa23-4306e7062e7c_1677909720.4575658.png)\\n![image.png](https://assets.leetcode.com/users/images/21756dfa-4ad6-44b5-865f-fffa10383d95_1677909734.7735925.png)\\n![image.png](https://assets.leetcode.com/users/images/2d5c564e-362b-4bcd-9e9e-674b9242c632_1677909750.6112893.png)\\n![image.png](https://assets.leetcode.com/users/images/b7e8972d-4c41-48dd-8e92-6ef64d3b71ed_1677909762.8237784.png)\\n\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n        long long int ans = 0;\\n        int badi = -1, mini = -1, maxi = -1, n = nums.size();\\n\\n        for(int i=0;i<n;i++){\\n            if(nums[i]  < minK || nums[i] > maxK) badi = i;\\n            if(nums[i] == minK) mini = i;\\n            if(nums[i] == maxK) maxi = i;\\n            ans += max(0, min(mini, maxi) - badi);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n        long long int ans = 0;\\n        int badi = -1, mini = -1, maxi = -1, n = nums.size();\\n\\n        for(int i=0;i<n;i++){\\n            if(nums[i]  < minK || nums[i] > maxK) badi = i;\\n            if(nums[i] == minK) mini = i;\\n            if(nums[i] == maxK) maxi = i;\\n            ans += max(0, min(mini, maxi) - badi);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3254355,
                "title": "easy-c-solution-o-n-tc",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialized `minK` amd `maxK` index with -1 as there last Position means they haven\\'t arrived.\\n2. `li` show last index of starting of valid subarray means in range of `minK` and `maxK`.\\n3. Then in Loop we allocating index according to alement arrival and also reseting if any out of `minK` and `maxK` arriving.\\n4. here `ans` is increasing when both the mni and mnx are arrived means they have not allocated -1 as there index.\\n4. returning `ans`.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n        long long n=nums.size(),mni=-1,mxi=-1,li=-1,ans=0;\\n        for(int i=0;i<n;++i){\\n            if(nums[i]<minK || nums[i]>maxK) li=i,mni=-1,mxi=-1;\\n            else{\\n                if(nums[i]==minK) mni=i;\\n                if(nums[i]==maxK) mxi=i;\\n                if(mni!=-1 && mxi!=-1) ans+=min(mni,mxi)-li;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Queue",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n        long long n=nums.size(),mni=-1,mxi=-1,li=-1,ans=0;\\n        for(int i=0;i<n;++i){\\n            if(nums[i]<minK || nums[i]>maxK) li=i,mni=-1,mxi=-1;\\n            else{\\n                if(nums[i]==minK) mni=i;\\n                if(nums[i]==maxK) mxi=i;\\n                if(mni!=-1 && mxi!=-1) ans+=min(mni,mxi)-li;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2709181,
                "title": "c-two-pointers-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n        long res = 0;\\n        bool minFound = false,maxFound = false;\\n        int start = 0,minStart = 0,maxStart = 0;\\n        \\n        for(int i=0;i<nums.size();i++){\\n            int num = nums[i];\\n            if(num < minK || num > maxK){\\n                minFound = false;\\n                maxFound = false;\\n                start = i+1;\\n            }\\n            \\n            if(num == minK){\\n                minFound  = true;\\n                minStart = i;\\n            }\\n            if(num == maxK){\\n                maxFound = true;\\n                maxStart = i;\\n            }\\n            \\n            if(minFound && maxFound){\\n                res += (min(minStart,maxStart) - start + 1);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n**Please upvote if it was helpful for you, thank you!**",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n        long res = 0;\\n        bool minFound = false,maxFound = false;\\n        int start = 0,minStart = 0,maxStart = 0;\\n        \\n        for(int i=0;i<nums.size();i++){\\n            int num = nums[i];\\n            if(num < minK || num > maxK){\\n                minFound = false;\\n                maxFound = false;\\n                start = i+1;\\n            }\\n            \\n            if(num == minK){\\n                minFound  = true;\\n                minStart = i;\\n            }\\n            if(num == maxK){\\n                maxFound = true;\\n                maxStart = i;\\n            }\\n            \\n            if(minFound && maxFound){\\n                res += (min(minStart,maxStart) - start + 1);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2708391,
                "title": "easy-and-intuitive-c-dp-solution-o-n-time-o-n-o-1-space",
                "content": "# Intuition\\nDP \\n\\n# Approach\\nLet `dp` be an array of size $(n+1) \\\\times 4$. Let \\n- `dp[i+1][0]` represents the number of subarrays that *ends at `nums[i]`* and with desired minimum and maximum attained. \\n- `dp[i+1][1]` represents the number of subarrays that *ends at `nums[i]`* and with desired minimum attained (but not for maximum). \\n- `dp[i+1][2]` represents the number of subarrays that *ends at `nums[i]`* and with desired maximum attained (but not for minimum). \\n- `dp[i+1][3]` represents the number of subarrays that *ends at `nums[i]`* and with neither maximum nor minimum attained. \\n\\nThe transitions are intuitive. We are counting the number of subarrays that ends with `nums[i]` so we must include this number. Then there are naturally four cases: `nums[i]` achieves the minK, achieves the maxK, achieves both, and achieves neither. Just consider the effect of adding `nums[i]` to all subarrays that end with `nums[i-1]`, and we will figure out the transitions. \\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$, and can be improved to be $O(1)$ since only `dp[i-1]` is used (and can add the result to `res` on the fly). Code attached at the end. \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n        \\n        vector<vector<long long>> dp(nums.size()+1, vector<long long>(4, 0));\\n        // dp[i][0] up to i, min = mink, max = maxk, end at nums[i]\\n        // dp[i][1] up to i, min = mink, max < maxk, end at nums[i]\\n        // dp[i][2] up to i, min > mink, max = maxk, end at nums[i]\\n        // dp[i][3] up to i, min > mink, max < maxk, end at nums[i]\\n        for (int i = 1; i <= nums.size(); i++)\\n        {\\n            int val = nums[i-1];\\n            if (minK <= val && val <= maxK)\\n            {\\n                if (val == minK && val == maxK)\\n                {\\n                    dp[i][0] = dp[i-1][0] + 1;\\n                    dp[i][1] = 0;\\n                    dp[i][2] = 0;\\n                    dp[i][3] = 0;\\n                } else if (val == minK && val < maxK)\\n                {\\n                    dp[i][0] = dp[i-1][0] + dp[i-1][2];\\n                    dp[i][1] = dp[i-1][1] + dp[i-1][3] + 1;\\n                    dp[i][2] = 0;\\n                    dp[i][3] = 0;\\n                } else if (val > minK && val == maxK)\\n                {\\n                    dp[i][0] = dp[i-1][0] + dp[i-1][1];\\n                    dp[i][1] = 0;\\n                    dp[i][2] = dp[i-1][2] + dp[i-1][3] + 1;\\n                    dp[i][3] = 0;\\n                } else if (val > minK && val < maxK)\\n                {\\n                    dp[i][0] = dp[i-1][0];\\n                    dp[i][1] = dp[i-1][1];\\n                    dp[i][2] = dp[i-1][2];\\n                    dp[i][3] = dp[i-1][3] + 1;\\n                }\\n            }\\n        }\\n        long long res = 0;\\n        for (int i = 1; i <= nums.size(); i++)\\n            res += dp[i][0];\\n        return res;\\n    }\\n};\\n```\\n\\nImproving space complexity to be $O(1)$: \\n```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n        vector<long long> prev (4, 0), curr (4, 0);\\n        long long res = 0;\\n        for (int i = 1; i <= nums.size(); i++)\\n        {\\n            int val = nums[i-1];\\n            if (minK <= val && val <= maxK)\\n            {\\n                if (val == minK && val == maxK)\\n                {\\n                    curr[0] = prev[0] + 1;\\n                    curr[1] = 0;\\n                    curr[2] = 0;\\n                    curr[3] = 0;\\n                } else if (val == minK && val < maxK)\\n                {\\n                    curr[0] = prev[0] + prev[2];\\n                    curr[1] = prev[1] + prev[3] + 1;\\n                    curr[2] = 0;\\n                    curr[3] = 0;\\n                } else if (val > minK && val == maxK)\\n                {\\n                    curr[0] = prev[0] + prev[1];\\n                    curr[1] = 0;\\n                    curr[2] = prev[2] + prev[3] + 1;\\n                    curr[3] = 0;\\n                } else if (val > minK && val < maxK)\\n                {\\n                    curr[0] = prev[0];\\n                    curr[1] = prev[1];\\n                    curr[2] = prev[2];\\n                    curr[3] = prev[3] + 1;\\n                }\\n            }\\n            res += curr[0];\\n            swap(curr, prev);\\n            curr = vector<long long>(4, 0);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n        \\n        vector<vector<long long>> dp(nums.size()+1, vector<long long>(4, 0));\\n        // dp[i][0] up to i, min = mink, max = maxk, end at nums[i]\\n        // dp[i][1] up to i, min = mink, max < maxk, end at nums[i]\\n        // dp[i][2] up to i, min > mink, max = maxk, end at nums[i]\\n        // dp[i][3] up to i, min > mink, max < maxk, end at nums[i]\\n        for (int i = 1; i <= nums.size(); i++)\\n        {\\n            int val = nums[i-1];\\n            if (minK <= val && val <= maxK)\\n            {\\n                if (val == minK && val == maxK)\\n                {\\n                    dp[i][0] = dp[i-1][0] + 1;\\n                    dp[i][1] = 0;\\n                    dp[i][2] = 0;\\n                    dp[i][3] = 0;\\n                } else if (val == minK && val < maxK)\\n                {\\n                    dp[i][0] = dp[i-1][0] + dp[i-1][2];\\n                    dp[i][1] = dp[i-1][1] + dp[i-1][3] + 1;\\n                    dp[i][2] = 0;\\n                    dp[i][3] = 0;\\n                } else if (val > minK && val == maxK)\\n                {\\n                    dp[i][0] = dp[i-1][0] + dp[i-1][1];\\n                    dp[i][1] = 0;\\n                    dp[i][2] = dp[i-1][2] + dp[i-1][3] + 1;\\n                    dp[i][3] = 0;\\n                } else if (val > minK && val < maxK)\\n                {\\n                    dp[i][0] = dp[i-1][0];\\n                    dp[i][1] = dp[i-1][1];\\n                    dp[i][2] = dp[i-1][2];\\n                    dp[i][3] = dp[i-1][3] + 1;\\n                }\\n            }\\n        }\\n        long long res = 0;\\n        for (int i = 1; i <= nums.size(); i++)\\n            res += dp[i][0];\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n        vector<long long> prev (4, 0), curr (4, 0);\\n        long long res = 0;\\n        for (int i = 1; i <= nums.size(); i++)\\n        {\\n            int val = nums[i-1];\\n            if (minK <= val && val <= maxK)\\n            {\\n                if (val == minK && val == maxK)\\n                {\\n                    curr[0] = prev[0] + 1;\\n                    curr[1] = 0;\\n                    curr[2] = 0;\\n                    curr[3] = 0;\\n                } else if (val == minK && val < maxK)\\n                {\\n                    curr[0] = prev[0] + prev[2];\\n                    curr[1] = prev[1] + prev[3] + 1;\\n                    curr[2] = 0;\\n                    curr[3] = 0;\\n                } else if (val > minK && val == maxK)\\n                {\\n                    curr[0] = prev[0] + prev[1];\\n                    curr[1] = 0;\\n                    curr[2] = prev[2] + prev[3] + 1;\\n                    curr[3] = 0;\\n                } else if (val > minK && val < maxK)\\n                {\\n                    curr[0] = prev[0];\\n                    curr[1] = prev[1];\\n                    curr[2] = prev[2];\\n                    curr[3] = prev[3] + 1;\\n                }\\n            }\\n            res += curr[0];\\n            swap(curr, prev);\\n            curr = vector<long long>(4, 0);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2708654,
                "title": "c-easy-explanation-w-example-100-faster-sliding-window",
                "content": "WINDOW = SUBARRAY\\nKeep record of the most recet index of minK and maxK in current window as it is needed while counting subarrays.\\n**Variables:**\\nmini = most recent index where nums[index] = minK\\nmaxi = most recent index where  nums[index] = maxK\\ncnt   = no. of fixed bound subarrays\\ni       = left corner of current window\\nj       = right corner of current window\\n\\n**Example:**  nums = [2,3,1,1,0,5,7]  minK=1, maxK=5\\nin window i = 0, j = 5\\nmini = 3(index of most recent 1), maxi = 5(index of most recent 5)\\n\\nfixed bound subarrays are [2,3,1,1,0,5], [3,1,1,0,5], [1,1,0,5], [1,0,5]\\nobserve [1,0,5] remains same we just iterate incrementing left index as 2,3,1,1 i.e, from i to min(mini, maxi)\\ncnt = min(mini, maxi) - i + 1;\\n\\nwhen i = 0, j = 6 : nums[j] = 7 > maxK \\nthis window is of no use, max no. in the window should be maxK for being fixed bound subarray \\nSLIDE THE WINDOW : i = j+1 because keeping jth index in window is of no use\\n\\n**If it helps, please UPVOTE : )**\\n\\n```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, int minK, int maxK) \\n    {\\n        int  n = nums.size();\\n        long long cnt = 0, mini = -1, maxi = -1; \\n        int i = 0, j = 0;                        //for iterating nums\\n\\n        while(j < n)                             //can also use for loop for j\\n        {\\n            if(nums[j] < minK || nums[j] > maxK) //subarray of no use now, move window\\n            {\\n                mini = maxi = -1;                //set new mini and maxi of new window\\n                i = j+1;                         //slide the window\\n            }\\n\\n            if (nums[j] == minK) mini = j;       //update the index of recently observed minK\\n\\t\\t\\tif (nums[j] == maxK) maxi = j;       //update the index of recently observed maxK\\n\\n            cnt += max(0LL, min(mini, maxi) - i + 1);  //if 2nd part of max is -ve means we don\\'t have minK and maxK in window now so max(0, -ve) = 0, no increment\\n\\n            j++;                                 //keep increasing the window towards right\\n        }\\n\\t\\treturn cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, int minK, int maxK) \\n    {\\n        int  n = nums.size();\\n        long long cnt = 0, mini = -1, maxi = -1; \\n        int i = 0, j = 0;                        //for iterating nums\\n\\n        while(j < n)                             //can also use for loop for j\\n        {\\n            if(nums[j] < minK || nums[j] > maxK) //subarray of no use now, move window\\n            {\\n                mini = maxi = -1;                //set new mini and maxi of new window\\n                i = j+1;                         //slide the window\\n            }\\n\\n            if (nums[j] == minK) mini = j;       //update the index of recently observed minK\\n\\t\\t\\tif (nums[j] == maxK) maxi = j;       //update the index of recently observed maxK\\n\\n            cnt += max(0LL, min(mini, maxi) - i + 1);  //if 2nd part of max is -ve means we don\\'t have minK and maxK in window now so max(0, -ve) = 0, no increment\\n\\n            j++;                                 //keep increasing the window towards right\\n        }\\n\\t\\treturn cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3253971,
                "title": "beats-90-o-n-detailed-explanation-with-dry-run",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->We have to find the subarray having minK and maxK as greatest and lowest bound. We have to keep track at each iteration about the existance of minK and maxK and simultaneously we have to count the subarrays. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. First of all, declare bool variables like minFound and maxFound to keep the track of minK and maxK in subarray.\\n2. Declare integer variables-\\n- start variable to store the starting index of subarray.\\n- minStart variable to store the minimum start index of subarray.\\n- maxStart variable to store the maxmum start index of subarray.\\n3. In each iteration,\\n - If nums[i] is smaller mink or greater than maxK, set minFound and maxfound to false and set start = i+1;\\n - if nums[i] is equal minK, set minFound to true and minStart = i.\\n - if nums[i] is equal maxK, set maxFound to true and maxStart = i.\\n4. In each iteration, we have to calculate total number of subarrays,\\n- for that, we have to find the minimum of minStart and maxstart because in array maxK can occur before minK as array isnt sorted.\\n- we have to subtract the minimum of minStart and maxStart with start variable because start is the initial of subarray.\\n\\n# Example With Dry Run\\n![WhatsApp Image 2023-03-04 at 06.13.19.jpg](https://assets.leetcode.com/users/images/b6c0e6fd-976d-4a21-b872-d2a0a1eed7ad_1677891771.4762344.jpeg)\\nconnect on linkdin if u have any doubt- https://linkedin.com/in/bhaskar-agrawal-a01069219 \\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& num, int minK, int maxK) {\\n        long ans = 0;\\n        bool minFound = false, maxFound = false;\\n        int start = 0, minStart = 0, maxStart = 0;\\n        for (int i = 0; i < num.size(); i++) {\\n            if (num[i] < minK || num[i] > maxK) {\\n                minFound = false;\\n                maxFound = false;\\n                start = i+1; \\n            }\\n            // keeping track of minFound and minstart\\n            if (num[i] == minK) {\\n                minFound = true;\\n                minStart = i;\\n            }\\n            // keeping track of maxFound and maxStart\\n            if (num[i]== maxK) {\\n                maxFound = true;\\n                maxStart = i;\\n            }\\n            // calculating the count when both are true\\n            if (minFound && maxFound) {\\n                ans += (min(minStart, maxStart) - start + 1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& num, int minK, int maxK) {\\n        long ans = 0;\\n        bool minFound = false, maxFound = false;\\n        int start = 0, minStart = 0, maxStart = 0;\\n        for (int i = 0; i < num.size(); i++) {\\n            if (num[i] < minK || num[i] > maxK) {\\n                minFound = false;\\n                maxFound = false;\\n                start = i+1; \\n            }\\n            // keeping track of minFound and minstart\\n            if (num[i] == minK) {\\n                minFound = true;\\n                minStart = i;\\n            }\\n            // keeping track of maxFound and maxStart\\n            if (num[i]== maxK) {\\n                maxFound = true;\\n                maxStart = i;\\n            }\\n            // calculating the count when both are true\\n            if (minFound && maxFound) {\\n                ans += (min(minStart, maxStart) - start + 1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3255171,
                "title": "c-sol",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n        long res = 0;\\n        bool minFound = false, maxFound = false;\\n        int start = 0, minStart = 0, maxStart = 0;\\n        for (int i = 0; i < nums.size(); i++) {\\n            int num = nums[i];\\n            if (num < minK || num > maxK) {\\n                minFound = false;\\n                maxFound = false;\\n                start = i+1;\\n            }\\n            if (num == minK) {\\n                minFound = true;\\n                minStart = i;\\n            }\\n            if (num == maxK) {\\n                maxFound = true;\\n                maxStart = i;\\n            }\\n            if (minFound && maxFound) {\\n                res += (min(minStart, maxStart) - start + 1);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n        long res = 0;\\n        bool minFound = false, maxFound = false;\\n        int start = 0, minStart = 0, maxStart = 0;\\n        for (int i = 0; i < nums.size(); i++) {\\n            int num = nums[i];\\n            if (num < minK || num > maxK) {\\n                minFound = false;\\n                maxFound = false;\\n                start = i+1;\\n            }\\n            if (num == minK) {\\n                minFound = true;\\n                minStart = i;\\n            }\\n            if (num == maxK) {\\n                maxFound = true;\\n                maxStart = i;\\n            }\\n            if (minFound && maxFound) {\\n                res += (min(minStart, maxStart) - start + 1);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3254362,
                "title": "c",
                "content": "# Complexity\\n- Time complexity: ```O(n)```\\n- Space complexity: ```O(1)```\\n\\n# Code\\n```\\npublic class Solution {\\n    public long CountSubarrays(int[] nums, int minK, int maxK) {\\n        int minPosition = -1, maxPosition = -1, leftBound = -1;\\n        long answer = 0;\\n\\n        for(int i = 0; i < nums.Length; i++) {\\n            if(nums[i] == minK) minPosition = i;\\n            if(nums[i] == maxK) maxPosition = i;\\n            if(nums[i] < minK || nums[i] > maxK) leftBound = i;\\n            answer += Math.Max(0, Math.Min(maxPosition, minPosition) - leftBound);\\n        }\\n\\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```O(n)```\n```O(1)```\n```\\npublic class Solution {\\n    public long CountSubarrays(int[] nums, int minK, int maxK) {\\n        int minPosition = -1, maxPosition = -1, leftBound = -1;\\n        long answer = 0;\\n\\n        for(int i = 0; i < nums.Length; i++) {\\n            if(nums[i] == minK) minPosition = i;\\n            if(nums[i] == maxK) maxPosition = i;\\n            if(nums[i] < minK || nums[i] > maxK) leftBound = i;\\n            answer += Math.Max(0, Math.Min(maxPosition, minPosition) - leftBound);\\n        }\\n\\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2708319,
                "title": "divide-and-process-c",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDivide the array into smaller subarrays at indices where nums[i] <minK or nums[i]>minK. Now process each subarray individually. For every subarray track all indices of minK and maxK. For every index in subarray find the last minK,maxK if both exists in subarray and add count for all the subarray having from start to last index(minK,maxK).\\n\\n# Complexity\\n- Time complexity: O(n log n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n    long long getRes(vector<int>& nums,int si,int ei,int minK,int maxK){     \\n        vector<int> mink,maxk;  \\n        for(int i =si;i<=ei;i++){\\n            if(nums[i]== minK)mink.push_back(i);\\n            if(nums[i]== maxK)maxk.push_back(i); }\\n        \\n       long long res = 0;\\n       for(int i =si;i<=ei;i++){  \\n        auto a = lower_bound(mink.begin(),mink.end(),i);\\n        auto b = lower_bound(maxk.begin(),maxk.end(),i);\\n        \\n        if(a==mink.end()||b == maxk.end() )continue;\\n        int x = *(a) ;\\n        int y = *(b);\\n        int v = max(x,y);\\n        res+= (ei-v+1); }\\n        return res;  \\n    }\\n    \\n    long long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n        int l = -1,r = -1;\\n        long long ans = 0;\\n        for(int i =0;i<nums.size();i++){\\n            if(nums[i]<=maxK && nums[i]>= minK){\\n                  if(l == -1)l = i; \\n                     r = i;  }\\n            else{   \\n                if(l!=-1)\\n                ans+= getRes(nums,l,r,minK,maxK);\\n                l = -1,r = -1;\\n            if(nums[i]<=maxK && nums[i]>= minK){\\n                  if(l == -1)l = i; \\n                      r = i;\\n            }   }   }\\n        \\n        if(l!= -1)\\n            ans += getRes(nums,l,r,minK,maxK);\\n        return ans;        \\n    }\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n    long long getRes(vector<int>& nums,int si,int ei,int minK,int maxK){     \\n        vector<int> mink,maxk;  \\n        for(int i =si;i<=ei;i++){\\n            if(nums[i]== minK)mink.push_back(i);\\n            if(nums[i]== maxK)maxk.push_back(i); }\\n        \\n       long long res = 0;\\n       for(int i =si;i<=ei;i++){  \\n        auto a = lower_bound(mink.begin(),mink.end(),i);\\n        auto b = lower_bound(maxk.begin(),maxk.end(),i);\\n        \\n        if(a==mink.end()||b == maxk.end() )continue;\\n        int x = *(a) ;\\n        int y = *(b);\\n        int v = max(x,y);\\n        res+= (ei-v+1); }\\n        return res;  \\n    }\\n    \\n    long long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n        int l = -1,r = -1;\\n        long long ans = 0;\\n        for(int i =0;i<nums.size();i++){\\n            if(nums[i]<=maxK && nums[i]>= minK){\\n                  if(l == -1)l = i; \\n                     r = i;  }\\n            else{   \\n                if(l!=-1)\\n                ans+= getRes(nums,l,r,minK,maxK);\\n                l = -1,r = -1;\\n            if(nums[i]<=maxK && nums[i]>= minK){\\n                  if(l == -1)l = i; \\n                      r = i;\\n            }   }   }\\n        \\n        if(l!= -1)\\n            ans += getRes(nums,l,r,minK,maxK);\\n        return ans;        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3365395,
                "title": "day-63-two-pointer-o-n-time-and-o-1-space-easiest-beginner-friendly-sol",
                "content": "**NOTE - PLEASE READ INTUITION AND APPROACH FIRST THEN SEE THE CODE. YOU WILL DEFINITELY UNDERSTAND THE CODE LINE BY LINE AFTER SEEING THE APPROACH.**\\n\\n# Intuition of this Problem:\\nThis solution works by iterating over the given array nums and keeping track of the most recent positions of the minimum value minK and the maximum value maxK in the array, as well as the most recent index leftBound outside the range [minK, maxK].\\n\\nFor each element in the array, if it falls within the range [minK, maxK], the code updates the most recent positions of minK and maxK, calculates the number of subarrays that can be formed between the most recent positions of minK and maxK, and adds this count to the answer.\\n\\nIf the current element falls outside the range [minK, maxK], the code updates the leftBound index to the current index i, and resets the most recent positions of minK and maxK to -1.\\n\\nIn the end, the code returns the total count of valid subarrays.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach for this Problem:\\nThe approach used in the given code can be classified as a two-pointer approach. We are maintaining two pointers, lastMin and lastMax, that track the most recent occurrences of minK and maxK, respectively. The variable leftBound represents the left endpoint of the current subarray being considered. By comparing the values of lastMin, lastMax, and leftBound, we are able to determine the number of valid subarrays within the range [minK, maxK]. \\n\\n**Explanation of code point wise :**\\n1. **int n = nums.size(); :** This statement initializes a variable n with the size of the input vector nums.\\n2. **int leftBound = -1; :** This statement initializes a variable leftBound to -1. This variable represents the index of the left endpoint of the current subarray being considered. Initially, there is no subarray being considered, so we set leftBound to -1.\\n3. **int lastMin = -1, lastMax = -1; :** These statements initialize two variables lastMin and lastMax to -1. These variables represent the indices of the most recent occurrences of minK and maxK, respectively. Initially, there are no occurrences of minK and maxK, so we set both variables to -1.\\n4. **long long count = 0; :** This statement initializes a variable count to 0. This variable represents the count of valid subarrays that we will be computing.\\n5. **for (int i = 0; i < n; i++) { ... } n :** This statement starts a loop that iterates over each element of the input vector nums.\\n6. **if (nums[i] >= minK && nums[i] <= maxK) { ... } :** This statement checks if the current element nums[i] is within the range [minK, maxK].\\n7. **lastMin = (nums[i] == minK) ? i : lastMin; :** This statement updates lastMin to the current index i if nums[i] is equal to minK, otherwise it leaves lastMin unchanged.\\n8. **lastMax = (nums[i] == maxK) ? i : lastMax; :** This statement updates lastMax to the current index i if nums[i] is equal to maxK, otherwise it leaves lastMax unchanged.\\n9. **count += max(0, min(lastMin, lastMax) - leftBound); :** This statement computes the number of valid subarrays that end at the current index i and adds it to the total count. The number of valid subarrays is equal to the number of subarrays whose minimum and maximum elements are both in the range [minK, maxK].\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Code:\\n```C++ []\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n        // initialize some variables\\n        int n = nums.size();\\n        int leftBound = -1;\\n        int lastMin = -1, lastMax = -1;\\n        long long count = 0;\\n        \\n        for (int i = 0; i < n; i++) {\\n            // check if nums[i] is within the range [minK, maxK]\\n            if (nums[i] >= minK && nums[i] <= maxK) {\\n                // if nums[i] is equal to minK, update lastMin to the current index i\\n                lastMin = (nums[i] == minK) ? i : lastMin;\\n                // if nums[i] is equal to maxK, update lastMax to the current index i\\n                lastMax = (nums[i] == maxK) ? i : lastMax;\\n                // update the count by the number of valid subarrays between leftBound and the \\n                // smaller of lastMin and lastMax\\n                count += max(0, min(lastMin, lastMax) - leftBound);\\n            } else {\\n                // if nums[i] is not within the range [minK, maxK], update leftBound to i\\n                leftBound = i;\\n                // reset lastMin and lastMax to -1\\n                lastMin = -1;\\n                lastMax = -1;\\n            }\\n        }\\n        \\n        // return the final count of valid subarrays\\n        return count;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public long countSubarrays(int[] nums, int minK, int maxK) {\\n        int n = nums.length;\\n        int leftBound = -1;\\n        int lastMin = -1, lastMax = -1;\\n        long count = 0;\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] >= minK && nums[i] <= maxK) {\\n                lastMin = (nums[i] == minK) ? i : lastMin;\\n                lastMax = (nums[i] == maxK) ? i : lastMax;\\n                count += Math.max(0, Math.min(lastMin, lastMax) - leftBound);\\n            } else {\\n                leftBound = i;\\n                lastMin = -1;\\n                lastMax = -1;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n\\n```\\n```Python []\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], minK: int, maxK: int) -> int:\\n        n = len(nums)\\n        leftBound = -1\\n        lastMin, lastMax = -1, -1\\n        count = 0\\n        \\n        for i in range(n):\\n            if nums[i] >= minK and nums[i] <= maxK:\\n                lastMin = i if nums[i] == minK else lastMin\\n                lastMax = i if nums[i] == maxK else lastMax\\n                count += max(0, min(lastMin, lastMax) - leftBound)\\n            else:\\n                leftBound = i\\n                lastMin = -1\\n                lastMax = -1\\n        \\n        return count\\n\\n```\\n\\n# Time Complexity and Space Complexity:\\n- Time complexity: **O(n)**, where n is the length of the input vector nums. This is because we are iterating through the input vector once, and for each iteration, we perform constant time operations.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(1)**, which means it uses a constant amount of extra memory. This is because we are only using a fixed number of variables to keep track of the state of the algorithm and not allocating any additional memory that scales with the size of the input.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n        // initialize some variables\\n        int n = nums.size();\\n        int leftBound = -1;\\n        int lastMin = -1, lastMax = -1;\\n        long long count = 0;\\n        \\n        for (int i = 0; i < n; i++) {\\n            // check if nums[i] is within the range [minK, maxK]\\n            if (nums[i] >= minK && nums[i] <= maxK) {\\n                // if nums[i] is equal to minK, update lastMin to the current index i\\n                lastMin = (nums[i] == minK) ? i : lastMin;\\n                // if nums[i] is equal to maxK, update lastMax to the current index i\\n                lastMax = (nums[i] == maxK) ? i : lastMax;\\n                // update the count by the number of valid subarrays between leftBound and the \\n                // smaller of lastMin and lastMax\\n                count += max(0, min(lastMin, lastMax) - leftBound);\\n            } else {\\n                // if nums[i] is not within the range [minK, maxK], update leftBound to i\\n                leftBound = i;\\n                // reset lastMin and lastMax to -1\\n                lastMin = -1;\\n                lastMax = -1;\\n            }\\n        }\\n        \\n        // return the final count of valid subarrays\\n        return count;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public long countSubarrays(int[] nums, int minK, int maxK) {\\n        int n = nums.length;\\n        int leftBound = -1;\\n        int lastMin = -1, lastMax = -1;\\n        long count = 0;\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] >= minK && nums[i] <= maxK) {\\n                lastMin = (nums[i] == minK) ? i : lastMin;\\n                lastMax = (nums[i] == maxK) ? i : lastMax;\\n                count += Math.max(0, Math.min(lastMin, lastMax) - leftBound);\\n            } else {\\n                leftBound = i;\\n                lastMin = -1;\\n                lastMax = -1;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n\\n```\n```Python []\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], minK: int, maxK: int) -> int:\\n        n = len(nums)\\n        leftBound = -1\\n        lastMin, lastMax = -1, -1\\n        count = 0\\n        \\n        for i in range(n):\\n            if nums[i] >= minK and nums[i] <= maxK:\\n                lastMin = i if nums[i] == minK else lastMin\\n                lastMax = i if nums[i] == maxK else lastMax\\n                count += max(0, min(lastMin, lastMax) - leftBound)\\n            else:\\n                leftBound = i\\n                lastMin = -1\\n                lastMax = -1\\n        \\n        return count\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2708781,
                "title": "easy-c-solution-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe know the answer for index `(i-1)`. What are the changes will happen if we consider the current element, index `i`, how will we calculate answer for the current index. And What will be our final result.\\n<hr>\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n* The sub-array must contain elements in the range [minK, maxK], so if there is an element in the array which is `nums[i] < minK` or `nums[i] > maxK`, then it could not be included in any subarray.\\n\\n* The fixed ranges will be from the beginning of minK or maxK and the end of maxK or minK\\n       `[1,3,5,2,7,5] -> [{1,3,5},2,7,5]` from index o to 2 it must be fixed.\\nSo, we start from the beginning but, we cannot start making sub-array until we get both minK and maxK.\\n\\n* First we start with the limit is 0. Here the limit is defined as the lowest point from where we can start forming a subarray. The limit will be updated once we cannot take an element in the subarray. i.e.,  `nums[i] < minK` or `nums[i] > maxK`. \\n\\n* `minInd` and `maxInd` will carry the recent appearance of the `minK` and `maxK` respectively.\\n\\nThe idea here is:\\n* Let\\'s say we know the number of subarrays that could be formed from the limit to last element.\\nUsing `[2,3,4,{1,3,5},2,3,1,2,7,5]` this array as an example with `minK = 1`, `maxK = 5`.\\n\\n* Let\\'s say we are at index `i = 7`. At this point, we have `nums[i] = 3`, and we know the answer up to index `i = 6`. So, adding the new element to the group how many **new sub-arrays** can be formed? We have to take `{1,3,5}` in the sub-array definitely and we can take` {2,3,4}` in the beginning. So, the number of new sub-array that could be formed will be 4 here. Which is `min(minInd, maxInd) - limit + 1`. \\n\\n* Now, let\\u2019s consider `i = 8`. At this point `nums[i] = 1`, which is `minK`. So now we can take this `[2,3,4,1,3,{5,2,3,1},2,7,5]` like this, so we have to update out `minInd = 8`. And the number of new sub-array that could be formed is `6`. We cannot form more new sub-arrays considering the new element. \\n\\n<hr>\\n\\n# Complexity\\n- Time complexity: `O(n)`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: `O(1)`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n  long long countSubarrays(vector<int>& nums, int minK, int maxK){\\n    ll n = nums.size(), limit = 0, minInd = -1, maxInd = -1, res = 0;\\n    for(ll i=0; i<n; i++){\\n      if(nums[i] == minK) \\n        minInd = i;\\n      if(nums[i] == maxK)\\n        maxInd = i;\\n      if(nums[i] < minK || nums[i] > maxK)\\n        limit = i + 1;\\n      res += max(0ll, min(minInd, maxInd) - limit + 1);\\n    }\\n    return res;\\n  }\\n};\\n```\\n\\n# Thanks and Regards\\nI couldn\\'t solve it during the contest, referred a few solutions. And tried to explain one of them.\\n\\nPlease don\\'t forget to **upvote if it helps.**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n  long long countSubarrays(vector<int>& nums, int minK, int maxK){\\n    ll n = nums.size(), limit = 0, minInd = -1, maxInd = -1, res = 0;\\n    for(ll i=0; i<n; i++){\\n      if(nums[i] == minK) \\n        minInd = i;\\n      if(nums[i] == maxK)\\n        maxInd = i;\\n      if(nums[i] < minK || nums[i] > maxK)\\n        limit = i + 1;\\n      res += max(0ll, min(minInd, maxInd) - limit + 1);\\n    }\\n    return res;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2708378,
                "title": "java-simplest-solution-with-explanation",
                "content": "finished after the contest :(\\n\\nbasically every time we find a valid window, we count the available subarrays within this window with\\n```\\ncount += Math.min(max, min) - i + 1;\\n```\\nwhere i is the start of current window, Math.min(max, min) is the last index where the subarray is still valid\\ne.g. current window 0 1 2 3 4 5 6 7 8, min 6, max 8\\nstart is 0, Math.min(min, max) is 6\\nvalid subarrays are: 0-8, 1-8... 6-8, so 6 - 0 + 1 = 7 windows\\n```\\nclass Solution {\\n    public long countSubarrays(int[] nums, int minK, int maxK) {\\n        long count = 0;\\n        int min = -1, max = -1, j = 0, i = 0;\\n        for (; j < nums.length; j++) {\\n            // out of bounds: restart\\n            if (nums[j] < minK || nums[j] > maxK) {\\n                min = -1;\\n                max = -1;\\n                i = j + 1;\\n                continue;\\n            }\\n            //update min/max pointer\\n            if (nums[j] == minK) min = j;\\n            if (nums[j] == maxK) max = j;\\n            \\n            // from the start (i) to last available window index (Math.min(max, min))\\n            if (max >= 0 && min >= 0) count += Math.min(max, min) - i + 1;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\ncount += Math.min(max, min) - i + 1;\\n```\n```\\nclass Solution {\\n    public long countSubarrays(int[] nums, int minK, int maxK) {\\n        long count = 0;\\n        int min = -1, max = -1, j = 0, i = 0;\\n        for (; j < nums.length; j++) {\\n            // out of bounds: restart\\n            if (nums[j] < minK || nums[j] > maxK) {\\n                min = -1;\\n                max = -1;\\n                i = j + 1;\\n                continue;\\n            }\\n            //update min/max pointer\\n            if (nums[j] == minK) min = j;\\n            if (nums[j] == maxK) max = j;\\n            \\n            // from the start (i) to last available window index (Math.min(max, min))\\n            if (max >= 0 && min >= 0) count += Math.min(max, min) - i + 1;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2708049,
                "title": "python3-o-n",
                "content": "The key idea is we need to first find each subarray bounded index left and right, where left is either -1 or nums[left]<minK or nums[left]>maxK, and right is either len(nums) or nums[right]<minK or nums[right]>maxK. And then calculate the number of the valided subarray in it.\\n\\n```\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], minK: int, maxK: int) -> int:\\n        Min = []\\n        Max = []\\n        res = 0\\n        left = -1\\n        for right in range(len(nums)):\\n            if nums[right]>maxK or nums[right]<minK:\\n                while Min and Max:\\n                    l = min(Min[0],Max[0])\\n                    r = max(Min[0],Max[0])\\n                    res += (l-left)*(right-r)\\n                    if Min[0]<Max[0]:\\n                        left = Min.pop(0)\\n                    else:\\n                        left = Max.pop(0)\\n                Min = []\\n                Max = []\\n                left = right\\n            else:\\n                if nums[right]==minK:\\n                    Min.append(right)\\n                if nums[right]==maxK:\\n                    Max.append(right)\\n        right = len(nums)\\n        while Min and Max:\\n            l = min(Min[0],Max[0])\\n            r = max(Min[0],Max[0])\\n            res += (l-left)*(right-r)\\n            if Min[0]<Max[0]:\\n                left = Min.pop(0)\\n            else:\\n                left = Max.pop(0)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], minK: int, maxK: int) -> int:\\n        Min = []\\n        Max = []\\n        res = 0\\n        left = -1\\n        for right in range(len(nums)):\\n            if nums[right]>maxK or nums[right]<minK:\\n                while Min and Max:\\n                    l = min(Min[0],Max[0])\\n                    r = max(Min[0],Max[0])\\n                    res += (l-left)*(right-r)\\n                    if Min[0]<Max[0]:\\n                        left = Min.pop(0)\\n                    else:\\n                        left = Max.pop(0)\\n                Min = []\\n                Max = []\\n                left = right\\n            else:\\n                if nums[right]==minK:\\n                    Min.append(right)\\n                if nums[right]==maxK:\\n                    Max.append(right)\\n        right = len(nums)\\n        while Min and Max:\\n            l = min(Min[0],Max[0])\\n            r = max(Min[0],Max[0])\\n            res += (l-left)*(right-r)\\n            if Min[0]<Max[0]:\\n                left = Min.pop(0)\\n            else:\\n                left = Max.pop(0)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2708017,
                "title": "java-simple-one-pass-solution-explained-with-diagram-o-n-time-o-1-space",
                "content": "**Intuition**: Loop through the entire array one time.\\nAt each index ith, find all *fixed-bound subarrays* with ith index as the right edge of subarray.\\n\\n**How to check fixed-bound arrays**\\nThere are two types of subarrays that end at ith index.\\n1. Subarrays where all values are *within bound*. e.g. minK <= value<= maxK\\n2. Subarrays where there exists a value *equal* to minK, and a value *equal* to maxK.\\n\\nIf both 1 and 2 are satisfied, it will be a *fixed bound subarray*.\\n\\n**Implementation**\\n1. Use `start` variable to exclude values outside bound, where start is exclusive. All subarrays in `(start, end]` are within bound.\\n\\n2. Use `hasMax` to store latest index where `nums[hasMax] == maxK`\\n    Use `hasMin` to store latest index where `nums[hasMin] == minK`\\n\\n3. Use `Math.min(hasMax, hasMin)` to find largest left edge where subarray `[left, right]` contains both `minK` and `maxK` \\n\\n\\nDiagram to illustrate:\\n![image](https://assets.leetcode.com/users/images/2c21c3fe-f08c-4c7b-b848-8bf4c0979d30_1665891739.4677215.png)\\n\\n\\n**Complexity:**\\nTime: O(N) complexity since it is only one-pass.\\nSpace: O(1) space complexity since only a few variables are initialised.\\n\\nLong solution:\\n```\\nclass Solution {\\n    public long countSubarrays(int[] nums, int minK, int maxK) {\\n        long totalSubarrays = 0;\\n        int n = nums.length;\\n        int hasMin = -1, hasMax = -1, start = -1;\\n\\n        for (int end = 0; end < n; end++) {\\n            if (nums[end] == minK) {\\n                hasMin = end;\\n            } \\n            if (nums[end] == maxK) {\\n                hasMax = end;\\n            }\\n\\t\\t\\t\\n\\t\\t\\t// if value is not within bound\\n            if (nums[end] > maxK || nums[end] < minK) {\\n                hasMin = -1;\\n                hasMax = -1;\\n\\t\\t\\t\\t// update start to exclude current value\\n                start = end;\\n            }\\n            \\n            if (hasMin != -1 && hasMax != -1) {\\n                int totalSubarraysWithinBound = end - start;\\n                int totalSubarraysWithoutMinOrMax = end - Math.min(hasMin, hasMax);\\n                totalSubarrays += (totalSubarraysWithinBound - totalSubarraysWithoutMinOrMax);\\n            }\\n        }\\n        return totalSubarrays;\\n    }\\n}\\n```\\n\\nShort solution:\\n\\n**Optimisation:**\\n `totalSubarraysWithinBound -totalSubarraysWithoutMinOrMax` === `(end - start) - (end - Math.min(hasMin, hasMax))` === `Math.min(hasMin, hasMax) - start`\\n\\n```\\nclass Solution {\\n    public long countSubarrays(int[] nums, int minK, int maxK) {\\n        long totalSubarrays = 0;\\n        int n = nums.length, hasMin = -1, hasMax = -1, start = -1;\\n        \\n        for (int end = 0; end < n; end++) {\\n            if (nums[end] == minK) hasMin = end;\\n            if (nums[end] == maxK) hasMax = end;\\n            if (nums[end] > maxK || nums[end] < minK) start = end;\\n            \\n            totalSubarrays += Math.max(0, (Math.min(hasMin, hasMax) - start));\\n        }\\n        \\n        return totalSubarrays;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public long countSubarrays(int[] nums, int minK, int maxK) {\\n        long totalSubarrays = 0;\\n        int n = nums.length;\\n        int hasMin = -1, hasMax = -1, start = -1;\\n\\n        for (int end = 0; end < n; end++) {\\n            if (nums[end] == minK) {\\n                hasMin = end;\\n            } \\n            if (nums[end] == maxK) {\\n                hasMax = end;\\n            }\\n\\t\\t\\t\\n\\t\\t\\t// if value is not within bound\\n            if (nums[end] > maxK || nums[end] < minK) {\\n                hasMin = -1;\\n                hasMax = -1;\\n\\t\\t\\t\\t// update start to exclude current value\\n                start = end;\\n            }\\n            \\n            if (hasMin != -1 && hasMax != -1) {\\n                int totalSubarraysWithinBound = end - start;\\n                int totalSubarraysWithoutMinOrMax = end - Math.min(hasMin, hasMax);\\n                totalSubarrays += (totalSubarraysWithinBound - totalSubarraysWithoutMinOrMax);\\n            }\\n        }\\n        return totalSubarrays;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public long countSubarrays(int[] nums, int minK, int maxK) {\\n        long totalSubarrays = 0;\\n        int n = nums.length, hasMin = -1, hasMax = -1, start = -1;\\n        \\n        for (int end = 0; end < n; end++) {\\n            if (nums[end] == minK) hasMin = end;\\n            if (nums[end] == maxK) hasMax = end;\\n            if (nums[end] > maxK || nums[end] < minK) start = end;\\n            \\n            totalSubarrays += Math.max(0, (Math.min(hasMin, hasMax) - start));\\n        }\\n        \\n        return totalSubarrays;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4009219,
                "title": "easy-35-lines-of-code-with-explanation-using-inclusion-exclusion-principle",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe need to find all subarrays having minimum value as minK \\nand maximum value as maxK.\\n\\nNow\\nI will have indices of 4 types\\n1 -> value greater than maxK or less than minK\\n2 -> indices with value as minK\\n3 -> indices with value as maxK\\n4 -> other left indices\\n\\nWe will exclude the first type of indices from our domain of possible indices to include because they will either disrupt maximum element or minimum element.\\n\\nso now the formula for answer(number of subarrays) **after excluding the 1st type of indices** will be\\n        \\nTotal Subarrays(excluding 1st type of indices) - subarrays with either no index with maxK or no index with minK(again excluding 1st type)\\nbecause if there is no index left with both 2 and 3 type of indices not present then atleast one of the two conditions will not be satisfied\\n\\nNow by **Inclusion Exclusion principle**\\ncount(not maxK index | not minK index) = \\ncount(not maxK index) + count(not minK index) \\n-count(not maxK index & not minK index)\\n\\n# Approach\\nSo we have to just find number of subarrays excluding some type indices.\\nWe can make a function for that which takes a set of indices which should not be included and returns the subarrays.\\nWe can make a set of indices which should not be included for every type which we require. \\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n        if(minK>maxK){return 0;}\\n        ll n = nums.size();\\n\\n        auto subcnt = [](ll cnt)-> ll{\\n            return (cnt*(cnt+1))/2;\\n        };\\n\\n        function <ll(set<ll>)> sub = [&](set <ll> excluded){\\n            ll prev(-1); // previously excluded index\\n            ll ans(0); \\n            for(auto x:excluded){\\n                ans += subcnt(x-prev);\\n                prev = x;\\n            }\\n            ans += subcnt(n-prev);\\n            return ans;\\n        };\\n\\n        set <ll> tot,sMin,sMax,sAll;\\n        for(int i=0; i<n; i++){\\n            if(minK>nums[i] || maxK<nums[i]){\\n                tot.insert(i); sMin.insert(i); sMax.insert(i); sAll.insert(i);\\n            }else if(nums[i]==minK){\\n                sMin.insert(i); sAll.insert(i);\\n            }else if(nums[i]==maxK){\\n                sMax.insert(i); sAll.insert(i);\\n            }\\n        }\\n\\n        ll total = sub(tot), notMin = sub(sMin), notMax = sub(sMax), notAll = sub(sAll);\\n        if(minK==maxK){return (total-notAll);}\\n        ll ans = total - notMin - notMax + notAll;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n        if(minK>maxK){return 0;}\\n        ll n = nums.size();\\n\\n        auto subcnt = [](ll cnt)-> ll{\\n            return (cnt*(cnt+1))/2;\\n        };\\n\\n        function <ll(set<ll>)> sub = [&](set <ll> excluded){\\n            ll prev(-1); // previously excluded index\\n            ll ans(0); \\n            for(auto x:excluded){\\n                ans += subcnt(x-prev);\\n                prev = x;\\n            }\\n            ans += subcnt(n-prev);\\n            return ans;\\n        };\\n\\n        set <ll> tot,sMin,sMax,sAll;\\n        for(int i=0; i<n; i++){\\n            if(minK>nums[i] || maxK<nums[i]){\\n                tot.insert(i); sMin.insert(i); sMax.insert(i); sAll.insert(i);\\n            }else if(nums[i]==minK){\\n                sMin.insert(i); sAll.insert(i);\\n            }else if(nums[i]==maxK){\\n                sMax.insert(i); sAll.insert(i);\\n            }\\n        }\\n\\n        ll total = sub(tot), notMin = sub(sMin), notMax = sub(sMax), notAll = sub(sAll);\\n        if(minK==maxK){return (total-notAll);}\\n        ll ans = total - notMin - notMax + notAll;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3294112,
                "title": "easiest-and-best-5-lines-of-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n`Very much thank you for visiting (*-*)` \\u2764\\uFE0F\\n\\n# Code\\n`Plsssss UpVote (*-*)` \\n```\\nclass Solution {\\n    public long countSubarrays(int[] nums, int minK, int maxK) {\\n        long ans = 0; int min = -1, max = -1, left = -1;\\n        for (int i = 0; i < nums.length; ++i) {\\n            if (nums[i] < minK || nums[i] > maxK) left = i;\\n            if (nums[i] == minK) min = i;\\n            if (nums[i] == maxK) max = i;\\n            ans += Math.max(0, Math.min(max, min) - left);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long countSubarrays(int[] nums, int minK, int maxK) {\\n        long ans = 0; int min = -1, max = -1, left = -1;\\n        for (int i = 0; i < nums.length; ++i) {\\n            if (nums[i] < minK || nums[i] > maxK) left = i;\\n            if (nums[i] == minK) min = i;\\n            if (nums[i] == maxK) max = i;\\n            ans += Math.max(0, Math.min(max, min) - left);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3285362,
                "title": "easy-c-solution-using-finder-and-future-array-without-sliding-window",
                "content": "# Approach\\nStored the future Destinations of max and min numbers in array and also stored possiblities of subarray at each index.\\n\\n# Complexity\\n- Time complexity:\\n    O(nlogn)\\n\\n- Space complexity:\\n    O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n        // return 0;\\n        int n = nums.size();\\n        unordered_map<int,set<int>>mp;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]==minK || nums[i]==maxK){\\n                mp[nums[i]].insert(i);\\n            }\\n        }\\n        // bool mink=false,maxk=false;\\n        vector<int>finder(n,-1);\\n        for(int i=0;i<n;i++){\\n            if(nums[i]==minK){\\n                auto it = mp[maxK].lower_bound(i);\\n                if(it!=mp[maxK].end()){\\n                    finder[i]=*it;\\n                }\\n            }\\n            else if(nums[i]==maxK){\\n                auto it = mp[minK].lower_bound(i);\\n                if(it!=mp[minK].end()){\\n                    finder[i]=*it;\\n                }\\n            }\\n            else if(nums[i]<=maxK && nums[i]>=minK){\\n                auto it1 = mp[maxK].lower_bound(i);\\n                auto it2 = mp[minK].lower_bound(i);\\n                if(it1!=mp[maxK].end() && it2!=mp[minK].end()){\\n                    finder[i]=max(*it1,*it2);\\n                }\\n            }\\n        }\\n        vector<int>future(n,0);\\n        int curr=0;\\n        for(int i=n-1;i>=0;i--){\\n            // future[i]=curr;\\n            if(nums[i]>=minK && nums[i]<=maxK){\\n                future[i]=curr;\\n                curr++;\\n            }\\n            else\\n            {\\n                curr=0;\\n            }\\n        }\\n        // cout<<\"finder array\"<<endl;\\n        // for(auto &i:finder){\\n        //     cout<<i<<\\' \\';\\n        // }\\n        // cout<<endl;\\n        // cout<<\"future array\"<<endl;\\n        // for(auto &i:future){\\n        //     cout<<i<<\\' \\';\\n        // }\\n        // cout<<endl;\\n        // cout<<\"indexes where ans is updated\"<<endl;\\n        long long ans=0;\\n        for(int i=0;i<n;i++){\\n            if(finder[i]!=-1){\\n                if(finder[i]<=future[i]+i){\\n                    ans+=future[finder[i]]+1;\\n                    // cout<<i<<\\' \\';\\n                }\\n                    \\n            }\\n        }\\n        // cout<<endl;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n        // return 0;\\n        int n = nums.size();\\n        unordered_map<int,set<int>>mp;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]==minK || nums[i]==maxK){\\n                mp[nums[i]].insert(i);\\n            }\\n        }\\n        // bool mink=false,maxk=false;\\n        vector<int>finder(n,-1);\\n        for(int i=0;i<n;i++){\\n            if(nums[i]==minK){\\n                auto it = mp[maxK].lower_bound(i);\\n                if(it!=mp[maxK].end()){\\n                    finder[i]=*it;\\n                }\\n            }\\n            else if(nums[i]==maxK){\\n                auto it = mp[minK].lower_bound(i);\\n                if(it!=mp[minK].end()){\\n                    finder[i]=*it;\\n                }\\n            }\\n            else if(nums[i]<=maxK && nums[i]>=minK){\\n                auto it1 = mp[maxK].lower_bound(i);\\n                auto it2 = mp[minK].lower_bound(i);\\n                if(it1!=mp[maxK].end() && it2!=mp[minK].end()){\\n                    finder[i]=max(*it1,*it2);\\n                }\\n            }\\n        }\\n        vector<int>future(n,0);\\n        int curr=0;\\n        for(int i=n-1;i>=0;i--){\\n            // future[i]=curr;\\n            if(nums[i]>=minK && nums[i]<=maxK){\\n                future[i]=curr;\\n                curr++;\\n            }\\n            else\\n            {\\n                curr=0;\\n            }\\n        }\\n        // cout<<\"finder array\"<<endl;\\n        // for(auto &i:finder){\\n        //     cout<<i<<\\' \\';\\n        // }\\n        // cout<<endl;\\n        // cout<<\"future array\"<<endl;\\n        // for(auto &i:future){\\n        //     cout<<i<<\\' \\';\\n        // }\\n        // cout<<endl;\\n        // cout<<\"indexes where ans is updated\"<<endl;\\n        long long ans=0;\\n        for(int i=0;i<n;i++){\\n            if(finder[i]!=-1){\\n                if(finder[i]<=future[i]+i){\\n                    ans+=future[finder[i]]+1;\\n                    // cout<<i<<\\' \\';\\n                }\\n                    \\n            }\\n        }\\n        // cout<<endl;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3255829,
                "title": "c-easy-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& v, int mink, int maxk) {\\n        bool mnf=false,mxf=false;\\n        long long c=0;\\n        long long s=0;\\n        long long mn,mx;\\n        for(int i=0;i<v.size();i++){\\n            if(mink>v[i] || maxk<v[i]){\\n                mnf=false;mxf=false;\\n                s=i+1;\\n            }\\n            if(mink==v[i]){\\n                mnf=true;\\n                mn=i;\\n            }\\n            if(maxk==v[i]){\\n                mxf=true;\\n                mx=i;\\n            }\\n            if(mnf && mxf){\\n                c+=min(mn,mx)-s+1;\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& v, int mink, int maxk) {\\n        bool mnf=false,mxf=false;\\n        long long c=0;\\n        long long s=0;\\n        long long mn,mx;\\n        for(int i=0;i<v.size();i++){\\n            if(mink>v[i] || maxk<v[i]){\\n                mnf=false;mxf=false;\\n                s=i+1;\\n            }\\n            if(mink==v[i]){\\n                mnf=true;\\n                mn=i;\\n            }\\n            if(maxk==v[i]){\\n                mxf=true;\\n                mx=i;\\n            }\\n            if(mnf && mxf){\\n                c+=min(mn,mx)-s+1;\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3255301,
                "title": "go-beats-100-simple-solution-three-pointers",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$ \\n\\n# Code\\n```\\nfunc min(x, y int) int {\\n\\tif x < y {\\n\\t\\treturn x\\n\\t}\\n\\treturn y\\n}\\n\\nfunc countSubarrays(nums []int, minK int, maxK int) int64 {\\n\\tvar ans int64\\n\\tlastMin, lastMax := -1, -1\\n\\tleftmost := 0\\n\\tfor i, d := range nums {\\n\\t\\tif d < minK || d > maxK {\\n\\t\\t\\tleftmost = i + 1\\n\\t\\t\\tlastMin = -1\\n\\t\\t\\tlastMax = -1\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tif d == minK {\\n\\t\\t\\tlastMin = i\\n\\t\\t}\\n\\t\\tif d == maxK {\\n\\t\\t\\tlastMax = i\\n\\t\\t}\\n        if lastMin != -1 && lastMax != -1 {\\n            ans += int64(min(lastMin, lastMax)-leftmost+1)\\n        }\\n\\t}\\n\\t\\n\\treturn ans\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Go",
                    "Array",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nfunc min(x, y int) int {\\n\\tif x < y {\\n\\t\\treturn x\\n\\t}\\n\\treturn y\\n}\\n\\nfunc countSubarrays(nums []int, minK int, maxK int) int64 {\\n\\tvar ans int64\\n\\tlastMin, lastMax := -1, -1\\n\\tleftmost := 0\\n\\tfor i, d := range nums {\\n\\t\\tif d < minK || d > maxK {\\n\\t\\t\\tleftmost = i + 1\\n\\t\\t\\tlastMin = -1\\n\\t\\t\\tlastMax = -1\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tif d == minK {\\n\\t\\t\\tlastMin = i\\n\\t\\t}\\n\\t\\tif d == maxK {\\n\\t\\t\\tlastMax = i\\n\\t\\t}\\n        if lastMin != -1 && lastMax != -1 {\\n            ans += int64(min(lastMin, lastMax)-leftmost+1)\\n        }\\n\\t}\\n\\t\\n\\treturn ans\\n}\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3254681,
                "title": "python3-three-markers-straightforward-an-super-concise",
                "content": "# Intuition\\nSweep along the array. Mark the last appereance of minK, maxK, and number outside the boundary as $a$,$b$,$x$. The start points of the subarray that ends here range from $x+1$ to $\\\\text{min}(a,b)$. Example:\\n\\n![image.png](https://assets.leetcode.com/users/images/435228d7-07a3-467c-bc1a-0ba372423488_1677912651.12321.png)\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], minK: int, maxK: int) -> int:\\n        x,a,b = -1,-2,-2\\n        res = 0\\n        for i,n in enumerate(nums):\\n            if n>maxK or n<minK: x = i\\n            if n == minK: a = i\\n            if n == maxK: b = i\\n            res += max(0, min(a,b) - x)\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], minK: int, maxK: int) -> int:\\n        x,a,b = -1,-2,-2\\n        res = 0\\n        for i,n in enumerate(nums):\\n            if n>maxK or n<minK: x = i\\n            if n == minK: a = i\\n            if n == maxK: b = i\\n            res += max(0, min(a,b) - x)\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3254008,
                "title": "count-subarrays-with-fixed-bounds-solving-the-leetcode-challenge-march-4-2023",
                "content": "![image.png](https://assets.leetcode.com/users/images/d5bd5c46-5f44-4fa7-820f-dd165a96fb91_1677816522.0925934.png)\\n\\n# Full explaination at : [Solution](https://yoichiisagi.hashnode.dev/count-subarrays-with-fixed-bounds-solving-the-leetcode-challenge-march-4-2023)\\n\\n![image.png](https://assets.leetcode.com/users/images/6907ce4f-a766-4668-bd51-1cedade65e46_1677816533.0083919.png)\\n\\n# Code\\n```\\nclass Solution {\\n    public long countSubarrays(int[] nums, int minK, int maxK) {\\n        long res = 0;\\n            \\n        int min=-1, max=-1, left = -1;\\n        \\n        for (int i=0; i<nums.length; i++) {\\n            if (nums[i]<minK || nums[i] > maxK) {\\n                left = min = max = i;\\n            } \\n            min = nums[i]==minK ? i : min;\\n            max = nums[i]==maxK ? i : max;\\n            res += Math.min(max, min)-left;  \\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long countSubarrays(int[] nums, int minK, int maxK) {\\n        long res = 0;\\n            \\n        int min=-1, max=-1, left = -1;\\n        \\n        for (int i=0; i<nums.length; i++) {\\n            if (nums[i]<minK || nums[i] > maxK) {\\n                left = min = max = i;\\n            } \\n            min = nums[i]==minK ? i : min;\\n            max = nums[i]==maxK ? i : max;\\n            res += Math.min(max, min)-left;  \\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2721499,
                "title": "python-rust-c-simple-idea-fast-solution-with-detailed-comments",
                "content": "**IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n**** \\n**Comment.** The idea behind the solution is simple. Each time we encounter an in-range number, we should first check that both *minK* and *maxK* are present in the current contiguous sequence of in-range numbers (i.e., since the last out-of-range number), then add all intervals that incorporate at least one *minK* and at least one *maxK*.\\n**** \\n**Python.** This [**solution**](https://leetcode.com/submissions/detail/825824488/) employs smart counting of subarrays. It demonstrated **922 ms runtime (92.88%)** and used **28.7 MB memory (54.56%)**. Time complexity is linear: **O(N)**. Space complexity is constant: **O(1)**.\\n```\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], minK: int, maxK: int) -> int:\\n        \\n        # [1] storage for indices of the last encountered\\n        #     types of numbers (minK, maxK and out-of-range)\\n        last_out = -1\\n        last_min = -1\\n        last_max = -1\\n        \\n        count = 0\\n        \\n        for i,n in enumerate(nums):\\n            \\n            if minK <= n <= maxK: \\n                if n == minK : last_min = i\\n                if n == maxK : last_max = i\\n                # [2] magic happens here: if on current iteration the\\n                #     number \\'n\\' falls in a given range, then we:\\n                #     - first, ensure that both minK and maxK have been\\n                #       seen after the last ouf-range-number;\\n                #     - second, we add all intervals that start right after\\n                #       the last out-of-range number and incorporate\\n\\t\\t\\t\\t#       at least one minK and at least one maxK\\n                count += max(min(last_min, last_max) - last_out, 0)\\n            else:\\n                last_out = i\\n            \\n        return count\\n```\\n**** \\n**Rust.** This [**solution**](https://leetcode.com/submissions/detail/825817964/) employs smart counting of subarrays. It demonstrated **12 ms runtime (100.00%)** and used **3.5 MB memory (30.00%)**. Time complexity is linear: **O(N)**. Space complexity is constant: **O(1)**.\\n```\\nimpl Solution \\n{\\n    pub fn count_subarrays(nums: Vec<i32>, min_k: i32, max_k: i32) -> i64 \\n    {\\n        // [1] storage for indices of the last encountered\\n        //     types of numbers (min_k, max_k and out-of-range)\\n        let mut last_out : i64 = -1;\\n        let mut last_min : i64 = -1;\\n        let mut last_max : i64 = -1;\\n\\n        let mut count    : i64 = 0;\\n\\n        for (i,n) in nums.into_iter().enumerate()\\n        {\\n            if min_k <= n && n <= max_k\\n            {\\n                if n == min_k { last_min = i as i64; }\\n                if n == max_k { last_max = i as i64; }\\n\\n                // [2] magic happens here: if on current iteration the\\n                //     number \\'n\\' falls in a given range, then we:\\n                //     - first, ensure that both min_k and max_k have been\\n                //       seen after the last ouf-range-number;\\n                //     - second, we add all intervals that start right after\\n                //       the last out-of-range number and incorporate \\n\\t\\t\\t\\t//       at least one min_k and at least one max_k\\n                count += 0i64.max(last_min.min(last_max) - last_out);\\n            }\\n            else { last_out = i as i64; }\\n        }\\n\\n        return count;\\n    }\\n}\\n```\\n**** \\n**\\u0421++.** This [**solution**](https://leetcode.com/submissions/detail/825826930/) employs smart counting of subarrays. It demonstrated **72 ms runtime (100.0%)** and used **70.2 MB memory (91.02%)**. Time complexity is linear: **O(N)**. Space complexity is constant: **O(1)**.\\n```\\n#include <algorithm>\\n\\nclass Solution \\n{\\npublic:\\n    long long countSubarrays(vector<int>& nums, int minK, int maxK) \\n    {\\n        // [1] storage for indices of the last encountered\\n        //     types of numbers (minK, maxK and out-of-range)\\n        long long last_out = -1;\\n        long long last_min = -1;\\n        long long last_max = -1;\\n        \\n        long long count    = 0;\\n        \\n        for (int i = 0; i < nums.size(); i++)\\n        {\\n            if (minK <= nums[i] && nums[i] <= maxK)\\n            {\\n                if (nums[i] == minK) last_min = i;\\n                if (nums[i] == maxK) last_max = i;\\n\\n                // [2] magic happens here: if on current iteration the\\n                //     number \\'n\\' falls in a given range, then we:\\n                //     - first, ensure that both minK and maxK have been\\n                //       seen after the last ouf-range-number;\\n                //     - second, we add all intervals that start right\\n                //       the last out-of-range number and incorporate \\n\\t\\t\\t\\t//       at least one minK and at least one maxK\\n                count += max(0LL, min(last_min, last_max) - last_out);\\n            }\\n            else last_out = i;\\n        }\\n\\n        return count;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "Python",
                    "C",
                    "Rust"
                ],
                "code": "```\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], minK: int, maxK: int) -> int:\\n        \\n        # [1] storage for indices of the last encountered\\n        #     types of numbers (minK, maxK and out-of-range)\\n        last_out = -1\\n        last_min = -1\\n        last_max = -1\\n        \\n        count = 0\\n        \\n        for i,n in enumerate(nums):\\n            \\n            if minK <= n <= maxK: \\n                if n == minK : last_min = i\\n                if n == maxK : last_max = i\\n                # [2] magic happens here: if on current iteration the\\n                #     number \\'n\\' falls in a given range, then we:\\n                #     - first, ensure that both minK and maxK have been\\n                #       seen after the last ouf-range-number;\\n                #     - second, we add all intervals that start right after\\n                #       the last out-of-range number and incorporate\\n\\t\\t\\t\\t#       at least one minK and at least one maxK\\n                count += max(min(last_min, last_max) - last_out, 0)\\n            else:\\n                last_out = i\\n            \\n        return count\\n```\n```\\nimpl Solution \\n{\\n    pub fn count_subarrays(nums: Vec<i32>, min_k: i32, max_k: i32) -> i64 \\n    {\\n        // [1] storage for indices of the last encountered\\n        //     types of numbers (min_k, max_k and out-of-range)\\n        let mut last_out : i64 = -1;\\n        let mut last_min : i64 = -1;\\n        let mut last_max : i64 = -1;\\n\\n        let mut count    : i64 = 0;\\n\\n        for (i,n) in nums.into_iter().enumerate()\\n        {\\n            if min_k <= n && n <= max_k\\n            {\\n                if n == min_k { last_min = i as i64; }\\n                if n == max_k { last_max = i as i64; }\\n\\n                // [2] magic happens here: if on current iteration the\\n                //     number \\'n\\' falls in a given range, then we:\\n                //     - first, ensure that both min_k and max_k have been\\n                //       seen after the last ouf-range-number;\\n                //     - second, we add all intervals that start right after\\n                //       the last out-of-range number and incorporate \\n\\t\\t\\t\\t//       at least one min_k and at least one max_k\\n                count += 0i64.max(last_min.min(last_max) - last_out);\\n            }\\n            else { last_out = i as i64; }\\n        }\\n\\n        return count;\\n    }\\n}\\n```\n```\\n#include <algorithm>\\n\\nclass Solution \\n{\\npublic:\\n    long long countSubarrays(vector<int>& nums, int minK, int maxK) \\n    {\\n        // [1] storage for indices of the last encountered\\n        //     types of numbers (minK, maxK and out-of-range)\\n        long long last_out = -1;\\n        long long last_min = -1;\\n        long long last_max = -1;\\n        \\n        long long count    = 0;\\n        \\n        for (int i = 0; i < nums.size(); i++)\\n        {\\n            if (minK <= nums[i] && nums[i] <= maxK)\\n            {\\n                if (nums[i] == minK) last_min = i;\\n                if (nums[i] == maxK) last_max = i;\\n\\n                // [2] magic happens here: if on current iteration the\\n                //     number \\'n\\' falls in a given range, then we:\\n                //     - first, ensure that both minK and maxK have been\\n                //       seen after the last ouf-range-number;\\n                //     - second, we add all intervals that start right\\n                //       the last out-of-range number and incorporate \\n\\t\\t\\t\\t//       at least one minK and at least one maxK\\n                count += max(0LL, min(last_min, last_max) - last_out);\\n            }\\n            else last_out = i;\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2708918,
                "title": "javascript-sliding-window-3-pointers-and-flag-for-min-and-max",
                "content": "```\\nvar countSubarrays = function(nums, minK, maxK) {\\n    let res = 0\\n    let startOfWindow = 0\\n    let currMinPos = -1\\n    let currMaxPos = -1\\n    let foundMin = false\\n    let foundMax = false\\n    \\n    for(let right = 0; right < nums.length; right++) {\\n        const curr = nums[right]\\n        \\n        if(curr === minK) {\\n            foundMin = true\\n            currMinPos = right\\n        }\\n        \\n        if(curr === maxK) {\\n            foundMax = true\\n            currMaxPos = right\\n        }\\n        \\n        \\n        if(curr < minK || curr > maxK) {\\n            foundMin = false\\n            foundMax= false\\n            startOfWindow = right+1\\n        }\\n        \\n        if(foundMin && foundMax) {\\n            res += (Math.min(currMinPos, currMaxPos) - startOfWindow + 1)\\n        }\\n    }\\n    \\n    return res\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar countSubarrays = function(nums, minK, maxK) {\\n    let res = 0\\n    let startOfWindow = 0\\n    let currMinPos = -1\\n    let currMaxPos = -1\\n    let foundMin = false\\n    let foundMax = false\\n    \\n    for(let right = 0; right < nums.length; right++) {\\n        const curr = nums[right]\\n        \\n        if(curr === minK) {\\n            foundMin = true\\n            currMinPos = right\\n        }\\n        \\n        if(curr === maxK) {\\n            foundMax = true\\n            currMaxPos = right\\n        }\\n        \\n        \\n        if(curr < minK || curr > maxK) {\\n            foundMin = false\\n            foundMax= false\\n            startOfWindow = right+1\\n        }\\n        \\n        if(foundMin && foundMax) {\\n            res += (Math.min(currMinPos, currMaxPos) - startOfWindow + 1)\\n        }\\n    }\\n    \\n    return res\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2708110,
                "title": "c-explained-solution-using-two-pointer-time-o-n-space-o-1",
                "content": "**Approach -** \\n**Step 1** - Find current min and current max values\\n**Step 2** - If cur element might be part of fixed-bound subarray than initialize start with cur index\\n**Step 3** - If cur element if minK than initialize left with cur index\\n**Step 4** - If cur element if maxK than initialize right with cur index\\n**Step 5** - If current max and cur min values are equal to maxK and minK then this is last element of any fixed-subaaray.\\n->    If cur element is equal to maxK than sub array that start\\'s from start to left and end at cur index is a fixed-bound subarray, so store cur length in a variable\\n->    Else if cur element is equal to mixK than sub array that start\\'s from start to right and end at cur index is a fixed-bound subarray, so store cur length in a variable\\n->    Add cur length to ans\\n**Step 6** - If cur max is greater than maxK or cur min less than minK then it will not be part of subarray so reset all values\\n**Step 7** - Return ans\\n\\n**Code -**\\n\\n```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& a, int minK, int maxK) { \\n        int n = a.size(),start = -1 , left =-1, right =-1 , curMx = INT_MIN, curMn = INT_MAX, flag=0 , curLen =0 ;\\n        // start -> First element that might be the part of fixed-bound subaaray\\n        // left -> Last element that is equal to minK after start\\n        // right -> Last elemetn that is equal to maxK after start\\n        // curMx -> max value after start\\n        // curMn -> min value after start\\n        // flag -> Used for initializing start\\n        // curLen -> Length from start to left or right depend upon cur value of element\\n        long long ans =0;\\n        for(int i=0;i<n;i++){\\n            curMx = max(curMx,a[i]);       \\n            curMn = min(curMn,a[i]);       \\n            if(flag==0&&a[i]>=minK&&a[i]<=maxK){\\n                start = i;\\n                flag=1;\\n            }\\n\\t\\t\\tif(a[i]==minK) left = i;\\n            if(a[i]==maxK) right = i;\\n            if(curMx==maxK&&curMn==minK){\\n                if(a[i]==maxK) curLen = (left-start+1);        // If cur element if maxK then curLen is from start to left\\n                else  if(a[i]==minK) curLen = (right-start+1); // Else if cur element if maxK then curLen is from start to right\\n                ans+= curLen;                                  // Otherwise no change in curLen\\n            }\\n            else if(curMx>maxK||curMn<minK){      // If cur element is greater than maxK or less than minK then it will not be part of subarray so reset all values\\n                curMx = INT_MIN;\\n                curMn = INT_MAX;\\n                start =-1;\\n                left = -1;\\n                right = -1;\\n                curLen = 0;\\n                flag =0;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Time Complexity - O(N)** \\n**Space Complexity - O(1)**\\nN is the length of the given array\\n\\n\\n**Upvote if you like it!**\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& a, int minK, int maxK) { \\n        int n = a.size(),start = -1 , left =-1, right =-1 , curMx = INT_MIN, curMn = INT_MAX, flag=0 , curLen =0 ;\\n        // start -> First element that might be the part of fixed-bound subaaray\\n        // left -> Last element that is equal to minK after start\\n        // right -> Last elemetn that is equal to maxK after start\\n        // curMx -> max value after start\\n        // curMn -> min value after start\\n        // flag -> Used for initializing start\\n        // curLen -> Length from start to left or right depend upon cur value of element\\n        long long ans =0;\\n        for(int i=0;i<n;i++){\\n            curMx = max(curMx,a[i]);       \\n            curMn = min(curMn,a[i]);       \\n            if(flag==0&&a[i]>=minK&&a[i]<=maxK){\\n                start = i;\\n                flag=1;\\n            }\\n\\t\\t\\tif(a[i]==minK) left = i;\\n            if(a[i]==maxK) right = i;\\n            if(curMx==maxK&&curMn==minK){\\n                if(a[i]==maxK) curLen = (left-start+1);        // If cur element if maxK then curLen is from start to left\\n                else  if(a[i]==minK) curLen = (right-start+1); // Else if cur element if maxK then curLen is from start to right\\n                ans+= curLen;                                  // Otherwise no change in curLen\\n            }\\n            else if(curMx>maxK||curMn<minK){      // If cur element is greater than maxK or less than minK then it will not be part of subarray so reset all values\\n                curMx = INT_MIN;\\n                curMn = INT_MAX;\\n                start =-1;\\n                left = -1;\\n                right = -1;\\n                curLen = 0;\\n                flag =0;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3300205,
                "title": "c-one-pass-linear-short-sweet-c-code",
                "content": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n        long long int ans = 0;\\n        int lb=-1,lmn=-1,lmx=-1,i,n=nums.size();\\n        for(i =0; i<n;i++){\\n            if(nums[i]>=minK&&nums[i]<=maxK){\\n                lmn = (nums[i]==minK)?i:lmn;\\n                lmx = (nums[i]==maxK)?i:lmx;\\n                ans += max(0,min(lmn,lmx)-lb);\\n            }else{\\n                lb = i,lmn=-1,lmx=-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n        long long int ans = 0;\\n        int lb=-1,lmn=-1,lmx=-1,i,n=nums.size();\\n        for(i =0; i<n;i++){\\n            if(nums[i]>=minK&&nums[i]<=maxK){\\n                lmn = (nums[i]==minK)?i:lmn;\\n                lmx = (nums[i]==maxK)?i:lmx;\\n                ans += max(0,min(lmn,lmx)-lb);\\n            }else{\\n                lb = i,lmn=-1,lmx=-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3285438,
                "title": "easy-o-n-c-solution-space-o-1",
                "content": "# Approach\\n-    Just take a variable which stores the index of number that we dont want to take.\\n-    Now, just traverse the array and the length will give you the no. of subarrays.\\n-    Add it to your ans.\\n\\n# Complexity\\n- Time complexity:\\n    $$O(n)$$\\n\\n- Space complexity:\\n    $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n        int n=nums.size();\\n        int maxk=-1,mink=-1,nok=-1;\\n        long long ans=0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]<minK || nums[i]>maxK){\\n                nok=i;\\n            }\\n            if(nums[i]==minK)\\n                mink=i;\\n            if(nums[i]==maxK)\\n                maxk=i;\\n            ans+=max(0,min(mink,maxk)-nok);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n        int n=nums.size();\\n        int maxk=-1,mink=-1,nok=-1;\\n        long long ans=0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]<minK || nums[i]>maxK){\\n                nok=i;\\n            }\\n            if(nums[i]==minK)\\n                mink=i;\\n            if(nums[i]==maxK)\\n                maxk=i;\\n            ans+=max(0,min(mink,maxk)-nok);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3257176,
                "title": "c-two-pointers",
                "content": "# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n        long long ans=0;\\n        int n=nums.size(),l=0,r=0;\\n        while(r<n)\\n        {\\n            if(nums[r] < minK || nums[r] > maxK)\\n            {\\n                int lastmin=-1,lastmax=-1;\\n                for(int i=l;i<r;i++)\\n                {\\n                    if(nums[i]==minK) lastmin=i;\\n                    if(nums[i]==maxK) lastmax=i;\\n                    if(lastmin >= 0  && lastmax>=0)\\n                    {\\n                        ans+= 1ll*(min(lastmin,lastmax)-l +1);\\n                    }\\n                }\\n                l=r+1;\\n            }\\n            r++;\\n        }\\n         int lastmin=-1,lastmax=-1;\\n        for(int i=l;i<r;i++)\\n        {\\n            if(nums[i]==minK) lastmin=i;\\n            if(nums[i]==maxK) lastmax=i;\\n            if(lastmin >= 0  && lastmax>=0)\\n            {\\n                ans+= 1ll*(min(lastmin,lastmax)-l +1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n        long long ans=0;\\n        int n=nums.size(),l=0,r=0;\\n        while(r<n)\\n        {\\n            if(nums[r] < minK || nums[r] > maxK)\\n            {\\n                int lastmin=-1,lastmax=-1;\\n                for(int i=l;i<r;i++)\\n                {\\n                    if(nums[i]==minK) lastmin=i;\\n                    if(nums[i]==maxK) lastmax=i;\\n                    if(lastmin >= 0  && lastmax>=0)\\n                    {\\n                        ans+= 1ll*(min(lastmin,lastmax)-l +1);\\n                    }\\n                }\\n                l=r+1;\\n            }\\n            r++;\\n        }\\n         int lastmin=-1,lastmax=-1;\\n        for(int i=l;i<r;i++)\\n        {\\n            if(nums[i]==minK) lastmin=i;\\n            if(nums[i]==maxK) lastmax=i;\\n            if(lastmin >= 0  && lastmax>=0)\\n            {\\n                ans+= 1ll*(min(lastmin,lastmax)-l +1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3256292,
                "title": "count-subarrays-with-fixed-bounds-c-easy-approach-fast-simple",
                "content": "**IF YOU LIKE, PLEASE UPVOTE.\\u2764\\uFE0F\\u2764\\uFE0F**\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n        \\n        int minKIndex=-1;\\n        int maxKIndex=-1;\\n        int culIndex=-1;\\n        long long ans=0;\\n\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]<minK || nums[i]>maxK)\\n            {\\n                 culIndex=i;\\n            }\\n            if(nums[i]==minK)\\n            {\\n                minKIndex=i;\\n            }\\n            if(nums[i]==maxK)\\n            {\\n                maxKIndex=i;\\n            }\\n            long long smaller=min(minKIndex,maxKIndex);\\n            long long temp = 0;\\n            if(smaller-culIndex>=0)\\n            {\\n                temp = smaller-culIndex;\\n            }\\n            ans+=temp;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n        \\n        int minKIndex=-1;\\n        int maxKIndex=-1;\\n        int culIndex=-1;\\n        long long ans=0;\\n\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]<minK || nums[i]>maxK)\\n            {\\n                 culIndex=i;\\n            }\\n            if(nums[i]==minK)\\n            {\\n                minKIndex=i;\\n            }\\n            if(nums[i]==maxK)\\n            {\\n                maxKIndex=i;\\n            }\\n            long long smaller=min(minKIndex,maxKIndex);\\n            long long temp = 0;\\n            if(smaller-culIndex>=0)\\n            {\\n                temp = smaller-culIndex;\\n            }\\n            ans+=temp;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3255809,
                "title": "swift-beats-100-runtime",
                "content": "# Complexity\\n- Time complexity:\\nThe time complexity of this code is O(n), where n is the number of elements in the input array nums. This is because the code iterates through the array once, performing constant time operations for each element.\\n\\n- Space complexity:\\nThe space complexity of this code is O(1), because the amount of memory used by the code does not depend on the size of the input array. The code only uses a constant amount of memory to store a few variables, regardless of the size of nums.\\n\\n# Code\\n```\\nclass Solution {\\n    func countSubarrays(_ nums: [Int], _ minK: Int, _ maxK: Int) -> Int {\\n        var ans: Int = 0\\n        var j = -1\\n        var prevMinKIndex = -1\\n        var prevMaxKIndex = -1\\n        \\n        for i in 0..<nums.count {\\n            if nums[i] < minK || nums[i] > maxK {\\n                j = i\\n            }\\n            if nums[i] == minK {\\n                prevMinKIndex = i\\n            }\\n            if nums[i] == maxK {\\n                prevMaxKIndex = i\\n            }\\n            \\n            ans += Int(max(0, min(prevMinKIndex, prevMaxKIndex) - j))\\n        }\\n        \\n        return Int(ans)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func countSubarrays(_ nums: [Int], _ minK: Int, _ maxK: Int) -> Int {\\n        var ans: Int = 0\\n        var j = -1\\n        var prevMinKIndex = -1\\n        var prevMaxKIndex = -1\\n        \\n        for i in 0..<nums.count {\\n            if nums[i] < minK || nums[i] > maxK {\\n                j = i\\n            }\\n            if nums[i] == minK {\\n                prevMinKIndex = i\\n            }\\n            if nums[i] == maxK {\\n                prevMaxKIndex = i\\n            }\\n            \\n            ans += Int(max(0, min(prevMinKIndex, prevMaxKIndex) - j))\\n        }\\n        \\n        return Int(ans)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3255588,
                "title": "easy-to-understand-code-with-steps",
                "content": "**Initialize a variable ans to 0 and two pointers maxI and minI to -1.**\\n\\n**Traverse the given array nums from left to right.**\\n\\n**If the current element is not in the range of minK and maxK, reset the pointers to -1 and set the start pointer to i+1.**\\n\\n**If the current element is equal to minK, update minI to i.**\\n\\n**If the current element is equal to maxK, update maxI to i.**\\n\\n**For each element, add the maximum of 0 and the minimum of minI and maxI minus start plus 1 to ans.**\\n\\n**Return ans.**\\n```\\nclass Solution {\\n    public long countSubarrays(int[] nums, int minK, int maxK) {\\n      int n=nums.length;\\n      long ans=0;\\n      int maxI=-1;\\n      int minI=-1;\\n      int start=0;\\n      for(int i=0;i<n;i++){\\n          if(nums[i]<minK || nums[i]>maxK){\\n              minI=maxI=-1;\\n              start=i+1;\\n          }\\n          if(nums[i]==minK){\\n              minI=i;\\n          }\\n          if(nums[i]==maxK){\\n              maxI=i;\\n          }\\n          ans=ans+Math.max(0L,Math.min(minI,maxI)-start+1);\\n      }\\n      return ans;\\n    }\\n}\\n```\\n# Upvoting is Much Appreciated",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long countSubarrays(int[] nums, int minK, int maxK) {\\n      int n=nums.length;\\n      long ans=0;\\n      int maxI=-1;\\n      int minI=-1;\\n      int start=0;\\n      for(int i=0;i<n;i++){\\n          if(nums[i]<minK || nums[i]>maxK){\\n              minI=maxI=-1;\\n              start=i+1;\\n          }\\n          if(nums[i]==minK){\\n              minI=i;\\n          }\\n          if(nums[i]==maxK){\\n              maxI=i;\\n          }\\n          ans=ans+Math.max(0L,Math.min(minI,maxI)-start+1);\\n      }\\n      return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3255319,
                "title": "easy-to-understand-c-solution-using-sliding-window-approach-o-n-o-1",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\npublic class Solution \\n{\\n    public long CountSubarrays(int[] nums, int minK, int maxK)\\n    {\\n        var result = 0L;\\n        var currentMinIndex = -1;\\n        var currentMaxIndex = -1;\\n        var startIndex = 0;\\n\\n        for (var i = 0; i < nums.Length; i++)\\n        {\\n            if (nums[i] >= minK && nums[i] <= maxK)\\n            {\\n                currentMinIndex = nums[i] == minK ? i : currentMinIndex;\\n                currentMaxIndex = nums[i] == maxK ? i : currentMaxIndex;\\n                result += Math.Max(0, Math.Min(currentMinIndex, currentMaxIndex) - startIndex + 1);\\n            }\\n            else\\n            {\\n                currentMinIndex = -1;\\n                currentMaxIndex = -1;\\n                startIndex = i + 1;\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```\\n\\n![pleaseupvote.jpg](https://assets.leetcode.com/users/images/782f0dd5-32a8-4b6a-bd72-43a426ca4a1a_1677927655.6856098.jpeg)\\n",
                "solutionTags": [
                    "C#",
                    "Array",
                    "Sliding Window"
                ],
                "code": "```\\npublic class Solution \\n{\\n    public long CountSubarrays(int[] nums, int minK, int maxK)\\n    {\\n        var result = 0L;\\n        var currentMinIndex = -1;\\n        var currentMaxIndex = -1;\\n        var startIndex = 0;\\n\\n        for (var i = 0; i < nums.Length; i++)\\n        {\\n            if (nums[i] >= minK && nums[i] <= maxK)\\n            {\\n                currentMinIndex = nums[i] == minK ? i : currentMinIndex;\\n                currentMaxIndex = nums[i] == maxK ? i : currentMaxIndex;\\n                result += Math.Max(0, Math.Min(currentMinIndex, currentMaxIndex) - startIndex + 1);\\n            }\\n            else\\n            {\\n                currentMinIndex = -1;\\n                currentMaxIndex = -1;\\n                startIndex = i + 1;\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3254227,
                "title": "detailed-explanation-for-easy-understanding-o-n",
                "content": "# Hi! Let\\'s Learn\\n\\nPrerequisites for this problem:\\nQ -> What is the total number of subarrays between index ```start``` and index ```i``` that end at ```i```?\\nA ->  ```i-start+1```\\n\\nExample : ```a = [1,2,3,4,5,6] ``` and ```start = 1``` and  ```i = 4``` then all subarrays ending at ```i``` are ``[2,3,4,5]``,``[3,4,5]``,``[4,5]``,``[5]`` . Therefore, total would be 4  which is equal to ```i-start+1``` \\n\\n\\n## Intuition and Approach\\n\\nCounting subarrays based on a condition is a common question.  How we do this is -- \\n\\n***Valid sub-array is a sub-array that has at-least one minK and one maxK.***\\n\\nAs we scan through the array, at each index ``i`` there can be a total ```i-start+1``` subarrays that end at ```i```. Out of this number we need to subtract the total number of invalid subarrays ending at ```i```.\\n[start is 0 initially, but it changes when we encounter an out of range element]\\n\\nTotal number of invalid subarrays ending at ``i`` is equal to ```i-P+1```  where ``P`` is the position *just after* least of latest seen occurence of minK or maxK.\\ni.e., ```P = min(lastMin,lastMax)+1``` where ``lastMin`` is the latest occurence of ``minK`` and ``lastMax`` is the latest occurence of ``maxK``.\\n\\nTherefore it is obvious, that we\\'ll have to maintain the lastMin, lastMax variables.\\nOne last thing is, that if we encounter an element that is out of range completely, then the subarray resets. \\n```\\nif(a[i] is out of range) then {\\n\\tstart = i+1;\\n\\tlastMin = i;\\n\\tlastMax = i;\\n}\\n```\\n\\n\\n**Why?**\\nBecause the least of latest occurence of maxK or minK denotes the leftbound of the last valid window .\\n``[1,2,3,4,5] if minK = 1 and maxK= 5``\\nthen at`` i=4``, total subarrays ending at ``i`` are ``[5],[4,5],[3,4,5],[2,3,4,5],[1,2,3,4,5]``. But out of these 4 are invalid =>`` [5],[4,5],[3,4,5],[2,3,4,5]`` because these don\\'t have ``minK``.\\nThe latest occurence of ``minK`` was at index 0, so all subarrays that end at ``i`` but start after index 0 are invalid.\\n``[1,2,3,4,5,4,3,1]``\\nthen at ``i=7``, total subarrays total 8 subarrays end at ``i``. But out of these 3 are invalid => ``[4,3,1],[3,1],[1]`` because these don\\'t have`` maxK``.\\nThe latest occurence of ``maxK`` was at index 4, so all subarrays that end at ``i`` but start after index 4 are invalid.\\n```\\n\\na = [1,3,5,2,7,5], minK = 1, maxK = 5\\nintially,\\nstart = 0\\nlastMin = -1\\nlastMax = -1\\ncount = 0\\n\\niteration i=0:\\na[i] is minK, so lastMin = i\\ntotal subarrays at i=0 are i-start+1 = 1\\ninvalid subarrys at i=0 are [i-(min(lastMin,lastMax)+1)+1] = 1 \\ncount += (1-1) i.e., total-invalid\\n```\\ncount is 0 | start is 0 | lastMin = 0 | lastMax = -1\\n```\\niteration i=1:\\ntotal subarrays at i=1 are i-start+1 = 2\\ninvalid subarrys at i=1 are [i-(min(lastMin,lastMax)+1)+1] = 2 \\ncount += (2-2)\\n```\\ncount is 0 | start is 0 | lastMin = 0 | lastMax = -1\\n```\\niteration i=2:\\na[i] is maxK, so lastMax = i\\ntotal subarrays at i=2 are i-start+1 = 3\\ninvalid subarrys at i=2 are [i-(min(lastMin,lastMax)+1)+1] = 2 \\ncount += (3-2)\\n```\\ncount is 1 | start is 0 | lastMin = 0 | lastMax = 2\\n```\\niteration i=3:\\ntotal subarrays at i=3 are i-start+1 = 4\\ninvalid subarrys at i=3 are [i-(min(lastMin,lastMax)+1)+1] = 3 \\ncount += (4-3)\\n```\\ncount is 2 | start is 0 | lastMin = 0 | lastMax = 2 \\n```\\niteration i=4:\\na[i] is out of range.\\nstart is i+1 = 5\\nlastMin = i = 5\\nlastMax = i = 5\\n```\\ncount is 2 | start is 5 | lastMin = 5 | lastMax = 5 \\n```\\niteration i=5:\\ntotal subarrays at i=5 are i-start+1 = 1\\ninvalid subarrys at i=5 are [i-(min(lastMin,lastMax)+1)+1] = 1 \\ncount += (1-1)\\n```\\ncount is 2 | start is 5 | lastMin = 5 | lastMax = 5 \\n\\n## Complexity\\nLinear time and constant space as we only maintain variables and only traverse the array once.\\n\\n## Code\\n\\n```javascript []\\nconst countSubarrays = function (nums, minK, maxK) {\\n    let lastMin=-1;\\n    let lastMax=-1;\\n    let start=0;\\n    let count=0;\\n    for(let i=0; i<nums.length; i++){\\n        if(nums[i]<minK || nums[i]>maxK){\\n            start = i+1;\\n            lastMin = i;\\n            lastMax = i;\\n            continue;\\n        }\\n        if(nums[i] == minK){\\n            lastMin = i;\\n        }\\n        if(nums[i] == maxK){\\n            lastMax = i;\\n        }\\n        valid = (i-start+1);\\n        invalid = i - (Math.min(lastMin, lastMax) + 1) + 1;\\n        count+= valid - invalid;\\n        console.log(start,valid,invalid,count);\\n      }\\n    return count;\\n};\\n```\\n```C++ []\\nlong long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n    int lastMin=-1;\\n    int lastMax=-1;\\n    int start=0;\\n    long long count=0;\\n    for(int i=0; i<nums.size(); i++){\\n        if(nums[i]<minK || nums[i]>maxK){\\n            start = i+1;\\n            lastMin = i;\\n            lastMax = i;\\n            continue;\\n        }\\n        if(nums[i] == minK){\\n            lastMin = i;\\n        }\\n        if(nums[i] == maxK){\\n            lastMax = i;\\n        }\\n        int valid = (i-start+1);\\n        int invalid = i - (min(lastMin, lastMax) + 1) + 1;\\n        count+= valid - invalid;\\n      }\\n    return count;    \\n }\\n\\n```\\n```Java []\\npublic long countSubarrays(int[] nums, int minK, int maxK) {\\n    int lastMin=-1;\\n    int lastMax=-1;\\n    int start=0;\\n    long count=0;\\n    for(int i=0; i<nums.length; i++){\\n        if(nums[i]<minK || nums[i]>maxK){\\n            start = i+1;\\n            lastMin = i;\\n            lastMax = i;\\n            continue;\\n        }\\n        if(nums[i] == minK){\\n            lastMin = i;\\n        }\\n        if(nums[i] == maxK){\\n            lastMax = i;\\n        }\\n        int valid = (i-start+1);\\n        int invalid = i - (Math.min(lastMin, lastMax) + 1) + 1;\\n        count+= valid - invalid;\\n      }\\n    return count;   \\n    }\\n```\\n\\n\\n\\nUpVote if this helped you. \\nLet\\'s  connect -> [LinkedIn](https://www.linkedin.com/in/dewesh-jha/)\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript",
                    "Array"
                ],
                "code": "```start```\n```i```\n```i```\n```i-start+1```\n```a = [1,2,3,4,5,6] ```\n```start = 1```\n```i = 4```\n```i```\n```i-start+1```\n```i-start+1```\n```i```\n```i```\n```i-P+1```\n```P = min(lastMin,lastMax)+1```\n```\\nif(a[i] is out of range) then {\\n\\tstart = i+1;\\n\\tlastMin = i;\\n\\tlastMax = i;\\n}\\n```\n```\\n\\na = [1,3,5,2,7,5], minK = 1, maxK = 5\\nintially,\\nstart = 0\\nlastMin = -1\\nlastMax = -1\\ncount = 0\\n\\niteration i=0:\\na[i] is minK, so lastMin = i\\ntotal subarrays at i=0 are i-start+1 = 1\\ninvalid subarrys at i=0 are [i-(min(lastMin,lastMax)+1)+1] = 1 \\ncount += (1-1) i.e., total-invalid\\n```\n```\\niteration i=1:\\ntotal subarrays at i=1 are i-start+1 = 2\\ninvalid subarrys at i=1 are [i-(min(lastMin,lastMax)+1)+1] = 2 \\ncount += (2-2)\\n```\n```\\niteration i=2:\\na[i] is maxK, so lastMax = i\\ntotal subarrays at i=2 are i-start+1 = 3\\ninvalid subarrys at i=2 are [i-(min(lastMin,lastMax)+1)+1] = 2 \\ncount += (3-2)\\n```\n```\\niteration i=3:\\ntotal subarrays at i=3 are i-start+1 = 4\\ninvalid subarrys at i=3 are [i-(min(lastMin,lastMax)+1)+1] = 3 \\ncount += (4-3)\\n```\n```\\niteration i=4:\\na[i] is out of range.\\nstart is i+1 = 5\\nlastMin = i = 5\\nlastMax = i = 5\\n```\n```\\niteration i=5:\\ntotal subarrays at i=5 are i-start+1 = 1\\ninvalid subarrys at i=5 are [i-(min(lastMin,lastMax)+1)+1] = 1 \\ncount += (1-1)\\n```\n```javascript []\\nconst countSubarrays = function (nums, minK, maxK) {\\n    let lastMin=-1;\\n    let lastMax=-1;\\n    let start=0;\\n    let count=0;\\n    for(let i=0; i<nums.length; i++){\\n        if(nums[i]<minK || nums[i]>maxK){\\n            start = i+1;\\n            lastMin = i;\\n            lastMax = i;\\n            continue;\\n        }\\n        if(nums[i] == minK){\\n            lastMin = i;\\n        }\\n        if(nums[i] == maxK){\\n            lastMax = i;\\n        }\\n        valid = (i-start+1);\\n        invalid = i - (Math.min(lastMin, lastMax) + 1) + 1;\\n        count+= valid - invalid;\\n        console.log(start,valid,invalid,count);\\n      }\\n    return count;\\n};\\n```\n```C++ []\\nlong long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n    int lastMin=-1;\\n    int lastMax=-1;\\n    int start=0;\\n    long long count=0;\\n    for(int i=0; i<nums.size(); i++){\\n        if(nums[i]<minK || nums[i]>maxK){\\n            start = i+1;\\n            lastMin = i;\\n            lastMax = i;\\n            continue;\\n        }\\n        if(nums[i] == minK){\\n            lastMin = i;\\n        }\\n        if(nums[i] == maxK){\\n            lastMax = i;\\n        }\\n        int valid = (i-start+1);\\n        int invalid = i - (min(lastMin, lastMax) + 1) + 1;\\n        count+= valid - invalid;\\n      }\\n    return count;    \\n }\\n\\n```\n```Java []\\npublic long countSubarrays(int[] nums, int minK, int maxK) {\\n    int lastMin=-1;\\n    int lastMax=-1;\\n    int start=0;\\n    long count=0;\\n    for(int i=0; i<nums.length; i++){\\n        if(nums[i]<minK || nums[i]>maxK){\\n            start = i+1;\\n            lastMin = i;\\n            lastMax = i;\\n            continue;\\n        }\\n        if(nums[i] == minK){\\n            lastMin = i;\\n        }\\n        if(nums[i] == maxK){\\n            lastMax = i;\\n        }\\n        int valid = (i-start+1);\\n        int invalid = i - (Math.min(lastMin, lastMax) + 1) + 1;\\n        count+= valid - invalid;\\n      }\\n    return count;   \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2711551,
                "title": "python-solution",
                "content": "This is inspired by  [this](https://leetcode.com/problems/count-subarrays-with-fixed-bounds/discuss/2708099/JavaC%2B%2BPython-Sliding-Window-with-Explanation) and [this](https://leetcode.com/problems/count-subarrays-with-fixed-bounds/discuss/2707997/Python-Two-Pointer-O(n)-time-and-O(1)-space) , those two are true experts :)\\n\\n![image](https://assets.leetcode.com/users/images/752ce915-0799-4030-b5a4-5b36d494177f_1665949790.505257.png)\\n\\nFrom the diagram above, we need to know the closetest bad point, min and max. We can have one pass to go through all the elements to figure those out then calculate the possible subarrays that meet the min and max bound condition.\\n\\n```\\n\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], minK: int, maxK: int) -> int:\\n                \\n        bad_point_temp = left_min_temp = left_max_temp = -1\\n        \\n        has_min = has_max = False\\n        \\n        sub_arr_cnt = 0\\n        \\n        for ix, num in enumerate(nums):\\n            \\n            if num > maxK or num < minK:\\n                bad_point_temp = ix\\n                has_min = False\\n                has_max = False\\n\\n            if num == minK:\\n                left_min_temp = ix\\n                has_min = True\\n            \\n            if num == maxK:\\n                left_max_temp = ix\\n                has_max = True\\n            \\n            if has_min and has_max:\\n            \\n                sub_arr_cnt += min(left_min_temp, left_max_temp) - bad_point_temp\\n        \\n        return sub_arr_cnt\\n        \\n\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], minK: int, maxK: int) -> int:\\n                \\n        bad_point_temp = left_min_temp = left_max_temp = -1\\n        \\n        has_min = has_max = False\\n        \\n        sub_arr_cnt = 0\\n        \\n        for ix, num in enumerate(nums):\\n            \\n            if num > maxK or num < minK:\\n                bad_point_temp = ix\\n                has_min = False\\n                has_max = False\\n\\n            if num == minK:\\n                left_min_temp = ix\\n                has_min = True\\n            \\n            if num == maxK:\\n                left_max_temp = ix\\n                has_max = True\\n            \\n            if has_min and has_max:\\n            \\n                sub_arr_cnt += min(left_min_temp, left_max_temp) - bad_point_temp\\n        \\n        return sub_arr_cnt\\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2709844,
                "title": "java-python-detailed-explanation-with-diagram",
                "content": "### Approach 1: Brute Force (TLE)\\n\\nCheck all possible subarrays and keep track of current minimum ``mi`` and maximum ``ma``. If either ``mi < minK`` or ``ma > maxK``, then we stop checking subarrays starting with index ``i`` and move on to index ``i + 1``. Once we find a subarray with ``mi = minK`` and ``ma = maxK``, then increment the result by 1.\\n```\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], minK: int, maxK: int) -> int:\\n        result = 0\\n        n = len(nums)\\n        for i in range(n):\\n            mi = ma = nums[i]\\n            for j in range(i, n):\\n                mi = min(mi, nums[j])\\n                ma = max(ma, nums[j])\\n                if mi < minK or ma > maxK:\\n                    break\\n                if mi == minK and ma == maxK:\\n                    result += 1\\n        return result\\n```\\n**Complexity Analysis**\\nNote: ``N`` is the length of the input array ``nums``.\\n* Time Compleixty: ``O(N^2)`` since we use nested for loops to check all possible subarrays.\\n* Space Complexity: ``O(1)``. No extra space is used.\\n\\n---\\n\\n### Approach 2: Two Pointers\\n**Observation**\\n\\nSuppose ``nums = [10,1,3,5,2,7,1,3,5,10,1,3], minK = 1, maxK = 5``.\\n\\n![image](https://assets.leetcode.com/users/images/ccba3069-c610-49f2-aaa7-5f345bef414c_1665908301.2791028.png)\\n\\nObviously, numbers colored by gray are not between ``minK = 1`` and ``maxK = 5``. They won\\'t be included in any fixed-bound subarrays. So, we only need to consider subarrays colored by yellow.\\n\\nHow to find subarrays colored by yellow? We can use **two pointers**: one is ``left`` and the other is ``right`` and **expand ``right`` one by one until we encounter a number that is not in the range ``[minK, maxK]``**.\\n\\nOK, now, we know the way getting subarrays colored by yellow. But how to count how many fixed-bound subarrays exist in a subarray colored by yellow?\\n\\nFor a better explanation, let\\'s take ``nums = [1, 3, 5, 1], minK = 1, maxK = 5`` for example.\\n\\nFirst, let\\'s see subarrays ending at index ``i = 3``.\\n\\n![image](https://assets.leetcode.com/users/images/dd1b5386-e39c-4637-a73a-6e19b167b19d_1665917101.629008.png)\\n\\nDo you find why the first 3 subarrays are fix-bound but the last one isn\\'t? Because it doesn\\'t include number ``5``.\\n\\nTo form a fix-bound subarray, it must include at least one ``minK`` and one ``maxK``. For the above ``nums``, the last ``minK = 1`` is at ``index = 3``, say ``lastMin``, and the last ``maxK = 5`` is at ``index = 2``, say ``lastMax``. So, to include both ``minK`` and ``maxK``, the largest starting index is exactly ``index = 2``, which is the minimum of ``lastMin`` and ``lastMax``. With ``index = 2``, we can easily **count the number of fix-bound subarrays ending at ``index = 3`` by calculating ``min(lastMin, lastMax) - st + 1``**.\\n\\n**Algorithm**\\n\\n1. Split ``nums`` into multiple subarrays by those numbers that are not between ``minK`` and ``maxK``.\\n2. Solve each subarrays ``nums[st...end]`` in step1 independently and sum all of them.\\n\\t(1) Keep track of the last occurrence of ``minK``, say ``lastMin``, and ``maxK``, say ``lastMax``, respectively.\\n\\t(2) Count number of fix-bound subarrays ending at each index by calculating ``min(lastMin, lastMax) - st + 1``\\n\\t\\n**Implementation**\\n<iframe src=\"https://leetcode.com/playground/A4Fpq84L/shared\" frameBorder=\"0\" width=\"800\" height=\"600\"></iframe>\\n\\n**Complexity Analysis**\\nNote: ``N`` is the length of the input array ``nums``.\\n* Time Compleixty: ``O(N)``. In ``countSubarrays``, we compare each element in ``nums`` with ``minK`` and ``maxK`` once. In ``helper``, we also do the comparison for all elements in ``nums`` once. So the elements in ``nums`` are processed twice.\\n* Space Complexity: ``O(1)``. No extra space is used.",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], minK: int, maxK: int) -> int:\\n        result = 0\\n        n = len(nums)\\n        for i in range(n):\\n            mi = ma = nums[i]\\n            for j in range(i, n):\\n                mi = min(mi, nums[j])\\n                ma = max(ma, nums[j])\\n                if mi < minK or ma > maxK:\\n                    break\\n                if mi == minK and ma == maxK:\\n                    result += 1\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2708344,
                "title": "sliding-window-with-explanation-o-n-time",
                "content": "```\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], minK: int, maxK: int) -> int:\\n        i =  0 # left index\\n        j = 0  # right index\\n        ans = 0\\n        \\n        minn = [] # store the indices of minK in a window which have no element less than minK and greater than maxK \\n        maxx = [] # store the indices of maxK in a window which have no element less than minK and greater than maxK\\n        \\n        while j<len(nums):\\n            if nums[j]==minK:\\n                minn.append(j)\\n            if nums[j]==maxK:\\n                maxx.append(j)\\n\\n            if nums[j]<minK or nums[j]>maxK: # conflict\\n                a,b = 0,0 # indices of minn and maxx array\\n                while a<len(minn) and b<len(maxx):\\n                    m = max(minn[a],maxx[b])  # max index which should keep in subbarray necessarily\\n                    ans+=j-m                  # add how many subarray can create such that they start from nums[i]\\n                    if nums[i]==minK:\\n                        a+=1\\n                    if nums[i]==maxK:\\n                        b+=1\\n                    i+=1 \\n                # there is a conflict on indix j so clear minn and maxx array    \\n                minn.clear()\\n                maxx.clear()\\n                \\n                i = j+1 # set left pointer to j+1 (searching for new window which can start from j+1)\\n                \\n            j+=1        \\n                \\n        # after reaching j on last indix check if there is a window which is already created       \\n        a,b = 0,0\\n        while a<len(minn) and b<len(maxx):\\n            m = max(minn[a],maxx[b])\\n            ans+=j-m\\n\\n            if nums[i]==minK:\\n                a+=1\\n            if nums[i]==maxK:\\n                b+=1\\n             \\n            i+=1        \\n                        \\n        return ans\\n\\t",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], minK: int, maxK: int) -> int:\\n        i =  0 # left index\\n        j = 0  # right index\\n        ans = 0\\n        \\n        minn = [] # store the indices of minK in a window which have no element less than minK and greater than maxK \\n        maxx = [] # store the indices of maxK in a window which have no element less than minK and greater than maxK\\n        \\n        while j<len(nums):\\n            if nums[j]==minK:\\n                minn.append(j)\\n            if nums[j]==maxK:\\n                maxx.append(j)\\n\\n            if nums[j]<minK or nums[j]>maxK: # conflict\\n                a,b = 0,0 # indices of minn and maxx array\\n                while a<len(minn) and b<len(maxx):\\n                    m = max(minn[a],maxx[b])  # max index which should keep in subbarray necessarily\\n                    ans+=j-m                  # add how many subarray can create such that they start from nums[i]\\n                    if nums[i]==minK:\\n                        a+=1\\n                    if nums[i]==maxK:\\n                        b+=1\\n                    i+=1 \\n                # there is a conflict on indix j so clear minn and maxx array    \\n                minn.clear()\\n                maxx.clear()\\n                \\n                i = j+1 # set left pointer to j+1 (searching for new window which can start from j+1)\\n                \\n            j+=1        \\n                \\n        # after reaching j on last indix check if there is a window which is already created       \\n        a,b = 0,0\\n        while a<len(minn) and b<len(maxx):\\n            m = max(minn[a],maxx[b])\\n            ans+=j-m\\n\\n            if nums[i]==minK:\\n                a+=1\\n            if nums[i]==maxK:\\n                b+=1\\n             \\n            i+=1        \\n                        \\n        return ans\\n\\t",
                "codeTag": "Java"
            },
            {
                "id": 2708301,
                "title": "c-sliding-window",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n        int n=nums.size(), low=-1, high=-1, l=0;\\n        long long count = 0;\\n        \\n        for(int i=0; i<n; i++) {\\n            if(nums[i]>=minK and nums[i]<=maxK) {\\n                if(nums[i] == minK) low = i;\\n                if(nums[i] == maxK) high = i;\\n                \\n                if(low!=-1 and high!=-1) count += min(low, high) - l + 1;\\n            }\\n            else {\\n                l = i+1;\\n                low = -1;\\n                high = -1;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n        int n=nums.size(), low=-1, high=-1, l=0;\\n        long long count = 0;\\n        \\n        for(int i=0; i<n; i++) {\\n            if(nums[i]>=minK and nums[i]<=maxK) {\\n                if(nums[i] == minK) low = i;\\n                if(nums[i] == maxK) high = i;\\n                \\n                if(low!=-1 and high!=-1) count += min(low, high) - l + 1;\\n            }\\n            else {\\n                l = i+1;\\n                low = -1;\\n                high = -1;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2708230,
                "title": "video-explanation-with-intuitions",
                "content": "https://www.youtube.com/watch?v=aepocGE6WPc",
                "solutionTags": [
                    "Suffix Array"
                ],
                "code": "https://www.youtube.com/watch?v=aepocGE6WPc",
                "codeTag": "Unknown"
            },
            {
                "id": 2708185,
                "title": "python-sliding-window-o-n-time-o-1-space-explained",
                "content": "```\\ndef countSubarrays(self, nums: List[int], minK: int, maxK: int) -> int:\\n\\tans = 0\\n\\tr = 0 # right of window\\n\\tl = 0 # left of window\\n\\tn = len(nums)\\n\\trecentMin = -1 # most recent instance of the max\\n\\trecentMax = -1 # most recent instance of the min\\n\\twhile r < n:\\n\\t\\twhile r<n: # sliding to the right\\n\\t\\t\\tnum = nums[r]\\n\\t\\t\\tif not minK<=num<=maxK: # if this number is too big or small we can no longer use this window\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t# now update the recent min and max if needed\\n\\t\\t\\tif num == minK:\\n\\t\\t\\t\\trecentMin = r\\n\\t\\t\\tif num == maxK:\\n\\t\\t\\t\\trecentMax = r\\n\\t\\t\\tr += 1\\n\\t\\t\\tif recentMin != -1 and recentMax != -1:\\n\\t\\t\\t\\tans += (min(recentMin,recentMax)-l)+1 # we can make as many new subarrays as the earliest occurrence of recentMin or recentMax minus the starting position of our window\\n\\t\\t# reset everything\\n\\t\\tr+=1\\n\\t\\tl = r\\n\\t\\trecentMin = -1\\n\\t\\trecentMax = -1\\n\\treturn ans\\n```\\n\\nThe toughest part of coming to this answer was figuring out what to add to ```ans```. I realized that we need to add ```(min(recentMin,recentMax)-l)+1``` by thinking of all the new subarrays we could create when we come across a new element. When we add a new element to our subarray (increase ```r``` by one), then we add as many new unique subarrays as we can create by moving ```l``` forward. We can only move ```l``` forward as longas ```recentMin``` and ```recentMax``` are within our sliding window ```[l,r]``` so we can create ```(min(recentMin,recentMax)-l)+1``` new subarrays!\\n",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "```\\ndef countSubarrays(self, nums: List[int], minK: int, maxK: int) -> int:\\n\\tans = 0\\n\\tr = 0 # right of window\\n\\tl = 0 # left of window\\n\\tn = len(nums)\\n\\trecentMin = -1 # most recent instance of the max\\n\\trecentMax = -1 # most recent instance of the min\\n\\twhile r < n:\\n\\t\\twhile r<n: # sliding to the right\\n\\t\\t\\tnum = nums[r]\\n\\t\\t\\tif not minK<=num<=maxK: # if this number is too big or small we can no longer use this window\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t# now update the recent min and max if needed\\n\\t\\t\\tif num == minK:\\n\\t\\t\\t\\trecentMin = r\\n\\t\\t\\tif num == maxK:\\n\\t\\t\\t\\trecentMax = r\\n\\t\\t\\tr += 1\\n\\t\\t\\tif recentMin != -1 and recentMax != -1:\\n\\t\\t\\t\\tans += (min(recentMin,recentMax)-l)+1 # we can make as many new subarrays as the earliest occurrence of recentMin or recentMax minus the starting position of our window\\n\\t\\t# reset everything\\n\\t\\tr+=1\\n\\t\\tl = r\\n\\t\\trecentMin = -1\\n\\t\\trecentMax = -1\\n\\treturn ans\\n```\n```ans```\n```(min(recentMin,recentMax)-l)+1```\n```r```\n```l```\n```l```\n```recentMin```\n```recentMax```\n```[l,r]```\n```(min(recentMin,recentMax)-l)+1```",
                "codeTag": "Python3"
            },
            {
                "id": 2708011,
                "title": "c-in-depth-explanation-intuition",
                "content": "# Solution/Intuition\\n\\n## Finding Segments\\n\\nFirst, lets make some observations about good (what we will call \"fixed-bounded\" arrays) subarrays:\\n-They must contain minK and maxK **at least once**\\n-No elements can lie outside of the range **$$[minK, maxK]$$**\\n\\n\\nThe second observation allows us to split the array into portions we can more easily calculate the sums with: Say that any element lies outside of the good range. Obviously, that element cannot be in any good subarray we will count towards the answer. Therefore, we may assume that there exists no good subarray from a[l] to a[r] such that l < i < r; **any good subarray will lie either completely to the left of or completely to the right of a bad element** (outside of the range $$[minK, maxK]$$). \\n\\nWe will calculate the answer between each pair of adjacent bad elements separately, and increment our final answer. (For the sake of our implemntation, assume the indexies -1 and n (0 based) are bad). \\n\\n## Computing For Each Segment\\n\\nFor each segment, we know that all elements lie between [minK, maxK]. Notice the positioning of maxK, minK in any subarray of a subsegment does not matter: \\n\\n[1, 2, 3], [3, 1, 1, 1, 1, 2], [2, 2, 2, 2, 2, 2, 2, 3, 1], [2, 1, 3, 2]. \\n(when minK = 1, maxK = 3, all the above subarrays are good)\\n\\nTherefore, to calculate the number of good subarrays in a segment, we simply need to fix the rightmost index (we will call j) in the subarray, and calculate for how many indexes (i) to the left such that the subarray is good. (Can be the opposite too)\\n\\nConveniently, we notice that **if the subarray starting from l ending at r is good, the subarray starting from l-1 is also good (as long as it lies within the segment)**. This works going rightwards too, but we have fixed r in order to avoid overcounting. All we have to do now is find the lastmost l such that the subarray from l to r is good, and increment the answer by (l - SegmentLeftbound + 1). \\n\\nNow, all we require for a subarray to be good is for it to contain minK and maxK. We can simply store the positions of their occurances, and find the greatest position of both minK and maxK such that it is not greater than r. The minimum of their positions marks the maximum l such that a[l:r] is a good subarray. We will use binary search to find their positions in O($$logN$$). \\n\\nSee code for implementation along with some things you should be careful with. \\n\\n---\\nThere is a more efficient (and possibly more elegant?) O($$N$$) solution using 2 pointers, so try it out if you want a challenge!\\n\\nBut our O($$NlogN$$) binary search for each index passes the time constraints perfectly, and avoids any tedious casework. \\n\\n\\n# Complexity\\nO($$NlogN$$) - O($$N$$) for each element, logN for binary searching at each index \\n\\n# Implementation \\n```cpp\\ntypedef long long ll; \\n\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& a, int lk, int rk) {\\n        ll n = a.size(); \\n        ll ans = 0;\\n\\n        //find position of bad indicies \\n        vector<int> bads(1, -1); \\n\\n        for (int i = 0; i < n; ++i) {\\n            p[i+1] += p[i];\\n            if (lk > a[i] || rk < a[i]) {\\n                p[i]++; \\n                bads.push_back(i);\\n            }\\n        }\\n        bads.push_back(n); \\n        \\n\\n        for (int i = 0; i < bads.size()-1; ++i) {\\n            //the subarray from l to r is good. \\n            //interestingly, l > r may occur, but the following loop \\n            //will not run, and therefore we will continue\\n            int l = bads[i]+1, r = bads[i+1]-1; \\n            \\n            //stores the positions of minK and maxK\\n            vector<int> mns, mxs; \\n\\n            for (int j = l; j <= r; ++j) {\\n                if (a[j] == lk) {\\n                    mns.push_back(j); \\n                } if (a[j] == rk) {\\n                    mxs.push_back(j); \\n                }\\n            }\\n            \\n            //if minK or maxK does not exist, we can continue to the next segment\\n            if (min(mns.size(), mxs.size()) == 0) continue; \\n            \\n            for (int j = l; j <= r; ++j) {\\n                //if the minimum index does not lie before j we may continue\\n                if (mns[0] > j || mxs[0] > j) continue; \\n\\n                //lowest index to go to \\n                int low = 1e9; \\n                \\n                //find last minK using binary search\\n                int lo = 0, hi = mns.size()-1; \\n                while (lo < hi) {\\n                    int mid = lo + (hi - lo + 1)/2;\\n                    if (mns[mid] <= j) lo = mid;\\n                    else hi = mid - 1; \\n                }\\n                low = min(low, mns[lo]); \\n\\n                //find last maxK using binary search\\n                lo = 0; hi = mxs.size()-1; \\n                while (lo < hi) {\\n                    int mid = lo + (hi - lo + 1)/2;\\n                    if (mxs[mid] <= j) lo = mid;\\n                    else hi = mid - 1; \\n                }\\n                low = min(low, mxs[lo]); \\n\\n                //increment the answer by the number of unfixed left positions \\n                ans += (low - l + 1); \\n            }\\n        }\\n        \\n        \\n        \\n        return ans; \\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```cpp\\ntypedef long long ll; \\n\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& a, int lk, int rk) {\\n        ll n = a.size(); \\n        ll ans = 0;\\n\\n        //find position of bad indicies \\n        vector<int> bads(1, -1); \\n\\n        for (int i = 0; i < n; ++i) {\\n            p[i+1] += p[i];\\n            if (lk > a[i] || rk < a[i]) {\\n                p[i]++; \\n                bads.push_back(i);\\n            }\\n        }\\n        bads.push_back(n); \\n        \\n\\n        for (int i = 0; i < bads.size()-1; ++i) {\\n            //the subarray from l to r is good. \\n            //interestingly, l > r may occur, but the following loop \\n            //will not run, and therefore we will continue\\n            int l = bads[i]+1, r = bads[i+1]-1; \\n            \\n            //stores the positions of minK and maxK\\n            vector<int> mns, mxs; \\n\\n            for (int j = l; j <= r; ++j) {\\n                if (a[j] == lk) {\\n                    mns.push_back(j); \\n                } if (a[j] == rk) {\\n                    mxs.push_back(j); \\n                }\\n            }\\n            \\n            //if minK or maxK does not exist, we can continue to the next segment\\n            if (min(mns.size(), mxs.size()) == 0) continue; \\n            \\n            for (int j = l; j <= r; ++j) {\\n                //if the minimum index does not lie before j we may continue\\n                if (mns[0] > j || mxs[0] > j) continue; \\n\\n                //lowest index to go to \\n                int low = 1e9; \\n                \\n                //find last minK using binary search\\n                int lo = 0, hi = mns.size()-1; \\n                while (lo < hi) {\\n                    int mid = lo + (hi - lo + 1)/2;\\n                    if (mns[mid] <= j) lo = mid;\\n                    else hi = mid - 1; \\n                }\\n                low = min(low, mns[lo]); \\n\\n                //find last maxK using binary search\\n                lo = 0; hi = mxs.size()-1; \\n                while (lo < hi) {\\n                    int mid = lo + (hi - lo + 1)/2;\\n                    if (mxs[mid] <= j) lo = mid;\\n                    else hi = mid - 1; \\n                }\\n                low = min(low, mxs[lo]); \\n\\n                //increment the answer by the number of unfixed left positions \\n                ans += (low - l + 1); \\n            }\\n        }\\n        \\n        \\n        \\n        return ans; \\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3261898,
                "title": "detailed-explanation-of-python-o-n-solution",
                "content": "# Intuition\\nWe have to count all subarrays with certain properties. In such problems, a good pattern is to think about what happens when the subarrays end at a certain position. Let\\'s iterate through the array and think about how to calculate the number of appropriate subarrays that end at a current position.\\n\\nnums = [1,3,5,2,7,5], minK = 1, maxK = 5\\n\\nHow many subarrays end at index 0, val - 1? -> 0 (no element equals maxK)\\n\\nHow many subarrays end at index 1, 3? -> 0 (no element equals maxK)\\n\\nHow many subarrays end at index 2, 5? -> 1 (the leftmost border can\\'t be further than the last minK)\\n\\nHow many subarrays end at index 3, 2? -> 1 (the leftmost border can\\'t be further than the last minK)\\n\\nHow many subarrays end at index 4, 7? -> 0 (7 is bigger than maxK)\\n\\nHow many subarrays end at index 5, 5? -> 0 (no element equals minK after the first element that can\\'t be in the subarray (bigger than maxK or smaller than minK))\\nthe answer is the suma of this values = 2\\n\\nIf the right border is fixed (current index inx in iteration) and we know the leftmost possible index of the left border \"llb\" and the rightmost possible left border \"rlb\" then the total number of subarrays that end at the current index is rlb-llb+1. So we can calculate the subarrays that end at all indexes, and the total number of subarrays is just the sum of all of them.\\n\\nThe rest is just figuring out how to calculate the leftmost left possible subarray border (llb) and rightmost left possible subarray border (rlb).\\n\\nFor rlb, it is simple. We always need maxK and minK elements, so let\\'s just take the minimum of their indexes before the current index = min(lastmaxKinx, lastminKinx).\\n\\nThe only restriction for the llb is that it should be after any inappropriate element. When we encounter an element that is greater than maxK or smaller than minK, we can set llb = current index + 1.\\n\\nConsider the input array nums = [1,3,5,2,7,5] and the range constraints minK = 1, maxK = 5. Let\\'s assume the right border is at index 3.\\n\\nIn this case, the leftmost left border(llb) is 1 at index 0 because there are no values between 1 and the right border that violate the constraints.\\n\\nTo calculate the rightmost left border(rlb), we need to find the index of the last minK or maxK element before the current index. In this case, the rightmost left border is also 1 because there is only one minK element and shifting the left border further right would exclude it.\\n\\nTherefore, the leftmost left border (llb) and rightmost left border (rlb) are both 0. The total number of subarrays ending at index 3 can be calculated as rlb-llb+1=0-0+1=1, which is correct.\\n\\n\\n# Approach\\n\\nTo calculate the rlb,  maintain the indices of the last occurrences of the minK and maxK in variables, \"last_minK\" and \"last_maxK\".\\n\\nMaintain left border (llb), the index of the next element AFTER the last element that violates the constraints in variable \"left_most\".\\n\\nIterate through the array and for each position, calculate the number of subarrays that end at that position: rlb-llb+1. \\nSum them up to the variable called \"count\".\\n\\n# Complexity\\n- Time complexity: O(n) - we iterate once through the array and perform a constant amount of work for each element.\\n- Space complexity: O(1) - we only need a few variables to solve this problem.\\n\\n# Code\\n```\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], minK: int, maxK: int) -> int:\\n        count = 0 # total amount\\n        last_minK = None # at initialization we dont have such elements\\n        last_maxK = None # at initialization we don\\'t have such elements\\n        left_most = 0 # we have no elements before wich violates constraints, llb value\\n\\n        for inx, n in enumerate(nums):\\n            if n < minK or n > maxK: # this elements violates constraints\\n                # last_minK and last_maxK cant be included in any window after inx\\n                left_most = inx+1\\n                last_minK = None\\n                last_maxK = None\\n            else:\\n                if n == minK:\\n                    last_minK = inx\\n                if n == maxK:\\n                    last_maxK = inx\\n                # we have both maxK and minK so lets calculate the number of subarrays ended at inx\\n                if last_minK is not None and last_maxK is not None:\\n                    right_most_left_border = min(last_minK, last_maxK)\\n                    count += right_most_left_border-left_most+1\\n\\n\\n        return count\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], minK: int, maxK: int) -> int:\\n        count = 0 # total amount\\n        last_minK = None # at initialization we dont have such elements\\n        last_maxK = None # at initialization we don\\'t have such elements\\n        left_most = 0 # we have no elements before wich violates constraints, llb value\\n\\n        for inx, n in enumerate(nums):\\n            if n < minK or n > maxK: # this elements violates constraints\\n                # last_minK and last_maxK cant be included in any window after inx\\n                left_most = inx+1\\n                last_minK = None\\n                last_maxK = None\\n            else:\\n                if n == minK:\\n                    last_minK = inx\\n                if n == maxK:\\n                    last_maxK = inx\\n                # we have both maxK and minK so lets calculate the number of subarrays ended at inx\\n                if last_minK is not None and last_maxK is not None:\\n                    right_most_left_border = min(last_minK, last_maxK)\\n                    count += right_most_left_border-left_most+1\\n\\n\\n        return count\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3257213,
                "title": "python-short-and-clean-functional-programming",
                "content": "# Approach\\nTLDR; Same as the [Official Solution](https://leetcode.com/problems/count-subarrays-with-fixed-bounds/editorial/).\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\nwhere, `n is the length of nums`.\\n\\n# Code\\n```python\\nclass Solution:\\n    def countSubarrays(self, nums: list[int], minK: int, maxK: int) -> int:\\n        indexes = lambda f: accumulate(range(len(nums)), lambda a, x: x if f(nums[x]) else a, initial=-1)\\n\\n        left_bounds = indexes(lambda num: num < minK or num > maxK)\\n        maxs = indexes(lambda num: num == maxK)\\n        mins = indexes(lambda num: num == minK)\\n\\n        count_fn = lambda lb, mx, mn: max(0, min(mx, mn) - lb)\\n        return sum(map(count_fn, left_bounds, maxs, mins))\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Sliding Window",
                    "Monotonic Queue"
                ],
                "code": "```python\\nclass Solution:\\n    def countSubarrays(self, nums: list[int], minK: int, maxK: int) -> int:\\n        indexes = lambda f: accumulate(range(len(nums)), lambda a, x: x if f(nums[x]) else a, initial=-1)\\n\\n        left_bounds = indexes(lambda num: num < minK or num > maxK)\\n        maxs = indexes(lambda num: num == maxK)\\n        mins = indexes(lambda num: num == minK)\\n\\n        count_fn = lambda lb, mx, mn: max(0, min(mx, mn) - lb)\\n        return sum(map(count_fn, left_bounds, maxs, mins))\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3256543,
                "title": "awesome-logic-beginner-friendy-code-in-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], minK: int, maxK: int) -> int:\\n        ans=0\\n        minindex=-1\\n        maxindex=-1\\n        culprit=-1\\n        for i in range(len(nums)):\\n            if nums[i]<minK or nums[i]>maxK:\\n                culprit=i\\n            if nums[i]==minK:\\n                minindex=i\\n            if nums[i]==maxK:\\n                maxindex=i\\n            \\n            smaller=min(minindex,maxindex)\\n            temp=smaller-culprit\\n            if temp<=0:\\n                ans+=0\\n            else:\\n                ans+=temp\\n        return ans\\n\\n        \\n\\n\\n        \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], minK: int, maxK: int) -> int:\\n        ans=0\\n        minindex=-1\\n        maxindex=-1\\n        culprit=-1\\n        for i in range(len(nums)):\\n            if nums[i]<minK or nums[i]>maxK:\\n                culprit=i\\n            if nums[i]==minK:\\n                minindex=i\\n            if nums[i]==maxK:\\n                maxindex=i\\n            \\n            smaller=min(minindex,maxindex)\\n            temp=smaller-culprit\\n            if temp<=0:\\n                ans+=0\\n            else:\\n                ans+=temp\\n        return ans\\n\\n        \\n\\n\\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3255881,
                "title": "you-will-understand",
                "content": "# Start \\nThe first thing that come in my mind when I saw this problem like brute force. \\n- so what was that ? \\n- okay by just using heap data structure and traverse in O(n^2) with two for loop and add elements one by one \\n- when ever i will get at top or say peek() min heap == minK \\n- and max heap == maxK at peek() i will increase the counter \\n- but i tried inside I know it will gonna give me TLE still i did just to check \\n\\n### And Here is that solution \\uD83D\\uDC47\\n\\n```\\nclass Solution {\\n    public long countSubarrays(int[] nums, int minK, int maxK) {\\n        PriorityQueue<Integer> minP = new PriorityQueue<>();\\n        PriorityQueue<Integer> maxP = new PriorityQueue<>(Collections.reverseOrder());\\n        long cnt = 0;\\n        for(int i=0; i<nums.length; i++){\\n            for(int j=i; j<nums.length; j++){\\n                minP.add(nums[j]);\\n                maxP.add(nums[j]);\\n                if(minP.peek()==minK && maxP.peek()==maxK){\\n                    cnt++;\\n                }\\n            }\\n            minP.clear();\\n            maxP.clear();\\n        }\\n        return cnt;\\n    }\\n}\\n```\\n1. As you can see simple I did two priority queue on is min heap and another one max heap \\n2. traverse in O(n^2) \\n3. checked condition with peek()\\n4. if checked and increment counter \\n5. after inner loop clear that heaps. \\n\\n### Result : TLE \\uD83D\\uDE0A\\n\\n- Then I checked that discussion section there they was talking about two pointer approach and some says three pointer approach I will say it sliding window appraoch beacuse thats what exactly we are doing here. \\n- but why? \\n- look this test case [1,3,5,2,7,5], minK = 1, maxK = 5\\n- here see from 1 to 7 or say before 7 till 2 ony you can form sub groups that 7 is boundary line that says you can\\'t include me. \\n- why i can\\'t include you so he says i will disturb your conditions of mink and maxk \\n- ohh so i got it now what how i gonna form these sub groups \\n- check first the first sub you can form and only sub you can form with ```1,3,5``` now left ```2``` before 7 okay so what \\n- so it mean that you can form 1 to 5 only 1 sub mean whenever you will get mink and maxk that will give you single sub \\n- okay then what and rest of remaing element before boundary here boundary is ```7``` they will just gonna include to form sub group by extra number those presents after 1 to 5 (mink and maxk)\\n- but wait here is a small catch friend \\n- what is it the catch is it if any element before 1 it will give number of element + 1 sub but after 5 it will just double the sub of before + ans every element alright \\n\\n### take conditions of two different test cases \\n\\n- ```1,3,5,2,|7|``` that 7 is you boundary line in this case 1 is present at beg so from 1 to 5 you formed 1 and next is 2 so ans get added by one. each time. \\n- but here take one more case ```3,1,3,5,2,|7|``` very first sub you will get 1 to 5 okay \\n- yup next now you have you minK and maxK so include before elements and if at end also present also include them \\n- see ```ans = ans+Math.max(0L, Math.min(minI, maxI)-start+1);``` this line exactly doing that taking min index and sub from start +1 why +1 because minI can itself start so it will also form one sub \\n- and when we get 2 in next iteration sub get double of it. every next element add double of first answer. or you can say (minI-start)\\n- same goes for other boundaries in that array. \\n### And Here is that solution \\uD83D\\uDC47\\n# Code\\n```\\nclass Solution {\\n    public long countSubarrays(int[] N, int minK, int maxK) {\\n        long ans = 0;\\n        int minI = -1; \\n        int maxI = -1; \\n        int start = 0;\\n        for(int i=0; i<N.length; i++){\\n            if(N[i]<minK || N[i]>maxK){\\n                minI = -1; maxI = -1;\\n                start = i+1;\\n            }\\n            if(N[i]==minK){\\n                minI = i;\\n            }\\n            if(N[i]==maxK){\\n                maxI = i;\\n            }\\n            ans = ans+Math.max(0L, Math.min(minI, maxI)-start+1);\\n        }\\n        return ans;\\n    }\\n}\\n```\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n## For your more understanding:- \\n![image.png](https://assets.leetcode.com/users/images/79fe20c7-de3c-4947-ae3c-714b71ff0ceb_1677940632.843061.png)\\n![image.png](https://assets.leetcode.com/users/images/71e5b3df-bae8-4495-a3b1-7db053e1fd15_1677940660.1250837.png)\\n![image.png](https://assets.leetcode.com/users/images/c11f413a-4244-4f33-9872-f2ebc90bd7c3_1677940682.664254.png)\\n![image.png](https://assets.leetcode.com/users/images/eec4474d-674f-4e3d-ae31-306e178aa665_1677940722.2354624.png)\\n![image.png](https://assets.leetcode.com/users/images/66a862aa-a6aa-46a8-9d1e-389a4b67b37f_1677940745.8228087.png)\\n![image.png](https://assets.leetcode.com/users/images/6238d3b4-0d3d-4e18-aef9-34a78cbb9676_1677940769.8968797.png)\\n![image.png](https://assets.leetcode.com/users/images/40d01b66-dd5f-4948-a75a-fa03713d8abf_1677940790.1193373.png)\\n\\n## Thanks For Visiting My Solution :>\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Sliding Window",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public long countSubarrays(int[] nums, int minK, int maxK) {\\n        PriorityQueue<Integer> minP = new PriorityQueue<>();\\n        PriorityQueue<Integer> maxP = new PriorityQueue<>(Collections.reverseOrder());\\n        long cnt = 0;\\n        for(int i=0; i<nums.length; i++){\\n            for(int j=i; j<nums.length; j++){\\n                minP.add(nums[j]);\\n                maxP.add(nums[j]);\\n                if(minP.peek()==minK && maxP.peek()==maxK){\\n                    cnt++;\\n                }\\n            }\\n            minP.clear();\\n            maxP.clear();\\n        }\\n        return cnt;\\n    }\\n}\\n```\n```1,3,5```\n```2```\n```7```\n```1,3,5,2,|7|```\n```3,1,3,5,2,|7|```\n```ans = ans+Math.max(0L, Math.min(minI, maxI)-start+1);```\n```\\nclass Solution {\\n    public long countSubarrays(int[] N, int minK, int maxK) {\\n        long ans = 0;\\n        int minI = -1; \\n        int maxI = -1; \\n        int start = 0;\\n        for(int i=0; i<N.length; i++){\\n            if(N[i]<minK || N[i]>maxK){\\n                minI = -1; maxI = -1;\\n                start = i+1;\\n            }\\n            if(N[i]==minK){\\n                minI = i;\\n            }\\n            if(N[i]==maxK){\\n                maxI = i;\\n            }\\n            ans = ans+Math.max(0L, Math.min(minI, maxI)-start+1);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3255869,
                "title": "sliding-window-examples-to-understand-the-code",
                "content": "# Intuition\\nWe can only count subarrays which have the numbers $$mink$$ and $$maxK$$ in them somewhere and no numbers are lesser than $$mink$$ or greater than $$maxk$$.\\n\\nLet\\'s first focus on the number of subarrays we can count from : $$1,2,3,4,2,5 $$ for $$minK=1$$ and $$maxK=5$$. The answer, is just $$1$$.Because any subarray of the above array won\\'t contain either $$minK$$ or $$maxK$$ except 1, which is the array itself. If we keep track of the indexes of $$minK$$ and $$maxK$$ , we can start counting subarrays the moment we are sure that <b>both</b> of them are present somewhere in the subarray we are counting.\\n\\n\\n\\n# Approach\\n A brute-force approach would be to find a section of the array which consists of the two numbers, and checking how many subarrays we can have. \\nExample, consider the subarray for ```mink=1``` and ```maxk=5```:\\n\\n# $$[..., 500, 2,4,3,4,1(mark),2,3,4,2,5 (mark),4,2,500,...]$$\\nHow many subarrays can we count from the above subarray according to the constraints in question? \\n**Notice**:\\n4 elements to the left of 1- ```2,4,3,4```\\n2 elements to the right of 5-```4,2```\\n\\nAll of the subarrays will need this subarray in them: $$1,2,3,4,2,5$$ as it\\'s the only section which has both $$minK$$ and $$maxK$$. For simplicity, call this section as $$arr$$.\\nEnumerating every possible subarray from ```2,4,3,4,arr```:\\n```\\n        arr\\n      4,arr\\n    3,4,arr\\n  4,3,4,arr\\n2,4,3,4,arr\\n```\\nIsn\\'t that also equal to the number of elements at the left of $$arr$$+ $$1$$ ?\\nThe result ```arr+1``` is obvious, but of significance for the next part.\\n\\nKeeping track of the *Starting Index* won\\'t be complicated. If we encounter a number less than ```minK``` or greater than ```maxK```, we have to reset start index.\\n\\n\\n# What about the numbers to the right of $$arr$$ ?\\nEnumerating every possible subarray from $$2,4,3,4,arr,4,2$$:\\n```\\n        arr\\n      4,arr\\n    3,4,arr\\n  4,3,4,arr\\n2,4,3,4,arr\\n//as if there was no number to the right\\n        arr,4\\n      4,arr,4\\n    3,4,arr,4\\n  4,3,4,arr,4\\n2,4,3,4,arr,4\\n//4 is appended to each array, or we still get 5 new arrays.\\n        arr,4,2\\n      4,arr,4,2\\n    3,4,arr,4,2\\n  4,3,4,arr,4,2\\n2,4,3,4,arr,4,2\\n//we again got 5 new sub-arrays\\n```\\nOr the solution should be something like:\\n# Count+=(Number of elements to the left of arr+1)\\nEven if we get new elements to the right of $$arr$$, we still just increment the answer by the number of elements to the left of arr+1.\\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ \\n\\n- Space complexity:\\n$$O(1)$$ \\n\\n# Code\\n```\\nclass Solution {\\n    public long countSubarrays(int[] nums, int minK, int maxK) {\\n        long ans =0;\\n        int start=0;\\n        int minI=-1,maxI=-1;\\n        for(int i=0;i<nums.length;i++){\\n            \\n            int x=nums[i];\\n            if(x<minK || x>maxK) {\\n            //just reset every value\\n            //as this is the start of a new section\\n                start=i+1;\\n                minI=-1;maxI=-1;\\n                }\\n            if(x==minK) minI=i;\\n            if(x==maxK) maxI=i;\\n            if( minI!=-1 && maxI!=-1){\\n                ans+=Math.min(maxI,minI)-start+1;\\n    //Math.min(maxI,minI) is just to find out the number\\n    // of elements to the left of arr\\n    //The moment minI and maxI are not equal to -1,\\n    //we can be sure to start counting.\\n            }\\n        }\\n        return ans ;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```mink=1```\n```maxk=5```\n```2,4,3,4```\n```4,2```\n```2,4,3,4,arr```\n```\\n        arr\\n      4,arr\\n    3,4,arr\\n  4,3,4,arr\\n2,4,3,4,arr\\n```\n```arr+1```\n```minK```\n```maxK```\n```\\n        arr\\n      4,arr\\n    3,4,arr\\n  4,3,4,arr\\n2,4,3,4,arr\\n//as if there was no number to the right\\n        arr,4\\n      4,arr,4\\n    3,4,arr,4\\n  4,3,4,arr,4\\n2,4,3,4,arr,4\\n//4 is appended to each array, or we still get 5 new arrays.\\n        arr,4,2\\n      4,arr,4,2\\n    3,4,arr,4,2\\n  4,3,4,arr,4,2\\n2,4,3,4,arr,4,2\\n//we again got 5 new sub-arrays\\n```\n```\\nclass Solution {\\n    public long countSubarrays(int[] nums, int minK, int maxK) {\\n        long ans =0;\\n        int start=0;\\n        int minI=-1,maxI=-1;\\n        for(int i=0;i<nums.length;i++){\\n            \\n            int x=nums[i];\\n            if(x<minK || x>maxK) {\\n            //just reset every value\\n            //as this is the start of a new section\\n                start=i+1;\\n                minI=-1;maxI=-1;\\n                }\\n            if(x==minK) minI=i;\\n            if(x==maxK) maxI=i;\\n            if( minI!=-1 && maxI!=-1){\\n                ans+=Math.min(maxI,minI)-start+1;\\n    //Math.min(maxI,minI) is just to find out the number\\n    // of elements to the left of arr\\n    //The moment minI and maxI are not equal to -1,\\n    //we can be sure to start counting.\\n            }\\n        }\\n        return ans ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3255842,
                "title": "formula-based-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], minK: int, maxK: int) -> int:\\n        count=0\\n        minimum=maximum=nonelement=-1\\n        for ind,val in enumerate(nums):\\n            if val==minK:\\n                minimum=ind\\n            if val==maxK:\\n                maximum=ind\\n            if not minK<=val<=maxK:\\n                nonelement=ind\\n            count+=max(0,min(minimum,maximum)-nonelement)\\n        return count\\n    #please upvote me it would helping me alot\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], minK: int, maxK: int) -> int:\\n        count=0\\n        minimum=maximum=nonelement=-1\\n        for ind,val in enumerate(nums):\\n            if val==minK:\\n                minimum=ind\\n            if val==maxK:\\n                maximum=ind\\n            if not minK<=val<=maxK:\\n                nonelement=ind\\n            count+=max(0,min(minimum,maximum)-nonelement)\\n        return count\\n    #please upvote me it would helping me alot\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3255389,
                "title": "easy-c-2-pointers-approach-sliding-window",
                "content": "# Approach\\nTake 2 pointers and strore the index of minK and maxK each time.\\nCalculate the number of ways of subarrays formed by the start index.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n        long long ans = 0;\\n        int mini = -1;\\n        int maxi = -1;\\n        int s = 0;\\n\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]<minK || nums[i]>maxK){\\n                mini = -1;\\n                maxi = -1;\\n                s = i+1;\\n            }\\n\\n            if(nums[i] == minK){\\n                mini = i;\\n            }\\n\\n            if(nums[i] == maxK){\\n                maxi = i;\\n            }\\n\\n            ans += max(0,min(mini,maxi)-s+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n        long long ans = 0;\\n        int mini = -1;\\n        int maxi = -1;\\n        int s = 0;\\n\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]<minK || nums[i]>maxK){\\n                mini = -1;\\n                maxi = -1;\\n                s = i+1;\\n            }\\n\\n            if(nums[i] == minK){\\n                mini = i;\\n            }\\n\\n            if(nums[i] == maxK){\\n                maxi = i;\\n            }\\n\\n            ans += max(0,min(mini,maxi)-s+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3255386,
                "title": "easy-c-solution-using-2-pointers-approach",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n        int mini=-1;\\n        int maxi=-1;\\n        long long ans=0;\\n        int st=0;\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i]<minK || nums[i]>maxK){\\n                mini=-1;\\n                maxi=-1;\\n                st=i+1;\\n            }\\n            if(nums[i]==minK){\\n                mini=i;\\n            }\\n            if(nums[i]==maxK){\\n                maxi=i;\\n            }\\n            \\n            ans+=max(0,min(mini,maxi)-st+1);\\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n        int mini=-1;\\n        int maxi=-1;\\n        long long ans=0;\\n        int st=0;\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i]<minK || nums[i]>maxK){\\n                mini=-1;\\n                maxi=-1;\\n                st=i+1;\\n            }\\n            if(nums[i]==minK){\\n                mini=i;\\n            }\\n            if(nums[i]==maxK){\\n                maxi=i;\\n            }\\n            \\n            ans+=max(0,min(mini,maxi)-st+1);\\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3255361,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, int minK, int maxK) \\n    {\\n        long long n=nums.size(),mni=-1,mxi=-1,li=-1,ans=0;\\n        for(int i=0;i<n;++i)\\n        {\\n            if(nums[i]<minK || nums[i]>maxK) li=i,mni=-1,mxi=-1;\\n            else\\n            {\\n                if(nums[i]==minK) mni=i;\\n                if(nums[i]==maxK) mxi=i;\\n                if(mni!=-1 && mxi!=-1) ans+=min(mni,mxi)-li;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, int minK, int maxK) \\n    {\\n        long long n=nums.size(),mni=-1,mxi=-1,li=-1,ans=0;\\n        for(int i=0;i<n;++i)\\n        {\\n            if(nums[i]<minK || nums[i]>maxK) li=i,mni=-1,mxi=-1;\\n            else\\n            {\\n                if(nums[i]==minK) mni=i;\\n                if(nums[i]==maxK) mxi=i;\\n                if(mni!=-1 && mxi!=-1) ans+=min(mni,mxi)-li;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3255211,
                "title": "15-line-code-sliding-window",
                "content": "```\\nlong long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n        long long int ans = 0;\\n        int lb=-1,lmn=-1,lmx=-1,i,n=nums.size();\\n        for(i =0; i<n;i++){\\n            if(nums[i]>=minK&&nums[i]<=maxK){\\n                lmn = (nums[i]==minK)?i:lmn;\\n                lmx = (nums[i]==maxK)?i:lmx;\\n                ans += max(0,min(lmn,lmx)-lb);\\n            }else{\\n                lb = i,lmn=-1,lmx=-1;\\n            }\\n        }\\n        return ans;\\n    }\\n\\t```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nlong long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n        long long int ans = 0;\\n        int lb=-1,lmn=-1,lmx=-1,i,n=nums.size();\\n        for(i =0; i<n;i++){\\n            if(nums[i]>=minK&&nums[i]<=maxK){\\n                lmn = (nums[i]==minK)?i:lmn;\\n                lmx = (nums[i]==maxK)?i:lmx;\\n                ans += max(0,min(lmn,lmx)-lb);\\n            }else{\\n                lb = i,lmn=-1,lmx=-1;\\n            }\\n        }\\n        return ans;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 3255132,
                "title": "easy-sliding-window-two-pointer-c",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n# Brute Force\\nThe first approach that comes up is the Brute Force Approach where we check all possible subarrays and count the ones that have min & max value as given. \\n# Optimization||Two Pointer||Sliding Window\\nWe need to find the no of subarrays possible starting from each index i,in a single traversal.We achieve this by keeping track of the most recent occurrence of minK, maxK, and the first element outside the range [minK, maxK]. This way, we can compute the number of subarrays with the required properties using just a few simple arithmetic operations.\\n# Algorithm \\n 1 :   Initialize variables n, count, nmink, nmaxk, rbound to the    size of the array, 0, n, n, and n, respectively. Also, initialize variable c to 0 to store the count of subarrays.\\n\\n 2 :   Traverse the array from right to left using a for loop and do the following:\\n\\n     a. If the current element is equal to minK, update the value of nmink to the current index.\\n     b. If the current element is equal to maxK, update the value of nmaxk to the current index.\\n     c. If the current element is greater than maxK or less than minK, update the value of rbound to the current index.\\n     d. If the difference between the indices of nmink and nmaxk is less than or equal to rbound, update the value of c by adding the difference between rbound and max(nmink, nmaxk).\\n\\n 3 :   Return the value of c.\\n\\n# Explanation with Example\\n<!-- Describe your approach to solving the problem. -->\\nLet\\'s say we have an array nums = [1, 4, 3, 4, 4, 2, 4, 5], minK = 4, and maxK = 4. We can use the sliding window approach to count the subarrays where the minimum and maximum elements are equal to minK and maxK, respectively.\\n\\nStarting from the right end, we have n = 8, rbound = 8, nmink = 8, nmaxk = 8, and c = 0.\\n\\nFor the last element, nums[7] = 5 is greater than maxK = 4, so we update rbound to 7.\\n\\nFor the second last element, nums[6] = 4 is equal to maxK, so we update nmaxk to 6. Also, since nmaxk is less than rbound, we calculate the number of subarrays that can be formed using the current window, which is rbound - max(nmink, nmaxk) = 2. So, we add 2 to the count c.\\n\\nFor the third last element, nums[5] = 2 is less than minK, so we update rbound to 5.\\n\\nFor the fourth last element, nums[4] = 4 is equal to maxK, so we update nmaxk to 4. Also, since nmaxk is less than rbound, we calculate the number of subarrays that can be formed using the current window, which is rbound - max(nmink, nmaxk) = 1. So, we add 1 to the count c.\\n\\nFor the fifth last element, nums[3] = 4 is equal to maxK, so we update nmaxk to 3. Also, since nmaxk is less than rbound, we calculate the number of subarrays that can be formed using the current window, which is rbound - max(nmink, nmax)\\n\\n# Complexity Comparison\\n- Time complexity: O(n)\\n  The optimized approach uses a single pass through the array, where we keep track of the indices of the most recent occurrence of minK, maxK, and the first element outside the range of [minK, maxK]. Since we only need to process each element of the array once, the time complexity of the optimized approach is O(n), where n is the size of the array.\\n\\n  On the other hand, the Brute Force approach uses two nested for loops to iterate over all possible pairs of indices, and for each pair, we iterate over the subarray between them to check the minimum and maximum elements. This leads to a time complexity of O(n^3), where n is the size of the array.\\n\\n  Therefore, the optimized approach is much faster than the Brute Force approach when it comes to time complexity.\\n- Space complexity: O(1)\\n   The optimized approach uses a constant amount of extra space to store some variables and the counter, which leads to a space complexity of O(1).\\n\\n   The Brute Force approach does not use any extra space to store the subarrays or their minimum and maximum elements, but it does use a counter variable to keep track of the count of subarrays. Therefore, the space complexity of the Brute Force approach is also O(1).\\n\\n  Therefore, both approaches have the same space complexity of O(1).\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n        int n=nums.size();\\n        int rbound=n;\\n        int nmink=n;\\n        int nmaxk=n;\\n        long long int c=0;\\n        for(int i=n-1;i>=0;i--){\\n            if(nums[i]==minK) nmink=i;\\n            if(nums[i]==maxK) nmaxk=i;\\n            if(nums[i]>maxK||nums[i]<minK) rbound=i;\\n            if(rbound-max(nmink,nmaxk)>0) c+=rbound-max(nmink,nmaxk);\\n            // cout<<c<<rbound<<max(nmink,nmaxk)<<endl;(FOR DEBUGGING)\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n        int n=nums.size();\\n        int rbound=n;\\n        int nmink=n;\\n        int nmaxk=n;\\n        long long int c=0;\\n        for(int i=n-1;i>=0;i--){\\n            if(nums[i]==minK) nmink=i;\\n            if(nums[i]==maxK) nmaxk=i;\\n            if(nums[i]>maxK||nums[i]<minK) rbound=i;\\n            if(rbound-max(nmink,nmaxk)>0) c+=rbound-max(nmink,nmaxk);\\n            // cout<<c<<rbound<<max(nmink,nmaxk)<<endl;(FOR DEBUGGING)\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3255126,
                "title": "c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n        long long ans = 0;\\n        bool minFound = false, maxFound = false;\\n        int start = 0, minStart = 0, maxStart = 0;\\n        for(int i=0; i<nums.size(); i++) {\\n            int num = nums[i];\\n            if(num < minK or num > maxK) {\\n                minFound = false;\\n                maxFound = false;\\n                start = i+1;\\n            }\\n            if(num == minK) {\\n                minFound = true;\\n                minStart = i;\\n            }\\n            if(num == maxK) {\\n                maxFound = true;\\n                maxStart = i;\\n            }\\n            if(minFound and maxFound) {\\n                ans += (min(minStart, maxStart) - start + 1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n        long long ans = 0;\\n        bool minFound = false, maxFound = false;\\n        int start = 0, minStart = 0, maxStart = 0;\\n        for(int i=0; i<nums.size(); i++) {\\n            int num = nums[i];\\n            if(num < minK or num > maxK) {\\n                minFound = false;\\n                maxFound = false;\\n                start = i+1;\\n            }\\n            if(num == minK) {\\n                minFound = true;\\n                minStart = i;\\n            }\\n            if(num == maxK) {\\n                maxFound = true;\\n                maxStart = i;\\n            }\\n            if(minFound and maxFound) {\\n                ans += (min(minStart, maxStart) - start + 1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3254813,
                "title": "python3-819-ms-faster-than-97-11-of-python3",
                "content": "![image](https://assets.leetcode.com/users/images/4fc8bf84-0bf6-448a-8f87-e11ac634dfd6_1677915439.91398.png)\\n```\\ndef countSubarrays(self, nums: List[int], minK: int, maxK: int) -> int:\\n        count = last = 0\\n        min_index = max_index = -1\\n        for i, num in enumerate(nums):\\n            if num < minK or num > maxK:\\n                last = i + 1\\n                min_index = max_index = -1\\n                continue\\n            if num == minK:\\n                min_index = i\\n            if num == maxK:\\n                max_index = i\\n            if min_index != -1 and max_index != -1:\\n                count += min(max_index, min_index) - last + 1\\n        return count\\n```\\n\\nThe given code is an implementation of a function called \\'countSubarrays\\' that takes in a list of integers \\'nums\\', and two integer values \\'minK\\' and \\'maxK\\' and returns the count of all contiguous subarrays in \\'nums\\' that have elements between \\'minK\\' and \\'maxK\\', inclusive. Here\\'s a step-by-step explanation of the code:\\n1. Define a function named \\'countSubarrays\\' that takes three input arguments: \\'nums\\' (a list of integers), \\'minK\\' (an integer), and \\'maxK\\' (an integer), and returns an integer.\\n1. Initialize \\'count\\' and \\'last\\' variables to 0. Initialize \\'min_index\\' and \\'max_index\\' variables to -1.\\n1. Loop through each index \\'i\\' and element \\'num\\' in the \\'nums\\' list:\\n\\t1. If the \\'num\\' is less than \\'minK\\' or greater than \\'maxK\\', set \\'last\\' to \\'i+1\\', \\'min_index\\' and \\'max_index\\' to -1 and continue to the next iteration.\\n\\t1. If the \\'num\\' is equal to \\'minK\\', set \\'min_index\\' to the current index \\'i\\'.\\n\\t1. If the \\'num\\' is equal to \\'maxK\\', set \\'max_index\\' to the current index \\'i\\'.\\n\\t1. If both \\'min_index\\' and \\'max_index\\' are not equal to -1, calculate the count of contiguous subarrays between the two indices, update the \\'count\\' variable and set \\'last\\' to the next index after the calculated subarray.\\n1. Return the \\'count\\' variable.\\n\\nNote that the time complexity of this algorithm is O(n), where n is the length of the \\'nums\\' list. This is because we are traversing the list only once and performing a constant number of operations for each element.",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef countSubarrays(self, nums: List[int], minK: int, maxK: int) -> int:\\n        count = last = 0\\n        min_index = max_index = -1\\n        for i, num in enumerate(nums):\\n            if num < minK or num > maxK:\\n                last = i + 1\\n                min_index = max_index = -1\\n                continue\\n            if num == minK:\\n                min_index = i\\n            if num == maxK:\\n                max_index = i\\n            if min_index != -1 and max_index != -1:\\n                count += min(max_index, min_index) - last + 1\\n        return count\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3254676,
                "title": "java-sliding-window-approach-with-intuition-and-detailed-comments",
                "content": "# Intuition\\nWe are storing the indices of recent value of maxK or minK occuring in the array and calculating its distance from the left bound to calculate the number of valid subaarys\\n\\nLeft bound is the element not within the valid range,since we cannot include it in our range we calculate subarrays after it choosing it as a reference\\n(**Follow comments for detailed explanation**)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSliding window\\n\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long countSubarrays(int[] nums, int minK, int maxK) {\\n        //Approach-1\\n        //Calculate all the subarrays and check min and max\\n\\n\\n        //Approach-2\\n        //Very tough intuition\\n        long count = 0;\\n        int recent_min = -1;//Stores the value of most recent element whose value is minK\\n        int recent_max = -1;//Stores the value of most recent element whose value is maxK\\n        int left_bound = -1; //Stores the value of most recent element whose value is outside the range\\n\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]>=minK && nums[i]<=maxK){\\n                recent_min = nums[i] == minK?i:recent_min;\\n                recent_max = nums[i] == maxK?i:recent_max;\\n\\n\\n                ////**************Important step***************\\n                //Always starts considering the subarrays from step 1\\n                //Distance from min(recent_min,recent_max) is taken because\\n                //All the elements between them contribute to number of subaarys\\n                //i.e consider Example 7 2 3 1 5 4 maxK = 5,minK = 1\\n                //subarray 1 5 is within bounds and left bound is index 0 since nums[0] is 7 which\\n                //out of bounds\\n                //Now the subarrays possible to left of 1 are\\n                //2 3 1 5,3 1 5 i.e two subarrays which can be given by Math.min(recent_min,recent_max)-left_bound\\n                //Similarly whenever a element withinbounds is added to the right i.e 4 in the above case\\n                //the count gets increased like explained above\\n                //Max with 0 is to handle the case when mink or maxk is not yet found\\n\\n\\n                count+=(Math.max(0,Math.min(recent_min,recent_max)-left_bound));\\n            }\\n            else{\\n                recent_min = -1;\\n                recent_max = -1;\\n                left_bound = i;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public long countSubarrays(int[] nums, int minK, int maxK) {\\n        //Approach-1\\n        //Calculate all the subarrays and check min and max\\n\\n\\n        //Approach-2\\n        //Very tough intuition\\n        long count = 0;\\n        int recent_min = -1;//Stores the value of most recent element whose value is minK\\n        int recent_max = -1;//Stores the value of most recent element whose value is maxK\\n        int left_bound = -1; //Stores the value of most recent element whose value is outside the range\\n\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]>=minK && nums[i]<=maxK){\\n                recent_min = nums[i] == minK?i:recent_min;\\n                recent_max = nums[i] == maxK?i:recent_max;\\n\\n\\n                ////**************Important step***************\\n                //Always starts considering the subarrays from step 1\\n                //Distance from min(recent_min,recent_max) is taken because\\n                //All the elements between them contribute to number of subaarys\\n                //i.e consider Example 7 2 3 1 5 4 maxK = 5,minK = 1\\n                //subarray 1 5 is within bounds and left bound is index 0 since nums[0] is 7 which\\n                //out of bounds\\n                //Now the subarrays possible to left of 1 are\\n                //2 3 1 5,3 1 5 i.e two subarrays which can be given by Math.min(recent_min,recent_max)-left_bound\\n                //Similarly whenever a element withinbounds is added to the right i.e 4 in the above case\\n                //the count gets increased like explained above\\n                //Max with 0 is to handle the case when mink or maxk is not yet found\\n\\n\\n                count+=(Math.max(0,Math.min(recent_min,recent_max)-left_bound));\\n            }\\n            else{\\n                recent_min = -1;\\n                recent_max = -1;\\n                left_bound = i;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3254354,
                "title": "beats-100-o-n-easy-approach-clean-code-well-explained-c",
                "content": "# Intuition\\nHere we have to count subarrays in an array of integers `nums` where the minimum value of the subarray is `minK` and the maximum value is `maxK`.\\n\\n# Approach\\nHere I am going for sliding window approach. \\n\\nTaking two pointers `j` as the starting of sub array (initialised as -1) and `i` as the end index of subarray (will iterate through it)\\n\\nWe will also be maintaining two pointers `minIndex` and `maxIndex` (initially -1) to point toward recent countered `minK` and `maxK` respectively.\\n\\nat last at each iteration `ans` will be increased by `max(0 , min(maxIndex,minIndex) - j)`.\\n\\nHope you will get it.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\nn is size of the array.\\n\\n- Space complexity:\\nConstant space.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, int minK, int maxK) \\n{\\n    long long ans = 0;\\n    int minIndex = -1;\\n    int maxIndex = -1;\\n    int j = -1;\\n    for (int i = 0; i  < nums.size(); i++)\\n    {\\n        if (nums[i] < minK || nums[i] > maxK)\\n        {\\n            j = i;\\n        }\\n        if (nums[i] == minK)\\n        {\\n            minIndex = i;\\n        }\\n        if (nums[i] == maxK)\\n        {\\n            maxIndex = i;\\n        }\\n        ans += max(0 , min(maxIndex,minIndex) - j);\\n    }\\n    return ans;\\n}\\n   \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, int minK, int maxK) \\n{\\n    long long ans = 0;\\n    int minIndex = -1;\\n    int maxIndex = -1;\\n    int j = -1;\\n    for (int i = 0; i  < nums.size(); i++)\\n    {\\n        if (nums[i] < minK || nums[i] > maxK)\\n        {\\n            j = i;\\n        }\\n        if (nums[i] == minK)\\n        {\\n            minIndex = i;\\n        }\\n        if (nums[i] == maxK)\\n        {\\n            maxIndex = i;\\n        }\\n        ans += max(0 , min(maxIndex,minIndex) - j);\\n    }\\n    return ans;\\n}\\n   \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3254336,
                "title": "brute-force-c-o-n-time-complexity-o-1-space-complexity",
                "content": "# Intuition\\nSince we need to find number of subarray , we need to think something in direction of sliding window \\n\\n# Approach\\n1-\\nWe take a start variable to mark the start of the sliding window \\n2- \\nWe need to mark the index where we found min and also where we found the maxima\\n3-\\nNow in case the nums[i] > maxK || nums[i] < minK\\nSo in this case , our sliding window is broken,\\nUpdate the start to i+1\\nmin_found = false;\\nmax_found = false;\\n//We are basically starting with new sliding window , so we reset all the parameters\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n        int start = 0;\\n        int min_found = false;\\n        int max_found = false;\\n        int min_ind = -1;\\n        int max_ind = -1;\\n        long long ans = 0;\\n        for(int i = 0;i<nums.size();i++)\\n        {\\n            if(nums[i] > maxK || nums[i] < minK)\\n            {\\n                min_found = false;\\n                max_found = false;\\n                start = i+1;\\n                continue;\\n            } //we need to reset our initial parameters \\n            if(nums[i] ==  minK)\\n            {\\n                min_ind = i;\\n                min_found = true;\\n            }\\n            if(nums[i] == maxK)\\n            {\\n                max_ind = i;\\n                max_found = true;\\n            }\\n            if(min_found && max_found)\\n//incase we have found both our min and max element , \\n//means we can add this subarray to our ans \\n            {\\n                int ss = min(min_ind , max_ind);\\n                //we have both min and max , so we need to add on to final answer\\n//why did we do min(min_ind , max_ind)??\\n//Because , the min/max element could be found either before max/min element \\n                ans = ans+(ss-start+1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n\\n# Complexity\\n- Time complexity:\\nSince we are travesring the array just once , so it means the TC is \\nO(n)\\n\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n        int start = 0;\\n        int min_found = false;\\n        int max_found = false;\\n        int min_ind = -1;\\n        int max_ind = -1;\\n        long long ans = 0;\\n        for(int i = 0;i<nums.size();i++)\\n        {\\n            if(nums[i] > maxK || nums[i] < minK)\\n            {\\n                min_found = false;\\n                max_found = false;\\n                start = i+1;\\n                continue;\\n            } //we need to reset our initial parameters \\n            if(nums[i] ==  minK)\\n            {\\n                min_ind = i;\\n                min_found = true;\\n            }\\n            if(nums[i] == maxK)\\n            {\\n                max_ind = i;\\n                max_found = true;\\n            }\\n            if(min_found && max_found)\\n//incase we have found both our min and max element , \\n//means we can add this subarray to our ans \\n            {\\n                int ss = min(min_ind , max_ind);\\n                //we have both min and max , so we need to add on to final answer\\n//why did we do min(min_ind , max_ind)??\\n//Because , the min/max element could be found either before max/min element \\n                ans = ans+(ss-start+1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3254298,
                "title": "easy-sliding-window-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n        int mini=-1, maxi=-1;\\n        int i=0,j=0, n= nums.size();\\n        long long cnt=0;\\n        while(j<n) {\\n            if(nums[j]<minK or nums[j]>maxK) {\\n                mini=maxi=-1;\\n                i=j+1;\\n            }\\n            if(nums[j]==minK) mini=j;\\n            if(nums[j]==maxK) maxi= j;\\n\\n            cnt+= max(0, min(mini, maxi) - i + 1); \\n            j++;\\n\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Queue",
                    "Sliding Window",
                    "Monotonic Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n        int mini=-1, maxi=-1;\\n        int i=0,j=0, n= nums.size();\\n        long long cnt=0;\\n        while(j<n) {\\n            if(nums[j]<minK or nums[j]>maxK) {\\n                mini=maxi=-1;\\n                i=j+1;\\n            }\\n            if(nums[j]==minK) mini=j;\\n            if(nums[j]==maxK) maxi= j;\\n\\n            cnt+= max(0, min(mini, maxi) - i + 1); \\n            j++;\\n\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3253913,
                "title": "easy-and-fast-c-solution-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n public:\\n  long long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n    long long ans = 0;\\n    int j = -1;\\n    int prevMinKIndex = -1;\\n    int prevMaxKIndex = -1;\\n\\n    for (int i = 0; i < nums.size(); ++i) {\\n      if (nums[i] < minK || nums[i] > maxK)\\n        j = i;\\n      if (nums[i] == minK)\\n        prevMinKIndex = i;\\n      if (nums[i] == maxK)\\n        prevMaxKIndex = i;\\n      // any index k in [j + 1, min(prevMinKIndex, prevMaxKIndex)] can be the\\n      // start of the subarray s.t. nums[k..i] satisfies the conditions\\n      ans += max(0, min(prevMinKIndex, prevMaxKIndex) - j);\\n    }\\n\\n    return ans;\\n  }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n public:\\n  long long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n    long long ans = 0;\\n    int j = -1;\\n    int prevMinKIndex = -1;\\n    int prevMaxKIndex = -1;\\n\\n    for (int i = 0; i < nums.size(); ++i) {\\n      if (nums[i] < minK || nums[i] > maxK)\\n        j = i;\\n      if (nums[i] == minK)\\n        prevMinKIndex = i;\\n      if (nums[i] == maxK)\\n        prevMaxKIndex = i;\\n      // any index k in [j + 1, min(prevMinKIndex, prevMaxKIndex)] can be the\\n      // start of the subarray s.t. nums[k..i] satisfies the conditions\\n      ans += max(0, min(prevMinKIndex, prevMaxKIndex) - j);\\n    }\\n\\n    return ans;\\n  }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3253900,
                "title": "daily-leetcoding-challenge-march-day-4",
                "content": "This problem is the Daily LeetCoding Challenge for March, Day 4.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/count-subarrays-with-fixed-bounds/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 0 approach in the official solution</summary>\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/count-subarrays-with-fixed-bounds/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 3003020,
                "title": "python-simple-maths",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countSubarrays(self, nums, minK, maxK):\\n        minfound = maxfound = False\\n        start = minstart = maxstart = 0\\n        total = 0\\n\\n        for i in range(len(nums)):\\n            if nums[i] == minK:\\n                minstart = i\\n                minfound = True\\n            if nums[i] == maxK:\\n                maxstart = i\\n                maxfound = True\\n            if not minK <= nums[i] <= maxK:\\n                minfound = maxfound = False\\n                start = i+1\\n            if minfound and maxfound:\\n                total += min(minstart,maxstart) - start + 1\\n\\n        return total\\n\\n\\n            \\n\\n\\n\\n\\n        \\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countSubarrays(self, nums, minK, maxK):\\n        minfound = maxfound = False\\n        start = minstart = maxstart = 0\\n        total = 0\\n\\n        for i in range(len(nums)):\\n            if nums[i] == minK:\\n                minstart = i\\n                minfound = True\\n            if nums[i] == maxK:\\n                maxstart = i\\n                maxfound = True\\n            if not minK <= nums[i] <= maxK:\\n                minfound = maxfound = False\\n                start = i+1\\n            if minfound and maxfound:\\n                total += min(minstart,maxstart) - start + 1\\n\\n        return total\\n\\n\\n            \\n\\n\\n\\n\\n        \\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2763355,
                "title": "queue-approach-o-n-easy-intuition",
                "content": "**SOLUTION USING QUEUE**\\n\\n1. **Take a queue**\\n2. **initialize** three variables `minElementPosition = -1` , `maxElementPosition = -1` & `res = 0`\\n\\t* *At any given point minElementPosition & maxElementPosition will tell us if our queue contains minK & max or not*\\n3. **Iterate** over the given nums array\\n\\t4. **If**` nums[i] >= minK OR nums[i] <= maxK` (*element is in given range/good element*) \\n\\t\\t\\t1. **Add** element into the Queue\\n\\t\\t\\t2. **If**` nums[i] == minK` **Then** `minElementPosition = queue.size()`\\n\\t\\t\\t3. **If** `nums[i] == maxK` **Then** `maxElementPosition = queue.size()`\\n\\t\\t\\t4. **If** `minElementPosition != -1 && maxElementPosition != -1 `\\n\\t\\t\\t**Then** `res += min(minElementPosition,maxElementPosition)`\\n\\t\\t\\t*i.e min(minElementPosition,maxElementPosition) this many subarray we can make with the elements in our queue*\\n\\t5. **Else**\\n\\t\\t1. Clear the Queue (*Delete all elements from queue*) \\n\\t\\t2. Reset` minElementPosition = -1 , maxElementPosition = -1 `\\n\\t\\t\\t(*means we dont have minK & maxK in our queue*)\\n\\n**This visualization will give you clear understanding of above steps & intution behind it**\\n![image](https://assets.leetcode.com/users/images/99431d24-b69e-48eb-b661-9a41c2a577ad_1667221522.5965605.jpeg)\\n\\n**Java Code**\\n```\\nclass Solution {\\n    public long countSubarrays(int[] nums, int minK, int maxK) {\\n        Queue<Integer> q = new ArrayDeque<>();\\n        int minElementIndex = -1;\\n        int maxElementIndex = -1;\\n        Long res= 0L;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i] >= minK || nums[i] <= maxK){\\n                q.add(nums[i]);\\n                if(nums[i] == minK) minElementIndex = q.size();\\n                if(nums[i] == maxK) maxElementIndex = q.size();\\n                if(minElementIndex != -1 && maxElementIndex!= -1){\\n                    res += Long.valueOf(Math.min(minElementIndex,maxElementIndex));\\n                } \\n                \\n            }\\n            else{\\n                q.clear();\\n                minElementIndex = -1;\\n                maxElementIndex = -1;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\\n\\n\\t\\n\\n",
                "solutionTags": [
                    "Java",
                    "C",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\n    public long countSubarrays(int[] nums, int minK, int maxK) {\\n        Queue<Integer> q = new ArrayDeque<>();\\n        int minElementIndex = -1;\\n        int maxElementIndex = -1;\\n        Long res= 0L;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i] >= minK || nums[i] <= maxK){\\n                q.add(nums[i]);\\n                if(nums[i] == minK) minElementIndex = q.size();\\n                if(nums[i] == maxK) maxElementIndex = q.size();\\n                if(minElementIndex != -1 && maxElementIndex!= -1){\\n                    res += Long.valueOf(Math.min(minElementIndex,maxElementIndex));\\n                } \\n                \\n            }\\n            else{\\n                q.clear();\\n                minElementIndex = -1;\\n                maxElementIndex = -1;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2747191,
                "title": "entire-thought-process-explained-using-ascii-pictures-must-read",
                "content": "**Must read in order to understand the complete logic, otherwise clean code under the commented one**\\n\\n```\\n/*\\n    Let\\'s do some observations\\n    --------------------------\\n    \\n    #1 Since the constraint is high enough therefore we can\\'t apply brute-force approach (trying\\n    each and every sub-array and count the ones which satisfy the condition describe in PS).\\n   \\n   NOTE: This second observation is the learning factor in this problem.\\n   \\n    #2 Next train of thought that must be comes into your mind that whenever we\\'re required\\n    to count number of sub-arrays which satisfying certain condition(s):\\n            + Can we count each sub-arrays strating with any ith index and each one of them satisfy\\n            the given certain conditions.\\n            \\n            + Well, if we can do it in a efficient manner then we\\'re good to go with this approach.\\n            \\n            + the result(count of subarrays) is nothing but sum of all the counts(of subarrays) starting\\n            at ith index.\\n            \\n            \\n            with this second observation, \\n            \\n            [1, 2, 4, 3, 2, 5, 2, 1, 4, 5, 2, 1], minK = 2, maxK = 4\\n                ^\\n                |\\n                |\\n                |\\n          1.  count how many sub-arrays starting with this index(1)\\n            \\n            [2, 4], [2, 4, 3], [2, 4, 3, 2] => total 3 sub-arrays (starting from 1)\\n            \\n          2.  sub-arrays count starting at index(2) is = 1 [4, 3, 2]\\n            \\n            \\n        If you closely observe, whenever we\\'re counting the sub-arrays starting with (0 & 1)\\n        the last sub-array in both the cases(1. & 2.) ended at index (5).\\n        \\n            Q: the question is that why we don\\'t go beyound that?\\n            A: Because any sub-array passing thourgh index 5 would be an invalid sub-array\\n                according to our requirement.\\n                \\n                why? because maximum element is changed which is 5 at index 5 and beyond that.\\n                \\n                \\n            Hence, we can say that any sub-array which passes through an element(< minK) and (> maxK)\\n            would be an invalid sub-array(i.e., NOT part of our concern).\\n                    In other words, we can say that such indices are dead end.\\n            \\n                    Let\\'s mark the dead end in the above example array:\\n                    \\n                    \\n                    [1, 2, 4, 3, 2, 5, 2, 1, 4, 5, 2, 1], minK = 2, maxK = 4\\n                     ^              ^     ^     ^     ^        \\n                     |              |     |     |     |  \\n                     |              |     |     |     |  \\n                     X              X     X     X     X\\n                    (< minK)      ( > maxK)\\n            \\n            \\n                Once we marked our dead ends in the original sub-arrays, these sub-arrays\\n                are the only that are part of concern:\\n            \\n                    sub-arrays in the range of indices (1, 4) => [2, 4, 3, 2]\\n                    \\n                    -----------------------------------(6, 6) => [2]\\n                    \\n                    -----------------------------------(8, 8) => [4]\\n                    \\n                    -----------------------------------(10, 10) => [2]\\n            \\n            Now, apply the observation #2 in these above sub-arrays and count\\n            the ones that we\\'re looking for.\\n            \\n            NOTE: Important point about these sub-arrays is:\\n                        1. every element is >= minK\\n                        2. every element is <= maxK\\n            \\n                    count_of_total_subarrays = count the sub-arrays with min=minK and max=maxK\\n            \\n            \\n            Let\\'s see, how many sub-arrays in the first splitted sub-array:\\n            \\n        starting_index\\n             |\\n             |\\n             V\\n            [2, 4, 3, 2]\\n                ^\\n                |\\n                |\\n              1(say fst) is the first index to the right of index 0(starting index)\\n              where minK & maxK both are included.\\n            \\n              now, total sub-arrays starting with 0th index\\n              can be given by = (count_of_elements_in_this_sub-array - 1)\\n                              = (n - fst)\\n                              = (4 - 1)\\n                              = 3\\n                              \\n                            n = number of elements in the current sub-array.\\n            \\n            \\n            similarly, let see the number of sub-arrays starting with index 1\\n            \\n            [2, 4, 3, 2]\\n                ^     ^\\n                |     |  fst\\n                |     |\\n                |   first_index where minK & maxK both are included to the right of starting index(1)\\n                |   \\n            starting_index(1)\\n            \\n            hence, total sub-arrays can be given by = (n - fst) = (4 - 3) = 1\\n            \\n            \\n            Total sub-arrays in this sub-array is = 3 + 1 = 4\\n            \\n            \\n            similarly, calculate the count of valid sub-arrays from each valid splitted sub-arrays\\n            and add their counts. The added final sum is nothing but our answer.\\n            \\n            \\n    Now, let\\'s see the approach [Psuedo Code]\\n    =========================================\\n        \\n        NOTE: n is the number of elements in the current spiltted sub-array(every element >= minK and\\n        <= maxK).\\n        \\n        for each spiltted sub-array\\n            for each index i in the range [0...n-1]\\n                find the first index of \\'minK\\' after index \\'i\\' -> say firstMinIndex\\n                find the first index of \\'maxK\\' after index \\'i\\' -> say firstMaxIndex\\n                \\n                now, finally compute the first index where both \\'minK\\' and \\'maxK\\' is included\\n                after index \\'i\\'\\n                \\n                firstIndexBothIncluded = max(firstMinIndex, firstMaxIndex)\\n                \\n                count_of_subarrays += (n - firstIndexBothIncluded)\\n                \\n        finally, return count_of_subarrays(this would be the our final answr for this problem).\\n        \\n        NOTE: finding \\'firstIndexBothIndcluded\\' for each \\'i\\' can take O(n) steps in the worst case ascenario.\\n        \\n        \\n        Time & Space Complexity Analysis\\n        ================================\\n        \\n        Time:\\n        ++++\\n            In worst case, entire given array(nums) itself can have all elements (>= minK & <= maxK)\\n            for each our i(0 <= i < len(nums)) calculating first index where both (minK & maxK)\\n            is included to the right of \\'i\\' can take O(n) in worst scenario.\\n            \\n            Hence, over-all time complexity for this would be : O(n * n) = O(n^2)\\n            \\n            But the compuating for first such index where both minK & maxK is included\\n            can be done in O(1) time, if we build suffix position array for (minK & maxK) beforehand.\\n            \\n            see the code for more clear understanding.\\n            \\n        Space:\\n        +++++\\n            O(sum(len(spitted_sub-arrays)) + len(suffix_array)) => all sum come out as linear.\\n            \\n        \\n        Credits: Goes to @codingmohan on YouTube for hint of second observation #2.\\n        ++++++++\\n\\t\\t\\n\\t\\tScope of Improvement\\n\\t\\t+++++++++++++++++\\n\\t\\t\\t\\tI think : computing suffix array again and again can be avoided by calculating\\n\\t\\t\\t\\tone single suffix array for both minK & maxK and pass starting and ending index of each-\\n\\t\\t\\t\\tsubarray rather than \\'subarray\\' itself.\\n*/\\n\\nclass Solution {\\n    \\n    private int minK;\\n    private int maxK;\\n    \\n    private long countOfSubarraysInSpilttedSubarray(List<Integer> subarray) {\\n        long cnt = 0;\\n        int n = subarray.size();\\n        \\n        // maxKPositions[i] = tells what is the nearest index(>= i) where maxK is located in \\'subarray\\'\\n        int[] maxKPositions = new int[n + 1];\\n        \\n        // for smooth computation. to avoid some conditional statements. like sub-array of single element\\n        // or doesn\\'t have minK & maxK in the given sub-array at all.\\n\\t\\t// that\\'s why filling with n so that for such test-cases the answer is added as 0\\n\\t\\t// in our final(cnt) answer automatically.\\n        Arrays.fill(maxKPositions, n); \\n        \\n        // minKPositions[i] = tells what is the nearest index(>= i) where minK is located in \\'subarray\\'\\n        int[] minKPositions = new int[n + 1];\\n        Arrays.fill(minKPositions, n);\\n        \\n        // building suffix positions arrays\\n        for(int i = n - 1; i >= 0; i -= 1) {\\n            maxKPositions[i] = subarray.get(i) == maxK ? i : maxKPositions[i + 1];\\n            minKPositions[i] = subarray.get(i) == minK ? i : minKPositions[i + 1];\\n        }\\n        \\n        for(int i = 0; i < n; i += 1) {\\n            int firstIndexBothIncluded = Math.max(maxKPositions[i], minKPositions[i]);\\n            cnt += (n - firstIndexBothIncluded); // nothing but (n - fst) as we\\'ve discussed\\n        }\\n        \\n        return cnt;\\n    }\\n    \\n    public long countSubarrays(int[] nums, int minK, int maxK) {\\n        this.minK = minK; this.maxK = maxK;\\n        long countOfSubarray = 0;\\n        \\n        // Used to store each spiltted array one by one\\n        List<Integer> subarray = new ArrayList<>();\\n        \\n        for(int i = 0; i < nums.length; i += 1) {\\n            // found a dead end [whatever stored in our \\'subarray\\' so far is the spiltted array]\\n            // compute the total sub-arrays from it and add it our answer\\n            if(nums[i] < minK || nums[i] > maxK) {\\n                countOfSubarray += countOfSubarraysInSpilttedSubarray(subarray);\\n                subarray.clear(); // clear to fill next valid sub-array\\n            } else \\n                subarray.add(nums[i]);\\n        }\\n        \\n        // in case, if our some answer exits in the last segement of original array\\n        // or each element of entire given array itself >= minK & <= maxK, for such test-cases\\n        // we\\'re not able to find dead end inside the above loop.\\n        // TCs like : [1, 4, 5, 1, 2, 3] minK = 1, maxK = 5 OR [4, 4, 5, 6, 1, 3, 2] minK = 1, maxK = 3\\n        countOfSubarray += countOfSubarraysInSpilttedSubarray(subarray);\\n        \\n        return countOfSubarray;\\n    }\\n}\\n```\\n\\n```\\nClean Code\\n```\\n\\n```\\nclass Solution {\\n    \\n    private int minK;\\n    private int maxK;\\n    \\n    private long countOfSubarraysInSpilttedSubarray(List<Integer> subarray) {\\n        long cnt = 0;\\n        int n = subarray.size();\\n        \\n        int[] maxKPositions = new int[n + 1];\\n        Arrays.fill(maxKPositions, n); \\n        \\n        int[] minKPositions = new int[n + 1];\\n        Arrays.fill(minKPositions, n);\\n        \\n        for(int i = n - 1; i >= 0; i -= 1) {\\n            maxKPositions[i] = subarray.get(i) == maxK ? i : maxKPositions[i + 1];\\n            minKPositions[i] = subarray.get(i) == minK ? i : minKPositions[i + 1];\\n        }\\n        \\n        for(int i = 0; i < n; i += 1) {\\n            int firstIndexBothIncluded = Math.max(maxKPositions[i], minKPositions[i]);\\n            cnt += (n - firstIndexBothIncluded);\\n        }\\n        \\n        return cnt;\\n    }\\n    \\n    public long countSubarrays(int[] nums, int minK, int maxK) {\\n        this.minK = minK; this.maxK = maxK;\\n        long countOfSubarray = 0;\\n        List<Integer> subarray = new ArrayList<>();\\n        for(int i = 0; i < nums.length; i += 1) {\\n            if(nums[i] < minK || nums[i] > maxK) {\\n                countOfSubarray += countOfSubarraysInSpilttedSubarray(subarray);\\n                subarray.clear(); \\n            } else \\n                subarray.add(nums[i]);\\n        }\\n        countOfSubarray += countOfSubarraysInSpilttedSubarray(subarray);\\n        return countOfSubarray;\\n    }\\n}\\n```\\n\\n*If you found this post helpful and if you feel that it deserve a upvote then do it*\\n*for putting this much efforts w/t any hesitation*",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/*\\n    Let\\'s do some observations\\n    --------------------------\\n    \\n    #1 Since the constraint is high enough therefore we can\\'t apply brute-force approach (trying\\n    each and every sub-array and count the ones which satisfy the condition describe in PS).\\n   \\n   NOTE: This second observation is the learning factor in this problem.\\n   \\n    #2 Next train of thought that must be comes into your mind that whenever we\\'re required\\n    to count number of sub-arrays which satisfying certain condition(s):\\n            + Can we count each sub-arrays strating with any ith index and each one of them satisfy\\n            the given certain conditions.\\n            \\n            + Well, if we can do it in a efficient manner then we\\'re good to go with this approach.\\n            \\n            + the result(count of subarrays) is nothing but sum of all the counts(of subarrays) starting\\n            at ith index.\\n            \\n            \\n            with this second observation, \\n            \\n            [1, 2, 4, 3, 2, 5, 2, 1, 4, 5, 2, 1], minK = 2, maxK = 4\\n                ^\\n                |\\n                |\\n                |\\n          1.  count how many sub-arrays starting with this index(1)\\n            \\n            [2, 4], [2, 4, 3], [2, 4, 3, 2] => total 3 sub-arrays (starting from 1)\\n            \\n          2.  sub-arrays count starting at index(2) is = 1 [4, 3, 2]\\n            \\n            \\n        If you closely observe, whenever we\\'re counting the sub-arrays starting with (0 & 1)\\n        the last sub-array in both the cases(1. & 2.) ended at index (5).\\n        \\n            Q: the question is that why we don\\'t go beyound that?\\n            A: Because any sub-array passing thourgh index 5 would be an invalid sub-array\\n                according to our requirement.\\n                \\n                why? because maximum element is changed which is 5 at index 5 and beyond that.\\n                \\n                \\n            Hence, we can say that any sub-array which passes through an element(< minK) and (> maxK)\\n            would be an invalid sub-array(i.e., NOT part of our concern).\\n                    In other words, we can say that such indices are dead end.\\n            \\n                    Let\\'s mark the dead end in the above example array:\\n                    \\n                    \\n                    [1, 2, 4, 3, 2, 5, 2, 1, 4, 5, 2, 1], minK = 2, maxK = 4\\n                     ^              ^     ^     ^     ^        \\n                     |              |     |     |     |  \\n                     |              |     |     |     |  \\n                     X              X     X     X     X\\n                    (< minK)      ( > maxK)\\n            \\n            \\n                Once we marked our dead ends in the original sub-arrays, these sub-arrays\\n                are the only that are part of concern:\\n            \\n                    sub-arrays in the range of indices (1, 4) => [2, 4, 3, 2]\\n                    \\n                    -----------------------------------(6, 6) => [2]\\n                    \\n                    -----------------------------------(8, 8) => [4]\\n                    \\n                    -----------------------------------(10, 10) => [2]\\n            \\n            Now, apply the observation #2 in these above sub-arrays and count\\n            the ones that we\\'re looking for.\\n            \\n            NOTE: Important point about these sub-arrays is:\\n                        1. every element is >= minK\\n                        2. every element is <= maxK\\n            \\n                    count_of_total_subarrays = count the sub-arrays with min=minK and max=maxK\\n            \\n            \\n            Let\\'s see, how many sub-arrays in the first splitted sub-array:\\n            \\n        starting_index\\n             |\\n             |\\n             V\\n            [2, 4, 3, 2]\\n                ^\\n                |\\n                |\\n              1(say fst) is the first index to the right of index 0(starting index)\\n              where minK & maxK both are included.\\n            \\n              now, total sub-arrays starting with 0th index\\n              can be given by = (count_of_elements_in_this_sub-array - 1)\\n                              = (n - fst)\\n                              = (4 - 1)\\n                              = 3\\n                              \\n                            n = number of elements in the current sub-array.\\n            \\n            \\n            similarly, let see the number of sub-arrays starting with index 1\\n            \\n            [2, 4, 3, 2]\\n                ^     ^\\n                |     |  fst\\n                |     |\\n                |   first_index where minK & maxK both are included to the right of starting index(1)\\n                |   \\n            starting_index(1)\\n            \\n            hence, total sub-arrays can be given by = (n - fst) = (4 - 3) = 1\\n            \\n            \\n            Total sub-arrays in this sub-array is = 3 + 1 = 4\\n            \\n            \\n            similarly, calculate the count of valid sub-arrays from each valid splitted sub-arrays\\n            and add their counts. The added final sum is nothing but our answer.\\n            \\n            \\n    Now, let\\'s see the approach [Psuedo Code]\\n    =========================================\\n        \\n        NOTE: n is the number of elements in the current spiltted sub-array(every element >= minK and\\n        <= maxK).\\n        \\n        for each spiltted sub-array\\n            for each index i in the range [0...n-1]\\n                find the first index of \\'minK\\' after index \\'i\\' -> say firstMinIndex\\n                find the first index of \\'maxK\\' after index \\'i\\' -> say firstMaxIndex\\n                \\n                now, finally compute the first index where both \\'minK\\' and \\'maxK\\' is included\\n                after index \\'i\\'\\n                \\n                firstIndexBothIncluded = max(firstMinIndex, firstMaxIndex)\\n                \\n                count_of_subarrays += (n - firstIndexBothIncluded)\\n                \\n        finally, return count_of_subarrays(this would be the our final answr for this problem).\\n        \\n        NOTE: finding \\'firstIndexBothIndcluded\\' for each \\'i\\' can take O(n) steps in the worst case ascenario.\\n        \\n        \\n        Time & Space Complexity Analysis\\n        ================================\\n        \\n        Time:\\n        ++++\\n            In worst case, entire given array(nums) itself can have all elements (>= minK & <= maxK)\\n            for each our i(0 <= i < len(nums)) calculating first index where both (minK & maxK)\\n            is included to the right of \\'i\\' can take O(n) in worst scenario.\\n            \\n            Hence, over-all time complexity for this would be : O(n * n) = O(n^2)\\n            \\n            But the compuating for first such index where both minK & maxK is included\\n            can be done in O(1) time, if we build suffix position array for (minK & maxK) beforehand.\\n            \\n            see the code for more clear understanding.\\n            \\n        Space:\\n        +++++\\n            O(sum(len(spitted_sub-arrays)) + len(suffix_array)) => all sum come out as linear.\\n            \\n        \\n        Credits: Goes to @codingmohan on YouTube for hint of second observation #2.\\n        ++++++++\\n\\t\\t\\n\\t\\tScope of Improvement\\n\\t\\t+++++++++++++++++\\n\\t\\t\\t\\tI think : computing suffix array again and again can be avoided by calculating\\n\\t\\t\\t\\tone single suffix array for both minK & maxK and pass starting and ending index of each-\\n\\t\\t\\t\\tsubarray rather than \\'subarray\\' itself.\\n*/\\n\\nclass Solution {\\n    \\n    private int minK;\\n    private int maxK;\\n    \\n    private long countOfSubarraysInSpilttedSubarray(List<Integer> subarray) {\\n        long cnt = 0;\\n        int n = subarray.size();\\n        \\n        // maxKPositions[i] = tells what is the nearest index(>= i) where maxK is located in \\'subarray\\'\\n        int[] maxKPositions = new int[n + 1];\\n        \\n        // for smooth computation. to avoid some conditional statements. like sub-array of single element\\n        // or doesn\\'t have minK & maxK in the given sub-array at all.\\n\\t\\t// that\\'s why filling with n so that for such test-cases the answer is added as 0\\n\\t\\t// in our final(cnt) answer automatically.\\n        Arrays.fill(maxKPositions, n); \\n        \\n        // minKPositions[i] = tells what is the nearest index(>= i) where minK is located in \\'subarray\\'\\n        int[] minKPositions = new int[n + 1];\\n        Arrays.fill(minKPositions, n);\\n        \\n        // building suffix positions arrays\\n        for(int i = n - 1; i >= 0; i -= 1) {\\n            maxKPositions[i] = subarray.get(i) == maxK ? i : maxKPositions[i + 1];\\n            minKPositions[i] = subarray.get(i) == minK ? i : minKPositions[i + 1];\\n        }\\n        \\n        for(int i = 0; i < n; i += 1) {\\n            int firstIndexBothIncluded = Math.max(maxKPositions[i], minKPositions[i]);\\n            cnt += (n - firstIndexBothIncluded); // nothing but (n - fst) as we\\'ve discussed\\n        }\\n        \\n        return cnt;\\n    }\\n    \\n    public long countSubarrays(int[] nums, int minK, int maxK) {\\n        this.minK = minK; this.maxK = maxK;\\n        long countOfSubarray = 0;\\n        \\n        // Used to store each spiltted array one by one\\n        List<Integer> subarray = new ArrayList<>();\\n        \\n        for(int i = 0; i < nums.length; i += 1) {\\n            // found a dead end [whatever stored in our \\'subarray\\' so far is the spiltted array]\\n            // compute the total sub-arrays from it and add it our answer\\n            if(nums[i] < minK || nums[i] > maxK) {\\n                countOfSubarray += countOfSubarraysInSpilttedSubarray(subarray);\\n                subarray.clear(); // clear to fill next valid sub-array\\n            } else \\n                subarray.add(nums[i]);\\n        }\\n        \\n        // in case, if our some answer exits in the last segement of original array\\n        // or each element of entire given array itself >= minK & <= maxK, for such test-cases\\n        // we\\'re not able to find dead end inside the above loop.\\n        // TCs like : [1, 4, 5, 1, 2, 3] minK = 1, maxK = 5 OR [4, 4, 5, 6, 1, 3, 2] minK = 1, maxK = 3\\n        countOfSubarray += countOfSubarraysInSpilttedSubarray(subarray);\\n        \\n        return countOfSubarray;\\n    }\\n}\\n```\n```\\nClean Code\\n```\n```\\nclass Solution {\\n    \\n    private int minK;\\n    private int maxK;\\n    \\n    private long countOfSubarraysInSpilttedSubarray(List<Integer> subarray) {\\n        long cnt = 0;\\n        int n = subarray.size();\\n        \\n        int[] maxKPositions = new int[n + 1];\\n        Arrays.fill(maxKPositions, n); \\n        \\n        int[] minKPositions = new int[n + 1];\\n        Arrays.fill(minKPositions, n);\\n        \\n        for(int i = n - 1; i >= 0; i -= 1) {\\n            maxKPositions[i] = subarray.get(i) == maxK ? i : maxKPositions[i + 1];\\n            minKPositions[i] = subarray.get(i) == minK ? i : minKPositions[i + 1];\\n        }\\n        \\n        for(int i = 0; i < n; i += 1) {\\n            int firstIndexBothIncluded = Math.max(maxKPositions[i], minKPositions[i]);\\n            cnt += (n - firstIndexBothIncluded);\\n        }\\n        \\n        return cnt;\\n    }\\n    \\n    public long countSubarrays(int[] nums, int minK, int maxK) {\\n        this.minK = minK; this.maxK = maxK;\\n        long countOfSubarray = 0;\\n        List<Integer> subarray = new ArrayList<>();\\n        for(int i = 0; i < nums.length; i += 1) {\\n            if(nums[i] < minK || nums[i] > maxK) {\\n                countOfSubarray += countOfSubarraysInSpilttedSubarray(subarray);\\n                subarray.clear(); \\n            } else \\n                subarray.add(nums[i]);\\n        }\\n        countOfSubarray += countOfSubarraysInSpilttedSubarray(subarray);\\n        return countOfSubarray;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2725200,
                "title": "sliding-window-with-explanation-c",
                "content": "This problem is like problem 795, but the difference is that the min val and max val of the subarry is fixed to minK and maxK. However, we could still use sliding window.\\n\\nThe value of the elements in the sliding is in the range [minK, maxK]. When we transverse the array, we need to record the lastest index of minK and maxK (refer as jmin and jmax). If num[i] is not in the range [minK, maxK], we need to update the left pointer to i+1.\\n\\nFor the counting, when we are transversing nums[i], the count of the subarrays is max(0, min(jmin,jmax)-j+1) (where j is the index of the left pointer of the sliding window). We could think in this way: when we fix the right edge of the subarray as i, then the number of choices of the left edge is the distance between the left pointer and the closest index of minK or maxK.\\n\\n```\\nlong long countSubarrays(vector<int>& A, int minK, int maxK) {\\n        long res = 0, j = 0, jmin = -1, jmax = -1, n = A.size();\\n        for (int i = 0; i < n; ++i) {\\n            if  (A[i] < minK || A[i] > maxK) {\\n                jmin = jmax = -1;\\n                j = i + 1;\\n            }\\n            if (A[i] == minK) jmin = i;\\n            if (A[i] == maxK) jmax = i;\\n            res += max(0L, min(jmin, jmax) - j + 1);\\n        }\\n        return res;\\n    }\\n\\n```\\n\\nThe explanation in Chinese is in this link: https://mp.weixin.qq.com/s?__biz=Mzg3OTY0ODc2Mw==&mid=2247483958&idx=1&sn=c05562e3f93f42bf6fc12c6586b7573a&chksm=cf0008a2f87781b479e428a478505775d86055d4e9f00dbf8dbbb3408b9516ed6b5b1f596666&token=960413088&lang=zh_CN#rd",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nlong long countSubarrays(vector<int>& A, int minK, int maxK) {\\n        long res = 0, j = 0, jmin = -1, jmax = -1, n = A.size();\\n        for (int i = 0; i < n; ++i) {\\n            if  (A[i] < minK || A[i] > maxK) {\\n                jmin = jmax = -1;\\n                j = i + 1;\\n            }\\n            if (A[i] == minK) jmin = i;\\n            if (A[i] == maxK) jmax = i;\\n            res += max(0L, min(jmin, jmax) - j + 1);\\n        }\\n        return res;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2722575,
                "title": "c",
                "content": "```\\nlong long countSubarrays(int* nums, int numsSize, int minK, int maxK){\\n\\n    long long ans = 0;\\n    int lastminK = -1, lastmaxK = -1;\\n    int start = 0;\\n    for(int i = 0; i < numsSize; i++){\\n        if(nums[i] > maxK || nums[i] < minK)\\n            start = i + 1;\\n        if(nums[i] == maxK)\\n            lastmaxK = i;\\n        if(nums[i] == minK)\\n            lastminK = i;\\n\\n        int pos = fmin(lastmaxK, lastminK);\\n        if(start > pos)\\n            continue;\\n        ans += pos - start + 1 ;\\n    }\\n    return ans;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nlong long countSubarrays(int* nums, int numsSize, int minK, int maxK){\\n\\n    long long ans = 0;\\n    int lastminK = -1, lastmaxK = -1;\\n    int start = 0;\\n    for(int i = 0; i < numsSize; i++){\\n        if(nums[i] > maxK || nums[i] < minK)\\n            start = i + 1;\\n        if(nums[i] == maxK)\\n            lastmaxK = i;\\n        if(nums[i] == minK)\\n            lastminK = i;\\n\\n        int pos = fmin(lastmaxK, lastminK);\\n        if(start > pos)\\n            continue;\\n        ans += pos - start + 1 ;\\n    }\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2713166,
                "title": "c-easytounderstandconcisesol",
                "content": "Approach:for each occurence of mink and maxk simultaneouly count the occurence of all element in range of mink and maxk all those would give a count of subarray\\nmaxptr is index of maxk and minptr is presence of mink\\n\\nif(PresenceOfMin & PresenceOfMax)\\ncnt+=(min(MaxPtr,MinPtr)-btwMinMax+1);![image](https://assets.leetcode.com/users/images/7ce59385-e168-407c-84f2-fec57e978e78_1665992124.9654012.png)\\n\\nCode:\\n\\n  long long countSubarrays(vector<int>& a, int mink, int maxk) {\\n        \\n        int btwMinMax=0,MinPtr=0,MaxPtr=0;\\n        bool PresenceOfMin=false,PresenceOfMax=false;\\n        long long int cnt=0;\\n        for(int i=0;i<a.size();i++)\\n        {\\n            if(a[i]<mink || a[i]>maxk )\\n            {\\n                btwMinMax=i+1;\\n                PresenceOfMax=false;\\n                PresenceOfMin=false;\\n            }\\n            if(a[i]==mink)\\n            {\\n                MinPtr=i;\\n                PresenceOfMin=true;\\n            }\\n            if(a[i]==maxk)\\n            {\\n                MaxPtr=i;\\n                PresenceOfMax=true;\\n            }\\n            if(PresenceOfMin & PresenceOfMax)\\n            {\\n                cnt+=(min(MaxPtr,MinPtr)-btwMinMax+1);\\n            }\\n        }\\n        \\n        return cnt;\\n       \\n    }\\n\\n\\n",
                "solutionTags": [],
                "code": "Approach:for each occurence of mink and maxk simultaneouly count the occurence of all element in range of mink and maxk all those would give a count of subarray\\nmaxptr is index of maxk and minptr is presence of mink\\n\\nif(PresenceOfMin & PresenceOfMax)\\ncnt+=(min(MaxPtr,MinPtr)-btwMinMax+1);![image](https://assets.leetcode.com/users/images/7ce59385-e168-407c-84f2-fec57e978e78_1665992124.9654012.png)\\n\\nCode:\\n\\n  long long countSubarrays(vector<int>& a, int mink, int maxk) {\\n        \\n        int btwMinMax=0,MinPtr=0,MaxPtr=0;\\n        bool PresenceOfMin=false,PresenceOfMax=false;\\n        long long int cnt=0;\\n        for(int i=0;i<a.size();i++)\\n        {\\n            if(a[i]<mink || a[i]>maxk )\\n            {\\n                btwMinMax=i+1;\\n                PresenceOfMax=false;\\n                PresenceOfMin=false;\\n            }\\n            if(a[i]==mink)\\n            {\\n                MinPtr=i;\\n                PresenceOfMin=true;\\n            }\\n            if(a[i]==maxk)\\n            {\\n                MaxPtr=i;\\n                PresenceOfMax=true;\\n            }\\n            if(PresenceOfMin & PresenceOfMax)\\n            {\\n                cnt+=(min(MaxPtr,MinPtr)-btwMinMax+1);\\n            }\\n        }\\n        \\n        return cnt;\\n       \\n    }\\n\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2711652,
                "title": "simple-o-n-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n        int j = 0;\\n        int prevMaxIdx = -1, prevMinIdx = -1;\\n        int n = nums.size();\\n        long long res = 0;\\n        for(int i=0;i<n;++i){\\n            if(nums[i]>maxK or nums[i]<minK){\\n                prevMaxIdx = -1;\\n                prevMinIdx = -1;\\n                j = i+1;\\n            }\\n            else{\\n                if(nums[i]==minK and nums[i]==maxK){\\n                    res+= (i - j+1);\\n                    prevMaxIdx = prevMinIdx = i;\\n                }\\n                else if(nums[i]==minK){\\n                    if(prevMaxIdx!=-1)res+= (prevMaxIdx-j+1);\\n                    prevMinIdx = i;\\n                }\\n                else if(nums[i]==maxK){\\n                    if(prevMinIdx!=-1)res+= (prevMinIdx - j+1);\\n                    prevMaxIdx = i;\\n                }\\n                else{\\n                    if(prevMinIdx!=-1 and prevMaxIdx!=-1){\\n                        res+= (min(prevMinIdx,prevMaxIdx) - j+1);\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n// [9,9,2,3,1,5,5,7,5]\\n```",
                "solutionTags": [
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n        int j = 0;\\n        int prevMaxIdx = -1, prevMinIdx = -1;\\n        int n = nums.size();\\n        long long res = 0;\\n        for(int i=0;i<n;++i){\\n            if(nums[i]>maxK or nums[i]<minK){\\n                prevMaxIdx = -1;\\n                prevMinIdx = -1;\\n                j = i+1;\\n            }\\n            else{\\n                if(nums[i]==minK and nums[i]==maxK){\\n                    res+= (i - j+1);\\n                    prevMaxIdx = prevMinIdx = i;\\n                }\\n                else if(nums[i]==minK){\\n                    if(prevMaxIdx!=-1)res+= (prevMaxIdx-j+1);\\n                    prevMinIdx = i;\\n                }\\n                else if(nums[i]==maxK){\\n                    if(prevMinIdx!=-1)res+= (prevMinIdx - j+1);\\n                    prevMaxIdx = i;\\n                }\\n                else{\\n                    if(prevMinIdx!=-1 and prevMaxIdx!=-1){\\n                        res+= (min(prevMinIdx,prevMaxIdx) - j+1);\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n// [9,9,2,3,1,5,5,7,5]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2710393,
                "title": "java-solution-sliding-window",
                "content": "### **Please Upvote** :D\\n```\\nclass Solution {\\n    public long countSubarrays(int[] nums, int minK, int maxK) {\\n        long ans = 0;\\n        \\n        int minIdx = -1, maxIdx = -1;\\n        int start = 0;\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] < minK || nums[i] > maxK) {\\n                minIdx = maxIdx = -1;\\n                start = i + 1;\\n            } \\n            \\n            if (nums[i] == minK) minIdx = i;\\n            if (nums[i] == maxK) maxIdx = i;\\n            \\n            ans += Math.max(0, Math.min(minIdx, maxIdx) - start + 1);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public long countSubarrays(int[] nums, int minK, int maxK) {\\n        long ans = 0;\\n        \\n        int minIdx = -1, maxIdx = -1;\\n        int start = 0;\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] < minK || nums[i] > maxK) {\\n                minIdx = maxIdx = -1;\\n                start = i + 1;\\n            } \\n            \\n            if (nums[i] == minK) minIdx = i;\\n            if (nums[i] == maxK) maxIdx = i;\\n            \\n            ans += Math.max(0, Math.min(minIdx, maxIdx) - start + 1);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2709052,
                "title": "explained-easy-generic-approach",
                "content": "To solve these type of problems we can follow below approach\\n\\nleft pointer will have the left index from where everything is ok\\nmaxIndex_1,maxIndex_2\\u2026.maxIndex_n will have rightmost position where respective conditions like 1,2\\u2026n are satisfied \\nNow we can take a valid range starting from left and ending at min(maxIndex_1,maxIndex_2, ..., maxIndex_n)\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} minK\\n * @param {number} maxK\\n * @return {number}\\n */\\nvar countSubarrays = function(nums, minK, maxK) {\\n    let left=0,right,maxIndex_forMin=-1,maxIndex_forMax=-1,count=0;\\n    for(let right=0;right<nums.length;right++){\\n        if(nums[right]===minK){\\n            maxIndex_forMin = right;\\n        }\\n        if(nums[right]===maxK){\\n            maxIndex_forMax = right;\\n        }\\n        if(nums[right]<minK || nums[right]>maxK){\\n            left = right+1;\\n            maxIndex_forMin=-1;\\n            maxIndex_forMax=-1;\\n        }\\n        if(left<=right && maxIndex_forMin!==-1 && maxIndex_forMax!==-1){\\n            count += (Math.min(maxIndex_forMin,maxIndex_forMax)-left+1);    \\n        }\\n    }\\n    return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} minK\\n * @param {number} maxK\\n * @return {number}\\n */\\nvar countSubarrays = function(nums, minK, maxK) {\\n    let left=0,right,maxIndex_forMin=-1,maxIndex_forMax=-1,count=0;\\n    for(let right=0;right<nums.length;right++){\\n        if(nums[right]===minK){\\n            maxIndex_forMin = right;\\n        }\\n        if(nums[right]===maxK){\\n            maxIndex_forMax = right;\\n        }\\n        if(nums[right]<minK || nums[right]>maxK){\\n            left = right+1;\\n            maxIndex_forMin=-1;\\n            maxIndex_forMax=-1;\\n        }\\n        if(left<=right && maxIndex_forMin!==-1 && maxIndex_forMax!==-1){\\n            count += (Math.min(maxIndex_forMin,maxIndex_forMax)-left+1);    \\n        }\\n    }\\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2708125,
                "title": "elegant-o-n-solution-c-with-a-detailed-explanation",
                "content": "```\\n#define ll long long\\n\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n        /*\\n        let\\n            event P = \"all the element x is included in the range of [minK, maxK]\"\\n            event Q = \"at least one minK is included\"\\n            event R = \"at least one maxK is included\".\\n\\n        Obviously,\\n            subarray\\'s set =  event(P & Q & R)\\n\\n        By inclusion\\u2013exclusion principle,\\n            event(P & Q & R) = event(P & Q & R) - event(P & ~Q & R) - event(P & Q & ~R) + event(P & ~Q & ~R)\\n        \\n        Here,\\n            event(P & Q & R)   = \"all the element x is included in the range of [minK, maxK]\"\\n            event(P & ~Q & R)  = \"all the element x is included in the range of (minK, maxK]\"\\n            event(P & Q & ~R)  = \"all the element x is included in the range of [minK, maxK)\"\\n            event(P & ~Q & ~R) = \"all the element x is included in the range of (minK, maxK)\"\\n            \\n        each event\\'s size can be computed in linear time (see the code below).\\n        \\n        Time Compiexity       : O(n)\\n        Extra Space Complexity: O(1)\\n        */\\n\\n        ll ans = count_ways(nums, minK, maxK);\\n        ans -= count_ways(nums, minK + 1, maxK);\\n        ans -= count_ways(nums, minK, maxK - 1);\\n        ans += count_ways(nums, minK + 1, maxK - 1);\\n        return ans;\\n    }\\n\\n    long long count_ways(vector<int> & nums, int L, int R){\\n        //return the number of subarrays of which all the element x is included in the range of [L, R].\\n\\n        ll res = 0;\\n        for (int i = 0, s = 0; i < nums.size(); i++){\\n            if (!(L <= nums[i] && nums[i] <= R)){\\n                s = 0;\\n            }else{\\n                s++;\\n            }\\n            res += s;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define ll long long\\n\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n        /*\\n        let\\n            event P = \"all the element x is included in the range of [minK, maxK]\"\\n            event Q = \"at least one minK is included\"\\n            event R = \"at least one maxK is included\".\\n\\n        Obviously,\\n            subarray\\'s set =  event(P & Q & R)\\n\\n        By inclusion\\u2013exclusion principle,\\n            event(P & Q & R) = event(P & Q & R) - event(P & ~Q & R) - event(P & Q & ~R) + event(P & ~Q & ~R)\\n        \\n        Here,\\n            event(P & Q & R)   = \"all the element x is included in the range of [minK, maxK]\"\\n            event(P & ~Q & R)  = \"all the element x is included in the range of (minK, maxK]\"\\n            event(P & Q & ~R)  = \"all the element x is included in the range of [minK, maxK)\"\\n            event(P & ~Q & ~R) = \"all the element x is included in the range of (minK, maxK)\"\\n            \\n        each event\\'s size can be computed in linear time (see the code below).\\n        \\n        Time Compiexity       : O(n)\\n        Extra Space Complexity: O(1)\\n        */\\n\\n        ll ans = count_ways(nums, minK, maxK);\\n        ans -= count_ways(nums, minK + 1, maxK);\\n        ans -= count_ways(nums, minK, maxK - 1);\\n        ans += count_ways(nums, minK + 1, maxK - 1);\\n        return ans;\\n    }\\n\\n    long long count_ways(vector<int> & nums, int L, int R){\\n        //return the number of subarrays of which all the element x is included in the range of [L, R].\\n\\n        ll res = 0;\\n        for (int i = 0, s = 0; i < nums.size(); i++){\\n            if (!(L <= nums[i] && nums[i] <= R)){\\n                s = 0;\\n            }else{\\n                s++;\\n            }\\n            res += s;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2708082,
                "title": "easy-detailed-explanation-with-clean-code",
                "content": "Take the ranges of the subarrays that does not contain minK or maxK. \\n\\nExample: [1,3,5,2,7,5] , minK = 1, maxK = 5\\n\\nThe ranges will be [1,3,5,2] [5]\\n\\n\\nAnother Example: [1,3,5,2,5] , minK = 1, maxK = 5\\n\\nThe ranges will be [1,3,5,2,5]\\n\\n\\nAnother Example: [5,3,7,1,7,2,3,1,4,5,8,6], minK = 2, maxK = 7\\n\\nThe ranges will be [5,3,7] [7,2,3] [4,5] [6]\\n\\n\\nThen we have to check how much subarrays are possible in this range only. There can\\u2019t be a subarray outside this range, because some element will be there lesser than minK or greater than maxK in between this range and next range.\\n\\nIn this range, traverse through all values and find how subarrays will come.\\n\\nThere are 3 cases:\\n\\n* current element equal to minK - find closest right index that corresponds to maxK. \\n\\nLets say closest right index that corresponds to maxK be 10 and this range last element index be 23. Then 23-10+1=14 subarrays are possible with this current element\\n\\n\\n* current element equal to maxK - find closest right index that corresponds to minK. \\n\\n\\n* current element is neither minK nor maxK. find closest right index that corresponds to maxK and  also find closest right index that corresponds to minK. Choose the farthest index and count the subarrays\\n\\n\\nIF ANY DOUBT COMMENT\\n\\n```\\nclass Solution {\\npublic:\\n    long long solve(int l, int r, vector<int>& nums, int minK, int maxK)\\n    {\\n        vector<int> min_idx,max_idx;\\n        for(int i=l;i<=r;i++)\\n        {\\n            if(nums[i]==minK)\\n            {\\n                min_idx.push_back(i);\\n            }\\n            if(nums[i]==maxK)\\n            {\\n                max_idx.push_back(i);\\n            }\\n        }\\n        long long int ans=0;\\n        for(int i=l;i<=r;i++)\\n        {\\n            if(nums[i]==minK)\\n            {\\n                int index=lower_bound(max_idx.begin(),max_idx.end(),i)-max_idx.begin();\\n                if(index==max_idx.size())\\n                {\\n                    continue;\\n                }\\n                long long int val=r-max_idx[index]+1;\\n                ans+=val;\\n            }\\n            else if(nums[i]==maxK)\\n            {\\n                int index=lower_bound(min_idx.begin(),min_idx.end(),i)-min_idx.begin();\\n                if(index==min_idx.size())\\n                {\\n                    continue;\\n                }\\n                long long int val=r-min_idx[index]+1;\\n                ans+=val;\\n            }\\n            else\\n            {\\n                int first=lower_bound(min_idx.begin(),min_idx.end(),i)-min_idx.begin();\\n                int second=lower_bound(max_idx.begin(),max_idx.end(),i)-max_idx.begin();\\n                if(first==min_idx.size() || second==max_idx.size())\\n                {\\n                    continue;\\n                }\\n                int index=max(min_idx[first],max_idx[second]);\\n                long long int val=r-index+1;\\n                ans+=val;\\n            }\\n        }\\n        return ans;\\n    }\\n    long long countSubarrays(vector<int>& nums, int minK, int maxK) \\n    {\\n        long long int ans=0;\\n        int left=0;\\n        vector<pair<int,int>> range;\\n        for(int right=0;right<nums.size();right++)\\n        {\\n            if(nums[right]<minK || nums[right]>maxK)\\n            {\\n                if(right-1>=left)\\n                {\\n                    range.push_back({left,right-1});\\n                }\\n                left=right+1;\\n            }\\n        }\\n        if(left!=nums.size())\\n        {\\n            if(nums.size()-1>=left)\\n            {\\n                range.push_back({left,nums.size()-1});\\n            }\\n        }\\n        for(int i=0;i<range.size();i++)\\n        {\\n            ans+=solve(range[i].first,range[i].second,nums,minK,maxK);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long solve(int l, int r, vector<int>& nums, int minK, int maxK)\\n    {\\n        vector<int> min_idx,max_idx;\\n        for(int i=l;i<=r;i++)\\n        {\\n            if(nums[i]==minK)\\n            {\\n                min_idx.push_back(i);\\n            }\\n            if(nums[i]==maxK)\\n            {\\n                max_idx.push_back(i);\\n            }\\n        }\\n        long long int ans=0;\\n        for(int i=l;i<=r;i++)\\n        {\\n            if(nums[i]==minK)\\n            {\\n                int index=lower_bound(max_idx.begin(),max_idx.end(),i)-max_idx.begin();\\n                if(index==max_idx.size())\\n                {\\n                    continue;\\n                }\\n                long long int val=r-max_idx[index]+1;\\n                ans+=val;\\n            }\\n            else if(nums[i]==maxK)\\n            {\\n                int index=lower_bound(min_idx.begin(),min_idx.end(),i)-min_idx.begin();\\n                if(index==min_idx.size())\\n                {\\n                    continue;\\n                }\\n                long long int val=r-min_idx[index]+1;\\n                ans+=val;\\n            }\\n            else\\n            {\\n                int first=lower_bound(min_idx.begin(),min_idx.end(),i)-min_idx.begin();\\n                int second=lower_bound(max_idx.begin(),max_idx.end(),i)-max_idx.begin();\\n                if(first==min_idx.size() || second==max_idx.size())\\n                {\\n                    continue;\\n                }\\n                int index=max(min_idx[first],max_idx[second]);\\n                long long int val=r-index+1;\\n                ans+=val;\\n            }\\n        }\\n        return ans;\\n    }\\n    long long countSubarrays(vector<int>& nums, int minK, int maxK) \\n    {\\n        long long int ans=0;\\n        int left=0;\\n        vector<pair<int,int>> range;\\n        for(int right=0;right<nums.size();right++)\\n        {\\n            if(nums[right]<minK || nums[right]>maxK)\\n            {\\n                if(right-1>=left)\\n                {\\n                    range.push_back({left,right-1});\\n                }\\n                left=right+1;\\n            }\\n        }\\n        if(left!=nums.size())\\n        {\\n            if(nums.size()-1>=left)\\n            {\\n                range.push_back({left,nums.size()-1});\\n            }\\n        }\\n        for(int i=0;i<range.size();i++)\\n        {\\n            ans+=solve(range[i].first,range[i].second,nums,minK,maxK);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2708065,
                "title": "o-nlogn-using-sliding-window-and-updating-min-max-map-examples",
                "content": "**Main Idea**:\\n+ Sliding window with first = [0, n-1], and expanding last = [first, n-1] where nums[last]>=minK and nums[last]<=maxK\\n+ Maintaining position of min, max of the sliding window\\n+ Updating ans <- ans + (last - max(pos min, posmax) + 1) at every sliding window\\n\\n**Examples**:\\n```\\nmin/maxK, nums:  1 5 [1, 3, 5, 2, 7, 5]\\npmin/max, last, d, ans:  [0] [2] 3 2 2\\npmin/max, last, d, ans:  [] [2] 3 0 2\\npmin/max, last, d, ans:  [] [2] 3 0 2\\npmin/max, last, d, ans:  [] [] 3 0 2\\npmin/max, last, d, ans:  [] [5] 5 0 2\\nans:  2\\n==================== \\n\\nmin/maxK, nums:  1 1 [1, 1, 1, 1]\\npmin/max, last, d, ans:  [0, 1, 2, 3] [0, 1, 2, 3] 3 4 4\\npmin/max, last, d, ans:  [1, 2, 3] [1, 2, 3] 3 3 7\\npmin/max, last, d, ans:  [2, 3] [2, 3] 3 2 9\\npmin/max, last, d, ans:  [3] [3] 3 1 10\\nans:  10\\n==================== \\n```\\n\\n**Code**:\\n```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], minK: int, maxK: int) -> int:\\n        print(\"min/maxK, nums: \", minK, maxK, nums)\\n        n = len(nums)\\n        pmin, pmax = SortedList([]), SortedList([])\\n        ans = 0\\n        last = -1\\n        for i in range(n):\\n            if nums[i]>=minK and nums[i]<=maxK:\\n                if last<i:\\n                    last = i\\n                    pmin.clear()\\n                    pmax.clear()\\n                    if nums[i]==minK:\\n                        pmin.add(i)\\n                    if nums[i]==maxK:\\n                        pmax.add(i)\\n                while last+1<n and nums[last+1]>=minK and nums[last+1]<=maxK:\\n                    if nums[last+1]==minK:\\n                        pmin.add(last+1)\\n                    if nums[last+1]==maxK:\\n                        pmax.add(last+1)\\n                    last = last + 1\\n                \\n                d = 0\\n                if len(pmin)>0 and len(pmax)>0:\\n                    d = last - max(pmin[0], pmax[0]) + 1\\n                ans = ans + d\\n                print(\"pmin/max, last, d, ans: \", list(pmin), list(pmax), last, d, ans)\\n                if nums[i]==minK:\\n                    pmin.discard(i)\\n                if nums[i]==maxK:\\n                    pmax.discard(i)\\n            else:\\n                last = -1\\n            pass\\n        print(\"ans: \", ans)\\n        print(\"=\" * 20, \"\\\\n\")\\n        \\n        return ans\\n    \\nprint = lambda *a, **aa: ()\\n```",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "```\\nmin/maxK, nums:  1 5 [1, 3, 5, 2, 7, 5]\\npmin/max, last, d, ans:  [0] [2] 3 2 2\\npmin/max, last, d, ans:  [] [2] 3 0 2\\npmin/max, last, d, ans:  [] [2] 3 0 2\\npmin/max, last, d, ans:  [] [] 3 0 2\\npmin/max, last, d, ans:  [] [5] 5 0 2\\nans:  2\\n==================== \\n\\nmin/maxK, nums:  1 1 [1, 1, 1, 1]\\npmin/max, last, d, ans:  [0, 1, 2, 3] [0, 1, 2, 3] 3 4 4\\npmin/max, last, d, ans:  [1, 2, 3] [1, 2, 3] 3 3 7\\npmin/max, last, d, ans:  [2, 3] [2, 3] 3 2 9\\npmin/max, last, d, ans:  [3] [3] 3 1 10\\nans:  10\\n==================== \\n```\n```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], minK: int, maxK: int) -> int:\\n        print(\"min/maxK, nums: \", minK, maxK, nums)\\n        n = len(nums)\\n        pmin, pmax = SortedList([]), SortedList([])\\n        ans = 0\\n        last = -1\\n        for i in range(n):\\n            if nums[i]>=minK and nums[i]<=maxK:\\n                if last<i:\\n                    last = i\\n                    pmin.clear()\\n                    pmax.clear()\\n                    if nums[i]==minK:\\n                        pmin.add(i)\\n                    if nums[i]==maxK:\\n                        pmax.add(i)\\n                while last+1<n and nums[last+1]>=minK and nums[last+1]<=maxK:\\n                    if nums[last+1]==minK:\\n                        pmin.add(last+1)\\n                    if nums[last+1]==maxK:\\n                        pmax.add(last+1)\\n                    last = last + 1\\n                \\n                d = 0\\n                if len(pmin)>0 and len(pmax)>0:\\n                    d = last - max(pmin[0], pmax[0]) + 1\\n                ans = ans + d\\n                print(\"pmin/max, last, d, ans: \", list(pmin), list(pmax), last, d, ans)\\n                if nums[i]==minK:\\n                    pmin.discard(i)\\n                if nums[i]==maxK:\\n                    pmax.discard(i)\\n            else:\\n                last = -1\\n            pass\\n        print(\"ans: \", ans)\\n        print(\"=\" * 20, \"\\\\n\")\\n        \\n        return ans\\n    \\nprint = lambda *a, **aa: ()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2707991,
                "title": "c-std-set-o-n-logn",
                "content": "**The idea is straightforward: For each index, count the number of subarray using it as the starting index. Sum it up and get the final result.**\\n\\nMore Details:\\n1. Use three std::set to store the array indices of minK, maxK, out-of-range numbers, respectively\\n2. Iterate through each index, find the three indices above that are closest to its right.\\n3. Find the start_idx (included) and end_idx (excluded), where `start_idx = max(min_idx, max_idx)` , and `end_idx = block_idx` \\n4. Update the total subarray count: `total_count += max(end_idx - start_idx, 0)`\\n\\nTime Complexity: O(N * logN)\\nSpace Complexity: O(N)\\n\\n```\\nclass Solution {\\npublic:\\n    using ll = long long;\\n    \\n    long long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n        const int n = nums.size();\\n        set<int> block_idx;\\n        set<int> min_idx;\\n        set<int> max_idx;\\n        for(int i=0;i<n;++i){\\n            if(nums[i] < minK || nums[i] > maxK){\\n                block_idx.insert(i);\\n            }\\n            if(nums[i] == minK){\\n                min_idx.insert(i);\\n            }\\n            if(nums[i] == maxK){\\n                max_idx.insert(i);\\n            }\\n        }\\n        if(min_idx.empty() || max_idx.empty()){\\n            return 0;\\n        }\\n        // block_idx.insert(-1);\\n        block_idx.insert(n);\\n        ll result = 0;\\n        for(int i=0;i<n;++i){\\n            auto it_min = min_idx.lower_bound(i);\\n            if(it_min == min_idx.end()){\\n                continue;\\n            }\\n            auto it_max = max_idx.lower_bound(i);\\n            if(it_max == max_idx.end()){\\n                continue;\\n            }\\n            int start_i = max(*it_min, *it_max);\\n            auto it_block = block_idx.lower_bound(i);\\n            int end_i = *it_block;\\n            result += ll(max(end_i - start_i, 0));\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    using ll = long long;\\n    \\n    long long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n        const int n = nums.size();\\n        set<int> block_idx;\\n        set<int> min_idx;\\n        set<int> max_idx;\\n        for(int i=0;i<n;++i){\\n            if(nums[i] < minK || nums[i] > maxK){\\n                block_idx.insert(i);\\n            }\\n            if(nums[i] == minK){\\n                min_idx.insert(i);\\n            }\\n            if(nums[i] == maxK){\\n                max_idx.insert(i);\\n            }\\n        }\\n        if(min_idx.empty() || max_idx.empty()){\\n            return 0;\\n        }\\n        // block_idx.insert(-1);\\n        block_idx.insert(n);\\n        ll result = 0;\\n        for(int i=0;i<n;++i){\\n            auto it_min = min_idx.lower_bound(i);\\n            if(it_min == min_idx.end()){\\n                continue;\\n            }\\n            auto it_max = max_idx.lower_bound(i);\\n            if(it_max == max_idx.end()){\\n                continue;\\n            }\\n            int start_i = max(*it_min, *it_max);\\n            auto it_block = block_idx.lower_bound(i);\\n            int end_i = *it_block;\\n            result += ll(max(end_i - start_i, 0));\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2707989,
                "title": "super-easy-understanding-for-any-languages-o-n",
                "content": "\\n\\nsuppose we have an array [1, 5, 2, 3, 4, 1, 5] how many subarray has 1 and 5?\\n\\nif we begin with index 0, end index and be 1, 2, 3, 4 ,5, 6;\\nif we begin with index 1, end index and be 5, 6\\nso we can draw a table like\\n```\\n1, 5, 2, 3, 4, 1, 5\\nb  e  e  e  e  e  e\\n   b           e  e\\n      b           e\\n         b        e\\n            b     e \\n               b  e\\n```\\nthe number of e is the answer (12 in this example)\\n\\nhow do we get count of e for each b efficiently is key of this problem\\n\\nsuppose you stand at index 0 and look right, you seek for closest index of 5. if you can find 5, for subarray end with index of that 5 to end of whole array are all satisfied.\\n\\nmore generally, you need find closest index of 1 and index of 5 from right side, choose the larger one (so it contains both 1 and 5). and you know how many subarrays satisfied\\n\\nhow do we do it? we scan whole array from right to left. when you meet 1 or 5, we update the index value\\n\\n```\\nindex  0, 1  2  3  4  5  6  7 \\n       1, 5, 2, 3, 4, 1, 5,\\n--\\nidx1                        7\\nidx5                        7\\n--\\nidx1                     7  7\\nidx5                     6  7\\n--\\nidx1                  5  7  7\\nidx5                  6  6  7\\n--\\nidx1         5  5  5  5  7  7\\nidx5         6  6  6  6  6  7\\n--\\nidx1      5  5  5  5  5  7  7\\nidx5      1  6  6  6  6  6  7\\n--\\nidx1   0  5  5  5  5  5  7  7\\nidx5   1  1  6  6  6  6  6  7\\n```\\nnow, for each index i, the number of satisfied subarray starting with index i is `n - max(idx1, idx5)`\\n\\nbut back to this question, how about number greater than 5 and less than 1? the easiest way is that you consider them as a spliter of whole array, and you just need count each subarray splitting by these values and summarize each result;\\n\\nmy code still needs some small tweaks for more efficient, but it is good enough to pass contest.\\n\\n```\\nclass Solution {\\npublic:\\n  long long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n    vector<int> buf;\\n    int64_t res = 0;\\n    for (int i : nums) {\\n      if (i > maxK || i < minK) {\\n        res += h(buf, minK, maxK);\\n        buf.clear();\\n      } else {\\n        buf.push_back(i);\\n      }\\n    }\\n    res += h(buf, minK, maxK);\\n    return res;\\n  }\\n\\n  int64_t h(const vector<int>& nums, int minK, int maxK) {\\n    int n = nums.size();\\n    vector<pair<int, int>> right(n + 1, make_pair(n, n));\\n    for (int i = n - 1; i >= 0; --i) {\\n      right[i].first = right[i + 1].first;\\n      right[i].second = right[i + 1].second;\\n      if (nums[i] == minK) right[i].first = i;\\n      if (nums[i] == maxK) right[i].second = i;\\n    }\\n    int64_t res = 0;\\n    for (int i = 0; i < n; ++i) {\\n      res += n - max(right[i].first, right[i].second);\\n    }\\n    return res;\\n  }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\n1, 5, 2, 3, 4, 1, 5\\nb  e  e  e  e  e  e\\n   b           e  e\\n      b           e\\n         b        e\\n            b     e \\n               b  e\\n```\n```\\nindex  0, 1  2  3  4  5  6  7 \\n       1, 5, 2, 3, 4, 1, 5,\\n--\\nidx1                        7\\nidx5                        7\\n--\\nidx1                     7  7\\nidx5                     6  7\\n--\\nidx1                  5  7  7\\nidx5                  6  6  7\\n--\\nidx1         5  5  5  5  7  7\\nidx5         6  6  6  6  6  7\\n--\\nidx1      5  5  5  5  5  7  7\\nidx5      1  6  6  6  6  6  7\\n--\\nidx1   0  5  5  5  5  5  7  7\\nidx5   1  1  6  6  6  6  6  7\\n```\n```\\nclass Solution {\\npublic:\\n  long long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n    vector<int> buf;\\n    int64_t res = 0;\\n    for (int i : nums) {\\n      if (i > maxK || i < minK) {\\n        res += h(buf, minK, maxK);\\n        buf.clear();\\n      } else {\\n        buf.push_back(i);\\n      }\\n    }\\n    res += h(buf, minK, maxK);\\n    return res;\\n  }\\n\\n  int64_t h(const vector<int>& nums, int minK, int maxK) {\\n    int n = nums.size();\\n    vector<pair<int, int>> right(n + 1, make_pair(n, n));\\n    for (int i = n - 1; i >= 0; --i) {\\n      right[i].first = right[i + 1].first;\\n      right[i].second = right[i + 1].second;\\n      if (nums[i] == minK) right[i].first = i;\\n      if (nums[i] == maxK) right[i].second = i;\\n    }\\n    int64_t res = 0;\\n    for (int i = 0; i < n; ++i) {\\n      res += n - max(right[i].first, right[i].second);\\n    }\\n    return res;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3273268,
                "title": "hard-easy-with-clear-explaination",
                "content": "# Intuition\\nWe can use a sliding window approach to find all subarrays with minimum value minK and maximum value maxK. We can keep track of the culprit index of the current subarray and update it whenever we encounter a value that is less than minK or greater than maxK.\\nWhen we find a subarray with both minK and maxK, we can count the number of subarrays that can be formed by taking the minimum index of minK and maxK as the starting point and the current index as the ending point.\\n\\n# Approach\\n- Initialise mini as -1 (To store index of minK) and maxi=-1(To store index of maxK) and culp=-1(To store index of the element which is either less than minK or greater than maxK).\\n- For each i we will find out number of subarrays ending at i, which satisfies our condition and add it to our ans.\\n- We will do min(mini,max) - culp. If this value is negative then it means that culprit index lies between minIndex and maxIndex. SO we cant have any subarray ending at ith index at this point.\\n- If min(mini,max) - culp >0 then this will be the number of subarrays with the given condition ending at ith index. We will add it to our ans.\\n- **Eg for above case** [7,3,3,4,2,1,5]. minK=2 maxk=5.\\nSo we have these 4 subarrays as ans. ->{3,3,4,2,1,5}{3,4,2,1,5}{4,2,1,5}{2,1,5}\\n  So 1 subarray would be from miniInd to maxInd and then We will keep reducing the minInd by 1 until we encounter the culprit. culp=0 min(minInd,maxInd)=4. Ans =4. Hence proved with example.\\n# Complexity\\n- **Time complexity**:\\nWe are traversing the nums vector only once. TC O(n)\\n\\n- **Space complexity**:\\nWe are notutilising any extra space. SC O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n        int mini=-1;\\n        int maxi=-1;\\n        int culp=-1;\\n        long long ans=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]==minK)mini=i;\\n            if(nums[i]==maxK)maxi=i;\\n            if(nums[i]<minK or nums[i]>maxK)culp=i;\\n\\n            int temp= min(mini,maxi)-culp;\\n            if(temp>0)\\n                ans+=temp;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n        int mini=-1;\\n        int maxi=-1;\\n        int culp=-1;\\n        long long ans=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]==minK)mini=i;\\n            if(nums[i]==maxK)maxi=i;\\n            if(nums[i]<minK or nums[i]>maxK)culp=i;\\n\\n            int temp= min(mini,maxi)-culp;\\n            if(temp>0)\\n                ans+=temp;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3267582,
                "title": "video-explanataion-how-to-approach-leetcode-hard-problems-like-this-how-to-develop-approach",
                "content": "Here is video explanation in Hindi,[https://youtu.be/YYimOxJiu3k]()\\n\\n# Intuition\\n This is a good problem to check your two pointer skills ,\\n Here we want a O(n) or O(n log n) solution ,\\n - O(**n**) -- > give us **hint** at **greedy** and **two pointer**\\n - O(**n log n**) --> give us **hint** at **Binary search** or **sorting** , but how can we use binary serach ? There is no way we can use binary serach here .Similarly **ordering cannot** be **change** so **No** do **sorting** .\\n\\n- So We are left with O(n) solution , using two pointer or greedy way .\\n\\n* So if we are at **ith** index and **can** we find **number of Fixed Bound subarrays** **ending** at index **i** ?\\n\\n* *  First obervation we can have Fixed bound subarray if we have **(mxK and mnK)** present <= **i** \\n  * Similarly we maitain one **Start\\'**  which points to the **start** of valid **subarray** , where we have value in range [mnK,mxK] from[start , i]\\n                 . \\n  * Now we can have all from \\'x\\' to this index \\'i\\' such that \\'x\\' in in range **[start, bounday_index]** , \\n  * what is **bounday_index**? ,  it is the index **beyond which we dont** have **both** the **[ \\'mnK\\' and \\'mxK\\']**\\n                bounday_index is **last occurence** of **either** \\'mnK\\' or \\'mxK\\', beyond this we will loose one of mnK or mxK.   \\n  *  So for all index **i** we check if there is valid range , then we also find **boundary_index** and no of subarrays ending at \\'i\\'\\n                is **(boundary_index - start)**+1\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n* We need 5 variables \\n  * i. small_idx -- this stores the latest index of \\'mnK\\' ( largest_index <= i)\\n           ii. big_idx -- this stores the latest index of \\'mxK\\' ( largest index <= i)\\n          iii. cur_mn -- it stores the current minimum value in range from [start, i]\\n           iv. cur_mx --  it stores the current minimum value in range from [start, i]\\n            v. start -- it stores the starting index of valid range ( valid means all values should be in range mnK <= x <= mxK ) \\n            \\n* Now for each index , we if **start = -1**, it means we are looking for a range with valid value \\n* if at any index we have nums[i] == mn or nums[i] == mx , we update our **small_idx** and **big_idx**\\n* at any index if we have **start != -1** , and neither **small_idx** and **big_idx = -1**, this means we have a range where we already have\\n            \\'mnK\\' and \\'mxK\\' values . \\n* Now number of valid subarray ending at index \\'i\\' = (boundary_index - start)+1\\n            here **bounday index = min( small_idx, big_idx)** ,\\n            we add this to our answer.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, int mn, int mx) {\\n         \\n        long long ans = 0;\\n        /*\\n         --> We need 5 variables \\n            i. small_idx -- this stores the latest index of \\'mnK\\' ( largest_index <= i)\\n           ii. big_idx -- this stores the latest index of \\'mxK\\' ( largest index <= i)\\n          iii. cur_mn -- it stores the current minimum value in range from [start, i]\\n           iv. cur_mx --  it stores the current minimum value in range from [start, i]\\n            v. start -- it stores the starting index of valid range ( valid means all values should be in range mnK <= x <= mxK ) \\n\\n        */\\n        int small_idx = -1,big_idx = -1;\\n        int cur_mn = INT_MAX , cur_mx = 0;\\n        int start = -1;\\n\\n        int n = nums.size();\\n\\n        for(int i=0;i<n;++i){\\n            //this means we are looking for a value in range which could be \\n            //start index of our valid range\\n            if(start == -1){\\n\\n                //if current vlaue is in range [ mn <= nums[i] <= mx ]\\n                if(mn<=nums[i] && nums[i]<=mx){\\n                    //we update the current maximum and current minimum\\n                    cur_mn = nums[i];\\n                    cur_mx = nums[i];\\n                    //similarly updating the indexes too if current vlaue is [mn] or [mx]\\n                    if(nums[i] == mn)small_idx = i;\\n                    if(nums[i] == mx)big_idx = i;\\n                    start  = i;\\n                    \\n                    //if mx and mn are equal than this value is a valid range so we update ans\\n                    if(mx == mn)ans++;\\n                }\\n                 continue;\\n            }\\n            else{\\n                //here we have a start value and all values in [start , i-1] are in range (mn<=x && x<= mx)\\n                //thats why start is not -1\\n                //we are updating current maximum and current minimum value\\n                cur_mn = min(cur_mn,nums[i]);\\n                cur_mx = max(cur_mx,nums[i]);\\n                \\n                //if this vlaue is out of range it means we close our previous ragne \\n                //and again start serachin for valid one and make start = -1\\n                if(cur_mn<mn || cur_mx > mx){\\n                    start = -1;\\n                    small_idx = -1;\\n                    big_idx = -1;\\n                }\\n                else{\\n                    //if current vaulue is [mn]\\n                    if(nums[i] == mn){\\n                       //we will change smallidx\\n                       small_idx = i;\\n                       if(nums[i] == mx)big_idx = i;\\n\\n                       //if we already have [mn] in current range \\n                        //then number of valid subarray ending at \\'i\\'\\n                        // is min(small_idx,big_idx) - start + 1;\\n                       long long count = 0;\\n                       if(big_idx != -1){\\n                           count = min(small_idx,big_idx) - start;\\n                           count++;\\n                       }\\n                        ans += count;\\n                    }\\n                    else if(nums[i] == mx){\\n\\n                        //we will change big_idx \\n                        big_idx = i;\\n                        long long count = 0;\\n\\n                        //if we already have [mn] in current range \\n                        //then number of valid subarray ending at \\'i\\'\\n                        // is min(small_idx,big_idx) - start + 1;\\n                        if(small_idx != -1){\\n                            count = min(small_idx,big_idx) - start;\\n                            count++;\\n                         }\\n                        \\n                        ans += count;\\n                    }\\n                    else{\\n                        //how many subarray which will end at\\n                        //index i \\n                        //if we already have [mn] in current range \\n                        //then number of valid subarray ending at \\'i\\'\\n                        // is min(small_idx,big_idx) - start + 1;\\n                        if(small_idx!=-1 && big_idx != -1){\\n                            long long count = (min(small_idx,big_idx) - start)+1;\\n                            ans += count;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, int mn, int mx) {\\n         \\n        long long ans = 0;\\n        /*\\n         --> We need 5 variables \\n            i. small_idx -- this stores the latest index of \\'mnK\\' ( largest_index <= i)\\n           ii. big_idx -- this stores the latest index of \\'mxK\\' ( largest index <= i)\\n          iii. cur_mn -- it stores the current minimum value in range from [start, i]\\n           iv. cur_mx --  it stores the current minimum value in range from [start, i]\\n            v. start -- it stores the starting index of valid range ( valid means all values should be in range mnK <= x <= mxK ) \\n\\n        */\\n        int small_idx = -1,big_idx = -1;\\n        int cur_mn = INT_MAX , cur_mx = 0;\\n        int start = -1;\\n\\n        int n = nums.size();\\n\\n        for(int i=0;i<n;++i){\\n            //this means we are looking for a value in range which could be \\n            //start index of our valid range\\n            if(start == -1){\\n\\n                //if current vlaue is in range [ mn <= nums[i] <= mx ]\\n                if(mn<=nums[i] && nums[i]<=mx){\\n                    //we update the current maximum and current minimum\\n                    cur_mn = nums[i];\\n                    cur_mx = nums[i];\\n                    //similarly updating the indexes too if current vlaue is [mn] or [mx]\\n                    if(nums[i] == mn)small_idx = i;\\n                    if(nums[i] == mx)big_idx = i;\\n                    start  = i;\\n                    \\n                    //if mx and mn are equal than this value is a valid range so we update ans\\n                    if(mx == mn)ans++;\\n                }\\n                 continue;\\n            }\\n            else{\\n                //here we have a start value and all values in [start , i-1] are in range (mn<=x && x<= mx)\\n                //thats why start is not -1\\n                //we are updating current maximum and current minimum value\\n                cur_mn = min(cur_mn,nums[i]);\\n                cur_mx = max(cur_mx,nums[i]);\\n                \\n                //if this vlaue is out of range it means we close our previous ragne \\n                //and again start serachin for valid one and make start = -1\\n                if(cur_mn<mn || cur_mx > mx){\\n                    start = -1;\\n                    small_idx = -1;\\n                    big_idx = -1;\\n                }\\n                else{\\n                    //if current vaulue is [mn]\\n                    if(nums[i] == mn){\\n                       //we will change smallidx\\n                       small_idx = i;\\n                       if(nums[i] == mx)big_idx = i;\\n\\n                       //if we already have [mn] in current range \\n                        //then number of valid subarray ending at \\'i\\'\\n                        // is min(small_idx,big_idx) - start + 1;\\n                       long long count = 0;\\n                       if(big_idx != -1){\\n                           count = min(small_idx,big_idx) - start;\\n                           count++;\\n                       }\\n                        ans += count;\\n                    }\\n                    else if(nums[i] == mx){\\n\\n                        //we will change big_idx \\n                        big_idx = i;\\n                        long long count = 0;\\n\\n                        //if we already have [mn] in current range \\n                        //then number of valid subarray ending at \\'i\\'\\n                        // is min(small_idx,big_idx) - start + 1;\\n                        if(small_idx != -1){\\n                            count = min(small_idx,big_idx) - start;\\n                            count++;\\n                         }\\n                        \\n                        ans += count;\\n                    }\\n                    else{\\n                        //how many subarray which will end at\\n                        //index i \\n                        //if we already have [mn] in current range \\n                        //then number of valid subarray ending at \\'i\\'\\n                        // is min(small_idx,big_idx) - start + 1;\\n                        if(small_idx!=-1 && big_idx != -1){\\n                            long long count = (min(small_idx,big_idx) - start)+1;\\n                            ans += count;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3257349,
                "title": "effiecient-brute-force-counts-as-solved-arrive-at-the-solution-from-here-beats-10",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe add concept of breakpoints, that is elements greater than maxK or less than minK \"breaks\" the array into two parts, and if we start counting from left of a breakpoint, we cannot include any elements past it.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nfind breakpoints for all nums[i]. \\nThat is breakpoint[i] is the nearest breakpoint to the right of nums[i]\\nnums= 1 3 5 2 7 5\\nbreakpoints= 4 4 4 4 4 6\\nBrute Force as usual, but once the inner loop(j),has satisfied the condition , the number of elements you can include from j are j-breakpoints[j]. add this to total count and go to next i.\\n\\n# Example\\n        1 3 5 2 7 5\\n        break on elements > maxK or <minK\\n        1 3 5 2 |7| 5\\n        you cannot take left from index 5 or right from index 3.\\n        loop i from 0 to len(nums) \\n            j from i to len(nums)\\n        now 1 3 5 2 |7| 5\\n                ^\\n                |\\n        when j is at 5 we have satisfied condition.\\n        number of elements before breakpoint is the number of arrays\\n        we can form from here.\\n        so we find that and go to next i , without increasing j.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution(object):\\n    def countSubarrays(self, nums, minK, maxK):\\n        c=0\\n        breakpts=[len(nums)]*len(nums)\\n        breakpt=0\\n        #\\n        #to add breakpts, traverse:\\n        #if u find a breakpoint, make every elements before the most #recent breakpoint to have a breakpoint\\n            \\n        for i in range(0,len(nums)):\\n            if(nums[i]>maxK or nums[i]<minK):\\n                breakpts[breakpt:i+1]=[i]*(i+1-breakpt)\\n                breakpt=i\\n        print(breakpts)\\n        i=0\\n        while(i<len(nums)):\\n            mi=ma=nums[i]\\n            j=i\\n            while(j<len(nums)):\\n                mi,ma=min(mi,nums[j]),max(ma,nums[j])\\n                if(mi==minK and ma==maxK):\\n                    c+=(breakpts[j]-j)\\n                    break\\n                if(nums[j]>maxK or nums[j]<minK):\\n                    break\\n                j+=1\\n            i+=1\\n            if(j==len(nums)):\\n                return c\\n        return c\\n        \\'\\'\\'\\n        1 3 5 2 7 5\\n        break on elements > maxK or <minK\\n        1 3 5 2 |7| 5\\n        you cannot take left from 5 or right from 2.\\n        loop i from 0 and j from i to traverse.\\n        now 1 3 5 2 |7| 5\\n                ^\\n                |\\n        from 5 , number of elements before breakpoint is the number of arrays we can form.\\n        so we find that and go to next i , without increasing j.\\n        \\'\\'\\'\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def countSubarrays(self, nums, minK, maxK):\\n        c=0\\n        breakpts=[len(nums)]*len(nums)\\n        breakpt=0\\n        #\\n        #to add breakpts, traverse:\\n        #if u find a breakpoint, make every elements before the most #recent breakpoint to have a breakpoint\\n            \\n        for i in range(0,len(nums)):\\n            if(nums[i]>maxK or nums[i]<minK):\\n                breakpts[breakpt:i+1]=[i]*(i+1-breakpt)\\n                breakpt=i\\n        print(breakpts)\\n        i=0\\n        while(i<len(nums)):\\n            mi=ma=nums[i]\\n            j=i\\n            while(j<len(nums)):\\n                mi,ma=min(mi,nums[j]),max(ma,nums[j])\\n                if(mi==minK and ma==maxK):\\n                    c+=(breakpts[j]-j)\\n                    break\\n                if(nums[j]>maxK or nums[j]<minK):\\n                    break\\n                j+=1\\n            i+=1\\n            if(j==len(nums)):\\n                return c\\n        return c\\n        \\'\\'\\'\\n        1 3 5 2 7 5\\n        break on elements > maxK or <minK\\n        1 3 5 2 |7| 5\\n        you cannot take left from 5 or right from 2.\\n        loop i from 0 and j from i to traverse.\\n        now 1 3 5 2 |7| 5\\n                ^\\n                |\\n        from 5 , number of elements before breakpoint is the number of arrays we can form.\\n        so we find that and go to next i , without increasing j.\\n        \\'\\'\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3257230,
                "title": "simple-solution-with-hindi-comments-just-trying-new-things",
                "content": "# Intuition\\nSliding window\\n\\n# Approach\\nComment pdho ayega smjh\\n\\n# Complexity\\n- Time complexity:\\nEk hi for loop chl rha hai kya hoga khud hi socho na \\n\\n- Space complexity:\\nSingle variable use kiya hu bs \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n        long long ans = 0;\\n        int j = -1; //bhai ye hai starting index subarray ka\\n        int mini = -1; //bro this is index of minimum number jo minK se match krega\\n        int maxi = -1; //aur ye wala maximum jo match krega\\n        \\n        //ab chalao loop\\n        for(int i=0; i< nums.size(); i++) {\\n            //ab bhai minK se chhota koi hai ya maxK se bda koi hai, to aukaat k bhar hai\\n            if(nums[i] < minK || nums[i] > maxK) j = i;\\n            \\n            //bhai mil gya na mink k brabar koi to krona update\\n            if(nums[i] == minK) mini = i;\\n            \\n            //same upar vala if ka concept\\n            if(nums[i] == maxK) maxi = i;\\n            \\n            //calculate krona bhai\\n            ans += max(0, min(mini, maxi) - j);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n        long long ans = 0;\\n        int j = -1; //bhai ye hai starting index subarray ka\\n        int mini = -1; //bro this is index of minimum number jo minK se match krega\\n        int maxi = -1; //aur ye wala maximum jo match krega\\n        \\n        //ab chalao loop\\n        for(int i=0; i< nums.size(); i++) {\\n            //ab bhai minK se chhota koi hai ya maxK se bda koi hai, to aukaat k bhar hai\\n            if(nums[i] < minK || nums[i] > maxK) j = i;\\n            \\n            //bhai mil gya na mink k brabar koi to krona update\\n            if(nums[i] == minK) mini = i;\\n            \\n            //same upar vala if ka concept\\n            if(nums[i] == maxK) maxi = i;\\n            \\n            //calculate krona bhai\\n            ans += max(0, min(mini, maxi) - j);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3257173,
                "title": "keep-track-of-min-and-max-element-index-and-the-last-element-where-it-min-and-max-are-outof-bounds",
                "content": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& a, int mik, int mak) {\\n        \\n        \\n        long long int l,r,cnt,inv,re;\\n        cnt=re=0;\\n        l=r=inv=-1;\\n        int n = a.size();\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(a[i]>=mik && a[i]<=mak)\\n            {\\n                if(a[i] == mik) l=i;\\n                if(a[i] == mak) r=i;\\n                cnt+= max(re,min(l,r)-inv);\\n            }\\n            else\\n            {\\n                inv= i;\\n                l=r=-1;\\n            }\\n        }\\n        \\n        return cnt;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& a, int mik, int mak) {\\n        \\n        \\n        long long int l,r,cnt,inv,re;\\n        cnt=re=0;\\n        l=r=inv=-1;\\n        int n = a.size();\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(a[i]>=mik && a[i]<=mak)\\n            {\\n                if(a[i] == mik) l=i;\\n                if(a[i] == mak) r=i;\\n                cnt+= max(re,min(l,r)-inv);\\n            }\\n            else\\n            {\\n                inv= i;\\n                l=r=-1;\\n            }\\n        }\\n        \\n        return cnt;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3256405,
                "title": "reverse-select-beating-100-in-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCalculating the count of subarrays qualified is harder than calculating the opposite. Then do the opposite and subtract it from number of all possible subarrays.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWhenever there\\'s a value outside interval [minK, maxK], do a calculation as the previous part does not impact later anymore. \\nWithin each part, whenever there\\'s a value == minK or maxK, we calculate the number of subarrays not qualified. \\nIf minK == maxK, this corner case is even easier and we can take another measure. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], minK: int, maxK: int) -> int:\\n        \\n        nums.append(maxK + 1)\\n        n = len(nums)\\n        \\n        if minK == maxK: \\n            cnt = 0\\n            res = 0\\n            for i in range(n): \\n                num = nums[i]\\n                if num == minK: \\n                    cnt += 1\\n                else:\\n                    res += cnt * (cnt + 1) // 2\\n                    cnt = 0\\n            return res                    \\n        \\n        startidx = None\\n        prevminidx = None\\n        prevmaxidx = None\\n        offset = 0\\n        res = 0\\n        \\n        for i in range(n): \\n            num = nums[i]\\n            if num < minK or num > maxK: \\n                if prevminidx is not None and prevmaxidx is not None: \\n                    llast1 = (i - 1) - (max(prevminidx, prevmaxidx) + 1) + 1\\n                    llast2 = max(prevmaxidx, prevminidx) - (min(prevmaxidx, prevminidx) + 1) + 1\\n                    ltotal = (i - 1) - startidx + 1\\n                    offset += llast1 * (llast1 + 1) // 2 + llast1 * llast2\\n                    res += ltotal * (ltotal + 1) // 2 - offset\\n                startidx = None\\n                prevminidx = None\\n                prevmaxidx = None\\n                offset = 0  \\n                continue\\n            else: \\n                if startidx is None: \\n                    startidx = i\\n                if num == minK: \\n                    if prevminidx is None and prevmaxidx is None: \\n                        l = i - startidx + 1\\n                        offset += l * (l + 1) // 2\\n                    elif prevminidx is None: \\n                        l1 = i - (prevmaxidx + 1) + 1\\n                        l2 = prevmaxidx - startidx + 1\\n                        offset += l1 * (l1 + 1) // 2 + (l1 - 1) * l2\\n                    elif prevmaxidx is None:\\n                        l1 = i - (prevminidx + 1) + 1\\n                        l2 = prevminidx - startidx + 1\\n                        offset += l1 * (l1 + 1) // 2 + l1 * l2\\n                    else: \\n                        if prevmaxidx >= prevminidx: \\n                            l1 = i - (prevmaxidx + 1) + 1\\n                            l2 = prevmaxidx - (prevminidx + 1) + 1\\n                            offset += l1 * (l1 + 1) // 2 + (l1 - 1) * l2\\n                        else: \\n                            l1 = i - (prevminidx + 1) + 1\\n                            l2 = prevminidx - (prevmaxidx + 1) + 1\\n                            offset += l1 * (l1 + 1) // 2 + l1 * l2\\n                    prevminidx = i\\n                elif num == maxK: \\n                    if prevminidx is None and prevmaxidx is None: \\n                        l = i - startidx + 1\\n                        offset += l * (l + 1) // 2\\n                    elif prevmaxidx is None: \\n                        l1 = i - (prevminidx + 1) + 1\\n                        l2 = prevminidx - startidx + 1\\n                        offset += l1 * (l1 + 1) // 2 + (l1 - 1) * l2\\n                    elif prevminidx is None: \\n                        l1 = i - (prevmaxidx + 1) + 1\\n                        l2 = prevmaxidx - startidx + 1\\n                        offset += l1 * (l1 + 1) // 2 + l1 * l2\\n                    else: \\n                        if prevminidx >= prevmaxidx: \\n                            l1 = i - (prevminidx + 1) + 1\\n                            l2 = prevminidx - (prevmaxidx + 1) + 1\\n                            offset += l1 * (l1 + 1) // 2 + (l1 - 1) * l2\\n                        else: \\n                            l1 = i - (prevmaxidx + 1) + 1\\n                            l2 = prevmaxidx - (prevminidx + 1) + 1\\n                            offset += l1 * (l1 + 1) // 2 + l1 * l2\\n                    prevmaxidx = i \\n            \\n        return res            \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], minK: int, maxK: int) -> int:\\n        \\n        nums.append(maxK + 1)\\n        n = len(nums)\\n        \\n        if minK == maxK: \\n            cnt = 0\\n            res = 0\\n            for i in range(n): \\n                num = nums[i]\\n                if num == minK: \\n                    cnt += 1\\n                else:\\n                    res += cnt * (cnt + 1) // 2\\n                    cnt = 0\\n            return res                    \\n        \\n        startidx = None\\n        prevminidx = None\\n        prevmaxidx = None\\n        offset = 0\\n        res = 0\\n        \\n        for i in range(n): \\n            num = nums[i]\\n            if num < minK or num > maxK: \\n                if prevminidx is not None and prevmaxidx is not None: \\n                    llast1 = (i - 1) - (max(prevminidx, prevmaxidx) + 1) + 1\\n                    llast2 = max(prevmaxidx, prevminidx) - (min(prevmaxidx, prevminidx) + 1) + 1\\n                    ltotal = (i - 1) - startidx + 1\\n                    offset += llast1 * (llast1 + 1) // 2 + llast1 * llast2\\n                    res += ltotal * (ltotal + 1) // 2 - offset\\n                startidx = None\\n                prevminidx = None\\n                prevmaxidx = None\\n                offset = 0  \\n                continue\\n            else: \\n                if startidx is None: \\n                    startidx = i\\n                if num == minK: \\n                    if prevminidx is None and prevmaxidx is None: \\n                        l = i - startidx + 1\\n                        offset += l * (l + 1) // 2\\n                    elif prevminidx is None: \\n                        l1 = i - (prevmaxidx + 1) + 1\\n                        l2 = prevmaxidx - startidx + 1\\n                        offset += l1 * (l1 + 1) // 2 + (l1 - 1) * l2\\n                    elif prevmaxidx is None:\\n                        l1 = i - (prevminidx + 1) + 1\\n                        l2 = prevminidx - startidx + 1\\n                        offset += l1 * (l1 + 1) // 2 + l1 * l2\\n                    else: \\n                        if prevmaxidx >= prevminidx: \\n                            l1 = i - (prevmaxidx + 1) + 1\\n                            l2 = prevmaxidx - (prevminidx + 1) + 1\\n                            offset += l1 * (l1 + 1) // 2 + (l1 - 1) * l2\\n                        else: \\n                            l1 = i - (prevminidx + 1) + 1\\n                            l2 = prevminidx - (prevmaxidx + 1) + 1\\n                            offset += l1 * (l1 + 1) // 2 + l1 * l2\\n                    prevminidx = i\\n                elif num == maxK: \\n                    if prevminidx is None and prevmaxidx is None: \\n                        l = i - startidx + 1\\n                        offset += l * (l + 1) // 2\\n                    elif prevmaxidx is None: \\n                        l1 = i - (prevminidx + 1) + 1\\n                        l2 = prevminidx - startidx + 1\\n                        offset += l1 * (l1 + 1) // 2 + (l1 - 1) * l2\\n                    elif prevminidx is None: \\n                        l1 = i - (prevmaxidx + 1) + 1\\n                        l2 = prevmaxidx - startidx + 1\\n                        offset += l1 * (l1 + 1) // 2 + l1 * l2\\n                    else: \\n                        if prevminidx >= prevmaxidx: \\n                            l1 = i - (prevminidx + 1) + 1\\n                            l2 = prevminidx - (prevmaxidx + 1) + 1\\n                            offset += l1 * (l1 + 1) // 2 + (l1 - 1) * l2\\n                        else: \\n                            l1 = i - (prevmaxidx + 1) + 1\\n                            l2 = prevmaxidx - (prevminidx + 1) + 1\\n                            offset += l1 * (l1 + 1) // 2 + l1 * l2\\n                    prevmaxidx = i \\n            \\n        return res            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3255864,
                "title": "2444-count-subarrays-with-fixed-bounds-java",
                "content": "```\\nclass Solution {\\n    public long countSubarrays(int[] nums, int minK, int maxK) {\\n        int mini=-1,maxi=-1,inval=-1,n=nums.length;\\n        long cnt=0;\\n      for(int i=0;i<n;i++)\\n      {\\n          if(nums[i]>=minK&&nums[i]<=maxK)\\n          {\\n              mini=(nums[i]==minK)?i:mini;\\n              maxi=(nums[i]==maxK)?i:maxi;\\n              cnt+=Math.max(0,Math.min(mini,maxi)-inval);  \\n          }\\n          else\\n          {\\n              inval=i;\\n              mini=-1;\\n              maxi=-1;\\n          }\\n          \\n      }\\n        return cnt;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public long countSubarrays(int[] nums, int minK, int maxK) {\\n        int mini=-1,maxi=-1,inval=-1,n=nums.length;\\n        long cnt=0;\\n      for(int i=0;i<n;i++)\\n      {\\n          if(nums[i]>=minK&&nums[i]<=maxK)\\n          {\\n              mini=(nums[i]==minK)?i:mini;\\n              maxi=(nums[i]==maxK)?i:maxi;\\n              cnt+=Math.max(0,Math.min(mini,maxi)-inval);  \\n          }\\n          else\\n          {\\n              inval=i;\\n              mini=-1;\\n              maxi=-1;\\n          }\\n          \\n      }\\n        return cnt;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3255839,
                "title": "kotlin-beats-100-3-pointer-approach-o-n-time-o-1-space",
                "content": "# Intuition\\nIntuition described in editorial, best described in this img:\\n![](https://leetcode.com/problems/count-subarrays-with-fixed-bounds/Figures/2444/4.png)\\n\\n\\n# Approach\\nWe have to keep 3 indices saved to determine count of valid subarrays ending at index i: \\n1. most recent index where number is out of bounds\\n2. most recent index where maxK occurred\\n3. most recent index where minK occurred\\n\\nThen at i: we can compute current array start - smallest index from where array has the most recent minK or maxK. \\nIf the recentOut index is smaller, then this means that from minOf(recentMinK, recentMaxK) to i, we have a valid array.\\n\\nAnd this array is valid even if we add all items up to the left bound, or most recent index out of bounds. This is displayed in the prev image.\\n\\nWhen we set recentOut to -1, we will even cover the case when whole array from start to i is valid, because we\\'ll add that 1 (currentArrStart -(-1)).\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    fun countSubarrays(nums: IntArray, minK: Int, maxK: Int): Long {\\n        var recentMin = -1\\n        var recentMax = -1\\n        var recentOut = -1\\n        var ans = 0L\\n\\n        for (i in nums.indices) {\\n            if (nums[i] < minK || nums[i] > maxK) {\\n                recentOut = i\\n            }\\n\\n            if (nums[i] == minK) {\\n                recentMin = i\\n            }\\n\\n            if (nums[i] == maxK) {\\n                recentMax = i\\n            }\\n            val currentArrStart = minOf(recentMin, recentMax)\\n            ans += maxOf(0, currentArrStart - recentOut)\\n        }\\n\\n        return ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun countSubarrays(nums: IntArray, minK: Int, maxK: Int): Long {\\n        var recentMin = -1\\n        var recentMax = -1\\n        var recentOut = -1\\n        var ans = 0L\\n\\n        for (i in nums.indices) {\\n            if (nums[i] < minK || nums[i] > maxK) {\\n                recentOut = i\\n            }\\n\\n            if (nums[i] == minK) {\\n                recentMin = i\\n            }\\n\\n            if (nums[i] == maxK) {\\n                recentMax = i\\n            }\\n            val currentArrStart = minOf(recentMin, recentMax)\\n            ans += maxOf(0, currentArrStart - recentOut)\\n        }\\n\\n        return ans\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3255715,
                "title": "99ms-easy-and-simple-java-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public long countSubarrays(int[] nums, int minK, int maxK) {\\n        int lb = -1, lmin = -1, lmax = -1;\\n        int n = nums.length;\\n        long count=0;\\n\\n        for (int i=0; i<n; i++) {\\n            if (nums[i] >= minK && nums[i] <= maxK) {\\n                lmin = (nums[i] == minK) ? i:lmin;\\n                lmax = (nums[i] == maxK) ? i:lmax;\\n                count+= Math.max(0, Math.min(lmin, lmax) - lb);\\n            } else {\\n                lb = i;\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long countSubarrays(int[] nums, int minK, int maxK) {\\n        int lb = -1, lmin = -1, lmax = -1;\\n        int n = nums.length;\\n        long count=0;\\n\\n        for (int i=0; i<n; i++) {\\n            if (nums[i] >= minK && nums[i] <= maxK) {\\n                lmin = (nums[i] == minK) ? i:lmin;\\n                lmax = (nums[i] == maxK) ? i:lmax;\\n                count+= Math.max(0, Math.min(lmin, lmax) - lb);\\n            } else {\\n                lb = i;\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3255714,
                "title": "python3-simple-solution-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**Sliding window/two pointer method.**\\n![Screenshot 2023-03-04 191026.png](https://assets.leetcode.com/users/images/dee888c2-6ca7-40b2-af1e-7694133f9836_1677937238.686007.png)\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- as per constraint as soon as we find minK and maxK in our subarray, update counter to 1.\\n- now how we will keep track of this, with help of our vars **minI, maxI and end_of_ssI.**\\n- these vars indicates indexes of found **minK, maxK** element and as well as when we encounter element less than or greater than provided we include it\\'s index too.\\n- **max(0, min(minI, maxI) - end_of_ssI)**: this ensures if till we have not found minK or maxK then update counter by 0, else update counter by 1.\\n- when any of **minI** or **maxI** is **-1** this will always **result in 0.**\\n- when we find both minK and maxK then **min(minI, maxI)** we take **because** it\\'s **close to end_of_ssI** and will result in 1.\\n- next time when minI and maxI gets updated counter will get updated to 1.\\n- **return counter**. \\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], minK: int, maxK: int) -> int:\\n        minI = -1\\n        maxI = -1\\n        end_of_ssI = -1\\n        counter = 0\\n        for i in range(len(nums)):\\n            if minK <= nums[i] <= maxK:\\n                minI = i if nums[i] == minK else minI\\n                maxI = i if nums[i] == maxK else maxI\\n                counter += max(0, min(minI, maxI) - end_of_ssI)\\n            else:\\n                minI = -1\\n                maxI = -1\\n                end_of_ssI = i\\n        return counter\\n```\\n# Please like and comment below :-)",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], minK: int, maxK: int) -> int:\\n        minI = -1\\n        maxI = -1\\n        end_of_ssI = -1\\n        counter = 0\\n        for i in range(len(nums)):\\n            if minK <= nums[i] <= maxK:\\n                minI = i if nums[i] == minK else minI\\n                maxI = i if nums[i] == maxK else maxI\\n                counter += max(0, min(minI, maxI) - end_of_ssI)\\n            else:\\n                minI = -1\\n                maxI = -1\\n                end_of_ssI = i\\n        return counter\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3255639,
                "title": "two-pointers",
                "content": "# Intuition & Approach\\nhttps://youtu.be/fkHpIESGLjA\\n\\n# Code\\n## C++\\n```cpp\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n        int n = nums.size();\\n        long long res = 0;\\n        int minPos = -1, maxPos = -1, leftBound = -1;\\n\\n        for (int i = 0; i < n; ++i) {\\n            if (nums[i] < minK || nums[i] > maxK)\\n                leftBound = i;\\n            \\n            if (nums[i] == minK) \\n                minPos = i;\\n            \\n            if (nums[i] == maxK)\\n                maxPos = i;\\n\\n            res += max(0, min(maxPos, minPos) - leftBound);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n## Java\\n```java\\nclass Solution {\\n    public long countSubarrays(int[] nums, int minK, int maxK) {\\n        int n = nums.length;\\n        long res = 0;\\n        int minPos = -1, maxPos = -1, leftBound = -1;\\n\\n        for (int i = 0; i < n; ++i) {\\n            if (nums[i] < minK || nums[i] > maxK)\\n                leftBound = i;\\n            \\n            if (nums[i] == minK) \\n                minPos = i;\\n            \\n            if (nums[i] == maxK)\\n                maxPos = i;\\n\\n            res += Math.max(0, Math.min(maxPos, minPos) - leftBound);\\n        }\\n        \\n        return res;\\n    }\\n}\\n```\\n## Python\\n```py\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], minK: int, maxK: int) -> int:\\n        n, res = len(nums), 0\\n        minPos = maxPos = leftBound = -1\\n\\n        for i in range(n):\\n            if nums[i] < minK or nums[i] > maxK:\\n                leftBound = i\\n            \\n            if nums[i] == minK:\\n                minPos = i\\n            \\n            if nums[i] == maxK:\\n                maxPos = i\\n\\n            res += max(0, min(maxPos, minPos) - leftBound)\\n                \\n        return res\\n```\\n## JavaScript\\n```js\\n/**\\n * @param {number[]} nums\\n * @param {number} minK\\n * @param {number} maxK\\n * @return {number}\\n */\\nvar countSubarrays = function(nums, minK, maxK) {\\n    const n = nums.length;\\n    let res = 0, minPos = -1, maxPos = -1, leftBound = -1;\\n\\n    for (let i = 0; i < n; ++i) {\\n        if (nums[i] < minK || nums[i] > maxK)\\n            leftBound = i;\\n        \\n        if (nums[i] == minK) \\n            minPos = i;\\n        \\n        if (nums[i] == maxK)\\n            maxPos = i;\\n\\n        res += Math.max(0, Math.min(maxPos, minPos) - leftBound);\\n    }\\n    \\n    return res;\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n        int n = nums.size();\\n        long long res = 0;\\n        int minPos = -1, maxPos = -1, leftBound = -1;\\n\\n        for (int i = 0; i < n; ++i) {\\n            if (nums[i] < minK || nums[i] > maxK)\\n                leftBound = i;\\n            \\n            if (nums[i] == minK) \\n                minPos = i;\\n            \\n            if (nums[i] == maxK)\\n                maxPos = i;\\n\\n            res += max(0, min(maxPos, minPos) - leftBound);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\n```java\\nclass Solution {\\n    public long countSubarrays(int[] nums, int minK, int maxK) {\\n        int n = nums.length;\\n        long res = 0;\\n        int minPos = -1, maxPos = -1, leftBound = -1;\\n\\n        for (int i = 0; i < n; ++i) {\\n            if (nums[i] < minK || nums[i] > maxK)\\n                leftBound = i;\\n            \\n            if (nums[i] == minK) \\n                minPos = i;\\n            \\n            if (nums[i] == maxK)\\n                maxPos = i;\\n\\n            res += Math.max(0, Math.min(maxPos, minPos) - leftBound);\\n        }\\n        \\n        return res;\\n    }\\n}\\n```\n```py\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], minK: int, maxK: int) -> int:\\n        n, res = len(nums), 0\\n        minPos = maxPos = leftBound = -1\\n\\n        for i in range(n):\\n            if nums[i] < minK or nums[i] > maxK:\\n                leftBound = i\\n            \\n            if nums[i] == minK:\\n                minPos = i\\n            \\n            if nums[i] == maxK:\\n                maxPos = i\\n\\n            res += max(0, min(maxPos, minPos) - leftBound)\\n                \\n        return res\\n```\n```js\\n/**\\n * @param {number[]} nums\\n * @param {number} minK\\n * @param {number} maxK\\n * @return {number}\\n */\\nvar countSubarrays = function(nums, minK, maxK) {\\n    const n = nums.length;\\n    let res = 0, minPos = -1, maxPos = -1, leftBound = -1;\\n\\n    for (let i = 0; i < n; ++i) {\\n        if (nums[i] < minK || nums[i] > maxK)\\n            leftBound = i;\\n        \\n        if (nums[i] == minK) \\n            minPos = i;\\n        \\n        if (nums[i] == maxK)\\n            maxPos = i;\\n\\n        res += Math.max(0, Math.min(maxPos, minPos) - leftBound);\\n    }\\n    \\n    return res;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3255476,
                "title": "c-sliding-window-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n        long long cnt=0;\\n        int n=nums.size();\\n        int j=0;\\n        int min_idx=-1;\\n        int max_idx=-1;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]<minK or nums[i]>maxK){\\n                min_idx=-1;\\n                max_idx=-1;\\n                j=i+1;\\n            }\\n            if(nums[i]==minK) min_idx=i;\\n            if(nums[i]==maxK) max_idx=i;\\n            if(min_idx!=-1 and max_idx!=-1){\\n                cnt+=min(min_idx,max_idx)-j+1;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n        long long cnt=0;\\n        int n=nums.size();\\n        int j=0;\\n        int min_idx=-1;\\n        int max_idx=-1;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]<minK or nums[i]>maxK){\\n                min_idx=-1;\\n                max_idx=-1;\\n                j=i+1;\\n            }\\n            if(nums[i]==minK) min_idx=i;\\n            if(nums[i]==maxK) max_idx=i;\\n            if(min_idx!=-1 and max_idx!=-1){\\n                cnt+=min(min_idx,max_idx)-j+1;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3255417,
                "title": "optimize-this-logic-o-n-2-to-o-n",
                "content": "\\n\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} minK\\n * @param {number} maxK\\n * @return {number}\\n */\\nvar countSubarrays = function(nums, minK, maxK) {\\n\\n        let maxPosition=-1;\\n        let minPosition=-1;\\n        let leftBound=-1;\\n        let answer=0;\\n        for(let i=0;i<nums.length;i++){\\n                if(nums[i]<minK || nums[i]>maxK ){\\n                    leftBound=i;\\n                }\\n                if(nums[i]==minK) minPosition=i;\\n                if(nums[i]==maxK) maxPosition=i;\\n               let a= Math.min(maxPosition,minPosition)-leftBound;\\n               if(a>0) answer+=a;\\n\\n        }\\n    return answer;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} minK\\n * @param {number} maxK\\n * @return {number}\\n */\\nvar countSubarrays = function(nums, minK, maxK) {\\n\\n        let maxPosition=-1;\\n        let minPosition=-1;\\n        let leftBound=-1;\\n        let answer=0;\\n        for(let i=0;i<nums.length;i++){\\n                if(nums[i]<minK || nums[i]>maxK ){\\n                    leftBound=i;\\n                }\\n                if(nums[i]==minK) minPosition=i;\\n                if(nums[i]==maxK) maxPosition=i;\\n               let a= Math.min(maxPosition,minPosition)-leftBound;\\n               if(a>0) answer+=a;\\n\\n        }\\n    return answer;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3255068,
                "title": "short-concise-c",
                "content": "```\\nclass Solution {\\n    long long solve(vector<int> &nums, int minK, int maxK) {\\n        long long a = -1, b = -1, n = nums.size(), ans = 0;\\n        for(int i=0; i<n; i++) {\\n            if(nums[i] == minK) a = i;\\n            if(nums[i] == maxK) b = i;\\n            ans += min(a, b) + 1;\\n        }\\n        return ans;\\n    }\\npublic:\\n    long long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n        long long ans = 0;\\n        vector<int> v;\\n        for(int i : nums) {\\n            if(minK <= i && i <= maxK) v.push_back(i);\\n            else ans += solve(v, minK, maxK), v.clear();\\n        }\\n        if(v.size()) ans += solve(v, minK, maxK);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    long long solve(vector<int> &nums, int minK, int maxK) {\\n        long long a = -1, b = -1, n = nums.size(), ans = 0;\\n        for(int i=0; i<n; i++) {\\n            if(nums[i] == minK) a = i;\\n            if(nums[i] == maxK) b = i;\\n            ans += min(a, b) + 1;\\n        }\\n        return ans;\\n    }\\npublic:\\n    long long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n        long long ans = 0;\\n        vector<int> v;\\n        for(int i : nums) {\\n            if(minK <= i && i <= maxK) v.push_back(i);\\n            else ans += solve(v, minK, maxK), v.clear();\\n        }\\n        if(v.size()) ans += solve(v, minK, maxK);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3255031,
                "title": "very-easy-intuitive-c-sliding-window",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n      \\n      long long int mn = 0, mx = 0;\\n      long long int st = 0, st1 = 0, st2 = 0;\\n      long long int ans = 0;\\n      for(int i=0; i<nums.size(); i++)\\n      {\\n        if(nums[i] < minK || nums[i] > maxK)\\n        {\\n          mn = mx = 0;\\n          st = i+1;\\n        }\\n        if(nums[i] == minK)\\n        {\\n          mn = 1;\\n          st1 = i;\\n        }\\n        if(nums[i] == maxK)\\n        {\\n          mx = 1;\\n          st2 = i;\\n        }\\n        \\n        if(mn && mx)\\n          ans += min(st1, st2) - st + 1;\\n        \\n      }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Queue",
                    "Sliding Window",
                    "Monotonic Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n      \\n      long long int mn = 0, mx = 0;\\n      long long int st = 0, st1 = 0, st2 = 0;\\n      long long int ans = 0;\\n      for(int i=0; i<nums.size(); i++)\\n      {\\n        if(nums[i] < minK || nums[i] > maxK)\\n        {\\n          mn = mx = 0;\\n          st = i+1;\\n        }\\n        if(nums[i] == minK)\\n        {\\n          mn = 1;\\n          st1 = i;\\n        }\\n        if(nums[i] == maxK)\\n        {\\n          mx = 1;\\n          st2 = i;\\n        }\\n        \\n        if(mn && mx)\\n          ans += min(st1, st2) - st + 1;\\n        \\n      }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3255025,
                "title": "easy-solution-in-c-give-96-5-beats-with-explanation",
                "content": "# Intuition:\\n**Below solution fully depends on the  traversing over the given array nums through iteration and also find the current positions of the minimum value minK and the maximum value maxK in the given array, So to generate a subarray always should between the given range which is lie within the minK and maxk; if the  minK > nums[i] or maxK <nums[i] then we update value lower bound = current index where this situation happens.Note that lower_bound indicates here the leftmost point present in the subarray. return the value count**\\n<!-- Describe your first thoughts on how to solve this **Bold**problem. -->\\n\\n# Approach\\nFirstly initilise all the variables :\\n\\n**count=0** : It will count no. of sub array can be formed.\\n\\n**low_b=-1**:It is Lower bound ,it act as pointer in our program initialises with -1 because right now it is not pointing to any subarray bascially it will point to the left most index of the current subarray where the minK > nums[i] or maxK <nums[i] condition happens.\\n\\n**smin** :It store the index of minK   which has the  last occurence in the  nums array and in other word it simply returns the indices of the most recent occurrences of  minK in the current subarray\\n\\n**smax** :It store the index of maxK   which has the  last occurence in the  nums array and in other word it simply returns the indices of the most recent occurrences of  maxK in the current subarray\\n\\nAfter that we have to just the compute the no. of subarray can be formed by finding the min value between the both the smin and smax and subtract it from  lowerbound afterward we have to return the maximum value by comparing them to (0,min(smin,smax)-low_b). \\nIt will give possible required answer. \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N) // for traversing an array \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(0);\\n        cout.tie(0);\\n        long long count=0;\\n        int low_b = -1, smin = -1, smax = -1, n = nums.size();\\n        for (int i = 0; i < n; ++i) {\\n         // if the assigned minimum value > subarray of nums[i] or\\n        //  assigned maximum value < subarray of nums[i] in that case\\n         // we have update our lower bound = current index where this \\n         // condition is going to break\\n            if (nums[i] < minK || nums[i] > maxK) low_b = i;\\n          // storing the index of minimum value of subarray\\n            if (nums[i] == minK) smin = i;\\n // storing the index of maximum value of subarray\\n            if (nums[i] == maxK) smax = i;\\n // counting the maximum no. of possible subarray can be formed\\n            count += max(0, min(smin, smax) - low_b);\\n        }\\n        return count;\\n    }\\n        \\n    \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(0);\\n        cout.tie(0);\\n        long long count=0;\\n        int low_b = -1, smin = -1, smax = -1, n = nums.size();\\n        for (int i = 0; i < n; ++i) {\\n         // if the assigned minimum value > subarray of nums[i] or\\n        //  assigned maximum value < subarray of nums[i] in that case\\n         // we have update our lower bound = current index where this \\n         // condition is going to break\\n            if (nums[i] < minK || nums[i] > maxK) low_b = i;\\n          // storing the index of minimum value of subarray\\n            if (nums[i] == minK) smin = i;\\n // storing the index of maximum value of subarray\\n            if (nums[i] == maxK) smax = i;\\n // counting the maximum no. of possible subarray can be formed\\n            count += max(0, min(smin, smax) - low_b);\\n        }\\n        return count;\\n    }\\n        \\n    \\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3254997,
                "title": "video-solution-easiest-solution-using-sliding-window-python",
                "content": "# Approach\\nhttps://youtu.be/vwzal4jbEfw\\n\\n# Code\\n```\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], minK: int, maxK: int) -> int:\\n        minFound = False\\n        maxFound = False\\n\\n        start = 0\\n        minStart = 0\\n        maxStart = 0\\n        count = 0\\n\\n        for i, num in enumerate(nums):\\n            if num > maxK or num < minK:\\n                minFound = False\\n                maxFound = False\\n                start = i+1\\n\\n            if num == minK:\\n                minStart = i\\n                minFound = True\\n            \\n            if num == maxK:\\n                maxStart = i\\n                maxFound = True\\n\\n            if minFound and maxFound:\\n                count += min(minStart, maxStart) - start + 1\\n\\n        return count\\n            \\n\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Queue",
                    "Sliding Window",
                    "Monotonic Queue"
                ],
                "code": "```\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], minK: int, maxK: int) -> int:\\n        minFound = False\\n        maxFound = False\\n\\n        start = 0\\n        minStart = 0\\n        maxStart = 0\\n        count = 0\\n\\n        for i, num in enumerate(nums):\\n            if num > maxK or num < minK:\\n                minFound = False\\n                maxFound = False\\n                start = i+1\\n\\n            if num == minK:\\n                minStart = i\\n                minFound = True\\n            \\n            if num == maxK:\\n                maxStart = i\\n                maxFound = True\\n\\n            if minFound and maxFound:\\n                count += min(minStart, maxStart) - start + 1\\n\\n        return count\\n            \\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3254989,
                "title": "day-63-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n        long long int ans = 0;\\n        int left = -1,right =-1,idx =-1;\\n        int n = nums.size();\\n        for(int i=0;i<n;i++){\\n            if(nums[i] < minK || nums[i] >maxK){\\n                idx =i;\\n            }\\n            if(nums[i]==minK){\\n                left =i;\\n            }\\n            if(nums[i]==maxK){\\n                right =i;\\n            }\\n            ans = ans+max(0,min(left,right)-idx);\\n        }\\n        return ans;\\n    }  \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n        long long int ans = 0;\\n        int left = -1,right =-1,idx =-1;\\n        int n = nums.size();\\n        for(int i=0;i<n;i++){\\n            if(nums[i] < minK || nums[i] >maxK){\\n                idx =i;\\n            }\\n            if(nums[i]==minK){\\n                left =i;\\n            }\\n            if(nums[i]==maxK){\\n                right =i;\\n            }\\n            ans = ans+max(0,min(left,right)-idx);\\n        }\\n        return ans;\\n    }  \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3254943,
                "title": "thought-process-easy-to-understand-o-n",
                "content": "\\nHi there!! Just wanted to share thought process on how I came to solution.\\n\\nSo, I started with thinking about using nextSmaller and nextGreater array concept coz they mostly works in finding count of subarrays with some target value present in it, but couldn\\'t come to any conclusion in initial thinking(I still think this can also work).\\n\\nSo, I quickly switched to finding opposite thing in which we\\'ll find the subarrays with the elements outside the range(<minK || >maxK), and then maybe remove it from total subarrays `[n*(n+1)/2]`, but this won\\'t work as we also need to make sure target subarray contains atleast both elements once.\\n\\nBut last approach helped to understand that whenever we have a element which is <minK || >maxK, it\\'s breaking the subarray(basically no target subarray will start from left side of this point, and end at right side of this point), so basically it means we just need to reset our starting point, now rest is just counting if min and max element is present in current part of array, and if both are present, we just need to see how many starting points I can get from left which include both elements.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n        int n=nums.size();\\n        long long ans=0;\\n        int countMin=0, countMax=0;\\n        int lastMinPos=0, lastMaxPos=0;\\n        int start=0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]<minK||nums[i]>maxK){\\n                countMax=countMin=0;\\n                start=i+1;\\n                continue;\\n            }\\n            if(nums[i]==minK){\\n                lastMinPos=i;\\n                countMin++;\\n            }\\n            if(nums[i]==maxK){\\n                lastMaxPos=i;\\n                countMax++;\\n            }\\n            if(countMin>0&&countMax>0){\\n                ans+=min(lastMinPos, lastMaxPos)-start+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n        int n=nums.size();\\n        long long ans=0;\\n        int countMin=0, countMax=0;\\n        int lastMinPos=0, lastMaxPos=0;\\n        int start=0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]<minK||nums[i]>maxK){\\n                countMax=countMin=0;\\n                start=i+1;\\n                continue;\\n            }\\n            if(nums[i]==minK){\\n                lastMinPos=i;\\n                countMin++;\\n            }\\n            if(nums[i]==maxK){\\n                lastMaxPos=i;\\n                countMax++;\\n            }\\n            if(countMin>0&&countMax>0){\\n                ans+=min(lastMinPos, lastMaxPos)-start+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3254875,
                "title": "easy-c-solution-beats-99",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIts easy to see that we have to create subarray which will fulfill the given condition and then we simply count there sum.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThis solution uses sliding window concept, we slide till we find both mink and maxk and then count the no. of subarray which can be formed by them till that position.\\nIn solution I used min(startmin,startmax) because it will give us the first index where any of them occured.\\nwhen we will get a value which is greater than maxk or smaller than mink then we simply update our j(which represents the start index from where the range may begin).\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, int mink, int maxk) {\\n        long long j=0;\\n        long long ans=0;\\n        long long startmax=0,startmin=0;\\n        bool ismax=false,ismin=false;\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            if(nums[i]<mink || nums[i]>maxk)\\n            {\\n                j=i+1;\\n                ismax=false;\\n                ismin=false;\\n                //continue;\\n            }\\n            if(nums[i]==mink)\\n            {\\n                ismin=true;\\n                startmin = i;\\n            }\\n            if(nums[i]==maxk)\\n            {\\n                ismax=true;\\n                startmax = i;\\n            }\\n            if(ismax && ismin)\\n            {\\n                ans+=min(startmin,startmax)-j+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, int mink, int maxk) {\\n        long long j=0;\\n        long long ans=0;\\n        long long startmax=0,startmin=0;\\n        bool ismax=false,ismin=false;\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            if(nums[i]<mink || nums[i]>maxk)\\n            {\\n                j=i+1;\\n                ismax=false;\\n                ismin=false;\\n                //continue;\\n            }\\n            if(nums[i]==mink)\\n            {\\n                ismin=true;\\n                startmin = i;\\n            }\\n            if(nums[i]==maxk)\\n            {\\n                ismax=true;\\n                startmax = i;\\n            }\\n            if(ismax && ismin)\\n            {\\n                ans+=min(startmin,startmax)-j+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3254861,
                "title": "java-beats-4ms-100-easy-to-understand-best-solution-short-and-fast",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n100%\\n\\n- Space complexity:\\n100%\\n\\n# Code\\n```\\nclass Solution {\\n    public long countSubarrays(int[] nums, int minK, int maxK) {\\n        int minI = -1, maxI = -1, left = -1, right = 0;\\n        long count = 0;\\n        while(right < nums.length){\\n            if(nums[right] < minK || nums[right] > maxK){\\n                minI = right;\\n                maxI = right;\\n                left = right;\\n            }\\n            minI = nums[right] == minK ? right : minI;\\n            maxI = nums[right] == maxK ?  right : maxI;\\n            count += Math.min(minI, maxI) - left;\\n            right++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long countSubarrays(int[] nums, int minK, int maxK) {\\n        int minI = -1, maxI = -1, left = -1, right = 0;\\n        long count = 0;\\n        while(right < nums.length){\\n            if(nums[right] < minK || nums[right] > maxK){\\n                minI = right;\\n                maxI = right;\\n                left = right;\\n            }\\n            minI = nums[right] == minK ? right : minI;\\n            maxI = nums[right] == maxK ?  right : maxI;\\n            count += Math.min(minI, maxI) - left;\\n            right++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3254674,
                "title": "java-easy-solution",
                "content": "- SIMPLE\\n\\n---\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public long countSubarrays(int[] nums, int minK, int maxK) {\\n        int n = nums.length;\\n        int leftBound = -1;\\n        int lastMin = -1, lastMax = -1;\\n        long count = 0;\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] >= minK && nums[i] <= maxK) {\\n                lastMin = (nums[i] == minK) ? i : lastMin;\\n                lastMax = (nums[i] == maxK) ? i : lastMax;\\n                count += Math.max(0, Math.min(lastMin, lastMax) - leftBound);\\n            } else {\\n                leftBound = i;\\n                lastMin = -1;\\n                lastMax = -1;\\n            }\\n        }\\n        \\n        return  count;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Queue",
                    "Sliding Window",
                    "Monotonic Queue"
                ],
                "code": "```\\nclass Solution {\\n    public long countSubarrays(int[] nums, int minK, int maxK) {\\n        int n = nums.length;\\n        int leftBound = -1;\\n        int lastMin = -1, lastMax = -1;\\n        long count = 0;\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] >= minK && nums[i] <= maxK) {\\n                lastMin = (nums[i] == minK) ? i : lastMin;\\n                lastMax = (nums[i] == maxK) ? i : lastMax;\\n                count += Math.max(0, Math.min(lastMin, lastMax) - leftBound);\\n            } else {\\n                leftBound = i;\\n                lastMin = -1;\\n                lastMax = -1;\\n            }\\n        }\\n        \\n        return  count;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3254660,
                "title": "golang-4-pointers",
                "content": "# Code\\n```\\nfunc min(a, b int) int {\\n    if a < b {return a}\\n    return b\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b {return a}\\n    return b\\n}\\n\\nfunc countSubarrays(nums []int, minK int, maxK int) int64 {\\n    var ans int64 = 0\\n    var minNumIndex, maxNumIndex, badNumIndex int = -1, -1, -1\\n    for i, num := range nums {\\n        if num < minK || num > maxK {badNumIndex = i}\\n        if nums[i] == maxK {maxNumIndex = i}\\n        if nums[i] == minK {minNumIndex = i}\\n        ans += int64(max(0, min(minNumIndex, maxNumIndex) - badNumIndex))\\n    }\\n    return ans\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc min(a, b int) int {\\n    if a < b {return a}\\n    return b\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b {return a}\\n    return b\\n}\\n\\nfunc countSubarrays(nums []int, minK int, maxK int) int64 {\\n    var ans int64 = 0\\n    var minNumIndex, maxNumIndex, badNumIndex int = -1, -1, -1\\n    for i, num := range nums {\\n        if num < minK || num > maxK {badNumIndex = i}\\n        if nums[i] == maxK {maxNumIndex = i}\\n        if nums[i] == minK {minNumIndex = i}\\n        ans += int64(max(0, min(minNumIndex, maxNumIndex) - badNumIndex))\\n    }\\n    return ans\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3254594,
                "title": "c-easy-to-understand-sliding-window-in-between-bounds-beats-100-faster-code",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n        long long ans = 0;\\n        int start = 0;\\n        int n = nums.size();\\n        int minInd = -1, maxInd = -1;\\n        for (int i=0; i<n; i++) {\\n            if (nums[i] < minK || nums[i] > maxK) {\\n                minInd = -1;\\n                maxInd = -1;\\n                start = i+1;\\n            }\\n            if (nums[i] == minK) minInd = i;\\n            if (nums[i] == maxK) maxInd = i;\\n            ans += max(0, min(minInd, maxInd)-start+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n        long long ans = 0;\\n        int start = 0;\\n        int n = nums.size();\\n        int minInd = -1, maxInd = -1;\\n        for (int i=0; i<n; i++) {\\n            if (nums[i] < minK || nums[i] > maxK) {\\n                minInd = -1;\\n                maxInd = -1;\\n                start = i+1;\\n            }\\n            if (nums[i] == minK) minInd = i;\\n            if (nums[i] == maxK) maxInd = i;\\n            ans += max(0, min(minInd, maxInd)-start+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3254580,
                "title": "c-best-solution-beats-80-upvote-if-helpful",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n        long long res=0;\\n        int start=0,minstart=0,maxstart=0;\\n        bool minf=false,maxf=false;\\n        for(int i=0;i<nums.size();i++){\\n          int num=nums[i];\\n          if(num<minK || num>maxK){\\n              minf=false;\\n              maxf=false;\\n              start=i+1;\\n          }\\n          if(num==minK){\\n              minf=true;\\n              minstart=i;\\n          }\\n          if(num==maxK){\\n              maxf=true;\\n              maxstart=i;\\n          }\\n          if(minf && maxf){\\n              res+=(min(minstart,maxstart)-start+1);\\n          }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n        long long res=0;\\n        int start=0,minstart=0,maxstart=0;\\n        bool minf=false,maxf=false;\\n        for(int i=0;i<nums.size();i++){\\n          int num=nums[i];\\n          if(num<minK || num>maxK){\\n              minf=false;\\n              maxf=false;\\n              start=i+1;\\n          }\\n          if(num==minK){\\n              minf=true;\\n              minstart=i;\\n          }\\n          if(num==maxK){\\n              maxf=true;\\n              maxstart=i;\\n          }\\n          if(minf && maxf){\\n              res+=(min(minstart,maxstart)-start+1);\\n          }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3254519,
                "title": "c-sliding-window-o-n-100-t-95-m",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe would find index of minK and maxK, for a given starting find total subarrays.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe will iterate through the array for fixed starting index, but if we find any **num > maxK** or **num < minK** then we would move the starting index.\\n\\nIf we get both minK and maxK for given starting point, we can calculate total subarrays.\\n```\\ntotalSubArrays = (min(maximumIndex, minimumIndex) - startingIndex + 1)\\n```\\nThis gives all possible subarrays containing thes points.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n        int n = nums.size();\\n        bool minFound = false, maxFound = false;\\n        long long ans = 0;\\n        int start = 0, minIdx, maxIdx;\\n        \\n        for (int i = 0; i < n; ++i) {\\n            int num = nums[i];\\n            if (num < minK || num > maxK) {\\n                minFound = false;\\n                maxFound = false;\\n                start = i + 1;\\n            }\\n            if (num == minK) {\\n                minFound = true;\\n                minIdx = i;\\n            }\\n            if (num == maxK) {\\n                maxFound = true;\\n                maxIdx = i;\\n            }\\n            if (maxFound && minFound) {\\n                ans += (min(minIdx, maxIdx) - start + 1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\ntotalSubArrays = (min(maximumIndex, minimumIndex) - startingIndex + 1)\\n```\n```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n        int n = nums.size();\\n        bool minFound = false, maxFound = false;\\n        long long ans = 0;\\n        int start = 0, minIdx, maxIdx;\\n        \\n        for (int i = 0; i < n; ++i) {\\n            int num = nums[i];\\n            if (num < minK || num > maxK) {\\n                minFound = false;\\n                maxFound = false;\\n                start = i + 1;\\n            }\\n            if (num == minK) {\\n                minFound = true;\\n                minIdx = i;\\n            }\\n            if (num == maxK) {\\n                maxFound = true;\\n                maxIdx = i;\\n            }\\n            if (maxFound && minFound) {\\n                ans += (min(minIdx, maxIdx) - start + 1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3254382,
                "title": "easy-c-solution-tc-o-n-sc-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n        long long ans=0;\\n        int idx=0;\\n        int mini=-1;\\n        int maxi=-1;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            if(nums[i]<minK || nums[i]>maxK){\\n                idx=i+1;\\n                mini=-1;\\n                maxi=-1;\\n            }\\n            else{\\n                if(nums[i]==minK){\\n                    mini=i;\\n                    \\n                }\\n                if(nums[i]==maxK){\\n                  \\n                    maxi=i;\\n                }\\n\\n                if(maxi!=-1 && mini!=-1){\\n                    ans+=(min(maxi,mini)-idx+1);\\n                }\\n            }\\n            \\n        }\\n        return ans;\\n\\n\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n        long long ans=0;\\n        int idx=0;\\n        int mini=-1;\\n        int maxi=-1;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            if(nums[i]<minK || nums[i]>maxK){\\n                idx=i+1;\\n                mini=-1;\\n                maxi=-1;\\n            }\\n            else{\\n                if(nums[i]==minK){\\n                    mini=i;\\n                    \\n                }\\n                if(nums[i]==maxK){\\n                  \\n                    maxi=i;\\n                }\\n\\n                if(maxi!=-1 && mini!=-1){\\n                    ans+=(min(maxi,mini)-idx+1);\\n                }\\n            }\\n            \\n        }\\n        return ans;\\n\\n\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3254325,
                "title": "c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n        int preMin=-1, preMax=-1, preValid=-1;\\n        long long ans=0;\\n        for(int i=0;i<nums.size();++i){\\n            if(nums[i]>=minK && nums[i]<=maxK){\\n                if(nums[i]==minK) preMin=i;\\n                if(nums[i]==maxK) preMax=i;\\n                if(preMin!=-1 && preMax!=-1){\\n                    ans+=min(preMin,preMax)-preValid;\\n                }\\n            }\\n            else{\\n                preValid=i;\\n                preMin=-1;\\n                preMax=-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n        int preMin=-1, preMax=-1, preValid=-1;\\n        long long ans=0;\\n        for(int i=0;i<nums.size();++i){\\n            if(nums[i]>=minK && nums[i]<=maxK){\\n                if(nums[i]==minK) preMin=i;\\n                if(nums[i]==maxK) preMax=i;\\n                if(preMin!=-1 && preMax!=-1){\\n                    ans+=min(preMin,preMax)-preValid;\\n                }\\n            }\\n            else{\\n                preValid=i;\\n                preMin=-1;\\n                preMax=-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3254320,
                "title": "python-divide-and-expand",
                "content": "**Solution**:\\nSince a subarray must contains numbers between minK and maxK, any number outside such range will act as a divider and we can consider subarrays to the left and to the right of it independently.\\n\\nIterate through all numbers and find the count of valid subarrays ending at each number.\\n     \\nFor a subarray starting from the divider and ending at some arbitrary number, we can shrink such subarray from the left and it will remain valid until it no longer includes minK or maxK. Thus, the count of valid subarrays is equal to the count of numbers starting from divider to the first of the last occurence of minK and maxK.\\n    \\n**Complexity**:\\n    Time: O(n)\\n    Space: O(1)\\n\\n```\\nclass Solution:\\n    def countSubarrays(self, nums: list[int], minK: int, maxK: int) -> int:\\n\\n        # Initialize three variables to keep track of indices of latest divider, minK, maxK\\n        div, minLast, maxLast = 0, -1, -1\\n\\n        # Initialize the result\\n        res = 0\\n\\n        # Iterate through all numbers\\n        for i, num in enumerate(nums):\\n\\n            # If the current number is a divider, we can disregard all numbers before it\\n            if not (minK <= num <= maxK):\\n                div, minLast, maxLast = i + 1, -1, -1\\n                continue\\n\\n            # Update the latest indices of minK and maxK\\n            minLast, maxLast = (\\n                i if num == minK else minLast,\\n                i if num == maxK else maxLast,\\n            )\\n\\n            # Update the result with the number of valid subarrays ending at the current number if we have seen minK and maxK\\n            res += (\\n                min(maxLast, minLast) - div + 1\\n                if minLast != -1 and maxLast != -1\\n                else 0\\n            )\\n\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countSubarrays(self, nums: list[int], minK: int, maxK: int) -> int:\\n\\n        # Initialize three variables to keep track of indices of latest divider, minK, maxK\\n        div, minLast, maxLast = 0, -1, -1\\n\\n        # Initialize the result\\n        res = 0\\n\\n        # Iterate through all numbers\\n        for i, num in enumerate(nums):\\n\\n            # If the current number is a divider, we can disregard all numbers before it\\n            if not (minK <= num <= maxK):\\n                div, minLast, maxLast = i + 1, -1, -1\\n                continue\\n\\n            # Update the latest indices of minK and maxK\\n            minLast, maxLast = (\\n                i if num == minK else minLast,\\n                i if num == maxK else maxLast,\\n            )\\n\\n            # Update the result with the number of valid subarrays ending at the current number if we have seen minK and maxK\\n            res += (\\n                min(maxLast, minLast) - div + 1\\n                if minLast != -1 and maxLast != -1\\n                else 0\\n            )\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3254312,
                "title": "time-100-space-90-time-o-n-space-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nLooking at a few base cases\\n1, 5 [1,5] = 1\\n1, 5 [2,1,5] = 2\\n1, 5 [1,5,1] = 3\\n1, 5 [2,1,5,1] = 5\\nyou may notice that the count for a single pair of min and max is equal to `amount on left` * `amount on right`.\\nFor multiple pairs, the number of substrings is the sum of single scores whenever we flip from minK to maxK, with updated bounds.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nEx: \\n`minK = 1  `\\n`maxK = 5  `\\n`nums = [2,1,5,1] `\\n`Expected Answer = 5`\\n\\nStart:\\nLeft bound = 0\\nRight bound = 3\\ncount = 0\\n\\nFirst step:\\n- First min/max value found: minK{1} @ i=1\\n- Other value: maxK{5} @ i=2\\n- Amount on left = (index of our first value - left bound + 1) = 2\\n- Amount on right = (right bound - index of our first flip + 1) = 2\\n- count += 2*2 // Count = 4\\n- Update our left bound: Left Bound = 2 //Our first index + 1\\n\\nSecond step:\\n- First min/max value found: maxK{5} @ i=2\\n- Other value: minK{1} @ i=3\\n- Amount on left = (index of our first value - left bound + 1) = 1\\n- Amount on right = (right bound - index of our first flip + 1) = 1\\n- count += 1*1 // Count = 5\\n- Update our left bound: Left Bound = 2 //Our first index + 1\\n\\nThird step:\\n- First min/max value found: minK{1} @ i=3\\n- Other value: NOT FOUND. We\\'re done with this string\\n- Return count // 5, as expected!\\n\\n##### Now we repeat the above for each range of valid ints in nums and return the sum!\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], minK: int, maxK: int) -> int:\\n        returnable = 0\\n\\n        ### Handle special case where min and max are same\\n        if minK == maxK:\\n            started = False\\n            l = 0\\n            for i, n in enumerate(nums):\\n                if n == minK:\\n                    if not started:\\n                        started = True\\n                        l = i\\n                else:\\n                    if started:\\n                        started = False\\n                        c = i-l\\n                        returnable += (c * (c+1)) // 2\\n            if started: # Finish it\\n                started = False\\n                c = i-l+1\\n                returnable += (c * (c+1)) // 2\\n            return returnable\\n\\n        started = False\\n        l = r = -1\\n\\n        ### Function to evaluate a single valid substring.\\n        ### - Must not contain invalid ints\\n        ### - Must contain minK and maxK \\n        def evaluate_substring(l, r):\\n            returnable = 0\\n\\n            ### Get our first value, minK or maxK and its index\\n            for i in range(l, r+1):\\n                n = nums[i]\\n                if n == minK or n == maxK:\\n                    curr_val = n\\n                    curr_val_idx = i\\n                    break\\n\\n            ### Whenever we min or max and it\\'s not equal to our current max, add score and flip our current value\\n            for i in range(curr_val_idx, r+1):\\n                n = nums[i]\\n                if n == minK or n == maxK:\\n                    if n != curr_val:\\n                        returnable += (curr_val_idx - l + 1) * (r - i + 1)\\n                        l = curr_val_idx + 1\\n                        curr_val_idx = i\\n                        curr_val = n\\n                    else: # n is current val\\n                        curr_val_idx = i\\n\\n            return returnable\\n\\n        # Split substrings at invalid characters and add idx if we\\'ve seen minK and maxK\\n        for i, n in enumerate(nums):\\n            if started:\\n                if minK <= n <= maxK:\\n                    r = i\\n                    min_found |= (n==minK)\\n                    max_found |= (n==maxK)\\n                else: # End of a run\\n                    started = False\\n                    if min_found and max_found:\\n                        returnable += evaluate_substring(l, r)\\n            else:\\n                if minK <= n <= maxK:\\n                    started = True\\n                    min_found = n == minK\\n                    max_found = n == maxK\\n                    l = i\\n        if started: # Finish last run\\n            if min_found and max_found:\\n                returnable += evaluate_substring(l, r)\\n\\n        return returnable\\n\\n\\n                \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], minK: int, maxK: int) -> int:\\n        returnable = 0\\n\\n        ### Handle special case where min and max are same\\n        if minK == maxK:\\n            started = False\\n            l = 0\\n            for i, n in enumerate(nums):\\n                if n == minK:\\n                    if not started:\\n                        started = True\\n                        l = i\\n                else:\\n                    if started:\\n                        started = False\\n                        c = i-l\\n                        returnable += (c * (c+1)) // 2\\n            if started: # Finish it\\n                started = False\\n                c = i-l+1\\n                returnable += (c * (c+1)) // 2\\n            return returnable\\n\\n        started = False\\n        l = r = -1\\n\\n        ### Function to evaluate a single valid substring.\\n        ### - Must not contain invalid ints\\n        ### - Must contain minK and maxK \\n        def evaluate_substring(l, r):\\n            returnable = 0\\n\\n            ### Get our first value, minK or maxK and its index\\n            for i in range(l, r+1):\\n                n = nums[i]\\n                if n == minK or n == maxK:\\n                    curr_val = n\\n                    curr_val_idx = i\\n                    break\\n\\n            ### Whenever we min or max and it\\'s not equal to our current max, add score and flip our current value\\n            for i in range(curr_val_idx, r+1):\\n                n = nums[i]\\n                if n == minK or n == maxK:\\n                    if n != curr_val:\\n                        returnable += (curr_val_idx - l + 1) * (r - i + 1)\\n                        l = curr_val_idx + 1\\n                        curr_val_idx = i\\n                        curr_val = n\\n                    else: # n is current val\\n                        curr_val_idx = i\\n\\n            return returnable\\n\\n        # Split substrings at invalid characters and add idx if we\\'ve seen minK and maxK\\n        for i, n in enumerate(nums):\\n            if started:\\n                if minK <= n <= maxK:\\n                    r = i\\n                    min_found |= (n==minK)\\n                    max_found |= (n==maxK)\\n                else: # End of a run\\n                    started = False\\n                    if min_found and max_found:\\n                        returnable += evaluate_substring(l, r)\\n            else:\\n                if minK <= n <= maxK:\\n                    started = True\\n                    min_found = n == minK\\n                    max_found = n == maxK\\n                    l = i\\n        if started: # Finish last run\\n            if min_found and max_found:\\n                returnable += evaluate_substring(l, r)\\n\\n        return returnable\\n\\n\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3254311,
                "title": "c-time-o-n-space-o-1-solution-with-explanation",
                "content": "# Intuition\\n1. Group the subarrays by the index of their last element.\\n2. In the group of subarrays whose index of last element is `i`, all the satisfied subarrays must share some same element(s) with value `minK` and some same element(s) with value `maxK`.\\n3. The shortest satisfied subarray in that group must start from the element with value `minK` or `maxK`. And that element must be the unique value in the shortest satisfied subarray.\\n4. The longest satisfied subarray in that group must start after an element whose value isn\\'t inside the range `[minK, maxK]` or start from index `0`.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Keep track the `start` index of the longest satisfied subarray for each group of subarrays.\\n2. Keep track the lastest index of the element with value `minK` and `maxK`. These 2 indices determine whether there\\'s any satisfied subarrays in that group, and also determine the start index of the shortest satisfied subarray in that group.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n        long long count = 0;\\n        size_t min_start = nums.size(); // use an out-of-range value to stand for the fact that it\\'s invalid\\n        size_t max_start = nums.size();\\n        size_t start = 0;\\n\\n        for (size_t i = 0; i != nums.size(); ++i) {\\n            if (nums[i] < minK || nums[i] > maxK) {\\n                start = i+1;\\n                min_start = nums.size();\\n                max_start = nums.size();\\n            } else {\\n                if (nums[i] == minK)\\n                    min_start = i;\\n                if (nums[i] == maxK)\\n                    max_start = i;\\n            }\\n\\n            if (min_start != nums.size() && max_start != nums.size())\\n                count += min(min_start, max_start) - start + 1;\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n        long long count = 0;\\n        size_t min_start = nums.size(); // use an out-of-range value to stand for the fact that it\\'s invalid\\n        size_t max_start = nums.size();\\n        size_t start = 0;\\n\\n        for (size_t i = 0; i != nums.size(); ++i) {\\n            if (nums[i] < minK || nums[i] > maxK) {\\n                start = i+1;\\n                min_start = nums.size();\\n                max_start = nums.size();\\n            } else {\\n                if (nums[i] == minK)\\n                    min_start = i;\\n                if (nums[i] == maxK)\\n                    max_start = i;\\n            }\\n\\n            if (min_start != nums.size() && max_start != nums.size())\\n                count += min(min_start, max_start) - start + 1;\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3254296,
                "title": "java-super-easy-solution-t-c-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long countSubarrays(int[] nums, int minK, int maxK) {\\n        long res=0;\\n        int start=0,minstart=0,maxstart=0;\\n        boolean isMin=false,isMax=false;\\n\\n        for(int i=0;i<nums.length;i++){\\n            int num=nums[i];\\n            if(num<minK || num>maxK){\\n                isMin=false;\\n                isMax=false;\\n                start=i+1;\\n            }\\n            if(num==minK){\\n                isMin=true;\\n                minstart=i;\\n            }\\n            if(num==maxK){\\n                isMax=true;\\n                maxstart=i;\\n            }\\n            if(isMin==true && isMax==true){\\n                res+=Math.min(minstart,maxstart)-start+1;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long countSubarrays(int[] nums, int minK, int maxK) {\\n        long res=0;\\n        int start=0,minstart=0,maxstart=0;\\n        boolean isMin=false,isMax=false;\\n\\n        for(int i=0;i<nums.length;i++){\\n            int num=nums[i];\\n            if(num<minK || num>maxK){\\n                isMin=false;\\n                isMax=false;\\n                start=i+1;\\n            }\\n            if(num==minK){\\n                isMin=true;\\n                minstart=i;\\n            }\\n            if(num==maxK){\\n                isMax=true;\\n                maxstart=i;\\n            }\\n            if(isMin==true && isMax==true){\\n                res+=Math.min(minstart,maxstart)-start+1;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3254217,
                "title": "c-using-sliding-window",
                "content": "# Intuition\\nWe can count the number of fixed bound contiguous arrays using 3-pointer approach.\\n\\n# Approach\\n- We increment result by the number of possible arrays between minimum (last min index, last max index) and the index of the element that is out of the contiguous part.\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n        int jb = -1, jmin = -1, jmax = -1;\\n        long result = 0;\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i]<minK || nums[i]>maxK) jb = i;\\n            if(nums[i] == minK) jmin = i;\\n            if(nums[i] == maxK) jmax = i;\\n            result += max(0, min(jmin, jmax)-jb);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n        int jb = -1, jmin = -1, jmax = -1;\\n        long result = 0;\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i]<minK || nums[i]>maxK) jb = i;\\n            if(nums[i] == minK) jmin = i;\\n            if(nums[i] == maxK) jmax = i;\\n            result += max(0, min(jmin, jmax)-jb);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3254192,
                "title": "beginner-friendly-soln-day-63-o-n-complexity",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. if a number is in range of mink and maxK than we can make subarray \\n2. then we calculate how many subarray possible and add with ans\\n3. return subarray count\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)<br>\\n<b>This years leetcode solutions of mine in github</b>\\nhttps://github.com/sabbir-063/Leetcode\\n\\n![image.png](https://assets.leetcode.com/users/images/50b84819-58ac-4e1f-8264-867d527b94ba_1677902498.8455594.png)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n        long long ans=0;\\n        int Min=-1, Max=-1, bound=-1;\\n\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i] >= minK and nums[i] <= maxK){\\n                Min = (nums[i] == minK)? i : Min;\\n                Max = (nums[i] == maxK)? i : Max;\\n                ans += max(0, min(Min, Max)-bound);\\n            }else{\\n                bound=i, Min=-1, Max=-1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n        long long ans=0;\\n        int Min=-1, Max=-1, bound=-1;\\n\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i] >= minK and nums[i] <= maxK){\\n                Min = (nums[i] == minK)? i : Min;\\n                Max = (nums[i] == maxK)? i : Max;\\n                ans += max(0, min(Min, Max)-bound);\\n            }else{\\n                bound=i, Min=-1, Max=-1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3254051,
                "title": "simple-solution-by-just-one-iteration",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public long countSubarrays(int[] nums, int minK, int maxK) {\\n        long res=0;\\n        int n=nums.length;\\n        int mini=-1,maxi=-1,start=0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]<minK || nums[i]>maxK){\\n                mini=maxi=-1;\\n                start=i+1;\\n            }\\n            if(nums[i]==minK){\\n                mini=i;\\n            }\\n            if(nums[i]==maxK){\\n                maxi=i;\\n            }\\n            res=res+Math.max(0L,Math.min(mini,maxi)-start+1);\\n        }\\n        return res;\\n    }\\n}\\n```\\nThank You.\\nKeep learning and keep Practicing. :)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long countSubarrays(int[] nums, int minK, int maxK) {\\n        long res=0;\\n        int n=nums.length;\\n        int mini=-1,maxi=-1,start=0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]<minK || nums[i]>maxK){\\n                mini=maxi=-1;\\n                start=i+1;\\n            }\\n            if(nums[i]==minK){\\n                mini=i;\\n            }\\n            if(nums[i]==maxK){\\n                maxi=i;\\n            }\\n            res=res+Math.max(0L,Math.min(mini,maxi)-start+1);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3254033,
                "title": "kotlin-three-pointer-solution",
                "content": "```\\nclass Solution {\\n    fun countSubarrays(nums: IntArray, minK: Int, maxK: Int): Long {\\n        var leftBound = -1\\n        var maxIdx = -1\\n        var minIdx = -1\\n        var result: Long = 0\\n        for (i in 0..(nums.size - 1)) {\\n            val curr = nums[i]\\n            if (minK > curr || curr > maxK) {\\n                leftBound = i\\n                continue\\n            }\\n            if (minK == curr) {\\n                minIdx = i\\n            }\\n            if (maxK == curr) {\\n                maxIdx = i\\n            }\\n            result += Math.max(0, Math.min(minIdx, maxIdx) - leftBound)\\n        }\\n        return result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun countSubarrays(nums: IntArray, minK: Int, maxK: Int): Long {\\n        var leftBound = -1\\n        var maxIdx = -1\\n        var minIdx = -1\\n        var result: Long = 0\\n        for (i in 0..(nums.size - 1)) {\\n            val curr = nums[i]\\n            if (minK > curr || curr > maxK) {\\n                leftBound = i\\n                continue\\n            }\\n            if (minK == curr) {\\n                minIdx = i\\n            }\\n            if (maxK == curr) {\\n                maxIdx = i\\n            }\\n            result += Math.max(0, Math.min(minIdx, maxIdx) - leftBound)\\n        }\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3253992,
                "title": "python3-solution-using-sliding-window",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem requires us to find the number of subarrays in an array where the minimum element is at least minK and the maximum element is at most maxK.\\nTo solve the problem, I used a sliding window approach.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI initialized three variables, lowest, highest, and inbetween, to -1. The lowest variable kept track of the last index where the minimum value was seen, the highest variable tracked the last index where the maximum value was seen, and the inbetween variable tracked the last index where a value outside the range of minK to maxK was seen.\\n\\nThen, I iterated through the array and updated these variables based on the current element\\'s value. If the current element was outside the range of minK to maxK, I updated the inbetween variable. If the current element was equal to minK, I updated the lowest variable, and if it was equal to maxK, I updated the highest variable.\\n\\nFinally, for each index, I calculated the number of subarrays that end at that index and have a minimum value of at least minK and a maximum value of at most maxK. I did so by taking the minimum of lowest and highest and subtracting inbetween from it. If the result was greater than or equal to zero, I added it to the out variable, which represented the total number of subarrays that meet the criteria.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime Complexity of this solution is O(n), where n is the length of the input array nums. This is because the algorithm iterates through the array once and performs a constant number of operations at each index.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace complexity of this solution is O(1), as it only uses a constant amount of extra space to store the three variables lowest, highest, and inbetween. The space used by the input array nums is not considered extra space as it is required by the problem statement. Therefore, the solution has a space complexity that is constant with respect to the size of the input array.\\n# Code\\n```\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], minK: int, maxK: int) -> int:\\n        out, lowest, highest, inbetween = 0, -1, -1, -1\\n        for idx, num in enumerate(nums):\\n            if num < minK or num > maxK:\\n                inbetween = idx\\n            if num == minK:\\n                lowest = idx\\n            if num == maxK:\\n                highest = idx\\n            out += max(0, min(lowest, highest) - inbetween)\\n        return out\\n```",
                "solutionTags": [
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], minK: int, maxK: int) -> int:\\n        out, lowest, highest, inbetween = 0, -1, -1, -1\\n        for idx, num in enumerate(nums):\\n            if num < minK or num > maxK:\\n                inbetween = idx\\n            if num == minK:\\n                lowest = idx\\n            if num == maxK:\\n                highest = idx\\n            out += max(0, min(lowest, highest) - inbetween)\\n        return out\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2858235,
                "title": "python3-using-3-pointers",
                "content": "class Solution:\\n\\n    def countSubarrays(self, nums: List[int], minK: int, maxK: int) -> int:\\n        minFound = maxFound = False\\n        start = minStart = maxStart = 0\\n        res = 0\\n        \\n        for i,num in enumerate(nums):\\n            if num>maxK or num<minK:\\n                minFound = maxFound = False\\n                start = i + 1\\n            if num == minK:\\n                minStart = i\\n                minFound = True\\n            if num == maxK:\\n                maxStart = i\\n                maxFound = True\\n            if minFound and maxFound:\\n                res+=min(minStart,maxStart)-start+1\\n                \\n        return res",
                "solutionTags": [],
                "code": "class Solution:\\n\\n    def countSubarrays(self, nums: List[int], minK: int, maxK: int) -> int:\\n        minFound = maxFound = False\\n        start = minStart = maxStart = 0\\n        res = 0\\n        \\n        for i,num in enumerate(nums):\\n            if num>maxK or num<minK:\\n                minFound = maxFound = False\\n                start = i + 1\\n            if num == minK:\\n                minStart = i\\n                minFound = True\\n            if num == maxK:\\n                maxStart = i\\n                maxFound = True\\n            if minFound and maxFound:\\n                res+=min(minStart,maxStart)-start+1\\n                \\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 2824727,
                "title": "three-pointers",
                "content": "```\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], minK: int, maxK: int) -> int:\\n        n = len(nums)\\n        breaker = i = j = 0\\n        answer = maxKCount = minKCount = 0\\n        \\n        while i < n:\\n            while breaker < n and minK <= nums[breaker] <= maxK:\\n                breaker += 1\\n            \\n            while (minKCount == 0 or maxKCount == 0) and j < breaker:\\n                minKCount += int(nums[j] == minK)\\n                maxKCount += int(nums[j] == maxK)\\n                j += 1\\n            \\n            if j == breaker and (minKCount == 0 or maxKCount == 0):\\n                breaker += 1\\n                i = j = breaker\\n                maxKCount = minKCount = 0 \\n            else:\\n                answer += breaker - j + 1\\n                minKCount -= int(nums[i] == minK)\\n                maxKCount -= int(nums[i] == maxK)\\n                i += 1\\n        \\n        return answer\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], minK: int, maxK: int) -> int:\\n        n = len(nums)\\n        breaker = i = j = 0\\n        answer = maxKCount = minKCount = 0\\n        \\n        while i < n:\\n            while breaker < n and minK <= nums[breaker] <= maxK:\\n                breaker += 1\\n            \\n            while (minKCount == 0 or maxKCount == 0) and j < breaker:\\n                minKCount += int(nums[j] == minK)\\n                maxKCount += int(nums[j] == maxK)\\n                j += 1\\n            \\n            if j == breaker and (minKCount == 0 or maxKCount == 0):\\n                breaker += 1\\n                i = j = breaker\\n                maxKCount = minKCount = 0 \\n            else:\\n                answer += breaker - j + 1\\n                minKCount -= int(nums[i] == minK)\\n                maxKCount -= int(nums[i] == maxK)\\n                i += 1\\n        \\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2725158,
                "title": "using-queue-2-queue-easy-to-understand",
                "content": "\\n```\\nclass Solution {\\nlong long fun(int h, int l,vector<int>&nums, int mini, int maxi){\\n        queue<int>mx;\\n        queue<int>mn;\\n        for(int c=h;c<=l;c++){\\n          if(nums[c]==maxi)mx.push(c);\\n          if(nums[c]==mini)mn.push(c);\\n        }\\n        long long rev=0;\\n        for(int c=h;c<=l;c++){\\n          while(mx.front()<c and mx.size())mx.pop();\\n          while(mn.front()<c and mn.size())mn.pop();\\n          if(mx.size()==0 or mn.size()==0)break;\\n          int pup=max(mn.front(),mx.front());\\n          rev+=l-pup;\\n          rev++;\\n        }\\n        return rev;\\n};\\npublic:\\n    long long countSubarrays(vector<int>& nums, int mini, int maxi) {\\n        int sz=nums.size();\\n      long long ref=0 ;\\n      long long cnt=-1;\\n      for(int c=0;c<sz;c++){\\n        if(nums[c]<mini or nums[c]>maxi){\\n          ref+=fun(cnt+1,c-1,nums,mini,maxi);\\n          cnt=c;\\n        }\\n      }\\n      ref+=fun(cnt+1,sz-1,nums,mini,maxi);\\n      return ref;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Queue",
                    "Monotonic Queue"
                ],
                "code": "```\\nclass Solution {\\nlong long fun(int h, int l,vector<int>&nums, int mini, int maxi){\\n        queue<int>mx;\\n        queue<int>mn;\\n        for(int c=h;c<=l;c++){\\n          if(nums[c]==maxi)mx.push(c);\\n          if(nums[c]==mini)mn.push(c);\\n        }\\n        long long rev=0;\\n        for(int c=h;c<=l;c++){\\n          while(mx.front()<c and mx.size())mx.pop();\\n          while(mn.front()<c and mn.size())mn.pop();\\n          if(mx.size()==0 or mn.size()==0)break;\\n          int pup=max(mn.front(),mx.front());\\n          rev+=l-pup;\\n          rev++;\\n        }\\n        return rev;\\n};\\npublic:\\n    long long countSubarrays(vector<int>& nums, int mini, int maxi) {\\n        int sz=nums.size();\\n      long long ref=0 ;\\n      long long cnt=-1;\\n      for(int c=0;c<sz;c++){\\n        if(nums[c]<mini or nums[c]>maxi){\\n          ref+=fun(cnt+1,c-1,nums,mini,maxi);\\n          cnt=c;\\n        }\\n      }\\n      ref+=fun(cnt+1,sz-1,nums,mini,maxi);\\n      return ref;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2724800,
                "title": "java-sliding-window-time-on-space-o1",
                "content": "**Java**\\nRuntime: 8 ms, faster than 90.13% of Java online submissions for Count Subarrays With Fixed Bounds.\\nMemory Usage: 80.9 MB, less than 16.93% of Java online submissions for Count Subarrays With Fixed Bounds.\\n```\\nclass Solution {\\n  public long countSubarrays(int[] nums, int minK, int maxK) {\\n    long ans = 0;\\n\\n    for(int i = 0; i < nums.length; i++)\\n      if(nums[i] >= minK && nums[i] <= maxK){\\n        int a = i, b = i, mini = 0, maxi = 0;\\n        \\n        while(++i != nums.length && (nums[i] >= minK && nums[i] <= maxK));\\n        \\n        while(true){\\n          for(; b != i && (mini == 0 || maxi == 0); b++){\\n            if(nums[b] == minK) mini++;\\n            if(nums[b] == maxK) maxi++;\\n          }\\n          \\n          if(mini == 0 || maxi == 0) break;\\n          \\n          for(; mini != 0 && maxi != 0; ans += 1 + (i-b), a++){\\n            if(nums[a] == minK) mini--;\\n            if(nums[a] == maxK) maxi--;\\n          }          \\n        }\\n      }\\n    \\n    return ans;    \\n  }\\n}\\n```\\n\\n**C++**\\nRuntime: 156 ms, faster than 81.83% of C++ online submissions for Count Subarrays With Fixed Bounds.\\nMemory Usage: 70.4 MB, less than 31.99% of C++ online submissions for Count Subarrays With Fixed Bounds.\\n```\\nclass Solution {\\npublic:\\n  long long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n    long ans = 0;\\n\\n    for(int i = 0; i < nums.size(); i++)\\n      if(nums[i] >= minK && nums[i] <= maxK){\\n        int a = i, b = i, mini = 0, maxi = 0;\\n        \\n        while(++i != nums.size() && (nums[i] >= minK && nums[i] <= maxK));\\n        \\n        while(true){\\n          for(; b != i && (mini == 0 || maxi == 0); b++){\\n            if(nums[b] == minK) mini++;\\n            if(nums[b] == maxK) maxi++;\\n          }\\n          \\n          if(mini == 0 || maxi == 0) break;\\n          \\n          for(; mini != 0 && maxi != 0; ans += 1 + (i-b), a++){\\n            if(nums[a] == minK) mini--;\\n            if(nums[a] == maxK) maxi--;\\n          }          \\n        }\\n      }\\n    \\n    return ans;       \\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n  public long countSubarrays(int[] nums, int minK, int maxK) {\\n    long ans = 0;\\n\\n    for(int i = 0; i < nums.length; i++)\\n      if(nums[i] >= minK && nums[i] <= maxK){\\n        int a = i, b = i, mini = 0, maxi = 0;\\n        \\n        while(++i != nums.length && (nums[i] >= minK && nums[i] <= maxK));\\n        \\n        while(true){\\n          for(; b != i && (mini == 0 || maxi == 0); b++){\\n            if(nums[b] == minK) mini++;\\n            if(nums[b] == maxK) maxi++;\\n          }\\n          \\n          if(mini == 0 || maxi == 0) break;\\n          \\n          for(; mini != 0 && maxi != 0; ans += 1 + (i-b), a++){\\n            if(nums[a] == minK) mini--;\\n            if(nums[a] == maxK) maxi--;\\n          }          \\n        }\\n      }\\n    \\n    return ans;    \\n  }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n  long long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n    long ans = 0;\\n\\n    for(int i = 0; i < nums.size(); i++)\\n      if(nums[i] >= minK && nums[i] <= maxK){\\n        int a = i, b = i, mini = 0, maxi = 0;\\n        \\n        while(++i != nums.size() && (nums[i] >= minK && nums[i] <= maxK));\\n        \\n        while(true){\\n          for(; b != i && (mini == 0 || maxi == 0); b++){\\n            if(nums[b] == minK) mini++;\\n            if(nums[b] == maxK) maxi++;\\n          }\\n          \\n          if(mini == 0 || maxi == 0) break;\\n          \\n          for(; mini != 0 && maxi != 0; ans += 1 + (i-b), a++){\\n            if(nums[a] == minK) mini--;\\n            if(nums[a] == maxK) maxi--;\\n          }          \\n        }\\n      }\\n    \\n    return ans;       \\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2724346,
                "title": "intutive-o-n-c-solution",
                "content": "First of all, lets see the intution behind this solution.\\n\\nSince the array length is of size \\'n\\', so the subarrays can start from [0, n-1].\\nSo from each of the index we\\'ll be counting the possible subarrays which contains at least one minK and one maxK and all the remaining elements should follow this condition of minK <= element <= maxK.\\n\\nSo to figure it out, from each index we need to find the right boundary upto which that subarray can be formed. As given in the question, to make maxK as the maximum element no other element which is greater than maxK should be there within that subarray. Similarly to make the minK as the minimum element in the subarray, no other element which is less than minK should be there.\\n\\nSo initially iam finding out the right boundary. I am traversing from right to left, so that at any index if we found an element which is less than minK or greater than maxK, we are sure that that index acts as an breaking point of the subarray. So iam keeping track of this index in the \\'farIndex\\' array.\\n\\nI am also keeping track of whether the minK and maxK are present in the subarray or not, and maintaining the left most index of each one.\\n\\nFinally iam traversing from left to right, and at each index first of all iam checking whether both minK and maxK are present to its right side or not (minIndex[i] == -1 || maxIndex[i] == -1). If it satisfied this condition then it denotes that either one is not present to the right side of current index. If both are not \\'-1\\', then it denotes that both minK and maxK are present to the right side of the current index. Now iam taking the right boundary upto which the current subarray which is starting from \\'index\\' can be extended (which is stored in farIndex). And also to find the subarrays, we need to make sure that both minK and maxK should be present within the given subarray, so iam finding the maximum of both the indices (max(minIndex[i], maxIndex[i])), now iam just adding all the subarrays by the line (next - currInd). \\n\\nIn this way iam adding all the subarrays that are satisfying the given conditions.\\n\\nTime complexity: O(N)\\nSpace complexity: O(N)\\n\\nOf course we can improve the space complexity to O(1), but i feel that understanding this intution behind that solution is important. Even in interviews as well directly jumping onto optimal solution will not give a good impression. We need to start from less efficient solution and should eventully move to optimal solution.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n        long long result = 0;\\n        int n = (int) nums.size();\\n        \\n        vector<int> farIndex(n, n);\\n        vector<int> minIndex(n, -1);\\n        vector<int> maxIndex(n, -1);\\n        \\n        for(int i = n - 1; i >= 0; i--) {\\n            if(nums[i] < minK || nums[i] > maxK) {\\n                farIndex[i] = i;\\n                continue;\\n            }\\n            else if(i < n - 1)\\n                farIndex[i] = farIndex[i + 1];\\n            \\n            if(nums[i] == minK)\\n                minIndex[i] = i;\\n            else if(i < n - 1)\\n                minIndex[i] = minIndex[i + 1];\\n            \\n            if(nums[i] == maxK)\\n                maxIndex[i] = i;\\n            else if(i < n - 1)\\n                maxIndex[i] = maxIndex[i + 1];\\n        }\\n        \\n        for(int i = 0; i < n; i++) {\\n            \\n            if(minIndex[i] == -1 || maxIndex[i] == -1)\\n                continue;\\n            int next = farIndex[i];\\n            int currInd = max(minIndex[i], maxIndex[i]);\\n            result += (long long) (next - currInd);            \\n        }\\n        \\n        return result;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n        long long result = 0;\\n        int n = (int) nums.size();\\n        \\n        vector<int> farIndex(n, n);\\n        vector<int> minIndex(n, -1);\\n        vector<int> maxIndex(n, -1);\\n        \\n        for(int i = n - 1; i >= 0; i--) {\\n            if(nums[i] < minK || nums[i] > maxK) {\\n                farIndex[i] = i;\\n                continue;\\n            }\\n            else if(i < n - 1)\\n                farIndex[i] = farIndex[i + 1];\\n            \\n            if(nums[i] == minK)\\n                minIndex[i] = i;\\n            else if(i < n - 1)\\n                minIndex[i] = minIndex[i + 1];\\n            \\n            if(nums[i] == maxK)\\n                maxIndex[i] = i;\\n            else if(i < n - 1)\\n                maxIndex[i] = maxIndex[i + 1];\\n        }\\n        \\n        for(int i = 0; i < n; i++) {\\n            \\n            if(minIndex[i] == -1 || maxIndex[i] == -1)\\n                continue;\\n            int next = farIndex[i];\\n            int currInd = max(minIndex[i], maxIndex[i]);\\n            result += (long long) (next - currInd);            \\n        }\\n        \\n        return result;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2717943,
                "title": "python-easy-sweep-line-sort-of-solution",
                "content": "```\\nclass Solution:\\n    # Travel from left to right and if you find minK assing p1 to it and when you find maxK assing p2 to it\\n    # When you find p1 and p2 both with valid numbers in between all the numbers left of p1 which are valid\\n    # will be added to the answer. As you keep travelling right keep adding all the valid numbers from the left of p1\\n    # as those all will contribute to the answer! Hence wew need a variable to store leftmost id of valid number.\\n    def countSubarrays(self, nums: List[int], minK: int, maxK: int) -> int:\\n        res = 0\\n        p1 = p2 = left = -1\\n        for right in range(len(nums)):\\n            if nums[right] == minK: p1 = right\\n            if nums[right] == maxK: p2 = right\\n            if nums[right] < minK or nums[right] > maxK: left = right\\n            res += max(0, (min(p1, p2) - left))\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    # Travel from left to right and if you find minK assing p1 to it and when you find maxK assing p2 to it\\n    # When you find p1 and p2 both with valid numbers in between all the numbers left of p1 which are valid\\n    # will be added to the answer. As you keep travelling right keep adding all the valid numbers from the left of p1\\n    # as those all will contribute to the answer! Hence wew need a variable to store leftmost id of valid number.\\n    def countSubarrays(self, nums: List[int], minK: int, maxK: int) -> int:\\n        res = 0\\n        p1 = p2 = left = -1\\n        for right in range(len(nums)):\\n            if nums[right] == minK: p1 = right\\n            if nums[right] == maxK: p2 = right\\n            if nums[right] < minK or nums[right] > maxK: left = right\\n            res += max(0, (min(p1, p2) - left))\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2710881,
                "title": "python3-sliding-window",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/1e82409ab24ddbc3956c14523e2c0b7fc67139a9) for solutions of weekly 315. \\n\\n```\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], minK: int, maxK: int) -> int:\\n        ans = 0 \\n        ii = imin = imax = -1\\n        for i, x in enumerate(nums): \\n            if minK <= x <= maxK: \\n                if minK == x: imin = i\\n                if maxK == x: imax = i \\n                ans += max(0, min(imax, imin) - ii)\\n            else: ii = i\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], minK: int, maxK: int) -> int:\\n        ans = 0 \\n        ii = imin = imax = -1\\n        for i, x in enumerate(nums): \\n            if minK <= x <= maxK: \\n                if minK == x: imin = i\\n                if maxK == x: imax = i \\n                ans += max(0, min(imax, imin) - ii)\\n            else: ii = i\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2709853,
                "title": "explanation-of-everyone-s-short-code-dry-run-c",
                "content": "```\\n\\n    /*Intuition -> Jo bhi minIdx aur maxIdx se kam hoga [start se us idx tak] ke sare elements aa b skte aur nahi b \\n [3 4 1 2 2 5 2 1] maxK=5,minK=1 -> start=0 minIdx=2 maxIdx=5 \\n Step 1 :  ab kitne subarrays bnege \\n              ans+= min(maxIdx,minIdx)-start+1 = min(2,5)-0+1 = 2-0+1 =3\\n            \\n        [3 4 1 2 2 5]  [4 1 2 2 5]  [1 2 2 5]  these are the 3 subarrays \\n        \\nStep 2 : Ab hum i=7 pe hai vps se 1 aya to minIdx=7,maxIdx=5 start=0\\n         ans+=min(maxIdx,minIdx)-start+1 = min(5,7)-0+1 = 5-0+1 =6\\n\\n[3,4,1,2,2,5,2,1] [4,1,2,2,5,2,1] [1,2,2,5,2,1]  [2,2,5,2,1] [2,5,2,1] [5,2,1] \\n\\naur agar dhyan se dekhe to inme se koi b array hmne phle count nhi kiya */\\n    \\n    //Approach 2 -> Simple Iterative solution (Pointers logic)\\nlong long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n        \\n        long long ans=0;\\n        int maxIdx=-1,minIdx=-1,start=0;\\n        bool maxFound=false,minFound=false;\\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]<minK or nums[i]>maxK)  //case 1 out of range element \\n            {\\n                minFound=false;  //flush eerything \\n                maxFound=false;\\n                start=i+1;  //iske aage se shyd hme koi subarray mile \\n                 //isko inlcude krke to nahi mil skta kuki ye to khud out of bound \\n                //i se phle wle hm phle hi calcualte kr chuke to ab i+1 wle dkeho\\n            }\\n            if(nums[i]==minK)    //case 2 if equal to minK update minIdx\\n            {\\n                minFound=true;\\n                minIdx=i;\\n            }\\n            if(nums[i]==maxK)  //case 3 if equal to maxK update maxIdx\\n            {\\n                maxFound=true;\\n                maxIdx=i;\\n            }\\n        \\n            if(maxFound==true and minFound==true) //case 4 when we found both\\n                ans+=max(0,min(maxIdx,minIdx)-start+1);  //add subarrays formed \\n        }\\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "```\\n\\n    /*Intuition -> Jo bhi minIdx aur maxIdx se kam hoga [start se us idx tak] ke sare elements aa b skte aur nahi b \\n [3 4 1 2 2 5 2 1] maxK=5,minK=1 -> start=0 minIdx=2 maxIdx=5 \\n Step 1 :  ab kitne subarrays bnege \\n              ans+= min(maxIdx,minIdx)-start+1 = min(2,5)-0+1 = 2-0+1 =3\\n            \\n        [3 4 1 2 2 5]  [4 1 2 2 5]  [1 2 2 5]  these are the 3 subarrays \\n        \\nStep 2 : Ab hum i=7 pe hai vps se 1 aya to minIdx=7,maxIdx=5 start=0\\n         ans+=min(maxIdx,minIdx)-start+1 = min(5,7)-0+1 = 5-0+1 =6\\n\\n[3,4,1,2,2,5,2,1] [4,1,2,2,5,2,1] [1,2,2,5,2,1]  [2,2,5,2,1] [2,5,2,1] [5,2,1] \\n\\naur agar dhyan se dekhe to inme se koi b array hmne phle count nhi kiya */\\n    \\n    //Approach 2 -> Simple Iterative solution (Pointers logic)\\nlong long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n        \\n        long long ans=0;\\n        int maxIdx=-1,minIdx=-1,start=0;\\n        bool maxFound=false,minFound=false;\\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]<minK or nums[i]>maxK)  //case 1 out of range element \\n            {\\n                minFound=false;  //flush eerything \\n                maxFound=false;\\n                start=i+1;  //iske aage se shyd hme koi subarray mile \\n                 //isko inlcude krke to nahi mil skta kuki ye to khud out of bound \\n                //i se phle wle hm phle hi calcualte kr chuke to ab i+1 wle dkeho\\n            }\\n            if(nums[i]==minK)    //case 2 if equal to minK update minIdx\\n            {\\n                minFound=true;\\n                minIdx=i;\\n            }\\n            if(nums[i]==maxK)  //case 3 if equal to maxK update maxIdx\\n            {\\n                maxFound=true;\\n                maxIdx=i;\\n            }\\n        \\n            if(maxFound==true and minFound==true) //case 4 when we found both\\n                ans+=max(0,min(maxIdx,minIdx)-start+1);  //add subarrays formed \\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2709087,
                "title": "c-o-n-monotonic-stack-sliding-window",
                "content": "```\\nclass Solution {\\npublic:\\n    bool condition(int val,int stv,int c){\\n        if(c)\\n            return val > stv;\\n        else\\n            return stv > val;\\n    }\\n    vector<int> computeMinMax(vector<int> nums, int leftToRight, int c){\\n        stack<int> st;\\n        int n = nums.size();\\n        vector<int> res(n);\\n        int start,end,steps,i;\\n        if(leftToRight)\\n            start = 0,end = n,steps = 1;\\n        else\\n            start = n-1,end = -1,steps = -1;\\n        i = start;\\n        while(i != end){\\n            while(!st.empty() && condition(nums[i],nums[st.top()],c))\\n                res[st.top()] = i - steps, st.pop();\\n            st.push(i);\\n            i  += steps;\\n        }\\n        while(!st.empty()){\\n            res[st.top()] = end - steps;\\n            st.pop();\\n        }\\n        return res;\\n    }\\n    long long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n        long long ans = 0;\\n        int n = nums.size();\\n        vector<int> mn = computeMinMax(nums,1,0), mx = computeMinMax(nums,1,1),nxtmn(n+1),nxtmx(n+1);\\n        nxtmn[n] = n,nxtmx[n] = n;\\n        for(int i=n-1;i>=0;i--){\\n            nxtmn[i] = n,nxtmx[i] = n;\\n            if(nums[i] == minK)\\n                nxtmn[i] = i;\\n            if(nums[i] == maxK)\\n                nxtmx[i] = i;\\n            nxtmx[i] = min(nxtmx[i],nxtmx[i+1]), nxtmn[i] = min(nxtmn[i],nxtmn[i+1]); \\n        }\\n        int i=0,j;\\n        while(i < n){\\n            j = i;\\n            while((j < n) && (nums[j] < maxK) && (nums[j] > minK))\\n                j++;\\n            if(!((j < n) && ((nums[j] == minK)||(nums[j] == maxK)))){\\n                i=j+1;\\n                continue;\\n            }\\n            if(nxtmn[i] != n && nxtmx[i] != n){\\n                int left = min(nxtmn[i],nxtmx[i]), right = max(nxtmn[i],nxtmx[i]);\\n                bool failed = false;\\n                for(int k=left;k<right;k++)\\n                    if((nums[k]< minK) || (nums[k] > maxK))\\n                        failed = true;\\n                if(failed){\\n                    i=j+1;\\n                    continue;\\n                }\\n                int exright = min(mn[nxtmn[i]], mx[nxtmx[i]]);\\n                if(exright >= right)\\n                    ans += (left - i + 1)*(exright - right + 1); \\n            }\\n            i = j+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool condition(int val,int stv,int c){\\n        if(c)\\n            return val > stv;\\n        else\\n            return stv > val;\\n    }\\n    vector<int> computeMinMax(vector<int> nums, int leftToRight, int c){\\n        stack<int> st;\\n        int n = nums.size();\\n        vector<int> res(n);\\n        int start,end,steps,i;\\n        if(leftToRight)\\n            start = 0,end = n,steps = 1;\\n        else\\n            start = n-1,end = -1,steps = -1;\\n        i = start;\\n        while(i != end){\\n            while(!st.empty() && condition(nums[i],nums[st.top()],c))\\n                res[st.top()] = i - steps, st.pop();\\n            st.push(i);\\n            i  += steps;\\n        }\\n        while(!st.empty()){\\n            res[st.top()] = end - steps;\\n            st.pop();\\n        }\\n        return res;\\n    }\\n    long long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n        long long ans = 0;\\n        int n = nums.size();\\n        vector<int> mn = computeMinMax(nums,1,0), mx = computeMinMax(nums,1,1),nxtmn(n+1),nxtmx(n+1);\\n        nxtmn[n] = n,nxtmx[n] = n;\\n        for(int i=n-1;i>=0;i--){\\n            nxtmn[i] = n,nxtmx[i] = n;\\n            if(nums[i] == minK)\\n                nxtmn[i] = i;\\n            if(nums[i] == maxK)\\n                nxtmx[i] = i;\\n            nxtmx[i] = min(nxtmx[i],nxtmx[i+1]), nxtmn[i] = min(nxtmn[i],nxtmn[i+1]); \\n        }\\n        int i=0,j;\\n        while(i < n){\\n            j = i;\\n            while((j < n) && (nums[j] < maxK) && (nums[j] > minK))\\n                j++;\\n            if(!((j < n) && ((nums[j] == minK)||(nums[j] == maxK)))){\\n                i=j+1;\\n                continue;\\n            }\\n            if(nxtmn[i] != n && nxtmx[i] != n){\\n                int left = min(nxtmn[i],nxtmx[i]), right = max(nxtmn[i],nxtmx[i]);\\n                bool failed = false;\\n                for(int k=left;k<right;k++)\\n                    if((nums[k]< minK) || (nums[k] > maxK))\\n                        failed = true;\\n                if(failed){\\n                    i=j+1;\\n                    continue;\\n                }\\n                int exright = min(mn[nxtmn[i]], mx[nxtmx[i]]);\\n                if(exright >= right)\\n                    ans += (left - i + 1)*(exright - right + 1); \\n            }\\n            i = j+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2708953,
                "title": "4-pointers-approach-c-with-explaination",
                "content": "**Intuition**\\nJust seeing the question, you first might get the feeling of solving it with Dynamic Programming or some segment tree solution. However the main problem that you are going to face while using those approaches is that you cannot change maximum and minimum when you shift the boundations of a window by 1 unit.\\n\\nThus this suggested to me that the question can be solved using a pointer approach rather than methods suggested above.\\n\\n**Methodology**\\nLet\\'s call the fixed-bound subarray as a \"valid\" subarray.\\n\\n1. Let\\'s consider all subarrays ending at the ith index. All these subarrays start from index `i, i - 1, i - 2 .... 1. `\\n2. *Now we can clearly tell, any number which is above maxK or below minK shouldn\\'t be included in the set of \"valid\" subarrays*. Thus it establishes the fact that we need to keep track of the right most \"above maxK\" value and the rightmost \"below minK\" value. We are keeping track of the rightmost since anything on the left of the rightmost can never be included and is thus useless. We can keep the track of both these values using 2 pointers : `above`, `below`. `left` becomes the leftmost index from which we can start including subarrays ending at the ith index.\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tleft = max(above, below)\\n3. Now we need to find the rightmost index from which we can start including subarrays ending at the ith index. So the rightmost index is dependent on the right most values of minK and maxK before the ith index. *This is because, we can only take the starting point up to the index which includes both minK and maxK values*. We can keep the track of both these values using 2 pointers :` low_right(minK)`, `high_right(maxK)`. Thus, \\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tright = min(high_right, low_right)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n4. Now if we just take the difference of the left index value and the right index value, we will get only those subarrays which have minimum value as minK and maximum value as maxK and ending at the ith index.\\n\\t\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tans += right - left + 1\\n\\t\\t\\t\\t\\t\\t\\t\\t\\n**Implementation**\\n\\n```\\nclass Solution \\n{\\npublic:\\n    long long countSubarrays(vector<int>& a, int low, int high) \\n    {\\n        if(low > high)\\n            return 0;\\n        \\n        int below, above, low_right, high_right;\\n        below = above = -1;\\n        low_right = high_right = -1;\\n        int n = a.size();\\n        \\n        long long int ans = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            //assigning roles to the currrent position\\n            if(a[i] < low)\\n                below = i;\\n            if(a[i] > high)\\n                above = i;\\n            if(a[i] == low)\\n                low_right = i;\\n            if(a[i] == high)\\n                high_right = i;\\n            \\n            \\n            //calculating the valid subarrays according to the given conditions\\n            int left = max(above, below);\\n\\t\\t\\tleft = left + 1;\\n\\t\\t\\tint right = min(high_right, low_right);\\n            ans += max(0, right - left + 1);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\t\\t\\t\\t\\t\\t\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    long long countSubarrays(vector<int>& a, int low, int high) \\n    {\\n        if(low > high)\\n            return 0;\\n        \\n        int below, above, low_right, high_right;\\n        below = above = -1;\\n        low_right = high_right = -1;\\n        int n = a.size();\\n        \\n        long long int ans = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            //assigning roles to the currrent position\\n            if(a[i] < low)\\n                below = i;\\n            if(a[i] > high)\\n                above = i;\\n            if(a[i] == low)\\n                low_right = i;\\n            if(a[i] == high)\\n                high_right = i;\\n            \\n            \\n            //calculating the valid subarrays according to the given conditions\\n            int left = max(above, below);\\n\\t\\t\\tleft = left + 1;\\n\\t\\t\\tint right = min(high_right, low_right);\\n            ans += max(0, right - left + 1);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\t\\t\\t\\t\\t\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2708857,
                "title": "javascript-o-n-163ms",
                "content": "```\\nconst countSubarrays = (a, L, R) => {\\n    let n = a.length, l = -1, rmin = -1, rmax = -1, res = 0;\\n    for (let i = 0; i < n; i++) {\\n        if (a[i] < L || a[i] > R) l = i;\\n        if (a[i] == L) rmin = i;\\n        if (a[i] == R) rmax = i;\\n        let cnt = Math.min(rmin, rmax) - l;\\n        res += Math.max(0, cnt);\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst countSubarrays = (a, L, R) => {\\n    let n = a.length, l = -1, rmin = -1, rmax = -1, res = 0;\\n    for (let i = 0; i < n; i++) {\\n        if (a[i] < L || a[i] > R) l = i;\\n        if (a[i] == L) rmin = i;\\n        if (a[i] == R) rmax = i;\\n        let cnt = Math.min(rmin, rmax) - l;\\n        res += Math.max(0, cnt);\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2708851,
                "title": "c-sliding-window-time-o-n-space-o-1",
                "content": "# Intuition\\nIf `minK = 5`, `maxK = 11`, `nums = [6, 6, 6, 6, 6, 6, 5, 6, 6, 6, 10, 11, 7, 8]`,\\nhow many *fixed-bound subarrays* can be formed?\\n\\nFirst, we know that the subarray `5, 6, 6, 6, 10, 11` must to be a part of the *fixed-bound subarray*.\\n\\nSecond, we are able to count the number of the **bolded** part of `[`**6, 6, 6, 6, 6, 6,**`5, 6, 6, 6, 10, 11, ...]` as the *fixed-bound subarray*.\\nThe number of the bolded part can be form as the *fixed-bound subarray* is `(index of the last \\'6\\' = 5) - (index of the first \\'6\\' = 0) + 1` = 6 (not included `5, 6, 6, 6, 10, 11` itself).\\n\\n> The rest parts will be explained in Approach\\n\\nTo conclude our intuition,\\nif we iterate the `nums`, we care about\\n1. if `nums[i]` lies in the closed interval `[minK, maxK]`, we mark `i` as the first (furthest) `validIndex` so far.\\n:: Notice that the `validIndex` of our example is `0` (the index of the first `\\'6\\'`)\\n2. once we successfully find both `minK` and `maxK`, we can calculate the number of *fixed-bound subarray* that can be formed.\\nFor `[`**6, 6, 6, 6, 6, 6,**`5, 6, 6, 6, 10, 11, ...]`, we can form `min(indexOf(5), indexOf(11)) - validIndex + 1` = 7 subarrays (included `5, 6, 6, 6, 10, 11` itself).\\n:: Notice that the general formula should be `min(indexOf(minK), indexOf(maxK)) - validIndex + 1`\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nBut how about if we meet a valid `nums[i]` after `[minK, maxK]`?\\nTo continue the above case, `[6, 6, 6, 6, 6, 6, 5, 6, 6, 6, 10, 11,`**7, 8**`]`.\\n\\nSimply to start with, how many subarrays can be formed if we include a new `\\'7\\'` only?\\nThe answer is still `min(indexOf(5), indexOf(11)) - validIndex + 1` = 7 subarrays.\\nBecause we are just adding a new valid number `\\'7\\'` into the *fixed-bound subarrays* that we have.\\n\\nIf adding a `\\'8\\'`? `\\'8\\'` is also a valid number in range `[minK, maxK]`.\\nThe answer is still `min(indexOf(5), indexOf(11)) - validIndex + 1` = 7 subarrays.\\nIt is the same reason as above, and this time we are adding the new `\\'8\\'` after the `\\'7\\'` to those *fixed-bound subarrays*.\\n\\nFinally, in case we meet a `nums[i]` that lies outside of `[minK, maxK]`, we have to reinitialize the records of `validIndex`, `found[]` and `lastIndex[]`.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Too Long; Didn\\'t Read\\n- find `validIndex` such that `nums[validIndex]` lies in range `[minK, maxK]`\\n  - keep `validIndex` as left biased as possible\\n- if found `minK` at `i`, set `found[minK] = true` and update `lastIndex[minK] = i`.\\n- if found `maxK` at `i`, set `found[maxK] = true` and update `lastIndex[maxK] = i`.\\n- if found both `minK` and `maxK`, accumulate the `result`\\n- if met any `nums[i]` that out of range `[minK, maxK]`, reinitialize the variables.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n**Solution 1**\\n```\\nclass Solution {\\npublic:\\n  long long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n    // index 0->min 1->max\\n    int found[2] {}, lastIndex[2] = {}, validIndex = -1;\\n    long result = 0;\\n    \\n    for (int i = 0; i < nums.size(); i++) {\\n      if (nums[i] < minK or nums[i] > maxK) {\\n        found[0] = found[1] = false;\\n        validIndex = -1;\\n        continue;\\n      }\\n      if (validIndex == -1 and minK <= nums[i] and nums[i] <= maxK)\\n        validIndex = i;\\n      if (nums[i] == minK) {\\n        found[0] = true;\\n        lastIndex[0] = i;\\n      }\\n      if (nums[i] == maxK) {\\n        found[1] = true;\\n        lastIndex[1] = i;\\n      }\\n      if (found[0] and found[1]) {\\n        result += min(lastIndex[0], lastIndex[1]) - validIndex + 1;\\n      }\\n    }\\n    \\n    return result;\\n  }\\n};\\n```\\n\\n**Solution 2**\\n- take out `found[]`\\n```\\nclass Solution {\\npublic:\\n  long long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n    // index 0->min 1->max\\n    int lastIndex[2] = { -1, -1 }, validIndex = -1;\\n    long result = 0;\\n    \\n    for (int i = 0; i < nums.size(); i++) {\\n      if (nums[i] < minK or nums[i] > maxK) {\\n        lastIndex[0] = lastIndex[1] = validIndex = -1;\\n        continue;\\n      }\\n      if (validIndex == -1 and minK <= nums[i] and nums[i] <= maxK)\\n        validIndex = i;\\n      if (nums[i] == minK)\\n        lastIndex[0] = i;\\n      if (nums[i] == maxK)\\n        lastIndex[1] = i;\\n      result += max(0, min(lastIndex[0], lastIndex[1]) - validIndex + 1);\\n    }\\n    \\n    return result;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  long long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n    // index 0->min 1->max\\n    int found[2] {}, lastIndex[2] = {}, validIndex = -1;\\n    long result = 0;\\n    \\n    for (int i = 0; i < nums.size(); i++) {\\n      if (nums[i] < minK or nums[i] > maxK) {\\n        found[0] = found[1] = false;\\n        validIndex = -1;\\n        continue;\\n      }\\n      if (validIndex == -1 and minK <= nums[i] and nums[i] <= maxK)\\n        validIndex = i;\\n      if (nums[i] == minK) {\\n        found[0] = true;\\n        lastIndex[0] = i;\\n      }\\n      if (nums[i] == maxK) {\\n        found[1] = true;\\n        lastIndex[1] = i;\\n      }\\n      if (found[0] and found[1]) {\\n        result += min(lastIndex[0], lastIndex[1]) - validIndex + 1;\\n      }\\n    }\\n    \\n    return result;\\n  }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n  long long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n    // index 0->min 1->max\\n    int lastIndex[2] = { -1, -1 }, validIndex = -1;\\n    long result = 0;\\n    \\n    for (int i = 0; i < nums.size(); i++) {\\n      if (nums[i] < minK or nums[i] > maxK) {\\n        lastIndex[0] = lastIndex[1] = validIndex = -1;\\n        continue;\\n      }\\n      if (validIndex == -1 and minK <= nums[i] and nums[i] <= maxK)\\n        validIndex = i;\\n      if (nums[i] == minK)\\n        lastIndex[0] = i;\\n      if (nums[i] == maxK)\\n        lastIndex[1] = i;\\n      result += max(0, min(lastIndex[0], lastIndex[1]) - validIndex + 1);\\n    }\\n    \\n    return result;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2708839,
                "title": "c-simplified-algorithm-explanation-o-n",
                "content": "Based on lee\\'s Solution:\\nhttps://leetcode.com/problems/count-subarrays-with-fixed-bounds/discuss/2708099/JavaC%2B%2BPython-Sliding-Window-with-Explanation\\n\\n**Algorithm:**\\n* find array range for which boundary conditions are stisfied (i.e, we found minK and maxK)\\n* if boundary condition is satisfied then find\\n* Number of start position of subarray which satisfies boundary condition are\\n\\t* from startIndex to min(latestMinIndex, latestMaxIndex) any one of them can act as start of subarray\\n* So for every index found after statisfying boundary condition can act as end of subarray\\n* Thus number of start positions are added for each end of subarray (statisfying boundary condition) to the result\\n\\n```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n        int n = nums.size();\\n        long long res = 0;\\n        int latestMinIndex = -1;\\n        int latestMaxIndex = -1;\\n        int startIndex = 0;\\n        \\n        for (int i = 0; i < n; i++){\\n            if(nums[i] < minK || nums[i] > maxK){ //boudary condition failed\\n                latestMinIndex = -1;\\n                latestMaxIndex = -1;\\n                startIndex = i + 1; // new subarray start position \\n            }\\n            \\n            if (nums[i] == minK) latestMinIndex = i; \\n            if (nums[i] == maxK) latestMaxIndex = i;\\n            \\n            if (latestMinIndex != -1 && latestMaxIndex != -1){ // if boudary condition satisfied\\n                //we may encounter minK or maxK first thats why do min to get valid start postions \\n                int nStartPosition = min(latestMinIndex,latestMaxIndex) - startIndex + 1; //+1 as 0 based indexing\\n                res += nStartPosition;\\n            }   \\n            // above if converted to simple formula as seen in other solutions:\\n            //res += max(0, min(latestMinIndex, latestMaxIndex) - startIndex + 1);\\n        }\\n        return res;\\n    }\\n};\\n```\\n***:D upvote if you like explaination!***",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n        int n = nums.size();\\n        long long res = 0;\\n        int latestMinIndex = -1;\\n        int latestMaxIndex = -1;\\n        int startIndex = 0;\\n        \\n        for (int i = 0; i < n; i++){\\n            if(nums[i] < minK || nums[i] > maxK){ //boudary condition failed\\n                latestMinIndex = -1;\\n                latestMaxIndex = -1;\\n                startIndex = i + 1; // new subarray start position \\n            }\\n            \\n            if (nums[i] == minK) latestMinIndex = i; \\n            if (nums[i] == maxK) latestMaxIndex = i;\\n            \\n            if (latestMinIndex != -1 && latestMaxIndex != -1){ // if boudary condition satisfied\\n                //we may encounter minK or maxK first thats why do min to get valid start postions \\n                int nStartPosition = min(latestMinIndex,latestMaxIndex) - startIndex + 1; //+1 as 0 based indexing\\n                res += nStartPosition;\\n            }   \\n            // above if converted to simple formula as seen in other solutions:\\n            //res += max(0, min(latestMinIndex, latestMaxIndex) - startIndex + 1);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2708477,
                "title": "python-easy-to-understand-o-n-time-o-1-space",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nLoop over each number, keep record of previous minK index, maxK index and outlier index.\\n\\nWhen encounter a number in valid range [minK, maxK], calculate the num of valid subarrays that end with this number.\\n\\nIf previous outlier is before previous minK and previous maxK, the valid start of the subarray can be any index between [prev_out, min(prev_minK, prev_maxK)].\\n\\n# Complexity\\n- Time complexity: One pass O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], minK: int, maxK: int) -> int:\\n        n = len(nums) \\n        # store indices of previous minK, maxK, outliers      \\n        prev_min, prev_max, prev_out = -1, -1, -1\\n\\n        cnt = 0        \\n        for i in range(n):\\n            if nums[i] < minK or nums[i] > maxK: \\n                prev_out = i\\n                continue               \\n            if nums[i] == minK: prev_min = i\\n            if nums[i] == maxK: prev_max = i\\n        \\n            # count subarrays, minK <= nums[i] <= maxK           \\n            if prev_out < prev_max and prev_out < prev_min:\\n                cnt += min(prev_max, prev_min) - prev_out\\n                            \\n        return cnt\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], minK: int, maxK: int) -> int:\\n        n = len(nums) \\n        # store indices of previous minK, maxK, outliers      \\n        prev_min, prev_max, prev_out = -1, -1, -1\\n\\n        cnt = 0        \\n        for i in range(n):\\n            if nums[i] < minK or nums[i] > maxK: \\n                prev_out = i\\n                continue               \\n            if nums[i] == minK: prev_min = i\\n            if nums[i] == maxK: prev_max = i\\n        \\n            # count subarrays, minK <= nums[i] <= maxK           \\n            if prev_out < prev_max and prev_out < prev_min:\\n                cnt += min(prev_max, prev_min) - prev_out\\n                            \\n        return cnt\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2708385,
                "title": "c-solution-two-pointer-approach-sliding-window",
                "content": "**Keen Observation**\\n* **If their is number which is greater than the maxK OR which is smaller than the minK then their is absolutely no subarray which can conain that index, that\\'s why we are doing st  = ed after the break condition.**\\n* **We will consider that with each index how many subarray with starting index before it can make a right subarray. More like contribution of each one.**\\n\\n```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n        \\n      long long count  = 0;\\n      int st = 0;\\n      int ed = 0;\\n      map<int,int> mini_map;\\n      map<int,int,greater<int>> maxi_map;\\n      \\n      while (ed < nums.size())\\n      {\\n\\t    // This is done so that map in not empty while comparing\\n        mini_map[nums[ed]] = ed;\\n        maxi_map[nums[ed]] = ed;\\n          \\n        while (ed < nums.size())\\n        {\\n          mini_map[nums[ed]] = ed;\\n          maxi_map[nums[ed]] = ed;\\n          \\n          if (mini_map.begin() -> first == minK && maxi_map.begin() -> first == maxK)\\n          {\\n\\t\\t    // If both the condition are met than calulate that with this index as the end index, how many subarrrays can be made\\n            int mini = min(mini_map.begin() -> second,maxi_map.begin() -> second);\\n            count += (mini - st + 1);\\n          }\\n          if (mini_map.begin() -> first < minK || maxi_map.begin() -> first > maxK)\\n          {\\n\\t\\t    // Break Condition\\n            break;\\n          }\\n          ed++;\\n        }\\n        ed++;\\n        st = ed;\\n        mini_map.clear();\\n        maxi_map.clear();\\n        \\n      }\\n      return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n        \\n      long long count  = 0;\\n      int st = 0;\\n      int ed = 0;\\n      map<int,int> mini_map;\\n      map<int,int,greater<int>> maxi_map;\\n      \\n      while (ed < nums.size())\\n      {\\n\\t    // This is done so that map in not empty while comparing\\n        mini_map[nums[ed]] = ed;\\n        maxi_map[nums[ed]] = ed;\\n          \\n        while (ed < nums.size())\\n        {\\n          mini_map[nums[ed]] = ed;\\n          maxi_map[nums[ed]] = ed;\\n          \\n          if (mini_map.begin() -> first == minK && maxi_map.begin() -> first == maxK)\\n          {\\n\\t\\t    // If both the condition are met than calulate that with this index as the end index, how many subarrrays can be made\\n            int mini = min(mini_map.begin() -> second,maxi_map.begin() -> second);\\n            count += (mini - st + 1);\\n          }\\n          if (mini_map.begin() -> first < minK || maxi_map.begin() -> first > maxK)\\n          {\\n\\t\\t    // Break Condition\\n            break;\\n          }\\n          ed++;\\n        }\\n        ed++;\\n        st = ed;\\n        mini_map.clear();\\n        maxi_map.clear();\\n        \\n      }\\n      return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2708327,
                "title": "easiest-java-solution",
                "content": "**upvote if it helped**\\n*post query if u got*\\n```\\nclass Solution {\\n    public long countSubarrays(int[] nums, int minK, int maxK) {\\n        int lastMax = -1;\\n        int lastMin = -1;\\n        int lastOut = -1;\\n        \\n        long total = 0;\\n        \\n        for (int i = 0; i < nums.length; ++i){\\n            \\n            if (nums[i] == minK){\\n                lastMin = i;\\n            }\\n            \\n            if (nums[i] == maxK){\\n                lastMax = i;\\n            }\\n            \\n            if (nums[i] < minK || nums[i] > maxK){\\n                lastOut = i;\\n            }\\n            \\n            total += Math.max(0 , Math.min(lastMin , lastMax) - lastOut);\\n        }\\n        \\n        return total;\\n    \\n    }\\n       \\n    \\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public long countSubarrays(int[] nums, int minK, int maxK) {\\n        int lastMax = -1;\\n        int lastMin = -1;\\n        int lastOut = -1;\\n        \\n        long total = 0;\\n        \\n        for (int i = 0; i < nums.length; ++i){\\n            \\n            if (nums[i] == minK){\\n                lastMin = i;\\n            }\\n            \\n            if (nums[i] == maxK){\\n                lastMax = i;\\n            }\\n            \\n            if (nums[i] < minK || nums[i] > maxK){\\n                lastOut = i;\\n            }\\n            \\n            total += Math.max(0 , Math.min(lastMin , lastMax) - lastOut);\\n        }\\n        \\n        return total;\\n    \\n    }\\n       \\n    \\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2708325,
                "title": "rust-sliding-window-with-comments",
                "content": "This is my unrevised submission for the 2022-10-16 Weekly Contest 315. Split the array into chunks that do not contain numbers outside `[min_k..=max_k]` so that we don\\'t have to worry about those. Then find all pairs of indices (`min_i`, `max_i`) where `nums[min_i] == min_k && nums[max_i] == max_k` or `nums[min_i] == mak_k && nums[max_i] == min_k`, i.e. the interval contains the necessary elements, and optionally some other elements in between. With that interval, we can form subarrays extending to either side, and the number of subarrays is the product of the possible extensions on either side.\\n\\nComment: The strategy was fairly easy to come up with, but the devil was in the details for this problem. Happy that I got it right.\\n\\n```\\nimpl Solution {\\n    pub fn count_subarrays(nums: Vec<i32>, min_k: i32, max_k: i32) -> i64 {\\n        let mut rez = 0;\\n\\n        for chunk in nums.split(|n| *n < min_k || *n > max_k) {\\n            let mut slow = 0;\\n            let (mut min_i_opt, mut max_i_opt) = (None, None);\\n            for fast in 0..chunk.len() {\\n                if chunk[fast] == min_k {\\n                    min_i_opt = Some(fast);\\n                }\\n                if chunk[fast] == max_k {\\n                    max_i_opt = Some(fast);\\n                }\\n                if let (Some(min_i), Some(max_i)) = (min_i_opt.clone(), max_i_opt.clone()) {\\n                    let (lo, hi) = (min_i.min(max_i), min_i.max(max_i));\\n                    rez += (lo - slow + 1) as u64 * (chunk.len() - hi) as u64;\\n                    if fast == min_i {\\n                        slow = max_i + 1;\\n                        max_i_opt = None;\\n                    } else {\\n                        slow = min_i + 1;\\n                        min_i_opt = None;\\n                    }\\n                }\\n            }\\n        }\\n        rez as _\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn count_subarrays(nums: Vec<i32>, min_k: i32, max_k: i32) -> i64 {\\n        let mut rez = 0;\\n\\n        for chunk in nums.split(|n| *n < min_k || *n > max_k) {\\n            let mut slow = 0;\\n            let (mut min_i_opt, mut max_i_opt) = (None, None);\\n            for fast in 0..chunk.len() {\\n                if chunk[fast] == min_k {\\n                    min_i_opt = Some(fast);\\n                }\\n                if chunk[fast] == max_k {\\n                    max_i_opt = Some(fast);\\n                }\\n                if let (Some(min_i), Some(max_i)) = (min_i_opt.clone(), max_i_opt.clone()) {\\n                    let (lo, hi) = (min_i.min(max_i), min_i.max(max_i));\\n                    rez += (lo - slow + 1) as u64 * (chunk.len() - hi) as u64;\\n                    if fast == min_i {\\n                        slow = max_i + 1;\\n                        max_i_opt = None;\\n                    } else {\\n                        slow = min_i + 1;\\n                        min_i_opt = None;\\n                    }\\n                }\\n            }\\n        }\\n        rez as _\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2708158,
                "title": "sliding-window-o-n",
                "content": "```\\nclass Solution {\\n    public long countSubarrays(int[] nums, int minK, int maxK) {\\n        int n = nums.length;\\n        int start = 0;\\n        int minKInd = -1;\\n        int maxKInd = -1;\\n        long count = 0;\\n        for(int end = 0; end < n; end++) {\\n            if(nums[end] < minK || nums[end] > maxK) {\\n                minKInd = -1;\\n                maxKInd = -1;\\n                start = end + 1;\\n            }else {\\n                if(nums[end] == minK) minKInd = end;\\n                if(nums[end] == maxK) maxKInd = end;\\n                if(minKInd == -1 || maxKInd == -1) continue;\\n                int right = Math.min(minKInd, maxKInd);\\n                count += ln(right - start + 1);\\n            }\\n        }\\n        \\n        return count;\\n    }\\n    \\n    private long ln(int num) { return Long.valueOf(num); }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public long countSubarrays(int[] nums, int minK, int maxK) {\\n        int n = nums.length;\\n        int start = 0;\\n        int minKInd = -1;\\n        int maxKInd = -1;\\n        long count = 0;\\n        for(int end = 0; end < n; end++) {\\n            if(nums[end] < minK || nums[end] > maxK) {\\n                minKInd = -1;\\n                maxKInd = -1;\\n                start = end + 1;\\n            }else {\\n                if(nums[end] == minK) minKInd = end;\\n                if(nums[end] == maxK) maxKInd = end;\\n                if(minKInd == -1 || maxKInd == -1) continue;\\n                int right = Math.min(minKInd, maxKInd);\\n                count += ln(right - start + 1);\\n            }\\n        }\\n        \\n        return count;\\n    }\\n    \\n    private long ln(int num) { return Long.valueOf(num); }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2708133,
                "title": "i-know-that-it-could-be-done-in-o-n-but",
                "content": "\\nWhen TreeSet can make your life easier and OJ is ok with O(n log n), why not?\\n\\n# High-Level Explanation:\\n\\nWe follow Napoleon\\'s strategy: Divide and Conquer, just to be dramatic.\\n\\nWe divide the array into chunks of the biggest fixed-bound subarrays. Then for each of them, we count the number of fixed-bound subarrays.\\n\\n\\n````   \\n   \\n    TreeSet<Integer> minIndexTreeSet = new TreeSet<>();\\n    TreeSet<Integer> maxIndexTreeSet = new TreeSet<>();\\n    int minK, maxK;\\n    long sum = 0;\\n    int[] nums;\\n\\n    public long countSubarrays(int[] nums, int minK, int maxK) {\\n        int start = 0;\\n        int size = nums.length;\\n        this.nums = nums;\\n        this.minK = minK;\\n        this.maxK = maxK;\\n        for (int i = 0; i < size; i++) {\\n            int num = nums[i];\\n            if (num < minK || num > maxK) {\\n                add(start, i - 1);\\n                start = i + 1;\\n                minIndexTreeSet.clear();\\n                maxIndexTreeSet.clear();\\n            }\\n            if (num == minK) {\\n                minIndexTreeSet.add(i);\\n            }\\n            if (num == maxK) {\\n                maxIndexTreeSet.add(i);\\n            }\\n        }\\n        add(start, size - 1);\\n        return sum;\\n    }\\n\\n    private void add(int start, int end) {\\n        if (start > end || maxIndexTreeSet.size() == 0 || minIndexTreeSet.size() == 0)\\n            return;\\n\\n        for (int i = start; i <= end; i++) {\\n            Integer floorMinIndex = minIndexTreeSet.floor(i);\\n            if (floorMinIndex == null) {\\n                continue;\\n            }\\n            Integer floorMaxIndex = maxIndexTreeSet.floor(i);\\n            if (floorMaxIndex == null) {\\n                continue;\\n            }\\n            int smallerIndex = Math.min(floorMinIndex, floorMaxIndex);\\n            int dif = smallerIndex - start + 1;\\n            sum += dif;\\n        }\\n    }\\n\\t",
                "solutionTags": [],
                "code": "\\nWhen TreeSet can make your life easier and OJ is ok with O(n log n), why not?\\n\\n# High-Level Explanation:\\n\\nWe follow Napoleon\\'s strategy: Divide and Conquer, just to be dramatic.\\n\\nWe divide the array into chunks of the biggest fixed-bound subarrays. Then for each of them, we count the number of fixed-bound subarrays.\\n\\n\\n````   \\n   \\n    TreeSet<Integer> minIndexTreeSet = new TreeSet<>();\\n    TreeSet<Integer> maxIndexTreeSet = new TreeSet<>();\\n    int minK, maxK;\\n    long sum = 0;\\n    int[] nums;\\n\\n    public long countSubarrays(int[] nums, int minK, int maxK) {\\n        int start = 0;\\n        int size = nums.length;\\n        this.nums = nums;\\n        this.minK = minK;\\n        this.maxK = maxK;\\n        for (int i = 0; i < size; i++) {\\n            int num = nums[i];\\n            if (num < minK || num > maxK) {\\n                add(start, i - 1);\\n                start = i + 1;\\n                minIndexTreeSet.clear();\\n                maxIndexTreeSet.clear();\\n            }\\n            if (num == minK) {\\n                minIndexTreeSet.add(i);\\n            }\\n            if (num == maxK) {\\n                maxIndexTreeSet.add(i);\\n            }\\n        }\\n        add(start, size - 1);\\n        return sum;\\n    }\\n\\n    private void add(int start, int end) {\\n        if (start > end || maxIndexTreeSet.size() == 0 || minIndexTreeSet.size() == 0)\\n            return;\\n\\n        for (int i = start; i <= end; i++) {\\n            Integer floorMinIndex = minIndexTreeSet.floor(i);\\n            if (floorMinIndex == null) {\\n                continue;\\n            }\\n            Integer floorMaxIndex = maxIndexTreeSet.floor(i);\\n            if (floorMaxIndex == null) {\\n                continue;\\n            }\\n            int smallerIndex = Math.min(floorMinIndex, floorMaxIndex);\\n            int dif = smallerIndex - start + 1;\\n            sum += dif;\\n        }\\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 2708035,
                "title": "c-simple-o-n-solution-explained",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can use two variables to record the occurence of `minK` and `maxK` and its index.\\nThen, if we found the two occurence when iterating array, we can calculate the number of subarray that end with current index.\\n\\n\\nOne thing to note is that if there is an element (breakpoint) that is larger than `maxK` or smaller than `minK` when iterating array, we need to re-initialize both the occurence variable. \\nThat is, we can think it as a new problem with array that begin with the breakpoint index + 1 because elements before breakpoint don\\'t influence the answer now.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n        \\n        int minIdx = -1, maxIdx = -1;\\n        long long ans = 0;\\n        int prevBreak = -1;\\n        \\n        for(int i=0; i < nums.size(); i++) {\\n            \\n            if (nums[i] == minK) {\\n                minIdx = i;\\n            }\\n            if (nums[i] == maxK) {\\n                maxIdx = i;\\n            }\\n            if (nums[i] > maxK || nums[i] < minK) {\\n                minIdx = maxIdx = -1;\\n                prevBreak = i;\\n            }\\n            \\n            if (minIdx != -1 && maxIdx != -1) {\\n                // add num of correct subarray that end with index i\\n                ans += (min(minIdx, maxIdx) - prevBreak);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n        \\n        int minIdx = -1, maxIdx = -1;\\n        long long ans = 0;\\n        int prevBreak = -1;\\n        \\n        for(int i=0; i < nums.size(); i++) {\\n            \\n            if (nums[i] == minK) {\\n                minIdx = i;\\n            }\\n            if (nums[i] == maxK) {\\n                maxIdx = i;\\n            }\\n            if (nums[i] > maxK || nums[i] < minK) {\\n                minIdx = maxIdx = -1;\\n                prevBreak = i;\\n            }\\n            \\n            if (minIdx != -1 && maxIdx != -1) {\\n                // add num of correct subarray that end with index i\\n                ans += (min(minIdx, maxIdx) - prevBreak);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2708034,
                "title": "python3-sliding-window-o-n-with-explanations",
                "content": "**Implementation**\\n\\n**Step 1** We create an array `arr` to store the indices (`i`) whose corresponding values (`num`) are out of bound (i.e. `num < minK or num > maxK`) - these are the indices that cannot be included in any of the fixed-bound subarrays. In addition, we add `-1` and `len(nums)` as two gatekeepers on both sides. For example, if `nums = [1,3,5,2,7,5], minK = 1, maxK = 5` then `arr = [-1, 4, 6]`.\\n\\n**Step 2** For each of the two neighboring indices `l` and `r` in `arr`, we count how many fixed-bound subarrays are within `nums[l + 1 : r]` by using a helper function.\\n\\nTo do this, we use a Counter `dic` to record the frequencies of the elements in the current subarray. Each time, we move the starting index (`i`) to the right by 1, and move the ending index `j` to the right as soon as both minK and maxK are included in the subarray (this can be easily checked since `dic` itself is a hashmap).\\n\\nIf this is the case, we count how many fixed-bound subarrays and added to the output of the helper function;\\n\\nOtherwise, there is no fixed-bound subarrays that start with the current starting index which also implies that we don\\u2019t need to check further starting indices. We repeat this process by iterating all possible starting indices.\\n \\n **Solution**\\n```\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], minK: int, maxK: int) -> int:\\n        if minK > maxK: return 0\\n        \\n        def count(l, r):\\n            if l + 1 == r: return 0\\n            dic = Counter([nums[l]])\\n            ans, j = 0, l + 1\\n            for i in range(l + 1, r):\\n                dic[nums[i - 1]] -= 1\\n                while not dic[minK] * dic[maxK] and j < r:\\n                    dic[nums[j]] += 1\\n                    j += 1\\n                if dic[minK] * dic[maxK]: ans += r - j + 1\\n                else: break\\n            return ans\\n        \\n        arr = [-1] + [i for i, num in enumerate(nums) if num < minK or num > maxK] + [len(nums)]\\n        return sum(count(arr[i - 1], arr[i]) for i in range(1, len(arr)))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], minK: int, maxK: int) -> int:\\n        if minK > maxK: return 0\\n        \\n        def count(l, r):\\n            if l + 1 == r: return 0\\n            dic = Counter([nums[l]])\\n            ans, j = 0, l + 1\\n            for i in range(l + 1, r):\\n                dic[nums[i - 1]] -= 1\\n                while not dic[minK] * dic[maxK] and j < r:\\n                    dic[nums[j]] += 1\\n                    j += 1\\n                if dic[minK] * dic[maxK]: ans += r - j + 1\\n                else: break\\n            return ans\\n        \\n        arr = [-1] + [i for i, num in enumerate(nums) if num < minK or num > maxK] + [len(nums)]\\n        return sum(count(arr[i - 1], arr[i]) for i in range(1, len(arr)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2708013,
                "title": "java-o-n-solution",
                "content": "```\\nclass Solution {\\n        \\n    public long countSubarrays(int[] nums, int minK, int maxK) {\\n\\t\\t long res = 0L;\\n        int left=0, minIdx=-1, maxIdx=-1, n=nums.length;\\n        for(int i=0; i<n; i++){\\n            if(nums[i] < minK || nums[i] > maxK){ // if out of range reset all values\\n                left = i + 1;\\n                minIdx = maxIdx = -1;\\n                continue;\\n            }\\n            if(nums[i] == minK) minIdx = i;\\n            if(nums[i] == maxK) maxIdx = i;\\n            \\n            if(minIdx != -1 && maxIdx != -1){ // if both min index and max index is found calculate the result\\n                long val = Math.min(minIdx, maxIdx) - left + 1;\\n                res += val;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n        \\n    public long countSubarrays(int[] nums, int minK, int maxK) {\\n\\t\\t long res = 0L;\\n        int left=0, minIdx=-1, maxIdx=-1, n=nums.length;\\n        for(int i=0; i<n; i++){\\n            if(nums[i] < minK || nums[i] > maxK){ // if out of range reset all values\\n                left = i + 1;\\n                minIdx = maxIdx = -1;\\n                continue;\\n            }\\n            if(nums[i] == minK) minIdx = i;\\n            if(nums[i] == maxK) maxIdx = i;\\n            \\n            if(minIdx != -1 && maxIdx != -1){ // if both min index and max index is found calculate the result\\n                long val = Math.min(minIdx, maxIdx) - left + 1;\\n                res += val;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3950734,
                "title": "sliding-window-c-clean-intuitive-code-99-ms",
                "content": "# Code\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& a, int mink, int maxk) {\\n        ll n=a.size(),ans=0;\\n        ll i=0,j=0,mini=INT_MAX,maxi=INT_MIN,maxind=-1,minind=-1;\\n        while(j<n){\\n            if(a[j]>maxk || a[j]<mink)\\n            {\\n                mini=INT_MAX,maxi=INT_MIN,maxind=-1,minind=-1;\\n                i=j+1;\\n            }\\n            else{\\n                if(maxi<=a[j]) maxi=a[j],maxind=j;\\n                if(mini>=a[j]) mini=a[j],minind=j;\\n                if(maxi==maxk && mini==mink) ans+=(min(maxind-i,minind-i)+1);\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& a, int mink, int maxk) {\\n        ll n=a.size(),ans=0;\\n        ll i=0,j=0,mini=INT_MAX,maxi=INT_MIN,maxind=-1,minind=-1;\\n        while(j<n){\\n            if(a[j]>maxk || a[j]<mink)\\n            {\\n                mini=INT_MAX,maxi=INT_MIN,maxind=-1,minind=-1;\\n                i=j+1;\\n            }\\n            else{\\n                if(maxi<=a[j]) maxi=a[j],maxind=j;\\n                if(mini>=a[j]) mini=a[j],minind=j;\\n                if(maxi==maxk && mini==mink) ans+=(min(maxind-i,minind-i)+1);\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3922124,
                "title": "sliding-windows-sub-array-best-and-easy-way",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n O(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, int mink, int maxk) {\\n\\n        long long ans=0;\\n\\n        int minkposition =-1;\\n        int maxkposition = -1;\\n        int culpritposition =-1;\\n\\n        for(int i=0;i<nums.size();i++){\\n           \\n           // agr dono se bada hua to culpritindex hai\\n            if(nums[i] < mink or nums[i] > maxk){\\n                culpritposition =i;\\n            }\\n\\n            if(nums[i] == mink){\\n                minkposition =i;\\n            }\\n            if(nums[i] == maxk){\\n                maxkposition = i;\\n            }\\n\\n            long long  smaller = min(minkposition,maxkposition);\\n             long long  temp  = smaller - culpritposition;\\n\\n             ans += (temp <= 0) ? 0 : temp;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, int mink, int maxk) {\\n\\n        long long ans=0;\\n\\n        int minkposition =-1;\\n        int maxkposition = -1;\\n        int culpritposition =-1;\\n\\n        for(int i=0;i<nums.size();i++){\\n           \\n           // agr dono se bada hua to culpritindex hai\\n            if(nums[i] < mink or nums[i] > maxk){\\n                culpritposition =i;\\n            }\\n\\n            if(nums[i] == mink){\\n                minkposition =i;\\n            }\\n            if(nums[i] == maxk){\\n                maxkposition = i;\\n            }\\n\\n            long long  smaller = min(minkposition,maxkposition);\\n             long long  temp  = smaller - culpritposition;\\n\\n             ans += (temp <= 0) ? 0 : temp;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3916326,
                "title": "sub-arrays",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], minK: int, maxK: int) -> int:\\n          x,a,b = -1,-2,-2\\n          res = 0\\n          for i,n in enumerate(nums):\\n            if n>maxK or n<minK: x = i\\n            if n == minK: a = i\\n            if n == maxK: b = i\\n            res += max(0, min(a,b) - x)\\n          return res\\n          \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], minK: int, maxK: int) -> int:\\n          x,a,b = -1,-2,-2\\n          res = 0\\n          for i,n in enumerate(nums):\\n            if n>maxK or n<minK: x = i\\n            if n == minK: a = i\\n            if n == maxK: b = i\\n            res += max(0, min(a,b) - x)\\n          return res\\n          \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3916286,
                "title": "easy-python-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], minK: int, maxK: int) -> int:\\n        x,a,b = -1,-2,-2\\n        res = 0\\n        for i,n in enumerate(nums):\\n            if n>maxK or n<minK: x = i\\n            if n == minK: a = i\\n            if n == maxK: b = i\\n            res += max(0, min(a,b) - x)\\n        return res\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], minK: int, maxK: int) -> int:\\n        x,a,b = -1,-2,-2\\n        res = 0\\n        for i,n in enumerate(nums):\\n            if n>maxK or n<minK: x = i\\n            if n == minK: a = i\\n            if n == maxK: b = i\\n            res += max(0, min(a,b) - x)\\n        return res\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3858512,
                "title": "simple-o-n-solution-easy-to-read",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nInstead of traversing to all subarrays, come up with an approach where we can find out what value is the current number is contributing to the answer.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe keep track of the last minPos and maxPos seen. Also, it is important to keep track of from which position are we starting our subarray.\\n\\nIterate the array:\\n1. If the cur item is not in min max range, skip it reseting the tracker variables.\\n2. Update minPos and maxPos.\\n3. If any of the minPos and maxPos are not available continue.\\n4. Now main part:\\n\\nCase 1: If cur number is minK, we need to check where was the last\\nmaxK, based on that calculate how many subarrays can be form.\\neg. [1,5,7,2,3,1,5], suppose we are index 6, so minPos will be 5, so we can subarrays like [3,1,5], [2,3,1,5], ... This     way it is easy to calculate the total contribution by this value.\\n\\nCase 2: If current is maxK, similar to above approach calculate\\n\\nCase 3: If current is inbetween range, then we just need to calculate from the index of min or max which appears first.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public long countSubarrays(int[] nums, int minK, int maxK) {\\n        long ans = 0;\\n\\n        int minPos = -1;\\n        int maxPos = -1;\\n\\n        int startSubArrayFrom = 0;\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            int cur = nums[i];\\n\\n            if (cur < minK || cur > maxK) {\\n                minPos = -1;\\n                maxPos = -1;\\n                startSubArrayFrom = i + 1;\\n                continue;\\n            }\\n\\n            if (cur == minK) {\\n                minPos = i;\\n            }\\n\\n            if (cur == maxK) {\\n                maxPos = i;\\n            }\\n\\n            if (minPos == -1 || maxPos == -1) {\\n                continue;\\n            }\\n\\n            if (cur == minK) {\\n                ans = ans + (maxPos + 1) - startSubArrayFrom;\\n            } else if (cur == maxK) {\\n                ans = ans + (minPos + 1) - startSubArrayFrom;\\n            } else {\\n                ans = ans + Math.min(minPos, maxPos) + 1 - startSubArrayFrom;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public long countSubarrays(int[] nums, int minK, int maxK) {\\n        long ans = 0;\\n\\n        int minPos = -1;\\n        int maxPos = -1;\\n\\n        int startSubArrayFrom = 0;\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            int cur = nums[i];\\n\\n            if (cur < minK || cur > maxK) {\\n                minPos = -1;\\n                maxPos = -1;\\n                startSubArrayFrom = i + 1;\\n                continue;\\n            }\\n\\n            if (cur == minK) {\\n                minPos = i;\\n            }\\n\\n            if (cur == maxK) {\\n                maxPos = i;\\n            }\\n\\n            if (minPos == -1 || maxPos == -1) {\\n                continue;\\n            }\\n\\n            if (cur == minK) {\\n                ans = ans + (maxPos + 1) - startSubArrayFrom;\\n            } else if (cur == maxK) {\\n                ans = ans + (minPos + 1) - startSubArrayFrom;\\n            } else {\\n                ans = ans + Math.min(minPos, maxPos) + 1 - startSubArrayFrom;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3853839,
                "title": "c-solution",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize a variable ans to 0 to keep track of the count of valid subarrays.\\n2. Initialize variables start, mini, and maxi to -1. start will be used to keep track of the starting index of the current subarray, and mini and maxi will be used to keep track of the indices of the last occurrence of minK and maxK, respectively.\\n3. Iterate through the elements of the vector nums using a for loop.\\n4. For each element nums[i], check if it is outside the range [minK, maxK]. If it is, reset both mini and maxi to -1, and update the start index to i + 1. This indicates that the current subarray does not satisfy the constraints, and we need to start looking for a new subarray from the next index.\\n5. If nums[i] is equal to minK, update mini to the current index i.\\n6. If nums[i] is equal to maxK, update maxi to the current index i.\\n7. If both mini and maxi are not -1, it means that we have found a valid subarray. The count of valid subarrays is then incremented by the number of subarrays that can be formed between the start index and the minimum of mini and maxi (inclusive), which is (min(mini, maxi) - start + 1).\\n8. Repeat steps 3-7 until all elements of the vector nums are processed.\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n        long long ans = 0;\\n        int n = nums.size();\\n        int start = 0, mini = -1, maxi = -1;\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] < minK || nums[i] > maxK) {\\n                mini = maxi = -1;\\n                start = i + 1;\\n            }\\n            if (nums[i] == minK) {\\n                mini = i;\\n            }\\n            if (nums[i] == maxK) {\\n                maxi = i;\\n            }\\n            if (mini != -1 && maxi != -1) {\\n                ans += (min(mini, maxi) - start + 1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Queue",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n        long long ans = 0;\\n        int n = nums.size();\\n        int start = 0, mini = -1, maxi = -1;\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] < minK || nums[i] > maxK) {\\n                mini = maxi = -1;\\n                start = i + 1;\\n            }\\n            if (nums[i] == minK) {\\n                mini = i;\\n            }\\n            if (nums[i] == maxK) {\\n                maxi = i;\\n            }\\n            if (mini != -1 && maxi != -1) {\\n                ans += (min(mini, maxi) - start + 1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3825310,
                "title": "solution-in-kotlin-o-nlogn",
                "content": "# Intuition\\nWe can iterate over the array using the index as the start index and then try and find the right the start and end boundaries of the potential valid sub-arrays starting from i.\\n\\nThis can be done with an extra loop, but in order to do it more efficiently we can keep track of the indices of minK values, maxK values and values either larger than maxK or smaller than minK in a binary tree. Then, we can find the boundaries in logarithmic time in the following way:\\n* (1) find the index of the next min k\\n* (2) find the index of the next max k\\n* (3) keep the maximum of the previous two values. This is the start boundary of the sub-arrays.\\n* (4) then find the index of the next value either smaller than min k or larger than max k. If there\\'s no value, assign the end of the array to that. \\n* If the value from (4) is smaller than the value from (3), there is no valid subarray starting at i. If it\\'s larger the difference gives us the number of valid sub-arrays starting from i. \\n\\n# Approach\\nSee intuition\\n\\n# Complexity\\n- Time complexity: $$O(N*logN)$$\\n\\n- Space complexity: $$O(N)$$\\n\\n# Code\\n```\\nclass Solution {\\n    fun countSubarrays(nums: IntArray, minK: Int, maxK: Int): Long {\\n        val smallerOrLargerIndices = TreeSet<Int>()\\n        val minKIndices = TreeSet<Int>()\\n        val maxKIndices = TreeSet<Int>()\\n\\n        for (i in 0 .. nums.size-1) {\\n            val num = nums[i]\\n            if (num == minK) {\\n                minKIndices.add(i)\\n            } else if (num == maxK) {\\n                maxKIndices.add(i)\\n            } else if (num < minK || num > maxK) {\\n                smallerOrLargerIndices.add(i)\\n            }\\n        }\\n\\n        var sum = 0L\\n        for (i in 0 .. nums.size-1) {\\n            val nextMinK = if (nums[i] == minK) {\\n                i\\n            } else {\\n                minKIndices.higher(i)\\n            }\\n            val nextMaxK = if (nums[i] == maxK) {\\n                i\\n            } else {\\n                maxKIndices.higher(i)\\n            }\\n            // println(\"i = $i, nextMaxK = $nextMaxK, nextMinK = $nextMinK\")\\n            if (nextMaxK != null && nextMinK != null) {\\n                val maxOfNextMinAndMaxK = Math.max(nextMinK, nextMaxK)\\n                val nextSmallerOrLarger = if(nums[i] < minK || nums[i] > maxK) {\\n                    i\\n                } else {\\n                    smallerOrLargerIndices.higher(i)\\n                }\\n                // println(\"i = $i, maxOfNextMinAndMaxK = $maxOfNextMinAndMaxK, nextSmallerOrLarger = $nextSmallerOrLarger\")\\n                if (nextSmallerOrLarger == null) {\\n                    val windowSizeEnd = nums.size-1 - maxOfNextMinAndMaxK + 1\\n                    // println(\"i = $i, nextSmallerOrLarger = $nextSmallerOrLarger, maxOfNextMinAndMaxK = $maxOfNextMinAndMaxK, windowSizeEnd = $windowSizeEnd\")\\n                    sum += windowSizeEnd\\n                } else {\\n                    if (nextSmallerOrLarger > maxOfNextMinAndMaxK) {\\n                        val windowSizeEnd = nextSmallerOrLarger - maxOfNextMinAndMaxK\\n                        // println(\"i = $i, nextSmallerOrLarger = $nextSmallerOrLarger, maxOfNextMinAndMaxK = $maxOfNextMinAndMaxK, windowSizeEnd = $windowSizeEnd\")\\n                        sum += windowSizeEnd\\n                    }\\n                }\\n            }\\n        }\\n\\n        return sum\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun countSubarrays(nums: IntArray, minK: Int, maxK: Int): Long {\\n        val smallerOrLargerIndices = TreeSet<Int>()\\n        val minKIndices = TreeSet<Int>()\\n        val maxKIndices = TreeSet<Int>()\\n\\n        for (i in 0 .. nums.size-1) {\\n            val num = nums[i]\\n            if (num == minK) {\\n                minKIndices.add(i)\\n            } else if (num == maxK) {\\n                maxKIndices.add(i)\\n            } else if (num < minK || num > maxK) {\\n                smallerOrLargerIndices.add(i)\\n            }\\n        }\\n\\n        var sum = 0L\\n        for (i in 0 .. nums.size-1) {\\n            val nextMinK = if (nums[i] == minK) {\\n                i\\n            } else {\\n                minKIndices.higher(i)\\n            }\\n            val nextMaxK = if (nums[i] == maxK) {\\n                i\\n            } else {\\n                maxKIndices.higher(i)\\n            }\\n            // println(\"i = $i, nextMaxK = $nextMaxK, nextMinK = $nextMinK\")\\n            if (nextMaxK != null && nextMinK != null) {\\n                val maxOfNextMinAndMaxK = Math.max(nextMinK, nextMaxK)\\n                val nextSmallerOrLarger = if(nums[i] < minK || nums[i] > maxK) {\\n                    i\\n                } else {\\n                    smallerOrLargerIndices.higher(i)\\n                }\\n                // println(\"i = $i, maxOfNextMinAndMaxK = $maxOfNextMinAndMaxK, nextSmallerOrLarger = $nextSmallerOrLarger\")\\n                if (nextSmallerOrLarger == null) {\\n                    val windowSizeEnd = nums.size-1 - maxOfNextMinAndMaxK + 1\\n                    // println(\"i = $i, nextSmallerOrLarger = $nextSmallerOrLarger, maxOfNextMinAndMaxK = $maxOfNextMinAndMaxK, windowSizeEnd = $windowSizeEnd\")\\n                    sum += windowSizeEnd\\n                } else {\\n                    if (nextSmallerOrLarger > maxOfNextMinAndMaxK) {\\n                        val windowSizeEnd = nextSmallerOrLarger - maxOfNextMinAndMaxK\\n                        // println(\"i = $i, nextSmallerOrLarger = $nextSmallerOrLarger, maxOfNextMinAndMaxK = $maxOfNextMinAndMaxK, windowSizeEnd = $windowSizeEnd\")\\n                        sum += windowSizeEnd\\n                    }\\n                }\\n            }\\n        }\\n\\n        return sum\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3794644,
                "title": "c-o-n-solution",
                "content": "```\\n    public long CountSubarrays(int[] nums, int minK, int maxK) {\\n            long res = 0;\\n            int prevMin = -1, prevMax = -1, boundary = -1;\\n            for(int i = 0; i < nums.Length;i++)\\n            {\\n                if(nums[i] < minK || nums[i] > maxK)\\n                {\\n                    boundary = i;\\n                    prevMin = -1;\\n                    prevMax = -1;\\n                    continue;\\n                }\\n                if(nums[i] == minK)\\n                {\\n                    prevMin = i;\\n                }\\n                if(nums[i] == maxK)\\n                {\\n                    prevMax = i;\\n                }\\n                if(prevMin != -1 && prevMax != -1)\\n                {\\n                    res += Math.Min(prevMax, prevMin) - boundary;\\n                }\\n            }\\n            return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public long CountSubarrays(int[] nums, int minK, int maxK) {\\n            long res = 0;\\n            int prevMin = -1, prevMax = -1, boundary = -1;\\n            for(int i = 0; i < nums.Length;i++)\\n            {\\n                if(nums[i] < minK || nums[i] > maxK)\\n                {\\n                    boundary = i;\\n                    prevMin = -1;\\n                    prevMax = -1;\\n                    continue;\\n                }\\n                if(nums[i] == minK)\\n                {\\n                    prevMin = i;\\n                }\\n                if(nums[i] == maxK)\\n                {\\n                    prevMax = i;\\n                }\\n                if(prevMin != -1 && prevMax != -1)\\n                {\\n                    res += Math.Min(prevMax, prevMin) - boundary;\\n                }\\n            }\\n            return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3770140,
                "title": "simple-usinng-sliding-window-method",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->By simply using sliding window while this we will keep tracking indices max and min of the window that we create, so when condition is fullfil (i.e max = maxk and min = mink) we add total subarray can be create in ans by consider distance betwwen minimum of index of max or min element and start point(i index),\\n\\n# Complexity\\n- Time complexity:**O(n)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:**O(1)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n        int n = nums.size();\\n        long long maxi = INT_MIN;\\n        long long mini = INT_MAX;\\n        \\n        int imax = 0, imin = 0;\\n        \\n        int i = 0;\\n        long long ans = 0;\\n        \\n        for(int j = 0; j < n; j++){\\n            if(nums[j]>=maxi) maxi = nums[j], imax = j;\\n            if(nums[j]<=mini) mini = nums[j], imin = j;\\n            \\n            if(maxi==maxK && mini == minK){\\n                ans += min(imax,imin) - i +1;\\n            }\\n            \\n            else if(maxi > maxK || mini < minK){\\n                mini = INT_MAX;\\n                maxi = INT_MIN;\\n                i = j+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n        int n = nums.size();\\n        long long maxi = INT_MIN;\\n        long long mini = INT_MAX;\\n        \\n        int imax = 0, imin = 0;\\n        \\n        int i = 0;\\n        long long ans = 0;\\n        \\n        for(int j = 0; j < n; j++){\\n            if(nums[j]>=maxi) maxi = nums[j], imax = j;\\n            if(nums[j]<=mini) mini = nums[j], imin = j;\\n            \\n            if(maxi==maxK && mini == minK){\\n                ans += min(imax,imin) - i +1;\\n            }\\n            \\n            else if(maxi > maxK || mini < minK){\\n                mini = INT_MAX;\\n                maxi = INT_MIN;\\n                i = j+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1821019,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "wish u survive today \\uD83D\\uDE4F"
                    },
                    {
                        "username": "jamAL108",
                        "content": "it was fun solving this prob"
                    },
                    {
                        "username": "aitachii",
                        "content": "Example 2 has 10 because it has\\n[1], [1], [1], [1],\\n[1,1], [1,1], [1,1],\\n[1,1,1], [1,1,1], \\nand the whole array [1,1,1,1]\\n\\nAlso, a contiguous subarray should have no skipped elements\\ne.g. given [1,2,3,4,5]\\n[2,3,4] is contiguous while [1,3,5] is not."
                    },
                    {
                        "username": "rajangoenka148",
                        "content": "Thank you for this explanation it helped.\n\nin the first example, why is nums[5] = [5] not a sub-array. Can you please explain?\nor are we suppose to take minK and maxK values  in compulsory?\n\nEdit: Yes we need to. Thanks anyway."
                    },
                    {
                        "username": "rahulrauki",
                        "content": "Its with great sadness I inform you that my solution gave TLE :("
                    },
                    {
                        "username": "iamdeepeshyadav",
                        "content": "Us moment 2023"
                    },
                    {
                        "username": "jperrin36",
                        "content": "felt this"
                    },
                    {
                        "username": "thou_mayest",
                        "content": "same :\\')"
                    },
                    {
                        "username": "TsuruLee",
                        "content": "A high quality problem. worth to save for practicing again in the future."
                    },
                    {
                        "username": "UchihaKim",
                        "content": "i miss the easy questions."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Something\\'s wrong I can feel it"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Great question! A doable hard problem :) \\nWhy is this tagged with queue though? I tried doing it with a queue, but that was O(N^2). I switched to using pointers and made it O(n). None of the solutions I\\'ve seen use queue. I\\'d recommend removing that tag."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "In  example  having  an array [1,3,5,2,7,5] with  minK = 1, maxK = 5.\nand its Output: 2 with the fixed-bound subarrays are [1,3,5] and [1,3,5,2].many of you are thinking  that\nwhy we were not include an [1,3] ,the reason is that ( in [1,3] subarray the minimum is=1 but maximum value is=3) so,we have to consider an subarray with an including  mink and maxk thats why we are not consider that ."
                    },
                    {
                        "username": "hgunwant38",
                        "content": "[@a1shine](/a1shine) because the given array is [1,3,5,2,7,5] and if we take 7 then it becomes greater than maxK. We need to form a contiguous subarray. [1,3,5,2,5] is not the one. "
                    },
                    {
                        "username": "alshine",
                        "content": "[@harshcodes04](/harshcodes04) 2 hours ago this answer would have speeded up my decision process so much"
                    },
                    {
                        "username": "harshcodes04",
                        "content": "[@a1shine](/a1shine) Bcoz we need a contiguous subarray."
                    },
                    {
                        "username": "alshine",
                        "content": "why don\\'t we add the option [1,3,5,2,5]?"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\nInitialize a variable ans to 0 and two pointers maxI and minI to -1.\\n\\nTraverse the given array nums from left to right.\\n\\nIf the current element is not in the range of minK and maxK, reset the pointers to -1 and set the start pointer to i+1.\\n\\nIf the current element is equal to minK, update minI to i.\\n\\nIf the current element is equal to maxK, update maxI to i.\\n\\nFor each element, add the maximum of 0 and the minimum of minI and maxI minus start plus 1 to ans.\\n\\nReturn ans."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code Link:-\\n\\nhttps://leetcode.com/problems/count-subarrays-with-fixed-bounds/solutions/3255588/easy-to-understand-code-with-steps/"
                    },
                    {
                        "username": "jperrin36",
                        "content": "LeetCode shouldnt assign hard questions on the weekend -____-"
                    }
                ]
            },
            {
                "id": 1821004,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "wish u survive today \\uD83D\\uDE4F"
                    },
                    {
                        "username": "jamAL108",
                        "content": "it was fun solving this prob"
                    },
                    {
                        "username": "aitachii",
                        "content": "Example 2 has 10 because it has\\n[1], [1], [1], [1],\\n[1,1], [1,1], [1,1],\\n[1,1,1], [1,1,1], \\nand the whole array [1,1,1,1]\\n\\nAlso, a contiguous subarray should have no skipped elements\\ne.g. given [1,2,3,4,5]\\n[2,3,4] is contiguous while [1,3,5] is not."
                    },
                    {
                        "username": "rajangoenka148",
                        "content": "Thank you for this explanation it helped.\n\nin the first example, why is nums[5] = [5] not a sub-array. Can you please explain?\nor are we suppose to take minK and maxK values  in compulsory?\n\nEdit: Yes we need to. Thanks anyway."
                    },
                    {
                        "username": "rahulrauki",
                        "content": "Its with great sadness I inform you that my solution gave TLE :("
                    },
                    {
                        "username": "iamdeepeshyadav",
                        "content": "Us moment 2023"
                    },
                    {
                        "username": "jperrin36",
                        "content": "felt this"
                    },
                    {
                        "username": "thou_mayest",
                        "content": "same :\\')"
                    },
                    {
                        "username": "TsuruLee",
                        "content": "A high quality problem. worth to save for practicing again in the future."
                    },
                    {
                        "username": "UchihaKim",
                        "content": "i miss the easy questions."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Something\\'s wrong I can feel it"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Great question! A doable hard problem :) \\nWhy is this tagged with queue though? I tried doing it with a queue, but that was O(N^2). I switched to using pointers and made it O(n). None of the solutions I\\'ve seen use queue. I\\'d recommend removing that tag."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "In  example  having  an array [1,3,5,2,7,5] with  minK = 1, maxK = 5.\nand its Output: 2 with the fixed-bound subarrays are [1,3,5] and [1,3,5,2].many of you are thinking  that\nwhy we were not include an [1,3] ,the reason is that ( in [1,3] subarray the minimum is=1 but maximum value is=3) so,we have to consider an subarray with an including  mink and maxk thats why we are not consider that ."
                    },
                    {
                        "username": "hgunwant38",
                        "content": "[@a1shine](/a1shine) because the given array is [1,3,5,2,7,5] and if we take 7 then it becomes greater than maxK. We need to form a contiguous subarray. [1,3,5,2,5] is not the one. "
                    },
                    {
                        "username": "alshine",
                        "content": "[@harshcodes04](/harshcodes04) 2 hours ago this answer would have speeded up my decision process so much"
                    },
                    {
                        "username": "harshcodes04",
                        "content": "[@a1shine](/a1shine) Bcoz we need a contiguous subarray."
                    },
                    {
                        "username": "alshine",
                        "content": "why don\\'t we add the option [1,3,5,2,5]?"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\nInitialize a variable ans to 0 and two pointers maxI and minI to -1.\\n\\nTraverse the given array nums from left to right.\\n\\nIf the current element is not in the range of minK and maxK, reset the pointers to -1 and set the start pointer to i+1.\\n\\nIf the current element is equal to minK, update minI to i.\\n\\nIf the current element is equal to maxK, update maxI to i.\\n\\nFor each element, add the maximum of 0 and the minimum of minI and maxI minus start plus 1 to ans.\\n\\nReturn ans."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code Link:-\\n\\nhttps://leetcode.com/problems/count-subarrays-with-fixed-bounds/solutions/3255588/easy-to-understand-code-with-steps/"
                    },
                    {
                        "username": "jperrin36",
                        "content": "LeetCode shouldnt assign hard questions on the weekend -____-"
                    }
                ]
            },
            {
                "id": 1821270,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "wish u survive today \\uD83D\\uDE4F"
                    },
                    {
                        "username": "jamAL108",
                        "content": "it was fun solving this prob"
                    },
                    {
                        "username": "aitachii",
                        "content": "Example 2 has 10 because it has\\n[1], [1], [1], [1],\\n[1,1], [1,1], [1,1],\\n[1,1,1], [1,1,1], \\nand the whole array [1,1,1,1]\\n\\nAlso, a contiguous subarray should have no skipped elements\\ne.g. given [1,2,3,4,5]\\n[2,3,4] is contiguous while [1,3,5] is not."
                    },
                    {
                        "username": "rajangoenka148",
                        "content": "Thank you for this explanation it helped.\n\nin the first example, why is nums[5] = [5] not a sub-array. Can you please explain?\nor are we suppose to take minK and maxK values  in compulsory?\n\nEdit: Yes we need to. Thanks anyway."
                    },
                    {
                        "username": "rahulrauki",
                        "content": "Its with great sadness I inform you that my solution gave TLE :("
                    },
                    {
                        "username": "iamdeepeshyadav",
                        "content": "Us moment 2023"
                    },
                    {
                        "username": "jperrin36",
                        "content": "felt this"
                    },
                    {
                        "username": "thou_mayest",
                        "content": "same :\\')"
                    },
                    {
                        "username": "TsuruLee",
                        "content": "A high quality problem. worth to save for practicing again in the future."
                    },
                    {
                        "username": "UchihaKim",
                        "content": "i miss the easy questions."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Something\\'s wrong I can feel it"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Great question! A doable hard problem :) \\nWhy is this tagged with queue though? I tried doing it with a queue, but that was O(N^2). I switched to using pointers and made it O(n). None of the solutions I\\'ve seen use queue. I\\'d recommend removing that tag."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "In  example  having  an array [1,3,5,2,7,5] with  minK = 1, maxK = 5.\nand its Output: 2 with the fixed-bound subarrays are [1,3,5] and [1,3,5,2].many of you are thinking  that\nwhy we were not include an [1,3] ,the reason is that ( in [1,3] subarray the minimum is=1 but maximum value is=3) so,we have to consider an subarray with an including  mink and maxk thats why we are not consider that ."
                    },
                    {
                        "username": "hgunwant38",
                        "content": "[@a1shine](/a1shine) because the given array is [1,3,5,2,7,5] and if we take 7 then it becomes greater than maxK. We need to form a contiguous subarray. [1,3,5,2,5] is not the one. "
                    },
                    {
                        "username": "alshine",
                        "content": "[@harshcodes04](/harshcodes04) 2 hours ago this answer would have speeded up my decision process so much"
                    },
                    {
                        "username": "harshcodes04",
                        "content": "[@a1shine](/a1shine) Bcoz we need a contiguous subarray."
                    },
                    {
                        "username": "alshine",
                        "content": "why don\\'t we add the option [1,3,5,2,5]?"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\nInitialize a variable ans to 0 and two pointers maxI and minI to -1.\\n\\nTraverse the given array nums from left to right.\\n\\nIf the current element is not in the range of minK and maxK, reset the pointers to -1 and set the start pointer to i+1.\\n\\nIf the current element is equal to minK, update minI to i.\\n\\nIf the current element is equal to maxK, update maxI to i.\\n\\nFor each element, add the maximum of 0 and the minimum of minI and maxI minus start plus 1 to ans.\\n\\nReturn ans."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code Link:-\\n\\nhttps://leetcode.com/problems/count-subarrays-with-fixed-bounds/solutions/3255588/easy-to-understand-code-with-steps/"
                    },
                    {
                        "username": "jperrin36",
                        "content": "LeetCode shouldnt assign hard questions on the weekend -____-"
                    }
                ]
            },
            {
                "id": 1821272,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "wish u survive today \\uD83D\\uDE4F"
                    },
                    {
                        "username": "jamAL108",
                        "content": "it was fun solving this prob"
                    },
                    {
                        "username": "aitachii",
                        "content": "Example 2 has 10 because it has\\n[1], [1], [1], [1],\\n[1,1], [1,1], [1,1],\\n[1,1,1], [1,1,1], \\nand the whole array [1,1,1,1]\\n\\nAlso, a contiguous subarray should have no skipped elements\\ne.g. given [1,2,3,4,5]\\n[2,3,4] is contiguous while [1,3,5] is not."
                    },
                    {
                        "username": "rajangoenka148",
                        "content": "Thank you for this explanation it helped.\n\nin the first example, why is nums[5] = [5] not a sub-array. Can you please explain?\nor are we suppose to take minK and maxK values  in compulsory?\n\nEdit: Yes we need to. Thanks anyway."
                    },
                    {
                        "username": "rahulrauki",
                        "content": "Its with great sadness I inform you that my solution gave TLE :("
                    },
                    {
                        "username": "iamdeepeshyadav",
                        "content": "Us moment 2023"
                    },
                    {
                        "username": "jperrin36",
                        "content": "felt this"
                    },
                    {
                        "username": "thou_mayest",
                        "content": "same :\\')"
                    },
                    {
                        "username": "TsuruLee",
                        "content": "A high quality problem. worth to save for practicing again in the future."
                    },
                    {
                        "username": "UchihaKim",
                        "content": "i miss the easy questions."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Something\\'s wrong I can feel it"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Great question! A doable hard problem :) \\nWhy is this tagged with queue though? I tried doing it with a queue, but that was O(N^2). I switched to using pointers and made it O(n). None of the solutions I\\'ve seen use queue. I\\'d recommend removing that tag."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "In  example  having  an array [1,3,5,2,7,5] with  minK = 1, maxK = 5.\nand its Output: 2 with the fixed-bound subarrays are [1,3,5] and [1,3,5,2].many of you are thinking  that\nwhy we were not include an [1,3] ,the reason is that ( in [1,3] subarray the minimum is=1 but maximum value is=3) so,we have to consider an subarray with an including  mink and maxk thats why we are not consider that ."
                    },
                    {
                        "username": "hgunwant38",
                        "content": "[@a1shine](/a1shine) because the given array is [1,3,5,2,7,5] and if we take 7 then it becomes greater than maxK. We need to form a contiguous subarray. [1,3,5,2,5] is not the one. "
                    },
                    {
                        "username": "alshine",
                        "content": "[@harshcodes04](/harshcodes04) 2 hours ago this answer would have speeded up my decision process so much"
                    },
                    {
                        "username": "harshcodes04",
                        "content": "[@a1shine](/a1shine) Bcoz we need a contiguous subarray."
                    },
                    {
                        "username": "alshine",
                        "content": "why don\\'t we add the option [1,3,5,2,5]?"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\nInitialize a variable ans to 0 and two pointers maxI and minI to -1.\\n\\nTraverse the given array nums from left to right.\\n\\nIf the current element is not in the range of minK and maxK, reset the pointers to -1 and set the start pointer to i+1.\\n\\nIf the current element is equal to minK, update minI to i.\\n\\nIf the current element is equal to maxK, update maxI to i.\\n\\nFor each element, add the maximum of 0 and the minimum of minI and maxI minus start plus 1 to ans.\\n\\nReturn ans."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code Link:-\\n\\nhttps://leetcode.com/problems/count-subarrays-with-fixed-bounds/solutions/3255588/easy-to-understand-code-with-steps/"
                    },
                    {
                        "username": "jperrin36",
                        "content": "LeetCode shouldnt assign hard questions on the weekend -____-"
                    }
                ]
            },
            {
                "id": 1820923,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "wish u survive today \\uD83D\\uDE4F"
                    },
                    {
                        "username": "jamAL108",
                        "content": "it was fun solving this prob"
                    },
                    {
                        "username": "aitachii",
                        "content": "Example 2 has 10 because it has\\n[1], [1], [1], [1],\\n[1,1], [1,1], [1,1],\\n[1,1,1], [1,1,1], \\nand the whole array [1,1,1,1]\\n\\nAlso, a contiguous subarray should have no skipped elements\\ne.g. given [1,2,3,4,5]\\n[2,3,4] is contiguous while [1,3,5] is not."
                    },
                    {
                        "username": "rajangoenka148",
                        "content": "Thank you for this explanation it helped.\n\nin the first example, why is nums[5] = [5] not a sub-array. Can you please explain?\nor are we suppose to take minK and maxK values  in compulsory?\n\nEdit: Yes we need to. Thanks anyway."
                    },
                    {
                        "username": "rahulrauki",
                        "content": "Its with great sadness I inform you that my solution gave TLE :("
                    },
                    {
                        "username": "iamdeepeshyadav",
                        "content": "Us moment 2023"
                    },
                    {
                        "username": "jperrin36",
                        "content": "felt this"
                    },
                    {
                        "username": "thou_mayest",
                        "content": "same :\\')"
                    },
                    {
                        "username": "TsuruLee",
                        "content": "A high quality problem. worth to save for practicing again in the future."
                    },
                    {
                        "username": "UchihaKim",
                        "content": "i miss the easy questions."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Something\\'s wrong I can feel it"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Great question! A doable hard problem :) \\nWhy is this tagged with queue though? I tried doing it with a queue, but that was O(N^2). I switched to using pointers and made it O(n). None of the solutions I\\'ve seen use queue. I\\'d recommend removing that tag."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "In  example  having  an array [1,3,5,2,7,5] with  minK = 1, maxK = 5.\nand its Output: 2 with the fixed-bound subarrays are [1,3,5] and [1,3,5,2].many of you are thinking  that\nwhy we were not include an [1,3] ,the reason is that ( in [1,3] subarray the minimum is=1 but maximum value is=3) so,we have to consider an subarray with an including  mink and maxk thats why we are not consider that ."
                    },
                    {
                        "username": "hgunwant38",
                        "content": "[@a1shine](/a1shine) because the given array is [1,3,5,2,7,5] and if we take 7 then it becomes greater than maxK. We need to form a contiguous subarray. [1,3,5,2,5] is not the one. "
                    },
                    {
                        "username": "alshine",
                        "content": "[@harshcodes04](/harshcodes04) 2 hours ago this answer would have speeded up my decision process so much"
                    },
                    {
                        "username": "harshcodes04",
                        "content": "[@a1shine](/a1shine) Bcoz we need a contiguous subarray."
                    },
                    {
                        "username": "alshine",
                        "content": "why don\\'t we add the option [1,3,5,2,5]?"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\nInitialize a variable ans to 0 and two pointers maxI and minI to -1.\\n\\nTraverse the given array nums from left to right.\\n\\nIf the current element is not in the range of minK and maxK, reset the pointers to -1 and set the start pointer to i+1.\\n\\nIf the current element is equal to minK, update minI to i.\\n\\nIf the current element is equal to maxK, update maxI to i.\\n\\nFor each element, add the maximum of 0 and the minimum of minI and maxI minus start plus 1 to ans.\\n\\nReturn ans."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code Link:-\\n\\nhttps://leetcode.com/problems/count-subarrays-with-fixed-bounds/solutions/3255588/easy-to-understand-code-with-steps/"
                    },
                    {
                        "username": "jperrin36",
                        "content": "LeetCode shouldnt assign hard questions on the weekend -____-"
                    }
                ]
            },
            {
                "id": 1821055,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "wish u survive today \\uD83D\\uDE4F"
                    },
                    {
                        "username": "jamAL108",
                        "content": "it was fun solving this prob"
                    },
                    {
                        "username": "aitachii",
                        "content": "Example 2 has 10 because it has\\n[1], [1], [1], [1],\\n[1,1], [1,1], [1,1],\\n[1,1,1], [1,1,1], \\nand the whole array [1,1,1,1]\\n\\nAlso, a contiguous subarray should have no skipped elements\\ne.g. given [1,2,3,4,5]\\n[2,3,4] is contiguous while [1,3,5] is not."
                    },
                    {
                        "username": "rajangoenka148",
                        "content": "Thank you for this explanation it helped.\n\nin the first example, why is nums[5] = [5] not a sub-array. Can you please explain?\nor are we suppose to take minK and maxK values  in compulsory?\n\nEdit: Yes we need to. Thanks anyway."
                    },
                    {
                        "username": "rahulrauki",
                        "content": "Its with great sadness I inform you that my solution gave TLE :("
                    },
                    {
                        "username": "iamdeepeshyadav",
                        "content": "Us moment 2023"
                    },
                    {
                        "username": "jperrin36",
                        "content": "felt this"
                    },
                    {
                        "username": "thou_mayest",
                        "content": "same :\\')"
                    },
                    {
                        "username": "TsuruLee",
                        "content": "A high quality problem. worth to save for practicing again in the future."
                    },
                    {
                        "username": "UchihaKim",
                        "content": "i miss the easy questions."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Something\\'s wrong I can feel it"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Great question! A doable hard problem :) \\nWhy is this tagged with queue though? I tried doing it with a queue, but that was O(N^2). I switched to using pointers and made it O(n). None of the solutions I\\'ve seen use queue. I\\'d recommend removing that tag."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "In  example  having  an array [1,3,5,2,7,5] with  minK = 1, maxK = 5.\nand its Output: 2 with the fixed-bound subarrays are [1,3,5] and [1,3,5,2].many of you are thinking  that\nwhy we were not include an [1,3] ,the reason is that ( in [1,3] subarray the minimum is=1 but maximum value is=3) so,we have to consider an subarray with an including  mink and maxk thats why we are not consider that ."
                    },
                    {
                        "username": "hgunwant38",
                        "content": "[@a1shine](/a1shine) because the given array is [1,3,5,2,7,5] and if we take 7 then it becomes greater than maxK. We need to form a contiguous subarray. [1,3,5,2,5] is not the one. "
                    },
                    {
                        "username": "alshine",
                        "content": "[@harshcodes04](/harshcodes04) 2 hours ago this answer would have speeded up my decision process so much"
                    },
                    {
                        "username": "harshcodes04",
                        "content": "[@a1shine](/a1shine) Bcoz we need a contiguous subarray."
                    },
                    {
                        "username": "alshine",
                        "content": "why don\\'t we add the option [1,3,5,2,5]?"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\nInitialize a variable ans to 0 and two pointers maxI and minI to -1.\\n\\nTraverse the given array nums from left to right.\\n\\nIf the current element is not in the range of minK and maxK, reset the pointers to -1 and set the start pointer to i+1.\\n\\nIf the current element is equal to minK, update minI to i.\\n\\nIf the current element is equal to maxK, update maxI to i.\\n\\nFor each element, add the maximum of 0 and the minimum of minI and maxI minus start plus 1 to ans.\\n\\nReturn ans."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code Link:-\\n\\nhttps://leetcode.com/problems/count-subarrays-with-fixed-bounds/solutions/3255588/easy-to-understand-code-with-steps/"
                    },
                    {
                        "username": "jperrin36",
                        "content": "LeetCode shouldnt assign hard questions on the weekend -____-"
                    }
                ]
            },
            {
                "id": 1821476,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "wish u survive today \\uD83D\\uDE4F"
                    },
                    {
                        "username": "jamAL108",
                        "content": "it was fun solving this prob"
                    },
                    {
                        "username": "aitachii",
                        "content": "Example 2 has 10 because it has\\n[1], [1], [1], [1],\\n[1,1], [1,1], [1,1],\\n[1,1,1], [1,1,1], \\nand the whole array [1,1,1,1]\\n\\nAlso, a contiguous subarray should have no skipped elements\\ne.g. given [1,2,3,4,5]\\n[2,3,4] is contiguous while [1,3,5] is not."
                    },
                    {
                        "username": "rajangoenka148",
                        "content": "Thank you for this explanation it helped.\n\nin the first example, why is nums[5] = [5] not a sub-array. Can you please explain?\nor are we suppose to take minK and maxK values  in compulsory?\n\nEdit: Yes we need to. Thanks anyway."
                    },
                    {
                        "username": "rahulrauki",
                        "content": "Its with great sadness I inform you that my solution gave TLE :("
                    },
                    {
                        "username": "iamdeepeshyadav",
                        "content": "Us moment 2023"
                    },
                    {
                        "username": "jperrin36",
                        "content": "felt this"
                    },
                    {
                        "username": "thou_mayest",
                        "content": "same :\\')"
                    },
                    {
                        "username": "TsuruLee",
                        "content": "A high quality problem. worth to save for practicing again in the future."
                    },
                    {
                        "username": "UchihaKim",
                        "content": "i miss the easy questions."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Something\\'s wrong I can feel it"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Great question! A doable hard problem :) \\nWhy is this tagged with queue though? I tried doing it with a queue, but that was O(N^2). I switched to using pointers and made it O(n). None of the solutions I\\'ve seen use queue. I\\'d recommend removing that tag."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "In  example  having  an array [1,3,5,2,7,5] with  minK = 1, maxK = 5.\nand its Output: 2 with the fixed-bound subarrays are [1,3,5] and [1,3,5,2].many of you are thinking  that\nwhy we were not include an [1,3] ,the reason is that ( in [1,3] subarray the minimum is=1 but maximum value is=3) so,we have to consider an subarray with an including  mink and maxk thats why we are not consider that ."
                    },
                    {
                        "username": "hgunwant38",
                        "content": "[@a1shine](/a1shine) because the given array is [1,3,5,2,7,5] and if we take 7 then it becomes greater than maxK. We need to form a contiguous subarray. [1,3,5,2,5] is not the one. "
                    },
                    {
                        "username": "alshine",
                        "content": "[@harshcodes04](/harshcodes04) 2 hours ago this answer would have speeded up my decision process so much"
                    },
                    {
                        "username": "harshcodes04",
                        "content": "[@a1shine](/a1shine) Bcoz we need a contiguous subarray."
                    },
                    {
                        "username": "alshine",
                        "content": "why don\\'t we add the option [1,3,5,2,5]?"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\nInitialize a variable ans to 0 and two pointers maxI and minI to -1.\\n\\nTraverse the given array nums from left to right.\\n\\nIf the current element is not in the range of minK and maxK, reset the pointers to -1 and set the start pointer to i+1.\\n\\nIf the current element is equal to minK, update minI to i.\\n\\nIf the current element is equal to maxK, update maxI to i.\\n\\nFor each element, add the maximum of 0 and the minimum of minI and maxI minus start plus 1 to ans.\\n\\nReturn ans."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code Link:-\\n\\nhttps://leetcode.com/problems/count-subarrays-with-fixed-bounds/solutions/3255588/easy-to-understand-code-with-steps/"
                    },
                    {
                        "username": "jperrin36",
                        "content": "LeetCode shouldnt assign hard questions on the weekend -____-"
                    }
                ]
            },
            {
                "id": 1821027,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "wish u survive today \\uD83D\\uDE4F"
                    },
                    {
                        "username": "jamAL108",
                        "content": "it was fun solving this prob"
                    },
                    {
                        "username": "aitachii",
                        "content": "Example 2 has 10 because it has\\n[1], [1], [1], [1],\\n[1,1], [1,1], [1,1],\\n[1,1,1], [1,1,1], \\nand the whole array [1,1,1,1]\\n\\nAlso, a contiguous subarray should have no skipped elements\\ne.g. given [1,2,3,4,5]\\n[2,3,4] is contiguous while [1,3,5] is not."
                    },
                    {
                        "username": "rajangoenka148",
                        "content": "Thank you for this explanation it helped.\n\nin the first example, why is nums[5] = [5] not a sub-array. Can you please explain?\nor are we suppose to take minK and maxK values  in compulsory?\n\nEdit: Yes we need to. Thanks anyway."
                    },
                    {
                        "username": "rahulrauki",
                        "content": "Its with great sadness I inform you that my solution gave TLE :("
                    },
                    {
                        "username": "iamdeepeshyadav",
                        "content": "Us moment 2023"
                    },
                    {
                        "username": "jperrin36",
                        "content": "felt this"
                    },
                    {
                        "username": "thou_mayest",
                        "content": "same :\\')"
                    },
                    {
                        "username": "TsuruLee",
                        "content": "A high quality problem. worth to save for practicing again in the future."
                    },
                    {
                        "username": "UchihaKim",
                        "content": "i miss the easy questions."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Something\\'s wrong I can feel it"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Great question! A doable hard problem :) \\nWhy is this tagged with queue though? I tried doing it with a queue, but that was O(N^2). I switched to using pointers and made it O(n). None of the solutions I\\'ve seen use queue. I\\'d recommend removing that tag."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "In  example  having  an array [1,3,5,2,7,5] with  minK = 1, maxK = 5.\nand its Output: 2 with the fixed-bound subarrays are [1,3,5] and [1,3,5,2].many of you are thinking  that\nwhy we were not include an [1,3] ,the reason is that ( in [1,3] subarray the minimum is=1 but maximum value is=3) so,we have to consider an subarray with an including  mink and maxk thats why we are not consider that ."
                    },
                    {
                        "username": "hgunwant38",
                        "content": "[@a1shine](/a1shine) because the given array is [1,3,5,2,7,5] and if we take 7 then it becomes greater than maxK. We need to form a contiguous subarray. [1,3,5,2,5] is not the one. "
                    },
                    {
                        "username": "alshine",
                        "content": "[@harshcodes04](/harshcodes04) 2 hours ago this answer would have speeded up my decision process so much"
                    },
                    {
                        "username": "harshcodes04",
                        "content": "[@a1shine](/a1shine) Bcoz we need a contiguous subarray."
                    },
                    {
                        "username": "alshine",
                        "content": "why don\\'t we add the option [1,3,5,2,5]?"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\nInitialize a variable ans to 0 and two pointers maxI and minI to -1.\\n\\nTraverse the given array nums from left to right.\\n\\nIf the current element is not in the range of minK and maxK, reset the pointers to -1 and set the start pointer to i+1.\\n\\nIf the current element is equal to minK, update minI to i.\\n\\nIf the current element is equal to maxK, update maxI to i.\\n\\nFor each element, add the maximum of 0 and the minimum of minI and maxI minus start plus 1 to ans.\\n\\nReturn ans."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code Link:-\\n\\nhttps://leetcode.com/problems/count-subarrays-with-fixed-bounds/solutions/3255588/easy-to-understand-code-with-steps/"
                    },
                    {
                        "username": "jperrin36",
                        "content": "LeetCode shouldnt assign hard questions on the weekend -____-"
                    }
                ]
            },
            {
                "id": 1821415,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "wish u survive today \\uD83D\\uDE4F"
                    },
                    {
                        "username": "jamAL108",
                        "content": "it was fun solving this prob"
                    },
                    {
                        "username": "aitachii",
                        "content": "Example 2 has 10 because it has\\n[1], [1], [1], [1],\\n[1,1], [1,1], [1,1],\\n[1,1,1], [1,1,1], \\nand the whole array [1,1,1,1]\\n\\nAlso, a contiguous subarray should have no skipped elements\\ne.g. given [1,2,3,4,5]\\n[2,3,4] is contiguous while [1,3,5] is not."
                    },
                    {
                        "username": "rajangoenka148",
                        "content": "Thank you for this explanation it helped.\n\nin the first example, why is nums[5] = [5] not a sub-array. Can you please explain?\nor are we suppose to take minK and maxK values  in compulsory?\n\nEdit: Yes we need to. Thanks anyway."
                    },
                    {
                        "username": "rahulrauki",
                        "content": "Its with great sadness I inform you that my solution gave TLE :("
                    },
                    {
                        "username": "iamdeepeshyadav",
                        "content": "Us moment 2023"
                    },
                    {
                        "username": "jperrin36",
                        "content": "felt this"
                    },
                    {
                        "username": "thou_mayest",
                        "content": "same :\\')"
                    },
                    {
                        "username": "TsuruLee",
                        "content": "A high quality problem. worth to save for practicing again in the future."
                    },
                    {
                        "username": "UchihaKim",
                        "content": "i miss the easy questions."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Something\\'s wrong I can feel it"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Great question! A doable hard problem :) \\nWhy is this tagged with queue though? I tried doing it with a queue, but that was O(N^2). I switched to using pointers and made it O(n). None of the solutions I\\'ve seen use queue. I\\'d recommend removing that tag."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "In  example  having  an array [1,3,5,2,7,5] with  minK = 1, maxK = 5.\nand its Output: 2 with the fixed-bound subarrays are [1,3,5] and [1,3,5,2].many of you are thinking  that\nwhy we were not include an [1,3] ,the reason is that ( in [1,3] subarray the minimum is=1 but maximum value is=3) so,we have to consider an subarray with an including  mink and maxk thats why we are not consider that ."
                    },
                    {
                        "username": "hgunwant38",
                        "content": "[@a1shine](/a1shine) because the given array is [1,3,5,2,7,5] and if we take 7 then it becomes greater than maxK. We need to form a contiguous subarray. [1,3,5,2,5] is not the one. "
                    },
                    {
                        "username": "alshine",
                        "content": "[@harshcodes04](/harshcodes04) 2 hours ago this answer would have speeded up my decision process so much"
                    },
                    {
                        "username": "harshcodes04",
                        "content": "[@a1shine](/a1shine) Bcoz we need a contiguous subarray."
                    },
                    {
                        "username": "alshine",
                        "content": "why don\\'t we add the option [1,3,5,2,5]?"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\nInitialize a variable ans to 0 and two pointers maxI and minI to -1.\\n\\nTraverse the given array nums from left to right.\\n\\nIf the current element is not in the range of minK and maxK, reset the pointers to -1 and set the start pointer to i+1.\\n\\nIf the current element is equal to minK, update minI to i.\\n\\nIf the current element is equal to maxK, update maxI to i.\\n\\nFor each element, add the maximum of 0 and the minimum of minI and maxI minus start plus 1 to ans.\\n\\nReturn ans."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code Link:-\\n\\nhttps://leetcode.com/problems/count-subarrays-with-fixed-bounds/solutions/3255588/easy-to-understand-code-with-steps/"
                    },
                    {
                        "username": "jperrin36",
                        "content": "LeetCode shouldnt assign hard questions on the weekend -____-"
                    }
                ]
            },
            {
                "id": 1821482,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "wish u survive today \\uD83D\\uDE4F"
                    },
                    {
                        "username": "jamAL108",
                        "content": "it was fun solving this prob"
                    },
                    {
                        "username": "aitachii",
                        "content": "Example 2 has 10 because it has\\n[1], [1], [1], [1],\\n[1,1], [1,1], [1,1],\\n[1,1,1], [1,1,1], \\nand the whole array [1,1,1,1]\\n\\nAlso, a contiguous subarray should have no skipped elements\\ne.g. given [1,2,3,4,5]\\n[2,3,4] is contiguous while [1,3,5] is not."
                    },
                    {
                        "username": "rajangoenka148",
                        "content": "Thank you for this explanation it helped.\n\nin the first example, why is nums[5] = [5] not a sub-array. Can you please explain?\nor are we suppose to take minK and maxK values  in compulsory?\n\nEdit: Yes we need to. Thanks anyway."
                    },
                    {
                        "username": "rahulrauki",
                        "content": "Its with great sadness I inform you that my solution gave TLE :("
                    },
                    {
                        "username": "iamdeepeshyadav",
                        "content": "Us moment 2023"
                    },
                    {
                        "username": "jperrin36",
                        "content": "felt this"
                    },
                    {
                        "username": "thou_mayest",
                        "content": "same :\\')"
                    },
                    {
                        "username": "TsuruLee",
                        "content": "A high quality problem. worth to save for practicing again in the future."
                    },
                    {
                        "username": "UchihaKim",
                        "content": "i miss the easy questions."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Something\\'s wrong I can feel it"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Great question! A doable hard problem :) \\nWhy is this tagged with queue though? I tried doing it with a queue, but that was O(N^2). I switched to using pointers and made it O(n). None of the solutions I\\'ve seen use queue. I\\'d recommend removing that tag."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "In  example  having  an array [1,3,5,2,7,5] with  minK = 1, maxK = 5.\nand its Output: 2 with the fixed-bound subarrays are [1,3,5] and [1,3,5,2].many of you are thinking  that\nwhy we were not include an [1,3] ,the reason is that ( in [1,3] subarray the minimum is=1 but maximum value is=3) so,we have to consider an subarray with an including  mink and maxk thats why we are not consider that ."
                    },
                    {
                        "username": "hgunwant38",
                        "content": "[@a1shine](/a1shine) because the given array is [1,3,5,2,7,5] and if we take 7 then it becomes greater than maxK. We need to form a contiguous subarray. [1,3,5,2,5] is not the one. "
                    },
                    {
                        "username": "alshine",
                        "content": "[@harshcodes04](/harshcodes04) 2 hours ago this answer would have speeded up my decision process so much"
                    },
                    {
                        "username": "harshcodes04",
                        "content": "[@a1shine](/a1shine) Bcoz we need a contiguous subarray."
                    },
                    {
                        "username": "alshine",
                        "content": "why don\\'t we add the option [1,3,5,2,5]?"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\nInitialize a variable ans to 0 and two pointers maxI and minI to -1.\\n\\nTraverse the given array nums from left to right.\\n\\nIf the current element is not in the range of minK and maxK, reset the pointers to -1 and set the start pointer to i+1.\\n\\nIf the current element is equal to minK, update minI to i.\\n\\nIf the current element is equal to maxK, update maxI to i.\\n\\nFor each element, add the maximum of 0 and the minimum of minI and maxI minus start plus 1 to ans.\\n\\nReturn ans."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code Link:-\\n\\nhttps://leetcode.com/problems/count-subarrays-with-fixed-bounds/solutions/3255588/easy-to-understand-code-with-steps/"
                    },
                    {
                        "username": "jperrin36",
                        "content": "LeetCode shouldnt assign hard questions on the weekend -____-"
                    }
                ]
            },
            {
                "id": 1821019,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "wish u survive today \\uD83D\\uDE4F"
                    },
                    {
                        "username": "jamAL108",
                        "content": "it was fun solving this prob"
                    },
                    {
                        "username": "aitachii",
                        "content": "Example 2 has 10 because it has\\n[1], [1], [1], [1],\\n[1,1], [1,1], [1,1],\\n[1,1,1], [1,1,1], \\nand the whole array [1,1,1,1]\\n\\nAlso, a contiguous subarray should have no skipped elements\\ne.g. given [1,2,3,4,5]\\n[2,3,4] is contiguous while [1,3,5] is not."
                    },
                    {
                        "username": "rajangoenka148",
                        "content": "Thank you for this explanation it helped.\n\nin the first example, why is nums[5] = [5] not a sub-array. Can you please explain?\nor are we suppose to take minK and maxK values  in compulsory?\n\nEdit: Yes we need to. Thanks anyway."
                    },
                    {
                        "username": "rahulrauki",
                        "content": "Its with great sadness I inform you that my solution gave TLE :("
                    },
                    {
                        "username": "iamdeepeshyadav",
                        "content": "Us moment 2023"
                    },
                    {
                        "username": "jperrin36",
                        "content": "felt this"
                    },
                    {
                        "username": "thou_mayest",
                        "content": "same :\\')"
                    },
                    {
                        "username": "TsuruLee",
                        "content": "A high quality problem. worth to save for practicing again in the future."
                    },
                    {
                        "username": "UchihaKim",
                        "content": "i miss the easy questions."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Something\\'s wrong I can feel it"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Great question! A doable hard problem :) \\nWhy is this tagged with queue though? I tried doing it with a queue, but that was O(N^2). I switched to using pointers and made it O(n). None of the solutions I\\'ve seen use queue. I\\'d recommend removing that tag."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "In  example  having  an array [1,3,5,2,7,5] with  minK = 1, maxK = 5.\nand its Output: 2 with the fixed-bound subarrays are [1,3,5] and [1,3,5,2].many of you are thinking  that\nwhy we were not include an [1,3] ,the reason is that ( in [1,3] subarray the minimum is=1 but maximum value is=3) so,we have to consider an subarray with an including  mink and maxk thats why we are not consider that ."
                    },
                    {
                        "username": "hgunwant38",
                        "content": "[@a1shine](/a1shine) because the given array is [1,3,5,2,7,5] and if we take 7 then it becomes greater than maxK. We need to form a contiguous subarray. [1,3,5,2,5] is not the one. "
                    },
                    {
                        "username": "alshine",
                        "content": "[@harshcodes04](/harshcodes04) 2 hours ago this answer would have speeded up my decision process so much"
                    },
                    {
                        "username": "harshcodes04",
                        "content": "[@a1shine](/a1shine) Bcoz we need a contiguous subarray."
                    },
                    {
                        "username": "alshine",
                        "content": "why don\\'t we add the option [1,3,5,2,5]?"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\nInitialize a variable ans to 0 and two pointers maxI and minI to -1.\\n\\nTraverse the given array nums from left to right.\\n\\nIf the current element is not in the range of minK and maxK, reset the pointers to -1 and set the start pointer to i+1.\\n\\nIf the current element is equal to minK, update minI to i.\\n\\nIf the current element is equal to maxK, update maxI to i.\\n\\nFor each element, add the maximum of 0 and the minimum of minI and maxI minus start plus 1 to ans.\\n\\nReturn ans."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code Link:-\\n\\nhttps://leetcode.com/problems/count-subarrays-with-fixed-bounds/solutions/3255588/easy-to-understand-code-with-steps/"
                    },
                    {
                        "username": "jperrin36",
                        "content": "LeetCode shouldnt assign hard questions on the weekend -____-"
                    }
                ]
            },
            {
                "id": 1821004,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "wish u survive today \\uD83D\\uDE4F"
                    },
                    {
                        "username": "jamAL108",
                        "content": "it was fun solving this prob"
                    },
                    {
                        "username": "aitachii",
                        "content": "Example 2 has 10 because it has\\n[1], [1], [1], [1],\\n[1,1], [1,1], [1,1],\\n[1,1,1], [1,1,1], \\nand the whole array [1,1,1,1]\\n\\nAlso, a contiguous subarray should have no skipped elements\\ne.g. given [1,2,3,4,5]\\n[2,3,4] is contiguous while [1,3,5] is not."
                    },
                    {
                        "username": "rajangoenka148",
                        "content": "Thank you for this explanation it helped.\n\nin the first example, why is nums[5] = [5] not a sub-array. Can you please explain?\nor are we suppose to take minK and maxK values  in compulsory?\n\nEdit: Yes we need to. Thanks anyway."
                    },
                    {
                        "username": "rahulrauki",
                        "content": "Its with great sadness I inform you that my solution gave TLE :("
                    },
                    {
                        "username": "iamdeepeshyadav",
                        "content": "Us moment 2023"
                    },
                    {
                        "username": "jperrin36",
                        "content": "felt this"
                    },
                    {
                        "username": "thou_mayest",
                        "content": "same :\\')"
                    },
                    {
                        "username": "TsuruLee",
                        "content": "A high quality problem. worth to save for practicing again in the future."
                    },
                    {
                        "username": "UchihaKim",
                        "content": "i miss the easy questions."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Something\\'s wrong I can feel it"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Great question! A doable hard problem :) \\nWhy is this tagged with queue though? I tried doing it with a queue, but that was O(N^2). I switched to using pointers and made it O(n). None of the solutions I\\'ve seen use queue. I\\'d recommend removing that tag."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "In  example  having  an array [1,3,5,2,7,5] with  minK = 1, maxK = 5.\nand its Output: 2 with the fixed-bound subarrays are [1,3,5] and [1,3,5,2].many of you are thinking  that\nwhy we were not include an [1,3] ,the reason is that ( in [1,3] subarray the minimum is=1 but maximum value is=3) so,we have to consider an subarray with an including  mink and maxk thats why we are not consider that ."
                    },
                    {
                        "username": "hgunwant38",
                        "content": "[@a1shine](/a1shine) because the given array is [1,3,5,2,7,5] and if we take 7 then it becomes greater than maxK. We need to form a contiguous subarray. [1,3,5,2,5] is not the one. "
                    },
                    {
                        "username": "alshine",
                        "content": "[@harshcodes04](/harshcodes04) 2 hours ago this answer would have speeded up my decision process so much"
                    },
                    {
                        "username": "harshcodes04",
                        "content": "[@a1shine](/a1shine) Bcoz we need a contiguous subarray."
                    },
                    {
                        "username": "alshine",
                        "content": "why don\\'t we add the option [1,3,5,2,5]?"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\nInitialize a variable ans to 0 and two pointers maxI and minI to -1.\\n\\nTraverse the given array nums from left to right.\\n\\nIf the current element is not in the range of minK and maxK, reset the pointers to -1 and set the start pointer to i+1.\\n\\nIf the current element is equal to minK, update minI to i.\\n\\nIf the current element is equal to maxK, update maxI to i.\\n\\nFor each element, add the maximum of 0 and the minimum of minI and maxI minus start plus 1 to ans.\\n\\nReturn ans."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code Link:-\\n\\nhttps://leetcode.com/problems/count-subarrays-with-fixed-bounds/solutions/3255588/easy-to-understand-code-with-steps/"
                    },
                    {
                        "username": "jperrin36",
                        "content": "LeetCode shouldnt assign hard questions on the weekend -____-"
                    }
                ]
            },
            {
                "id": 1821270,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "wish u survive today \\uD83D\\uDE4F"
                    },
                    {
                        "username": "jamAL108",
                        "content": "it was fun solving this prob"
                    },
                    {
                        "username": "aitachii",
                        "content": "Example 2 has 10 because it has\\n[1], [1], [1], [1],\\n[1,1], [1,1], [1,1],\\n[1,1,1], [1,1,1], \\nand the whole array [1,1,1,1]\\n\\nAlso, a contiguous subarray should have no skipped elements\\ne.g. given [1,2,3,4,5]\\n[2,3,4] is contiguous while [1,3,5] is not."
                    },
                    {
                        "username": "rajangoenka148",
                        "content": "Thank you for this explanation it helped.\n\nin the first example, why is nums[5] = [5] not a sub-array. Can you please explain?\nor are we suppose to take minK and maxK values  in compulsory?\n\nEdit: Yes we need to. Thanks anyway."
                    },
                    {
                        "username": "rahulrauki",
                        "content": "Its with great sadness I inform you that my solution gave TLE :("
                    },
                    {
                        "username": "iamdeepeshyadav",
                        "content": "Us moment 2023"
                    },
                    {
                        "username": "jperrin36",
                        "content": "felt this"
                    },
                    {
                        "username": "thou_mayest",
                        "content": "same :\\')"
                    },
                    {
                        "username": "TsuruLee",
                        "content": "A high quality problem. worth to save for practicing again in the future."
                    },
                    {
                        "username": "UchihaKim",
                        "content": "i miss the easy questions."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Something\\'s wrong I can feel it"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Great question! A doable hard problem :) \\nWhy is this tagged with queue though? I tried doing it with a queue, but that was O(N^2). I switched to using pointers and made it O(n). None of the solutions I\\'ve seen use queue. I\\'d recommend removing that tag."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "In  example  having  an array [1,3,5,2,7,5] with  minK = 1, maxK = 5.\nand its Output: 2 with the fixed-bound subarrays are [1,3,5] and [1,3,5,2].many of you are thinking  that\nwhy we were not include an [1,3] ,the reason is that ( in [1,3] subarray the minimum is=1 but maximum value is=3) so,we have to consider an subarray with an including  mink and maxk thats why we are not consider that ."
                    },
                    {
                        "username": "hgunwant38",
                        "content": "[@a1shine](/a1shine) because the given array is [1,3,5,2,7,5] and if we take 7 then it becomes greater than maxK. We need to form a contiguous subarray. [1,3,5,2,5] is not the one. "
                    },
                    {
                        "username": "alshine",
                        "content": "[@harshcodes04](/harshcodes04) 2 hours ago this answer would have speeded up my decision process so much"
                    },
                    {
                        "username": "harshcodes04",
                        "content": "[@a1shine](/a1shine) Bcoz we need a contiguous subarray."
                    },
                    {
                        "username": "alshine",
                        "content": "why don\\'t we add the option [1,3,5,2,5]?"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\nInitialize a variable ans to 0 and two pointers maxI and minI to -1.\\n\\nTraverse the given array nums from left to right.\\n\\nIf the current element is not in the range of minK and maxK, reset the pointers to -1 and set the start pointer to i+1.\\n\\nIf the current element is equal to minK, update minI to i.\\n\\nIf the current element is equal to maxK, update maxI to i.\\n\\nFor each element, add the maximum of 0 and the minimum of minI and maxI minus start plus 1 to ans.\\n\\nReturn ans."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code Link:-\\n\\nhttps://leetcode.com/problems/count-subarrays-with-fixed-bounds/solutions/3255588/easy-to-understand-code-with-steps/"
                    },
                    {
                        "username": "jperrin36",
                        "content": "LeetCode shouldnt assign hard questions on the weekend -____-"
                    }
                ]
            },
            {
                "id": 1821272,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "wish u survive today \\uD83D\\uDE4F"
                    },
                    {
                        "username": "jamAL108",
                        "content": "it was fun solving this prob"
                    },
                    {
                        "username": "aitachii",
                        "content": "Example 2 has 10 because it has\\n[1], [1], [1], [1],\\n[1,1], [1,1], [1,1],\\n[1,1,1], [1,1,1], \\nand the whole array [1,1,1,1]\\n\\nAlso, a contiguous subarray should have no skipped elements\\ne.g. given [1,2,3,4,5]\\n[2,3,4] is contiguous while [1,3,5] is not."
                    },
                    {
                        "username": "rajangoenka148",
                        "content": "Thank you for this explanation it helped.\n\nin the first example, why is nums[5] = [5] not a sub-array. Can you please explain?\nor are we suppose to take minK and maxK values  in compulsory?\n\nEdit: Yes we need to. Thanks anyway."
                    },
                    {
                        "username": "rahulrauki",
                        "content": "Its with great sadness I inform you that my solution gave TLE :("
                    },
                    {
                        "username": "iamdeepeshyadav",
                        "content": "Us moment 2023"
                    },
                    {
                        "username": "jperrin36",
                        "content": "felt this"
                    },
                    {
                        "username": "thou_mayest",
                        "content": "same :\\')"
                    },
                    {
                        "username": "TsuruLee",
                        "content": "A high quality problem. worth to save for practicing again in the future."
                    },
                    {
                        "username": "UchihaKim",
                        "content": "i miss the easy questions."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Something\\'s wrong I can feel it"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Great question! A doable hard problem :) \\nWhy is this tagged with queue though? I tried doing it with a queue, but that was O(N^2). I switched to using pointers and made it O(n). None of the solutions I\\'ve seen use queue. I\\'d recommend removing that tag."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "In  example  having  an array [1,3,5,2,7,5] with  minK = 1, maxK = 5.\nand its Output: 2 with the fixed-bound subarrays are [1,3,5] and [1,3,5,2].many of you are thinking  that\nwhy we were not include an [1,3] ,the reason is that ( in [1,3] subarray the minimum is=1 but maximum value is=3) so,we have to consider an subarray with an including  mink and maxk thats why we are not consider that ."
                    },
                    {
                        "username": "hgunwant38",
                        "content": "[@a1shine](/a1shine) because the given array is [1,3,5,2,7,5] and if we take 7 then it becomes greater than maxK. We need to form a contiguous subarray. [1,3,5,2,5] is not the one. "
                    },
                    {
                        "username": "alshine",
                        "content": "[@harshcodes04](/harshcodes04) 2 hours ago this answer would have speeded up my decision process so much"
                    },
                    {
                        "username": "harshcodes04",
                        "content": "[@a1shine](/a1shine) Bcoz we need a contiguous subarray."
                    },
                    {
                        "username": "alshine",
                        "content": "why don\\'t we add the option [1,3,5,2,5]?"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\nInitialize a variable ans to 0 and two pointers maxI and minI to -1.\\n\\nTraverse the given array nums from left to right.\\n\\nIf the current element is not in the range of minK and maxK, reset the pointers to -1 and set the start pointer to i+1.\\n\\nIf the current element is equal to minK, update minI to i.\\n\\nIf the current element is equal to maxK, update maxI to i.\\n\\nFor each element, add the maximum of 0 and the minimum of minI and maxI minus start plus 1 to ans.\\n\\nReturn ans."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code Link:-\\n\\nhttps://leetcode.com/problems/count-subarrays-with-fixed-bounds/solutions/3255588/easy-to-understand-code-with-steps/"
                    },
                    {
                        "username": "jperrin36",
                        "content": "LeetCode shouldnt assign hard questions on the weekend -____-"
                    }
                ]
            },
            {
                "id": 1820923,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "wish u survive today \\uD83D\\uDE4F"
                    },
                    {
                        "username": "jamAL108",
                        "content": "it was fun solving this prob"
                    },
                    {
                        "username": "aitachii",
                        "content": "Example 2 has 10 because it has\\n[1], [1], [1], [1],\\n[1,1], [1,1], [1,1],\\n[1,1,1], [1,1,1], \\nand the whole array [1,1,1,1]\\n\\nAlso, a contiguous subarray should have no skipped elements\\ne.g. given [1,2,3,4,5]\\n[2,3,4] is contiguous while [1,3,5] is not."
                    },
                    {
                        "username": "rajangoenka148",
                        "content": "Thank you for this explanation it helped.\n\nin the first example, why is nums[5] = [5] not a sub-array. Can you please explain?\nor are we suppose to take minK and maxK values  in compulsory?\n\nEdit: Yes we need to. Thanks anyway."
                    },
                    {
                        "username": "rahulrauki",
                        "content": "Its with great sadness I inform you that my solution gave TLE :("
                    },
                    {
                        "username": "iamdeepeshyadav",
                        "content": "Us moment 2023"
                    },
                    {
                        "username": "jperrin36",
                        "content": "felt this"
                    },
                    {
                        "username": "thou_mayest",
                        "content": "same :\\')"
                    },
                    {
                        "username": "TsuruLee",
                        "content": "A high quality problem. worth to save for practicing again in the future."
                    },
                    {
                        "username": "UchihaKim",
                        "content": "i miss the easy questions."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Something\\'s wrong I can feel it"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Great question! A doable hard problem :) \\nWhy is this tagged with queue though? I tried doing it with a queue, but that was O(N^2). I switched to using pointers and made it O(n). None of the solutions I\\'ve seen use queue. I\\'d recommend removing that tag."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "In  example  having  an array [1,3,5,2,7,5] with  minK = 1, maxK = 5.\nand its Output: 2 with the fixed-bound subarrays are [1,3,5] and [1,3,5,2].many of you are thinking  that\nwhy we were not include an [1,3] ,the reason is that ( in [1,3] subarray the minimum is=1 but maximum value is=3) so,we have to consider an subarray with an including  mink and maxk thats why we are not consider that ."
                    },
                    {
                        "username": "hgunwant38",
                        "content": "[@a1shine](/a1shine) because the given array is [1,3,5,2,7,5] and if we take 7 then it becomes greater than maxK. We need to form a contiguous subarray. [1,3,5,2,5] is not the one. "
                    },
                    {
                        "username": "alshine",
                        "content": "[@harshcodes04](/harshcodes04) 2 hours ago this answer would have speeded up my decision process so much"
                    },
                    {
                        "username": "harshcodes04",
                        "content": "[@a1shine](/a1shine) Bcoz we need a contiguous subarray."
                    },
                    {
                        "username": "alshine",
                        "content": "why don\\'t we add the option [1,3,5,2,5]?"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\nInitialize a variable ans to 0 and two pointers maxI and minI to -1.\\n\\nTraverse the given array nums from left to right.\\n\\nIf the current element is not in the range of minK and maxK, reset the pointers to -1 and set the start pointer to i+1.\\n\\nIf the current element is equal to minK, update minI to i.\\n\\nIf the current element is equal to maxK, update maxI to i.\\n\\nFor each element, add the maximum of 0 and the minimum of minI and maxI minus start plus 1 to ans.\\n\\nReturn ans."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code Link:-\\n\\nhttps://leetcode.com/problems/count-subarrays-with-fixed-bounds/solutions/3255588/easy-to-understand-code-with-steps/"
                    },
                    {
                        "username": "jperrin36",
                        "content": "LeetCode shouldnt assign hard questions on the weekend -____-"
                    }
                ]
            },
            {
                "id": 1821055,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "wish u survive today \\uD83D\\uDE4F"
                    },
                    {
                        "username": "jamAL108",
                        "content": "it was fun solving this prob"
                    },
                    {
                        "username": "aitachii",
                        "content": "Example 2 has 10 because it has\\n[1], [1], [1], [1],\\n[1,1], [1,1], [1,1],\\n[1,1,1], [1,1,1], \\nand the whole array [1,1,1,1]\\n\\nAlso, a contiguous subarray should have no skipped elements\\ne.g. given [1,2,3,4,5]\\n[2,3,4] is contiguous while [1,3,5] is not."
                    },
                    {
                        "username": "rajangoenka148",
                        "content": "Thank you for this explanation it helped.\n\nin the first example, why is nums[5] = [5] not a sub-array. Can you please explain?\nor are we suppose to take minK and maxK values  in compulsory?\n\nEdit: Yes we need to. Thanks anyway."
                    },
                    {
                        "username": "rahulrauki",
                        "content": "Its with great sadness I inform you that my solution gave TLE :("
                    },
                    {
                        "username": "iamdeepeshyadav",
                        "content": "Us moment 2023"
                    },
                    {
                        "username": "jperrin36",
                        "content": "felt this"
                    },
                    {
                        "username": "thou_mayest",
                        "content": "same :\\')"
                    },
                    {
                        "username": "TsuruLee",
                        "content": "A high quality problem. worth to save for practicing again in the future."
                    },
                    {
                        "username": "UchihaKim",
                        "content": "i miss the easy questions."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Something\\'s wrong I can feel it"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Great question! A doable hard problem :) \\nWhy is this tagged with queue though? I tried doing it with a queue, but that was O(N^2). I switched to using pointers and made it O(n). None of the solutions I\\'ve seen use queue. I\\'d recommend removing that tag."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "In  example  having  an array [1,3,5,2,7,5] with  minK = 1, maxK = 5.\nand its Output: 2 with the fixed-bound subarrays are [1,3,5] and [1,3,5,2].many of you are thinking  that\nwhy we were not include an [1,3] ,the reason is that ( in [1,3] subarray the minimum is=1 but maximum value is=3) so,we have to consider an subarray with an including  mink and maxk thats why we are not consider that ."
                    },
                    {
                        "username": "hgunwant38",
                        "content": "[@a1shine](/a1shine) because the given array is [1,3,5,2,7,5] and if we take 7 then it becomes greater than maxK. We need to form a contiguous subarray. [1,3,5,2,5] is not the one. "
                    },
                    {
                        "username": "alshine",
                        "content": "[@harshcodes04](/harshcodes04) 2 hours ago this answer would have speeded up my decision process so much"
                    },
                    {
                        "username": "harshcodes04",
                        "content": "[@a1shine](/a1shine) Bcoz we need a contiguous subarray."
                    },
                    {
                        "username": "alshine",
                        "content": "why don\\'t we add the option [1,3,5,2,5]?"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\nInitialize a variable ans to 0 and two pointers maxI and minI to -1.\\n\\nTraverse the given array nums from left to right.\\n\\nIf the current element is not in the range of minK and maxK, reset the pointers to -1 and set the start pointer to i+1.\\n\\nIf the current element is equal to minK, update minI to i.\\n\\nIf the current element is equal to maxK, update maxI to i.\\n\\nFor each element, add the maximum of 0 and the minimum of minI and maxI minus start plus 1 to ans.\\n\\nReturn ans."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code Link:-\\n\\nhttps://leetcode.com/problems/count-subarrays-with-fixed-bounds/solutions/3255588/easy-to-understand-code-with-steps/"
                    },
                    {
                        "username": "jperrin36",
                        "content": "LeetCode shouldnt assign hard questions on the weekend -____-"
                    }
                ]
            },
            {
                "id": 1821476,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "wish u survive today \\uD83D\\uDE4F"
                    },
                    {
                        "username": "jamAL108",
                        "content": "it was fun solving this prob"
                    },
                    {
                        "username": "aitachii",
                        "content": "Example 2 has 10 because it has\\n[1], [1], [1], [1],\\n[1,1], [1,1], [1,1],\\n[1,1,1], [1,1,1], \\nand the whole array [1,1,1,1]\\n\\nAlso, a contiguous subarray should have no skipped elements\\ne.g. given [1,2,3,4,5]\\n[2,3,4] is contiguous while [1,3,5] is not."
                    },
                    {
                        "username": "rajangoenka148",
                        "content": "Thank you for this explanation it helped.\n\nin the first example, why is nums[5] = [5] not a sub-array. Can you please explain?\nor are we suppose to take minK and maxK values  in compulsory?\n\nEdit: Yes we need to. Thanks anyway."
                    },
                    {
                        "username": "rahulrauki",
                        "content": "Its with great sadness I inform you that my solution gave TLE :("
                    },
                    {
                        "username": "iamdeepeshyadav",
                        "content": "Us moment 2023"
                    },
                    {
                        "username": "jperrin36",
                        "content": "felt this"
                    },
                    {
                        "username": "thou_mayest",
                        "content": "same :\\')"
                    },
                    {
                        "username": "TsuruLee",
                        "content": "A high quality problem. worth to save for practicing again in the future."
                    },
                    {
                        "username": "UchihaKim",
                        "content": "i miss the easy questions."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Something\\'s wrong I can feel it"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Great question! A doable hard problem :) \\nWhy is this tagged with queue though? I tried doing it with a queue, but that was O(N^2). I switched to using pointers and made it O(n). None of the solutions I\\'ve seen use queue. I\\'d recommend removing that tag."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "In  example  having  an array [1,3,5,2,7,5] with  minK = 1, maxK = 5.\nand its Output: 2 with the fixed-bound subarrays are [1,3,5] and [1,3,5,2].many of you are thinking  that\nwhy we were not include an [1,3] ,the reason is that ( in [1,3] subarray the minimum is=1 but maximum value is=3) so,we have to consider an subarray with an including  mink and maxk thats why we are not consider that ."
                    },
                    {
                        "username": "hgunwant38",
                        "content": "[@a1shine](/a1shine) because the given array is [1,3,5,2,7,5] and if we take 7 then it becomes greater than maxK. We need to form a contiguous subarray. [1,3,5,2,5] is not the one. "
                    },
                    {
                        "username": "alshine",
                        "content": "[@harshcodes04](/harshcodes04) 2 hours ago this answer would have speeded up my decision process so much"
                    },
                    {
                        "username": "harshcodes04",
                        "content": "[@a1shine](/a1shine) Bcoz we need a contiguous subarray."
                    },
                    {
                        "username": "alshine",
                        "content": "why don\\'t we add the option [1,3,5,2,5]?"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\nInitialize a variable ans to 0 and two pointers maxI and minI to -1.\\n\\nTraverse the given array nums from left to right.\\n\\nIf the current element is not in the range of minK and maxK, reset the pointers to -1 and set the start pointer to i+1.\\n\\nIf the current element is equal to minK, update minI to i.\\n\\nIf the current element is equal to maxK, update maxI to i.\\n\\nFor each element, add the maximum of 0 and the minimum of minI and maxI minus start plus 1 to ans.\\n\\nReturn ans."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code Link:-\\n\\nhttps://leetcode.com/problems/count-subarrays-with-fixed-bounds/solutions/3255588/easy-to-understand-code-with-steps/"
                    },
                    {
                        "username": "jperrin36",
                        "content": "LeetCode shouldnt assign hard questions on the weekend -____-"
                    }
                ]
            },
            {
                "id": 1821027,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "wish u survive today \\uD83D\\uDE4F"
                    },
                    {
                        "username": "jamAL108",
                        "content": "it was fun solving this prob"
                    },
                    {
                        "username": "aitachii",
                        "content": "Example 2 has 10 because it has\\n[1], [1], [1], [1],\\n[1,1], [1,1], [1,1],\\n[1,1,1], [1,1,1], \\nand the whole array [1,1,1,1]\\n\\nAlso, a contiguous subarray should have no skipped elements\\ne.g. given [1,2,3,4,5]\\n[2,3,4] is contiguous while [1,3,5] is not."
                    },
                    {
                        "username": "rajangoenka148",
                        "content": "Thank you for this explanation it helped.\n\nin the first example, why is nums[5] = [5] not a sub-array. Can you please explain?\nor are we suppose to take minK and maxK values  in compulsory?\n\nEdit: Yes we need to. Thanks anyway."
                    },
                    {
                        "username": "rahulrauki",
                        "content": "Its with great sadness I inform you that my solution gave TLE :("
                    },
                    {
                        "username": "iamdeepeshyadav",
                        "content": "Us moment 2023"
                    },
                    {
                        "username": "jperrin36",
                        "content": "felt this"
                    },
                    {
                        "username": "thou_mayest",
                        "content": "same :\\')"
                    },
                    {
                        "username": "TsuruLee",
                        "content": "A high quality problem. worth to save for practicing again in the future."
                    },
                    {
                        "username": "UchihaKim",
                        "content": "i miss the easy questions."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Something\\'s wrong I can feel it"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Great question! A doable hard problem :) \\nWhy is this tagged with queue though? I tried doing it with a queue, but that was O(N^2). I switched to using pointers and made it O(n). None of the solutions I\\'ve seen use queue. I\\'d recommend removing that tag."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "In  example  having  an array [1,3,5,2,7,5] with  minK = 1, maxK = 5.\nand its Output: 2 with the fixed-bound subarrays are [1,3,5] and [1,3,5,2].many of you are thinking  that\nwhy we were not include an [1,3] ,the reason is that ( in [1,3] subarray the minimum is=1 but maximum value is=3) so,we have to consider an subarray with an including  mink and maxk thats why we are not consider that ."
                    },
                    {
                        "username": "hgunwant38",
                        "content": "[@a1shine](/a1shine) because the given array is [1,3,5,2,7,5] and if we take 7 then it becomes greater than maxK. We need to form a contiguous subarray. [1,3,5,2,5] is not the one. "
                    },
                    {
                        "username": "alshine",
                        "content": "[@harshcodes04](/harshcodes04) 2 hours ago this answer would have speeded up my decision process so much"
                    },
                    {
                        "username": "harshcodes04",
                        "content": "[@a1shine](/a1shine) Bcoz we need a contiguous subarray."
                    },
                    {
                        "username": "alshine",
                        "content": "why don\\'t we add the option [1,3,5,2,5]?"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\nInitialize a variable ans to 0 and two pointers maxI and minI to -1.\\n\\nTraverse the given array nums from left to right.\\n\\nIf the current element is not in the range of minK and maxK, reset the pointers to -1 and set the start pointer to i+1.\\n\\nIf the current element is equal to minK, update minI to i.\\n\\nIf the current element is equal to maxK, update maxI to i.\\n\\nFor each element, add the maximum of 0 and the minimum of minI and maxI minus start plus 1 to ans.\\n\\nReturn ans."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code Link:-\\n\\nhttps://leetcode.com/problems/count-subarrays-with-fixed-bounds/solutions/3255588/easy-to-understand-code-with-steps/"
                    },
                    {
                        "username": "jperrin36",
                        "content": "LeetCode shouldnt assign hard questions on the weekend -____-"
                    }
                ]
            },
            {
                "id": 1821415,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "wish u survive today \\uD83D\\uDE4F"
                    },
                    {
                        "username": "jamAL108",
                        "content": "it was fun solving this prob"
                    },
                    {
                        "username": "aitachii",
                        "content": "Example 2 has 10 because it has\\n[1], [1], [1], [1],\\n[1,1], [1,1], [1,1],\\n[1,1,1], [1,1,1], \\nand the whole array [1,1,1,1]\\n\\nAlso, a contiguous subarray should have no skipped elements\\ne.g. given [1,2,3,4,5]\\n[2,3,4] is contiguous while [1,3,5] is not."
                    },
                    {
                        "username": "rajangoenka148",
                        "content": "Thank you for this explanation it helped.\n\nin the first example, why is nums[5] = [5] not a sub-array. Can you please explain?\nor are we suppose to take minK and maxK values  in compulsory?\n\nEdit: Yes we need to. Thanks anyway."
                    },
                    {
                        "username": "rahulrauki",
                        "content": "Its with great sadness I inform you that my solution gave TLE :("
                    },
                    {
                        "username": "iamdeepeshyadav",
                        "content": "Us moment 2023"
                    },
                    {
                        "username": "jperrin36",
                        "content": "felt this"
                    },
                    {
                        "username": "thou_mayest",
                        "content": "same :\\')"
                    },
                    {
                        "username": "TsuruLee",
                        "content": "A high quality problem. worth to save for practicing again in the future."
                    },
                    {
                        "username": "UchihaKim",
                        "content": "i miss the easy questions."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Something\\'s wrong I can feel it"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Great question! A doable hard problem :) \\nWhy is this tagged with queue though? I tried doing it with a queue, but that was O(N^2). I switched to using pointers and made it O(n). None of the solutions I\\'ve seen use queue. I\\'d recommend removing that tag."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "In  example  having  an array [1,3,5,2,7,5] with  minK = 1, maxK = 5.\nand its Output: 2 with the fixed-bound subarrays are [1,3,5] and [1,3,5,2].many of you are thinking  that\nwhy we were not include an [1,3] ,the reason is that ( in [1,3] subarray the minimum is=1 but maximum value is=3) so,we have to consider an subarray with an including  mink and maxk thats why we are not consider that ."
                    },
                    {
                        "username": "hgunwant38",
                        "content": "[@a1shine](/a1shine) because the given array is [1,3,5,2,7,5] and if we take 7 then it becomes greater than maxK. We need to form a contiguous subarray. [1,3,5,2,5] is not the one. "
                    },
                    {
                        "username": "alshine",
                        "content": "[@harshcodes04](/harshcodes04) 2 hours ago this answer would have speeded up my decision process so much"
                    },
                    {
                        "username": "harshcodes04",
                        "content": "[@a1shine](/a1shine) Bcoz we need a contiguous subarray."
                    },
                    {
                        "username": "alshine",
                        "content": "why don\\'t we add the option [1,3,5,2,5]?"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\nInitialize a variable ans to 0 and two pointers maxI and minI to -1.\\n\\nTraverse the given array nums from left to right.\\n\\nIf the current element is not in the range of minK and maxK, reset the pointers to -1 and set the start pointer to i+1.\\n\\nIf the current element is equal to minK, update minI to i.\\n\\nIf the current element is equal to maxK, update maxI to i.\\n\\nFor each element, add the maximum of 0 and the minimum of minI and maxI minus start plus 1 to ans.\\n\\nReturn ans."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code Link:-\\n\\nhttps://leetcode.com/problems/count-subarrays-with-fixed-bounds/solutions/3255588/easy-to-understand-code-with-steps/"
                    },
                    {
                        "username": "jperrin36",
                        "content": "LeetCode shouldnt assign hard questions on the weekend -____-"
                    }
                ]
            },
            {
                "id": 1821482,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "wish u survive today \\uD83D\\uDE4F"
                    },
                    {
                        "username": "jamAL108",
                        "content": "it was fun solving this prob"
                    },
                    {
                        "username": "aitachii",
                        "content": "Example 2 has 10 because it has\\n[1], [1], [1], [1],\\n[1,1], [1,1], [1,1],\\n[1,1,1], [1,1,1], \\nand the whole array [1,1,1,1]\\n\\nAlso, a contiguous subarray should have no skipped elements\\ne.g. given [1,2,3,4,5]\\n[2,3,4] is contiguous while [1,3,5] is not."
                    },
                    {
                        "username": "rajangoenka148",
                        "content": "Thank you for this explanation it helped.\n\nin the first example, why is nums[5] = [5] not a sub-array. Can you please explain?\nor are we suppose to take minK and maxK values  in compulsory?\n\nEdit: Yes we need to. Thanks anyway."
                    },
                    {
                        "username": "rahulrauki",
                        "content": "Its with great sadness I inform you that my solution gave TLE :("
                    },
                    {
                        "username": "iamdeepeshyadav",
                        "content": "Us moment 2023"
                    },
                    {
                        "username": "jperrin36",
                        "content": "felt this"
                    },
                    {
                        "username": "thou_mayest",
                        "content": "same :\\')"
                    },
                    {
                        "username": "TsuruLee",
                        "content": "A high quality problem. worth to save for practicing again in the future."
                    },
                    {
                        "username": "UchihaKim",
                        "content": "i miss the easy questions."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Something\\'s wrong I can feel it"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Great question! A doable hard problem :) \\nWhy is this tagged with queue though? I tried doing it with a queue, but that was O(N^2). I switched to using pointers and made it O(n). None of the solutions I\\'ve seen use queue. I\\'d recommend removing that tag."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "In  example  having  an array [1,3,5,2,7,5] with  minK = 1, maxK = 5.\nand its Output: 2 with the fixed-bound subarrays are [1,3,5] and [1,3,5,2].many of you are thinking  that\nwhy we were not include an [1,3] ,the reason is that ( in [1,3] subarray the minimum is=1 but maximum value is=3) so,we have to consider an subarray with an including  mink and maxk thats why we are not consider that ."
                    },
                    {
                        "username": "hgunwant38",
                        "content": "[@a1shine](/a1shine) because the given array is [1,3,5,2,7,5] and if we take 7 then it becomes greater than maxK. We need to form a contiguous subarray. [1,3,5,2,5] is not the one. "
                    },
                    {
                        "username": "alshine",
                        "content": "[@harshcodes04](/harshcodes04) 2 hours ago this answer would have speeded up my decision process so much"
                    },
                    {
                        "username": "harshcodes04",
                        "content": "[@a1shine](/a1shine) Bcoz we need a contiguous subarray."
                    },
                    {
                        "username": "alshine",
                        "content": "why don\\'t we add the option [1,3,5,2,5]?"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\nInitialize a variable ans to 0 and two pointers maxI and minI to -1.\\n\\nTraverse the given array nums from left to right.\\n\\nIf the current element is not in the range of minK and maxK, reset the pointers to -1 and set the start pointer to i+1.\\n\\nIf the current element is equal to minK, update minI to i.\\n\\nIf the current element is equal to maxK, update maxI to i.\\n\\nFor each element, add the maximum of 0 and the minimum of minI and maxI minus start plus 1 to ans.\\n\\nReturn ans."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code Link:-\\n\\nhttps://leetcode.com/problems/count-subarrays-with-fixed-bounds/solutions/3255588/easy-to-understand-code-with-steps/"
                    },
                    {
                        "username": "jperrin36",
                        "content": "LeetCode shouldnt assign hard questions on the weekend -____-"
                    }
                ]
            },
            {
                "id": 1821598,
                "content": [
                    {
                        "username": "NicholasCG",
                        "content": "Maybe it\\'s just from practice, but this is an easier hard."
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Simple Question + Very Large Input == Hard Problem\\nSimple Question + TLE                      == Hard Problem"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This isn\\'t hard at all after I\\'ve watched the solution. Still a long way to go."
                    },
                    {
                        "username": "Msey",
                        "content": "every question is easy when you read the solution"
                    },
                    {
                        "username": "ajbil3112",
                        "content": "why this question can not be solve using minheap and maxheap ?"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "Implementing heap would need at least O(nlogn) time complexity. Solution needs to be order of O(n)."
                    },
                    {
                        "username": "ShantanuDutta",
                        "content": " long long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n    long long c = 0;\\n    int flagMin = 0, flagMax = 0;\\n    int i = 0, j = 0;\\n\\n    while (i < nums.size()) {\\n        if (nums[j] >= minK && nums[j] <= maxK) {\\n            if (nums[j] == minK) {\\n                flagMin = 1;\\n            } \\n            if (nums[j] == maxK) {\\n                flagMax = 1;\\n            }\\n\\n            if (flagMin == 1 && flagMax == 1) {\\n                c++;\\n            }\\n            j++;\\n        } else {\\n            i++;\\n            j = i;\\n            flagMin = 0;\\n            flagMax = 0;\\n        }\\n\\n        if (j == nums.size()) {\\n            i++;\\n            j = i;\\n            flagMin = 0;\\n            flagMax = 0;\\n        }\\n    }\\n\\n    return c;\\n} \\n\\n\\n\\n\\n\\n\\n\\n\\nplz check it passes 45/51 but for huge chunk of 1s array it gives TLE"
                    },
                    {
                        "username": "namandt",
                        "content": "true"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "First I used Two-Pointer using only 'two-pointer' which gave me TLE at 45/51 Test-Case then after 1hr of trying to figure out I had to check Solution tab, Long way to go and learn.\n\nTip: Be careful while implementing Two-Pointer solution. One might need to add 3rd Pointer\n\nHint : They are expecting you to solve this problem in O(n) TC"
                    },
                    {
                        "username": "dumb_me",
                        "content": "2 pointer is really painfull when question is tagged hard \\uD83D\\uDE2D\\uD83D\\uDE2D\\n"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "Huh? a **hard** problem?"
                    },
                    {
                        "username": "beardedone",
                        "content": "[@arghyadas](/arghyadas) pieceofpie\\'s solution is the same as the official leetcode solution verbatim with the comments removed and the white space adjusted."
                    },
                    {
                        "username": "xeniawann",
                        "content": "Impressive solution! I only though of a sliding window, I wonder how you came up with that?"
                    },
                    {
                        "username": "arghyadas",
                        "content": "I saw your solution, Its pretty impressive. But I\\'m not able to get the intuition behind that\\uD83E\\uDD72"
                    },
                    {
                        "username": "shivansh961",
                        "content": "I think this is a precise level of hard question"
                    },
                    {
                        "username": "roishevah",
                        "content": "This question is tagged with possible solution using queue/monotonnic queue, but it seems like it\\'s not related to the question.\\nCan someone please exaplain why/how monotonnic queue should be used to solve this question?"
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "This should be marked as Medium problem"
                    }
                ]
            },
            {
                "id": 1821063,
                "content": [
                    {
                        "username": "NicholasCG",
                        "content": "Maybe it\\'s just from practice, but this is an easier hard."
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Simple Question + Very Large Input == Hard Problem\\nSimple Question + TLE                      == Hard Problem"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This isn\\'t hard at all after I\\'ve watched the solution. Still a long way to go."
                    },
                    {
                        "username": "Msey",
                        "content": "every question is easy when you read the solution"
                    },
                    {
                        "username": "ajbil3112",
                        "content": "why this question can not be solve using minheap and maxheap ?"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "Implementing heap would need at least O(nlogn) time complexity. Solution needs to be order of O(n)."
                    },
                    {
                        "username": "ShantanuDutta",
                        "content": " long long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n    long long c = 0;\\n    int flagMin = 0, flagMax = 0;\\n    int i = 0, j = 0;\\n\\n    while (i < nums.size()) {\\n        if (nums[j] >= minK && nums[j] <= maxK) {\\n            if (nums[j] == minK) {\\n                flagMin = 1;\\n            } \\n            if (nums[j] == maxK) {\\n                flagMax = 1;\\n            }\\n\\n            if (flagMin == 1 && flagMax == 1) {\\n                c++;\\n            }\\n            j++;\\n        } else {\\n            i++;\\n            j = i;\\n            flagMin = 0;\\n            flagMax = 0;\\n        }\\n\\n        if (j == nums.size()) {\\n            i++;\\n            j = i;\\n            flagMin = 0;\\n            flagMax = 0;\\n        }\\n    }\\n\\n    return c;\\n} \\n\\n\\n\\n\\n\\n\\n\\n\\nplz check it passes 45/51 but for huge chunk of 1s array it gives TLE"
                    },
                    {
                        "username": "namandt",
                        "content": "true"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "First I used Two-Pointer using only 'two-pointer' which gave me TLE at 45/51 Test-Case then after 1hr of trying to figure out I had to check Solution tab, Long way to go and learn.\n\nTip: Be careful while implementing Two-Pointer solution. One might need to add 3rd Pointer\n\nHint : They are expecting you to solve this problem in O(n) TC"
                    },
                    {
                        "username": "dumb_me",
                        "content": "2 pointer is really painfull when question is tagged hard \\uD83D\\uDE2D\\uD83D\\uDE2D\\n"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "Huh? a **hard** problem?"
                    },
                    {
                        "username": "beardedone",
                        "content": "[@arghyadas](/arghyadas) pieceofpie\\'s solution is the same as the official leetcode solution verbatim with the comments removed and the white space adjusted."
                    },
                    {
                        "username": "xeniawann",
                        "content": "Impressive solution! I only though of a sliding window, I wonder how you came up with that?"
                    },
                    {
                        "username": "arghyadas",
                        "content": "I saw your solution, Its pretty impressive. But I\\'m not able to get the intuition behind that\\uD83E\\uDD72"
                    },
                    {
                        "username": "shivansh961",
                        "content": "I think this is a precise level of hard question"
                    },
                    {
                        "username": "roishevah",
                        "content": "This question is tagged with possible solution using queue/monotonnic queue, but it seems like it\\'s not related to the question.\\nCan someone please exaplain why/how monotonnic queue should be used to solve this question?"
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "This should be marked as Medium problem"
                    }
                ]
            },
            {
                "id": 1821064,
                "content": [
                    {
                        "username": "NicholasCG",
                        "content": "Maybe it\\'s just from practice, but this is an easier hard."
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Simple Question + Very Large Input == Hard Problem\\nSimple Question + TLE                      == Hard Problem"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This isn\\'t hard at all after I\\'ve watched the solution. Still a long way to go."
                    },
                    {
                        "username": "Msey",
                        "content": "every question is easy when you read the solution"
                    },
                    {
                        "username": "ajbil3112",
                        "content": "why this question can not be solve using minheap and maxheap ?"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "Implementing heap would need at least O(nlogn) time complexity. Solution needs to be order of O(n)."
                    },
                    {
                        "username": "ShantanuDutta",
                        "content": " long long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n    long long c = 0;\\n    int flagMin = 0, flagMax = 0;\\n    int i = 0, j = 0;\\n\\n    while (i < nums.size()) {\\n        if (nums[j] >= minK && nums[j] <= maxK) {\\n            if (nums[j] == minK) {\\n                flagMin = 1;\\n            } \\n            if (nums[j] == maxK) {\\n                flagMax = 1;\\n            }\\n\\n            if (flagMin == 1 && flagMax == 1) {\\n                c++;\\n            }\\n            j++;\\n        } else {\\n            i++;\\n            j = i;\\n            flagMin = 0;\\n            flagMax = 0;\\n        }\\n\\n        if (j == nums.size()) {\\n            i++;\\n            j = i;\\n            flagMin = 0;\\n            flagMax = 0;\\n        }\\n    }\\n\\n    return c;\\n} \\n\\n\\n\\n\\n\\n\\n\\n\\nplz check it passes 45/51 but for huge chunk of 1s array it gives TLE"
                    },
                    {
                        "username": "namandt",
                        "content": "true"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "First I used Two-Pointer using only 'two-pointer' which gave me TLE at 45/51 Test-Case then after 1hr of trying to figure out I had to check Solution tab, Long way to go and learn.\n\nTip: Be careful while implementing Two-Pointer solution. One might need to add 3rd Pointer\n\nHint : They are expecting you to solve this problem in O(n) TC"
                    },
                    {
                        "username": "dumb_me",
                        "content": "2 pointer is really painfull when question is tagged hard \\uD83D\\uDE2D\\uD83D\\uDE2D\\n"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "Huh? a **hard** problem?"
                    },
                    {
                        "username": "beardedone",
                        "content": "[@arghyadas](/arghyadas) pieceofpie\\'s solution is the same as the official leetcode solution verbatim with the comments removed and the white space adjusted."
                    },
                    {
                        "username": "xeniawann",
                        "content": "Impressive solution! I only though of a sliding window, I wonder how you came up with that?"
                    },
                    {
                        "username": "arghyadas",
                        "content": "I saw your solution, Its pretty impressive. But I\\'m not able to get the intuition behind that\\uD83E\\uDD72"
                    },
                    {
                        "username": "shivansh961",
                        "content": "I think this is a precise level of hard question"
                    },
                    {
                        "username": "roishevah",
                        "content": "This question is tagged with possible solution using queue/monotonnic queue, but it seems like it\\'s not related to the question.\\nCan someone please exaplain why/how monotonnic queue should be used to solve this question?"
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "This should be marked as Medium problem"
                    }
                ]
            },
            {
                "id": 1821441,
                "content": [
                    {
                        "username": "NicholasCG",
                        "content": "Maybe it\\'s just from practice, but this is an easier hard."
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Simple Question + Very Large Input == Hard Problem\\nSimple Question + TLE                      == Hard Problem"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This isn\\'t hard at all after I\\'ve watched the solution. Still a long way to go."
                    },
                    {
                        "username": "Msey",
                        "content": "every question is easy when you read the solution"
                    },
                    {
                        "username": "ajbil3112",
                        "content": "why this question can not be solve using minheap and maxheap ?"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "Implementing heap would need at least O(nlogn) time complexity. Solution needs to be order of O(n)."
                    },
                    {
                        "username": "ShantanuDutta",
                        "content": " long long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n    long long c = 0;\\n    int flagMin = 0, flagMax = 0;\\n    int i = 0, j = 0;\\n\\n    while (i < nums.size()) {\\n        if (nums[j] >= minK && nums[j] <= maxK) {\\n            if (nums[j] == minK) {\\n                flagMin = 1;\\n            } \\n            if (nums[j] == maxK) {\\n                flagMax = 1;\\n            }\\n\\n            if (flagMin == 1 && flagMax == 1) {\\n                c++;\\n            }\\n            j++;\\n        } else {\\n            i++;\\n            j = i;\\n            flagMin = 0;\\n            flagMax = 0;\\n        }\\n\\n        if (j == nums.size()) {\\n            i++;\\n            j = i;\\n            flagMin = 0;\\n            flagMax = 0;\\n        }\\n    }\\n\\n    return c;\\n} \\n\\n\\n\\n\\n\\n\\n\\n\\nplz check it passes 45/51 but for huge chunk of 1s array it gives TLE"
                    },
                    {
                        "username": "namandt",
                        "content": "true"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "First I used Two-Pointer using only 'two-pointer' which gave me TLE at 45/51 Test-Case then after 1hr of trying to figure out I had to check Solution tab, Long way to go and learn.\n\nTip: Be careful while implementing Two-Pointer solution. One might need to add 3rd Pointer\n\nHint : They are expecting you to solve this problem in O(n) TC"
                    },
                    {
                        "username": "dumb_me",
                        "content": "2 pointer is really painfull when question is tagged hard \\uD83D\\uDE2D\\uD83D\\uDE2D\\n"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "Huh? a **hard** problem?"
                    },
                    {
                        "username": "beardedone",
                        "content": "[@arghyadas](/arghyadas) pieceofpie\\'s solution is the same as the official leetcode solution verbatim with the comments removed and the white space adjusted."
                    },
                    {
                        "username": "xeniawann",
                        "content": "Impressive solution! I only though of a sliding window, I wonder how you came up with that?"
                    },
                    {
                        "username": "arghyadas",
                        "content": "I saw your solution, Its pretty impressive. But I\\'m not able to get the intuition behind that\\uD83E\\uDD72"
                    },
                    {
                        "username": "shivansh961",
                        "content": "I think this is a precise level of hard question"
                    },
                    {
                        "username": "roishevah",
                        "content": "This question is tagged with possible solution using queue/monotonnic queue, but it seems like it\\'s not related to the question.\\nCan someone please exaplain why/how monotonnic queue should be used to solve this question?"
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "This should be marked as Medium problem"
                    }
                ]
            },
            {
                "id": 1821391,
                "content": [
                    {
                        "username": "NicholasCG",
                        "content": "Maybe it\\'s just from practice, but this is an easier hard."
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Simple Question + Very Large Input == Hard Problem\\nSimple Question + TLE                      == Hard Problem"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This isn\\'t hard at all after I\\'ve watched the solution. Still a long way to go."
                    },
                    {
                        "username": "Msey",
                        "content": "every question is easy when you read the solution"
                    },
                    {
                        "username": "ajbil3112",
                        "content": "why this question can not be solve using minheap and maxheap ?"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "Implementing heap would need at least O(nlogn) time complexity. Solution needs to be order of O(n)."
                    },
                    {
                        "username": "ShantanuDutta",
                        "content": " long long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n    long long c = 0;\\n    int flagMin = 0, flagMax = 0;\\n    int i = 0, j = 0;\\n\\n    while (i < nums.size()) {\\n        if (nums[j] >= minK && nums[j] <= maxK) {\\n            if (nums[j] == minK) {\\n                flagMin = 1;\\n            } \\n            if (nums[j] == maxK) {\\n                flagMax = 1;\\n            }\\n\\n            if (flagMin == 1 && flagMax == 1) {\\n                c++;\\n            }\\n            j++;\\n        } else {\\n            i++;\\n            j = i;\\n            flagMin = 0;\\n            flagMax = 0;\\n        }\\n\\n        if (j == nums.size()) {\\n            i++;\\n            j = i;\\n            flagMin = 0;\\n            flagMax = 0;\\n        }\\n    }\\n\\n    return c;\\n} \\n\\n\\n\\n\\n\\n\\n\\n\\nplz check it passes 45/51 but for huge chunk of 1s array it gives TLE"
                    },
                    {
                        "username": "namandt",
                        "content": "true"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "First I used Two-Pointer using only 'two-pointer' which gave me TLE at 45/51 Test-Case then after 1hr of trying to figure out I had to check Solution tab, Long way to go and learn.\n\nTip: Be careful while implementing Two-Pointer solution. One might need to add 3rd Pointer\n\nHint : They are expecting you to solve this problem in O(n) TC"
                    },
                    {
                        "username": "dumb_me",
                        "content": "2 pointer is really painfull when question is tagged hard \\uD83D\\uDE2D\\uD83D\\uDE2D\\n"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "Huh? a **hard** problem?"
                    },
                    {
                        "username": "beardedone",
                        "content": "[@arghyadas](/arghyadas) pieceofpie\\'s solution is the same as the official leetcode solution verbatim with the comments removed and the white space adjusted."
                    },
                    {
                        "username": "xeniawann",
                        "content": "Impressive solution! I only though of a sliding window, I wonder how you came up with that?"
                    },
                    {
                        "username": "arghyadas",
                        "content": "I saw your solution, Its pretty impressive. But I\\'m not able to get the intuition behind that\\uD83E\\uDD72"
                    },
                    {
                        "username": "shivansh961",
                        "content": "I think this is a precise level of hard question"
                    },
                    {
                        "username": "roishevah",
                        "content": "This question is tagged with possible solution using queue/monotonnic queue, but it seems like it\\'s not related to the question.\\nCan someone please exaplain why/how monotonnic queue should be used to solve this question?"
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "This should be marked as Medium problem"
                    }
                ]
            },
            {
                "id": 1821108,
                "content": [
                    {
                        "username": "NicholasCG",
                        "content": "Maybe it\\'s just from practice, but this is an easier hard."
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Simple Question + Very Large Input == Hard Problem\\nSimple Question + TLE                      == Hard Problem"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This isn\\'t hard at all after I\\'ve watched the solution. Still a long way to go."
                    },
                    {
                        "username": "Msey",
                        "content": "every question is easy when you read the solution"
                    },
                    {
                        "username": "ajbil3112",
                        "content": "why this question can not be solve using minheap and maxheap ?"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "Implementing heap would need at least O(nlogn) time complexity. Solution needs to be order of O(n)."
                    },
                    {
                        "username": "ShantanuDutta",
                        "content": " long long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n    long long c = 0;\\n    int flagMin = 0, flagMax = 0;\\n    int i = 0, j = 0;\\n\\n    while (i < nums.size()) {\\n        if (nums[j] >= minK && nums[j] <= maxK) {\\n            if (nums[j] == minK) {\\n                flagMin = 1;\\n            } \\n            if (nums[j] == maxK) {\\n                flagMax = 1;\\n            }\\n\\n            if (flagMin == 1 && flagMax == 1) {\\n                c++;\\n            }\\n            j++;\\n        } else {\\n            i++;\\n            j = i;\\n            flagMin = 0;\\n            flagMax = 0;\\n        }\\n\\n        if (j == nums.size()) {\\n            i++;\\n            j = i;\\n            flagMin = 0;\\n            flagMax = 0;\\n        }\\n    }\\n\\n    return c;\\n} \\n\\n\\n\\n\\n\\n\\n\\n\\nplz check it passes 45/51 but for huge chunk of 1s array it gives TLE"
                    },
                    {
                        "username": "namandt",
                        "content": "true"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "First I used Two-Pointer using only 'two-pointer' which gave me TLE at 45/51 Test-Case then after 1hr of trying to figure out I had to check Solution tab, Long way to go and learn.\n\nTip: Be careful while implementing Two-Pointer solution. One might need to add 3rd Pointer\n\nHint : They are expecting you to solve this problem in O(n) TC"
                    },
                    {
                        "username": "dumb_me",
                        "content": "2 pointer is really painfull when question is tagged hard \\uD83D\\uDE2D\\uD83D\\uDE2D\\n"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "Huh? a **hard** problem?"
                    },
                    {
                        "username": "beardedone",
                        "content": "[@arghyadas](/arghyadas) pieceofpie\\'s solution is the same as the official leetcode solution verbatim with the comments removed and the white space adjusted."
                    },
                    {
                        "username": "xeniawann",
                        "content": "Impressive solution! I only though of a sliding window, I wonder how you came up with that?"
                    },
                    {
                        "username": "arghyadas",
                        "content": "I saw your solution, Its pretty impressive. But I\\'m not able to get the intuition behind that\\uD83E\\uDD72"
                    },
                    {
                        "username": "shivansh961",
                        "content": "I think this is a precise level of hard question"
                    },
                    {
                        "username": "roishevah",
                        "content": "This question is tagged with possible solution using queue/monotonnic queue, but it seems like it\\'s not related to the question.\\nCan someone please exaplain why/how monotonnic queue should be used to solve this question?"
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "This should be marked as Medium problem"
                    }
                ]
            },
            {
                "id": 1821040,
                "content": [
                    {
                        "username": "NicholasCG",
                        "content": "Maybe it\\'s just from practice, but this is an easier hard."
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Simple Question + Very Large Input == Hard Problem\\nSimple Question + TLE                      == Hard Problem"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This isn\\'t hard at all after I\\'ve watched the solution. Still a long way to go."
                    },
                    {
                        "username": "Msey",
                        "content": "every question is easy when you read the solution"
                    },
                    {
                        "username": "ajbil3112",
                        "content": "why this question can not be solve using minheap and maxheap ?"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "Implementing heap would need at least O(nlogn) time complexity. Solution needs to be order of O(n)."
                    },
                    {
                        "username": "ShantanuDutta",
                        "content": " long long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n    long long c = 0;\\n    int flagMin = 0, flagMax = 0;\\n    int i = 0, j = 0;\\n\\n    while (i < nums.size()) {\\n        if (nums[j] >= minK && nums[j] <= maxK) {\\n            if (nums[j] == minK) {\\n                flagMin = 1;\\n            } \\n            if (nums[j] == maxK) {\\n                flagMax = 1;\\n            }\\n\\n            if (flagMin == 1 && flagMax == 1) {\\n                c++;\\n            }\\n            j++;\\n        } else {\\n            i++;\\n            j = i;\\n            flagMin = 0;\\n            flagMax = 0;\\n        }\\n\\n        if (j == nums.size()) {\\n            i++;\\n            j = i;\\n            flagMin = 0;\\n            flagMax = 0;\\n        }\\n    }\\n\\n    return c;\\n} \\n\\n\\n\\n\\n\\n\\n\\n\\nplz check it passes 45/51 but for huge chunk of 1s array it gives TLE"
                    },
                    {
                        "username": "namandt",
                        "content": "true"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "First I used Two-Pointer using only 'two-pointer' which gave me TLE at 45/51 Test-Case then after 1hr of trying to figure out I had to check Solution tab, Long way to go and learn.\n\nTip: Be careful while implementing Two-Pointer solution. One might need to add 3rd Pointer\n\nHint : They are expecting you to solve this problem in O(n) TC"
                    },
                    {
                        "username": "dumb_me",
                        "content": "2 pointer is really painfull when question is tagged hard \\uD83D\\uDE2D\\uD83D\\uDE2D\\n"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "Huh? a **hard** problem?"
                    },
                    {
                        "username": "beardedone",
                        "content": "[@arghyadas](/arghyadas) pieceofpie\\'s solution is the same as the official leetcode solution verbatim with the comments removed and the white space adjusted."
                    },
                    {
                        "username": "xeniawann",
                        "content": "Impressive solution! I only though of a sliding window, I wonder how you came up with that?"
                    },
                    {
                        "username": "arghyadas",
                        "content": "I saw your solution, Its pretty impressive. But I\\'m not able to get the intuition behind that\\uD83E\\uDD72"
                    },
                    {
                        "username": "shivansh961",
                        "content": "I think this is a precise level of hard question"
                    },
                    {
                        "username": "roishevah",
                        "content": "This question is tagged with possible solution using queue/monotonnic queue, but it seems like it\\'s not related to the question.\\nCan someone please exaplain why/how monotonnic queue should be used to solve this question?"
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "This should be marked as Medium problem"
                    }
                ]
            },
            {
                "id": 1821001,
                "content": [
                    {
                        "username": "NicholasCG",
                        "content": "Maybe it\\'s just from practice, but this is an easier hard."
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Simple Question + Very Large Input == Hard Problem\\nSimple Question + TLE                      == Hard Problem"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This isn\\'t hard at all after I\\'ve watched the solution. Still a long way to go."
                    },
                    {
                        "username": "Msey",
                        "content": "every question is easy when you read the solution"
                    },
                    {
                        "username": "ajbil3112",
                        "content": "why this question can not be solve using minheap and maxheap ?"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "Implementing heap would need at least O(nlogn) time complexity. Solution needs to be order of O(n)."
                    },
                    {
                        "username": "ShantanuDutta",
                        "content": " long long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n    long long c = 0;\\n    int flagMin = 0, flagMax = 0;\\n    int i = 0, j = 0;\\n\\n    while (i < nums.size()) {\\n        if (nums[j] >= minK && nums[j] <= maxK) {\\n            if (nums[j] == minK) {\\n                flagMin = 1;\\n            } \\n            if (nums[j] == maxK) {\\n                flagMax = 1;\\n            }\\n\\n            if (flagMin == 1 && flagMax == 1) {\\n                c++;\\n            }\\n            j++;\\n        } else {\\n            i++;\\n            j = i;\\n            flagMin = 0;\\n            flagMax = 0;\\n        }\\n\\n        if (j == nums.size()) {\\n            i++;\\n            j = i;\\n            flagMin = 0;\\n            flagMax = 0;\\n        }\\n    }\\n\\n    return c;\\n} \\n\\n\\n\\n\\n\\n\\n\\n\\nplz check it passes 45/51 but for huge chunk of 1s array it gives TLE"
                    },
                    {
                        "username": "namandt",
                        "content": "true"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "First I used Two-Pointer using only 'two-pointer' which gave me TLE at 45/51 Test-Case then after 1hr of trying to figure out I had to check Solution tab, Long way to go and learn.\n\nTip: Be careful while implementing Two-Pointer solution. One might need to add 3rd Pointer\n\nHint : They are expecting you to solve this problem in O(n) TC"
                    },
                    {
                        "username": "dumb_me",
                        "content": "2 pointer is really painfull when question is tagged hard \\uD83D\\uDE2D\\uD83D\\uDE2D\\n"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "Huh? a **hard** problem?"
                    },
                    {
                        "username": "beardedone",
                        "content": "[@arghyadas](/arghyadas) pieceofpie\\'s solution is the same as the official leetcode solution verbatim with the comments removed and the white space adjusted."
                    },
                    {
                        "username": "xeniawann",
                        "content": "Impressive solution! I only though of a sliding window, I wonder how you came up with that?"
                    },
                    {
                        "username": "arghyadas",
                        "content": "I saw your solution, Its pretty impressive. But I\\'m not able to get the intuition behind that\\uD83E\\uDD72"
                    },
                    {
                        "username": "shivansh961",
                        "content": "I think this is a precise level of hard question"
                    },
                    {
                        "username": "roishevah",
                        "content": "This question is tagged with possible solution using queue/monotonnic queue, but it seems like it\\'s not related to the question.\\nCan someone please exaplain why/how monotonnic queue should be used to solve this question?"
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "This should be marked as Medium problem"
                    }
                ]
            },
            {
                "id": 2054456,
                "content": [
                    {
                        "username": "NicholasCG",
                        "content": "Maybe it\\'s just from practice, but this is an easier hard."
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Simple Question + Very Large Input == Hard Problem\\nSimple Question + TLE                      == Hard Problem"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This isn\\'t hard at all after I\\'ve watched the solution. Still a long way to go."
                    },
                    {
                        "username": "Msey",
                        "content": "every question is easy when you read the solution"
                    },
                    {
                        "username": "ajbil3112",
                        "content": "why this question can not be solve using minheap and maxheap ?"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "Implementing heap would need at least O(nlogn) time complexity. Solution needs to be order of O(n)."
                    },
                    {
                        "username": "ShantanuDutta",
                        "content": " long long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n    long long c = 0;\\n    int flagMin = 0, flagMax = 0;\\n    int i = 0, j = 0;\\n\\n    while (i < nums.size()) {\\n        if (nums[j] >= minK && nums[j] <= maxK) {\\n            if (nums[j] == minK) {\\n                flagMin = 1;\\n            } \\n            if (nums[j] == maxK) {\\n                flagMax = 1;\\n            }\\n\\n            if (flagMin == 1 && flagMax == 1) {\\n                c++;\\n            }\\n            j++;\\n        } else {\\n            i++;\\n            j = i;\\n            flagMin = 0;\\n            flagMax = 0;\\n        }\\n\\n        if (j == nums.size()) {\\n            i++;\\n            j = i;\\n            flagMin = 0;\\n            flagMax = 0;\\n        }\\n    }\\n\\n    return c;\\n} \\n\\n\\n\\n\\n\\n\\n\\n\\nplz check it passes 45/51 but for huge chunk of 1s array it gives TLE"
                    },
                    {
                        "username": "namandt",
                        "content": "true"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "First I used Two-Pointer using only 'two-pointer' which gave me TLE at 45/51 Test-Case then after 1hr of trying to figure out I had to check Solution tab, Long way to go and learn.\n\nTip: Be careful while implementing Two-Pointer solution. One might need to add 3rd Pointer\n\nHint : They are expecting you to solve this problem in O(n) TC"
                    },
                    {
                        "username": "dumb_me",
                        "content": "2 pointer is really painfull when question is tagged hard \\uD83D\\uDE2D\\uD83D\\uDE2D\\n"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "Huh? a **hard** problem?"
                    },
                    {
                        "username": "beardedone",
                        "content": "[@arghyadas](/arghyadas) pieceofpie\\'s solution is the same as the official leetcode solution verbatim with the comments removed and the white space adjusted."
                    },
                    {
                        "username": "xeniawann",
                        "content": "Impressive solution! I only though of a sliding window, I wonder how you came up with that?"
                    },
                    {
                        "username": "arghyadas",
                        "content": "I saw your solution, Its pretty impressive. But I\\'m not able to get the intuition behind that\\uD83E\\uDD72"
                    },
                    {
                        "username": "shivansh961",
                        "content": "I think this is a precise level of hard question"
                    },
                    {
                        "username": "roishevah",
                        "content": "This question is tagged with possible solution using queue/monotonnic queue, but it seems like it\\'s not related to the question.\\nCan someone please exaplain why/how monotonnic queue should be used to solve this question?"
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "This should be marked as Medium problem"
                    }
                ]
            },
            {
                "id": 2029399,
                "content": [
                    {
                        "username": "NicholasCG",
                        "content": "Maybe it\\'s just from practice, but this is an easier hard."
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Simple Question + Very Large Input == Hard Problem\\nSimple Question + TLE                      == Hard Problem"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This isn\\'t hard at all after I\\'ve watched the solution. Still a long way to go."
                    },
                    {
                        "username": "Msey",
                        "content": "every question is easy when you read the solution"
                    },
                    {
                        "username": "ajbil3112",
                        "content": "why this question can not be solve using minheap and maxheap ?"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "Implementing heap would need at least O(nlogn) time complexity. Solution needs to be order of O(n)."
                    },
                    {
                        "username": "ShantanuDutta",
                        "content": " long long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n    long long c = 0;\\n    int flagMin = 0, flagMax = 0;\\n    int i = 0, j = 0;\\n\\n    while (i < nums.size()) {\\n        if (nums[j] >= minK && nums[j] <= maxK) {\\n            if (nums[j] == minK) {\\n                flagMin = 1;\\n            } \\n            if (nums[j] == maxK) {\\n                flagMax = 1;\\n            }\\n\\n            if (flagMin == 1 && flagMax == 1) {\\n                c++;\\n            }\\n            j++;\\n        } else {\\n            i++;\\n            j = i;\\n            flagMin = 0;\\n            flagMax = 0;\\n        }\\n\\n        if (j == nums.size()) {\\n            i++;\\n            j = i;\\n            flagMin = 0;\\n            flagMax = 0;\\n        }\\n    }\\n\\n    return c;\\n} \\n\\n\\n\\n\\n\\n\\n\\n\\nplz check it passes 45/51 but for huge chunk of 1s array it gives TLE"
                    },
                    {
                        "username": "namandt",
                        "content": "true"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "First I used Two-Pointer using only 'two-pointer' which gave me TLE at 45/51 Test-Case then after 1hr of trying to figure out I had to check Solution tab, Long way to go and learn.\n\nTip: Be careful while implementing Two-Pointer solution. One might need to add 3rd Pointer\n\nHint : They are expecting you to solve this problem in O(n) TC"
                    },
                    {
                        "username": "dumb_me",
                        "content": "2 pointer is really painfull when question is tagged hard \\uD83D\\uDE2D\\uD83D\\uDE2D\\n"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "Huh? a **hard** problem?"
                    },
                    {
                        "username": "beardedone",
                        "content": "[@arghyadas](/arghyadas) pieceofpie\\'s solution is the same as the official leetcode solution verbatim with the comments removed and the white space adjusted."
                    },
                    {
                        "username": "xeniawann",
                        "content": "Impressive solution! I only though of a sliding window, I wonder how you came up with that?"
                    },
                    {
                        "username": "arghyadas",
                        "content": "I saw your solution, Its pretty impressive. But I\\'m not able to get the intuition behind that\\uD83E\\uDD72"
                    },
                    {
                        "username": "shivansh961",
                        "content": "I think this is a precise level of hard question"
                    },
                    {
                        "username": "roishevah",
                        "content": "This question is tagged with possible solution using queue/monotonnic queue, but it seems like it\\'s not related to the question.\\nCan someone please exaplain why/how monotonnic queue should be used to solve this question?"
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "This should be marked as Medium problem"
                    }
                ]
            },
            {
                "id": 1848406,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Damn. I spent quite long on this problem, coming up with convoluted divide and conquer solutions that kept giving wrong answers because I was double counting stuff all the time.\\nIn the end, I just simplified my thinking process, eliminated the unnecessary information I was keeping track of, and came up with a really simple solution that holds in just a few line of codes. The intuition behind it is also really pretty simple to explain. It just took me really long to come up with it\\nUsually, the feeling when you finally get it is very satisfying, but here it was more like \"All this for THAT?\"\\n\\n `    def countSubarrays(self, nums: List[int], minK: int, maxK: int) -> int:\\n        \\n        count=0\\n        start=lastmin=lastmax=-1\\n        for i,num in enumerate(nums):\\n            if num==minK: lastmin=i\\n            if num==maxK: lastmax=i\\n            if num>maxK or num<minK: start=lastmin=lastmax=i\\n            count+=min(lastmin,lastmax)-start\\n\\n        return count`"
                    },
                    {
                        "username": "Anonymous84",
                        "content": "if I find solution bruce force, it for me. TLE\\n```python\\ndef countSubarrays(self, nums: List[int], minK: int, maxK: int) -> int:\\n    n = len(nums)\\n    ans = 0\\n    for i in range(0, n):\\n        if nums[i] < minK or nums[i] > maxK:\\n            continue\\n        c = 0\\n        min_val = float(\\'inf\\')\\n        max_val = float(\\'-inf\\')\\n        for k in range(i, n):\\n            min_val = min(min_val, nums[k])\\n            max_val = max(max_val, nums[k])\\n            if min_val == minK and max_val == maxK:\\n                c = c + 1\\n        ans = ans + c\\n    return ans\\n```"
                    },
                    {
                        "username": "chirag_j_rana",
                        "content": "Damnnn... This is Beautiful!!"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Brute force with little added effieciency actually counts as solved lol , i added breakpoints and just counted as usual"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Refer to my solution , i explained in detail there"
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "easily explained , O(n) solution, try and you won\\'t regret  also your sub and comment is appreciated https://youtu.be/iHIhb_dfbMM"
                    },
                    {
                        "username": "ProgDevel",
                        "content": "Just an example  of decomposition of array `[1,2,1,4,1,3,4]` with `minK=1` and `maxK=4`. Answer is `16`\\n```\\n[1,2,1,4]\\n  [2,1,4]\\n    [1,4]\\n[1,2,1,4,1,3,4]\\n[1,2,1,4,1,3]\\n[1,2,1,4,1]\\n  [2,1,4,1,3,4]\\n  [2,1,4,1,3]\\n  [2,1,4,1]\\n    [1,4,1,3,4]\\n    [1,4,1,3]\\n    [1,4,1]\\n      [4,1,3,4]\\n      [4,1,3]\\n      [4,1]\\n        [1,3,4]\\n```"
                    },
                    {
                        "username": "hoangnn451",
                        "content": "I was thinking in a very confusing way and couldn\\'t implement it, after looking at the solution it\\'s very simple to implement. "
                    },
                    {
                        "username": "ArtsemMaliutsin",
                        "content": "really? "
                    },
                    {
                        "username": "mabatov",
                        "content": "how to avoid TLE?"
                    },
                    {
                        "username": "kumarnitesh88441",
                        "content": "\\u2705using brute force O(N^2) is give the TLE.\\n\\u2705but I using O(N) is awesome (:"
                    }
                ]
            },
            {
                "id": 1822719,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Damn. I spent quite long on this problem, coming up with convoluted divide and conquer solutions that kept giving wrong answers because I was double counting stuff all the time.\\nIn the end, I just simplified my thinking process, eliminated the unnecessary information I was keeping track of, and came up with a really simple solution that holds in just a few line of codes. The intuition behind it is also really pretty simple to explain. It just took me really long to come up with it\\nUsually, the feeling when you finally get it is very satisfying, but here it was more like \"All this for THAT?\"\\n\\n `    def countSubarrays(self, nums: List[int], minK: int, maxK: int) -> int:\\n        \\n        count=0\\n        start=lastmin=lastmax=-1\\n        for i,num in enumerate(nums):\\n            if num==minK: lastmin=i\\n            if num==maxK: lastmax=i\\n            if num>maxK or num<minK: start=lastmin=lastmax=i\\n            count+=min(lastmin,lastmax)-start\\n\\n        return count`"
                    },
                    {
                        "username": "Anonymous84",
                        "content": "if I find solution bruce force, it for me. TLE\\n```python\\ndef countSubarrays(self, nums: List[int], minK: int, maxK: int) -> int:\\n    n = len(nums)\\n    ans = 0\\n    for i in range(0, n):\\n        if nums[i] < minK or nums[i] > maxK:\\n            continue\\n        c = 0\\n        min_val = float(\\'inf\\')\\n        max_val = float(\\'-inf\\')\\n        for k in range(i, n):\\n            min_val = min(min_val, nums[k])\\n            max_val = max(max_val, nums[k])\\n            if min_val == minK and max_val == maxK:\\n                c = c + 1\\n        ans = ans + c\\n    return ans\\n```"
                    },
                    {
                        "username": "chirag_j_rana",
                        "content": "Damnnn... This is Beautiful!!"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Brute force with little added effieciency actually counts as solved lol , i added breakpoints and just counted as usual"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Refer to my solution , i explained in detail there"
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "easily explained , O(n) solution, try and you won\\'t regret  also your sub and comment is appreciated https://youtu.be/iHIhb_dfbMM"
                    },
                    {
                        "username": "ProgDevel",
                        "content": "Just an example  of decomposition of array `[1,2,1,4,1,3,4]` with `minK=1` and `maxK=4`. Answer is `16`\\n```\\n[1,2,1,4]\\n  [2,1,4]\\n    [1,4]\\n[1,2,1,4,1,3,4]\\n[1,2,1,4,1,3]\\n[1,2,1,4,1]\\n  [2,1,4,1,3,4]\\n  [2,1,4,1,3]\\n  [2,1,4,1]\\n    [1,4,1,3,4]\\n    [1,4,1,3]\\n    [1,4,1]\\n      [4,1,3,4]\\n      [4,1,3]\\n      [4,1]\\n        [1,3,4]\\n```"
                    },
                    {
                        "username": "hoangnn451",
                        "content": "I was thinking in a very confusing way and couldn\\'t implement it, after looking at the solution it\\'s very simple to implement. "
                    },
                    {
                        "username": "ArtsemMaliutsin",
                        "content": "really? "
                    },
                    {
                        "username": "mabatov",
                        "content": "how to avoid TLE?"
                    },
                    {
                        "username": "kumarnitesh88441",
                        "content": "\\u2705using brute force O(N^2) is give the TLE.\\n\\u2705but I using O(N) is awesome (:"
                    }
                ]
            },
            {
                "id": 1821990,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Damn. I spent quite long on this problem, coming up with convoluted divide and conquer solutions that kept giving wrong answers because I was double counting stuff all the time.\\nIn the end, I just simplified my thinking process, eliminated the unnecessary information I was keeping track of, and came up with a really simple solution that holds in just a few line of codes. The intuition behind it is also really pretty simple to explain. It just took me really long to come up with it\\nUsually, the feeling when you finally get it is very satisfying, but here it was more like \"All this for THAT?\"\\n\\n `    def countSubarrays(self, nums: List[int], minK: int, maxK: int) -> int:\\n        \\n        count=0\\n        start=lastmin=lastmax=-1\\n        for i,num in enumerate(nums):\\n            if num==minK: lastmin=i\\n            if num==maxK: lastmax=i\\n            if num>maxK or num<minK: start=lastmin=lastmax=i\\n            count+=min(lastmin,lastmax)-start\\n\\n        return count`"
                    },
                    {
                        "username": "Anonymous84",
                        "content": "if I find solution bruce force, it for me. TLE\\n```python\\ndef countSubarrays(self, nums: List[int], minK: int, maxK: int) -> int:\\n    n = len(nums)\\n    ans = 0\\n    for i in range(0, n):\\n        if nums[i] < minK or nums[i] > maxK:\\n            continue\\n        c = 0\\n        min_val = float(\\'inf\\')\\n        max_val = float(\\'-inf\\')\\n        for k in range(i, n):\\n            min_val = min(min_val, nums[k])\\n            max_val = max(max_val, nums[k])\\n            if min_val == minK and max_val == maxK:\\n                c = c + 1\\n        ans = ans + c\\n    return ans\\n```"
                    },
                    {
                        "username": "chirag_j_rana",
                        "content": "Damnnn... This is Beautiful!!"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Brute force with little added effieciency actually counts as solved lol , i added breakpoints and just counted as usual"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Refer to my solution , i explained in detail there"
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "easily explained , O(n) solution, try and you won\\'t regret  also your sub and comment is appreciated https://youtu.be/iHIhb_dfbMM"
                    },
                    {
                        "username": "ProgDevel",
                        "content": "Just an example  of decomposition of array `[1,2,1,4,1,3,4]` with `minK=1` and `maxK=4`. Answer is `16`\\n```\\n[1,2,1,4]\\n  [2,1,4]\\n    [1,4]\\n[1,2,1,4,1,3,4]\\n[1,2,1,4,1,3]\\n[1,2,1,4,1]\\n  [2,1,4,1,3,4]\\n  [2,1,4,1,3]\\n  [2,1,4,1]\\n    [1,4,1,3,4]\\n    [1,4,1,3]\\n    [1,4,1]\\n      [4,1,3,4]\\n      [4,1,3]\\n      [4,1]\\n        [1,3,4]\\n```"
                    },
                    {
                        "username": "hoangnn451",
                        "content": "I was thinking in a very confusing way and couldn\\'t implement it, after looking at the solution it\\'s very simple to implement. "
                    },
                    {
                        "username": "ArtsemMaliutsin",
                        "content": "really? "
                    },
                    {
                        "username": "mabatov",
                        "content": "how to avoid TLE?"
                    },
                    {
                        "username": "kumarnitesh88441",
                        "content": "\\u2705using brute force O(N^2) is give the TLE.\\n\\u2705but I using O(N) is awesome (:"
                    }
                ]
            },
            {
                "id": 1821920,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Damn. I spent quite long on this problem, coming up with convoluted divide and conquer solutions that kept giving wrong answers because I was double counting stuff all the time.\\nIn the end, I just simplified my thinking process, eliminated the unnecessary information I was keeping track of, and came up with a really simple solution that holds in just a few line of codes. The intuition behind it is also really pretty simple to explain. It just took me really long to come up with it\\nUsually, the feeling when you finally get it is very satisfying, but here it was more like \"All this for THAT?\"\\n\\n `    def countSubarrays(self, nums: List[int], minK: int, maxK: int) -> int:\\n        \\n        count=0\\n        start=lastmin=lastmax=-1\\n        for i,num in enumerate(nums):\\n            if num==minK: lastmin=i\\n            if num==maxK: lastmax=i\\n            if num>maxK or num<minK: start=lastmin=lastmax=i\\n            count+=min(lastmin,lastmax)-start\\n\\n        return count`"
                    },
                    {
                        "username": "Anonymous84",
                        "content": "if I find solution bruce force, it for me. TLE\\n```python\\ndef countSubarrays(self, nums: List[int], minK: int, maxK: int) -> int:\\n    n = len(nums)\\n    ans = 0\\n    for i in range(0, n):\\n        if nums[i] < minK or nums[i] > maxK:\\n            continue\\n        c = 0\\n        min_val = float(\\'inf\\')\\n        max_val = float(\\'-inf\\')\\n        for k in range(i, n):\\n            min_val = min(min_val, nums[k])\\n            max_val = max(max_val, nums[k])\\n            if min_val == minK and max_val == maxK:\\n                c = c + 1\\n        ans = ans + c\\n    return ans\\n```"
                    },
                    {
                        "username": "chirag_j_rana",
                        "content": "Damnnn... This is Beautiful!!"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Brute force with little added effieciency actually counts as solved lol , i added breakpoints and just counted as usual"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Refer to my solution , i explained in detail there"
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "easily explained , O(n) solution, try and you won\\'t regret  also your sub and comment is appreciated https://youtu.be/iHIhb_dfbMM"
                    },
                    {
                        "username": "ProgDevel",
                        "content": "Just an example  of decomposition of array `[1,2,1,4,1,3,4]` with `minK=1` and `maxK=4`. Answer is `16`\\n```\\n[1,2,1,4]\\n  [2,1,4]\\n    [1,4]\\n[1,2,1,4,1,3,4]\\n[1,2,1,4,1,3]\\n[1,2,1,4,1]\\n  [2,1,4,1,3,4]\\n  [2,1,4,1,3]\\n  [2,1,4,1]\\n    [1,4,1,3,4]\\n    [1,4,1,3]\\n    [1,4,1]\\n      [4,1,3,4]\\n      [4,1,3]\\n      [4,1]\\n        [1,3,4]\\n```"
                    },
                    {
                        "username": "hoangnn451",
                        "content": "I was thinking in a very confusing way and couldn\\'t implement it, after looking at the solution it\\'s very simple to implement. "
                    },
                    {
                        "username": "ArtsemMaliutsin",
                        "content": "really? "
                    },
                    {
                        "username": "mabatov",
                        "content": "how to avoid TLE?"
                    },
                    {
                        "username": "kumarnitesh88441",
                        "content": "\\u2705using brute force O(N^2) is give the TLE.\\n\\u2705but I using O(N) is awesome (:"
                    }
                ]
            },
            {
                "id": 1821909,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Damn. I spent quite long on this problem, coming up with convoluted divide and conquer solutions that kept giving wrong answers because I was double counting stuff all the time.\\nIn the end, I just simplified my thinking process, eliminated the unnecessary information I was keeping track of, and came up with a really simple solution that holds in just a few line of codes. The intuition behind it is also really pretty simple to explain. It just took me really long to come up with it\\nUsually, the feeling when you finally get it is very satisfying, but here it was more like \"All this for THAT?\"\\n\\n `    def countSubarrays(self, nums: List[int], minK: int, maxK: int) -> int:\\n        \\n        count=0\\n        start=lastmin=lastmax=-1\\n        for i,num in enumerate(nums):\\n            if num==minK: lastmin=i\\n            if num==maxK: lastmax=i\\n            if num>maxK or num<minK: start=lastmin=lastmax=i\\n            count+=min(lastmin,lastmax)-start\\n\\n        return count`"
                    },
                    {
                        "username": "Anonymous84",
                        "content": "if I find solution bruce force, it for me. TLE\\n```python\\ndef countSubarrays(self, nums: List[int], minK: int, maxK: int) -> int:\\n    n = len(nums)\\n    ans = 0\\n    for i in range(0, n):\\n        if nums[i] < minK or nums[i] > maxK:\\n            continue\\n        c = 0\\n        min_val = float(\\'inf\\')\\n        max_val = float(\\'-inf\\')\\n        for k in range(i, n):\\n            min_val = min(min_val, nums[k])\\n            max_val = max(max_val, nums[k])\\n            if min_val == minK and max_val == maxK:\\n                c = c + 1\\n        ans = ans + c\\n    return ans\\n```"
                    },
                    {
                        "username": "chirag_j_rana",
                        "content": "Damnnn... This is Beautiful!!"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Brute force with little added effieciency actually counts as solved lol , i added breakpoints and just counted as usual"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Refer to my solution , i explained in detail there"
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "easily explained , O(n) solution, try and you won\\'t regret  also your sub and comment is appreciated https://youtu.be/iHIhb_dfbMM"
                    },
                    {
                        "username": "ProgDevel",
                        "content": "Just an example  of decomposition of array `[1,2,1,4,1,3,4]` with `minK=1` and `maxK=4`. Answer is `16`\\n```\\n[1,2,1,4]\\n  [2,1,4]\\n    [1,4]\\n[1,2,1,4,1,3,4]\\n[1,2,1,4,1,3]\\n[1,2,1,4,1]\\n  [2,1,4,1,3,4]\\n  [2,1,4,1,3]\\n  [2,1,4,1]\\n    [1,4,1,3,4]\\n    [1,4,1,3]\\n    [1,4,1]\\n      [4,1,3,4]\\n      [4,1,3]\\n      [4,1]\\n        [1,3,4]\\n```"
                    },
                    {
                        "username": "hoangnn451",
                        "content": "I was thinking in a very confusing way and couldn\\'t implement it, after looking at the solution it\\'s very simple to implement. "
                    },
                    {
                        "username": "ArtsemMaliutsin",
                        "content": "really? "
                    },
                    {
                        "username": "mabatov",
                        "content": "how to avoid TLE?"
                    },
                    {
                        "username": "kumarnitesh88441",
                        "content": "\\u2705using brute force O(N^2) is give the TLE.\\n\\u2705but I using O(N) is awesome (:"
                    }
                ]
            },
            {
                "id": 1821750,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Damn. I spent quite long on this problem, coming up with convoluted divide and conquer solutions that kept giving wrong answers because I was double counting stuff all the time.\\nIn the end, I just simplified my thinking process, eliminated the unnecessary information I was keeping track of, and came up with a really simple solution that holds in just a few line of codes. The intuition behind it is also really pretty simple to explain. It just took me really long to come up with it\\nUsually, the feeling when you finally get it is very satisfying, but here it was more like \"All this for THAT?\"\\n\\n `    def countSubarrays(self, nums: List[int], minK: int, maxK: int) -> int:\\n        \\n        count=0\\n        start=lastmin=lastmax=-1\\n        for i,num in enumerate(nums):\\n            if num==minK: lastmin=i\\n            if num==maxK: lastmax=i\\n            if num>maxK or num<minK: start=lastmin=lastmax=i\\n            count+=min(lastmin,lastmax)-start\\n\\n        return count`"
                    },
                    {
                        "username": "Anonymous84",
                        "content": "if I find solution bruce force, it for me. TLE\\n```python\\ndef countSubarrays(self, nums: List[int], minK: int, maxK: int) -> int:\\n    n = len(nums)\\n    ans = 0\\n    for i in range(0, n):\\n        if nums[i] < minK or nums[i] > maxK:\\n            continue\\n        c = 0\\n        min_val = float(\\'inf\\')\\n        max_val = float(\\'-inf\\')\\n        for k in range(i, n):\\n            min_val = min(min_val, nums[k])\\n            max_val = max(max_val, nums[k])\\n            if min_val == minK and max_val == maxK:\\n                c = c + 1\\n        ans = ans + c\\n    return ans\\n```"
                    },
                    {
                        "username": "chirag_j_rana",
                        "content": "Damnnn... This is Beautiful!!"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Brute force with little added effieciency actually counts as solved lol , i added breakpoints and just counted as usual"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Refer to my solution , i explained in detail there"
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "easily explained , O(n) solution, try and you won\\'t regret  also your sub and comment is appreciated https://youtu.be/iHIhb_dfbMM"
                    },
                    {
                        "username": "ProgDevel",
                        "content": "Just an example  of decomposition of array `[1,2,1,4,1,3,4]` with `minK=1` and `maxK=4`. Answer is `16`\\n```\\n[1,2,1,4]\\n  [2,1,4]\\n    [1,4]\\n[1,2,1,4,1,3,4]\\n[1,2,1,4,1,3]\\n[1,2,1,4,1]\\n  [2,1,4,1,3,4]\\n  [2,1,4,1,3]\\n  [2,1,4,1]\\n    [1,4,1,3,4]\\n    [1,4,1,3]\\n    [1,4,1]\\n      [4,1,3,4]\\n      [4,1,3]\\n      [4,1]\\n        [1,3,4]\\n```"
                    },
                    {
                        "username": "hoangnn451",
                        "content": "I was thinking in a very confusing way and couldn\\'t implement it, after looking at the solution it\\'s very simple to implement. "
                    },
                    {
                        "username": "ArtsemMaliutsin",
                        "content": "really? "
                    },
                    {
                        "username": "mabatov",
                        "content": "how to avoid TLE?"
                    },
                    {
                        "username": "kumarnitesh88441",
                        "content": "\\u2705using brute force O(N^2) is give the TLE.\\n\\u2705but I using O(N) is awesome (:"
                    }
                ]
            },
            {
                "id": 1821439,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Damn. I spent quite long on this problem, coming up with convoluted divide and conquer solutions that kept giving wrong answers because I was double counting stuff all the time.\\nIn the end, I just simplified my thinking process, eliminated the unnecessary information I was keeping track of, and came up with a really simple solution that holds in just a few line of codes. The intuition behind it is also really pretty simple to explain. It just took me really long to come up with it\\nUsually, the feeling when you finally get it is very satisfying, but here it was more like \"All this for THAT?\"\\n\\n `    def countSubarrays(self, nums: List[int], minK: int, maxK: int) -> int:\\n        \\n        count=0\\n        start=lastmin=lastmax=-1\\n        for i,num in enumerate(nums):\\n            if num==minK: lastmin=i\\n            if num==maxK: lastmax=i\\n            if num>maxK or num<minK: start=lastmin=lastmax=i\\n            count+=min(lastmin,lastmax)-start\\n\\n        return count`"
                    },
                    {
                        "username": "Anonymous84",
                        "content": "if I find solution bruce force, it for me. TLE\\n```python\\ndef countSubarrays(self, nums: List[int], minK: int, maxK: int) -> int:\\n    n = len(nums)\\n    ans = 0\\n    for i in range(0, n):\\n        if nums[i] < minK or nums[i] > maxK:\\n            continue\\n        c = 0\\n        min_val = float(\\'inf\\')\\n        max_val = float(\\'-inf\\')\\n        for k in range(i, n):\\n            min_val = min(min_val, nums[k])\\n            max_val = max(max_val, nums[k])\\n            if min_val == minK and max_val == maxK:\\n                c = c + 1\\n        ans = ans + c\\n    return ans\\n```"
                    },
                    {
                        "username": "chirag_j_rana",
                        "content": "Damnnn... This is Beautiful!!"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Brute force with little added effieciency actually counts as solved lol , i added breakpoints and just counted as usual"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Refer to my solution , i explained in detail there"
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "easily explained , O(n) solution, try and you won\\'t regret  also your sub and comment is appreciated https://youtu.be/iHIhb_dfbMM"
                    },
                    {
                        "username": "ProgDevel",
                        "content": "Just an example  of decomposition of array `[1,2,1,4,1,3,4]` with `minK=1` and `maxK=4`. Answer is `16`\\n```\\n[1,2,1,4]\\n  [2,1,4]\\n    [1,4]\\n[1,2,1,4,1,3,4]\\n[1,2,1,4,1,3]\\n[1,2,1,4,1]\\n  [2,1,4,1,3,4]\\n  [2,1,4,1,3]\\n  [2,1,4,1]\\n    [1,4,1,3,4]\\n    [1,4,1,3]\\n    [1,4,1]\\n      [4,1,3,4]\\n      [4,1,3]\\n      [4,1]\\n        [1,3,4]\\n```"
                    },
                    {
                        "username": "hoangnn451",
                        "content": "I was thinking in a very confusing way and couldn\\'t implement it, after looking at the solution it\\'s very simple to implement. "
                    },
                    {
                        "username": "ArtsemMaliutsin",
                        "content": "really? "
                    },
                    {
                        "username": "mabatov",
                        "content": "how to avoid TLE?"
                    },
                    {
                        "username": "kumarnitesh88441",
                        "content": "\\u2705using brute force O(N^2) is give the TLE.\\n\\u2705but I using O(N) is awesome (:"
                    }
                ]
            },
            {
                "id": 1821434,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Damn. I spent quite long on this problem, coming up with convoluted divide and conquer solutions that kept giving wrong answers because I was double counting stuff all the time.\\nIn the end, I just simplified my thinking process, eliminated the unnecessary information I was keeping track of, and came up with a really simple solution that holds in just a few line of codes. The intuition behind it is also really pretty simple to explain. It just took me really long to come up with it\\nUsually, the feeling when you finally get it is very satisfying, but here it was more like \"All this for THAT?\"\\n\\n `    def countSubarrays(self, nums: List[int], minK: int, maxK: int) -> int:\\n        \\n        count=0\\n        start=lastmin=lastmax=-1\\n        for i,num in enumerate(nums):\\n            if num==minK: lastmin=i\\n            if num==maxK: lastmax=i\\n            if num>maxK or num<minK: start=lastmin=lastmax=i\\n            count+=min(lastmin,lastmax)-start\\n\\n        return count`"
                    },
                    {
                        "username": "Anonymous84",
                        "content": "if I find solution bruce force, it for me. TLE\\n```python\\ndef countSubarrays(self, nums: List[int], minK: int, maxK: int) -> int:\\n    n = len(nums)\\n    ans = 0\\n    for i in range(0, n):\\n        if nums[i] < minK or nums[i] > maxK:\\n            continue\\n        c = 0\\n        min_val = float(\\'inf\\')\\n        max_val = float(\\'-inf\\')\\n        for k in range(i, n):\\n            min_val = min(min_val, nums[k])\\n            max_val = max(max_val, nums[k])\\n            if min_val == minK and max_val == maxK:\\n                c = c + 1\\n        ans = ans + c\\n    return ans\\n```"
                    },
                    {
                        "username": "chirag_j_rana",
                        "content": "Damnnn... This is Beautiful!!"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Brute force with little added effieciency actually counts as solved lol , i added breakpoints and just counted as usual"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Refer to my solution , i explained in detail there"
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "easily explained , O(n) solution, try and you won\\'t regret  also your sub and comment is appreciated https://youtu.be/iHIhb_dfbMM"
                    },
                    {
                        "username": "ProgDevel",
                        "content": "Just an example  of decomposition of array `[1,2,1,4,1,3,4]` with `minK=1` and `maxK=4`. Answer is `16`\\n```\\n[1,2,1,4]\\n  [2,1,4]\\n    [1,4]\\n[1,2,1,4,1,3,4]\\n[1,2,1,4,1,3]\\n[1,2,1,4,1]\\n  [2,1,4,1,3,4]\\n  [2,1,4,1,3]\\n  [2,1,4,1]\\n    [1,4,1,3,4]\\n    [1,4,1,3]\\n    [1,4,1]\\n      [4,1,3,4]\\n      [4,1,3]\\n      [4,1]\\n        [1,3,4]\\n```"
                    },
                    {
                        "username": "hoangnn451",
                        "content": "I was thinking in a very confusing way and couldn\\'t implement it, after looking at the solution it\\'s very simple to implement. "
                    },
                    {
                        "username": "ArtsemMaliutsin",
                        "content": "really? "
                    },
                    {
                        "username": "mabatov",
                        "content": "how to avoid TLE?"
                    },
                    {
                        "username": "kumarnitesh88441",
                        "content": "\\u2705using brute force O(N^2) is give the TLE.\\n\\u2705but I using O(N) is awesome (:"
                    }
                ]
            },
            {
                "id": 1821396,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Damn. I spent quite long on this problem, coming up with convoluted divide and conquer solutions that kept giving wrong answers because I was double counting stuff all the time.\\nIn the end, I just simplified my thinking process, eliminated the unnecessary information I was keeping track of, and came up with a really simple solution that holds in just a few line of codes. The intuition behind it is also really pretty simple to explain. It just took me really long to come up with it\\nUsually, the feeling when you finally get it is very satisfying, but here it was more like \"All this for THAT?\"\\n\\n `    def countSubarrays(self, nums: List[int], minK: int, maxK: int) -> int:\\n        \\n        count=0\\n        start=lastmin=lastmax=-1\\n        for i,num in enumerate(nums):\\n            if num==minK: lastmin=i\\n            if num==maxK: lastmax=i\\n            if num>maxK or num<minK: start=lastmin=lastmax=i\\n            count+=min(lastmin,lastmax)-start\\n\\n        return count`"
                    },
                    {
                        "username": "Anonymous84",
                        "content": "if I find solution bruce force, it for me. TLE\\n```python\\ndef countSubarrays(self, nums: List[int], minK: int, maxK: int) -> int:\\n    n = len(nums)\\n    ans = 0\\n    for i in range(0, n):\\n        if nums[i] < minK or nums[i] > maxK:\\n            continue\\n        c = 0\\n        min_val = float(\\'inf\\')\\n        max_val = float(\\'-inf\\')\\n        for k in range(i, n):\\n            min_val = min(min_val, nums[k])\\n            max_val = max(max_val, nums[k])\\n            if min_val == minK and max_val == maxK:\\n                c = c + 1\\n        ans = ans + c\\n    return ans\\n```"
                    },
                    {
                        "username": "chirag_j_rana",
                        "content": "Damnnn... This is Beautiful!!"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Brute force with little added effieciency actually counts as solved lol , i added breakpoints and just counted as usual"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Refer to my solution , i explained in detail there"
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "easily explained , O(n) solution, try and you won\\'t regret  also your sub and comment is appreciated https://youtu.be/iHIhb_dfbMM"
                    },
                    {
                        "username": "ProgDevel",
                        "content": "Just an example  of decomposition of array `[1,2,1,4,1,3,4]` with `minK=1` and `maxK=4`. Answer is `16`\\n```\\n[1,2,1,4]\\n  [2,1,4]\\n    [1,4]\\n[1,2,1,4,1,3,4]\\n[1,2,1,4,1,3]\\n[1,2,1,4,1]\\n  [2,1,4,1,3,4]\\n  [2,1,4,1,3]\\n  [2,1,4,1]\\n    [1,4,1,3,4]\\n    [1,4,1,3]\\n    [1,4,1]\\n      [4,1,3,4]\\n      [4,1,3]\\n      [4,1]\\n        [1,3,4]\\n```"
                    },
                    {
                        "username": "hoangnn451",
                        "content": "I was thinking in a very confusing way and couldn\\'t implement it, after looking at the solution it\\'s very simple to implement. "
                    },
                    {
                        "username": "ArtsemMaliutsin",
                        "content": "really? "
                    },
                    {
                        "username": "mabatov",
                        "content": "how to avoid TLE?"
                    },
                    {
                        "username": "kumarnitesh88441",
                        "content": "\\u2705using brute force O(N^2) is give the TLE.\\n\\u2705but I using O(N) is awesome (:"
                    }
                ]
            },
            {
                "id": 1821367,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Damn. I spent quite long on this problem, coming up with convoluted divide and conquer solutions that kept giving wrong answers because I was double counting stuff all the time.\\nIn the end, I just simplified my thinking process, eliminated the unnecessary information I was keeping track of, and came up with a really simple solution that holds in just a few line of codes. The intuition behind it is also really pretty simple to explain. It just took me really long to come up with it\\nUsually, the feeling when you finally get it is very satisfying, but here it was more like \"All this for THAT?\"\\n\\n `    def countSubarrays(self, nums: List[int], minK: int, maxK: int) -> int:\\n        \\n        count=0\\n        start=lastmin=lastmax=-1\\n        for i,num in enumerate(nums):\\n            if num==minK: lastmin=i\\n            if num==maxK: lastmax=i\\n            if num>maxK or num<minK: start=lastmin=lastmax=i\\n            count+=min(lastmin,lastmax)-start\\n\\n        return count`"
                    },
                    {
                        "username": "Anonymous84",
                        "content": "if I find solution bruce force, it for me. TLE\\n```python\\ndef countSubarrays(self, nums: List[int], minK: int, maxK: int) -> int:\\n    n = len(nums)\\n    ans = 0\\n    for i in range(0, n):\\n        if nums[i] < minK or nums[i] > maxK:\\n            continue\\n        c = 0\\n        min_val = float(\\'inf\\')\\n        max_val = float(\\'-inf\\')\\n        for k in range(i, n):\\n            min_val = min(min_val, nums[k])\\n            max_val = max(max_val, nums[k])\\n            if min_val == minK and max_val == maxK:\\n                c = c + 1\\n        ans = ans + c\\n    return ans\\n```"
                    },
                    {
                        "username": "chirag_j_rana",
                        "content": "Damnnn... This is Beautiful!!"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Brute force with little added effieciency actually counts as solved lol , i added breakpoints and just counted as usual"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Refer to my solution , i explained in detail there"
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "easily explained , O(n) solution, try and you won\\'t regret  also your sub and comment is appreciated https://youtu.be/iHIhb_dfbMM"
                    },
                    {
                        "username": "ProgDevel",
                        "content": "Just an example  of decomposition of array `[1,2,1,4,1,3,4]` with `minK=1` and `maxK=4`. Answer is `16`\\n```\\n[1,2,1,4]\\n  [2,1,4]\\n    [1,4]\\n[1,2,1,4,1,3,4]\\n[1,2,1,4,1,3]\\n[1,2,1,4,1]\\n  [2,1,4,1,3,4]\\n  [2,1,4,1,3]\\n  [2,1,4,1]\\n    [1,4,1,3,4]\\n    [1,4,1,3]\\n    [1,4,1]\\n      [4,1,3,4]\\n      [4,1,3]\\n      [4,1]\\n        [1,3,4]\\n```"
                    },
                    {
                        "username": "hoangnn451",
                        "content": "I was thinking in a very confusing way and couldn\\'t implement it, after looking at the solution it\\'s very simple to implement. "
                    },
                    {
                        "username": "ArtsemMaliutsin",
                        "content": "really? "
                    },
                    {
                        "username": "mabatov",
                        "content": "how to avoid TLE?"
                    },
                    {
                        "username": "kumarnitesh88441",
                        "content": "\\u2705using brute force O(N^2) is give the TLE.\\n\\u2705but I using O(N) is awesome (:"
                    }
                ]
            },
            {
                "id": 1821358,
                "content": [
                    {
                        "username": "charonme",
                        "content": "for a \"hard\" problem the time constraints could be made more strict as I didn\\'t get TLE even though I didn\\'t use the queue optimization"
                    },
                    {
                        "username": "kumarnitesh88441",
                        "content": "I used two pointers but gives TLE?"
                    },
                    {
                        "username": "saurabh-huh",
                        "content": "It is a much hard problem than  I think"
                    },
                    {
                        "username": "cus_ved",
                        "content": " `your inline code...your inline code...`\\nlong long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n        int n=nums.size();\\n        int ind=-1;\\n        pair<int,int>p={-1,-1};\\n        long long int ans=0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]>=minK &&nums[i]<=maxK){\\n                if(ind==-1)\\n                ind=i;\\n            }\\n            else{\\n                ind=-1;\\n                p.first=-1;\\n                p.second=-1;\\n                continue;\\n            }\\n            if(nums[i]==minK){\\n                p.first=i;\\n            }\\n            if(nums[i]==maxK){\\n                p.second=i;\\n            }\\n            int ind1=min(p.first,p.second);\\n            int ind2=max(p.first,p.second);\\n            if(ind1!=-1 &&ind2!=-1){\\n                int l=ind1-ind;\\n                ans+=1LL*(l+1);\\n            }\\n\\n\\n        }\\n     without 1LL i am getting TLE...why?"
                    },
                    {
                        "username": "AhmadSaleh2001",
                        "content": "Hint : Don\\'t use vector in c++ because its very slow"
                    },
                    {
                        "username": "beardedone",
                        "content": "vectors in c++ aren\\'t slow.  Access to an element in a vector is the same as an array, if you use the [] operator or an iterator.  Resizing the vector takes some time, but you can reserve space in the vector before you start adding to it to avoid multiple memory allocations.  What alternative do you propose?  The nums parameter is expected to be a vector.\\n\\nAlso, this problem can be solved with a space complexity of O(1) space, so other than nums parameter, where does the vector or its alternative come in?"
                    },
                    {
                        "username": "Tensor08",
                        "content": "This problem should be marked as `BrainTeaser`, Good Question though."
                    },
                    {
                        "username": "Jack_knight",
                        "content": "We can have 2 segment trees one for giving max in range and other one for giving min in range then store indices of minK and maxK then find minimum and maximum between those indices if it follow the condition add it to the answer.\\nCan anyone help to implement it and clarify if this will work or not?"
                    },
                    {
                        "username": "harshitisback",
                        "content": "yup you can solve it by two priorityQueue but the problem is TLE "
                    },
                    {
                        "username": "VigneshwarVG",
                        "content": "hint :   keep track of the values that are less than the minK too \\n     it might help.."
                    },
                    {
                        "username": "VigneshwarVG",
                        "content": "i came across this test case : \\nit might help you to get a hint\\n[934372,927845,479424,49441,17167,17167,65553,927845,17167,927845,17167,425106,17167,927845,17167,927845,251338,17167]\\nminK =\\n17167\\nmaxK =\\n927845\\nUse Testcase\\nOutput\\n132"
                    },
                    {
                        "username": "rookycipher",
                        "content": "I am only able to find 58 sub arrays for the following input {35054,398719,945315,945315,820417,945315,35054,945315,171832,945315,35054,109750,790964,441974,552913}. But the test case has 81 as the expected output and I am not able to understand, how?"
                    },
                    {
                        "username": "VigneshwarVG",
                        "content": "keep track of both mink and maxk  \\ni guess you might have not keep track of  values between the boundaries as greater than or equal to  mink and lesser or equal to maxk"
                    }
                ]
            },
            {
                "id": 1821349,
                "content": [
                    {
                        "username": "charonme",
                        "content": "for a \"hard\" problem the time constraints could be made more strict as I didn\\'t get TLE even though I didn\\'t use the queue optimization"
                    },
                    {
                        "username": "kumarnitesh88441",
                        "content": "I used two pointers but gives TLE?"
                    },
                    {
                        "username": "saurabh-huh",
                        "content": "It is a much hard problem than  I think"
                    },
                    {
                        "username": "cus_ved",
                        "content": " `your inline code...your inline code...`\\nlong long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n        int n=nums.size();\\n        int ind=-1;\\n        pair<int,int>p={-1,-1};\\n        long long int ans=0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]>=minK &&nums[i]<=maxK){\\n                if(ind==-1)\\n                ind=i;\\n            }\\n            else{\\n                ind=-1;\\n                p.first=-1;\\n                p.second=-1;\\n                continue;\\n            }\\n            if(nums[i]==minK){\\n                p.first=i;\\n            }\\n            if(nums[i]==maxK){\\n                p.second=i;\\n            }\\n            int ind1=min(p.first,p.second);\\n            int ind2=max(p.first,p.second);\\n            if(ind1!=-1 &&ind2!=-1){\\n                int l=ind1-ind;\\n                ans+=1LL*(l+1);\\n            }\\n\\n\\n        }\\n     without 1LL i am getting TLE...why?"
                    },
                    {
                        "username": "AhmadSaleh2001",
                        "content": "Hint : Don\\'t use vector in c++ because its very slow"
                    },
                    {
                        "username": "beardedone",
                        "content": "vectors in c++ aren\\'t slow.  Access to an element in a vector is the same as an array, if you use the [] operator or an iterator.  Resizing the vector takes some time, but you can reserve space in the vector before you start adding to it to avoid multiple memory allocations.  What alternative do you propose?  The nums parameter is expected to be a vector.\\n\\nAlso, this problem can be solved with a space complexity of O(1) space, so other than nums parameter, where does the vector or its alternative come in?"
                    },
                    {
                        "username": "Tensor08",
                        "content": "This problem should be marked as `BrainTeaser`, Good Question though."
                    },
                    {
                        "username": "Jack_knight",
                        "content": "We can have 2 segment trees one for giving max in range and other one for giving min in range then store indices of minK and maxK then find minimum and maximum between those indices if it follow the condition add it to the answer.\\nCan anyone help to implement it and clarify if this will work or not?"
                    },
                    {
                        "username": "harshitisback",
                        "content": "yup you can solve it by two priorityQueue but the problem is TLE "
                    },
                    {
                        "username": "VigneshwarVG",
                        "content": "hint :   keep track of the values that are less than the minK too \\n     it might help.."
                    },
                    {
                        "username": "VigneshwarVG",
                        "content": "i came across this test case : \\nit might help you to get a hint\\n[934372,927845,479424,49441,17167,17167,65553,927845,17167,927845,17167,425106,17167,927845,17167,927845,251338,17167]\\nminK =\\n17167\\nmaxK =\\n927845\\nUse Testcase\\nOutput\\n132"
                    },
                    {
                        "username": "rookycipher",
                        "content": "I am only able to find 58 sub arrays for the following input {35054,398719,945315,945315,820417,945315,35054,945315,171832,945315,35054,109750,790964,441974,552913}. But the test case has 81 as the expected output and I am not able to understand, how?"
                    },
                    {
                        "username": "VigneshwarVG",
                        "content": "keep track of both mink and maxk  \\ni guess you might have not keep track of  values between the boundaries as greater than or equal to  mink and lesser or equal to maxk"
                    }
                ]
            },
            {
                "id": 1821312,
                "content": [
                    {
                        "username": "charonme",
                        "content": "for a \"hard\" problem the time constraints could be made more strict as I didn\\'t get TLE even though I didn\\'t use the queue optimization"
                    },
                    {
                        "username": "kumarnitesh88441",
                        "content": "I used two pointers but gives TLE?"
                    },
                    {
                        "username": "saurabh-huh",
                        "content": "It is a much hard problem than  I think"
                    },
                    {
                        "username": "cus_ved",
                        "content": " `your inline code...your inline code...`\\nlong long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n        int n=nums.size();\\n        int ind=-1;\\n        pair<int,int>p={-1,-1};\\n        long long int ans=0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]>=minK &&nums[i]<=maxK){\\n                if(ind==-1)\\n                ind=i;\\n            }\\n            else{\\n                ind=-1;\\n                p.first=-1;\\n                p.second=-1;\\n                continue;\\n            }\\n            if(nums[i]==minK){\\n                p.first=i;\\n            }\\n            if(nums[i]==maxK){\\n                p.second=i;\\n            }\\n            int ind1=min(p.first,p.second);\\n            int ind2=max(p.first,p.second);\\n            if(ind1!=-1 &&ind2!=-1){\\n                int l=ind1-ind;\\n                ans+=1LL*(l+1);\\n            }\\n\\n\\n        }\\n     without 1LL i am getting TLE...why?"
                    },
                    {
                        "username": "AhmadSaleh2001",
                        "content": "Hint : Don\\'t use vector in c++ because its very slow"
                    },
                    {
                        "username": "beardedone",
                        "content": "vectors in c++ aren\\'t slow.  Access to an element in a vector is the same as an array, if you use the [] operator or an iterator.  Resizing the vector takes some time, but you can reserve space in the vector before you start adding to it to avoid multiple memory allocations.  What alternative do you propose?  The nums parameter is expected to be a vector.\\n\\nAlso, this problem can be solved with a space complexity of O(1) space, so other than nums parameter, where does the vector or its alternative come in?"
                    },
                    {
                        "username": "Tensor08",
                        "content": "This problem should be marked as `BrainTeaser`, Good Question though."
                    },
                    {
                        "username": "Jack_knight",
                        "content": "We can have 2 segment trees one for giving max in range and other one for giving min in range then store indices of minK and maxK then find minimum and maximum between those indices if it follow the condition add it to the answer.\\nCan anyone help to implement it and clarify if this will work or not?"
                    },
                    {
                        "username": "harshitisback",
                        "content": "yup you can solve it by two priorityQueue but the problem is TLE "
                    },
                    {
                        "username": "VigneshwarVG",
                        "content": "hint :   keep track of the values that are less than the minK too \\n     it might help.."
                    },
                    {
                        "username": "VigneshwarVG",
                        "content": "i came across this test case : \\nit might help you to get a hint\\n[934372,927845,479424,49441,17167,17167,65553,927845,17167,927845,17167,425106,17167,927845,17167,927845,251338,17167]\\nminK =\\n17167\\nmaxK =\\n927845\\nUse Testcase\\nOutput\\n132"
                    },
                    {
                        "username": "rookycipher",
                        "content": "I am only able to find 58 sub arrays for the following input {35054,398719,945315,945315,820417,945315,35054,945315,171832,945315,35054,109750,790964,441974,552913}. But the test case has 81 as the expected output and I am not able to understand, how?"
                    },
                    {
                        "username": "VigneshwarVG",
                        "content": "keep track of both mink and maxk  \\ni guess you might have not keep track of  values between the boundaries as greater than or equal to  mink and lesser or equal to maxk"
                    }
                ]
            },
            {
                "id": 1821309,
                "content": [
                    {
                        "username": "charonme",
                        "content": "for a \"hard\" problem the time constraints could be made more strict as I didn\\'t get TLE even though I didn\\'t use the queue optimization"
                    },
                    {
                        "username": "kumarnitesh88441",
                        "content": "I used two pointers but gives TLE?"
                    },
                    {
                        "username": "saurabh-huh",
                        "content": "It is a much hard problem than  I think"
                    },
                    {
                        "username": "cus_ved",
                        "content": " `your inline code...your inline code...`\\nlong long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n        int n=nums.size();\\n        int ind=-1;\\n        pair<int,int>p={-1,-1};\\n        long long int ans=0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]>=minK &&nums[i]<=maxK){\\n                if(ind==-1)\\n                ind=i;\\n            }\\n            else{\\n                ind=-1;\\n                p.first=-1;\\n                p.second=-1;\\n                continue;\\n            }\\n            if(nums[i]==minK){\\n                p.first=i;\\n            }\\n            if(nums[i]==maxK){\\n                p.second=i;\\n            }\\n            int ind1=min(p.first,p.second);\\n            int ind2=max(p.first,p.second);\\n            if(ind1!=-1 &&ind2!=-1){\\n                int l=ind1-ind;\\n                ans+=1LL*(l+1);\\n            }\\n\\n\\n        }\\n     without 1LL i am getting TLE...why?"
                    },
                    {
                        "username": "AhmadSaleh2001",
                        "content": "Hint : Don\\'t use vector in c++ because its very slow"
                    },
                    {
                        "username": "beardedone",
                        "content": "vectors in c++ aren\\'t slow.  Access to an element in a vector is the same as an array, if you use the [] operator or an iterator.  Resizing the vector takes some time, but you can reserve space in the vector before you start adding to it to avoid multiple memory allocations.  What alternative do you propose?  The nums parameter is expected to be a vector.\\n\\nAlso, this problem can be solved with a space complexity of O(1) space, so other than nums parameter, where does the vector or its alternative come in?"
                    },
                    {
                        "username": "Tensor08",
                        "content": "This problem should be marked as `BrainTeaser`, Good Question though."
                    },
                    {
                        "username": "Jack_knight",
                        "content": "We can have 2 segment trees one for giving max in range and other one for giving min in range then store indices of minK and maxK then find minimum and maximum between those indices if it follow the condition add it to the answer.\\nCan anyone help to implement it and clarify if this will work or not?"
                    },
                    {
                        "username": "harshitisback",
                        "content": "yup you can solve it by two priorityQueue but the problem is TLE "
                    },
                    {
                        "username": "VigneshwarVG",
                        "content": "hint :   keep track of the values that are less than the minK too \\n     it might help.."
                    },
                    {
                        "username": "VigneshwarVG",
                        "content": "i came across this test case : \\nit might help you to get a hint\\n[934372,927845,479424,49441,17167,17167,65553,927845,17167,927845,17167,425106,17167,927845,17167,927845,251338,17167]\\nminK =\\n17167\\nmaxK =\\n927845\\nUse Testcase\\nOutput\\n132"
                    },
                    {
                        "username": "rookycipher",
                        "content": "I am only able to find 58 sub arrays for the following input {35054,398719,945315,945315,820417,945315,35054,945315,171832,945315,35054,109750,790964,441974,552913}. But the test case has 81 as the expected output and I am not able to understand, how?"
                    },
                    {
                        "username": "VigneshwarVG",
                        "content": "keep track of both mink and maxk  \\ni guess you might have not keep track of  values between the boundaries as greater than or equal to  mink and lesser or equal to maxk"
                    }
                ]
            },
            {
                "id": 1821304,
                "content": [
                    {
                        "username": "charonme",
                        "content": "for a \"hard\" problem the time constraints could be made more strict as I didn\\'t get TLE even though I didn\\'t use the queue optimization"
                    },
                    {
                        "username": "kumarnitesh88441",
                        "content": "I used two pointers but gives TLE?"
                    },
                    {
                        "username": "saurabh-huh",
                        "content": "It is a much hard problem than  I think"
                    },
                    {
                        "username": "cus_ved",
                        "content": " `your inline code...your inline code...`\\nlong long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n        int n=nums.size();\\n        int ind=-1;\\n        pair<int,int>p={-1,-1};\\n        long long int ans=0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]>=minK &&nums[i]<=maxK){\\n                if(ind==-1)\\n                ind=i;\\n            }\\n            else{\\n                ind=-1;\\n                p.first=-1;\\n                p.second=-1;\\n                continue;\\n            }\\n            if(nums[i]==minK){\\n                p.first=i;\\n            }\\n            if(nums[i]==maxK){\\n                p.second=i;\\n            }\\n            int ind1=min(p.first,p.second);\\n            int ind2=max(p.first,p.second);\\n            if(ind1!=-1 &&ind2!=-1){\\n                int l=ind1-ind;\\n                ans+=1LL*(l+1);\\n            }\\n\\n\\n        }\\n     without 1LL i am getting TLE...why?"
                    },
                    {
                        "username": "AhmadSaleh2001",
                        "content": "Hint : Don\\'t use vector in c++ because its very slow"
                    },
                    {
                        "username": "beardedone",
                        "content": "vectors in c++ aren\\'t slow.  Access to an element in a vector is the same as an array, if you use the [] operator or an iterator.  Resizing the vector takes some time, but you can reserve space in the vector before you start adding to it to avoid multiple memory allocations.  What alternative do you propose?  The nums parameter is expected to be a vector.\\n\\nAlso, this problem can be solved with a space complexity of O(1) space, so other than nums parameter, where does the vector or its alternative come in?"
                    },
                    {
                        "username": "Tensor08",
                        "content": "This problem should be marked as `BrainTeaser`, Good Question though."
                    },
                    {
                        "username": "Jack_knight",
                        "content": "We can have 2 segment trees one for giving max in range and other one for giving min in range then store indices of minK and maxK then find minimum and maximum between those indices if it follow the condition add it to the answer.\\nCan anyone help to implement it and clarify if this will work or not?"
                    },
                    {
                        "username": "harshitisback",
                        "content": "yup you can solve it by two priorityQueue but the problem is TLE "
                    },
                    {
                        "username": "VigneshwarVG",
                        "content": "hint :   keep track of the values that are less than the minK too \\n     it might help.."
                    },
                    {
                        "username": "VigneshwarVG",
                        "content": "i came across this test case : \\nit might help you to get a hint\\n[934372,927845,479424,49441,17167,17167,65553,927845,17167,927845,17167,425106,17167,927845,17167,927845,251338,17167]\\nminK =\\n17167\\nmaxK =\\n927845\\nUse Testcase\\nOutput\\n132"
                    },
                    {
                        "username": "rookycipher",
                        "content": "I am only able to find 58 sub arrays for the following input {35054,398719,945315,945315,820417,945315,35054,945315,171832,945315,35054,109750,790964,441974,552913}. But the test case has 81 as the expected output and I am not able to understand, how?"
                    },
                    {
                        "username": "VigneshwarVG",
                        "content": "keep track of both mink and maxk  \\ni guess you might have not keep track of  values between the boundaries as greater than or equal to  mink and lesser or equal to maxk"
                    }
                ]
            },
            {
                "id": 1821287,
                "content": [
                    {
                        "username": "charonme",
                        "content": "for a \"hard\" problem the time constraints could be made more strict as I didn\\'t get TLE even though I didn\\'t use the queue optimization"
                    },
                    {
                        "username": "kumarnitesh88441",
                        "content": "I used two pointers but gives TLE?"
                    },
                    {
                        "username": "saurabh-huh",
                        "content": "It is a much hard problem than  I think"
                    },
                    {
                        "username": "cus_ved",
                        "content": " `your inline code...your inline code...`\\nlong long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n        int n=nums.size();\\n        int ind=-1;\\n        pair<int,int>p={-1,-1};\\n        long long int ans=0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]>=minK &&nums[i]<=maxK){\\n                if(ind==-1)\\n                ind=i;\\n            }\\n            else{\\n                ind=-1;\\n                p.first=-1;\\n                p.second=-1;\\n                continue;\\n            }\\n            if(nums[i]==minK){\\n                p.first=i;\\n            }\\n            if(nums[i]==maxK){\\n                p.second=i;\\n            }\\n            int ind1=min(p.first,p.second);\\n            int ind2=max(p.first,p.second);\\n            if(ind1!=-1 &&ind2!=-1){\\n                int l=ind1-ind;\\n                ans+=1LL*(l+1);\\n            }\\n\\n\\n        }\\n     without 1LL i am getting TLE...why?"
                    },
                    {
                        "username": "AhmadSaleh2001",
                        "content": "Hint : Don\\'t use vector in c++ because its very slow"
                    },
                    {
                        "username": "beardedone",
                        "content": "vectors in c++ aren\\'t slow.  Access to an element in a vector is the same as an array, if you use the [] operator or an iterator.  Resizing the vector takes some time, but you can reserve space in the vector before you start adding to it to avoid multiple memory allocations.  What alternative do you propose?  The nums parameter is expected to be a vector.\\n\\nAlso, this problem can be solved with a space complexity of O(1) space, so other than nums parameter, where does the vector or its alternative come in?"
                    },
                    {
                        "username": "Tensor08",
                        "content": "This problem should be marked as `BrainTeaser`, Good Question though."
                    },
                    {
                        "username": "Jack_knight",
                        "content": "We can have 2 segment trees one for giving max in range and other one for giving min in range then store indices of minK and maxK then find minimum and maximum between those indices if it follow the condition add it to the answer.\\nCan anyone help to implement it and clarify if this will work or not?"
                    },
                    {
                        "username": "harshitisback",
                        "content": "yup you can solve it by two priorityQueue but the problem is TLE "
                    },
                    {
                        "username": "VigneshwarVG",
                        "content": "hint :   keep track of the values that are less than the minK too \\n     it might help.."
                    },
                    {
                        "username": "VigneshwarVG",
                        "content": "i came across this test case : \\nit might help you to get a hint\\n[934372,927845,479424,49441,17167,17167,65553,927845,17167,927845,17167,425106,17167,927845,17167,927845,251338,17167]\\nminK =\\n17167\\nmaxK =\\n927845\\nUse Testcase\\nOutput\\n132"
                    },
                    {
                        "username": "rookycipher",
                        "content": "I am only able to find 58 sub arrays for the following input {35054,398719,945315,945315,820417,945315,35054,945315,171832,945315,35054,109750,790964,441974,552913}. But the test case has 81 as the expected output and I am not able to understand, how?"
                    },
                    {
                        "username": "VigneshwarVG",
                        "content": "keep track of both mink and maxk  \\ni guess you might have not keep track of  values between the boundaries as greater than or equal to  mink and lesser or equal to maxk"
                    }
                ]
            },
            {
                "id": 1821138,
                "content": [
                    {
                        "username": "charonme",
                        "content": "for a \"hard\" problem the time constraints could be made more strict as I didn\\'t get TLE even though I didn\\'t use the queue optimization"
                    },
                    {
                        "username": "kumarnitesh88441",
                        "content": "I used two pointers but gives TLE?"
                    },
                    {
                        "username": "saurabh-huh",
                        "content": "It is a much hard problem than  I think"
                    },
                    {
                        "username": "cus_ved",
                        "content": " `your inline code...your inline code...`\\nlong long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n        int n=nums.size();\\n        int ind=-1;\\n        pair<int,int>p={-1,-1};\\n        long long int ans=0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]>=minK &&nums[i]<=maxK){\\n                if(ind==-1)\\n                ind=i;\\n            }\\n            else{\\n                ind=-1;\\n                p.first=-1;\\n                p.second=-1;\\n                continue;\\n            }\\n            if(nums[i]==minK){\\n                p.first=i;\\n            }\\n            if(nums[i]==maxK){\\n                p.second=i;\\n            }\\n            int ind1=min(p.first,p.second);\\n            int ind2=max(p.first,p.second);\\n            if(ind1!=-1 &&ind2!=-1){\\n                int l=ind1-ind;\\n                ans+=1LL*(l+1);\\n            }\\n\\n\\n        }\\n     without 1LL i am getting TLE...why?"
                    },
                    {
                        "username": "AhmadSaleh2001",
                        "content": "Hint : Don\\'t use vector in c++ because its very slow"
                    },
                    {
                        "username": "beardedone",
                        "content": "vectors in c++ aren\\'t slow.  Access to an element in a vector is the same as an array, if you use the [] operator or an iterator.  Resizing the vector takes some time, but you can reserve space in the vector before you start adding to it to avoid multiple memory allocations.  What alternative do you propose?  The nums parameter is expected to be a vector.\\n\\nAlso, this problem can be solved with a space complexity of O(1) space, so other than nums parameter, where does the vector or its alternative come in?"
                    },
                    {
                        "username": "Tensor08",
                        "content": "This problem should be marked as `BrainTeaser`, Good Question though."
                    },
                    {
                        "username": "Jack_knight",
                        "content": "We can have 2 segment trees one for giving max in range and other one for giving min in range then store indices of minK and maxK then find minimum and maximum between those indices if it follow the condition add it to the answer.\\nCan anyone help to implement it and clarify if this will work or not?"
                    },
                    {
                        "username": "harshitisback",
                        "content": "yup you can solve it by two priorityQueue but the problem is TLE "
                    },
                    {
                        "username": "VigneshwarVG",
                        "content": "hint :   keep track of the values that are less than the minK too \\n     it might help.."
                    },
                    {
                        "username": "VigneshwarVG",
                        "content": "i came across this test case : \\nit might help you to get a hint\\n[934372,927845,479424,49441,17167,17167,65553,927845,17167,927845,17167,425106,17167,927845,17167,927845,251338,17167]\\nminK =\\n17167\\nmaxK =\\n927845\\nUse Testcase\\nOutput\\n132"
                    },
                    {
                        "username": "rookycipher",
                        "content": "I am only able to find 58 sub arrays for the following input {35054,398719,945315,945315,820417,945315,35054,945315,171832,945315,35054,109750,790964,441974,552913}. But the test case has 81 as the expected output and I am not able to understand, how?"
                    },
                    {
                        "username": "VigneshwarVG",
                        "content": "keep track of both mink and maxk  \\ni guess you might have not keep track of  values between the boundaries as greater than or equal to  mink and lesser or equal to maxk"
                    }
                ]
            },
            {
                "id": 1821123,
                "content": [
                    {
                        "username": "charonme",
                        "content": "for a \"hard\" problem the time constraints could be made more strict as I didn\\'t get TLE even though I didn\\'t use the queue optimization"
                    },
                    {
                        "username": "kumarnitesh88441",
                        "content": "I used two pointers but gives TLE?"
                    },
                    {
                        "username": "saurabh-huh",
                        "content": "It is a much hard problem than  I think"
                    },
                    {
                        "username": "cus_ved",
                        "content": " `your inline code...your inline code...`\\nlong long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n        int n=nums.size();\\n        int ind=-1;\\n        pair<int,int>p={-1,-1};\\n        long long int ans=0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]>=minK &&nums[i]<=maxK){\\n                if(ind==-1)\\n                ind=i;\\n            }\\n            else{\\n                ind=-1;\\n                p.first=-1;\\n                p.second=-1;\\n                continue;\\n            }\\n            if(nums[i]==minK){\\n                p.first=i;\\n            }\\n            if(nums[i]==maxK){\\n                p.second=i;\\n            }\\n            int ind1=min(p.first,p.second);\\n            int ind2=max(p.first,p.second);\\n            if(ind1!=-1 &&ind2!=-1){\\n                int l=ind1-ind;\\n                ans+=1LL*(l+1);\\n            }\\n\\n\\n        }\\n     without 1LL i am getting TLE...why?"
                    },
                    {
                        "username": "AhmadSaleh2001",
                        "content": "Hint : Don\\'t use vector in c++ because its very slow"
                    },
                    {
                        "username": "beardedone",
                        "content": "vectors in c++ aren\\'t slow.  Access to an element in a vector is the same as an array, if you use the [] operator or an iterator.  Resizing the vector takes some time, but you can reserve space in the vector before you start adding to it to avoid multiple memory allocations.  What alternative do you propose?  The nums parameter is expected to be a vector.\\n\\nAlso, this problem can be solved with a space complexity of O(1) space, so other than nums parameter, where does the vector or its alternative come in?"
                    },
                    {
                        "username": "Tensor08",
                        "content": "This problem should be marked as `BrainTeaser`, Good Question though."
                    },
                    {
                        "username": "Jack_knight",
                        "content": "We can have 2 segment trees one for giving max in range and other one for giving min in range then store indices of minK and maxK then find minimum and maximum between those indices if it follow the condition add it to the answer.\\nCan anyone help to implement it and clarify if this will work or not?"
                    },
                    {
                        "username": "harshitisback",
                        "content": "yup you can solve it by two priorityQueue but the problem is TLE "
                    },
                    {
                        "username": "VigneshwarVG",
                        "content": "hint :   keep track of the values that are less than the minK too \\n     it might help.."
                    },
                    {
                        "username": "VigneshwarVG",
                        "content": "i came across this test case : \\nit might help you to get a hint\\n[934372,927845,479424,49441,17167,17167,65553,927845,17167,927845,17167,425106,17167,927845,17167,927845,251338,17167]\\nminK =\\n17167\\nmaxK =\\n927845\\nUse Testcase\\nOutput\\n132"
                    },
                    {
                        "username": "rookycipher",
                        "content": "I am only able to find 58 sub arrays for the following input {35054,398719,945315,945315,820417,945315,35054,945315,171832,945315,35054,109750,790964,441974,552913}. But the test case has 81 as the expected output and I am not able to understand, how?"
                    },
                    {
                        "username": "VigneshwarVG",
                        "content": "keep track of both mink and maxk  \\ni guess you might have not keep track of  values between the boundaries as greater than or equal to  mink and lesser or equal to maxk"
                    }
                ]
            },
            {
                "id": 1821101,
                "content": [
                    {
                        "username": "charonme",
                        "content": "for a \"hard\" problem the time constraints could be made more strict as I didn\\'t get TLE even though I didn\\'t use the queue optimization"
                    },
                    {
                        "username": "kumarnitesh88441",
                        "content": "I used two pointers but gives TLE?"
                    },
                    {
                        "username": "saurabh-huh",
                        "content": "It is a much hard problem than  I think"
                    },
                    {
                        "username": "cus_ved",
                        "content": " `your inline code...your inline code...`\\nlong long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n        int n=nums.size();\\n        int ind=-1;\\n        pair<int,int>p={-1,-1};\\n        long long int ans=0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]>=minK &&nums[i]<=maxK){\\n                if(ind==-1)\\n                ind=i;\\n            }\\n            else{\\n                ind=-1;\\n                p.first=-1;\\n                p.second=-1;\\n                continue;\\n            }\\n            if(nums[i]==minK){\\n                p.first=i;\\n            }\\n            if(nums[i]==maxK){\\n                p.second=i;\\n            }\\n            int ind1=min(p.first,p.second);\\n            int ind2=max(p.first,p.second);\\n            if(ind1!=-1 &&ind2!=-1){\\n                int l=ind1-ind;\\n                ans+=1LL*(l+1);\\n            }\\n\\n\\n        }\\n     without 1LL i am getting TLE...why?"
                    },
                    {
                        "username": "AhmadSaleh2001",
                        "content": "Hint : Don\\'t use vector in c++ because its very slow"
                    },
                    {
                        "username": "beardedone",
                        "content": "vectors in c++ aren\\'t slow.  Access to an element in a vector is the same as an array, if you use the [] operator or an iterator.  Resizing the vector takes some time, but you can reserve space in the vector before you start adding to it to avoid multiple memory allocations.  What alternative do you propose?  The nums parameter is expected to be a vector.\\n\\nAlso, this problem can be solved with a space complexity of O(1) space, so other than nums parameter, where does the vector or its alternative come in?"
                    },
                    {
                        "username": "Tensor08",
                        "content": "This problem should be marked as `BrainTeaser`, Good Question though."
                    },
                    {
                        "username": "Jack_knight",
                        "content": "We can have 2 segment trees one for giving max in range and other one for giving min in range then store indices of minK and maxK then find minimum and maximum between those indices if it follow the condition add it to the answer.\\nCan anyone help to implement it and clarify if this will work or not?"
                    },
                    {
                        "username": "harshitisback",
                        "content": "yup you can solve it by two priorityQueue but the problem is TLE "
                    },
                    {
                        "username": "VigneshwarVG",
                        "content": "hint :   keep track of the values that are less than the minK too \\n     it might help.."
                    },
                    {
                        "username": "VigneshwarVG",
                        "content": "i came across this test case : \\nit might help you to get a hint\\n[934372,927845,479424,49441,17167,17167,65553,927845,17167,927845,17167,425106,17167,927845,17167,927845,251338,17167]\\nminK =\\n17167\\nmaxK =\\n927845\\nUse Testcase\\nOutput\\n132"
                    },
                    {
                        "username": "rookycipher",
                        "content": "I am only able to find 58 sub arrays for the following input {35054,398719,945315,945315,820417,945315,35054,945315,171832,945315,35054,109750,790964,441974,552913}. But the test case has 81 as the expected output and I am not able to understand, how?"
                    },
                    {
                        "username": "VigneshwarVG",
                        "content": "keep track of both mink and maxk  \\ni guess you might have not keep track of  values between the boundaries as greater than or equal to  mink and lesser or equal to maxk"
                    }
                ]
            },
            {
                "id": 1821085,
                "content": [
                    {
                        "username": "charonme",
                        "content": "for a \"hard\" problem the time constraints could be made more strict as I didn\\'t get TLE even though I didn\\'t use the queue optimization"
                    },
                    {
                        "username": "kumarnitesh88441",
                        "content": "I used two pointers but gives TLE?"
                    },
                    {
                        "username": "saurabh-huh",
                        "content": "It is a much hard problem than  I think"
                    },
                    {
                        "username": "cus_ved",
                        "content": " `your inline code...your inline code...`\\nlong long countSubarrays(vector<int>& nums, int minK, int maxK) {\\n        int n=nums.size();\\n        int ind=-1;\\n        pair<int,int>p={-1,-1};\\n        long long int ans=0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]>=minK &&nums[i]<=maxK){\\n                if(ind==-1)\\n                ind=i;\\n            }\\n            else{\\n                ind=-1;\\n                p.first=-1;\\n                p.second=-1;\\n                continue;\\n            }\\n            if(nums[i]==minK){\\n                p.first=i;\\n            }\\n            if(nums[i]==maxK){\\n                p.second=i;\\n            }\\n            int ind1=min(p.first,p.second);\\n            int ind2=max(p.first,p.second);\\n            if(ind1!=-1 &&ind2!=-1){\\n                int l=ind1-ind;\\n                ans+=1LL*(l+1);\\n            }\\n\\n\\n        }\\n     without 1LL i am getting TLE...why?"
                    },
                    {
                        "username": "AhmadSaleh2001",
                        "content": "Hint : Don\\'t use vector in c++ because its very slow"
                    },
                    {
                        "username": "beardedone",
                        "content": "vectors in c++ aren\\'t slow.  Access to an element in a vector is the same as an array, if you use the [] operator or an iterator.  Resizing the vector takes some time, but you can reserve space in the vector before you start adding to it to avoid multiple memory allocations.  What alternative do you propose?  The nums parameter is expected to be a vector.\\n\\nAlso, this problem can be solved with a space complexity of O(1) space, so other than nums parameter, where does the vector or its alternative come in?"
                    },
                    {
                        "username": "Tensor08",
                        "content": "This problem should be marked as `BrainTeaser`, Good Question though."
                    },
                    {
                        "username": "Jack_knight",
                        "content": "We can have 2 segment trees one for giving max in range and other one for giving min in range then store indices of minK and maxK then find minimum and maximum between those indices if it follow the condition add it to the answer.\\nCan anyone help to implement it and clarify if this will work or not?"
                    },
                    {
                        "username": "harshitisback",
                        "content": "yup you can solve it by two priorityQueue but the problem is TLE "
                    },
                    {
                        "username": "VigneshwarVG",
                        "content": "hint :   keep track of the values that are less than the minK too \\n     it might help.."
                    },
                    {
                        "username": "VigneshwarVG",
                        "content": "i came across this test case : \\nit might help you to get a hint\\n[934372,927845,479424,49441,17167,17167,65553,927845,17167,927845,17167,425106,17167,927845,17167,927845,251338,17167]\\nminK =\\n17167\\nmaxK =\\n927845\\nUse Testcase\\nOutput\\n132"
                    },
                    {
                        "username": "rookycipher",
                        "content": "I am only able to find 58 sub arrays for the following input {35054,398719,945315,945315,820417,945315,35054,945315,171832,945315,35054,109750,790964,441974,552913}. But the test case has 81 as the expected output and I am not able to understand, how?"
                    },
                    {
                        "username": "VigneshwarVG",
                        "content": "keep track of both mink and maxk  \\ni guess you might have not keep track of  values between the boundaries as greater than or equal to  mink and lesser or equal to maxk"
                    }
                ]
            }
        ]
    }
]