[
    {
        "title": "Increment Submatrices by One",
        "question_content": "You are given a positive integer n, indicating that we initially have an n x n&nbsp;0-indexed integer matrix mat filled with zeroes.\nYou are also given a 2D integer array query. For each query[i] = [row1i, col1i, row2i, col2i], you should do the following operation:\n\n\tAdd 1 to every element in the submatrix with the top left corner (row1i, col1i) and the bottom right corner (row2i, col2i). That is, add 1 to mat[x][y] for all row1i <= x <= row2i and col1i <= y <= col2i.\n\nReturn the matrix mat after performing every query.\n&nbsp;\nExample 1:\n\nInput: n = 3, queries = [[1,1,2,2],[0,0,1,1]]\nOutput: [[1,1,0],[1,2,1],[0,1,1]]\nExplanation: The diagram above shows the initial matrix, the matrix after the first query, and the matrix after the second query.\n- In the first query, we add 1 to every element in the submatrix with the top left corner (1, 1) and bottom right corner (2, 2).\n- In the second query, we add 1 to every element in the submatrix with the top left corner (0, 0) and bottom right corner (1, 1).\n\nExample 2:\n\nInput: n = 2, queries = [[0,0,1,1]]\nOutput: [[1,1],[1,1]]\nExplanation: The diagram above shows the initial matrix and the matrix after the first query.\n- In the first query we add 1 to every element in the matrix.\n\n&nbsp;\nConstraints:\n\n\t1 <= n <= 500\n\t1 <= queries.length <= 104\n\t0 <= row1i <= row2i < n\n\t0 <= col1i <= col2i < n",
        "solutions": [
            {
                "id": 3052675,
                "title": "python3-sweep-line-range-addition-w-visualization-clean-concise",
                "content": "# Na\\xEFve Approach\\nFollowing the description of this problem, for each query, we update the every element covered in the submatrix defined by `(r1, c1)` and `(r2, c2)`. However, it is pretty clear to know that the time complexity for this approach is $$O(n^2q)$$, which could be up to $$500 \\\\times 500 \\\\times 10^4 = 2.5 \\\\times 10^9$$ and result in TLE.\\n\\nSo, how can we come up with a better algorithm with improved time complexity?\\n\\n# Intuition\\nThis problem is the 2-D version of [LC 370. Range Addition](https://leetcode.com/problems/range-addition/). Essentially, we are doing range addition for each query.\\n\\n# Visualization\\nConsider the 1-D Range Addition problem and suppose we have `n = 5` and `queries = [[1,3],[2,4],[0,2]]`. Below is the visual illustration on the technique of `Range Caching`.\\n\\n![LC2536.jpeg](https://assets.leetcode.com/users/images/2db6189c-c45b-4246-b23b-3b679d40d82a_1673763280.9586592.jpeg)\\n\\n\\n# Approach\\nFor each query, denoted as `(r1, c1, r2, c2)`, we perform a preprocessing (range caching) on each row involved. Specifically, for each row within `[r1, r2]`, we add 1 at column `c1` and subtract 1 at the next column of `c2`.\\n\\nAfter preprocessing, we calculate the output by performing range addition (sweeping line) on all elements of the matrix, and output the answer.\\n\\n# Complexity\\n- Time complexity: $$O(n^2 + nq) \\\\approx O(nq)$$, if $$q \\\\gg n$$;\\n\\n- Space complexity: $$O(1)$$, if not including the $$O(n^2)$$ space for output.\\n\\n**Please upvote if you find this solution helpful. Thanks!**\\n\\n# Solution (Range Caching)\\n```\\nclass Solution:\\n    def rangeAddQueries(self, n: int, queries: List[List[int]]) -> List[List[int]]:\\n        ans = [[0] * n for _ in range(n)]\\n        for r1, c1, r2, c2 in queries:\\n            for r in range(r1, r2 + 1):\\n                ans[r][c1] += 1\\n                if c2 + 1 < n: ans[r][c2 + 1] -= 1\\n        for r in range(n):\\n            for c in range(1, n):\\n                ans[r][c] += ans[r][c - 1]\\n        return ans\\n```\\n\\n# Follow-up (Bonus)\\nNow we know the concept of range caching technique to solve this problem, is there a even better solution to further improve the overall time complexity?\\n\\nThe answer is **yes** and the idea is straightforward as visualized below:\\n\\n![LC2536_2.jpeg](https://assets.leetcode.com/users/images/34c20906-9a2e-44cc-a92e-3a21f92aa688_1673806434.9392116.jpeg)\\n\\n\\nIn brief, we can directly use 2-D range caching (previously we were using 1-D range caching in this 2-D problem). The difference here is that for each query, we now need to (1) cache the value at 4 cells (instead of 2 cells at each row); and (2) calculate the output by going through the full matrix twice, one by row and one by column (instead of once).\\n\\n- Time complexity: $$O(n^2 + q)$$, which is better than the solution above;\\n\\n- Space complexity: $$O(1)$$, if not including the $$O(n^2)$$ space for output.\\n\\n**Remark:** Personally, I feel that 2-D range caching is bit trickier to digest, but using 1-D range caching applied to this problem would be sufficient and easier to think & code.\\n\\n# Improved Solution (2-D Range Caching)\\n```\\nclass Solution:\\n    def rangeAddQueries(self, n: int, queries: List[List[int]]) -> List[List[int]]:\\n        ans = [[0] * n for _ in range(n)]\\n        for r1, c1, r2, c2 in queries:\\n            ans[r1][c1] += 1\\n            if r2 + 1 < n: ans[r2 + 1][c1] -= 1\\n            if c2 + 1 < n: ans[r1][c2 + 1] -= 1\\n            if r2 + 1 < n and c2 + 1 < n: ans[r2 + 1][c2 + 1] += 1\\n        for r in range(1, n):\\n            for c in range(n):\\n                ans[r][c] += ans[r - 1][c]\\n        for r in range(n):\\n            for c in range(1, n):\\n                ans[r][c] += ans[r][c - 1]\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rangeAddQueries(self, n: int, queries: List[List[int]]) -> List[List[int]]:\\n        ans = [[0] * n for _ in range(n)]\\n        for r1, c1, r2, c2 in queries:\\n            for r in range(r1, r2 + 1):\\n                ans[r][c1] += 1\\n                if c2 + 1 < n: ans[r][c2 + 1] -= 1\\n        for r in range(n):\\n            for c in range(1, n):\\n                ans[r][c] += ans[r][c - 1]\\n        return ans\\n```\n```\\nclass Solution:\\n    def rangeAddQueries(self, n: int, queries: List[List[int]]) -> List[List[int]]:\\n        ans = [[0] * n for _ in range(n)]\\n        for r1, c1, r2, c2 in queries:\\n            ans[r1][c1] += 1\\n            if r2 + 1 < n: ans[r2 + 1][c1] -= 1\\n            if c2 + 1 < n: ans[r1][c2 + 1] -= 1\\n            if r2 + 1 < n and c2 + 1 < n: ans[r2 + 1][c2 + 1] += 1\\n        for r in range(1, n):\\n            for c in range(n):\\n                ans[r][c] += ans[r - 1][c]\\n        for r in range(n):\\n            for c in range(1, n):\\n                ans[r][c] += ans[r][c - 1]\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3052719,
                "title": "prefix-sum-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n        vector<vector<int>> mat(n, vector<int>(n, 0));\\n        \\n        for (auto q : queries) {\\n            int r1 = q[0], c1 = q[1], r2 = q[2], c2 = q[3];\\n            \\n            mat[r1][c1] += 1;\\n            if(r2 + 1 < n && c2 + 1 < n) mat[r2 + 1][c2 + 1] += 1;\\n            if(r2 + 1< n) mat[r2 + 1][c1] -= 1;\\n            if(c2 + 1 < n) mat[r1][c2 + 1] -= 1;\\n        }\\n        \\n        for(int i=0; i<n; i++) {\\n            for (int j=1; j<n; j++) {\\n                mat[i][j] += mat[i][j - 1];\\n            }\\n        }\\n        for(int i=1; i<n; i++) {\\n            for (int j=0; j<n; j++) {\\n                mat[i][j] += mat[i - 1][j];\\n            }\\n        }\\n        return mat;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n        vector<vector<int>> mat(n, vector<int>(n, 0));\\n        \\n        for (auto q : queries) {\\n            int r1 = q[0], c1 = q[1], r2 = q[2], c2 = q[3];\\n            \\n            mat[r1][c1] += 1;\\n            if(r2 + 1 < n && c2 + 1 < n) mat[r2 + 1][c2 + 1] += 1;\\n            if(r2 + 1< n) mat[r2 + 1][c1] -= 1;\\n            if(c2 + 1 < n) mat[r1][c2 + 1] -= 1;\\n        }\\n        \\n        for(int i=0; i<n; i++) {\\n            for (int j=1; j<n; j++) {\\n                mat[i][j] += mat[i][j - 1];\\n            }\\n        }\\n        for(int i=1; i<n; i++) {\\n            for (int j=0; j<n; j++) {\\n                mat[i][j] += mat[i - 1][j];\\n            }\\n        }\\n        return mat;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3053405,
                "title": "easy-to-understand-prefix-sum-with-explanation-not-brute-force-c-solution",
                "content": "# hint \\n1) try to solve using some pre computation, like some variation in prefix sum. \\n\\n        \\n\\n# Complexity\\n- Time complexity: $$O(queries.size()*n + n*n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n*n)$$ (for storing answer)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n        \\n\\n/*\\napproach-\\n    let n = 3, queries = [[1,1,2,2],[0,0,1,1]]\\n\\n    make a ans array of size n*(n+1)\\n    ans = 0 0 0 0\\n          0 0 0 0\\n          0 0 0 0\\n    for every query :\\n        make all row from x1 to x2 \\n            ans[i][y1]++; ans[i][y2+1]--;\\n    \\n    after first iteration:\\n    ans = 0 0 0 0\\n          0 1 0 -1\\n          0 1 0 -1\\n    after second iteration:\\n    ans = 1 0 -1 0\\n          1 1 -1 -1\\n          0 1 0  -1\\n    why ans[i][y1]++ and ans[i][y2+1]-- ??\\n        -> (i,y1) indicates that this perticular query contribute 1 from this index so we add 1 in ans.\\n        -> (i,y2+1) indicates that this perticular query no longer contributes any 1 so we subtract 1 in ans.\\n\\n\\n    now calculate prefix sum of every row;\\n    ans = 1 1 0 0\\n          1 2 1 0\\n          0 1 1 0\\n    delete the last column.\\n    return ans;\\n*/\\n\\n        vector<int>row1,row2;\\n        vector<int>fir(n+1,0),sec(n+1,0);\\n        vector<vector<int>>ans(n,vector<int>(n+1,0));\\n        \\n        for(auto x : queries){\\n            int x1 = x[0], x2 = x[2];\\n            int y1 = x[1], y2 = x[3];\\n            \\n            for(int i = x1; i<=x2; i++){\\n                ans[i][y1] +=1;\\n                ans[i][y2+1] -=1;\\n            }\\n        }\\n        \\n        for(int i = 0; i<n; i++){\\n            for(int j = 0; j<n; j++){\\n                if(j>0) ans[i][j] = ans[i][j]+ans[i][j-1];\\n            }\\n        }\\n        for(int i = 0; i<n; i++) ans[i].pop_back();\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Matrix",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n        \\n\\n/*\\napproach-\\n    let n = 3, queries = [[1,1,2,2],[0,0,1,1]]\\n\\n    make a ans array of size n*(n+1)\\n    ans = 0 0 0 0\\n          0 0 0 0\\n          0 0 0 0\\n    for every query :\\n        make all row from x1 to x2 \\n            ans[i][y1]++; ans[i][y2+1]--;\\n    \\n    after first iteration:\\n    ans = 0 0 0 0\\n          0 1 0 -1\\n          0 1 0 -1\\n    after second iteration:\\n    ans = 1 0 -1 0\\n          1 1 -1 -1\\n          0 1 0  -1\\n    why ans[i][y1]++ and ans[i][y2+1]-- ??\\n        -> (i,y1) indicates that this perticular query contribute 1 from this index so we add 1 in ans.\\n        -> (i,y2+1) indicates that this perticular query no longer contributes any 1 so we subtract 1 in ans.\\n\\n\\n    now calculate prefix sum of every row;\\n    ans = 1 1 0 0\\n          1 2 1 0\\n          0 1 1 0\\n    delete the last column.\\n    return ans;\\n*/\\n\\n        vector<int>row1,row2;\\n        vector<int>fir(n+1,0),sec(n+1,0);\\n        vector<vector<int>>ans(n,vector<int>(n+1,0));\\n        \\n        for(auto x : queries){\\n            int x1 = x[0], x2 = x[2];\\n            int y1 = x[1], y2 = x[3];\\n            \\n            for(int i = x1; i<=x2; i++){\\n                ans[i][y1] +=1;\\n                ans[i][y2+1] -=1;\\n            }\\n        }\\n        \\n        for(int i = 0; i<n; i++){\\n            for(int j = 0; j<n; j++){\\n                if(j>0) ans[i][j] = ans[i][j]+ans[i][j-1];\\n            }\\n        }\\n        for(int i = 0; i<n; i++) ans[i].pop_back();\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3177915,
                "title": "area-sweep",
                "content": "As a refresher, a line sweep is a technique when, instead of adding value to each element, we:\\n- Add value at the start of the segment,\\n- Subtract that value after the end of the segment. \\n\\nAfter processing all queries, we use a prefix sum to aggregate all queries in a single \"sweep\".\\n\\nBased on the problem contraints, a line sweep solution is accepted.\\n\\n2D area sweep is more complicated, but signifficantly faster: O(m + n * n) vs. O(m * n + n * n)).\\n\\nIt\\'s useful to place these sulutions side-by-side to highlight the difference.\\n\\n## 1D Sweep\\n\\n![image](https://assets.leetcode.com/users/images/539a8cbc-8fdd-4485-bece-26e473c1d54b_1676248344.1043003.png)\\n\\n**C++**\\n```cpp\\nvector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n    vector<vector<int>> res(n, vector<int>(n));\\n    for (auto q : queries)\\n        for (int i = q[0]; i <= q[2]; ++i) {\\n            res[i][q[1]] += 1;\\n            if (q[3] + 1 < n)\\n                res[i][q[3] + 1] -= 1;\\n        }\\n    for (int i = 0; i < n; ++i)\\n        partial_sum(begin(res[i]), end(res[i]), begin(res[i]));\\n    return res;\\n}\\n```\\n\\n## 2D Sweep\\nFor the area sweep, we:\\n- Add value to `[r1][c1]`.\\n- Subtract that value from `[r1][c2 + 1]`,\\n- Subtract that value from `[r2 + 1][c1]`,\\n- Add that value again to `[r2 + 1][c2 + 1]`.\\n\\nNote that we do prefix sum independently for each dimension, so that we do not double-count.\\n\\n![image](https://assets.leetcode.com/users/images/2a2516ed-54bd-4f7f-9296-9ccea788c761_1676248400.5119631.png)\\n\\n**C++**\\n```cpp\\nvector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n    vector<vector<int>> res(n, vector<int>(n));\\n    for (auto q : queries) {\\n            int r1 = q[0], c1 = q[1], r2 = q[2], c2 = q[3];\\n            ++res[r1][c1];\\n            if (r2 + 1 < n)\\n                --res[r2 + 1][c1];\\n            if (c2 + 1 < n)\\n                --res[r1][c2 + 1];\\n            if (max(r2, c2) + 1 < n)\\n                ++res[r2 + 1][c2 + 1];\\n    }\\n    for (int i = 0; i < n; ++i)\\n        partial_sum(begin(res[i]), end(res[i]), begin(res[i]));  \\n    for (int i = 1; i < n; ++i)\\n        for (int j = 0; j < n; ++j)\\n            res[i][j] += res[i - 1][j];         \\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nvector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n    vector<vector<int>> res(n, vector<int>(n));\\n    for (auto q : queries)\\n        for (int i = q[0]; i <= q[2]; ++i) {\\n            res[i][q[1]] += 1;\\n            if (q[3] + 1 < n)\\n                res[i][q[3] + 1] -= 1;\\n        }\\n    for (int i = 0; i < n; ++i)\\n        partial_sum(begin(res[i]), end(res[i]), begin(res[i]));\\n    return res;\\n}\\n```\n```cpp\\nvector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n    vector<vector<int>> res(n, vector<int>(n));\\n    for (auto q : queries) {\\n            int r1 = q[0], c1 = q[1], r2 = q[2], c2 = q[3];\\n            ++res[r1][c1];\\n            if (r2 + 1 < n)\\n                --res[r2 + 1][c1];\\n            if (c2 + 1 < n)\\n                --res[r1][c2 + 1];\\n            if (max(r2, c2) + 1 < n)\\n                ++res[r2 + 1][c2 + 1];\\n    }\\n    for (int i = 0; i < n; ++i)\\n        partial_sum(begin(res[i]), end(res[i]), begin(res[i]));  \\n    for (int i = 1; i < n; ++i)\\n        for (int j = 0; j < n; ++j)\\n            res[i][j] += res[i - 1][j];         \\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3052741,
                "title": "easy-python-solution-numpy",
                "content": "# Code\\n```\\nimport numpy as np\\nclass Solution:\\n    def rangeAddQueries(self, n: int, queries: List[List[int]]) -> List[List[int]]:\\n        mat = [[0 for _ in range(n)] for _ in range(n)]\\n        mat = np.array(mat)\\n        for vals in queries:\\n           x1, x2, y1, y2 = vals[0], vals[1], vals[2], vals[3]\\n           mat[x1:y1+1, x2:y2+1] += 1\\n        return mat\\n```\\nDo upvote if you like the solution :)",
                "solutionTags": [
                    "Python3",
                    "Matrix"
                ],
                "code": "```\\nimport numpy as np\\nclass Solution:\\n    def rangeAddQueries(self, n: int, queries: List[List[int]]) -> List[List[int]]:\\n        mat = [[0 for _ in range(n)] for _ in range(n)]\\n        mat = np.array(mat)\\n        for vals in queries:\\n           x1, x2, y1, y2 = vals[0], vals[1], vals[2], vals[3]\\n           mat[x1:y1+1, x2:y2+1] += 1\\n        return mat\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3053724,
                "title": "c-ac-difference-array-for-2d-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe need to calculate the changes after performing the queries . A brute force solution will be traversing the 2D vector for each query and updating the matrix for the given range of query . But this repeated work can be avoided by calculating the amount of increment for each cell.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI will try to mark each row in such a way that it will signify the range in which changes can be done\\n\\nFor ex --  We are given an array of size 4 \\n0 0 0 0\\n\\nquery 1 --- increase the array range 1 to 3 by 1.\\n\\n0 1 1 1 \\n\\nquery 2 --- increase the array range  2 to 3 by 1\\n\\n0 1 2 2\\n\\nBut it will take so much time to update again and again. It will not be sufficient to get **AC**\\n\\nSo instead of updating each time , Lets mark range start as +1 and end+1 as -1. \\n\\nTake an array of n+1 size to avoid out of bound error\\n0 0 0 0 0\\n\\nafter query 1 (increase 1 to 3) i.e increase  index 1 by 1 and decrease  index 3+1 => 4 by 1\\n\\n0 1 0 0 -1 \\n\\nafter query 2 (increase 2 to 3) i.e increase  index 2 by 1 and decrease 1 index 3+1=>4 by 1\\n\\n0 1 1 0 -2 \\n\\nNow generate the **prefix sum** of our difference array.\\n\\n0 1 2 2 0\\n\\nClearly the result of both approaches  are same but in this method we have done **query updation in constant time** and at last prefix sum takes linear time which is better than traversing the array again and again.\\n\\nThis same concept of difference array we can use for 2D array just traverse rows \\nfor( row -- start to row -- end)\\n{\\n      // do same as above inside the loop for each row\\n}  \\n\\nAt last generate the answer 2D array by taking prefix sum of each row.Below is given the code\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n        \\n        vector<vector<int>>ans(n,vector<int>(n,0));\\n\\n        // row size n column size n+1\\n        vector<vector<int>>diff(n,vector<int>(n+1,0));\\n        // I will use the concept of difference array for row \\n\\n        // i will take the row wise prefix sum of the difference array and assign it back to our ans 2d array \\n\\n        for(int i = 0 ; i < queries.size() ; i++)\\n        {\\n            // for every row \\n            // increase the \\n            // start by 1 and decrease the end+1 by 1\\n            \\n\\n             int rstart = queries[i][0];\\n             int cstart = queries[i][1];\\n             int rend   = queries[i][2];\\n             int cend   = queries[i][3];\\n\\n             for( int j = rstart ; j <= rend ; j++)\\n             {\\n                  diff[j][cstart]+=1;\\n                  diff[j][cend+1]-=1;\\n             } \\n\\n        }\\n        \\n        // now take prefix sum of every row of difference matrix\\n\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            for(int j = 0 ; j < n ;j++)\\n            {\\n                 if(j > 0)\\n                 {\\n                     diff[i][j]+=diff[i][j-1];\\n                 }\\n\\n                 // assign the value at each cell after calculating   the prefix sum till that cell \\n\\n                 ans[i][j]=diff[i][j];\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n        \\n        vector<vector<int>>ans(n,vector<int>(n,0));\\n\\n        // row size n column size n+1\\n        vector<vector<int>>diff(n,vector<int>(n+1,0));\\n        // I will use the concept of difference array for row \\n\\n        // i will take the row wise prefix sum of the difference array and assign it back to our ans 2d array \\n\\n        for(int i = 0 ; i < queries.size() ; i++)\\n        {\\n            // for every row \\n            // increase the \\n            // start by 1 and decrease the end+1 by 1\\n            \\n\\n             int rstart = queries[i][0];\\n             int cstart = queries[i][1];\\n             int rend   = queries[i][2];\\n             int cend   = queries[i][3];\\n\\n             for( int j = rstart ; j <= rend ; j++)\\n             {\\n                  diff[j][cstart]+=1;\\n                  diff[j][cend+1]-=1;\\n             } \\n\\n        }\\n        \\n        // now take prefix sum of every row of difference matrix\\n\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            for(int j = 0 ; j < n ;j++)\\n            {\\n                 if(j > 0)\\n                 {\\n                     diff[i][j]+=diff[i][j-1];\\n                 }\\n\\n                 // assign the value at each cell after calculating   the prefix sum till that cell \\n\\n                 ans[i][j]=diff[i][j];\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3099720,
                "title": "brute-force-optimization-optimization-x2",
                "content": "# Intuition\\n- Brute force is too costly\\n- At 1 dimension, any range addition, can be represented as addition and reduction at left boundary and right boundary+1\\n    - Whats range addition? (1d)\\n    - [1,5,2] means increase each value between index 1 and 5 by 2\\n        - this problem is a speicifc case, where all deltas are 1\\n    - That means put 2 at index 1 and -2 at index 6(5+1, if exist) then do prefix sum\\n    - multi range additions can be combined together into one array, and do one last pre fix sum\\n        - why? Try it.\\n- At 2 dimensions, it\\'s actually the same\\n- For detail regarding range addition refer to [370. Range Addition](https://leetcode.com/problems/range-addition/), from 1d to 2d\\n\\n\\n# [Brute Force, 502ms](https://leetcode.com/problems/increment-submatrices-by-one/submissions/878740844/)\\nTC: O(n^2*L), L is length of query\\nSC: O(1)\\n```java\\nclass Solution {\\n    public int[][] rangeAddQueries(int n, int[][] Q) {\\n        int[][] res = new int[n][n];\\n        for (var q : Q) {\\n            int r0 = q[0], c0 = q[1], r1 = q[2]+1, c1 = q[3]+1;\\n            for (int i = r0; i < r1; i++) for (int j = c0; j < c1; j++)\\n              res[i][j]++;\\n        }\\n        return res;\\n    }\\n}\\n```\\n# [row level optimization, 21 ms](https://leetcode.com/problems/increment-submatrices-by-one/submissions/885321637/)\\nTC: O(n*L+n^2)\\nSC: O(1)\\n```java\\nclass Solution {\\n    public int[][] rangeAddQueries(int n, int[][] queries) {\\n        int[][] res = new int[n][n];\\n        for (var q : queries) {\\n            int r0 = q[0], c0 = q[1], r1 = q[2]+1, c1 = q[3]+1;\\n            for (int i = r0; i < r1; i++) {\\n                res[i][c0]++;\\n                if (c1 < n) res[i][c1]--;\\n            }\\n        }\\n\\n        for (var row : res)\\n            for (int j = 1; j < n; j++)\\n                row[j] += row[j-1];\\n\\n        return res;\\n    }\\n}\\n```\\n# [2d, 7ms](https://leetcode.com/problems/increment-submatrices-by-one/submissions/885379542/)\\nTC: O(2*n^2)\\nSC: O(1)\\n```java\\nclass Solution {\\n    public int[][] rangeAddQueries(int n, int[][] Q) {\\n        int[][] res = new int[n][n];\\n        for (var q : Q) {\\n            int r0 = q[0], c0 = q[1], r1 = q[2]+1, c1 = q[3]+1;\\n            res[r0][c0]++;\\n            if (c1 < n) res[r0][c1]--;\\n            if (r1 < n) {\\n                res[r1][c0]--;\\n                if (c1 < n) res[r1][c1]++;\\n            }\\n        }\\n\\n        for (int i = 0; i < n; i++) for (int j = 1; j < n; j++)\\n            res[i][j] += res[i][j-1];\\n\\n        for (int i = 1; i < n; i++) for (int j = 0; j < n; j++)\\n            res[i][j] += res[i-1][j];\\n\\n        return res;\\n    }\\n}\\n```\\n\\nPlease ignore below unless you want to know what \"not fun\" is.\\n# [2d, 11 ms, just for (NOT) fun](https://leetcode.com/problems/increment-submatrices-by-one/submissions/885312579/)\\nTC: O(L+n^2)\\nSC: O(n+L)\\n```java\\nclass Solution {\\n    record Row (int d, int c0, int c1) {}\\n    public int[][] rangeAddQueries(int n, int[][] Q) {\\n        List<Row>[] rows = new List[n];\\n        for (int i = 0; i < n; i++) rows[i] = new ArrayList<>();\\n\\n        for (var q : Q) {\\n            int r0 = q[0], c0 = q[1], r1 = q[2]+1, c1 = q[3]+1;\\n            rows[r0].add(new Row(1, c0, c1));\\n            if (r1 < n) rows[r1].add(new Row(-1, c0, c1));\\n        }\\n\\n        int[][] res = new int[n][n];\\n        int[] diff = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            for (var r : rows[i]) {\\n                diff[r.c0] += r.d;\\n                if (r.c1 < n) diff[r.c1] -= r.d;\\n            }\\n\\n            res[i][0] = diff[0];\\n            for (int j = 1; j < n; j++) res[i][j] += res[i][j-1] + diff[j];\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public int[][] rangeAddQueries(int n, int[][] Q) {\\n        int[][] res = new int[n][n];\\n        for (var q : Q) {\\n            int r0 = q[0], c0 = q[1], r1 = q[2]+1, c1 = q[3]+1;\\n            for (int i = r0; i < r1; i++) for (int j = c0; j < c1; j++)\\n              res[i][j]++;\\n        }\\n        return res;\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public int[][] rangeAddQueries(int n, int[][] queries) {\\n        int[][] res = new int[n][n];\\n        for (var q : queries) {\\n            int r0 = q[0], c0 = q[1], r1 = q[2]+1, c1 = q[3]+1;\\n            for (int i = r0; i < r1; i++) {\\n                res[i][c0]++;\\n                if (c1 < n) res[i][c1]--;\\n            }\\n        }\\n\\n        for (var row : res)\\n            for (int j = 1; j < n; j++)\\n                row[j] += row[j-1];\\n\\n        return res;\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public int[][] rangeAddQueries(int n, int[][] Q) {\\n        int[][] res = new int[n][n];\\n        for (var q : Q) {\\n            int r0 = q[0], c0 = q[1], r1 = q[2]+1, c1 = q[3]+1;\\n            res[r0][c0]++;\\n            if (c1 < n) res[r0][c1]--;\\n            if (r1 < n) {\\n                res[r1][c0]--;\\n                if (c1 < n) res[r1][c1]++;\\n            }\\n        }\\n\\n        for (int i = 0; i < n; i++) for (int j = 1; j < n; j++)\\n            res[i][j] += res[i][j-1];\\n\\n        for (int i = 1; i < n; i++) for (int j = 0; j < n; j++)\\n            res[i][j] += res[i-1][j];\\n\\n        return res;\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    record Row (int d, int c0, int c1) {}\\n    public int[][] rangeAddQueries(int n, int[][] Q) {\\n        List<Row>[] rows = new List[n];\\n        for (int i = 0; i < n; i++) rows[i] = new ArrayList<>();\\n\\n        for (var q : Q) {\\n            int r0 = q[0], c0 = q[1], r1 = q[2]+1, c1 = q[3]+1;\\n            rows[r0].add(new Row(1, c0, c1));\\n            if (r1 < n) rows[r1].add(new Row(-1, c0, c1));\\n        }\\n\\n        int[][] res = new int[n][n];\\n        int[] diff = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            for (var r : rows[i]) {\\n                diff[r.c0] += r.d;\\n                if (r.c1 < n) diff[r.c1] -= r.d;\\n            }\\n\\n            res[i][0] = diff[0];\\n            for (int j = 1; j < n; j++) res[i][j] += res[i][j-1] + diff[j];\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3052815,
                "title": "c-scanline-algo-clean-code",
                "content": "![image](https://assets.leetcode.com/users/images/35be67d7-2dd9-404a-8c06-c2c5112ef9dc_1673757401.114663.png)\\n\\n\\n\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tvector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n\\t\\t\\t   vector<vector<int>> mat(n, vector<int>(n)), diff(n + 1, vector<int>(n + 1));\\n\\n\\t\\t\\tfor (auto q : queries) {\\n\\t\\t\\t\\tint row1 = q[0], col1 = q[1], row2 = q[2], col2 = q[3];\\n\\t\\t\\t\\tdiff[row1][col1]++;\\n\\t\\t\\t\\tdiff[row1][col2 + 1]--;\\n\\t\\t\\t\\tdiff[row2 + 1][col1]--;\\n\\t\\t\\t\\tdiff[row2 + 1][col2 + 1]++;\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\t\\tfor (int j = 0; j < n; j++) {\\n\\t\\t\\t\\t\\tmat[i][j] += diff[i][j];\\n\\t\\t\\t\\t\\tif (i > 0) mat[i][j] += mat[i - 1][j];\\n\\t\\t\\t\\t\\tif (j > 0) mat[i][j] += mat[i][j - 1];\\n\\t\\t\\t\\t\\tif (i > 0 && j > 0) mat[i][j] -= mat[i - 1][j - 1];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn mat;\\n\\t\\t\\t}\\n\\t\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t\\tvector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n\\t\\t\\t   vector<vector<int>> mat(n, vector<int>(n)), diff(n + 1, vector<int>(n + 1));\\n\\n\\t\\t\\tfor (auto q : queries) {\\n\\t\\t\\t\\tint row1 = q[0], col1 = q[1], row2 = q[2], col2 = q[3];\\n\\t\\t\\t\\tdiff[row1][col1]++;\\n\\t\\t\\t\\tdiff[row1][col2 + 1]--;\\n\\t\\t\\t\\tdiff[row2 + 1][col1]--;\\n\\t\\t\\t\\tdiff[row2 + 1][col2 + 1]++;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3052738,
                "title": "python3-solution-100-faster-o-n-n",
                "content": "# Complexity\\n- Time complexity: $$O(n * n)$$\\n- Space complexity: $$O(n * n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def rangeAddQueries(self, n: int, queries: List[List[int]]) -> List[List[int]]:\\n        mat = [[0] * n for _ in range(n)]\\n        for r1, c1, r2, c2 in queries:\\n            mat[r1][c1] += 1\\n            if r2 + 1 < n: mat[r2 + 1][c1] -= 1\\n            if c2 + 1 < n: mat[r1][c2 + 1] -= 1\\n            if r2 + 1 < n and c2 + 1 < n: mat[r2 + 1][c2 + 1] += 1\\n        for i in range(n):\\n            for j in range(1, n):\\n                mat[i][j] += mat[i][j - 1]\\n        for i in range(1, n):\\n            for j in range(n):\\n                mat[i][j] += mat[i - 1][j]\\n        return mat\\n```",
                "solutionTags": [
                    "Python3",
                    "Matrix",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def rangeAddQueries(self, n: int, queries: List[List[int]]) -> List[List[int]]:\\n        mat = [[0] * n for _ in range(n)]\\n        for r1, c1, r2, c2 in queries:\\n            mat[r1][c1] += 1\\n            if r2 + 1 < n: mat[r2 + 1][c1] -= 1\\n            if c2 + 1 < n: mat[r1][c2 + 1] -= 1\\n            if r2 + 1 < n and c2 + 1 < n: mat[r2 + 1][c2 + 1] += 1\\n        for i in range(n):\\n            for j in range(1, n):\\n                mat[i][j] += mat[i][j - 1]\\n        for i in range(1, n):\\n            for j in range(n):\\n                mat[i][j] += mat[i - 1][j]\\n        return mat\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3052736,
                "title": "my-accepted-java-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] rangeAddQueries(int n, int[][] queries) {\\n            int[][] mat = new int[n][n];\\n        for (int[] query : queries) {\\n            int row1 = query[0], col1 = query[1], row2 = query[2], col2 = query[3];\\n            for (int i = row1; i <= row2; i++) {\\n                for (int j = col1; j <= col2; j++) {\\n                    mat[i][j]++;\\n                }\\n            }\\n        }\\n        return mat;\\n    \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] rangeAddQueries(int n, int[][] queries) {\\n            int[][] mat = new int[n][n];\\n        for (int[] query : queries) {\\n            int row1 = query[0], col1 = query[1], row2 = query[2], col2 = query[3];\\n            for (int i = row1; i <= row2; i++) {\\n                for (int j = col1; j <= col2; j++) {\\n                    mat[i][j]++;\\n                }\\n            }\\n        }\\n        return mat;\\n    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3053956,
                "title": "c-marking-boundaries-efficient-approach",
                "content": "# Intuition\\nBrute-force approach for solving this problem is not working in the given time constraints. So we need to reduce nested loops.\\n\\n# Approach\\nWe mark boundary of start point of adding 1 and ending point of adding 1 for each row. By using given steps:\\n\\ni) Initialize nxn matrix with 0.\\n\\nii) For marking start point of the boundary, we add +1 for each row given in the query.\\n \\niii) For marking end point of the boundary, we add -1 at the next column for each row. But if we are at last column of the row, we mark first column of the next row as -1 and if we are also at last row of matrix then we skip adding -1.\\n\\niv) At last we create required matrix by taking count as 0 and update it as par the values marked in the matrix\\'s cell and assign count to that cell. \\n\\n# Complexity\\n- Time complexity:\\nO(nxn) + O(queries x rows)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution \\n{\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) \\n    {\\n        vector<vector<int>> mat(n, vector<int> (n, 0));\\n        int r1, c1, r2, c2;\\n        for(auto &it:queries)\\n        {\\n            r1=it[0], c1=it[1], r2=it[2], c2=it[3];\\n            for(int i=r1; i<=r2; i++) //marking each row of the query\\n            {\\n                mat[i][c1] += 1; //according to the query, we need to start adding 1 from (i, c1) cell\\n                if((c2+1)>=n) //for stop adding one, we need to check whether we are at last cell of the row or not\\n                    if(i+1<n) //if we are at last cell, we mark first cell of next row as stop adding 1\\n                        mat[i+1][0] -= 1;\\n                    else\\n                        continue;\\n                        \\n                \\n                else //if we are not at last cell, we mark next cell of the row at stop adding 1.\\n                    mat[i][c2+1] -= 1;      \\n                \\n            }    \\n        }\\n        \\n        int cnt=0;\\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j=0; j<n; j++)\\n            {\\n                cnt += mat[i][j];\\n                mat[i][j] = cnt;\\n            }\\n        }\\n        return mat;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Matrix"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) \\n    {\\n        vector<vector<int>> mat(n, vector<int> (n, 0));\\n        int r1, c1, r2, c2;\\n        for(auto &it:queries)\\n        {\\n            r1=it[0], c1=it[1], r2=it[2], c2=it[3];\\n            for(int i=r1; i<=r2; i++) //marking each row of the query\\n            {\\n                mat[i][c1] += 1; //according to the query, we need to start adding 1 from (i, c1) cell\\n                if((c2+1)>=n) //for stop adding one, we need to check whether we are at last cell of the row or not\\n                    if(i+1<n) //if we are at last cell, we mark first cell of next row as stop adding 1\\n                        mat[i+1][0] -= 1;\\n                    else\\n                        continue;\\n                        \\n                \\n                else //if we are not at last cell, we mark next cell of the row at stop adding 1.\\n                    mat[i][c2+1] -= 1;      \\n                \\n            }    \\n        }\\n        \\n        int cnt=0;\\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j=0; j<n; j++)\\n            {\\n                cnt += mat[i][j];\\n                mat[i][j] = cnt;\\n            }\\n        }\\n        return mat;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3052995,
                "title": "java-prefix-sum-optimised-solution",
                "content": "```\\nclass Solution {\\n    public int[][] rangeAddQueries(int n, int[][] queries) {\\n        int [][]mat = new int[n][n];\\n        int[][] prefix = new int[n+1][n+1];\\n        \\n        for(int[] query : queries) {\\n            int row1 = query[0], col1 = query[1], row2 = query[2], col2 = query[3];\\n            prefix[row1][col1] += 1;\\n            prefix[row2 + 1][col2 + 1] += 1;\\n            prefix[row1][col2 + 1] -= 1;\\n            prefix[row2 + 1][col1] -= 1;\\n        }\\n        \\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < n; j++) {\\n                prefix[i][j+1] += prefix[i][j];\\n            }\\n        }\\n        \\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < n; j++) {\\n                prefix[i+1][j] += prefix[i][j];\\n                mat[i][j] = prefix[i][j];\\n            }\\n        }\\n        return mat;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] rangeAddQueries(int n, int[][] queries) {\\n        int [][]mat = new int[n][n];\\n        int[][] prefix = new int[n+1][n+1];\\n        \\n        for(int[] query : queries) {\\n            int row1 = query[0], col1 = query[1], row2 = query[2], col2 = query[3];\\n            prefix[row1][col1] += 1;\\n            prefix[row2 + 1][col2 + 1] += 1;\\n            prefix[row1][col2 + 1] -= 1;\\n            prefix[row2 + 1][col1] -= 1;\\n        }\\n        \\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < n; j++) {\\n                prefix[i][j+1] += prefix[i][j];\\n            }\\n        }\\n        \\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < n; j++) {\\n                prefix[i+1][j] += prefix[i][j];\\n                mat[i][j] = prefix[i][j];\\n            }\\n        }\\n        return mat;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3052847,
                "title": "accepted-easy-solution-short-simple-best-method",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n        vector<vector<int>> dp(n, vector<int>(n));\\n        for(vector<int> v:queries)\\n        {\\n            for(int i=v[0];i<=v[2];i++)\\n            {\\n                dp[i][v[1]]+=1;\\n                if(v[3]<n-1)\\n                dp[i][v[3]+1]-=1;\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=1;j<n;j++)\\n            dp[i][j]+=dp[i][j-1];\\n        }\\n        return dp;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n        vector<vector<int>> dp(n, vector<int>(n));\\n        for(vector<int> v:queries)\\n        {\\n            for(int i=v[0];i<=v[2];i++)\\n            {\\n                dp[i][v[1]]+=1;\\n                if(v[3]<n-1)\\n                dp[i][v[3]+1]-=1;\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=1;j<n;j++)\\n            dp[i][j]+=dp[i][j-1];\\n        }\\n        return dp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3052757,
                "title": "java-2-solutions-brute-force-and-optimized",
                "content": "# Please Upvote :D\\n---\\n##### 1. Brute force approach:\\n``` java []\\nclass Solution {\\n    public int[][] rangeAddQueries(int n, int[][] queries) {\\n        int[][] a = new int[n][n];\\n        for (int[] q : queries) {\\n            int r1 = q[0], r2 = q[2];   // row1, row2\\n            int c1 = q[1], c2 = q[3];   // col1, col2\\n            // iterate over the matrix \\n            // with corners row1, col1 and row2, col2 \\n            for (int i = r1; i <= r2; i++) {\\n                for (int j = c1; j <= c2; j++) {\\n                    a[i][j]++;  // increment\\n                }\\n            }\\n        }\\n        \\n        return a;   // return the matrix\\n    }\\n}\\n\\n// TC: O(m * n^2), SC: O(n^2)\\n```\\n---\\n##### 2. Optimized approach:\\n``` java []\\nclass Solution {\\n    public int[][] rangeAddQueries(int n, int[][] queries) {\\n        int[][] a = new int[n][n];\\n        for (int[] q : queries) {\\n            int r1 = q[0], r2 = q[2];\\n            int c1 = q[1], c2 = q[3];\\n            for (int i = r1; i <= r2; i++) {\\n                a[i][c1]++;\\n            }\\n            if (c2 + 1 < n) {\\n                for (int i = r1; i <= r2; i++) {\\n                    a[i][c2 + 1]--;\\n                }\\n            }\\n        }\\n        \\n        for (int i = 0; i < n; i++) {\\n            for (int j = 1; j < n; j++) {\\n                a[i][j] += a[i][j - 1];\\n            }\\n        }\\n        \\n        return a;\\n    }\\n}\\n\\n// TC: O(m * n) + O(n ^ 2), SC: O(n ^ 2)\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Matrix"
                ],
                "code": "``` java []\\nclass Solution {\\n    public int[][] rangeAddQueries(int n, int[][] queries) {\\n        int[][] a = new int[n][n];\\n        for (int[] q : queries) {\\n            int r1 = q[0], r2 = q[2];   // row1, row2\\n            int c1 = q[1], c2 = q[3];   // col1, col2\\n            // iterate over the matrix \\n            // with corners row1, col1 and row2, col2 \\n            for (int i = r1; i <= r2; i++) {\\n                for (int j = c1; j <= c2; j++) {\\n                    a[i][j]++;  // increment\\n                }\\n            }\\n        }\\n        \\n        return a;   // return the matrix\\n    }\\n}\\n\\n// TC: O(m * n^2), SC: O(n^2)\\n```\n``` java []\\nclass Solution {\\n    public int[][] rangeAddQueries(int n, int[][] queries) {\\n        int[][] a = new int[n][n];\\n        for (int[] q : queries) {\\n            int r1 = q[0], r2 = q[2];\\n            int c1 = q[1], c2 = q[3];\\n            for (int i = r1; i <= r2; i++) {\\n                a[i][c1]++;\\n            }\\n            if (c2 + 1 < n) {\\n                for (int i = r1; i <= r2; i++) {\\n                    a[i][c2 + 1]--;\\n                }\\n            }\\n        }\\n        \\n        for (int i = 0; i < n; i++) {\\n            for (int j = 1; j < n; j++) {\\n                a[i][j] += a[i][j - 1];\\n            }\\n        }\\n        \\n        return a;\\n    }\\n}\\n\\n// TC: O(m * n) + O(n ^ 2), SC: O(n ^ 2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3811374,
                "title": "python-3-sweep-line-simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n1. 1-D sweep line\\n```\\nclass Solution:\\n    def rangeAddQueries(self, n: int, queries: List[List[int]]) -> List[List[int]]:\\n        ans = [[0] * n for _ in range(n)]\\n        for r1, c1, r2, c2 in queries:\\n            for r in range(r1, r2 + 1):\\n                ans[r][c1] += 1\\n                if c2 + 1 < n: ans[r][c2 + 1] -= 1\\n        for r in range(n):\\n            for c in range(1, n):\\n                ans[r][c] += ans[r][c - 1]\\n        return ans\\n```\\n- TC: $$O(N^2 + NQ)$$\\n- SC: $$O(1)$$ if not including space for answer\\n\\n2. 2-D Sweep line\\n```\\nclass Solution:\\n    def rangeAddQueries(self, n: int, queries: List[List[int]]) -> List[List[int]]:\\n    ans = [[0] * n for _ in range(n)]\\n    for r1, c1, r2, c2 in queries:\\n        ans[r1][c1] += 1\\n        if r2 + 1 < n: ans[r2 + 1][c1] -= 1\\n        if c2 + 1 < n: ans[r1][c2 + 1] -= 1\\n        if r2 + 1 < n and c2 + 1 < n: ans[r2 + 1][c2 + 1] += 1\\n    for r in range(1, n):\\n        for c in range(n):\\n            ans[r][c] += ans[r - 1][c]\\n    for r in range(n):\\n        for c in range(1, n):\\n            ans[r][c] += ans[r][c - 1]\\n    return ans\\n```\\n- TC: $$O(N^2 + Q)$$\\n- SC: $$O(1)$$ if not including space for answer",
                "solutionTags": [
                    "Python3",
                    "Line Sweep",
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    def rangeAddQueries(self, n: int, queries: List[List[int]]) -> List[List[int]]:\\n        ans = [[0] * n for _ in range(n)]\\n        for r1, c1, r2, c2 in queries:\\n            for r in range(r1, r2 + 1):\\n                ans[r][c1] += 1\\n                if c2 + 1 < n: ans[r][c2 + 1] -= 1\\n        for r in range(n):\\n            for c in range(1, n):\\n                ans[r][c] += ans[r][c - 1]\\n        return ans\\n```\n```\\nclass Solution:\\n    def rangeAddQueries(self, n: int, queries: List[List[int]]) -> List[List[int]]:\\n    ans = [[0] * n for _ in range(n)]\\n    for r1, c1, r2, c2 in queries:\\n        ans[r1][c1] += 1\\n        if r2 + 1 < n: ans[r2 + 1][c1] -= 1\\n        if c2 + 1 < n: ans[r1][c2 + 1] -= 1\\n        if r2 + 1 < n and c2 + 1 < n: ans[r2 + 1][c2 + 1] += 1\\n    for r in range(1, n):\\n        for c in range(n):\\n            ans[r][c] += ans[r - 1][c]\\n    for r in range(n):\\n        for c in range(1, n):\\n            ans[r][c] += ans[r][c - 1]\\n    return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3053574,
                "title": "simple-java-two-loops-easy-to-understand",
                "content": "1. Given Condion : row1i <= x <= row2i and col1i <= y <= col2i.\\n1. So run to loops, one for row and one for column.\\n\\n```\\nclass Solution {\\n    public int[][] rangeAddQueries(int n, int[][] queries) {   \\n        \\n        int[][] answer = new int[n][n];\\n        \\n        for (int[] A : queries) {\\n\\t\\t\\n            int row1 = A[0], row2 = A[2];\\n\\t\\t\\tint col1 = A[1], col2 = A[3];\\n            \\n            for (int row = row1; row <= row2; row++) {\\n                for (int col = col1; col <= col2; col++) {\\n                    answer[row][col] += 1;\\n                }\\n            }\\n        }\\n        return answer;\\n    }\\n}\\n```\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] rangeAddQueries(int n, int[][] queries) {   \\n        \\n        int[][] answer = new int[n][n];\\n        \\n        for (int[] A : queries) {\\n\\t\\t\\n            int row1 = A[0], row2 = A[2];\\n\\t\\t\\tint col1 = A[1], col2 = A[3];\\n            \\n            for (int row = row1; row <= row2; row++) {\\n                for (int col = col1; col <= col2; col++) {\\n                    answer[row][col] += 1;\\n                }\\n            }\\n        }\\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3052875,
                "title": "c-prefix-sum-detailed-explaination",
                "content": "# Intuition \\uD83D\\uDE80\\nThe intuition behind this code is to use a 2D prefix sum algorithm to efficiently calculate the range add queries on a 2D grid.\\n\\nThe code first initializes a 2D array \"ansArray\" with all elements as 0. Then it iterates through the input \"queries\" vector, which contains information about the ranges (r1, c1) and (r2, c2) that need to be incremented in the 2D grid. The code increments the value at position (r1, c1) in the \"ansArray\" and then checks for cases where indices r2+1 and c2+1 are less than n and update the ansArray accordingly.\\n\\nThen the code uses prefix sum algorithm to update the values in the ansArray by iterating through the array twice, first for column and then for row.\\n\\nFinally, the code creates a new 2D array \"res\" with the same dimensions as \"ansArray\" and copies the values of \"ansArray\" into \"res\". The method returns \"res\" as the final answer, which contains the updated grid after all the range add queries have been applied.\\n\\nThe benefit of using prefix sum algorithm is that it allows to perform multiple queries and update the grid in a time complexity of O(n) where n is the number of elements in the grid.\\n\\n# Code \\uD83D\\uDE80\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n            vector<vector<int>> ansArray(n, vector<int>(n, 0));\\n        \\n            for (auto &it : queries) {\\n                int r1 = it[0], c1 = it[1], r2 = it[2], c2 = it[3];\\n                ansArray[r1][c1]++;\\n                \\n                if (r2 + 1 < n && c2 + 1 < n) {\\n                    ansArray[r2 + 1][c2 + 1]++;\\n                }\\n                if (r2 + 1 < n) {\\n                    ansArray[r2 + 1][c1]--;\\n                }\\n                if (c2 + 1 < n) {\\n                    ansArray[r1][c2 + 1]--;\\n                }\\n            }\\n        \\n            for (int i = 0; i < n; i++) {\\n                for (int j = 1; j < n; j++) {\\n                    ansArray[i][j] += ansArray[i][j - 1];\\n                }\\n                \\n            }\\n      \\n            for (int i = 1; i < n; i++) {\\n                for (int j = 0; j < n; j++) {\\n                    ansArray[i][j] += ansArray[i - 1][j];\\n                }\\n            }\\n        \\n            return ansArray;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n            vector<vector<int>> ansArray(n, vector<int>(n, 0));\\n        \\n            for (auto &it : queries) {\\n                int r1 = it[0], c1 = it[1], r2 = it[2], c2 = it[3];\\n                ansArray[r1][c1]++;\\n                \\n                if (r2 + 1 < n && c2 + 1 < n) {\\n                    ansArray[r2 + 1][c2 + 1]++;\\n                }\\n                if (r2 + 1 < n) {\\n                    ansArray[r2 + 1][c1]--;\\n                }\\n                if (c2 + 1 < n) {\\n                    ansArray[r1][c2 + 1]--;\\n                }\\n            }\\n        \\n            for (int i = 0; i < n; i++) {\\n                for (int j = 1; j < n; j++) {\\n                    ansArray[i][j] += ansArray[i][j - 1];\\n                }\\n                \\n            }\\n      \\n            for (int i = 1; i < n; i++) {\\n                for (int j = 0; j < n; j++) {\\n                    ansArray[i][j] += ansArray[i - 1][j];\\n                }\\n            }\\n        \\n            return ansArray;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3052743,
                "title": "short-clean-java",
                "content": "\\n```java []\\nclass Solution {\\n    public int[][] rangeAddQueries(int n, int[][] queries) {\\n        int[][] arr = new int[n][n];\\n        for(int k=0; k<queries.length; k++){\\n            for(int i=queries[k][0]; i<=queries[k][2]; i++){\\n                for(int j=queries[k][1]; j<=queries[k][3]; j++){\\n                    arr[i][j] += 1;\\n                }\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java []\\nclass Solution {\\n    public int[][] rangeAddQueries(int n, int[][] queries) {\\n        int[][] arr = new int[n][n];\\n        for(int k=0; k<queries.length; k++){\\n            for(int i=queries[k][0]; i<=queries[k][2]; i++){\\n                for(int j=queries[k][1]; j<=queries[k][3]; j++){\\n                    arr[i][j] += 1;\\n                }\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3057198,
                "title": "prefix-sum-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n        O(n*n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n        O(n*n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n        vector<vector<int>>mat(n,vector<int>(n,0));\\n        for(auto q : queries){\\n            mat[q[0]][q[1]]++;\\n            if(q[2]+1<n && q[3]+1<n) mat[q[2]+1][q[3]+1]++;\\n            if(q[3]+1<n) mat[q[0]][q[3]+1]--;\\n            if(q[2]+1<n) mat[q[2]+1][q[1]]--; \\n        }\\n        for (int r = 1; r < n; r ++) {\\n            for (int c = 0; c < n; c ++) mat[r][c] += mat[r-1][c];\\n        }\\n        for (int r = 0; r < n; r ++) {\\n            for (int c = 1; c < n; c ++) mat[r][c] += mat[r][c-1];\\n        }\\n        return mat;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n        vector<vector<int>>mat(n,vector<int>(n,0));\\n        for(auto q : queries){\\n            mat[q[0]][q[1]]++;\\n            if(q[2]+1<n && q[3]+1<n) mat[q[2]+1][q[3]+1]++;\\n            if(q[3]+1<n) mat[q[0]][q[3]+1]--;\\n            if(q[2]+1<n) mat[q[2]+1][q[1]]--; \\n        }\\n        for (int r = 1; r < n; r ++) {\\n            for (int c = 0; c < n; c ++) mat[r][c] += mat[r-1][c];\\n        }\\n        for (int r = 0; r < n; r ++) {\\n            for (int c = 1; c < n; c ++) mat[r][c] += mat[r][c-1];\\n        }\\n        return mat;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3057197,
                "title": "brute-force",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n        O(n*n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n        O(n*n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n        vector<vector<int>>mat(n,vector<int>(n,0));\\n        for(auto q : queries){\\n            mat[q[0]][q[1]]++;\\n            if(q[2]+1<n && q[3]+1<n) mat[q[2]+1][q[3]+1]++;\\n            if(q[3]+1<n) mat[q[0]][q[3]+1]--;\\n            if(q[2]+1<n) mat[q[2]+1][q[1]]--; \\n        }\\n        for (int r = 1; r < n; r ++) {\\n            for (int c = 0; c < n; c ++) mat[r][c] += mat[r-1][c];\\n        }\\n        for (int r = 0; r < n; r ++) {\\n            for (int c = 1; c < n; c ++) mat[r][c] += mat[r][c-1];\\n        }\\n        return mat;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n        vector<vector<int>>mat(n,vector<int>(n,0));\\n        for(auto q : queries){\\n            mat[q[0]][q[1]]++;\\n            if(q[2]+1<n && q[3]+1<n) mat[q[2]+1][q[3]+1]++;\\n            if(q[3]+1<n) mat[q[0]][q[3]+1]--;\\n            if(q[2]+1<n) mat[q[2]+1][q[1]]--; \\n        }\\n        for (int r = 1; r < n; r ++) {\\n            for (int c = 0; c < n; c ++) mat[r][c] += mat[r-1][c];\\n        }\\n        for (int r = 0; r < n; r ++) {\\n            for (int c = 1; c < n; c ++) mat[r][c] += mat[r][c-1];\\n        }\\n        return mat;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3056914,
                "title": "easy-best-solution-in-c-prefixsum",
                "content": "# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n**Please Upvote if u liked my Solution**\\uD83E\\uDD17\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n        vector<vector<int>> mat(n,vector<int>(n));\\n        for(auto it:queries){\\n            int r1=it[0],r2=it[2],c1=it[1],c2=it[3];\\n            mat[r1][c1]++;\\n            if(c2+1<n)\\n                mat[r1][c2+1]--;\\n            if(r2+1<n) \\n                mat[r2+1][c1]--;\\n            if(r2+1<n && c2+1<n)\\n                mat[r2+1][c2+1]++;\\n        }\\n        int prefixSum=0;\\n        for(int i=0;i<n;i++){\\n            prefixSum=0;\\n            for(int j=0;j<n;j++){\\n                prefixSum+=mat[i][j];\\n                mat[i][j]=prefixSum;\\n            }\\n        }\\n        for(int j=0;j<n;j++){\\n            prefixSum=0;\\n            for(int i=0;i<n;i++){\\n                prefixSum+=mat[i][j];\\n                mat[i][j]=prefixSum;\\n            }\\n        }\\n        return mat;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Matrix",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n        vector<vector<int>> mat(n,vector<int>(n));\\n        for(auto it:queries){\\n            int r1=it[0],r2=it[2],c1=it[1],c2=it[3];\\n            mat[r1][c1]++;\\n            if(c2+1<n)\\n                mat[r1][c2+1]--;\\n            if(r2+1<n) \\n                mat[r2+1][c1]--;\\n            if(r2+1<n && c2+1<n)\\n                mat[r2+1][c2+1]++;\\n        }\\n        int prefixSum=0;\\n        for(int i=0;i<n;i++){\\n            prefixSum=0;\\n            for(int j=0;j<n;j++){\\n                prefixSum+=mat[i][j];\\n                mat[i][j]=prefixSum;\\n            }\\n        }\\n        for(int j=0;j<n;j++){\\n            prefixSum=0;\\n            for(int i=0;i<n;i++){\\n                prefixSum+=mat[i][j];\\n                mat[i][j]=prefixSum;\\n            }\\n        }\\n        return mat;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3055514,
                "title": "brute-force-approach-no-tle-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nSince we are runnig 3 nested loops, hence, TC will be O(cubic N)\\n\\n- Space complexity:\\nO(N*N) : For array we are using to store our ans...\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] rangeAddQueries(int n, int[][] queries) {\\n        int[][] mat = new int[n][n];\\n   for (int[] q : queries) {\\n       int row1 = q[0], col1 = q[1], row2 = q[2], col2 = q[3];\\n       for (int i = row1; i <= row2; i++) {\\n           for (int j = col1; j <= col2; j++) {\\n               mat[i][j]++;\\n           }\\n       }\\n   }\\n   return mat;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] rangeAddQueries(int n, int[][] queries) {\\n        int[][] mat = new int[n][n];\\n   for (int[] q : queries) {\\n       int row1 = q[0], col1 = q[1], row2 = q[2], col2 = q[3];\\n       for (int i = row1; i <= row2; i++) {\\n           for (int j = col1; j <= col2; j++) {\\n               mat[i][j]++;\\n           }\\n       }\\n   }\\n   return mat;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3053745,
                "title": "c-prefix-sum-in-each-row-each-column",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n        //basically the idea is to get mat[i][j]th element by its prefix sum so for each query we we increase top left by one & check if bottom+1 & right+1 is valid if its we increase by 1 if not we decrease value ou bottom+1,left & bottom,left+1 by 1 \\n    vector<vector<int>>mat(n,vector<int>(n,0));\\n        for(int i=0;i<queries.size();i++){\\n            int r1=queries[i][0],r2=queries[i][2],c1=queries[i][1],c2=queries[i][3];\\n            mat[r1][c1]+=1;\\n            if(r2+1<n && c2+1<n)mat[r2+1][c2+1]+=1;//increase value of next element diagonally\\n            if(r2+1<n)mat[r2+1][c1]-=1;//decreasing value of next element in same column\\n            if(c2+1<n)mat[r1][c2+1]-=1;//decreasing value of next element in same row\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=1;j<n;j++){\\n                mat[i][j]+=mat[i][j-1];\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=1;j<n;j++){\\n                mat[j][i]+=mat[j-1][i];\\n            }\\n        }\\n        return mat;\\n    }\\n};\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n        //basically the idea is to get mat[i][j]th element by its prefix sum so for each query we we increase top left by one & check if bottom+1 & right+1 is valid if its we increase by 1 if not we decrease value ou bottom+1,left & bottom,left+1 by 1 \\n    vector<vector<int>>mat(n,vector<int>(n,0));\\n        for(int i=0;i<queries.size();i++){\\n            int r1=queries[i][0],r2=queries[i][2],c1=queries[i][1],c2=queries[i][3];\\n            mat[r1][c1]+=1;\\n            if(r2+1<n && c2+1<n)mat[r2+1][c2+1]+=1;//increase value of next element diagonally\\n            if(r2+1<n)mat[r2+1][c1]-=1;//decreasing value of next element in same column\\n            if(c2+1<n)mat[r1][c2+1]-=1;//decreasing value of next element in same row\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=1;j<n;j++){\\n                mat[i][j]+=mat[i][j-1];\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=1;j<n;j++){\\n                mat[j][i]+=mat[j-1][i];\\n            }\\n        }\\n        return mat;\\n    }\\n};\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3053516,
                "title": "js-brute-force-can-get-the-job-done",
                "content": "# Intuition\\nBrute force\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n^2)\\n\\n# Code\\n```\\nvar rangeAddQueries = function (n, queries) {\\n  const mat = new Array(n).fill().map(() => new Array(n).fill(0));\\n  for (let q of queries) {\\n    for (let i = q[0]; i <= q[2]; i++) {\\n      for (let j = q[1]; j <= q[3]; j++) {\\n        mat[i][j]++;\\n      }\\n    }\\n  }\\n  return mat;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar rangeAddQueries = function (n, queries) {\\n  const mat = new Array(n).fill().map(() => new Array(n).fill(0));\\n  for (let q of queries) {\\n    for (let i = q[0]; i <= q[2]; i++) {\\n      for (let j = q[1]; j <= q[3]; j++) {\\n        mat[i][j]++;\\n      }\\n    }\\n  }\\n  return mat;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3052916,
                "title": "c-difference-matrix-inspired-by-the-difference-array",
                "content": "# Intuition\\nThis solution is derived from the idea of the 1-d difference array. \\nFor an 1d array, if there are multiple update before a query(note here that the question\\'s wording is vague -- update in this question is \"query,\" but query means to assess the value of the array), we can do the following:\\n\\ncreate a difference array $diff$ such that $diff[i] = arr[i] - arr[i-1]$. To update a given range $(i,j)$ by some value $c$, simply update as \\n`diff[i] += c` and `diff[j+1] -= c`. Then we reaseemble the prefix sum of the difference array to get the result, i.e., \\n`arr_final[i] = arr_final[i-1] + diff[i]`. \\n\\nThis can be generalized to 2d by choosing the prefix sum very carefully.  \\n\\n\\n# Complexity\\n- Time complexity: $O(n^2)$, each insert takes $O(1)$ and the number of queries is strictly bounded by the size of the matrix. The building and the rebuilding take both $O(n)$\\n- Space complexity:$O(n^2)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nusing namespace std;\\nclass Solution {\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n\\n        // create difference matrices    \\n        vector<vector<int>> diff_matrix;\\n        vector<vector<int>> result_matrix;\\n        for (int i = 0; i < n; i ++) {\\n            vector<int> current(n, 0);\\n            vector<int> current_result(n, 0);\\n            diff_matrix.push_back(current);\\n            result_matrix.push_back(current_result);\\n        }\\n        int x1, y1, x2, y2;\\n        for (auto vect : queries) {\\n            int x1 = vect[0], y1 = vect[1], x2 = vect[2], y2 = vect[3];\\n            insert(diff_matrix, x1, y1, x2, y2, 1);\\n        }\\n        //reassemble the matrix \\n        \\n        for (int i = 0; i < n; i ++) {\\n            for (int j = 0; j < n; j ++) {\\n                int up_left = (i-1 >= 0 && j - 1 >=0) ? result_matrix[i-1][j-1] : 0;\\n                int up = (i - 1 >= 0) ? result_matrix[i-1][j] : 0; \\n                int left = (j - 1 >= 0) ? result_matrix[i][j-1] : 0;\\n                result_matrix[i][j] = diff_matrix[i][j] - up_left + up + left;\\n            }\\n        }\\n        return result_matrix;\\n        // for each query, we perform the following:\\n        // \\n    }\\n    void insert(vector<vector<int>>& diff_matrix, int x1, int y1, int x2, int y2, int update){\\n        diff_matrix[x1][y1] += update;\\n        if (x2 + 1 < diff_matrix.size())\\n            diff_matrix[x2 + 1][y1] -= update;\\n        if (y2 + 1 < diff_matrix[0].size())\\n            diff_matrix[x1][y2 + 1] -= update;\\n        if (x2 + 1 < diff_matrix[0].size() && y2 + 1 < diff_matrix.size())\\n            diff_matrix[x2 + 1][y2 + 1] += update;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nusing namespace std;\\nclass Solution {\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n\\n        // create difference matrices    \\n        vector<vector<int>> diff_matrix;\\n        vector<vector<int>> result_matrix;\\n        for (int i = 0; i < n; i ++) {\\n            vector<int> current(n, 0);\\n            vector<int> current_result(n, 0);\\n            diff_matrix.push_back(current);\\n            result_matrix.push_back(current_result);\\n        }\\n        int x1, y1, x2, y2;\\n        for (auto vect : queries) {\\n            int x1 = vect[0], y1 = vect[1], x2 = vect[2], y2 = vect[3];\\n            insert(diff_matrix, x1, y1, x2, y2, 1);\\n        }\\n        //reassemble the matrix \\n        \\n        for (int i = 0; i < n; i ++) {\\n            for (int j = 0; j < n; j ++) {\\n                int up_left = (i-1 >= 0 && j - 1 >=0) ? result_matrix[i-1][j-1] : 0;\\n                int up = (i - 1 >= 0) ? result_matrix[i-1][j] : 0; \\n                int left = (j - 1 >= 0) ? result_matrix[i][j-1] : 0;\\n                result_matrix[i][j] = diff_matrix[i][j] - up_left + up + left;\\n            }\\n        }\\n        return result_matrix;\\n        // for each query, we perform the following:\\n        // \\n    }\\n    void insert(vector<vector<int>>& diff_matrix, int x1, int y1, int x2, int y2, int update){\\n        diff_matrix[x1][y1] += update;\\n        if (x2 + 1 < diff_matrix.size())\\n            diff_matrix[x2 + 1][y1] -= update;\\n        if (y2 + 1 < diff_matrix[0].size())\\n            diff_matrix[x1][y2 + 1] -= update;\\n        if (x2 + 1 < diff_matrix[0].size() && y2 + 1 < diff_matrix.size())\\n            diff_matrix[x2 + 1][y2 + 1] += update;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3052572,
                "title": "simple-java-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] rangeAddQueries(int n, int[][] q) {\\n        int a[][]=new int[n][n];\\n        for(int i=0;i<q.length;i++)\\n        {\\n            for(int i1=q[i][0];i1<=q[i][2];i1++)\\n            {\\n                for(int j=q[i][1];j<=q[i][3];j++)\\n                {\\n                    a[i1][j]+=1;\\n                    //System.out.println(i1+\" \"+j);\\n                }\\n            }\\n        }\\n        return a;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] rangeAddQueries(int n, int[][] q) {\\n        int a[][]=new int[n][n];\\n        for(int i=0;i<q.length;i++)\\n        {\\n            for(int i1=q[i][0];i1<=q[i][2];i1++)\\n            {\\n                for(int j=q[i][1];j<=q[i][3];j++)\\n                {\\n                    a[i1][j]+=1;\\n                    //System.out.println(i1+\" \"+j);\\n                }\\n            }\\n        }\\n        return a;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3060621,
                "title": "easy-short-conversion-from-brute-force-to-optimized",
                "content": "# Intuition\\nFirst i tried to apply the brute force but after successfully failing on 12/30 testcases what i was clear about was that i have to make the complexity from O(10^4*500*500) to O(10^4*500)\\n\\n# Approach\\nOther than changing the values of all the rows just increment the first index of each row and decrement the index after the last element of each row.\\nBy this if at last if we change an array to prefix sum then it will assign all the required values at once.\\n\\n# Complexity\\n- Time complexity: O(n*q)\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n        vector<vector<int>>v(n,vector<int>(n,0));\\n        for(auto& i:queries){\\n            for(int k=i[0];k<=i[2];k++)\\n                v[k][i[1]]++; if((i[3]+1)<n) v[k][i[3]+1]--;    \\n        }\\n        for(int i=0;i<n;i++) for(int j=1;j<n;j++) v[i][j]+=v[i][j-1];\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n        vector<vector<int>>v(n,vector<int>(n,0));\\n        for(auto& i:queries){\\n            for(int k=i[0];k<=i[2];k++)\\n                v[k][i[1]]++; if((i[3]+1)<n) v[k][i[3]+1]--;    \\n        }\\n        for(int i=0;i<n;i++) for(int j=1;j<n;j++) v[i][j]+=v[i][j-1];\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3054414,
                "title": "simple-4-step-prefix-sum-c-solution-optimized-approach",
                "content": "# Intuition\\nApply prefix sum on 2D Matrix. \\n\\nStep 1 : arr[x1][y1]++\\nStep 2 : arr[x2+1][y2+1]++\\nstep 3 : arr[x2+1][y1]--\\nstep 4 : arr[x1][y2+1]--\\n\\nAfter performing all the queries\\n\\narr[i][j] += arr[i - 1][j] + arr[i][j - 1] - arr[i - 1][j - 1];\\n\\n# Complexity\\n- Time complexity: O(NXN)\\n\\n- Space complexity: O(NXN)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& q) \\n    {\\n        vector<vector<int>>arr(n, vector<int>(n, 0));\\n        \\n        for(int i=0; i<q.size(); i++)\\n        {\\n            int x1 = q[i][0];\\n            int y1 = q[i][1];\\n            int x2 = q[i][2];\\n            int y2 = q[i][3];\\n            \\n            arr[x1][y1]++;\\n            if(y2+1<n && x2+1<n) arr[x2 + 1][y2 + 1]++;\\n            if(y2+1 < n) arr[x1][y2 + 1]--;\\n            if(x2+1 < n) arr[x2 + 1][y1]--;\\n            \\n        }\\n        \\n\\t\\tfor(int i=0;i<n;i++)\\n        {\\n            for (int j = 0; j < n; j++) {\\n                \\n                if(i-1 >= 0) arr[i][j] += arr[i-1][j];\\n                if(j-1 >= 0) arr[i][j] += arr[i][j-1];\\n                if(i-1>=0 && j-1>=0) arr[i][j] -= arr[i-1][j-1];\\n            }\\n        }\\n\\t\\t\\n        \\n        return arr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Matrix",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& q) \\n    {\\n        vector<vector<int>>arr(n, vector<int>(n, 0));\\n        \\n        for(int i=0; i<q.size(); i++)\\n        {\\n            int x1 = q[i][0];\\n            int y1 = q[i][1];\\n            int x2 = q[i][2];\\n            int y2 = q[i][3];\\n            \\n            arr[x1][y1]++;\\n            if(y2+1<n && x2+1<n) arr[x2 + 1][y2 + 1]++;\\n            if(y2+1 < n) arr[x1][y2 + 1]--;\\n            if(x2+1 < n) arr[x2 + 1][y1]--;\\n            \\n        }\\n        \\n\\t\\tfor(int i=0;i<n;i++)\\n        {\\n            for (int j = 0; j < n; j++) {\\n                \\n                if(i-1 >= 0) arr[i][j] += arr[i-1][j];\\n                if(j-1 >= 0) arr[i][j] += arr[i][j-1];\\n                if(i-1>=0 && j-1>=0) arr[i][j] -= arr[i-1][j-1];\\n            }\\n        }\\n\\t\\t\\n        \\n        return arr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3054242,
                "title": "prefix-sum-c-easiest-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n        vector<vector<int>> temp(n+2,vector<int>(n+2,0));\\n        int k = queries.size();\\n        for(int i=0 ;i < k ;i++)\\n        {\\n            int x1 = queries[i][0];\\n            int y1 = queries[i][1];\\n            int x2 = queries[i][2];\\n            int y2 = queries[i][3];\\n            temp[x1+1][y1+1] += 1;\\n            temp[x1+1][y2+2] += -1;\\n            temp[x2+2][y1+1] += -1;\\n            temp[x2+2][y2+2] += 1;\\n        }\\n        for(int i=1;i<=n+1;i++)\\n        {\\n            for(int j=1;j<=n+1;j++)\\n            {\\n                temp[i][j] = temp[i][j] + temp[i-1][j] + temp[i][j-1] - temp[i-1][j-1];\\n            }\\n        }\\n        vector<vector<int>> ans(n,vector(n,0));\\n        for(int i= 1;i<=n;i++)\\n        {\\n            for(int j=1;j<=n;j++)\\n                ans[i-1][j-1] = temp[i][j];\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n        vector<vector<int>> temp(n+2,vector<int>(n+2,0));\\n        int k = queries.size();\\n        for(int i=0 ;i < k ;i++)\\n        {\\n            int x1 = queries[i][0];\\n            int y1 = queries[i][1];\\n            int x2 = queries[i][2];\\n            int y2 = queries[i][3];\\n            temp[x1+1][y1+1] += 1;\\n            temp[x1+1][y2+2] += -1;\\n            temp[x2+2][y1+1] += -1;\\n            temp[x2+2][y2+2] += 1;\\n        }\\n        for(int i=1;i<=n+1;i++)\\n        {\\n            for(int j=1;j<=n+1;j++)\\n            {\\n                temp[i][j] = temp[i][j] + temp[i-1][j] + temp[i][j-1] - temp[i-1][j-1];\\n            }\\n        }\\n        vector<vector<int>> ans(n,vector(n,0));\\n        for(int i= 1;i<=n;i++)\\n        {\\n            for(int j=1;j<=n;j++)\\n                ans[i-1][j-1] = temp[i][j];\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3052993,
                "title": "2-solutions-easy-approach-explained-with-example-time-space-complexity",
                "content": "### Do upvote\\uD83D\\uDD3C if it adds value !\\n\\n# Approach : \\n<!-- Describe your approach to solving the problem. -->\\n- consider a  1D array(with all zeroes) of size say 6(say n).\\nwe have queries to set all indexes to 1 for [0,3],[2,4] and [4,5] (index1 , index2) , what we could do is : \\n\\n- increment index1 by 1 and decrement index2+1( if <=n-1) by 1  \\n```\\n-> for [0,3] we have array as [1,0,0,0,-1,0]\\n-> Now [2,4] makes array as [1,0,1,0,-1,-1]\\n-> Now [4,5] makes array as [1,0,1,0,0,-1]\\n```\\n\\n\\n- Now perform operation array[i]+=array[i-1] for all  i (n-1>=i>0)\\n```\\nWe get our final array as [1,1,2,2,2,1] which is desired array .\\n```\\n\\n\\nApplying the same concept in 2D array in the below 2 solutions : )\\n\\n\\n \\n\\n# Complexity\\n#### \\u2714 Time complexity:O(n\\xD7(queries_length))+O(n\\xD7n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n#### \\u2714 Space complexity:O(n\\xD7n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code 1 :Applying the above 1D array concept row-wise \\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n        vector<vector<int>> ans(n,vector<int>(n,0));\\n        vector<int> row(n,0);\\n        vector<int> col(n,0);\\n        for(int i=0 ; i<queries.size() ; i++){\\n            for(int j=queries[i][0] ; j<=queries[i][2] ; j++){\\n                ans[j][queries[i][1]]+=1;\\n                if(queries[i][3]+1<n){\\n                    ans[j][queries[i][3]+1]-=1;\\n                }\\n            }\\n        }\\n        for(int i=0 ; i<n ; i++)\\n        {\\n            for(int j=1 ; j<n ; j++){\\n                ans[i][j]+=ans[i][j-1];\\n            }\\n        }   \\n        return ans;\\n    }\\n};\\n```\\n\\n# Code 2 : Applying the above 1D array concept column-wise\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n        vector<vector<int>> ans(n,vector<int>(n,0));\\n        vector<int> row(n,0);\\n        vector<int> col(n,0);\\n        for(int i=0 ; i<queries.size() ; i++){\\n            for(int j=queries[i][1] ; j<=queries[i][3] ; j++){\\n                ans[queries[i][0]][j]+=1;\\n                if(queries[i][2]+1<n){\\n                    ans[queries[i][2]+1][j]-=1;\\n                }\\n            }\\n        }\\n        for(int i=0 ; i<n ; i++)\\n        {\\n            for(int j=1 ; j<n ; j++){\\n                ans[j][i]+=ans[j-1][i];\\n            }\\n        }   \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n-> for [0,3] we have array as [1,0,0,0,-1,0]\\n-> Now [2,4] makes array as [1,0,1,0,-1,-1]\\n-> Now [4,5] makes array as [1,0,1,0,0,-1]\\n```\n```\\nWe get our final array as [1,1,2,2,2,1] which is desired array .\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n        vector<vector<int>> ans(n,vector<int>(n,0));\\n        vector<int> row(n,0);\\n        vector<int> col(n,0);\\n        for(int i=0 ; i<queries.size() ; i++){\\n            for(int j=queries[i][0] ; j<=queries[i][2] ; j++){\\n                ans[j][queries[i][1]]+=1;\\n                if(queries[i][3]+1<n){\\n                    ans[j][queries[i][3]+1]-=1;\\n                }\\n            }\\n        }\\n        for(int i=0 ; i<n ; i++)\\n        {\\n            for(int j=1 ; j<n ; j++){\\n                ans[i][j]+=ans[i][j-1];\\n            }\\n        }   \\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n        vector<vector<int>> ans(n,vector<int>(n,0));\\n        vector<int> row(n,0);\\n        vector<int> col(n,0);\\n        for(int i=0 ; i<queries.size() ; i++){\\n            for(int j=queries[i][1] ; j<=queries[i][3] ; j++){\\n                ans[queries[i][0]][j]+=1;\\n                if(queries[i][2]+1<n){\\n                    ans[queries[i][2]+1][j]-=1;\\n                }\\n            }\\n        }\\n        for(int i=0 ; i<n ; i++)\\n        {\\n            for(int j=1 ; j<n ; j++){\\n                ans[j][i]+=ans[j-1][i];\\n            }\\n        }   \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3052883,
                "title": "python3-prefix-sum-difference-array-accepted-solutions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUsing the difference array to solve the problem\\n# Approach\\nThe method is applying prefix sum to each row. we only need to mark the start and end position\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\n    O(N * N), because we are going through the entire matrix at the end\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1) if we do not count the output size\\n\\n# Code\\n```\\nclass Solution:\\n    def rangeAddQueries(self, n: int, queries: List[List[int]]) -> List[List[int]]:\\n        mat = [[0] * n for _ in range(n)]\\n        for row1, col1, row2, col2 in queries:\\n            for r in range(row1, row2 + 1):\\n                mat[r][col1] += 1\\n                if col2 + 1 < n:\\n                    mat[r][col2 + 1] -= 1\\n        for r in mat:\\n            for i in range(1, len(r)):\\n                r[i] += r[i - 1]\\n        return mat\\n            \\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def rangeAddQueries(self, n: int, queries: List[List[int]]) -> List[List[int]]:\\n        mat = [[0] * n for _ in range(n)]\\n        for row1, col1, row2, col2 in queries:\\n            for r in range(row1, row2 + 1):\\n                mat[r][col1] += 1\\n                if col2 + 1 < n:\\n                    mat[r][col2 + 1] -= 1\\n        for r in mat:\\n            for i in range(1, len(r)):\\n                r[i] += r[i - 1]\\n        return mat\\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3052660,
                "title": "java-c-javascript-prefix-matrix-beats-100-o-m-n-time-concise-and-clean-code",
                "content": "# Intuition\\nMaintaining a prefix matrix to store increments and decrements of size [n+1][n+1].\\n\\n\\n# Complexity\\n- Time complexity: O((m*n) + (n*n)) \\u2243 O(m*n) ,m=queries.length\\n\\n- Space complexity: O(n^2)\\n\\n# Code\\n``` java []\\nclass Solution {\\n    public int[][] rangeAddQueries(int n, int[][] queries) {\\n        int[][] prefix = new int[n+1][n+1];\\n        int[][] a = new int[n][n];\\n        for(int[] x:queries)\\n        {\\n            int r1 = x[0], r2 = x[2], c1 = x[1], c2 = x[3];\\n            for(int i=r1;i<=r2;i++){\\n                prefix[i][c1]++;\\n                prefix[i][c2+1]--;\\n            }\\n        }\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            int sum=0;\\n            for(int j=0;j<n;j++)\\n            {\\n                sum+=prefix[i][j];\\n                a[i][j]+=sum;\\n            }\\n        }\\n        \\n        return a;\\n    }\\n}\\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n        vector<vector<int>> prefix(n+1, vector<int>(n+1));\\n        vector<vector<int>> a(n, vector<int>(n));\\n        for(auto x:queries)\\n        {\\n            int r1 = x[0], r2 = x[2], c1 = x[1], c2 = x[3];\\n            for(int i=r1;i<=r2;i++){\\n                prefix[i][c1]++;\\n                prefix[i][c2+1]--;\\n            }\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            int sum=0;\\n            for(int j=0;j<n;j++)\\n            {\\n                sum+=prefix[i][j];\\n                a[i][j]+=sum;\\n            }\\n        }\\n        \\n        return a;\\n    }\\n};\\n```\\n``` javascript []\\nvar rangeAddQueries = function(n, queries) {\\n    let prefix = new Array(n+1).fill(0).map(() => new Array(n+1).fill(0));\\n    let a = new Array(n).fill(0).map(() => new Array(n).fill(0));\\n    for (let x of queries) {\\n        let r1 = x[0], c1 = x[1], r2 = x[2], c2 = x[3];\\n        for (let j = r1; j <= r2; j++) {\\n            prefix[j][c1]++;\\n            prefix[j][c2 + 1]--;\\n        }\\n    }\\n\\n    for (let i = 0; i < n; i++) {\\n        let sum = 0;\\n        for (let j = 0; j < n; j++) {\\n            sum += prefix[i][j];\\n            a[i][j] += sum;\\n        }\\n    }\\n    return a;\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "JavaScript",
                    "Prefix Sum"
                ],
                "code": "``` java []\\nclass Solution {\\n    public int[][] rangeAddQueries(int n, int[][] queries) {\\n        int[][] prefix = new int[n+1][n+1];\\n        int[][] a = new int[n][n];\\n        for(int[] x:queries)\\n        {\\n            int r1 = x[0], r2 = x[2], c1 = x[1], c2 = x[3];\\n            for(int i=r1;i<=r2;i++){\\n                prefix[i][c1]++;\\n                prefix[i][c2+1]--;\\n            }\\n        }\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            int sum=0;\\n            for(int j=0;j<n;j++)\\n            {\\n                sum+=prefix[i][j];\\n                a[i][j]+=sum;\\n            }\\n        }\\n        \\n        return a;\\n    }\\n}\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n        vector<vector<int>> prefix(n+1, vector<int>(n+1));\\n        vector<vector<int>> a(n, vector<int>(n));\\n        for(auto x:queries)\\n        {\\n            int r1 = x[0], r2 = x[2], c1 = x[1], c2 = x[3];\\n            for(int i=r1;i<=r2;i++){\\n                prefix[i][c1]++;\\n                prefix[i][c2+1]--;\\n            }\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            int sum=0;\\n            for(int j=0;j<n;j++)\\n            {\\n                sum+=prefix[i][j];\\n                a[i][j]+=sum;\\n            }\\n        }\\n        \\n        return a;\\n    }\\n};\\n```\n``` javascript []\\nvar rangeAddQueries = function(n, queries) {\\n    let prefix = new Array(n+1).fill(0).map(() => new Array(n+1).fill(0));\\n    let a = new Array(n).fill(0).map(() => new Array(n).fill(0));\\n    for (let x of queries) {\\n        let r1 = x[0], c1 = x[1], r2 = x[2], c2 = x[3];\\n        for (let j = r1; j <= r2; j++) {\\n            prefix[j][c1]++;\\n            prefix[j][c2 + 1]--;\\n        }\\n    }\\n\\n    for (let i = 0; i < n; i++) {\\n        let sum = 0;\\n        for (let j = 0; j < n; j++) {\\n            sum += prefix[i][j];\\n            a[i][j] += sum;\\n        }\\n    }\\n    return a;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3052599,
                "title": "python-brute-force-optimization",
                "content": "# Intution \\n- This problem is similar to [Array Manipulation](https://www.hackerrank.com/challenges/crush/problem) problem on hackerrank.\\n- We would manipulate each row of matrix and then calculate prefix sum.\\n-----------\\n- We would apply each wuery one by one and in each query we will go in each row one by one in the submatrix.\\n- For manipulation in each row instead of iterating through whole row we will update elements only at matrix[col_start, col_end+1].\\n- At last calculate prefix sum for each row.\\n\\n# Complexity\\n- Time complexity: O(n<sup>2</sup>)\\n- Space complexity: O(n<sup>2</sup>)\\n\\n# Code\\n```\\nclass Solution:\\n    def rangeAddQueries(self, n: int, queries: List[List[int]]) -> List[List[int]]:\\n        m = [[0]*n for i in range(n)]\\n        for q in queries:\\n            sr, sc, er, ec = q\\n            for i in range(sr, er+1):\\n                m[i][sc] += 1\\n                if ec+1 < n:\\n                    m[i][ec+1] -=1\\n        \\n        for i in range(n):\\n            for j in range(1, n):\\n                m[i][j] += m[i][j-1]\\n                \\n        return m\\n```\\n---------------\\n**Upvote the post if you find it helpful.\\nHappy coding.**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rangeAddQueries(self, n: int, queries: List[List[int]]) -> List[List[int]]:\\n        m = [[0]*n for i in range(n)]\\n        for q in queries:\\n            sr, sc, er, ec = q\\n            for i in range(sr, er+1):\\n                m[i][sc] += 1\\n                if ec+1 < n:\\n                    m[i][ec+1] -=1\\n        \\n        for i in range(n):\\n            for j in range(1, n):\\n                m[i][j] += m[i][j-1]\\n                \\n        return m\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3052577,
                "title": "easy-short-efficient-clean-code",
                "content": "```\\nclass Solution {\\n    typedef long long ll;\\n    #define vi(x) vector<x>\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n        vi(vi(ll))pre(n, vi(ll)(n)); // prefix\\n        for(const auto&q:queries){\\n            ll inc=q[1], dec=q[3]+1; // [inc, dec-1] range is marked to be increased\\n            for(ll r=q[0];r<=q[2];++r){\\n                pre[r][inc]+=1;\\n                if(dec<n){\\n                    pre[r][dec]-=1;\\n                }\\n            }\\n        }\\n        vi(vi(int))ans(n, vi(int)(n));\\n        for(ll r=0;r<n;++r){\\n            ll off=0; // offset\\n            for(ll c=0;c<n;++c){\\n                off+=pre[r][c];\\n                ans[r][c]=off;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    typedef long long ll;\\n    #define vi(x) vector<x>\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n        vi(vi(ll))pre(n, vi(ll)(n)); // prefix\\n        for(const auto&q:queries){\\n            ll inc=q[1], dec=q[3]+1; // [inc, dec-1] range is marked to be increased\\n            for(ll r=q[0];r<=q[2];++r){\\n                pre[r][inc]+=1;\\n                if(dec<n){\\n                    pre[r][dec]-=1;\\n                }\\n            }\\n        }\\n        vi(vi(int))ans(n, vi(int)(n));\\n        for(ll r=0;r<n;++r){\\n            ll off=0; // offset\\n            for(ll c=0;c<n;++c){\\n                off+=pre[r][c];\\n                ans[r][c]=off;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3052576,
                "title": "c-column-and-row-prefix-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    int size;\\n    void update(int a,int b,int x,int y,vector<vector<int>> &mat){\\n        mat[a][b] += 1;\\n        if(x+1<size){\\n            mat[x+1][b] -= 1;\\n        }\\n        if(x+1 < size && y+1 < size){\\n            mat[x+1][y+1] += 1;\\n        }\\n        if(y+1 < size){\\n            mat[a][y+1] -= 1;\\n        }\\n    }\\n    \\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n        vector<vector<int>> mat(n,vector<int>(n,0));\\n        size = n;\\n        for(auto i : queries){\\n            update(i[0],i[1],i[2],i[3],mat);\\n        }\\n        // column prefix sum\\n        for(int i=0;i<size;i++){\\n            for(int j=1;j<size;j++){\\n                mat[i][j] += mat[i][j-1];\\n            }\\n        }\\n        // row prefix sum\\n        for(int i=0;i<size;i++){\\n            for(int j=1;j<size;j++){\\n                mat[j][i] += mat[j-1][i];\\n            }\\n        }\\n        return mat;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int size;\\n    void update(int a,int b,int x,int y,vector<vector<int>> &mat){\\n        mat[a][b] += 1;\\n        if(x+1<size){\\n            mat[x+1][b] -= 1;\\n        }\\n        if(x+1 < size && y+1 < size){\\n            mat[x+1][y+1] += 1;\\n        }\\n        if(y+1 < size){\\n            mat[a][y+1] -= 1;\\n        }\\n    }\\n    \\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n        vector<vector<int>> mat(n,vector<int>(n,0));\\n        size = n;\\n        for(auto i : queries){\\n            update(i[0],i[1],i[2],i[3],mat);\\n        }\\n        // column prefix sum\\n        for(int i=0;i<size;i++){\\n            for(int j=1;j<size;j++){\\n                mat[i][j] += mat[i][j-1];\\n            }\\n        }\\n        // row prefix sum\\n        for(int i=0;i<size;i++){\\n            for(int j=1;j<size;j++){\\n                mat[j][i] += mat[j-1][i];\\n            }\\n        }\\n        return mat;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3762992,
                "title": "1-1-trick",
                "content": "# Intuition\\nif you want to increase array from [l,r] you can increase l by 1 and decrease r by 1 then take prefix sum of it;\\nin this case need to inc/dec by x so increse l by x and decrease r+1 by x\\nTo do so you have to create vector of size n+1 to take of bound(created by r+1 term)\\nthen simply take prefix sum and remove that n+1th term. \\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& q) {\\n        vector<vector<int>>ans(n+1,vector<int>(n+1,0));\\n        for(int i=0;i<q.size();i++){\\n            for(int j=q[i][0];j<=q[i][2];j++){\\n                ans[j][q[i][1]]++;\\n                ans[j][q[i][3]+1]--; \\n            }\\n        }\\n        ans.pop_back();\\n        for(int i=0;i<n;i++){\\n            ans[i].pop_back();\\n            for(int j=1;j<n;j++){\\n                ans[i][j]+=ans[i][j-1];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& q) {\\n        vector<vector<int>>ans(n+1,vector<int>(n+1,0));\\n        for(int i=0;i<q.size();i++){\\n            for(int j=q[i][0];j<=q[i][2];j++){\\n                ans[j][q[i][1]]++;\\n                ans[j][q[i][3]+1]--; \\n            }\\n        }\\n        ans.pop_back();\\n        for(int i=0;i<n;i++){\\n            ans[i].pop_back();\\n            for(int j=1;j<n;j++){\\n                ans[i][j]+=ans[i][j-1];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3404056,
                "title": "easy-to-understand-must-see",
                "content": "# Code\\n```\\nclass Solution \\n{\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) \\n    {\\n        vector<vector<int>>mat(n,vector<int>(n,0));\\n\\n        //preprocessing\\n        for(int i=0;i<queries.size();i++)\\n        {\\n            //row col  row col\\n            int startrow = queries[i][0];\\n            int endrow   = queries[i][2];\\n            \\n            int startcol = queries[i][1];\\n            int endcol   = queries[i][3];\\n\\n            for(int j=startrow;j<=endrow;j++)\\n            {\\n                mat[j][startcol]+=1;\\n            }\\n            if(endcol+1 < mat[0].size())\\n            {\\n               for(int j=startrow;j<=endrow;j++)\\n               {\\n                    mat[j][endcol+1]-=1;\\n               }   \\n            }\\n        }    \\n\\n        //linear accumulation\\n        for(int i=0;i<mat.size();i++)\\n        {\\n            for(int j=0;j<mat[i].size();j++)\\n            {\\n                if(j == 0)\\n                continue;\\n\\n                mat[i][j] = mat[i][j] + mat[i][j-1];\\n            }\\n        }\\n        return mat;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Matrix",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) \\n    {\\n        vector<vector<int>>mat(n,vector<int>(n,0));\\n\\n        //preprocessing\\n        for(int i=0;i<queries.size();i++)\\n        {\\n            //row col  row col\\n            int startrow = queries[i][0];\\n            int endrow   = queries[i][2];\\n            \\n            int startcol = queries[i][1];\\n            int endcol   = queries[i][3];\\n\\n            for(int j=startrow;j<=endrow;j++)\\n            {\\n                mat[j][startcol]+=1;\\n            }\\n            if(endcol+1 < mat[0].size())\\n            {\\n               for(int j=startrow;j<=endrow;j++)\\n               {\\n                    mat[j][endcol+1]-=1;\\n               }   \\n            }\\n        }    \\n\\n        //linear accumulation\\n        for(int i=0;i<mat.size();i++)\\n        {\\n            for(int j=0;j<mat[i].size();j++)\\n            {\\n                if(j == 0)\\n                continue;\\n\\n                mat[i][j] = mat[i][j] + mat[i][j-1];\\n            }\\n        }\\n        return mat;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3324809,
                "title": "prefix-sum-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n        vector<vector<int>> mat(n,vector<int>(n,0));\\n        for(auto &p : queries) {\\n            int x1 = p[0] ,y1 = p[1],x2 = p[2] ,y2 = p[3]; \\n            for(int i=x1;i<=x2;i++) {\\n                mat[i][y1]++;\\n                // if next column is out of matrix \\n                // mark the next row as negative\\n                if((y2+1) >= n) {\\n                    if(i+1 < n) mat[i+1][0] -= 1;\\n                    else continue;\\n                } else {\\n                    mat[i][y2+1] -= 1;\\n\\n                }\\n            }\\n        }   \\n        int temp = 0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++) {\\n                temp += mat[i][j];\\n                mat[i][j] = temp;\\n            }\\n        }\\n        return mat;\\n    }\\n};\\n```\\n# Please Upvote if like the solution",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n        vector<vector<int>> mat(n,vector<int>(n,0));\\n        for(auto &p : queries) {\\n            int x1 = p[0] ,y1 = p[1],x2 = p[2] ,y2 = p[3]; \\n            for(int i=x1;i<=x2;i++) {\\n                mat[i][y1]++;\\n                // if next column is out of matrix \\n                // mark the next row as negative\\n                if((y2+1) >= n) {\\n                    if(i+1 < n) mat[i+1][0] -= 1;\\n                    else continue;\\n                } else {\\n                    mat[i][y2+1] -= 1;\\n\\n                }\\n            }\\n        }   \\n        int temp = 0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++) {\\n                temp += mat[i][j];\\n                mat[i][j] = temp;\\n            }\\n        }\\n        return mat;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3316765,
                "title": "c-easy-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n        vector<vector<int>> mat(n,vector<int>(n,0));\\n        for(auto x : queries){\\n            int a = x[0],b = x[1],c = x[2],d = x[3];\\n            mat[a][b] += 1;\\n            if(d+1 < n) mat[a][d+1] -= 1;\\n            if(c+1 < n) mat[c+1][b] -= 1;\\n            if(c+1 < n && d+1 < n) mat[c+1][d+1] += 1;\\n        }\\n        for(int i = 0;i < n;i++){\\n            for(int j = 1;j < n;j++){\\n                mat[i][j] += mat[i][j-1];\\n            }\\n        }\\n        for(int j = 0;j < n;j++){\\n            for(int i = 1;i < n;i++){\\n                mat[i][j] += mat[i-1][j];\\n            }\\n        }\\n        return mat;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n        vector<vector<int>> mat(n,vector<int>(n,0));\\n        for(auto x : queries){\\n            int a = x[0],b = x[1],c = x[2],d = x[3];\\n            mat[a][b] += 1;\\n            if(d+1 < n) mat[a][d+1] -= 1;\\n            if(c+1 < n) mat[c+1][b] -= 1;\\n            if(c+1 < n && d+1 < n) mat[c+1][d+1] += 1;\\n        }\\n        for(int i = 0;i < n;i++){\\n            for(int j = 1;j < n;j++){\\n                mat[i][j] += mat[i][j-1];\\n            }\\n        }\\n        for(int j = 0;j < n;j++){\\n            for(int i = 1;i < n;i++){\\n                mat[i][j] += mat[i-1][j];\\n            }\\n        }\\n        return mat;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3185027,
                "title": "c-and-python-70-faster-code-prefix-sum-range-caching-behaviour",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nPrefix Sum\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n**C++ Solution:-**\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n        vector<vector<int>> mat(n, vector<int>(n,0));\\n        for(auto &it:queries) {\\n            int r1 = it[0];\\n            int c1 = it[1];\\n            int r2 = it[2];\\n            int c2 = it[3];\\n            for(int i=r1; i<=r2; i++) {\\n                mat[i][c1] += 1;\\n                if(c2+1<n) mat[i][c2+1] -= 1;\\n            }\\n        }\\n        for(int r=0; r<n; r++) {\\n            for(int c=1; c<n; c++) {\\n                mat[r][c] += mat[r][c-1];\\n            }\\n        }\\n        return mat;\\n    }\\n};\\n```\\n**Python Solution:-**\\n```\\nclass Solution:\\n    def rangeAddQueries(self, n: int, queries: List[List[int]]) -> List[List[int]]:\\n        mat = [[0]*n for _ in range(n)]\\n        for r1, c1, r2, c2 in queries:\\n            for r in range(r1, r2+1):\\n                mat[r][c1] += 1\\n                if c2+1 < n:\\n                    mat[r][c2+1] -= 1\\n        for row in range(n):\\n            for col in range(1, n):\\n                mat[row][col] += mat[row][col-1]\\n        return mat\\n```",
                "solutionTags": [
                    "C++",
                    "Python3",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n        vector<vector<int>> mat(n, vector<int>(n,0));\\n        for(auto &it:queries) {\\n            int r1 = it[0];\\n            int c1 = it[1];\\n            int r2 = it[2];\\n            int c2 = it[3];\\n            for(int i=r1; i<=r2; i++) {\\n                mat[i][c1] += 1;\\n                if(c2+1<n) mat[i][c2+1] -= 1;\\n            }\\n        }\\n        for(int r=0; r<n; r++) {\\n            for(int c=1; c<n; c++) {\\n                mat[r][c] += mat[r][c-1];\\n            }\\n        }\\n        return mat;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def rangeAddQueries(self, n: int, queries: List[List[int]]) -> List[List[int]]:\\n        mat = [[0]*n for _ in range(n)]\\n        for r1, c1, r2, c2 in queries:\\n            for r in range(r1, r2+1):\\n                mat[r][c1] += 1\\n                if c2+1 < n:\\n                    mat[r][c2+1] -= 1\\n        for row in range(n):\\n            for col in range(1, n):\\n                mat[row][col] += mat[row][col-1]\\n        return mat\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3093757,
                "title": "easy-c-using-prefix-sum-well-explained-and-commented",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1) Start with the range (l,r) as given in queries.\\n2) Increment l++ and decrement r--.\\n3) Now, when we will take prefix sum, then all elements in range of (l,r) will be converted, except the last column.\\n4) Then pop the last column by removing the elements of last column.\\n\\n# Complexity\\n- Time complexity : O(n^2)\\n- Space complexity : O(n^2) \\n- Extra Space complexity : O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& q) {\\n        int m=q.size();\\n        int i1,j1,i2,j2;\\n        vector<vector<int>> ans(n, vector<int>(n+1));\\n\\n        for(int i=0; i<m; i++){\\n            //finding the range i.e. (l,r)\\n            i1=q[i][0];\\n            j1=q[i][1];\\n            i2=q[i][2];\\n            j2=q[i][3];\\n            //we are starting with a range (l,r)\\n            //queries is a range given in form of (l,r)\\n            //so method is: l=1 and r+1=-1\\n            //when we take prefix sum, the elements in range will be added with 1 giving the desired result\\n            for(int row=i1; row<=i2; row++){\\n                ans[row][j1]++;\\n                ans[row][j2+1]--;\\n            }\\n        }\\n\\n        //prefix sum for whole matrix in each row\\n        for(int i=0; i<n; i++){\\n            for(int j=1; j<n; j++){\\n                //adding j-1 to sum, so start j with 1\\n                ans[i][j]+=ans[i][j-1];\\n            }\\n            \\n            ans[i].pop_back(); //pop the elements of last row for n*n matrix\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& q) {\\n        int m=q.size();\\n        int i1,j1,i2,j2;\\n        vector<vector<int>> ans(n, vector<int>(n+1));\\n\\n        for(int i=0; i<m; i++){\\n            //finding the range i.e. (l,r)\\n            i1=q[i][0];\\n            j1=q[i][1];\\n            i2=q[i][2];\\n            j2=q[i][3];\\n            //we are starting with a range (l,r)\\n            //queries is a range given in form of (l,r)\\n            //so method is: l=1 and r+1=-1\\n            //when we take prefix sum, the elements in range will be added with 1 giving the desired result\\n            for(int row=i1; row<=i2; row++){\\n                ans[row][j1]++;\\n                ans[row][j2+1]--;\\n            }\\n        }\\n\\n        //prefix sum for whole matrix in each row\\n        for(int i=0; i<n; i++){\\n            for(int j=1; j<n; j++){\\n                //adding j-1 to sum, so start j with 1\\n                ans[i][j]+=ans[i][j-1];\\n            }\\n            \\n            ans[i].pop_back(); //pop the elements of last row for n*n matrix\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3087499,
                "title": "c-o-n-2-clean-code",
                "content": "```c++\\nclass Solution {\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n        vector<vector<int>> res(n + 1, vector<int>(n + 1, 0));\\n        for (auto query: queries) {\\n            auto x = query[0], y = query[1], toX = query[2], toY = query[3];\\n            res[x][y]++, res[x][toY + 1]--, res[toX + 1][y]--, res[toX + 1][toY + 1]++;\\n        }\\n        for (int i = 0; i < n; i++) \\n            for (int j = 0; j < n; j++) {\\n                if (i) res[i][j] += res[i-1][j];\\n                if (j) res[i][j] += res[i][j-1];\\n                if (i && j) res[i][j] -= res[i-1][j-1];\\n            }\\n        res.pop_back();\\n        for (auto &row: res) row.pop_back();\\n        return res;\\n    }\\n};\\n```\\n\\n**For more solutions, check out this \\uD83C\\uDFC6  [GITHUB REPOSITORY](https://github.com/MuhtasimTanmoy/playground) with over 1500+ solutions.**",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n        vector<vector<int>> res(n + 1, vector<int>(n + 1, 0));\\n        for (auto query: queries) {\\n            auto x = query[0], y = query[1], toX = query[2], toY = query[3];\\n            res[x][y]++, res[x][toY + 1]--, res[toX + 1][y]--, res[toX + 1][toY + 1]++;\\n        }\\n        for (int i = 0; i < n; i++) \\n            for (int j = 0; j < n; j++) {\\n                if (i) res[i][j] += res[i-1][j];\\n                if (j) res[i][j] += res[i][j-1];\\n                if (i && j) res[i][j] -= res[i-1][j-1];\\n            }\\n        res.pop_back();\\n        for (auto &row: res) row.pop_back();\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3079051,
                "title": "python-evolving-linear-time-sweep-3-approaches-the-best",
                "content": "# Intuition\\nApproach 1: Sort the queries, then for each result row scan the queries and maintain a min-heap of query right columns. This puts the solution in slowest 5%, narrowly avoiding TLE.\\n\\nApproach 2: Get rid of sorting and min-heap, and instead scan the queries for each row, adding $$1$$ at left column and $$-1$$ after right column. Then, recreate the result of previous approach by scanning each row. This puts the solution at roughly top 33%\\u201350% running time.\\n\\nApproach 3: Instead of scanning queries per row, scan them once, adding $$1$$ at first row and $$-1$$ below last row. Then, recreate the prerequisites of previous approach by scanning each column. This puts the solution at top 5% running time.\\n\\nFinal variation: Compactify code lines a bit at some expense of running time. :)\\n\\nThe Best!\\n\\n# Complexity\\n- Time complexity: $$O(n^2+m)$$\\n- Space complexity: $$O(1)$$ extra space\\n\\n# Code\\nApproach 1: $$O(n^2+nm\\\\log m)$$ / $$O(m)$$\\n```py\\ndef rangeAddQueries(self, n: int, queries: list[list[int]]) -> list[list[int]]:\\n    queries.sort(key=lambda q: q[1])\\n    res, qlen = [[0]*n for row in range(n)], len(queries)\\n    for row in range(n):\\n        ends, qidx = [], 0\\n        for col in range(n):\\n            while qidx < qlen and col == queries[qidx][1]:\\n                (r1, c1, r2, c2), qidx = queries[qidx], qidx+1\\n                if r1 <= row <= r2:\\n                    heapq.heappush(ends, c2)\\n            while ends and col > ends[0]:\\n                heapq.heappop(ends)\\n            res[row][col] = len(ends)\\n    return res\\n```\\n\\nApproach 2: $$O(n^2 + nm)$$ / $$O(1)$$\\n```py\\ndef rangeAddQueries(self, n: int, queries: list[list[int]]) -> list[list[int]]:\\n    res = [[0]*n for row in range(n)]\\n    for r1, c1, r2, c2 in queries:\\n        for row in range(r1, r2+1):\\n            res[row][c1] += 1\\n        if c2 != n-1:\\n            for row in range(r1, r2+1):\\n                res[row][c2+1] -= 1\\n    for row in range(n):\\n        ins = 0\\n        for col in range(n):\\n            res[row][col] = ins = ins + res[row][col]\\n    return res\\n```\\n\\nApproach 3: $$O(n^2+m)$$ / $$O(1)$$\\n```py\\ndef rangeAddQueries(self, n: int, queries: list[list[int]]) -> list[list[int]]:\\n    res = [[0]*n for row in range(n)]\\n    for r1, c1, r2, c2 in queries:\\n        res[r1][c1] += 1\\n        if c2 != n-1:\\n            res[r1][c2+1] -= 1\\n        if r2 != n-1:\\n            res[r2+1][c1] -= 1\\n            if c2 != n-1:\\n                res[r2+1][c2+1] += 1\\n    for row in range(n):\\n        for col in range(n):\\n            res[row][col] += res[row-1][col] if row else 0\\n    for row in range(n):\\n        for col in range(n):\\n            res[row][col] += res[row][col-1] if col else 0\\n    return res\\n```\\n\\nFinal variation: $$O(n^2+m)$$ / $$O(1)$$\\n```py\\ndef rangeAddQueries(self, n: int, queries: list[list[int]]) -> list[list[int]]:\\n    res = [[0]*n for row in range(n)]\\n    for r1, c1, r2, c2 in queries:\\n        res[r1][c1] += 1\\n        res[r1][min(c2+1, n-1)] -= c2 != n-1\\n        res[min(r2+1, n-1)][c1] -= r2 != n-1\\n        res[min(r2+1, n-1)][min(c2+1, n-1)] += max(r2, c2) != n-1\\n    for row in range(n):\\n        for col in range(n):\\n            res[row][col] += res[row-1][col] if row else 0\\n    for row in range(n):\\n        for col in range(n):\\n            res[row][col] += res[row][col-1] if col else 0\\n    return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```py\\ndef rangeAddQueries(self, n: int, queries: list[list[int]]) -> list[list[int]]:\\n    queries.sort(key=lambda q: q[1])\\n    res, qlen = [[0]*n for row in range(n)], len(queries)\\n    for row in range(n):\\n        ends, qidx = [], 0\\n        for col in range(n):\\n            while qidx < qlen and col == queries[qidx][1]:\\n                (r1, c1, r2, c2), qidx = queries[qidx], qidx+1\\n                if r1 <= row <= r2:\\n                    heapq.heappush(ends, c2)\\n            while ends and col > ends[0]:\\n                heapq.heappop(ends)\\n            res[row][col] = len(ends)\\n    return res\\n```\n```py\\ndef rangeAddQueries(self, n: int, queries: list[list[int]]) -> list[list[int]]:\\n    res = [[0]*n for row in range(n)]\\n    for r1, c1, r2, c2 in queries:\\n        for row in range(r1, r2+1):\\n            res[row][c1] += 1\\n        if c2 != n-1:\\n            for row in range(r1, r2+1):\\n                res[row][c2+1] -= 1\\n    for row in range(n):\\n        ins = 0\\n        for col in range(n):\\n            res[row][col] = ins = ins + res[row][col]\\n    return res\\n```\n```py\\ndef rangeAddQueries(self, n: int, queries: list[list[int]]) -> list[list[int]]:\\n    res = [[0]*n for row in range(n)]\\n    for r1, c1, r2, c2 in queries:\\n        res[r1][c1] += 1\\n        if c2 != n-1:\\n            res[r1][c2+1] -= 1\\n        if r2 != n-1:\\n            res[r2+1][c1] -= 1\\n            if c2 != n-1:\\n                res[r2+1][c2+1] += 1\\n    for row in range(n):\\n        for col in range(n):\\n            res[row][col] += res[row-1][col] if row else 0\\n    for row in range(n):\\n        for col in range(n):\\n            res[row][col] += res[row][col-1] if col else 0\\n    return res\\n```\n```py\\ndef rangeAddQueries(self, n: int, queries: list[list[int]]) -> list[list[int]]:\\n    res = [[0]*n for row in range(n)]\\n    for r1, c1, r2, c2 in queries:\\n        res[r1][c1] += 1\\n        res[r1][min(c2+1, n-1)] -= c2 != n-1\\n        res[min(r2+1, n-1)][c1] -= r2 != n-1\\n        res[min(r2+1, n-1)][min(c2+1, n-1)] += max(r2, c2) != n-1\\n    for row in range(n):\\n        for col in range(n):\\n            res[row][col] += res[row-1][col] if row else 0\\n    for row in range(n):\\n        for col in range(n):\\n            res[row][col] += res[row][col-1] if col else 0\\n    return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3061558,
                "title": "c-easy-fast",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n        vector<vector<int>> mat(n, vector<int>(n, 0));\\n        \\n        for (auto q : queries) {\\n            int r1 = q[0], c1 = q[1], r2 = q[2], c2 = q[3];\\n            \\n            mat[r1][c1] += 1;\\n            if(r2 + 1 < n && c2 + 1 < n) mat[r2 + 1][c2 + 1] += 1;\\n            if(r2 + 1< n) mat[r2 + 1][c1] -= 1;\\n            if(c2 + 1 < n) mat[r1][c2 + 1] -= 1;\\n        }\\n        \\n        for(int i=0; i<n; i++) {\\n            for (int j=1; j<n; j++) {\\n                mat[i][j] += mat[i][j - 1];\\n            }\\n        }\\n        for(int i=1; i<n; i++) {\\n            for (int j=0; j<n; j++) {\\n                mat[i][j] += mat[i - 1][j];\\n            }\\n        }\\n        return mat;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n        vector<vector<int>> mat(n, vector<int>(n, 0));\\n        \\n        for (auto q : queries) {\\n            int r1 = q[0], c1 = q[1], r2 = q[2], c2 = q[3];\\n            \\n            mat[r1][c1] += 1;\\n            if(r2 + 1 < n && c2 + 1 < n) mat[r2 + 1][c2 + 1] += 1;\\n            if(r2 + 1< n) mat[r2 + 1][c1] -= 1;\\n            if(c2 + 1 < n) mat[r1][c2 + 1] -= 1;\\n        }\\n        \\n        for(int i=0; i<n; i++) {\\n            for (int j=1; j<n; j++) {\\n                mat[i][j] += mat[i][j - 1];\\n            }\\n        }\\n        for(int i=1; i<n; i++) {\\n            for (int j=0; j<n; j++) {\\n                mat[i][j] += mat[i - 1][j];\\n            }\\n        }\\n        return mat;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3057579,
                "title": "prefix-sum-approach-beats-100-submissions-java-intuitive",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nPREFIX SUM APPROACH IMPLEMENTED FOR EACH QUERY WHICH DRASTICALLY REDUCES THE TC.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBRUTE FORCE APPROACH WONT WORK FOR C++ SUNMISSIONS . SO GO AHEAD WITH THIS PREFIX SUM APPROACH WHICH IS MUCH FASTER. IMPLEMENT THE PREFIX SUM CALCULATION FOR EACH QUERY THEN FORM THE FINAL 2D MATRIX BY ADDING THE CONTENT OF EACH ROW WHICH FINALLY FORMS THE ARRAY.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(q*N) + O(N^2)\\n\\nMUCH FASTER THAN BRUTE FORCE !\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nN*N MATRX IS ALL YOU NEED!\\n\\n# Code\\n```\\nclass Solution {\\n   public int[][] rangeAddQueries(int n, int[][] queries) {\\n   int[][] ans = new int[n][n];\\n   for (int[] q : queries) {\\n       int row1 = q[0], col1 = q[1], row2 = q[2], col2 = q[3];\\n       for (int i = row1; i <= row2; i++) \\n       {\\n           ans[i][col1] +=1; //MARK THE BEGINNING OF QUERY WITH +1\\n           if ((col2 +1) < n ) //CHECK IF THE POSITION LIES WITHIN THAT COL IN THE ARRAY\\n           {\\n               ans[i][col2 +1] -=1; //IF THE POS EXISTS, MARK IT WITH -1 ... DRY RUN IT FOR BETTER UNDERSTANDING.\\n           }\\n        }\\n    }\\n    for(int i=0;i<n;i++)\\n    {\\n        for(int j=1;j<n;j++)\\n        {\\n            ans[i][j] += ans[i][j-1]; //FINALLY TRAVERSE THE ARRAY AND ADD THE CONTENT OF EACH ROW IN IT.\\n        }\\n    }\\n   return ans;\\n   }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n   public int[][] rangeAddQueries(int n, int[][] queries) {\\n   int[][] ans = new int[n][n];\\n   for (int[] q : queries) {\\n       int row1 = q[0], col1 = q[1], row2 = q[2], col2 = q[3];\\n       for (int i = row1; i <= row2; i++) \\n       {\\n           ans[i][col1] +=1; //MARK THE BEGINNING OF QUERY WITH +1\\n           if ((col2 +1) < n ) //CHECK IF THE POSITION LIES WITHIN THAT COL IN THE ARRAY\\n           {\\n               ans[i][col2 +1] -=1; //IF THE POS EXISTS, MARK IT WITH -1 ... DRY RUN IT FOR BETTER UNDERSTANDING.\\n           }\\n        }\\n    }\\n    for(int i=0;i<n;i++)\\n    {\\n        for(int j=1;j<n;j++)\\n        {\\n            ans[i][j] += ans[i][j-1]; //FINALLY TRAVERSE THE ARRAY AND ADD THE CONTENT OF EACH ROW IN IT.\\n        }\\n    }\\n   return ans;\\n   }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3057193,
                "title": "java-easy",
                "content": "```\\nclass Solution {\\n    public int[][] rangeAddQueries(int n, int[][] queries) {\\n        int[][] ans = new int[n][n];\\n        int q = queries.length;\\n        int i = 0,j=0,h=0;\\n        for(i=0;i<q;i++){\\n            int r1 = queries[i][0], c1 = queries[i][1], r2 = queries[i][2], c2 = queries[i][3];\\n            for(j=r1;j<=r2;j++)\\n                for(h=c1;h<=c2;h++)\\n                    ans[j][h]++;\\n            \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] rangeAddQueries(int n, int[][] queries) {\\n        int[][] ans = new int[n][n];\\n        int q = queries.length;\\n        int i = 0,j=0,h=0;\\n        for(i=0;i<q;i++){\\n            int r1 = queries[i][0], c1 = queries[i][1], r2 = queries[i][2], c2 = queries[i][3];\\n            for(j=r1;j<=r2;j++)\\n                for(h=c1;h<=c2;h++)\\n                    ans[j][h]++;\\n            \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3056979,
                "title": "simple-python-solution-faster-than-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def rangeAddQueries(self, n: int, queries: List[List[int]]) -> List[List[int]]:\\n        grid = [[0]*n for _ in range(n)]\\n                \\n        for row1,col1, row2, col2 in queries:\\n            grid[row1][col1] += 1\\n\\n            if row2+ 1< n:\\n                grid[row2+1][col1] -= 1\\n            if col2 + 1 < n:\\n                grid[row1][col2+1] -= 1\\n\\n            if row2 + 1 < n and col2 + 1< n:\\n                grid[row2+1][col2+1] += 1\\n\\n        for i in range(1,n):\\n            for j in range(n):\\n                grid[i][j] += grid[i-1][j]\\n        for i in range(n):\\n            for j in range(1,n):\\n                grid[i][j] += grid[i][j-1]\\n        return grid\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rangeAddQueries(self, n: int, queries: List[List[int]]) -> List[List[int]]:\\n        grid = [[0]*n for _ in range(n)]\\n                \\n        for row1,col1, row2, col2 in queries:\\n            grid[row1][col1] += 1\\n\\n            if row2+ 1< n:\\n                grid[row2+1][col1] -= 1\\n            if col2 + 1 < n:\\n                grid[row1][col2+1] -= 1\\n\\n            if row2 + 1 < n and col2 + 1< n:\\n                grid[row2+1][col2+1] += 1\\n\\n        for i in range(1,n):\\n            for j in range(n):\\n                grid[i][j] += grid[i-1][j]\\n        for i in range(n):\\n            for j in range(1,n):\\n                grid[i][j] += grid[i][j-1]\\n        return grid\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3056680,
                "title": "simple-bruteforce-works-on-array-not-on-vector-c",
                "content": "# Intuition\\nIf we do bruteforce on array, it gets accepted but if we do the same on vector, we get TLE.\\n\\n\\n# Complexity\\n- Time complexity: O(qn^2)\\n\\n- Space complexity: O(n^2)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n        int v[n][n];\\n        for(int i=0;i<n;++i){\\n            for(int j=0;j<n;++j){\\n                v[i][j]=0;\\n            }\\n        }\\n        int m=queries.size();\\n        for(int i=0;i<m;++i){\\n            int ub=queries[i][0],lb=queries[i][1],lob=queries[i][2],rb=queries[i][3];\\n            for(int j=ub;j<=lob;++j){\\n                for(int k=lb;k<=rb;++k){\\n                    v[j][k]+=1;\\n                }\\n            }\\n        }\\n        vector<vector<int>> ans(n,vector<int>(n,0));\\n        for(int i=0;i<n;++i){\\n            for(int j=0;j<n;++j){\\n                ans[i][j]=v[i][j];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n        int v[n][n];\\n        for(int i=0;i<n;++i){\\n            for(int j=0;j<n;++j){\\n                v[i][j]=0;\\n            }\\n        }\\n        int m=queries.size();\\n        for(int i=0;i<m;++i){\\n            int ub=queries[i][0],lb=queries[i][1],lob=queries[i][2],rb=queries[i][3];\\n            for(int j=ub;j<=lob;++j){\\n                for(int k=lb;k<=rb;++k){\\n                    v[j][k]+=1;\\n                }\\n            }\\n        }\\n        vector<vector<int>> ans(n,vector<int>(n,0));\\n        for(int i=0;i<n;++i){\\n            for(int j=0;j<n;++j){\\n                ans[i][j]=v[i][j];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3054769,
                "title": "explained-step-by-step-1d-prefix-sum-approach-simple-and-easy-to-understand",
                "content": "```\\n// How do we add a number in a 1D array for range i to j?\\n// We increase arr[i] by X and decrease arr[j+1] by X\\n// Why do we do so?\\n// We do so because when we sum the array from (i+1) till j then elements in the range i to j is increased and arr[j+1] becomes neuteral hence array from range i to j is increased by x\\n// For Ex:- \\n// arr[] = {0, 0, 0, 0, 0, 0}\\n// increase the array by X for range 1 to 3\\n// add arr[1] by X and subtract arr[4] by X\\n// arr[] = {0, X, 0, 0, -X, 0}\\n// after performing sum arr[] = {0, X, X, X, 0, 0}\\n\\n// We will be using the same approach for each row starting from row1 to row2 for each query in queries\\n// We will perform sum row-wise to increase the matrix\\n// finally, return the matrix\\n\\nclass Solution {\\n    public int[][] rangeAddQueries(int n, int[][] queries) {\\n        \\n        int[][] mat = new int[n][n];\\n        \\n        for(int[] query : queries) {\\n            \\n            int row1 = query[0], col1 = query[1], row2 = query[2], col2 = query[3];\\n            \\n            while(row1 <= row2) {\\n                mat[row1][col1]++;\\n                if(col2 + 1 < n) {\\n                    mat[row1][col2+1]--;\\n                }\\n                ++row1;\\n            }\\n        }\\n        \\n        for(int i = 0; i < n; i++) {\\n            for(int j = 1; j < n; j++) {\\n                mat[i][j] += mat[i][j-1];\\n            }\\n        }\\n        \\n        return mat;\\n    }\\n}\\n```\\n**Please upvote\\uD83D\\uDC4D if you find it useful**",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\n// How do we add a number in a 1D array for range i to j?\\n// We increase arr[i] by X and decrease arr[j+1] by X\\n// Why do we do so?\\n// We do so because when we sum the array from (i+1) till j then elements in the range i to j is increased and arr[j+1] becomes neuteral hence array from range i to j is increased by x\\n// For Ex:- \\n// arr[] = {0, 0, 0, 0, 0, 0}\\n// increase the array by X for range 1 to 3\\n// add arr[1] by X and subtract arr[4] by X\\n// arr[] = {0, X, 0, 0, -X, 0}\\n// after performing sum arr[] = {0, X, X, X, 0, 0}\\n\\n// We will be using the same approach for each row starting from row1 to row2 for each query in queries\\n// We will perform sum row-wise to increase the matrix\\n// finally, return the matrix\\n\\nclass Solution {\\n    public int[][] rangeAddQueries(int n, int[][] queries) {\\n        \\n        int[][] mat = new int[n][n];\\n        \\n        for(int[] query : queries) {\\n            \\n            int row1 = query[0], col1 = query[1], row2 = query[2], col2 = query[3];\\n            \\n            while(row1 <= row2) {\\n                mat[row1][col1]++;\\n                if(col2 + 1 < n) {\\n                    mat[row1][col2+1]--;\\n                }\\n                ++row1;\\n            }\\n        }\\n        \\n        for(int i = 0; i < n; i++) {\\n            for(int j = 1; j < n; j++) {\\n                mat[i][j] += mat[i][j-1];\\n            }\\n        }\\n        \\n        return mat;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3054761,
                "title": "java-easy-simple",
                "content": "\\tclass Solution {\\n\\t\\tpublic int[][] rangeAddQueries(int n, int[][] q) {\\n\\t\\t\\tint[][] mat = new int[n][n];\\n\\t\\t\\tfor(int[] arr:q){\\n\\t\\t\\t\\tint row1=arr[0],col1=arr[1], row2=arr[2],col2=arr[3];\\n\\t\\t\\t\\tfor(int i=row1;i<=row2 && i<n;i++){\\n\\t\\t\\t\\t\\tfor(int j=col1;j<=col2 && j<n;j++){\\n\\t\\t\\t\\t\\t\\tmat[i][j]+=1;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn mat;\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Java",
                    "Matrix"
                ],
                "code": "class Solution {\\n\\t\\tpublic int[][] rangeAddQueries(int n, int[][] q) {\\n\\t\\t\\tint[][] mat = new int[n][n];\\n\\t\\t\\tfor(int[] arr:q){\\n\\t\\t\\t\\tint row1=arr[0],col1=arr[1], row2=arr[2],col2=arr[3];\\n\\t\\t\\t\\tfor(int i=row1;i<=row2 && i<n;i++){\\n\\t\\t\\t\\t\\tfor(int j=col1;j<=col2 && j<n;j++){\\n\\t\\t\\t\\t\\t\\tmat[i][j]+=1;\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3054690,
                "title": "c-simple-and-most-easy-solution-with-explanation",
                "content": "**Using Scanline Algorithm**\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n        vector<vector<int>> mat(n,vector<int>(n,0));\\n        for(int i=0;i<queries.size();i++)\\n        {\\n            int rs=queries[i][0];\\n            int cs=queries[i][1];\\n            int re=queries[i][2];\\n            int ce=queries[i][3];\\n            for(int j=rs;j<=re;j++)\\n            {\\n                mat[j][cs]+=1;//doing +1 to start column for each row\\n                if(ce<n-1)\\n                    mat[j][ce+1]-=1;//doing -1 to endcolumn+1  for each row \\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=1;j<n;j++)\\n            {\\n                mat[i][j]+=mat[i][j-1];//generating prefix sum of each row\\n            }\\n        }\\n        return mat;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n        vector<vector<int>> mat(n,vector<int>(n,0));\\n        for(int i=0;i<queries.size();i++)\\n        {\\n            int rs=queries[i][0];\\n            int cs=queries[i][1];\\n            int re=queries[i][2];\\n            int ce=queries[i][3];\\n            for(int j=rs;j<=re;j++)\\n            {\\n                mat[j][cs]+=1;//doing +1 to start column for each row\\n                if(ce<n-1)\\n                    mat[j][ce+1]-=1;//doing -1 to endcolumn+1  for each row \\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=1;j<n;j++)\\n            {\\n                mat[i][j]+=mat[i][j-1];//generating prefix sum of each row\\n            }\\n        }\\n        return mat;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3054418,
                "title": "hindi-version-c-easy-approach",
                "content": "The post is in hindi because there are very less post explaning approach in HINDI.\\n# Approach\\nSirf itni baat yaad rakho ki har query mein starting row se ending row tak ke starting and ending column ko mark karna hai taaki whole matrix ko ek baar mein fill kar sake. Har query ka last column agar nth column nahi hai toh uske next column par -1 ko mark kardenge taaki ye paata chal jaaye ki yahan ek query finish ho rahi hai. Baaki ek example ko pick karo and uspar dry run karo code ke saath saath and comments provided hai code mein.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(queries*n) + O(n*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n*n) for result vector\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n        vector<vector<int>>res(n,vector<int>(n,0));\\n        res.resize(n,vector<int>(n,0));\\n        int m = queries.size();\\n        // Ye loop ki time Complexity hogi : O(queries*n)\\n        for(int i=0;i<m;i++)\\n        {\\n            // ye starting row ka position hai\\n            int rowS = queries[i][0];\\n            // ye starting column ka position hai\\n            int colS = queries[i][1];\\n            // ye ending row ka position hai\\n            int rowE = queries[i][2];\\n            // ye ending column ka position hai\\n            int colE = queries[i][3];\\n            // ab hum yahan har row ke liye uski starting and ending position mark kar rahe hai ki bhai is row ke is index tak 1 put karna hai\\n            for(int j=rowS;j<=rowE;j++)\\n            {\\n                res[j][colS]++;\\n                // ye condition ye bata degi ki kahan par stop karna hai ek given query ke liye toh hum us point par -1 mark kar denge\\n                if((colE+1)!=n)\\n                {\\n                    res[j][colE+1]--;\\n                }\\n            }\\n        }\\n        // ye loop ki time complexity hogi O(n*n)\\n        // ab hum prefix sum waale concept ka istemal karke pura matrix fill karlenge\\n        for(int i = 0; i < n; i++)\\n            for(int j = 1; j < n; j++)\\n            // columns ke through traverse karke matrix mein previous value ko add karte jaa rahe hai\\n                res[i][j] += res[i][j-1];\\n        return res;\\n    }\\n};\\n```\\nAgar post read karke help mili ho toh please upvote karna!!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n        vector<vector<int>>res(n,vector<int>(n,0));\\n        res.resize(n,vector<int>(n,0));\\n        int m = queries.size();\\n        // Ye loop ki time Complexity hogi : O(queries*n)\\n        for(int i=0;i<m;i++)\\n        {\\n            // ye starting row ka position hai\\n            int rowS = queries[i][0];\\n            // ye starting column ka position hai\\n            int colS = queries[i][1];\\n            // ye ending row ka position hai\\n            int rowE = queries[i][2];\\n            // ye ending column ka position hai\\n            int colE = queries[i][3];\\n            // ab hum yahan har row ke liye uski starting and ending position mark kar rahe hai ki bhai is row ke is index tak 1 put karna hai\\n            for(int j=rowS;j<=rowE;j++)\\n            {\\n                res[j][colS]++;\\n                // ye condition ye bata degi ki kahan par stop karna hai ek given query ke liye toh hum us point par -1 mark kar denge\\n                if((colE+1)!=n)\\n                {\\n                    res[j][colE+1]--;\\n                }\\n            }\\n        }\\n        // ye loop ki time complexity hogi O(n*n)\\n        // ab hum prefix sum waale concept ka istemal karke pura matrix fill karlenge\\n        for(int i = 0; i < n; i++)\\n            for(int j = 1; j < n; j++)\\n            // columns ke through traverse karke matrix mein previous value ko add karte jaa rahe hai\\n                res[i][j] += res[i][j-1];\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3054372,
                "title": "2536-java-1-approach",
                "content": "\\n# Approach 1\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Runtime : 1072 ms\\n- Beats : 8.33%\\n- Memory : 50.3 MB\\n- Beats : 100%\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] rangeAddQueries(int n, int[][] queries) {\\n        int arr[][] = new int[n][n];\\n        for(int i[] : queries){\\n            while(i[0] <= i[2]){\\n                int col = i[1];\\n                while(col <= i[3]){\\n                    arr[i[0]][col]++;\\n                    col++;\\n                }\\n                i[0]++;\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] rangeAddQueries(int n, int[][] queries) {\\n        int arr[][] = new int[n][n];\\n        for(int i[] : queries){\\n            while(i[0] <= i[2]){\\n                int col = i[1];\\n                while(col <= i[3]){\\n                    arr[i[0]][col]++;\\n                    col++;\\n                }\\n                i[0]++;\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3053814,
                "title": "easy-understand-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> v(n*n+1);\\n        int x,y,z,k;\\n        for(auto &i: queries){\\n            z = i[2]-i[0]+1;\\n            k = 0;\\n            while(z--){\\n            x = (i[0]+k)*n+i[1],y = (i[0]+k)*n+i[3]+1;\\n                k++;\\n            v[x]++;v[y]--;\\n            }\\n        }\\n        for(int i = 1; i<= n*n; i++){\\n            v[i] = v[i-1]+v[i];\\n        }\\n        vector<vector<int>> ans(n,vector<int>(n));\\n        for(x = 0; x < n; x++){\\n            for(y = 0; y < n; y++){\\n                ans[x][y] = v[x*n+y];\\n            }\\n        }\\n        return ans;\\n    }\\n};```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Dynamic Programming",
                    "Matrix",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> v(n*n+1);\\n        int x,y,z,k;\\n        for(auto &i: queries){\\n            z = i[2]-i[0]+1;\\n            k = 0;\\n            while(z--){\\n            x = (i[0]+k)*n+i[1],y = (i[0]+k)*n+i[3]+1;\\n                k++;\\n            v[x]++;v[y]--;\\n            }\\n        }\\n        for(int i = 1; i<= n*n; i++){\\n            v[i] = v[i-1]+v[i];\\n        }\\n        vector<vector<int>> ans(n,vector<int>(n));\\n        for(x = 0; x < n; x++){\\n            for(y = 0; y < n; y++){\\n                ans[x][y] = v[x*n+y];\\n            }\\n        }\\n        return ans;\\n    }\\n};```",
                "codeTag": "Java"
            },
            {
                "id": 3053527,
                "title": "python3-solution",
                "content": "\\n```\\nimport numpy as np\\nclass Solution:\\n    def rangeAddQueries(self, n: int, queries: List[List[int]]) -> List[List[int]]:\\n        ans=[[0]*n for _ in range(n)]\\n        res=np.array(ans)\\n        for x in queries:\\n            row1=x[0]\\n            col1=x[1]\\n            row2=x[2]\\n            col2=x[3]\\n            res[row1:row2+1,col1:col2+1]+=1\\n            \\n        return res        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nimport numpy as np\\nclass Solution:\\n    def rangeAddQueries(self, n: int, queries: List[List[int]]) -> List[List[int]]:\\n        ans=[[0]*n for _ in range(n)]\\n        res=np.array(ans)\\n        for x in queries:\\n            row1=x[0]\\n            col1=x[1]\\n            row2=x[2]\\n            col2=x[3]\\n            res[row1:row2+1,col1:col2+1]+=1\\n            \\n        return res        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3053272,
                "title": "c-prefix-sum-and-python-numpy-solution",
                "content": "c++\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& q) {\\n        vector<vector<int>> temp(n+1,vector<int>(n+1,0));\\n        for(auto &x:q){\\n            int i1=x[0], j1=x[1], i2=x[2], j2= x[3];\\n            //top left and bottom right\\n            temp[i1][j1]++;\\n            temp[i2+1][j2+1]++;\\n            //bottom left and top right\\n            temp[i1][j2+1]--;\\n            temp[i2+1][j1]--;\\n        }\\n        \\n        vector<vector<int>> ans(n,vector<int>(n,0));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                //applying top-down on temp array\\n                if(i>0)temp[i][j]+= temp[i-1][j];\\n                if(j>0)temp[i][j]+= temp[i][j-1];\\n                if(i>0 && j>0) temp[i][j]-= temp[i-1][j-1];\\n                \\n                ans[i][j]= temp[i][j];\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n\\npython (using numpy)\\n```\\nimport numpy\\n\\nclass Solution:\\n    def rangeAddQueries(self, n: int, qq: List[List[int]]) -> List[List[int]]:\\n        arr= [[0]* n for i in range(n)];\\n        arr= numpy.array(arr);\\n        \\n        for q in qq:\\n            r1,c1,r2,c2= q[0],q[1],q[2],q[3]\\n            \\n            arr[r1:r2+1, c1:c2+1]+=1\\n            \\n            \\n        return arr\\n```",
                "solutionTags": [
                    "C++",
                    "Python",
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& q) {\\n        vector<vector<int>> temp(n+1,vector<int>(n+1,0));\\n        for(auto &x:q){\\n            int i1=x[0], j1=x[1], i2=x[2], j2= x[3];\\n            //top left and bottom right\\n            temp[i1][j1]++;\\n            temp[i2+1][j2+1]++;\\n            //bottom left and top right\\n            temp[i1][j2+1]--;\\n            temp[i2+1][j1]--;\\n        }\\n        \\n        vector<vector<int>> ans(n,vector<int>(n,0));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                //applying top-down on temp array\\n                if(i>0)temp[i][j]+= temp[i-1][j];\\n                if(j>0)temp[i][j]+= temp[i][j-1];\\n                if(i>0 && j>0) temp[i][j]-= temp[i-1][j-1];\\n                \\n                ans[i][j]= temp[i][j];\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\n```\\nimport numpy\\n\\nclass Solution:\\n    def rangeAddQueries(self, n: int, qq: List[List[int]]) -> List[List[int]]:\\n        arr= [[0]* n for i in range(n)];\\n        arr= numpy.array(arr);\\n        \\n        for q in qq:\\n            r1,c1,r2,c2= q[0],q[1],q[2],q[3]\\n            \\n            arr[r1:r2+1, c1:c2+1]+=1\\n            \\n            \\n        return arr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3053150,
                "title": "python3-difference-array-postfix-sum",
                "content": "The strategy is to keep track of the changes made to each cell at the boundaries, instead of maintaining the final value of each cell.\\n\\nInitially, we initialize the matrix with all zeroes. For each query, we add 1 to the top-left corner cell ($r_{start}, c_{start}$) and subtract 1 from the cells at ($r_{start}, c_{end+1}$) and ($r_{end+1}, c_{start}$). However, in the nature of prefix computation, this leads to a duplicate cost by subtracting both row and column boundaries. Therefore, we balance this out by adding 1 to the cell after the bottom-right corner of the sub-matrix ($r_{end+1}, c_{end+1}$). Afterwards, we use the prefix sum technique to update the final matrix by adding the differences from the previous cells.\\n\\nThis approach enables us to update the matrix in constant time for each query, without the need to iterate through the entire matrix for each query.\\n\\n# Complexity\\nTime `O(q+n^2)`\\nSpace `O(1)`\\n\\n# Code\\n```\\nclass Solution:\\n    def rangeAddQueries(self, n: int, queries: List[List[int]]) -> List[List[int]]:\\n        mat = [[0]*n for _ in range(n)]\\n        for r1, c1, r2, c2 in queries:\\n            mat[r1][c1] += 1\\n            if r2 < n-1:\\n                mat[r2+1][c1] -= 1\\n            if c2 < n-1:\\n                mat[r1][c2+1] -= 1\\n            if r2 < n-1 and c2 < n-1:\\n                mat[r2+1][c2+1] += 1\\n        for i in range(1, n):\\n            mat[0][i] += mat[0][i-1]\\n            mat[i][0] += mat[i-1][0]\\n        for i in range(1, n):\\n            for j in range(1, n):\\n                mat[i][j] = mat[i][j] + mat[i-1][j] + mat[i][j-1] - mat[i-1][j-1]\\n        return mat\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rangeAddQueries(self, n: int, queries: List[List[int]]) -> List[List[int]]:\\n        mat = [[0]*n for _ in range(n)]\\n        for r1, c1, r2, c2 in queries:\\n            mat[r1][c1] += 1\\n            if r2 < n-1:\\n                mat[r2+1][c1] -= 1\\n            if c2 < n-1:\\n                mat[r1][c2+1] -= 1\\n            if r2 < n-1 and c2 < n-1:\\n                mat[r2+1][c2+1] += 1\\n        for i in range(1, n):\\n            mat[0][i] += mat[0][i-1]\\n            mat[i][0] += mat[i-1][0]\\n        for i in range(1, n):\\n            for j in range(1, n):\\n                mat[i][j] = mat[i][j] + mat[i-1][j] + mat[i][j-1] - mat[i-1][j-1]\\n        return mat\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3053106,
                "title": "brute-force-accepted-in-java-beginner-friendly-space-complexity-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBrute force\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(Q*(N*N))$$\\nwhere Q is queries length\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(N*N)$$\\nI think it was a amortized $$O(1)$$ because we are declaring auxiliary space except the return matrix.\\n\\ncorrect me if i am wrong. \\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] rangeAddQueries(int n, int[][] queries) {\\n        int[][] mat=new int[n][n];\\n\\n        for(int[] ar:queries)\\n        {\\n            int r1=ar[0];\\n            int c1=ar[1];\\n\\n            int r2=ar[2];\\n            int c2=ar[3];\\n\\n            for(int i=r1;i<=r2;i++)\\n            {\\n                for(int j=c1;j<=c2;j++)\\n                {\\n                    mat[i][j]++;\\n                }\\n            }\\n        }\\n\\n        \\n        return mat;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] rangeAddQueries(int n, int[][] queries) {\\n        int[][] mat=new int[n][n];\\n\\n        for(int[] ar:queries)\\n        {\\n            int r1=ar[0];\\n            int c1=ar[1];\\n\\n            int r2=ar[2];\\n            int c2=ar[3];\\n\\n            for(int i=r1;i<=r2;i++)\\n            {\\n                for(int j=c1;j<=c2;j++)\\n                {\\n                    mat[i][j]++;\\n                }\\n            }\\n        }\\n\\n        \\n        return mat;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3053093,
                "title": "easy-clean-short-c-solution-prefix-sum",
                "content": "**Approch**\\n* Imagine each row as a separate array. Instead of updating the whole submatrix together, we can use prefix sum to update each row separately.\\n* For each query, iterate over the rows i in the range [row1, row2] and add 1 to prefix sum mat[i][col1] (start point), and subtract 1 from mat[i][col2 + 1] (end point).\\n* After doing this operation for all the queries, update each row separately with mat[i][j] = mat[i][j] + mat[i][j - 1].\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n    vector<vector<int>> mat(n, vector<int>(n, 0));\\n\\n    for (auto q : queries) {\\n        int row1 = q[0], col1 = q[1], row2 = q[2], col2 = q[3];\\n        for (int i = row1; i <= row2; i++) {\\n            mat[i][col1]++; // row start point\\n            if (col2 + 1 < n) mat[i][col2 + 1]--; // row end point // to mark as end of submatrix\\n                                                  //1 is substracted to offset previous submatrix values\\n        }\\n    }\\n    for (int i = 0; i < n; i++) {\\n        for (int j = 1; j < n; j++) {\\n            mat[i][j] += mat[i][j - 1]; // copy from previous column \\n        }\\n    }\\n    return mat;\\n    }\\n};\\n```\\nTC: **O(q*n + n^2)**\\ncouldn\\'t solve it in contest :\\'( but after seeing hints it was easy :)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n    vector<vector<int>> mat(n, vector<int>(n, 0));\\n\\n    for (auto q : queries) {\\n        int row1 = q[0], col1 = q[1], row2 = q[2], col2 = q[3];\\n        for (int i = row1; i <= row2; i++) {\\n            mat[i][col1]++; // row start point\\n            if (col2 + 1 < n) mat[i][col2 + 1]--; // row end point // to mark as end of submatrix\\n                                                  //1 is substracted to offset previous submatrix values\\n        }\\n    }\\n    for (int i = 0; i < n; i++) {\\n        for (int j = 1; j < n; j++) {\\n            mat[i][j] += mat[i][j - 1]; // copy from previous column \\n        }\\n    }\\n    return mat;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3053001,
                "title": "c-solution",
                "content": "![image](https://assets.leetcode.com/users/images/3db57d59-9106-49cf-b22b-132d4b9bb4a2_1673760058.2489529.png)\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries)\\n    {\\n        vector<vector<int>> v(n,vector<int>(n,0));\\n        for(auto i: queries)\\n        {\\n            int row1=i[0],col1=i[1],row2=i[2],col2=i[3];\\n            for(int j=row1;j<=row2;j++)\\n                v[j][col1]++;\\n            if(col2==n-1)\\n                for(int j=row1+1;j<=row2+1 && j<n;j++)\\n                    v[j][0]--;\\n            else\\n                for(int j=row1;j<=row2;j++)\\n                    v[j][col2+1]--;\\n                \\n        }\\n        int prev=0;\\n        for(int i=0;i<n;i++)\\n            for(int j=0;j<n;j++)\\n            {\\n                v[i][j]+=prev;\\n                prev=v[i][j];\\n            }\\n        return v;\\n    }\\n};\\n```\\n\\nLogic - I tried to use a 2D implementation of 1D range sum queries.\\nTime Complexity: O(queries * rows) for first function, O(rows * columns) for second function.\\nSpace Complextity: O(rows * columns)",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries)\\n    {\\n        vector<vector<int>> v(n,vector<int>(n,0));\\n        for(auto i: queries)\\n        {\\n            int row1=i[0],col1=i[1],row2=i[2],col2=i[3];\\n            for(int j=row1;j<=row2;j++)\\n                v[j][col1]++;\\n            if(col2==n-1)\\n                for(int j=row1+1;j<=row2+1 && j<n;j++)\\n                    v[j][0]--;\\n            else\\n                for(int j=row1;j<=row2;j++)\\n                    v[j][col2+1]--;\\n                \\n        }\\n        int prev=0;\\n        for(int i=0;i<n;i++)\\n            for(int j=0;j<n;j++)\\n            {\\n                v[i][j]+=prev;\\n                prev=v[i][j];\\n            }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3052987,
                "title": "simple-c-solution-difference-array-beats-100",
                "content": "The first step is to create a 2D array called arr with n rows and n columns, filled with zeroes.\\n\\nThen, it iterates over the queries, for each query, it adds +1 to the specific position in the array and -1 to the next column if it\\'s less than n. This is done to mark the range of the query, the first element of the range will be incremented by one, and the next element after the range will be decremented by one. This way, the difference between the two elements will be the value that is added to the range.\\n\\nThen, it iterates over the array, for each element of the array, it adds the current element to the previous one, this is done to convert the marked array to the final array.\\n\\nThis approach is similar to the difference array algorithm, as it\\'s using the same technique to solve the problem, it\\'s updating the range by marking it with +1 and -1 and then converting it to the final array by adding up the current element to the previous one.\\n\\nThe time complexity of this solution is $$O(n^2)$$ as we are iterating over the array multiple times and the space complexity is $$O(n^2)$$ as we are using a 2D array with n*n elements.\\n# Approach\\nDifference array\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n^2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int[][] RangeAddQueries(int n, int[][] queries) {\\n        var arr = new int[n][];\\n        for (var i = 0; i < n; i++)\\n        {\\n            arr[i] = new int[n];\\n        }\\n\\n        for (var i = 0; i < queries.Length; i++)\\n        {\\n            var row1 = queries[i][0];\\n            var row2 = queries[i][2];\\n            var col1 = queries[i][1];\\n            var col2 = queries[i][3];\\n            for (var j = row1; j <= row2; j++)\\n            {\\n                arr[j][col1]++;\\n                if (col2 + 1 < n) arr[j][col2+1]--;\\n            }\\n        }\\n\\n        for (var i = 0; i < n; i++)\\n        {\\n            for (var j = 1; j < n; j++)\\n            {\\n                arr[i][j] += arr[i][j-1];\\n            }\\n        }\\n\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int[][] RangeAddQueries(int n, int[][] queries) {\\n        var arr = new int[n][];\\n        for (var i = 0; i < n; i++)\\n        {\\n            arr[i] = new int[n];\\n        }\\n\\n        for (var i = 0; i < queries.Length; i++)\\n        {\\n            var row1 = queries[i][0];\\n            var row2 = queries[i][2];\\n            var col1 = queries[i][1];\\n            var col2 = queries[i][3];\\n            for (var j = row1; j <= row2; j++)\\n            {\\n                arr[j][col1]++;\\n                if (col2 + 1 < n) arr[j][col2+1]--;\\n            }\\n        }\\n\\n        for (var i = 0; i < n; i++)\\n        {\\n            for (var j = 1; j < n; j++)\\n            {\\n                arr[i][j] += arr[i][j-1];\\n            }\\n        }\\n\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3052978,
                "title": "accepeted-in-java-but-got-tle-in-c-python",
                "content": "Java Brute Force  Solution got accepted\\n ```\\nclass Solution {\\n    public int[][] rangeAddQueries(int n, int[][] queries) {\\n    int[][] mat = new int[n][n];\\n    for (int[] q : queries) {\\n        int row1 = q[0], col1 = q[1], row2 = q[2], col2 = q[3];\\n        for (int i = row1; i <= row2; i++) {\\n            for (int j = col1; j <= col2; j++) {\\n                mat[i][j]++;\\n            }\\n        }\\n    }\\n    return mat;\\n    }\\n}\\n```\\n\\nBut same C++ Solution gets Time Limit Exceeded on TestCase 18\\n ```\\nclass Solution {\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n        vector<vector<int>> mat(n, vector<int>(n, 0)) ;\\n        for (auto &q : queries) {\\n            int row1 = q[0], col1 = q[1], row2 = q[2], col2 = q[3];\\n            for (int i = row1; i <= row2; i++) {\\n                for (int j = col1; j <= col2; j++) {\\n                    mat[i][j]++;\\n                }\\n            }\\n        }\\n        return mat;\\n    }\\n};\\n```\\n\\nPlease fix the issue as many participants got penalty because of this issue.",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] rangeAddQueries(int n, int[][] queries) {\\n    int[][] mat = new int[n][n];\\n    for (int[] q : queries) {\\n        int row1 = q[0], col1 = q[1], row2 = q[2], col2 = q[3];\\n        for (int i = row1; i <= row2; i++) {\\n            for (int j = col1; j <= col2; j++) {\\n                mat[i][j]++;\\n            }\\n        }\\n    }\\n    return mat;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n        vector<vector<int>> mat(n, vector<int>(n, 0)) ;\\n        for (auto &q : queries) {\\n            int row1 = q[0], col1 = q[1], row2 = q[2], col2 = q[3];\\n            for (int i = row1; i <= row2; i++) {\\n                for (int j = col1; j <= col2; j++) {\\n                    mat[i][j]++;\\n                }\\n            }\\n        }\\n        return mat;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3052928,
                "title": "rust-concise-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N * (N + Q))\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N * N)\\n# Code\\n```\\nimpl Solution {\\n    pub fn range_add_queries(n: i32, queries: Vec<Vec<i32>>) -> Vec<Vec<i32>> {\\n        let n = n as usize;\\n        let mut data = vec![vec![0; n + 1]; n];\\n        \\n        for q in queries {\\n            let (x, y, u, v) = (q[0] as usize, q[1] as usize, q[2] as usize, q[3] as usize);\\n            for i in x ..= u {\\n                data[i][y] += 1;\\n                data[i][v + 1] -= 1;\\n            }\\n        }\\n        \\n        let mut ret = vec![];\\n        for i in 0 .. n {\\n            let mut v = vec![];\\n            let mut sum = 0;\\n            for j in 0 .. n {\\n                sum += data[i][j];\\n                v.push(sum);\\n            }\\n            ret.push(v);\\n        }\\n        \\n        ret\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn range_add_queries(n: i32, queries: Vec<Vec<i32>>) -> Vec<Vec<i32>> {\\n        let n = n as usize;\\n        let mut data = vec![vec![0; n + 1]; n];\\n        \\n        for q in queries {\\n            let (x, y, u, v) = (q[0] as usize, q[1] as usize, q[2] as usize, q[3] as usize);\\n            for i in x ..= u {\\n                data[i][y] += 1;\\n                data[i][v + 1] -= 1;\\n            }\\n        }\\n        \\n        let mut ret = vec![];\\n        for i in 0 .. n {\\n            let mut v = vec![];\\n            let mut sum = 0;\\n            for j in 0 .. n {\\n                sum += data[i][j];\\n                v.push(sum);\\n            }\\n            ret.push(v);\\n        }\\n        \\n        ret\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3052924,
                "title": "c-prefix-sum-short-and-concise",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n        vector<vector<int>> arr(n, vector<int> (n, 0));\\n        for(auto query : queries){\\n            int r1 = query[0], r2 = query[2];\\n            int c1 = query[1], c2 = query[3];\\n            arr[r1][c1] += 1;\\n            if(c2 + 1 < n) arr[r1][c2 + 1]--;\\n            if(r2 + 1 < n) arr[r2 + 1][c1]--;\\n            if(r2 + 1 < n and c2 + 1 < n) arr[r2 + 1][c2 + 1]++;\\n        }\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < n; j++){\\n                if(i == 0 and j == 0) continue;\\n                else if(i == 0) arr[i][j] += arr[i][j - 1];\\n                else if(j == 0) arr[i][j] += arr[i - 1][j];\\n                else arr[i][j] += arr[i - 1][j] + arr[i][j - 1] - arr[i - 1][j - 1]; \\n            }\\n        }\\n        return arr;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n        vector<vector<int>> arr(n, vector<int> (n, 0));\\n        for(auto query : queries){\\n            int r1 = query[0], r2 = query[2];\\n            int c1 = query[1], c2 = query[3];\\n            arr[r1][c1] += 1;\\n            if(c2 + 1 < n) arr[r1][c2 + 1]--;\\n            if(r2 + 1 < n) arr[r2 + 1][c1]--;\\n            if(r2 + 1 < n and c2 + 1 < n) arr[r2 + 1][c2 + 1]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3052844,
                "title": "python-simple-clean-hashmap-counter-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse a HM that tells you how much to add to the counter for each row when you reach (i,j)\\nUse a second HM that tells you how much to remove from the counter when you reach (i,j)\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2 + q*n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n\\n# Code\\n```\\nclass Solution:\\n    def rangeAddQueries(self, n: int, queries: List[List[int]]) -> List[List[int]]:\\n        \\n        out = [ [0]*n for i in range(n)]\\n\\n        #When we reach hms with key [i,j] we increment counter by hms[i,j]\\n        hms = defaultdict(int)\\n        #When we reach hme with key [i,j] we increment counter by hme[i,j]\\n        hme = defaultdict(int)\\n        \\n        for q in queries:\\n            \\n            for i in range(q[0],q[2]+1):\\n                hms[(i,q[1])] += 1\\n                hme[(i,q[3]+1)] += 1\\n\\n        for i in range(n):\\n            count = 0\\n            for j in range(n):\\n                count += hms[(i,j)]\\n                count -= hme[(i,j)]\\n                out[i][j] = count\\n        return out\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def rangeAddQueries(self, n: int, queries: List[List[int]]) -> List[List[int]]:\\n        \\n        out = [ [0]*n for i in range(n)]\\n\\n        #When we reach hms with key [i,j] we increment counter by hms[i,j]\\n        hms = defaultdict(int)\\n        #When we reach hme with key [i,j] we increment counter by hme[i,j]\\n        hme = defaultdict(int)\\n        \\n        for q in queries:\\n            \\n            for i in range(q[0],q[2]+1):\\n                hms[(i,q[1])] += 1\\n                hme[(i,q[3]+1)] += 1\\n\\n        for i in range(n):\\n            count = 0\\n            for j in range(n):\\n                count += hms[(i,j)]\\n                count -= hme[(i,j)]\\n                out[i][j] = count\\n        return out\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3052834,
                "title": "java-1ms-100-easy-to-understand",
                "content": "# Intuition\\nPrefix Sum\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] rangeAddQueries(int n, int[][] queries) {\\n        int[][] temp = new int[n][n];\\n        for(int[] query : queries){\\n            int sr = query[0];\\n            int sc = query[1];\\n            int er = query[2];\\n            int ec = query[3];\\n            temp[sr][sc] += 1;\\n            if(ec + 1 < n){\\n                temp[sr][ec + 1] -= 1;\\n            }\\n            if(er + 1 < n){\\n                temp[er + 1][sc] -= 1;\\n            }\\n            if(er + 1 < n && ec + 1 < n){\\n                temp[er + 1][ec + 1] += 1;\\n            }\\n        }\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < n; j++){\\n                temp[i][j] += j - 1 >= 0 ? temp[i][j - 1] : 0;\\n            }\\n        }\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < n; j++){\\n                temp[j][i] += j - 1 >= 0 ? temp[j - 1][i] : 0;\\n            }\\n        }\\n        return temp;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Matrix",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] rangeAddQueries(int n, int[][] queries) {\\n        int[][] temp = new int[n][n];\\n        for(int[] query : queries){\\n            int sr = query[0];\\n            int sc = query[1];\\n            int er = query[2];\\n            int ec = query[3];\\n            temp[sr][sc] += 1;\\n            if(ec + 1 < n){\\n                temp[sr][ec + 1] -= 1;\\n            }\\n            if(er + 1 < n){\\n                temp[er + 1][sc] -= 1;\\n            }\\n            if(er + 1 < n && ec + 1 < n){\\n                temp[er + 1][ec + 1] += 1;\\n            }\\n        }\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < n; j++){\\n                temp[i][j] += j - 1 >= 0 ? temp[i][j - 1] : 0;\\n            }\\n        }\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < n; j++){\\n                temp[j][i] += j - 1 >= 0 ? temp[j - 1][i] : 0;\\n            }\\n        }\\n        return temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3052826,
                "title": "c-clean-solution-with-comments",
                "content": "# Approach\\nThe idea is to fill-out a table row by row.\\nFirst row is filled-out in a brute force way by deriving all the values from input queries.\\nFor any other row, for a given cell the value is computed as:\\n1. Take the value from the cell above.\\n2. Subtract number of queries (squares) which end in the cell above. They no longer cover current cell.\\n3. Add number of queries (squares) which start in the current cell.\\n\\n# Complexity\\n- Time complexity:\\nO(n*m) + O(n*n)\\n\\n- Space complexity:\\nO(n*n)\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    struct Sq{\\n        int start_i;\\n        int start_j;\\n        int end_i;\\n        int end_j;\\n    };\\n\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n        // Store all query squares.\\n        vector<Sq> sqs;\\n        for(const auto &query : queries) {\\n            sqs.push_back(Sq{.start_i = query[0], .start_j = query[1], .end_i = query[2], .end_j = query[3]});\\n        }\\n        \\n        // How many squares start at a given cell?\\n        vector<vector<int>> starting(n, vector<int>(n, 0));\\n        // How many squares end at a given cell?\\n        vector<vector<int>> ending(n, vector<int>(n, 0));\\n        // Result\\n        vector<vector<int>> res(n, vector<int>(n, 0));\\n        \\n        for(const auto &sq : sqs) {\\n            // Fill out \\'starting\\'\\n            for(int j = sq.start_j; j<=sq.end_j; ++j) {\\n                starting[sq.start_i][j]+=1;\\n            }\\n            // Fill out \\'ending\\'\\n            for(int j = sq.start_j; j<=sq.end_j; ++j) {\\n                ending[sq.end_i][j]+=1;\\n            }\\n            // Fill out first row of the result.\\n            if(sq.start_i == 0) {\\n                for(int j = sq.start_j; j<=sq.end_j; ++j) {\\n                    res[0][j]+=1;\\n                }\\n            }\\n        }\\n        \\n        // Iterate over each cell starting from row #1.\\n        for(int i = 1; i<n; ++i) {\\n            for(int j = 0; j<n; ++j) {\\n                // Take a value from the cell above, subtract squares which end above and add squares which start in the current cell.\\n                res[i][j] = res[i-1][j] - ending[i-1][j] + starting[i][j];\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    struct Sq{\\n        int start_i;\\n        int start_j;\\n        int end_i;\\n        int end_j;\\n    };\\n\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n        // Store all query squares.\\n        vector<Sq> sqs;\\n        for(const auto &query : queries) {\\n            sqs.push_back(Sq{.start_i = query[0], .start_j = query[1], .end_i = query[2], .end_j = query[3]});\\n        }\\n        \\n        // How many squares start at a given cell?\\n        vector<vector<int>> starting(n, vector<int>(n, 0));\\n        // How many squares end at a given cell?\\n        vector<vector<int>> ending(n, vector<int>(n, 0));\\n        // Result\\n        vector<vector<int>> res(n, vector<int>(n, 0));\\n        \\n        for(const auto &sq : sqs) {\\n            // Fill out \\'starting\\'\\n            for(int j = sq.start_j; j<=sq.end_j; ++j) {\\n                starting[sq.start_i][j]+=1;\\n            }\\n            // Fill out \\'ending\\'\\n            for(int j = sq.start_j; j<=sq.end_j; ++j) {\\n                ending[sq.end_i][j]+=1;\\n            }\\n            // Fill out first row of the result.\\n            if(sq.start_i == 0) {\\n                for(int j = sq.start_j; j<=sq.end_j; ++j) {\\n                    res[0][j]+=1;\\n                }\\n            }\\n        }\\n        \\n        // Iterate over each cell starting from row #1.\\n        for(int i = 1; i<n; ++i) {\\n            for(int j = 0; j<n; ++j) {\\n                // Take a value from the cell above, subtract squares which end above and add squares which start in the current cell.\\n                res[i][j] = res[i-1][j] - ending[i-1][j] + starting[i][j];\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3052767,
                "title": "java-solution-along-with-c",
                "content": "# Accepted Solution in java\\n```\\nclass Solution {\\n    public int[][] rangeAddQueries(int n, int[][] qu) {\\n        int ans[][] =new int[n][n];\\n        for(int [] q:qu){\\n            int r1=q[0];\\n            int c1=q[1];\\n            int r2=q[2];\\n            int c2=q[3];\\n            for(int i=r1;i<=r2;i++){\\n                for(int j=c1;j<=c2;j++){\\n                    ans[i][j]++;\\n                }\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```\\n# TlE in c++ solution for same code line \\uD83E\\uDD72\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n        vector<vector<int>> vv(n,vector<int> (n,0));\\n        for(auto q:queries){\\n            int r1=q[0];\\n            int c1=q[1];\\n            int r2=q[2];\\n            int c2=q[3];\\n            for(int j=r1;j<=r2;j++){\\n                for(int k=c1;k<=c2;k++){\\n                    vv[j][k]++;\\n                }\\n            }\\n        }\\n        return vv;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] rangeAddQueries(int n, int[][] qu) {\\n        int ans[][] =new int[n][n];\\n        for(int [] q:qu){\\n            int r1=q[0];\\n            int c1=q[1];\\n            int r2=q[2];\\n            int c2=q[3];\\n            for(int i=r1;i<=r2;i++){\\n                for(int j=c1;j<=c2;j++){\\n                    ans[i][j]++;\\n                }\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n        vector<vector<int>> vv(n,vector<int> (n,0));\\n        for(auto q:queries){\\n            int r1=q[0];\\n            int c1=q[1];\\n            int r2=q[2];\\n            int c2=q[3];\\n            for(int j=r1;j<=r2;j++){\\n                for(int k=c1;k<=c2;k++){\\n                    vv[j][k]++;\\n                }\\n            }\\n        }\\n        return vv;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3052713,
                "title": "python3-prefix-sum",
                "content": "\\n```\\nclass Solution:\\n    def rangeAddQueries(self, n: int, queries: List[List[int]]) -> List[List[int]]:\\n        ans = [[0]*n for _ in range(n)]\\n        for i, j, ii, jj in queries: \\n            ans[i][j] += 1\\n            if ii+1 < n: ans[ii+1][j] -= 1\\n            if jj+1 < n: ans[i][jj+1] -= 1\\n            if ii+1 < n and jj+1 < n: ans[ii+1][jj+1] += 1\\n        for i in range(n): \\n            prefix = 0 \\n            for j in range(n): \\n                prefix += ans[i][j]\\n                ans[i][j] = prefix \\n                if i: ans[i][j] += ans[i-1][j]\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rangeAddQueries(self, n: int, queries: List[List[int]]) -> List[List[int]]:\\n        ans = [[0]*n for _ in range(n)]\\n        for i, j, ii, jj in queries: \\n            ans[i][j] += 1\\n            if ii+1 < n: ans[ii+1][j] -= 1\\n            if jj+1 < n: ans[i][jj+1] -= 1\\n            if ii+1 < n and jj+1 < n: ans[ii+1][jj+1] += 1\\n        for i in range(n): \\n            prefix = 0 \\n            for j in range(n): \\n                prefix += ans[i][j]\\n                ans[i][j] = prefix \\n                if i: ans[i][j] += ans[i-1][j]\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3052649,
                "title": "my-solution-o-n-o-queries-length-o-n-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n        \\n        vector<vector<int>> tmp(n,vector<int>(n,0)); \\n        \\n        for(auto x:queries){\\n            for(int i=x[0];i<=x[2];i++) {\\n                tmp[i][x[1]]+=1;\\n                if(x[3]+1<n) tmp[i][x[3]+1]-=1;\\n            }\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=1;j<n;j++){\\n                tmp[i][j] += tmp[i][j-1];\\n            }\\n        }\\n        \\n        return tmp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n        \\n        vector<vector<int>> tmp(n,vector<int>(n,0)); \\n        \\n        for(auto x:queries){\\n            for(int i=x[0];i<=x[2];i++) {\\n                tmp[i][x[1]]+=1;\\n                if(x[3]+1<n) tmp[i][x[3]+1]-=1;\\n            }\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=1;j<n;j++){\\n                tmp[i][j] += tmp[i][j-1];\\n            }\\n        }\\n        \\n        return tmp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3052633,
                "title": "prefix-sum-2d-array-o-n-m",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n        vector<vector<int>> arr(n+1, vector<int>(n+1));\\n        for (auto& q : queries) {\\n            arr[q[0]][q[1]]++, arr[q[0]][q[3] + 1]--;\\n            arr[q[2] + 1][q[1]]--, arr[q[2] + 1][q[3] + 1]++;\\n        }\\n        \\n        for (int i = 0; i < n; i++) \\n            for (int j = 1; j < n; j++)  arr[i][j] += arr[i][j - 1];\\n        for (int i = 1; i < n; i++) \\n            for (int j = 0; j < n; j++)  arr[i][j] += arr[i - 1][j];\\n        vector<vector<int>> ans(n,vector<int>(n));\\n        for(int i= 0;i<n;i++){\\n            for(int j = 0;j<n;j++)ans[i][j] = arr[i][j];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n        vector<vector<int>> arr(n+1, vector<int>(n+1));\\n        for (auto& q : queries) {\\n            arr[q[0]][q[1]]++, arr[q[0]][q[3] + 1]--;\\n            arr[q[2] + 1][q[1]]--, arr[q[2] + 1][q[3] + 1]++;\\n        }\\n        \\n        for (int i = 0; i < n; i++) \\n            for (int j = 1; j < n; j++)  arr[i][j] += arr[i][j - 1];\\n        for (int i = 1; i < n; i++) \\n            for (int j = 0; j < n; j++)  arr[i][j] += arr[i - 1][j];\\n        vector<vector<int>> ans(n,vector<int>(n));\\n        for(int i= 0;i<n;i++){\\n            for(int j = 0;j<n;j++)ans[i][j] = arr[i][j];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3052629,
                "title": "2536-increment-submatrices-by-one-java-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] rangeAddQueries(int n, int[][] queries) {\\n    int[][] mat = new int[n][n];\\n    for (int[] q : queries) {\\n        int row1 = q[0], col1 = q[1], row2 = q[2], col2 = q[3];\\n        for (int i = row1; i <= row2; i++) {\\n            for (int j = col1; j <= col2; j++) {\\n                mat[i][j]++;\\n            }\\n        }\\n    }\\n    return mat;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] rangeAddQueries(int n, int[][] queries) {\\n    int[][] mat = new int[n][n];\\n    for (int[] q : queries) {\\n        int row1 = q[0], col1 = q[1], row2 = q[2], col2 = q[3];\\n        for (int i = row1; i <= row2; i++) {\\n            for (int j = col1; j <= col2; j++) {\\n                mat[i][j]++;\\n            }\\n        }\\n    }\\n    return mat;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4012659,
                "title": "simple-using-2d-vector",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// class Solution {\\n// public:\\n//     vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n//         // vector<vector<int>> ans(,0);\\n//         // vector<vector<int>> ans(n,vector<int> (n,0));\\n//         // int ans[n][n]={0};\\n//             // vector<vector<int>> ans(n);\\n//     vector<vector<int>> ans( n , vector<int> (n, 0)); \\n// int rs,re,cs,ce;\\n//         for(int i=0;i<n;i++){\\n//             rs=queries[i][0];\\n//             re=queries[i][2];\\n//             cs=queries[i][1];\\n//             ce=queries[i][3];\\n//             for(int j=rs;j<=re;j++){\\n//                 ans[j][cs]+=1;\\n//                 if((ce+1)>=n){\\n//                     if(j+1<n){\\n//                         ans[j+1][0]-=1;\\n//                     }\\n//                     else{\\n//                         continue;\\n//                     }\\n//                 }\\n//                 else{\\n//                     ans[j][ce+1]-=1;\\n//                 }\\n//             }\\n            \\n//         }\\n//         int cnt=0;\\n//             for(int i=0;i,n;i++){\\n//                 for(int j=0;j<n;j++){\\n//                     cnt+=ans[i][j];\\n//                     ans[i][j]=cnt;\\n//                 }\\n//             }\\n//             // return ans;\\n//         return ans;\\n//     }\\n// };\\n\\nclass Solution \\n{\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) \\n    {\\n        vector<vector<int>> mat(n, vector<int> (n, 0));\\n        int r1, c1, r2, c2;\\n        for(auto &it:queries)\\n        {\\n            r1=it[0], c1=it[1], r2=it[2], c2=it[3];\\n            for(int i=r1; i<=r2; i++) //marking each row of the query\\n            {\\n                mat[i][c1] += 1; //according to the query, we need to start adding 1 from (i, c1) cell\\n                if((c2+1)>=n) //for stop adding one, we need to check whether we are at last cell of the row or not\\n                    if(i+1<n) //if we are at last cell, we mark first cell of next row as stop adding 1\\n                        mat[i+1][0] -= 1;\\n                    else\\n                        continue;\\n                        \\n                \\n                else //if we are not at last cell, we mark next cell of the row at stop adding 1.\\n                    mat[i][c2+1] -= 1;      \\n                \\n            }    \\n        }\\n        \\n        int cnt=0;\\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j=0; j<n; j++)\\n            {\\n                cnt += mat[i][j];\\n                mat[i][j] = cnt;\\n            }\\n        }\\n        return mat;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n// class Solution {\\n// public:\\n//     vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n//         // vector<vector<int>> ans(,0);\\n//         // vector<vector<int>> ans(n,vector<int> (n,0));\\n//         // int ans[n][n]={0};\\n//             // vector<vector<int>> ans(n);\\n//     vector<vector<int>> ans( n , vector<int> (n, 0)); \\n// int rs,re,cs,ce;\\n//         for(int i=0;i<n;i++){\\n//             rs=queries[i][0];\\n//             re=queries[i][2];\\n//             cs=queries[i][1];\\n//             ce=queries[i][3];\\n//             for(int j=rs;j<=re;j++){\\n//                 ans[j][cs]+=1;\\n//                 if((ce+1)>=n){\\n//                     if(j+1<n){\\n//                         ans[j+1][0]-=1;\\n//                     }\\n//                     else{\\n//                         continue;\\n//                     }\\n//                 }\\n//                 else{\\n//                     ans[j][ce+1]-=1;\\n//                 }\\n//             }\\n            \\n//         }\\n//         int cnt=0;\\n//             for(int i=0;i,n;i++){\\n//                 for(int j=0;j<n;j++){\\n//                     cnt+=ans[i][j];\\n//                     ans[i][j]=cnt;\\n//                 }\\n//             }\\n//             // return ans;\\n//         return ans;\\n//     }\\n// };\\n\\nclass Solution \\n{\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) \\n    {\\n        vector<vector<int>> mat(n, vector<int> (n, 0));\\n        int r1, c1, r2, c2;\\n        for(auto &it:queries)\\n        {\\n            r1=it[0], c1=it[1], r2=it[2], c2=it[3];\\n            for(int i=r1; i<=r2; i++) //marking each row of the query\\n            {\\n                mat[i][c1] += 1; //according to the query, we need to start adding 1 from (i, c1) cell\\n                if((c2+1)>=n) //for stop adding one, we need to check whether we are at last cell of the row or not\\n                    if(i+1<n) //if we are at last cell, we mark first cell of next row as stop adding 1\\n                        mat[i+1][0] -= 1;\\n                    else\\n                        continue;\\n                        \\n                \\n                else //if we are not at last cell, we mark next cell of the row at stop adding 1.\\n                    mat[i][c2+1] -= 1;      \\n                \\n            }    \\n        }\\n        \\n        int cnt=0;\\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j=0; j<n; j++)\\n            {\\n                cnt += mat[i][j];\\n                mat[i][j] = cnt;\\n            }\\n        }\\n        return mat;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3976096,
                "title": "python-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe code you provided is solving a problem related to range queries and updates in a 2D array. The goal is to efficiently update specific submatrices within the array based on a set of queries and then return the final state of the array after all the queries have been processed.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- **Initialize the Answer Matrix:** The code starts by initializing a 2D matrix called ans with all elements set to 0. This matrix will store the final results after processing the queries. It has the same dimensions as the original array (n x n).\\n\\n**Process Each Query:**\\n\\n- It iterates through each query in the queries array using a for loop. Each query is represented as [row1, col1, row2, col2].\\n\\n**For each query, it performs the following steps:**\\n\\n- Marks the beginning of the query with a +1 in the ans matrix for each row within the specified range. This is done using a nested loop that iterates from row1 to row2. For each row j, it increments ans[j][col1] by 1.\\n\\n- Checks if (col2 + 1) is within the array bounds (i.e., it checks if the ending column index is not at the rightmost edge of the array).\\n\\n- If (col2 + 1) is within bounds, it subtracts -1 from ans[j][col2 + 1]. This step is crucial for maintaining the balance in the matrix because it effectively cancels out the +1 added earlier when the query ends. This is a key optimization to avoid manually updating every cell within the query range.\\n\\n**Accumulate Values in Each Row:**\\n\\n- After processing all the queries, the code uses nested loops to accumulate the values in each row of the ans matrix. For each row, it iterates from the second column (col=1) to the last column (col=n-1) and adds the value of the previous column to the current column. This step ensures that each cell in a row contains the cumulative sum of values, which represents the final state of the array after all queries.\\n**Return the Result:**\\n\\n- Finally, the code returns the ans matrix, which contains the cumulative additions and subtractions based on the queries. This matrix represents the final state of the 2D array after all updates.\\nThe approach used in this code is efficient because it avoids directly updating each cell within the query range and leverages the cumulative sum technique to achieve the final result.\\n# Complexity\\n# - Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- Initializing the result_matrix takes O(n^2) time because it involves creating an n x n matrix.\\n\\n- Processing Each Query: For each query, the code involves looping through rows and potentially columns within the specified range. In the worst case, it loops through all rows and columns for each query. Therefore, the time complexity for this part is O(Q * n^2), where Q is the number of queries.\\n\\n- Accumulating Values in Each Row: The double loop that accumulates values in each row has a time complexity of O(n^2).\\n\\n- Overall, the time complexity of the code is O(n^2) for initializing the matrix plus O(Q * n^2) for processing the queries, where Q is the number of queries. In most cases, the dominant factor is the query processing, so the time complexity is primarily determined by the number of queries and the size of the matrix.\\n\\n# - Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n- The space complexity is dominated by the result_matrix, which is an n x n matrix. Therefore, the space complexity is O(n^2).\\n\\n- In summary, the time complexity is O(n^2 + Q * n^2), and the space complexity is O(n^2), where n is the size of the matrix, and Q is the number of queries. The code efficiently processes the queries, especially for a large number of queries compared to the size of the matrix, but the space complexity is quadratic due to the result matrix.\\n\\n# Code\\n```\\nclass Solution:\\n    def rangeAddQueries(self, n: int, queries: List[List[int]]) -> List[List[int]]:\\n        # Initialize the answer matrix with zeros\\n        result_matrix = [[0] * n for _ in range(n)]\\n        \\n        # Process each query\\n        for query in queries:\\n            start_row, start_col, end_row, end_col = query\\n            \\n            # Mark the beginning of the query with +1\\n            for row in range(start_row, end_row + 1):\\n                result_matrix[row][start_col] += 1\\n                \\n                # Check if (end_col + 1) is within the array bounds\\n                if end_col + 1 != n:\\n                    result_matrix[row][end_col + 1] -= 1\\n        \\n        # Accumulate values in each row\\n        for row in range(n):\\n            for col in range(1, n):\\n                result_matrix[row][col] += result_matrix[row][col - 1]\\n        \\n        return result_matrix\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rangeAddQueries(self, n: int, queries: List[List[int]]) -> List[List[int]]:\\n        # Initialize the answer matrix with zeros\\n        result_matrix = [[0] * n for _ in range(n)]\\n        \\n        # Process each query\\n        for query in queries:\\n            start_row, start_col, end_row, end_col = query\\n            \\n            # Mark the beginning of the query with +1\\n            for row in range(start_row, end_row + 1):\\n                result_matrix[row][start_col] += 1\\n                \\n                # Check if (end_col + 1) is within the array bounds\\n                if end_col + 1 != n:\\n                    result_matrix[row][end_col + 1] -= 1\\n        \\n        # Accumulate values in each row\\n        for row in range(n):\\n            for col in range(1, n):\\n                result_matrix[row][col] += result_matrix[row][col - 1]\\n        \\n        return result_matrix\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3968344,
                "title": "python-medium",
                "content": "```\\nclass Solution(object):\\n    def rangeAddQueries(self, n, queries):\\n        mat = [[0] * (n + 1) for _ in range(n + 1)]\\n        \\n        for startRow, startCol, endRow, endCol in queries:\\n            for r in range(startRow, endRow + 1):\\n                mat[r][startCol] += 1\\n                mat[r][endCol + 1] -= 1\\n\\n        \\n        \\n        for i in range(n):\\n            for j in range(1, n):\\n                mat[i][j] += mat[i][j - 1]\\n\\n        \\n        ans = [[0] * n for _ in range(n)]\\n        for i in range(n):\\n            for j in range(n):\\n                ans[i][j] = mat[i][j]\\n\\n        return ans\\n\\n           \\n\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def rangeAddQueries(self, n, queries):\\n        mat = [[0] * (n + 1) for _ in range(n + 1)]\\n        \\n        for startRow, startCol, endRow, endCol in queries:\\n            for r in range(startRow, endRow + 1):\\n                mat[r][startCol] += 1\\n                mat[r][endCol + 1] -= 1\\n\\n        \\n        \\n        for i in range(n):\\n            for j in range(1, n):\\n                mat[i][j] += mat[i][j - 1]\\n\\n        \\n        ans = [[0] * n for _ in range(n)]\\n        for i in range(n):\\n            for j in range(n):\\n                ans[i][j] = mat[i][j]\\n\\n        return ans\\n\\n           \\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3958844,
                "title": "easy-c-solution-with-explanation",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& q) {\\n        vector<vector<int>>ans(n,vector<int>(n,0));\\n        for(int i=0;i<q.size();i++){\\n            for(int j=q[i][0];j<=q[i][2];j++){//row number\\n                ans[j][q[i][1]]++;//row ith and column number on query \\n                if((1+q[i][3])!=n){ //checking if last indexis out of bounds or not\\n                    ans[j][q[i][3]+1]--;//addition of this make submatrix add -1\\n                }\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=1;j<n;j++){// 1 element is left for the puspose of comparision\\n                ans[i][j]+=ans[i][j-1];//add number of elements before\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& q) {\\n        vector<vector<int>>ans(n,vector<int>(n,0));\\n        for(int i=0;i<q.size();i++){\\n            for(int j=q[i][0];j<=q[i][2];j++){//row number\\n                ans[j][q[i][1]]++;//row ith and column number on query \\n                if((1+q[i][3])!=n){ //checking if last indexis out of bounds or not\\n                    ans[j][q[i][3]+1]--;//addition of this make submatrix add -1\\n                }\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=1;j<n;j++){// 1 element is left for the puspose of comparision\\n                ans[i][j]+=ans[i][j-1];//add number of elements before\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3958254,
                "title": "very-easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] rangeAddQueries(int n, int[][] queries) {\\n        int[][] ans = new int[n][n]; \\n        for (int i = 0; i < queries.length; i++) {\\n            int f = queries[i][0];\\n            int s = queries[i][1];\\n            int e1 = queries[i][2];\\n            int e2 = queries[i][3];\\n            check(f, s, e1, e2, ans);\\n        }\\n        return ans;\\n    }\\n\\n    public static void check(int f, int s, int e1, int e2, int[][] ans) {\\n        for (int i = f; i <= e1; i++) {\\n            for (int j = s; j <= e2; j++) {\\n                ans[i][j] += 1;\\n            }\\n        }\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] rangeAddQueries(int n, int[][] queries) {\\n        int[][] ans = new int[n][n]; \\n        for (int i = 0; i < queries.length; i++) {\\n            int f = queries[i][0];\\n            int s = queries[i][1];\\n            int e1 = queries[i][2];\\n            int e2 = queries[i][3];\\n            check(f, s, e1, e2, ans);\\n        }\\n        return ans;\\n    }\\n\\n    public static void check(int f, int s, int e1, int e2, int[][] ans) {\\n        for (int i = f; i <= e1; i++) {\\n            for (int j = s; j <= e2; j++) {\\n                ans[i][j] += 1;\\n            }\\n        }\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3942735,
                "title": "javascript-2d-difference-array-358ms",
                "content": "```\\n/////////////////////////// Template //////////////////////////////\\nfunction DiffArray2D(g) {\\n    let n = g.length, m = g[0].length, d = [...Array(n)].map(() => Array(m + 1).fill(0));\\n    initialize();\\n    return { addRange, recover, D }\\n    function initialize() {\\n        for (let i = 0; i < n; i++) d[i][0] = g[i][0];\\n        for (let i = 0; i < n; i++)\\n            for (let j = 1; j < m; j++)\\n                d[i][j] = g[i][j] - g[i][j - 1];\\n    }\\n    function addRange(x1, y1, x2, y2, v) {\\n        for (let i = x1; i <= x2; i++) {\\n            d[i][y1] += v;\\n            d[i][y2 + 1] -= v;\\n        }\\n    }\\n    function recover() {\\n        let res = [...Array(n)].map(() => Array(m).fill(0));\\n        for (let i = 0; i < n; i++)\\n            for (let j = 0; j < m; j++)\\n                res[i][j] = j == 0 ? d[i][j] : d[i][j] + res[i][j - 1];\\n        return res;\\n    }\\n    function D() {\\n        return d;\\n    }\\n}\\n///////////////////////////////////////////////////////////////\\n\\nconst rangeAddQueries = (n, queries) => {\\n    let g = [...Array(n)].map(() => Array(n).fill(0)), da = new DiffArray2D(g);\\n    for (const [x1, y1, x2, y2] of queries) da.addRange(x1, y1, x2, y2, 1);\\n    let res = da.recover();\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Matrix",
                    "Prefix Sum"
                ],
                "code": "```\\n/////////////////////////// Template //////////////////////////////\\nfunction DiffArray2D(g) {\\n    let n = g.length, m = g[0].length, d = [...Array(n)].map(() => Array(m + 1).fill(0));\\n    initialize();\\n    return { addRange, recover, D }\\n    function initialize() {\\n        for (let i = 0; i < n; i++) d[i][0] = g[i][0];\\n        for (let i = 0; i < n; i++)\\n            for (let j = 1; j < m; j++)\\n                d[i][j] = g[i][j] - g[i][j - 1];\\n    }\\n    function addRange(x1, y1, x2, y2, v) {\\n        for (let i = x1; i <= x2; i++) {\\n            d[i][y1] += v;\\n            d[i][y2 + 1] -= v;\\n        }\\n    }\\n    function recover() {\\n        let res = [...Array(n)].map(() => Array(m).fill(0));\\n        for (let i = 0; i < n; i++)\\n            for (let j = 0; j < m; j++)\\n                res[i][j] = j == 0 ? d[i][j] : d[i][j] + res[i][j - 1];\\n        return res;\\n    }\\n    function D() {\\n        return d;\\n    }\\n}\\n///////////////////////////////////////////////////////////////\\n\\nconst rangeAddQueries = (n, queries) => {\\n    let g = [...Array(n)].map(() => Array(n).fill(0)), da = new DiffArray2D(g);\\n    for (const [x1, y1, x2, y2] of queries) da.addRange(x1, y1, x2, y2, 1);\\n    let res = da.recover();\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3851459,
                "title": "c-solution",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n^2 + q)\\n   where q is the size of queries array\\n   and n is the size of matrix\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n        vector<vector<int>> mat(n, vector<int> (n,0));\\n        for(int i=0;i<queries.size();i++)\\n        {\\n            int r1=queries[i][0];\\n            int r2=queries[i][2];\\n            int c1=queries[i][1];\\n            int c2=queries[i][3];\\n\\n            mat[r1][c1]+=1;\\n            if(c2+1<n)  mat[r1][c2+1]-=1;\\n            if(r2+1<n)  mat[r2+1][c1]-=1;\\n            if(r2+1<n && c2+1<n)    mat[r2+1][c2+1]+=1;\\n        }\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=1;j<n;j++){\\n                mat[i][j] +=mat[i][j-1];\\n            }\\n        }\\n\\n        for(int j=0;j<n;j++){\\n            for(int i=1;i<n;i++){\\n                mat[i][j] +=mat[i-1][j];\\n            }\\n        }\\n\\n        return mat;\\n    }\\n};\\n\\n```\\n\\n# Complexity\\n- Time complexity: O(n^2 * q)\\n   where q is the size of queries array\\n   and n is the size of matrix\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n//This Solution also gives tle\\nclass Solution {\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n        vector<vector<int>> mat(n, vector<int> (n,0));\\n        for(int i=0;i<queries.size();i++)\\n        {\\n            for(int j=queries[i][0];j<=queries[i][2];j++)\\n            {\\n                for(int k=queries[i][1];k<=queries[i][3];k++)\\n                {\\n                    mat[j][k]++;\\n                }\\n            }\\n        }\\n        return mat;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n        vector<vector<int>> mat(n, vector<int> (n,0));\\n        for(int i=0;i<queries.size();i++)\\n        {\\n            int r1=queries[i][0];\\n            int r2=queries[i][2];\\n            int c1=queries[i][1];\\n            int c2=queries[i][3];\\n\\n            mat[r1][c1]+=1;\\n            if(c2+1<n)  mat[r1][c2+1]-=1;\\n            if(r2+1<n)  mat[r2+1][c1]-=1;\\n            if(r2+1<n && c2+1<n)    mat[r2+1][c2+1]+=1;\\n        }\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=1;j<n;j++){\\n                mat[i][j] +=mat[i][j-1];\\n            }\\n        }\\n\\n        for(int j=0;j<n;j++){\\n            for(int i=1;i<n;i++){\\n                mat[i][j] +=mat[i-1][j];\\n            }\\n        }\\n\\n        return mat;\\n    }\\n};\\n\\n```\n```\\n//This Solution also gives tle\\nclass Solution {\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n        vector<vector<int>> mat(n, vector<int> (n,0));\\n        for(int i=0;i<queries.size();i++)\\n        {\\n            for(int j=queries[i][0];j<=queries[i][2];j++)\\n            {\\n                for(int k=queries[i][1];k<=queries[i][3];k++)\\n                {\\n                    mat[j][k]++;\\n                }\\n            }\\n        }\\n        return mat;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3849015,
                "title": "golang-solution",
                "content": "# Code\\n```go\\nfunc rangeAddQueries(n int, queries [][]int) [][]int {\\n\\tresult := make([][]int, n)\\n\\tfor i := range result {\\n\\t\\tresult[i] = make([]int, n+1)\\n\\t}\\n\\tfor _, query := range queries {\\n\\t\\tfor r := query[0]; r <= query[2]; r++ {\\n\\t\\t\\tresult[r][query[1]]++\\n\\t\\t\\tresult[r][query[3]+1]--\\n\\t\\t}\\n\\t}\\n\\tfor r := range result {\\n\\t\\tfor c := 1; c < n; c++ {\\n\\t\\t\\tresult[r][c] += result[r][c-1]\\n\\t\\t}\\n\\t\\tresult[r] = result[r][:n]\\n\\t}\\n\\treturn result\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc rangeAddQueries(n int, queries [][]int) [][]int {\\n\\tresult := make([][]int, n)\\n\\tfor i := range result {\\n\\t\\tresult[i] = make([]int, n+1)\\n\\t}\\n\\tfor _, query := range queries {\\n\\t\\tfor r := query[0]; r <= query[2]; r++ {\\n\\t\\t\\tresult[r][query[1]]++\\n\\t\\t\\tresult[r][query[3]+1]--\\n\\t\\t}\\n\\t}\\n\\tfor r := range result {\\n\\t\\tfor c := 1; c < n; c++ {\\n\\t\\t\\tresult[r][c] += result[r][c-1]\\n\\t\\t}\\n\\t\\tresult[r] = result[r][:n]\\n\\t}\\n\\treturn result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3795148,
                "title": "use-numpy-to-brute-force",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nnumpy is _blazing_ **fast**\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nbrute force\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def rangeAddQueries(self, n: int, queries: List[List[int]]) -> List[List[int]]:\\n        import numpy as np\\n        a = np.full((n,n), 0)\\n        for row1i, col1i, row2i, col2i in queries:\\n            a[row1i:row2i+1, col1i: col2i+1] +=1\\n        return a.tolist()\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rangeAddQueries(self, n: int, queries: List[List[int]]) -> List[List[int]]:\\n        import numpy as np\\n        a = np.full((n,n), 0)\\n        for row1i, col1i, row2i, col2i in queries:\\n            a[row1i:row2i+1, col1i: col2i+1] +=1\\n        return a.tolist()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3766654,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst you might think to do it with Brute force  but it\\'ll give TLE\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIt can be solved by prefix-sum method\\n# Complexity\\n- Time complexity:O(mxn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n        int m = queries.size();\\n        \\n        // Create a matrix of size n x n initialized with 0\\n        vector<vector<int>> mat(n, vector<int>(n, 0));\\n        \\n        // Iterate over the queries\\n        for (int i = 0; i < m; i++) {\\n            int row1 = queries[i][0];\\n            int col1 = queries[i][1];\\n            int row2 = queries[i][2];\\n            int col2 = queries[i][3];\\n            \\n            // Update the matrix for the range [row1, row2] and column col1\\n            for (int j = row1; j <= row2; j++) {\\n                mat[j][col1] += 1;\\n                \\n                // If col2+1 is within the matrix bounds, subtract 1 from mat[j][col2+1]\\n                if (col2 + 1 < n) {\\n                    mat[j][col2 + 1] += -1;\\n                }\\n            }\\n        }\\n        \\n        // Compute prefix sums for each row of the matrix\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 1; j < n; j++) {\\n                // Add the previous element to the current element\\n                mat[i][j] = mat[i][j] + mat[i][j - 1];\\n            }\\n        }\\n        \\n        // Return the modified matrix\\n        return mat;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n        int m = queries.size();\\n        \\n        // Create a matrix of size n x n initialized with 0\\n        vector<vector<int>> mat(n, vector<int>(n, 0));\\n        \\n        // Iterate over the queries\\n        for (int i = 0; i < m; i++) {\\n            int row1 = queries[i][0];\\n            int col1 = queries[i][1];\\n            int row2 = queries[i][2];\\n            int col2 = queries[i][3];\\n            \\n            // Update the matrix for the range [row1, row2] and column col1\\n            for (int j = row1; j <= row2; j++) {\\n                mat[j][col1] += 1;\\n                \\n                // If col2+1 is within the matrix bounds, subtract 1 from mat[j][col2+1]\\n                if (col2 + 1 < n) {\\n                    mat[j][col2 + 1] += -1;\\n                }\\n            }\\n        }\\n        \\n        // Compute prefix sums for each row of the matrix\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 1; j < n; j++) {\\n                // Add the previous element to the current element\\n                mat[i][j] = mat[i][j] + mat[i][j - 1];\\n            }\\n        }\\n        \\n        // Return the modified matrix\\n        return mat;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3755797,
                "title": "difference-arrays-concept-2d-array",
                "content": "# Intuition\\n/*\\n*** Difference Arrays Concept ****\\nlet us take a 1d array question\\nGiven Q ranges of the form [L,R], find for each point x\\u2208[1,N] the number of ranges that contain that point.\\n\\nbrute force will be o(n^2)\\n\\nto optimize if we can use prefix sum concept\\n\\nlet n=4 and ranges are [0,2],[1,3],[1,2]\\nwe need to check how many  ranges will touch the number present at an index\\nlet take an arr of n+1\\n[0,0,0,0,0]\\nfor [0,2] -[1,0,0,-1,0]  this array prefix sum [1,1,1,0]\\nfor [1,3] -[0,1,0,0,-1] this array prefix sum will be [0,1,1,1,0]\\nnow we can see that for query we can set the range in o(1) after processing \\nall the queries then we will utilize this to generate prefix sum\\n\\nfor same [1,3] if we preform on the diff array after performing [0,2] array\\nit will be like [1,1,0,-1,-1] this array prefix sum will be [1,2,2,1,1]\\n\\nso in this way will use -1 to cut of the sum from the next index that is not our range\\n\\n\\nwe can apply this same concept on 2d array\\n*/\\n\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n\\nvector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) \\n{\\n   \\n    vector<vector<int>>ans(n,vector<int>(n,0));\\n    vector<vector<int>>diffarr(n,vector<int>(n+1,0));\\n    for(int i=0;i<queries.size();i++){\\n        int rstart=queries[i][0];\\n        int rend=queries[i][2];\\n        int cstart=queries[i][1];\\n        int cend=queries[i][3];\\n        for(int j=rstart;j<=rend;j++){\\n            diffarr[j][cstart]+=1;\\n            diffarr[j][cend+1]-=1;\\n        }\\n    }\\n\\n    for(int i=0;i<n;i++){\\n        for(int j=0;j<n;j++){\\n            if(j>0){\\n                diffarr[i][j]+=diffarr[i][j-1];\\n            }\\n            ans[i][j]=diffarr[i][j];\\n        }\\n    }\\n\\n    return ans;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n\\nvector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) \\n{\\n   \\n    vector<vector<int>>ans(n,vector<int>(n,0));\\n    vector<vector<int>>diffarr(n,vector<int>(n+1,0));\\n    for(int i=0;i<queries.size();i++){\\n        int rstart=queries[i][0];\\n        int rend=queries[i][2];\\n        int cstart=queries[i][1];\\n        int cend=queries[i][3];\\n        for(int j=rstart;j<=rend;j++){\\n            diffarr[j][cstart]+=1;\\n            diffarr[j][cend+1]-=1;\\n        }\\n    }\\n\\n    for(int i=0;i<n;i++){\\n        for(int j=0;j<n;j++){\\n            if(j>0){\\n                diffarr[i][j]+=diffarr[i][j-1];\\n            }\\n            ans[i][j]=diffarr[i][j];\\n        }\\n    }\\n\\n    return ans;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3746049,
                "title": "c-python-difference-array-solution-with-explanation",
                "content": "### difference array\\nWe can use differece array to to adding a number of an interval (each query), here is 2d differece array.\\ntc is O(n^2 + q), sc is O(n^2)\\n![image](https://assets.leetcode.com/users/images/1c2f5bca-7d1d-4d2b-a63e-fa6c41ecaece_1689001988.6290648.png)\\n```\\nA is array\\ndifference_array(prefix_array(A)) = prefix_array(difference_array(A))\\ndifference_array and prefix_array are inverse operator for each other.\\n```\\n\\n### python\\n```python\\nclass Solution:\\n    def rangeAddQueries(self, n: int, queries: List[List[int]]) -> List[List[int]]:\\n        diff = [[0] * n for _ in range(n)]\\n        for r1, c1, r2, c2 in queries:\\n\\t\\t\\t# update difference value for 4 corners\\n            diff[r1][c1] += 1\\n            if c2 + 1 < n: diff[r1][c2+1] -= 1\\n            if r2 + 1 < n: diff[r2+1][c1] -= 1\\n            if r2 + 1 < n and c2 + 1 < n: diff[r2+1][c2+1] += 1\\n\\t\\t\\t\\n\\t\\t# calculate prefix sum of difference array\\n        for i in range(n):\\n            for j in range(n):\\n                diff[i][j] += (diff[i-1][j] if i - 1 >= 0 else 0) + (diff[i][j-1] if j - 1 >= 0 else 0) - (diff[i-1][j-1] if i - 1 >= 0 and j - 1 >= 0 else 0)\\n\\n        return diff\\n```\\n### c++\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n        vector<vector<int>> diff (n, vector<int> (n));\\n        for (auto& q: queries) {\\n            diff[q[0]][q[1]] += 1;\\n            if (q[3] + 1 < n) diff[q[0]][q[3]+1] -= 1;\\n            if (q[2] + 1 < n) diff[q[2]+1][q[1]] -= 1;\\n            if (q[3] + 1 < n && q[2] + 1 < n) diff[q[2]+1][q[3]+1] += 1;\\n        }\\n        \\n        for (int i = 0; i < n; i+=1) {\\n            for (int j = 0; j < n; j+=1) \\n                diff[i][j] += (i - 1 >= 0 ? diff[i-1][j]: 0) + (j - 1 >= 0? diff[i][j-1]: 0) - (i - 1 >= 0 && j - 1 >= 0 ?  diff[i-1][j-1]: 0); \\n        }\\n        return diff;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Python",
                    "C",
                    "Array"
                ],
                "code": "```\\nA is array\\ndifference_array(prefix_array(A)) = prefix_array(difference_array(A))\\ndifference_array and prefix_array are inverse operator for each other.\\n```\n```python\\nclass Solution:\\n    def rangeAddQueries(self, n: int, queries: List[List[int]]) -> List[List[int]]:\\n        diff = [[0] * n for _ in range(n)]\\n        for r1, c1, r2, c2 in queries:\\n\\t\\t\\t# update difference value for 4 corners\\n            diff[r1][c1] += 1\\n            if c2 + 1 < n: diff[r1][c2+1] -= 1\\n            if r2 + 1 < n: diff[r2+1][c1] -= 1\\n            if r2 + 1 < n and c2 + 1 < n: diff[r2+1][c2+1] += 1\\n\\t\\t\\t\\n\\t\\t# calculate prefix sum of difference array\\n        for i in range(n):\\n            for j in range(n):\\n                diff[i][j] += (diff[i-1][j] if i - 1 >= 0 else 0) + (diff[i][j-1] if j - 1 >= 0 else 0) - (diff[i-1][j-1] if i - 1 >= 0 and j - 1 >= 0 else 0)\\n\\n        return diff\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n        vector<vector<int>> diff (n, vector<int> (n));\\n        for (auto& q: queries) {\\n            diff[q[0]][q[1]] += 1;\\n            if (q[3] + 1 < n) diff[q[0]][q[3]+1] -= 1;\\n            if (q[2] + 1 < n) diff[q[2]+1][q[1]] -= 1;\\n            if (q[3] + 1 < n && q[2] + 1 < n) diff[q[2]+1][q[3]+1] += 1;\\n        }\\n        \\n        for (int i = 0; i < n; i+=1) {\\n            for (int j = 0; j < n; j+=1) \\n                diff[i][j] += (i - 1 >= 0 ? diff[i-1][j]: 0) + (j - 1 >= 0? diff[i][j-1]: 0) - (i - 1 >= 0 && j - 1 >= 0 ?  diff[i-1][j-1]: 0); \\n        }\\n        return diff;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3731147,
                "title": "golang-prefix-sum-line-sweep",
                "content": "# Code\\n```\\nfunc rangeAddQueries(n int, queries [][]int) [][]int {\\n  mat := make([][]int, n)\\n  for i := 0; i < len(mat); i++ {\\n    mat[i] = make([]int, n)\\n  }\\n  // Let\\'s mark the start and one after the end and then do a prefix sum at the\\n  // end. This is very much like line sweep.\\n  for _, query := range queries {\\n    rowStart, colStart := query[0], query[1]\\n    rowEnd, colEnd := query[2], query[3]\\n    for i := rowStart; i <= rowEnd; i++ {\\n      mat[i][colStart]++\\n      if colEnd+1 < n {\\n        mat[i][colEnd+1]--\\n      }\\n    }\\n  }\\n  for i := 0; i < n; i++ {\\n    for j := 1; j < n; j++ {\\n      mat[i][j] = mat[i][j-1] + mat[i][j]\\n    }\\n  }\\n  return mat\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Line Sweep",
                    "Prefix Sum"
                ],
                "code": "```\\nfunc rangeAddQueries(n int, queries [][]int) [][]int {\\n  mat := make([][]int, n)\\n  for i := 0; i < len(mat); i++ {\\n    mat[i] = make([]int, n)\\n  }\\n  // Let\\'s mark the start and one after the end and then do a prefix sum at the\\n  // end. This is very much like line sweep.\\n  for _, query := range queries {\\n    rowStart, colStart := query[0], query[1]\\n    rowEnd, colEnd := query[2], query[3]\\n    for i := rowStart; i <= rowEnd; i++ {\\n      mat[i][colStart]++\\n      if colEnd+1 < n {\\n        mat[i][colEnd+1]--\\n      }\\n    }\\n  }\\n  for i := 0; i < n; i++ {\\n    for j := 1; j < n; j++ {\\n      mat[i][j] = mat[i][j-1] + mat[i][j]\\n    }\\n  }\\n  return mat\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3716513,
                "title": "c-math-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n        vector<vector<int>> ans(n,vector<int>(n,0));\\n        for(auto x : queries){\\n            int x1=x[0];\\n            int y1=x[1];\\n            int x2=x[2];\\n            int y2=x[3];\\n            y2++;\\n            for(int i=x1;i<=x2;i++){\\n                ans[i][y1]++;\\n            }\\n            if(y2<n){\\n                for(int i=x1;i<=x2;i++){\\n                    ans[i][y2]--;\\n                }\\n            }\\n        }\\n        for(int j=1;j<n;j++){\\n            for(int i=0;i<n;i++){\\n                ans[i][j]+=ans[i][j-1];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n        vector<vector<int>> ans(n,vector<int>(n,0));\\n        for(auto x : queries){\\n            int x1=x[0];\\n            int y1=x[1];\\n            int x2=x[2];\\n            int y2=x[3];\\n            y2++;\\n            for(int i=x1;i<=x2;i++){\\n                ans[i][y1]++;\\n            }\\n            if(y2<n){\\n                for(int i=x1;i<=x2;i++){\\n                    ans[i][y2]--;\\n                }\\n            }\\n        }\\n        for(int j=1;j<n;j++){\\n            for(int i=0;i<n;i++){\\n                ans[i][j]+=ans[i][j-1];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3696749,
                "title": "c-solution-using-for-loops",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe key to solving this problem in C# is 1. initializing the jagged array and 2. for each int[] of queries, properly incrementing the array elements.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Instantiate int[][] **matrix** with the size of **n** --> var matrix = new int[n][];\\n2. For each row of **matrix**, instantiate new int[n] --> use foreach loop\\n3. Create a helper method **processSubmatrix** with the parameter of int[] --> void processSubmatrix(int[] query)\\n4. Create two for loops to iterate through all elements of a given query that starts from row1, col1 to row2, col2\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n) - to be more specific, the size of each query (the worstcase is n) * the number of queries\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\npublic class Solution {\\n    public int[][] RangeAddQueries(int n, int[][] queries) {\\n\\n        var matrix = new int[n][];\\n        for (int i = 0; i < n; i++)\\n        {\\n            matrix[i] = new int[n];\\n        }\\n\\n        foreach (var query in queries)\\n        {\\n            processSubmatrix(query);\\n        }\\n        \\n        return matrix;\\n\\n        void processSubmatrix(int[] query)\\n        {\\n            int row1 = query[0], col1 = query[1], row2 = query[2], col2 = query[3];\\n            for (int i = row1; i <= row2; i++)\\n            {\\n                for (int j = col1; j <= col2; j++)\\n                {\\n                    matrix[i][j]++;\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int[][] RangeAddQueries(int n, int[][] queries) {\\n\\n        var matrix = new int[n][];\\n        for (int i = 0; i < n; i++)\\n        {\\n            matrix[i] = new int[n];\\n        }\\n\\n        foreach (var query in queries)\\n        {\\n            processSubmatrix(query);\\n        }\\n        \\n        return matrix;\\n\\n        void processSubmatrix(int[] query)\\n        {\\n            int row1 = query[0], col1 = query[1], row2 = query[2], col2 = query[3];\\n            for (int i = row1; i <= row2; i++)\\n            {\\n                for (int j = col1; j <= col2; j++)\\n                {\\n                    matrix[i][j]++;\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3658317,
                "title": "easy-faster-efficient-java-soln",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] rangeAddQueries(int n, int[][] queries) {\\n        int [][] arr = new int[n][n];\\n        for(int [] q : queries){\\n            int r1 = q[0];\\n            int c1 = q[1];\\n            int r2 = q[2];\\n            int c2 = q[3];\\n            for(int i = r1; i <= r2; i++){\\n                arr[i][c1] += 1;\\n                if(c2 + 1 < n){\\n                    arr[i][c2 + 1] -= 1;\\n                }\\n            }\\n        }\\n        for(int i = 0; i < n; i++){\\n            for(int j = 1; j < n; j++){\\n                arr[i][j] += arr[i][j - 1];\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] rangeAddQueries(int n, int[][] queries) {\\n        int [][] arr = new int[n][n];\\n        for(int [] q : queries){\\n            int r1 = q[0];\\n            int c1 = q[1];\\n            int r2 = q[2];\\n            int c2 = q[3];\\n            for(int i = r1; i <= r2; i++){\\n                arr[i][c1] += 1;\\n                if(c2 + 1 < n){\\n                    arr[i][c2 + 1] -= 1;\\n                }\\n            }\\n        }\\n        for(int i = 0; i < n; i++){\\n            for(int j = 1; j < n; j++){\\n                arr[i][j] += arr[i][j - 1];\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3649430,
                "title": "solution-c-prefix-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n        vector<vector<int>> res(n, vector<int> (n, 0));\\n        for(vector<int> q: queries){\\n            int r1 = q[0], c1 = q[1], r2 = q[2], c2 = q[3];\\n            for(int i = c1; i <= c2; i++){\\n                res[r1][i] += 1;\\n                if(r2 + 1 < n) res[r2 + 1][i] -= 1;\\n            }\\n        }\\n\\n        for(int i = 0; i < n; i++){\\n            for(int j = 1; j < n; j++){\\n                res[j][i] += res[j-1][i];\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n        vector<vector<int>> res(n, vector<int> (n, 0));\\n        for(vector<int> q: queries){\\n            int r1 = q[0], c1 = q[1], r2 = q[2], c2 = q[3];\\n            for(int i = c1; i <= c2; i++){\\n                res[r1][i] += 1;\\n                if(r2 + 1 < n) res[r2 + 1][i] -= 1;\\n            }\\n        }\\n\\n        for(int i = 0; i < n; i++){\\n            for(int j = 1; j < n; j++){\\n                res[j][i] += res[j-1][i];\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3634277,
                "title": "scanline-algorithm-beats-100-in-space",
                "content": "\\n# Complexity\\n- Time complexity:\\n    o(K*n)\\n\\n- Space complexity:\\n    o(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n        vector<vector<int>> matrix(n,vector<int>(n,0));\\n        for(int k = 0; k < queries.size() ;k++){\\n            int x1 = queries[k][0], y1 = queries[k][1];\\n            int x2 = queries[k][2], y2 = queries[k][3];\\n            for(int i = x1; i <= x2; i++){\\n                matrix[i][y1] += 1;\\n                if(y2 < n -1){\\n                    matrix[i][y2+1] += -1;\\n                }\\n            }\\n        }\\n        for(int i = 0; i < n; i++){\\n            for(int j = 1; j < n; j++){\\n                matrix[i][j] = matrix[i][j] + matrix[i][j-1];\\n            }\\n        }\\n\\n        return matrix;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n        vector<vector<int>> matrix(n,vector<int>(n,0));\\n        for(int k = 0; k < queries.size() ;k++){\\n            int x1 = queries[k][0], y1 = queries[k][1];\\n            int x2 = queries[k][2], y2 = queries[k][3];\\n            for(int i = x1; i <= x2; i++){\\n                matrix[i][y1] += 1;\\n                if(y2 < n -1){\\n                    matrix[i][y2+1] += -1;\\n                }\\n            }\\n        }\\n        for(int i = 0; i < n; i++){\\n            for(int j = 1; j < n; j++){\\n                matrix[i][j] = matrix[i][j] + matrix[i][j-1];\\n            }\\n        }\\n\\n        return matrix;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3589264,
                "title": "single-letter-variable-names",
                "content": "```c++\\nclass Solution {\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n        vector<vector<int>> g(n + 1, vector<int>(n + 1, 0));\\n        for (auto &q : queries) {\\n            auto &t = g[q[0]], &b = g[q[2] + 1];\\n            auto l = q[1], r = q[3] + 1;\\n            ++t[l], --t[r], --b[l], ++b[r];\\n        }\\n        g.pop_back(); auto &r = g[0];\\n        for (int s = 0, i = -1; ++i < n; r[i] = s += r[i])\\n            g[i].pop_back();\\n        for (int i = 0; ++i < n;) {\\n            auto &c = g[i], &h = g[i - 1];\\n            for (int s = 0, j = -1; ++j < n;)\\n                c[j] = (s += c[j]) + h[j];\\n        }\\n        return g;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Line Sweep",
                    "Prefix Sum"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n        vector<vector<int>> g(n + 1, vector<int>(n + 1, 0));\\n        for (auto &q : queries) {\\n            auto &t = g[q[0]], &b = g[q[2] + 1];\\n            auto l = q[1], r = q[3] + 1;\\n            ++t[l], --t[r], --b[l], ++b[r];\\n        }\\n        g.pop_back(); auto &r = g[0];\\n        for (int s = 0, i = -1; ++i < n; r[i] = s += r[i])\\n            g[i].pop_back();\\n        for (int i = 0; ++i < n;) {\\n            auto &c = g[i], &h = g[i - 1];\\n            for (int s = 0, j = -1; ++j < n;)\\n                c[j] = (s += c[j]) + h[j];\\n        }\\n        return g;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3583266,
                "title": "java-3-line-brute-force-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int[][] rangeAddQueries(int n, int[][] queries) {\\n        int[][] res = new int[n][n];\\n        for (int[] q : queries) for (int r = q[0]; r <= q[2]; r++) for (int c = q[1]; c <= q[3]; c++) res[r][c]++;\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] rangeAddQueries(int n, int[][] queries) {\\n        int[][] res = new int[n][n];\\n        for (int[] q : queries) for (int r = q[0]; r <= q[2]; r++) for (int c = q[1]; c <= q[3]; c++) res[r][c]++;\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3550341,
                "title": "774-ms",
                "content": "```ruby\\ndef range_add_queries n, q\\n    g = Array.new n do [0] * n end\\n    q.each do | r1, c1, r2, c2 |\\n        g[r1][c1] += 1\\n        r2v, c2v = (r2 += 1) < n, (c2 += 1) < n\\n        g[r1][c2] -= 1 if c2v\\n        g[r2][c1] -= 1 if r2v\\n        g[r2][c2] += 1 if c2v && r2v\\n    end\\n    s = 0; g.first.map! { s += _1 }\\n    for i in 1...n\\n        p, r, t = 0, g[i], g[i.pred]\\n        n.times { r[_1] = (p += r[_1]) + t[_1] }\\n    end\\n    g\\nend\\n```\\n\"Branchless\" queries:\\n```ruby\\ndef range_add_queries n, q\\n    g = Array.new(n.succ) { [0] * n.succ }\\n    q.each do | r1, c1, r2, c2 |\\n        (t = g[r1])[c1] += 1; t[c2 += 1] -= 1\\n        (b = g[r2 + 1])[c1] -= 1; b[c2] += 1\\n    end\\n    g.pop; g.each(&:pop)\\n    s = 0; g.first.map! { s += _1 }\\n    for i in 1...n\\n        p, r, t = 0, g[i], g[i.pred]\\n        n.times { r[_1] = (p += r[_1]) + t[_1] }\\n    end\\n    g\\nend\\n```",
                "solutionTags": [
                    "Ruby",
                    "Line Sweep",
                    "Prefix Sum"
                ],
                "code": "```ruby\\ndef range_add_queries n, q\\n    g = Array.new n do [0] * n end\\n    q.each do | r1, c1, r2, c2 |\\n        g[r1][c1] += 1\\n        r2v, c2v = (r2 += 1) < n, (c2 += 1) < n\\n        g[r1][c2] -= 1 if c2v\\n        g[r2][c1] -= 1 if r2v\\n        g[r2][c2] += 1 if c2v && r2v\\n    end\\n    s = 0; g.first.map! { s += _1 }\\n    for i in 1...n\\n        p, r, t = 0, g[i], g[i.pred]\\n        n.times { r[_1] = (p += r[_1]) + t[_1] }\\n    end\\n    g\\nend\\n```\n```ruby\\ndef range_add_queries n, q\\n    g = Array.new(n.succ) { [0] * n.succ }\\n    q.each do | r1, c1, r2, c2 |\\n        (t = g[r1])[c1] += 1; t[c2 += 1] -= 1\\n        (b = g[r2 + 1])[c1] -= 1; b[c2] += 1\\n    end\\n    g.pop; g.each(&:pop)\\n    s = 0; g.first.map! { s += _1 }\\n    for i in 1...n\\n        p, r, t = 0, g[i], g[i.pred]\\n        n.times { r[_1] = (p += r[_1]) + t[_1] }\\n    end\\n    g\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3506919,
                "title": "java-easy-to-understand-beats-90-mark-boundary-for-each-row",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] rangeAddQueries(int n, int[][] queries) {\\n        int[][] result=new int[n][n];\\n        for(int[] query:queries) {\\n            int sr=query[0],sc=query[1],er=query[2],ec=query[3];\\n            for(int i=sr;i<=er;i++) {\\n                result[i][sc]++;\\n                if(ec+1<n) {\\n                    result[i][ec+1]--;\\n                }\\n            }\\n        }\\n        for(int i=0;i<n;i++) {\\n            int sum=0;\\n            for(int j=0;j<n;j++) {\\n                sum+=result[i][j];\\n                result[i][j]=sum;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] rangeAddQueries(int n, int[][] queries) {\\n        int[][] result=new int[n][n];\\n        for(int[] query:queries) {\\n            int sr=query[0],sc=query[1],er=query[2],ec=query[3];\\n            for(int i=sr;i<=er;i++) {\\n                result[i][sc]++;\\n                if(ec+1<n) {\\n                    result[i][ec+1]--;\\n                }\\n            }\\n        }\\n        for(int i=0;i<n;i++) {\\n            int sum=0;\\n            for(int j=0;j<n;j++) {\\n                sum+=result[i][j];\\n                result[i][j]=sum;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3506912,
                "title": "c-easy-to-understand-mark-boundaries",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n        vector<vector<int>> result(n,vector<int>(n,0));\\n        for(auto query:queries) {\\n            int sr=query[0],sc=query[1],er=query[2],ec=query[3];\\n            for(int i=sr;i<=er;i++) {\\n                result[i][sc]++;\\n                if(ec+1<n) {\\n                    result[i][ec+1]--;\\n                }\\n            }\\n        }\\n        for(int i=0;i<n;i++) {\\n            int sum=0;\\n            for(int j=0;j<n;j++) {\\n                sum+=result[i][j];\\n                result[i][j]=sum;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n        vector<vector<int>> result(n,vector<int>(n,0));\\n        for(auto query:queries) {\\n            int sr=query[0],sc=query[1],er=query[2],ec=query[3];\\n            for(int i=sr;i<=er;i++) {\\n                result[i][sc]++;\\n                if(ec+1<n) {\\n                    result[i][ec+1]--;\\n                }\\n            }\\n        }\\n        for(int i=0;i<n;i++) {\\n            int sum=0;\\n            for(int j=0;j<n;j++) {\\n                sum+=result[i][j];\\n                result[i][j]=sum;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3497629,
                "title": "go-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc rangeAddQueries(n int, q [][]int) [][]int {\\n   mat := make([][]int, 0)\\n\\tfor i := 0; i < n; i++ {\\n\\t\\ttemp := make([]int, n)\\n\\t\\tmat = append(mat, temp)\\n\\t}\\n\\tfor i := range q {\\n\\t\\trow1 := q[i][0]\\n\\t\\tcol1 := q[i][1]\\n\\t\\trow2 := q[i][2]\\n\\t\\tcol2 := q[i][3]\\n\\t\\tfor j := row1; j <= row2; j++ {\\n\\t\\t\\tfor k := col1; k <= col2; k++ {\\n\\t\\t\\t\\tmat[j][k] = mat[j][k] + 1\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n    return mat \\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc rangeAddQueries(n int, q [][]int) [][]int {\\n   mat := make([][]int, 0)\\n\\tfor i := 0; i < n; i++ {\\n\\t\\ttemp := make([]int, n)\\n\\t\\tmat = append(mat, temp)\\n\\t}\\n\\tfor i := range q {\\n\\t\\trow1 := q[i][0]\\n\\t\\tcol1 := q[i][1]\\n\\t\\trow2 := q[i][2]\\n\\t\\tcol2 := q[i][3]\\n\\t\\tfor j := row1; j <= row2; j++ {\\n\\t\\t\\tfor k := col1; k <= col2; k++ {\\n\\t\\t\\t\\tmat[j][k] = mat[j][k] + 1\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n    return mat \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3490392,
                "title": "clean-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& q) \\n    {\\n       vector<vector<int>> res (n,vector<int>(n,0));\\n       for(int i = 0 ; i<q.size();i++)\\n       {\\n           int r1 = q[i][0];\\n           int r2 = q[i][2];\\n           int c1 = q[i][1];\\n           int c2 = q[i][3];\\n           for(int j = r1;j<=r2;j++)\\n           {\\n                res[j][c1] += 1; \\n                if(c2+1<n)\\n                res[j][c2+1] += -1; \\n           }\\n         \\n       } \\n       \\n\\n\\n       for(int i =0; i<n;i++)\\n       {\\n           for(int  j =1 ; j<n;j++)\\n           res[i][j] =  res[i][j] + res[i][j-1];\\n       }\\n\\n       return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& q) \\n    {\\n       vector<vector<int>> res (n,vector<int>(n,0));\\n       for(int i = 0 ; i<q.size();i++)\\n       {\\n           int r1 = q[i][0];\\n           int r2 = q[i][2];\\n           int c1 = q[i][1];\\n           int c2 = q[i][3];\\n           for(int j = r1;j<=r2;j++)\\n           {\\n                res[j][c1] += 1; \\n                if(c2+1<n)\\n                res[j][c2+1] += -1; \\n           }\\n         \\n       } \\n       \\n\\n\\n       for(int i =0; i<n;i++)\\n       {\\n           for(int  j =1 ; j<n;j++)\\n           res[i][j] =  res[i][j] + res[i][j-1];\\n       }\\n\\n       return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3471553,
                "title": "java-sweep-line",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJava implementation of [solution](https://leetcode.com/problems/increment-submatrices-by-one/solutions/3052675/python3-sweep-line-range-addition-w-visualization-clean-concise/?orderBy=most_votes)\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n * n + k) k is the length of queries.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] rangeAddQueries(int n, int[][] queries) {\\n        int[][] res = new int[n][n];\\n        for(int[] query: queries){\\n            int row1 = query[0], col1 = query[1], row2 =  query[2], col2 = query[3];\\n            res[row1][col1]++;\\n            if(row2 + 1 < n) res[row2 + 1][col1]--;\\n            if(col2 + 1 < n) res[row1][col2 + 1]--;\\n            if(row2 + 1 < n && col2 + 1 < n)  res[row2 + 1][col2 + 1]++;\\n        }\\n        for(int i = 0; i < n; ++i){\\n            for(int j = 1; j < n; ++j)\\n                res[i][j] += res[i][j - 1];\\n        }\\n        for(int j = 0; j < n; ++j){\\n            for(int i = 1; i < n; ++i){\\n                res[i][j] += res[i - 1][j];\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] rangeAddQueries(int n, int[][] queries) {\\n        int[][] res = new int[n][n];\\n        for(int[] query: queries){\\n            int row1 = query[0], col1 = query[1], row2 =  query[2], col2 = query[3];\\n            res[row1][col1]++;\\n            if(row2 + 1 < n) res[row2 + 1][col1]--;\\n            if(col2 + 1 < n) res[row1][col2 + 1]--;\\n            if(row2 + 1 < n && col2 + 1 < n)  res[row2 + 1][col2 + 1]++;\\n        }\\n        for(int i = 0; i < n; ++i){\\n            for(int j = 1; j < n; ++j)\\n                res[i][j] += res[i][j - 1];\\n        }\\n        for(int j = 0; j < n; ++j){\\n            for(int i = 1; i < n; ++i){\\n                res[i][j] += res[i - 1][j];\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3451361,
                "title": "c-brute-force",
                "content": "# Intuition\\nUse brute force.\\n\\n# Approach\\nUse brute force.\\n3 nested cycles:\\n- outer cycle goes through queries\\n- 1st inner cycle goes through rows\\n- 2nd inner cycle goes through columns\\n\\n# Complexity\\n- Time complexity:\\n$$O(len(queries) * n^2)$$ -->\\n\\n- Space complexity:\\n$$O(n^2)$$\\n\\n# Code\\n```\\npublic class Solution {\\n    public int[][] RangeAddQueries(int n, int[][] queries) {\\n        var rs = CreateMatrix(n);\\n        for (int k = 0; k < queries.Length; k++)\\n        {\\n            for (int i = queries[k][0]; i <= queries[k][2]; i++)\\n            {\\n                for (int j = queries[k][1]; j <= queries[k][3]; j++)\\n                {\\n                    rs[i][j]++;\\n                }\\n            }\\n        }\\n        return rs;\\n    }\\n    private int[][] CreateMatrix(int n)\\n    {\\n        var rs = new int[n][];\\n        for (int i = 0; i < rs.Length; i++)\\n        {\\n            rs[i] = new int[n];\\n        }\\n        return rs;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int[][] RangeAddQueries(int n, int[][] queries) {\\n        var rs = CreateMatrix(n);\\n        for (int k = 0; k < queries.Length; k++)\\n        {\\n            for (int i = queries[k][0]; i <= queries[k][2]; i++)\\n            {\\n                for (int j = queries[k][1]; j <= queries[k][3]; j++)\\n                {\\n                    rs[i][j]++;\\n                }\\n            }\\n        }\\n        return rs;\\n    }\\n    private int[][] CreateMatrix(int n)\\n    {\\n        var rs = new int[n][];\\n        for (int i = 0; i < rs.Length; i++)\\n        {\\n            rs[i] = new int[n];\\n        }\\n        return rs;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3368851,
                "title": "simple-java-solution-the-basis-of-prefix-sum-questions",
                "content": "# Code\\n```\\nclass Solution {\\n    //TC: O(n2) SC: O(1)\\n    public int[][] rangeAddQueries(int n, int[][] queries) {\\n        int[][] dp = new int[n][n];\\n\\n        for(int[] query : queries){\\n            int startRow = query[0];\\n            int startCol = query[1];\\n            int endRow = query[2];\\n            int endCol = query[3];\\n            for(int i = startRow; i <= endRow; i++){\\n                for(int j = startCol; j <= endCol; j++){\\n                    dp[i][j] += 1;\\n                }\\n            }\\n        }\\n\\n        return dp;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    //TC: O(n2) SC: O(1)\\n    public int[][] rangeAddQueries(int n, int[][] queries) {\\n        int[][] dp = new int[n][n];\\n\\n        for(int[] query : queries){\\n            int startRow = query[0];\\n            int startCol = query[1];\\n            int endRow = query[2];\\n            int endCol = query[3];\\n            for(int i = startRow; i <= endRow; i++){\\n                for(int j = startCol; j <= endCol; j++){\\n                    dp[i][j] += 1;\\n                }\\n            }\\n        }\\n\\n        return dp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3361740,
                "title": "simple-c-prefix-sum-o-n-2-nq-solution",
                "content": "<!-- # Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- # Complexity -->\\n<!-- - Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity:\\nAdd your space complexity here, e.g. $$O(n)$$ --> \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n        vector<vector<int>> t(n, vector<int>(n,0));\\n        for(vector<int> q:queries){\\n            fillin(t, q);\\n        }\\n        for(int i=0; i<n; i++){\\n            for(int j=1;j<n;j++)\\n                t[i][j]+=t[i][j-1];\\n        }\\n        return t;\\n    }\\n    void fillin(vector<vector<int>> &t, vector<int> &q){\\n        for(int i=q[0]; i<=q[2]; i++){\\n                t[i][q[1]]++;\\n                if(q[3]!=t.size()-1)\\n                    t[i][q[3]+1]--;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n        vector<vector<int>> t(n, vector<int>(n,0));\\n        for(vector<int> q:queries){\\n            fillin(t, q);\\n        }\\n        for(int i=0; i<n; i++){\\n            for(int j=1;j<n;j++)\\n                t[i][j]+=t[i][j-1];\\n        }\\n        return t;\\n    }\\n    void fillin(vector<vector<int>> &t, vector<int> &q){\\n        for(int i=q[0]; i<=q[2]; i++){\\n                t[i][q[1]]++;\\n                if(q[3]!=t.size()-1)\\n                    t[i][q[3]+1]--;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3350314,
                "title": "c-prefix-sum-faster-easy-to-understand",
                "content": "* ***Prefix Sum***\\n\\n* ***Time Complexity :- O(Q * N)***\\n\\n* ***Space Complexity :- O(N * N)***\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n        \\n        // declare a 2D array\\n        \\n        vector<vector<int>> mat(n, vector<int> (n, 0));\\n        \\n        // traverse over the queries and perform the operations\\n        \\n        for(int i = 0; i < queries.size(); i++)\\n        {\\n            int row1 = queries[i][0], col1 = queries[i][1], row2 = queries[i][2], col2 = queries[i][3];\\n            \\n            for(int j = row1; j <= row2; j++)\\n            {\\n                mat[j][col1]++;\\n                \\n                if(1 + col2 < n)\\n                {\\n                    mat[j][col2 + 1]--;\\n                }\\n            }\\n        }\\n        \\n        // find the prefix sum of each row\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 1; j < n; j++)\\n            {\\n                mat[i][j] += mat[i][j - 1];\\n            }\\n        }\\n        \\n        return mat;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Matrix",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n        \\n        // declare a 2D array\\n        \\n        vector<vector<int>> mat(n, vector<int> (n, 0));\\n        \\n        // traverse over the queries and perform the operations\\n        \\n        for(int i = 0; i < queries.size(); i++)\\n        {\\n            int row1 = queries[i][0], col1 = queries[i][1], row2 = queries[i][2], col2 = queries[i][3];\\n            \\n            for(int j = row1; j <= row2; j++)\\n            {\\n                mat[j][col1]++;\\n                \\n                if(1 + col2 < n)\\n                {\\n                    mat[j][col2 + 1]--;\\n                }\\n            }\\n        }\\n        \\n        // find the prefix sum of each row\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 1; j < n; j++)\\n            {\\n                mat[i][j] += mat[i][j - 1];\\n            }\\n        }\\n        \\n        return mat;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3313814,
                "title": "java-optimal-solution-using-2d-prefix-sums-2-pass",
                "content": "\\n```\\nclass Solution {\\n    public int[][] rangeAddQueries(int N, int[][] Q) {\\n        int[][] G = new int[N][N];\\n        for(int[] q : Q){\\n            int r1=q[0], c1=q[1], r2=q[2], c2=q[3];\\n            G[r1][c1]++; \\n            if(c2<N-1) \\n                G[r1][c2+1]--;\\n            if(r2<N-1)\\n                G[r2+1][c1]--;\\n            if(c2<N-1 && r2<N-1)\\n                G[r2+1][c2+1]++;\\n            \\n        }\\n\\n        for(int i=0; i<N; i++){\\n            for(int j=0; j<N; j++){\\n                if(i>0) G[i][j] += G[i-1][j];\\n                if(j>0) G[i][j] += G[i][j-1];\\n                if(i>0 && j>0) G[i][j] -= G[i-1][j-1];\\n            }\\n        }\\n\\n                \\n         \\n        return G;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] rangeAddQueries(int N, int[][] Q) {\\n        int[][] G = new int[N][N];\\n        for(int[] q : Q){\\n            int r1=q[0], c1=q[1], r2=q[2], c2=q[3];\\n            G[r1][c1]++; \\n            if(c2<N-1) \\n                G[r1][c2+1]--;\\n            if(r2<N-1)\\n                G[r2+1][c1]--;\\n            if(c2<N-1 && r2<N-1)\\n                G[r2+1][c2+1]++;\\n            \\n        }\\n\\n        for(int i=0; i<N; i++){\\n            for(int j=0; j<N; j++){\\n                if(i>0) G[i][j] += G[i-1][j];\\n                if(j>0) G[i][j] += G[i][j-1];\\n                if(i>0 && j>0) G[i][j] -= G[i-1][j-1];\\n            }\\n        }\\n\\n                \\n         \\n        return G;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3300667,
                "title": "dart-query-brute-force",
                "content": "# Code\\n```\\nclass Solution {\\n  List<List<int>> rangeAddQueries(int n, List<List<int>> queries) {\\n    List<List<int>> mat = List.generate(\\n      n,\\n      (index) => List.filled(n, 0),\\n    );\\n    for (var q in queries) {\\n      int r1 = q[0], c1 = q[1], r2 = q[2], c2 = q[3];\\n      for (var i = r1; i <= r2; i++) {\\n        for (var j = c1; j <= c2; j++) {\\n          mat[i][j] = mat[i][j] + 1;\\n        }\\n      }\\n    }\\n\\n    return mat;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  List<List<int>> rangeAddQueries(int n, List<List<int>> queries) {\\n    List<List<int>> mat = List.generate(\\n      n,\\n      (index) => List.filled(n, 0),\\n    );\\n    for (var q in queries) {\\n      int r1 = q[0], c1 = q[1], r2 = q[2], c2 = q[3];\\n      for (var i = r1; i <= r2; i++) {\\n        for (var j = c1; j <= c2; j++) {\\n          mat[i][j] = mat[i][j] + 1;\\n        }\\n      }\\n    }\\n\\n    return mat;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3287622,
                "title": "python-solution-beats-95",
                "content": "![Screenshot 2023-03-12 at 10.56.09.png](https://assets.leetcode.com/users/images/236f0676-5625-49fc-9e38-93c451050211_1678611461.091891.png)\\n\\n# Approach\\n\\n1. The rangeAddQueries function takes two parameters:\\nn is the size of the square matrix to be created (n x n).\\nqueries is a list of 2D integer arrays, each representing a query.\\n2. We start by initializing the matrix mat with all zeroes, using a list comprehension.\\n3. We then loop through each query in queries, and for each query, we update the values in the corresponding submatrix using the following logic:\\n4. Increment the value at the top left corner of the submatrix by 1.\\n5. Decrement the value at the bottom left corner of the submatrix + 1 by 1.\\n6. Decrement the value at the top right corner of the submatrix + 1 by 1.\\n7. Increment the value at the bottom right corner of the submatrix + 1 by 1.\\n8. After performing all the queries, we update the matrix mat using the following logic:\\n9. For each row, we loop through all the columns and update each value by adding the value to its left.\\n10. For each column, we loop through all the rows and update each value by adding the value above it.\\n11. Finally, we return the updated matrix mat.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of this algorithm is O(q + n^2), where q is the number of queries and n is the size of the matrix. So, O(n^2).\\n\\n- Space complexity:\\nThe space complexity is also O(n^2), as we need to create the mat matrix.\\n\\n# More\\n\\nMore LeetCode solutions of mine at .\\n\\n# Code\\n```\\nclass Solution:\\n    def rangeAddQueries(self, n: int, queries: List[List[int]]) -> List[List[int]]:\\n        # initialize the matrix with all zeroes\\n        mat = [[0] * n for _ in range(n)]\\n        \\n        # perform the queries\\n        for row1, col1, row2, col2 in queries:\\n            mat[row1][col1] += 1\\n            if row2+1 < n:\\n                mat[row2+1][col1] -= 1\\n            if col2+1 < n:\\n                mat[row1][col2+1] -= 1\\n            if row2+1 < n and col2+1 < n:\\n                mat[row2+1][col2+1] += 1\\n        \\n        # update the matrix\\n        for i in range(n):\\n            for j in range(1, n):\\n                mat[i][j] += mat[i][j-1]\\n        \\n        for i in range(1, n):\\n            for j in range(n):\\n                mat[i][j] += mat[i-1][j]\\n        \\n        return mat\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def rangeAddQueries(self, n: int, queries: List[List[int]]) -> List[List[int]]:\\n        # initialize the matrix with all zeroes\\n        mat = [[0] * n for _ in range(n)]\\n        \\n        # perform the queries\\n        for row1, col1, row2, col2 in queries:\\n            mat[row1][col1] += 1\\n            if row2+1 < n:\\n                mat[row2+1][col1] -= 1\\n            if col2+1 < n:\\n                mat[row1][col2+1] -= 1\\n            if row2+1 < n and col2+1 < n:\\n                mat[row2+1][col2+1] += 1\\n        \\n        # update the matrix\\n        for i in range(n):\\n            for j in range(1, n):\\n                mat[i][j] += mat[i][j-1]\\n        \\n        for i in range(1, n):\\n            for j in range(n):\\n                mat[i][j] += mat[i-1][j]\\n        \\n        return mat\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3257148,
                "title": "java-row-column-sweep-clear-explanations",
                "content": "# Approach\\n1. Declare an int[][] markings that will contain the marking of increment/decrement, but will also contain the answer to the problem\\n2. For each query, mark the rows query[0]..query[2] column query[1] with +1 and query[3]+1 with  -1.\\n3. Folling step 2, traverse each row and use a rollingSum to add the value of the marking. Set cell value to the value of the rollingValue.\\n4. When a cell will have a marking of -1, then the rollingValue will decrease and the following cells on that row will have value 0.\\n    - EG: supposing row[x] is [0,0,0,1,0,0,-1,0]\\n    - when traversing it, as soon as we hit index 3, the rollingSum becomes 1. The ongoing cells will have the value 1.\\n    - when hitting index 6, the rolling sum becomes 0 (1-1) so the folling cells will have value 0.\\n\\n# Complexity\\n- Time complexity:$$O(n + ql * qr)$$ (queryLength * rowsOfEachQuery)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] rangeAddQueries(int n, int[][] queries) {\\n        int[][] markings = getMarkingMatrix(n, queries);\\n        int rollingValue;\\n        for (int i = 0; i < n; i++) {\\n            rollingValue = 0;\\n            for(int j = 0; j < n; j++) {\\n                rollingValue += markings[i][j];\\n                markings[i][j] = rollingValue;\\n            }\\n        }\\n        return markings;\\n    }\\n\\n    private int[][] getMarkingMatrix(int n, int[][] queries) {\\n        int[][] markings = new int[n][n];\\n        for (int[] query : queries) {\\n            for(int i = query[0]; i <= query[2]; i++) {\\n                markings[i][query[1]]++;\\n                if(query[3] < n-1) {\\n                    markings[i][query[3]+1]--;\\n                }\\n            }\\n        }\\n        return markings;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Line Sweep"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] rangeAddQueries(int n, int[][] queries) {\\n        int[][] markings = getMarkingMatrix(n, queries);\\n        int rollingValue;\\n        for (int i = 0; i < n; i++) {\\n            rollingValue = 0;\\n            for(int j = 0; j < n; j++) {\\n                rollingValue += markings[i][j];\\n                markings[i][j] = rollingValue;\\n            }\\n        }\\n        return markings;\\n    }\\n\\n    private int[][] getMarkingMatrix(int n, int[][] queries) {\\n        int[][] markings = new int[n][n];\\n        for (int[] query : queries) {\\n            for(int i = query[0]; i <= query[2]; i++) {\\n                markings[i][query[1]]++;\\n                if(query[3] < n-1) {\\n                    markings[i][query[3]+1]--;\\n                }\\n            }\\n        }\\n        return markings;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3219390,
                "title": "using-prefix-sum-logic",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n        vector <vector <int>> ans(n, vector <int> (n, 0));\\n        int a, b, c, d, i, j;\\n        for (auto q : queries) {\\n            ans[q[0]][q[1]]++;\\n            if (q[3] + 1 < n)\\n            ans[q[0]][q[3] + 1]--;\\n            if (q[2] + 1 < n) {\\n                ans[q[2] + 1][q[1]]--;\\n                if (q[3] + 1 < n)\\n                ans[q[2] + 1][q[3] + 1]++;\\n            }\\n        }\\n        for (i=0;i<n;i++) {\\n            for (j=1;j<n;j++) {\\n                ans[j][i] += ans[j-1][i];\\n            }\\n        }\\n        for (i=0;i<n;i++) {\\n            for (j=1;j<n;j++) {\\n                ans[i][j] += ans[i][j-1];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n        vector <vector <int>> ans(n, vector <int> (n, 0));\\n        int a, b, c, d, i, j;\\n        for (auto q : queries) {\\n            ans[q[0]][q[1]]++;\\n            if (q[3] + 1 < n)\\n            ans[q[0]][q[3] + 1]--;\\n            if (q[2] + 1 < n) {\\n                ans[q[2] + 1][q[1]]--;\\n                if (q[3] + 1 < n)\\n                ans[q[2] + 1][q[3] + 1]++;\\n            }\\n        }\\n        for (i=0;i<n;i++) {\\n            for (j=1;j<n;j++) {\\n                ans[j][i] += ans[j-1][i];\\n            }\\n        }\\n        for (i=0;i<n;i++) {\\n            for (j=1;j<n;j++) {\\n                ans[i][j] += ans[i][j-1];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3189353,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n        vector<vector<int>>v(n,vector<int>(n,0));\\n        for(auto it:queries) {\\n            for(int i=it[0];i<=it[2];i++) {\\n                v[i][it[1]]+=1;\\n            }\\n            if(it[3]+1<n) {\\n                for(int i=it[0];i<=it[2];i++) {\\n                    v[i][it[3]+1]-=1;\\n                }\\n            }\\n        }\\n        for(int i=0;i<n;i++) {\\n            for(int j=0;j<n;j++) {\\n                v[i][j]=(j>0?v[i][j-1]+v[i][j]:v[i][j]);\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n        vector<vector<int>>v(n,vector<int>(n,0));\\n        for(auto it:queries) {\\n            for(int i=it[0];i<=it[2];i++) {\\n                v[i][it[1]]+=1;\\n            }\\n            if(it[3]+1<n) {\\n                for(int i=it[0];i<=it[2];i++) {\\n                    v[i][it[3]+1]-=1;\\n                }\\n            }\\n        }\\n        for(int i=0;i<n;i++) {\\n            for(int j=0;j<n;j++) {\\n                v[i][j]=(j>0?v[i][j-1]+v[i][j]:v[i][j]);\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3189326,
                "title": "javascript-o-n-3",
                "content": "```\\nconst rangeAddQueries = (n, queries) => {\\n  let grid = new Array(n).fill().map((x) => new Array(n).fill(0));\\n  for (let [row1, col1, row2, col2] of queries)\\n    for (let row = row1; row <= row2; row++)\\n      for (let col = col1; col <= col2; col++) \\n        grid[row][col]++;\\n  return grid;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst rangeAddQueries = (n, queries) => {\\n  let grid = new Array(n).fill().map((x) => new Array(n).fill(0));\\n  for (let [row1, col1, row2, col2] of queries)\\n    for (let row = row1; row <= row2; row++)\\n      for (let col = col1; col <= col2; col++) \\n        grid[row][col]++;\\n  return grid;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3186598,
                "title": "java-22ms-beats-86-71-1d-area-sweep-solution",
                "content": "\\n```\\nclass Solution {\\n    public int[][] rangeAddQueries(int n, int[][] queries) {\\n        int [] sum = new int [n*n+1];\\n\\n        for(int [] query: queries){\\n            int r = query[0], c = query[1], r1 = query[2], c1 = query[3];\\n            for(int i = r; i <= r1; i++ ){\\n                int begin = i*n + c, end = i*n + c1;\\n                sum[begin]++;\\n                sum[end+1]--;\\n            }\\n            \\n        }\\n\\n        for(int i =1; i < n*n;i++){\\n            sum[i] += sum[i-1];\\n        }\\n\\n        int index = 0;\\n        int [][] mat = new int[n][n];\\n\\n        for(int i = 0; i < n; i++)\\n            for(int j =0; j < n; j++)\\n                mat[i][j] = sum[index++];\\n\\n        return mat;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] rangeAddQueries(int n, int[][] queries) {\\n        int [] sum = new int [n*n+1];\\n\\n        for(int [] query: queries){\\n            int r = query[0], c = query[1], r1 = query[2], c1 = query[3];\\n            for(int i = r; i <= r1; i++ ){\\n                int begin = i*n + c, end = i*n + c1;\\n                sum[begin]++;\\n                sum[end+1]--;\\n            }\\n            \\n        }\\n\\n        for(int i =1; i < n*n;i++){\\n            sum[i] += sum[i-1];\\n        }\\n\\n        int index = 0;\\n        int [][] mat = new int[n][n];\\n\\n        for(int i = 0; i < n; i++)\\n            for(int j =0; j < n; j++)\\n                mat[i][j] = sum[index++];\\n\\n        return mat;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3168034,
                "title": "simple-brute-force-java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int[][] rangeAddQueries(int n, int[][] queries) {\\n        int mat[][] = new int[n][n];\\n        for(int q[]:queries){\\n            for(int r=q[0];r<=q[2];r++){\\n                for(int c=q[1];c<=q[3];c++){\\n                    mat[r][c]+=1;\\n                }\\n            }\\n        }\\n        return mat;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] rangeAddQueries(int n, int[][] queries) {\\n        int mat[][] = new int[n][n];\\n        for(int q[]:queries){\\n            for(int r=q[0];r<=q[2];r++){\\n                for(int c=q[1];c<=q[3];c++){\\n                    mat[r][c]+=1;\\n                }\\n            }\\n        }\\n        return mat;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3155618,
                "title": "easiest-solution-c-easy-to-understand-simple-prifix-sum-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n        vector<vector<int>> vec(n,vector<int>(n,0));\\n        for(auto i:queries){\\n            for(int j=i[0];j<=i[2];j++){\\n                vec[j][i[1]]++;\\n                if(i[3]<n-1) vec[j][i[3]+1]--;\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(j>0) vec[i][j]=vec[i][j]+vec[i][j-1];\\n            }\\n        }\\n        return vec;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n        vector<vector<int>> vec(n,vector<int>(n,0));\\n        for(auto i:queries){\\n            for(int j=i[0];j<=i[2];j++){\\n                vec[j][i[1]]++;\\n                if(i[3]<n-1) vec[j][i[3]+1]--;\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(j>0) vec[i][j]=vec[i][j]+vec[i][j-1];\\n            }\\n        }\\n        return vec;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3135571,
                "title": "golang-prefix-sum",
                "content": "# Code\\n```\\nfunc rangeAddQueries(n int, queries [][]int) [][]int {\\n    ans := make([][]int, n)\\n    for i := 0; i < n; i++ {\\n        ans[i] = make([]int, n)\\n    }\\n    for _, query := range queries {\\n        row1, row2, col1, col2 := query[0], query[2] + 1, query[1], query[3] + 1\\n        ans[row1][col1]++\\n        if row2 < n && col2 < n {ans[row2][col2]++}\\n        if col2 < n {ans[row1][col2]--}\\n        if row2 < n {ans[row2][col1]--}\\n    }\\n    for i := 0; i < n; i++ {\\n        for j := 1; j < n; j++ {\\n            ans[i][j] += ans[i][j - 1]\\n        }\\n    }\\n    for i := 0; i < n; i++ {\\n        for j := 1; j < n; j++ {\\n            ans[j][i] += ans[j - 1][i]\\n        }\\n    }\\n    return ans\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Array",
                    "Matrix",
                    "Prefix Sum"
                ],
                "code": "```\\nfunc rangeAddQueries(n int, queries [][]int) [][]int {\\n    ans := make([][]int, n)\\n    for i := 0; i < n; i++ {\\n        ans[i] = make([]int, n)\\n    }\\n    for _, query := range queries {\\n        row1, row2, col1, col2 := query[0], query[2] + 1, query[1], query[3] + 1\\n        ans[row1][col1]++\\n        if row2 < n && col2 < n {ans[row2][col2]++}\\n        if col2 < n {ans[row1][col2]--}\\n        if row2 < n {ans[row2][col1]--}\\n    }\\n    for i := 0; i < n; i++ {\\n        for j := 1; j < n; j++ {\\n            ans[i][j] += ans[i][j - 1]\\n        }\\n    }\\n    for i := 0; i < n; i++ {\\n        for j := 1; j < n; j++ {\\n            ans[j][i] += ans[j - 1][i]\\n        }\\n    }\\n    return ans\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3135549,
                "title": "c-multiple-solutions-prefix-sum",
                "content": "# Code\\n```\\n// TC = O(n ^ 2 + q * n)\\nclass Solution {\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n        vector<vector<int>> ans(n, vector<int>(n, 0));\\n        for(vector<int> query: queries) {\\n            for(int i = query[0]; i <= query[2]; i++) {\\n                ans[i][query[1]]++;\\n                if(query[3] + 1 < n)\\n                    ans[i][query[3] + 1]--;\\n            }\\n        }\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 1; j < n; j++) {\\n                ans[i][j] += ans[i][j - 1];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\nOR\\n\\n// TC = O(n ^ 2 + q)\\nclass Solution {\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n        vector<vector<int>> ans(n, vector<int>(n, 0));\\n        for(vector<int> query: queries) {\\n            int row1 = query[0], row2 = query[2] + 1, col1 = query[1], col2 = query[3] + 1;\\n            ans[row1][col1]++;\\n            if(row2 < n && col2 < n)ans[row2][col2]++;\\n            if(col2 < n) ans[row1][col2]--;\\n            if(row2 < n) ans[row2][col1]--;\\n        }\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 1; j < n; j++) {\\n                ans[i][j] += ans[i][j - 1];\\n            }\\n        }\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 1; j < n; j++) {\\n                ans[j][i] += ans[j - 1][i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Matrix",
                    "Prefix Sum"
                ],
                "code": "```\\n// TC = O(n ^ 2 + q * n)\\nclass Solution {\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n        vector<vector<int>> ans(n, vector<int>(n, 0));\\n        for(vector<int> query: queries) {\\n            for(int i = query[0]; i <= query[2]; i++) {\\n                ans[i][query[1]]++;\\n                if(query[3] + 1 < n)\\n                    ans[i][query[3] + 1]--;\\n            }\\n        }\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 1; j < n; j++) {\\n                ans[i][j] += ans[i][j - 1];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\nOR\\n\\n// TC = O(n ^ 2 + q)\\nclass Solution {\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n        vector<vector<int>> ans(n, vector<int>(n, 0));\\n        for(vector<int> query: queries) {\\n            int row1 = query[0], row2 = query[2] + 1, col1 = query[1], col2 = query[3] + 1;\\n            ans[row1][col1]++;\\n            if(row2 < n && col2 < n)ans[row2][col2]++;\\n            if(col2 < n) ans[row1][col2]--;\\n            if(row2 < n) ans[row2][col1]--;\\n        }\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 1; j < n; j++) {\\n                ans[i][j] += ans[i][j - 1];\\n            }\\n        }\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 1; j < n; j++) {\\n                ans[j][i] += ans[j - 1][i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3121397,
                "title": "java-easy-solution-to-understand-brute-force",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int[][] rangeAddQueries(int n, int[][] queries) {\\n        int[][] max = new int[n][n];\\n\\n        for (int[] query : queries) {\\n            int row1 = query[0], row2 = query[2];\\n            int col1 = query[1], col2 = query[3];\\n\\n            for (int i=row1; i<=row2; i++)\\n                for (int j = col1; j<=col2; j++)\\n                    max[i][j]++;\\n\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] rangeAddQueries(int n, int[][] queries) {\\n        int[][] max = new int[n][n];\\n\\n        for (int[] query : queries) {\\n            int row1 = query[0], row2 = query[2];\\n            int col1 = query[1], col2 = query[3];\\n\\n            for (int i=row1; i<=row2; i++)\\n                for (int j = col1; j<=col2; j++)\\n                    max[i][j]++;\\n\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3119814,
                "title": "c-from-brute-force-to-dynamic-programming-prefix-sum-with-explanation",
                "content": "# Method1: Brute Force\\nA very direct way is to increase each query area one-by-one.\\n```\\nvector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n    vector<vector<int>> matrix(n, vector<int>(n, 0));\\n    \\n    for (const auto &q : queries) {\\n        int row1 = q[0];\\n        int col1 = q[1];\\n        int row2 = q[2];\\n        int col2 = q[3];\\n        for (int row = row1; row != row2 + 1; ++row)\\n            for (int col = col1; col != col2 + 1; ++col)\\n                ++matrix[row][col];\\n    }\\n\\n    return matrix;\\n}\\n```\\n- Time complexity: $$O(q * n^2)$$, $$q$$: `queries` size, $$n$$: number of rows / columns in `matrix`\\n- Space complexity: $$O(1)$$, we only use the space must be returned, which is $$O(n^2)$$\\n\\nThe brute force method will cause TLE eventually...\\n\\n# Method2: Treated as n Prefix Sum Arrays\\nThe brute force method traverses the same `matrix` cell many times (in the worst case, it\\'s `queries` size). That\\'s where we can optimize it.\\n\\nIf the scenario is only a 1D array instead of 2D matrix, we may optimize it by\\n- thinking of the answer array as an prefix sum array `array`\\n- thinking of each query (`start`, `end`) as a pair of variation. It causes the cumulative sum value increases by one at `start`, and causes the cumulative sum value decreases by one at `end + 1` (the position after `end`).\\n- then we solve it by counting variation value of each slot, then transforming them into the prefix sum array.\\n\\nFor example, if `n` is `10`, and the queries are `[3, 5], [2, 8]`.\\n1. Generate a counting array with sisze `10`\\n2. Traverse each query and count the variation at each slot.\\n    1. for `[3, 5]`, we increase one at slot `3` and decrease one at slot `6` (position after `5`).\\n    2. for `[2, 8]`, we increase one at slot `2` and decrease one at slot `9`.\\n    - the counting array becomes `[0,0,1,1,0,0,-1,0,-1,0]`\\n3. Traverse the counting array and transform it into prefix sum array, and that\\'s the answer\\n    - the prefix sum array becomes `[0,0,1,2,2,2,1,1,0,0]`\\n\\nSo back to consider the original scenario which is a 2D matrix, we can solve it by dividing the `n * n` matrix into `n` 1D arrays (e.g. `n` rows of `matrix`), and then applying the above optimization. The only difference from 1D array is that the variation of each query in 2D matrix applies to a certain range of rows.\\n\\n```\\nvector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n    vector<vector<int>> matrix(n, vector<int>(n, 0));\\n    \\n    for (const auto &q : queries) {\\n        int row1 = q[0];\\n        int col1 = q[1]; // causes a positive variation in a row\\n        int row2 = q[2];\\n        int col2 = q[3]; // causes a negative variation after this slot in a row\\n\\n        // count the variation at each slot in each row\\n        // apply the count value to a certain range of rows\\n        for (int row = row1; row != row2 + 1; ++row) {\\n            ++matrix[row][col1];\\n            if (col2 + 1 != n) // position after the last slot\\n                --matrix[row][col2 + 1];\\n        }       \\n    }\\n\\n    // transform the record into prefix sum arrays\\n    for (int row = 0; row != n; ++row)\\n        for (int col = 1; col != n; ++col)\\n            matrix[row][col] += matrix[row][col - 1];\\n\\n    return matrix;\\n}\\n```\\n- Time complexity: $$O(q * n + n^2)$$, $$q$$: `queries` size, $$n$$: number of rows in `matrix`\\n- Space complexity: $$O(1)$$, we only use the space must be returned, which is $$O(n^2)$$\\n\\n# Method3: Column is also a Prefix Sum Array\\nThe previous method has to setup `start`, `end` of variation in each row of the same column for each query. Why not we also count the variation in each column just like a prefix sum array too?\\n\\nSo let\\'s split this procedure in method2 into 2 steps. First, for each query, we only record the first row & the row behind the last row which have to setup the {`start`, `end`} pair of variation in the range of rows (count the variation for each column). After checking all queries, we transform each column into prefix sum array, so that we get the variation count of each row.\\n\\nFor the column to record `start` of variation of row,\\nthe start position is `matrix[row1][col1]`, it increases the cumulative sum value for the column by one;\\nthe position after end position is `matrix[row2 + 1][col1]`, it decreases the cumulative sum value for the column by one.\\n\\nFor the column to record `end` of variation of row,\\nthe start position is `matrix[row1][col2 + 1]`, it **decreases** the cumulative sum value for the column by one;\\nthe position after end position is `matrix[row2 + 1][col2 + 1]`, it **increases** the the cumulative sum value for the column by one.\\n\\n```\\nvector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n    vector<vector<int>> matrix(n, vector<int>(n, 0));\\n    \\n    for (const auto &q : queries) {\\n        int row1 = q[0];\\n        int col1 = q[1]; // causes a positive variation in a row\\n        int row2 = q[2];\\n        int col2 = q[3]; // causes a negative variation after this slot in a row\\n\\n        // count the variation at each slot of the column\\n        // which represents the `start` variation in the range of rows\\n        ++matrix[row1][col1];\\n        if (row2 + 1 != n) --matrix[row2 + 1][col1];\\n\\n        // count the variation at each slot of the column\\n        // which represents the `end` variation in the range of rows\\n        if (col2 + 1 != n) --matrix[row1][col2 + 1];\\n        if (row2 + 1 != n && col2 + 1 != n) ++matrix[row2 + 1][col2 + 1];\\n    }\\n\\n    // transform each column into prefix sum array\\n    // so we get the variation count at each slot in each row\\n    for (int col = 0; col != n; ++col)\\n        for (int row = 1; row != n; ++row)\\n            matrix[row][col] += matrix[row - 1][col];\\n\\n    // transform the record into prefix sum arrays\\n    for (int row = 0; row != n; ++row)\\n        for (int col = 1; col != n; ++col)\\n            matrix[row][col] += matrix[row][col - 1];\\n\\n    return matrix;\\n}\\n```\\n- Time complexity: $$O(q + n^2)$$, $$q$$: `queries` size, $$n$$: number of rows in `matrix`\\n- Space complexity: $$O(1)$$, we only use the space must be returned, which is $$O(n^2)$$\\n\\n# Method4: Merge two n by n Traversals\\nObserving the last 2 traversals of `matrix` in method3, the update of `matrix[row][col]` only relates to itself, `matrix[row - 1][col]` & `matrix[row][col - 1]`. Each slot has similar updating pattern and becomes read-only after updating, so we can merge these 2 traversals together.\\n\\nThe first traversal (the following code) only updates column slot based on the previous slot in the same column:\\n```\\n    for (int col = 0; col != n; ++col)\\n        for (int row = 1; row != n; ++row)\\n            matrix[row][col] += matrix[row - 1][col];\\n```\\nSo it remains the same if swapping the inner loop & outer loop\\n```\\n    for (int row = 1; row != n; ++row)\\n        for (int col = 0; col != n; ++col)\\n            matrix[row][col] += matrix[row - 1][col];\\n```\\n\\nWhen we merge the above code into the last traversal of `matrix`, there\\'re 2 notes:\\n- the value of `matrix[row - 1][col]` in the merged loop has different meaning. Compared to the value in the unmerged loop, the value in the merged loop includes **additional offset** `matrix[row - 1][col - 1]`. So in the merged loop, we have to remove such offset to get the same value of `matrix[row - 1][col]` in the unmerged loop.\\n- careful the range boundary check\\n\\nSo the merged loop becomes\\n```\\n    // transform the record into prefix sum arrays\\n    for (int row = 0; row != n; ++row) {\\n        for (int col = 0; col != n; ++col) {\\n            // transform each column into prefix sum array\\n            // so we get the variation count at each slot in each row\\n            if (row > 0)\\n                matrix[row][col] += matrix[row - 1][col];\\n            if (row > 0 && col > 0)\\n                matrix[row][col] -= matrix[row - 1][col - 1];\\n\\n            // transform the record into n prefix sum arrays (each row)\\n            if (col > 0)\\n                matrix[row][col] += matrix[row][col - 1];\\n        }\\n    }\\n```\\n\\nAfter some reordering of code:\\n```\\nvector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n    vector<vector<int>> matrix(n, vector<int>(n, 0));\\n    \\n    for (const auto &q : queries) {\\n        int row1 = q[0];\\n        int col1 = q[1]; // causes a positive variation in a row\\n        int row2 = q[2];\\n        int col2 = q[3]; // causes a negative variation after this slot in a row\\n\\n        // count the variation at each slot of the column\\n        // which represents the `start` variation in the range of rows\\n        ++matrix[row1][col1];\\n        if (row2 + 1 != n) --matrix[row2 + 1][col1];\\n\\n        // count the variation at each slot of the column\\n        // which represents the `end` variation in the range of rows\\n        if (col2 + 1 != n) --matrix[row1][col2 + 1];\\n        if (row2 + 1 != n && col2 + 1 != n) ++matrix[row2 + 1][col2 + 1];\\n    }\\n\\n    // transform the record into prefix sum arrays\\n    for (int row = 0; row != n; ++row) {\\n        for (int col = 0; col != n; ++col) {\\n            // transform each column into prefix sum array\\n            // so we get the variation count at each slot in each row\\n            // transform the record into n prefix sum arrays (each row)\\n            if (row > 0 && col > 0) matrix[row][col] -= matrix[row - 1][col - 1];\\n            if (row > 0) matrix[row][col] += matrix[row - 1][col];\\n            if (col > 0) matrix[row][col] += matrix[row][col - 1];\\n        }\\n    }\\n\\n    return matrix;\\n}\\n```\\n- Time complexity: $$O(q + n^2)$$, $$q$$: `queries` size, $$n$$: number of rows in `matrix`\\n- Space complexity: $$O(1)$$, we only use the space must be returned, which is $$O(n^2)$$",
                "solutionTags": [
                    "C++",
                    "Divide and Conquer",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```\\nvector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n    vector<vector<int>> matrix(n, vector<int>(n, 0));\\n    \\n    for (const auto &q : queries) {\\n        int row1 = q[0];\\n        int col1 = q[1];\\n        int row2 = q[2];\\n        int col2 = q[3];\\n        for (int row = row1; row != row2 + 1; ++row)\\n            for (int col = col1; col != col2 + 1; ++col)\\n                ++matrix[row][col];\\n    }\\n\\n    return matrix;\\n}\\n```\n```\\nvector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n    vector<vector<int>> matrix(n, vector<int>(n, 0));\\n    \\n    for (const auto &q : queries) {\\n        int row1 = q[0];\\n        int col1 = q[1]; // causes a positive variation in a row\\n        int row2 = q[2];\\n        int col2 = q[3]; // causes a negative variation after this slot in a row\\n\\n        // count the variation at each slot in each row\\n        // apply the count value to a certain range of rows\\n        for (int row = row1; row != row2 + 1; ++row) {\\n            ++matrix[row][col1];\\n            if (col2 + 1 != n) // position after the last slot\\n                --matrix[row][col2 + 1];\\n        }       \\n    }\\n\\n    // transform the record into prefix sum arrays\\n    for (int row = 0; row != n; ++row)\\n        for (int col = 1; col != n; ++col)\\n            matrix[row][col] += matrix[row][col - 1];\\n\\n    return matrix;\\n}\\n```\n```\\nvector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n    vector<vector<int>> matrix(n, vector<int>(n, 0));\\n    \\n    for (const auto &q : queries) {\\n        int row1 = q[0];\\n        int col1 = q[1]; // causes a positive variation in a row\\n        int row2 = q[2];\\n        int col2 = q[3]; // causes a negative variation after this slot in a row\\n\\n        // count the variation at each slot of the column\\n        // which represents the `start` variation in the range of rows\\n        ++matrix[row1][col1];\\n        if (row2 + 1 != n) --matrix[row2 + 1][col1];\\n\\n        // count the variation at each slot of the column\\n        // which represents the `end` variation in the range of rows\\n        if (col2 + 1 != n) --matrix[row1][col2 + 1];\\n        if (row2 + 1 != n && col2 + 1 != n) ++matrix[row2 + 1][col2 + 1];\\n    }\\n\\n    // transform each column into prefix sum array\\n    // so we get the variation count at each slot in each row\\n    for (int col = 0; col != n; ++col)\\n        for (int row = 1; row != n; ++row)\\n            matrix[row][col] += matrix[row - 1][col];\\n\\n    // transform the record into prefix sum arrays\\n    for (int row = 0; row != n; ++row)\\n        for (int col = 1; col != n; ++col)\\n            matrix[row][col] += matrix[row][col - 1];\\n\\n    return matrix;\\n}\\n```\n```\\n    for (int col = 0; col != n; ++col)\\n        for (int row = 1; row != n; ++row)\\n            matrix[row][col] += matrix[row - 1][col];\\n```\n```\\n    for (int row = 1; row != n; ++row)\\n        for (int col = 0; col != n; ++col)\\n            matrix[row][col] += matrix[row - 1][col];\\n```\n```\\n    // transform the record into prefix sum arrays\\n    for (int row = 0; row != n; ++row) {\\n        for (int col = 0; col != n; ++col) {\\n            // transform each column into prefix sum array\\n            // so we get the variation count at each slot in each row\\n            if (row > 0)\\n                matrix[row][col] += matrix[row - 1][col];\\n            if (row > 0 && col > 0)\\n                matrix[row][col] -= matrix[row - 1][col - 1];\\n\\n            // transform the record into n prefix sum arrays (each row)\\n            if (col > 0)\\n                matrix[row][col] += matrix[row][col - 1];\\n        }\\n    }\\n```\n```\\nvector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n    vector<vector<int>> matrix(n, vector<int>(n, 0));\\n    \\n    for (const auto &q : queries) {\\n        int row1 = q[0];\\n        int col1 = q[1]; // causes a positive variation in a row\\n        int row2 = q[2];\\n        int col2 = q[3]; // causes a negative variation after this slot in a row\\n\\n        // count the variation at each slot of the column\\n        // which represents the `start` variation in the range of rows\\n        ++matrix[row1][col1];\\n        if (row2 + 1 != n) --matrix[row2 + 1][col1];\\n\\n        // count the variation at each slot of the column\\n        // which represents the `end` variation in the range of rows\\n        if (col2 + 1 != n) --matrix[row1][col2 + 1];\\n        if (row2 + 1 != n && col2 + 1 != n) ++matrix[row2 + 1][col2 + 1];\\n    }\\n\\n    // transform the record into prefix sum arrays\\n    for (int row = 0; row != n; ++row) {\\n        for (int col = 0; col != n; ++col) {\\n            // transform each column into prefix sum array\\n            // so we get the variation count at each slot in each row\\n            // transform the record into n prefix sum arrays (each row)\\n            if (row > 0 && col > 0) matrix[row][col] -= matrix[row - 1][col - 1];\\n            if (row > 0) matrix[row][col] += matrix[row - 1][col];\\n            if (col > 0) matrix[row][col] += matrix[row][col - 1];\\n        }\\n    }\\n\\n    return matrix;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3106801,
                "title": "explained-kotlin-solution",
                "content": "# Approach and Intuition\\nThe problem requires adding 1 to every element in a given submatrix of a 2D matrix. A simple approach to this problem is to iterate through the queries array and for each query, add 1 to every element in the submatrix specified by the query.\\n\\nThe intuition behind this approach is that we can represent the submatrix operations as a set of range updates, where each query updates a given range of elements in the matrix by a certain value. In this case, the value to be added is 1.\\n\\nTo implement this, we can use a 2D array to store the resulting matrix. We can then iterate through the queries array, where each query is an integer array with 4 elements. The first two elements of the query array represent the top-left corner coordinates of the submatrix, and the last two elements represent the bottom-right corner coordinates of the submatrix. We can then use nested loops to iterate through the submatrix and add 1 to every element in the submatrix.\\n\\nOnce we have processed all the queries, we can return the resulting matrix.\\n\\nAlternatively, one can use Fenwick Tree (also known as Binary Indexed Tree) or Segment Tree to do the range updates and range queries efficiently, but that would require a different level of complexity and understanding of these data structures.\\n\\n# Code\\n```\\nclass Solution {\\n    fun rangeAddQueries(n: Int, queries: Array<IntArray>): Array<IntArray> {\\n        // Initialize a 2D array to store the result matrix\\n        val ret = Array(n) { IntArray(n) }\\n        // Iterate through the queries\\n        for (query in queries) {\\n            // Get the top-left corner coordinates of the submatrix\\n            val row1 = query[0]\\n            val col1 = query[1]\\n            // Get the bottom-right corner coordinates of the submatrix\\n            val row2 = query[2]\\n            val col2 = query[3]\\n            // Add 1 to the submatrix\\n            for (i in row1..row2) {\\n                for (j in col1..col2) {\\n                    ret[i][j] += 1\\n                }\\n            }\\n        }\\n        // Return the resulting matrix\\n        return ret\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun rangeAddQueries(n: Int, queries: Array<IntArray>): Array<IntArray> {\\n        // Initialize a 2D array to store the result matrix\\n        val ret = Array(n) { IntArray(n) }\\n        // Iterate through the queries\\n        for (query in queries) {\\n            // Get the top-left corner coordinates of the submatrix\\n            val row1 = query[0]\\n            val col1 = query[1]\\n            // Get the bottom-right corner coordinates of the submatrix\\n            val row2 = query[2]\\n            val col2 = query[3]\\n            // Add 1 to the submatrix\\n            for (i in row1..row2) {\\n                for (j in col1..col2) {\\n                    ret[i][j] += 1\\n                }\\n            }\\n        }\\n        // Return the resulting matrix\\n        return ret\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3105480,
                "title": "c-efficient-approach",
                "content": "```\\nvector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& q) {\\n        vector<vector<int>>v(n,vector<int>(n,0));\\n        for(int k=0;k<q.size();k++){\\n            int i=q[k][0];\\n            int j=q[k][1];\\n            int a=q[k][2];\\n            int b=q[k][3];\\n            for(;i<=a;i++){\\n                v[i][j]++;\\n                if(b+1<n)\\n                    v[i][b+1]--;\\n            }\\n        }\\n        for(int i=0;i<v.size();i++){\\n            for(int j=1;j<n;j++)\\n                v[i][j]+=v[i][j-1];\\n        }\\n        return v;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& q) {\\n        vector<vector<int>>v(n,vector<int>(n,0));\\n        for(int k=0;k<q.size();k++){\\n            int i=q[k][0];\\n            int j=q[k][1];\\n            int a=q[k][2];\\n            int b=q[k][3];\\n            for(;i<=a;i++){\\n                v[i][j]++;\\n                if(b+1<n)\\n                    v[i][b+1]--;\\n            }\\n        }\\n        for(int i=0;i<v.size();i++){\\n            for(int j=1;j<n;j++)\\n                v[i][j]+=v[i][j-1];\\n        }\\n        return v;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3086677,
                "title": "best-easy-line-sweep-prefix-sum-solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n        vector<vector<int>>vt(n,vector<int>(n+1,0));\\n        vector<vector<int>>ans;\\n        for(int i=0;i<queries.size();i++)\\n        {\\n            for(int j=queries[i][0];j<=queries[i][2];j++)\\n            {\\n                vt[j][queries[i][1]]++;\\n                vt[j][queries[i][3]+1]--;\\n            }\\n        }\\n        for(int i=0;i<vt.size();i++)\\n        {\\n            int sum=0;\\n            vector<int>res;\\n            for(int j=0;j<vt[i].size();j++)\\n            {\\n                sum+=vt[i][j];\\n                if(j!=vt[i].size()-1)\\n                    res.push_back(sum);\\n            }\\n            ans.push_back(res);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n        vector<vector<int>>vt(n,vector<int>(n+1,0));\\n        vector<vector<int>>ans;\\n        for(int i=0;i<queries.size();i++)\\n        {\\n            for(int j=queries[i][0];j<=queries[i][2];j++)\\n            {\\n                vt[j][queries[i][1]]++;\\n                vt[j][queries[i][3]+1]--;\\n            }\\n        }\\n        for(int i=0;i<vt.size();i++)\\n        {\\n            int sum=0;\\n            vector<int>res;\\n            for(int j=0;j<vt[i].size();j++)\\n            {\\n                sum+=vt[i][j];\\n                if(j!=vt[i].size()-1)\\n                    res.push_back(sum);\\n            }\\n            ans.push_back(res);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3080701,
                "title": "java-easy-100",
                "content": "```\\nclass Solution {\\n    public int[][] rangeAddQueries(int n, int[][] queries) {\\n        int arr[][] = new int[n][n];\\n        Arrays.stream(arr).forEach(a -> Arrays.fill(a, 0));\\n        for(int a[]:queries)\\n        {\\n            int row1=a[0],col1=a[1],row2=a[2],col2=a[3];\\n            for(int i=row1;i<=row2;i++)\\n            {\\n                for(int j=col1;j<=col2;j++)\\n                {\\n                    arr[i][j]+=1;\\n                }\\n            }\\n        }\\n        return arr;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int[][] rangeAddQueries(int n, int[][] queries) {\\n        int arr[][] = new int[n][n];\\n        Arrays.stream(arr).forEach(a -> Arrays.fill(a, 0));\\n        for(int a[]:queries)\\n        {\\n            int row1=a[0],col1=a[1],row2=a[2],col2=a[3];\\n            for(int i=row1;i<=row2;i++)\\n            {\\n                for(int j=col1;j<=col2;j++)\\n                {\\n                    arr[i][j]+=1;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3080209,
                "title": "easy-to-understand-c-line-sweep",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n        vector<vector<int>> result(n,vector<int>(n,0));\\n        \\n        // Mark all corners of the squares for line sweep\\n        // for line sweep mark the boundaries of the full rectangle\\n        for (auto &q : queries) {\\n            int x1 = q[0]; int y1 = q[1];\\n            int x2 = q[2]; int y2 = q[3];\\n            \\n            result[x1][y1] += 1;\\n            if (x2+1 < n) {\\n                result[x2+1][y1] -= 1;\\n            }\\n            if (y2+1 < n) {\\n                result[x1][y2+1] -= 1;\\n            }\\n            if ((x2+1 < n) && (y2+1 < n)) {\\n                result[x2+1][y2+1] += 1;\\n            }\\n        }\\n        \\n        // Sweep horizontally on the row of the matrix\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 1; j < n; j++) {\\n                result[i][j] += result[i][j-1];\\n            }\\n        }\\n        \\n        // Sweep vertically on the column of the matrix\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 1; j < n; j++) {\\n                result[j][i] += result[j-1][i];\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n        vector<vector<int>> result(n,vector<int>(n,0));\\n        \\n        // Mark all corners of the squares for line sweep\\n        // for line sweep mark the boundaries of the full rectangle\\n        for (auto &q : queries) {\\n            int x1 = q[0]; int y1 = q[1];\\n            int x2 = q[2]; int y2 = q[3];\\n            \\n            result[x1][y1] += 1;\\n            if (x2+1 < n) {\\n                result[x2+1][y1] -= 1;\\n            }\\n            if (y2+1 < n) {\\n                result[x1][y2+1] -= 1;\\n            }\\n            if ((x2+1 < n) && (y2+1 < n)) {\\n                result[x2+1][y2+1] += 1;\\n            }\\n        }\\n        \\n        // Sweep horizontally on the row of the matrix\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 1; j < n; j++) {\\n                result[i][j] += result[i][j-1];\\n            }\\n        }\\n        \\n        // Sweep vertically on the column of the matrix\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 1; j < n; j++) {\\n                result[j][i] += result[j-1][i];\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3078523,
                "title": "java-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] rangeAddQueries(int n, int[][] queries) {\\n        int [][] mat = new int[n][n];\\n        for(int a[] : mat){\\n            Arrays.fill(a,0);\\n        }\\n\\n        for(int a [] : queries){\\n            int row1 = a[0];\\n            int col1 = a[1];\\n            int row2 = a[2];\\n            int col2 = a[3];\\n            \\n            for(int i=row1; i<=row2;i++){\\n                for(int j=col1;j<=col2;j++){\\n                    mat[i][j] += 1;\\n                }\\n            }\\n        }\\n\\n        return mat;\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] rangeAddQueries(int n, int[][] queries) {\\n        int [][] mat = new int[n][n];\\n        for(int a[] : mat){\\n            Arrays.fill(a,0);\\n        }\\n\\n        for(int a [] : queries){\\n            int row1 = a[0];\\n            int col1 = a[1];\\n            int row2 = a[2];\\n            int col2 = a[3];\\n            \\n            for(int i=row1; i<=row2;i++){\\n                for(int j=col1;j<=col2;j++){\\n                    mat[i][j] += 1;\\n                }\\n            }\\n        }\\n\\n        return mat;\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3077130,
                "title": "c-solution-clean-code-with-comments",
                "content": "\\n# Complexity\\n- Time complexity:O(Q*N) + O(N*N)\\n- TLE IS FOR O(Q*N*N) sol\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n- As the matrix is out space\\n- Inp and Out space not considered for it\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n        vector<vector<int>> mat(n, vector<int>(n,0));\\n        \\n        for(auto q : queries){\\n            int r1,c1,r2,c2;\\n            r1 = q[0];\\n            c1 = q[1];\\n            r2 = q[2];\\n            c2 = q[3];\\n            for(int i=r1; i<=r2; i++){\\n                //marking at start of every row\\n                mat[i][c1]++; //c1 col it start and c2 it ends\\n                if(c2+1!=n) mat[i][c2+1]--; //1cell after c2 inc should stop\\n                //we nullify that effect by decrementing \\n            }\\n        }\\n        \\n        //now we give real vals from bookmarked ones\\n        for(int i=0; i<n; i++){\\n            for(int j=1; j<n; j++){\\n                //we update row wise. Thinking each row is a separate array\\n                mat[i][j] +=mat[i][j-1];\\n            }\\n        }\\n    \\n        return mat;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n        vector<vector<int>> mat(n, vector<int>(n,0));\\n        \\n        for(auto q : queries){\\n            int r1,c1,r2,c2;\\n            r1 = q[0];\\n            c1 = q[1];\\n            r2 = q[2];\\n            c2 = q[3];\\n            for(int i=r1; i<=r2; i++){\\n                //marking at start of every row\\n                mat[i][c1]++; //c1 col it start and c2 it ends\\n                if(c2+1!=n) mat[i][c2+1]--; //1cell after c2 inc should stop\\n                //we nullify that effect by decrementing \\n            }\\n        }\\n        \\n        //now we give real vals from bookmarked ones\\n        for(int i=0; i<n; i++){\\n            for(int j=1; j<n; j++){\\n                //we update row wise. Thinking each row is a separate array\\n                mat[i][j] +=mat[i][j-1];\\n            }\\n        }\\n    \\n        return mat;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3075549,
                "title": "java-simple-soln",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] rangeAddQueries(int n, int[][] queries) {\\n        int[][] arr=new int[n][n];\\n        for(int i=0;i<queries.length;i++)\\n        {\\n            int row1=queries[i][0];\\n            int col1=queries[i][1];\\n            int row2=queries[i][2];\\n            int col2=queries[i][3];\\n            for(int j=row1;j<=row2;j++)\\n            {\\n                for(int k=col1;k<=col2;k++)\\n                {\\n                    arr[j][k]+=1;\\n                }\\n            }\\n        }\\n        return arr;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] rangeAddQueries(int n, int[][] queries) {\\n        int[][] arr=new int[n][n];\\n        for(int i=0;i<queries.length;i++)\\n        {\\n            int row1=queries[i][0];\\n            int col1=queries[i][1];\\n            int row2=queries[i][2];\\n            int col2=queries[i][3];\\n            for(int j=row1;j<=row2;j++)\\n            {\\n                for(int k=col1;k<=col2;k++)\\n                {\\n                    arr[j][k]+=1;\\n                }\\n            }\\n        }\\n        return arr;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3072622,
                "title": "c-prefix-sum",
                "content": "# Complexity\\n- Time complexity: $$O(q * n + n^2)$$\\n- Space complexity: $$O(n^2)$$\\n\\n# Code\\n```\\npublic class Solution\\n{\\n    public int[][] RangeAddQueries(int n, int[][] queries)\\n    {\\n        int[][] grid = new int[n][];\\n        for (int i = 0; i < n; i++)\\n        {\\n            grid[i] = new int[n];\\n        }\\n\\n        foreach (var query in queries)\\n        {\\n            for (int i = query[0]; i <= query[2]; i++)\\n            {\\n                grid[i][query[1]]++;\\n                if (query[3] + 1 < n)\\n                {\\n                    grid[i][query[3] + 1]--;\\n                }\\n            }\\n        }\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            for (int j = 1; j < n; j++)\\n            {\\n                grid[i][j] += grid[i][j - 1];\\n            }\\n        }\\n\\n        return grid;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Array",
                    "Matrix",
                    "Prefix Sum"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public int[][] RangeAddQueries(int n, int[][] queries)\\n    {\\n        int[][] grid = new int[n][];\\n        for (int i = 0; i < n; i++)\\n        {\\n            grid[i] = new int[n];\\n        }\\n\\n        foreach (var query in queries)\\n        {\\n            for (int i = query[0]; i <= query[2]; i++)\\n            {\\n                grid[i][query[1]]++;\\n                if (query[3] + 1 < n)\\n                {\\n                    grid[i][query[3] + 1]--;\\n                }\\n            }\\n        }\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            for (int j = 1; j < n; j++)\\n            {\\n                grid[i][j] += grid[i][j - 1];\\n            }\\n        }\\n\\n        return grid;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3071867,
                "title": "c-sol-prefix-sum-with-diagram",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->Prefix sum\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThink about the cells that are effected in a prefix sum array if we place 1 or -1 in it.\\n![image.png](https://assets.leetcode.com/users/images/d9149de1-34cd-42e4-8632-7f9baf657a46_1674116005.9764316.png)\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n        vector<vector<int>> ans(n+2, vector<int>(n+2,0)), finalAns(n);\\n        for(auto &i: queries){\\n            ans[i[0]+1][i[1]+1]++;\\n            ans[i[2]+2][i[3]+2]++;\\n            ans[i[0]+1][i[3]+2]--;\\n            ans[i[2]+2][i[1]+1]--;\\n            \\n        }\\n        \\n        for(int i=1;i<n+1;i++){\\n            for(int j=1;j<n+1;j++){\\n                ans[i][j]+=ans[i-1][j]+ans[i][j-1]-ans[i-1][j-1];\\n                finalAns[i-1].push_back(ans[i][j]);\\n            }\\n        }\\n        return finalAns;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n        vector<vector<int>> ans(n+2, vector<int>(n+2,0)), finalAns(n);\\n        for(auto &i: queries){\\n            ans[i[0]+1][i[1]+1]++;\\n            ans[i[2]+2][i[3]+2]++;\\n            ans[i[0]+1][i[3]+2]--;\\n            ans[i[2]+2][i[1]+1]--;\\n            \\n        }\\n        \\n        for(int i=1;i<n+1;i++){\\n            for(int j=1;j<n+1;j++){\\n                ans[i][j]+=ans[i-1][j]+ans[i][j-1]-ans[i-1][j-1];\\n                finalAns[i-1].push_back(ans[i][j]);\\n            }\\n        }\\n        return finalAns;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3069644,
                "title": "range-sum-prefix-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nuse range sum but for a matrix instead of a linear array\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nif the range was linear we would add one to the starting point and -1 to the (end point+1) of the ranges and then take prefixsum of the whole array/vector\\n\\nsince we have a matrix , we do this operations for all the vertical length of (y2-y1+1) \\n\\n\\n \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nk =queries.size();\\n\\nO(n*k)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1) auxilary space\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& q) {\\n        \\nvector<vector<int>> mat(n,vector<int>(n,0));\\nint len=q.size();\\n\\nfor(int j=0;j<len;j++){\\n    int x1,x2,y1,y2;\\n\\nx1=q[j][0];\\ny1=q[j][1];\\nx2=q[j][2];\\ny2=q[j][3];\\n\\nfor(int i=x1;i<=x2;i++)\\nmat[i][y1]++;\\n\\nif(y2+1 >=n)\\ncontinue;\\n\\nfor(int i=x1;i<=x2;i++)\\nmat[i][y2+1]--;\\n}\\n\\n// take the prefix sum\\n\\nfor(int i=0;i<n;i++)\\nfor(int j=1;j<n;j++)\\n    mat[i][j]+=mat[i][j-1];\\n\\n\\nreturn mat;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& q) {\\n        \\nvector<vector<int>> mat(n,vector<int>(n,0));\\nint len=q.size();\\n\\nfor(int j=0;j<len;j++){\\n    int x1,x2,y1,y2;\\n\\nx1=q[j][0];\\ny1=q[j][1];\\nx2=q[j][2];\\ny2=q[j][3];\\n\\nfor(int i=x1;i<=x2;i++)\\nmat[i][y1]++;\\n\\nif(y2+1 >=n)\\ncontinue;\\n\\nfor(int i=x1;i<=x2;i++)\\nmat[i][y2+1]--;\\n}\\n\\n// take the prefix sum\\n\\nfor(int i=0;i<n;i++)\\nfor(int j=1;j<n;j++)\\n    mat[i][j]+=mat[i][j-1];\\n\\n\\nreturn mat;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3069574,
                "title": "c-easy-version",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n        vector<vector<int>>v(n,vector<int>(n,0));\\n        int r1,r2,c1,c2;\\n        for (auto &q:queries) \\n        {\\n            r1 = q[0];\\n            c1 = q[1]; \\n            r2 = q[2]; \\n            c2 = q[3];\\n            v[r1][c1]++;\\n            if(c2+1<n) v[r1][c2+1]--;\\n            if(r2+1<n) v[r2+1][c1]--;\\n            if(r2+1<n and c2+1<n) v[r2+1][c2+1]++;\\n        }\\n        for(int i=0;i<n;i++) \\n        {\\n            for (int j=1; j<n;j++) \\n            {\\n                v[i][j]+=v[i][j-1];\\n            }\\n        }\\n        for (int i=1;i<n;i++) \\n        {\\n            for (int j=0;j<n;j++) \\n            {\\n                v[i][j]+=v[i-1][j];\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n        vector<vector<int>>v(n,vector<int>(n,0));\\n        int r1,r2,c1,c2;\\n        for (auto &q:queries) \\n        {\\n            r1 = q[0];\\n            c1 = q[1]; \\n            r2 = q[2]; \\n            c2 = q[3];\\n            v[r1][c1]++;\\n            if(c2+1<n) v[r1][c2+1]--;\\n            if(r2+1<n) v[r2+1][c1]--;\\n            if(r2+1<n and c2+1<n) v[r2+1][c2+1]++;\\n        }\\n        for(int i=0;i<n;i++) \\n        {\\n            for (int j=1; j<n;j++) \\n            {\\n                v[i][j]+=v[i][j-1];\\n            }\\n        }\\n        for (int i=1;i<n;i++) \\n        {\\n            for (int j=0;j<n;j++) \\n            {\\n                v[i][j]+=v[i-1][j];\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3068712,
                "title": "python-range-caching",
                "content": "# Intuition\\nBased on this solution [[Python3] Sweep Line (Range Addition w/ Visualization), Clean & Concise](https://leetcode.com/problems/increment-submatrices-by-one/solutions/3052675/python3-sweep-line-range-addition-w-visualization-clean-concise/). I\\'ll write some explanation for the 2-D range caching for personal record.\\n\\nObservation: if the caching and restoration works for a single query, it will work for any amount of queries.\\nProof: we can conduct the caching and restoration on separate matrixs and sum them up, due to the properties of addition, this won\\'t change the result.\\n\\nThus we just need to proof that this method works for a single query. If we want to step backwards, that\\'s we want to restore the cache vertically, then what we want is something like below:\\n\\n1   1   1   1\\n0   0   0   0\\n0   0   0   0\\n-1  -1   -1  -1\\n\\nIf we sweep all the columns, we\\'ll get the result of a single query.\\n\\nThis can be further cached horizontally like this:\\n1 0 0 0 -1\\n0 0 0 0 0\\n0 0 0 0 0\\n-1 0 0 0 1\\n\\nbacause 1 0 0 0 -1 -> 1   1   1   1 and -1 0 0 0 1 -> -1 -1 -1 -1 if we sweep the row.\\n\\nThus, if we add 1 to `mat[r1][c1]` and `mat[r2 + 1][c2 + 1]` and minus 1 to `mat[r2 + 1][c1]` and `mat[r1][c2 + 1]`, after sweeping vertically and horizontally, we\\'ll get the resul tof a single query.\\n# Complexity\\n- Time complexity:\\n$$O(n^2 + q)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def rangeAddQueries(self, n: int, queries: List[List[int]]):\\n        mat = [[0 for _ in range(n)] for _ in range(n)]\\n        for r1, c1, r2, c2 in queries:\\n            mat[r1][c1] += 1\\n            if r2 + 1 < n:\\n                mat[r2 + 1][c1] -= 1 \\n            if c2 + 1 < n:\\n                mat[r1][c2 + 1] -= 1\\n            if r2 + 1 < n and c2 + 1 < n:\\n                mat[r2 + 1][c2 + 1] += 1\\n        for i in range(n):\\n            for j in range(1, n):\\n                mat[i][j] += mat[i][j - 1]\\n        for j in range(n):\\n            for i in range(1, n):\\n                mat[i][j] += mat[i - 1][j]\\n        return mat\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rangeAddQueries(self, n: int, queries: List[List[int]]):\\n        mat = [[0 for _ in range(n)] for _ in range(n)]\\n        for r1, c1, r2, c2 in queries:\\n            mat[r1][c1] += 1\\n            if r2 + 1 < n:\\n                mat[r2 + 1][c1] -= 1 \\n            if c2 + 1 < n:\\n                mat[r1][c2 + 1] -= 1\\n            if r2 + 1 < n and c2 + 1 < n:\\n                mat[r2 + 1][c2 + 1] += 1\\n        for i in range(n):\\n            for j in range(1, n):\\n                mat[i][j] += mat[i][j - 1]\\n        for j in range(n):\\n            for i in range(1, n):\\n                mat[i][j] += mat[i - 1][j]\\n        return mat\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3067509,
                "title": "java-easy-solution-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] rangeAddQueries(int n, int[][] queries) {\\n        int[][] arr=new int[n][n];\\n        for(int i=0;i<queries.length;i++)\\n        {\\n            int row1=queries[i][0];\\n            int col1=queries[i][1];\\n            int row2=queries[i][2];\\n            int col2=queries[i][3];\\n            for(int j=row1;j<=row2;j++)\\n            {\\n                for(int k=col1;k<=col2;k++)\\n                {\\n                    arr[j][k]+=1;\\n                }\\n            }\\n        }\\n        return arr;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] rangeAddQueries(int n, int[][] queries) {\\n        int[][] arr=new int[n][n];\\n        for(int i=0;i<queries.length;i++)\\n        {\\n            int row1=queries[i][0];\\n            int col1=queries[i][1];\\n            int row2=queries[i][2];\\n            int col2=queries[i][3];\\n            for(int j=row1;j<=row2;j++)\\n            {\\n                for(int k=col1;k<=col2;k++)\\n                {\\n                    arr[j][k]+=1;\\n                }\\n            }\\n        }\\n        return arr;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3067502,
                "title": "java-easy-solution-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] rangeAddQueries(int n, int[][] queries) {\\n        int[][] arr=new int[n][n];\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            for(int j=0;j<arr.length;j++)\\n            {\\n                arr[i][j]=0;\\n            }\\n        }\\n        for(int i=0;i<queries.length;i++)\\n        {\\n            int row1=queries[i][0];\\n            int col1=queries[i][1];\\n            int row2=queries[i][2];\\n            int col2=queries[i][3];\\n            for(int j=row1;j<=row2;j++)\\n            {\\n                for(int k=col1;k<=col2;k++)\\n                {\\n                    arr[j][k]+=1;\\n                }\\n            }\\n        }\\n        return arr;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] rangeAddQueries(int n, int[][] queries) {\\n        int[][] arr=new int[n][n];\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            for(int j=0;j<arr.length;j++)\\n            {\\n                arr[i][j]=0;\\n            }\\n        }\\n        for(int i=0;i<queries.length;i++)\\n        {\\n            int row1=queries[i][0];\\n            int col1=queries[i][1];\\n            int row2=queries[i][2];\\n            int col2=queries[i][3];\\n            for(int j=row1;j<=row2;j++)\\n            {\\n                for(int k=col1;k<=col2;k++)\\n                {\\n                    arr[j][k]+=1;\\n                }\\n            }\\n        }\\n        return arr;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3066347,
                "title": "java",
                "content": "# Complexity\\n- Time complexity:\\n $$O(n^2)$$\\n\\n\\n- Space complexity:\\n  $$O(n^2)$$\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] rangeAddQueries(int n, int[][] queries) {\\n        int mat[][] = new int[n][n];\\n        for(int query[]:queries) {\\n            helper(mat,query[0],query[1],query[2],query[3]);\\n        }\\n        return mat;\\n    }\\n    \\n    private void helper(int[][] mat,int rowStart,int rowEnd,int colStart,int colEnd) {\\n        for(int i=rowStart;i<=colStart;i++) {\\n            for(int j=rowEnd;j<=colEnd;j++) {\\n                mat[i][j] += 1;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] rangeAddQueries(int n, int[][] queries) {\\n        int mat[][] = new int[n][n];\\n        for(int query[]:queries) {\\n            helper(mat,query[0],query[1],query[2],query[3]);\\n        }\\n        return mat;\\n    }\\n    \\n    private void helper(int[][] mat,int rowStart,int rowEnd,int colStart,int colEnd) {\\n        for(int i=rowStart;i<=colStart;i++) {\\n            for(int j=rowEnd;j<=colEnd;j++) {\\n                mat[i][j] += 1;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3065942,
                "title": "python-2d-range-sum",
                "content": "```\\nclass Solution:\\n    def rangeAddQueries(self, n: int, queries: List[List[int]]) -> List[List[int]]:\\n        # 2D-range sum\\n        ans = []\\n        for i in range(n):\\n            ans.append([0 for _ in range(n)])\\n        \\n        for sr, sc, er, ec in queries:\\n            for i in range(sr, er + 1):\\n                ans[i][sc] += 1\\n                if ec + 1 < n:\\n                    ans[i][ec + 1] -= 1\\n        \\n        for i in range(n):\\n            for j in range(1, n):\\n                ans[i][j] += ans[i][j - 1]\\n                \\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rangeAddQueries(self, n: int, queries: List[List[int]]) -> List[List[int]]:\\n        # 2D-range sum\\n        ans = []\\n        for i in range(n):\\n            ans.append([0 for _ in range(n)])\\n        \\n        for sr, sc, er, ec in queries:\\n            for i in range(sr, er + 1):\\n                ans[i][sc] += 1\\n                if ec + 1 < n:\\n                    ans[i][ec + 1] -= 1\\n        \\n        for i in range(n):\\n            for j in range(1, n):\\n                ans[i][j] += ans[i][j - 1]\\n                \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3065698,
                "title": "java-o-n-n-contribution-technique",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n*n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] rangeAddQueries(int n, int[][] queries) {\\n        \\n        int res[][] = new int[n][n];\\n        \\n        for(int i = 0;i < queries.length;i++) {\\n            \\n            int r1 = queries[i][0];\\n            int c1 = queries[i][1];\\n            int r2 = queries[i][2];\\n            int c2 = queries[i][3];\\n            \\n            for(int j = r1;j <= r2;j++) {\\n                res[j][c1]++;\\n                if(c2 + 1 != n) { res[j][c2 + 1]--; }\\n            }\\n        }\\n        \\n        for(int i = 0;i < n;i++) {\\n            for(int j = 1;j < n;j++) {\\n                res[i][j] += res[i][j - 1];\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] rangeAddQueries(int n, int[][] queries) {\\n        \\n        int res[][] = new int[n][n];\\n        \\n        for(int i = 0;i < queries.length;i++) {\\n            \\n            int r1 = queries[i][0];\\n            int c1 = queries[i][1];\\n            int r2 = queries[i][2];\\n            int c2 = queries[i][3];\\n            \\n            for(int j = r1;j <= r2;j++) {\\n                res[j][c1]++;\\n                if(c2 + 1 != n) { res[j][c2 + 1]--; }\\n            }\\n        }\\n        \\n        for(int i = 0;i < n;i++) {\\n            for(int j = 1;j < n;j++) {\\n                res[i][j] += res[i][j - 1];\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3065297,
                "title": "prefix-sums-57-speed",
                "content": "![image.png](https://assets.leetcode.com/users/images/74b1448f-768f-42ec-bb64-a79115128636_1673980569.1225696.png)\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def rangeAddQueries(self, n: int, queries: List[List[int]]) -> List[List[int]]:\\n        m = [[0] * n for _ in range(n)]\\n        for r1, c1, r2, c2 in queries:\\n            for r in range(r1, r2 + 1):\\n                m[r][c1] += 1\\n                if c2 + 1 < n:\\n                    m[r][c2 + 1] -= 1\\n        for row in m:\\n            val = 0\\n            for c in range(n):\\n                row[c] += val\\n                val = row[c]\\n        return m\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rangeAddQueries(self, n: int, queries: List[List[int]]) -> List[List[int]]:\\n        m = [[0] * n for _ in range(n)]\\n        for r1, c1, r2, c2 in queries:\\n            for r in range(r1, r2 + 1):\\n                m[r][c1] += 1\\n                if c2 + 1 < n:\\n                    m[r][c2 + 1] -= 1\\n        for row in m:\\n            val = 0\\n            for c in range(n):\\n                row[c] += val\\n                val = row[c]\\n        return m\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3063059,
                "title": "brute-force-approach-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] rangeAddQueries(int n, int[][] queries) {\\n        int[][] mat=new int[n][n];\\n        for(int[]q:queries){\\n            int row1=q[0],row2=q[2],col1=q[1],col2=q[3];\\n            for(int x=row1;x<=row2;x++){\\n                for(int y=col1;y<=col2;y++){\\n                    mat[x][y]++;\\n                }\\n            }\\n        }\\n        return mat;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] rangeAddQueries(int n, int[][] queries) {\\n        int[][] mat=new int[n][n];\\n        for(int[]q:queries){\\n            int row1=q[0],row2=q[2],col1=q[1],col2=q[3];\\n            for(int x=row1;x<=row2;x++){\\n                for(int y=col1;y<=col2;y++){\\n                    mat[x][y]++;\\n                }\\n            }\\n        }\\n        return mat;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3063045,
                "title": "c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n        int i=0;\\n        vector<vector<int>>mat(n,vector<int>(n,0));\\n        while(i<queries.size())\\n        {\\n            int x=queries[i][0];\\n            int a=queries[i][1];\\n            int b=queries[i][2];\\n            int c=queries[i][3];\\n                for(int j=x;j<=b;j++)\\n                {\\n                    mat[j][a]++;\\n                    if(1+c<n)\\n                    mat[j][c+1]--;\\n                }\\n                  i++;\\n            }\\n          \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=1;j<n;j++)\\n            {\\n                mat[i][j]+=mat[i][j-1];\\n            }\\n        }\\n        return mat;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n        int i=0;\\n        vector<vector<int>>mat(n,vector<int>(n,0));\\n        while(i<queries.size())\\n        {\\n            int x=queries[i][0];\\n            int a=queries[i][1];\\n            int b=queries[i][2];\\n            int c=queries[i][3];\\n                for(int j=x;j<=b;j++)\\n                {\\n                    mat[j][a]++;\\n                    if(1+c<n)\\n                    mat[j][c+1]--;\\n                }\\n                  i++;\\n            }\\n          \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=1;j<n;j++)\\n            {\\n                mat[i][j]+=mat[i][j-1];\\n            }\\n        }\\n        return mat;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3061688,
                "title": "simple-java-prefix-sum-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(N(Q + N))\\n\\n- Space complexity:\\nO(N^2)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] rangeAddQueries(int n, int[][] queries) {\\n        int[][] preSum = new int[n][n + 1];\\n        for (int[] query : queries) {\\n            for (int i = query[0]; i <= query[2]; i++) {\\n                preSum[i][query[1]]++;\\n                preSum[i][query[3] + 1]--;\\n            }\\n        }\\n\\n        int[][] res = new int[n][n];\\n        for (int i = 0; i < n; i++) {\\n            int cur = 0;\\n            for (int j = 0; j < n; j++) {\\n                cur += preSum[i][j];\\n                res[i][j] = cur;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] rangeAddQueries(int n, int[][] queries) {\\n        int[][] preSum = new int[n][n + 1];\\n        for (int[] query : queries) {\\n            for (int i = query[0]; i <= query[2]; i++) {\\n                preSum[i][query[1]]++;\\n                preSum[i][query[3] + 1]--;\\n            }\\n        }\\n\\n        int[][] res = new int[n][n];\\n        for (int i = 0; i < n; i++) {\\n            int cur = 0;\\n            for (int j = 0; j < n; j++) {\\n                cur += preSum[i][j];\\n                res[i][j] = cur;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3061532,
                "title": "python-multiple-solution-2-d-caching-1-d-row-caching-numpy-solution",
                "content": "\\n# Approach 1 (2-D caching)\\n```\\nclass Solution:\\n    def rangeAddQueries(self, n: int, queries: List[List[int]]) -> List[List[int]]:\\n        \\n        mat = [[0 for _ in range(n)] for _ in range(n)]\\n\\n        for q in queries:\\n            r,c,re,ce = q\\n\\n            mat[r][c] += 1\\n\\n            if ce != n-1:\\n                mat[r][ce+1] -= 1\\n\\n            if re != n-1:\\n                mat[re+1][c] -= 1\\n\\n            if re != n-1 and ce != n-1:\\n                mat[re+1][ce+1] += 1\\n\\n        for row in range(len(mat)) :\\n            for col in range(1,len(mat[0])):\\n                mat[row][col] += mat[row][col-1]\\n\\n        for row in range(1,len(mat)) :\\n            for col in range(len(mat[0])):\\n                mat[row][col] += mat[row-1][col]\\n\\n        return mat\\n\\n                                \\n```\\n# Approach 2 (1-D row caching)\\n\\n    class Solution:\\n        def rangeAddQueries(self, n: int, queries: List[List[int]]) -> List[List[int]]:\\n\\n        mat = [[0 for _ in range(n)] for _ in range(n)]\\n\\n        for q in queries:\\n            r,c,re,ce = q\\n            for row in range(r,re+1):\\n                mat[row][c] += 1\\n                if ce != n-1:\\n                    mat[row][ce+1] -=1\\n\\n        for row in range(0,len(mat)):\\n            for col in range(1,len(mat[0])):\\n                mat[row][col] = mat[row][col] + mat[row][col-1] \\n        return mat\\n\\n\\n# Approach 3 (using numpy)\\n\\n\\n    class Solution:\\n        def rangeAddQueries(self, n: int, queries: List[List[int]]) -> List[List[int]]:\\n        import numpy as np\\n        \\n        mat = np.zeros((n,n),dtype = np.int8)\\n\\n        # mat = [[0 for _ in range(n)] for _ in range(n)]\\n        mat = np.array(mat)\\n        \\n        for q in queries:\\n            r,c,re,ce = q\\n            \\n            # sub_mat = np.ones((re-r+1,ce-c+1),dtype = np.int8)\\n            \\n            mat[r:re+1,c:ce+1] +=  1 \\n            \\n            \\n        return mat\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rangeAddQueries(self, n: int, queries: List[List[int]]) -> List[List[int]]:\\n        \\n        mat = [[0 for _ in range(n)] for _ in range(n)]\\n\\n        for q in queries:\\n            r,c,re,ce = q\\n\\n            mat[r][c] += 1\\n\\n            if ce != n-1:\\n                mat[r][ce+1] -= 1\\n\\n            if re != n-1:\\n                mat[re+1][c] -= 1\\n\\n            if re != n-1 and ce != n-1:\\n                mat[re+1][ce+1] += 1\\n\\n        for row in range(len(mat)) :\\n            for col in range(1,len(mat[0])):\\n                mat[row][col] += mat[row][col-1]\\n\\n        for row in range(1,len(mat)) :\\n            for col in range(len(mat[0])):\\n                mat[row][col] += mat[row-1][col]\\n\\n        return mat\\n\\n                                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3061347,
                "title": "python-vs-java-speed",
                "content": "# Intuition\\nThese are identical solutions, one in Java and one in Python3.\\nThe solution in Java is successful, but the one in Python3 exceeds the time limit.\\n\\n# Code Java\\n```\\nclass Solution {\\n    public int[][] rangeAddQueries(int n, int[][] x) {\\n            int[][] res = new int[n][n];\\n            \\n            for (int i=0;i<x.length;i++){\\n                for (int r1 = x[i][0]; r1 < x[i][2]+1; r1++)\\n                    for (int c1 = x[i][1]; c1 < x[i][3] + 1; c1++)\\n                        res[r1][c1] += 1;\\n            }\\n            \\n            return res;\\n        }\\n}\\n\\n```\\n\\n# Code Python3\\n```\\nclass Solution:\\n    def rangeAddQueries(self, n: int, queries: List[List[int]]) -> List[List[int]]:\\n        res = [[ 0 for i in range(n) ] for j in range(n) ]\\n        for x in queries:\\n            for r1 in range(x[0],x[2]+1):\\n                for c1 in range(x[1], x[3] + 1):\\n                    res[r1][c1] += 1\\n        return res\\n```",
                "solutionTags": [
                    "Java",
                    "Python3"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] rangeAddQueries(int n, int[][] x) {\\n            int[][] res = new int[n][n];\\n            \\n            for (int i=0;i<x.length;i++){\\n                for (int r1 = x[i][0]; r1 < x[i][2]+1; r1++)\\n                    for (int c1 = x[i][1]; c1 < x[i][3] + 1; c1++)\\n                        res[r1][c1] += 1;\\n            }\\n            \\n            return res;\\n        }\\n}\\n\\n```\n```\\nclass Solution:\\n    def rangeAddQueries(self, n: int, queries: List[List[int]]) -> List[List[int]]:\\n        res = [[ 0 for i in range(n) ] for j in range(n) ]\\n        for x in queries:\\n            for r1 in range(x[0],x[2]+1):\\n                for c1 in range(x[1], x[3] + 1):\\n                    res[r1][c1] += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3061160,
                "title": "python-solution-simple-and-easy",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def rangeAddQueries(self, n: int, queries: List[List[int]]) -> List[List[int]]:\\n        matrix=[[0 for i in range(n+1)] for j in range(n+1) ]\\n\\n        for row1,col1,row2,col2 in queries:\\n            for row in range(row1,row2+1):\\n                matrix[row][col1]+=1\\n                matrix[row][col2+1]-=1\\n        output=[]\\n        for row in range(n):\\n            total=0\\n            temp=[]\\n            for col in range(n):\\n                  total+=matrix[row][col]\\n                  temp.append(total)\\n            output.append(temp)\\n        return output\\n                  \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rangeAddQueries(self, n: int, queries: List[List[int]]) -> List[List[int]]:\\n        matrix=[[0 for i in range(n+1)] for j in range(n+1) ]\\n\\n        for row1,col1,row2,col2 in queries:\\n            for row in range(row1,row2+1):\\n                matrix[row][col1]+=1\\n                matrix[row][col2+1]-=1\\n        output=[]\\n        for row in range(n):\\n            total=0\\n            temp=[]\\n            for col in range(n):\\n                  total+=matrix[row][col]\\n                  temp.append(total)\\n            output.append(temp)\\n        return output\\n                  \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3060366,
                "title": "c-tried-thinking-like-lee215-line-sweep-prefix-sum",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nPrefix sum and line sweep\\n# Complexity\\n- Time complexity:\\n$$O(n^2)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n        vector<vector<int>> vals(n+1,vector<int>(n+1,0));\\n        for(int i=0;i<queries.size();i++){\\n            vals[queries[i][0]][queries[i][1]]++;\\n            vals[queries[i][2]+1][queries[i][1]]--;\\n            vals[queries[i][0]][queries[i][3]+1]--;\\n            vals[queries[i][2]+1][queries[i][3]+1]++;\\n        }\\n        vector<vector<int>> ans(n,vector<int>(n,0));\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(i==0&&j==0){\\n                    ans[i][j]=vals[i][j];\\n                }\\n                else if(i==0){\\n                    vals[i][j]=vals[i][j]+vals[i][j-1];\\n                    ans[i][j]=vals[i][j];\\n                }\\n                else if(j==0){\\n                    vals[i][j]=vals[i][j]+vals[i-1][j];\\n                    ans[i][j]=vals[i][j];\\n                }\\n                else {\\n                    vals[i][j]=vals[i][j]+vals[i][j-1]+vals[i-1][j]-vals[i-1][j-1];\\n                    ans[i][j]=vals[i][j];\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Line Sweep",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n        vector<vector<int>> vals(n+1,vector<int>(n+1,0));\\n        for(int i=0;i<queries.size();i++){\\n            vals[queries[i][0]][queries[i][1]]++;\\n            vals[queries[i][2]+1][queries[i][1]]--;\\n            vals[queries[i][0]][queries[i][3]+1]--;\\n            vals[queries[i][2]+1][queries[i][3]+1]++;\\n        }\\n        vector<vector<int>> ans(n,vector<int>(n,0));\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(i==0&&j==0){\\n                    ans[i][j]=vals[i][j];\\n                }\\n                else if(i==0){\\n                    vals[i][j]=vals[i][j]+vals[i][j-1];\\n                    ans[i][j]=vals[i][j];\\n                }\\n                else if(j==0){\\n                    vals[i][j]=vals[i][j]+vals[i-1][j];\\n                    ans[i][j]=vals[i][j];\\n                }\\n                else {\\n                    vals[i][j]=vals[i][j]+vals[i][j-1]+vals[i-1][j]-vals[i-1][j-1];\\n                    ans[i][j]=vals[i][j];\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3059837,
                "title": "js",
                "content": "\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @param {number[][]} queries\\n * @return {number[][]}\\n */\\nvar rangeAddQueries = function(n, queries) {\\n    // make the grid\\n    let g = [];\\n    for(let i = 0; i < n; i++) {\\n        let r = [];\\n        for(let j = 0; j < n; j++) {\\n            r.push(0)\\n        }\\n        g.push(r)\\n    }\\n\\n    // for each query, mark the left column of the rows \\n    // in the given range by adding 1 in the cell. also mark the\\n    // right column + 1 over in the same row (if it is in bounds)\\n    // by subtracting 1 in the cell.\\n    for(const [x,y,x2,y2] of queries) {\\n        for(let i = x; i < x2+1; i++) {\\n            g[i][y] += 1\\n            if(y2+1 < n) g[i][y2+1] -= 1\\n        }\\n    }\\n    \\n    // in each row, go through each column and add to\\n    // the element the previous col value. if a column is marked with\\n    // an increment, it will hit the decrement that was marked   \\n    // eventually and \"cancel out\".\\n    for(let i = 0; i < n; i++) {\\n        for(let j = 1; j < n; j++) {\\n            g[i][j] += g[i][j-1]\\n        }\\n    }\\n    \\n    return g;\\n };\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number[][]} queries\\n * @return {number[][]}\\n */\\nvar rangeAddQueries = function(n, queries) {\\n    // make the grid\\n    let g = [];\\n    for(let i = 0; i < n; i++) {\\n        let r = [];\\n        for(let j = 0; j < n; j++) {\\n            r.push(0)\\n        }\\n        g.push(r)\\n    }\\n\\n    // for each query, mark the left column of the rows \\n    // in the given range by adding 1 in the cell. also mark the\\n    // right column + 1 over in the same row (if it is in bounds)\\n    // by subtracting 1 in the cell.\\n    for(const [x,y,x2,y2] of queries) {\\n        for(let i = x; i < x2+1; i++) {\\n            g[i][y] += 1\\n            if(y2+1 < n) g[i][y2+1] -= 1\\n        }\\n    }\\n    \\n    // in each row, go through each column and add to\\n    // the element the previous col value. if a column is marked with\\n    // an increment, it will hit the decrement that was marked   \\n    // eventually and \"cancel out\".\\n    for(let i = 0; i < n; i++) {\\n        for(let j = 1; j < n; j++) {\\n            g[i][j] += g[i][j-1]\\n        }\\n    }\\n    \\n    return g;\\n };\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3059645,
                "title": "golang-174-ms-10-6-mb",
                "content": "# Complexity\\n- Time complexity: $$O(m + n^2)$$\\n- Space complexity: $$O(n^2)$$\\nwhere **m** - queries length\\n# Code\\n```\\nfunc rangeAddQueries(n int, queries [][]int) [][]int {\\n\\tresult := make([][]int, n)\\n\\tfor i := range result {\\n\\t\\tresult[i] = make([]int, n)\\n\\t}\\n\\tfor _, query := range queries {\\n\\t\\trow1, col1, row2, col2 := query[0], query[1], query[2], query[3]\\n\\t\\tresult[row1][col1]++\\n\\t\\tnotLastRow := row2 < n-1\\n\\t\\tnotLastCol := col2 < n-1\\n\\t\\tif notLastCol {\\n\\t\\t\\tresult[row1][col2+1]--\\n\\t\\t}\\n\\t\\tif notLastRow {\\n\\t\\t\\tresult[row2+1][col1]--\\n\\t\\t}\\n\\t\\tif notLastRow && notLastCol {\\n\\t\\t\\tresult[row2+1][col2+1]++\\n\\t\\t}\\n\\t}\\n\\tfor j := 1; j < n; j++ {\\n\\t\\tresult[0][j] += result[0][j-1]\\n\\t}\\n\\tfor i := 1; i < n; i++ {\\n\\t\\tfor j := 1; j < n; j++ {\\n\\t\\t\\tresult[i][j] += result[i][j-1]\\n\\t\\t\\tresult[i][j-1] += result[i-1][j-1]\\n\\t\\t}\\n\\t\\tresult[i][n-1] += result[i-1][n-1]\\n\\t}\\n\\treturn result\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc rangeAddQueries(n int, queries [][]int) [][]int {\\n\\tresult := make([][]int, n)\\n\\tfor i := range result {\\n\\t\\tresult[i] = make([]int, n)\\n\\t}\\n\\tfor _, query := range queries {\\n\\t\\trow1, col1, row2, col2 := query[0], query[1], query[2], query[3]\\n\\t\\tresult[row1][col1]++\\n\\t\\tnotLastRow := row2 < n-1\\n\\t\\tnotLastCol := col2 < n-1\\n\\t\\tif notLastCol {\\n\\t\\t\\tresult[row1][col2+1]--\\n\\t\\t}\\n\\t\\tif notLastRow {\\n\\t\\t\\tresult[row2+1][col1]--\\n\\t\\t}\\n\\t\\tif notLastRow && notLastCol {\\n\\t\\t\\tresult[row2+1][col2+1]++\\n\\t\\t}\\n\\t}\\n\\tfor j := 1; j < n; j++ {\\n\\t\\tresult[0][j] += result[0][j-1]\\n\\t}\\n\\tfor i := 1; i < n; i++ {\\n\\t\\tfor j := 1; j < n; j++ {\\n\\t\\t\\tresult[i][j] += result[i][j-1]\\n\\t\\t\\tresult[i][j-1] += result[i-1][j-1]\\n\\t\\t}\\n\\t\\tresult[i][n-1] += result[i-1][n-1]\\n\\t}\\n\\treturn result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3059621,
                "title": "jai-shree-ram-easy",
                "content": "\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) \\n    {\\n        vector<vector<int>> ans(n,vector<int> (n,0));\\n        \\n        for(vector<int> a:queries)\\n        {\\n            int r1=a[0];\\n            int c1=a[1];\\n            int r2=a[2];\\n            int c2=a[3];\\n            \\n            //me\\n            ans[r1][c1]+=1;\\n            //down\\n            if(r2+1<n)\\n                ans[r2+1][c1]+=(-1);\\n            //right\\n            if(c2+1<n)\\n                ans[r1][c2+1]+=(-1);\\n            //middle\\n            if(r2+1<n && c2+1<n)\\n                ans[r2+1][c2+1]+=1;\\n            \\n        }\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=1;j<n;j++)\\n                ans[i][j]+=ans[i][j-1];\\n        }\\n        \\n        for(int j=0;j<n;j++)\\n        {\\n            for(int i=1;i<n;i++)\\n                ans[i][j]+=ans[i-1][j];\\n        }\\n        return ans;\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) \\n    {\\n        vector<vector<int>> ans(n,vector<int> (n,0));\\n        \\n        for(vector<int> a:queries)\\n        {\\n            int r1=a[0];\\n            int c1=a[1];\\n            int r2=a[2];\\n            int c2=a[3];\\n            \\n            //me\\n            ans[r1][c1]+=1;\\n            //down\\n            if(r2+1<n)\\n                ans[r2+1][c1]+=(-1);\\n            //right\\n            if(c2+1<n)\\n                ans[r1][c2+1]+=(-1);\\n            //middle\\n            if(r2+1<n && c2+1<n)\\n                ans[r2+1][c2+1]+=1;\\n            \\n        }\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=1;j<n;j++)\\n                ans[i][j]+=ans[i][j-1];\\n        }\\n        \\n        for(int j=0;j<n;j++)\\n        {\\n            for(int i=1;i<n;i++)\\n                ans[i][j]+=ans[i-1][j];\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3058677,
                "title": "partial-sum-c-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n        vector<vector<int> > res(n, vector<int>(n, 0));\\n        \\n        for (auto query : queries) {\\n            int r1 = query[0];\\n            int c1 = query[1];\\n            int r2 = query[2];\\n            int c2 = query[3];\\n            \\n            for (int r = r1; r <= r2; r++) {\\n                res[r][c1] += 1;\\n                if (c2 + 1 < n) {\\n                    res[r][c2 + 1] -= 1;\\n                }\\n            }\\n        }\\n        \\n        for (int i = 0; i < n; i++) {\\n            for (int j = 1; j < n; j++) {\\n                res[i][j] += res[i][j-1];\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n        vector<vector<int> > res(n, vector<int>(n, 0));\\n        \\n        for (auto query : queries) {\\n            int r1 = query[0];\\n            int c1 = query[1];\\n            int r2 = query[2];\\n            int c2 = query[3];\\n            \\n            for (int r = r1; r <= r2; r++) {\\n                res[r][c1] += 1;\\n                if (c2 + 1 < n) {\\n                    res[r][c2 + 1] -= 1;\\n                }\\n            }\\n        }\\n        \\n        for (int i = 0; i < n; i++) {\\n            for (int j = 1; j < n; j++) {\\n                res[i][j] += res[i][j-1];\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3058330,
                "title": "scala-straightforward",
                "content": "# Code\\n```\\nobject Solution {\\n  def rangeAddQueries(n: Int, queries: Array[Array[Int]]): Array[Array[Int]] = {\\n    val arr = Array.fill(n)(new Array[Int](n))\\n    queries.foreach { q =>\\n      for {\\n        i <- q(0) to q(2)\\n        j <- q(1) to q(3)\\n      } arr(i)(j) += 1\\n    }\\n    arr\\n  }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n  def rangeAddQueries(n: Int, queries: Array[Array[Int]]): Array[Array[Int]] = {\\n    val arr = Array.fill(n)(new Array[Int](n))\\n    queries.foreach { q =>\\n      for {\\n        i <- q(0) to q(2)\\n        j <- q(1) to q(3)\\n      } arr(i)(j) += 1\\n    }\\n    arr\\n  }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3058242,
                "title": "easy-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n        vector<vector<int>> mat(n, vector<int> (n, 0));\\n        \\n        for(int i=0; i<queries.size(); i++) {\\n            vector<int> range = queries[i];\\n            for(int j=range[0]; j<=range[2]; j++) {\\n                mat[j][range[1]] += 1;\\n            }\\n            for(int j=range[0]; j<=range[2]; j++) {\\n                if(range[3]+1 == n) {\\n                    if(j+1 < n) mat[j+1][0] -= 1;\\n                }\\n                else mat[j][range[3]+1] -= 1;\\n            }\\n        }\\n        \\n        int tot = 0;\\n        for(int i=0; i<n; i++) {\\n            for(int j=0; j<n; j++) {\\n                // cout << mat[i][j] << \\' \\';\\n                tot += mat[i][j];\\n                mat[i][j] = tot;\\n            }\\n            // cout << endl;\\n        }\\n        \\n        return mat;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n        vector<vector<int>> mat(n, vector<int> (n, 0));\\n        \\n        for(int i=0; i<queries.size(); i++) {\\n            vector<int> range = queries[i];\\n            for(int j=range[0]; j<=range[2]; j++) {\\n                mat[j][range[1]] += 1;\\n            }\\n            for(int j=range[0]; j<=range[2]; j++) {\\n                if(range[3]+1 == n) {\\n                    if(j+1 < n) mat[j+1][0] -= 1;\\n                }\\n                else mat[j][range[3]+1] -= 1;\\n            }\\n        }\\n        \\n        int tot = 0;\\n        for(int i=0; i<n; i++) {\\n            for(int j=0; j<n; j++) {\\n                // cout << mat[i][j] << \\' \\';\\n                tot += mat[i][j];\\n                mat[i][j] = tot;\\n            }\\n            // cout << endl;\\n        }\\n        \\n        return mat;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3058177,
                "title": "python-o-n-q-100-faster",
                "content": "# Code\\n```\\nfrom collections import defaultdict\\nclass Solution:\\n    def rangeAddQueries(self, n: int, queries: List[List[int]]) -> List[List[int]]:\\n        d = defaultdict(list)\\n        L, R = 0, 1\\n        for i, (lx, ty, rx, by) in enumerate(queries):\\n            d[lx].append((i,L))\\n            d[rx + 1].append((i,R))\\n        grid = [[0]*n for _ in range(n)]\\n        events = defaultdict(int)\\n        for i in range(n):\\n            for j, E in d[i]:\\n                _, ty, _, by = queries[j]\\n                if E == L:\\n                    events[ty] += 1\\n                    events[by+1] -= 1\\n                else:\\n                    events[ty] -= 1\\n                    events[by+1] += 1\\n            cur = 0\\n            for j in range(n):\\n                cur += events[j]\\n                grid[i][j] = cur\\n        return grid\\n                \\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def rangeAddQueries(self, n: int, queries: List[List[int]]) -> List[List[int]]:\\n        d = defaultdict(list)\\n        L, R = 0, 1\\n        for i, (lx, ty, rx, by) in enumerate(queries):\\n            d[lx].append((i,L))\\n            d[rx + 1].append((i,R))\\n        grid = [[0]*n for _ in range(n)]\\n        events = defaultdict(int)\\n        for i in range(n):\\n            for j, E in d[i]:\\n                _, ty, _, by = queries[j]\\n                if E == L:\\n                    events[ty] += 1\\n                    events[by+1] -= 1\\n                else:\\n                    events[ty] -= 1\\n                    events[by+1] += 1\\n            cur = 0\\n            for j in range(n):\\n                cur += events[j]\\n                grid[i][j] = cur\\n        return grid\\n                \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3057658,
                "title": "increment-submatrices-by-one",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& q) {\\n        vector<vector<int>> p(n,vector<int>(n,0));\\n        for(int i=0;i<q.size();i++){\\n            for(int j=q[i][0];j<=q[i][2];j++){\\n                p[j][q[i][1]]++;\\n                if((1+q[i][3])!=n)\\n                    p[j][q[i][3]+1]--;\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=1;j<n;j++){\\n                p[i][j]+=p[i][j-1];\\n            }\\n        }\\n        return p;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& q) {\\n        vector<vector<int>> p(n,vector<int>(n,0));\\n        for(int i=0;i<q.size();i++){\\n            for(int j=q[i][0];j<=q[i][2];j++){\\n                p[j][q[i][1]]++;\\n                if((1+q[i][3])!=n)\\n                    p[j][q[i][3]+1]--;\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=1;j<n;j++){\\n                p[i][j]+=p[i][j-1];\\n            }\\n        }\\n        return p;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1758421,
                "content": [
                    {
                        "username": "PS07",
                        "content": "Accepeted in Java but got TLE in C++ & Python !!\n\nJava Brute Force  Solution got accepted\n ```\nclass Solution {\n    public int[][] rangeAddQueries(int n, int[][] queries) {\n    int[][] mat = new int[n][n];\n    for (int[] q : queries) {\n        int row1 = q[0], col1 = q[1], row2 = q[2], col2 = q[3];\n        for (int i = row1; i <= row2; i++) {\n            for (int j = col1; j <= col2; j++) {\n                mat[i][j]++;\n            }\n        }\n    }\n    return mat;\n    }\n}\n```\n\nBut same C++ Solution gets Time Limit Exceeded on TestCase 18\n ```\nclass Solution {\npublic:\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\n        vector<vector<int>> mat(n, vector<int>(n, 0)) ;\n        for (auto &q : queries) {\n            int row1 = q[0], col1 = q[1], row2 = q[2], col2 = q[3];\n            for (int i = row1; i <= row2; i++) {\n                for (int j = col1; j <= col2; j++) {\n                    mat[i][j]++;\n                }\n            }\n        }\n        return mat;\n    }\n};\n```\n\nPlease fix the issue as many participants got penalty because of this issue."
                    },
                    {
                        "username": "krashkodes",
                        "content": "[@Leetcode_A_P_R](/Leetcode_A_P_R)  Look up the concept of Difference Array and Prefix Sum. A good resource for related questions on leetcode is [this](https://leetcode.com/discuss/study-guide/2166045/line-sweep-algorithms)."
                    },
                    {
                        "username": "raiabhinavprakash",
                        "content": "[@krashkodes](/krashkodes) can you please give an idea to solve this in c++. Because brute force is accepted in java"
                    },
                    {
                        "username": "ZheDre1N",
                        "content": "class Solution {\\n    func rangeAddQueries(_ n: Int, _ queries: [[Int]]) -> [[Int]] {\\n        var matrix = Array(repeating: Array(repeating: 0, count: n), count: n)\\n        \\n        for query in queries {\\n            for i in query[0]...query[2] {\\n                for j in query[1]...query[3]  {\\n                    matrix[i][j] += 1\\n                }\\n            }\\n        }\\n        return matrix\\n    }\\n}\\n\\nOptimising swift solution also don\\'t pass"
                    },
                    {
                        "username": "PS07",
                        "content": "[@krashkodes](/krashkodes)  Exactly "
                    },
                    {
                        "username": "krashkodes",
                        "content": "If brute force was meant to be accepted this wouldn\\'t have been marked medium. "
                    },
                    {
                        "username": "ZongyuWu",
                        "content": "Python TLE..."
                    },
                    {
                        "username": "hxu10",
                        "content": "Please add more test cases,  like n=500, q=10000 and all queries are increasing the whole matrix by 1, this will make Java brute force solution not pass. \n\nIf you want brute force pass, you should make all language equal,  not Java can pass but c++ can't,  one should not be punished by the coding language he chosen. "
                    },
                    {
                        "username": "leetcodingm",
                        "content": "hint: think about how you would solve it on an 1D array without running each query separately, i.e how can you accumulate queries"
                    },
                    {
                        "username": "nirala_001",
                        "content": "Java getting AC but in C++ TLE why ?\\nvery sad day for  me !!\\nHappy coding"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "https://leetcode.com/problems/increment-submatrices-by-one/solutions/3053106/brute-force-accepted-in-java-beginner-friendly-space-complexity-explained/"
                    },
                    {
                        "username": "vishalbiet",
                        "content": "yes i also realised this after seeing Brute force Solution written in java gets accepted while c++ gives TLE \\uD83D\\uDE25"
                    },
                    {
                        "username": "sepac",
                        "content": "Not sure how this is a medium..."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "The solution idea was great!! Couldn\\'t break through this by myself"
                    },
                    {
                        "username": "Unikdahal",
                        "content": "Same Solution TLE in C++ Accepted in Java..."
                    },
                    {
                        "username": "bharat_bardiya",
                        "content": "why brute force solution also working ?"
                    },
                    {
                        "username": "goodgoodwish",
                        "content": "My Rust brute force code accepted."
                    },
                    {
                        "username": "akshays274",
                        "content": "    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n\\n        vector<vector<int>> mat(n,vector<int> (n,0));\\n\\n        for(int i=0;i<queries.size();i++)\\n        {\\n            int j = queries[i][0];\\n            int k = queries[i][1];\\n            int count = (queries[i][2]-queries[i][0]+1)*(queries[i][3]-queries[i][1]+1);\\n                \\n            while(count)\\n            {\\n                \\n                mat[j][k]++;\\n\\n                if(queries[i][3] == 0)\\n                {\\n                    j++;\\n                }\\n                else if(k%queries[i][3]!=0 || k==0)\\n                    k++;\\n                else\\n                {\\n                    j++;\\n                    k=queries[i][1];\\n                }\\n                \\n                count--;\\n            }\\n        }\\n        return mat;\\n    }\\n};\\n\\nwhat is wrong with this approach? I tried this optimized approach but it is showing in TLE\\n"
                    }
                ]
            },
            {
                "id": 1758313,
                "content": [
                    {
                        "username": "PS07",
                        "content": "Accepeted in Java but got TLE in C++ & Python !!\n\nJava Brute Force  Solution got accepted\n ```\nclass Solution {\n    public int[][] rangeAddQueries(int n, int[][] queries) {\n    int[][] mat = new int[n][n];\n    for (int[] q : queries) {\n        int row1 = q[0], col1 = q[1], row2 = q[2], col2 = q[3];\n        for (int i = row1; i <= row2; i++) {\n            for (int j = col1; j <= col2; j++) {\n                mat[i][j]++;\n            }\n        }\n    }\n    return mat;\n    }\n}\n```\n\nBut same C++ Solution gets Time Limit Exceeded on TestCase 18\n ```\nclass Solution {\npublic:\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\n        vector<vector<int>> mat(n, vector<int>(n, 0)) ;\n        for (auto &q : queries) {\n            int row1 = q[0], col1 = q[1], row2 = q[2], col2 = q[3];\n            for (int i = row1; i <= row2; i++) {\n                for (int j = col1; j <= col2; j++) {\n                    mat[i][j]++;\n                }\n            }\n        }\n        return mat;\n    }\n};\n```\n\nPlease fix the issue as many participants got penalty because of this issue."
                    },
                    {
                        "username": "krashkodes",
                        "content": "[@Leetcode_A_P_R](/Leetcode_A_P_R)  Look up the concept of Difference Array and Prefix Sum. A good resource for related questions on leetcode is [this](https://leetcode.com/discuss/study-guide/2166045/line-sweep-algorithms)."
                    },
                    {
                        "username": "raiabhinavprakash",
                        "content": "[@krashkodes](/krashkodes) can you please give an idea to solve this in c++. Because brute force is accepted in java"
                    },
                    {
                        "username": "ZheDre1N",
                        "content": "class Solution {\\n    func rangeAddQueries(_ n: Int, _ queries: [[Int]]) -> [[Int]] {\\n        var matrix = Array(repeating: Array(repeating: 0, count: n), count: n)\\n        \\n        for query in queries {\\n            for i in query[0]...query[2] {\\n                for j in query[1]...query[3]  {\\n                    matrix[i][j] += 1\\n                }\\n            }\\n        }\\n        return matrix\\n    }\\n}\\n\\nOptimising swift solution also don\\'t pass"
                    },
                    {
                        "username": "PS07",
                        "content": "[@krashkodes](/krashkodes)  Exactly "
                    },
                    {
                        "username": "krashkodes",
                        "content": "If brute force was meant to be accepted this wouldn\\'t have been marked medium. "
                    },
                    {
                        "username": "ZongyuWu",
                        "content": "Python TLE..."
                    },
                    {
                        "username": "hxu10",
                        "content": "Please add more test cases,  like n=500, q=10000 and all queries are increasing the whole matrix by 1, this will make Java brute force solution not pass. \n\nIf you want brute force pass, you should make all language equal,  not Java can pass but c++ can't,  one should not be punished by the coding language he chosen. "
                    },
                    {
                        "username": "leetcodingm",
                        "content": "hint: think about how you would solve it on an 1D array without running each query separately, i.e how can you accumulate queries"
                    },
                    {
                        "username": "nirala_001",
                        "content": "Java getting AC but in C++ TLE why ?\\nvery sad day for  me !!\\nHappy coding"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "https://leetcode.com/problems/increment-submatrices-by-one/solutions/3053106/brute-force-accepted-in-java-beginner-friendly-space-complexity-explained/"
                    },
                    {
                        "username": "vishalbiet",
                        "content": "yes i also realised this after seeing Brute force Solution written in java gets accepted while c++ gives TLE \\uD83D\\uDE25"
                    },
                    {
                        "username": "sepac",
                        "content": "Not sure how this is a medium..."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "The solution idea was great!! Couldn\\'t break through this by myself"
                    },
                    {
                        "username": "Unikdahal",
                        "content": "Same Solution TLE in C++ Accepted in Java..."
                    },
                    {
                        "username": "bharat_bardiya",
                        "content": "why brute force solution also working ?"
                    },
                    {
                        "username": "goodgoodwish",
                        "content": "My Rust brute force code accepted."
                    },
                    {
                        "username": "akshays274",
                        "content": "    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n\\n        vector<vector<int>> mat(n,vector<int> (n,0));\\n\\n        for(int i=0;i<queries.size();i++)\\n        {\\n            int j = queries[i][0];\\n            int k = queries[i][1];\\n            int count = (queries[i][2]-queries[i][0]+1)*(queries[i][3]-queries[i][1]+1);\\n                \\n            while(count)\\n            {\\n                \\n                mat[j][k]++;\\n\\n                if(queries[i][3] == 0)\\n                {\\n                    j++;\\n                }\\n                else if(k%queries[i][3]!=0 || k==0)\\n                    k++;\\n                else\\n                {\\n                    j++;\\n                    k=queries[i][1];\\n                }\\n                \\n                count--;\\n            }\\n        }\\n        return mat;\\n    }\\n};\\n\\nwhat is wrong with this approach? I tried this optimized approach but it is showing in TLE\\n"
                    }
                ]
            },
            {
                "id": 1759510,
                "content": [
                    {
                        "username": "PS07",
                        "content": "Accepeted in Java but got TLE in C++ & Python !!\n\nJava Brute Force  Solution got accepted\n ```\nclass Solution {\n    public int[][] rangeAddQueries(int n, int[][] queries) {\n    int[][] mat = new int[n][n];\n    for (int[] q : queries) {\n        int row1 = q[0], col1 = q[1], row2 = q[2], col2 = q[3];\n        for (int i = row1; i <= row2; i++) {\n            for (int j = col1; j <= col2; j++) {\n                mat[i][j]++;\n            }\n        }\n    }\n    return mat;\n    }\n}\n```\n\nBut same C++ Solution gets Time Limit Exceeded on TestCase 18\n ```\nclass Solution {\npublic:\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\n        vector<vector<int>> mat(n, vector<int>(n, 0)) ;\n        for (auto &q : queries) {\n            int row1 = q[0], col1 = q[1], row2 = q[2], col2 = q[3];\n            for (int i = row1; i <= row2; i++) {\n                for (int j = col1; j <= col2; j++) {\n                    mat[i][j]++;\n                }\n            }\n        }\n        return mat;\n    }\n};\n```\n\nPlease fix the issue as many participants got penalty because of this issue."
                    },
                    {
                        "username": "krashkodes",
                        "content": "[@Leetcode_A_P_R](/Leetcode_A_P_R)  Look up the concept of Difference Array and Prefix Sum. A good resource for related questions on leetcode is [this](https://leetcode.com/discuss/study-guide/2166045/line-sweep-algorithms)."
                    },
                    {
                        "username": "raiabhinavprakash",
                        "content": "[@krashkodes](/krashkodes) can you please give an idea to solve this in c++. Because brute force is accepted in java"
                    },
                    {
                        "username": "ZheDre1N",
                        "content": "class Solution {\\n    func rangeAddQueries(_ n: Int, _ queries: [[Int]]) -> [[Int]] {\\n        var matrix = Array(repeating: Array(repeating: 0, count: n), count: n)\\n        \\n        for query in queries {\\n            for i in query[0]...query[2] {\\n                for j in query[1]...query[3]  {\\n                    matrix[i][j] += 1\\n                }\\n            }\\n        }\\n        return matrix\\n    }\\n}\\n\\nOptimising swift solution also don\\'t pass"
                    },
                    {
                        "username": "PS07",
                        "content": "[@krashkodes](/krashkodes)  Exactly "
                    },
                    {
                        "username": "krashkodes",
                        "content": "If brute force was meant to be accepted this wouldn\\'t have been marked medium. "
                    },
                    {
                        "username": "ZongyuWu",
                        "content": "Python TLE..."
                    },
                    {
                        "username": "hxu10",
                        "content": "Please add more test cases,  like n=500, q=10000 and all queries are increasing the whole matrix by 1, this will make Java brute force solution not pass. \n\nIf you want brute force pass, you should make all language equal,  not Java can pass but c++ can't,  one should not be punished by the coding language he chosen. "
                    },
                    {
                        "username": "leetcodingm",
                        "content": "hint: think about how you would solve it on an 1D array without running each query separately, i.e how can you accumulate queries"
                    },
                    {
                        "username": "nirala_001",
                        "content": "Java getting AC but in C++ TLE why ?\\nvery sad day for  me !!\\nHappy coding"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "https://leetcode.com/problems/increment-submatrices-by-one/solutions/3053106/brute-force-accepted-in-java-beginner-friendly-space-complexity-explained/"
                    },
                    {
                        "username": "vishalbiet",
                        "content": "yes i also realised this after seeing Brute force Solution written in java gets accepted while c++ gives TLE \\uD83D\\uDE25"
                    },
                    {
                        "username": "sepac",
                        "content": "Not sure how this is a medium..."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "The solution idea was great!! Couldn\\'t break through this by myself"
                    },
                    {
                        "username": "Unikdahal",
                        "content": "Same Solution TLE in C++ Accepted in Java..."
                    },
                    {
                        "username": "bharat_bardiya",
                        "content": "why brute force solution also working ?"
                    },
                    {
                        "username": "goodgoodwish",
                        "content": "My Rust brute force code accepted."
                    },
                    {
                        "username": "akshays274",
                        "content": "    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n\\n        vector<vector<int>> mat(n,vector<int> (n,0));\\n\\n        for(int i=0;i<queries.size();i++)\\n        {\\n            int j = queries[i][0];\\n            int k = queries[i][1];\\n            int count = (queries[i][2]-queries[i][0]+1)*(queries[i][3]-queries[i][1]+1);\\n                \\n            while(count)\\n            {\\n                \\n                mat[j][k]++;\\n\\n                if(queries[i][3] == 0)\\n                {\\n                    j++;\\n                }\\n                else if(k%queries[i][3]!=0 || k==0)\\n                    k++;\\n                else\\n                {\\n                    j++;\\n                    k=queries[i][1];\\n                }\\n                \\n                count--;\\n            }\\n        }\\n        return mat;\\n    }\\n};\\n\\nwhat is wrong with this approach? I tried this optimized approach but it is showing in TLE\\n"
                    }
                ]
            },
            {
                "id": 1758759,
                "content": [
                    {
                        "username": "PS07",
                        "content": "Accepeted in Java but got TLE in C++ & Python !!\n\nJava Brute Force  Solution got accepted\n ```\nclass Solution {\n    public int[][] rangeAddQueries(int n, int[][] queries) {\n    int[][] mat = new int[n][n];\n    for (int[] q : queries) {\n        int row1 = q[0], col1 = q[1], row2 = q[2], col2 = q[3];\n        for (int i = row1; i <= row2; i++) {\n            for (int j = col1; j <= col2; j++) {\n                mat[i][j]++;\n            }\n        }\n    }\n    return mat;\n    }\n}\n```\n\nBut same C++ Solution gets Time Limit Exceeded on TestCase 18\n ```\nclass Solution {\npublic:\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\n        vector<vector<int>> mat(n, vector<int>(n, 0)) ;\n        for (auto &q : queries) {\n            int row1 = q[0], col1 = q[1], row2 = q[2], col2 = q[3];\n            for (int i = row1; i <= row2; i++) {\n                for (int j = col1; j <= col2; j++) {\n                    mat[i][j]++;\n                }\n            }\n        }\n        return mat;\n    }\n};\n```\n\nPlease fix the issue as many participants got penalty because of this issue."
                    },
                    {
                        "username": "krashkodes",
                        "content": "[@Leetcode_A_P_R](/Leetcode_A_P_R)  Look up the concept of Difference Array and Prefix Sum. A good resource for related questions on leetcode is [this](https://leetcode.com/discuss/study-guide/2166045/line-sweep-algorithms)."
                    },
                    {
                        "username": "raiabhinavprakash",
                        "content": "[@krashkodes](/krashkodes) can you please give an idea to solve this in c++. Because brute force is accepted in java"
                    },
                    {
                        "username": "ZheDre1N",
                        "content": "class Solution {\\n    func rangeAddQueries(_ n: Int, _ queries: [[Int]]) -> [[Int]] {\\n        var matrix = Array(repeating: Array(repeating: 0, count: n), count: n)\\n        \\n        for query in queries {\\n            for i in query[0]...query[2] {\\n                for j in query[1]...query[3]  {\\n                    matrix[i][j] += 1\\n                }\\n            }\\n        }\\n        return matrix\\n    }\\n}\\n\\nOptimising swift solution also don\\'t pass"
                    },
                    {
                        "username": "PS07",
                        "content": "[@krashkodes](/krashkodes)  Exactly "
                    },
                    {
                        "username": "krashkodes",
                        "content": "If brute force was meant to be accepted this wouldn\\'t have been marked medium. "
                    },
                    {
                        "username": "ZongyuWu",
                        "content": "Python TLE..."
                    },
                    {
                        "username": "hxu10",
                        "content": "Please add more test cases,  like n=500, q=10000 and all queries are increasing the whole matrix by 1, this will make Java brute force solution not pass. \n\nIf you want brute force pass, you should make all language equal,  not Java can pass but c++ can't,  one should not be punished by the coding language he chosen. "
                    },
                    {
                        "username": "leetcodingm",
                        "content": "hint: think about how you would solve it on an 1D array without running each query separately, i.e how can you accumulate queries"
                    },
                    {
                        "username": "nirala_001",
                        "content": "Java getting AC but in C++ TLE why ?\\nvery sad day for  me !!\\nHappy coding"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "https://leetcode.com/problems/increment-submatrices-by-one/solutions/3053106/brute-force-accepted-in-java-beginner-friendly-space-complexity-explained/"
                    },
                    {
                        "username": "vishalbiet",
                        "content": "yes i also realised this after seeing Brute force Solution written in java gets accepted while c++ gives TLE \\uD83D\\uDE25"
                    },
                    {
                        "username": "sepac",
                        "content": "Not sure how this is a medium..."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "The solution idea was great!! Couldn\\'t break through this by myself"
                    },
                    {
                        "username": "Unikdahal",
                        "content": "Same Solution TLE in C++ Accepted in Java..."
                    },
                    {
                        "username": "bharat_bardiya",
                        "content": "why brute force solution also working ?"
                    },
                    {
                        "username": "goodgoodwish",
                        "content": "My Rust brute force code accepted."
                    },
                    {
                        "username": "akshays274",
                        "content": "    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n\\n        vector<vector<int>> mat(n,vector<int> (n,0));\\n\\n        for(int i=0;i<queries.size();i++)\\n        {\\n            int j = queries[i][0];\\n            int k = queries[i][1];\\n            int count = (queries[i][2]-queries[i][0]+1)*(queries[i][3]-queries[i][1]+1);\\n                \\n            while(count)\\n            {\\n                \\n                mat[j][k]++;\\n\\n                if(queries[i][3] == 0)\\n                {\\n                    j++;\\n                }\\n                else if(k%queries[i][3]!=0 || k==0)\\n                    k++;\\n                else\\n                {\\n                    j++;\\n                    k=queries[i][1];\\n                }\\n                \\n                count--;\\n            }\\n        }\\n        return mat;\\n    }\\n};\\n\\nwhat is wrong with this approach? I tried this optimized approach but it is showing in TLE\\n"
                    }
                ]
            },
            {
                "id": 1758431,
                "content": [
                    {
                        "username": "PS07",
                        "content": "Accepeted in Java but got TLE in C++ & Python !!\n\nJava Brute Force  Solution got accepted\n ```\nclass Solution {\n    public int[][] rangeAddQueries(int n, int[][] queries) {\n    int[][] mat = new int[n][n];\n    for (int[] q : queries) {\n        int row1 = q[0], col1 = q[1], row2 = q[2], col2 = q[3];\n        for (int i = row1; i <= row2; i++) {\n            for (int j = col1; j <= col2; j++) {\n                mat[i][j]++;\n            }\n        }\n    }\n    return mat;\n    }\n}\n```\n\nBut same C++ Solution gets Time Limit Exceeded on TestCase 18\n ```\nclass Solution {\npublic:\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\n        vector<vector<int>> mat(n, vector<int>(n, 0)) ;\n        for (auto &q : queries) {\n            int row1 = q[0], col1 = q[1], row2 = q[2], col2 = q[3];\n            for (int i = row1; i <= row2; i++) {\n                for (int j = col1; j <= col2; j++) {\n                    mat[i][j]++;\n                }\n            }\n        }\n        return mat;\n    }\n};\n```\n\nPlease fix the issue as many participants got penalty because of this issue."
                    },
                    {
                        "username": "krashkodes",
                        "content": "[@Leetcode_A_P_R](/Leetcode_A_P_R)  Look up the concept of Difference Array and Prefix Sum. A good resource for related questions on leetcode is [this](https://leetcode.com/discuss/study-guide/2166045/line-sweep-algorithms)."
                    },
                    {
                        "username": "raiabhinavprakash",
                        "content": "[@krashkodes](/krashkodes) can you please give an idea to solve this in c++. Because brute force is accepted in java"
                    },
                    {
                        "username": "ZheDre1N",
                        "content": "class Solution {\\n    func rangeAddQueries(_ n: Int, _ queries: [[Int]]) -> [[Int]] {\\n        var matrix = Array(repeating: Array(repeating: 0, count: n), count: n)\\n        \\n        for query in queries {\\n            for i in query[0]...query[2] {\\n                for j in query[1]...query[3]  {\\n                    matrix[i][j] += 1\\n                }\\n            }\\n        }\\n        return matrix\\n    }\\n}\\n\\nOptimising swift solution also don\\'t pass"
                    },
                    {
                        "username": "PS07",
                        "content": "[@krashkodes](/krashkodes)  Exactly "
                    },
                    {
                        "username": "krashkodes",
                        "content": "If brute force was meant to be accepted this wouldn\\'t have been marked medium. "
                    },
                    {
                        "username": "ZongyuWu",
                        "content": "Python TLE..."
                    },
                    {
                        "username": "hxu10",
                        "content": "Please add more test cases,  like n=500, q=10000 and all queries are increasing the whole matrix by 1, this will make Java brute force solution not pass. \n\nIf you want brute force pass, you should make all language equal,  not Java can pass but c++ can't,  one should not be punished by the coding language he chosen. "
                    },
                    {
                        "username": "leetcodingm",
                        "content": "hint: think about how you would solve it on an 1D array without running each query separately, i.e how can you accumulate queries"
                    },
                    {
                        "username": "nirala_001",
                        "content": "Java getting AC but in C++ TLE why ?\\nvery sad day for  me !!\\nHappy coding"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "https://leetcode.com/problems/increment-submatrices-by-one/solutions/3053106/brute-force-accepted-in-java-beginner-friendly-space-complexity-explained/"
                    },
                    {
                        "username": "vishalbiet",
                        "content": "yes i also realised this after seeing Brute force Solution written in java gets accepted while c++ gives TLE \\uD83D\\uDE25"
                    },
                    {
                        "username": "sepac",
                        "content": "Not sure how this is a medium..."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "The solution idea was great!! Couldn\\'t break through this by myself"
                    },
                    {
                        "username": "Unikdahal",
                        "content": "Same Solution TLE in C++ Accepted in Java..."
                    },
                    {
                        "username": "bharat_bardiya",
                        "content": "why brute force solution also working ?"
                    },
                    {
                        "username": "goodgoodwish",
                        "content": "My Rust brute force code accepted."
                    },
                    {
                        "username": "akshays274",
                        "content": "    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n\\n        vector<vector<int>> mat(n,vector<int> (n,0));\\n\\n        for(int i=0;i<queries.size();i++)\\n        {\\n            int j = queries[i][0];\\n            int k = queries[i][1];\\n            int count = (queries[i][2]-queries[i][0]+1)*(queries[i][3]-queries[i][1]+1);\\n                \\n            while(count)\\n            {\\n                \\n                mat[j][k]++;\\n\\n                if(queries[i][3] == 0)\\n                {\\n                    j++;\\n                }\\n                else if(k%queries[i][3]!=0 || k==0)\\n                    k++;\\n                else\\n                {\\n                    j++;\\n                    k=queries[i][1];\\n                }\\n                \\n                count--;\\n            }\\n        }\\n        return mat;\\n    }\\n};\\n\\nwhat is wrong with this approach? I tried this optimized approach but it is showing in TLE\\n"
                    }
                ]
            },
            {
                "id": 1759507,
                "content": [
                    {
                        "username": "PS07",
                        "content": "Accepeted in Java but got TLE in C++ & Python !!\n\nJava Brute Force  Solution got accepted\n ```\nclass Solution {\n    public int[][] rangeAddQueries(int n, int[][] queries) {\n    int[][] mat = new int[n][n];\n    for (int[] q : queries) {\n        int row1 = q[0], col1 = q[1], row2 = q[2], col2 = q[3];\n        for (int i = row1; i <= row2; i++) {\n            for (int j = col1; j <= col2; j++) {\n                mat[i][j]++;\n            }\n        }\n    }\n    return mat;\n    }\n}\n```\n\nBut same C++ Solution gets Time Limit Exceeded on TestCase 18\n ```\nclass Solution {\npublic:\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\n        vector<vector<int>> mat(n, vector<int>(n, 0)) ;\n        for (auto &q : queries) {\n            int row1 = q[0], col1 = q[1], row2 = q[2], col2 = q[3];\n            for (int i = row1; i <= row2; i++) {\n                for (int j = col1; j <= col2; j++) {\n                    mat[i][j]++;\n                }\n            }\n        }\n        return mat;\n    }\n};\n```\n\nPlease fix the issue as many participants got penalty because of this issue."
                    },
                    {
                        "username": "krashkodes",
                        "content": "[@Leetcode_A_P_R](/Leetcode_A_P_R)  Look up the concept of Difference Array and Prefix Sum. A good resource for related questions on leetcode is [this](https://leetcode.com/discuss/study-guide/2166045/line-sweep-algorithms)."
                    },
                    {
                        "username": "raiabhinavprakash",
                        "content": "[@krashkodes](/krashkodes) can you please give an idea to solve this in c++. Because brute force is accepted in java"
                    },
                    {
                        "username": "ZheDre1N",
                        "content": "class Solution {\\n    func rangeAddQueries(_ n: Int, _ queries: [[Int]]) -> [[Int]] {\\n        var matrix = Array(repeating: Array(repeating: 0, count: n), count: n)\\n        \\n        for query in queries {\\n            for i in query[0]...query[2] {\\n                for j in query[1]...query[3]  {\\n                    matrix[i][j] += 1\\n                }\\n            }\\n        }\\n        return matrix\\n    }\\n}\\n\\nOptimising swift solution also don\\'t pass"
                    },
                    {
                        "username": "PS07",
                        "content": "[@krashkodes](/krashkodes)  Exactly "
                    },
                    {
                        "username": "krashkodes",
                        "content": "If brute force was meant to be accepted this wouldn\\'t have been marked medium. "
                    },
                    {
                        "username": "ZongyuWu",
                        "content": "Python TLE..."
                    },
                    {
                        "username": "hxu10",
                        "content": "Please add more test cases,  like n=500, q=10000 and all queries are increasing the whole matrix by 1, this will make Java brute force solution not pass. \n\nIf you want brute force pass, you should make all language equal,  not Java can pass but c++ can't,  one should not be punished by the coding language he chosen. "
                    },
                    {
                        "username": "leetcodingm",
                        "content": "hint: think about how you would solve it on an 1D array without running each query separately, i.e how can you accumulate queries"
                    },
                    {
                        "username": "nirala_001",
                        "content": "Java getting AC but in C++ TLE why ?\\nvery sad day for  me !!\\nHappy coding"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "https://leetcode.com/problems/increment-submatrices-by-one/solutions/3053106/brute-force-accepted-in-java-beginner-friendly-space-complexity-explained/"
                    },
                    {
                        "username": "vishalbiet",
                        "content": "yes i also realised this after seeing Brute force Solution written in java gets accepted while c++ gives TLE \\uD83D\\uDE25"
                    },
                    {
                        "username": "sepac",
                        "content": "Not sure how this is a medium..."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "The solution idea was great!! Couldn\\'t break through this by myself"
                    },
                    {
                        "username": "Unikdahal",
                        "content": "Same Solution TLE in C++ Accepted in Java..."
                    },
                    {
                        "username": "bharat_bardiya",
                        "content": "why brute force solution also working ?"
                    },
                    {
                        "username": "goodgoodwish",
                        "content": "My Rust brute force code accepted."
                    },
                    {
                        "username": "akshays274",
                        "content": "    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n\\n        vector<vector<int>> mat(n,vector<int> (n,0));\\n\\n        for(int i=0;i<queries.size();i++)\\n        {\\n            int j = queries[i][0];\\n            int k = queries[i][1];\\n            int count = (queries[i][2]-queries[i][0]+1)*(queries[i][3]-queries[i][1]+1);\\n                \\n            while(count)\\n            {\\n                \\n                mat[j][k]++;\\n\\n                if(queries[i][3] == 0)\\n                {\\n                    j++;\\n                }\\n                else if(k%queries[i][3]!=0 || k==0)\\n                    k++;\\n                else\\n                {\\n                    j++;\\n                    k=queries[i][1];\\n                }\\n                \\n                count--;\\n            }\\n        }\\n        return mat;\\n    }\\n};\\n\\nwhat is wrong with this approach? I tried this optimized approach but it is showing in TLE\\n"
                    }
                ]
            },
            {
                "id": 1759273,
                "content": [
                    {
                        "username": "PS07",
                        "content": "Accepeted in Java but got TLE in C++ & Python !!\n\nJava Brute Force  Solution got accepted\n ```\nclass Solution {\n    public int[][] rangeAddQueries(int n, int[][] queries) {\n    int[][] mat = new int[n][n];\n    for (int[] q : queries) {\n        int row1 = q[0], col1 = q[1], row2 = q[2], col2 = q[3];\n        for (int i = row1; i <= row2; i++) {\n            for (int j = col1; j <= col2; j++) {\n                mat[i][j]++;\n            }\n        }\n    }\n    return mat;\n    }\n}\n```\n\nBut same C++ Solution gets Time Limit Exceeded on TestCase 18\n ```\nclass Solution {\npublic:\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\n        vector<vector<int>> mat(n, vector<int>(n, 0)) ;\n        for (auto &q : queries) {\n            int row1 = q[0], col1 = q[1], row2 = q[2], col2 = q[3];\n            for (int i = row1; i <= row2; i++) {\n                for (int j = col1; j <= col2; j++) {\n                    mat[i][j]++;\n                }\n            }\n        }\n        return mat;\n    }\n};\n```\n\nPlease fix the issue as many participants got penalty because of this issue."
                    },
                    {
                        "username": "krashkodes",
                        "content": "[@Leetcode_A_P_R](/Leetcode_A_P_R)  Look up the concept of Difference Array and Prefix Sum. A good resource for related questions on leetcode is [this](https://leetcode.com/discuss/study-guide/2166045/line-sweep-algorithms)."
                    },
                    {
                        "username": "raiabhinavprakash",
                        "content": "[@krashkodes](/krashkodes) can you please give an idea to solve this in c++. Because brute force is accepted in java"
                    },
                    {
                        "username": "ZheDre1N",
                        "content": "class Solution {\\n    func rangeAddQueries(_ n: Int, _ queries: [[Int]]) -> [[Int]] {\\n        var matrix = Array(repeating: Array(repeating: 0, count: n), count: n)\\n        \\n        for query in queries {\\n            for i in query[0]...query[2] {\\n                for j in query[1]...query[3]  {\\n                    matrix[i][j] += 1\\n                }\\n            }\\n        }\\n        return matrix\\n    }\\n}\\n\\nOptimising swift solution also don\\'t pass"
                    },
                    {
                        "username": "PS07",
                        "content": "[@krashkodes](/krashkodes)  Exactly "
                    },
                    {
                        "username": "krashkodes",
                        "content": "If brute force was meant to be accepted this wouldn\\'t have been marked medium. "
                    },
                    {
                        "username": "ZongyuWu",
                        "content": "Python TLE..."
                    },
                    {
                        "username": "hxu10",
                        "content": "Please add more test cases,  like n=500, q=10000 and all queries are increasing the whole matrix by 1, this will make Java brute force solution not pass. \n\nIf you want brute force pass, you should make all language equal,  not Java can pass but c++ can't,  one should not be punished by the coding language he chosen. "
                    },
                    {
                        "username": "leetcodingm",
                        "content": "hint: think about how you would solve it on an 1D array without running each query separately, i.e how can you accumulate queries"
                    },
                    {
                        "username": "nirala_001",
                        "content": "Java getting AC but in C++ TLE why ?\\nvery sad day for  me !!\\nHappy coding"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "https://leetcode.com/problems/increment-submatrices-by-one/solutions/3053106/brute-force-accepted-in-java-beginner-friendly-space-complexity-explained/"
                    },
                    {
                        "username": "vishalbiet",
                        "content": "yes i also realised this after seeing Brute force Solution written in java gets accepted while c++ gives TLE \\uD83D\\uDE25"
                    },
                    {
                        "username": "sepac",
                        "content": "Not sure how this is a medium..."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "The solution idea was great!! Couldn\\'t break through this by myself"
                    },
                    {
                        "username": "Unikdahal",
                        "content": "Same Solution TLE in C++ Accepted in Java..."
                    },
                    {
                        "username": "bharat_bardiya",
                        "content": "why brute force solution also working ?"
                    },
                    {
                        "username": "goodgoodwish",
                        "content": "My Rust brute force code accepted."
                    },
                    {
                        "username": "akshays274",
                        "content": "    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n\\n        vector<vector<int>> mat(n,vector<int> (n,0));\\n\\n        for(int i=0;i<queries.size();i++)\\n        {\\n            int j = queries[i][0];\\n            int k = queries[i][1];\\n            int count = (queries[i][2]-queries[i][0]+1)*(queries[i][3]-queries[i][1]+1);\\n                \\n            while(count)\\n            {\\n                \\n                mat[j][k]++;\\n\\n                if(queries[i][3] == 0)\\n                {\\n                    j++;\\n                }\\n                else if(k%queries[i][3]!=0 || k==0)\\n                    k++;\\n                else\\n                {\\n                    j++;\\n                    k=queries[i][1];\\n                }\\n                \\n                count--;\\n            }\\n        }\\n        return mat;\\n    }\\n};\\n\\nwhat is wrong with this approach? I tried this optimized approach but it is showing in TLE\\n"
                    }
                ]
            },
            {
                "id": 1758324,
                "content": [
                    {
                        "username": "PS07",
                        "content": "Accepeted in Java but got TLE in C++ & Python !!\n\nJava Brute Force  Solution got accepted\n ```\nclass Solution {\n    public int[][] rangeAddQueries(int n, int[][] queries) {\n    int[][] mat = new int[n][n];\n    for (int[] q : queries) {\n        int row1 = q[0], col1 = q[1], row2 = q[2], col2 = q[3];\n        for (int i = row1; i <= row2; i++) {\n            for (int j = col1; j <= col2; j++) {\n                mat[i][j]++;\n            }\n        }\n    }\n    return mat;\n    }\n}\n```\n\nBut same C++ Solution gets Time Limit Exceeded on TestCase 18\n ```\nclass Solution {\npublic:\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\n        vector<vector<int>> mat(n, vector<int>(n, 0)) ;\n        for (auto &q : queries) {\n            int row1 = q[0], col1 = q[1], row2 = q[2], col2 = q[3];\n            for (int i = row1; i <= row2; i++) {\n                for (int j = col1; j <= col2; j++) {\n                    mat[i][j]++;\n                }\n            }\n        }\n        return mat;\n    }\n};\n```\n\nPlease fix the issue as many participants got penalty because of this issue."
                    },
                    {
                        "username": "krashkodes",
                        "content": "[@Leetcode_A_P_R](/Leetcode_A_P_R)  Look up the concept of Difference Array and Prefix Sum. A good resource for related questions on leetcode is [this](https://leetcode.com/discuss/study-guide/2166045/line-sweep-algorithms)."
                    },
                    {
                        "username": "raiabhinavprakash",
                        "content": "[@krashkodes](/krashkodes) can you please give an idea to solve this in c++. Because brute force is accepted in java"
                    },
                    {
                        "username": "ZheDre1N",
                        "content": "class Solution {\\n    func rangeAddQueries(_ n: Int, _ queries: [[Int]]) -> [[Int]] {\\n        var matrix = Array(repeating: Array(repeating: 0, count: n), count: n)\\n        \\n        for query in queries {\\n            for i in query[0]...query[2] {\\n                for j in query[1]...query[3]  {\\n                    matrix[i][j] += 1\\n                }\\n            }\\n        }\\n        return matrix\\n    }\\n}\\n\\nOptimising swift solution also don\\'t pass"
                    },
                    {
                        "username": "PS07",
                        "content": "[@krashkodes](/krashkodes)  Exactly "
                    },
                    {
                        "username": "krashkodes",
                        "content": "If brute force was meant to be accepted this wouldn\\'t have been marked medium. "
                    },
                    {
                        "username": "ZongyuWu",
                        "content": "Python TLE..."
                    },
                    {
                        "username": "hxu10",
                        "content": "Please add more test cases,  like n=500, q=10000 and all queries are increasing the whole matrix by 1, this will make Java brute force solution not pass. \n\nIf you want brute force pass, you should make all language equal,  not Java can pass but c++ can't,  one should not be punished by the coding language he chosen. "
                    },
                    {
                        "username": "leetcodingm",
                        "content": "hint: think about how you would solve it on an 1D array without running each query separately, i.e how can you accumulate queries"
                    },
                    {
                        "username": "nirala_001",
                        "content": "Java getting AC but in C++ TLE why ?\\nvery sad day for  me !!\\nHappy coding"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "https://leetcode.com/problems/increment-submatrices-by-one/solutions/3053106/brute-force-accepted-in-java-beginner-friendly-space-complexity-explained/"
                    },
                    {
                        "username": "vishalbiet",
                        "content": "yes i also realised this after seeing Brute force Solution written in java gets accepted while c++ gives TLE \\uD83D\\uDE25"
                    },
                    {
                        "username": "sepac",
                        "content": "Not sure how this is a medium..."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "The solution idea was great!! Couldn\\'t break through this by myself"
                    },
                    {
                        "username": "Unikdahal",
                        "content": "Same Solution TLE in C++ Accepted in Java..."
                    },
                    {
                        "username": "bharat_bardiya",
                        "content": "why brute force solution also working ?"
                    },
                    {
                        "username": "goodgoodwish",
                        "content": "My Rust brute force code accepted."
                    },
                    {
                        "username": "akshays274",
                        "content": "    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n\\n        vector<vector<int>> mat(n,vector<int> (n,0));\\n\\n        for(int i=0;i<queries.size();i++)\\n        {\\n            int j = queries[i][0];\\n            int k = queries[i][1];\\n            int count = (queries[i][2]-queries[i][0]+1)*(queries[i][3]-queries[i][1]+1);\\n                \\n            while(count)\\n            {\\n                \\n                mat[j][k]++;\\n\\n                if(queries[i][3] == 0)\\n                {\\n                    j++;\\n                }\\n                else if(k%queries[i][3]!=0 || k==0)\\n                    k++;\\n                else\\n                {\\n                    j++;\\n                    k=queries[i][1];\\n                }\\n                \\n                count--;\\n            }\\n        }\\n        return mat;\\n    }\\n};\\n\\nwhat is wrong with this approach? I tried this optimized approach but it is showing in TLE\\n"
                    }
                ]
            },
            {
                "id": 1758537,
                "content": [
                    {
                        "username": "PS07",
                        "content": "Accepeted in Java but got TLE in C++ & Python !!\n\nJava Brute Force  Solution got accepted\n ```\nclass Solution {\n    public int[][] rangeAddQueries(int n, int[][] queries) {\n    int[][] mat = new int[n][n];\n    for (int[] q : queries) {\n        int row1 = q[0], col1 = q[1], row2 = q[2], col2 = q[3];\n        for (int i = row1; i <= row2; i++) {\n            for (int j = col1; j <= col2; j++) {\n                mat[i][j]++;\n            }\n        }\n    }\n    return mat;\n    }\n}\n```\n\nBut same C++ Solution gets Time Limit Exceeded on TestCase 18\n ```\nclass Solution {\npublic:\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\n        vector<vector<int>> mat(n, vector<int>(n, 0)) ;\n        for (auto &q : queries) {\n            int row1 = q[0], col1 = q[1], row2 = q[2], col2 = q[3];\n            for (int i = row1; i <= row2; i++) {\n                for (int j = col1; j <= col2; j++) {\n                    mat[i][j]++;\n                }\n            }\n        }\n        return mat;\n    }\n};\n```\n\nPlease fix the issue as many participants got penalty because of this issue."
                    },
                    {
                        "username": "krashkodes",
                        "content": "[@Leetcode_A_P_R](/Leetcode_A_P_R)  Look up the concept of Difference Array and Prefix Sum. A good resource for related questions on leetcode is [this](https://leetcode.com/discuss/study-guide/2166045/line-sweep-algorithms)."
                    },
                    {
                        "username": "raiabhinavprakash",
                        "content": "[@krashkodes](/krashkodes) can you please give an idea to solve this in c++. Because brute force is accepted in java"
                    },
                    {
                        "username": "ZheDre1N",
                        "content": "class Solution {\\n    func rangeAddQueries(_ n: Int, _ queries: [[Int]]) -> [[Int]] {\\n        var matrix = Array(repeating: Array(repeating: 0, count: n), count: n)\\n        \\n        for query in queries {\\n            for i in query[0]...query[2] {\\n                for j in query[1]...query[3]  {\\n                    matrix[i][j] += 1\\n                }\\n            }\\n        }\\n        return matrix\\n    }\\n}\\n\\nOptimising swift solution also don\\'t pass"
                    },
                    {
                        "username": "PS07",
                        "content": "[@krashkodes](/krashkodes)  Exactly "
                    },
                    {
                        "username": "krashkodes",
                        "content": "If brute force was meant to be accepted this wouldn\\'t have been marked medium. "
                    },
                    {
                        "username": "ZongyuWu",
                        "content": "Python TLE..."
                    },
                    {
                        "username": "hxu10",
                        "content": "Please add more test cases,  like n=500, q=10000 and all queries are increasing the whole matrix by 1, this will make Java brute force solution not pass. \n\nIf you want brute force pass, you should make all language equal,  not Java can pass but c++ can't,  one should not be punished by the coding language he chosen. "
                    },
                    {
                        "username": "leetcodingm",
                        "content": "hint: think about how you would solve it on an 1D array without running each query separately, i.e how can you accumulate queries"
                    },
                    {
                        "username": "nirala_001",
                        "content": "Java getting AC but in C++ TLE why ?\\nvery sad day for  me !!\\nHappy coding"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "https://leetcode.com/problems/increment-submatrices-by-one/solutions/3053106/brute-force-accepted-in-java-beginner-friendly-space-complexity-explained/"
                    },
                    {
                        "username": "vishalbiet",
                        "content": "yes i also realised this after seeing Brute force Solution written in java gets accepted while c++ gives TLE \\uD83D\\uDE25"
                    },
                    {
                        "username": "sepac",
                        "content": "Not sure how this is a medium..."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "The solution idea was great!! Couldn\\'t break through this by myself"
                    },
                    {
                        "username": "Unikdahal",
                        "content": "Same Solution TLE in C++ Accepted in Java..."
                    },
                    {
                        "username": "bharat_bardiya",
                        "content": "why brute force solution also working ?"
                    },
                    {
                        "username": "goodgoodwish",
                        "content": "My Rust brute force code accepted."
                    },
                    {
                        "username": "akshays274",
                        "content": "    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n\\n        vector<vector<int>> mat(n,vector<int> (n,0));\\n\\n        for(int i=0;i<queries.size();i++)\\n        {\\n            int j = queries[i][0];\\n            int k = queries[i][1];\\n            int count = (queries[i][2]-queries[i][0]+1)*(queries[i][3]-queries[i][1]+1);\\n                \\n            while(count)\\n            {\\n                \\n                mat[j][k]++;\\n\\n                if(queries[i][3] == 0)\\n                {\\n                    j++;\\n                }\\n                else if(k%queries[i][3]!=0 || k==0)\\n                    k++;\\n                else\\n                {\\n                    j++;\\n                    k=queries[i][1];\\n                }\\n                \\n                count--;\\n            }\\n        }\\n        return mat;\\n    }\\n};\\n\\nwhat is wrong with this approach? I tried this optimized approach but it is showing in TLE\\n"
                    }
                ]
            },
            {
                "id": 1762336,
                "content": [
                    {
                        "username": "PS07",
                        "content": "Accepeted in Java but got TLE in C++ & Python !!\n\nJava Brute Force  Solution got accepted\n ```\nclass Solution {\n    public int[][] rangeAddQueries(int n, int[][] queries) {\n    int[][] mat = new int[n][n];\n    for (int[] q : queries) {\n        int row1 = q[0], col1 = q[1], row2 = q[2], col2 = q[3];\n        for (int i = row1; i <= row2; i++) {\n            for (int j = col1; j <= col2; j++) {\n                mat[i][j]++;\n            }\n        }\n    }\n    return mat;\n    }\n}\n```\n\nBut same C++ Solution gets Time Limit Exceeded on TestCase 18\n ```\nclass Solution {\npublic:\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\n        vector<vector<int>> mat(n, vector<int>(n, 0)) ;\n        for (auto &q : queries) {\n            int row1 = q[0], col1 = q[1], row2 = q[2], col2 = q[3];\n            for (int i = row1; i <= row2; i++) {\n                for (int j = col1; j <= col2; j++) {\n                    mat[i][j]++;\n                }\n            }\n        }\n        return mat;\n    }\n};\n```\n\nPlease fix the issue as many participants got penalty because of this issue."
                    },
                    {
                        "username": "krashkodes",
                        "content": "[@Leetcode_A_P_R](/Leetcode_A_P_R)  Look up the concept of Difference Array and Prefix Sum. A good resource for related questions on leetcode is [this](https://leetcode.com/discuss/study-guide/2166045/line-sweep-algorithms)."
                    },
                    {
                        "username": "raiabhinavprakash",
                        "content": "[@krashkodes](/krashkodes) can you please give an idea to solve this in c++. Because brute force is accepted in java"
                    },
                    {
                        "username": "ZheDre1N",
                        "content": "class Solution {\\n    func rangeAddQueries(_ n: Int, _ queries: [[Int]]) -> [[Int]] {\\n        var matrix = Array(repeating: Array(repeating: 0, count: n), count: n)\\n        \\n        for query in queries {\\n            for i in query[0]...query[2] {\\n                for j in query[1]...query[3]  {\\n                    matrix[i][j] += 1\\n                }\\n            }\\n        }\\n        return matrix\\n    }\\n}\\n\\nOptimising swift solution also don\\'t pass"
                    },
                    {
                        "username": "PS07",
                        "content": "[@krashkodes](/krashkodes)  Exactly "
                    },
                    {
                        "username": "krashkodes",
                        "content": "If brute force was meant to be accepted this wouldn\\'t have been marked medium. "
                    },
                    {
                        "username": "ZongyuWu",
                        "content": "Python TLE..."
                    },
                    {
                        "username": "hxu10",
                        "content": "Please add more test cases,  like n=500, q=10000 and all queries are increasing the whole matrix by 1, this will make Java brute force solution not pass. \n\nIf you want brute force pass, you should make all language equal,  not Java can pass but c++ can't,  one should not be punished by the coding language he chosen. "
                    },
                    {
                        "username": "leetcodingm",
                        "content": "hint: think about how you would solve it on an 1D array without running each query separately, i.e how can you accumulate queries"
                    },
                    {
                        "username": "nirala_001",
                        "content": "Java getting AC but in C++ TLE why ?\\nvery sad day for  me !!\\nHappy coding"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "https://leetcode.com/problems/increment-submatrices-by-one/solutions/3053106/brute-force-accepted-in-java-beginner-friendly-space-complexity-explained/"
                    },
                    {
                        "username": "vishalbiet",
                        "content": "yes i also realised this after seeing Brute force Solution written in java gets accepted while c++ gives TLE \\uD83D\\uDE25"
                    },
                    {
                        "username": "sepac",
                        "content": "Not sure how this is a medium..."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "The solution idea was great!! Couldn\\'t break through this by myself"
                    },
                    {
                        "username": "Unikdahal",
                        "content": "Same Solution TLE in C++ Accepted in Java..."
                    },
                    {
                        "username": "bharat_bardiya",
                        "content": "why brute force solution also working ?"
                    },
                    {
                        "username": "goodgoodwish",
                        "content": "My Rust brute force code accepted."
                    },
                    {
                        "username": "akshays274",
                        "content": "    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n\\n        vector<vector<int>> mat(n,vector<int> (n,0));\\n\\n        for(int i=0;i<queries.size();i++)\\n        {\\n            int j = queries[i][0];\\n            int k = queries[i][1];\\n            int count = (queries[i][2]-queries[i][0]+1)*(queries[i][3]-queries[i][1]+1);\\n                \\n            while(count)\\n            {\\n                \\n                mat[j][k]++;\\n\\n                if(queries[i][3] == 0)\\n                {\\n                    j++;\\n                }\\n                else if(k%queries[i][3]!=0 || k==0)\\n                    k++;\\n                else\\n                {\\n                    j++;\\n                    k=queries[i][1];\\n                }\\n                \\n                count--;\\n            }\\n        }\\n        return mat;\\n    }\\n};\\n\\nwhat is wrong with this approach? I tried this optimized approach but it is showing in TLE\\n"
                    }
                ]
            },
            {
                "id": 1758421,
                "content": [
                    {
                        "username": "PS07",
                        "content": "Accepeted in Java but got TLE in C++ & Python !!\n\nJava Brute Force  Solution got accepted\n ```\nclass Solution {\n    public int[][] rangeAddQueries(int n, int[][] queries) {\n    int[][] mat = new int[n][n];\n    for (int[] q : queries) {\n        int row1 = q[0], col1 = q[1], row2 = q[2], col2 = q[3];\n        for (int i = row1; i <= row2; i++) {\n            for (int j = col1; j <= col2; j++) {\n                mat[i][j]++;\n            }\n        }\n    }\n    return mat;\n    }\n}\n```\n\nBut same C++ Solution gets Time Limit Exceeded on TestCase 18\n ```\nclass Solution {\npublic:\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\n        vector<vector<int>> mat(n, vector<int>(n, 0)) ;\n        for (auto &q : queries) {\n            int row1 = q[0], col1 = q[1], row2 = q[2], col2 = q[3];\n            for (int i = row1; i <= row2; i++) {\n                for (int j = col1; j <= col2; j++) {\n                    mat[i][j]++;\n                }\n            }\n        }\n        return mat;\n    }\n};\n```\n\nPlease fix the issue as many participants got penalty because of this issue."
                    },
                    {
                        "username": "krashkodes",
                        "content": "[@Leetcode_A_P_R](/Leetcode_A_P_R)  Look up the concept of Difference Array and Prefix Sum. A good resource for related questions on leetcode is [this](https://leetcode.com/discuss/study-guide/2166045/line-sweep-algorithms)."
                    },
                    {
                        "username": "raiabhinavprakash",
                        "content": "[@krashkodes](/krashkodes) can you please give an idea to solve this in c++. Because brute force is accepted in java"
                    },
                    {
                        "username": "ZheDre1N",
                        "content": "class Solution {\\n    func rangeAddQueries(_ n: Int, _ queries: [[Int]]) -> [[Int]] {\\n        var matrix = Array(repeating: Array(repeating: 0, count: n), count: n)\\n        \\n        for query in queries {\\n            for i in query[0]...query[2] {\\n                for j in query[1]...query[3]  {\\n                    matrix[i][j] += 1\\n                }\\n            }\\n        }\\n        return matrix\\n    }\\n}\\n\\nOptimising swift solution also don\\'t pass"
                    },
                    {
                        "username": "PS07",
                        "content": "[@krashkodes](/krashkodes)  Exactly "
                    },
                    {
                        "username": "krashkodes",
                        "content": "If brute force was meant to be accepted this wouldn\\'t have been marked medium. "
                    },
                    {
                        "username": "ZongyuWu",
                        "content": "Python TLE..."
                    },
                    {
                        "username": "hxu10",
                        "content": "Please add more test cases,  like n=500, q=10000 and all queries are increasing the whole matrix by 1, this will make Java brute force solution not pass. \n\nIf you want brute force pass, you should make all language equal,  not Java can pass but c++ can't,  one should not be punished by the coding language he chosen. "
                    },
                    {
                        "username": "leetcodingm",
                        "content": "hint: think about how you would solve it on an 1D array without running each query separately, i.e how can you accumulate queries"
                    },
                    {
                        "username": "nirala_001",
                        "content": "Java getting AC but in C++ TLE why ?\\nvery sad day for  me !!\\nHappy coding"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "https://leetcode.com/problems/increment-submatrices-by-one/solutions/3053106/brute-force-accepted-in-java-beginner-friendly-space-complexity-explained/"
                    },
                    {
                        "username": "vishalbiet",
                        "content": "yes i also realised this after seeing Brute force Solution written in java gets accepted while c++ gives TLE \\uD83D\\uDE25"
                    },
                    {
                        "username": "sepac",
                        "content": "Not sure how this is a medium..."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "The solution idea was great!! Couldn\\'t break through this by myself"
                    },
                    {
                        "username": "Unikdahal",
                        "content": "Same Solution TLE in C++ Accepted in Java..."
                    },
                    {
                        "username": "bharat_bardiya",
                        "content": "why brute force solution also working ?"
                    },
                    {
                        "username": "goodgoodwish",
                        "content": "My Rust brute force code accepted."
                    },
                    {
                        "username": "akshays274",
                        "content": "    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n\\n        vector<vector<int>> mat(n,vector<int> (n,0));\\n\\n        for(int i=0;i<queries.size();i++)\\n        {\\n            int j = queries[i][0];\\n            int k = queries[i][1];\\n            int count = (queries[i][2]-queries[i][0]+1)*(queries[i][3]-queries[i][1]+1);\\n                \\n            while(count)\\n            {\\n                \\n                mat[j][k]++;\\n\\n                if(queries[i][3] == 0)\\n                {\\n                    j++;\\n                }\\n                else if(k%queries[i][3]!=0 || k==0)\\n                    k++;\\n                else\\n                {\\n                    j++;\\n                    k=queries[i][1];\\n                }\\n                \\n                count--;\\n            }\\n        }\\n        return mat;\\n    }\\n};\\n\\nwhat is wrong with this approach? I tried this optimized approach but it is showing in TLE\\n"
                    }
                ]
            },
            {
                "id": 1758313,
                "content": [
                    {
                        "username": "PS07",
                        "content": "Accepeted in Java but got TLE in C++ & Python !!\n\nJava Brute Force  Solution got accepted\n ```\nclass Solution {\n    public int[][] rangeAddQueries(int n, int[][] queries) {\n    int[][] mat = new int[n][n];\n    for (int[] q : queries) {\n        int row1 = q[0], col1 = q[1], row2 = q[2], col2 = q[3];\n        for (int i = row1; i <= row2; i++) {\n            for (int j = col1; j <= col2; j++) {\n                mat[i][j]++;\n            }\n        }\n    }\n    return mat;\n    }\n}\n```\n\nBut same C++ Solution gets Time Limit Exceeded on TestCase 18\n ```\nclass Solution {\npublic:\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\n        vector<vector<int>> mat(n, vector<int>(n, 0)) ;\n        for (auto &q : queries) {\n            int row1 = q[0], col1 = q[1], row2 = q[2], col2 = q[3];\n            for (int i = row1; i <= row2; i++) {\n                for (int j = col1; j <= col2; j++) {\n                    mat[i][j]++;\n                }\n            }\n        }\n        return mat;\n    }\n};\n```\n\nPlease fix the issue as many participants got penalty because of this issue."
                    },
                    {
                        "username": "krashkodes",
                        "content": "[@Leetcode_A_P_R](/Leetcode_A_P_R)  Look up the concept of Difference Array and Prefix Sum. A good resource for related questions on leetcode is [this](https://leetcode.com/discuss/study-guide/2166045/line-sweep-algorithms)."
                    },
                    {
                        "username": "raiabhinavprakash",
                        "content": "[@krashkodes](/krashkodes) can you please give an idea to solve this in c++. Because brute force is accepted in java"
                    },
                    {
                        "username": "ZheDre1N",
                        "content": "class Solution {\\n    func rangeAddQueries(_ n: Int, _ queries: [[Int]]) -> [[Int]] {\\n        var matrix = Array(repeating: Array(repeating: 0, count: n), count: n)\\n        \\n        for query in queries {\\n            for i in query[0]...query[2] {\\n                for j in query[1]...query[3]  {\\n                    matrix[i][j] += 1\\n                }\\n            }\\n        }\\n        return matrix\\n    }\\n}\\n\\nOptimising swift solution also don\\'t pass"
                    },
                    {
                        "username": "PS07",
                        "content": "[@krashkodes](/krashkodes)  Exactly "
                    },
                    {
                        "username": "krashkodes",
                        "content": "If brute force was meant to be accepted this wouldn\\'t have been marked medium. "
                    },
                    {
                        "username": "ZongyuWu",
                        "content": "Python TLE..."
                    },
                    {
                        "username": "hxu10",
                        "content": "Please add more test cases,  like n=500, q=10000 and all queries are increasing the whole matrix by 1, this will make Java brute force solution not pass. \n\nIf you want brute force pass, you should make all language equal,  not Java can pass but c++ can't,  one should not be punished by the coding language he chosen. "
                    },
                    {
                        "username": "leetcodingm",
                        "content": "hint: think about how you would solve it on an 1D array without running each query separately, i.e how can you accumulate queries"
                    },
                    {
                        "username": "nirala_001",
                        "content": "Java getting AC but in C++ TLE why ?\\nvery sad day for  me !!\\nHappy coding"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "https://leetcode.com/problems/increment-submatrices-by-one/solutions/3053106/brute-force-accepted-in-java-beginner-friendly-space-complexity-explained/"
                    },
                    {
                        "username": "vishalbiet",
                        "content": "yes i also realised this after seeing Brute force Solution written in java gets accepted while c++ gives TLE \\uD83D\\uDE25"
                    },
                    {
                        "username": "sepac",
                        "content": "Not sure how this is a medium..."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "The solution idea was great!! Couldn\\'t break through this by myself"
                    },
                    {
                        "username": "Unikdahal",
                        "content": "Same Solution TLE in C++ Accepted in Java..."
                    },
                    {
                        "username": "bharat_bardiya",
                        "content": "why brute force solution also working ?"
                    },
                    {
                        "username": "goodgoodwish",
                        "content": "My Rust brute force code accepted."
                    },
                    {
                        "username": "akshays274",
                        "content": "    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n\\n        vector<vector<int>> mat(n,vector<int> (n,0));\\n\\n        for(int i=0;i<queries.size();i++)\\n        {\\n            int j = queries[i][0];\\n            int k = queries[i][1];\\n            int count = (queries[i][2]-queries[i][0]+1)*(queries[i][3]-queries[i][1]+1);\\n                \\n            while(count)\\n            {\\n                \\n                mat[j][k]++;\\n\\n                if(queries[i][3] == 0)\\n                {\\n                    j++;\\n                }\\n                else if(k%queries[i][3]!=0 || k==0)\\n                    k++;\\n                else\\n                {\\n                    j++;\\n                    k=queries[i][1];\\n                }\\n                \\n                count--;\\n            }\\n        }\\n        return mat;\\n    }\\n};\\n\\nwhat is wrong with this approach? I tried this optimized approach but it is showing in TLE\\n"
                    }
                ]
            },
            {
                "id": 1759510,
                "content": [
                    {
                        "username": "PS07",
                        "content": "Accepeted in Java but got TLE in C++ & Python !!\n\nJava Brute Force  Solution got accepted\n ```\nclass Solution {\n    public int[][] rangeAddQueries(int n, int[][] queries) {\n    int[][] mat = new int[n][n];\n    for (int[] q : queries) {\n        int row1 = q[0], col1 = q[1], row2 = q[2], col2 = q[3];\n        for (int i = row1; i <= row2; i++) {\n            for (int j = col1; j <= col2; j++) {\n                mat[i][j]++;\n            }\n        }\n    }\n    return mat;\n    }\n}\n```\n\nBut same C++ Solution gets Time Limit Exceeded on TestCase 18\n ```\nclass Solution {\npublic:\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\n        vector<vector<int>> mat(n, vector<int>(n, 0)) ;\n        for (auto &q : queries) {\n            int row1 = q[0], col1 = q[1], row2 = q[2], col2 = q[3];\n            for (int i = row1; i <= row2; i++) {\n                for (int j = col1; j <= col2; j++) {\n                    mat[i][j]++;\n                }\n            }\n        }\n        return mat;\n    }\n};\n```\n\nPlease fix the issue as many participants got penalty because of this issue."
                    },
                    {
                        "username": "krashkodes",
                        "content": "[@Leetcode_A_P_R](/Leetcode_A_P_R)  Look up the concept of Difference Array and Prefix Sum. A good resource for related questions on leetcode is [this](https://leetcode.com/discuss/study-guide/2166045/line-sweep-algorithms)."
                    },
                    {
                        "username": "raiabhinavprakash",
                        "content": "[@krashkodes](/krashkodes) can you please give an idea to solve this in c++. Because brute force is accepted in java"
                    },
                    {
                        "username": "ZheDre1N",
                        "content": "class Solution {\\n    func rangeAddQueries(_ n: Int, _ queries: [[Int]]) -> [[Int]] {\\n        var matrix = Array(repeating: Array(repeating: 0, count: n), count: n)\\n        \\n        for query in queries {\\n            for i in query[0]...query[2] {\\n                for j in query[1]...query[3]  {\\n                    matrix[i][j] += 1\\n                }\\n            }\\n        }\\n        return matrix\\n    }\\n}\\n\\nOptimising swift solution also don\\'t pass"
                    },
                    {
                        "username": "PS07",
                        "content": "[@krashkodes](/krashkodes)  Exactly "
                    },
                    {
                        "username": "krashkodes",
                        "content": "If brute force was meant to be accepted this wouldn\\'t have been marked medium. "
                    },
                    {
                        "username": "ZongyuWu",
                        "content": "Python TLE..."
                    },
                    {
                        "username": "hxu10",
                        "content": "Please add more test cases,  like n=500, q=10000 and all queries are increasing the whole matrix by 1, this will make Java brute force solution not pass. \n\nIf you want brute force pass, you should make all language equal,  not Java can pass but c++ can't,  one should not be punished by the coding language he chosen. "
                    },
                    {
                        "username": "leetcodingm",
                        "content": "hint: think about how you would solve it on an 1D array without running each query separately, i.e how can you accumulate queries"
                    },
                    {
                        "username": "nirala_001",
                        "content": "Java getting AC but in C++ TLE why ?\\nvery sad day for  me !!\\nHappy coding"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "https://leetcode.com/problems/increment-submatrices-by-one/solutions/3053106/brute-force-accepted-in-java-beginner-friendly-space-complexity-explained/"
                    },
                    {
                        "username": "vishalbiet",
                        "content": "yes i also realised this after seeing Brute force Solution written in java gets accepted while c++ gives TLE \\uD83D\\uDE25"
                    },
                    {
                        "username": "sepac",
                        "content": "Not sure how this is a medium..."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "The solution idea was great!! Couldn\\'t break through this by myself"
                    },
                    {
                        "username": "Unikdahal",
                        "content": "Same Solution TLE in C++ Accepted in Java..."
                    },
                    {
                        "username": "bharat_bardiya",
                        "content": "why brute force solution also working ?"
                    },
                    {
                        "username": "goodgoodwish",
                        "content": "My Rust brute force code accepted."
                    },
                    {
                        "username": "akshays274",
                        "content": "    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n\\n        vector<vector<int>> mat(n,vector<int> (n,0));\\n\\n        for(int i=0;i<queries.size();i++)\\n        {\\n            int j = queries[i][0];\\n            int k = queries[i][1];\\n            int count = (queries[i][2]-queries[i][0]+1)*(queries[i][3]-queries[i][1]+1);\\n                \\n            while(count)\\n            {\\n                \\n                mat[j][k]++;\\n\\n                if(queries[i][3] == 0)\\n                {\\n                    j++;\\n                }\\n                else if(k%queries[i][3]!=0 || k==0)\\n                    k++;\\n                else\\n                {\\n                    j++;\\n                    k=queries[i][1];\\n                }\\n                \\n                count--;\\n            }\\n        }\\n        return mat;\\n    }\\n};\\n\\nwhat is wrong with this approach? I tried this optimized approach but it is showing in TLE\\n"
                    }
                ]
            },
            {
                "id": 1758759,
                "content": [
                    {
                        "username": "PS07",
                        "content": "Accepeted in Java but got TLE in C++ & Python !!\n\nJava Brute Force  Solution got accepted\n ```\nclass Solution {\n    public int[][] rangeAddQueries(int n, int[][] queries) {\n    int[][] mat = new int[n][n];\n    for (int[] q : queries) {\n        int row1 = q[0], col1 = q[1], row2 = q[2], col2 = q[3];\n        for (int i = row1; i <= row2; i++) {\n            for (int j = col1; j <= col2; j++) {\n                mat[i][j]++;\n            }\n        }\n    }\n    return mat;\n    }\n}\n```\n\nBut same C++ Solution gets Time Limit Exceeded on TestCase 18\n ```\nclass Solution {\npublic:\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\n        vector<vector<int>> mat(n, vector<int>(n, 0)) ;\n        for (auto &q : queries) {\n            int row1 = q[0], col1 = q[1], row2 = q[2], col2 = q[3];\n            for (int i = row1; i <= row2; i++) {\n                for (int j = col1; j <= col2; j++) {\n                    mat[i][j]++;\n                }\n            }\n        }\n        return mat;\n    }\n};\n```\n\nPlease fix the issue as many participants got penalty because of this issue."
                    },
                    {
                        "username": "krashkodes",
                        "content": "[@Leetcode_A_P_R](/Leetcode_A_P_R)  Look up the concept of Difference Array and Prefix Sum. A good resource for related questions on leetcode is [this](https://leetcode.com/discuss/study-guide/2166045/line-sweep-algorithms)."
                    },
                    {
                        "username": "raiabhinavprakash",
                        "content": "[@krashkodes](/krashkodes) can you please give an idea to solve this in c++. Because brute force is accepted in java"
                    },
                    {
                        "username": "ZheDre1N",
                        "content": "class Solution {\\n    func rangeAddQueries(_ n: Int, _ queries: [[Int]]) -> [[Int]] {\\n        var matrix = Array(repeating: Array(repeating: 0, count: n), count: n)\\n        \\n        for query in queries {\\n            for i in query[0]...query[2] {\\n                for j in query[1]...query[3]  {\\n                    matrix[i][j] += 1\\n                }\\n            }\\n        }\\n        return matrix\\n    }\\n}\\n\\nOptimising swift solution also don\\'t pass"
                    },
                    {
                        "username": "PS07",
                        "content": "[@krashkodes](/krashkodes)  Exactly "
                    },
                    {
                        "username": "krashkodes",
                        "content": "If brute force was meant to be accepted this wouldn\\'t have been marked medium. "
                    },
                    {
                        "username": "ZongyuWu",
                        "content": "Python TLE..."
                    },
                    {
                        "username": "hxu10",
                        "content": "Please add more test cases,  like n=500, q=10000 and all queries are increasing the whole matrix by 1, this will make Java brute force solution not pass. \n\nIf you want brute force pass, you should make all language equal,  not Java can pass but c++ can't,  one should not be punished by the coding language he chosen. "
                    },
                    {
                        "username": "leetcodingm",
                        "content": "hint: think about how you would solve it on an 1D array without running each query separately, i.e how can you accumulate queries"
                    },
                    {
                        "username": "nirala_001",
                        "content": "Java getting AC but in C++ TLE why ?\\nvery sad day for  me !!\\nHappy coding"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "https://leetcode.com/problems/increment-submatrices-by-one/solutions/3053106/brute-force-accepted-in-java-beginner-friendly-space-complexity-explained/"
                    },
                    {
                        "username": "vishalbiet",
                        "content": "yes i also realised this after seeing Brute force Solution written in java gets accepted while c++ gives TLE \\uD83D\\uDE25"
                    },
                    {
                        "username": "sepac",
                        "content": "Not sure how this is a medium..."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "The solution idea was great!! Couldn\\'t break through this by myself"
                    },
                    {
                        "username": "Unikdahal",
                        "content": "Same Solution TLE in C++ Accepted in Java..."
                    },
                    {
                        "username": "bharat_bardiya",
                        "content": "why brute force solution also working ?"
                    },
                    {
                        "username": "goodgoodwish",
                        "content": "My Rust brute force code accepted."
                    },
                    {
                        "username": "akshays274",
                        "content": "    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n\\n        vector<vector<int>> mat(n,vector<int> (n,0));\\n\\n        for(int i=0;i<queries.size();i++)\\n        {\\n            int j = queries[i][0];\\n            int k = queries[i][1];\\n            int count = (queries[i][2]-queries[i][0]+1)*(queries[i][3]-queries[i][1]+1);\\n                \\n            while(count)\\n            {\\n                \\n                mat[j][k]++;\\n\\n                if(queries[i][3] == 0)\\n                {\\n                    j++;\\n                }\\n                else if(k%queries[i][3]!=0 || k==0)\\n                    k++;\\n                else\\n                {\\n                    j++;\\n                    k=queries[i][1];\\n                }\\n                \\n                count--;\\n            }\\n        }\\n        return mat;\\n    }\\n};\\n\\nwhat is wrong with this approach? I tried this optimized approach but it is showing in TLE\\n"
                    }
                ]
            },
            {
                "id": 1758431,
                "content": [
                    {
                        "username": "PS07",
                        "content": "Accepeted in Java but got TLE in C++ & Python !!\n\nJava Brute Force  Solution got accepted\n ```\nclass Solution {\n    public int[][] rangeAddQueries(int n, int[][] queries) {\n    int[][] mat = new int[n][n];\n    for (int[] q : queries) {\n        int row1 = q[0], col1 = q[1], row2 = q[2], col2 = q[3];\n        for (int i = row1; i <= row2; i++) {\n            for (int j = col1; j <= col2; j++) {\n                mat[i][j]++;\n            }\n        }\n    }\n    return mat;\n    }\n}\n```\n\nBut same C++ Solution gets Time Limit Exceeded on TestCase 18\n ```\nclass Solution {\npublic:\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\n        vector<vector<int>> mat(n, vector<int>(n, 0)) ;\n        for (auto &q : queries) {\n            int row1 = q[0], col1 = q[1], row2 = q[2], col2 = q[3];\n            for (int i = row1; i <= row2; i++) {\n                for (int j = col1; j <= col2; j++) {\n                    mat[i][j]++;\n                }\n            }\n        }\n        return mat;\n    }\n};\n```\n\nPlease fix the issue as many participants got penalty because of this issue."
                    },
                    {
                        "username": "krashkodes",
                        "content": "[@Leetcode_A_P_R](/Leetcode_A_P_R)  Look up the concept of Difference Array and Prefix Sum. A good resource for related questions on leetcode is [this](https://leetcode.com/discuss/study-guide/2166045/line-sweep-algorithms)."
                    },
                    {
                        "username": "raiabhinavprakash",
                        "content": "[@krashkodes](/krashkodes) can you please give an idea to solve this in c++. Because brute force is accepted in java"
                    },
                    {
                        "username": "ZheDre1N",
                        "content": "class Solution {\\n    func rangeAddQueries(_ n: Int, _ queries: [[Int]]) -> [[Int]] {\\n        var matrix = Array(repeating: Array(repeating: 0, count: n), count: n)\\n        \\n        for query in queries {\\n            for i in query[0]...query[2] {\\n                for j in query[1]...query[3]  {\\n                    matrix[i][j] += 1\\n                }\\n            }\\n        }\\n        return matrix\\n    }\\n}\\n\\nOptimising swift solution also don\\'t pass"
                    },
                    {
                        "username": "PS07",
                        "content": "[@krashkodes](/krashkodes)  Exactly "
                    },
                    {
                        "username": "krashkodes",
                        "content": "If brute force was meant to be accepted this wouldn\\'t have been marked medium. "
                    },
                    {
                        "username": "ZongyuWu",
                        "content": "Python TLE..."
                    },
                    {
                        "username": "hxu10",
                        "content": "Please add more test cases,  like n=500, q=10000 and all queries are increasing the whole matrix by 1, this will make Java brute force solution not pass. \n\nIf you want brute force pass, you should make all language equal,  not Java can pass but c++ can't,  one should not be punished by the coding language he chosen. "
                    },
                    {
                        "username": "leetcodingm",
                        "content": "hint: think about how you would solve it on an 1D array without running each query separately, i.e how can you accumulate queries"
                    },
                    {
                        "username": "nirala_001",
                        "content": "Java getting AC but in C++ TLE why ?\\nvery sad day for  me !!\\nHappy coding"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "https://leetcode.com/problems/increment-submatrices-by-one/solutions/3053106/brute-force-accepted-in-java-beginner-friendly-space-complexity-explained/"
                    },
                    {
                        "username": "vishalbiet",
                        "content": "yes i also realised this after seeing Brute force Solution written in java gets accepted while c++ gives TLE \\uD83D\\uDE25"
                    },
                    {
                        "username": "sepac",
                        "content": "Not sure how this is a medium..."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "The solution idea was great!! Couldn\\'t break through this by myself"
                    },
                    {
                        "username": "Unikdahal",
                        "content": "Same Solution TLE in C++ Accepted in Java..."
                    },
                    {
                        "username": "bharat_bardiya",
                        "content": "why brute force solution also working ?"
                    },
                    {
                        "username": "goodgoodwish",
                        "content": "My Rust brute force code accepted."
                    },
                    {
                        "username": "akshays274",
                        "content": "    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n\\n        vector<vector<int>> mat(n,vector<int> (n,0));\\n\\n        for(int i=0;i<queries.size();i++)\\n        {\\n            int j = queries[i][0];\\n            int k = queries[i][1];\\n            int count = (queries[i][2]-queries[i][0]+1)*(queries[i][3]-queries[i][1]+1);\\n                \\n            while(count)\\n            {\\n                \\n                mat[j][k]++;\\n\\n                if(queries[i][3] == 0)\\n                {\\n                    j++;\\n                }\\n                else if(k%queries[i][3]!=0 || k==0)\\n                    k++;\\n                else\\n                {\\n                    j++;\\n                    k=queries[i][1];\\n                }\\n                \\n                count--;\\n            }\\n        }\\n        return mat;\\n    }\\n};\\n\\nwhat is wrong with this approach? I tried this optimized approach but it is showing in TLE\\n"
                    }
                ]
            },
            {
                "id": 1759507,
                "content": [
                    {
                        "username": "PS07",
                        "content": "Accepeted in Java but got TLE in C++ & Python !!\n\nJava Brute Force  Solution got accepted\n ```\nclass Solution {\n    public int[][] rangeAddQueries(int n, int[][] queries) {\n    int[][] mat = new int[n][n];\n    for (int[] q : queries) {\n        int row1 = q[0], col1 = q[1], row2 = q[2], col2 = q[3];\n        for (int i = row1; i <= row2; i++) {\n            for (int j = col1; j <= col2; j++) {\n                mat[i][j]++;\n            }\n        }\n    }\n    return mat;\n    }\n}\n```\n\nBut same C++ Solution gets Time Limit Exceeded on TestCase 18\n ```\nclass Solution {\npublic:\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\n        vector<vector<int>> mat(n, vector<int>(n, 0)) ;\n        for (auto &q : queries) {\n            int row1 = q[0], col1 = q[1], row2 = q[2], col2 = q[3];\n            for (int i = row1; i <= row2; i++) {\n                for (int j = col1; j <= col2; j++) {\n                    mat[i][j]++;\n                }\n            }\n        }\n        return mat;\n    }\n};\n```\n\nPlease fix the issue as many participants got penalty because of this issue."
                    },
                    {
                        "username": "krashkodes",
                        "content": "[@Leetcode_A_P_R](/Leetcode_A_P_R)  Look up the concept of Difference Array and Prefix Sum. A good resource for related questions on leetcode is [this](https://leetcode.com/discuss/study-guide/2166045/line-sweep-algorithms)."
                    },
                    {
                        "username": "raiabhinavprakash",
                        "content": "[@krashkodes](/krashkodes) can you please give an idea to solve this in c++. Because brute force is accepted in java"
                    },
                    {
                        "username": "ZheDre1N",
                        "content": "class Solution {\\n    func rangeAddQueries(_ n: Int, _ queries: [[Int]]) -> [[Int]] {\\n        var matrix = Array(repeating: Array(repeating: 0, count: n), count: n)\\n        \\n        for query in queries {\\n            for i in query[0]...query[2] {\\n                for j in query[1]...query[3]  {\\n                    matrix[i][j] += 1\\n                }\\n            }\\n        }\\n        return matrix\\n    }\\n}\\n\\nOptimising swift solution also don\\'t pass"
                    },
                    {
                        "username": "PS07",
                        "content": "[@krashkodes](/krashkodes)  Exactly "
                    },
                    {
                        "username": "krashkodes",
                        "content": "If brute force was meant to be accepted this wouldn\\'t have been marked medium. "
                    },
                    {
                        "username": "ZongyuWu",
                        "content": "Python TLE..."
                    },
                    {
                        "username": "hxu10",
                        "content": "Please add more test cases,  like n=500, q=10000 and all queries are increasing the whole matrix by 1, this will make Java brute force solution not pass. \n\nIf you want brute force pass, you should make all language equal,  not Java can pass but c++ can't,  one should not be punished by the coding language he chosen. "
                    },
                    {
                        "username": "leetcodingm",
                        "content": "hint: think about how you would solve it on an 1D array without running each query separately, i.e how can you accumulate queries"
                    },
                    {
                        "username": "nirala_001",
                        "content": "Java getting AC but in C++ TLE why ?\\nvery sad day for  me !!\\nHappy coding"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "https://leetcode.com/problems/increment-submatrices-by-one/solutions/3053106/brute-force-accepted-in-java-beginner-friendly-space-complexity-explained/"
                    },
                    {
                        "username": "vishalbiet",
                        "content": "yes i also realised this after seeing Brute force Solution written in java gets accepted while c++ gives TLE \\uD83D\\uDE25"
                    },
                    {
                        "username": "sepac",
                        "content": "Not sure how this is a medium..."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "The solution idea was great!! Couldn\\'t break through this by myself"
                    },
                    {
                        "username": "Unikdahal",
                        "content": "Same Solution TLE in C++ Accepted in Java..."
                    },
                    {
                        "username": "bharat_bardiya",
                        "content": "why brute force solution also working ?"
                    },
                    {
                        "username": "goodgoodwish",
                        "content": "My Rust brute force code accepted."
                    },
                    {
                        "username": "akshays274",
                        "content": "    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n\\n        vector<vector<int>> mat(n,vector<int> (n,0));\\n\\n        for(int i=0;i<queries.size();i++)\\n        {\\n            int j = queries[i][0];\\n            int k = queries[i][1];\\n            int count = (queries[i][2]-queries[i][0]+1)*(queries[i][3]-queries[i][1]+1);\\n                \\n            while(count)\\n            {\\n                \\n                mat[j][k]++;\\n\\n                if(queries[i][3] == 0)\\n                {\\n                    j++;\\n                }\\n                else if(k%queries[i][3]!=0 || k==0)\\n                    k++;\\n                else\\n                {\\n                    j++;\\n                    k=queries[i][1];\\n                }\\n                \\n                count--;\\n            }\\n        }\\n        return mat;\\n    }\\n};\\n\\nwhat is wrong with this approach? I tried this optimized approach but it is showing in TLE\\n"
                    }
                ]
            },
            {
                "id": 1759273,
                "content": [
                    {
                        "username": "PS07",
                        "content": "Accepeted in Java but got TLE in C++ & Python !!\n\nJava Brute Force  Solution got accepted\n ```\nclass Solution {\n    public int[][] rangeAddQueries(int n, int[][] queries) {\n    int[][] mat = new int[n][n];\n    for (int[] q : queries) {\n        int row1 = q[0], col1 = q[1], row2 = q[2], col2 = q[3];\n        for (int i = row1; i <= row2; i++) {\n            for (int j = col1; j <= col2; j++) {\n                mat[i][j]++;\n            }\n        }\n    }\n    return mat;\n    }\n}\n```\n\nBut same C++ Solution gets Time Limit Exceeded on TestCase 18\n ```\nclass Solution {\npublic:\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\n        vector<vector<int>> mat(n, vector<int>(n, 0)) ;\n        for (auto &q : queries) {\n            int row1 = q[0], col1 = q[1], row2 = q[2], col2 = q[3];\n            for (int i = row1; i <= row2; i++) {\n                for (int j = col1; j <= col2; j++) {\n                    mat[i][j]++;\n                }\n            }\n        }\n        return mat;\n    }\n};\n```\n\nPlease fix the issue as many participants got penalty because of this issue."
                    },
                    {
                        "username": "krashkodes",
                        "content": "[@Leetcode_A_P_R](/Leetcode_A_P_R)  Look up the concept of Difference Array and Prefix Sum. A good resource for related questions on leetcode is [this](https://leetcode.com/discuss/study-guide/2166045/line-sweep-algorithms)."
                    },
                    {
                        "username": "raiabhinavprakash",
                        "content": "[@krashkodes](/krashkodes) can you please give an idea to solve this in c++. Because brute force is accepted in java"
                    },
                    {
                        "username": "ZheDre1N",
                        "content": "class Solution {\\n    func rangeAddQueries(_ n: Int, _ queries: [[Int]]) -> [[Int]] {\\n        var matrix = Array(repeating: Array(repeating: 0, count: n), count: n)\\n        \\n        for query in queries {\\n            for i in query[0]...query[2] {\\n                for j in query[1]...query[3]  {\\n                    matrix[i][j] += 1\\n                }\\n            }\\n        }\\n        return matrix\\n    }\\n}\\n\\nOptimising swift solution also don\\'t pass"
                    },
                    {
                        "username": "PS07",
                        "content": "[@krashkodes](/krashkodes)  Exactly "
                    },
                    {
                        "username": "krashkodes",
                        "content": "If brute force was meant to be accepted this wouldn\\'t have been marked medium. "
                    },
                    {
                        "username": "ZongyuWu",
                        "content": "Python TLE..."
                    },
                    {
                        "username": "hxu10",
                        "content": "Please add more test cases,  like n=500, q=10000 and all queries are increasing the whole matrix by 1, this will make Java brute force solution not pass. \n\nIf you want brute force pass, you should make all language equal,  not Java can pass but c++ can't,  one should not be punished by the coding language he chosen. "
                    },
                    {
                        "username": "leetcodingm",
                        "content": "hint: think about how you would solve it on an 1D array without running each query separately, i.e how can you accumulate queries"
                    },
                    {
                        "username": "nirala_001",
                        "content": "Java getting AC but in C++ TLE why ?\\nvery sad day for  me !!\\nHappy coding"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "https://leetcode.com/problems/increment-submatrices-by-one/solutions/3053106/brute-force-accepted-in-java-beginner-friendly-space-complexity-explained/"
                    },
                    {
                        "username": "vishalbiet",
                        "content": "yes i also realised this after seeing Brute force Solution written in java gets accepted while c++ gives TLE \\uD83D\\uDE25"
                    },
                    {
                        "username": "sepac",
                        "content": "Not sure how this is a medium..."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "The solution idea was great!! Couldn\\'t break through this by myself"
                    },
                    {
                        "username": "Unikdahal",
                        "content": "Same Solution TLE in C++ Accepted in Java..."
                    },
                    {
                        "username": "bharat_bardiya",
                        "content": "why brute force solution also working ?"
                    },
                    {
                        "username": "goodgoodwish",
                        "content": "My Rust brute force code accepted."
                    },
                    {
                        "username": "akshays274",
                        "content": "    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n\\n        vector<vector<int>> mat(n,vector<int> (n,0));\\n\\n        for(int i=0;i<queries.size();i++)\\n        {\\n            int j = queries[i][0];\\n            int k = queries[i][1];\\n            int count = (queries[i][2]-queries[i][0]+1)*(queries[i][3]-queries[i][1]+1);\\n                \\n            while(count)\\n            {\\n                \\n                mat[j][k]++;\\n\\n                if(queries[i][3] == 0)\\n                {\\n                    j++;\\n                }\\n                else if(k%queries[i][3]!=0 || k==0)\\n                    k++;\\n                else\\n                {\\n                    j++;\\n                    k=queries[i][1];\\n                }\\n                \\n                count--;\\n            }\\n        }\\n        return mat;\\n    }\\n};\\n\\nwhat is wrong with this approach? I tried this optimized approach but it is showing in TLE\\n"
                    }
                ]
            },
            {
                "id": 1758324,
                "content": [
                    {
                        "username": "PS07",
                        "content": "Accepeted in Java but got TLE in C++ & Python !!\n\nJava Brute Force  Solution got accepted\n ```\nclass Solution {\n    public int[][] rangeAddQueries(int n, int[][] queries) {\n    int[][] mat = new int[n][n];\n    for (int[] q : queries) {\n        int row1 = q[0], col1 = q[1], row2 = q[2], col2 = q[3];\n        for (int i = row1; i <= row2; i++) {\n            for (int j = col1; j <= col2; j++) {\n                mat[i][j]++;\n            }\n        }\n    }\n    return mat;\n    }\n}\n```\n\nBut same C++ Solution gets Time Limit Exceeded on TestCase 18\n ```\nclass Solution {\npublic:\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\n        vector<vector<int>> mat(n, vector<int>(n, 0)) ;\n        for (auto &q : queries) {\n            int row1 = q[0], col1 = q[1], row2 = q[2], col2 = q[3];\n            for (int i = row1; i <= row2; i++) {\n                for (int j = col1; j <= col2; j++) {\n                    mat[i][j]++;\n                }\n            }\n        }\n        return mat;\n    }\n};\n```\n\nPlease fix the issue as many participants got penalty because of this issue."
                    },
                    {
                        "username": "krashkodes",
                        "content": "[@Leetcode_A_P_R](/Leetcode_A_P_R)  Look up the concept of Difference Array and Prefix Sum. A good resource for related questions on leetcode is [this](https://leetcode.com/discuss/study-guide/2166045/line-sweep-algorithms)."
                    },
                    {
                        "username": "raiabhinavprakash",
                        "content": "[@krashkodes](/krashkodes) can you please give an idea to solve this in c++. Because brute force is accepted in java"
                    },
                    {
                        "username": "ZheDre1N",
                        "content": "class Solution {\\n    func rangeAddQueries(_ n: Int, _ queries: [[Int]]) -> [[Int]] {\\n        var matrix = Array(repeating: Array(repeating: 0, count: n), count: n)\\n        \\n        for query in queries {\\n            for i in query[0]...query[2] {\\n                for j in query[1]...query[3]  {\\n                    matrix[i][j] += 1\\n                }\\n            }\\n        }\\n        return matrix\\n    }\\n}\\n\\nOptimising swift solution also don\\'t pass"
                    },
                    {
                        "username": "PS07",
                        "content": "[@krashkodes](/krashkodes)  Exactly "
                    },
                    {
                        "username": "krashkodes",
                        "content": "If brute force was meant to be accepted this wouldn\\'t have been marked medium. "
                    },
                    {
                        "username": "ZongyuWu",
                        "content": "Python TLE..."
                    },
                    {
                        "username": "hxu10",
                        "content": "Please add more test cases,  like n=500, q=10000 and all queries are increasing the whole matrix by 1, this will make Java brute force solution not pass. \n\nIf you want brute force pass, you should make all language equal,  not Java can pass but c++ can't,  one should not be punished by the coding language he chosen. "
                    },
                    {
                        "username": "leetcodingm",
                        "content": "hint: think about how you would solve it on an 1D array without running each query separately, i.e how can you accumulate queries"
                    },
                    {
                        "username": "nirala_001",
                        "content": "Java getting AC but in C++ TLE why ?\\nvery sad day for  me !!\\nHappy coding"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "https://leetcode.com/problems/increment-submatrices-by-one/solutions/3053106/brute-force-accepted-in-java-beginner-friendly-space-complexity-explained/"
                    },
                    {
                        "username": "vishalbiet",
                        "content": "yes i also realised this after seeing Brute force Solution written in java gets accepted while c++ gives TLE \\uD83D\\uDE25"
                    },
                    {
                        "username": "sepac",
                        "content": "Not sure how this is a medium..."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "The solution idea was great!! Couldn\\'t break through this by myself"
                    },
                    {
                        "username": "Unikdahal",
                        "content": "Same Solution TLE in C++ Accepted in Java..."
                    },
                    {
                        "username": "bharat_bardiya",
                        "content": "why brute force solution also working ?"
                    },
                    {
                        "username": "goodgoodwish",
                        "content": "My Rust brute force code accepted."
                    },
                    {
                        "username": "akshays274",
                        "content": "    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n\\n        vector<vector<int>> mat(n,vector<int> (n,0));\\n\\n        for(int i=0;i<queries.size();i++)\\n        {\\n            int j = queries[i][0];\\n            int k = queries[i][1];\\n            int count = (queries[i][2]-queries[i][0]+1)*(queries[i][3]-queries[i][1]+1);\\n                \\n            while(count)\\n            {\\n                \\n                mat[j][k]++;\\n\\n                if(queries[i][3] == 0)\\n                {\\n                    j++;\\n                }\\n                else if(k%queries[i][3]!=0 || k==0)\\n                    k++;\\n                else\\n                {\\n                    j++;\\n                    k=queries[i][1];\\n                }\\n                \\n                count--;\\n            }\\n        }\\n        return mat;\\n    }\\n};\\n\\nwhat is wrong with this approach? I tried this optimized approach but it is showing in TLE\\n"
                    }
                ]
            },
            {
                "id": 1758537,
                "content": [
                    {
                        "username": "PS07",
                        "content": "Accepeted in Java but got TLE in C++ & Python !!\n\nJava Brute Force  Solution got accepted\n ```\nclass Solution {\n    public int[][] rangeAddQueries(int n, int[][] queries) {\n    int[][] mat = new int[n][n];\n    for (int[] q : queries) {\n        int row1 = q[0], col1 = q[1], row2 = q[2], col2 = q[3];\n        for (int i = row1; i <= row2; i++) {\n            for (int j = col1; j <= col2; j++) {\n                mat[i][j]++;\n            }\n        }\n    }\n    return mat;\n    }\n}\n```\n\nBut same C++ Solution gets Time Limit Exceeded on TestCase 18\n ```\nclass Solution {\npublic:\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\n        vector<vector<int>> mat(n, vector<int>(n, 0)) ;\n        for (auto &q : queries) {\n            int row1 = q[0], col1 = q[1], row2 = q[2], col2 = q[3];\n            for (int i = row1; i <= row2; i++) {\n                for (int j = col1; j <= col2; j++) {\n                    mat[i][j]++;\n                }\n            }\n        }\n        return mat;\n    }\n};\n```\n\nPlease fix the issue as many participants got penalty because of this issue."
                    },
                    {
                        "username": "krashkodes",
                        "content": "[@Leetcode_A_P_R](/Leetcode_A_P_R)  Look up the concept of Difference Array and Prefix Sum. A good resource for related questions on leetcode is [this](https://leetcode.com/discuss/study-guide/2166045/line-sweep-algorithms)."
                    },
                    {
                        "username": "raiabhinavprakash",
                        "content": "[@krashkodes](/krashkodes) can you please give an idea to solve this in c++. Because brute force is accepted in java"
                    },
                    {
                        "username": "ZheDre1N",
                        "content": "class Solution {\\n    func rangeAddQueries(_ n: Int, _ queries: [[Int]]) -> [[Int]] {\\n        var matrix = Array(repeating: Array(repeating: 0, count: n), count: n)\\n        \\n        for query in queries {\\n            for i in query[0]...query[2] {\\n                for j in query[1]...query[3]  {\\n                    matrix[i][j] += 1\\n                }\\n            }\\n        }\\n        return matrix\\n    }\\n}\\n\\nOptimising swift solution also don\\'t pass"
                    },
                    {
                        "username": "PS07",
                        "content": "[@krashkodes](/krashkodes)  Exactly "
                    },
                    {
                        "username": "krashkodes",
                        "content": "If brute force was meant to be accepted this wouldn\\'t have been marked medium. "
                    },
                    {
                        "username": "ZongyuWu",
                        "content": "Python TLE..."
                    },
                    {
                        "username": "hxu10",
                        "content": "Please add more test cases,  like n=500, q=10000 and all queries are increasing the whole matrix by 1, this will make Java brute force solution not pass. \n\nIf you want brute force pass, you should make all language equal,  not Java can pass but c++ can't,  one should not be punished by the coding language he chosen. "
                    },
                    {
                        "username": "leetcodingm",
                        "content": "hint: think about how you would solve it on an 1D array without running each query separately, i.e how can you accumulate queries"
                    },
                    {
                        "username": "nirala_001",
                        "content": "Java getting AC but in C++ TLE why ?\\nvery sad day for  me !!\\nHappy coding"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "https://leetcode.com/problems/increment-submatrices-by-one/solutions/3053106/brute-force-accepted-in-java-beginner-friendly-space-complexity-explained/"
                    },
                    {
                        "username": "vishalbiet",
                        "content": "yes i also realised this after seeing Brute force Solution written in java gets accepted while c++ gives TLE \\uD83D\\uDE25"
                    },
                    {
                        "username": "sepac",
                        "content": "Not sure how this is a medium..."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "The solution idea was great!! Couldn\\'t break through this by myself"
                    },
                    {
                        "username": "Unikdahal",
                        "content": "Same Solution TLE in C++ Accepted in Java..."
                    },
                    {
                        "username": "bharat_bardiya",
                        "content": "why brute force solution also working ?"
                    },
                    {
                        "username": "goodgoodwish",
                        "content": "My Rust brute force code accepted."
                    },
                    {
                        "username": "akshays274",
                        "content": "    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n\\n        vector<vector<int>> mat(n,vector<int> (n,0));\\n\\n        for(int i=0;i<queries.size();i++)\\n        {\\n            int j = queries[i][0];\\n            int k = queries[i][1];\\n            int count = (queries[i][2]-queries[i][0]+1)*(queries[i][3]-queries[i][1]+1);\\n                \\n            while(count)\\n            {\\n                \\n                mat[j][k]++;\\n\\n                if(queries[i][3] == 0)\\n                {\\n                    j++;\\n                }\\n                else if(k%queries[i][3]!=0 || k==0)\\n                    k++;\\n                else\\n                {\\n                    j++;\\n                    k=queries[i][1];\\n                }\\n                \\n                count--;\\n            }\\n        }\\n        return mat;\\n    }\\n};\\n\\nwhat is wrong with this approach? I tried this optimized approach but it is showing in TLE\\n"
                    }
                ]
            },
            {
                "id": 1762336,
                "content": [
                    {
                        "username": "PS07",
                        "content": "Accepeted in Java but got TLE in C++ & Python !!\n\nJava Brute Force  Solution got accepted\n ```\nclass Solution {\n    public int[][] rangeAddQueries(int n, int[][] queries) {\n    int[][] mat = new int[n][n];\n    for (int[] q : queries) {\n        int row1 = q[0], col1 = q[1], row2 = q[2], col2 = q[3];\n        for (int i = row1; i <= row2; i++) {\n            for (int j = col1; j <= col2; j++) {\n                mat[i][j]++;\n            }\n        }\n    }\n    return mat;\n    }\n}\n```\n\nBut same C++ Solution gets Time Limit Exceeded on TestCase 18\n ```\nclass Solution {\npublic:\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\n        vector<vector<int>> mat(n, vector<int>(n, 0)) ;\n        for (auto &q : queries) {\n            int row1 = q[0], col1 = q[1], row2 = q[2], col2 = q[3];\n            for (int i = row1; i <= row2; i++) {\n                for (int j = col1; j <= col2; j++) {\n                    mat[i][j]++;\n                }\n            }\n        }\n        return mat;\n    }\n};\n```\n\nPlease fix the issue as many participants got penalty because of this issue."
                    },
                    {
                        "username": "krashkodes",
                        "content": "[@Leetcode_A_P_R](/Leetcode_A_P_R)  Look up the concept of Difference Array and Prefix Sum. A good resource for related questions on leetcode is [this](https://leetcode.com/discuss/study-guide/2166045/line-sweep-algorithms)."
                    },
                    {
                        "username": "raiabhinavprakash",
                        "content": "[@krashkodes](/krashkodes) can you please give an idea to solve this in c++. Because brute force is accepted in java"
                    },
                    {
                        "username": "ZheDre1N",
                        "content": "class Solution {\\n    func rangeAddQueries(_ n: Int, _ queries: [[Int]]) -> [[Int]] {\\n        var matrix = Array(repeating: Array(repeating: 0, count: n), count: n)\\n        \\n        for query in queries {\\n            for i in query[0]...query[2] {\\n                for j in query[1]...query[3]  {\\n                    matrix[i][j] += 1\\n                }\\n            }\\n        }\\n        return matrix\\n    }\\n}\\n\\nOptimising swift solution also don\\'t pass"
                    },
                    {
                        "username": "PS07",
                        "content": "[@krashkodes](/krashkodes)  Exactly "
                    },
                    {
                        "username": "krashkodes",
                        "content": "If brute force was meant to be accepted this wouldn\\'t have been marked medium. "
                    },
                    {
                        "username": "ZongyuWu",
                        "content": "Python TLE..."
                    },
                    {
                        "username": "hxu10",
                        "content": "Please add more test cases,  like n=500, q=10000 and all queries are increasing the whole matrix by 1, this will make Java brute force solution not pass. \n\nIf you want brute force pass, you should make all language equal,  not Java can pass but c++ can't,  one should not be punished by the coding language he chosen. "
                    },
                    {
                        "username": "leetcodingm",
                        "content": "hint: think about how you would solve it on an 1D array without running each query separately, i.e how can you accumulate queries"
                    },
                    {
                        "username": "nirala_001",
                        "content": "Java getting AC but in C++ TLE why ?\\nvery sad day for  me !!\\nHappy coding"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "https://leetcode.com/problems/increment-submatrices-by-one/solutions/3053106/brute-force-accepted-in-java-beginner-friendly-space-complexity-explained/"
                    },
                    {
                        "username": "vishalbiet",
                        "content": "yes i also realised this after seeing Brute force Solution written in java gets accepted while c++ gives TLE \\uD83D\\uDE25"
                    },
                    {
                        "username": "sepac",
                        "content": "Not sure how this is a medium..."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "The solution idea was great!! Couldn\\'t break through this by myself"
                    },
                    {
                        "username": "Unikdahal",
                        "content": "Same Solution TLE in C++ Accepted in Java..."
                    },
                    {
                        "username": "bharat_bardiya",
                        "content": "why brute force solution also working ?"
                    },
                    {
                        "username": "goodgoodwish",
                        "content": "My Rust brute force code accepted."
                    },
                    {
                        "username": "akshays274",
                        "content": "    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\\n\\n        vector<vector<int>> mat(n,vector<int> (n,0));\\n\\n        for(int i=0;i<queries.size();i++)\\n        {\\n            int j = queries[i][0];\\n            int k = queries[i][1];\\n            int count = (queries[i][2]-queries[i][0]+1)*(queries[i][3]-queries[i][1]+1);\\n                \\n            while(count)\\n            {\\n                \\n                mat[j][k]++;\\n\\n                if(queries[i][3] == 0)\\n                {\\n                    j++;\\n                }\\n                else if(k%queries[i][3]!=0 || k==0)\\n                    k++;\\n                else\\n                {\\n                    j++;\\n                    k=queries[i][1];\\n                }\\n                \\n                count--;\\n            }\\n        }\\n        return mat;\\n    }\\n};\\n\\nwhat is wrong with this approach? I tried this optimized approach but it is showing in TLE\\n"
                    }
                ]
            }
        ]
    }
]