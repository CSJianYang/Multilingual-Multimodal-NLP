[
    {
        "title": "Design Graph With Shortest Path Calculator",
        "question_content": "There is a directed weighted graph that consists of n nodes numbered from 0 to n - 1. The edges of the graph are initially represented by the given array edges where edges[i] = [fromi, toi, edgeCosti] meaning that there is an edge from fromi to toi with the cost edgeCosti.\nImplement the Graph class:\n\n\tGraph(int n, int[][] edges) initializes the object with n nodes and the given edges.\n\taddEdge(int[] edge) adds an edge to the list of edges where edge = [from, to, edgeCost]. It is guaranteed that there is no edge between the two nodes before adding this one.\n\tint shortestPath(int node1, int node2) returns the minimum cost of a path from node1 to node2. If no path exists, return -1. The cost of a path is the sum of the costs of the edges in the path.\n\n&nbsp;\nExample 1:\n\nInput\n[\"Graph\", \"shortestPath\", \"shortestPath\", \"addEdge\", \"shortestPath\"]\n[[4, [[0, 2, 5], [0, 1, 2], [1, 2, 1], [3, 0, 3]]], [3, 2], [0, 3], [[1, 3, 4]], [0, 3]]\nOutput\n[null, 6, -1, null, 6]\nExplanation\nGraph g = new Graph(4, [[0, 2, 5], [0, 1, 2], [1, 2, 1], [3, 0, 3]]);\ng.shortestPath(3, 2); // return 6. The shortest path from 3 to 2 in the first diagram above is 3 -> 0 -> 1 -> 2 with a total cost of 3 + 2 + 1 = 6.\ng.shortestPath(0, 3); // return -1. There is no path from 0 to 3.\ng.addEdge([1, 3, 4]); // We add an edge from node 1 to node 3, and we get the second diagram above.\ng.shortestPath(0, 3); // return 6. The shortest path from 0 to 3 now is 0 -> 1 -> 3 with a total cost of 2 + 4 = 6.\n\n&nbsp;\nConstraints:\n\n\t1 <= n <= 100\n\t0 <= edges.length <= n * (n - 1)\n\tedges[i].length == edge.length == 3\n\t0 <= fromi, toi, from, to, node1, node2 <= n - 1\n\t1 <= edgeCosti, edgeCost <= 106\n\tThere are no repeated edges and no self-loops in the graph at any point.\n\tAt most 100 calls will be made for addEdge.\n\tAt most 100 calls will be made for shortestPath.",
        "solutions": [
            {
                "id": 3419976,
                "title": "c-java-python3-simple-dijkstra",
                "content": "\\n# Intuition\\nDijkstra can be used to find the minimum distance between nodes\\n\\n# Approach\\nStore edges in an adjacency matrix and perform diskstra each time shortestPath method is called\\n\\n# Complexity\\n- Time complexity: O(Elog(V)) (Dijkstra)\\n\\n- Space complexity: O(E + V)\\n\\n# Code\\n**Python3**:\\n```\\ndef __init__(self, n: int, edges: List[List[int]]):\\n    self.adj_list = [[] for _ in range(n)]\\n    for a, b, cost in edges:\\n        self.adj_list[a].append((b, cost))\\n\\ndef addEdge(self, edge: List[int]) -> None:\\n    a, b, cost = edge\\n    self.adj_list[a].append((b, cost))\\n\\ndef shortestPath(self, node1: int, node2: int) -> int:\\n    n, pq = len(self.adj_list), [(0, node1)]\\n    dist = [inf] * (n)\\n    dist[node1] = 0\\n\\n    while pq:\\n        d, node = heappop(pq)\\n        if node == node2: return d\\n        if d > dist[node]: continue\\n        for neighbor, cost in self.adj_list[node]:\\n            new_dist = d + cost\\n            if new_dist < dist[neighbor]:\\n                dist[neighbor] = new_dist\\n                heappush(pq, (new_dist, neighbor))\\n    return -1\\n```\\n\\n**C++**:\\n```\\nvector<vector<pair<int, int>>> adj_list;\\nGraph(int n, vector<vector<int>>& edges) {\\n    adj_list.resize(n);\\n    for (auto& e: edges)\\n        adj_list[e[0]].push_back(make_pair(e[1], e[2]));\\n}\\n\\nvoid addEdge(vector<int> e) {\\n    adj_list[e[0]].push_back(make_pair(e[1], e[2]));\\n}\\n\\nint shortestPath(int node1, int node2) {\\n    int n = adj_list.size();\\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\\n    vector<int> dist(n, INT_MAX);\\n    dist[node1] = 0;\\n    pq.push(make_pair(0, node1));\\n    \\n    while (!pq.empty()) {\\n        int d = pq.top().first, node = pq.top().second; pq.pop();\\n        if (node == node2) return d;\\n        if (d > dist[node]) continue;\\n        for (auto& neighbor : adj_list[node]) {\\n            int new_dist = d + neighbor.second;\\n            if (new_dist < dist[neighbor.first]) {\\n                dist[neighbor.first] = new_dist;\\n                pq.push(make_pair(new_dist, neighbor.first));\\n            }\\n        }\\n    }\\n    return -1;\\n}\\n```\\n\\n**Java**:\\n```\\nList<List<Pair<Integer, Integer>>> adj_list;\\npublic Graph(int n, int[][] edges) {\\n    adj_list = new ArrayList<>();\\n    for (int i = 0; i < n; i++)\\n        adj_list.add(new ArrayList<>());\\n    for (int[] e : edges)\\n        adj_list.get(e[0]).add(new Pair<>(e[1], e[2]));\\n}\\n\\npublic void addEdge(int[] e) {\\n    adj_list.get(e[0]).add(new Pair<>(e[1], e[2]));\\n}\\n\\npublic int shortestPath(int node1, int node2) {\\n    int n = adj_list.size();\\n    PriorityQueue<Pair<Integer, Integer>> pq = new PriorityQueue<>(Comparator.comparingInt(p -> p.getKey()));\\n    int[] dist = new int[n];\\n    Arrays.fill(dist, Integer.MAX_VALUE);\\n    dist[node1] = 0;\\n    pq.offer(new Pair<>(0, node1));\\n\\n    while (!pq.isEmpty()) {\\n        var pair = pq.poll();\\n        int d = pair.getKey(), node = pair.getValue();\\n        if (node == node2) return d;\\n        if (d > dist[node]) continue;\\n        for (Pair<Integer, Integer> neighbor : adj_list.get(node)) {\\n            int new_dist = d + neighbor.getValue();\\n            if (new_dist < dist[neighbor.getKey()]) {\\n                dist[neighbor.getKey()] = new_dist;\\n                pq.offer(new Pair<>(new_dist, neighbor.getKey()));\\n            }\\n        }\\n    }\\n    return -1;\\n}\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef __init__(self, n: int, edges: List[List[int]]):\\n    self.adj_list = [[] for _ in range(n)]\\n    for a, b, cost in edges:\\n        self.adj_list[a].append((b, cost))\\n\\ndef addEdge(self, edge: List[int]) -> None:\\n    a, b, cost = edge\\n    self.adj_list[a].append((b, cost))\\n\\ndef shortestPath(self, node1: int, node2: int) -> int:\\n    n, pq = len(self.adj_list), [(0, node1)]\\n    dist = [inf] * (n)\\n    dist[node1] = 0\\n\\n    while pq:\\n        d, node = heappop(pq)\\n        if node == node2: return d\\n        if d > dist[node]: continue\\n        for neighbor, cost in self.adj_list[node]:\\n            new_dist = d + cost\\n            if new_dist < dist[neighbor]:\\n                dist[neighbor] = new_dist\\n                heappush(pq, (new_dist, neighbor))\\n    return -1\\n```\n```\\nvector<vector<pair<int, int>>> adj_list;\\nGraph(int n, vector<vector<int>>& edges) {\\n    adj_list.resize(n);\\n    for (auto& e: edges)\\n        adj_list[e[0]].push_back(make_pair(e[1], e[2]));\\n}\\n\\nvoid addEdge(vector<int> e) {\\n    adj_list[e[0]].push_back(make_pair(e[1], e[2]));\\n}\\n\\nint shortestPath(int node1, int node2) {\\n    int n = adj_list.size();\\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\\n    vector<int> dist(n, INT_MAX);\\n    dist[node1] = 0;\\n    pq.push(make_pair(0, node1));\\n    \\n    while (!pq.empty()) {\\n        int d = pq.top().first, node = pq.top().second; pq.pop();\\n        if (node == node2) return d;\\n        if (d > dist[node]) continue;\\n        for (auto& neighbor : adj_list[node]) {\\n            int new_dist = d + neighbor.second;\\n            if (new_dist < dist[neighbor.first]) {\\n                dist[neighbor.first] = new_dist;\\n                pq.push(make_pair(new_dist, neighbor.first));\\n            }\\n        }\\n    }\\n    return -1;\\n}\\n```\n```\\nList<List<Pair<Integer, Integer>>> adj_list;\\npublic Graph(int n, int[][] edges) {\\n    adj_list = new ArrayList<>();\\n    for (int i = 0; i < n; i++)\\n        adj_list.add(new ArrayList<>());\\n    for (int[] e : edges)\\n        adj_list.get(e[0]).add(new Pair<>(e[1], e[2]));\\n}\\n\\npublic void addEdge(int[] e) {\\n    adj_list.get(e[0]).add(new Pair<>(e[1], e[2]));\\n}\\n\\npublic int shortestPath(int node1, int node2) {\\n    int n = adj_list.size();\\n    PriorityQueue<Pair<Integer, Integer>> pq = new PriorityQueue<>(Comparator.comparingInt(p -> p.getKey()));\\n    int[] dist = new int[n];\\n    Arrays.fill(dist, Integer.MAX_VALUE);\\n    dist[node1] = 0;\\n    pq.offer(new Pair<>(0, node1));\\n\\n    while (!pq.isEmpty()) {\\n        var pair = pq.poll();\\n        int d = pair.getKey(), node = pair.getValue();\\n        if (node == node2) return d;\\n        if (d > dist[node]) continue;\\n        for (Pair<Integer, Integer> neighbor : adj_list.get(node)) {\\n            int new_dist = d + neighbor.getValue();\\n            if (new_dist < dist[neighbor.getKey()]) {\\n                dist[neighbor.getKey()] = new_dist;\\n                pq.offer(new Pair<>(new_dist, neighbor.getKey()));\\n            }\\n        }\\n    }\\n    return -1;\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3420159,
                "title": "dijkstra-vs-floyd-warshall",
                "content": "> My account (votrubac) was banned due to the contest rules violation... Not sure if LeetCode got hacked or someting.\\n\\nWe could pre-compute all-pairs shortest paths in O(n ^ 3) using the Floyd\\u2013Warshall algorithm. There are algorithms that are a bit faster (but more complex).\\n\\nI am not aware, however, of a fast incremental version of the all-pairs shortest paths algorithm. For Floyd\\u2013Warshall it would take O(n ^ 2) to recompute, and we need to do for each `addEdge` call.\\n\\nSince we are limited to 100 `addEdge` and 100 `shortestPath` calls, we can just do Dijkstra instead - O(n ^ 2) for every `shortestPath` call. If the number of updates is much smaller than the number of queries - then Floyd\\u2013Warshall would be a better choice.\\n\\n## Dijkstra\\n**C++**\\n```cpp\\nclass Graph {\\npublic:\\n    vector<vector<array<int, 2>>> al;\\n    Graph(int n, vector<vector<int>>& edges) {\\n        al.resize(n);\\n        for (auto &e : edges)\\n            al[e[0]].push_back({e[1], e[2]});\\n    }\\n    void addEdge(const vector<int> &e) {\\n        al[e[0]].push_back({e[1], e[2]});\\n    }\\n    int shortestPath(int node1, int node2) {\\n        priority_queue<array<int, 2>, vector<array<int, 2>>, greater<>> pq;\\n        vector<int> cost(al.size(), INT_MAX);\\n        cost[node1] = 0;\\n        pq.push({0, node1});\\n        while (!pq.empty() && pq.top()[1] != node2) {\\n            auto [cost_i, i] = pq.top(); pq.pop();\\n            if (cost_i != cost[i])\\n                continue;\\n            for(auto [j, cost_j] : al[i])\\n                if (cost_i + cost_j < cost[j]) {\\n                    cost[j] = cost_i + cost_j;\\n                    pq.push({cost[j], j});\\n                }\\n        }\\n        return cost[node2] == INT_MAX ? -1 : cost[node2];\\n    }\\n};\\n```\\n\\n## Floyd\\u2013Warshall\\n**C++**\\n```cpp\\nclass Graph {\\npublic:\\n    vector<vector<int>> am;\\n    Graph(int n, vector<vector<int>>& edges) {\\n        am = vector<vector<int>>(n, vector<int>(n, 1e9));\\n        for (auto &e : edges)\\n            am[e[0]][e[1]] = e[2];\\n        for (int i = 0; i < n; ++i)\\n            am[i][i] = 0;\\n        for (int k = 0; k < n; ++k)\\n            for (int i = 0; i < n; ++i)\\n                for (int j = 0; j < n; ++j)\\n                    am[i][j] = min(am[i][j], am[i][k] + am[k][j]);\\n    }\\n    void addEdge(const vector<int> &e) {\\n        for (int i = 0; i < am.size(); ++i)\\n            for (int j = 0; j < am.size(); ++j)\\n                am[i][j] = min(am[i][j], am[i][e[0]] + am[e[1]][j] + e[2]);\\n    }\\n    int shortestPath(int n1, int n2) {\\n        return am[n1][n2] == 1e9 ? -1 : am[n1][n2];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nclass Graph {\\npublic:\\n    vector<vector<array<int, 2>>> al;\\n    Graph(int n, vector<vector<int>>& edges) {\\n        al.resize(n);\\n        for (auto &e : edges)\\n            al[e[0]].push_back({e[1], e[2]});\\n    }\\n    void addEdge(const vector<int> &e) {\\n        al[e[0]].push_back({e[1], e[2]});\\n    }\\n    int shortestPath(int node1, int node2) {\\n        priority_queue<array<int, 2>, vector<array<int, 2>>, greater<>> pq;\\n        vector<int> cost(al.size(), INT_MAX);\\n        cost[node1] = 0;\\n        pq.push({0, node1});\\n        while (!pq.empty() && pq.top()[1] != node2) {\\n            auto [cost_i, i] = pq.top(); pq.pop();\\n            if (cost_i != cost[i])\\n                continue;\\n            for(auto [j, cost_j] : al[i])\\n                if (cost_i + cost_j < cost[j]) {\\n                    cost[j] = cost_i + cost_j;\\n                    pq.push({cost[j], j});\\n                }\\n        }\\n        return cost[node2] == INT_MAX ? -1 : cost[node2];\\n    }\\n};\\n```\n```cpp\\nclass Graph {\\npublic:\\n    vector<vector<int>> am;\\n    Graph(int n, vector<vector<int>>& edges) {\\n        am = vector<vector<int>>(n, vector<int>(n, 1e9));\\n        for (auto &e : edges)\\n            am[e[0]][e[1]] = e[2];\\n        for (int i = 0; i < n; ++i)\\n            am[i][i] = 0;\\n        for (int k = 0; k < n; ++k)\\n            for (int i = 0; i < n; ++i)\\n                for (int j = 0; j < n; ++j)\\n                    am[i][j] = min(am[i][j], am[i][k] + am[k][j]);\\n    }\\n    void addEdge(const vector<int> &e) {\\n        for (int i = 0; i < am.size(); ++i)\\n            for (int j = 0; j < am.size(); ++j)\\n                am[i][j] = min(am[i][j], am[i][e[0]] + am[e[1]][j] + e[2]);\\n    }\\n    int shortestPath(int n1, int n2) {\\n        return am[n1][n2] == 1e9 ? -1 : am[n1][n2];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420035,
                "title": "simple-bfs-with-cost-very-simple-easy-to-understand-solution",
                "content": "<b> Please Up Vote if you like the solution\\n```\\n/*\\n1. Calculating the shortest path using bfs.\\n2. While doing so just need to keep tracking of the cost of the node from the source in vis array.\\n3. Traverse to the node, only if moving to this will reduce the cost.\\n*/\\n\\n\\nclass Graph {\\npublic:\\n    vector<vector<pair<int,int>>> g;\\n    \\n    Graph(int n, vector<vector<int>>& edges) {\\n        g.resize(n);\\n        for(auto e: edges)  g[e[0]].push_back({e[1], e[2]});\\n    }\\n    \\n    void addEdge(vector<int> e) { g[e[0]].push_back({e[1], e[2]}); }\\n    \\n    int shortestPath(int node1, int node2) {\\n        if(node1 == node2) return 0;\\n        int ans = INT_MAX;\\n        vector<int> vis(g.size(), INT_MAX);\\n        queue<pair<int,int>> q; q.push({node1, 0});\\n        while(!q.empty()){\\n            auto p = q.front(); q.pop();\\n            for(auto node: g[p.first]){\\n                int newCost = node.second + p.second;\\n                if(node.first == node2 ) ans = min(ans, newCost );\\n                if(vis[node.first] >= newCost){ \\n                    vis[node.first] = newCost; \\n                    q.push({node.first, newCost}); \\n                }\\n            }\\n        }\\n        return (ans == INT_MAX)?-1:ans;\\n    }\\n};\\n\\n```\\nHere is an article of my recent interview experience - A Journey to FAANG Company, I recomand you to go through this to know which all resources I have used & how I cracked interview at Amazon:\\nhttps://leetcode.com/discuss/interview-experience/3171859/Journey-to-a-FAANG-Company-Amazon-or-SDE2-(L5)-or-Bangalore-or-Oct-2022-Accepted",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/*\\n1. Calculating the shortest path using bfs.\\n2. While doing so just need to keep tracking of the cost of the node from the source in vis array.\\n3. Traverse to the node, only if moving to this will reduce the cost.\\n*/\\n\\n\\nclass Graph {\\npublic:\\n    vector<vector<pair<int,int>>> g;\\n    \\n    Graph(int n, vector<vector<int>>& edges) {\\n        g.resize(n);\\n        for(auto e: edges)  g[e[0]].push_back({e[1], e[2]});\\n    }\\n    \\n    void addEdge(vector<int> e) { g[e[0]].push_back({e[1], e[2]}); }\\n    \\n    int shortestPath(int node1, int node2) {\\n        if(node1 == node2) return 0;\\n        int ans = INT_MAX;\\n        vector<int> vis(g.size(), INT_MAX);\\n        queue<pair<int,int>> q; q.push({node1, 0});\\n        while(!q.empty()){\\n            auto p = q.front(); q.pop();\\n            for(auto node: g[p.first]){\\n                int newCost = node.second + p.second;\\n                if(node.first == node2 ) ans = min(ans, newCost );\\n                if(vis[node.first] >= newCost){ \\n                    vis[node.first] = newCost; \\n                    q.push({node.first, newCost}); \\n                }\\n            }\\n        }\\n        return (ans == INT_MAX)?-1:ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420250,
                "title": "legendary-floyd-warshall-algorithm",
                "content": "# Complexity\\n- Time complexity: n^3 -> init || n^2 -> add_edge\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: n^2\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Graph {\\npublic:\\n    vector<vector<long>> dist;\\n    int N=0;\\n    \\n    Graph(int n, vector<vector<int>>& edges) {\\n        N=n;\\n        dist = vector<vector<long>>(n,vector<long>(n,1e14));\\n        \\n        \\n        for(auto &edge:edges){\\n            dist[edge[0]][edge[1]] = edge[2];\\n        }\\n        \\n        \\n        for(int i=0;i<n;++i){\\n            dist[i][i]=0;\\n        }\\n        \\n        for(int k=0;k<n;++k){\\n            for(int i=0;i<n;++i){\\n                for(int j=0;j<n;++j){\\n                        dist[i][j] = min(dist[i][j],dist[i][k] + dist[k][j]);\\n                    }\\n            }\\n        }\\n    }\\n    \\n    void addEdge(vector<int> edge) {\\n        for(int i=0;i<N;++i){\\n            for(int j=0;j<N;++j){\\n                dist[i][j] = min(dist[i][j],dist[i][edge[0]]+dist[edge[1]][j]+edge[2]);\\n            }\\n        }\\n    }\\n    \\n    int shortestPath(int node1, int node2) {\\n        return ((dist[node1][node2]>=1e14) ? -1 : dist[node1][node2]);\\n    }\\n};\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph* obj = new Graph(n, edges);\\n * obj->addEdge(edge);\\n * int param_2 = obj->shortestPath(node1,node2);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Graph {\\npublic:\\n    vector<vector<long>> dist;\\n    int N=0;\\n    \\n    Graph(int n, vector<vector<int>>& edges) {\\n        N=n;\\n        dist = vector<vector<long>>(n,vector<long>(n,1e14));\\n        \\n        \\n        for(auto &edge:edges){\\n            dist[edge[0]][edge[1]] = edge[2];\\n        }\\n        \\n        \\n        for(int i=0;i<n;++i){\\n            dist[i][i]=0;\\n        }\\n        \\n        for(int k=0;k<n;++k){\\n            for(int i=0;i<n;++i){\\n                for(int j=0;j<n;++j){\\n                        dist[i][j] = min(dist[i][j],dist[i][k] + dist[k][j]);\\n                    }\\n            }\\n        }\\n    }\\n    \\n    void addEdge(vector<int> edge) {\\n        for(int i=0;i<N;++i){\\n            for(int j=0;j<N;++j){\\n                dist[i][j] = min(dist[i][j],dist[i][edge[0]]+dist[edge[1]][j]+edge[2]);\\n            }\\n        }\\n    }\\n    \\n    int shortestPath(int node1, int node2) {\\n        return ((dist[node1][node2]>=1e14) ? -1 : dist[node1][node2]);\\n    }\\n};\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph* obj = new Graph(n, edges);\\n * obj->addEdge(edge);\\n * int param_2 = obj->shortestPath(node1,node2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420014,
                "title": "java-python-3-dijkstra-algorithm",
                "content": "\\n\\n```java\\n    private Map<Integer, Map<Integer, Integer>> graph = new HashMap<>();\\n\\n    public Graph(int n, int[][] edges) {\\n        for (int[] e : edges) {\\n            graph.computeIfAbsent(e[0], m -> new HashMap<>()).put(e[1], e[2]);\\n        }\\n    }\\n    \\n    public void addEdge(int[] edge) {\\n        graph.computeIfAbsent(edge[0], m -> new HashMap<>()).put(edge[1], edge[2]);\\n    }\\n    \\n    public int shortestPath(int node1, int node2) {\\n        PriorityQueue<int[]> pq = new PriorityQueue<>(Comparator.comparingInt(a -> a[0]));\\n        pq.offer(new int[]{0, node1});\\n        Set<Integer> seen = new HashSet<>();\\n        while (!pq.isEmpty()) {\\n            int cost = pq.peek()[0], node = pq.poll()[1];\\n            if (node == node2) {\\n                return cost;\\n            }\\n            if (graph.containsKey(node) && seen.add(node)) {\\n                for (var entry : graph.get(node).entrySet()) {\\n                    int kid = entry.getKey(), w = entry.getValue();\\n                    pq.offer(new int[]{w + cost, kid});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n```\\n```python\\n    def __init__(self, n: int, edges: List[List[int]]):\\n        self.graph = defaultdict(dict)\\n        for a, b, cost in edges:\\n            self.graph[a][b] = cost\\n\\n    def addEdge(self, edge: List[int]) -> None:\\n        a, b, cost = edge\\n        self.graph[a][b] = cost\\n        \\n\\n    def shortestPath(self, node1: int, node2: int) -> int:\\n        g, seen = self.graph, set()\\n        heap = [(0, node1)]\\n        while heap:\\n            cost, node = heappop(heap)\\n            if node == node2:\\n                return cost\\n            if node not in seen and node in g:\\n                seen.add(node)\\n                for kid, cost1 in g[node].items():\\n                    heappush(heap, (cost + cost1, kid))\\n        return -1\\n```",
                "solutionTags": [],
                "code": "```java\\n    private Map<Integer, Map<Integer, Integer>> graph = new HashMap<>();\\n\\n    public Graph(int n, int[][] edges) {\\n        for (int[] e : edges) {\\n            graph.computeIfAbsent(e[0], m -> new HashMap<>()).put(e[1], e[2]);\\n        }\\n    }\\n    \\n    public void addEdge(int[] edge) {\\n        graph.computeIfAbsent(edge[0], m -> new HashMap<>()).put(edge[1], edge[2]);\\n    }\\n    \\n    public int shortestPath(int node1, int node2) {\\n        PriorityQueue<int[]> pq = new PriorityQueue<>(Comparator.comparingInt(a -> a[0]));\\n        pq.offer(new int[]{0, node1});\\n        Set<Integer> seen = new HashSet<>();\\n        while (!pq.isEmpty()) {\\n            int cost = pq.peek()[0], node = pq.poll()[1];\\n            if (node == node2) {\\n                return cost;\\n            }\\n            if (graph.containsKey(node) && seen.add(node)) {\\n                for (var entry : graph.get(node).entrySet()) {\\n                    int kid = entry.getKey(), w = entry.getValue();\\n                    pq.offer(new int[]{w + cost, kid});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n```\n```python\\n    def __init__(self, n: int, edges: List[List[int]]):\\n        self.graph = defaultdict(dict)\\n        for a, b, cost in edges:\\n            self.graph[a][b] = cost\\n\\n    def addEdge(self, edge: List[int]) -> None:\\n        a, b, cost = edge\\n        self.graph[a][b] = cost\\n        \\n\\n    def shortestPath(self, node1: int, node2: int) -> int:\\n        g, seen = self.graph, set()\\n        heap = [(0, node1)]\\n        while heap:\\n            cost, node = heappop(heap)\\n            if node == node2:\\n                return cost\\n            if node not in seen and node in g:\\n                seen.add(node)\\n                for kid, cost1 in g[node].items():\\n                    heappush(heap, (cost + cost1, kid))\\n        return -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3420087,
                "title": "simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Graph {\\n    List<List<int[]>> res;\\n    int n;\\n    public Graph(int n, int[][] edges) {\\n        this.n = n;\\n        res = new ArrayList<>();\\n        for (int i = 0; i < n; i++) {\\n            res.add(new ArrayList<>());\\n        }\\n        for (int[] edge : edges) {\\n            int u = edge[0], v = edge[1], w = edge[2];\\n            res.get(u).add(new int[]{v, w});\\n        }\\n    }\\n\\n    public void addEdge(int[] edge) {\\n        int u = edge[0], v = edge[1], w = edge[2];\\n        res.get(u).add(new int[]{v, w});\\n    }\\n\\n    public int shortestPath(int node1, int node2) {\\n        PriorityQueue<int[]> nm = new PriorityQueue<>((a, b) -> a[1] - b[1]);\\n        nm.offer(new int[]{node1, 0});\\n        boolean[] visited = new boolean[n];\\n        while (!nm.isEmpty())\\n        {\\n            int[] curr = nm.poll();\\n            int u = curr[0], d = curr[1];\\n            if (visited[u])\\n            {\\n                continue;\\n            }\\n            visited[u] = true;\\n            if (u == node2) return d;\\n            for (int[] e : res.get(u))\\n            {\\n                int v = e[0], w = e[1];\\n                if (!visited[v])\\n                {\\n                    nm.offer(new int[]{v, d + w});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Graph {\\n    List<List<int[]>> res;\\n    int n;\\n    public Graph(int n, int[][] edges) {\\n        this.n = n;\\n        res = new ArrayList<>();\\n        for (int i = 0; i < n; i++) {\\n            res.add(new ArrayList<>());\\n        }\\n        for (int[] edge : edges) {\\n            int u = edge[0], v = edge[1], w = edge[2];\\n            res.get(u).add(new int[]{v, w});\\n        }\\n    }\\n\\n    public void addEdge(int[] edge) {\\n        int u = edge[0], v = edge[1], w = edge[2];\\n        res.get(u).add(new int[]{v, w});\\n    }\\n\\n    public int shortestPath(int node1, int node2) {\\n        PriorityQueue<int[]> nm = new PriorityQueue<>((a, b) -> a[1] - b[1]);\\n        nm.offer(new int[]{node1, 0});\\n        boolean[] visited = new boolean[n];\\n        while (!nm.isEmpty())\\n        {\\n            int[] curr = nm.poll();\\n            int u = curr[0], d = curr[1];\\n            if (visited[u])\\n            {\\n                continue;\\n            }\\n            visited[u] = true;\\n            if (u == node2) return d;\\n            for (int[] e : res.get(u))\\n            {\\n                int v = e[0], w = e[1];\\n                if (!visited[v])\\n                {\\n                    nm.offer(new int[]{v, d + w});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420070,
                "title": "simple-java-dijkstra",
                "content": "```\\nclass pair{\\n    int node;\\n    int dist;\\n    pair(int node1,int dist1){\\n        node=node1;\\n        dist=dist1;\\n    }\\n}\\nclass Graph {\\n    List<List<pair>> adj;\\n    int n1;\\n    public Graph(int n, int[][] edges) {\\n        adj=new ArrayList<>();\\n        for(int i=0;i<n;i++){\\n            adj.add(new ArrayList<>());\\n        }\\n        for(int p[]:edges){\\n            adj.get(p[0]).add(new pair(p[1],p[2]));\\n        }\\n        n1=n;\\n    }\\n    \\n    public void addEdge(int[] edge) {\\n        adj.get(edge[0]).add(new pair(edge[1],edge[2]));\\n    }\\n    \\n    public int shortestPath(int src, int dest) {\\n        int distn[]=new int[n1];\\n        Arrays.fill(distn,(int)1e9);\\n        distn[src]=0;\\n        Queue<pair> q=new LinkedList<>();\\n        q.add(new pair(src,0));\\n        while(!q.isEmpty()){\\n            pair it=q.poll();\\n            int node=it.node;\\n            int dis=it.dist;\\n            for(pair x:adj.get(node)){\\n                if(x.dist+dis<distn[x.node]){\\n                    distn[x.node]=x.dist+dis;\\n                    q.add(new pair(x.node,distn[x.node]));\\n                }\\n            }\\n        }\\n        return distn[dest]==(int)1e9?-1:distn[dest];\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass pair{\\n    int node;\\n    int dist;\\n    pair(int node1,int dist1){\\n        node=node1;\\n        dist=dist1;\\n    }\\n}\\nclass Graph {\\n    List<List<pair>> adj;\\n    int n1;\\n    public Graph(int n, int[][] edges) {\\n        adj=new ArrayList<>();\\n        for(int i=0;i<n;i++){\\n            adj.add(new ArrayList<>());\\n        }\\n        for(int p[]:edges){\\n            adj.get(p[0]).add(new pair(p[1],p[2]));\\n        }\\n        n1=n;\\n    }\\n    \\n    public void addEdge(int[] edge) {\\n        adj.get(edge[0]).add(new pair(edge[1],edge[2]));\\n    }\\n    \\n    public int shortestPath(int src, int dest) {\\n        int distn[]=new int[n1];\\n        Arrays.fill(distn,(int)1e9);\\n        distn[src]=0;\\n        Queue<pair> q=new LinkedList<>();\\n        q.add(new pair(src,0));\\n        while(!q.isEmpty()){\\n            pair it=q.poll();\\n            int node=it.node;\\n            int dis=it.dist;\\n            for(pair x:adj.get(node)){\\n                if(x.dist+dis<distn[x.node]){\\n                    distn[x.node]=x.dist+dis;\\n                    q.add(new pair(x.node,distn[x.node]));\\n                }\\n            }\\n        }\\n        return distn[dest]==(int)1e9?-1:distn[dest];\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420247,
                "title": "explained-simple-and-clear-python-code",
                "content": "# Intuition\\nThe problem is asking to find the shortest path between two given nodes in a directed weighted graph. This can be solved by using Dijkstra\\'s algorithm, which is a well-known algorithm used to find the shortest path in a weighted graph.\\n\\n\\n# Approach\\nWe can implement the Graph class with an adjacency list data structure to store the graph. The constructor takes two inputs, the number of nodes in the graph and the edges of the graph. We can create the adjacency list by iterating through the edges and adding them to the appropriate nodes.\\n\\nThe addEdge() function can add a new edge to the graph by simply appending the edge to the adjacency list of the \"from\" node.\\n\\nThe shortestPath() function is where we will implement Dijkstra\\'s algorithm. We start by initializing a heap with a tuple of (0, node1), where node1 is the starting node. We also initialize a dictionary to keep track of the minimum distance from the starting node to each node. We set the distance to the starting node as 0, and all other distances as infinity.\\n\\nWe then pop the smallest element from the heap, and check if we have reached the target node (node2). If so, we return the current distance. If not, we check if we have already found a shorter path to the current node. If we have, we skip to the next node. Otherwise, we update the minimum distance to the current node and add its neighbors to the heap.\\n\\nFinally, if we have gone through all the nodes and have not found a path to the target node, we return -1.\\n# Complexity\\n- Time complexity:\\nThe time complexity of Dijkstra\\'s algorithm is O(E + V log V), where E is the number of edges and V is the number of vertices. In our implementation, we use a heap to keep track of the next node to visit, which takes O(log V) time for each insertion and deletion. Therefore, the time complexity of our implementation is also O(E + V log V).\\n- Space complexity:\\nWe use an adjacency list to store the graph, which takes O(E + V) space. We also use a heap and a dictionary to keep track of the minimum distances, which takes O(V) space. Therefore, the overall space complexity is O(E + V).\\n# Code\\n```\\nimport heapq\\n\\nclass Graph:\\n\\n    def __init__(self, n: int, edges: List[List[int]]):\\n        self.adj_list = {i: [] for i in range(n)}\\n        for edge in edges:\\n            self.adj_list[edge[0]].append((edge[1], edge[2]))\\n        \\n    def addEdge(self, edge: List[int]) -> None:\\n        self.adj_list[edge[0]].append((edge[1], edge[2]))\\n\\n    def shortestPath(self, node1: int, node2: int) -> int:\\n        heap = [(0, node1)]\\n        dist = {i: float(\\'inf\\') for i in range(len(self.adj_list))}\\n        dist[node1] = 0\\n        \\n        while heap:\\n            (d, node) = heapq.heappop(heap)\\n            if node == node2:\\n                return d\\n            if d > dist[node]:\\n                continue\\n            for neighbor, weight in self.adj_list[node]:\\n                new_dist = d + weight\\n                if new_dist < dist[neighbor]:\\n                    dist[neighbor] = new_dist\\n                    heapq.heappush(heap, (new_dist, neighbor))\\n                    \\n        return -1\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport heapq\\n\\nclass Graph:\\n\\n    def __init__(self, n: int, edges: List[List[int]]):\\n        self.adj_list = {i: [] for i in range(n)}\\n        for edge in edges:\\n            self.adj_list[edge[0]].append((edge[1], edge[2]))\\n        \\n    def addEdge(self, edge: List[int]) -> None:\\n        self.adj_list[edge[0]].append((edge[1], edge[2]))\\n\\n    def shortestPath(self, node1: int, node2: int) -> int:\\n        heap = [(0, node1)]\\n        dist = {i: float(\\'inf\\') for i in range(len(self.adj_list))}\\n        dist[node1] = 0\\n        \\n        while heap:\\n            (d, node) = heapq.heappop(heap)\\n            if node == node2:\\n                return d\\n            if d > dist[node]:\\n                continue\\n            for neighbor, weight in self.adj_list[node]:\\n                new_dist = d + weight\\n                if new_dist < dist[neighbor]:\\n                    dist[neighbor] = new_dist\\n                    heapq.heappush(heap, (new_dist, neighbor))\\n                    \\n        return -1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421164,
                "title": "c-graph-dijkstra-algo",
                "content": "# Code\\n```\\nclass Graph\\n{\\npublic:\\n    unordered_map<int, vector<pair<int, int>>> graph;\\n    int k;\\n    Graph(int n, vector<vector<int>> &e)\\n    {\\n        for (auto x : e)\\n        {\\n            vector<int> l;\\n            graph[x[0]].push_back({x[1], x[2]});\\n        }\\n        k = n;\\n    }\\n    void addEdge(vector<int> e)\\n    {\\n        graph[e[0]].push_back({e[1], e[2]});\\n    }\\n    int shortestPath(int n1, int n2)\\n    {\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> p;\\n        p.push({0, n1});\\n        vector<int> dis(k + 1, 1e9);\\n        dis[n1] = 0;\\n        while (!p.empty())\\n        {\\n            int dist = p.top().first;\\n            int node = p.top().second;\\n            p.pop();\\n            for (auto i : graph[node])\\n            {\\n                if (dist + i.second < dis[i.first])\\n                {\\n                    dis[i.first] = dist + i.second;\\n                    p.push({dis[i.first], i.first});\\n                }\\n            }\\n        }\\n        if (dis[n2] == 1e9)\\n            return -1;\\n        else\\n            return dis[n2];\\n    }\\n};\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph* obj = new Graph(n, edges);\\n * obj->addEdge(edge);\\n * int param_2 = obj->shortestPath(node1,node2);\\n */\\n```\\n![upvote (2).jpg](https://assets.leetcode.com/users/images/5689674d-29b2-49b8-ab6a-5d2a317d5e0b_1681590486.9208362.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Graph",
                    "Shortest Path"
                ],
                "code": "```\\nclass Graph\\n{\\npublic:\\n    unordered_map<int, vector<pair<int, int>>> graph;\\n    int k;\\n    Graph(int n, vector<vector<int>> &e)\\n    {\\n        for (auto x : e)\\n        {\\n            vector<int> l;\\n            graph[x[0]].push_back({x[1], x[2]});\\n        }\\n        k = n;\\n    }\\n    void addEdge(vector<int> e)\\n    {\\n        graph[e[0]].push_back({e[1], e[2]});\\n    }\\n    int shortestPath(int n1, int n2)\\n    {\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> p;\\n        p.push({0, n1});\\n        vector<int> dis(k + 1, 1e9);\\n        dis[n1] = 0;\\n        while (!p.empty())\\n        {\\n            int dist = p.top().first;\\n            int node = p.top().second;\\n            p.pop();\\n            for (auto i : graph[node])\\n            {\\n                if (dist + i.second < dis[i.first])\\n                {\\n                    dis[i.first] = dist + i.second;\\n                    p.push({dis[i.first], i.first});\\n                }\\n            }\\n        }\\n        if (dis[n2] == 1e9)\\n            return -1;\\n        else\\n            return dis[n2];\\n    }\\n};\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph* obj = new Graph(n, edges);\\n * obj->addEdge(edge);\\n * int param_2 = obj->shortestPath(node1,node2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422331,
                "title": "easy-dijkstra",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Code\\n```\\nclass Graph {\\npublic:\\n    vector<vector<pair<int,int>>>adj_graph;\\n    Graph(int n, vector<vector<int>>& edges) {        \\n        adj_graph.resize(n);\\n        for(auto edge:edges){\\n            adj_graph[edge[0]].push_back({edge[1],edge[2]});\\n        }\\n        \\n    }\\n    \\n    void addEdge(vector<int> edge) {\\n        adj_graph[edge[0]].push_back({edge[1],edge[2]});\\n        \\n    }\\n    int shortestPath(int node1, int node2) {   \\n        int n= adj_graph.size();\\n        vector<int>dist(n,1e9);\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pq;\\n        pq.push({0,node1});\\n        dist[node1]=0;\\n        while(!pq.empty()){\\n            int node=pq.top().second;\\n            int pdist=pq.top().first;\\n            pq.pop();\\n            if(node==node2)return pdist;\\n            for(auto ngh:adj_graph[node]){\\n                int curdist=ngh.second;\\n                int adjnode=ngh.first;\\n                if(curdist+pdist<dist[adjnode]){\\n                    dist[adjnode]=curdist+pdist;\\n                    pq.push({dist[adjnode],adjnode});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph* obj = new Graph(n, edges);\\n * obj->addEdge(edge);\\n * int param_2 = obj->shortestPath(node1,node2);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Graph {\\npublic:\\n    vector<vector<pair<int,int>>>adj_graph;\\n    Graph(int n, vector<vector<int>>& edges) {        \\n        adj_graph.resize(n);\\n        for(auto edge:edges){\\n            adj_graph[edge[0]].push_back({edge[1],edge[2]});\\n        }\\n        \\n    }\\n    \\n    void addEdge(vector<int> edge) {\\n        adj_graph[edge[0]].push_back({edge[1],edge[2]});\\n        \\n    }\\n    int shortestPath(int node1, int node2) {   \\n        int n= adj_graph.size();\\n        vector<int>dist(n,1e9);\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pq;\\n        pq.push({0,node1});\\n        dist[node1]=0;\\n        while(!pq.empty()){\\n            int node=pq.top().second;\\n            int pdist=pq.top().first;\\n            pq.pop();\\n            if(node==node2)return pdist;\\n            for(auto ngh:adj_graph[node]){\\n                int curdist=ngh.second;\\n                int adjnode=ngh.first;\\n                if(curdist+pdist<dist[adjnode]){\\n                    dist[adjnode]=curdist+pdist;\\n                    pq.push({dist[adjnode],adjnode});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph* obj = new Graph(n, edges);\\n * obj->addEdge(edge);\\n * int param_2 = obj->shortestPath(node1,node2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421193,
                "title": "python-3-dicts-heap-t-m-1126-ms-17-3-mb",
                "content": "```\\nclass Graph:\\n    def __init__(self, n: int, edges: list[list[int]]):\\n\\n        self.graph = defaultdict(list)\\n        for edge in edges: self.addEdge(edge)\\n\\n\\n    def addEdge(self, edge: list[int]) -> None:\\n\\n        frm, to, edgeCost = edge\\n        self.graph[frm].append((to, edgeCost))\\n\\n\\n    def shortestPath(self, s: int, t: int) -> int:\\n        \\n        d, queue = defaultdict(lambda:-1, {s:0}), [(0,s)]\\n \\n        while queue:\\n            a,b = heappop(queue)\\n            if d[b] == a:\\n                for to, edgeCost in self.graph[b]:\\n                    if d[to] > a + edgeCost or d[to] < 0:\\n                        d[to] = a + edgeCost\\n                        heappush(queue, (d[to], to))\\n        return d[t]\\n\\n```\\n[https://leetcode.com/problems/design-graph-with-shortest-path-calculator/submissions/934352860/](http://)\\n\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Graph:\\n    def __init__(self, n: int, edges: list[list[int]]):\\n\\n        self.graph = defaultdict(list)\\n        for edge in edges: self.addEdge(edge)\\n\\n\\n    def addEdge(self, edge: list[int]) -> None:\\n\\n        frm, to, edgeCost = edge\\n        self.graph[frm].append((to, edgeCost))\\n\\n\\n    def shortestPath(self, s: int, t: int) -> int:\\n        \\n        d, queue = defaultdict(lambda:-1, {s:0}), [(0,s)]\\n \\n        while queue:\\n            a,b = heappop(queue)\\n            if d[b] == a:\\n                for to, edgeCost in self.graph[b]:\\n                    if d[to] > a + edgeCost or d[to] < 0:\\n                        d[to] = a + edgeCost\\n                        heappush(queue, (d[to], to))\\n        return d[t]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421023,
                "title": "simple-c-solution-dijkstra-100-time-and-100-memory-efficient",
                "content": "```\\nconst int N=105;\\nclass Graph{\\n    vector<pair<int,int>>g[N];\\npublic:\\n    Graph(int n, vector<vector<int>>& edges) {\\n        // g.resize(n);\\n        for(auto it:edges){\\n            g[it[0]].push_back({it[1],it[2]});\\n        }\\n    }\\n    \\n    void addEdge(vector<int> edge) {\\n        g[edge[0]].push_back({edge[1],edge[2]});\\n    }\\n    \\n    int shortestPath(int node1, int node2) {\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pq;\\n        //minheap: min at top\\n        vector<int> dist(100,INT_MAX);\\n        pq.push({0,node1});\\n        //{dist,node}\\n        dist[node1]=0;\\n        while(!pq.empty()){\\n            int curr=pq.top().second;\\n            int curr_d=pq.top().first;\\n            pq.pop();\\n\\n            for(auto it:g[curr]){\\n                if(curr_d+it.second<dist[it.first]){\\n                    dist[it.first]=curr_d+it.second;\\n                    pq.push({dist[it.first],it.first});\\n                }\\n            }\\n        }\\n        if(dist[node2]==INT_MAX)return -1;\\n        return dist[node2];\\n    }\\n};\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph* obj = new Graph(n, edges);\\n * obj->addEdge(edge);\\n * int param_2 = obj->shortestPath(node1,node2);\\n */\\n\\n```",
                "solutionTags": [
                    "C",
                    "Graph",
                    "Heap (Priority Queue)",
                    "Shortest Path"
                ],
                "code": "```\\nconst int N=105;\\nclass Graph{\\n    vector<pair<int,int>>g[N];\\npublic:\\n    Graph(int n, vector<vector<int>>& edges) {\\n        // g.resize(n);\\n        for(auto it:edges){\\n            g[it[0]].push_back({it[1],it[2]});\\n        }\\n    }\\n    \\n    void addEdge(vector<int> edge) {\\n        g[edge[0]].push_back({edge[1],edge[2]});\\n    }\\n    \\n    int shortestPath(int node1, int node2) {\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pq;\\n        //minheap: min at top\\n        vector<int> dist(100,INT_MAX);\\n        pq.push({0,node1});\\n        //{dist,node}\\n        dist[node1]=0;\\n        while(!pq.empty()){\\n            int curr=pq.top().second;\\n            int curr_d=pq.top().first;\\n            pq.pop();\\n\\n            for(auto it:g[curr]){\\n                if(curr_d+it.second<dist[it.first]){\\n                    dist[it.first]=curr_d+it.second;\\n                    pq.push({dist[it.first],it.first});\\n                }\\n            }\\n        }\\n        if(dist[node2]==INT_MAX)return -1;\\n        return dist[node2];\\n    }\\n};\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph* obj = new Graph(n, edges);\\n * obj->addEdge(edge);\\n * int param_2 = obj->shortestPath(node1,node2);\\n */\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3419970,
                "title": "cpp-python3-dijktra-s-algorithm",
                "content": "\\n\\n#### If you helped, Please upvote.\\n\\n### Solution\\n```cpp []\\nclass Graph {\\npublic:\\n    typedef long long ll;\\n    vector<vector<pair<int, int>>> G;\\n    int n;\\n    \\n    Graph(int _n, vector<vector<int>>& edges) {\\n        this -> n = _n;\\n        G.resize(n);\\n        for(auto& e : edges) G[e[0]].push_back({e[1], e[2]});\\n    }\\n    \\n    void addEdge(vector<int> edge) {\\n        G[edge[0]].push_back({edge[1], edge[2]});\\n    }\\n    \\n    int shortestPath(int node1, int node2) {\\n        // Dijktra\\'s algo\\n        priority_queue<pair<ll, int>, vector<pair<ll, int>>, greater<pair<ll, int>>> pq;\\n        pq.push({0, node1});\\n        \\n        vector<int> dist(n, INT_MAX);\\n        dist[node1] = 0;\\n        \\n        while(!pq.empty()) {\\n            auto [d, u] = pq.top(); pq.pop();\\n            if(u == node2) return d;\\n            if(dist[u] < d) continue;\\n            for(auto [v, wt] : G[u]) {\\n               if(dist[v] > dist[u] + wt) {\\n                    pq.push({d + wt, v});\\n                    dist[v] = d + wt;\\n               }\\n            } \\n        }\\n        \\n        return -1;\\n    }\\n};\\n```\\n```python []\\nclass Graph:\\n\\n    def __init__(self, n: int, edges: List[List[int]]):\\n        self.N = n\\n        self.INF = 10**19\\n        adj_list = collections.defaultdict(list)\\n        for u, v, wt in edges:\\n            adj_list[u].append((v, wt))\\n        self.adj_list = adj_list\\n\\n    def addEdge(self, edge: List[int]) -> None:\\n        self.adj_list[edge[0]].append((edge[1], edge[2]))\\n\\n    def shortestPath(self, node1: int, node2: int) -> int:\\n        h = []\\n        heapq.heappush(h, (0, node1))\\n        dist = [self.INF] * self.N\\n        dist[node1] = 0\\n        \\n        while len(h) :\\n            d, u = heapq.heappop(h)\\n            if(u == node2) : return d\\n            if dist[u] < d : continue\\n            for v, wt in self.adj_list[u]:\\n                if dist[v] > dist[u] + wt:\\n                    dist[v] = dist[u] + wt\\n                    heapq.heappush(h, (dist[v], v))\\n        return -1\\n\\n```\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```cpp []\\nclass Graph {\\npublic:\\n    typedef long long ll;\\n    vector<vector<pair<int, int>>> G;\\n    int n;\\n    \\n    Graph(int _n, vector<vector<int>>& edges) {\\n        this -> n = _n;\\n        G.resize(n);\\n        for(auto& e : edges) G[e[0]].push_back({e[1], e[2]});\\n    }\\n    \\n    void addEdge(vector<int> edge) {\\n        G[edge[0]].push_back({edge[1], edge[2]});\\n    }\\n    \\n    int shortestPath(int node1, int node2) {\\n        // Dijktra\\'s algo\\n        priority_queue<pair<ll, int>, vector<pair<ll, int>>, greater<pair<ll, int>>> pq;\\n        pq.push({0, node1});\\n        \\n        vector<int> dist(n, INT_MAX);\\n        dist[node1] = 0;\\n        \\n        while(!pq.empty()) {\\n            auto [d, u] = pq.top(); pq.pop();\\n            if(u == node2) return d;\\n            if(dist[u] < d) continue;\\n            for(auto [v, wt] : G[u]) {\\n               if(dist[v] > dist[u] + wt) {\\n                    pq.push({d + wt, v});\\n                    dist[v] = d + wt;\\n               }\\n            } \\n        }\\n        \\n        return -1;\\n    }\\n};\\n```\n```python []\\nclass Graph:\\n\\n    def __init__(self, n: int, edges: List[List[int]]):\\n        self.N = n\\n        self.INF = 10**19\\n        adj_list = collections.defaultdict(list)\\n        for u, v, wt in edges:\\n            adj_list[u].append((v, wt))\\n        self.adj_list = adj_list\\n\\n    def addEdge(self, edge: List[int]) -> None:\\n        self.adj_list[edge[0]].append((edge[1], edge[2]))\\n\\n    def shortestPath(self, node1: int, node2: int) -> int:\\n        h = []\\n        heapq.heappush(h, (0, node1))\\n        dist = [self.INF] * self.N\\n        dist[node1] = 0\\n        \\n        while len(h) :\\n            d, u = heapq.heappop(h)\\n            if(u == node2) : return d\\n            if dist[u] < d : continue\\n            for v, wt in self.adj_list[u]:\\n                if dist[v] > dist[u] + wt:\\n                    dist[v] = dist[u] + wt\\n                    heapq.heappush(h, (dist[v], v))\\n        return -1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3425426,
                "title": "simple-partial-update-floyd-warshall-solution-in-python-with-explanation",
                "content": "# Intuition\\nMost soltuions are based on the Dijkstra algorithm that compute the single-source shortest path when the `shortestPath` function is called. This solution explores an alternative approach where the all-pair shortest paths are precomputed in the initial stage and are getting update everytime a new edge added. \\n\\nDue to the simplicity of the beautiful Floyd-Warshall algorithm, this solution is more concise and easier to implement. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIn the initial stage, we build the graph and compute the all-pair shortest path with the classic Floyd-Warshall algorithm in $$O(n^3)$$. \\n\\nWhen an edge added, we update the all-pair shortest-path with the benefit from the new edge. The full Floyd-Warshall is too slow since the `addEdge` function can be called up to $$n$$ times. Thus, the key is not to perform the full Floyd-Warshall algorithm. Instead, a partial $$O(n^2)$$ Floyd-Warshall algorithm is performed two-times to update the involved edges only. \\n\\nWhen `shortestPath` is called, there is nothing to do but to return the precomputed shortest path. The time complexity is $$O(1)$$. \\n\\n# Complexity\\n- __init__: $$O(n^3)$$\\n- addEdge: $$O(n^2)$$\\n- shortestPath: $$O(1)$$\\nWhere $$n$$ is the number of nodes in the graph. \\n\\n\\n# Code\\n```\\nclass Graph:\\n    def __init__(self, n: int, edges: List[List[int]]):\\n        self.n = n\\n        self.graph = [[inf] * n for _ in range(n)]\\n        for i in range(n):\\n            self.graph[i][i] = 0\\n        for u, v, w in edges:\\n            self.graph[u][v] = w\\n        # Full Floyd-Warshall algorithm\\n        for k in range(n):\\n            for i in range(n):\\n                if self.graph[i][k] < inf:\\n                    for j in range(n):\\n                        self.graph[i][j] = min(self.graph[i][j], self.graph[i][k] + self.graph[k][j])\\n        \\n    def addEdge(self, edge: List[int]) -> None:\\n        (u, v, w) = edge\\n        if self.graph[u][v] <= w:\\n            return\\n        self.graph[u][v] = w\\n        # Partial Floyd-Warshall for updating involved edges only\\n        for k in [u, v]:\\n            for i in range(self.n):\\n                for j in range(self.n):\\n                    self.graph[i][j] = min(self.graph[i][j], self.graph[i][k] + self.graph[k][j])\\n                \\n    def shortestPath(self, node1: int, node2: int) -> int:\\n        return self.graph[node1][node2] if self.graph[node1][node2] < inf else -1",
                "solutionTags": [
                    "Python3"
                ],
                "code": "# Intuition\\nMost soltuions are based on the Dijkstra algorithm that compute the single-source shortest path when the `shortestPath` function is called. This solution explores an alternative approach where the all-pair shortest paths are precomputed in the initial stage and are getting update everytime a new edge added. \\n\\nDue to the simplicity of the beautiful Floyd-Warshall algorithm, this solution is more concise and easier to implement. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIn the initial stage, we build the graph and compute the all-pair shortest path with the classic Floyd-Warshall algorithm in $$O(n^3)$$. \\n\\nWhen an edge added, we update the all-pair shortest-path with the benefit from the new edge. The full Floyd-Warshall is too slow since the `addEdge` function can be called up to $$n$$ times. Thus, the key is not to perform the full Floyd-Warshall algorithm. Instead, a partial $$O(n^2)$$ Floyd-Warshall algorithm is performed two-times to update the involved edges only. \\n\\nWhen `shortestPath` is called, there is nothing to do but to return the precomputed shortest path. The time complexity is $$O(1)$$. \\n\\n# Complexity\\n- __init__: $$O(n^3)$$\\n- addEdge: $$O(n^2)$$\\n- shortestPath: $$O(1)$$\\nWhere $$n$$ is the number of nodes in the graph. \\n\\n\\n# Code\\n```\\nclass Graph:\\n    def __init__(self, n: int, edges: List[List[int]]):\\n        self.n = n\\n        self.graph = [[inf] * n for _ in range(n)]\\n        for i in range(n):\\n            self.graph[i][i] = 0\\n        for u, v, w in edges:\\n            self.graph[u][v] = w\\n        # Full Floyd-Warshall algorithm\\n        for k in range(n):\\n            for i in range(n):\\n                if self.graph[i][k] < inf:\\n                    for j in range(n):\\n                        self.graph[i][j] = min(self.graph[i][j], self.graph[i][k] + self.graph[k][j])\\n        \\n    def addEdge(self, edge: List[int]) -> None:\\n        (u, v, w) = edge\\n        if self.graph[u][v] <= w:\\n            return\\n        self.graph[u][v] = w\\n        # Partial Floyd-Warshall for updating involved edges only\\n        for k in [u, v]:\\n            for i in range(self.n):\\n                for j in range(self.n):\\n                    self.graph[i][j] = min(self.graph[i][j], self.graph[i][k] + self.graph[k][j])\\n                \\n    def shortestPath(self, node1: int, node2: int) -> int:\\n        return self.graph[node1][node2] if self.graph[node1][node2] < inf else -1",
                "codeTag": "Java"
            },
            {
                "id": 3420111,
                "title": "javascript-dijkstra",
                "content": "# Intuition\\nSimple emulation\\n\\n# Approach\\nStore all the edges in hash map.\\n\\naddEdge - add one more node to edge.\\nshortestPath - implement optimal path finding using Heap. On each step go to next node with min total path. For this node add all reachable nodes from this node to the MinHeap. Priority will be cost to get to particular node.\\n\\n# Complexity\\n- Time complexity:\\naddEdge O(1)\\nshortestPath O(K*Nlog(N))\\n\\n- Space complexity:\\nO(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @param {number[][]} edges\\n */\\nvar Graph = function(n, edges) {\\n    this.map = new Map()\\n    let map = this.map;\\n    for(let i = 0; i < edges.length; i++){\\n        let edge = edges[i]\\n        let from = edge[0]\\n        let to = edge[1]\\n        let cost = edge[2]\\n        if(!map.has(from)){\\n            map.set(from, new Set())\\n        }\\n        \\n        map.get(from).add({to, cost})\\n    }\\n};\\n\\n/** \\n * @param {number[]} edge\\n * @return {void}\\n */\\nGraph.prototype.addEdge = function(edge) {\\n    let map = this.map;\\n     let from = edge[0]\\n     let to = edge[1]\\n     let cost = edge[2]\\n     if(!map.has(from)){\\n        map.set(from, new Set())\\n     }\\n        \\n     map.get(from).add({to, cost})\\n};\\n\\n/** \\n * @param {number} node1 \\n * @param {number} node2\\n * @return {number}\\n */\\nGraph.prototype.shortestPath = function(node1, node2) {\\n    \\n    const heap = new MinPriorityQueue()\\n    heap.enqueue({node: node1, cost: 0}, 0)\\n    let visited = new Set()\\n    \\n    while(heap.size() > 0){\\n        const top = heap.dequeue().element;\\n        \\n        if(visited.has(top.node)){\\n            continue;\\n        }\\n        visited.add(top.node)\\n        if(top.node === node2){\\n            return top.cost;\\n        }\\n        let next = this.map.get(top.node)\\n        if(next){\\n            for (let n of next){\\n                heap.enqueue({node: n.to, cost: top.cost + n.cost}, top.cost + n.cost)\\n            }\\n        }\\n    }\\n    \\n    return -1\\n    \\n    \\n};\\n\\n/** \\n * Your Graph object will be instantiated and called as such:\\n * var obj = new Graph(n, edges)\\n * obj.addEdge(edge)\\n * var param_2 = obj.shortestPath(node1,node2)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number[][]} edges\\n */\\nvar Graph = function(n, edges) {\\n    this.map = new Map()\\n    let map = this.map;\\n    for(let i = 0; i < edges.length; i++){\\n        let edge = edges[i]\\n        let from = edge[0]\\n        let to = edge[1]\\n        let cost = edge[2]\\n        if(!map.has(from)){\\n            map.set(from, new Set())\\n        }\\n        \\n        map.get(from).add({to, cost})\\n    }\\n};\\n\\n/** \\n * @param {number[]} edge\\n * @return {void}\\n */\\nGraph.prototype.addEdge = function(edge) {\\n    let map = this.map;\\n     let from = edge[0]\\n     let to = edge[1]\\n     let cost = edge[2]\\n     if(!map.has(from)){\\n        map.set(from, new Set())\\n     }\\n        \\n     map.get(from).add({to, cost})\\n};\\n\\n/** \\n * @param {number} node1 \\n * @param {number} node2\\n * @return {number}\\n */\\nGraph.prototype.shortestPath = function(node1, node2) {\\n    \\n    const heap = new MinPriorityQueue()\\n    heap.enqueue({node: node1, cost: 0}, 0)\\n    let visited = new Set()\\n    \\n    while(heap.size() > 0){\\n        const top = heap.dequeue().element;\\n        \\n        if(visited.has(top.node)){\\n            continue;\\n        }\\n        visited.add(top.node)\\n        if(top.node === node2){\\n            return top.cost;\\n        }\\n        let next = this.map.get(top.node)\\n        if(next){\\n            for (let n of next){\\n                heap.enqueue({node: n.to, cost: top.cost + n.cost}, top.cost + n.cost)\\n            }\\n        }\\n    }\\n    \\n    return -1\\n    \\n    \\n};\\n\\n/** \\n * Your Graph object will be instantiated and called as such:\\n * var obj = new Graph(n, edges)\\n * obj.addEdge(edge)\\n * var param_2 = obj.shortestPath(node1,node2)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3449101,
                "title": "dijkstra",
                "content": "# Code\\n```\\nclass Graph {\\nprivate:\\n    vector<pair<int,int>> g[101];\\n    int n;\\npublic:\\n    Graph(int num, vector<vector<int>>& edges) {\\n        n = num;\\n        for(auto&edge: edges) \\n            g[edge[0]].push_back({edge[1],edge[2]});\\n    }\\n    void addEdge(vector<int> edge) {\\n        g[edge[0]].push_back({edge[1],edge[2]});\\n    }\\n    int dijkstra(int src,int dest){\\n        set<pair<int,int>> st;\\n        vector<int> dist(n,1e9);\\n        dist[src] = 0;\\n        st.insert({0,src});\\n        while(!st.empty()){\\n            auto top = *st.begin();\\n            st.erase(st.begin());\\n            int wt = top.first, u = top.second;\\n            for(auto&[v,weight]: g[u]){\\n                if(wt+weight < dist[v]){\\n                    dist[v] = wt + weight;\\n                    st.insert({dist[v],v});\\n                }\\n            }\\n        }\\n        return dist[dest] == 1e9 ? -1 : dist[dest];\\n    }\\n    int shortestPath(int node1, int node2) {\\n        return dijkstra(node1,node2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Graph",
                    "Design",
                    "Heap (Priority Queue)",
                    "Shortest Path"
                ],
                "code": "```\\nclass Graph {\\nprivate:\\n    vector<pair<int,int>> g[101];\\n    int n;\\npublic:\\n    Graph(int num, vector<vector<int>>& edges) {\\n        n = num;\\n        for(auto&edge: edges) \\n            g[edge[0]].push_back({edge[1],edge[2]});\\n    }\\n    void addEdge(vector<int> edge) {\\n        g[edge[0]].push_back({edge[1],edge[2]});\\n    }\\n    int dijkstra(int src,int dest){\\n        set<pair<int,int>> st;\\n        vector<int> dist(n,1e9);\\n        dist[src] = 0;\\n        st.insert({0,src});\\n        while(!st.empty()){\\n            auto top = *st.begin();\\n            st.erase(st.begin());\\n            int wt = top.first, u = top.second;\\n            for(auto&[v,weight]: g[u]){\\n                if(wt+weight < dist[v]){\\n                    dist[v] = wt + weight;\\n                    st.insert({dist[v],v});\\n                }\\n            }\\n        }\\n        return dist[dest] == 1e9 ? -1 : dist[dest];\\n    }\\n    int shortestPath(int node1, int node2) {\\n        return dijkstra(node1,node2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422271,
                "title": "c-two-solutions-dijkstra-floyd-warshall-simple-direct-implementation",
                "content": "Here constraints are very small (n <= 100, call <= 100)\\nSo we can easily answer any query in ```n*n``` (n = no of nodes)\\n\\n# **1. Dijkstra**\\n\\n(Prerequisite: Dijkstra Algorithm)\\n\\na. Maintain a adj list\\nb. Add edge directly to the adj list\\nc. For queries call Dijkstra Algorithm \\n\\n**Code:**\\n\\nNote: Here I have also maintained an ```updated``` array \\nSay we called ```Dijkstra``` on 1, 100 times and no edges are added so our code will still call for ```Dijkstra``` 100 times. \\n```updated``` array solves this problem as it is set to true whenever we have a result and it is set false whenever a new edge is added.\\n\\n```\\nclass Graph {\\npublic:\\n    \\n    vector<vector<int>> dist;\\n    vector<vector<pair<int, int>>> adj;\\n    vector<int> updated;\\n    \\n    void dijkstra(vector<vector<pair<int, int>>> adj, int src, vector<int>& dist) {\\n        int v = adj.size();\\n        dist = vector<int>(v, INT_MAX);\\n        dist[src] = 0;\\n        priority_queue < pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\\n        pq.push(make_pair(0, src));\\n\\n        while (pq.empty() == false) {\\n            pair<int, int> curr = pq.top();\\n            pq.pop();\\n\\n            int parent = curr.second;\\n            int parentDist = curr.first;\\n            for (pair<int, int> it : adj[parent]) {\\n                int child = it.first;\\n                int prentChidDist = it.second;\\n                if (dist[child] > parentDist + prentChidDist) {\\n                    dist[child] = parentDist + prentChidDist;\\n                    pq.push(make_pair(dist[child], child));\\n                }\\n            }\\n        }\\n        for(auto &it: dist) \\n            if(it == INT_MAX)\\n                it = -1;\\n    }\\n    \\n    Graph(int n, vector<vector<int>>& edges) {\\n        adj = vector<vector<pair<int, int>>>(n);\\n        for(auto &edge: edges) {\\n            int u = edge[0], v = edge[1], dist = edge[2];\\n            adj[u].push_back({v, dist});\\n        }\\n        dist = vector<vector<int>>(n);\\n        updated = vector<int>(n, false);\\n    }\\n    \\n    void addEdge(vector<int> edge) {\\n        int u = edge[0], v = edge[1], dist = edge[2];\\n        adj[u].push_back({v, dist});\\n        int n = adj.size();\\n        updated = vector<int>(n, false);\\n    }\\n    \\n    int shortestPath(int node1, int node2) {\\n        if(updated[node1] == false) {\\n            dijkstra(adj, node1, dist[node1]);\\n            updated[node1] = true;\\n        }\\n        return dist[node1][node2];\\n    }\\n};\\n```\\n\\nTime Complexity:\\nInitialisation: O(E) for creating Adj List\\nAddEdge: O(1) for adding edge, O(V) for update array initiallisation\\nshortestPath: O(Elog(V)) for Dijkstra\\n\\n\\n# 2. Floyd Warshall \\n\\n(Prerequisite: Floyd Warshall  Algorithm)\\n\\na. Compute the ```matrix``` where ```matrix[u][v]``` stores the dist from ```u->v```.\\nb. Call for Floyd Warshall algorithm which will convert ```matrix[u][v]``` to shortest dist between ```u``` and ```v```\\nc. Whenever a edge is added check if this is better than prev, and then update the matrix for this new edge added between ```u``` and ```v``` by calculating the newDist for every pair of node making it pass through ```u->v```\\nd. For queries directly return ```matrix[u][v]```\\n\\n**Code:**\\n```\\nclass Graph {\\npublic:\\n    \\n    vector<vector<int>> matrix;\\n    bool updated;\\n    \\n    void shortest_distance() {\\n\\t    int n = matrix.size();\\n\\t    for(int via = 0; via < n; via++) {\\n\\t        for(int i = 0; i < n; i++) {\\n\\t            for(int j = 0; j < n; j++) {\\n\\t                int newDist = -1;\\n\\t                if(matrix[i][via] != -1 && matrix[via][j] != -1)\\n\\t                   newDist = matrix[i][via] + matrix[via][j];\\n\\t                   \\n\\t                if(newDist != -1) {\\n\\t                    if(matrix[i][j] == -1) matrix[i][j] = newDist;\\n\\t                    else matrix[i][j] = min(matrix[i][j], newDist);\\n\\t                }\\n\\t            }\\n\\t        }\\n\\t    }\\n\\t}\\n    \\n    void shortest_distance(int u, int v) {\\n        int n = matrix.size();\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < n; j++) {\\n                int newDist = -1;\\n                if(matrix[i][u] != -1 && matrix[v][j] != -1)\\n                   newDist = matrix[i][u] + matrix[u][v] + matrix[v][j];\\n\\n                if(newDist != -1) {\\n                    if(matrix[i][j] == -1) matrix[i][j] = newDist;\\n                    else matrix[i][j] = min(matrix[i][j], newDist);\\n                }\\n            }\\n        }\\n    }\\n    \\n    Graph(int n, vector<vector<int>>& edges) {\\n        matrix = vector<vector<int>>(n, vector<int>(n, -1));\\n        for(auto &edge: edges) {\\n            int u = edge[0], v = edge[1], dist = edge[2];\\n            matrix[u][v] = dist;\\n        }\\n        for(int i = 0; i < n; i++) matrix[i][i] = 0;\\n        shortest_distance();\\n    }\\n    \\n    void addEdge(vector<int> edge) {\\n        int u = edge[0], v = edge[1], dist = edge[2];\\n        if(matrix[u][v] != -1 && matrix[u][v] < dist) return;\\n        matrix[u][v] = dist;\\n        shortest_distance(u, v);\\n    }\\n    \\n    int shortestPath(int node1, int node2) {\\n        return matrix[node1][node2];\\n    }\\n};\\n\\n```\\n\\nTime Complexity:\\nInitialisation: O(V^3) for Floyd Warshall\\nAddEdge: O(V^2) for updating matrix\\nshortestPath: O(1) \\n\\nI am not good with writing so please bear with that ;)\\nIf it helped please upvote :)\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```n*n```\n```updated```\n```Dijkstra```\n```Dijkstra```\n```updated```\n```\\nclass Graph {\\npublic:\\n    \\n    vector<vector<int>> dist;\\n    vector<vector<pair<int, int>>> adj;\\n    vector<int> updated;\\n    \\n    void dijkstra(vector<vector<pair<int, int>>> adj, int src, vector<int>& dist) {\\n        int v = adj.size();\\n        dist = vector<int>(v, INT_MAX);\\n        dist[src] = 0;\\n        priority_queue < pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\\n        pq.push(make_pair(0, src));\\n\\n        while (pq.empty() == false) {\\n            pair<int, int> curr = pq.top();\\n            pq.pop();\\n\\n            int parent = curr.second;\\n            int parentDist = curr.first;\\n            for (pair<int, int> it : adj[parent]) {\\n                int child = it.first;\\n                int prentChidDist = it.second;\\n                if (dist[child] > parentDist + prentChidDist) {\\n                    dist[child] = parentDist + prentChidDist;\\n                    pq.push(make_pair(dist[child], child));\\n                }\\n            }\\n        }\\n        for(auto &it: dist) \\n            if(it == INT_MAX)\\n                it = -1;\\n    }\\n    \\n    Graph(int n, vector<vector<int>>& edges) {\\n        adj = vector<vector<pair<int, int>>>(n);\\n        for(auto &edge: edges) {\\n            int u = edge[0], v = edge[1], dist = edge[2];\\n            adj[u].push_back({v, dist});\\n        }\\n        dist = vector<vector<int>>(n);\\n        updated = vector<int>(n, false);\\n    }\\n    \\n    void addEdge(vector<int> edge) {\\n        int u = edge[0], v = edge[1], dist = edge[2];\\n        adj[u].push_back({v, dist});\\n        int n = adj.size();\\n        updated = vector<int>(n, false);\\n    }\\n    \\n    int shortestPath(int node1, int node2) {\\n        if(updated[node1] == false) {\\n            dijkstra(adj, node1, dist[node1]);\\n            updated[node1] = true;\\n        }\\n        return dist[node1][node2];\\n    }\\n};\\n```\n```matrix```\n```matrix[u][v]```\n```u->v```\n```matrix[u][v]```\n```u```\n```v```\n```u```\n```v```\n```u->v```\n```matrix[u][v]```\n```\\nclass Graph {\\npublic:\\n    \\n    vector<vector<int>> matrix;\\n    bool updated;\\n    \\n    void shortest_distance() {\\n\\t    int n = matrix.size();\\n\\t    for(int via = 0; via < n; via++) {\\n\\t        for(int i = 0; i < n; i++) {\\n\\t            for(int j = 0; j < n; j++) {\\n\\t                int newDist = -1;\\n\\t                if(matrix[i][via] != -1 && matrix[via][j] != -1)\\n\\t                   newDist = matrix[i][via] + matrix[via][j];\\n\\t                   \\n\\t                if(newDist != -1) {\\n\\t                    if(matrix[i][j] == -1) matrix[i][j] = newDist;\\n\\t                    else matrix[i][j] = min(matrix[i][j], newDist);\\n\\t                }\\n\\t            }\\n\\t        }\\n\\t    }\\n\\t}\\n    \\n    void shortest_distance(int u, int v) {\\n        int n = matrix.size();\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < n; j++) {\\n                int newDist = -1;\\n                if(matrix[i][u] != -1 && matrix[v][j] != -1)\\n                   newDist = matrix[i][u] + matrix[u][v] + matrix[v][j];\\n\\n                if(newDist != -1) {\\n                    if(matrix[i][j] == -1) matrix[i][j] = newDist;\\n                    else matrix[i][j] = min(matrix[i][j], newDist);\\n                }\\n            }\\n        }\\n    }\\n    \\n    Graph(int n, vector<vector<int>>& edges) {\\n        matrix = vector<vector<int>>(n, vector<int>(n, -1));\\n        for(auto &edge: edges) {\\n            int u = edge[0], v = edge[1], dist = edge[2];\\n            matrix[u][v] = dist;\\n        }\\n        for(int i = 0; i < n; i++) matrix[i][i] = 0;\\n        shortest_distance();\\n    }\\n    \\n    void addEdge(vector<int> edge) {\\n        int u = edge[0], v = edge[1], dist = edge[2];\\n        if(matrix[u][v] != -1 && matrix[u][v] < dist) return;\\n        matrix[u][v] = dist;\\n        shortest_distance(u, v);\\n    }\\n    \\n    int shortestPath(int node1, int node2) {\\n        return matrix[node1][node2];\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422099,
                "title": "c-very-easy-djkastra-algorithm",
                "content": "```\\nclass Graph {\\npublic:\\n    vector<pair<int,int>> v[101];\\n    typedef pair<int,int> pi;\\n    Graph(int n, vector<vector<int>>& edges) {\\n        for(auto it:edges)\\n        {\\n            v[it[0]].push_back({it[1],it[2]});\\n        }\\n    }\\n    \\n    void addEdge(vector<int> edge) {\\n         v[edge[0]].push_back({edge[1],edge[2]});\\n    }\\n    \\n    int shortestPath(int node1, int node2) {\\n        vector<int> dist(101,INT_MAX);\\n        dist[node1]=0;\\n        priority_queue<pi,vector<pi>,greater<pi>> pq;\\n        pq.push({dist[node1],node1});\\n        while(!pq.empty())\\n        {\\n            int val=pq.top().first;\\n            int node=pq.top().second;\\n            pq.pop();\\n            for(auto it:v[node])\\n            {\\n                int x=it.first;\\n                int wt=it.second;\\n                if(dist[x]>dist[node]+wt)\\n                {\\n                    dist[x]=dist[node]+wt;\\n                    pq.push({dist[x],x});\\n                }\\n            }\\n        }\\n        return (dist[node2]==INT_MAX)?-1:dist[node2];\\n    }\\n};\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph* obj = new Graph(n, edges);\\n * obj->addEdge(edge);\\n * int param_2 = obj->shortestPath(node1,node2);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass Graph {\\npublic:\\n    vector<pair<int,int>> v[101];\\n    typedef pair<int,int> pi;\\n    Graph(int n, vector<vector<int>>& edges) {\\n        for(auto it:edges)\\n        {\\n            v[it[0]].push_back({it[1],it[2]});\\n        }\\n    }\\n    \\n    void addEdge(vector<int> edge) {\\n         v[edge[0]].push_back({edge[1],edge[2]});\\n    }\\n    \\n    int shortestPath(int node1, int node2) {\\n        vector<int> dist(101,INT_MAX);\\n        dist[node1]=0;\\n        priority_queue<pi,vector<pi>,greater<pi>> pq;\\n        pq.push({dist[node1],node1});\\n        while(!pq.empty())\\n        {\\n            int val=pq.top().first;\\n            int node=pq.top().second;\\n            pq.pop();\\n            for(auto it:v[node])\\n            {\\n                int x=it.first;\\n                int wt=it.second;\\n                if(dist[x]>dist[node]+wt)\\n                {\\n                    dist[x]=dist[node]+wt;\\n                    pq.push({dist[x],x});\\n                }\\n            }\\n        }\\n        return (dist[node2]==INT_MAX)?-1:dist[node2];\\n    }\\n};\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph* obj = new Graph(n, edges);\\n * obj->addEdge(edge);\\n * int param_2 = obj->shortestPath(node1,node2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420671,
                "title": "very-easy-floyd-warshall-c",
                "content": "\\n# Code\\n```\\nclass Graph {\\npublic:\\n    \\n    int n;\\n    int temp[100][100]; // Since maximum size is 100 x 100\\n    \\n    Graph(int n, vector<vector<int>>& edges) {\\n\\n        this->n = n;    // Set number of nodes\\n\\n        // Initialize cost matrix\\n        memset(temp,0x3f3f3f3f,sizeof temp); \\n \\n        for(int i = 0; i < edges.size(); i++) \\n        // Update cost from provided edges matrix\\n        // edges[i][0] is fromNode edges[i][1] is toNode\\n        // edges[i][2] is Cost\\n        {\\n            temp[edges[i][0]][edges[i][1]] = edges[i][2];\\n        }\\n        for(int i = 0; i < n; i++)\\n        {\\n            // Cost from self is 0\\n            temp[i][i] = 0;\\n        }\\n        for(int k = 0; k < n; k++)\\n        {\\n            for(int i = 0; i < n; i++)\\n            {\\n                for(int j = 0; j < n; j++)\\n                { \\n                    // Basic Floyd Warshall \\n                    temp[i][j] = min(temp[i][j], temp[i][k] + temp[k][j]);\\n                }\\n            }\\n        }\\n    }\\n    \\n    void addEdge(vector<int> edge) {\\n        // When new edge is added update cost matrix\\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 0; j < n; j++)\\n            {\\n                temp[i][j] = min(temp[i][j], temp[i][edge[0]] + edge[2] + temp[edge[1]][j]);\\n            }\\n        }\\n    }\\n    \\n    int shortestPath(int node1, int node2) {\\n        // If node1 to node2 does not exist then return -1\\n        if(temp[node1][node2] == 0x3f3f3f3f)\\n        {\\n            return -1;\\n        }\\n        else\\n        {\\n            return temp[node1][node2];\\n        }\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Graph {\\npublic:\\n    \\n    int n;\\n    int temp[100][100]; // Since maximum size is 100 x 100\\n    \\n    Graph(int n, vector<vector<int>>& edges) {\\n\\n        this->n = n;    // Set number of nodes\\n\\n        // Initialize cost matrix\\n        memset(temp,0x3f3f3f3f,sizeof temp); \\n \\n        for(int i = 0; i < edges.size(); i++) \\n        // Update cost from provided edges matrix\\n        // edges[i][0] is fromNode edges[i][1] is toNode\\n        // edges[i][2] is Cost\\n        {\\n            temp[edges[i][0]][edges[i][1]] = edges[i][2];\\n        }\\n        for(int i = 0; i < n; i++)\\n        {\\n            // Cost from self is 0\\n            temp[i][i] = 0;\\n        }\\n        for(int k = 0; k < n; k++)\\n        {\\n            for(int i = 0; i < n; i++)\\n            {\\n                for(int j = 0; j < n; j++)\\n                { \\n                    // Basic Floyd Warshall \\n                    temp[i][j] = min(temp[i][j], temp[i][k] + temp[k][j]);\\n                }\\n            }\\n        }\\n    }\\n    \\n    void addEdge(vector<int> edge) {\\n        // When new edge is added update cost matrix\\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 0; j < n; j++)\\n            {\\n                temp[i][j] = min(temp[i][j], temp[i][edge[0]] + edge[2] + temp[edge[1]][j]);\\n            }\\n        }\\n    }\\n    \\n    int shortestPath(int node1, int node2) {\\n        // If node1 to node2 does not exist then return -1\\n        if(temp[node1][node2] == 0x3f3f3f3f)\\n        {\\n            return -1;\\n        }\\n        else\\n        {\\n            return temp[node1][node2];\\n        }\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420598,
                "title": "dijkstra-s-algorithm",
                "content": "# Intuition\\nMy first thought was to apply Floyd-Warshall\\'s algorithm but adding a edge to graph and doing relaxation for newly inserted edge will take $$O(n^2)$$. If we look at contraints they are not that strict we can easily apply dijstra\\'s algorithm for each query to get distance between nodes and adding a edge to graph also won\\'t effect much for individual distance calculation.\\n\\n# Approach\\nWe can build an adjacency list, building adjacency list will take $$O(E)$$ and adding a edge to adjacency list will take $O(1)$ time complexity.\\n\\nFrom here we can apply dijkstra algorithm for each query (node1, node2) for the complexity of $O(V \\\\cdot log(E + V))$.\\n\\n## Dijstras\\nFollowing is the steps for dijstra\\'s algorithm that finds distance of all the nodes from node `from`.\\n\\n- We keep distance array to keep track of minimum distance from `from` node to every other node (initially all to `INT_MAX`). We also need visited boolean array which has the nodes marked `true` if minimum distance to that node is already found.\\n- Min Priority queue is used to find the next node that is closest to `from` node and has not been visited.\\n- Distance of `from` to `from` is initialised to 0 and pushed to priority queue to start the algorithm.\\n- Now we pick the top most `node` at priority queue and go to it\\'s neighbour and check if we can perform any edge relaxation from the neighbour nodes of this `node` if there is edge relaxation performed we add that relaxation to priority queue as contender for next better pick.\\n- At the end distance array will have minimum distance from node `from` to all the other nodes.\\n\\n\\n# Complexity\\n- Time complexity:\\n    - Build: $O(E)$\\n    - Add Edge: $O(1)$\\n    - Shortest Path: $O(V \\\\cdot log(E + V))$\\n- Space complexity:\\n    - Graph will take $O(E + V)$\\n    - Dijstra algorithm takes $OD(E + V)$\\n\\n\\n# Code\\n```cpp\\nclass Graph {\\npublic:\\n  vector<vector<vector<int>>> graph;\\n  int n;\\n  Graph(int n, vector<vector<int>>& edges) {\\n    this->n = n;\\n    graph.resize(n);\\n    for (auto e: edges) {\\n      graph[e[0]].push_back({e[1], e[2]});\\n    }\\n  }\\n  \\n  void addEdge(vector<int> e) {\\n    graph[e[0]].push_back({e[1], e[2]});\\n  }\\n\\n  int shortestPath(int from, int to) {\\n    vector<int> dist(n, INT_MAX);\\n    vector<bool> visited(n, false);\\n    priority_queue<\\n      pair<int, int>,\\n      vector<pair<int, int>>,\\n      greater<pair<int, int>>> pq;\\n\\n    dist[from] = 0;\\n    pq.push({0, from});\\n\\n    while (!pq.empty()) {\\n      auto at = pq.top().second;\\n      auto di = pq.top().first;\\n      pq.pop();\\n\\n      if (at == to) {\\n        break;\\n      }\\n\\n      visited[at] = true;\\n\\n      for (auto e: graph[at]) {\\n        int to = e[0], weight = e[1];\\n\\n        if (visited[to]) continue;\\n\\n        int new_dist = di + weight;\\n\\n        if (dist[to] > new_dist) {\\n          dist[to] = new_dist;\\n          pq.push({new_dist, to});\\n        }\\n      }\\n    }\\n\\n    return dist[to] == INT_MAX ? -1 : dist[to];\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Shortest Path"
                ],
                "code": "```cpp\\nclass Graph {\\npublic:\\n  vector<vector<vector<int>>> graph;\\n  int n;\\n  Graph(int n, vector<vector<int>>& edges) {\\n    this->n = n;\\n    graph.resize(n);\\n    for (auto e: edges) {\\n      graph[e[0]].push_back({e[1], e[2]});\\n    }\\n  }\\n  \\n  void addEdge(vector<int> e) {\\n    graph[e[0]].push_back({e[1], e[2]});\\n  }\\n\\n  int shortestPath(int from, int to) {\\n    vector<int> dist(n, INT_MAX);\\n    vector<bool> visited(n, false);\\n    priority_queue<\\n      pair<int, int>,\\n      vector<pair<int, int>>,\\n      greater<pair<int, int>>> pq;\\n\\n    dist[from] = 0;\\n    pq.push({0, from});\\n\\n    while (!pq.empty()) {\\n      auto at = pq.top().second;\\n      auto di = pq.top().first;\\n      pq.pop();\\n\\n      if (at == to) {\\n        break;\\n      }\\n\\n      visited[at] = true;\\n\\n      for (auto e: graph[at]) {\\n        int to = e[0], weight = e[1];\\n\\n        if (visited[to]) continue;\\n\\n        int new_dist = di + weight;\\n\\n        if (dist[to] > new_dist) {\\n          dist[to] = new_dist;\\n          pq.push({new_dist, to});\\n        }\\n      }\\n    }\\n\\n    return dist[to] == INT_MAX ? -1 : dist[to];\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420438,
                "title": "time-space-100-beats-c-dijkstra-easy-to-understand",
                "content": "````\\nclass Graph {\\npublic:\\n    vector<vector<vector<int>>> g;\\n    long long int solve(int s,int e,vector<long long int> &dist,vector<bool>& vis){\\n        if(s==e){\\n            return 0;\\n        }\\n        if(dist[s] < 1e11)return dist[s];\\n        if(vis[s]){\\n            return dist[s];\\n        }\\n        vis[s] = true;\\n        long long int d = 1e11;\\n        for(auto &i: g[s]){\\n            d = min(d,solve(i[0],e,dist,vis)+i[1]*1LL);\\n        }\\n        return dist[s] = d;\\n    }\\n    \\n    Graph(int n, vector<vector<int>>& edges) {\\n        g.resize(n);\\n        for(auto &i: edges){\\n            g[i[0]].push_back({i[1],i[2]});\\n        }\\n    }\\n    \\n    void addEdge(vector<int> edge) {\\n        g[edge[0]].push_back({edge[1],edge[2]});\\n    }\\n    \\n    int shortestPath(int s, int e) {\\n        vector<long long int> dist(g.size(),1e11);\\n        dist[s] = 0;\\n        vector<bool> v(g.size());\\n        priority_queue<vector<long long int>,vector<vector<long long int>>,greater<vector<long long int>>> pq;\\n        pq.push({0,s});\\n        while(!pq.empty()){\\n            vector<long long int> v = pq.top();\\n            pq.pop();\\n            for(auto &i: g[v[1]]){\\n                if(dist[i[0]]>dist[v[1]]+i[1]*1LL){\\n                    dist[i[0]]=dist[v[1]]+i[1]*1LL;\\n                    pq.push({dist[i[0]],i[0]});\\n                }\\n            }\\n        }\\n        if(dist[e]==1e11)return -1;\\n        return dist[e];\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "C",
                    "Graph"
                ],
                "code": "````\\nclass Graph {\\npublic:\\n    vector<vector<vector<int>>> g;\\n    long long int solve(int s,int e,vector<long long int> &dist,vector<bool>& vis){\\n        if(s==e){\\n            return 0;\\n        }\\n        if(dist[s] < 1e11)return dist[s];\\n        if(vis[s]){\\n            return dist[s];\\n        }\\n        vis[s] = true;\\n        long long int d = 1e11;\\n        for(auto &i: g[s]){\\n            d = min(d,solve(i[0],e,dist,vis)+i[1]*1LL);\\n        }\\n        return dist[s] = d;\\n    }\\n    \\n    Graph(int n, vector<vector<int>>& edges) {\\n        g.resize(n);\\n        for(auto &i: edges){\\n            g[i[0]].push_back({i[1],i[2]});\\n        }\\n    }\\n    \\n    void addEdge(vector<int> edge) {\\n        g[edge[0]].push_back({edge[1],edge[2]});\\n    }\\n    \\n    int shortestPath(int s, int e) {\\n        vector<long long int> dist(g.size(),1e11);\\n        dist[s] = 0;\\n        vector<bool> v(g.size());\\n        priority_queue<vector<long long int>,vector<vector<long long int>>,greater<vector<long long int>>> pq;\\n        pq.push({0,s});\\n        while(!pq.empty()){\\n            vector<long long int> v = pq.top();\\n            pq.pop();\\n            for(auto &i: g[v[1]]){\\n                if(dist[i[0]]>dist[v[1]]+i[1]*1LL){\\n                    dist[i[0]]=dist[v[1]]+i[1]*1LL;\\n                    pq.push({dist[i[0]],i[0]});\\n                }\\n            }\\n        }\\n        if(dist[e]==1e11)return -1;\\n        return dist[e];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420319,
                "title": "simple-dijkstra-c-with-video-explanation",
                "content": "```\\nclass Graph {\\npublic:\\n    unordered_map<int,vector<pair<int,int>>> mp;\\n    typedef pair<int,int> pi;\\n    int m = 0;\\n    Graph(int n, vector<vector<int>>& edges) {\\n        for (int i=0; i< edges.size();i++){\\n            pi p = {edges[i][1],edges[i][2]};\\n            mp[edges[i][0]].emplace_back(p);\\n        }\\n        m = n;\\n    }\\n    \\n    void addEdge(vector<int> edge) {\\n        pi p = {edge[1],edge[2]};\\n        mp[edge[0]].emplace_back(p);\\n    }\\n    \\n    int shortestPath(int node1, int node2) {\\n        priority_queue<pi,vector<pi>,greater<pi> > pq;\\n        vector<int> dist(m,1000000000);\\n        dist[node1] = 0;\\n        pi p = {0, node1};\\n        pq.push(p);\\n        while (!pq.empty()){\\n            int dis = pq.top().first;\\n            int cur = pq.top().second;\\n            pq.pop();\\n            for (int i=0; i< mp[cur].size();i++){\\n                int next = mp[cur][i].first;\\n                if (dis + mp[cur][i].second < dist[next]){\\n                    dist[next] = dis + mp[cur][i].second;\\n                    pi p ={dist[next],next};\\n                    pq.push(p);\\n                }\\n            }\\n        }\\n        if (dist[node2] == 1000000000){\\n            return -1;\\n        }\\n        return dist[node2];\\n    }\\n};\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph* obj = new Graph(n, edges);\\n * obj->addEdge(edge);\\n * int param_2 = obj->shortestPath(node1,node2);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Graph {\\npublic:\\n    unordered_map<int,vector<pair<int,int>>> mp;\\n    typedef pair<int,int> pi;\\n    int m = 0;\\n    Graph(int n, vector<vector<int>>& edges) {\\n        for (int i=0; i< edges.size();i++){\\n            pi p = {edges[i][1],edges[i][2]};\\n            mp[edges[i][0]].emplace_back(p);\\n        }\\n        m = n;\\n    }\\n    \\n    void addEdge(vector<int> edge) {\\n        pi p = {edge[1],edge[2]};\\n        mp[edge[0]].emplace_back(p);\\n    }\\n    \\n    int shortestPath(int node1, int node2) {\\n        priority_queue<pi,vector<pi>,greater<pi> > pq;\\n        vector<int> dist(m,1000000000);\\n        dist[node1] = 0;\\n        pi p = {0, node1};\\n        pq.push(p);\\n        while (!pq.empty()){\\n            int dis = pq.top().first;\\n            int cur = pq.top().second;\\n            pq.pop();\\n            for (int i=0; i< mp[cur].size();i++){\\n                int next = mp[cur][i].first;\\n                if (dis + mp[cur][i].second < dist[next]){\\n                    dist[next] = dis + mp[cur][i].second;\\n                    pi p ={dist[next],next};\\n                    pq.push(p);\\n                }\\n            }\\n        }\\n        if (dist[node2] == 1000000000){\\n            return -1;\\n        }\\n        return dist[node2];\\n    }\\n};\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph* obj = new Graph(n, edges);\\n * obj->addEdge(edge);\\n * int param_2 = obj->shortestPath(node1,node2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420249,
                "title": "c-dijkstra",
                "content": "```\\nclass Graph {\\npublic:\\n    typedef pair<int, int> p;\\n    vector<vector<pair<int,int> > > adj;\\n    int node;\\n    int dijkstra(int V, int S,int des)\\n    {\\n        vector <int> dis(V,INT_MAX);\\n        dis[S]=0;   //source node =S\\n        priority_queue<p, vector<p>,greater<p> > pq;  //min queue\\n        \\n        pq.push({0,S}); //starting from this source node\\n        \\n        while(pq.size()){\\n            auto f =pq.top();\\n            int node = f.second;\\n            int d = f.first;\\n            pq.pop();\\n            \\n            for(auto num: adj[node]){\\n                int w = num.second; //weight\\n                int nextNode = num.first;    \\n                if( dis[node] + w < dis[nextNode] ){\\n                    dis[nextNode]= dis[node] + w;\\n                    pq.push({dis[nextNode], nextNode });    //pushing only if the distance is less\\n                }\\n            }\\n        }\\n        if(dis[des] == INT_MAX)\\n            return -1;\\n        return dis[des];\\n    }\\n    Graph(int n, vector<vector<int>>& edges) {\\n        adj.resize(n);\\n        node = n;\\n        for(auto ele:edges){\\n            adj[ele[0]].push_back({ele[1],ele[2]});\\n        }\\n    }\\n    \\n    void addEdge(vector<int> edge) {\\n        adj[edge[0]].push_back({edge[1],edge[2]});\\n    }\\n    \\n    int shortestPath(int node1, int node2) {\\n        return dijkstra(node,node1,node2);\\n    }\\n};\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph* obj = new Graph(n, edges);\\n * obj->addEdge(edge);\\n * int param_2 = obj->shortestPath(node1,node2);\\n */\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Graph {\\npublic:\\n    typedef pair<int, int> p;\\n    vector<vector<pair<int,int> > > adj;\\n    int node;\\n    int dijkstra(int V, int S,int des)\\n    {\\n        vector <int> dis(V,INT_MAX);\\n        dis[S]=0;   //source node =S\\n        priority_queue<p, vector<p>,greater<p> > pq;  //min queue\\n        \\n        pq.push({0,S}); //starting from this source node\\n        \\n        while(pq.size()){\\n            auto f =pq.top();\\n            int node = f.second;\\n            int d = f.first;\\n            pq.pop();\\n            \\n            for(auto num: adj[node]){\\n                int w = num.second; //weight\\n                int nextNode = num.first;    \\n                if( dis[node] + w < dis[nextNode] ){\\n                    dis[nextNode]= dis[node] + w;\\n                    pq.push({dis[nextNode], nextNode });    //pushing only if the distance is less\\n                }\\n            }\\n        }\\n        if(dis[des] == INT_MAX)\\n            return -1;\\n        return dis[des];\\n    }\\n    Graph(int n, vector<vector<int>>& edges) {\\n        adj.resize(n);\\n        node = n;\\n        for(auto ele:edges){\\n            adj[ele[0]].push_back({ele[1],ele[2]});\\n        }\\n    }\\n    \\n    void addEdge(vector<int> edge) {\\n        adj[edge[0]].push_back({edge[1],edge[2]});\\n    }\\n    \\n    int shortestPath(int node1, int node2) {\\n        return dijkstra(node,node1,node2);\\n    }\\n};\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph* obj = new Graph(n, edges);\\n * obj->addEdge(edge);\\n * int param_2 = obj->shortestPath(node1,node2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420154,
                "title": "c-solution-using-dijkstra-algorithm",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Graph {\\n    int n;\\n    vector<vector<pair<int, int>>> adj;\\npublic:\\n    Graph(int n, vector<vector<int>>& edges) {\\n        this->n=n;\\n        adj.resize(n);\\n        for (auto&i:edges) {\\n            int u=i[0],v=i[1],w=i[2];\\n            adj[u].push_back({v, w});\\n        }\\n    }\\n    \\n    void addEdge(vector<int> edge) {\\n        adj[edge[0]].push_back({edge[1], edge[2]});\\n    }\\n    \\n    int shortestPath(int node1, int node2) {\\n        priority_queue<pair<int,int>,vector<pair<int,int> >,greater<pair<int,int> > >pq;\\n    vector<int>distance(n+1,1e9);\\n    distance[node1]=0;\\n    pq.push({0,node1});\\n    while(pq.size())\\n    {\\n        int node=pq.top().second;\\n        int dis=pq.top().first;\\n        pq.pop();\\n        for(auto i:adj[node])\\n        {\\n            int adjnode=i.first;\\n            int edgeW=i.second;\\n            if(distance[node]+edgeW<distance[adjnode])\\n            {\\n                distance[adjnode]=distance[node]+edgeW;\\n                pq.push({distance[adjnode],adjnode});\\n            }\\n        }\\n    }\\n\\n        return (distance[node2]==1e9)?-1:distance[node2];\\n    }\\n};\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph* obj = new Graph(n, edges);\\n * obj->addEdge(edge);\\n * int param_2 = obj->shortestPath(node1,node2);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Graph {\\n    int n;\\n    vector<vector<pair<int, int>>> adj;\\npublic:\\n    Graph(int n, vector<vector<int>>& edges) {\\n        this->n=n;\\n        adj.resize(n);\\n        for (auto&i:edges) {\\n            int u=i[0],v=i[1],w=i[2];\\n            adj[u].push_back({v, w});\\n        }\\n    }\\n    \\n    void addEdge(vector<int> edge) {\\n        adj[edge[0]].push_back({edge[1], edge[2]});\\n    }\\n    \\n    int shortestPath(int node1, int node2) {\\n        priority_queue<pair<int,int>,vector<pair<int,int> >,greater<pair<int,int> > >pq;\\n    vector<int>distance(n+1,1e9);\\n    distance[node1]=0;\\n    pq.push({0,node1});\\n    while(pq.size())\\n    {\\n        int node=pq.top().second;\\n        int dis=pq.top().first;\\n        pq.pop();\\n        for(auto i:adj[node])\\n        {\\n            int adjnode=i.first;\\n            int edgeW=i.second;\\n            if(distance[node]+edgeW<distance[adjnode])\\n            {\\n                distance[adjnode]=distance[node]+edgeW;\\n                pq.push({distance[adjnode],adjnode});\\n            }\\n        }\\n    }\\n\\n        return (distance[node2]==1e9)?-1:distance[node2];\\n    }\\n};\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph* obj = new Graph(n, edges);\\n * obj->addEdge(edge);\\n * int param_2 = obj->shortestPath(node1,node2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420101,
                "title": "easy-and-intuitive-approach-code-with-comments-djikstra-c",
                "content": "\\n# Code\\n```\\nclass Graph {\\npublic:\\n    //Initialize graph\\n    vector<vector<pair<int,int>>> g;\\n    Graph(int n, vector<vector<int>>& edges) {\\n        int sz = (int)edges.size();\\n        g.resize(n);\\n       for(int i=0;i<sz;++i){\\n           int f = edges[i][0];\\n           int t = edges[i][1];\\n           int w = edges[i][2];\\n           g[f].push_back({t,w});\\n       } \\n    }\\n    \\n    //Atmost 100 new esges would be introduced, max edges in a graph with total nodes n is n*(n-1).\\n    void addEdge(vector<int> edge) {\\n        g[edge[0]].push_back({edge[1],edge[2]});\\n    }\\n    \\n    \\n    //Do a Djikstra with source = node1.\\n    \\n    //This will pass because the max operations would be: \\n    \\n    //100*O(nlogm + mlogn) m is number of edges and n is number of nodes.\\n    \\n    //Since m <= n*(n-1) we take the max which is n*(n-1), and max n could be 100.\\n    \\n    //So max operations = 100*O(100*log(100*99)+100*99*log(100)) which is nearly 2*10^6 which should pass under 1 second.\\n    \\n    //Will be called atmost 100 times.\\n    int shortestPath(int node1, int node2) {\\n        \\n        //Standard djikstra using priority queue. Refer cp-algorithms.\\n        \\n        vector<int> d((int)g.size(),2e9);\\n        using pii = pair<int,int>;\\n        priority_queue<pii,vector<pii>,greater<pii>> q;\\n        q.push({0, node1});\\n        d[node1]=0;\\n        while(!q.empty()){\\n            int v = q.top().second;\\n            int d_v = q.top().first;\\n            q.pop();\\n            if (d_v != d[v])\\n                continue;\\n\\n            for (auto edge : g[v]) {\\n                int to = edge.first;\\n                int len = edge.second;\\n\\n                if (d[v] + len < d[to]) {\\n                    d[to] = d[v] + len;\\n                    q.push({d[to], to});\\n                }\\n            }\\n        }\\n        if(d[node2]==2e9)\\n            return -1;\\n        return d[node2];\\n    }\\n};\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph* obj = new Graph(n, edges);\\n * obj->addEdge(edge);\\n * int param_2 = obj->shortestPath(node1,node2);\\n */\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Graph {\\npublic:\\n    //Initialize graph\\n    vector<vector<pair<int,int>>> g;\\n    Graph(int n, vector<vector<int>>& edges) {\\n        int sz = (int)edges.size();\\n        g.resize(n);\\n       for(int i=0;i<sz;++i){\\n           int f = edges[i][0];\\n           int t = edges[i][1];\\n           int w = edges[i][2];\\n           g[f].push_back({t,w});\\n       } \\n    }\\n    \\n    //Atmost 100 new esges would be introduced, max edges in a graph with total nodes n is n*(n-1).\\n    void addEdge(vector<int> edge) {\\n        g[edge[0]].push_back({edge[1],edge[2]});\\n    }\\n    \\n    \\n    //Do a Djikstra with source = node1.\\n    \\n    //This will pass because the max operations would be: \\n    \\n    //100*O(nlogm + mlogn) m is number of edges and n is number of nodes.\\n    \\n    //Since m <= n*(n-1) we take the max which is n*(n-1), and max n could be 100.\\n    \\n    //So max operations = 100*O(100*log(100*99)+100*99*log(100)) which is nearly 2*10^6 which should pass under 1 second.\\n    \\n    //Will be called atmost 100 times.\\n    int shortestPath(int node1, int node2) {\\n        \\n        //Standard djikstra using priority queue. Refer cp-algorithms.\\n        \\n        vector<int> d((int)g.size(),2e9);\\n        using pii = pair<int,int>;\\n        priority_queue<pii,vector<pii>,greater<pii>> q;\\n        q.push({0, node1});\\n        d[node1]=0;\\n        while(!q.empty()){\\n            int v = q.top().second;\\n            int d_v = q.top().first;\\n            q.pop();\\n            if (d_v != d[v])\\n                continue;\\n\\n            for (auto edge : g[v]) {\\n                int to = edge.first;\\n                int len = edge.second;\\n\\n                if (d[v] + len < d[to]) {\\n                    d[to] = d[v] + len;\\n                    q.push({d[to], to});\\n                }\\n            }\\n        }\\n        if(d[node2]==2e9)\\n            return -1;\\n        return d[node2];\\n    }\\n};\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph* obj = new Graph(n, edges);\\n * obj->addEdge(edge);\\n * int param_2 = obj->shortestPath(node1,node2);\\n */\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420011,
                "title": "bellman-ford",
                "content": "# Intuition\\nJust brute-force.\\n\\n# Approach\\nBell-ford.\\n\\n# Complexity\\n- Time complexity:\\nO(1) for add edge.\\nO(m) for shortest path.\\n\\n- Space complexity:\\nO(m)\\n\\n# Code\\n```\\nclass Graph {\\n    const int n;\\n    vector<vector<int>> edges;\\npublic:\\n    Graph(int n, vector<vector<int>>& edges) : n(n), edges(edges) {\\n        \\n    }\\n    \\n    void addEdge(vector<int> edge) {\\n       edges.push_back(edge);\\n    }\\n    \\n    int shortestPath(int node1, int node2) {\\n        if (node1 == node2) {\\n            return 0;\\n        }\\n        vector<int> dp(n, INT_MAX);\\n        dp[node1] = 0;\\n        for (bool mark = true; mark;) {\\n            mark = false;\\n            for (const auto& edge : edges) {\\n                if (dp[edge[0]] == INT_MAX) {\\n                    continue;\\n                }\\n                if (dp[edge[1]] > dp[edge[0]] + edge[2]) {\\n                    dp[edge[1]] = dp[edge[0]] + edge[2] ;\\n                    mark = true;\\n                }\\n            }\\n        }\\n        return dp[node2] == INT_MAX ? (-1) : dp[node2];\\n    }\\n};\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph* obj = new Graph(n, edges);\\n * obj->addEdge(edge);\\n * int param_2 = obj->shortestPath(node1,node2);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Graph {\\n    const int n;\\n    vector<vector<int>> edges;\\npublic:\\n    Graph(int n, vector<vector<int>>& edges) : n(n), edges(edges) {\\n        \\n    }\\n    \\n    void addEdge(vector<int> edge) {\\n       edges.push_back(edge);\\n    }\\n    \\n    int shortestPath(int node1, int node2) {\\n        if (node1 == node2) {\\n            return 0;\\n        }\\n        vector<int> dp(n, INT_MAX);\\n        dp[node1] = 0;\\n        for (bool mark = true; mark;) {\\n            mark = false;\\n            for (const auto& edge : edges) {\\n                if (dp[edge[0]] == INT_MAX) {\\n                    continue;\\n                }\\n                if (dp[edge[1]] > dp[edge[0]] + edge[2]) {\\n                    dp[edge[1]] = dp[edge[0]] + edge[2] ;\\n                    mark = true;\\n                }\\n            }\\n        }\\n        return dp[node2] == INT_MAX ? (-1) : dp[node2];\\n    }\\n};\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph* obj = new Graph(n, edges);\\n * obj->addEdge(edge);\\n * int param_2 = obj->shortestPath(node1,node2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3419982,
                "title": "python3-solution",
                "content": "\\n```\\nimport heapq\\nclass Graph:\\n\\n    def __init__(self, n: int, edges: List[List[int]]):\\n        self.adj_list=[[] for _ in range(n)]\\n        for u,v,w in edges:\\n            self.adj_list[u].append((v,w))\\n        \\n\\n    def addEdge(self, edge: List[int]) -> None:\\n        u,v,w=edge\\n        self.adj_list[u].append((v,w))\\n        \\n\\n    def shortestPath(self, node1: int, node2: int) -> int:\\n        n=len(self.adj_list)\\n        pq=[(0,node1)]\\n        dist=[float(\\'inf\\') for _ in range(n)]\\n        dist[node1]=0\\n        while pq:\\n            d,u=heapq.heappop(pq)\\n            if u==node2:\\n                return d\\n            if d>dist[u]:\\n                continue\\n                \\n            for v,w in self.adj_list[u]:\\n                if d+w<dist[v]:\\n                    dist[v]=d+w\\n                    heapq.heappush(pq,(dist[v],v))\\n                    \\n                    \\n                    \\n        return -1            \\n        \\n        \\n\\n\\n# Your Graph object will be instantiated and called as such:\\n# obj = Graph(n, edges)\\n# obj.addEdge(edge)\\n# param_2 = obj.shortestPath(node1,node2)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nimport heapq\\nclass Graph:\\n\\n    def __init__(self, n: int, edges: List[List[int]]):\\n        self.adj_list=[[] for _ in range(n)]\\n        for u,v,w in edges:\\n            self.adj_list[u].append((v,w))\\n        \\n\\n    def addEdge(self, edge: List[int]) -> None:\\n        u,v,w=edge\\n        self.adj_list[u].append((v,w))\\n        \\n\\n    def shortestPath(self, node1: int, node2: int) -> int:\\n        n=len(self.adj_list)\\n        pq=[(0,node1)]\\n        dist=[float(\\'inf\\') for _ in range(n)]\\n        dist[node1]=0\\n        while pq:\\n            d,u=heapq.heappop(pq)\\n            if u==node2:\\n                return d\\n            if d>dist[u]:\\n                continue\\n                \\n            for v,w in self.adj_list[u]:\\n                if d+w<dist[v]:\\n                    dist[v]=d+w\\n                    heapq.heappush(pq,(dist[v],v))\\n                    \\n                    \\n                    \\n        return -1            \\n        \\n        \\n\\n\\n# Your Graph object will be instantiated and called as such:\\n# obj = Graph(n, edges)\\n# obj.addEdge(edge)\\n# param_2 = obj.shortestPath(node1,node2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3460374,
                "title": "java-graph-dijkstra-algo-for-shortest-path-upvote",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nApply dijkstra algo for shortest path\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Graph {\\n\\n    class Node{\\n        int vertex;\\n        int weight;\\n        public Node(int vertex, int weight){\\n            this.vertex = vertex;\\n            this.weight = weight;\\n        }\\n    }\\n\\n    Map<Integer, List<Node>> graph;\\n    int V;\\n    int[] dist;\\n    PriorityQueue<Node> queue;\\n\\n    public Graph(int n, int[][] edges) {\\n        V = n;\\n\\n        dist = new int[V];\\n        queue = new PriorityQueue<>((a, b) -> a.weight - b.weight);\\n\\n        graph = new HashMap<>();\\n        for(int[] edge : edges){\\n            int u = edge[0];\\n            int v = edge[1];\\n            int weight = edge[2];\\n\\n            graph.putIfAbsent(u, new ArrayList<>());\\n            graph.get(u).add(new Node(v, weight));\\n        }\\n    }\\n    \\n    public void addEdge(int[] edge) {\\n        int u = edge[0];\\n        int v = edge[1];\\n        int weight = edge[2];\\n\\n        graph.putIfAbsent(u, new ArrayList<>());\\n        graph.get(u).add(new Node(v, weight));\\n    }\\n    \\n    public int shortestPath(int node1, int node2) {\\n        return shortestPathHelper(node1, node2);\\n    }\\n\\n    private int shortestPathHelper(int src, int dest){\\n        Arrays.fill(dist, Integer.MAX_VALUE);\\n        queue.clear();\\n\\n        dist[src] = 0;\\n        queue.add(new Node(src, 0));\\n\\n        while(!queue.isEmpty()){\\n\\n            Node currNode = queue.poll();\\n\\n            for(Node childNode : graph.getOrDefault(currNode.vertex, new ArrayList<>())){\\n                if(dist[childNode.vertex] > dist[currNode.vertex] + childNode.weight){\\n                    dist[childNode.vertex] = dist[currNode.vertex] + childNode.weight;\\n                    queue.add(new Node(childNode.vertex, dist[childNode.vertex]));\\n                }\\n            }\\n        }\\n        return dist[dest] == Integer.MAX_VALUE ? -1 : dist[dest];\\n    }\\n\\n}\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph obj = new Graph(n, edges);\\n * obj.addEdge(edge);\\n * int param_2 = obj.shortestPath(node1,node2);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Graph {\\n\\n    class Node{\\n        int vertex;\\n        int weight;\\n        public Node(int vertex, int weight){\\n            this.vertex = vertex;\\n            this.weight = weight;\\n        }\\n    }\\n\\n    Map<Integer, List<Node>> graph;\\n    int V;\\n    int[] dist;\\n    PriorityQueue<Node> queue;\\n\\n    public Graph(int n, int[][] edges) {\\n        V = n;\\n\\n        dist = new int[V];\\n        queue = new PriorityQueue<>((a, b) -> a.weight - b.weight);\\n\\n        graph = new HashMap<>();\\n        for(int[] edge : edges){\\n            int u = edge[0];\\n            int v = edge[1];\\n            int weight = edge[2];\\n\\n            graph.putIfAbsent(u, new ArrayList<>());\\n            graph.get(u).add(new Node(v, weight));\\n        }\\n    }\\n    \\n    public void addEdge(int[] edge) {\\n        int u = edge[0];\\n        int v = edge[1];\\n        int weight = edge[2];\\n\\n        graph.putIfAbsent(u, new ArrayList<>());\\n        graph.get(u).add(new Node(v, weight));\\n    }\\n    \\n    public int shortestPath(int node1, int node2) {\\n        return shortestPathHelper(node1, node2);\\n    }\\n\\n    private int shortestPathHelper(int src, int dest){\\n        Arrays.fill(dist, Integer.MAX_VALUE);\\n        queue.clear();\\n\\n        dist[src] = 0;\\n        queue.add(new Node(src, 0));\\n\\n        while(!queue.isEmpty()){\\n\\n            Node currNode = queue.poll();\\n\\n            for(Node childNode : graph.getOrDefault(currNode.vertex, new ArrayList<>())){\\n                if(dist[childNode.vertex] > dist[currNode.vertex] + childNode.weight){\\n                    dist[childNode.vertex] = dist[currNode.vertex] + childNode.weight;\\n                    queue.add(new Node(childNode.vertex, dist[childNode.vertex]));\\n                }\\n            }\\n        }\\n        return dist[dest] == Integer.MAX_VALUE ? -1 : dist[dest];\\n    }\\n\\n}\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph obj = new Graph(n, edges);\\n * obj.addEdge(edge);\\n * int param_2 = obj.shortestPath(node1,node2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3451903,
                "title": "c-encyclopedia-dijkstra-heap-optimized-dijkstra-spfa-floyd-warshall",
                "content": "### 1. Plain Dijkstra\\n\\n#### Intuition\\n\\nPlain Dijkstra.\\n- Instead of using a priority queue, this way of dijkstra uses a simple linear search to find the next unvisited node with the minimum distance.\\n- The reason for using a linear search instead of a heap is that the graph is dense. In this case, the overhead of maintaining a heap may be larger than the benefit of using it. Linear search also simplifies the implementation and can be faster for small graphs.\\n\\n#### Approach\\n\\nThis graph is represented by **adjacency matrix**.\\\\\\nThe implementation starts by initializing the distance of all nodes from the starting node to infinity (represented by `0x3f3f3f3f`), except for the starting node itself which has a distance of 0. Then, it iterates through all nodes, selecting the unvisited node with the smallest distance as the next node to visit. It marks the selected node as visited and updates the distance of its unvisited neighbors if a shorter path is found. Finally, the algorithm returns the distance of the target node if there is a path or -1 if there is no path.\\n\\n#### Complexity\\n\\nn is the number of nodes and m is the number of edges.\\n\\nThe time complexity of adding an edge is $$O(1)$$, and the space complexity is $$O(m)$$.\\\\\\nThe time complexity of computing the shortest path is $$O(n^2 + m)$$. The space complexity is $$O(n)$$ to store the distance array and visited set.\\n    \\n#### Code\\n\\n```cpp\\nclass Graph {\\npublic:\\n    const int INF = 0x3f3f3f3f;\\n    vector<vector<int>> g;\\n\\n    Graph(int n, vector<vector<int>>& edges) {\\n        g = vector<vector<int>>(n, vector<int>(n, INF));\\n        for (auto &e: edges)\\n            g[e[0]][e[1]] = e[2];\\n    }\\n\\n    void addEdge(vector<int> e) {\\n        g[e[0]][e[1]] = e[2];\\n    }\\n\\n    int shortestPath(int node1, int node2) {\\n        int n = g.size();\\n        vector<int> dist(n, INF);\\n        vector<bool> st(n);\\n        dist[node1] = 0;\\n\\n        for (int i = 0; i < n; ++i)\\n        {\\n            int t = -1;\\n            for (int j = 0; j < n; ++j)\\n                if (!st[j] && (t == -1 || dist[t] > dist[j]))\\n                    t = j;\\n            st[t] = true;\\n\\n            for (int j = 0; j < n; ++j)\\n                dist[j] = min(dist[j], dist[t] + g[t][j]);\\n        }\\n\\n        return dist[node2] == INF ? -1 : dist[node2];\\n    }\\n};\\n```\\n\\n### 2. Heap-Optimized Dijkstra\\n\\n#### Intuition\\n\\nThe approach taken in Solution 2 is also based on Dijkstra\\'s algorithm. However, it uses a priority queue to optimize the search time of finding the next unvisited node with the minimum distance.\\n\\n#### Approach\\n\\nThis graph is represented by **adjacency list**.\\\\\\nThis algorithm works by maintaining a set of visited nodes and a priority queue of nodes to visit. The priority queue is sorted based on the distance from the starting node. The algorithm repeatedly extracts the node with the smallest distance from the priority queue and relaxes all its neighbors, updating their distances if a shorter path is found. This continues until the destination node is visited or the priority queue is empty.\\n\\n#### Complexity\\n\\nn is the number of nodes and m is the number of edges.\\n\\nThe time complexity of adding an edge is $$O(1)$$, and the space complexity is $$O(m)$$.\\\\\\nThe time complexity of computing the shortest path is $$O(m * log n)$$. The space complexity is $$O(n)$$ to store the distance array and visited set.\\n    \\n#### Code\\n```cpp\\nclass Graph {\\npublic:\\n    vector<vector<pair<int, int>>> adj;\\n    \\n    Graph(int n, vector<vector<int>>& edge) {\\n        adj.resize(n);\\n        for (auto& e: edge)\\n            adj[e[0]].emplace_back(e[1], e[2]);\\n    }\\n\\n    void addEdge(vector<int> e) {\\n        adj[e[0]].emplace_back(e[1], e[2]);\\n    }\\n\\n    int shortestPath(int node1, int node2) {\\n        vector<int> dist(n);\\n        memset(&dist[0], 0x3f, n * sizeof(int));\\n        vector<bool> st(n);\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> heap;\\n        heap.emplace(0, node1);\\n        dist[node1] = 0;\\n\\n        while (!heap.empty())\\n        {\\n            auto [d, u] = heap.top(); heap.pop();\\n            if (st[u]) continue;\\n            st[u] = true;\\n            for (auto& edge : edges[u])\\n            {\\n                auto [v, w] = edge;\\n                if (dist[v] > dist[u] + w)\\n                {\\n                    dist[v] = dist[u] + w;\\n                    heap.emplace(dist[v], v);\\n                }\\n            }\\n        }\\n\\n        if (dist[node2] == 0x3f3f3f3f) return -1;\\n        return dist[node2];\\n    }\\n};\\n```\\n\\n### 3. SPFA\\n\\n#### Intuition\\n\\nShortest Path Faster Algorithm (SPFA).\\n- SPFA is an improvement over Dijkstra\\'s algorithm that uses a queue to optimize the search time of finding the next unvisited node with the minimum distance.\\n- It is similar to Dijkstra\\'s algorithm, but instead of always selecting the node with the smallest distance, SPFA maintains a queue of nodes to visit, and it only adds a node to the queue if its distance is updated.\\n\\n#### Approach\\n\\nThis graph is represented by **forward star edge list**.\\\\\\nThe implementation starts by initializing the distance of all nodes from the starting node to infinity (represented by `0x3f3f3f3f`), except for the starting node itself which has a distance of 0. Then, it uses a queue to maintain the nodes to visit, initially adding the starting node to the queue. It repeatedly dequeues a node from the queue, relaxes its neighbors by updating their distances if a shorter path is found, and enqueues them if their distances are updated. This process continues until the queue is empty, which means all nodes have been visited. Finally, the algorithm returns the distance of the target node if there is a path or -1 if there is no path.\\n\\n#### Complexity\\n\\nn is the number of nodes and m is the number of edges.\\n\\nThe time complexity of adding an edge is $$O(1)$$, and the space complexity is $$O(m)$$.\\\\\\nThe time complexity of computing the shortest path is $$O(n * m)$$, but it can be optimized to $$O(k * m)$$ on average, where `k` is the average number of edges per node. The space complexity is $$O(n)$$ to store the distance array and visited set, and $$O(n)$$ for the queue.\\n    \\n#### Code\\n```cpp\\nclass Graph {\\npublic:\\n    static const int N = 100, M = 10000;\\n    int head[N], e[M], ne[M], w[M], idx;\\n    int dist[N];\\n    bool st[N];\\n    \\n    Graph(int n, vector<vector<int>>& edges) {\\n        memset(head, -1, sizeof head);\\n        for (auto& e: edges)\\n            addEdge(e);\\n    }\\n\\n    void addEdge(vector<int> edge) {\\n        int a = edge[0], b = edge[1], c = edge[2];\\n        e[idx] = b, w[idx] = c, ne[idx] = head[a], head[a] = idx++;\\n    }\\n\\n    int shortestPath(int node1, int node2) {\\n        memset(dist, 0x3f, sizeof dist);\\n        memset(st, false, sizeof st);\\n        queue<int> q;\\n        q.push(node1);\\n        dist[node1] = 0;    \\n        st[node1] = true;\\n\\n        while (!q.empty())\\n        {\\n            int t = q.front();\\n            q.pop();\\n\\n            st[t] = false;\\n\\n            for (int i = head[t]; ~i; i = ne[i])\\n            {\\n                int j = e[i];\\n                if (dist[j] > dist[t] + w[i])\\n                {\\n                    dist[j] = dist[t] + w[i];\\n                    if (!st[j]) q.push(j), st[j] = true;\\n                }\\n            }\\n        }\\n\\n        if (dist[node2] == 0x3f3f3f3f) return -1;\\n        return dist[node2];\\n    }\\n};\\n```\\n\\n### 4. Floyd-Warshall\\n\\n#### Intuition\\n\\nFloyd-Warshall algorithm. The algorithm uses dynamic programming to find the shortest path between all pairs of nodes in a weighted graph.\\n\\n#### Approach\\n\\nThis graph is represented by **adjacency matrix**.\\\\\\nThe graph is represented as an adjacency matrix in the form of a two-dimensional vector `d` of size `n x n`. The constructor of the Graph class initializes the distance between each node to `0x3f3f3f3f` (which is a large value used to represent infinity). Then, the edges are added to the d matrix. The addEdge function updates the distance between nodes `a` and `b` with weight `w`. If the current distance is greater than the new distance, the shortest path between all pairs of nodes is recomputed using the Floyd algorithm. The shortestPath function returns the shortest path between node1 and node2.\\n\\n#### Complexity\\n\\nn is the number of nodes and m is the number of edges.\\n\\nThe time complexity of adding an edge is $$O(n^2)$$, and the space complexity is $$O(m)$$.\\\\\\nThe time complexity of computing the shortest path is $$O(n^3)$$. The space complexity is $$O(n^2)$$ to store the distance matrix.\\n    \\n#### Code\\n```cpp\\nclass Graph {\\npublic:\\n    vector<vector<int>> d;\\n    Graph(int n, vector<vector<int>>& edges) {\\n        d = vector(n, vector<int>(n, 0x3f3f3f3f));\\n        for (int i = 0; i < n; i++)\\n            d[i][i] = 0;\\n        for (auto& e : edges)\\n            d[e[0]][e[1]] = e[2];\\n        floyd(n);\\n    }\\n    \\n    void addEdge(vector<int> edge) {\\n        int a = edge[0], b = edge[1], w = edge[2];\\n        if (d[a][b] > w)\\n            for (int i = 0; i < d.size(); i++)\\n                for (int j = 0; j < d.size(); j++)\\n                    d[i][j] = min(d[i][j], d[i][a] + w + d[b][j]);\\n    }\\n\\n    int shortestPath(int node1, int node2) {\\n        return d[node1][node2] == 0x3f3f3f3f ? -1 : d[node1][node2];\\n    }\\n    \\nprivate:\\n    void floyd(int n)\\n    {\\n        for (int k = 0; k < n; k++)\\n            for (int i = 0; i < n; i++)\\n                for (int j = 0; j < n; j++)\\n                    d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Graph"
                ],
                "code": "```cpp\\nclass Graph {\\npublic:\\n    const int INF = 0x3f3f3f3f;\\n    vector<vector<int>> g;\\n\\n    Graph(int n, vector<vector<int>>& edges) {\\n        g = vector<vector<int>>(n, vector<int>(n, INF));\\n        for (auto &e: edges)\\n            g[e[0]][e[1]] = e[2];\\n    }\\n\\n    void addEdge(vector<int> e) {\\n        g[e[0]][e[1]] = e[2];\\n    }\\n\\n    int shortestPath(int node1, int node2) {\\n        int n = g.size();\\n        vector<int> dist(n, INF);\\n        vector<bool> st(n);\\n        dist[node1] = 0;\\n\\n        for (int i = 0; i < n; ++i)\\n        {\\n            int t = -1;\\n            for (int j = 0; j < n; ++j)\\n                if (!st[j] && (t == -1 || dist[t] > dist[j]))\\n                    t = j;\\n            st[t] = true;\\n\\n            for (int j = 0; j < n; ++j)\\n                dist[j] = min(dist[j], dist[t] + g[t][j]);\\n        }\\n\\n        return dist[node2] == INF ? -1 : dist[node2];\\n    }\\n};\\n```\n```cpp\\nclass Graph {\\npublic:\\n    vector<vector<pair<int, int>>> adj;\\n    \\n    Graph(int n, vector<vector<int>>& edge) {\\n        adj.resize(n);\\n        for (auto& e: edge)\\n            adj[e[0]].emplace_back(e[1], e[2]);\\n    }\\n\\n    void addEdge(vector<int> e) {\\n        adj[e[0]].emplace_back(e[1], e[2]);\\n    }\\n\\n    int shortestPath(int node1, int node2) {\\n        vector<int> dist(n);\\n        memset(&dist[0], 0x3f, n * sizeof(int));\\n        vector<bool> st(n);\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> heap;\\n        heap.emplace(0, node1);\\n        dist[node1] = 0;\\n\\n        while (!heap.empty())\\n        {\\n            auto [d, u] = heap.top(); heap.pop();\\n            if (st[u]) continue;\\n            st[u] = true;\\n            for (auto& edge : edges[u])\\n            {\\n                auto [v, w] = edge;\\n                if (dist[v] > dist[u] + w)\\n                {\\n                    dist[v] = dist[u] + w;\\n                    heap.emplace(dist[v], v);\\n                }\\n            }\\n        }\\n\\n        if (dist[node2] == 0x3f3f3f3f) return -1;\\n        return dist[node2];\\n    }\\n};\\n```\n```cpp\\nclass Graph {\\npublic:\\n    static const int N = 100, M = 10000;\\n    int head[N], e[M], ne[M], w[M], idx;\\n    int dist[N];\\n    bool st[N];\\n    \\n    Graph(int n, vector<vector<int>>& edges) {\\n        memset(head, -1, sizeof head);\\n        for (auto& e: edges)\\n            addEdge(e);\\n    }\\n\\n    void addEdge(vector<int> edge) {\\n        int a = edge[0], b = edge[1], c = edge[2];\\n        e[idx] = b, w[idx] = c, ne[idx] = head[a], head[a] = idx++;\\n    }\\n\\n    int shortestPath(int node1, int node2) {\\n        memset(dist, 0x3f, sizeof dist);\\n        memset(st, false, sizeof st);\\n        queue<int> q;\\n        q.push(node1);\\n        dist[node1] = 0;    \\n        st[node1] = true;\\n\\n        while (!q.empty())\\n        {\\n            int t = q.front();\\n            q.pop();\\n\\n            st[t] = false;\\n\\n            for (int i = head[t]; ~i; i = ne[i])\\n            {\\n                int j = e[i];\\n                if (dist[j] > dist[t] + w[i])\\n                {\\n                    dist[j] = dist[t] + w[i];\\n                    if (!st[j]) q.push(j), st[j] = true;\\n                }\\n            }\\n        }\\n\\n        if (dist[node2] == 0x3f3f3f3f) return -1;\\n        return dist[node2];\\n    }\\n};\\n```\n```cpp\\nclass Graph {\\npublic:\\n    vector<vector<int>> d;\\n    Graph(int n, vector<vector<int>>& edges) {\\n        d = vector(n, vector<int>(n, 0x3f3f3f3f));\\n        for (int i = 0; i < n; i++)\\n            d[i][i] = 0;\\n        for (auto& e : edges)\\n            d[e[0]][e[1]] = e[2];\\n        floyd(n);\\n    }\\n    \\n    void addEdge(vector<int> edge) {\\n        int a = edge[0], b = edge[1], w = edge[2];\\n        if (d[a][b] > w)\\n            for (int i = 0; i < d.size(); i++)\\n                for (int j = 0; j < d.size(); j++)\\n                    d[i][j] = min(d[i][j], d[i][a] + w + d[b][j]);\\n    }\\n\\n    int shortestPath(int node1, int node2) {\\n        return d[node1][node2] == 0x3f3f3f3f ? -1 : d[node1][node2];\\n    }\\n    \\nprivate:\\n    void floyd(int n)\\n    {\\n        for (int k = 0; k < n; k++)\\n            for (int i = 0; i < n; i++)\\n                for (int j = 0; j < n; j++)\\n                    d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3423916,
                "title": "dijkstra-s-algorithm-c",
                "content": "```\\nclass Graph {\\n    int n;\\n    unordered_map<int, vector<pair<int, int>>> adj;\\npublic:\\n    Graph(int m, vector<vector<int>>& edges) {\\n        for(auto e : edges) adj[e[0]].push_back({e[1], e[2]});\\n        n = m;\\n    }\\n    \\n    void addEdge(vector<int> e) {\\n        adj[e[0]].push_back({e[1], e[2]});\\n        n++;\\n    }\\n    \\n    int shortestPath(int a, int b) {\\n        vector<int> d(n, 1e9);\\n        d[a] = 0;\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\\n        pq.push({0, a});\\n        \\n        while(pq.size()) {\\n            int dis = pq.top().first, node = pq.top().second;\\n            pq.pop();\\n            if(node == b) return dis;\\n            \\n            for(auto ad : adj[node]) {\\n                if(dis + ad.second < d[ad.first]) {\\n                    d[ad.first] = dis + ad.second;\\n                    pq.push({d[ad.first], ad.first});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph* obj = new Graph(n, edges);\\n * obj->addEdge(edge);\\n * int param_2 = obj->shortestPath(node1,node2);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Shortest Path"
                ],
                "code": "```\\nclass Graph {\\n    int n;\\n    unordered_map<int, vector<pair<int, int>>> adj;\\npublic:\\n    Graph(int m, vector<vector<int>>& edges) {\\n        for(auto e : edges) adj[e[0]].push_back({e[1], e[2]});\\n        n = m;\\n    }\\n    \\n    void addEdge(vector<int> e) {\\n        adj[e[0]].push_back({e[1], e[2]});\\n        n++;\\n    }\\n    \\n    int shortestPath(int a, int b) {\\n        vector<int> d(n, 1e9);\\n        d[a] = 0;\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\\n        pq.push({0, a});\\n        \\n        while(pq.size()) {\\n            int dis = pq.top().first, node = pq.top().second;\\n            pq.pop();\\n            if(node == b) return dis;\\n            \\n            for(auto ad : adj[node]) {\\n                if(dis + ad.second < d[ad.first]) {\\n                    d[ad.first] = dis + ad.second;\\n                    pq.push({d[ad.first], ad.first});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph* obj = new Graph(n, edges);\\n * obj->addEdge(edge);\\n * int param_2 = obj->shortestPath(node1,node2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421303,
                "title": "easy-c-solution-using-dijkstra",
                "content": "# Code\\n```\\nclass Graph {\\npublic:\\n    unordered_map<int, list<pair<int, int>>> adj;\\n    int m = 0;\\n    vector<int> dijkstra(int s) {\\n        vector<int> dist(m, INT_MAX);\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> q;\\n        q.push({s, 0});\\n        dist[s] = 0;\\n        while(!q.empty()) {\\n            auto f = q.top();\\n            q.pop();\\n            \\n            int node = f.first;\\n            int di = f.second;\\n            \\n            for(auto nbr: adj[node]) {\\n                \\n                int n = nbr.first;\\n                int d = nbr.second;\\n                \\n                int total = di + d;\\n                \\n                if(dist[n] > total) {\\n                    dist[n] = total;\\n                    q.push({n, dist[n]});\\n                }\\n            }\\n        }\\n        return dist;\\n    }\\n    Graph(int n, vector<vector<int>>& edges) {\\n        m = n;\\n        for(auto edge: edges) {\\n            adj[edge[0]].push_back({edge[1], edge[2]});\\n        }\\n    }\\n    \\n    void addEdge(vector<int> edge) {\\n        adj[edge[0]].push_back({edge[1], edge[2]});\\n    }\\n    \\n    int shortestPath(int node1, int node2) {\\n        vector<int> ans = dijkstra(node1);\\n        if(ans[node2] != INT_MAX) {\\n            return ans[node2];\\n        }\\n        return -1;\\n    }\\n};\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph* obj = new Graph(n, edges);\\n * obj->addEdge(edge);\\n * int param_2 = obj->shortestPath(node1,node2);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Graph {\\npublic:\\n    unordered_map<int, list<pair<int, int>>> adj;\\n    int m = 0;\\n    vector<int> dijkstra(int s) {\\n        vector<int> dist(m, INT_MAX);\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> q;\\n        q.push({s, 0});\\n        dist[s] = 0;\\n        while(!q.empty()) {\\n            auto f = q.top();\\n            q.pop();\\n            \\n            int node = f.first;\\n            int di = f.second;\\n            \\n            for(auto nbr: adj[node]) {\\n                \\n                int n = nbr.first;\\n                int d = nbr.second;\\n                \\n                int total = di + d;\\n                \\n                if(dist[n] > total) {\\n                    dist[n] = total;\\n                    q.push({n, dist[n]});\\n                }\\n            }\\n        }\\n        return dist;\\n    }\\n    Graph(int n, vector<vector<int>>& edges) {\\n        m = n;\\n        for(auto edge: edges) {\\n            adj[edge[0]].push_back({edge[1], edge[2]});\\n        }\\n    }\\n    \\n    void addEdge(vector<int> edge) {\\n        adj[edge[0]].push_back({edge[1], edge[2]});\\n    }\\n    \\n    int shortestPath(int node1, int node2) {\\n        vector<int> ans = dijkstra(node1);\\n        if(ans[node2] != INT_MAX) {\\n            return ans[node2];\\n        }\\n        return -1;\\n    }\\n};\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph* obj = new Graph(n, edges);\\n * obj->addEdge(edge);\\n * int param_2 = obj->shortestPath(node1,node2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420672,
                "title": "simple-bfs-solution-very-easy-to-understand",
                "content": "\\tclass Graph {\\n\\tpublic:\\n\\n\\t\\tvector<vector<pair<int, int>>> adj;\\n\\t\\tvector<int> inorder;\\n\\t\\tint num = 0;\\n\\t\\tGraph(int n, vector<vector<int>>& edges) \\n\\t\\t{\\n\\t\\t\\tnum = n;\\n\\t\\t\\tadj.resize(n);\\n\\t\\t\\tinorder.resize(n, 0);\\n\\t\\t\\tfor(int i = 0; i < edges.size(); i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint u = edges[i][0];\\n\\t\\t\\t\\tint v = edges[i][1];\\n\\t\\t\\t\\tint cost = edges[i][2];\\n\\n\\t\\t\\t\\tadj[u].push_back({v, cost});\\n\\t\\t\\t\\tinorder[v]++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tvoid addEdge(vector<int> edge) \\n\\t\\t{\\n\\t\\t\\tint u = edge[0];\\n\\t\\t\\tint v = edge[1];\\n\\t\\t\\tint cost = edge[2];\\n\\n\\t\\t\\tadj[u].push_back({v, cost});\\n\\t\\t}\\n\\n\\n\\n\\t\\tint shortestPath(int node1, int node2) \\n\\t\\t{        \\n\\t\\t\\tvector<int> dis(num, INT_MAX);\\n\\t\\t\\tdis[node1] = 0;\\n\\n\\t\\t\\tqueue<int> q;\\n\\t\\t\\tq.push(node1);\\n\\n\\t\\t\\twhile(!q.empty())\\n\\t\\t\\t{\\n\\t\\t\\t\\tint temp = q.front();\\n\\t\\t\\t\\tq.pop();\\n\\n\\t\\t\\t\\tfor(auto i : adj[temp])\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint u = i.first;\\n\\t\\t\\t\\t\\tint c = i.second;\\n\\n\\t\\t\\t\\t\\tif(dis[u] > dis[temp] + c)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tdis[u] = dis[temp]+c;\\n\\t\\t\\t\\t\\t\\tq.push(u);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tif(dis[node2] != INT_MAX)\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn dis[node2];\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t\\treturn -1;\\n\\n\\t\\t}\\n\\t};\\n",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "\\tclass Graph {\\n\\tpublic:\\n\\n\\t\\tvector<vector<pair<int, int>>> adj;\\n\\t\\tvector<int> inorder;\\n\\t\\tint num = 0;\\n\\t\\tGraph(int n, vector<vector<int>>& edges) \\n\\t\\t{\\n\\t\\t\\tnum = n;\\n\\t\\t\\tadj.resize(n);\\n\\t\\t\\tinorder.resize(n, 0);\\n\\t\\t\\tfor(int i = 0; i < edges.size(); i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint u = edges[i][0];\\n\\t\\t\\t\\tint v = edges[i][1];\\n\\t\\t\\t\\tint cost = edges[i][2];\\n\\n\\t\\t\\t\\tadj[u].push_back({v, cost});\\n\\t\\t\\t\\tinorder[v]++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tvoid addEdge(vector<int> edge) \\n\\t\\t{\\n\\t\\t\\tint u = edge[0];\\n\\t\\t\\tint v = edge[1];\\n\\t\\t\\tint cost = edge[2];\\n\\n\\t\\t\\tadj[u].push_back({v, cost});\\n\\t\\t}\\n\\n\\n\\n\\t\\tint shortestPath(int node1, int node2) \\n\\t\\t{        \\n\\t\\t\\tvector<int> dis(num, INT_MAX);\\n\\t\\t\\tdis[node1] = 0;\\n\\n\\t\\t\\tqueue<int> q;\\n\\t\\t\\tq.push(node1);\\n\\n\\t\\t\\twhile(!q.empty())\\n\\t\\t\\t{\\n\\t\\t\\t\\tint temp = q.front();\\n\\t\\t\\t\\tq.pop();\\n\\n\\t\\t\\t\\tfor(auto i : adj[temp])\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint u = i.first;\\n\\t\\t\\t\\t\\tint c = i.second;\\n\\n\\t\\t\\t\\t\\tif(dis[u] > dis[temp] + c)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tdis[u] = dis[temp]+c;\\n\\t\\t\\t\\t\\t\\tq.push(u);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tif(dis[node2] != INT_MAX)\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn dis[node2];\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t\\treturn -1;\\n\\n\\t\\t}\\n\\t};\\n",
                "codeTag": "Java"
            },
            {
                "id": 3420409,
                "title": "c-dijkstra-definitely-a-medium",
                "content": "## Explanation\\nNot a hard problem tbh !! Use Dijkstra to find the shortest path !!\\n\\n## Code\\n```\\nclass Graph {\\npublic:\\n    \\n    vector<vector<pair<int,int>>>e;\\n    int nodes;\\n    \\n    Graph(int n, vector<vector<int>>& edges) {\\n        e.resize(n);\\n        for(auto &it:edges){\\n            e[it[0]].push_back({it[1],it[2]});\\n        }\\n        nodes=n;\\n    }\\n    \\n    void addEdge(vector<int> edge) {\\n        e[edge[0]].push_back({edge[1],edge[2]});\\n        \\n    }\\n    \\n    int shortestPath(int node1, int node2) {\\n        vector<int> dist(nodes, numeric_limits<int>::max());\\n        dist[node1] = 0;\\n\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq; \\n        pq.push(make_pair(0, node1)); \\n        while (!pq.empty()) {\\n            int curr_dist = pq.top().first;\\n            int curr_node = pq.top().second;\\n            pq.pop(); \\n\\n            if (curr_node == node2) {\\n                return curr_dist;\\n            }\\n\\n            for (auto neighbor : e[curr_node]) {\\n                int next_node = neighbor.first;\\n                int edge_cost = neighbor.second;\\n                if (curr_dist + edge_cost < dist[next_node]) {\\n                    dist[next_node] = curr_dist + edge_cost; \\n                    pq.push(make_pair(dist[next_node], next_node));\\n                }\\n            }\\n        }\\n\\n        return -1; \\n    }\\n};\\n\\n```\\n\\n## Complexity\\n- Time complexity:\\n    Add Edge - $$O(1)$$\\n    Shortest Path - $$O(V*E)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n    Adjacency List - $$O(V*E)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Graph"
                ],
                "code": "```\\nclass Graph {\\npublic:\\n    \\n    vector<vector<pair<int,int>>>e;\\n    int nodes;\\n    \\n    Graph(int n, vector<vector<int>>& edges) {\\n        e.resize(n);\\n        for(auto &it:edges){\\n            e[it[0]].push_back({it[1],it[2]});\\n        }\\n        nodes=n;\\n    }\\n    \\n    void addEdge(vector<int> edge) {\\n        e[edge[0]].push_back({edge[1],edge[2]});\\n        \\n    }\\n    \\n    int shortestPath(int node1, int node2) {\\n        vector<int> dist(nodes, numeric_limits<int>::max());\\n        dist[node1] = 0;\\n\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq; \\n        pq.push(make_pair(0, node1)); \\n        while (!pq.empty()) {\\n            int curr_dist = pq.top().first;\\n            int curr_node = pq.top().second;\\n            pq.pop(); \\n\\n            if (curr_node == node2) {\\n                return curr_dist;\\n            }\\n\\n            for (auto neighbor : e[curr_node]) {\\n                int next_node = neighbor.first;\\n                int edge_cost = neighbor.second;\\n                if (curr_dist + edge_cost < dist[next_node]) {\\n                    dist[next_node] = curr_dist + edge_cost; \\n                    pq.push(make_pair(dist[next_node], next_node));\\n                }\\n            }\\n        }\\n\\n        return -1; \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420350,
                "title": "c-dijkstra-algorithm-and-update-distance",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWhen add edge from a to b, distance is w,\\nfor all pair`(i, j)`the distance change is `i->a` + `a->b` + `b->j` \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Constructor, using dijkstra algorithm to build all pair`(i, j)` distance, \\n   and stored into `dist[i][j]`\\n2. function: `addEdge(a, b, w)`\\n   case 1: `dist[a][b] <= w`, directly return.\\n   \\n   case 2: `dist[a][b] > w`, update `dist[a][b] = w`\\n   scan all of pairs(i, j) update `dist[i][j]`\\n   ```\\n   for(int i = 0 ;  i < n ; i++)\\n      for(int j = 0 ; j < n ; j++)\\n          dist[i][j] = dist[i][a] + dist[a][b] + dist[b][j]);\\n   ```\\n3. function: `shortestPath(node1, node2)`\\n   directly return `dist[node1][node2]`\\n    \\n# Complexity\\n- Time complexity: O(max(Elog(V), V ^ 2)) (Dijkstra)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(max(E + V, V ^ 2))\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Graph {\\npublic:\\n    vector<vector<pair<int, int>>> adj;\\n    vector<vector<int>> dist;\\n    int node_cnt;\\n    \\n    void get_shortest_len(int src) {\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\\n        vector<int> visited(node_cnt, INT32_MAX);\\n        \\n        pq.push({0, src});\\n        visited[src] = 0;\\n        \\n        while(!pq.empty()) {\\n            int node_weight = pq.top().first;\\n            int node = pq.top().second;\\n            pq.pop();\\n            if(visited[node] < node_weight) {\\n                continue;\\n            }\\n            \\n            for(int i = 0 ; i < adj[node].size() ; i++) {\\n                int next = adj[node][i].first;\\n                int next_weight = adj[node][i].second;\\n                \\n                if(visited[next] <= (node_weight + next_weight)) {\\n                    continue;\\n                }\\n                visited[next] = node_weight + next_weight;\\n                pq.push({node_weight + next_weight, next});\\n            }\\n        }\\n        \\n        for(int i = 0 ; i < node_cnt ; i++) {\\n            dist[src][i] = visited[i];\\n        }\\n        \\n    }\\n    Graph(int n, vector<vector<int>>& edges) {\\n        adj.clear();\\n        adj.resize(n);\\n        dist.resize(n, vector<int>(n, INT32_MAX));\\n        node_cnt = n;\\n        \\n        for(vector<int> &v : edges) {\\n            adj[v[0]].push_back({v[1], v[2]});\\n        }\\n        \\n        for(int i = 0 ; i < n ; i++) {\\n            get_shortest_len(i);\\n        }\\n    }\\n    \\n    void addEdge(vector<int> edge) {\\n        int a = edge[0];\\n        int b = edge[1];\\n        int w = edge[2];\\n        if(dist[a][b] <= w) {\\n            return;\\n        }\\n        dist[a][b] = w;\\n        \\n        for(int i = 0 ; i < node_cnt ; i++) {\\n            for(int j = 0 ; j < node_cnt ; j++) {\\n                if((i != j) && (dist[i][a] < INT32_MAX) && (dist[b][j] < INT32_MAX))  {\\n                    dist[i][j] = min(dist[i][j], dist[i][a] + dist[a][b] + dist[b][j]);\\n                }\\n            }\\n        }\\n    }\\n    \\n    int shortestPath(int node1, int node2) {\\n        return dist[node1][node2] == INT32_MAX ? -1: dist[node1][node2];\\n    }\\n};\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph* obj = new Graph(n, edges);\\n * obj->addEdge(edge);\\n * int param_2 = obj->shortestPath(node1,node2);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n   for(int i = 0 ;  i < n ; i++)\\n      for(int j = 0 ; j < n ; j++)\\n          dist[i][j] = dist[i][a] + dist[a][b] + dist[b][j]);\\n   ```\n```\\nclass Graph {\\npublic:\\n    vector<vector<pair<int, int>>> adj;\\n    vector<vector<int>> dist;\\n    int node_cnt;\\n    \\n    void get_shortest_len(int src) {\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\\n        vector<int> visited(node_cnt, INT32_MAX);\\n        \\n        pq.push({0, src});\\n        visited[src] = 0;\\n        \\n        while(!pq.empty()) {\\n            int node_weight = pq.top().first;\\n            int node = pq.top().second;\\n            pq.pop();\\n            if(visited[node] < node_weight) {\\n                continue;\\n            }\\n            \\n            for(int i = 0 ; i < adj[node].size() ; i++) {\\n                int next = adj[node][i].first;\\n                int next_weight = adj[node][i].second;\\n                \\n                if(visited[next] <= (node_weight + next_weight)) {\\n                    continue;\\n                }\\n                visited[next] = node_weight + next_weight;\\n                pq.push({node_weight + next_weight, next});\\n            }\\n        }\\n        \\n        for(int i = 0 ; i < node_cnt ; i++) {\\n            dist[src][i] = visited[i];\\n        }\\n        \\n    }\\n    Graph(int n, vector<vector<int>>& edges) {\\n        adj.clear();\\n        adj.resize(n);\\n        dist.resize(n, vector<int>(n, INT32_MAX));\\n        node_cnt = n;\\n        \\n        for(vector<int> &v : edges) {\\n            adj[v[0]].push_back({v[1], v[2]});\\n        }\\n        \\n        for(int i = 0 ; i < n ; i++) {\\n            get_shortest_len(i);\\n        }\\n    }\\n    \\n    void addEdge(vector<int> edge) {\\n        int a = edge[0];\\n        int b = edge[1];\\n        int w = edge[2];\\n        if(dist[a][b] <= w) {\\n            return;\\n        }\\n        dist[a][b] = w;\\n        \\n        for(int i = 0 ; i < node_cnt ; i++) {\\n            for(int j = 0 ; j < node_cnt ; j++) {\\n                if((i != j) && (dist[i][a] < INT32_MAX) && (dist[b][j] < INT32_MAX))  {\\n                    dist[i][j] = min(dist[i][j], dist[i][a] + dist[a][b] + dist[b][j]);\\n                }\\n            }\\n        }\\n    }\\n    \\n    int shortestPath(int node1, int node2) {\\n        return dist[node1][node2] == INT32_MAX ? -1: dist[node1][node2];\\n    }\\n};\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph* obj = new Graph(n, edges);\\n * obj->addEdge(edge);\\n * int param_2 = obj->shortestPath(node1,node2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420094,
                "title": "c-simple-dijkstra",
                "content": "```\\nclass Graph {\\npublic:\\n    vector<vector<vector<int>>> g;\\n    int N;\\n    Graph(int n, vector<vector<int>>& edges) {\\n        g.resize(n);\\n        N = n;\\n        for(auto &x: edges) {\\n            g[x[0]].push_back({x[1],x[2]});\\n        }\\n        \\n    }\\n    \\n    void addEdge(vector<int> edge) {\\n        g[edge[0]].push_back({edge[1],edge[2]});\\n\\n    }\\n    \\n    int shortestPath(int node1, int node2) {\\n        priority_queue<pair<int,int>,vector<pair<int,int>>, greater<>> pq;\\n        \\n        pq.push({0,node1});\\n        \\n        while(pq.size()) {\\n            int cst = pq.top().first, node = pq.top().second;\\n            pq.pop();\\n            for(auto &x: g[node]) {\\n                if(cost[x[0]] > cst+x[1]) {\\n                    cost[x[0]] = cst+x[1];\\n                    pq.push({cost[x[0]],x[0]});\\n                }\\n            }\\n        }\\n        \\n        return cost[node2] >= 1e9 ? -1 : cost[node2];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Graph {\\npublic:\\n    vector<vector<vector<int>>> g;\\n    int N;\\n    Graph(int n, vector<vector<int>>& edges) {\\n        g.resize(n);\\n        N = n;\\n        for(auto &x: edges) {\\n            g[x[0]].push_back({x[1],x[2]});\\n        }\\n        \\n    }\\n    \\n    void addEdge(vector<int> edge) {\\n        g[edge[0]].push_back({edge[1],edge[2]});\\n\\n    }\\n    \\n    int shortestPath(int node1, int node2) {\\n        priority_queue<pair<int,int>,vector<pair<int,int>>, greater<>> pq;\\n        \\n        pq.push({0,node1});\\n        \\n        while(pq.size()) {\\n            int cst = pq.top().first, node = pq.top().second;\\n            pq.pop();\\n            for(auto &x: g[node]) {\\n                if(cost[x[0]] > cst+x[1]) {\\n                    cost[x[0]] = cst+x[1];\\n                    pq.push({cost[x[0]],x[0]});\\n                }\\n            }\\n        }\\n        \\n        return cost[node2] >= 1e9 ? -1 : cost[node2];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420043,
                "title": "dijkstra-java",
                "content": "\\n\\n# Code\\n```\\nclass Graph {\\n    List<List<int[]>> adj=new ArrayList<>();\\n    int n;\\n    public Graph(int n, int[][] edges) {\\n        for(int i=0;i<n;i++){\\n            adj.add(new ArrayList<>());\\n        }\\n        this.n=n;\\n        for(int edge[]: edges){\\n            adj.get(edge[0]).add(new int[]{edge[1],edge[2]});\\n        }\\n    }\\n    \\n    public void addEdge(int[] edge) {\\n        adj.get(edge[0]).add(new int[]{edge[1],edge[2]});\\n    }\\n    \\n    public int shortestPath(int node1, int node2) {\\n        int dist[]=new int[n+1];\\n        Arrays.fill(dist,Integer.MAX_VALUE);\\n        dist[node1]=0;\\n        PriorityQueue<int[]> pq=new PriorityQueue<>((a,b)->a[1]-b[1]);\\n        pq.add(new int[]{node1,0});\\n        while(!pq.isEmpty()){\\n            int u=pq.poll()[0];\\n            for(int p[]: adj.get(u)){\\n                int v=p[0];\\n                int w=p[1];\\n                if(dist[v]>dist[u]+w){\\n                    dist[v]=dist[u]+w;\\n                    pq.add(new int[]{v,dist[v]});\\n                }\\n            }\\n        }\\n        if(dist[node2]==Integer.MAX_VALUE){\\n                return -1;\\n        }\\n        return dist[node2];\\n    }\\n    \\n}\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph obj = new Graph(n, edges);\\n * obj.addEdge(edge);\\n * int param_2 = obj.shortestPath(node1,node2);\\n */",
                "solutionTags": [
                    "Java"
                ],
                "code": "\\n\\n# Code\\n```\\nclass Graph {\\n    List<List<int[]>> adj=new ArrayList<>();\\n    int n;\\n    public Graph(int n, int[][] edges) {\\n        for(int i=0;i<n;i++){\\n            adj.add(new ArrayList<>());\\n        }\\n        this.n=n;\\n        for(int edge[]: edges){\\n            adj.get(edge[0]).add(new int[]{edge[1],edge[2]});\\n        }\\n    }\\n    \\n    public void addEdge(int[] edge) {\\n        adj.get(edge[0]).add(new int[]{edge[1],edge[2]});\\n    }\\n    \\n    public int shortestPath(int node1, int node2) {\\n        int dist[]=new int[n+1];\\n        Arrays.fill(dist,Integer.MAX_VALUE);\\n        dist[node1]=0;\\n        PriorityQueue<int[]> pq=new PriorityQueue<>((a,b)->a[1]-b[1]);\\n        pq.add(new int[]{node1,0});\\n        while(!pq.isEmpty()){\\n            int u=pq.poll()[0];\\n            for(int p[]: adj.get(u)){\\n                int v=p[0];\\n                int w=p[1];\\n                if(dist[v]>dist[u]+w){\\n                    dist[v]=dist[u]+w;\\n                    pq.add(new int[]{v,dist[v]});\\n                }\\n            }\\n        }\\n        if(dist[node2]==Integer.MAX_VALUE){\\n                return -1;\\n        }\\n        return dist[node2];\\n    }\\n    \\n}\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph obj = new Graph(n, edges);\\n * obj.addEdge(edge);\\n * int param_2 = obj.shortestPath(node1,node2);\\n */",
                "codeTag": "Java"
            },
            {
                "id": 3419984,
                "title": "easy-short-efficient-clean-code",
                "content": "```\\nclass Graph {\\npublic:\\ntypedef long long ll;\\n#define vi(x) vector<x>\\n\\nvector<vector<pair<ll, ll>>>g;\\nll n;\\n\\nll shortestPath(ll s, ll dest) { // dijkstra-dense ; for max edges; O(v^2)\\n        vi(ll)d(n, LLONG_MAX); // dist of the shortest path from src to every node\\n        bitset<100>vis(0);\\n        d[s] = 0;\\n        for (ll i = 0; i < n; i++) {\\n            ll v = -1;\\n            for (ll j = 0; j < n; j++) {\\n                if (!vis[j] && (v == -1 || d[j] < d[v])){\\n                    v = j;\\n                }\\n            }\\n            if (v==-1 || d[v] == LLONG_MAX){\\n                break;\\n            }\\n            vis[v] = true;\\n            for (const auto&[to, w] : g[v]) {\\n                if (d[v] + w < d[to]) {\\n                    d[to] = d[v] + w;\\n                }\\n            }\\n        }\\n        return (d[dest]==LLONG_MAX?-1:d[dest]); // path not found \\n    }\\n\\n    Graph(int N, const vi(vi(int))& edges) {\\n        n=N;\\n        g.resize(n);\\n        for(const auto&edge:edges){\\n            addEdge(edge);\\n        }\\n    }\\n    \\n    void addEdge(const vi(int)&edge) {\\n        g[edge[0]].push_back({edge[1], edge[2]});\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Graph {\\npublic:\\ntypedef long long ll;\\n#define vi(x) vector<x>\\n\\nvector<vector<pair<ll, ll>>>g;\\nll n;\\n\\nll shortestPath(ll s, ll dest) { // dijkstra-dense ; for max edges; O(v^2)\\n        vi(ll)d(n, LLONG_MAX); // dist of the shortest path from src to every node\\n        bitset<100>vis(0);\\n        d[s] = 0;\\n        for (ll i = 0; i < n; i++) {\\n            ll v = -1;\\n            for (ll j = 0; j < n; j++) {\\n                if (!vis[j] && (v == -1 || d[j] < d[v])){\\n                    v = j;\\n                }\\n            }\\n            if (v==-1 || d[v] == LLONG_MAX){\\n                break;\\n            }\\n            vis[v] = true;\\n            for (const auto&[to, w] : g[v]) {\\n                if (d[v] + w < d[to]) {\\n                    d[to] = d[v] + w;\\n                }\\n            }\\n        }\\n        return (d[dest]==LLONG_MAX?-1:d[dest]); // path not found \\n    }\\n\\n    Graph(int N, const vi(vi(int))& edges) {\\n        n=N;\\n        g.resize(n);\\n        for(const auto&edge:edges){\\n            addEdge(edge);\\n        }\\n    }\\n    \\n    void addEdge(const vi(int)&edge) {\\n        g[edge[0]].push_back({edge[1], edge[2]});\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4059471,
                "title": "simple-java-solution",
                "content": "# Code\\n```\\n\\tclass Graph {\\n\\t\\tint n;\\n\\t\\tList<List<int[]>> adjacents;\\n\\n\\t\\tpublic Graph(int n, int[][] edges) {\\n\\t\\t\\tthis.n = n;\\n\\t\\t\\tadjacents = new ArrayList<>();\\n\\t\\t\\tfor (int i = 0; i < n; i++)\\n\\t\\t\\t\\tadjacents.add(new ArrayList<>());\\n\\t\\t\\tfor (int[] edge : edges)\\n\\t\\t\\t\\tadjacents.get(edge[0]).add(new int[] { edge[1], edge[2] });\\n\\t\\t}\\n\\n\\t\\tpublic void addEdge(int[] edge) {\\n\\t\\t\\tadjacents.get(edge[0]).add(new int[] { edge[1], edge[2] });\\n\\t\\t}\\n\\n\\t\\tpublic int shortestPath(int node1, int node2) {\\n\\t\\t\\tPriorityQueue<int[]> q = new PriorityQueue<>((a, b) -> a[1] - b[1]);\\n\\t\\t\\tq.add(new int[] { node1, 0 });\\n\\t\\t\\tboolean[] visited = new boolean[n];\\n\\t\\t\\twhile (!q.isEmpty()) {\\n\\t\\t\\t\\tint[] point = q.poll();\\n\\t\\t\\t\\tint u = point[0];\\n\\t\\t\\t\\tint w = point[1];\\n\\t\\t\\t\\tif (visited[u])\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\tvisited[u] = true;\\n\\t\\t\\t\\tif (u == node2)\\n\\t\\t\\t\\t\\treturn w;\\n\\t\\t\\t\\tfor (int[] adj : adjacents.get(u)) {\\n\\t\\t\\t\\t\\tif (!visited[adj[0]]) {\\n\\t\\t\\t\\t\\t\\tq.offer(new int[] { adj[0], adj[1] + w });\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n\\t}\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph obj = new Graph(n, edges);\\n * obj.addEdge(edge);\\n * int param_2 = obj.shortestPath(node1,node2);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\tclass Graph {\\n\\t\\tint n;\\n\\t\\tList<List<int[]>> adjacents;\\n\\n\\t\\tpublic Graph(int n, int[][] edges) {\\n\\t\\t\\tthis.n = n;\\n\\t\\t\\tadjacents = new ArrayList<>();\\n\\t\\t\\tfor (int i = 0; i < n; i++)\\n\\t\\t\\t\\tadjacents.add(new ArrayList<>());\\n\\t\\t\\tfor (int[] edge : edges)\\n\\t\\t\\t\\tadjacents.get(edge[0]).add(new int[] { edge[1], edge[2] });\\n\\t\\t}\\n\\n\\t\\tpublic void addEdge(int[] edge) {\\n\\t\\t\\tadjacents.get(edge[0]).add(new int[] { edge[1], edge[2] });\\n\\t\\t}\\n\\n\\t\\tpublic int shortestPath(int node1, int node2) {\\n\\t\\t\\tPriorityQueue<int[]> q = new PriorityQueue<>((a, b) -> a[1] - b[1]);\\n\\t\\t\\tq.add(new int[] { node1, 0 });\\n\\t\\t\\tboolean[] visited = new boolean[n];\\n\\t\\t\\twhile (!q.isEmpty()) {\\n\\t\\t\\t\\tint[] point = q.poll();\\n\\t\\t\\t\\tint u = point[0];\\n\\t\\t\\t\\tint w = point[1];\\n\\t\\t\\t\\tif (visited[u])\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\tvisited[u] = true;\\n\\t\\t\\t\\tif (u == node2)\\n\\t\\t\\t\\t\\treturn w;\\n\\t\\t\\t\\tfor (int[] adj : adjacents.get(u)) {\\n\\t\\t\\t\\t\\tif (!visited[adj[0]]) {\\n\\t\\t\\t\\t\\t\\tq.offer(new int[] { adj[0], adj[1] + w });\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n\\t}\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph obj = new Graph(n, edges);\\n * obj.addEdge(edge);\\n * int param_2 = obj.shortestPath(node1,node2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3948471,
                "title": "bellman-ford-java-algorithm",
                "content": "Solution using Bellman Ford Algorithm. Add a variable flag, which will make sure to break the loop in case there is no change in table between two iterations.\\n```\\nclass Graph {\\n    int n;\\n    ArrayList<int[]> edges;\\n    public Graph(int n, int[][] edges) {\\n        this.n = n;\\n        this.edges = new ArrayList<>();\\n        for(int[] edge: edges) {\\n            this.edges.add(edge);\\n        } \\n    }\\n    \\n    public void addEdge(int[] edge) {\\n        edges.add(edge);\\n    }\\n    \\n    public int shortestPath(int node1, int node2) {\\n        int[] table = new int[n];\\n        Arrays.fill(table, Integer.MAX_VALUE);\\n        table[node1] = 0;\\n        for(int i=0;i<n;i++) {\\n            boolean flag = false;\\n            for(int[] edge: edges) {\\n                if(table[edge[0]] == Integer.MAX_VALUE) continue;\\n                if(table[edge[1]] > edge[2] + table[edge[0]]) {\\n                    flag = true;\\n                    table[edge[1]] = edge[2] + table[edge[0]];\\n                }\\n            }\\n            if(flag==false) break;\\n        }\\n        return table[node2] == Integer.MAX_VALUE ? -1 : table[node2];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Graph {\\n    int n;\\n    ArrayList<int[]> edges;\\n    public Graph(int n, int[][] edges) {\\n        this.n = n;\\n        this.edges = new ArrayList<>();\\n        for(int[] edge: edges) {\\n            this.edges.add(edge);\\n        } \\n    }\\n    \\n    public void addEdge(int[] edge) {\\n        edges.add(edge);\\n    }\\n    \\n    public int shortestPath(int node1, int node2) {\\n        int[] table = new int[n];\\n        Arrays.fill(table, Integer.MAX_VALUE);\\n        table[node1] = 0;\\n        for(int i=0;i<n;i++) {\\n            boolean flag = false;\\n            for(int[] edge: edges) {\\n                if(table[edge[0]] == Integer.MAX_VALUE) continue;\\n                if(table[edge[1]] > edge[2] + table[edge[0]]) {\\n                    flag = true;\\n                    table[edge[1]] = edge[2] + table[edge[0]];\\n                }\\n            }\\n            if(flag==false) break;\\n        }\\n        return table[node2] == Integer.MAX_VALUE ? -1 : table[node2];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3907276,
                "title": "c-solution",
                "content": "\\n\\n# Code\\n```\\ntypedef pair<int,int> pii;\\nclass Graph {\\npublic:\\nvector<vector<pair<int,int>>>adj;\\nint n;\\n    Graph(int n, vector<vector<int>>& edges) {\\n        adj.resize(n);\\n        this->n=n;\\n        for (auto it:edges)\\n        {\\n            adj[it[0]].push_back({it[1],it[2]});\\n        }\\n    }\\n    \\n    void addEdge(vector<int> edge) {\\n        adj[edge[0]].push_back({edge[1],edge[2]});\\n    }\\n    void dfs(int node,vector<int>&vis,stack<int>&st)\\n    {\\n        vis[node]=1;\\n        for (auto it: adj[node])\\n        {\\n          if (vis[it.first]==0)\\n          {\\n              dfs(it.first,vis,st);\\n          }\\n        }\\n        st.push(node);\\n    }\\n    int shortestPath(int node1, int node2) \\n    {\\n        stack<int>st;\\n        vector<int>vis(n,0);\\n        // for (int i=0;i<n;i++)\\n        // {\\n        //     if (vis[i]==0)\\n        //     {\\n        //         dfs(i,vis,st);\\n        //     }\\n        // }\\n        vector<int>dist(n,INT_MAX);\\n        dist[node1]=0;\\n        priority_queue<pii,vector<pii>,greater<pii>>pq;\\n         pq.push({0,node1});\\n        // while(!st.empty())\\n        // {\\n        //     int node=st.top();\\n        //     st.pop();\\n        //     if (dist[node]!=INT_MAX)\\n        //     {\\n        //         for (auto it: adj[node])\\n        //         {\\n        //             if (dist[it.first]>dist[node]+it.second)\\n        //             {\\n        //                 dist[it.first]=dist[node]+it.second;\\n        //             }\\n        //         }\\n        //     }\\n        // }\\n\\n        while(!pq.empty())\\n        {\\n            auto temp=pq.top();\\n            int node=temp.second;\\n            pq.pop();\\n            for (auto it: adj[node])\\n            {\\n                if (dist[it.first]>dist[node]+it.second)\\n                {\\n                  dist[it.first]=dist[node]+it.second;\\n                  pq.push({dist[it.first],it.first});\\n                }\\n            }\\n        }\\n        if (dist[node2]==INT_MAX) return -1;\\n        return dist[node2];\\n\\n    }\\n};\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph* obj = new Graph(n, edges);\\n * obj->addEdge(edge);\\n * int param_2 = obj->shortestPath(node1,node2);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\ntypedef pair<int,int> pii;\\nclass Graph {\\npublic:\\nvector<vector<pair<int,int>>>adj;\\nint n;\\n    Graph(int n, vector<vector<int>>& edges) {\\n        adj.resize(n);\\n        this->n=n;\\n        for (auto it:edges)\\n        {\\n            adj[it[0]].push_back({it[1],it[2]});\\n        }\\n    }\\n    \\n    void addEdge(vector<int> edge) {\\n        adj[edge[0]].push_back({edge[1],edge[2]});\\n    }\\n    void dfs(int node,vector<int>&vis,stack<int>&st)\\n    {\\n        vis[node]=1;\\n        for (auto it: adj[node])\\n        {\\n          if (vis[it.first]==0)\\n          {\\n              dfs(it.first,vis,st);\\n          }\\n        }\\n        st.push(node);\\n    }\\n    int shortestPath(int node1, int node2) \\n    {\\n        stack<int>st;\\n        vector<int>vis(n,0);\\n        // for (int i=0;i<n;i++)\\n        // {\\n        //     if (vis[i]==0)\\n        //     {\\n        //         dfs(i,vis,st);\\n        //     }\\n        // }\\n        vector<int>dist(n,INT_MAX);\\n        dist[node1]=0;\\n        priority_queue<pii,vector<pii>,greater<pii>>pq;\\n         pq.push({0,node1});\\n        // while(!st.empty())\\n        // {\\n        //     int node=st.top();\\n        //     st.pop();\\n        //     if (dist[node]!=INT_MAX)\\n        //     {\\n        //         for (auto it: adj[node])\\n        //         {\\n        //             if (dist[it.first]>dist[node]+it.second)\\n        //             {\\n        //                 dist[it.first]=dist[node]+it.second;\\n        //             }\\n        //         }\\n        //     }\\n        // }\\n\\n        while(!pq.empty())\\n        {\\n            auto temp=pq.top();\\n            int node=temp.second;\\n            pq.pop();\\n            for (auto it: adj[node])\\n            {\\n                if (dist[it.first]>dist[node]+it.second)\\n                {\\n                  dist[it.first]=dist[node]+it.second;\\n                  pq.push({dist[it.first],it.first});\\n                }\\n            }\\n        }\\n        if (dist[node2]==INT_MAX) return -1;\\n        return dist[node2];\\n\\n    }\\n};\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph* obj = new Graph(n, edges);\\n * obj->addEdge(edge);\\n * int param_2 = obj->shortestPath(node1,node2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3905184,
                "title": "floyd-warshall-take-only-distance-no-new-edge-update-needed",
                "content": "# Floyd Warshall || Take only distance no edge update\\n```\\nclass Graph {\\npublic:\\n    int N=0;\\n    vector<vector<long long>> dis;\\n    Graph(int n, vector<vector<int>>& edges) \\n    {\\n        this->N=n;\\n        std::vector<std::vector<long long>> Dis(100, std::vector<long long>(100, INT_MAX));\\n        dis=Dis;\\n        for(auto x: edges)\\n            dis[x[0]][x[1]]=x[2];\\n\\n        for(int k=0;k<N;k++)\\n        for(int i=0;i<N;i++)   \\n        for(int j=0;j<N;j++)\\n            {if(i==j) dis[i][j]=0;\\n            dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]);}\\n    }\\n    \\n    void addEdge(vector<int> edge) \\n    {\\n        for(int i=0;i<N;i++)   \\n        for(int j=0;j<N;j++)\\n            {if(i==j) dis[i][j]=0;\\n            dis[i][j]=min(dis[i][j],dis[i][edge[0]]+edge[2]+dis[edge[1]][j]);}\\n    }\\n    \\n    \\n    int shortestPath(int node1, int node2) \\n    {\\n        if (dis[node1][node2]>=INT_MAX)\\n            return -1;\\n        return dis[node1][node2];\\n\\n    }\\n};\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph* obj = new Graph(n, edges);\\n * obj->addEdge(edge);\\n * int param_2 = obj->shortestPath(node1,node2);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Graph {\\npublic:\\n    int N=0;\\n    vector<vector<long long>> dis;\\n    Graph(int n, vector<vector<int>>& edges) \\n    {\\n        this->N=n;\\n        std::vector<std::vector<long long>> Dis(100, std::vector<long long>(100, INT_MAX));\\n        dis=Dis;\\n        for(auto x: edges)\\n            dis[x[0]][x[1]]=x[2];\\n\\n        for(int k=0;k<N;k++)\\n        for(int i=0;i<N;i++)   \\n        for(int j=0;j<N;j++)\\n            {if(i==j) dis[i][j]=0;\\n            dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]);}\\n    }\\n    \\n    void addEdge(vector<int> edge) \\n    {\\n        for(int i=0;i<N;i++)   \\n        for(int j=0;j<N;j++)\\n            {if(i==j) dis[i][j]=0;\\n            dis[i][j]=min(dis[i][j],dis[i][edge[0]]+edge[2]+dis[edge[1]][j]);}\\n    }\\n    \\n    \\n    int shortestPath(int node1, int node2) \\n    {\\n        if (dis[node1][node2]>=INT_MAX)\\n            return -1;\\n        return dis[node1][node2];\\n\\n    }\\n};\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph* obj = new Graph(n, edges);\\n * obj->addEdge(edge);\\n * int param_2 = obj->shortestPath(node1,node2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3899300,
                "title": "solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Graph {\\n public:\\n  Graph(int n, vector<vector<int>>& edges) {\\n    graph.resize(n);\\n    for (const vector<int>& edge : edges)\\n      addEdge(edge);\\n  }\\n\\n  void addEdge(vector<int> edge) {\\n    const int u = edge[0];\\n    const int v = edge[1];\\n    const int w = edge[2];\\n    graph[u].emplace_back(v, w);\\n  }\\n\\n  int shortestPath(int node1, int node2) {\\n    vector<int> dist(graph.size(), INT_MAX);\\n    using P = pair<int, int>;  // (d, u)\\n    priority_queue<P, vector<P>, greater<>> minHeap;\\n\\n    dist[node1] = 0;\\n    minHeap.emplace(dist[node1], node1);\\n\\n    while (!minHeap.empty()) {\\n      const auto [d, u] = minHeap.top();\\n      minHeap.pop();\\n      if (u == node2)\\n        return d;\\n      for (const auto& [v, w] : graph[u])\\n        if (d + w < dist[v]) {\\n          dist[v] = d + w;\\n          minHeap.emplace(dist[v], v);\\n        }\\n    }\\n\\n    return -1;\\n  }\\n\\n private:\\n  vector<vector<pair<int, int>>> graph;\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Graph {\\n public:\\n  Graph(int n, vector<vector<int>>& edges) {\\n    graph.resize(n);\\n    for (const vector<int>& edge : edges)\\n      addEdge(edge);\\n  }\\n\\n  void addEdge(vector<int> edge) {\\n    const int u = edge[0];\\n    const int v = edge[1];\\n    const int w = edge[2];\\n    graph[u].emplace_back(v, w);\\n  }\\n\\n  int shortestPath(int node1, int node2) {\\n    vector<int> dist(graph.size(), INT_MAX);\\n    using P = pair<int, int>;  // (d, u)\\n    priority_queue<P, vector<P>, greater<>> minHeap;\\n\\n    dist[node1] = 0;\\n    minHeap.emplace(dist[node1], node1);\\n\\n    while (!minHeap.empty()) {\\n      const auto [d, u] = minHeap.top();\\n      minHeap.pop();\\n      if (u == node2)\\n        return d;\\n      for (const auto& [v, w] : graph[u])\\n        if (d + w < dist[v]) {\\n          dist[v] = d + w;\\n          minHeap.emplace(dist[v], v);\\n        }\\n    }\\n\\n    return -1;\\n  }\\n\\n private:\\n  vector<vector<pair<int, int>>> graph;\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3871366,
                "title": "dijkstra-algorithm-adjacency-matrix-easy-implementation-fastest-solution",
                "content": "\\n# Complexity\\n- Time complexity:O(n*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n*n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Graph {\\npublic:\\n    int **grph;\\n    int v;\\n    int dijkstra(int n1,int n2, int **grph){\\n\\n        vector<int> dist(v,1000000000);\\n        dist[n1]=0;\\n        vector<bool> visit(v,false);\\n        for(int i=0;i<v-1;i++){\\n            int u=-1;\\n            for(int k=0;k<v;k++){\\n                if(!visit[k] && (u==-1 || dist[k]<dist[u]))u=k;\\n            }\\n            visit[u]=true;\\n            for(int j=0;j<v;j++){\\n                if(grph[u][j]!=0 && !visit[j]){\\n                   dist[j]=min(dist[j],dist[u]+grph[u][j]);\\n                }\\n            }\\n        }\\n        if(dist[n2]==1000000000)return -1;\\n        return dist[n2];\\n    }\\n    Graph(int n, vector<vector<int>>& edges) {\\n        grph=new int *[n];\\n        for(int i=0;i<n;i++)grph[i]=new int [n];\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                grph[i][j]=0;\\n            }\\n        }\\n        for(auto r: edges){\\n            grph[r[0]][r[1]]=r[2];\\n        }\\n        v=n;\\n    }\\n    \\n    void addEdge(vector<int> edge) {\\n        grph[edge[0]][edge[1]]=edge[2];\\n    }\\n    \\n    int shortestPath(int node1, int node2) {\\n        return dijkstra(node1,node2,grph);\\n\\n    }\\n};\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph* obj = new Graph(n, edges);\\n * obj->addEdge(edge);\\n * int param_2 = obj->shortestPath(node1,node2);\\n */\\n```\\n# ****PLEASE UPVOTE****\\n",
                "solutionTags": [
                    "C++",
                    "Graph",
                    "Matrix",
                    "Shortest Path"
                ],
                "code": "```\\nclass Graph {\\npublic:\\n    int **grph;\\n    int v;\\n    int dijkstra(int n1,int n2, int **grph){\\n\\n        vector<int> dist(v,1000000000);\\n        dist[n1]=0;\\n        vector<bool> visit(v,false);\\n        for(int i=0;i<v-1;i++){\\n            int u=-1;\\n            for(int k=0;k<v;k++){\\n                if(!visit[k] && (u==-1 || dist[k]<dist[u]))u=k;\\n            }\\n            visit[u]=true;\\n            for(int j=0;j<v;j++){\\n                if(grph[u][j]!=0 && !visit[j]){\\n                   dist[j]=min(dist[j],dist[u]+grph[u][j]);\\n                }\\n            }\\n        }\\n        if(dist[n2]==1000000000)return -1;\\n        return dist[n2];\\n    }\\n    Graph(int n, vector<vector<int>>& edges) {\\n        grph=new int *[n];\\n        for(int i=0;i<n;i++)grph[i]=new int [n];\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                grph[i][j]=0;\\n            }\\n        }\\n        for(auto r: edges){\\n            grph[r[0]][r[1]]=r[2];\\n        }\\n        v=n;\\n    }\\n    \\n    void addEdge(vector<int> edge) {\\n        grph[edge[0]][edge[1]]=edge[2];\\n    }\\n    \\n    int shortestPath(int node1, int node2) {\\n        return dijkstra(node1,node2,grph);\\n\\n    }\\n};\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph* obj = new Graph(n, edges);\\n * obj->addEdge(edge);\\n * int param_2 = obj->shortestPath(node1,node2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3832291,
                "title": "beats-98-comments-explanation-of-each-function-clean-code",
                "content": "\\n\\n# Approach\\nNeed of all the funtion is described in comment.\\n\\n\\n\\n# Code\\n```\\nclass Graph {\\n\\n    class Pair{ //custom data type\\n        int  node,wt;\\n        Pair(  int node, int wt){\\n            this.node=node;\\n            this.wt=wt;\\n        }\\n    }\\n\\n\\n    int n;\\n    ArrayList<ArrayList<Pair>> adj;\\n\\n    public Graph(int n, int[][] edges) {    //Need: fill global variables n and adj to use it in another funtion\\n        this.n=n;\\n        adj=new ArrayList();\\n\\n        for(int i=0; i<n; i++)\\n           adj.add(new ArrayList());\\n\\n        for(int i=0; i<edges.length; i++)\\n           adj.get(edges[i][0]).add(new Pair(edges[i][1],edges[i][2]));\\n       \\n    }\\n    \\n    public void addEdge(int[] edge) {   // Need: This funtion is used to add edge between two node\\n          adj.get(edge[0]).add(new Pair(edge[1],edge[2]));\\n    }\\n    \\n    public int shortestPath(int node1, int node2) { // use dijkstra\\'s algo to find shortest route b/w src and dest. \\n    // You are given with src , dest, adj, No. of nodes (n) use this vaiables to find shortest path.\\n        int[] dist=new int[n];\\n        Arrays.fill(dist,Integer.MAX_VALUE);\\n        dist[node1]=0;\\n\\n        PriorityQueue<Pair> q=new PriorityQueue<>((a ,b)-> a.wt-b.wt); \\n        q.add(new Pair(node1,0));\\n\\n        while(! q.isEmpty()){\\n            Pair curr=q.poll();\\n            int node=curr.node;\\n            int wt=curr.wt;\\n\\n            if(node==node2)\\n            return wt;\\n\\n            for(Pair t: adj.get(node)){\\n                int adjNode=t.node;\\n                int adjwt=t.wt;\\n\\n                if(dist[adjNode]>wt+adjwt){\\n                    dist[adjNode]=wt+adjwt;\\n                    q.add(new Pair(adjNode,adjwt+wt));\\n                }\\n            }\\n        }\\n    return -1;\\n    }\\n}\\n\\n```\\n\\n# Upvote button is below \\uD83E\\uDD24\\n\\n",
                "solutionTags": [
                    "Java",
                    "Graph",
                    "Heap (Priority Queue)",
                    "Shortest Path"
                ],
                "code": "```\\nclass Graph {\\n\\n    class Pair{ //custom data type\\n        int  node,wt;\\n        Pair(  int node, int wt){\\n            this.node=node;\\n            this.wt=wt;\\n        }\\n    }\\n\\n\\n    int n;\\n    ArrayList<ArrayList<Pair>> adj;\\n\\n    public Graph(int n, int[][] edges) {    //Need: fill global variables n and adj to use it in another funtion\\n        this.n=n;\\n        adj=new ArrayList();\\n\\n        for(int i=0; i<n; i++)\\n           adj.add(new ArrayList());\\n\\n        for(int i=0; i<edges.length; i++)\\n           adj.get(edges[i][0]).add(new Pair(edges[i][1],edges[i][2]));\\n       \\n    }\\n    \\n    public void addEdge(int[] edge) {   // Need: This funtion is used to add edge between two node\\n          adj.get(edge[0]).add(new Pair(edge[1],edge[2]));\\n    }\\n    \\n    public int shortestPath(int node1, int node2) { // use dijkstra\\'s algo to find shortest route b/w src and dest. \\n    // You are given with src , dest, adj, No. of nodes (n) use this vaiables to find shortest path.\\n        int[] dist=new int[n];\\n        Arrays.fill(dist,Integer.MAX_VALUE);\\n        dist[node1]=0;\\n\\n        PriorityQueue<Pair> q=new PriorityQueue<>((a ,b)-> a.wt-b.wt); \\n        q.add(new Pair(node1,0));\\n\\n        while(! q.isEmpty()){\\n            Pair curr=q.poll();\\n            int node=curr.node;\\n            int wt=curr.wt;\\n\\n            if(node==node2)\\n            return wt;\\n\\n            for(Pair t: adj.get(node)){\\n                int adjNode=t.node;\\n                int adjwt=t.wt;\\n\\n                if(dist[adjNode]>wt+adjwt){\\n                    dist[adjNode]=wt+adjwt;\\n                    q.add(new Pair(adjNode,adjwt+wt));\\n                }\\n            }\\n        }\\n    return -1;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3784882,
                "title": "core-dijkstra-algorithm-implementation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Graph:\\n\\n    def __init__(self, n: int, edges: List[List[int]]):\\n        self.n = n\\n        self.adj_list = [[] for i in range(n)]\\n        for edge in edges:\\n            self.addEdge(edge)\\n\\n    def addEdge(self, edge: List[int]) -> None:\\n        start,end,cost  = edge\\n        self.adj_list[start].append((end,cost))\\n\\n    def shortestPath(self, node1: int, node2: int) -> int:\\n        dist = [float(\\'inf\\')]*self.n\\n        dist[node1] = 0\\n        heap = [(0,node1)]\\n        while heap:\\n            cost,node = heapq.heappop(heap)\\n            if cost>dist[node]:\\n                continue\\n            if node==node2:\\n                return dist[node2]\\n            for neighbour,weight in self.adj_list[node]:\\n                total_dist = cost+weight\\n                if total_dist<dist[neighbour]:\\n                    dist[neighbour] = total_dist\\n                    heapq.heappush(heap,(total_dist,neighbour))\\n        return dist[node2] if dist[node2]!=float(\\'inf\\') else -1\\n            \\n        \\n\\n\\n# Your Graph object will be instantiated and called as such:\\n# obj = Graph(n, edges)\\n# obj.addEdge(edge)\\n# param_2 = obj.shortestPath(node1,node2)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Graph:\\n\\n    def __init__(self, n: int, edges: List[List[int]]):\\n        self.n = n\\n        self.adj_list = [[] for i in range(n)]\\n        for edge in edges:\\n            self.addEdge(edge)\\n\\n    def addEdge(self, edge: List[int]) -> None:\\n        start,end,cost  = edge\\n        self.adj_list[start].append((end,cost))\\n\\n    def shortestPath(self, node1: int, node2: int) -> int:\\n        dist = [float(\\'inf\\')]*self.n\\n        dist[node1] = 0\\n        heap = [(0,node1)]\\n        while heap:\\n            cost,node = heapq.heappop(heap)\\n            if cost>dist[node]:\\n                continue\\n            if node==node2:\\n                return dist[node2]\\n            for neighbour,weight in self.adj_list[node]:\\n                total_dist = cost+weight\\n                if total_dist<dist[neighbour]:\\n                    dist[neighbour] = total_dist\\n                    heapq.heappush(heap,(total_dist,neighbour))\\n        return dist[node2] if dist[node2]!=float(\\'inf\\') else -1\\n            \\n        \\n\\n\\n# Your Graph object will be instantiated and called as such:\\n# obj = Graph(n, edges)\\n# obj.addEdge(edge)\\n# param_2 = obj.shortestPath(node1,node2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3755682,
                "title": "c-dijkstrak-algorithm",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity is o(V+E logV)\\n\\n- Space complexity\\n\\n# Code\\n```\\nclass Graph {\\npublic:\\nvector<vector<pair<int,int>>>adj;\\n    Graph(int n, vector<vector<int>>& edges) {\\n       adj.resize(n) ;\\n       for(auto &e:edges)\\n       {\\n           adj[e[0]].push_back({e[1],e[2]});\\n       }\\n    }\\n    \\n    void addEdge(vector<int> edge) {\\n        adj[edge[0]].push_back({edge[1],edge[2]});\\n    }\\n    \\n    int shortestPath(int node1, int node2) {\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pq;\\n        int n=adj.size();\\n        vector<int>dis(n,INT_MAX);\\n        dis[node1]=0;\\n        pq.push({0,node1});\\n        while(!pq.empty()){\\n            auto it=pq.top();\\n            int d=it.first;\\n            int node=it.second;\\n            pq.pop();\\n            if(node==node2) return d;\\n            for(auto j:adj[node])\\n            {\\n                int adjn=j.first;\\n                int e=j.second;\\n                if(dis[adjn]>d+e)\\n                {\\n                    dis[adjn]=d+e;\\n                    pq.push({dis[adjn],adjn});\\n                }\\n            }\\n        }\\n        return -1;\\n\\n    }\\n};\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph* obj = new Graph(n, edges);\\n * obj->addEdge(edge);\\n * int param_2 = obj->shortestPath(node1,node2);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Graph {\\npublic:\\nvector<vector<pair<int,int>>>adj;\\n    Graph(int n, vector<vector<int>>& edges) {\\n       adj.resize(n) ;\\n       for(auto &e:edges)\\n       {\\n           adj[e[0]].push_back({e[1],e[2]});\\n       }\\n    }\\n    \\n    void addEdge(vector<int> edge) {\\n        adj[edge[0]].push_back({edge[1],edge[2]});\\n    }\\n    \\n    int shortestPath(int node1, int node2) {\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pq;\\n        int n=adj.size();\\n        vector<int>dis(n,INT_MAX);\\n        dis[node1]=0;\\n        pq.push({0,node1});\\n        while(!pq.empty()){\\n            auto it=pq.top();\\n            int d=it.first;\\n            int node=it.second;\\n            pq.pop();\\n            if(node==node2) return d;\\n            for(auto j:adj[node])\\n            {\\n                int adjn=j.first;\\n                int e=j.second;\\n                if(dis[adjn]>d+e)\\n                {\\n                    dis[adjn]=d+e;\\n                    pq.push({dis[adjn],adjn});\\n                }\\n            }\\n        }\\n        return -1;\\n\\n    }\\n};\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph* obj = new Graph(n, edges);\\n * obj->addEdge(edge);\\n * int param_2 = obj->shortestPath(node1,node2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3729220,
                "title": "simple-dijsktra",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Graph {\\npublic:\\n    vector<vector<pair<int,int>>> adj;\\n    Graph(int n, vector<vector<int>>& edges) {\\n        adj.resize(n);\\n        for (auto &e : edges)\\n        {\\n            adj[e[0]].push_back({e[1],e[2]});\\n        }\\n    }\\n    \\n    void addEdge(vector<int> edge) {\\n        \\n        adj[edge[0]].push_back({edge[1],edge[2]});\\n    }\\n    \\n    int shortestPath(int node1, int node2) {\\n        \\npriority_queue<pair<int,int>, vector<pair<int,int>>, \\ngreater<pair<int,int>> > pq;\\nint n = adj.size();\\nvector<int> dis(n,INT_MAX);\\ndis[node1] = 0;\\npq.push({0,node1});\\n\\nwhile(!pq.empty())\\n{\\n    auto it = pq.top();\\n    int d = it.first;\\n    int node = it.second;\\n    pq.pop();\\n    if(node == node2) return d;\\n    for (auto j : adj[node])\\n    {\\n        int adjn = j.first;\\n        int e = j.second;\\n        if(dis[adjn] > d + e)\\n        {\\n            dis[adjn] =  d + e;\\n            pq.push({dis[adjn],adjn});\\n        }\\n    }\\n}\\n\\n    return -1;\\n\\n    }\\n};\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph* obj = new Graph(n, edges);\\n * obj->addEdge(edge);\\n * int param_2 = obj->shortestPath(node1,node2);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Graph {\\npublic:\\n    vector<vector<pair<int,int>>> adj;\\n    Graph(int n, vector<vector<int>>& edges) {\\n        adj.resize(n);\\n        for (auto &e : edges)\\n        {\\n            adj[e[0]].push_back({e[1],e[2]});\\n        }\\n    }\\n    \\n    void addEdge(vector<int> edge) {\\n        \\n        adj[edge[0]].push_back({edge[1],edge[2]});\\n    }\\n    \\n    int shortestPath(int node1, int node2) {\\n        \\npriority_queue<pair<int,int>, vector<pair<int,int>>, \\ngreater<pair<int,int>> > pq;\\nint n = adj.size();\\nvector<int> dis(n,INT_MAX);\\ndis[node1] = 0;\\npq.push({0,node1});\\n\\nwhile(!pq.empty())\\n{\\n    auto it = pq.top();\\n    int d = it.first;\\n    int node = it.second;\\n    pq.pop();\\n    if(node == node2) return d;\\n    for (auto j : adj[node])\\n    {\\n        int adjn = j.first;\\n        int e = j.second;\\n        if(dis[adjn] > d + e)\\n        {\\n            dis[adjn] =  d + e;\\n            pq.push({dis[adjn],adjn});\\n        }\\n    }\\n}\\n\\n    return -1;\\n\\n    }\\n};\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph* obj = new Graph(n, edges);\\n * obj->addEdge(edge);\\n * int param_2 = obj->shortestPath(node1,node2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3647943,
                "title": "simple-dijkstra-s-implementation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis Problem is a Straight forward Implementation of a Naive Dijkstra Algorithm.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSimply define & build a Graph for calculating the Shortest Path between any 2 Nodes. Keep adding the Edges when necessary.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O((V + E) log V), where V is the number of vertices and E is the number of edges.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(V + E)\\n# Code\\n```\\nclass Graph {\\n\\n    List<int[]>[] graph;\\n    public Graph(int n, int[][] edges) {\\n        graph = new ArrayList[n];\\n\\n        for(int i = 0; i < n; i++)\\n            graph[i] = new ArrayList<int[]>();\\n\\n        for(int[] edge: edges)\\n        {\\n            int src = edge[0], dest = edge[1], weight = edge[2];\\n            graph[src].add(new int[]{dest, weight});\\n        }\\n    }\\n    \\n    public void addEdge(int[] edge) {\\n        int src = edge[0], dest = edge[1], weight = edge[2];\\n        graph[src].add(new int[]{dest, weight});\\n    }\\n    \\n    public int shortestPath(int node1, int node2) {\\n        PriorityQueue<int[]> pq = new PriorityQueue<int[]>((a, b) -> a[1] - b[1]);\\n        int[] minCost = new int[graph.length];\\n        boolean[] visited = new boolean[graph.length];\\n        Arrays.fill(minCost, Integer.MAX_VALUE);\\n\\n        pq.offer(new int[]{node1, 0});\\n        minCost[node1] = 0;\\n\\n        while(!pq.isEmpty())\\n        {\\n            int[] current = pq.poll();\\n            int src = current[0];\\n            int curCost = current[1];\\n\\n            if(src == node2)\\n                return curCost;\\n            \\n            if(visited[src]) \\n                continue;\\n            \\n            visited[src] = true;\\n            \\n            for(int[] neighbourData: graph[src])\\n            {\\n                int neighbour = neighbourData[0], time = neighbourData[1];\\n\\n                if(curCost + time < minCost[neighbour])\\n                {\\n                    minCost[neighbour] = curCost + time;\\n                    pq.offer(new int[]{neighbour, minCost[neighbour]});\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph obj = new Graph(n, edges);\\n * obj.addEdge(edge);\\n * int param_2 = obj.shortestPath(node1,node2);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Graph",
                    "Shortest Path"
                ],
                "code": "```\\nclass Graph {\\n\\n    List<int[]>[] graph;\\n    public Graph(int n, int[][] edges) {\\n        graph = new ArrayList[n];\\n\\n        for(int i = 0; i < n; i++)\\n            graph[i] = new ArrayList<int[]>();\\n\\n        for(int[] edge: edges)\\n        {\\n            int src = edge[0], dest = edge[1], weight = edge[2];\\n            graph[src].add(new int[]{dest, weight});\\n        }\\n    }\\n    \\n    public void addEdge(int[] edge) {\\n        int src = edge[0], dest = edge[1], weight = edge[2];\\n        graph[src].add(new int[]{dest, weight});\\n    }\\n    \\n    public int shortestPath(int node1, int node2) {\\n        PriorityQueue<int[]> pq = new PriorityQueue<int[]>((a, b) -> a[1] - b[1]);\\n        int[] minCost = new int[graph.length];\\n        boolean[] visited = new boolean[graph.length];\\n        Arrays.fill(minCost, Integer.MAX_VALUE);\\n\\n        pq.offer(new int[]{node1, 0});\\n        minCost[node1] = 0;\\n\\n        while(!pq.isEmpty())\\n        {\\n            int[] current = pq.poll();\\n            int src = current[0];\\n            int curCost = current[1];\\n\\n            if(src == node2)\\n                return curCost;\\n            \\n            if(visited[src]) \\n                continue;\\n            \\n            visited[src] = true;\\n            \\n            for(int[] neighbourData: graph[src])\\n            {\\n                int neighbour = neighbourData[0], time = neighbourData[1];\\n\\n                if(curCost + time < minCost[neighbour])\\n                {\\n                    minCost[neighbour] = curCost + time;\\n                    pq.offer(new int[]{neighbour, minCost[neighbour]});\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph obj = new Graph(n, edges);\\n * obj.addEdge(edge);\\n * int param_2 = obj.shortestPath(node1,node2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3642525,
                "title": "java-dijkstra-s-shortest-path",
                "content": "\\n\\n# Code\\n```\\nclass Graph {\\n\\n    int[][] adj;\\n    int[] distance;\\n\\n    public Graph(int n, int[][] edges) {\\n        adj = new int[n][n];\\n        distance = new int[n];\\n        for (int[] arr : adj) {\\n            Arrays.fill(arr, -1);\\n        }\\n        Arrays.fill(distance, Integer.MAX_VALUE);\\n\\n        for (int[] edge : edges) {\\n            int x = edge[0];\\n            int y = edge[1];\\n            int w = edge[2];\\n\\n            adj[x][y] = w;\\n        }\\n    }\\n    \\n    public void addEdge(int[] edge) {\\n        int x = edge[0];\\n        int y = edge[1];\\n        int w = edge[2];\\n\\n        adj[x][y] = w;\\n\\n    }\\n    \\n    public int shortestPath(int node1, int node2) {\\n        solve(distance, adj, node1, node2);\\n        return distance[node2] == Integer.MAX_VALUE ? -1 : distance[node2];\\n    }\\n\\n    void solve(int[] dist, int[][] adj, int s1, int d) {\\n        Arrays.fill(dist, Integer.MAX_VALUE);\\n        dist[s1] = 0;\\n        Queue<int[]> pq = new PriorityQueue<>((a, b) -> Integer.compare(a[1], b[1]));\\n        Set<Integer> set = new HashSet<>();\\n        pq.add(new int[]{s1, 0});\\n\\n        while (!pq.isEmpty()) {\\n            int[] node = pq.poll();\\n            int s = node[0];\\n            if (set.contains(s))\\n                continue;\\n            \\n            set.add(s);\\n            for (int i = 0; i < adj[s].length; i++) {\\n                if (adj[s][i] != -1 && i != s) {\\n                    int w = adj[s][i];\\n                        if (distance[s] + w < distance[i]) {\\n                            distance[i] = distance[s] + w;\\n                            pq.add(new int[]{i, distance[i]});\\n                        }\\n                }\\n            }\\n        }\\n    }\\n}\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph obj = new Graph(n, edges);\\n * obj.addEdge(edge);\\n * int param_2 = obj.shortestPath(node1,node2);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Graph {\\n\\n    int[][] adj;\\n    int[] distance;\\n\\n    public Graph(int n, int[][] edges) {\\n        adj = new int[n][n];\\n        distance = new int[n];\\n        for (int[] arr : adj) {\\n            Arrays.fill(arr, -1);\\n        }\\n        Arrays.fill(distance, Integer.MAX_VALUE);\\n\\n        for (int[] edge : edges) {\\n            int x = edge[0];\\n            int y = edge[1];\\n            int w = edge[2];\\n\\n            adj[x][y] = w;\\n        }\\n    }\\n    \\n    public void addEdge(int[] edge) {\\n        int x = edge[0];\\n        int y = edge[1];\\n        int w = edge[2];\\n\\n        adj[x][y] = w;\\n\\n    }\\n    \\n    public int shortestPath(int node1, int node2) {\\n        solve(distance, adj, node1, node2);\\n        return distance[node2] == Integer.MAX_VALUE ? -1 : distance[node2];\\n    }\\n\\n    void solve(int[] dist, int[][] adj, int s1, int d) {\\n        Arrays.fill(dist, Integer.MAX_VALUE);\\n        dist[s1] = 0;\\n        Queue<int[]> pq = new PriorityQueue<>((a, b) -> Integer.compare(a[1], b[1]));\\n        Set<Integer> set = new HashSet<>();\\n        pq.add(new int[]{s1, 0});\\n\\n        while (!pq.isEmpty()) {\\n            int[] node = pq.poll();\\n            int s = node[0];\\n            if (set.contains(s))\\n                continue;\\n            \\n            set.add(s);\\n            for (int i = 0; i < adj[s].length; i++) {\\n                if (adj[s][i] != -1 && i != s) {\\n                    int w = adj[s][i];\\n                        if (distance[s] + w < distance[i]) {\\n                            distance[i] = distance[s] + w;\\n                            pq.add(new int[]{i, distance[i]});\\n                        }\\n                }\\n            }\\n        }\\n    }\\n}\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph obj = new Graph(n, edges);\\n * obj.addEdge(edge);\\n * int param_2 = obj.shortestPath(node1,node2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3620294,
                "title": "dijkastra",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMaintain a weighted graph and carry out dijkastra for each shortest path query.\\n\\n# Complexity\\n- Time complexity: $$O(m\\\\log n)$$, where $n$ and $m$ are the vertex number and edge number respectively.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n+m)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Graph {\\n    int n;\\n    vector<vector<vector<int>>> e;\\npublic:\\n    Graph(int n, vector<vector<int>>& edges) {\\n        this->n=n;\\n        e.resize(n);\\n        for(auto&v:edges)\\n            e[v[0]].push_back({v[1],v[2]});\\n        \\n    }\\n    \\n    void addEdge(vector<int> edge) {\\n        e[edge[0]].push_back({edge[1],edge[2]});\\n    }\\n    \\n    int shortestPath(int s, int t) {\\n        vector<int> d(n,INT_MAX);\\n        priority_queue<vector<int>,vector<vector<int>>,greater<vector<int>>> pq;\\n        pq.push({0,s});\\n        d[s]=0;\\n        while(!pq.empty()){\\n            int dis=pq.top()[0],u=pq.top()[1];\\n            pq.pop();\\n            if(u==t) return d[u];\\n            if(dis>d[u]) continue;\\n            for(auto&ev:e[u]){\\n                int nd=dis+ev[1],v=ev[0];\\n                if(nd>=d[v]) continue;\\n                d[v]=nd;\\n                pq.push({nd, v});\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph* obj = new Graph(n, edges);\\n * obj->addEdge(edge);\\n * int param_2 = obj->shortestPath(node1,node2);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Graph {\\n    int n;\\n    vector<vector<vector<int>>> e;\\npublic:\\n    Graph(int n, vector<vector<int>>& edges) {\\n        this->n=n;\\n        e.resize(n);\\n        for(auto&v:edges)\\n            e[v[0]].push_back({v[1],v[2]});\\n        \\n    }\\n    \\n    void addEdge(vector<int> edge) {\\n        e[edge[0]].push_back({edge[1],edge[2]});\\n    }\\n    \\n    int shortestPath(int s, int t) {\\n        vector<int> d(n,INT_MAX);\\n        priority_queue<vector<int>,vector<vector<int>>,greater<vector<int>>> pq;\\n        pq.push({0,s});\\n        d[s]=0;\\n        while(!pq.empty()){\\n            int dis=pq.top()[0],u=pq.top()[1];\\n            pq.pop();\\n            if(u==t) return d[u];\\n            if(dis>d[u]) continue;\\n            for(auto&ev:e[u]){\\n                int nd=dis+ev[1],v=ev[0];\\n                if(nd>=d[v]) continue;\\n                d[v]=nd;\\n                pq.push({nd, v});\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph* obj = new Graph(n, edges);\\n * obj->addEdge(edge);\\n * int param_2 = obj->shortestPath(node1,node2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3545696,
                "title": "dijkstra-java",
                "content": "# Code\\n```\\nclass Graph {\\n    List<int[]>[] l;\\n    public Graph(int n, int[][] edges) {\\n        l = new ArrayList[n];\\n        for (int i = 0; i < n; i++) {\\n            l[i] = new ArrayList<>();\\n        }\\n        for (int[] e: edges) {\\n            l[e[0]].add(new int[]{e[1], e[2]});\\n        }\\n    }\\n    \\n    public void addEdge(int[] edge) {\\n        l[edge[0]].add(new int[]{edge[1], edge[2]});\\n    }\\n    \\n    public int shortestPath(int node1, int node2) {\\n        int[] res = new int[l.length];\\n        PriorityQueue<int[]> q = new PriorityQueue<>((o1, o2) -> o1[1] - o2[1]);\\n        q.add(new int[]{node1, 0});\\n        while (!q.isEmpty()) {\\n            int[] k = q.poll();\\n            if (k[0] == node2) {\\n                return k[1];\\n            }\\n            if (res[k[0]] != 0) {\\n                continue;\\n            }\\n            res[k[0]] = k[1];\\n            for (int[] z: l[k[0]]) {\\n                if (res[z[0]] != 0) {\\n                    continue;\\n                }\\n                q.offer(new int[]{z[0], k[1] + z[1]});   \\n            }\\n        }\\n        return -1;\\n    }\\n}\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph obj = new Graph(n, edges);\\n * obj.addEdge(edge);\\n * int param_2 = obj.shortestPath(node1,node2);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Graph {\\n    List<int[]>[] l;\\n    public Graph(int n, int[][] edges) {\\n        l = new ArrayList[n];\\n        for (int i = 0; i < n; i++) {\\n            l[i] = new ArrayList<>();\\n        }\\n        for (int[] e: edges) {\\n            l[e[0]].add(new int[]{e[1], e[2]});\\n        }\\n    }\\n    \\n    public void addEdge(int[] edge) {\\n        l[edge[0]].add(new int[]{edge[1], edge[2]});\\n    }\\n    \\n    public int shortestPath(int node1, int node2) {\\n        int[] res = new int[l.length];\\n        PriorityQueue<int[]> q = new PriorityQueue<>((o1, o2) -> o1[1] - o2[1]);\\n        q.add(new int[]{node1, 0});\\n        while (!q.isEmpty()) {\\n            int[] k = q.poll();\\n            if (k[0] == node2) {\\n                return k[1];\\n            }\\n            if (res[k[0]] != 0) {\\n                continue;\\n            }\\n            res[k[0]] = k[1];\\n            for (int[] z: l[k[0]]) {\\n                if (res[z[0]] != 0) {\\n                    continue;\\n                }\\n                q.offer(new int[]{z[0], k[1] + z[1]});   \\n            }\\n        }\\n        return -1;\\n    }\\n}\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph obj = new Graph(n, edges);\\n * obj.addEdge(edge);\\n * int param_2 = obj.shortestPath(node1,node2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3542563,
                "title": "dijkstra-algorithm-java-solution",
                "content": "# Code\\n```\\nclass Graph {\\n    class pair{\\n        int vertex;\\n        int weight;\\n        public pair(int vertex,int weight){\\n            this.vertex=vertex;\\n            this.weight=weight;\\n        }\\n    }\\n    int n;\\n    ArrayList<ArrayList<pair>> adj;\\n    public Graph(int n, int[][] edges) {\\n        this.n=n;\\n        this.adj = new ArrayList<>();\\n        for(int i=0;i<=n;i++) adj.add(new ArrayList<>());\\n        for(int i=0;i<edges.length;i++){\\n            adj.get(edges[i][0]).add(new pair(edges[i][1],edges[i][2]));\\n        }\\n    }\\n    \\n    public void addEdge(int[] edge) {\\n        adj.get(edge[0]).add(new pair(edge[1],edge[2]));\\n    }\\n    \\n    public int shortestPath(int node1, int node2) {\\n        int[] dist = new int[n+1];\\n        Arrays.fill(dist,Integer.MAX_VALUE);\\n        PriorityQueue<pair> pq = new PriorityQueue<>((x,y) -> x.weight - y.weight);\\n        dist[node1] = 0;\\n        pq.offer(new pair(node1,0));\\n        while(!pq.isEmpty()){\\n            int vertex = pq.peek().vertex;\\n            int weight = pq.peek().weight;\\n            pq.poll();\\n            if(vertex==node2) return weight;\\n            for(pair it:adj.get(vertex)){\\n                if(dist[it.vertex]>weight+it.weight){\\n                    dist[it.vertex] = weight+it.weight;\\n                    pq.offer(new pair(it.vertex,dist[it.vertex]));\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph obj = new Graph(n, edges);\\n * obj.addEdge(edge);\\n * int param_2 = obj.shortestPath(node1,node2);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Graph",
                    "Design",
                    "Heap (Priority Queue)",
                    "Shortest Path"
                ],
                "code": "```\\nclass Graph {\\n    class pair{\\n        int vertex;\\n        int weight;\\n        public pair(int vertex,int weight){\\n            this.vertex=vertex;\\n            this.weight=weight;\\n        }\\n    }\\n    int n;\\n    ArrayList<ArrayList<pair>> adj;\\n    public Graph(int n, int[][] edges) {\\n        this.n=n;\\n        this.adj = new ArrayList<>();\\n        for(int i=0;i<=n;i++) adj.add(new ArrayList<>());\\n        for(int i=0;i<edges.length;i++){\\n            adj.get(edges[i][0]).add(new pair(edges[i][1],edges[i][2]));\\n        }\\n    }\\n    \\n    public void addEdge(int[] edge) {\\n        adj.get(edge[0]).add(new pair(edge[1],edge[2]));\\n    }\\n    \\n    public int shortestPath(int node1, int node2) {\\n        int[] dist = new int[n+1];\\n        Arrays.fill(dist,Integer.MAX_VALUE);\\n        PriorityQueue<pair> pq = new PriorityQueue<>((x,y) -> x.weight - y.weight);\\n        dist[node1] = 0;\\n        pq.offer(new pair(node1,0));\\n        while(!pq.isEmpty()){\\n            int vertex = pq.peek().vertex;\\n            int weight = pq.peek().weight;\\n            pq.poll();\\n            if(vertex==node2) return weight;\\n            for(pair it:adj.get(vertex)){\\n                if(dist[it.vertex]>weight+it.weight){\\n                    dist[it.vertex] = weight+it.weight;\\n                    pq.offer(new pair(it.vertex,dist[it.vertex]));\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph obj = new Graph(n, edges);\\n * obj.addEdge(edge);\\n * int param_2 = obj.shortestPath(node1,node2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3539369,
                "title": "c-bfs-dijkstra-algorithm-graphs-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Code\\n```\\nclass Graph {\\npublic:\\n    unordered_map<int, vector<pair<int, int>>>adj;\\n    int N;\\n    Graph(int n, vector<vector<int>>& edges) {\\n        N=n;\\n        for(auto it: edges){\\n            adj[it[0]].push_back({it[1], it[2]});\\n        }\\n    }\\n    \\n    void addEdge(vector<int> edge) {\\n        adj[edge[0]].push_back({edge[1], edge[2]});\\n    }\\n    \\n    int shortestPath(int node1, int node2) {\\n        vector<int>v(N+1, 1e9);\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>>q;\\n        q.push({0, node1});\\n        v[node1]=0;\\n        while(!q.empty()){\\n            int ind=q.top().second, wt=q.top().first;\\n            q.pop();\\n            for(auto it: adj[ind]){\\n                if(v[it.first]>wt+it.second){\\n                    v[it.first]=wt+it.second;\\n                    q.push({v[it.first], it.first});\\n                }\\n            }\\n        }\\n        if(v[node2]==1e9){return -1;}\\n        return v[node2];\\n    }\\n};\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph* obj = new Graph(n, edges);\\n * obj->addEdge(edge);\\n * int param_2 = obj->shortestPath(node1,node2);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph",
                    "Heap (Priority Queue)",
                    "Shortest Path"
                ],
                "code": "```\\nclass Graph {\\npublic:\\n    unordered_map<int, vector<pair<int, int>>>adj;\\n    int N;\\n    Graph(int n, vector<vector<int>>& edges) {\\n        N=n;\\n        for(auto it: edges){\\n            adj[it[0]].push_back({it[1], it[2]});\\n        }\\n    }\\n    \\n    void addEdge(vector<int> edge) {\\n        adj[edge[0]].push_back({edge[1], edge[2]});\\n    }\\n    \\n    int shortestPath(int node1, int node2) {\\n        vector<int>v(N+1, 1e9);\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>>q;\\n        q.push({0, node1});\\n        v[node1]=0;\\n        while(!q.empty()){\\n            int ind=q.top().second, wt=q.top().first;\\n            q.pop();\\n            for(auto it: adj[ind]){\\n                if(v[it.first]>wt+it.second){\\n                    v[it.first]=wt+it.second;\\n                    q.push({v[it.first], it.first});\\n                }\\n            }\\n        }\\n        if(v[node2]==1e9){return -1;}\\n        return v[node2];\\n    }\\n};\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph* obj = new Graph(n, edges);\\n * obj->addEdge(edge);\\n * int param_2 = obj->shortestPath(node1,node2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3505797,
                "title": "simple-more-efficient-most-optimized-javascript-solution",
                "content": "```\\nPlease Up-Vote , If This Helps You !!!\\n```\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nStore all the edges in hash map.\\n\\naddEdge - add one more node to edge.\\nshortestPath - implement optimal path finding using Heap. On each step go to next node with min total path. For this node add all reachable nodes from this node to the MinHeap. Priority will be cost to get to particular node.\\n\\n# Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n\\n# Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n\\n# Code\\n```\\nvar Graph = function(n, edges) {\\n    this.map = new Map()\\n    let map = this.map;\\n    for(let i = 0; i < edges.length; i++){\\n        let edge = edges[i]\\n        let from = edge[0]\\n        let to = edge[1]\\n        let cost = edge[2]\\n        if(!map.has(from)){\\n            map.set(from, new Set())\\n        }\\n        \\n        map.get(from).add({to, cost})\\n    }\\n};\\n\\nGraph.prototype.addEdge = function(edge) {\\n    let map = this.map;\\n     let from = edge[0]\\n     let to = edge[1]\\n     let cost = edge[2]\\n     if(!map.has(from)){\\n        map.set(from, new Set())\\n     }\\n        \\n     map.get(from).add({to, cost})\\n};\\n\\nGraph.prototype.shortestPath = function(node1, node2) {\\n    \\n    const heap = new MinPriorityQueue()\\n    heap.enqueue({node: node1, cost: 0}, 0)\\n    let visited = new Set()\\n    \\n    while(heap.size() > 0){\\n        const top = heap.dequeue().element;\\n        \\n        if(visited.has(top.node)){\\n            continue;\\n        }\\n        visited.add(top.node)\\n        if(top.node === node2){\\n            return top.cost;\\n        }\\n        let next = this.map.get(top.node)\\n        if(next){\\n            for (let n of next){\\n                heap.enqueue({node: n.to, cost: top.cost + n.cost}, top.cost + n.cost)\\n            }\\n        }\\n    }\\n    return -1  \\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Graph",
                    "Design",
                    "Heap (Priority Queue)",
                    "Shortest Path"
                ],
                "code": "```\\nPlease Up-Vote , If This Helps You !!!\\n```\n```\\nvar Graph = function(n, edges) {\\n    this.map = new Map()\\n    let map = this.map;\\n    for(let i = 0; i < edges.length; i++){\\n        let edge = edges[i]\\n        let from = edge[0]\\n        let to = edge[1]\\n        let cost = edge[2]\\n        if(!map.has(from)){\\n            map.set(from, new Set())\\n        }\\n        \\n        map.get(from).add({to, cost})\\n    }\\n};\\n\\nGraph.prototype.addEdge = function(edge) {\\n    let map = this.map;\\n     let from = edge[0]\\n     let to = edge[1]\\n     let cost = edge[2]\\n     if(!map.has(from)){\\n        map.set(from, new Set())\\n     }\\n        \\n     map.get(from).add({to, cost})\\n};\\n\\nGraph.prototype.shortestPath = function(node1, node2) {\\n    \\n    const heap = new MinPriorityQueue()\\n    heap.enqueue({node: node1, cost: 0}, 0)\\n    let visited = new Set()\\n    \\n    while(heap.size() > 0){\\n        const top = heap.dequeue().element;\\n        \\n        if(visited.has(top.node)){\\n            continue;\\n        }\\n        visited.add(top.node)\\n        if(top.node === node2){\\n            return top.cost;\\n        }\\n        let next = this.map.get(top.node)\\n        if(next){\\n            for (let n of next){\\n                heap.enqueue({node: n.to, cost: top.cost + n.cost}, top.cost + n.cost)\\n            }\\n        }\\n    }\\n    return -1  \\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3502182,
                "title": "kotlin-dijkstra",
                "content": "# Approach\\n\\nSince we know that:\\n\\n`1 <= n <= 100`\\n`At most 100 calls will be made for addEdge. `\\n`At most 100 calls will be made for shortestPath`\\n\\nI choose to not precompute all the shortest paths from the beginning. I compute each shortest path from `node1` to `node2` on each call of `shortestPath(node1, node2)`. But I build the graph with adjency list on `init` and update it on `addEdge(edge)`\\n\\nThis solution I used Djikstra\\'s algorithm, it\\'s pretty straight forward to use for this problem. The code is self-explanatory\\n\\n\\n - **Time complexity:** building `Graph` class is $$O(E^2) \\\\approx O(n^2)$$ and `shortestPath()` is $$O(n^2)$$\\n\\n - **Space complexity:** $$O(E^2) \\\\approx O(N^2)$$ since we can have n * n edges as per the constraints, and we store that in our adjecency list `adj`\\n# Code\\n```\\nclass Graph(n: Int, edges: Array<IntArray>) {\\n\\n    val adj = HashMap<Int, ArrayList<Pair<Int, Int>>>().apply {\\n        for (i in 0 until n)\\n            this[i] = ArrayList<Pair<Int, Int>>()\\n\\n        for ((u, v, cost) in edges) {\\n            this[u] = getOrDefault(u, ArrayList<Pair<Int, Int>>()).apply { this.add(v to cost) }\\n        }\\n    }\\n\\n    fun addEdge(edge: IntArray) {\\n        val (u, v, cost) = edge\\n        adj[u] = adj.getOrDefault(u, ArrayList<Pair<Int, Int>>()).apply { this.add(v to cost) }\\n    }\\n\\n    fun shortestPath(node1: Int, node2: Int): Int {\\n        val minHeap = PriorityQueue<Pair<Int, Int>> {a, b -> a.second - b.second }\\n        val distance = IntArray(adj.size) { Integer.MAX_VALUE }\\n\\n        minHeap.add(node1 to 0)\\n        distance[node1] = 0\\n\\n        while (minHeap.isNotEmpty()) {\\n            val (node, cost) = minHeap.poll()\\n\\n            if (node == node2) return cost\\n            if (cost > distance[node]) continue\\n\\n            adj[node]?.let {\\n                for ((next, nextCost) in adj[node]!!) {\\n                    if (cost + nextCost < distance[next]) {\\n                        distance[next] = cost + nextCost\\n                        minHeap.add(next to cost + nextCost)\\n                    }\\n                }\\n            }\\n        }\\n\\n        return -1\\n    }\\n\\n}\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * var obj = Graph(n, edges)\\n * obj.addEdge(edge)\\n * var param_2 = obj.shortestPath(node1,node2)\\n */\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Shortest Path"
                ],
                "code": "```\\nclass Graph(n: Int, edges: Array<IntArray>) {\\n\\n    val adj = HashMap<Int, ArrayList<Pair<Int, Int>>>().apply {\\n        for (i in 0 until n)\\n            this[i] = ArrayList<Pair<Int, Int>>()\\n\\n        for ((u, v, cost) in edges) {\\n            this[u] = getOrDefault(u, ArrayList<Pair<Int, Int>>()).apply { this.add(v to cost) }\\n        }\\n    }\\n\\n    fun addEdge(edge: IntArray) {\\n        val (u, v, cost) = edge\\n        adj[u] = adj.getOrDefault(u, ArrayList<Pair<Int, Int>>()).apply { this.add(v to cost) }\\n    }\\n\\n    fun shortestPath(node1: Int, node2: Int): Int {\\n        val minHeap = PriorityQueue<Pair<Int, Int>> {a, b -> a.second - b.second }\\n        val distance = IntArray(adj.size) { Integer.MAX_VALUE }\\n\\n        minHeap.add(node1 to 0)\\n        distance[node1] = 0\\n\\n        while (minHeap.isNotEmpty()) {\\n            val (node, cost) = minHeap.poll()\\n\\n            if (node == node2) return cost\\n            if (cost > distance[node]) continue\\n\\n            adj[node]?.let {\\n                for ((next, nextCost) in adj[node]!!) {\\n                    if (cost + nextCost < distance[next]) {\\n                        distance[next] = cost + nextCost\\n                        minHeap.add(next to cost + nextCost)\\n                    }\\n                }\\n            }\\n        }\\n\\n        return -1\\n    }\\n\\n}\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * var obj = Graph(n, edges)\\n * obj.addEdge(edge)\\n * var param_2 = obj.shortestPath(node1,node2)\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3496247,
                "title": "java-javascript-c-solution",
                "content": "**Java**\\n```\\nimport java.util.ArrayList;\\nimport java.util.Arrays;\\nimport java.util.List;\\nimport java.util.PriorityQueue;\\n\\npublic class Graph {\\n\\n    private static final int NO_PATH_EXISTS = -1;\\n\\n    private record Node(int ID, int costOfEdge) {}\\n    private record Step(int ID, int costFromStart) {}\\n\\n    private final List<Node>[] graph;\\n    private final int totalNodes;\\n\\n    public Graph(int totalNodes, int[][] edges) {\\n        this.totalNodes = totalNodes;\\n        graph = new List[totalNodes];\\n        for (int i = 0; i < totalNodes; ++i) {\\n            graph[i] = new ArrayList<>();\\n        }\\n\\n        for (int[] edge : edges) {\\n            int from = edge[0];\\n            int to = edge[1];\\n            int cost = edge[2];\\n            graph[from].add(new Node(to, cost));\\n        }\\n    }\\n\\n    public void addEdge(int[] edge) {\\n        int from = edge[0];\\n        int to = edge[1];\\n        int cost = edge[2];\\n        graph[from].add(new Node(to, cost));\\n    }\\n\\n    public int shortestPath(int start, int goal) {\\n        int[] distanceFromStart = new int[this.totalNodes];\\n        Arrays.fill(distanceFromStart, Integer.MAX_VALUE);\\n        distanceFromStart[start] = 0;\\n\\n        PriorityQueue<Step> minHeap = new PriorityQueue<>((x, y) -> x.costFromStart - y.costFromStart);\\n        minHeap.add(new Step(start, 0));\\n\\n        while (!minHeap.isEmpty()) {\\n\\n            Step current = minHeap.poll();\\n            if (current.ID == goal) {\\n                break;\\n            }\\n\\n            List<Node> neighbours = graph[current.ID];\\n            for (Node next : neighbours) {\\n                if (distanceFromStart[next.ID] > current.costFromStart + next.costOfEdge) {\\n                    distanceFromStart[next.ID] = current.costFromStart + next.costOfEdge;\\n                    minHeap.add(new Step(next.ID, distanceFromStart[next.ID]));\\n                }\\n            }\\n        }\\n\\n        return distanceFromStart[goal] != Integer.MAX_VALUE ? distanceFromStart[goal] : NO_PATH_EXISTS;\\n    }\\n}\\n```\\n**JavaScript**\\n```\\nclass Graph {\\n\\n    static NO_PATH_EXISTS = -1;\\n\\n    /**\\n     * @param {number} totalNodes\\n     * @param {number[][]} edges\\n     */\\n    constructor(totalNodes, edges) {\\n        this.graph = new Array(totalNodes);//Array<Node>\\n        this.totalNodes = totalNodes;\\n        for (let i = 0; i < totalNodes; ++i) {\\n            this.graph[i] = new Array();\\n        }\\n\\n        for (let [from, to, cost] of edges) {\\n            this.graph[from].push(new Node(to, cost));\\n        }\\n    }\\n\\n    /** \\n     * @param {number[]} edge\\n     * @return {void}\\n     */\\n    addEdge(edge) {\\n        let from = edge[0];\\n        let to = edge[1];\\n        let cost = edge[2];\\n        this.graph[from].push(new Node(to, cost));\\n    }\\n\\n    /** \\n     * @param {number} start \\n     * @param {number} goal\\n     * @return {number}\\n     */\\n    shortestPath(start, goal) {\\n        const distanceFromStart = new Array(this.totalNodes).fill(Number.MAX_SAFE_INTEGER);\\n        distanceFromStart[start] = 0;\\n\\n        //const {MinPriorityQueue} = require(\\'@datastructures-js/priority-queue\\');\\n        //MinPriorityQueue<Step>\\n        const minHeap = new MinPriorityQueue({compare: (x, y) => x.costFromStart - y.costFromStart});\\n        minHeap.enqueue(new Step(start, 0));\\n\\n        while (!minHeap.isEmpty()) {\\n\\n            let current = minHeap.dequeue();\\n            if (current.ID === goal) {\\n                break;\\n            }\\n\\n            const neighbours = this.graph[current.ID];\\n            for (let next of neighbours) {\\n                if (distanceFromStart[next.ID] > current.costFromStart + next.costOfEdge) {\\n                    distanceFromStart[next.ID] = current.costFromStart + next.costOfEdge;\\n                    minHeap.enqueue(new Step(next.ID, distanceFromStart[next.ID]));\\n                }\\n            }\\n        }\\n\\n        return distanceFromStart[goal] !== Number.MAX_SAFE_INTEGER ? distanceFromStart[goal] : Graph.NO_PATH_EXISTS;\\n    }\\n}\\n\\n/** \\n * @param {number} ID \\n * @param {number} costOfEdge\\n */\\nfunction Node(ID, costOfEdge) {\\n    this.ID = ID;\\n    this.costOfEdge = costOfEdge;\\n}\\n\\n/** \\n * @param {number} ID \\n * @param {number} costFromStart\\n */\\nfunction Step(ID, costFromStart) {\\n    this.ID = ID;\\n    this.costFromStart = costFromStart;\\n}\\n```\\n**C++**\\n```\\n#include <queue>\\n#include <memory>\\n#include <vector>\\n#include <climits>\\nusing namespace std;\\n\\nstruct Node {\\n    int ID;\\n    int costOfEdge;\\n    Node(int ID, int costOfEdge) : ID {ID}, costOfEdge {costOfEdge} {}\\n};\\n\\nstruct Step {\\n    int ID;\\n    int costFromStart;\\n    Step(int ID, int costFromStart) : ID {ID}, costFromStart {costFromStart} {}\\n};\\n\\nclass Graph {\\n\\n    const static int NO_PATH_EXISTS = -1;\\n    vector<vector<Node>> graph;\\n    int totalNodes;\\n\\npublic:\\n    Graph(int totalNodes, const vector<vector<int>>& edges) : totalNodes {totalNodes} {\\n        graph.resize(totalNodes);\\n        for (const auto& edge : edges) {\\n            int from = edge[0];\\n            int to = edge[1];\\n            int cost = edge[2];\\n            graph[from].emplace_back(to, cost);\\n        }\\n    }\\n\\n    void addEdge(const vector<int>& edge) {\\n        int from = edge[0];\\n        int to = edge[1];\\n        int cost = edge[2];\\n        graph[from].emplace_back(to, cost);\\n    }\\n\\n    int shortestPath(int start, int goal) const {\\n        vector<int>distanceFromStart(totalNodes, INT_MAX);\\n        distanceFromStart[start] = 0;\\n\\n        static auto comparator = [](const Step& first, const Step& second)\\n        {return first.costFromStart > second.costFromStart;};\\n\\n        priority_queue<Step, vector<Step>, decltype(comparator)> minHeap(comparator);\\n        minHeap.emplace(start, 0);\\n\\n        while (!minHeap.empty()) {\\n\\n            Step current = minHeap.top();\\n            minHeap.pop();\\n            if (current.ID == goal) {\\n                break;\\n            }\\n\\n            const vector<Node>& neighbours = graph[current.ID];\\n            for (const auto& next : neighbours) {\\n                if (distanceFromStart[next.ID] > current.costFromStart + next.costOfEdge) {\\n                    distanceFromStart[next.ID] = current.costFromStart + next.costOfEdge;\\n                    minHeap.emplace(next.ID, distanceFromStart[next.ID]);\\n                }\\n            }\\n        }\\n\\n        return distanceFromStart[goal] != INT_MAX ? distanceFromStart[goal] : NO_PATH_EXISTS;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "JavaScript",
                    "Graph"
                ],
                "code": "```\\nimport java.util.ArrayList;\\nimport java.util.Arrays;\\nimport java.util.List;\\nimport java.util.PriorityQueue;\\n\\npublic class Graph {\\n\\n    private static final int NO_PATH_EXISTS = -1;\\n\\n    private record Node(int ID, int costOfEdge) {}\\n    private record Step(int ID, int costFromStart) {}\\n\\n    private final List<Node>[] graph;\\n    private final int totalNodes;\\n\\n    public Graph(int totalNodes, int[][] edges) {\\n        this.totalNodes = totalNodes;\\n        graph = new List[totalNodes];\\n        for (int i = 0; i < totalNodes; ++i) {\\n            graph[i] = new ArrayList<>();\\n        }\\n\\n        for (int[] edge : edges) {\\n            int from = edge[0];\\n            int to = edge[1];\\n            int cost = edge[2];\\n            graph[from].add(new Node(to, cost));\\n        }\\n    }\\n\\n    public void addEdge(int[] edge) {\\n        int from = edge[0];\\n        int to = edge[1];\\n        int cost = edge[2];\\n        graph[from].add(new Node(to, cost));\\n    }\\n\\n    public int shortestPath(int start, int goal) {\\n        int[] distanceFromStart = new int[this.totalNodes];\\n        Arrays.fill(distanceFromStart, Integer.MAX_VALUE);\\n        distanceFromStart[start] = 0;\\n\\n        PriorityQueue<Step> minHeap = new PriorityQueue<>((x, y) -> x.costFromStart - y.costFromStart);\\n        minHeap.add(new Step(start, 0));\\n\\n        while (!minHeap.isEmpty()) {\\n\\n            Step current = minHeap.poll();\\n            if (current.ID == goal) {\\n                break;\\n            }\\n\\n            List<Node> neighbours = graph[current.ID];\\n            for (Node next : neighbours) {\\n                if (distanceFromStart[next.ID] > current.costFromStart + next.costOfEdge) {\\n                    distanceFromStart[next.ID] = current.costFromStart + next.costOfEdge;\\n                    minHeap.add(new Step(next.ID, distanceFromStart[next.ID]));\\n                }\\n            }\\n        }\\n\\n        return distanceFromStart[goal] != Integer.MAX_VALUE ? distanceFromStart[goal] : NO_PATH_EXISTS;\\n    }\\n}\\n```\n```\\nclass Graph {\\n\\n    static NO_PATH_EXISTS = -1;\\n\\n    /**\\n     * @param {number} totalNodes\\n     * @param {number[][]} edges\\n     */\\n    constructor(totalNodes, edges) {\\n        this.graph = new Array(totalNodes);//Array<Node>\\n        this.totalNodes = totalNodes;\\n        for (let i = 0; i < totalNodes; ++i) {\\n            this.graph[i] = new Array();\\n        }\\n\\n        for (let [from, to, cost] of edges) {\\n            this.graph[from].push(new Node(to, cost));\\n        }\\n    }\\n\\n    /** \\n     * @param {number[]} edge\\n     * @return {void}\\n     */\\n    addEdge(edge) {\\n        let from = edge[0];\\n        let to = edge[1];\\n        let cost = edge[2];\\n        this.graph[from].push(new Node(to, cost));\\n    }\\n\\n    /** \\n     * @param {number} start \\n     * @param {number} goal\\n     * @return {number}\\n     */\\n    shortestPath(start, goal) {\\n        const distanceFromStart = new Array(this.totalNodes).fill(Number.MAX_SAFE_INTEGER);\\n        distanceFromStart[start] = 0;\\n\\n        //const {MinPriorityQueue} = require(\\'@datastructures-js/priority-queue\\');\\n        //MinPriorityQueue<Step>\\n        const minHeap = new MinPriorityQueue({compare: (x, y) => x.costFromStart - y.costFromStart});\\n        minHeap.enqueue(new Step(start, 0));\\n\\n        while (!minHeap.isEmpty()) {\\n\\n            let current = minHeap.dequeue();\\n            if (current.ID === goal) {\\n                break;\\n            }\\n\\n            const neighbours = this.graph[current.ID];\\n            for (let next of neighbours) {\\n                if (distanceFromStart[next.ID] > current.costFromStart + next.costOfEdge) {\\n                    distanceFromStart[next.ID] = current.costFromStart + next.costOfEdge;\\n                    minHeap.enqueue(new Step(next.ID, distanceFromStart[next.ID]));\\n                }\\n            }\\n        }\\n\\n        return distanceFromStart[goal] !== Number.MAX_SAFE_INTEGER ? distanceFromStart[goal] : Graph.NO_PATH_EXISTS;\\n    }\\n}\\n\\n/** \\n * @param {number} ID \\n * @param {number} costOfEdge\\n */\\nfunction Node(ID, costOfEdge) {\\n    this.ID = ID;\\n    this.costOfEdge = costOfEdge;\\n}\\n\\n/** \\n * @param {number} ID \\n * @param {number} costFromStart\\n */\\nfunction Step(ID, costFromStart) {\\n    this.ID = ID;\\n    this.costFromStart = costFromStart;\\n}\\n```\n```\\n#include <queue>\\n#include <memory>\\n#include <vector>\\n#include <climits>\\nusing namespace std;\\n\\nstruct Node {\\n    int ID;\\n    int costOfEdge;\\n    Node(int ID, int costOfEdge) : ID {ID}, costOfEdge {costOfEdge} {}\\n};\\n\\nstruct Step {\\n    int ID;\\n    int costFromStart;\\n    Step(int ID, int costFromStart) : ID {ID}, costFromStart {costFromStart} {}\\n};\\n\\nclass Graph {\\n\\n    const static int NO_PATH_EXISTS = -1;\\n    vector<vector<Node>> graph;\\n    int totalNodes;\\n\\npublic:\\n    Graph(int totalNodes, const vector<vector<int>>& edges) : totalNodes {totalNodes} {\\n        graph.resize(totalNodes);\\n        for (const auto& edge : edges) {\\n            int from = edge[0];\\n            int to = edge[1];\\n            int cost = edge[2];\\n            graph[from].emplace_back(to, cost);\\n        }\\n    }\\n\\n    void addEdge(const vector<int>& edge) {\\n        int from = edge[0];\\n        int to = edge[1];\\n        int cost = edge[2];\\n        graph[from].emplace_back(to, cost);\\n    }\\n\\n    int shortestPath(int start, int goal) const {\\n        vector<int>distanceFromStart(totalNodes, INT_MAX);\\n        distanceFromStart[start] = 0;\\n\\n        static auto comparator = [](const Step& first, const Step& second)\\n        {return first.costFromStart > second.costFromStart;};\\n\\n        priority_queue<Step, vector<Step>, decltype(comparator)> minHeap(comparator);\\n        minHeap.emplace(start, 0);\\n\\n        while (!minHeap.empty()) {\\n\\n            Step current = minHeap.top();\\n            minHeap.pop();\\n            if (current.ID == goal) {\\n                break;\\n            }\\n\\n            const vector<Node>& neighbours = graph[current.ID];\\n            for (const auto& next : neighbours) {\\n                if (distanceFromStart[next.ID] > current.costFromStart + next.costOfEdge) {\\n                    distanceFromStart[next.ID] = current.costFromStart + next.costOfEdge;\\n                    minHeap.emplace(next.ID, distanceFromStart[next.ID]);\\n                }\\n            }\\n        }\\n\\n        return distanceFromStart[goal] != INT_MAX ? distanceFromStart[goal] : NO_PATH_EXISTS;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3490636,
                "title": "c-floydd-warshall-algo",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Graph {\\npublic:\\nvector<vector<int>> cost;\\nint n=-1;\\n    Graph(int n, vector<vector<int>>& edges) {\\n        this->n=n;\\n        cost.resize(n,vector<int>(n,1e8));\\n        for(int i=0;i<n;i++) cost[i][i]=0;\\n        for(auto& ele: edges){\\n            cost[ele[0]][ele[1]]=ele[2];\\n        }\\n        for(int k=0;k<n;k++){\\n            for(int i=0;i<n;i++){\\n                for(int j=0;j<n;j++){\\n                    if(cost[i][j]>cost[i][k]+cost[k][j]){\\n                        cost[i][j]=cost[i][k]+cost[k][j];\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    \\n    void addEdge(vector<int> ele) {\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(cost[i][j]>cost[i][ele[0]]+cost[ele[1]][j]+ele[2]){\\n                    cost[i][j]=cost[i][ele[0]]+cost[ele[1]][j]+ele[2];\\n                }\\n            }\\n        }\\n    }\\n    \\n    int shortestPath(int node1, int node2) {\\n        return (cost[node1][node2]!=1e8)?cost[node1][node2]:(-1);\\n    }\\n};\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph* obj = new Graph(n, edges);\\n * obj->addEdge(edge);\\n * int param_2 = obj->shortestPath(node1,node2);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Graph {\\npublic:\\nvector<vector<int>> cost;\\nint n=-1;\\n    Graph(int n, vector<vector<int>>& edges) {\\n        this->n=n;\\n        cost.resize(n,vector<int>(n,1e8));\\n        for(int i=0;i<n;i++) cost[i][i]=0;\\n        for(auto& ele: edges){\\n            cost[ele[0]][ele[1]]=ele[2];\\n        }\\n        for(int k=0;k<n;k++){\\n            for(int i=0;i<n;i++){\\n                for(int j=0;j<n;j++){\\n                    if(cost[i][j]>cost[i][k]+cost[k][j]){\\n                        cost[i][j]=cost[i][k]+cost[k][j];\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    \\n    void addEdge(vector<int> ele) {\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(cost[i][j]>cost[i][ele[0]]+cost[ele[1]][j]+ele[2]){\\n                    cost[i][j]=cost[i][ele[0]]+cost[ele[1]][j]+ele[2];\\n                }\\n            }\\n        }\\n    }\\n    \\n    int shortestPath(int node1, int node2) {\\n        return (cost[node1][node2]!=1e8)?cost[node1][node2]:(-1);\\n    }\\n};\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph* obj = new Graph(n, edges);\\n * obj->addEdge(edge);\\n * int param_2 = obj->shortestPath(node1,node2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3481905,
                "title": "c-dijkstra-solution-with-explanation",
                "content": "```cpp\\n/*\\nnaive Dijkstra for dense graph.\\nuse adjacent matrix.\\ntc of shortestPath is O(n^2), sc is O(n^2)\\n*/\\nclass Graph {\\npublic:\\n    vector<vector<int>> g;\\n    \\n    Graph(int n, vector<vector<int>>& edges): g (n, vector<int> (n, INT_MAX)) {\\n        for (vector<int> & e: edges) g[e[0]][e[1]] = e[2];\\n    }\\n    \\n    void addEdge(vector<int> edge) {\\n        g[edge[0]][edge[1]] = edge[2];\\n    }\\n    \\n    int shortestPath(int node1, int node2) {\\n        int nodenum = this -> g.size();\\n        vector<bool> visited (nodenum, false);\\n        vector<int> dis (nodenum, INT_MAX);\\n        dis[node1] = 0;\\n        while (true) {\\n            int nearest = -1;\\n            for (int i = 0; i < nodenum; i += 1) {\\n                if (!visited[i] && (nearest == -1 || dis[i] < dis[nearest])) nearest = i;\\n            }\\n            if (dis[nearest] == INT_MAX) return -1; // all nodes reachable from the start are updated\\n            else if (nearest == node2) return dis[node2];\\n            visited[nearest] = true;\\n            for (int i = 0; i < nodenum; i += 1) {\\n                if (g[nearest][i] != INT_MAX) dis[i] = min(dis[i], dis[nearest] + g[nearest][i]);\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\n/*\\nnaive Dijkstra for dense graph.\\nuse adjacent matrix.\\ntc of shortestPath is O(n^2), sc is O(n^2)\\n*/\\nclass Graph {\\npublic:\\n    vector<vector<int>> g;\\n    \\n    Graph(int n, vector<vector<int>>& edges): g (n, vector<int> (n, INT_MAX)) {\\n        for (vector<int> & e: edges) g[e[0]][e[1]] = e[2];\\n    }\\n    \\n    void addEdge(vector<int> edge) {\\n        g[edge[0]][edge[1]] = edge[2];\\n    }\\n    \\n    int shortestPath(int node1, int node2) {\\n        int nodenum = this -> g.size();\\n        vector<bool> visited (nodenum, false);\\n        vector<int> dis (nodenum, INT_MAX);\\n        dis[node1] = 0;\\n        while (true) {\\n            int nearest = -1;\\n            for (int i = 0; i < nodenum; i += 1) {\\n                if (!visited[i] && (nearest == -1 || dis[i] < dis[nearest])) nearest = i;\\n            }\\n            if (dis[nearest] == INT_MAX) return -1; // all nodes reachable from the start are updated\\n            else if (nearest == node2) return dis[node2];\\n            visited[nearest] = true;\\n            for (int i = 0; i < nodenum; i += 1) {\\n                if (g[nearest][i] != INT_MAX) dis[i] = min(dis[i], dis[nearest] + g[nearest][i]);\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3456978,
                "title": "dijkstra-algorithm",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Graph:\\n\\n    def __init__(self, n: int, edges: List[List[int]]):\\n        self.size=n\\n        self.edges=edges\\n        \\n\\n    def addEdge(self, edge: List[int]) -> None:\\n        self.edges.append(edge)\\n        \\n\\n    def shortestPath(self, node1: int, node2: int) -> int:\\n        n=self.size\\n        dist=[float(\"inf\")]*n\\n        dist[node1]=0\\n        adj=[([])for i in range(n)]\\n        for i in self.edges:\\n            adj[i[0]].append([i[1],i[2]])\\n        pq=deque()\\n        count=0\\n        pq.append((node1,0))\\n        while len(pq)>0:\\n            node,time=pq.popleft()\\n            for i in adj[node]:\\n                v=i[0]\\n                t=i[1]\\n                if dist[v]>t+time:\\n                    dist[v]=t+time\\n                    pq.append((v,dist[v]))\\n        if dist[node2]!=float(\"inf\"):\\n            return dist[node2]\\n        else:\\n            return -1\\n\\n        \\n\\n\\n# Your Graph object will be instantiated and called as such:\\n# obj = Graph(n, edges)\\n# obj.addEdge(edge)\\n# param_2 = obj.shortestPath(node1,node2)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Graph:\\n\\n    def __init__(self, n: int, edges: List[List[int]]):\\n        self.size=n\\n        self.edges=edges\\n        \\n\\n    def addEdge(self, edge: List[int]) -> None:\\n        self.edges.append(edge)\\n        \\n\\n    def shortestPath(self, node1: int, node2: int) -> int:\\n        n=self.size\\n        dist=[float(\"inf\")]*n\\n        dist[node1]=0\\n        adj=[([])for i in range(n)]\\n        for i in self.edges:\\n            adj[i[0]].append([i[1],i[2]])\\n        pq=deque()\\n        count=0\\n        pq.append((node1,0))\\n        while len(pq)>0:\\n            node,time=pq.popleft()\\n            for i in adj[node]:\\n                v=i[0]\\n                t=i[1]\\n                if dist[v]>t+time:\\n                    dist[v]=t+time\\n                    pq.append((v,dist[v]))\\n        if dist[node2]!=float(\"inf\"):\\n            return dist[node2]\\n        else:\\n            return -1\\n\\n        \\n\\n\\n# Your Graph object will be instantiated and called as such:\\n# obj = Graph(n, edges)\\n# obj.addEdge(edge)\\n# param_2 = obj.shortestPath(node1,node2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445451,
                "title": "java-floyd-warshall-algorithm",
                "content": "\\n\\n# Code\\n```\\nclass Graph {\\n\\n    int[][] graph;\\n    int n;\\n    public Graph(int n, int[][] edges) {\\n        graph = new int[n][n];\\n        this.n = n;\\n        for(int i = 0; i < n; i ++){\\n            for(int j = 0; j < n; j ++){\\n                graph[i][j] = Integer.MAX_VALUE;\\n            }\\n        }\\n        for(int[] edge : edges){\\n            int from = edge[0];\\n            int to = edge[1];\\n            int cost = edge[2];\\n            graph[from][to] = cost;\\n        }   \\n        for(int k = 0; k < n; k ++){\\n            for(int i = 0; i < n; i ++){\\n                for(int j = 0; j < n; j ++){\\n                    if( graph[i][k] != Integer.MAX_VALUE && graph[k][j] != Integer.MAX_VALUE){\\n                        graph[i][j] = Math.min(graph[i][j], graph[i][k] + graph[k][j]);\\n                    }\\n                }\\n            }\\n        }\\n        for(int i = 0; i < n; i ++){\\n            graph[i][i] = 0;\\n        }\\n         \\n        //print();\\n\\n        \\n    }\\n    \\n    public void addEdge(int[] edge) {\\n        int from = edge[0];\\n        int to = edge[1];\\n        int cost = edge[2];\\n        if (graph[from][to] > cost){\\n            graph[from][to] = cost;\\n            for(int i = 0; i < n; i ++){\\n                for(int j = 0; j < n; j ++){\\n                    if( graph[i][from] != Integer.MAX_VALUE && graph[to][j] != Integer.MAX_VALUE){\\n                        graph[i][j] = Math.min(graph[i][j], graph[i][from] + graph[to][j] + cost);\\n                    }\\n                }\\n            }\\n        }\\n        //print();\\n        \\n    }\\n    public int shortestPath(int node1, int node2) {\\n         int ans = Integer.MAX_VALUE;\\n        return graph[node1][node2] == Integer.MAX_VALUE ? -1 : graph[node1][node2];\\n    }\\n    public void print(){\\n        for(int i = 0; i < n; i ++){\\n            for(int j = 0; j < n; j ++){\\n                System.out.printf(graph[i][j] + \", \");\\n            }\\n            System.out.println();\\n        }\\n                    System.out.println();\\n\\n    }\\n}\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph obj = new Graph(n, edges);\\n * obj.addEdge(edge);\\n * int param_2 = obj.shortestPath(node1,node2);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Graph {\\n\\n    int[][] graph;\\n    int n;\\n    public Graph(int n, int[][] edges) {\\n        graph = new int[n][n];\\n        this.n = n;\\n        for(int i = 0; i < n; i ++){\\n            for(int j = 0; j < n; j ++){\\n                graph[i][j] = Integer.MAX_VALUE;\\n            }\\n        }\\n        for(int[] edge : edges){\\n            int from = edge[0];\\n            int to = edge[1];\\n            int cost = edge[2];\\n            graph[from][to] = cost;\\n        }   \\n        for(int k = 0; k < n; k ++){\\n            for(int i = 0; i < n; i ++){\\n                for(int j = 0; j < n; j ++){\\n                    if( graph[i][k] != Integer.MAX_VALUE && graph[k][j] != Integer.MAX_VALUE){\\n                        graph[i][j] = Math.min(graph[i][j], graph[i][k] + graph[k][j]);\\n                    }\\n                }\\n            }\\n        }\\n        for(int i = 0; i < n; i ++){\\n            graph[i][i] = 0;\\n        }\\n         \\n        //print();\\n\\n        \\n    }\\n    \\n    public void addEdge(int[] edge) {\\n        int from = edge[0];\\n        int to = edge[1];\\n        int cost = edge[2];\\n        if (graph[from][to] > cost){\\n            graph[from][to] = cost;\\n            for(int i = 0; i < n; i ++){\\n                for(int j = 0; j < n; j ++){\\n                    if( graph[i][from] != Integer.MAX_VALUE && graph[to][j] != Integer.MAX_VALUE){\\n                        graph[i][j] = Math.min(graph[i][j], graph[i][from] + graph[to][j] + cost);\\n                    }\\n                }\\n            }\\n        }\\n        //print();\\n        \\n    }\\n    public int shortestPath(int node1, int node2) {\\n         int ans = Integer.MAX_VALUE;\\n        return graph[node1][node2] == Integer.MAX_VALUE ? -1 : graph[node1][node2];\\n    }\\n    public void print(){\\n        for(int i = 0; i < n; i ++){\\n            for(int j = 0; j < n; j ++){\\n                System.out.printf(graph[i][j] + \", \");\\n            }\\n            System.out.println();\\n        }\\n                    System.out.println();\\n\\n    }\\n}\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph obj = new Graph(n, edges);\\n * obj.addEdge(edge);\\n * int param_2 = obj.shortestPath(node1,node2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3442437,
                "title": "python3-dijkstra-using-heapq",
                "content": "\\n# Code\\n```\\nclass Graph:\\n\\n    def __init__(self, n: int, edges: List[List[int]]):\\n        self.mp={k:[] for k in range(n)}\\n        for e in edges:\\n            self.mp[e[0]].append((e[1],e[2]))\\n\\n    def addEdge(self, edge: List[int]) -> None:\\n        self.mp[edge[0]].append((edge[1],edge[2]))\\n        \\n\\n    def shortestPath(self, node1: int, node2: int) -> int:\\n        dist=[float(\\'inf\\') for i in range(len(self.mp))]\\n        hp =[(0,node1)]\\n        while len(hp)>0:\\n            d,v =heapq.heappop(hp)\\n            if(v==node2):\\n                return int(d)\\n            if d> dist[v]:\\n                continue\\n            for neighbor,weight in self.mp[v]:\\n                if(dist[neighbor]> d+weight):\\n                    dist[neighbor]=d+weight\\n                    heapq.heappush(hp,(dist[neighbor],neighbor))\\n        return -1\\n            \\n                \\n        \\n\\n\\n# Your Graph object will be instantiated and called as such:\\n# obj = Graph(n, edges)\\n# obj.addEdge(edge)\\n# param_2 = obj.shortestPath(node1,node2)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Graph:\\n\\n    def __init__(self, n: int, edges: List[List[int]]):\\n        self.mp={k:[] for k in range(n)}\\n        for e in edges:\\n            self.mp[e[0]].append((e[1],e[2]))\\n\\n    def addEdge(self, edge: List[int]) -> None:\\n        self.mp[edge[0]].append((edge[1],edge[2]))\\n        \\n\\n    def shortestPath(self, node1: int, node2: int) -> int:\\n        dist=[float(\\'inf\\') for i in range(len(self.mp))]\\n        hp =[(0,node1)]\\n        while len(hp)>0:\\n            d,v =heapq.heappop(hp)\\n            if(v==node2):\\n                return int(d)\\n            if d> dist[v]:\\n                continue\\n            for neighbor,weight in self.mp[v]:\\n                if(dist[neighbor]> d+weight):\\n                    dist[neighbor]=d+weight\\n                    heapq.heappush(hp,(dist[neighbor],neighbor))\\n        return -1\\n            \\n                \\n        \\n\\n\\n# Your Graph object will be instantiated and called as such:\\n# obj = Graph(n, edges)\\n# obj.addEdge(edge)\\n# param_2 = obj.shortestPath(node1,node2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3441969,
                "title": "floyd-algorithm",
                "content": "\\n\\n# Code\\n```\\nclass Graph {\\npublic:\\n    Graph(int n, vector<vector<int>>& edges) {\\n        N = n;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (i != j) {\\n                    dp[i][j] = 1e8;\\n                } else {\\n                    dp[i][j] = 0;\\n                }\\n            }\\n        }\\n        for (auto e : edges) {\\n            dp[e[0]][e[1]] = e[2];\\n        }\\n        // floyd \\u7B97\\u6CD5\\n        for (int k = 0; k < n; k++) {\\n            for (int i = 0; i < n; i++) {\\n                if (i == k) continue;\\n                for (int j = 0; j < n; j++) {\\n                    if (i == j or j == k) continue;\\n                    dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j]);\\n                }\\n            }\\n        }\\n    }\\n    \\n    void addEdge(vector<int> edge) {\\n        dp[edge[0]][edge[1]] = min(dp[edge[0]][edge[1]], edge[2]);\\n        // update the min distance from edge[0] to other node\\n        for (int i = 0; i < N; i++) {\\n            if (i == edge[0] or i == edge[1]) continue;\\n            dp[edge[0]][i] = min(dp[edge[0]][i], edge[2] + dp[edge[1]][i]);\\n        }\\n        // update the min distance from any node to other node using edge[0]\\n        for (int i = 0; i < N; i++) {\\n            for (int j = 0; j < N; j++) {\\n                if (i == j or j == edge[0] or i == edge[0]) continue;\\n                dp[i][j] = min(dp[i][j], dp[i][edge[0]] + dp[edge[0]][j]);\\n            }\\n        }\\n    }\\n    \\n    int shortestPath(int node1, int node2) {\\n        return dp[node1][node2] == 1e8 ? -1 : dp[node1][node2];\\n    }\\nprivate:\\n    int N;\\n    int dp[105][105];\\n};\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph* obj = new Graph(n, edges);\\n * obj->addEdge(edge);\\n * int param_2 = obj->shortestPath(node1,node2);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Graph {\\npublic:\\n    Graph(int n, vector<vector<int>>& edges) {\\n        N = n;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (i != j) {\\n                    dp[i][j] = 1e8;\\n                } else {\\n                    dp[i][j] = 0;\\n                }\\n            }\\n        }\\n        for (auto e : edges) {\\n            dp[e[0]][e[1]] = e[2];\\n        }\\n        // floyd \\u7B97\\u6CD5\\n        for (int k = 0; k < n; k++) {\\n            for (int i = 0; i < n; i++) {\\n                if (i == k) continue;\\n                for (int j = 0; j < n; j++) {\\n                    if (i == j or j == k) continue;\\n                    dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j]);\\n                }\\n            }\\n        }\\n    }\\n    \\n    void addEdge(vector<int> edge) {\\n        dp[edge[0]][edge[1]] = min(dp[edge[0]][edge[1]], edge[2]);\\n        // update the min distance from edge[0] to other node\\n        for (int i = 0; i < N; i++) {\\n            if (i == edge[0] or i == edge[1]) continue;\\n            dp[edge[0]][i] = min(dp[edge[0]][i], edge[2] + dp[edge[1]][i]);\\n        }\\n        // update the min distance from any node to other node using edge[0]\\n        for (int i = 0; i < N; i++) {\\n            for (int j = 0; j < N; j++) {\\n                if (i == j or j == edge[0] or i == edge[0]) continue;\\n                dp[i][j] = min(dp[i][j], dp[i][edge[0]] + dp[edge[0]][j]);\\n            }\\n        }\\n    }\\n    \\n    int shortestPath(int node1, int node2) {\\n        return dp[node1][node2] == 1e8 ? -1 : dp[node1][node2];\\n    }\\nprivate:\\n    int N;\\n    int dp[105][105];\\n};\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph* obj = new Graph(n, edges);\\n * obj->addEdge(edge);\\n * int param_2 = obj->shortestPath(node1,node2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3438304,
                "title": "simple-dijkstra-s-algorithm-shortest-path-map",
                "content": "# Approach\\nMake adjacency list first while calling constructor.\\nThen on calling addEdge  function we will append edge in our adjacency list.\\nAnd for shortestPath between two nodes we will be applying dijkstra\\'s\\nalgorithm which you can see below how i have applied in this question. \\n\\n\\n# Code\\n```\\nclass Graph {\\npublic:\\n    int s;\\n    unordered_map<int,vector<pair<int,int>>> mp;\\n    \\n    Graph(int n, vector<vector<int>>& edges) \\n    {\\n        s = n;\\n        for(auto i:edges)\\n        {\\n            int u = i[0];\\n            int v = i[1];\\n            int wt = i[2];\\n            mp[u].push_back({v,wt});\\n        }\\n\\n    }\\n    \\n    void addEdge(vector<int> edge) \\n    {\\n        int u = edge[0];\\n        int v = edge[1];\\n        int wt = edge[2];\\n        mp[u].push_back({v,wt});       \\n        \\n    }\\n    \\n    int shortestPath(int node1, int node2) \\n    {\\n        //Applying dijkstra\\'s\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> q;\\n        //we will be pushing 0 distance from node1 initially. \\n        q.push({0,node1});\\n        vector<int> dist(s,INT_MAX);\\n        dist[node1]=0;\\n        \\n        while(!q.empty())\\n        {\\n            int dis = q.top().first;\\n            int node = q.top().second;\\n            q.pop();\\n            for(auto i:mp[node])\\n            {\\n                int adjNode = i.first;\\n                int wt = i.second;\\n                if(dis+wt<dist[adjNode])\\n                {\\n                    dist[adjNode]=dis+wt;\\n                    q.push({dist[adjNode],adjNode});\\n                }\\n            }\\n        }\\n        return dist[node2]==INT_MAX?-1:dist[node2];\\n        \\n        \\n        \\n    }\\n};\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph* obj = new Graph(n, edges);\\n * obj->addEdge(edge);\\n * int param_2 = obj->shortestPath(node1,node2);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Graph {\\npublic:\\n    int s;\\n    unordered_map<int,vector<pair<int,int>>> mp;\\n    \\n    Graph(int n, vector<vector<int>>& edges) \\n    {\\n        s = n;\\n        for(auto i:edges)\\n        {\\n            int u = i[0];\\n            int v = i[1];\\n            int wt = i[2];\\n            mp[u].push_back({v,wt});\\n        }\\n\\n    }\\n    \\n    void addEdge(vector<int> edge) \\n    {\\n        int u = edge[0];\\n        int v = edge[1];\\n        int wt = edge[2];\\n        mp[u].push_back({v,wt});       \\n        \\n    }\\n    \\n    int shortestPath(int node1, int node2) \\n    {\\n        //Applying dijkstra\\'s\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> q;\\n        //we will be pushing 0 distance from node1 initially. \\n        q.push({0,node1});\\n        vector<int> dist(s,INT_MAX);\\n        dist[node1]=0;\\n        \\n        while(!q.empty())\\n        {\\n            int dis = q.top().first;\\n            int node = q.top().second;\\n            q.pop();\\n            for(auto i:mp[node])\\n            {\\n                int adjNode = i.first;\\n                int wt = i.second;\\n                if(dis+wt<dist[adjNode])\\n                {\\n                    dist[adjNode]=dis+wt;\\n                    q.push({dist[adjNode],adjNode});\\n                }\\n            }\\n        }\\n        return dist[node2]==INT_MAX?-1:dist[node2];\\n        \\n        \\n        \\n    }\\n};\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph* obj = new Graph(n, edges);\\n * obj->addEdge(edge);\\n * int param_2 = obj->shortestPath(node1,node2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3434829,
                "title": "c-basic-adjacency-list-disjkstra",
                "content": "```\\nint INF = 1e9;\\n#define pi pair<int, int>\\nclass Graph {\\npublic:\\n    vector<int> Adj[100];\\n    int Dist[101][101];\\n    int N;\\n    Graph(int n, vector<vector<int>>& edges) {\\n        N = n;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n                Dist[i][j] = INF;\\n        }\\n        for(auto &x : edges)\\n        {\\n            Adj[x[0]].push_back(x[1]);\\n            Dist[x[0]][x[1]] = x[2];\\n        }\\n    }\\n    \\n    void addEdge(vector<int> x) {\\n        Adj[x[0]].push_back(x[1]);\\n        Dist[x[0]][x[1]] = x[2];\\n    }\\n    \\n    int shortestPath(int node1, int node2){\\n        if(node1 == node2)return 0;\\n        priority_queue<pi, vector<pi>, greater<pi>> pq;\\n        pq.push({0, node1});\\n        vector<int> IsVisited(N, INF);\\n        IsVisited[node1] = 0;\\n        int ans = INF;\\n        while(!pq.empty())\\n        {\\n            pi a = pq.top();\\n            pq.pop();\\n            int idx = a.second, dist = a.first;\\n            for(auto &x : Adj[idx])\\n            {\\n                if(Dist[idx][x] + dist < IsVisited[x]){pq.push({Dist[idx][x] + dist, x});IsVisited[x] = Dist[idx][x] + dist;}\\n                if(x == node2)ans  = min(dist + Dist[idx][x], ans);\\n            }\\n        }\\n        return (ans == INF) ? -1 : ans;\\n    }\\n};\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph* obj = new Graph(n, edges);\\n * obj->addEdge(edge);\\n * int param_2 = obj->shortestPath(node1,node2);\\n */\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint INF = 1e9;\\n#define pi pair<int, int>\\nclass Graph {\\npublic:\\n    vector<int> Adj[100];\\n    int Dist[101][101];\\n    int N;\\n    Graph(int n, vector<vector<int>>& edges) {\\n        N = n;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n                Dist[i][j] = INF;\\n        }\\n        for(auto &x : edges)\\n        {\\n            Adj[x[0]].push_back(x[1]);\\n            Dist[x[0]][x[1]] = x[2];\\n        }\\n    }\\n    \\n    void addEdge(vector<int> x) {\\n        Adj[x[0]].push_back(x[1]);\\n        Dist[x[0]][x[1]] = x[2];\\n    }\\n    \\n    int shortestPath(int node1, int node2){\\n        if(node1 == node2)return 0;\\n        priority_queue<pi, vector<pi>, greater<pi>> pq;\\n        pq.push({0, node1});\\n        vector<int> IsVisited(N, INF);\\n        IsVisited[node1] = 0;\\n        int ans = INF;\\n        while(!pq.empty())\\n        {\\n            pi a = pq.top();\\n            pq.pop();\\n            int idx = a.second, dist = a.first;\\n            for(auto &x : Adj[idx])\\n            {\\n                if(Dist[idx][x] + dist < IsVisited[x]){pq.push({Dist[idx][x] + dist, x});IsVisited[x] = Dist[idx][x] + dist;}\\n                if(x == node2)ans  = min(dist + Dist[idx][x], ans);\\n            }\\n        }\\n        return (ans == INF) ? -1 : ans;\\n    }\\n};\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph* obj = new Graph(n, edges);\\n * obj->addEdge(edge);\\n * int param_2 = obj->shortestPath(node1,node2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3433955,
                "title": "java-99-80-no-need-to-re-process-all-of-floyd-warshall-when-adding-the-edge",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nGraph: O(N^3)\\naddEdge: O(N^2)\\nshortestPath: O(1)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Graph {\\n    final int inf = 500_000_000;\\n    int[][] dist;\\n    int n;\\n    \\n    public Graph(int n, int[][] edges) {\\n        dist = new int[n][n];\\n        this.n=n;\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n; j++){\\n                dist[i][j]=inf;\\n            }\\n            dist[i][i]=0;\\n        }\\n\\n        for(int[] e:edges)dist[e[0]][e[1]]=e[2];\\n\\n        for(int k=0; k<n; k++){\\n            for(int i=0; i<n; i++){\\n                for(int j=0; j<n; j++){\\n                    dist[i][j]=Math.min(dist[i][j], dist[i][k]+dist[k][j]);\\n                }\\n            }\\n        }\\n    }\\n    \\n    public void addEdge(int[] e) {\\n        if(dist[e[0]][e[1]]<=e[2])return;\\n\\n        dist[e[0]][e[1]]=e[2];\\n        for(int i=0; i<n; i++)\\n        for(int j=0; j<n; j++)\\n        dist[i][j]=Math.min(dist[i][j], dist[i][e[0]]+e[2]+dist[e[1]][j]);\\n    }\\n    \\n    public int shortestPath(int i1, int i2) {\\n        return dist[i1][i2]!=inf? dist[i1][i2]:-1;\\n    }\\n}\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph obj = new Graph(n, edges);\\n * obj.addEdge(edge);\\n * int param_2 = obj.shortestPath(node1,node2);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Graph {\\n    final int inf = 500_000_000;\\n    int[][] dist;\\n    int n;\\n    \\n    public Graph(int n, int[][] edges) {\\n        dist = new int[n][n];\\n        this.n=n;\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n; j++){\\n                dist[i][j]=inf;\\n            }\\n            dist[i][i]=0;\\n        }\\n\\n        for(int[] e:edges)dist[e[0]][e[1]]=e[2];\\n\\n        for(int k=0; k<n; k++){\\n            for(int i=0; i<n; i++){\\n                for(int j=0; j<n; j++){\\n                    dist[i][j]=Math.min(dist[i][j], dist[i][k]+dist[k][j]);\\n                }\\n            }\\n        }\\n    }\\n    \\n    public void addEdge(int[] e) {\\n        if(dist[e[0]][e[1]]<=e[2])return;\\n\\n        dist[e[0]][e[1]]=e[2];\\n        for(int i=0; i<n; i++)\\n        for(int j=0; j<n; j++)\\n        dist[i][j]=Math.min(dist[i][j], dist[i][e[0]]+e[2]+dist[e[1]][j]);\\n    }\\n    \\n    public int shortestPath(int i1, int i2) {\\n        return dist[i1][i2]!=inf? dist[i1][i2]:-1;\\n    }\\n}\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph obj = new Graph(n, edges);\\n * obj.addEdge(edge);\\n * int param_2 = obj.shortestPath(node1,node2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3433235,
                "title": "golang-simple-dijkstra",
                "content": "```\\ntype MinHeap [][2]int\\n\\nfunc (h MinHeap) Len() int            { return len(h) }\\nfunc (h MinHeap) Less(i, j int) bool  { return h[i][0] < h[j][0] }\\nfunc (h MinHeap) Swap(i, j int)       { h[i], h[j] = h[j], h[i] }\\nfunc (h *MinHeap) Push(x interface{}) { *h = append(*h, x.([2]int)) }\\nfunc (h *MinHeap) Pop() (v interface{}) {\\n\\t*h, v = (*h)[:len(*h)-1], (*h)[len(*h)-1]\\n\\treturn\\n}\\n\\ntype Graph struct {\\n    gr map[int][][2]int\\n    n int\\n}\\n\\n\\nfunc Constructor(n int, edges [][]int) Graph {\\n    gr := make(map[int][][2]int, n)\\n    for _, edge := range edges {\\n\\t\\tu, v, w := edge[0], edge[1], edge[2]\\n        gr[u] = append(gr[u], [2]int{w, v})\\n    }\\n    return Graph{\\n        gr:gr,\\n        n:n,\\n    }\\n}\\n\\n\\nfunc (g *Graph) AddEdge(edge []int)  {\\n    u, v, w := edge[0], edge[1], edge[2]\\n    g.gr[u] = append(g.gr[u], [2]int{w, v})\\n}\\n\\nconst inf = 1 << 31\\nfunc (g *Graph) ShortestPath(st int, ed int) int {\\n\\tdist := make([]int, g.n)\\n\\tfor i := range dist {\\n\\t\\tdist[i] = inf\\n\\t}\\n\\tdist[st] = 0\\n\\th := &MinHeap{}\\n\\theap.Init(h)\\n\\th.Push([2]int{0, st})\\n\\n\\tused := make([]bool, g.n)\\n\\n\\tfor h.Len() > 0 {\\n\\t\\te := heap.Pop(h).([2]int)\\n\\t\\tif used[e[1]] {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n        if e[1]==ed {\\n            return dist[ed]\\n        }\\n\\t\\tused[e[1]] = true\\n\\n\\t\\tconns := g.gr[e[1]]\\n\\t\\tfor i := range conns {\\n\\t\\t\\tne := conns[i]\\n\\t\\t\\tif dist[e[1]]+ne[0] < dist[ne[1]] {\\n\\t\\t\\t\\tdist[ne[1]] = dist[e[1]] + ne[0]\\n\\t\\t\\t\\theap.Push(h, [2]int{dist[ne[1]], ne[1]})\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n    return -1\\n}\\n\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * obj := Constructor(n, edges);\\n * obj.AddEdge(edge);\\n * param_2 := obj.ShortestPath(node1,node2);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\ntype MinHeap [][2]int\\n\\nfunc (h MinHeap) Len() int            { return len(h) }\\nfunc (h MinHeap) Less(i, j int) bool  { return h[i][0] < h[j][0] }\\nfunc (h MinHeap) Swap(i, j int)       { h[i], h[j] = h[j], h[i] }\\nfunc (h *MinHeap) Push(x interface{}) { *h = append(*h, x.([2]int)) }\\nfunc (h *MinHeap) Pop() (v interface{}) {\\n\\t*h, v = (*h)[:len(*h)-1], (*h)[len(*h)-1]\\n\\treturn\\n}\\n\\ntype Graph struct {\\n    gr map[int][][2]int\\n    n int\\n}\\n\\n\\nfunc Constructor(n int, edges [][]int) Graph {\\n    gr := make(map[int][][2]int, n)\\n    for _, edge := range edges {\\n\\t\\tu, v, w := edge[0], edge[1], edge[2]\\n        gr[u] = append(gr[u], [2]int{w, v})\\n    }\\n    return Graph{\\n        gr:gr,\\n        n:n,\\n    }\\n}\\n\\n\\nfunc (g *Graph) AddEdge(edge []int)  {\\n    u, v, w := edge[0], edge[1], edge[2]\\n    g.gr[u] = append(g.gr[u], [2]int{w, v})\\n}\\n\\nconst inf = 1 << 31\\nfunc (g *Graph) ShortestPath(st int, ed int) int {\\n\\tdist := make([]int, g.n)\\n\\tfor i := range dist {\\n\\t\\tdist[i] = inf\\n\\t}\\n\\tdist[st] = 0\\n\\th := &MinHeap{}\\n\\theap.Init(h)\\n\\th.Push([2]int{0, st})\\n\\n\\tused := make([]bool, g.n)\\n\\n\\tfor h.Len() > 0 {\\n\\t\\te := heap.Pop(h).([2]int)\\n\\t\\tif used[e[1]] {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n        if e[1]==ed {\\n            return dist[ed]\\n        }\\n\\t\\tused[e[1]] = true\\n\\n\\t\\tconns := g.gr[e[1]]\\n\\t\\tfor i := range conns {\\n\\t\\t\\tne := conns[i]\\n\\t\\t\\tif dist[e[1]]+ne[0] < dist[ne[1]] {\\n\\t\\t\\t\\tdist[ne[1]] = dist[e[1]] + ne[0]\\n\\t\\t\\t\\theap.Push(h, [2]int{dist[ne[1]], ne[1]})\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n    return -1\\n}\\n\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * obj := Constructor(n, edges);\\n * obj.AddEdge(edge);\\n * param_2 := obj.ShortestPath(node1,node2);\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3432236,
                "title": "dijkstra-s-algorithm-to-find-the-shortest-path",
                "content": "# Intuition\\nWe need to use Dijkstra Algorithm whenever shortestPath function is called. \\n\\n# Approach\\n- Dijkstra Algorithm for Graphs. \\n\\n# Complexity\\n- Time complexity: O(N2)\\n\\n- Space complexity: O(N)\\n\\n# Code\\n```\\nclass Graph {\\n    public int vertices;\\n    public Map<Integer, List<int[]>> adjList;\\n    public Graph(int n, int[][] edges) {\\n        this.vertices = n;\\n        this.adjList = new HashMap<>();\\n        for(int i=0; i<edges.length; i++){\\n            int[] edge = edges[i];\\n            if(!adjList.containsKey(edge[0])){\\n                adjList.put(edge[0], new ArrayList<>());\\n            }\\n            adjList.get(edge[0]).add(new int[]{edge[1], edge[2]});\\n        }\\n    }\\n    \\n    public void addEdge(int[] edge) {\\n        if(!adjList.containsKey(edge[0])){\\n                adjList.put(edge[0], new ArrayList<>());\\n        }\\n        adjList.get(edge[0]).add(new int[]{edge[1], edge[2]});\\n    }\\n    \\n    public int shortestPath(int node1, int node2) {\\n        boolean[] sptSet = new boolean[vertices];\\n        for(int i=0; i<vertices; i++){\\n            sptSet[i] = false;\\n        }\\n\\n        int[] shortestPath = new int[this.vertices];\\n        for(int i=0; i<vertices; i++){\\n            shortestPath[i] = Integer.MAX_VALUE;\\n        }\\n        shortestPath[node1] = 0;\\n        util(node1, sptSet, shortestPath);\\n        if(shortestPath[node2] == Integer.MAX_VALUE){\\n            return -1;\\n        }else{\\n            return shortestPath[node2];\\n        }\\n    }\\n\\n    public void util(Integer node, boolean[] sptSet, int[] shortestPath){\\n        \\n        Map<Integer, List<int[]>> temp = this.adjList;\\n\\n        for(int i=0; i<this.vertices; i++){\\n            int currentNode = getNewNode(sptSet, shortestPath);\\n            if(currentNode == -1){\\n                continue;\\n            }\\n            int currentShort = shortestPath[currentNode];\\n            List<int[]> neigs = adjList.getOrDefault(currentNode, new ArrayList<>());\\n            sptSet[currentNode] = true;\\n\\n            for(int j =0; j< neigs.size(); j++){\\n                int[] neig = neigs.get(j);\\n                int dest = neig[0];\\n                int cost = neig[1];\\n                if(currentShort + cost < shortestPath[dest]){\\n                    shortestPath[dest] = currentShort + cost;\\n                }\\n            }\\n        }\\n    }\\n\\n    public int getNewNode(boolean[] sptSet, int[] shortestPath){\\n        int index = -1;\\n        int min = Integer.MAX_VALUE;\\n        for(int i=0; i<this.vertices; i++){\\n            if(sptSet[i] == false && shortestPath[i] < min){\\n                min = shortestPath[i];\\n                index = i;\\n            }\\n        }\\n        return index;\\n    }\\n}\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph obj = new Graph(n, edges);\\n * obj.addEdge(edge);\\n * int param_2 = obj.shortestPath(node1,node2);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Graph"
                ],
                "code": "```\\nclass Graph {\\n    public int vertices;\\n    public Map<Integer, List<int[]>> adjList;\\n    public Graph(int n, int[][] edges) {\\n        this.vertices = n;\\n        this.adjList = new HashMap<>();\\n        for(int i=0; i<edges.length; i++){\\n            int[] edge = edges[i];\\n            if(!adjList.containsKey(edge[0])){\\n                adjList.put(edge[0], new ArrayList<>());\\n            }\\n            adjList.get(edge[0]).add(new int[]{edge[1], edge[2]});\\n        }\\n    }\\n    \\n    public void addEdge(int[] edge) {\\n        if(!adjList.containsKey(edge[0])){\\n                adjList.put(edge[0], new ArrayList<>());\\n        }\\n        adjList.get(edge[0]).add(new int[]{edge[1], edge[2]});\\n    }\\n    \\n    public int shortestPath(int node1, int node2) {\\n        boolean[] sptSet = new boolean[vertices];\\n        for(int i=0; i<vertices; i++){\\n            sptSet[i] = false;\\n        }\\n\\n        int[] shortestPath = new int[this.vertices];\\n        for(int i=0; i<vertices; i++){\\n            shortestPath[i] = Integer.MAX_VALUE;\\n        }\\n        shortestPath[node1] = 0;\\n        util(node1, sptSet, shortestPath);\\n        if(shortestPath[node2] == Integer.MAX_VALUE){\\n            return -1;\\n        }else{\\n            return shortestPath[node2];\\n        }\\n    }\\n\\n    public void util(Integer node, boolean[] sptSet, int[] shortestPath){\\n        \\n        Map<Integer, List<int[]>> temp = this.adjList;\\n\\n        for(int i=0; i<this.vertices; i++){\\n            int currentNode = getNewNode(sptSet, shortestPath);\\n            if(currentNode == -1){\\n                continue;\\n            }\\n            int currentShort = shortestPath[currentNode];\\n            List<int[]> neigs = adjList.getOrDefault(currentNode, new ArrayList<>());\\n            sptSet[currentNode] = true;\\n\\n            for(int j =0; j< neigs.size(); j++){\\n                int[] neig = neigs.get(j);\\n                int dest = neig[0];\\n                int cost = neig[1];\\n                if(currentShort + cost < shortestPath[dest]){\\n                    shortestPath[dest] = currentShort + cost;\\n                }\\n            }\\n        }\\n    }\\n\\n    public int getNewNode(boolean[] sptSet, int[] shortestPath){\\n        int index = -1;\\n        int min = Integer.MAX_VALUE;\\n        for(int i=0; i<this.vertices; i++){\\n            if(sptSet[i] == false && shortestPath[i] < min){\\n                min = shortestPath[i];\\n                index = i;\\n            }\\n        }\\n        return index;\\n    }\\n}\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph obj = new Graph(n, edges);\\n * obj.addEdge(edge);\\n * int param_2 = obj.shortestPath(node1,node2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3432171,
                "title": "scala-dijkstra",
                "content": "# Code\\n```  \\n\\nclass Graph(_n: Int, _edges: Array[Array[Int]]) {\\n\\n  type Vertex = Int\\n\\n  val edgeMap = scala.collection.mutable.Map.empty[Vertex, List[(Vertex, Int)]].withDefaultValue(List.empty)\\n  _edges.foreach(addEdge)\\n\\n  def addEdge(arr: Array[Int]): Unit =\\n    edgeMap(arr(0)) ::= (arr(1), arr(2))\\n\\n  def shortestPath(node1: Int, node2: Int): Int = {\\n    val visited = scala.collection.mutable.Set.empty[Vertex]\\n    val queue = scala.collection.mutable.PriorityQueue((0, node1)).reverse\\n    def goFind: Int =\\n      if(queue.isEmpty) -1\\n      else {\\n        val (cost, vertex) = queue.dequeue()\\n        if (!visited.add(vertex)) goFind\\n        else if (vertex == node2) cost\\n        else {\\n          edgeMap(vertex).foreach { case (to, edgeCost) => queue.enqueue((cost + edgeCost, to)) }\\n          goFind\\n        }\\n      }\\n\\n    goFind\\n  }\\n}\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * var obj = new Graph(n, edges)\\n * obj.addEdge(edge)\\n * var param_2 = obj.shortestPath(node1,node2)\\n */\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```  \\n\\nclass Graph(_n: Int, _edges: Array[Array[Int]]) {\\n\\n  type Vertex = Int\\n\\n  val edgeMap = scala.collection.mutable.Map.empty[Vertex, List[(Vertex, Int)]].withDefaultValue(List.empty)\\n  _edges.foreach(addEdge)\\n\\n  def addEdge(arr: Array[Int]): Unit =\\n    edgeMap(arr(0)) ::= (arr(1), arr(2))\\n\\n  def shortestPath(node1: Int, node2: Int): Int = {\\n    val visited = scala.collection.mutable.Set.empty[Vertex]\\n    val queue = scala.collection.mutable.PriorityQueue((0, node1)).reverse\\n    def goFind: Int =\\n      if(queue.isEmpty) -1\\n      else {\\n        val (cost, vertex) = queue.dequeue()\\n        if (!visited.add(vertex)) goFind\\n        else if (vertex == node2) cost\\n        else {\\n          edgeMap(vertex).foreach { case (to, edgeCost) => queue.enqueue((cost + edgeCost, to)) }\\n          goFind\\n        }\\n      }\\n\\n    goFind\\n  }\\n}\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * var obj = new Graph(n, edges)\\n * obj.addEdge(edge)\\n * var param_2 = obj.shortestPath(node1,node2)\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3431395,
                "title": "java-easy-to-understand-bfs-with-priorityqueue",
                "content": "```\\nclass Graph {\\n    List<List<int[]>> graph;\\n    int N;\\n    public Graph(int n, int[][] edges) {\\n        graph = new ArrayList<>();\\n        N = n;\\n        for(int i = 0; i < n; i++) graph.add(new ArrayList<>());\\n        for(int[] edge: edges) graph.get(edge[0]).add(new int[]{edge[1], edge[2]});\\n    }\\n    \\n    public void addEdge(int[] edge) {\\n        graph.get(edge[0]).add(new int[]{edge[1], edge[2]});\\n    }\\n    \\n    public int shortestPath(int node1, int node2) {\\n        Queue<int[]> que = new PriorityQueue<>((a, b) -> Integer.compare(a[1], b[1]));\\n        boolean[] visited = new boolean[N];\\n        que.offer(new int[]{node1, 0});\\n        int res = Integer.MAX_VALUE;\\n        while(!que.isEmpty()){\\n            int[] cur = que.poll();\\n            visited[cur[0]] = true;\\n            if(cur[0] == node2){\\n                return cur[1];\\n            }\\n            List<int[]> neighbors = graph.get(cur[0]);\\n            for(int[] neighbor: neighbors){\\n                if(visited[neighbor[0]]) continue;\\n                que.offer(new int[]{neighbor[0], cur[1] + neighbor[1]});\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Graph {\\n    List<List<int[]>> graph;\\n    int N;\\n    public Graph(int n, int[][] edges) {\\n        graph = new ArrayList<>();\\n        N = n;\\n        for(int i = 0; i < n; i++) graph.add(new ArrayList<>());\\n        for(int[] edge: edges) graph.get(edge[0]).add(new int[]{edge[1], edge[2]});\\n    }\\n    \\n    public void addEdge(int[] edge) {\\n        graph.get(edge[0]).add(new int[]{edge[1], edge[2]});\\n    }\\n    \\n    public int shortestPath(int node1, int node2) {\\n        Queue<int[]> que = new PriorityQueue<>((a, b) -> Integer.compare(a[1], b[1]));\\n        boolean[] visited = new boolean[N];\\n        que.offer(new int[]{node1, 0});\\n        int res = Integer.MAX_VALUE;\\n        while(!que.isEmpty()){\\n            int[] cur = que.poll();\\n            visited[cur[0]] = true;\\n            if(cur[0] == node2){\\n                return cur[1];\\n            }\\n            List<int[]> neighbors = graph.get(cur[0]);\\n            for(int[] neighbor: neighbors){\\n                if(visited[neighbor[0]]) continue;\\n                que.offer(new int[]{neighbor[0], cur[1] + neighbor[1]});\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3430373,
                "title": "dijkstra-and-relax-weight",
                "content": "```\\nclass Graph {\\npublic:\\n    vector<vector<int> > mPath;\\n    int n;\\n    Graph(int n, vector<vector<int>>& edges) {\\n        this->n = n;\\n        mPath = *(new vector<vector<int> >(n, vector<int>(n, -1)));\\n        vector<vector<pair<int, int> > > adj(n, vector<pair<int, int> >());\\n        for(vector<int> x: edges){\\n            adj[x[0]].push_back({x[2], x[1]});\\n        }\\n        priority_queue<pair<int, int>, vector<pair<int, int> >, greater<pair<int,int> > > pq;\\n        int d;\\n        for(int i = 0; i < n; i++){\\n            mPath[i][i] = 0;\\n            pq.push({0, i});\\n            vector<int> reached(n, 0);\\n            while(!pq.empty()){\\n                d = pq.top().second;\\n                pq.pop();\\n                if(reached[d]) continue;\\n                reached[d] = 1;\\n                for(pair<int, int> x: adj[d]){\\n                    if(mPath[i][x.second] == -1 || mPath[i][x.second] > mPath[i][d] + x.first) {\\n                        mPath[i][x.second] = mPath[i][d] + x.first;\\n                        pq.push({mPath[i][x.second], x.second});\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    \\n    void addEdge(vector<int> edge) {\\n        int x, y;\\n        for(int i = 0; i < n; i++){\\n            x = mPath[i][edge[0]];\\n            if(x != -1){\\n                for(int j = 0; j < n; j++){\\n                    y = mPath[edge[1]][j];\\n                    if(y != -1){\\n                        if(mPath[i][j] == -1 || mPath[i][j] > x + edge[2] + y){\\n                            mPath[i][j] = x + edge[2] + y;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    \\n    int shortestPath(int node1, int node2) {\\n        return mPath[node1][node2];\\n    }\\n};\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph* obj = new Graph(n, edges);\\n * obj->addEdge(edge);\\n * int param_2 = obj->shortestPath(node1,node2);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass Graph {\\npublic:\\n    vector<vector<int> > mPath;\\n    int n;\\n    Graph(int n, vector<vector<int>>& edges) {\\n        this->n = n;\\n        mPath = *(new vector<vector<int> >(n, vector<int>(n, -1)));\\n        vector<vector<pair<int, int> > > adj(n, vector<pair<int, int> >());\\n        for(vector<int> x: edges){\\n            adj[x[0]].push_back({x[2], x[1]});\\n        }\\n        priority_queue<pair<int, int>, vector<pair<int, int> >, greater<pair<int,int> > > pq;\\n        int d;\\n        for(int i = 0; i < n; i++){\\n            mPath[i][i] = 0;\\n            pq.push({0, i});\\n            vector<int> reached(n, 0);\\n            while(!pq.empty()){\\n                d = pq.top().second;\\n                pq.pop();\\n                if(reached[d]) continue;\\n                reached[d] = 1;\\n                for(pair<int, int> x: adj[d]){\\n                    if(mPath[i][x.second] == -1 || mPath[i][x.second] > mPath[i][d] + x.first) {\\n                        mPath[i][x.second] = mPath[i][d] + x.first;\\n                        pq.push({mPath[i][x.second], x.second});\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    \\n    void addEdge(vector<int> edge) {\\n        int x, y;\\n        for(int i = 0; i < n; i++){\\n            x = mPath[i][edge[0]];\\n            if(x != -1){\\n                for(int j = 0; j < n; j++){\\n                    y = mPath[edge[1]][j];\\n                    if(y != -1){\\n                        if(mPath[i][j] == -1 || mPath[i][j] > x + edge[2] + y){\\n                            mPath[i][j] = x + edge[2] + y;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    \\n    int shortestPath(int node1, int node2) {\\n        return mPath[node1][node2];\\n    }\\n};\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph* obj = new Graph(n, edges);\\n * obj->addEdge(edge);\\n * int param_2 = obj->shortestPath(node1,node2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3429577,
                "title": "100-acceptance-easy-simple-approach-beginner-friendly-solution",
                "content": "# Code\\n```\\nclass Graph {\\n    List<int[]>[] adjList;\\n    int n;\\n    \\n    public int shortestPath(int node1, int node2) {\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[1] - b[1]);\\n        int[] dist = new int[n];\\n        Arrays.fill(dist, Integer.MAX_VALUE);\\n        dist[node1] = 0;\\n        pq.offer(new int[]{node1, 0});\\n        while (!pq.isEmpty()) {\\n            int[] curr = pq.poll();\\n            int node = curr[0], distance = curr[1];\\n            if (node == node2) {\\n                return distance;\\n            }\\n            if (distance > dist[node]) {\\n                continue;\\n            }\\n            for (int[] neighbor : adjList[node]) {\\n                int nextNode = neighbor[0], edgeCost = neighbor[1];\\n                int newDist = distance + edgeCost;\\n                if (newDist < dist[nextNode]) {\\n                    dist[nextNode] = newDist;\\n                    pq.offer(new int[]{nextNode, newDist});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n       \\n    public void addEdge(int[] edge) {\\n        int from = edge[0], to = edge[1], cost = edge[2];\\n        adjList[from].add(new int[]{to, cost});\\n    }\\n    \\n    public Graph(int n, int[][] edges) {\\n        this.n = n;\\n        adjList = new List[n];\\n        for (int i = 0; i < n; i++) {\\n            adjList[i] = new ArrayList<>();\\n        }\\n        for (int[] edge : edges) {\\n            int from = edge[0], to = edge[1], cost = edge[2];\\n            adjList[from].add(new int[]{to, cost});\\n        }\\n    }\\n \\n}\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph obj = new Graph(n, edges);\\n * obj.addEdge(edge);\\n * int param_2 = obj.shortestPath(node1,node2);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Graph",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Graph {\\n    List<int[]>[] adjList;\\n    int n;\\n    \\n    public int shortestPath(int node1, int node2) {\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[1] - b[1]);\\n        int[] dist = new int[n];\\n        Arrays.fill(dist, Integer.MAX_VALUE);\\n        dist[node1] = 0;\\n        pq.offer(new int[]{node1, 0});\\n        while (!pq.isEmpty()) {\\n            int[] curr = pq.poll();\\n            int node = curr[0], distance = curr[1];\\n            if (node == node2) {\\n                return distance;\\n            }\\n            if (distance > dist[node]) {\\n                continue;\\n            }\\n            for (int[] neighbor : adjList[node]) {\\n                int nextNode = neighbor[0], edgeCost = neighbor[1];\\n                int newDist = distance + edgeCost;\\n                if (newDist < dist[nextNode]) {\\n                    dist[nextNode] = newDist;\\n                    pq.offer(new int[]{nextNode, newDist});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n       \\n    public void addEdge(int[] edge) {\\n        int from = edge[0], to = edge[1], cost = edge[2];\\n        adjList[from].add(new int[]{to, cost});\\n    }\\n    \\n    public Graph(int n, int[][] edges) {\\n        this.n = n;\\n        adjList = new List[n];\\n        for (int i = 0; i < n; i++) {\\n            adjList[i] = new ArrayList<>();\\n        }\\n        for (int[] edge : edges) {\\n            int from = edge[0], to = edge[1], cost = edge[2];\\n            adjList[from].add(new int[]{to, cost});\\n        }\\n    }\\n \\n}\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph obj = new Graph(n, edges);\\n * obj.addEdge(edge);\\n * int param_2 = obj.shortestPath(node1,node2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3428004,
                "title": "classic-dijkstra",
                "content": "\\n# Code\\n```\\nclass Graph:\\n\\n    def __init__(self, n: int, edges: List[List[int]]):\\n        self.out = [[] for _ in range(n)]\\n        self.n = n\\n        for a, b, v in edges:\\n            self.out[a].append((b, v))\\n        \\n    def addEdge(self, edge: List[int]) -> None:\\n        self.out[edge[0]].append((edge[1], edge[2]))\\n        \\n    def shortestPath(self, node1: int, node2: int) -> int:\\n        col = [0] * self.n\\n        heap = [(0, node1)]\\n        while heap:\\n            dist, node = heapq.heappop(heap)\\n            if col[node] == 2:\\n                continue\\n            if node == node2:\\n                return dist\\n            col[node] = 2\\n            for neigh, val in self.out[node]:\\n                if col[neigh] != 2:\\n                    heapq.heappush(heap, (dist+val, neigh))\\n        return -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Graph:\\n\\n    def __init__(self, n: int, edges: List[List[int]]):\\n        self.out = [[] for _ in range(n)]\\n        self.n = n\\n        for a, b, v in edges:\\n            self.out[a].append((b, v))\\n        \\n    def addEdge(self, edge: List[int]) -> None:\\n        self.out[edge[0]].append((edge[1], edge[2]))\\n        \\n    def shortestPath(self, node1: int, node2: int) -> int:\\n        col = [0] * self.n\\n        heap = [(0, node1)]\\n        while heap:\\n            dist, node = heapq.heappop(heap)\\n            if col[node] == 2:\\n                continue\\n            if node == node2:\\n                return dist\\n            col[node] = 2\\n            for neigh, val in self.out[node]:\\n                if col[neigh] != 2:\\n                    heapq.heappush(heap, (dist+val, neigh))\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3427477,
                "title": "python3-solution",
                "content": "```\\nclass Graph:\\n    \\n    def __init__(self, n: int, edges: List[List[int]]):\\n        self.graph = defaultdict(list)\\n        self.len = n\\n        \\n        for edge in edges:\\n            self.addEdge(edge)\\n        \\n\\n    def addEdge(self, edge: List[int]) -> None:\\n        x, y, cost = edge[0], edge[1], edge[2]\\n        self.graph[x].append([y, cost])\\n        \\n\\n    def shortestPath(self, node1: int, node2: int) -> int:\\n        \\n        pq = []\\n        \\n        dist = [sys.maxsize] * self.len\\n        \\n        heapq.heappush(pq, (0, node1))\\n        dist[node1] = 0\\n        \\n        while pq:\\n            cost, curr = heapq.heappop(pq)\\n            if curr == node2:\\n                return cost\\n            for neighbour, cost in self.graph[curr]:\\n                if dist[neighbour] > dist[curr] + cost:\\n                    dist[neighbour] = dist[curr] + cost\\n                    heapq.heappush(pq, (dist[neighbour], neighbour))\\n        return -1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Graph:\\n    \\n    def __init__(self, n: int, edges: List[List[int]]):\\n        self.graph = defaultdict(list)\\n        self.len = n\\n        \\n        for edge in edges:\\n            self.addEdge(edge)\\n        \\n\\n    def addEdge(self, edge: List[int]) -> None:\\n        x, y, cost = edge[0], edge[1], edge[2]\\n        self.graph[x].append([y, cost])\\n        \\n\\n    def shortestPath(self, node1: int, node2: int) -> int:\\n        \\n        pq = []\\n        \\n        dist = [sys.maxsize] * self.len\\n        \\n        heapq.heappush(pq, (0, node1))\\n        dist[node1] = 0\\n        \\n        while pq:\\n            cost, curr = heapq.heappop(pq)\\n            if curr == node2:\\n                return cost\\n            for neighbour, cost in self.graph[curr]:\\n                if dist[neighbour] > dist[curr] + cost:\\n                    dist[neighbour] = dist[curr] + cost\\n                    heapq.heappush(pq, (dist[neighbour], neighbour))\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3427440,
                "title": "dijkstra-c-with-comments",
                "content": "The problem is to create a graph and then use the dijkstra alogrithm to find the shortest distance between the two nodes.\\n\\n# Code\\n```\\nclass Graph {\\npublic:\\n// creation of an adjaceny list.\\n    unordered_map<int, vector<pair<int, int> > > adj;\\n    int count;\\n    Graph(int n, vector<vector<int>>& edges) {\\n        //intialization of object\\n        //called intially for the creation of graph\\n        for(auto x : edges){\\n            adj[x[0]].push_back({x[1], x[2]});\\n            // this is simple graph creation, kind of an adjacency list\\n        }\\n        count = n;\\n    }\\n    \\n    void addEdge(vector<int> edge) {\\n        // basically we need to add the graph edge with the corresponding weight\\n        // so we\\'ve created a graph and just map (u,v) with the corresponding edge weight\\n        adj[edge[0]].push_back({edge[1], edge[2]});\\n    }\\n    \\n    int shortestPath(int node1, int node2) {\\n        // to find the shortest path, we use dijkstra\\'s : striver approach of set\\n\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int> > > pq;\\n        pq.push({0,node1}); // 0,0;\\n        vector<int> dist(count+1, 1e9);\\n        dist[node1] = 0; // dist[S] = 0\\n\\n        while(!pq.empty()){\\n            int dis = pq.top().first;\\n            int node = pq.top().second;\\n            pq.pop();\\n\\n            for(auto it : adj[node]){\\n                if(dis + it.second < dist[it.first]){\\n                    dist[it.first] = dis + it.second;\\n                    pq.push({dist[it.first], it.first});\\n                }\\n            }\\n        }\\n\\n        // now we check that whether the node2 was reachable or not,,\\n        // if not return -1\\n        // else the distance array gives you the distance from node1 to node2\\n        if(dist[node2] == 1e9) return -1;\\n        else return dist[node2];\\n    }\\n};\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph* obj = new Graph(n, edges);\\n * obj->addEdge(edge);\\n * int param_2 = obj->shortestPath(node1,node2);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Graph {\\npublic:\\n// creation of an adjaceny list.\\n    unordered_map<int, vector<pair<int, int> > > adj;\\n    int count;\\n    Graph(int n, vector<vector<int>>& edges) {\\n        //intialization of object\\n        //called intially for the creation of graph\\n        for(auto x : edges){\\n            adj[x[0]].push_back({x[1], x[2]});\\n            // this is simple graph creation, kind of an adjacency list\\n        }\\n        count = n;\\n    }\\n    \\n    void addEdge(vector<int> edge) {\\n        // basically we need to add the graph edge with the corresponding weight\\n        // so we\\'ve created a graph and just map (u,v) with the corresponding edge weight\\n        adj[edge[0]].push_back({edge[1], edge[2]});\\n    }\\n    \\n    int shortestPath(int node1, int node2) {\\n        // to find the shortest path, we use dijkstra\\'s : striver approach of set\\n\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int> > > pq;\\n        pq.push({0,node1}); // 0,0;\\n        vector<int> dist(count+1, 1e9);\\n        dist[node1] = 0; // dist[S] = 0\\n\\n        while(!pq.empty()){\\n            int dis = pq.top().first;\\n            int node = pq.top().second;\\n            pq.pop();\\n\\n            for(auto it : adj[node]){\\n                if(dis + it.second < dist[it.first]){\\n                    dist[it.first] = dis + it.second;\\n                    pq.push({dist[it.first], it.first});\\n                }\\n            }\\n        }\\n\\n        // now we check that whether the node2 was reachable or not,,\\n        // if not return -1\\n        // else the distance array gives you the distance from node1 to node2\\n        if(dist[node2] == 1e9) return -1;\\n        else return dist[node2];\\n    }\\n};\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph* obj = new Graph(n, edges);\\n * obj->addEdge(edge);\\n * int param_2 = obj->shortestPath(node1,node2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3427115,
                "title": "tc-sc-dijistra-algo-grapgh-min-priority-queue-adj-list",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n making the adj list globally to access the whole classes\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nsteps are:\\n      1. Making the Adj list \\n      2. Making the vis or cost vector for storing the dis.\\n      3. Then dijistra algo (simple)\\n      3. Return the vis[node2] if , it is not INT_MAX or -1.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n     O(E*log(N))\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n   O(N+E) + O(N)  --> for(adj list and vis/cost vector)\\n\\n# Code\\n```\\n\\n\\n \\ntypedef  pair<int,int> pi;\\n#define pq priority_queue<pi,vector<pi>,greater<pi>>\\n\\n    int dijistra( int st, int end , int node,  vector<vector< pair<int,long long>>> &adj)\\n  {\\n \\n     vector<int>vis(node,INT_MAX);\\n      pq minH;\\n     minH.push({0,st});\\n     vis[st]=0;\\n     while(!minH.empty() && minH.top().second!=end)\\n     {\\n          auto [currD,currN]=minH.top();\\n         minH.pop();\\n         if(currD>vis[currN]) \\n         continue;\\n         for(auto &[adjN,adjD]:adj[currN])\\n         {\\n             if(adjD+currD<vis[adjN])\\n             {\\n                 vis[adjN]=adjD+currD;\\n                   minH.push({vis[adjN],adjN});\\n             }\\n             \\n         }\\n     }\\n     return vis[end]!=INT_MAX ? vis[end] :-1; \\n\\n  }\\n\\n\\nclass Graph {\\npublic:\\n    \\n\\n        \\n        vector<vector< pair<int,long long>   >> adj;\\n       \\n       \\n    Graph(int n, vector<vector<int>>& edges) {\\n           adj.resize(n);\\n        for( auto &e:edges)\\n        {\\n            adj[e[0]].push_back({e[1],e[2]});\\n        }\\n     \\n\\n    }\\n    \\n    void addEdge(vector<int> edge) {\\n        adj[edge[0]].push_back({edge[1],edge[2]});\\n    }\\n    \\n    int shortestPath(int node1, int node2) {\\n        return dijistra(node1,node2, adj.size(),adj);\\n    }\\n};\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph* obj = new Graph(n, edges);\\n * obj->addEdge(edge);\\n * int param_2 = obj->shortestPath(node1,node2);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\n\\n \\ntypedef  pair<int,int> pi;\\n#define pq priority_queue<pi,vector<pi>,greater<pi>>\\n\\n    int dijistra( int st, int end , int node,  vector<vector< pair<int,long long>>> &adj)\\n  {\\n \\n     vector<int>vis(node,INT_MAX);\\n      pq minH;\\n     minH.push({0,st});\\n     vis[st]=0;\\n     while(!minH.empty() && minH.top().second!=end)\\n     {\\n          auto [currD,currN]=minH.top();\\n         minH.pop();\\n         if(currD>vis[currN]) \\n         continue;\\n         for(auto &[adjN,adjD]:adj[currN])\\n         {\\n             if(adjD+currD<vis[adjN])\\n             {\\n                 vis[adjN]=adjD+currD;\\n                   minH.push({vis[adjN],adjN});\\n             }\\n             \\n         }\\n     }\\n     return vis[end]!=INT_MAX ? vis[end] :-1; \\n\\n  }\\n\\n\\nclass Graph {\\npublic:\\n    \\n\\n        \\n        vector<vector< pair<int,long long>   >> adj;\\n       \\n       \\n    Graph(int n, vector<vector<int>>& edges) {\\n           adj.resize(n);\\n        for( auto &e:edges)\\n        {\\n            adj[e[0]].push_back({e[1],e[2]});\\n        }\\n     \\n\\n    }\\n    \\n    void addEdge(vector<int> edge) {\\n        adj[edge[0]].push_back({edge[1],edge[2]});\\n    }\\n    \\n    int shortestPath(int node1, int node2) {\\n        return dijistra(node1,node2, adj.size(),adj);\\n    }\\n};\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph* obj = new Graph(n, edges);\\n * obj->addEdge(edge);\\n * int param_2 = obj->shortestPath(node1,node2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3426279,
                "title": "dijekstra-s-algorithm",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust run dijekstra for all pairs of shortest paths.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- 100*(N^3)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(N*N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Graph {\\npublic:\\n    vector<vector<pair<int,int>>> adj;\\n    \\n    Graph(int n, vector<vector<int>>& edges) {\\n        adj.resize(n);\\n       for(auto &i: edges){\\n           adj[i[0]].push_back({i[1], i[2]});\\n       }\\n       \\n    }\\n    \\n    void addEdge(vector<int> edge) {\\n        adj[edge[0]].push_back({edge[1], edge[2]});\\n    }\\n    \\n    int shortestPath(int node1, int node2) {\\n        set<pair<int,int>> q;\\n        q.insert({0,node1});\\n        vector<int> visited(adj.size(), 0);\\n        vector<int> dist(adj.size(), 1e9);\\n        dist[node1]=0;\\n        \\n        while(!q.empty()){\\n            pair<int,int> node = *q.begin();\\n            visited[node.second]=1;\\n            q.erase(q.begin());\\n            \\n            for(auto &i: adj[node.second]){\\n                if(!visited[i.first]){\\n                    dist[i.first]=min(dist[i.first], i.second+node.first);\\n                    q.insert({dist[i.first], i.first});\\n                }\\n            }\\n        }\\n        \\n        if(dist[node2]==1e9){\\n            return -1;\\n        }\\n        return dist[node2];   \\n    }\\n};\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph* obj = new Graph(n, edges);\\n * obj->addEdge(edge);\\n * int param_2 = obj->shortestPath(node1,node2);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Graph {\\npublic:\\n    vector<vector<pair<int,int>>> adj;\\n    \\n    Graph(int n, vector<vector<int>>& edges) {\\n        adj.resize(n);\\n       for(auto &i: edges){\\n           adj[i[0]].push_back({i[1], i[2]});\\n       }\\n       \\n    }\\n    \\n    void addEdge(vector<int> edge) {\\n        adj[edge[0]].push_back({edge[1], edge[2]});\\n    }\\n    \\n    int shortestPath(int node1, int node2) {\\n        set<pair<int,int>> q;\\n        q.insert({0,node1});\\n        vector<int> visited(adj.size(), 0);\\n        vector<int> dist(adj.size(), 1e9);\\n        dist[node1]=0;\\n        \\n        while(!q.empty()){\\n            pair<int,int> node = *q.begin();\\n            visited[node.second]=1;\\n            q.erase(q.begin());\\n            \\n            for(auto &i: adj[node.second]){\\n                if(!visited[i.first]){\\n                    dist[i.first]=min(dist[i.first], i.second+node.first);\\n                    q.insert({dist[i.first], i.first});\\n                }\\n            }\\n        }\\n        \\n        if(dist[node2]==1e9){\\n            return -1;\\n        }\\n        return dist[node2];   \\n    }\\n};\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph* obj = new Graph(n, edges);\\n * obj->addEdge(edge);\\n * int param_2 = obj->shortestPath(node1,node2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3426209,
                "title": "c-beat-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDijkstra\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Graph {\\npublic:\\n    vector<vector<int>> e;\\n    Graph(int n, vector<vector<int>>& edges) {\\n        e=vector<vector<int>>(n,vector<int>(n,INT_MAX));\\n        for(auto x:edges){\\n            e[x[0]][x[1]]=x[2];\\n        }\\n    }\\n    \\n    void addEdge(vector<int> edge) {\\n        e[edge[0]][edge[1]]=edge[2];\\n    }\\n    \\n    int shortestPath(int node1, int node2) {\\n        int n=e.size();\\n        vector<int> dis(n,INT_MAX),vis(n);\\n        dis[node1]=0;\\n        while(1){\\n            int x=-1;\\n            for(int i=0;i<n;i++){\\n                if(!vis[i]&&(x<0||dis[i]<dis[x])) x=i;\\n            }\\n            if(x<0||dis[x]==INT_MAX){\\n                return dis[node2]<INT_MAX ? dis[node2]:-1;\\n            }\\n            vis[x]=true;\\n            for(int y=0;y<n;y++){\\n                if(e[x][y]<INT_MAX&&dis[x]+e[x][y]<dis[y]){\\n                    dis[y]=dis[x]+e[x][y];\\n                }\\n            }\\n        }\\n    }\\n};\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph* obj = new Graph(n, edges);\\n * obj->addEdge(edge);\\n * int param_2 = obj->shortestPath(node1,node2);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Graph {\\npublic:\\n    vector<vector<int>> e;\\n    Graph(int n, vector<vector<int>>& edges) {\\n        e=vector<vector<int>>(n,vector<int>(n,INT_MAX));\\n        for(auto x:edges){\\n            e[x[0]][x[1]]=x[2];\\n        }\\n    }\\n    \\n    void addEdge(vector<int> edge) {\\n        e[edge[0]][edge[1]]=edge[2];\\n    }\\n    \\n    int shortestPath(int node1, int node2) {\\n        int n=e.size();\\n        vector<int> dis(n,INT_MAX),vis(n);\\n        dis[node1]=0;\\n        while(1){\\n            int x=-1;\\n            for(int i=0;i<n;i++){\\n                if(!vis[i]&&(x<0||dis[i]<dis[x])) x=i;\\n            }\\n            if(x<0||dis[x]==INT_MAX){\\n                return dis[node2]<INT_MAX ? dis[node2]:-1;\\n            }\\n            vis[x]=true;\\n            for(int y=0;y<n;y++){\\n                if(e[x][y]<INT_MAX&&dis[x]+e[x][y]<dis[y]){\\n                    dis[y]=dis[x]+e[x][y];\\n                }\\n            }\\n        }\\n    }\\n};\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph* obj = new Graph(n, edges);\\n * obj->addEdge(edge);\\n * int param_2 = obj->shortestPath(node1,node2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3426152,
                "title": "simple-dijiskstra-neat-code-with-tc-sc",
                "content": "\\n## Time Complexity:\\n$$O((V+E)log(V+E))$$\\n\\n## Space Complexity:\\n$$O(V+E)$$\\n\\n# Code\\n```\\nclass comparator{\\n    public:\\n      bool operator()(const pair<int,int>& p1,const pair<int,int>& p2){\\n          if(p2.second < p1.second){\\n              return true;\\n          }\\n          else{\\n              return false;\\n          }\\n      }  \\n};\\n\\n\\n\\nclass Graph {\\npublic:\\n    vector<vector<vector<int>>> adjL;\\n    int n;\\n    Graph(int _n, vector<vector<int>>& edges) {\\n         n = _n;\\n        \\n        adjL.resize(n);\\n        \\n        for(auto e:edges){\\n            adjL[e[0]].push_back({e[1],e[2]});\\n        }\\n        \\n       \\n    }\\n    \\n    void addEdge(vector<int> edge) {\\n        adjL[edge[0]].push_back({edge[1],edge[2]});\\n    }\\n    \\n    int shortestPath(int node1, int node2) {\\n      \\n        return dijkstra(node1,node2);\\n    }\\n    \\n    \\n    int dijkstra(int src,int dst){\\n        vector<int> dis(n,INT_MAX);\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,comparator> pq;\\n        \\n        dis[src] = 0;\\n        pq.push({src,0});\\n        \\n        while(!pq.empty()){\\n            pair<int,int> frontN = pq.top();\\n            int srcNode = frontN.first;\\n            int srcDis = frontN.second;\\n            pq.pop();\\n\\n            if(srcNode == dst){\\n                break;\\n            }\\n            \\n            for(auto i: adjL[srcNode]){\\n                int adjNode = i[0];\\n                int adjDis = i[1];\\n                int newDis = srcDis + adjDis; \\n                if(newDis < dis[adjNode]){\\n                    dis[adjNode] = newDis;\\n                    pq.push({adjNode,newDis});\\n                }\\n            }\\n        }\\n        \\n        if(dis[dst] == INT_MAX){\\n            return -1;\\n        }\\n        \\n        return dis[dst];\\n    }\\n\\n};\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph* obj = new Graph(n, edges);\\n * obj->addEdge(edge);\\n * int param_2 = obj->shortestPath(node1,node2);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass comparator{\\n    public:\\n      bool operator()(const pair<int,int>& p1,const pair<int,int>& p2){\\n          if(p2.second < p1.second){\\n              return true;\\n          }\\n          else{\\n              return false;\\n          }\\n      }  \\n};\\n\\n\\n\\nclass Graph {\\npublic:\\n    vector<vector<vector<int>>> adjL;\\n    int n;\\n    Graph(int _n, vector<vector<int>>& edges) {\\n         n = _n;\\n        \\n        adjL.resize(n);\\n        \\n        for(auto e:edges){\\n            adjL[e[0]].push_back({e[1],e[2]});\\n        }\\n        \\n       \\n    }\\n    \\n    void addEdge(vector<int> edge) {\\n        adjL[edge[0]].push_back({edge[1],edge[2]});\\n    }\\n    \\n    int shortestPath(int node1, int node2) {\\n      \\n        return dijkstra(node1,node2);\\n    }\\n    \\n    \\n    int dijkstra(int src,int dst){\\n        vector<int> dis(n,INT_MAX);\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,comparator> pq;\\n        \\n        dis[src] = 0;\\n        pq.push({src,0});\\n        \\n        while(!pq.empty()){\\n            pair<int,int> frontN = pq.top();\\n            int srcNode = frontN.first;\\n            int srcDis = frontN.second;\\n            pq.pop();\\n\\n            if(srcNode == dst){\\n                break;\\n            }\\n            \\n            for(auto i: adjL[srcNode]){\\n                int adjNode = i[0];\\n                int adjDis = i[1];\\n                int newDis = srcDis + adjDis; \\n                if(newDis < dis[adjNode]){\\n                    dis[adjNode] = newDis;\\n                    pq.push({adjNode,newDis});\\n                }\\n            }\\n        }\\n        \\n        if(dis[dst] == INT_MAX){\\n            return -1;\\n        }\\n        \\n        return dis[dst];\\n    }\\n\\n};\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph* obj = new Graph(n, edges);\\n * obj->addEdge(edge);\\n * int param_2 = obj->shortestPath(node1,node2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3425000,
                "title": "clean-java-dijkstra",
                "content": "# Complexity\\n- Time complexity of shortestPath(): O(E*logV) - time complexity of Dijkstra algorithm, we have logV due to minHeap, and E since in worst case we will have to traverse all edges before we reach destination. \\n\\nWhy it\\'s logV instead of logE: O(E*logE) -> O(E*log(V^2)) [we can move exponent outside of logarithm] -> O(E*2*logV) -> O(E*logV) [we can remove constants in Big-O notation]\\n\\n---\\n\\n- Overall Space complexity: O(V + E) V for visited array, V + E for adjList\\n\\n# Code\\n```\\nclass Graph {\\n    private Map<Integer, List<int[]>> adjList = new HashMap<>(); // from - list of pairs<to, wei>\\n    private final int n; // n is immutable since new edges(from, to) within [0, n-1]\\n\\n    public Graph(int n, int[][] edges) {\\n        this.n = n;\\n        for(var edge: edges) addEdge(edge);\\n    }\\n    \\n    public void addEdge(int[] edge) {\\n        adjList.computeIfAbsent(edge[0], k -> new ArrayList<>())\\n                .add(new int[]{edge[1], edge[2]});\\n    }\\n    \\n    // Dijkstra alg(BFS with MinHeap): 1) Add src to queue, \\n    // 2) Pop pair(node, wei) with lowest weight, check if it\\'s dest or visited, otherwise visit node, \\n    // 3) Add all outgoing edges(with weights) from popped node to MinHeap\\n    // NB: if queue.isEmpty & dest not found -> it can\\'t be reached from src, return -1\\n    public int shortestPath(int src, int dest) {\\n        var queue = new PriorityQueue<int[]>((a, b) -> a[1] - b[1]);\\n        var visited = new boolean[n];\\n        queue.add(new int[]{src, 0}); // wei=0 since we start from src\\n\\n        while(!queue.isEmpty()) {\\n            var nodeWei = queue.poll();\\n            int node = nodeWei[0], wei = nodeWei[1];\\n\\n            if(visited[node]) continue;\\n            if(node == dest) return wei;\\n\\n            visited[node] = true;\\n\\n            adjList.getOrDefault(node, Collections.emptyList())\\n                .forEach(e -> queue.add(new int[]{e[0], wei + e[1]}));\\n        }\\n\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Graph {\\n    private Map<Integer, List<int[]>> adjList = new HashMap<>(); // from - list of pairs<to, wei>\\n    private final int n; // n is immutable since new edges(from, to) within [0, n-1]\\n\\n    public Graph(int n, int[][] edges) {\\n        this.n = n;\\n        for(var edge: edges) addEdge(edge);\\n    }\\n    \\n    public void addEdge(int[] edge) {\\n        adjList.computeIfAbsent(edge[0], k -> new ArrayList<>())\\n                .add(new int[]{edge[1], edge[2]});\\n    }\\n    \\n    // Dijkstra alg(BFS with MinHeap): 1) Add src to queue, \\n    // 2) Pop pair(node, wei) with lowest weight, check if it\\'s dest or visited, otherwise visit node, \\n    // 3) Add all outgoing edges(with weights) from popped node to MinHeap\\n    // NB: if queue.isEmpty & dest not found -> it can\\'t be reached from src, return -1\\n    public int shortestPath(int src, int dest) {\\n        var queue = new PriorityQueue<int[]>((a, b) -> a[1] - b[1]);\\n        var visited = new boolean[n];\\n        queue.add(new int[]{src, 0}); // wei=0 since we start from src\\n\\n        while(!queue.isEmpty()) {\\n            var nodeWei = queue.poll();\\n            int node = nodeWei[0], wei = nodeWei[1];\\n\\n            if(visited[node]) continue;\\n            if(node == dest) return wei;\\n\\n            visited[node] = true;\\n\\n            adjList.getOrDefault(node, Collections.emptyList())\\n                .forEach(e -> queue.add(new int[]{e[0], wei + e[1]}));\\n        }\\n\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3424503,
                "title": "c-custom-dijkstra-1691ms-353-7mb",
                "content": "This problem requires a shortest path with an ever changing graph, so, among all the possible options, we might go for a Dijkstra that should work well, given the relatively low constraints we will face.\\n\\nWe will start declaring `maxNodes` with a value of `100` (as per specs), then at instance level:\\n* `connections`, an array of `maxNodes` vectors of pairs we will use later to track the information of each edge;\\n* `costs` is an array of `maxNodes` cells we will use in our traversal.\\n\\nIn the constructor we will take each `edge` in `edges` and:\\n* create a pair with destination (ie: `edge[1]`) and cost (ie: `edge[2]`);\\n* push said pair in the vector matching the origin (`edge[0]`) in `connection`.\\n\\nIn `addEdge` we will do the same for the provided `edge`.\\n\\nThe `shortestPath` function might carry more complexity, by:\\n* declare `res` and assign the result of calling `minPath` with `n1` and `n2`;\\n* `return` `-1` if `res == INT_MAX` or `res` otherwise.\\n\\n`minPath` will take two nodes `start` and `dest` and:\\n* `return` `0` if `start` and `end` match;\\n* declare `pq` as a min heap of vectors;\\n* fill `costs` with `INT_MAX`;\\n* set `costs[start]` to `0` (we start from there, so no cost);\\n* take each `connection` we can get from `start` (ie: `connections[start]`) and:\\n    * extract `to` and `cost` from it;\\n    * push a vector with `{cost, to, start}` in `pq`;\\n* looping with a nice optimised Dijkstra loop that will run `while` `pq` is not empty and will:\\n    * take the top of `pq` and store it in `top`;\\n    * extract `cost`, `currNode` and `prevNode` from it;\\n    * pop the top out of `pq`;\\n    * `continue` if we have already been here (ie: `costs[currNode] != INT_MAX`, since it will never be the case with a node we visited in this run);\\n    * update `costs[currNode]` to the be `cost` (since we know that the first time we reach each node also has to be the cheapest);\\n    * `break` if we reached `dest`;\\n    * if not, for each `connection` we can get from `currNode` (ie: `connections[currNode]`) we will:\\n    * extract `to` and `cost` from it;\\n    * push a vector with `{costs[currNode] + cost, to, currNode}` in `pq`;\\n* finally, `return` `costs[dest]`. \\n\\n# Complexity\\n- Time complexity: $$O(e)$$ (constructor and `shortestPath`), $$O(1)$$ (`addEdge`)\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```cpp\\nconstexpr int maxNodes = 100;\\n\\nclass Graph {\\n    vector<pair<int, int>> connections[maxNodes];\\n    int costs[maxNodes];\\n    int minPath(int start, int dest) {\\n        // edge case\\n        if (start == dest) return 0;\\n        // support variables\\n        priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> pq;\\n        // preparing costs and pq;\\n        fill(costs, costs + maxNodes, INT_MAX);\\n        costs[start] = 0;\\n        for (auto &connection: connections[start]) {\\n            auto [to, cost] = connection;\\n            pq.push({cost, to, start});\\n        }\\n        // Dijkstra!\\n        while (pq.size()) {\\n            // popping the top of pq\\n            auto &top = pq.top();\\n            int cost = top[0], currNode = top[1], prevNode = top[2];\\n            pq.pop();\\n            // already been here\\n            if (costs[currNode] != INT_MAX) continue;\\n            costs[currNode] = cost;\\n            if (currNode == dest) break;\\n            for (auto &connection: connections[currNode]) {\\n                auto [to, cost] = connection;\\n                pq.push({costs[currNode] + cost, to, currNode});\\n            }\\n        }\\n        return costs[dest];\\n    }\\npublic:\\n    Graph(int n, vector<vector<int>> &edges) {\\n        for (auto &edge: edges) connections[edge[0]].push_back({edge[1], edge[2]});\\n    }\\n    \\n    void addEdge(vector<int> edge) {\\n        connections[edge[0]].push_back({edge[1], edge[2]});\\n    }\\n    \\n    int shortestPath(int n1, int n2) {\\n        int res = minPath(n1, n2);\\n        return res == INT_MAX ? -1 : res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Graph",
                    "Shortest Path"
                ],
                "code": "```cpp\\nconstexpr int maxNodes = 100;\\n\\nclass Graph {\\n    vector<pair<int, int>> connections[maxNodes];\\n    int costs[maxNodes];\\n    int minPath(int start, int dest) {\\n        // edge case\\n        if (start == dest) return 0;\\n        // support variables\\n        priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> pq;\\n        // preparing costs and pq;\\n        fill(costs, costs + maxNodes, INT_MAX);\\n        costs[start] = 0;\\n        for (auto &connection: connections[start]) {\\n            auto [to, cost] = connection;\\n            pq.push({cost, to, start});\\n        }\\n        // Dijkstra!\\n        while (pq.size()) {\\n            // popping the top of pq\\n            auto &top = pq.top();\\n            int cost = top[0], currNode = top[1], prevNode = top[2];\\n            pq.pop();\\n            // already been here\\n            if (costs[currNode] != INT_MAX) continue;\\n            costs[currNode] = cost;\\n            if (currNode == dest) break;\\n            for (auto &connection: connections[currNode]) {\\n                auto [to, cost] = connection;\\n                pq.push({costs[currNode] + cost, to, currNode});\\n            }\\n        }\\n        return costs[dest];\\n    }\\npublic:\\n    Graph(int n, vector<vector<int>> &edges) {\\n        for (auto &edge: edges) connections[edge[0]].push_back({edge[1], edge[2]});\\n    }\\n    \\n    void addEdge(vector<int> edge) {\\n        connections[edge[0]].push_back({edge[1], edge[2]});\\n    }\\n    \\n    int shortestPath(int n1, int n2) {\\n        int res = minPath(n1, n2);\\n        return res == INT_MAX ? -1 : res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3424187,
                "title": "javascript-2642-design-graph-with-shortest-path-calculator",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\n1\\n```\\nvar Graph = function (n, edges) {\\n    Graph.prototype.addEdge = function (edge) {\\n        const [f, t, c] = edge;\\n        g[f].push([t, c]);\\n    };\\n\\n    Graph.prototype.shortestPath = function (f, t) {\\n        const q = [];\\n        const c2s = new Array(n).fill(Infinity);\\n        c2s[f] = 0;\\n        q.push([f, 0]);\\n        while (q.length) {\\n            const [f, c] = q.shift();\\n            for (const [t, c] of g[f] || []) {\\n                if (c2s[t] > c2s[f] + c) {\\n                    c2s[t] = c2s[f] + c;\\n                    q.push([t, c2s[t]]);\\n                }\\n            }\\n        }\\n        return c2s[t] === Infinity ? -1 : c2s[t];\\n    };\\n\\n    g = Array.from({ length: n }, () => []);\\n    for (let i = 0; i < edges.length; i++) {\\n        this.addEdge(edges[i]);\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar Graph = function (n, edges) {\\n    Graph.prototype.addEdge = function (edge) {\\n        const [f, t, c] = edge;\\n        g[f].push([t, c]);\\n    };\\n\\n    Graph.prototype.shortestPath = function (f, t) {\\n        const q = [];\\n        const c2s = new Array(n).fill(Infinity);\\n        c2s[f] = 0;\\n        q.push([f, 0]);\\n        while (q.length) {\\n            const [f, c] = q.shift();\\n            for (const [t, c] of g[f] || []) {\\n                if (c2s[t] > c2s[f] + c) {\\n                    c2s[t] = c2s[f] + c;\\n                    q.push([t, c2s[t]]);\\n                }\\n            }\\n        }\\n        return c2s[t] === Infinity ? -1 : c2s[t];\\n    };\\n\\n    g = Array.from({ length: n }, () => []);\\n    for (let i = 0; i < edges.length; i++) {\\n        this.addEdge(edges[i]);\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3424089,
                "title": "a-few-solutions",
                "content": "Compute the single-source-shortest-paths upon demand for each query from source `s` to target `t`.\\n\\n* Bellman-Ford results in TLE\\n* SPFA (shortest paths faster algorithm) is AC\\n    * this is a natural progression from Bellman-Ford, ie. we only attempt to relax candidate edges (instead of all edges)\\n\\n---\\n\\n**Bellman-Ford (TLE) Solutions:**\\n\\n*Kotlin*\\n```\\nclass Graph(N: Int, E: Array<IntArray>) {\\n    private var N = N\\n    private var E = E.toMutableList()\\n    private var INF = 1e9.toInt() + 7\\n    fun addEdge(edge: IntArray) {\\n        E.add(edge)\\n    }\\n    fun shortestPath(s: Int, t: Int): Int {\\n        var dist = IntArray(N) { INF }\\n        dist[s] = 0\\n        for (k in 0 until N - 1)\\n            for ((u, v, w) in E)\\n                if (dist[v] > dist[u] + w)\\n                    dist[v] = dist[u] + w\\n        return if (dist[t] < INF) dist[t] else -1\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nclass Graph {\\n    constructor(N, E) {\\n        this.N = N;\\n        this.E = E;\\n    }\\n    addEdge(edge) {\\n        this.E.push(edge);\\n    }\\n    shortestPath(s, t) {\\n        let dist = Array(this.N).fill(Infinity);\\n        dist[s] = 0;\\n        for (let k = 0; k < this.N - 1; ++k)\\n            for (let [u, v, w] of this.E)\\n                if (dist[v] > dist[u] + w)\\n                    dist[v] = dist[u] + w;\\n        return dist[t] < Infinity ? dist[t] : -1;\\n    }\\n}\\n```\\n\\n*Python3*\\n```\\nclass Graph:\\n    def __init__(self, N: int, E: List[List[int]]):\\n        self.N = N\\n        self.E = E\\n        self.INF = int(1e9 + 7)\\n\\n    def addEdge(self, edge: List[int]) -> None:\\n        self.E.append(edge)\\n\\n    def shortestPath(self, s: int, t: int) -> int:\\n        N, E, INF = self.N, self.E, self.INF\\n        dist = [INF] * N\\n        dist[s] = 0\\n        for _ in range(len(E) - 1):\\n            for u, v, w in E:\\n                dist[v] = min(dist[v], dist[u] + w)\\n        return dist[t] if dist[t] < INF else -1\\n```\\n\\n*Rust*\\n```\\n// TODO: implement me!\\n```\\n\\n*C++*\\n```\\nclass Graph {\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    int N, INF;\\n    VVI E;\\npublic:\\n    Graph(int N, VVI& E) : N{ N }, INF{ int(1e9 + 7) }, E{ E } {}\\n    void addEdge(VI edge) { E.emplace_back(edge); }\\n    int shortestPath(int s, int t) {\\n        VI dist(N, INF);\\n        dist[s] = 0;\\n        for (auto k{ 0 }; k < N - 1; ++k) {\\n            for (auto& edge: E) {\\n                auto [u, v, w] = tie(edge[0], edge[1], edge[2]);\\n                if (dist[v] > dist[u] + w)\\n                    dist[v] = dist[u] + w;\\n            }\\n        }\\n        return dist[t] < INF ? dist[t] : -1;\\n    }\\n};\\n```\\n\\n**SPFA (AC) Solutions:**\\n\\n*Kotlin*\\n```\\nclass Graph(N: Int, E: Array<IntArray>) {\\n    private var N = N\\n    private var adj = mutableMapOf<Int, MutableList<Pair<Int, Int>>>();\\n    private var INF = 1e9.toInt() + 7\\n    init {\\n        for (i in 0 until N)\\n            adj[i] = mutableListOf<Pair<Int, Int>>()\\n        for ((u, v, w) in E)\\n            adj[u]!!.add(Pair(v, w))\\n    }\\n    fun addEdge(edge: IntArray) {\\n        var (u, v, w) = edge\\n        adj[u]!!.add(Pair(v, w))\\n    }\\n    fun shortestPath(s: Int, t: Int): Int {\\n        var dist = IntArray(N) { INF }\\n        dist[s] = 0\\n        var q: Queue<Int> = LinkedList<Int>(listOf(s))\\n        while (0 < q.size) {\\n            var k = q.size\\n            while (0 < k--) {\\n                var u = q.poll()\\n                for ((v, w) in adj[u]!!) {\\n                    if (dist[v] > dist[u] + w) {\\n                        dist[v] = dist[u] + w; q.add(v)\\n                    }\\n                }\\n            }\\n        }\\n        return if (dist[t] < INF) dist[t] else -1\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nclass Graph {\\n    constructor(N, E) {\\n        this.N = N;\\n        this.adj = new Map([...Array(N).keys()].map(i => [i, []]));\\n        for (let [u, v, w] of E)\\n            this.adj.get(u).push([v, w]);\\n    }\\n    addEdge(edge) {\\n        let [u, v, w] = edge;\\n        this.adj.get(u).push([v, w]);\\n    }\\n    shortestPath(s, t) {\\n        let dist = Array(this.N).fill(Infinity);\\n        dist[s] = 0;\\n        let q = [s];\\n        while (q.length) {\\n            let k = q.length;\\n            while (k--) {\\n                let u = q.shift();\\n                for (let [v, w] of this.adj.get(u))\\n                    if (dist[v] > dist[u] + w)\\n                        dist[v] = dist[u] + w, q.push(v);\\n            }\\n        }\\n        return dist[t] < Infinity ? dist[t] : -1;\\n    }\\n}\\n```\\n\\n*Python3*\\n```\\nclass Graph:\\n    def __init__(self, N: int, E: List[List[int]]):\\n        self.N = N\\n        self.adj = defaultdict(list)\\n        for u, v, w in E:\\n            self.adj[u].append((v, w))\\n        self.INF = int(1e9 + 7)\\n\\n    def addEdge(self, edge: List[int]) -> None:\\n        u, v, w = edge\\n        self.adj[u].append((v, w))\\n\\n    def shortestPath(self, s: int, t: int) -> int:\\n        N, adj, INF = self.N, self.adj, self.INF\\n        dist = [INF] * N\\n        dist[s] = 0\\n        q = deque([s])\\n        while q:\\n            for _ in range(len(q)):\\n                u = q.popleft()\\n                for v, w in adj[u]:\\n                    if dist[v] > dist[u] + w:\\n                        dist[v] = dist[u] + w; q.append(v)\\n        return dist[t] if dist[t] < INF else -1\\n```\\n\\n*Rust*\\n```\\n// TODO: implement me!\\n```\\n\\n*C++*\\n```\\nclass Graph {\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    using Queue = queue<int>;\\n    using Pair = pair<int, int>;\\n    using Pairs = vector<Pair>;\\n    using Map = unordered_map<int, Pairs>;\\n    int N, INF;\\n    Map adj;\\npublic:\\n    Graph(int N, VVI& E) : N{ N }, INF{ int(1e9 + 7) } {\\n        for (auto& edge: E) {\\n            auto [u, v, w] = tie(edge[0], edge[1], edge[2]);\\n            adj[u].emplace_back(v, w);\\n        }\\n    }\\n    void addEdge(VI edge) {\\n        auto [u, v, w] = tie(edge[0], edge[1], edge[2]);\\n        adj[u].emplace_back(v, w);\\n    }\\n    int shortestPath(int s, int t) {\\n        VI dist(N, INF);\\n        dist[s] = 0;\\n        Queue q{{{ s }}};\\n        while (q.size()) {\\n            auto u = q.front(); q.pop();\\n            for (auto [v, w]: adj[u])\\n                if (dist[v] > dist[u] + w)\\n                    dist[v] = dist[u] + w, q.push(v);\\n        }\\n        return dist[t] < INF ? dist[t] : -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Graph(N: Int, E: Array<IntArray>) {\\n    private var N = N\\n    private var E = E.toMutableList()\\n    private var INF = 1e9.toInt() + 7\\n    fun addEdge(edge: IntArray) {\\n        E.add(edge)\\n    }\\n    fun shortestPath(s: Int, t: Int): Int {\\n        var dist = IntArray(N) { INF }\\n        dist[s] = 0\\n        for (k in 0 until N - 1)\\n            for ((u, v, w) in E)\\n                if (dist[v] > dist[u] + w)\\n                    dist[v] = dist[u] + w\\n        return if (dist[t] < INF) dist[t] else -1\\n    }\\n}\\n```\n```\\nclass Graph {\\n    constructor(N, E) {\\n        this.N = N;\\n        this.E = E;\\n    }\\n    addEdge(edge) {\\n        this.E.push(edge);\\n    }\\n    shortestPath(s, t) {\\n        let dist = Array(this.N).fill(Infinity);\\n        dist[s] = 0;\\n        for (let k = 0; k < this.N - 1; ++k)\\n            for (let [u, v, w] of this.E)\\n                if (dist[v] > dist[u] + w)\\n                    dist[v] = dist[u] + w;\\n        return dist[t] < Infinity ? dist[t] : -1;\\n    }\\n}\\n```\n```\\nclass Graph:\\n    def __init__(self, N: int, E: List[List[int]]):\\n        self.N = N\\n        self.E = E\\n        self.INF = int(1e9 + 7)\\n\\n    def addEdge(self, edge: List[int]) -> None:\\n        self.E.append(edge)\\n\\n    def shortestPath(self, s: int, t: int) -> int:\\n        N, E, INF = self.N, self.E, self.INF\\n        dist = [INF] * N\\n        dist[s] = 0\\n        for _ in range(len(E) - 1):\\n            for u, v, w in E:\\n                dist[v] = min(dist[v], dist[u] + w)\\n        return dist[t] if dist[t] < INF else -1\\n```\n```\\n// TODO: implement me!\\n```\n```\\nclass Graph {\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    int N, INF;\\n    VVI E;\\npublic:\\n    Graph(int N, VVI& E) : N{ N }, INF{ int(1e9 + 7) }, E{ E } {}\\n    void addEdge(VI edge) { E.emplace_back(edge); }\\n    int shortestPath(int s, int t) {\\n        VI dist(N, INF);\\n        dist[s] = 0;\\n        for (auto k{ 0 }; k < N - 1; ++k) {\\n            for (auto& edge: E) {\\n                auto [u, v, w] = tie(edge[0], edge[1], edge[2]);\\n                if (dist[v] > dist[u] + w)\\n                    dist[v] = dist[u] + w;\\n            }\\n        }\\n        return dist[t] < INF ? dist[t] : -1;\\n    }\\n};\\n```\n```\\nclass Graph(N: Int, E: Array<IntArray>) {\\n    private var N = N\\n    private var adj = mutableMapOf<Int, MutableList<Pair<Int, Int>>>();\\n    private var INF = 1e9.toInt() + 7\\n    init {\\n        for (i in 0 until N)\\n            adj[i] = mutableListOf<Pair<Int, Int>>()\\n        for ((u, v, w) in E)\\n            adj[u]!!.add(Pair(v, w))\\n    }\\n    fun addEdge(edge: IntArray) {\\n        var (u, v, w) = edge\\n        adj[u]!!.add(Pair(v, w))\\n    }\\n    fun shortestPath(s: Int, t: Int): Int {\\n        var dist = IntArray(N) { INF }\\n        dist[s] = 0\\n        var q: Queue<Int> = LinkedList<Int>(listOf(s))\\n        while (0 < q.size) {\\n            var k = q.size\\n            while (0 < k--) {\\n                var u = q.poll()\\n                for ((v, w) in adj[u]!!) {\\n                    if (dist[v] > dist[u] + w) {\\n                        dist[v] = dist[u] + w; q.add(v)\\n                    }\\n                }\\n            }\\n        }\\n        return if (dist[t] < INF) dist[t] else -1\\n    }\\n}\\n```\n```\\nclass Graph {\\n    constructor(N, E) {\\n        this.N = N;\\n        this.adj = new Map([...Array(N).keys()].map(i => [i, []]));\\n        for (let [u, v, w] of E)\\n            this.adj.get(u).push([v, w]);\\n    }\\n    addEdge(edge) {\\n        let [u, v, w] = edge;\\n        this.adj.get(u).push([v, w]);\\n    }\\n    shortestPath(s, t) {\\n        let dist = Array(this.N).fill(Infinity);\\n        dist[s] = 0;\\n        let q = [s];\\n        while (q.length) {\\n            let k = q.length;\\n            while (k--) {\\n                let u = q.shift();\\n                for (let [v, w] of this.adj.get(u))\\n                    if (dist[v] > dist[u] + w)\\n                        dist[v] = dist[u] + w, q.push(v);\\n            }\\n        }\\n        return dist[t] < Infinity ? dist[t] : -1;\\n    }\\n}\\n```\n```\\nclass Graph:\\n    def __init__(self, N: int, E: List[List[int]]):\\n        self.N = N\\n        self.adj = defaultdict(list)\\n        for u, v, w in E:\\n            self.adj[u].append((v, w))\\n        self.INF = int(1e9 + 7)\\n\\n    def addEdge(self, edge: List[int]) -> None:\\n        u, v, w = edge\\n        self.adj[u].append((v, w))\\n\\n    def shortestPath(self, s: int, t: int) -> int:\\n        N, adj, INF = self.N, self.adj, self.INF\\n        dist = [INF] * N\\n        dist[s] = 0\\n        q = deque([s])\\n        while q:\\n            for _ in range(len(q)):\\n                u = q.popleft()\\n                for v, w in adj[u]:\\n                    if dist[v] > dist[u] + w:\\n                        dist[v] = dist[u] + w; q.append(v)\\n        return dist[t] if dist[t] < INF else -1\\n```\n```\\n// TODO: implement me!\\n```\n```\\nclass Graph {\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    using Queue = queue<int>;\\n    using Pair = pair<int, int>;\\n    using Pairs = vector<Pair>;\\n    using Map = unordered_map<int, Pairs>;\\n    int N, INF;\\n    Map adj;\\npublic:\\n    Graph(int N, VVI& E) : N{ N }, INF{ int(1e9 + 7) } {\\n        for (auto& edge: E) {\\n            auto [u, v, w] = tie(edge[0], edge[1], edge[2]);\\n            adj[u].emplace_back(v, w);\\n        }\\n    }\\n    void addEdge(VI edge) {\\n        auto [u, v, w] = tie(edge[0], edge[1], edge[2]);\\n        adj[u].emplace_back(v, w);\\n    }\\n    int shortestPath(int s, int t) {\\n        VI dist(N, INF);\\n        dist[s] = 0;\\n        Queue q{{{ s }}};\\n        while (q.size()) {\\n            auto u = q.front(); q.pop();\\n            for (auto [v, w]: adj[u])\\n                if (dist[v] > dist[u] + w)\\n                    dist[v] = dist[u] + w, q.push(v);\\n        }\\n        return dist[t] < INF ? dist[t] : -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3423912,
                "title": "easy-and-simple-bfs-solution-with-dijkstra-c-beats-100-speed-and-memory",
                "content": "**Approach**\\nCreate the adjacency list and perform simple diskstra each time shortestPath function is invoked.\\n\\n**Complexity**\\nTime complexity: O(E x log(V)) \\nSpace complexity: O(E + V)\\n\\n\\n```\\nclass Graph {\\npublic:\\n    vector<vector<pair<int,int>>> adj;\\n    Graph(int n, vector<vector<int>>& edges) {\\n        adj.resize(n);\\n        for(auto it:edges)\\n            adj[it[0]].push_back({it[1],it[2]});\\n    }\\n    \\n    void addEdge(vector<int> edge) {\\n        adj[edge[0]].push_back({edge[1],edge[2]});\\n    }\\n    \\n    int shortestPath(int node1, int node2) {\\n        vector<int> dist(100,1e9);\\n        \\n        typedef pair<int,int> pi;\\n        priority_queue<pi,vector<pi>,greater<pi>>pq;\\n        pq.push({0,node1});\\n        dist[node1]=0;\\n        \\n        while(!pq.empty()){\\n            auto [dis,node] = pq.top();\\n            pq.pop();\\n            \\n            for(auto it:adj[node]){\\n                if(dis+it.second<dist[it.first]){\\n                    dist[it.first]=dis+it.second;\\n                    pq.push({dist[it.first],it.first});\\n                }\\n            }   \\n        }\\n        return dist[node2]==1e9?-1:dist[node2];\\n    }\\n};\\n```\\nPls upvote if this solution helps you!",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Graph {\\npublic:\\n    vector<vector<pair<int,int>>> adj;\\n    Graph(int n, vector<vector<int>>& edges) {\\n        adj.resize(n);\\n        for(auto it:edges)\\n            adj[it[0]].push_back({it[1],it[2]});\\n    }\\n    \\n    void addEdge(vector<int> edge) {\\n        adj[edge[0]].push_back({edge[1],edge[2]});\\n    }\\n    \\n    int shortestPath(int node1, int node2) {\\n        vector<int> dist(100,1e9);\\n        \\n        typedef pair<int,int> pi;\\n        priority_queue<pi,vector<pi>,greater<pi>>pq;\\n        pq.push({0,node1});\\n        dist[node1]=0;\\n        \\n        while(!pq.empty()){\\n            auto [dis,node] = pq.top();\\n            pq.pop();\\n            \\n            for(auto it:adj[node]){\\n                if(dis+it.second<dist[it.first]){\\n                    dist[it.first]=dis+it.second;\\n                    pq.push({dist[it.first],it.first});\\n                }\\n            }   \\n        }\\n        return dist[node2]==1e9?-1:dist[node2];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3423890,
                "title": "java-bfs-dijsktra",
                "content": "```\\nclass Graph {\\n    private List<Pair<Integer, Integer>>[] graph; \\n    private int N;\\n\\n    public Graph(int n, int[][] edges) {\\n        N = n;\\n        graph = new ArrayList[N+1];\\n        for (int i = 0; i <= n; i++) \\n            graph[i] = new ArrayList<>();\\n\\n        for (int[] edge : edges) {\\n            int u = edge[0], v = edge[1], w = edge[2];\\n            graph[u].add(new Pair<>(v, w));\\n        }\\n    }\\n\\n    public void addEdge(int[] edge) {\\n        int u = edge[0], v = edge[1], w = edge[2];\\n        graph[u].add(new Pair<>(v, w));\\n    }\\n\\n    public int shortestPath(int start, int end) {\\n        \\n        PriorityQueue<Pair<Integer, Integer>> pq = new PriorityQueue<>(\\n            (a, b) -> a.getValue() - b.getValue());\\n        \\n        int[] dist = new int[N+1]; // distance array\\n        Arrays.fill(dist, Integer.MAX_VALUE);\\n\\n        dist[start] = 0;\\n        pq.add(new Pair<>(start, 0));\\n\\n        while (!pq.isEmpty()) {\\n            Pair<Integer, Integer> node = pq.poll();\\n            int vtx = node.getKey();\\n\\n            for (Pair<Integer, Integer> nbr : graph[vtx]) {\\n                int nbrNode = nbr.getKey();\\n                int nbrDist = nbr.getValue();\\n\\n                if (dist[vtx] + nbrDist < dist[nbrNode]) { \\n                // (WSF for current vtx + dist to reach this nbr) < (current saved dist)\\n                    dist[nbrNode] = dist[vtx] + nbrDist;\\n                    // update the dist array with current distance added\\n                    pq.add(new Pair<>(nbrNode, dist[nbrNode]));\\n                }\\n            }\\n        }\\n\\n        return dist[end] == Integer.MAX_VALUE ? -1 : dist[end];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Graph {\\n    private List<Pair<Integer, Integer>>[] graph; \\n    private int N;\\n\\n    public Graph(int n, int[][] edges) {\\n        N = n;\\n        graph = new ArrayList[N+1];\\n        for (int i = 0; i <= n; i++) \\n            graph[i] = new ArrayList<>();\\n\\n        for (int[] edge : edges) {\\n            int u = edge[0], v = edge[1], w = edge[2];\\n            graph[u].add(new Pair<>(v, w));\\n        }\\n    }\\n\\n    public void addEdge(int[] edge) {\\n        int u = edge[0], v = edge[1], w = edge[2];\\n        graph[u].add(new Pair<>(v, w));\\n    }\\n\\n    public int shortestPath(int start, int end) {\\n        \\n        PriorityQueue<Pair<Integer, Integer>> pq = new PriorityQueue<>(\\n            (a, b) -> a.getValue() - b.getValue());\\n        \\n        int[] dist = new int[N+1]; // distance array\\n        Arrays.fill(dist, Integer.MAX_VALUE);\\n\\n        dist[start] = 0;\\n        pq.add(new Pair<>(start, 0));\\n\\n        while (!pq.isEmpty()) {\\n            Pair<Integer, Integer> node = pq.poll();\\n            int vtx = node.getKey();\\n\\n            for (Pair<Integer, Integer> nbr : graph[vtx]) {\\n                int nbrNode = nbr.getKey();\\n                int nbrDist = nbr.getValue();\\n\\n                if (dist[vtx] + nbrDist < dist[nbrNode]) { \\n                // (WSF for current vtx + dist to reach this nbr) < (current saved dist)\\n                    dist[nbrNode] = dist[vtx] + nbrDist;\\n                    // update the dist array with current distance added\\n                    pq.add(new Pair<>(nbrNode, dist[nbrNode]));\\n                }\\n            }\\n        }\\n\\n        return dist[end] == Integer.MAX_VALUE ? -1 : dist[end];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3423683,
                "title": "my-simple-c-solution-simple-dijkstra-100-faster",
                "content": "![image](https://assets.leetcode.com/users/images/c8e5aa32-b2e9-4edf-a808-aa353f04f268_1681652504.094857.png)\\n\\n```\\nclass Graph {\\npublic:\\n    vector<vector<pair<int, int>>> graph; \\n    int n;\\n    Graph(int n, vector<vector<int>>& edges) {\\n        graph.resize(n);\\n        this->n = n; \\n        for(auto &edge: edges) {\\n            int a = edge[0];\\n            int b = edge[1];\\n            int cost = edge[2];\\n            \\n            graph[a].push_back({b,cost}); \\n        }\\n    }\\n    \\n    void addEdge(vector<int> edge) {\\n        int a = edge[0];\\n        int b = edge[1];\\n        \\n        int cost = edge[2];\\n        \\n        graph[a].push_back({b,cost}); \\n    }\\n    \\n    int shortestPath(int node1, int node2) {\\n        \\n        vector<int> dis(n, INT_MAX);\\n        dis[node1] = 0;\\n        vector<bool> vis(n, false);\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq; \\n        pq.push({0, node1});\\n        \\n        while(!pq.empty()) {\\n            auto front = pq.top();\\n            pq.pop();\\n            \\n            if(front.second == node2) return front.first; \\n            if(vis[front.second]) continue;\\n            vis[front.second] = true; \\n            \\n            for(auto &nb: graph[front.second]) {\\n                if(not vis[nb.first]) {\\n                    dis[nb.first] = min(dis[nb.first], nb.second+front.first);\\n                    pq.push({dis[nb.first], nb.first}); \\n                }\\n            }\\n        }\\n        \\n        \\n        return -1; \\n    }\\n};\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph* obj = new Graph(n, edges);\\n * obj->addEdge(edge);\\n * int param_2 = obj->shortestPath(node1,node2);\\n */\\n ```",
                "solutionTags": [],
                "code": "```\\nclass Graph {\\npublic:\\n    vector<vector<pair<int, int>>> graph; \\n    int n;\\n    Graph(int n, vector<vector<int>>& edges) {\\n        graph.resize(n);\\n        this->n = n; \\n        for(auto &edge: edges) {\\n            int a = edge[0];\\n            int b = edge[1];\\n            int cost = edge[2];\\n            \\n            graph[a].push_back({b,cost}); \\n        }\\n    }\\n    \\n    void addEdge(vector<int> edge) {\\n        int a = edge[0];\\n        int b = edge[1];\\n        \\n        int cost = edge[2];\\n        \\n        graph[a].push_back({b,cost}); \\n    }\\n    \\n    int shortestPath(int node1, int node2) {\\n        \\n        vector<int> dis(n, INT_MAX);\\n        dis[node1] = 0;\\n        vector<bool> vis(n, false);\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq; \\n        pq.push({0, node1});\\n        \\n        while(!pq.empty()) {\\n            auto front = pq.top();\\n            pq.pop();\\n            \\n            if(front.second == node2) return front.first; \\n            if(vis[front.second]) continue;\\n            vis[front.second] = true; \\n            \\n            for(auto &nb: graph[front.second]) {\\n                if(not vis[nb.first]) {\\n                    dis[nb.first] = min(dis[nb.first], nb.second+front.first);\\n                    pq.push({dis[nb.first], nb.first}); \\n                }\\n            }\\n        }\\n        \\n        \\n        return -1; \\n    }\\n};\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph* obj = new Graph(n, edges);\\n * obj->addEdge(edge);\\n * int param_2 = obj->shortestPath(node1,node2);\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 3423648,
                "title": "super-easy-brute-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Graph {\\npublic:\\n    int n;\\n    \\n    vector<pair<int, int>> adj[100];\\n    \\n    void shortest(int node, vector<int> &dist){\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\\n        pq.push({0, node});\\n        dist[node] = 0;\\n        while(!pq.empty()){\\n            auto nde = pq.top();\\n            pq.pop();\\n            int wtt = nde.first;\\n            int nd = nde.second;\\n            for(auto &i : adj[nd]){\\n                int wt = i.first;\\n                int nbr = i.second;\\n                if(dist[nd] + wt < dist[nbr]){\\n                    dist[nbr] = dist[nd] + wt;\\n                    pq.push({dist[nbr], nbr});\\n                }\\n            }\\n        }\\n    }\\n\\n    Graph(int N, vector<vector<int>>& edges) {\\n        n = N;\\n        for(auto &e : edges){\\n            adj[e[0]].push_back({e[2], e[1]});\\n        }\\n    }\\n    \\n    void addEdge(vector<int> edge) {\\n        adj[edge[0]].push_back({edge[2], edge[1]});\\n    }\\n    \\n    int shortestPath(int node1, int node2) {\\n        vector<int> dist(n, INT_MAX);\\n        shortest(node1, dist);\\n        return dist[node2] == INT_MAX ? -1 : dist[node2];\\n    } \\n};\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph* obj = new Graph(n, edges);\\n * obj->addEdge(edge);\\n * int param_2 = obj->shortestPath(node1,node2);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Graph {\\npublic:\\n    int n;\\n    \\n    vector<pair<int, int>> adj[100];\\n    \\n    void shortest(int node, vector<int> &dist){\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\\n        pq.push({0, node});\\n        dist[node] = 0;\\n        while(!pq.empty()){\\n            auto nde = pq.top();\\n            pq.pop();\\n            int wtt = nde.first;\\n            int nd = nde.second;\\n            for(auto &i : adj[nd]){\\n                int wt = i.first;\\n                int nbr = i.second;\\n                if(dist[nd] + wt < dist[nbr]){\\n                    dist[nbr] = dist[nd] + wt;\\n                    pq.push({dist[nbr], nbr});\\n                }\\n            }\\n        }\\n    }\\n\\n    Graph(int N, vector<vector<int>>& edges) {\\n        n = N;\\n        for(auto &e : edges){\\n            adj[e[0]].push_back({e[2], e[1]});\\n        }\\n    }\\n    \\n    void addEdge(vector<int> edge) {\\n        adj[edge[0]].push_back({edge[2], edge[1]});\\n    }\\n    \\n    int shortestPath(int node1, int node2) {\\n        vector<int> dist(n, INT_MAX);\\n        shortest(node1, dist);\\n        return dist[node2] == INT_MAX ? -1 : dist[node2];\\n    } \\n};\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph* obj = new Graph(n, edges);\\n * obj->addEdge(edge);\\n * int param_2 = obj->shortestPath(node1,node2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3423620,
                "title": "dijkstra-java-simple-and-easy",
                "content": "\\n# Code\\n```\\nclass Graph {\\n    public HashMap<Integer,HashMap<Integer,Integer>> map=new HashMap<>();\\n    public Graph(int n, int[][] edges) {\\n        for(int i=0;i<n;i++){\\n            map.put(i,new HashMap<>());\\n        }\\n        for(int i=0;i<edges.length;i++){\\n            map.get(edges[i][0]).put(edges[i][1],edges[i][2]);\\n        }\\n    }\\n    \\n    public void addEdge(int[] edge) {\\n        map.get(edge[0]).put(edge[1],edge[2]);\\n    }\\n    \\n    public int shortestPath(int node1, int node2) {\\n        PriorityQueue<pairs> pq=new PriorityQueue<>(new Comparator<pairs>() {\\n            @Override\\n            public int compare(pairs o1,pairs o2){\\n                return o1.cost-o2.cost;\\n            }\\n        });\\n        HashSet<Integer> visited=new HashSet<>();\\n        pq.add(new pairs(node1,0));\\n        while(!pq.isEmpty()){\\n            pairs rv=pq.remove();\\n            if(visited.contains(rv.vtx)){\\n                continue;\\n            }\\n            if(rv.vtx==node2){\\n                return rv.cost;\\n            } \\n            visited.add(rv.vtx);\\n            for(int nbrs:map.get(rv.vtx).keySet()){\\n                if(!visited.contains(nbrs)){\\n                    pq.add(new pairs(nbrs,rv.cost+map.get(rv.vtx).get(nbrs)));\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\nclass pairs{\\n        int vtx;\\n        int cost;\\n        pairs(int e1,int cost){\\n            this.vtx=e1;\\n            this.cost=cost;\\n        }\\n    }\\n\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph obj = new Graph(n, edges);\\n * obj.addEdge(edge);\\n * int param_2 = obj.shortestPath(node1,node2);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Graph {\\n    public HashMap<Integer,HashMap<Integer,Integer>> map=new HashMap<>();\\n    public Graph(int n, int[][] edges) {\\n        for(int i=0;i<n;i++){\\n            map.put(i,new HashMap<>());\\n        }\\n        for(int i=0;i<edges.length;i++){\\n            map.get(edges[i][0]).put(edges[i][1],edges[i][2]);\\n        }\\n    }\\n    \\n    public void addEdge(int[] edge) {\\n        map.get(edge[0]).put(edge[1],edge[2]);\\n    }\\n    \\n    public int shortestPath(int node1, int node2) {\\n        PriorityQueue<pairs> pq=new PriorityQueue<>(new Comparator<pairs>() {\\n            @Override\\n            public int compare(pairs o1,pairs o2){\\n                return o1.cost-o2.cost;\\n            }\\n        });\\n        HashSet<Integer> visited=new HashSet<>();\\n        pq.add(new pairs(node1,0));\\n        while(!pq.isEmpty()){\\n            pairs rv=pq.remove();\\n            if(visited.contains(rv.vtx)){\\n                continue;\\n            }\\n            if(rv.vtx==node2){\\n                return rv.cost;\\n            } \\n            visited.add(rv.vtx);\\n            for(int nbrs:map.get(rv.vtx).keySet()){\\n                if(!visited.contains(nbrs)){\\n                    pq.add(new pairs(nbrs,rv.cost+map.get(rv.vtx).get(nbrs)));\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\nclass pairs{\\n        int vtx;\\n        int cost;\\n        pairs(int e1,int cost){\\n            this.vtx=e1;\\n            this.cost=cost;\\n        }\\n    }\\n\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph obj = new Graph(n, edges);\\n * obj.addEdge(edge);\\n * int param_2 = obj.shortestPath(node1,node2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3423578,
                "title": "using-set",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach: **Dijkstra algorithm** \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Graph {\\npublic:\\n    vector<pair<int,int>>adj[101];\\n    int size;\\n    \\n    Graph(int n, vector<vector<int>>& edges) {\\n        size=n;\\n         for(auto i:edges){\\n            adj[i[0]].push_back({i[1],i[2]});\\n         } \\n    }\\n\\n    void addEdge(vector<int> edge) {\\n        adj[edge[0]].push_back({edge[1],edge[2]});\\n    }\\n\\n    int shortestPath(int node1, int node2) {\\n       // priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pq;\\n        set<pair<int,int>>st;\\n        vector<int>dist(size+1,INT_MAX);\\n        dist[node1]=0;\\n        //pq.push({0,node1});\\n        st.insert({0,node1});\\n        while(!st.empty()){\\n            auto it = *(st.begin());\\n            int Nodedist=it.first;\\n            int node=it.second;\\n            st.erase(it);\\n            for(auto it:adj[node]){\\n                int edwt = it.second;\\n                int adjNode= it.first;\\n                if(Nodedist+edwt<dist[adjNode]){\\n                    if(dist[adjNode]!= INT_MAX)\\n                        st.erase({dist[adjNode],adjNode});\\n                    \\n                    dist[adjNode]=Nodedist+edwt;\\n                    st.insert({dist[adjNode],adjNode});\\n                    //pq.push({dist[adjNode],adjNode});\\n                }\\n            }\\n        }\\n        if(dist[node2]==INT_MAX) return -1;\\n        return dist[node2];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Graph {\\npublic:\\n    vector<pair<int,int>>adj[101];\\n    int size;\\n    \\n    Graph(int n, vector<vector<int>>& edges) {\\n        size=n;\\n         for(auto i:edges){\\n            adj[i[0]].push_back({i[1],i[2]});\\n         } \\n    }\\n\\n    void addEdge(vector<int> edge) {\\n        adj[edge[0]].push_back({edge[1],edge[2]});\\n    }\\n\\n    int shortestPath(int node1, int node2) {\\n       // priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pq;\\n        set<pair<int,int>>st;\\n        vector<int>dist(size+1,INT_MAX);\\n        dist[node1]=0;\\n        //pq.push({0,node1});\\n        st.insert({0,node1});\\n        while(!st.empty()){\\n            auto it = *(st.begin());\\n            int Nodedist=it.first;\\n            int node=it.second;\\n            st.erase(it);\\n            for(auto it:adj[node]){\\n                int edwt = it.second;\\n                int adjNode= it.first;\\n                if(Nodedist+edwt<dist[adjNode]){\\n                    if(dist[adjNode]!= INT_MAX)\\n                        st.erase({dist[adjNode],adjNode});\\n                    \\n                    dist[adjNode]=Nodedist+edwt;\\n                    st.insert({dist[adjNode],adjNode});\\n                    //pq.push({dist[adjNode],adjNode});\\n                }\\n            }\\n        }\\n        if(dist[node2]==INT_MAX) return -1;\\n        return dist[node2];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3423025,
                "title": "c-dijkstra",
                "content": "```\\nclass Graph {\\npublic:\\n    vector<vector<pair<int,int>>> adj;\\n    int n;\\n    Graph(int n, vector<vector<int>>& edges) {\\n        this->n = n;\\n        adj.clear();\\n        adj.resize(n);\\n        for(auto &e : edges){\\n            addEdge(e);\\n        }\\n    }\\n    \\n    void addEdge(vector<int> e) {\\n        adj[e[0]].push_back({e[2], e[1]});\\n    }\\n    \\n    int shortestPath(int node1, int node2) {\\n        priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> pq;\\n        pq.push({0, node1});\\n        \\n        vector<int> dist(n, INT_MAX);\\n        dist[node1] = 0;\\n        \\n        while(!pq.empty()){\\n            int wt = pq.top().first, u=pq.top().second;\\n            pq.pop();\\n            for(auto &child : adj[u]){\\n                int wt2 = child.first, v = child.second;\\n                if(dist[v] > dist[u]+wt2){\\n                    dist[v] = dist[u]+wt2;\\n                    pq.push({dist[v], v});\\n                }\\n            }\\n        }\\n        \\n        return dist[node2]==INT_MAX ? -1 : dist[node2];\\n    }\\n};\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph* obj = new Graph(n, edges);\\n * obj->addEdge(edge);\\n * int param_2 = obj->shortestPath(node1,node2);\\n */\\n```\\nplease **UPVOTE**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Heap (Priority Queue)",
                    "Shortest Path"
                ],
                "code": "```\\nclass Graph {\\npublic:\\n    vector<vector<pair<int,int>>> adj;\\n    int n;\\n    Graph(int n, vector<vector<int>>& edges) {\\n        this->n = n;\\n        adj.clear();\\n        adj.resize(n);\\n        for(auto &e : edges){\\n            addEdge(e);\\n        }\\n    }\\n    \\n    void addEdge(vector<int> e) {\\n        adj[e[0]].push_back({e[2], e[1]});\\n    }\\n    \\n    int shortestPath(int node1, int node2) {\\n        priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> pq;\\n        pq.push({0, node1});\\n        \\n        vector<int> dist(n, INT_MAX);\\n        dist[node1] = 0;\\n        \\n        while(!pq.empty()){\\n            int wt = pq.top().first, u=pq.top().second;\\n            pq.pop();\\n            for(auto &child : adj[u]){\\n                int wt2 = child.first, v = child.second;\\n                if(dist[v] > dist[u]+wt2){\\n                    dist[v] = dist[u]+wt2;\\n                    pq.push({dist[v], v});\\n                }\\n            }\\n        }\\n        \\n        return dist[node2]==INT_MAX ? -1 : dist[node2];\\n    }\\n};\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph* obj = new Graph(n, edges);\\n * obj->addEdge(edge);\\n * int param_2 = obj->shortestPath(node1,node2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422725,
                "title": "dijkstra-s-shortest-path-algo-clean-code-java",
                "content": "# Intuition\\nThe graph is clearly Directed + Weighted, and problem demands shortest paths between 2 nodes. Hence, Dijkstra\\'s is the simplest approach to run each time ```int shortestPath(int node1, int node2)``` is executed.\\n\\n# Approach\\n1. To traverse any graph (BFS or DFS or DIJKSTRA), we need an aadjacency list. This lets you look up a node\\'s neighbors in ```O(1)``` Time while using ```(V * E)``` Space. From there we add each edge to this data structure.\\n\\n2. Dijsktra\\'s Shortest path requires you to maintain the shortest distance found for all N nodes. We also need a PriorityQueue i.e Min Heap to organize the nodes being traversed. This PriorityQueue holds nodes represented by a. nodeID and b. distance traveled to reach this node so far. The Heap will prioritize the nodes with the LEAST distance traveled.\\n3. For each node popped from the heap, explore the neighbors pulled from the adjacency list. Each neighbor/child node will have its cost added to the popped node\\'s distance traveled. If the total is an improvement on the child\\'s min distance, update it and enqueue it into the Heap.\\n4. Eventually all reachable nodes will have their min distance optimized to the abosulte best, and the heap has nothing to be enqueued (i.e. empty). Remember that the starting node may not be able to reach the target node.\\n\\n# Complexity\\n- Time complexity:\\n```O(E * log|V|) ``` since the Heap takes ```log(v)``` to pop the next node each time. This is multiplied by ```(E + V)``` because we are traversing all neighboring nodes (i.e. number of edges). This does not TLE only because the number of times ```int shortestPath(int node1, int node2)``` is executed is at most 100x.\\n\\n- Space complexity:\\n```(V * E)``` to store adjacency list.\\n\\nIf something in this seems incorrect, feel free to comment.\\n\\n# Code\\n```\\nclass Graph {\\n    \\n    List<Pair<Integer, Integer>>[] adjList;\\n    int n;\\n    public Graph(int n, int[][] edges) {\\n        produceAdjList(n, edges);\\n    }\\n    \\n    private void produceAdjList(int n, int[][] edges) {\\n        // Initialize adjacency list with empty neighbors per node.\\n        this.n = n;\\n        this.adjList = new ArrayList[n];\\n\\n        for (int i = 0; i < n; i++)\\n            adjList[i] = new ArrayList();\\n        \\n        // Populate adjacency list with each edge.\\n        for (int[] edge : edges)\\n            addEdge(edge);\\n    }\\n    \\n    public void addEdge(int[] edge) {\\n        // For FROM, add connection with TO + COST.\\n        int from = edge[0], to = edge[1], cost = edge[2];\\n        adjList[from].add(new Pair(to, cost));\\n    }\\n    \\n    public int shortestPath(int node1, int node2) {\\n        // Maintain shortest path found per node.\\n        int[] minDist = new int[n];\\n        Arrays.fill(minDist, Integer.MAX_VALUE);\\n        \\n        // Begin with starting node having min distance 0.\\n        minDist[node1] = 0;\\n\\n        // PriorityQueue sorts nodes by those traveling smallest distance.\\n        // Each Pair is represented as [nodeId, distanceTraveled].\\n        PriorityQueue<Pair<Integer, Integer>> pq = new PriorityQueue<>((a, b) -> a.getValue() - b.getValue());\\n\\n        // Enque first node with 0 distance.\\n        pq.add(new Pair(node1, 0));\\n\\n        // Execute Dijkstra\\'s Shortest path.\\n        while (!pq.isEmpty()) {\\n            // Get next node.\\n            Pair<Integer, Integer> entry = pq.poll();\\n            int node = entry.getKey();\\n            int dist = entry.getValue();\\n            \\n            // Go thru neighbors to continue search.\\n            for (var child : adjList[node]) {\\n                // Check if distance is improved.\\n                int childDist = child.getValue() + dist;\\n                int childNode = child.getKey();\\n                if (childDist < minDist[childNode]) {\\n                    // Mark new shortest distance and enqeue node.\\n                    minDist[childNode] = childDist;\\n                    pq.add(new Pair(childNode, childDist));\\n                }\\n            }\\n        }\\n        \\n        // Send result if we ever found the target.\\n        return minDist[node2] == Integer.MAX_VALUE ? -1 : minDist[node2];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Graph"
                ],
                "code": "```int shortestPath(int node1, int node2)```\n```O(1)```\n```(V * E)```\n```O(E * log|V|) ```\n```log(v)```\n```(E + V)```\n```int shortestPath(int node1, int node2)```\n```(V * E)```\n```\\nclass Graph {\\n    \\n    List<Pair<Integer, Integer>>[] adjList;\\n    int n;\\n    public Graph(int n, int[][] edges) {\\n        produceAdjList(n, edges);\\n    }\\n    \\n    private void produceAdjList(int n, int[][] edges) {\\n        // Initialize adjacency list with empty neighbors per node.\\n        this.n = n;\\n        this.adjList = new ArrayList[n];\\n\\n        for (int i = 0; i < n; i++)\\n            adjList[i] = new ArrayList();\\n        \\n        // Populate adjacency list with each edge.\\n        for (int[] edge : edges)\\n            addEdge(edge);\\n    }\\n    \\n    public void addEdge(int[] edge) {\\n        // For FROM, add connection with TO + COST.\\n        int from = edge[0], to = edge[1], cost = edge[2];\\n        adjList[from].add(new Pair(to, cost));\\n    }\\n    \\n    public int shortestPath(int node1, int node2) {\\n        // Maintain shortest path found per node.\\n        int[] minDist = new int[n];\\n        Arrays.fill(minDist, Integer.MAX_VALUE);\\n        \\n        // Begin with starting node having min distance 0.\\n        minDist[node1] = 0;\\n\\n        // PriorityQueue sorts nodes by those traveling smallest distance.\\n        // Each Pair is represented as [nodeId, distanceTraveled].\\n        PriorityQueue<Pair<Integer, Integer>> pq = new PriorityQueue<>((a, b) -> a.getValue() - b.getValue());\\n\\n        // Enque first node with 0 distance.\\n        pq.add(new Pair(node1, 0));\\n\\n        // Execute Dijkstra\\'s Shortest path.\\n        while (!pq.isEmpty()) {\\n            // Get next node.\\n            Pair<Integer, Integer> entry = pq.poll();\\n            int node = entry.getKey();\\n            int dist = entry.getValue();\\n            \\n            // Go thru neighbors to continue search.\\n            for (var child : adjList[node]) {\\n                // Check if distance is improved.\\n                int childDist = child.getValue() + dist;\\n                int childNode = child.getKey();\\n                if (childDist < minDist[childNode]) {\\n                    // Mark new shortest distance and enqeue node.\\n                    minDist[childNode] = childDist;\\n                    pq.add(new Pair(childNode, childDist));\\n                }\\n            }\\n        }\\n        \\n        // Send result if we ever found the target.\\n        return minDist[node2] == Integer.MAX_VALUE ? -1 : minDist[node2];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421986,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\n#[derive(Debug, Clone, PartialEq, Eq, Hash)]\\nstruct Graph {\\n    al: Vec<Vec<(usize, i32)>>,\\n}\\n\\nimpl Graph {\\n    fn new(n: i32, edges: Vec<Vec<i32>>) -> Self {\\n        let mut al = vec![vec![]; n as usize];\\n        for e in edges {\\n            al[e[0] as usize].push((e[1] as usize, e[2]));\\n        }\\n        Self { al }\\n    }\\n\\n    fn add_edge(&mut self, edge: Vec<i32>) {\\n        self.al[edge[0] as usize].push((edge[1] as usize, edge[2]));\\n    }\\n\\n    fn shortest_path(&self, node1: i32, node2: i32) -> i32 {\\n        let mut pq = std::collections::BinaryHeap::new();\\n        let mut cost = vec![std::i32::MAX; self.al.len()];\\n        cost[node1 as usize] = 0;\\n        pq.push(std::cmp::Reverse((0, node1)));\\n        while let Some(std::cmp::Reverse((cost_i, i))) = pq.pop() {\\n            if cost_i != cost[i as usize] {\\n                continue;\\n            }\\n            for (j, cost_j) in &self.al[i as usize] {\\n                if cost_i + *cost_j < cost[*j] {\\n                    cost[*j] = cost_i + *cost_j;\\n                    pq.push(std::cmp::Reverse((cost[*j], *j as i32)));\\n                }\\n            }\\n        }\\n        if cost[node2 as usize] == std::i32::MAX {\\n            -1\\n        } else {\\n            cost[node2 as usize]\\n        }\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\n#[derive(Debug, Clone, PartialEq, Eq, Hash)]\\nstruct Graph {\\n    al: Vec<Vec<(usize, i32)>>,\\n}\\n\\nimpl Graph {\\n    fn new(n: i32, edges: Vec<Vec<i32>>) -> Self {\\n        let mut al = vec![vec![]; n as usize];\\n        for e in edges {\\n            al[e[0] as usize].push((e[1] as usize, e[2]));\\n        }\\n        Self { al }\\n    }\\n\\n    fn add_edge(&mut self, edge: Vec<i32>) {\\n        self.al[edge[0] as usize].push((edge[1] as usize, edge[2]));\\n    }\\n\\n    fn shortest_path(&self, node1: i32, node2: i32) -> i32 {\\n        let mut pq = std::collections::BinaryHeap::new();\\n        let mut cost = vec![std::i32::MAX; self.al.len()];\\n        cost[node1 as usize] = 0;\\n        pq.push(std::cmp::Reverse((0, node1)));\\n        while let Some(std::cmp::Reverse((cost_i, i))) = pq.pop() {\\n            if cost_i != cost[i as usize] {\\n                continue;\\n            }\\n            for (j, cost_j) in &self.al[i as usize] {\\n                if cost_i + *cost_j < cost[*j] {\\n                    cost[*j] = cost_i + *cost_j;\\n                    pq.push(std::cmp::Reverse((cost[*j], *j as i32)));\\n                }\\n            }\\n        }\\n        if cost[node2 as usize] == std::i32::MAX {\\n            -1\\n        } else {\\n            cost[node2 as usize]\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3421545,
                "title": "c-simple-dijkstra-algorithm",
                "content": "\\n# Code\\n```\\nclass Graph {\\npublic:\\n    vector<vector<pair<int,int>>> adj;\\n    int n;\\n    Graph(int m, vector<vector<int>>& edges) {\\n        n = m;\\n        adj.resize(n);\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            int a = edges[i][0];\\n            int b = edges[i][1];\\n            int dis = edges[i][2];\\n            adj[a].push_back({b,dis});\\n        }\\n    }\\n    \\n    void addEdge(vector<int> edge) {\\n        int a = edge[0];\\n        int b = edge[1];\\n        int dis = edge[2];\\n        adj[a].push_back({b,dis});\\n    }\\n    \\n    int shortestPath(int node1, int node2) {\\n        vector<int> dist(n,INT_MAX);\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pq;\\n        pq.push({0,node1});\\n        dist[node1] = 0;\\n        while(!pq.empty())\\n        {\\n            int u = pq.top().second;\\n            pq.pop();\\n            for(auto &i:adj[u])\\n            {\\n                int v = i.first;\\n                int dis = i.second;\\n                if(dist[v]>dist[u]+dis)\\n                {\\n                    dist[v] = dist[u]+dis;\\n                    pq.push({dist[v],v});\\n                }\\n            }\\n        }\\n        if(dist[node2]==INT_MAX)\\n            return -1;\\n        return dist[node2];\\n    }\\n};\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph* obj = new Graph(n, edges);\\n * obj->addEdge(edge);\\n * int param_2 = obj->shortestPath(node1,node2);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Graph {\\npublic:\\n    vector<vector<pair<int,int>>> adj;\\n    int n;\\n    Graph(int m, vector<vector<int>>& edges) {\\n        n = m;\\n        adj.resize(n);\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            int a = edges[i][0];\\n            int b = edges[i][1];\\n            int dis = edges[i][2];\\n            adj[a].push_back({b,dis});\\n        }\\n    }\\n    \\n    void addEdge(vector<int> edge) {\\n        int a = edge[0];\\n        int b = edge[1];\\n        int dis = edge[2];\\n        adj[a].push_back({b,dis});\\n    }\\n    \\n    int shortestPath(int node1, int node2) {\\n        vector<int> dist(n,INT_MAX);\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pq;\\n        pq.push({0,node1});\\n        dist[node1] = 0;\\n        while(!pq.empty())\\n        {\\n            int u = pq.top().second;\\n            pq.pop();\\n            for(auto &i:adj[u])\\n            {\\n                int v = i.first;\\n                int dis = i.second;\\n                if(dist[v]>dist[u]+dis)\\n                {\\n                    dist[v] = dist[u]+dis;\\n                    pq.push({dist[v],v});\\n                }\\n            }\\n        }\\n        if(dist[node2]==INT_MAX)\\n            return -1;\\n        return dist[node2];\\n    }\\n};\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph* obj = new Graph(n, edges);\\n * obj->addEdge(edge);\\n * int param_2 = obj->shortestPath(node1,node2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421336,
                "title": "java-graph-dijkstra-s-algorithm",
                "content": "# Intuition\\nDijkstra\\'s Algorithm finds the shortest path between a given node (which is called the \"node1\" in this problem) and all other nodes in a graph. \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nStore edges in a HashMap and perform Dijkstra\\'s shortest path algorithm.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(V^2) (It can be reduced to O(ElogV))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(E + V)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Graph {\\n\\n    private HashMap<Integer, HashMap<Integer, Integer>> map;\\n\\n    public Graph(int n, int[][] edges) {\\n        map = new HashMap<>();\\n        for (int i = 0; i < n; i++) {\\n            map.put(i, new HashMap<>());\\n        }\\n        for (int[] edge : edges) {\\n            map.get(edge[0]).put(edge[1], edge[2]);\\n        }\\n    }\\n\\n    public void addEdge(int[] edge) {\\n        map.get(edge[0]).put(edge[1], edge[2]);\\n    }\\n\\n    private int findMinimum(boolean[] visited, int[] costMap) {\\n        int minVal = Integer.MAX_VALUE, min = -1;\\n        for (int i = 0; i < costMap.length; i++) {\\n            if (!visited[i]) {\\n                if (minVal > costMap[i]) {\\n                    minVal = costMap[i];\\n                    min = i;\\n                }\\n            }\\n        }\\n        return min;\\n    }\\n\\n    public int shortestPath(int node1, int node2) {\\n        boolean[] visited = new boolean[this.map.size()];\\n        int[] costMap = new int[this.map.size()];\\n        Arrays.fill(costMap, Integer.MAX_VALUE);\\n        costMap[node1] = 0;\\n        for (int i = 0; i < this.map.size() - 1; i++) {\\n            int key = findMinimum(visited, costMap);\\n            if (key == -1) {\\n                break;\\n            }\\n            visited[key] = true;\\n            if (this.map.containsKey(key)) {\\n                for (int to : this.map.get(key).keySet()) {\\n                    costMap[to] = Math.min(costMap[to], costMap[key] + this.map.get(key).get(to));\\n                }\\n            }\\n        }\\n        if (costMap[node2] == Integer.MAX_VALUE) {\\n            return -1;\\n        }\\n        return costMap[node2];\\n    }\\n}\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph obj = new Graph(n, edges);\\n * obj.addEdge(edge);\\n * int param_2 = obj.shortestPath(node1,node2);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Graph",
                    "Shortest Path"
                ],
                "code": "```\\nclass Graph {\\n\\n    private HashMap<Integer, HashMap<Integer, Integer>> map;\\n\\n    public Graph(int n, int[][] edges) {\\n        map = new HashMap<>();\\n        for (int i = 0; i < n; i++) {\\n            map.put(i, new HashMap<>());\\n        }\\n        for (int[] edge : edges) {\\n            map.get(edge[0]).put(edge[1], edge[2]);\\n        }\\n    }\\n\\n    public void addEdge(int[] edge) {\\n        map.get(edge[0]).put(edge[1], edge[2]);\\n    }\\n\\n    private int findMinimum(boolean[] visited, int[] costMap) {\\n        int minVal = Integer.MAX_VALUE, min = -1;\\n        for (int i = 0; i < costMap.length; i++) {\\n            if (!visited[i]) {\\n                if (minVal > costMap[i]) {\\n                    minVal = costMap[i];\\n                    min = i;\\n                }\\n            }\\n        }\\n        return min;\\n    }\\n\\n    public int shortestPath(int node1, int node2) {\\n        boolean[] visited = new boolean[this.map.size()];\\n        int[] costMap = new int[this.map.size()];\\n        Arrays.fill(costMap, Integer.MAX_VALUE);\\n        costMap[node1] = 0;\\n        for (int i = 0; i < this.map.size() - 1; i++) {\\n            int key = findMinimum(visited, costMap);\\n            if (key == -1) {\\n                break;\\n            }\\n            visited[key] = true;\\n            if (this.map.containsKey(key)) {\\n                for (int to : this.map.get(key).keySet()) {\\n                    costMap[to] = Math.min(costMap[to], costMap[key] + this.map.get(key).get(to));\\n                }\\n            }\\n        }\\n        if (costMap[node2] == Integer.MAX_VALUE) {\\n            return -1;\\n        }\\n        return costMap[node2];\\n    }\\n}\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph obj = new Graph(n, edges);\\n * obj.addEdge(edge);\\n * int param_2 = obj.shortestPath(node1,node2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421330,
                "title": "c-bruteforce-dijkstra",
                "content": "```\\nclass Graph {\\npublic:\\n    unordered_map<int,vector<pair<int,int>>> ourmap;\\n    int nodes;\\n    Graph(int n, vector<vector<int>>& edges) {\\n        for(int i=0;i<edges.size();i++){\\n            int a=edges[i][0];\\n            int b=edges[i][1];\\n            int weight=edges[i][2];\\n            ourmap[a].push_back({b,weight});\\n        }\\n        this->nodes=n;\\n    }\\n    \\n    void addEdge(vector<int> edge) {\\n        \\n        int a=edge[0];\\n        int b=edge[1];\\n        int weight=edge[2];\\n        ourmap[a].push_back({b,weight});\\n    }\\n    \\n    int shortestPath(int node1, int node2) {\\n        \\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> minheap;\\n        vector<int> distance(nodes,1e9);\\n        distance[node1]=0;\\n        minheap.push({0,node1});\\n        while(minheap.size()!=0){\\n            \\n            pair<int,int> front=minheap.top();\\n            minheap.pop();\\n            int d=front.first;\\n            int node=front.second;\\n            vector<pair<int,int>> temp=ourmap[node];\\n            for(int i=0;i<temp.size();i++){\\n                \\n                int child=temp[i].first;\\n                int weight=temp[i].second;\\n                if(d+weight<distance[child]){\\n                    distance[child]=d+weight;\\n                    minheap.push({distance[child],child});\\n                }\\n            }\\n            \\n        }\\n        if(distance[node2]!=1e9){\\n            return distance[node2];\\n        }\\n        return -1;\\n    }\\n};\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph* obj = new Graph(n, edges);\\n * obj->addEdge(edge);\\n * int param_2 = obj->shortestPath(node1,node2);",
                "solutionTags": [],
                "code": "```\\nclass Graph {\\npublic:\\n    unordered_map<int,vector<pair<int,int>>> ourmap;\\n    int nodes;\\n    Graph(int n, vector<vector<int>>& edges) {\\n        for(int i=0;i<edges.size();i++){\\n            int a=edges[i][0];\\n            int b=edges[i][1];\\n            int weight=edges[i][2];\\n            ourmap[a].push_back({b,weight});\\n        }\\n        this->nodes=n;\\n    }\\n    \\n    void addEdge(vector<int> edge) {\\n        \\n        int a=edge[0];\\n        int b=edge[1];\\n        int weight=edge[2];\\n        ourmap[a].push_back({b,weight});\\n    }\\n    \\n    int shortestPath(int node1, int node2) {\\n        \\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> minheap;\\n        vector<int> distance(nodes,1e9);\\n        distance[node1]=0;\\n        minheap.push({0,node1});\\n        while(minheap.size()!=0){\\n            \\n            pair<int,int> front=minheap.top();\\n            minheap.pop();\\n            int d=front.first;\\n            int node=front.second;\\n            vector<pair<int,int>> temp=ourmap[node];\\n            for(int i=0;i<temp.size();i++){\\n                \\n                int child=temp[i].first;\\n                int weight=temp[i].second;\\n                if(d+weight<distance[child]){\\n                    distance[child]=d+weight;\\n                    minheap.push({distance[child],child});\\n                }\\n            }\\n            \\n        }\\n        if(distance[node2]!=1e9){\\n            return distance[node2];\\n        }\\n        return -1;\\n    }\\n};\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph* obj = new Graph(n, edges);\\n * obj->addEdge(edge);\\n * int param_2 = obj->shortestPath(node1,node2);",
                "codeTag": "Java"
            },
            {
                "id": 3421298,
                "title": "go-dijkstra-s-shortest-path-algorithm",
                "content": "This is a fairly standard implementation based on Dijkstra\\'s shortest path algorithm and using a priority queue. With some more patience, it should be possible to develop an incremental solution that better fits this usecase. \\n\\n```\\ntype Edge struct {\\n    head int\\n    cost int\\n}\\n\\ntype Graph struct {\\n    adj [][]Edge\\n}\\n\\nfunc Constructor(n int, edges [][]int) Graph {\\n    adj := make([][]Edge, n)\\n    for _, e := range edges {\\n        adj[e[0]] = append(adj[e[0]], Edge{e[1], e[2]})\\n    }\\n    return Graph{adj}\\n}\\n\\nfunc (this *Graph) AddEdge(edge []int)  {\\n    this.adj[edge[0]] = append(this.adj[edge[0]], Edge{edge[1], edge[2]})\\n}\\n\\nfunc (this *Graph) ShortestPath(node1 int, node2 int) int {\\n    n := len(this.adj)\\n    items := make([]*Item, n)\\n    for i := 0; i < n; i++ {\\n        items[i] = &Item{i, math.MaxInt, i}\\n    }\\n    items[node1].priority = 0\\n    queue := make(PriorityQueue, n)\\n    copy(queue, items)\\n    heap.Init(&queue)\\n    for len(queue) > 0 {\\n        i := heap.Pop(&queue).(*Item)\\n        node, priority := i.value, i.priority\\n        if priority == math.MaxInt || node == node2 {\\n            break\\n        }\\n        for _, e := range this.adj[node] {\\n            j := items[e.head]\\n            if h := priority + e.cost; h < j.priority {\\n                j.priority = h\\n                heap.Fix(&queue, j.index)\\n            }\\n        } \\n    }\\n    if items[node2].priority == math.MaxInt {\\n        return -1\\n    }\\n    return items[node2].priority\\n}\\n\\ntype Item struct {\\n\\tvalue    int\\n\\tpriority int\\n\\tindex    int\\n}\\n\\ntype PriorityQueue []*Item\\n\\nfunc (pq PriorityQueue) Len() int { return len(pq) }\\n\\nfunc (pq PriorityQueue) Less(i, j int) bool {\\n\\treturn pq[i].priority < pq[j].priority\\n}\\n\\nfunc (pq PriorityQueue) Swap(i, j int) {\\n\\tpq[i], pq[j] = pq[j], pq[i]\\n\\tpq[i].index = i\\n\\tpq[j].index = j\\n}\\n\\nfunc (pq *PriorityQueue) Push(x interface{}) {\\n\\tn := len(*pq)\\n\\titem := x.(*Item)\\n\\titem.index = n\\n\\t*pq = append(*pq, item)\\n}\\n\\nfunc (pq *PriorityQueue) Pop() interface{} {\\n\\told := *pq\\n\\tn := len(old)\\n\\titem := old[n-1]\\n\\told[n-1] = nil  // avoid memory leak\\n\\titem.index = -1 // for safety\\n\\t*pq = old[0 : n-1]\\n\\treturn item\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\ntype Edge struct {\\n    head int\\n    cost int\\n}\\n\\ntype Graph struct {\\n    adj [][]Edge\\n}\\n\\nfunc Constructor(n int, edges [][]int) Graph {\\n    adj := make([][]Edge, n)\\n    for _, e := range edges {\\n        adj[e[0]] = append(adj[e[0]], Edge{e[1], e[2]})\\n    }\\n    return Graph{adj}\\n}\\n\\nfunc (this *Graph) AddEdge(edge []int)  {\\n    this.adj[edge[0]] = append(this.adj[edge[0]], Edge{edge[1], edge[2]})\\n}\\n\\nfunc (this *Graph) ShortestPath(node1 int, node2 int) int {\\n    n := len(this.adj)\\n    items := make([]*Item, n)\\n    for i := 0; i < n; i++ {\\n        items[i] = &Item{i, math.MaxInt, i}\\n    }\\n    items[node1].priority = 0\\n    queue := make(PriorityQueue, n)\\n    copy(queue, items)\\n    heap.Init(&queue)\\n    for len(queue) > 0 {\\n        i := heap.Pop(&queue).(*Item)\\n        node, priority := i.value, i.priority\\n        if priority == math.MaxInt || node == node2 {\\n            break\\n        }\\n        for _, e := range this.adj[node] {\\n            j := items[e.head]\\n            if h := priority + e.cost; h < j.priority {\\n                j.priority = h\\n                heap.Fix(&queue, j.index)\\n            }\\n        } \\n    }\\n    if items[node2].priority == math.MaxInt {\\n        return -1\\n    }\\n    return items[node2].priority\\n}\\n\\ntype Item struct {\\n\\tvalue    int\\n\\tpriority int\\n\\tindex    int\\n}\\n\\ntype PriorityQueue []*Item\\n\\nfunc (pq PriorityQueue) Len() int { return len(pq) }\\n\\nfunc (pq PriorityQueue) Less(i, j int) bool {\\n\\treturn pq[i].priority < pq[j].priority\\n}\\n\\nfunc (pq PriorityQueue) Swap(i, j int) {\\n\\tpq[i], pq[j] = pq[j], pq[i]\\n\\tpq[i].index = i\\n\\tpq[j].index = j\\n}\\n\\nfunc (pq *PriorityQueue) Push(x interface{}) {\\n\\tn := len(*pq)\\n\\titem := x.(*Item)\\n\\titem.index = n\\n\\t*pq = append(*pq, item)\\n}\\n\\nfunc (pq *PriorityQueue) Pop() interface{} {\\n\\told := *pq\\n\\tn := len(old)\\n\\titem := old[n-1]\\n\\told[n-1] = nil  // avoid memory leak\\n\\titem.index = -1 // for safety\\n\\t*pq = old[0 : n-1]\\n\\treturn item\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3421291,
                "title": "java-dijkstra-s-algorithm",
                "content": "\\n# Code\\n```\\nclass Edge {\\n  int v; // other vertex v\\n  int w; // edge weight\\n\\n  public Edge(int _v, int _w) {\\n    v = _v;\\n    w = _w;\\n  }\\n}\\n\\nclass Graph {\\n  List < Edge > [] graph;\\n  int n;\\n  int inf = Integer.MAX_VALUE;\\n  public Graph(int n, int[][] edges) {\\n    //Intialize graph\\n    this.n = n;\\n    graph = new ArrayList[n];\\n    for (int i = 0; i < n; i++) graph[i] = new ArrayList < > ();\\n\\n    //construct graph\\n    for (int[] edge: edges) \\n      addEdge(edge);\\n  }\\n\\n  public void addEdge(int[] edge) {\\n    int u = edge[0], v = edge[1], weight = edge[2];\\n    graph[u].add(new Edge(v, weight));\\n  }\\n\\n  public int shortestPath(int node1, int node2) {\\n    PriorityQueue < Edge > pq = new PriorityQueue < > ((a, b) -> a.w - b.w);\\n    int[] dist = new int[n];\\n    Arrays.fill(dist, inf);\\n\\n    dist[node1] = 0;\\n    pq.add(new Edge(node1, 0));\\n\\n    while (!pq.isEmpty()) {\\n      Edge cur = pq.poll();\\n      int u = cur.v;\\n\\n      for (Edge e: graph[u]) {\\n        int v = e.v;\\n        int weight = e.w;\\n\\n        if (dist[u] + weight < dist[v]) {\\n          dist[v] = dist[u] + weight;\\n          pq.add(new Edge(v, dist[v]));\\n        }\\n      }\\n    }\\n\\n    return dist[node2] == inf? -1 : dist[node2];\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Edge {\\n  int v; // other vertex v\\n  int w; // edge weight\\n\\n  public Edge(int _v, int _w) {\\n    v = _v;\\n    w = _w;\\n  }\\n}\\n\\nclass Graph {\\n  List < Edge > [] graph;\\n  int n;\\n  int inf = Integer.MAX_VALUE;\\n  public Graph(int n, int[][] edges) {\\n    //Intialize graph\\n    this.n = n;\\n    graph = new ArrayList[n];\\n    for (int i = 0; i < n; i++) graph[i] = new ArrayList < > ();\\n\\n    //construct graph\\n    for (int[] edge: edges) \\n      addEdge(edge);\\n  }\\n\\n  public void addEdge(int[] edge) {\\n    int u = edge[0], v = edge[1], weight = edge[2];\\n    graph[u].add(new Edge(v, weight));\\n  }\\n\\n  public int shortestPath(int node1, int node2) {\\n    PriorityQueue < Edge > pq = new PriorityQueue < > ((a, b) -> a.w - b.w);\\n    int[] dist = new int[n];\\n    Arrays.fill(dist, inf);\\n\\n    dist[node1] = 0;\\n    pq.add(new Edge(node1, 0));\\n\\n    while (!pq.isEmpty()) {\\n      Edge cur = pq.poll();\\n      int u = cur.v;\\n\\n      for (Edge e: graph[u]) {\\n        int v = e.v;\\n        int weight = e.w;\\n\\n        if (dist[u] + weight < dist[v]) {\\n          dist[v] = dist[u] + weight;\\n          pq.add(new Edge(v, dist[v]));\\n        }\\n      }\\n    }\\n\\n    return dist[node2] == inf? -1 : dist[node2];\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421175,
                "title": "breadth-first-search-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(n^2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#include<ctime>\\n#include<cmath>\\n#include<cstring>\\n#include<list>\\n#include<vector>\\n#include<queue>\\n#include<stack>\\n#include<iostream>\\n\\nclass Graph {\\npublic:\\n    std::vector<std::vector<int>> graph ; \\n    std::vector<std::vector<int>> costs ;\\n    std::vector<int> dists ; \\n    int spread= 0  ;\\n    long long skies = 1000000000000 ;\\n    int search(int begin,int stop){\\n        std::pair<int,int> parse(begin,0) ;\\n        std::queue<std::pair<int,int>> values ; \\n        values.push(parse) ;\\n        long long minned = skies ;\\n        int check = false  ;\\n        while(values.size()>0){\\n         parse =  values.front() ;\\n            values.pop() ;\\n            std::vector<int>& buffer = graph[parse.first] ;\\n            for(int ds=0;ds<buffer.size();ds++){\\n                int temps = buffer[ds] ;\\n                int added = costs[parse.first][temps] ;\\n                if(temps==stop){minned \\n                    = std::min(minned,(long long)(parse.second+added)) ;\\n                check= true ;        continue ; }\\n                if(dists[temps]!=-1&&dists[temps]<=parse.second+added)\\n                {; continue ; }\\n                dists[temps]=  parse.second+added ; \\n                values.push(std::pair<int,int>(temps,parse.second+added)) ;\\n            }\\n        }\\n          if(stop== begin ){return  0;}\\n        if(check==false){return -1 ; }\\n        return (int)minned ; \\n    }\\n    Graph(int n, vector<vector<int>>& edges) {\\n        int breadth = edges.size() ;\\n        std::vector<int> worker ;\\n        graph = std::vector<std::vector<int>>(n,worker) ;\\n        worker = std::vector<int>(n,0) ;\\n        costs = std::vector<std::vector<int>>(n,worker) ;\\n        dists = std::vector<int>(n,-1) ;\\n        spread = n  ;\\n        // std::cout<<44  ;\\n        for(int   fs=0 ;fs <breadth ;fs++){\\n            std::vector<int>& check = edges[fs] ;\\n            costs[check[0]][check[1]] = check[2] ;\\n            graph[check[0]].push_back(check[1]) ;\\n        }\\n       // std::cout<<55 ; \\n    }\\n    \\n    void addEdge(vector<int> edge) {\\n        int lower = edge[1] ;\\n        int upper = edge[0] ;\\n        graph[upper].push_back(lower)   ; \\n        costs[upper][lower] = edge[2] ;\\n    }\\n    \\n    int shortestPath(int node1, int node2) {\\n        dists = std::vector<int>(spread,-1) ;\\n        if(node2==node1){return 0;}\\n        int mines = search(node1,node2) ;\\n        // int mines = 4 ; \\n        return mines ; \\n    }\\n};\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph* obj = new Graph(n, edges);\\n * obj->addEdge(edge);\\n * int param_2 = obj->shortestPath(node1,node2);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph",
                    "Queue",
                    "Shortest Path"
                ],
                "code": "```\\n#include<ctime>\\n#include<cmath>\\n#include<cstring>\\n#include<list>\\n#include<vector>\\n#include<queue>\\n#include<stack>\\n#include<iostream>\\n\\nclass Graph {\\npublic:\\n    std::vector<std::vector<int>> graph ; \\n    std::vector<std::vector<int>> costs ;\\n    std::vector<int> dists ; \\n    int spread= 0  ;\\n    long long skies = 1000000000000 ;\\n    int search(int begin,int stop){\\n        std::pair<int,int> parse(begin,0) ;\\n        std::queue<std::pair<int,int>> values ; \\n        values.push(parse) ;\\n        long long minned = skies ;\\n        int check = false  ;\\n        while(values.size()>0){\\n         parse =  values.front() ;\\n            values.pop() ;\\n            std::vector<int>& buffer = graph[parse.first] ;\\n            for(int ds=0;ds<buffer.size();ds++){\\n                int temps = buffer[ds] ;\\n                int added = costs[parse.first][temps] ;\\n                if(temps==stop){minned \\n                    = std::min(minned,(long long)(parse.second+added)) ;\\n                check= true ;        continue ; }\\n                if(dists[temps]!=-1&&dists[temps]<=parse.second+added)\\n                {; continue ; }\\n                dists[temps]=  parse.second+added ; \\n                values.push(std::pair<int,int>(temps,parse.second+added)) ;\\n            }\\n        }\\n          if(stop== begin ){return  0;}\\n        if(check==false){return -1 ; }\\n        return (int)minned ; \\n    }\\n    Graph(int n, vector<vector<int>>& edges) {\\n        int breadth = edges.size() ;\\n        std::vector<int> worker ;\\n        graph = std::vector<std::vector<int>>(n,worker) ;\\n        worker = std::vector<int>(n,0) ;\\n        costs = std::vector<std::vector<int>>(n,worker) ;\\n        dists = std::vector<int>(n,-1) ;\\n        spread = n  ;\\n        // std::cout<<44  ;\\n        for(int   fs=0 ;fs <breadth ;fs++){\\n            std::vector<int>& check = edges[fs] ;\\n            costs[check[0]][check[1]] = check[2] ;\\n            graph[check[0]].push_back(check[1]) ;\\n        }\\n       // std::cout<<55 ; \\n    }\\n    \\n    void addEdge(vector<int> edge) {\\n        int lower = edge[1] ;\\n        int upper = edge[0] ;\\n        graph[upper].push_back(lower)   ; \\n        costs[upper][lower] = edge[2] ;\\n    }\\n    \\n    int shortestPath(int node1, int node2) {\\n        dists = std::vector<int>(spread,-1) ;\\n        if(node2==node1){return 0;}\\n        int mines = search(node1,node2) ;\\n        // int mines = 4 ; \\n        return mines ; \\n    }\\n};\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph* obj = new Graph(n, edges);\\n * obj->addEdge(edge);\\n * int param_2 = obj->shortestPath(node1,node2);\\n */\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3421035,
                "title": "clean-easiest-c-code",
                "content": "# Code\\n### PLease Upvote if u liked my Solution\\uD83E\\uDD17\\n```\\nclass Graph {\\npublic:\\n    int nu;\\n    vector<vector<pair<int,int>>> adj;\\n    \\n    Graph(int n, vector<vector<int>>& edges) {\\n        nu=n;\\n        adj.resize(n);\\n        for(auto it:edges)\\n            adj[it[0]].push_back({it[1],it[2]});\\n    }\\n    \\n    void addEdge(vector<int> edge) {\\n        adj[edge[0]].push_back({edge[1],edge[2]});\\n    }\\n    \\n    int shortestPath(int node1, int node2) {\\n        vector<int> distance(nu,INT_MAX);\\n        distance[node1]=0;\\n        using p=pair<int,int>;\\n        priority_queue<p,vector<p>,greater<p>> pq;\\n        pq.push({0,node1});\\n        while(pq.size()){\\n            auto [cost,node] = pq.top();\\n            pq.pop();\\n            if(node == node2)\\n                return cost;\\n            for(auto it:adj[node]){\\n                auto [adjNode,dis] = it;\\n                if(dis + cost < distance[adjNode]){\\n                    distance[adjNode] = dis + cost;\\n                    pq.push({distance[adjNode],adjNode});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph* obj = new Graph(n, edges);\\n * obj->addEdge(edge);\\n * int param_2 = obj->shortestPath(node1,node2);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Graph",
                    "Heap (Priority Queue)",
                    "Shortest Path"
                ],
                "code": "```\\nclass Graph {\\npublic:\\n    int nu;\\n    vector<vector<pair<int,int>>> adj;\\n    \\n    Graph(int n, vector<vector<int>>& edges) {\\n        nu=n;\\n        adj.resize(n);\\n        for(auto it:edges)\\n            adj[it[0]].push_back({it[1],it[2]});\\n    }\\n    \\n    void addEdge(vector<int> edge) {\\n        adj[edge[0]].push_back({edge[1],edge[2]});\\n    }\\n    \\n    int shortestPath(int node1, int node2) {\\n        vector<int> distance(nu,INT_MAX);\\n        distance[node1]=0;\\n        using p=pair<int,int>;\\n        priority_queue<p,vector<p>,greater<p>> pq;\\n        pq.push({0,node1});\\n        while(pq.size()){\\n            auto [cost,node] = pq.top();\\n            pq.pop();\\n            if(node == node2)\\n                return cost;\\n            for(auto it:adj[node]){\\n                auto [adjNode,dis] = it;\\n                if(dis + cost < distance[adjNode]){\\n                    distance[adjNode] = dis + cost;\\n                    pq.push({distance[adjNode],adjNode});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph* obj = new Graph(n, edges);\\n * obj->addEdge(edge);\\n * int param_2 = obj->shortestPath(node1,node2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421024,
                "title": "simple-dijktras-algorithm-with-explanation-specially-designed-for-beginner-s",
                "content": "```\\nvector<pair<int,int>>adj[101];\\n#define ipair pair<int,int>\\n#define ll long long int\\n\\nint dijkstra(int src,int des){\\n    vector<ll>dist(101);\\n    for(int i=0;i<101;i++) dist[i]=LLONG_MAX;\\n    dist[src]=0;\\n    priority_queue<ipair,vector<ipair>,greater<ipair>>pq;\\n    pq.push({0,src}); // fistValue will store the edgeCost till now the currentNode from the sourceNode , Second value will contains the currentNodeValue;\\n    \\n    while(pq.size()){\\n        int u = pq.top().second; pq.pop();\\n        for(auto x: adj[u]){\\n            int v = x.first;\\n            ll val = dist[u]+ x.second;\\n            if(val< dist[v]){\\n                dist[v]=val;\\n                pq.push({dist[v],v});\\n            }\\n        }\\n    }\\n    \\n    if(dist[des]==INT_MAX)\\n        return -1;\\n    return dist[des];\\n    \\n}\\n\\n\\nclass Graph {\\npublic:\\n    Graph(int n, vector<vector<int>>& edges) {\\n        for(int i=0;i<101;i++)\\n            adj[i].clear();\\n        for(auto x: edges){\\n            int src = x[0],des=x[1],cost = x[2];\\n            adj[src].push_back({des,cost});\\n        }\\n        \\n    }\\n    \\n    void addEdge(vector<int> x) {\\n        int src = x[0],des=x[1],cost = x[2];\\n        adj[src].push_back({des,cost});\\n    }\\n    \\n    int shortestPath(int node1, int node2) {\\n        return dijkstra(node1,node2);\\n    }\\n};\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph* obj = new Graph(n, edges);\\n * obj->addEdge(edge);\\n * int param_2 = obj->shortestPath(node1,node2);\\n */\\n```\\n\\nTime Complexity -> O(n^2)*NumberofQueries;\\nSpace Complexity -> O(n) \\nHere n is the number of vertices in the graph;\\n\\n",
                "solutionTags": [],
                "code": "```\\nvector<pair<int,int>>adj[101];\\n#define ipair pair<int,int>\\n#define ll long long int\\n\\nint dijkstra(int src,int des){\\n    vector<ll>dist(101);\\n    for(int i=0;i<101;i++) dist[i]=LLONG_MAX;\\n    dist[src]=0;\\n    priority_queue<ipair,vector<ipair>,greater<ipair>>pq;\\n    pq.push({0,src}); // fistValue will store the edgeCost till now the currentNode from the sourceNode , Second value will contains the currentNodeValue;\\n    \\n    while(pq.size()){\\n        int u = pq.top().second; pq.pop();\\n        for(auto x: adj[u]){\\n            int v = x.first;\\n            ll val = dist[u]+ x.second;\\n            if(val< dist[v]){\\n                dist[v]=val;\\n                pq.push({dist[v],v});\\n            }\\n        }\\n    }\\n    \\n    if(dist[des]==INT_MAX)\\n        return -1;\\n    return dist[des];\\n    \\n}\\n\\n\\nclass Graph {\\npublic:\\n    Graph(int n, vector<vector<int>>& edges) {\\n        for(int i=0;i<101;i++)\\n            adj[i].clear();\\n        for(auto x: edges){\\n            int src = x[0],des=x[1],cost = x[2];\\n            adj[src].push_back({des,cost});\\n        }\\n        \\n    }\\n    \\n    void addEdge(vector<int> x) {\\n        int src = x[0],des=x[1],cost = x[2];\\n        adj[src].push_back({des,cost});\\n    }\\n    \\n    int shortestPath(int node1, int node2) {\\n        return dijkstra(node1,node2);\\n    }\\n};\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph* obj = new Graph(n, edges);\\n * obj->addEdge(edge);\\n * int param_2 = obj->shortestPath(node1,node2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421013,
                "title": "dijkastra-algorithm",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Graph {\\npublic:\\n    unordered_map<int,vector<pair<int,int>>>ump;\\n    int n1;\\n    Graph(int n, vector<vector<int>>& edges) {\\n        for(auto x:edges){\\n            ump[x[0]].push_back({x[1],x[2]});\\n        }\\n        n1=n;\\n    }\\n    \\n    void addEdge(vector<int> edge) {\\n        ump[edge[0]].push_back({edge[1],edge[2]});\\n    }\\n    \\n    int shortestPath(int node1, int node2) {\\n        vector<int>dis(n1,1e9);\\n        dis[node1]=0;\\n        queue<pair<int,int>>q;\\n        q.push({node1,0});\\n        while(!q.empty()){\\n            auto temp=q.front();\\n            q.pop();\\n            for(auto x:ump[temp.first]){\\n                if(dis[x.first]>temp.second+x.second){\\n                    dis[x.first]=temp.second+x.second;\\n                    q.push({x.first,dis[x.first]});\\n                }\\n            }\\n        }\\n        if(dis[node2]==1e9)return -1;\\n        return dis[node2];\\n    }\\n};\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph* obj = new Graph(n, edges);\\n * obj->addEdge(edge);\\n * int param_2 = obj->shortestPath(node1,node2);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Graph {\\npublic:\\n    unordered_map<int,vector<pair<int,int>>>ump;\\n    int n1;\\n    Graph(int n, vector<vector<int>>& edges) {\\n        for(auto x:edges){\\n            ump[x[0]].push_back({x[1],x[2]});\\n        }\\n        n1=n;\\n    }\\n    \\n    void addEdge(vector<int> edge) {\\n        ump[edge[0]].push_back({edge[1],edge[2]});\\n    }\\n    \\n    int shortestPath(int node1, int node2) {\\n        vector<int>dis(n1,1e9);\\n        dis[node1]=0;\\n        queue<pair<int,int>>q;\\n        q.push({node1,0});\\n        while(!q.empty()){\\n            auto temp=q.front();\\n            q.pop();\\n            for(auto x:ump[temp.first]){\\n                if(dis[x.first]>temp.second+x.second){\\n                    dis[x.first]=temp.second+x.second;\\n                    q.push({x.first,dis[x.first]});\\n                }\\n            }\\n        }\\n        if(dis[node2]==1e9)return -1;\\n        return dis[node2];\\n    }\\n};\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph* obj = new Graph(n, edges);\\n * obj->addEdge(edge);\\n * int param_2 = obj->shortestPath(node1,node2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421010,
                "title": "rust-dijkstra-solution",
                "content": "# Code\\n```rust []\\nstruct Graph {\\n    dict: Vec<Vec<(usize, i32)>>,\\n}\\n\\n#[derive(Eq)]\\nstruct Path(usize, i32);\\n\\nimpl PartialEq for Path {\\n    fn eq(&self, other: &Self) -> bool {\\n        self.1 == other.1\\n    }\\n}\\n\\nimpl PartialOrd for Path {\\n    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {\\n        other.1.partial_cmp(&self.1)\\n    }\\n}\\n\\nimpl Ord for Path {\\n    fn cmp(&self, other: &Self) -> std::cmp::Ordering {\\n        self.partial_cmp(other).unwrap()\\n    }\\n}\\n\\n/**\\n * `&self` means the method takes an immutable reference.\\n * If you need a mutable reference, change it to `&mut self` instead.\\n */\\nimpl Graph {\\n    fn new(n: i32, edges: Vec<Vec<i32>>) -> Self {\\n        let mut dict = vec![Vec::new(); n as usize];\\n        for edge in edges {\\n            dict[edge[0] as usize].push((edge[1] as usize, edge[2]));\\n        }\\n\\n        Self { dict }\\n    }\\n\\n    fn add_edge(&mut self, edge: Vec<i32>) {\\n        self.dict[edge[0] as usize].push((edge[1] as usize, edge[2]));\\n    }\\n\\n    fn shortest_path(&self, node1: i32, node2: i32) -> i32 {\\n        let (node1, node2) = (node1 as usize, node2 as usize);\\n\\n        let mut pq = std::collections::BinaryHeap::new();\\n        let mut dist = vec![i32::MAX; self.dict.len()];\\n\\n        dist[node1] = 0;\\n\\n        pq.push(Path(node1 as usize, 0));\\n\\n        while let Some(v) = pq.pop() {\\n            if v.0 != node2 {\\n                for &(node, cost) in self.dict[v.0].iter() {\\n                    if cost + v.1 < dist[node] {\\n                        dist[node] = cost + v.1;\\n                        pq.push(Path(node, dist[node]));\\n                    }\\n                }\\n            } else {\\n                return v.1;\\n            }\\n        }\\n\\n        -1\\n    }\\n}\\n\\n/*\\n * Your Graph object will be instantiated and called as such:\\n * let obj = Graph::new(n, edges);\\n * obj.add_edge(edge);\\n * let ret_2: i32 = obj.shortest_path(node1, node2);\\n */\\n\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust []\\nstruct Graph {\\n    dict: Vec<Vec<(usize, i32)>>,\\n}\\n\\n#[derive(Eq)]\\nstruct Path(usize, i32);\\n\\nimpl PartialEq for Path {\\n    fn eq(&self, other: &Self) -> bool {\\n        self.1 == other.1\\n    }\\n}\\n\\nimpl PartialOrd for Path {\\n    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {\\n        other.1.partial_cmp(&self.1)\\n    }\\n}\\n\\nimpl Ord for Path {\\n    fn cmp(&self, other: &Self) -> std::cmp::Ordering {\\n        self.partial_cmp(other).unwrap()\\n    }\\n}\\n\\n/**\\n * `&self` means the method takes an immutable reference.\\n * If you need a mutable reference, change it to `&mut self` instead.\\n */\\nimpl Graph {\\n    fn new(n: i32, edges: Vec<Vec<i32>>) -> Self {\\n        let mut dict = vec![Vec::new(); n as usize];\\n        for edge in edges {\\n            dict[edge[0] as usize].push((edge[1] as usize, edge[2]));\\n        }\\n\\n        Self { dict }\\n    }\\n\\n    fn add_edge(&mut self, edge: Vec<i32>) {\\n        self.dict[edge[0] as usize].push((edge[1] as usize, edge[2]));\\n    }\\n\\n    fn shortest_path(&self, node1: i32, node2: i32) -> i32 {\\n        let (node1, node2) = (node1 as usize, node2 as usize);\\n\\n        let mut pq = std::collections::BinaryHeap::new();\\n        let mut dist = vec![i32::MAX; self.dict.len()];\\n\\n        dist[node1] = 0;\\n\\n        pq.push(Path(node1 as usize, 0));\\n\\n        while let Some(v) = pq.pop() {\\n            if v.0 != node2 {\\n                for &(node, cost) in self.dict[v.0].iter() {\\n                    if cost + v.1 < dist[node] {\\n                        dist[node] = cost + v.1;\\n                        pq.push(Path(node, dist[node]));\\n                    }\\n                }\\n            } else {\\n                return v.1;\\n            }\\n        }\\n\\n        -1\\n    }\\n}\\n\\n/*\\n * Your Graph object will be instantiated and called as such:\\n * let obj = Graph::new(n, edges);\\n * obj.add_edge(edge);\\n * let ret_2: i32 = obj.shortest_path(node1, node2);\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3420988,
                "title": "python-simple-dijkstra-s-algorithm",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Graph:\\n\\n    def __init__(self, n, edges):\\n        self.dict1 = defaultdict(list)\\n        self.n = n\\n\\n        for i,j,c in edges:\\n            self.dict1[i].append((j,c))\\n\\n    def addEdge(self, edge):\\n        self.dict1[edge[0]].append((edge[1],edge[2]))\\n\\n    def shortestPath(self, node1, node2):\\n        stack, dist = [(0,node1)], [float(\"inf\")]*self.n\\n\\n        dist[node1] = 0\\n\\n        while stack:\\n            c, node = heappop(stack)\\n\\n            for neighbor,cost in self.dict1[node]:\\n                if cost + c < dist[neighbor]:\\n                    dist[neighbor] = cost + c\\n                    heapq.heappush(stack,(cost+c,neighbor))\\n\\n        return dist[node2] if dist[node2] != float(\"inf\") else -1\\n\\n\\n\\n\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Graph:\\n\\n    def __init__(self, n, edges):\\n        self.dict1 = defaultdict(list)\\n        self.n = n\\n\\n        for i,j,c in edges:\\n            self.dict1[i].append((j,c))\\n\\n    def addEdge(self, edge):\\n        self.dict1[edge[0]].append((edge[1],edge[2]))\\n\\n    def shortestPath(self, node1, node2):\\n        stack, dist = [(0,node1)], [float(\"inf\")]*self.n\\n\\n        dist[node1] = 0\\n\\n        while stack:\\n            c, node = heappop(stack)\\n\\n            for neighbor,cost in self.dict1[node]:\\n                if cost + c < dist[neighbor]:\\n                    dist[neighbor] = cost + c\\n                    heapq.heappush(stack,(cost+c,neighbor))\\n\\n        return dist[node2] if dist[node2] != float(\"inf\") else -1\\n\\n\\n\\n\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420972,
                "title": "typescript-floyd-warshall-algorithm",
                "content": "# Complexity\\n- Time complexity:\\nconstructor: O(n^3)\\naddEdge: O(n^2)\\nshortestPath: O(1)\\n\\n- Space complexity:\\nO(n^2)\\n\\n# Code\\n```\\nclass Graph {\\n  N: number;\\n  edges: number[][];\\n\\n  constructor(n: number, edges: number[][]) {\\n    this.N = n;\\n    this.edges = [];\\n    for(let i = 0; i < n; i++) {\\n      this.edges[i] = [];\\n      for(let j = 0; j < n; j++) {\\n        if (i === j) {\\n          this.edges[i][j] = 0;\\n        } else {\\n          this.edges[i][j] = Number.MAX_SAFE_INTEGER;\\n        }\\n      }\\n    }\\n\\n    edges.forEach(([x, y, w]) => {\\n      this.edges[x][y] = Math.min(this.edges[x][y], w);\\n    });\\n\\n    for (let k = 0; k < n; k++) {\\n      for (let i = 0; i < n; i++) {\\n        for (let j = 0; j < n; j++) {\\n          if (i != k && j != k && i != j) {\\n            this.edges[i][j] = Math.min(this.edges[i][j], this.edges[i][k] + this.edges[k][j]);\\n          }\\n        }\\n      }\\n    }\\n  }\\n\\n  addEdge(edge: number[]): void {\\n    for (let i = 0; i < this.N; i++) {\\n      for (let j = 0; j < this.N; j++) {\\n        this.edges[i][j] = Math.min(this.edges[i][j], this.edges[i][edge[0]] + edge[2] + this.edges[edge[1]][j]);\\n      }\\n    }\\n  }\\n\\n  shortestPath(node1: number, node2: number): number {\\n    return this.edges[node1][node2] === Number.MAX_SAFE_INTEGER ? -1 : this.edges[node1][node2];\\n  }\\n}\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nclass Graph {\\n  N: number;\\n  edges: number[][];\\n\\n  constructor(n: number, edges: number[][]) {\\n    this.N = n;\\n    this.edges = [];\\n    for(let i = 0; i < n; i++) {\\n      this.edges[i] = [];\\n      for(let j = 0; j < n; j++) {\\n        if (i === j) {\\n          this.edges[i][j] = 0;\\n        } else {\\n          this.edges[i][j] = Number.MAX_SAFE_INTEGER;\\n        }\\n      }\\n    }\\n\\n    edges.forEach(([x, y, w]) => {\\n      this.edges[x][y] = Math.min(this.edges[x][y], w);\\n    });\\n\\n    for (let k = 0; k < n; k++) {\\n      for (let i = 0; i < n; i++) {\\n        for (let j = 0; j < n; j++) {\\n          if (i != k && j != k && i != j) {\\n            this.edges[i][j] = Math.min(this.edges[i][j], this.edges[i][k] + this.edges[k][j]);\\n          }\\n        }\\n      }\\n    }\\n  }\\n\\n  addEdge(edge: number[]): void {\\n    for (let i = 0; i < this.N; i++) {\\n      for (let j = 0; j < this.N; j++) {\\n        this.edges[i][j] = Math.min(this.edges[i][j], this.edges[i][edge[0]] + edge[2] + this.edges[edge[1]][j]);\\n      }\\n    }\\n  }\\n\\n  shortestPath(node1: number, node2: number): number {\\n    return this.edges[node1][node2] === Number.MAX_SAFE_INTEGER ? -1 : this.edges[node1][node2];\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420967,
                "title": "simplest-and-easiest-solution-beginners-friendly",
                "content": "```\\nclass Graph {\\npublic:\\n    \\n    int nn=0;\\n    vector<vector<pair<int,int>>>g;\\n    \\n    \\n    Graph(int n, vector<vector<int>>& edges) {\\n        nn=n;\\n        for(int i=0;i<n;i++){\\n            vector<pair<int,int>>m;\\n            g.push_back(m);\\n        }\\n        \\n        for(int i=0;i<edges.size();i++){\\n            int src=edges[i][0];\\n            int dst=edges[i][1];\\n            int wt=edges[i][2];\\n            g[src].push_back({dst,wt});\\n        }\\n        \\n        \\n    }\\n    \\n    void addEdge(vector<int> edge) {\\n        int src=edge[0];\\n            int dst=edge[1];\\n            int wt=edge[2];\\n            g[src].push_back({dst,wt});\\n    }\\n    \\n    \\n    \\n    void kamsekam( int sr, vector<int>& ds) {\\n    int n = g.size();\\n\\n\\n    ds[sr] = 0; \\n                priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> pq; \\n    pq.push({0, sr}); \\n\\n                while (!pq.empty()) {\\n        int u = pq.top().second; \\n        pq.pop();\\n\\n       \\n    for (pair<int,int> ngh : g[u]) {\\n            int v = ngh.first; \\n                     int weight = ngh.second; \\n\\n            if (ds[u] + weight < ds[v]) {\\n                ds[v] = ds[u] + weight;\\n                pq.push({ds[v], v});\\n            }\\n        }\\n    }\\n}\\n\\n\\n    \\n    \\n    int shortestPath(int node1, int node2) {\\n         int sr = node1; \\n     \\n   \\n    vector<int> ds(nn, INT_MAX); \\n\\n    kamsekam( sr, ds);\\n    if(ds[node2]==INT_MAX){\\n        return -1;\\n    }\\n    return ds[node2];\\n    }\\n};\\n\\n",
                "solutionTags": [
                    "C",
                    "Graph",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Graph {\\npublic:\\n    \\n    int nn=0;\\n    vector<vector<pair<int,int>>>g;\\n    \\n    \\n    Graph(int n, vector<vector<int>>& edges) {\\n        nn=n;\\n        for(int i=0;i<n;i++){\\n            vector<pair<int,int>>m;\\n            g.push_back(m);\\n        }\\n        \\n        for(int i=0;i<edges.size();i++){\\n            int src=edges[i][0];\\n            int dst=edges[i][1];\\n            int wt=edges[i][2];\\n            g[src].push_back({dst,wt});\\n        }\\n        \\n        \\n    }\\n    \\n    void addEdge(vector<int> edge) {\\n        int src=edge[0];\\n            int dst=edge[1];\\n            int wt=edge[2];\\n            g[src].push_back({dst,wt});\\n    }\\n    \\n    \\n    \\n    void kamsekam( int sr, vector<int>& ds) {\\n    int n = g.size();\\n\\n\\n    ds[sr] = 0; \\n                priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> pq; \\n    pq.push({0, sr}); \\n\\n                while (!pq.empty()) {\\n        int u = pq.top().second; \\n        pq.pop();\\n\\n       \\n    for (pair<int,int> ngh : g[u]) {\\n            int v = ngh.first; \\n                     int weight = ngh.second; \\n\\n            if (ds[u] + weight < ds[v]) {\\n                ds[v] = ds[u] + weight;\\n                pq.push({ds[v], v});\\n            }\\n        }\\n    }\\n}\\n\\n\\n    \\n    \\n    int shortestPath(int node1, int node2) {\\n         int sr = node1; \\n     \\n   \\n    vector<int> ds(nn, INT_MAX); \\n\\n    kamsekam( sr, ds);\\n    if(ds[node2]==INT_MAX){\\n        return -1;\\n    }\\n    return ds[node2];\\n    }\\n};\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 3420935,
                "title": "c-dijkstra-with-al",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nDijkstra to answer each query would suffice, along with an AL for quick evaluation of the neighbors of each node.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe update the AL each time addEdge is called, and do a dijkstra each time shortestPath is called.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(1) for addEdge, O((V+E)logV) for each shortestPath\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1) for addEdge, O(V) for each shortestPath\\n\\n# Code\\n```\\nclass Graph {\\npublic:\\n    int n;\\n    vector<vector<pair<int,int>>> al;\\n    Graph(int _n, vector<vector<int>>& edges) {\\n        n = _n;\\n        al.resize(n);\\n        for(auto&e:edges){\\n            al[e[0]].push_back({e[1],e[2]});\\n        }\\n        \\n    }\\n    \\n    void addEdge(vector<int> edge) {\\n        al[edge[0]].push_back({edge[1],edge[2]});\\n    }\\n    \\n    int shortestPath(int node1, int node2) {\\n        vector<int> d(n,1e9);\\n        d[node1] = 0;\\n        priority_queue<pair<int,int>, vector<pair<int,int>>, greater<>> pq;\\n        pq.push({0,node1});\\n        while(pq.size()){\\n            auto [du,u] = pq.top(); pq.pop();\\n            if(du!=d[u]) continue;\\n            for(auto&[v,w]:al[u]){\\n                if(du+w < d[v]){\\n                    d[v] = du+w;\\n                    pq.push({d[v],v});\\n                }\\n            }\\n        }\\n        if(d[node2]==1e9) return -1;\\n        else return d[node2];\\n        \\n    }\\n};\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph* obj = new Graph(n, edges);\\n * obj->addEdge(edge);\\n * int param_2 = obj->shortestPath(node1,node2);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Graph {\\npublic:\\n    int n;\\n    vector<vector<pair<int,int>>> al;\\n    Graph(int _n, vector<vector<int>>& edges) {\\n        n = _n;\\n        al.resize(n);\\n        for(auto&e:edges){\\n            al[e[0]].push_back({e[1],e[2]});\\n        }\\n        \\n    }\\n    \\n    void addEdge(vector<int> edge) {\\n        al[edge[0]].push_back({edge[1],edge[2]});\\n    }\\n    \\n    int shortestPath(int node1, int node2) {\\n        vector<int> d(n,1e9);\\n        d[node1] = 0;\\n        priority_queue<pair<int,int>, vector<pair<int,int>>, greater<>> pq;\\n        pq.push({0,node1});\\n        while(pq.size()){\\n            auto [du,u] = pq.top(); pq.pop();\\n            if(du!=d[u]) continue;\\n            for(auto&[v,w]:al[u]){\\n                if(du+w < d[v]){\\n                    d[v] = du+w;\\n                    pq.push({d[v],v});\\n                }\\n            }\\n        }\\n        if(d[node2]==1e9) return -1;\\n        else return d[node2];\\n        \\n    }\\n};\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph* obj = new Graph(n, edges);\\n * obj->addEdge(edge);\\n * int param_2 = obj->shortestPath(node1,node2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420931,
                "title": "dijkstra-stack-javascript-solution",
                "content": "# Code\\n```\\n/**\\n * @param {number} n\\n * @param {number[][]} edges\\n */\\nvar Graph = function(n, edges) {\\n    this.n = n;\\n    this.map = new Map();\\n    let nodes;\\n    for (const [from, to, cost] of edges) {\\n        nodes = this.map.get(from);\\n        if (nodes) nodes.push({ to: to, cost: cost });\\n        else this.map.set(from, [{ to: to, cost: cost }]);\\n    }\\n};\\n\\n/** \\n * @param {number[]} edge\\n * @return {void}\\n */\\nGraph.prototype.addEdge = function(edge) {\\n    const [from, to, cost] = edge;\\n    const nodes = this.map.get(from);\\n    if (nodes) nodes.push({ to: to, cost: cost });\\n    else this.map.set(from, [{ to: to, cost: cost }]);\\n};\\n\\n/** \\n * @param {number} node1 \\n * @param {number} node2\\n * @return {number}\\n */\\nGraph.prototype.shortestPath = function(node1, node2) {\\n    const dist = new Array(this.n).fill(Number.MAX_VALUE);\\n    dist[node1] = 0;\\n\\n    const stack = [{ to: node1, cost: 0 }];\\n\\n    while (stack.length) {\\n        const { to, cost } = stack.shift();\\n        const nodes = this.map.get(to);\\n        if (nodes) {\\n            for (let i = 0; i < nodes.length; ++i) {\\n                if (cost + nodes[i].cost < dist[nodes[i].to]) {\\n                    dist[nodes[i].to] = cost + nodes[i].cost;\\n                    stack.push({ to: nodes[i].to, cost: dist[nodes[i].to] });\\n                }\\n            }\\n        }\\n    }\\n\\n    return dist[node2] === Number.MAX_VALUE ? -1 : dist[node2];\\n};\\n\\n/** \\n * Your Graph object will be instantiated and called as such:\\n * var obj = new Graph(n, edges)\\n * obj.addEdge(edge)\\n * var param_2 = obj.shortestPath(node1,node2)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number[][]} edges\\n */\\nvar Graph = function(n, edges) {\\n    this.n = n;\\n    this.map = new Map();\\n    let nodes;\\n    for (const [from, to, cost] of edges) {\\n        nodes = this.map.get(from);\\n        if (nodes) nodes.push({ to: to, cost: cost });\\n        else this.map.set(from, [{ to: to, cost: cost }]);\\n    }\\n};\\n\\n/** \\n * @param {number[]} edge\\n * @return {void}\\n */\\nGraph.prototype.addEdge = function(edge) {\\n    const [from, to, cost] = edge;\\n    const nodes = this.map.get(from);\\n    if (nodes) nodes.push({ to: to, cost: cost });\\n    else this.map.set(from, [{ to: to, cost: cost }]);\\n};\\n\\n/** \\n * @param {number} node1 \\n * @param {number} node2\\n * @return {number}\\n */\\nGraph.prototype.shortestPath = function(node1, node2) {\\n    const dist = new Array(this.n).fill(Number.MAX_VALUE);\\n    dist[node1] = 0;\\n\\n    const stack = [{ to: node1, cost: 0 }];\\n\\n    while (stack.length) {\\n        const { to, cost } = stack.shift();\\n        const nodes = this.map.get(to);\\n        if (nodes) {\\n            for (let i = 0; i < nodes.length; ++i) {\\n                if (cost + nodes[i].cost < dist[nodes[i].to]) {\\n                    dist[nodes[i].to] = cost + nodes[i].cost;\\n                    stack.push({ to: nodes[i].to, cost: dist[nodes[i].to] });\\n                }\\n            }\\n        }\\n    }\\n\\n    return dist[node2] === Number.MAX_VALUE ? -1 : dist[node2];\\n};\\n\\n/** \\n * Your Graph object will be instantiated and called as such:\\n * var obj = new Graph(n, edges)\\n * obj.addEdge(edge)\\n * var param_2 = obj.shortestPath(node1,node2)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3420874,
                "title": "c-using-djikstra-algorithm",
                "content": "```\\nclass Graph {\\npublic:\\n    vector< vector<pair<int,int> > > adj;\\n    int x=0;\\n    Graph(int n, vector<vector<int>>& edges) {\\n        adj.resize(n);\\n        x=n;\\n        for(int i=0;i<edges.size();i++){\\n            adj[edges[i][0]].push_back({edges[i][1],edges[i][2]});\\n        }\\n    }\\n    \\n    void addEdge(vector<int> edge) {\\n         adj[edge[0]].push_back({edge[1],edge[2]});\\n    }\\n    \\n    int shortestPath(int node1, int node2) {\\n        \\n        priority_queue<pair<int,int>,vector<pair<int,int> >,greater<pair<int,int>>> pq;\\n\\tvector<int> distTo(x+1,INT_MAX);//1-indexed array for calculating shortest paths\\n\\tdistTo[node1] = 0;\\n\\tpq.push(make_pair(0,node1));\\t// (dist,source)\\n\\twhile( !pq.empty() ){\\n\\t\\tint dist = pq.top().first;\\n\\t\\tint prev = pq.top().second;\\n\\t\\tpq.pop();\\n\\t\\tvector<pair<int,int> >::iterator it;\\n\\t\\tfor( it = adj[prev].begin() ; it != adj[prev].end() ; it++){\\n\\t\\t\\tint next = it->first;\\n\\t\\t\\tint nextDist = it->second;\\n\\t\\t\\tif( distTo[next] > distTo[prev] + nextDist){\\n\\t\\t\\t\\tdistTo[next] = distTo[prev] + nextDist;\\n\\t\\t\\t\\tpq.push(make_pair(distTo[next], next));\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n        if(distTo[node2]==INT_MAX)return -1;\\n        return distTo[node2];\\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Graph"
                ],
                "code": "```\\nclass Graph {\\npublic:\\n    vector< vector<pair<int,int> > > adj;\\n    int x=0;\\n    Graph(int n, vector<vector<int>>& edges) {\\n        adj.resize(n);\\n        x=n;\\n        for(int i=0;i<edges.size();i++){\\n            adj[edges[i][0]].push_back({edges[i][1],edges[i][2]});\\n        }\\n    }\\n    \\n    void addEdge(vector<int> edge) {\\n         adj[edge[0]].push_back({edge[1],edge[2]});\\n    }\\n    \\n    int shortestPath(int node1, int node2) {\\n        \\n        priority_queue<pair<int,int>,vector<pair<int,int> >,greater<pair<int,int>>> pq;\\n\\tvector<int> distTo(x+1,INT_MAX);//1-indexed array for calculating shortest paths\\n\\tdistTo[node1] = 0;\\n\\tpq.push(make_pair(0,node1));\\t// (dist,source)\\n\\twhile( !pq.empty() ){\\n\\t\\tint dist = pq.top().first;\\n\\t\\tint prev = pq.top().second;\\n\\t\\tpq.pop();\\n\\t\\tvector<pair<int,int> >::iterator it;\\n\\t\\tfor( it = adj[prev].begin() ; it != adj[prev].end() ; it++){\\n\\t\\t\\tint next = it->first;\\n\\t\\t\\tint nextDist = it->second;\\n\\t\\t\\tif( distTo[next] > distTo[prev] + nextDist){\\n\\t\\t\\t\\tdistTo[next] = distTo[prev] + nextDist;\\n\\t\\t\\t\\tpq.push(make_pair(distTo[next], next));\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n        if(distTo[node2]==INT_MAX)return -1;\\n        return distTo[node2];\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420843,
                "title": "simple-python-3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Graph:\\n\\n    def __init__(self, n: int, edges: List[List[int]]):\\n        self.E = defaultdict(list)\\n        for u, v, w in edges:\\n            self.E[u].append((v, w))\\n        self.n = n\\n        \\n    def addEdge(self, edge: List[int]) -> None:\\n        u, v, w = edge\\n        self.E[u].append((v, w))\\n        \\n    def shortestPath(self, node1: int, node2: int) -> int:\\n        q = [(0, node1)]\\n        heapq.heapify(q)\\n        visited = set()\\n        \\n        while q:\\n            cost, cur = heapq.heappop(q)\\n            if cur in visited:\\n                continue\\n            visited.add(cur)\\n            \\n            if cur == node2:\\n                return cost\\n            \\n            for v, w in self.E[cur]:\\n                heapq.heappush(q, (cost + w, v))\\n      \\n        return -1\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Graph:\\n\\n    def __init__(self, n: int, edges: List[List[int]]):\\n        self.E = defaultdict(list)\\n        for u, v, w in edges:\\n            self.E[u].append((v, w))\\n        self.n = n\\n        \\n    def addEdge(self, edge: List[int]) -> None:\\n        u, v, w = edge\\n        self.E[u].append((v, w))\\n        \\n    def shortestPath(self, node1: int, node2: int) -> int:\\n        q = [(0, node1)]\\n        heapq.heapify(q)\\n        visited = set()\\n        \\n        while q:\\n            cost, cur = heapq.heappop(q)\\n            if cur in visited:\\n                continue\\n            visited.add(cur)\\n            \\n            if cur == node2:\\n                return cost\\n            \\n            for v, w in self.E[cur]:\\n                heapq.heappush(q, (cost + w, v))\\n      \\n        return -1\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420840,
                "title": "python-solution-using-heap",
                "content": "\\n\\n# Code\\n```\\nclass Graph:\\n\\n    def __init__(self, n: int, edges: List[List[int]]):\\n        self.adj_list = [[] for _ in range(n)]\\n        for u, v, w in edges:\\n            self.adj_list[u].append((v, w))\\n        \\n\\n    def addEdge(self, edge: List[int]) -> None:\\n        u, v, w = edge\\n        self.adj_list[u].append((v, w))\\n        \\n\\n    def shortestPath(self, node1: int, node2: int) -> int:\\n        \\n        n = len(self.adj_list)\\n        dist = [float(\\'inf\\')] * n\\n        dist[node1] = 0\\n        heap = [(0, node1)]\\n        \\n        while heap:\\n            d, u = heapq.heappop(heap)\\n            if u == node2:\\n                return d\\n            if dist[u] < d:\\n                continue\\n            for v, w in self.adj_list[u]:\\n                if dist[u] + w < dist[v]:\\n                    dist[v] = dist[u] + w\\n                    heapq.heappush(heap, (dist[v], v))\\n        \\n        return -1\\n# Your Graph object will be instantiated and called as such:\\n# obj = Graph(n, edges)\\n# obj.addEdge(edge)\\n# param_2 = obj.shortestPath(node1,node2)\\n```",
                "solutionTags": [
                    "Python3",
                    "Shortest Path"
                ],
                "code": "```\\nclass Graph:\\n\\n    def __init__(self, n: int, edges: List[List[int]]):\\n        self.adj_list = [[] for _ in range(n)]\\n        for u, v, w in edges:\\n            self.adj_list[u].append((v, w))\\n        \\n\\n    def addEdge(self, edge: List[int]) -> None:\\n        u, v, w = edge\\n        self.adj_list[u].append((v, w))\\n        \\n\\n    def shortestPath(self, node1: int, node2: int) -> int:\\n        \\n        n = len(self.adj_list)\\n        dist = [float(\\'inf\\')] * n\\n        dist[node1] = 0\\n        heap = [(0, node1)]\\n        \\n        while heap:\\n            d, u = heapq.heappop(heap)\\n            if u == node2:\\n                return d\\n            if dist[u] < d:\\n                continue\\n            for v, w in self.adj_list[u]:\\n                if dist[u] + w < dist[v]:\\n                    dist[v] = dist[u] + w\\n                    heapq.heappush(heap, (dist[v], v))\\n        \\n        return -1\\n# Your Graph object will be instantiated and called as such:\\n# obj = Graph(n, edges)\\n# obj.addEdge(edge)\\n# param_2 = obj.shortestPath(node1,node2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420813,
                "title": "not-a-hard-problem-simply-implementation-of-djkstra-algorithm",
                "content": "#  class Pair\\n   {\\n    int node,wt;\\n    Pair(int node,int wt)\\n    {\\n        this.node=node;\\n        this.wt=wt;\\n    }\\n    }\\n#     class Graph {\\n    List<List<Pair>> adj=new ArrayList<>();\\n    int dup=0;\\n    public Graph(int n, int[][] edges) {\\n        dup=n;\\n        for(int i=0;i<n;i++)\\n        {\\n            adj.add(new ArrayList<>());\\n        }\\n        for(int[] arr:edges)\\n        {\\n            adj.get(arr[0]).add(new Pair(arr[1],arr[2]));\\n        }\\n    }\\n    \\n    public void addEdge(int[] edge) {\\n        adj.get(edge[0]).add(new Pair(edge[1],edge[2]));\\n    }\\n    \\n    public int shortestPath(int node1, int node2) {\\n        int[] dis=new int[dup];\\n        Arrays.fill(dis,Integer.MAX_VALUE);\\n        Queue<int[]> q=new PriorityQueue<>((a,b)->a[1]-b[1]);\\n        q.add(new int[]{node1,0});\\n        dis[node1]=0;\\n        while(!q.isEmpty())\\n        {\\n            int[] curr=q.poll();\\n            for(Pair p:adj.get(curr[0]))\\n            {\\n                if(dis[p.node]>(curr[1]+p.wt))\\n                {\\n                    dis[p.node]=curr[1]+p.wt;\\n                    q.add(new int[]{p.node,dis[p.node]});\\n                }\\n            }\\n        }\\n          return dis[node2]==Integer.MAX_VALUE?-1:dis[node2];  \\n    }\\n}\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph obj = new Graph(n, edges);\\n * obj.addEdge(edge);\\n * int param_2 = obj.shortestPath(node1,node2);\\n */",
                "solutionTags": [
                    "Java",
                    "Graph"
                ],
                "code": "#  class Pair\\n   {\\n    int node,wt;\\n    Pair(int node,int wt)\\n    {\\n        this.node=node;\\n        this.wt=wt;\\n    }\\n    }\\n#     class Graph {\\n    List<List<Pair>> adj=new ArrayList<>();\\n    int dup=0;\\n    public Graph(int n, int[][] edges) {\\n        dup=n;\\n        for(int i=0;i<n;i++)\\n        {\\n            adj.add(new ArrayList<>());\\n        }\\n        for(int[] arr:edges)\\n        {\\n            adj.get(arr[0]).add(new Pair(arr[1],arr[2]));\\n        }\\n    }\\n    \\n    public void addEdge(int[] edge) {\\n        adj.get(edge[0]).add(new Pair(edge[1],edge[2]));\\n    }\\n    \\n    public int shortestPath(int node1, int node2) {\\n        int[] dis=new int[dup];\\n        Arrays.fill(dis,Integer.MAX_VALUE);\\n        Queue<int[]> q=new PriorityQueue<>((a,b)->a[1]-b[1]);\\n        q.add(new int[]{node1,0});\\n        dis[node1]=0;\\n        while(!q.isEmpty())\\n        {\\n            int[] curr=q.poll();\\n            for(Pair p:adj.get(curr[0]))\\n            {\\n                if(dis[p.node]>(curr[1]+p.wt))\\n                {\\n                    dis[p.node]=curr[1]+p.wt;\\n                    q.add(new int[]{p.node,dis[p.node]});\\n                }\\n            }\\n        }\\n          return dis[node2]==Integer.MAX_VALUE?-1:dis[node2];  \\n    }\\n}\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph obj = new Graph(n, edges);\\n * obj.addEdge(edge);\\n * int param_2 = obj.shortestPath(node1,node2);\\n */",
                "codeTag": "Java"
            },
            {
                "id": 3420762,
                "title": "best-easy-c-solution-imp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe need to find the shortest path between two nodes in a graph. To do that, we can use an algorithm called Dijkstra\\'s algorithm.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nWe will create an adjacency list to represent the graph.\\nWe will initialize the distance of all nodes to infinity, except the starting node which is 0.\\n\\nWe will use a priority queue to store the nodes that we need to process next. We will insert the starting node with distance 0 into the priority queue.\\n\\nWe will then process the nodes in the priority queue until we reach the destination node or the priority queue is empty.\\n\\nFor each node we process, we will look at its neighbors and update their distances if the path through the current node is shorter than their current distances.\\n\\nAfter processing all the neighbors of a node, we will insert them into the priority queue.\\n\\nWe will repeat steps 4-6 until we reach the destination node or the priority queue is empty.\\n\\nFinally, we will return the shortest distance to the destination node\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime complexity: O(ElogV) where E is the number of edges and V is the number of vertices in the graph. This is because we process each edge once and insert each node into the priority queue once. The time complexity can be reduced to O(E+VlogV) using a Fibonacci heap.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace complexity: O(V) for the distance array and O(V) for the priority queue. Therefore, the space complexity is O(V).\\n# Code\\n```\\n#include <vector>\\n#include <queue>\\n#include <limits>\\n\\nusing namespace std;\\n\\nclass Graph {\\nprivate:\\n    vector<vector<pair<int, int>>> adj_list;\\n    vector<int> dist;\\n    vector<bool> visited;\\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\\n\\npublic:\\n    Graph(int n, vector<vector<int>>& edges) {\\n        adj_list.resize(n);\\n        dist.resize(n, numeric_limits<int>::max());\\n        visited.resize(n, false);\\n\\n        for (auto& edge : edges) {\\n            int from = edge[0];\\n            int to = edge[1];\\n            int cost = edge[2];\\n            adj_list[from].push_back(make_pair(to, cost));\\n        }\\n    }\\n\\n    void addEdge(vector<int> edge) {\\n        int from = edge[0];\\n        int to = edge[1];\\n        int cost = edge[2];\\n        adj_list[from].push_back(make_pair(to, cost));\\n    }\\n\\n    int shortestPath(int node1, int node2) {\\n        while (!pq.empty()) {\\n            pq.pop();\\n        }\\n        dist.assign(dist.size(), numeric_limits<int>::max());\\n        visited.assign(visited.size(), false);\\n\\n        dist[node1] = 0;\\n        pq.push(make_pair(0, node1));\\n\\n        while (!pq.empty()) {\\n            int node = pq.top().second;\\n            pq.pop();\\n\\n            if (visited[node]) {\\n                continue;\\n            }\\n\\n            visited[node] = true;\\n\\n            for (auto& neighbor : adj_list[node]) {\\n                int neighbor_node = neighbor.first;\\n                int neighbor_cost = neighbor.second;\\n\\n                if (visited[neighbor_node]) {\\n                    continue;\\n                }\\n\\n                int tentative_dist = dist[node] + neighbor_cost;\\n\\n                if (tentative_dist < dist[neighbor_node]) {\\n                    dist[neighbor_node] = tentative_dist;\\n                    pq.push(make_pair(tentative_dist, neighbor_node));\\n                }\\n            }\\n        }\\n\\n        return (dist[node2] == numeric_limits<int>::max()) ? -1 : dist[node2];\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include <vector>\\n#include <queue>\\n#include <limits>\\n\\nusing namespace std;\\n\\nclass Graph {\\nprivate:\\n    vector<vector<pair<int, int>>> adj_list;\\n    vector<int> dist;\\n    vector<bool> visited;\\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\\n\\npublic:\\n    Graph(int n, vector<vector<int>>& edges) {\\n        adj_list.resize(n);\\n        dist.resize(n, numeric_limits<int>::max());\\n        visited.resize(n, false);\\n\\n        for (auto& edge : edges) {\\n            int from = edge[0];\\n            int to = edge[1];\\n            int cost = edge[2];\\n            adj_list[from].push_back(make_pair(to, cost));\\n        }\\n    }\\n\\n    void addEdge(vector<int> edge) {\\n        int from = edge[0];\\n        int to = edge[1];\\n        int cost = edge[2];\\n        adj_list[from].push_back(make_pair(to, cost));\\n    }\\n\\n    int shortestPath(int node1, int node2) {\\n        while (!pq.empty()) {\\n            pq.pop();\\n        }\\n        dist.assign(dist.size(), numeric_limits<int>::max());\\n        visited.assign(visited.size(), false);\\n\\n        dist[node1] = 0;\\n        pq.push(make_pair(0, node1));\\n\\n        while (!pq.empty()) {\\n            int node = pq.top().second;\\n            pq.pop();\\n\\n            if (visited[node]) {\\n                continue;\\n            }\\n\\n            visited[node] = true;\\n\\n            for (auto& neighbor : adj_list[node]) {\\n                int neighbor_node = neighbor.first;\\n                int neighbor_cost = neighbor.second;\\n\\n                if (visited[neighbor_node]) {\\n                    continue;\\n                }\\n\\n                int tentative_dist = dist[node] + neighbor_cost;\\n\\n                if (tentative_dist < dist[neighbor_node]) {\\n                    dist[neighbor_node] = tentative_dist;\\n                    pq.push(make_pair(tentative_dist, neighbor_node));\\n                }\\n            }\\n        }\\n\\n        return (dist[node2] == numeric_limits<int>::max()) ? -1 : dist[node2];\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3420744,
                "title": "typescript-bellman-ford-algorithm",
                "content": "```ts\\nclass Graph {\\n    N: number;\\n    edges: number[][];\\n    constructor(n: number, edges: number[][]) {\\n        this.N = n;\\n        this.edges = edges;\\n    }\\n\\n    addEdge(edge: number[]): void {\\n        this.edges.push(edge);\\n    }\\n\\n    shortestPath(node1: number, node2: number): number {\\n        const N = this.N;\\n        // node: 0 to N-1\\n        const dist: number[] = new Array(N).fill(Infinity);\\n        dist[node1] = 0;\\n        for (let i = 0; i < N; i++) {\\n            for (const [a, b, w] of this.edges) {\\n                dist[b] = Math.min(dist[a] + w, dist[b]);\\n            }\\n        }\\n        if (dist[node2] === Infinity) {\\n            return -1;\\n        }\\n        return dist[node2];\\n    }\\n}\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```ts\\nclass Graph {\\n    N: number;\\n    edges: number[][];\\n    constructor(n: number, edges: number[][]) {\\n        this.N = n;\\n        this.edges = edges;\\n    }\\n\\n    addEdge(edge: number[]): void {\\n        this.edges.push(edge);\\n    }\\n\\n    shortestPath(node1: number, node2: number): number {\\n        const N = this.N;\\n        // node: 0 to N-1\\n        const dist: number[] = new Array(N).fill(Infinity);\\n        dist[node1] = 0;\\n        for (let i = 0; i < N; i++) {\\n            for (const [a, b, w] of this.edges) {\\n                dist[b] = Math.min(dist[a] + w, dist[b]);\\n            }\\n        }\\n        if (dist[node2] === Infinity) {\\n            return -1;\\n        }\\n        return dist[node2];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420739,
                "title": "java-dijkstra-algorithm",
                "content": "\\n# Code\\n```\\nclass Graph {\\n\\n    List<List<int[]>> graph;\\n\\n    public Graph(int n, int[][] edges) {\\n        graph = getEdges( n , edges );\\n    }\\n    \\n    public void addEdge(int[] edge) {\\n        int u = edge[0];\\n        int v = edge[1];\\n        int w = edge[2];\\n        graph.get(u).add(new int[] {v , w});\\n    }\\n    \\n    public int shortestPath(int node1, int node2) {\\n        // min heap\\n        PriorityQueue<int[]> q = new PriorityQueue<>(new Comparator<int[]>() {\\n            @Override\\n            public int compare(int[] ints, int[] t1) {\\n                return ints[1] - t1[1];\\n            }\\n        });\\n        int[] dist = new int[graph.size()];\\n        Arrays.fill(dist , Integer.MAX_VALUE);\\n        dist[node1] = 0;\\n        q.add(new int[] {node1 , 0});\\n\\n        while(!q.isEmpty()){\\n            int[] cords = q.poll();\\n\\n            int node = cords[0];\\n            int distCoverd = cords[1];\\n\\n            if(node == node2){\\n                return distCoverd;\\n            }\\n            \\n            for(int[] nei : graph.get(node)){\\n\\n                int nextNode = nei[0];\\n                int cost = nei[1];\\n\\n                int nextDist = distCoverd + cost;\\n\\n                if(nextDist < dist[nextNode]){\\n\\n                    dist[nextNode] = nextDist;\\n\\n                    q.add(new int[] {nextNode , dist[nextNode] });\\n\\n                }\\n\\n            }\\n        }\\n        return -1;\\n    }\\n\\n    private List<List<int[]>> getEdges(int n, int[][] edges){\\n        List<List<int[]>> list = new ArrayList<>();\\n        for(int i=0; i<n; i++){\\n            list.add(new ArrayList<>());\\n        }\\n        for(int[]  i : edges){\\n            int u = i[0];\\n            int v = i[1];\\n            int w = i[2];\\n            list.get(u).add(new int[]{v , w});\\n        }\\n        return list;\\n    }\\n}\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph obj = new Graph(n, edges);\\n * obj.addEdge(edge);\\n * int param_2 = obj.shortestPath(node1,node2);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Graph"
                ],
                "code": "```\\nclass Graph {\\n\\n    List<List<int[]>> graph;\\n\\n    public Graph(int n, int[][] edges) {\\n        graph = getEdges( n , edges );\\n    }\\n    \\n    public void addEdge(int[] edge) {\\n        int u = edge[0];\\n        int v = edge[1];\\n        int w = edge[2];\\n        graph.get(u).add(new int[] {v , w});\\n    }\\n    \\n    public int shortestPath(int node1, int node2) {\\n        // min heap\\n        PriorityQueue<int[]> q = new PriorityQueue<>(new Comparator<int[]>() {\\n            @Override\\n            public int compare(int[] ints, int[] t1) {\\n                return ints[1] - t1[1];\\n            }\\n        });\\n        int[] dist = new int[graph.size()];\\n        Arrays.fill(dist , Integer.MAX_VALUE);\\n        dist[node1] = 0;\\n        q.add(new int[] {node1 , 0});\\n\\n        while(!q.isEmpty()){\\n            int[] cords = q.poll();\\n\\n            int node = cords[0];\\n            int distCoverd = cords[1];\\n\\n            if(node == node2){\\n                return distCoverd;\\n            }\\n            \\n            for(int[] nei : graph.get(node)){\\n\\n                int nextNode = nei[0];\\n                int cost = nei[1];\\n\\n                int nextDist = distCoverd + cost;\\n\\n                if(nextDist < dist[nextNode]){\\n\\n                    dist[nextNode] = nextDist;\\n\\n                    q.add(new int[] {nextNode , dist[nextNode] });\\n\\n                }\\n\\n            }\\n        }\\n        return -1;\\n    }\\n\\n    private List<List<int[]>> getEdges(int n, int[][] edges){\\n        List<List<int[]>> list = new ArrayList<>();\\n        for(int i=0; i<n; i++){\\n            list.add(new ArrayList<>());\\n        }\\n        for(int[]  i : edges){\\n            int u = i[0];\\n            int v = i[1];\\n            int w = i[2];\\n            list.get(u).add(new int[]{v , w});\\n        }\\n        return list;\\n    }\\n}\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph obj = new Graph(n, edges);\\n * obj.addEdge(edge);\\n * int param_2 = obj.shortestPath(node1,node2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420728,
                "title": "simple-dijkstra",
                "content": "\\n\\n# Code\\n```\\nclass Graph {\\npublic:\\n    \\n    \\n    Graph(int n, vector<vector<int>>& edges) {\\n        \\n        adj.resize(n);\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            adj[edges[i][0]].push_back({edges[i][1],edges[i][2]});\\n        }\\n            \\n    }\\n    \\n    void addEdge(vector<int> edge) {\\n          \\n         adj[edge[0]].push_back({edge[1],edge[2]});\\n    }\\n    \\n    int shortestPath(int node1, int node2) {\\n         \\n        \\n       \\n      vector<int> dis= dijkstra(node1);\\n        if(dis[node2]==INT_MAX) return -1;\\n        return dis[node2];        \\n    }\\n    \\n    private :\\n      vector<vector<pair<int,int>>> adj;\\n    \\n    \\n      vector<int> dijkstra(int S) {\\n        int V = adj.size();\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\\n\\n        vector<int> distTo(V, INT_MAX);\\n\\n        distTo[S] = 0;\\n        pq.push({0, S});\\n\\n        while (!pq.empty()) {\\n            int node = pq.top().second;\\n            int dis = pq.top().first;\\n            pq.pop();\\n\\n            // if (dis > distTo[node]) {\\n            //     continue;\\n            // }\\n\\n            for (auto it : adj[node]) {\\n                int v = it.first;\\n                int w = it.second;\\n                if (dis + w < distTo[v]) {\\n                    distTo[v] = dis + w;\\n                    pq.push({distTo[v], v});\\n                }\\n            }\\n        }\\n        return distTo;\\n    }\\n};\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph* obj = new Graph(n, edges);\\n * obj->addEdge(edge);\\n * int param_2 = obj->shortestPath(node1,node2);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Graph {\\npublic:\\n    \\n    \\n    Graph(int n, vector<vector<int>>& edges) {\\n        \\n        adj.resize(n);\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            adj[edges[i][0]].push_back({edges[i][1],edges[i][2]});\\n        }\\n            \\n    }\\n    \\n    void addEdge(vector<int> edge) {\\n          \\n         adj[edge[0]].push_back({edge[1],edge[2]});\\n    }\\n    \\n    int shortestPath(int node1, int node2) {\\n         \\n        \\n       \\n      vector<int> dis= dijkstra(node1);\\n        if(dis[node2]==INT_MAX) return -1;\\n        return dis[node2];        \\n    }\\n    \\n    private :\\n      vector<vector<pair<int,int>>> adj;\\n    \\n    \\n      vector<int> dijkstra(int S) {\\n        int V = adj.size();\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\\n\\n        vector<int> distTo(V, INT_MAX);\\n\\n        distTo[S] = 0;\\n        pq.push({0, S});\\n\\n        while (!pq.empty()) {\\n            int node = pq.top().second;\\n            int dis = pq.top().first;\\n            pq.pop();\\n\\n            // if (dis > distTo[node]) {\\n            //     continue;\\n            // }\\n\\n            for (auto it : adj[node]) {\\n                int v = it.first;\\n                int w = it.second;\\n                if (dis + w < distTo[v]) {\\n                    distTo[v] = dis + w;\\n                    pq.push({distTo[v], v});\\n                }\\n            }\\n        }\\n        return distTo;\\n    }\\n};\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph* obj = new Graph(n, edges);\\n * obj->addEdge(edge);\\n * int param_2 = obj->shortestPath(node1,node2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420723,
                "title": "c-dijkstra-s",
                "content": "# Code\\n```\\nclass Graph {\\n    vector<pair<int, int>> adjList[105];\\n    int n;\\npublic:\\n    Graph(int n, vector<vector<int>>& edges) {\\n        this -> n = n;\\n        for(vector<int> edge: edges) {\\n            adjList[edge[0]].push_back({edge[1], edge[2]});\\n        }\\n    }\\n    \\n    void addEdge(vector<int> edge) {\\n        adjList[edge[0]].push_back({edge[1], edge[2]});\\n    }\\n    \\n    int shortestPath(int node1, int node2) {\\n        vector<int> dist(n, INT_MAX);\\n        dist[node1] = 0;\\n        set<pair<int, int>> Set;\\n        Set.insert({0, node1});\\n        while(!Set.empty()) {\\n            pair<int, int> temp = *(Set.begin());\\n            int u = temp.second;\\n            Set.erase(*Set.begin());\\n            for(auto iter: adjList[u]) {\\n                int v = iter.first;\\n                int w = iter.second;\\n                if(dist[u] + w < dist[v]) {\\n                    Set.erase({dist[v], v});\\n                    dist[v] = dist[u] + w;\\n                    Set.insert({dist[v], v});\\n                }\\n            }\\n        }\\n        return dist[node2] == INT_MAX? -1: dist[node2];\\n    }\\n};\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph* obj = new Graph(n, edges);\\n * obj->addEdge(edge);\\n * int param_2 = obj->shortestPath(node1,node2);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Shortest Path"
                ],
                "code": "```\\nclass Graph {\\n    vector<pair<int, int>> adjList[105];\\n    int n;\\npublic:\\n    Graph(int n, vector<vector<int>>& edges) {\\n        this -> n = n;\\n        for(vector<int> edge: edges) {\\n            adjList[edge[0]].push_back({edge[1], edge[2]});\\n        }\\n    }\\n    \\n    void addEdge(vector<int> edge) {\\n        adjList[edge[0]].push_back({edge[1], edge[2]});\\n    }\\n    \\n    int shortestPath(int node1, int node2) {\\n        vector<int> dist(n, INT_MAX);\\n        dist[node1] = 0;\\n        set<pair<int, int>> Set;\\n        Set.insert({0, node1});\\n        while(!Set.empty()) {\\n            pair<int, int> temp = *(Set.begin());\\n            int u = temp.second;\\n            Set.erase(*Set.begin());\\n            for(auto iter: adjList[u]) {\\n                int v = iter.first;\\n                int w = iter.second;\\n                if(dist[u] + w < dist[v]) {\\n                    Set.erase({dist[v], v});\\n                    dist[v] = dist[u] + w;\\n                    Set.insert({dist[v], v});\\n                }\\n            }\\n        }\\n        return dist[node2] == INT_MAX? -1: dist[node2];\\n    }\\n};\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph* obj = new Graph(n, edges);\\n * obj->addEdge(edge);\\n * int param_2 = obj->shortestPath(node1,node2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420667,
                "title": "c-code-using-dijkstra-s-algorithm-explained-approach",
                "content": "# Intuition\\nUsing Dijkstra\\'s Algorithm to find the minimum cost between node1 to node2.\\n\\n# Approach\\n1. Initialize all distances to infinity and the distance of the source node to 0.\\n\\n2. Create a priority queue and add the source node to it with a priority of 0.\\n\\n3. While the priority queue is not empty, remove the node with the smallest priority and mark it as visited.\\n\\n4. For each neighbor of the current node, calculate the tentative distance from the source node to that neighbor by adding the distance from the current node to the neighbor to the distance of the current node from the source node.\\n\\n5. If the tentative distance is less than the current distance of the neighbor, update the distance of the neighbor to the tentative distance and add the neighbor to the priority queue with a priority equal to the new distance.\\n\\n6. Repeat steps 3-5 until all nodes have been visited.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of the above implementation of Dijkstra\\'s algorithm using a priority queue is O((E + V) log V), where E is the number of edges and V is the number of vertices in the graph. This is because the algorithm processes each vertex once and each edge once, and the priority queue operations take O(log V) time.\\n\\n- Space complexity:\\nThe space complexity of this implementation is O(V), where V is the number of vertices in the graph. This is because the algorithm requires a distance vector of size V to store the distances of all vertices from the source node, and a priority queue that can contain at most V vertices. Additionally, the adjacency list for the graph may require additional space proportional to the number of edges.\\n\\nNote that the space complexity of the priority queue itself is not considered in this calculation, as it is assumed to be proportional to the number of vertices in the graph, which is already accounted for in the space complexity calculation.\\n\\n# Code\\n```\\nclass Graph {\\nprivate:\\n    vector<vector<pair<int, int>>> adjList;\\n    int numNodes;\\npublic:\\n    Graph(int n, vector<vector<int>>& edges) {\\n        numNodes = n;\\n        adjList.resize(numNodes);\\n\\n        for (auto& edge : edges) {\\n            int from = edge[0];\\n            int to = edge[1];\\n            int cost = edge[2];\\n            adjList[from].push_back({to, cost});\\n        }\\n    }\\n    \\n    void addEdge(vector<int> edge) {\\n        int from = edge[0];\\n        int to = edge[1];\\n        int cost = edge[2];\\n        adjList[from].push_back({to, cost});\\n    }\\n    \\n    int shortestPath(int node1, int node2) {\\n        vector<int> dist(numNodes, numeric_limits<int>::max());\\n        dist[node1] = 0;\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\\n        pq.push({0, node1});\\n\\n        while (!pq.empty()) {\\n            int u = pq.top().second;\\n            pq.pop();\\n\\n            for (auto& neighbor : adjList[u]) {\\n                int v = neighbor.first;\\n                int w = neighbor.second;\\n\\n                if (dist[u] != numeric_limits<int>::max() && dist[v] > dist[u] + w) {\\n                    dist[v] = dist[u] + w;\\n                    pq.push({dist[v], v});\\n                }\\n            }\\n        }\\n\\n        return (dist[node2] == numeric_limits<int>::max()) ? -1 : dist[node2];\\n\\xA0\\xA0\\xA0\\xA0}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Graph",
                    "Design",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Graph {\\nprivate:\\n    vector<vector<pair<int, int>>> adjList;\\n    int numNodes;\\npublic:\\n    Graph(int n, vector<vector<int>>& edges) {\\n        numNodes = n;\\n        adjList.resize(numNodes);\\n\\n        for (auto& edge : edges) {\\n            int from = edge[0];\\n            int to = edge[1];\\n            int cost = edge[2];\\n            adjList[from].push_back({to, cost});\\n        }\\n    }\\n    \\n    void addEdge(vector<int> edge) {\\n        int from = edge[0];\\n        int to = edge[1];\\n        int cost = edge[2];\\n        adjList[from].push_back({to, cost});\\n    }\\n    \\n    int shortestPath(int node1, int node2) {\\n        vector<int> dist(numNodes, numeric_limits<int>::max());\\n        dist[node1] = 0;\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\\n        pq.push({0, node1});\\n\\n        while (!pq.empty()) {\\n            int u = pq.top().second;\\n            pq.pop();\\n\\n            for (auto& neighbor : adjList[u]) {\\n                int v = neighbor.first;\\n                int w = neighbor.second;\\n\\n                if (dist[u] != numeric_limits<int>::max() && dist[v] > dist[u] + w) {\\n                    dist[v] = dist[u] + w;\\n                    pq.push({dist[v], v});\\n                }\\n            }\\n        }\\n\\n        return (dist[node2] == numeric_limits<int>::max()) ? -1 : dist[node2];\\n\\xA0\\xA0\\xA0\\xA0}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420643,
                "title": "python-edsgerish-solution",
                "content": "# Intuition\\nDo Dijkstra per every query, constraints are low enough to be lazy\\n\\n# Complexity\\n- Time complexity:\\n$$O(QN)$$ - Q number of queries, N number of vertices\\n\\n- Space complexity:\\n$$O(N)$$\\n\\n# Code\\n```\\nfrom collections import defaultdict\\nfrom math import inf\\nfrom heapq import heappop, heappush\\n\\nclass Graph:\\n    def __init__(self, n: int, edges: List[List[int]]):\\n        self.g = defaultdict(set)\\n        for u, v, w in edges: self.g[u].add((v, w))\\n        self.n = n\\n\\n    def addEdge(self, edge: List[int]) -> None:\\n        u, v, w = edge\\n        self.g[u].add((v, w))\\n        \\n    def shortestPath(self, node1: int, node2: int) -> int:\\n        q = [(0, node1)]\\n        dist = [inf] * self.n\\n        dist[node1] = 0\\n        while q:\\n            d, u = heappop(q)\\n            if u == node2:\\n                return d\\n            for v, w in self.g[u]:\\n                if d + w < dist[v]:\\n                    dist[v] = d + w\\n                    heappush(q, (d + w, v))\\n        return -1  \\n\\n\\n# Your Graph object will be instantiated and called as such:\\n# obj = Graph(n, edges)\\n# obj.addEdge(edge)\\n# param_2 = obj.shortestPath(node1,node2)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Graph",
                    "Shortest Path"
                ],
                "code": "```\\nfrom collections import defaultdict\\nfrom math import inf\\nfrom heapq import heappop, heappush\\n\\nclass Graph:\\n    def __init__(self, n: int, edges: List[List[int]]):\\n        self.g = defaultdict(set)\\n        for u, v, w in edges: self.g[u].add((v, w))\\n        self.n = n\\n\\n    def addEdge(self, edge: List[int]) -> None:\\n        u, v, w = edge\\n        self.g[u].add((v, w))\\n        \\n    def shortestPath(self, node1: int, node2: int) -> int:\\n        q = [(0, node1)]\\n        dist = [inf] * self.n\\n        dist[node1] = 0\\n        while q:\\n            d, u = heappop(q)\\n            if u == node2:\\n                return d\\n            for v, w in self.g[u]:\\n                if d + w < dist[v]:\\n                    dist[v] = d + w\\n                    heappush(q, (d + w, v))\\n        return -1  \\n\\n\\n# Your Graph object will be instantiated and called as such:\\n# obj = Graph(n, edges)\\n# obj.addEdge(edge)\\n# param_2 = obj.shortestPath(node1,node2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420642,
                "title": "python-solution-implementing-dijkstra-algorithm",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAs soon as I read that we need to calculate the shortest path from a node to another, the famous Dijkstra Algorithm popped in my head and right here is just its implementation in python.\\n\\n# Code\\n```\\nimport heapq\\nclass Graph:\\n    #the graph constructor \\n    def __init__(self, n: int, edges: List[List[int]]):\\n        self.n = n\\n        self.edges = edges \\n        \\n\\n    def addEdge(self, edge: List[int]) -> None:\\n        self.edges.append(edge)\\n    \\n    #one extra function to create the directed, weighted graph which gets called only when all the edges have been inserted \\n    def createGraph(self,edges):\\n        graph = {i:dict() for i in range(self.n)}\\n        \\n        for s,e,w in edges:\\n            graph[s][e] = w\\n            \\n        return graph\\n    #implementation of the dijkstra algorithm \\n    def shortestPath(self, node1: int, node2: int) -> int:\\n        graph = self.createGraph(self.edges)\\n        dists = {node:math.inf for node in graph}\\n        dists[node1] = 0\\n        q = [(0,node1)]\\n        \\n        while q:\\n            curr_dist, curr_node = heapq.heappop(q)\\n            if curr_dist > dists[curr_node]:\\n                continue\\n            else:\\n                for nbr, wt in graph[curr_node].items():\\n                    dist = curr_dist + wt\\n                    if dist < dists[nbr]:\\n                        dists[nbr] = dist\\n                        heapq.heappush(q,(dist,nbr))\\n        return -1 if dists[node2] == math.inf else dists[node2]\\n\\n\\n# Your Graph object will be instantiated and called as such:\\n# obj = Graph(n, edges)\\n# obj.addEdge(edge)\\n# param_2 = obj.shortestPath(node1,node2)\\n```",
                "solutionTags": [
                    "Python3",
                    "Graph",
                    "Heap (Priority Queue)",
                    "Shortest Path"
                ],
                "code": "```\\nimport heapq\\nclass Graph:\\n    #the graph constructor \\n    def __init__(self, n: int, edges: List[List[int]]):\\n        self.n = n\\n        self.edges = edges \\n        \\n\\n    def addEdge(self, edge: List[int]) -> None:\\n        self.edges.append(edge)\\n    \\n    #one extra function to create the directed, weighted graph which gets called only when all the edges have been inserted \\n    def createGraph(self,edges):\\n        graph = {i:dict() for i in range(self.n)}\\n        \\n        for s,e,w in edges:\\n            graph[s][e] = w\\n            \\n        return graph\\n    #implementation of the dijkstra algorithm \\n    def shortestPath(self, node1: int, node2: int) -> int:\\n        graph = self.createGraph(self.edges)\\n        dists = {node:math.inf for node in graph}\\n        dists[node1] = 0\\n        q = [(0,node1)]\\n        \\n        while q:\\n            curr_dist, curr_node = heapq.heappop(q)\\n            if curr_dist > dists[curr_node]:\\n                continue\\n            else:\\n                for nbr, wt in graph[curr_node].items():\\n                    dist = curr_dist + wt\\n                    if dist < dists[nbr]:\\n                        dists[nbr] = dist\\n                        heapq.heappush(q,(dist,nbr))\\n        return -1 if dists[node2] == math.inf else dists[node2]\\n\\n\\n# Your Graph object will be instantiated and called as such:\\n# obj = Graph(n, edges)\\n# obj.addEdge(edge)\\n# param_2 = obj.shortestPath(node1,node2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420585,
                "title": "java-solution-easy-to-understood-beats-100",
                "content": "# Intuition\\nDIJKSTRA ALGOTIHTM\\n\\n# Approach\\nUSING PRIORITY QUEUE\\n\\n# Complexity\\n- Time complexity:\\nO(V ElogV)\\n# Code\\n```\\nclass Graph {\\n   int n;\\n   ArrayList<ArrayList<int[]>> l;\\n    public Graph(int n, int[][] edges) {\\n        this.n=n;\\n        l=new ArrayList<>();\\n        for(int i=0;i<n;i++)\\n        {\\n            l.add(new ArrayList<>());\\n        }\\n        for(int edge[]:edges)\\n        {\\n          int from=edge[0];\\n          int to=edge[1];\\n          int cost=edge[2];\\n          l.get(from).add(new int[]{to,cost});\\n        }\\n\\n\\n    }\\n    \\n    public void addEdge(int[] edge) {\\n\\n          int from=edge[0];\\n          int to=edge[1];\\n          int cost=edge[2];\\n          l.get(from).add(new int[]{to,cost});\\n        \\n    }\\n    \\n    public int shortestPath(int node1, int node2) {\\n        PriorityQueue<int[]> pq=new PriorityQueue<>((a,b)->a[1]-b[1]);\\n        pq.add(new int[]{node1,0});\\n        int distance[]=new int[n];\\n        Arrays.fill(distance,Integer.MAX_VALUE);\\n        distance[node1]=0;\\n        while(!pq.isEmpty())\\n        {\\n            int currNode=pq.peek()[0];\\n            int currDistance=pq.peek()[1];\\n            pq.poll();\\n            if(node2==currNode)return distance[currNode];\\n            ArrayList<int[]> child=l.get(currNode);\\n            for(int []c:child){\\n                int nextNode=c[0];\\n                int childdist=c[1];\\n                if(childdist+currDistance<distance[nextNode])\\n                {\\n                    distance[nextNode]=childdist+currDistance;\\n                    pq.add(new int[]{nextNode,distance[nextNode]});\\n                }\\n            }\\n            \\n        }\\n        return -1;\\n    }\\n}\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph obj = new Graph(n, edges);\\n * obj.addEdge(edge);\\n * int param_2 = obj.shortestPath(node1,node2);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Graph {\\n   int n;\\n   ArrayList<ArrayList<int[]>> l;\\n    public Graph(int n, int[][] edges) {\\n        this.n=n;\\n        l=new ArrayList<>();\\n        for(int i=0;i<n;i++)\\n        {\\n            l.add(new ArrayList<>());\\n        }\\n        for(int edge[]:edges)\\n        {\\n          int from=edge[0];\\n          int to=edge[1];\\n          int cost=edge[2];\\n          l.get(from).add(new int[]{to,cost});\\n        }\\n\\n\\n    }\\n    \\n    public void addEdge(int[] edge) {\\n\\n          int from=edge[0];\\n          int to=edge[1];\\n          int cost=edge[2];\\n          l.get(from).add(new int[]{to,cost});\\n        \\n    }\\n    \\n    public int shortestPath(int node1, int node2) {\\n        PriorityQueue<int[]> pq=new PriorityQueue<>((a,b)->a[1]-b[1]);\\n        pq.add(new int[]{node1,0});\\n        int distance[]=new int[n];\\n        Arrays.fill(distance,Integer.MAX_VALUE);\\n        distance[node1]=0;\\n        while(!pq.isEmpty())\\n        {\\n            int currNode=pq.peek()[0];\\n            int currDistance=pq.peek()[1];\\n            pq.poll();\\n            if(node2==currNode)return distance[currNode];\\n            ArrayList<int[]> child=l.get(currNode);\\n            for(int []c:child){\\n                int nextNode=c[0];\\n                int childdist=c[1];\\n                if(childdist+currDistance<distance[nextNode])\\n                {\\n                    distance[nextNode]=childdist+currDistance;\\n                    pq.add(new int[]{nextNode,distance[nextNode]});\\n                }\\n            }\\n            \\n        }\\n        return -1;\\n    }\\n}\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph obj = new Graph(n, edges);\\n * obj.addEdge(edge);\\n * int param_2 = obj.shortestPath(node1,node2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420566,
                "title": "python3-dijkstra",
                "content": "\\n```\\nclass Graph:\\n\\n    def __init__(self, n: int, edges: List[List[int]]):\\n        self.graph = [[] for _ in range(n)]\\n        for u, v, w in edges: \\n            self.graph[u].append((v, w))\\n\\n    def addEdge(self, edge: List[int]) -> None:\\n        u, v, w = edge\\n        self.graph[u].append((v, w))\\n\\n    def shortestPath(self, node1: int, node2: int) -> int:\\n        pq = [(0, node1)]\\n        dist = [inf]*len(self.graph)\\n        dist[node1] = 0 \\n        while pq: \\n            cost, u = heappop(pq)\\n            if u == node2: return cost\\n            for v, w in self.graph[u]: \\n                if cost + w < dist[v]: \\n                    dist[v] = cost + w\\n                    heappush(pq, (cost + w, v))\\n        return -1 \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Graph:\\n\\n    def __init__(self, n: int, edges: List[List[int]]):\\n        self.graph = [[] for _ in range(n)]\\n        for u, v, w in edges: \\n            self.graph[u].append((v, w))\\n\\n    def addEdge(self, edge: List[int]) -> None:\\n        u, v, w = edge\\n        self.graph[u].append((v, w))\\n\\n    def shortestPath(self, node1: int, node2: int) -> int:\\n        pq = [(0, node1)]\\n        dist = [inf]*len(self.graph)\\n        dist[node1] = 0 \\n        while pq: \\n            cost, u = heappop(pq)\\n            if u == node2: return cost\\n            for v, w in self.graph[u]: \\n                if cost + w < dist[v]: \\n                    dist[v] = cost + w\\n                    heappush(pq, (cost + w, v))\\n        return -1 \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420558,
                "title": "easy-explanation-with-comments-and-complexities-mentioned-djikstra",
                "content": "# Intuition\\nFor initializing graph, we first need to add edges from edges[i][0] to edges[i][1] with edge weight as edges[i][2].To find shortest distance between two nodes, we need to use Djikstra\\'s algorithm. \\n**Note**: Here the source node is node1 and not 0, so take care while solving the algorithm.\\n\\n# Approach\\n1. With the given \"n\" and edges array, we create graph using adjacency list and add all the edges with edge-weight to create directed graph. This is done in constructor which is called while creating object of the class.\\n2. For addEdge, we add extra edge from edge[0] to edge[1] with edge-weight as edge[2].\\n3. To find shortest distance, we use Djikstra\\'s algorithm.\\n4. For this,we use PriorityQueue(min-heap) so that we get minimum distance required to reach the destination node.\\n5. We initialize distance array with infinite distance and keep on updating it whenever shorter distance to that path is discovered.\\n6. If we cannot reach destination node, distance will be infinite and we will return -1. \\n\\n# Complexity\\n- Time complexity:\\nO((N+E)*logN). Going through N nodes and E edges and log N for priority queue\\n\\n- Space complexity:\\nO(N). Distance array and priority queue\\n\\n# Code\\n```\\n//it is used to create graph\\n//where adjacent= neighbouring node to the current node\\n//edgecost=cost required to reach that node\\nclass Node{\\n    int adjacent,edgeCost;\\n    Node(int adjacent,int edgeCost){\\n        this.adjacent=adjacent;\\n        this.edgeCost=edgeCost;\\n    }\\n}\\n\\n//it is stored in queue to represent node with it\\'s current distance\\nclass Pair{\\n    int node,distance;\\n    Pair(int node,int distance){\\n        this.node=node;\\n        this.distance=distance;\\n    }\\n}\\n\\nclass Graph {\\n    //adjacency list for graph\\n    ArrayList<ArrayList<Node>> adj=new ArrayList<>();\\n    \\n    public Graph(int n, int[][] edges) {\\n        //adding empty array for all \"n\" nodes\\n        for(int i=0;i<n;i++){\\n            ArrayList<Node> arr=new ArrayList<>();\\n            adj.add(arr);\\n        }\\n        //creating edges between two nodes with given edge weight\\n        for(int i=0;i<edges.length;i++){\\n            adj.get(edges[i][0]).add(new Node(edges[i][1],edges[i][2]));\\n        }\\n    }\\n    \\n    //creating edges between two nodes with given edge weight\\n    public void addEdge(int[] edges) {\\n        adj.get(edges[0]).add(new Node(edges[1],edges[2]));\\n    }\\n    \\n    public int shortestPath(int node1, int node2) {\\n        //min-heap to store node with minimum path distance\\n        PriorityQueue<Pair> pq=new PriorityQueue<Pair>((x,y)-> x.distance-y.distance);\\n        pq.offer(new Pair(node1,0));\\n        int[] dist=new int[adj.size()];\\n        //declaring distance array with all values intially as infinity\\n        for(int i=0;i<dist.length;i++){\\n            dist[i]=(int)(1e9);\\n        }\\n        //source node distance is assigned to 0\\n        dist[node1]=0;\\n        while(pq.size()!=0){\\n            //removing pair from queue\\n            Pair p=pq.poll();\\n            int distance=p.distance;\\n            int node=p.node;\\n            //traversing neighbouring nodes \\n            for(int i=0;i<adj.get(node).size();i++){\\n                int adjacent=adj.get(node).get(i).adjacent;\\n                int edgeCost=adj.get(node).get(i).edgeCost;\\n                //if computed path distance is smaller,update it\\n                if(distance+edgeCost<dist[adjacent]){\\n                    dist[adjacent]=distance+edgeCost;\\n                    pq.add(new Pair(adjacent,dist[adjacent]));\\n                }\\n            }\\n        }\\n        //if distance of destination node is infinity,it can be reached and return -1\\n        //else return the distance\\n        return dist[node2]==(int)(1e9)?-1:dist[node2];\\n    }\\n}\\n\\n",
                "solutionTags": [
                    "Java",
                    "Graph",
                    "Heap (Priority Queue)"
                ],
                "code": "# Intuition\\nFor initializing graph, we first need to add edges from edges[i][0] to edges[i][1] with edge weight as edges[i][2].To find shortest distance between two nodes, we need to use Djikstra\\'s algorithm. \\n**Note**: Here the source node is node1 and not 0, so take care while solving the algorithm.\\n\\n# Approach\\n1. With the given \"n\" and edges array, we create graph using adjacency list and add all the edges with edge-weight to create directed graph. This is done in constructor which is called while creating object of the class.\\n2. For addEdge, we add extra edge from edge[0] to edge[1] with edge-weight as edge[2].\\n3. To find shortest distance, we use Djikstra\\'s algorithm.\\n4. For this,we use PriorityQueue(min-heap) so that we get minimum distance required to reach the destination node.\\n5. We initialize distance array with infinite distance and keep on updating it whenever shorter distance to that path is discovered.\\n6. If we cannot reach destination node, distance will be infinite and we will return -1. \\n\\n# Complexity\\n- Time complexity:\\nO((N+E)*logN). Going through N nodes and E edges and log N for priority queue\\n\\n- Space complexity:\\nO(N). Distance array and priority queue\\n\\n# Code\\n```\\n//it is used to create graph\\n//where adjacent= neighbouring node to the current node\\n//edgecost=cost required to reach that node\\nclass Node{\\n    int adjacent,edgeCost;\\n    Node(int adjacent,int edgeCost){\\n        this.adjacent=adjacent;\\n        this.edgeCost=edgeCost;\\n    }\\n}\\n\\n//it is stored in queue to represent node with it\\'s current distance\\nclass Pair{\\n    int node,distance;\\n    Pair(int node,int distance){\\n        this.node=node;\\n        this.distance=distance;\\n    }\\n}\\n\\nclass Graph {\\n    //adjacency list for graph\\n    ArrayList<ArrayList<Node>> adj=new ArrayList<>();\\n    \\n    public Graph(int n, int[][] edges) {\\n        //adding empty array for all \"n\" nodes\\n        for(int i=0;i<n;i++){\\n            ArrayList<Node> arr=new ArrayList<>();\\n            adj.add(arr);\\n        }\\n        //creating edges between two nodes with given edge weight\\n        for(int i=0;i<edges.length;i++){\\n            adj.get(edges[i][0]).add(new Node(edges[i][1],edges[i][2]));\\n        }\\n    }\\n    \\n    //creating edges between two nodes with given edge weight\\n    public void addEdge(int[] edges) {\\n        adj.get(edges[0]).add(new Node(edges[1],edges[2]));\\n    }\\n    \\n    public int shortestPath(int node1, int node2) {\\n        //min-heap to store node with minimum path distance\\n        PriorityQueue<Pair> pq=new PriorityQueue<Pair>((x,y)-> x.distance-y.distance);\\n        pq.offer(new Pair(node1,0));\\n        int[] dist=new int[adj.size()];\\n        //declaring distance array with all values intially as infinity\\n        for(int i=0;i<dist.length;i++){\\n            dist[i]=(int)(1e9);\\n        }\\n        //source node distance is assigned to 0\\n        dist[node1]=0;\\n        while(pq.size()!=0){\\n            //removing pair from queue\\n            Pair p=pq.poll();\\n            int distance=p.distance;\\n            int node=p.node;\\n            //traversing neighbouring nodes \\n            for(int i=0;i<adj.get(node).size();i++){\\n                int adjacent=adj.get(node).get(i).adjacent;\\n                int edgeCost=adj.get(node).get(i).edgeCost;\\n                //if computed path distance is smaller,update it\\n                if(distance+edgeCost<dist[adjacent]){\\n                    dist[adjacent]=distance+edgeCost;\\n                    pq.add(new Pair(adjacent,dist[adjacent]));\\n                }\\n            }\\n        }\\n        //if distance of destination node is infinity,it can be reached and return -1\\n        //else return the distance\\n        return dist[node2]==(int)(1e9)?-1:dist[node2];\\n    }\\n}\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 3420516,
                "title": "c-solution-using-dijkstra-algorithm",
                "content": "```\\nclass Graph \\n{\\n    public:\\n    vector<pair<int,int>> total[100];\\n    Graph(int n, vector<vector<int>>& edges) \\n    {\\n        int t=edges.size();\\n        for(int i=0;i<t;i++) total[edges[i][0]].push_back({edges[i][1],edges[i][2]});\\n    }\\n    \\n    void addEdge(vector<int> edge) \\n    {\\n        total[edge[0]].push_back({edge[1],edge[2]});\\n    }\\n    \\n    int shortestPath(int node1, int node2) \\n    {\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> q;\\n        q.push({0,node1});\\n        bool v[101];\\n        memset(v,false,sizeof(v));\\n        while(!q.empty())\\n        {\\n            pair<int,int> p=q.top();\\n            q.pop();\\n            int cost=p.first;\\n            int node=p.second;\\n            if(v[node]) continue;\\n            v[node]=true;\\n            if(node==node2) return cost;\\n            for(int i=0;i<total[node].size();i++) q.push({cost+total[node][i].second,total[node][i].first});\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Graph \\n{\\n    public:\\n    vector<pair<int,int>> total[100];\\n    Graph(int n, vector<vector<int>>& edges) \\n    {\\n        int t=edges.size();\\n        for(int i=0;i<t;i++) total[edges[i][0]].push_back({edges[i][1],edges[i][2]});\\n    }\\n    \\n    void addEdge(vector<int> edge) \\n    {\\n        total[edge[0]].push_back({edge[1],edge[2]});\\n    }\\n    \\n    int shortestPath(int node1, int node2) \\n    {\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> q;\\n        q.push({0,node1});\\n        bool v[101];\\n        memset(v,false,sizeof(v));\\n        while(!q.empty())\\n        {\\n            pair<int,int> p=q.top();\\n            q.pop();\\n            int cost=p.first;\\n            int node=p.second;\\n            if(v[node]) continue;\\n            v[node]=true;\\n            if(node==node2) return cost;\\n            for(int i=0;i<total[node].size();i++) q.push({cost+total[node][i].second,total[node][i].first});\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420499,
                "title": "my-solution",
                "content": "```\\nclass Graph {\\n private:\\n  static constexpr int i_from = 0;\\n  static constexpr int i_to = 1;\\n  static constexpr int i_cost = 2;\\n  using pq_node_t = pair<int, int>;   // {node, minimum cost}\\n  \\n public:\\n  /**\\n   * Time Complexity: O(n_edges)\\n   */\\n  Graph(const int n, const vector<vector<int>> &edges) : graph_(n) {\\n    for (const vector<int> &edge : edges) {\\n      graph_[edge[i_from]].emplace_back(edge[i_to], edge[i_cost]);\\n    }\\n  }\\n\\n  /**\\n   * Time Complexity: O(1)\\n   */\\n  void addEdge(const vector<int> &edge) {\\n    graph_[edge[i_from]].emplace_back(edge[i_to], edge[i_cost]);\\n  }\\n\\n  /**\\n   * Time Complexity: O(n_edges * log(n))\\n   */\\n  int shortestPath(const int node1, const int node2) {\\n    auto compare = [](const pq_node_t &lhs, const pq_node_t &rhs) -> bool {\\n      return !(lhs.second < rhs.second);\\n    };\\n    \\n    priority_queue<pq_node_t, vector<pq_node_t>, decltype(compare)> pq(compare);\\n    pq.emplace(node1, 0);\\n    int costs[graph_.size()];\\n    fill(costs, costs + graph_.size(), numeric_limits<int>::max());\\n    while (!pq.empty()) {\\n      const auto [node, cost] = pq.top();\\n      pq.pop();\\n      if (node == node2) {\\n        return cost;\\n      }\\n      if (cost >= costs[node]) {\\n        continue;\\n      }\\n      costs[node] = cost;\\n      for (const auto [next, cost_delta] : graph_[node]) {\\n        const int next_cost = cost + cost_delta;\\n        if (next_cost >= costs[next]) {\\n          continue;\\n        }\\n        pq.emplace(next, next_cost);\\n      }\\n    }\\n    return -1;\\n  }\\n  \\n private:\\n  vector<vector<pair<int, int>>> graph_;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Graph {\\n private:\\n  static constexpr int i_from = 0;\\n  static constexpr int i_to = 1;\\n  static constexpr int i_cost = 2;\\n  using pq_node_t = pair<int, int>;   // {node, minimum cost}\\n  \\n public:\\n  /**\\n   * Time Complexity: O(n_edges)\\n   */\\n  Graph(const int n, const vector<vector<int>> &edges) : graph_(n) {\\n    for (const vector<int> &edge : edges) {\\n      graph_[edge[i_from]].emplace_back(edge[i_to], edge[i_cost]);\\n    }\\n  }\\n\\n  /**\\n   * Time Complexity: O(1)\\n   */\\n  void addEdge(const vector<int> &edge) {\\n    graph_[edge[i_from]].emplace_back(edge[i_to], edge[i_cost]);\\n  }\\n\\n  /**\\n   * Time Complexity: O(n_edges * log(n))\\n   */\\n  int shortestPath(const int node1, const int node2) {\\n    auto compare = [](const pq_node_t &lhs, const pq_node_t &rhs) -> bool {\\n      return !(lhs.second < rhs.second);\\n    };\\n    \\n    priority_queue<pq_node_t, vector<pq_node_t>, decltype(compare)> pq(compare);\\n    pq.emplace(node1, 0);\\n    int costs[graph_.size()];\\n    fill(costs, costs + graph_.size(), numeric_limits<int>::max());\\n    while (!pq.empty()) {\\n      const auto [node, cost] = pq.top();\\n      pq.pop();\\n      if (node == node2) {\\n        return cost;\\n      }\\n      if (cost >= costs[node]) {\\n        continue;\\n      }\\n      costs[node] = cost;\\n      for (const auto [next, cost_delta] : graph_[node]) {\\n        const int next_cost = cost + cost_delta;\\n        if (next_cost >= costs[next]) {\\n          continue;\\n        }\\n        pq.emplace(next, next_cost);\\n      }\\n    }\\n    return -1;\\n  }\\n  \\n private:\\n  vector<vector<pair<int, int>>> graph_;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420492,
                "title": "python-o-n-2-time-o-n-2-space",
                "content": "# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n^2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Graph:\\n\\n    def __init__(self, n: int, edges: List[List[int]]):\\n        self.size = n\\n        self.edges = [[-1 for _ in range(n)] for _ in range(n)]\\n        for edge in edges:\\n            self.addEdge(edge)\\n        \\n\\n    def addEdge(self, edge: List[int]) -> None:\\n        i = edge[0]\\n        j = edge[1]\\n        k = edge[2]\\n        self.edges[i][j] = k\\n        \\n        \\n    def shortestPath(self, node1: int, node2: int) -> int:\\n        heap = []\\n        heappush(heap, (0, node1))\\n        dist = [float(\\'inf\\')] * self.size\\n        dist[node1] = 0\\n  \\n        while heap:\\n            d, u = heapq.heappop(heap)\\n            for v, weight in enumerate(self.edges[u]):\\n                if weight < 0:\\n                    continue\\n                if dist[v] > dist[u] + weight:\\n                    dist[v] = dist[u] + weight\\n                    heappush(heap, (dist[v], v))\\n            \\n        return dist[node2] if dist[node2] < float(\"inf\") else -1 \\n        \\n        \\n        \\n\\n\\n# Your Graph object will be instantiated and called as such:\\n# obj = Graph(n, edges)\\n# obj.addEdge(edge)\\n# param_2 = obj.shortestPath(node1,node2)\\n```",
                "solutionTags": [
                    "Python3",
                    "Graph",
                    "Heap (Priority Queue)",
                    "Matrix"
                ],
                "code": "```\\nclass Graph:\\n\\n    def __init__(self, n: int, edges: List[List[int]]):\\n        self.size = n\\n        self.edges = [[-1 for _ in range(n)] for _ in range(n)]\\n        for edge in edges:\\n            self.addEdge(edge)\\n        \\n\\n    def addEdge(self, edge: List[int]) -> None:\\n        i = edge[0]\\n        j = edge[1]\\n        k = edge[2]\\n        self.edges[i][j] = k\\n        \\n        \\n    def shortestPath(self, node1: int, node2: int) -> int:\\n        heap = []\\n        heappush(heap, (0, node1))\\n        dist = [float(\\'inf\\')] * self.size\\n        dist[node1] = 0\\n  \\n        while heap:\\n            d, u = heapq.heappop(heap)\\n            for v, weight in enumerate(self.edges[u]):\\n                if weight < 0:\\n                    continue\\n                if dist[v] > dist[u] + weight:\\n                    dist[v] = dist[u] + weight\\n                    heappush(heap, (dist[v], v))\\n            \\n        return dist[node2] if dist[node2] < float(\"inf\") else -1 \\n        \\n        \\n        \\n\\n\\n# Your Graph object will be instantiated and called as such:\\n# obj = Graph(n, edges)\\n# obj.addEdge(edge)\\n# param_2 = obj.shortestPath(node1,node2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420465,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Graph {\\npublic:\\nvector<pair<int,int>> graph[100];\\nint g;\\n    Graph(int n, vector<vector<int>>& edges) {\\n        g=n;\\n        for(int i=0;i<edges.size();i++){\\n            graph[edges[i][0]].push_back({edges[i][1],edges[i][2]});\\n        }\\n    }\\n    \\n    void addEdge(vector<int> edge) {\\n         graph[edge[0]].push_back({edge[1],edge[2]});\\n    }\\n    \\n    int shortestPath(int node1, int node2) {\\n        long long int dis[g+1];\\n        for(int i=0;i<=g;i++) dis[i]=1e10+5;\\n        dis[node1]=0;\\n        set<pair<int,int>> st;\\n        st.insert({0,node1});\\n        while(!st.empty()){\\n            int node=st.begin()->second;\\n            st.erase(st.begin());\\n            for( auto child : graph[node]){\\n                if(dis[child.first]>dis[node]+child.second){\\n                    dis[child.first]=dis[node]+child.second;\\n                    st.insert({dis[child.first],child.first});\\n                }\\n            }\\n        }\\n\\n        if(dis[node2]>1e10+1) return -1;\\n        return dis[node2];\\n\\n    }\\n};\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph* obj = new Graph(n, edges);\\n * obj->addEdge(edge);\\n * int param_2 = obj->shortestPath(node1,node2);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Graph {\\npublic:\\nvector<pair<int,int>> graph[100];\\nint g;\\n    Graph(int n, vector<vector<int>>& edges) {\\n        g=n;\\n        for(int i=0;i<edges.size();i++){\\n            graph[edges[i][0]].push_back({edges[i][1],edges[i][2]});\\n        }\\n    }\\n    \\n    void addEdge(vector<int> edge) {\\n         graph[edge[0]].push_back({edge[1],edge[2]});\\n    }\\n    \\n    int shortestPath(int node1, int node2) {\\n        long long int dis[g+1];\\n        for(int i=0;i<=g;i++) dis[i]=1e10+5;\\n        dis[node1]=0;\\n        set<pair<int,int>> st;\\n        st.insert({0,node1});\\n        while(!st.empty()){\\n            int node=st.begin()->second;\\n            st.erase(st.begin());\\n            for( auto child : graph[node]){\\n                if(dis[child.first]>dis[node]+child.second){\\n                    dis[child.first]=dis[node]+child.second;\\n                    st.insert({dis[child.first],child.first});\\n                }\\n            }\\n        }\\n\\n        if(dis[node2]>1e10+1) return -1;\\n        return dis[node2];\\n\\n    }\\n};\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph* obj = new Graph(n, edges);\\n * obj->addEdge(edge);\\n * int param_2 = obj->shortestPath(node1,node2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420460,
                "title": "very-easy-and-self-explanatory-solution-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Graph {\\n    class Node{\\n        int node;\\n        int cost;\\n        public Node(int node,int cost){\\n            this.node = node;\\n            this.cost = cost;\\n        }\\n    }\\n    \\n    class Cell implements Comparable<Cell>{\\n        int node;\\n        int minCost;\\n        public Cell(int node,int minCost){\\n            this.node = node;\\n            this.minCost = minCost;\\n        }\\n        public int compareTo(Cell that){\\n            return this.minCost - that.minCost;\\n        }\\n    }\\n    \\n    List<List<Node>> adjList = new ArrayList<>();\\n    int n;\\n    \\n    public Graph(int n, int[][] edges) {\\n\\n        this.n = n;\\n       \\n        for(int i=0;i<n;i++){\\n            adjList.add(new ArrayList<>());\\n        }\\n        for(int[] edge:edges){\\n            adjList.get(edge[0]).add(new Node(edge[1],edge[2]));\\n           \\n        }\\n        \\n    }\\n    \\n    public void addEdge(int[] edge) {\\n        \\n            if(adjList.contains(edge[0])){\\n                adjList.add(new ArrayList<>());\\n            }\\n        \\n            adjList.get(edge[0]).add(new Node(edge[1],edge[2]));  \\n        \\n    }\\n    \\n    public int shortestPath(int node1, int node2) {\\n        \\n        Queue<Cell> q = new PriorityQueue<>();\\n        \\n        q.add(new Cell(node1,0));\\n        \\n        \\n        int[] shortestPath = new int[n];\\n        \\n        Arrays.fill(shortestPath,Integer.MAX_VALUE);\\n        \\n        shortestPath[node1] = 0;\\n        \\n        while(!q.isEmpty()){\\n            \\n            Cell cell = q.poll();\\n            \\n            int node = cell.node;\\n            int minCost = cell.minCost;\\n            \\n            for(int i=0;i<adjList.get(node).size();i++){\\n                int neighbourNode = adjList.get(node).get(i).node;\\n                int neighbourNodeCost = adjList.get(node).get(i).cost;\\n                \\n                if(shortestPath[neighbourNode] > minCost + neighbourNodeCost){\\n                    shortestPath[neighbourNode] = minCost + neighbourNodeCost;\\n                    q.add(new Cell(neighbourNode,shortestPath[neighbourNode]));\\n                }\\n                \\n            }\\n            \\n            \\n        }\\n        \\n        if(shortestPath[node2] == Integer.MAX_VALUE)\\n            return -1;\\n        \\n        return shortestPath[node2];\\n    }\\n}\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph obj = new Graph(n, edges);\\n * obj.addEdge(edge);\\n * int param_2 = obj.shortestPath(node1,node2);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Graph",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Graph {\\n    class Node{\\n        int node;\\n        int cost;\\n        public Node(int node,int cost){\\n            this.node = node;\\n            this.cost = cost;\\n        }\\n    }\\n    \\n    class Cell implements Comparable<Cell>{\\n        int node;\\n        int minCost;\\n        public Cell(int node,int minCost){\\n            this.node = node;\\n            this.minCost = minCost;\\n        }\\n        public int compareTo(Cell that){\\n            return this.minCost - that.minCost;\\n        }\\n    }\\n    \\n    List<List<Node>> adjList = new ArrayList<>();\\n    int n;\\n    \\n    public Graph(int n, int[][] edges) {\\n\\n        this.n = n;\\n       \\n        for(int i=0;i<n;i++){\\n            adjList.add(new ArrayList<>());\\n        }\\n        for(int[] edge:edges){\\n            adjList.get(edge[0]).add(new Node(edge[1],edge[2]));\\n           \\n        }\\n        \\n    }\\n    \\n    public void addEdge(int[] edge) {\\n        \\n            if(adjList.contains(edge[0])){\\n                adjList.add(new ArrayList<>());\\n            }\\n        \\n            adjList.get(edge[0]).add(new Node(edge[1],edge[2]));  \\n        \\n    }\\n    \\n    public int shortestPath(int node1, int node2) {\\n        \\n        Queue<Cell> q = new PriorityQueue<>();\\n        \\n        q.add(new Cell(node1,0));\\n        \\n        \\n        int[] shortestPath = new int[n];\\n        \\n        Arrays.fill(shortestPath,Integer.MAX_VALUE);\\n        \\n        shortestPath[node1] = 0;\\n        \\n        while(!q.isEmpty()){\\n            \\n            Cell cell = q.poll();\\n            \\n            int node = cell.node;\\n            int minCost = cell.minCost;\\n            \\n            for(int i=0;i<adjList.get(node).size();i++){\\n                int neighbourNode = adjList.get(node).get(i).node;\\n                int neighbourNodeCost = adjList.get(node).get(i).cost;\\n                \\n                if(shortestPath[neighbourNode] > minCost + neighbourNodeCost){\\n                    shortestPath[neighbourNode] = minCost + neighbourNodeCost;\\n                    q.add(new Cell(neighbourNode,shortestPath[neighbourNode]));\\n                }\\n                \\n            }\\n            \\n            \\n        }\\n        \\n        if(shortestPath[node2] == Integer.MAX_VALUE)\\n            return -1;\\n        \\n        return shortestPath[node2];\\n    }\\n}\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph obj = new Graph(n, edges);\\n * obj.addEdge(edge);\\n * int param_2 = obj.shortestPath(node1,node2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420457,
                "title": "c-dijkstra",
                "content": "# Intuition\\nShortest paths in a weighted graph => Dijkstra.\\nThere are only 100 calls for shortestPath, so Dijkstra is enought.\\n\\n# Approach\\n- Dijkstra\\n\\n# Complexity\\n- Time complexity: $$O(E * Log(V))$$\\n\\n- Space complexity: $$O(E + V)$$\\n\\n# Code\\n```\\npublic class Graph \\n{\\n    private readonly int n;\\n    private readonly List<int[]>[] adj;\\n    public Graph(int n, int[][] edges)\\n    {\\n        this.n = n;\\n        adj = new List<int[]>[n];\\n        for (int i = 0; i < n; i++)\\n        {\\n            adj[i] = new List<int[]>();\\n        }\\n        foreach (int[] edge in edges)\\n        {\\n            AddEdge(edge);\\n        }\\n    }\\n\\n    public void AddEdge(int[] edge)\\n    {\\n        adj[edge[0]].Add(new int[] { edge[1], edge[2] });\\n    }\\n\\n    public int ShortestPath(int node1, int node2)\\n    {\\n        int[] dist = new int[n];\\n        for (int i = 0; i < n; i++)\\n        {\\n            dist[i] = int.MaxValue;\\n        }\\n        dist[node1] = 0;\\n        PriorityQueue<int[], int> pq = new PriorityQueue<int[], int>();\\n        pq.Enqueue(new int[] { node1, 0 }, 0);\\n        while (pq.Count > 0)\\n        {\\n            int[] curr = pq.Dequeue();\\n            int u = curr[0];\\n            int d = curr[1];\\n            if (u == node2)\\n            {\\n                return d;\\n            }\\n            foreach (int[] edge in adj[u])\\n            {\\n                int v = edge[0];\\n                int w = edge[1];\\n                if (dist[u] + w < dist[v])\\n                {\\n                    dist[v] = dist[u] + w;\\n                    pq.Enqueue(new int[] { v, dist[v] }, dist[v]);\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Graph \\n{\\n    private readonly int n;\\n    private readonly List<int[]>[] adj;\\n    public Graph(int n, int[][] edges)\\n    {\\n        this.n = n;\\n        adj = new List<int[]>[n];\\n        for (int i = 0; i < n; i++)\\n        {\\n            adj[i] = new List<int[]>();\\n        }\\n        foreach (int[] edge in edges)\\n        {\\n            AddEdge(edge);\\n        }\\n    }\\n\\n    public void AddEdge(int[] edge)\\n    {\\n        adj[edge[0]].Add(new int[] { edge[1], edge[2] });\\n    }\\n\\n    public int ShortestPath(int node1, int node2)\\n    {\\n        int[] dist = new int[n];\\n        for (int i = 0; i < n; i++)\\n        {\\n            dist[i] = int.MaxValue;\\n        }\\n        dist[node1] = 0;\\n        PriorityQueue<int[], int> pq = new PriorityQueue<int[], int>();\\n        pq.Enqueue(new int[] { node1, 0 }, 0);\\n        while (pq.Count > 0)\\n        {\\n            int[] curr = pq.Dequeue();\\n            int u = curr[0];\\n            int d = curr[1];\\n            if (u == node2)\\n            {\\n                return d;\\n            }\\n            foreach (int[] edge in adj[u])\\n            {\\n                int v = edge[0];\\n                int w = edge[1];\\n                if (dist[u] + w < dist[v])\\n                {\\n                    dist[v] = dist[u] + w;\\n                    pq.Enqueue(new int[] { v, dist[v] }, dist[v]);\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420407,
                "title": "c-python-short-code-by-using-floyd-warshall-algorithm",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nn is only 100, and the O(n^3) solution is doable.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^3)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code (C++)\\n```\\nconst int INF = 0x3f3f3f3f;\\nint dis[110][110];\\nclass Graph {\\npublic:\\n    int n;\\n    Graph(int n, vector<vector<int>>& edges) {\\n        this -> n = n;\\n        memset(dis, 0x3f, sizeof dis);\\n        for (auto e : edges){\\n            int i = e[0], j = e[1], c = e[2];\\n            dis[i][j] = c;\\n        }\\n        for (int i = 0; i< n; ++i)dis[i][i] = 0;   \\n        for (int k = 0; k < n; ++k)\\n             for (int i = 0; i < n; ++i)\\n               for (int j = 0; j < n; ++j)\\n                      dis[i][j] = min(dis[i][j], dis[i][k]+dis[k][j]);\\n    }\\n    void addEdge(vector<int> e) {\\n        int k1 = e[0], k2 = e[1], c = e[2];\\n        for (int i = 0; i < n; ++i)\\n            for (int j = 0; j < n; ++j)\\n                dis[i][j] = min(dis[i][j], dis[i][k1] + c + dis[k2][j]);        \\n    }\\n    \\n    int shortestPath(int i, int j) {\\n        return dis[i][j] == INF? -1: dis[i][j];      \\n    }\\n};\\n```\\n\\n# Code (Python) \\n```python\\nclass Graph:\\n    def __init__(self, n: int, edges: List[List[int]]):\\n        self.n = n\\n        self.dis = [[float(\\'inf\\')]*n for _ in range(n)]\\n        for a,b, c in edges:\\n            self.dis[a][b]=c\\n        for i in range(n):self.dis[i][i]=0\\n        for k in range(n):\\n            for i in range(n):\\n                for j in range(n):\\n                    self.dis[i][j] = min(self.dis[i][j], self.dis[i][k]+self.dis[k][j])\\n\\n    def addEdge(self, edge: List[int]) -> None:\\n        k1, k2, c = edge\\n        for i in range(self.n):\\n            for j in range(self.n):\\n                self.dis[i][j] = min(self.dis[i][j], self.dis[i][k1] + c + self.dis[k2][j])\\n\\n    def shortestPath(self, node1: int, node2: int) -> int:\\n        if self.dis[node1][node2] == float(\\'inf\\'):return -1\\n        return self.dis[node1][node2]\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nconst int INF = 0x3f3f3f3f;\\nint dis[110][110];\\nclass Graph {\\npublic:\\n    int n;\\n    Graph(int n, vector<vector<int>>& edges) {\\n        this -> n = n;\\n        memset(dis, 0x3f, sizeof dis);\\n        for (auto e : edges){\\n            int i = e[0], j = e[1], c = e[2];\\n            dis[i][j] = c;\\n        }\\n        for (int i = 0; i< n; ++i)dis[i][i] = 0;   \\n        for (int k = 0; k < n; ++k)\\n             for (int i = 0; i < n; ++i)\\n               for (int j = 0; j < n; ++j)\\n                      dis[i][j] = min(dis[i][j], dis[i][k]+dis[k][j]);\\n    }\\n    void addEdge(vector<int> e) {\\n        int k1 = e[0], k2 = e[1], c = e[2];\\n        for (int i = 0; i < n; ++i)\\n            for (int j = 0; j < n; ++j)\\n                dis[i][j] = min(dis[i][j], dis[i][k1] + c + dis[k2][j]);        \\n    }\\n    \\n    int shortestPath(int i, int j) {\\n        return dis[i][j] == INF? -1: dis[i][j];      \\n    }\\n};\\n```\n```python\\nclass Graph:\\n    def __init__(self, n: int, edges: List[List[int]]):\\n        self.n = n\\n        self.dis = [[float(\\'inf\\')]*n for _ in range(n)]\\n        for a,b, c in edges:\\n            self.dis[a][b]=c\\n        for i in range(n):self.dis[i][i]=0\\n        for k in range(n):\\n            for i in range(n):\\n                for j in range(n):\\n                    self.dis[i][j] = min(self.dis[i][j], self.dis[i][k]+self.dis[k][j])\\n\\n    def addEdge(self, edge: List[int]) -> None:\\n        k1, k2, c = edge\\n        for i in range(self.n):\\n            for j in range(self.n):\\n                self.dis[i][j] = min(self.dis[i][j], self.dis[i][k1] + c + self.dis[k2][j])\\n\\n    def shortestPath(self, node1: int, node2: int) -> int:\\n        if self.dis[node1][node2] == float(\\'inf\\'):return -1\\n        return self.dis[node1][node2]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420399,
                "title": "simple-dijkstra-algorithm-java-solution",
                "content": "# Code\\n```\\nclass Pair implements Comparable<Pair> {\\n    int node;\\n    int wt;\\n    public Pair(int node, int wt){\\n        this.node=node;\\n        this.wt=wt;\\n    }\\n    @Override\\n    public int compareTo(Pair p){\\n        return this.wt==p.wt?(this.node-p.node):(this.wt-p.wt);\\n    }\\n}\\n\\nclass Graph {\\n    \\n    List<List<Pair>> adjList=new ArrayList<>();\\n    \\n    public Graph(int n, int[][] edges) {\\n        for(int i=0; i<n; i++) adjList.add(new ArrayList<Pair>());\\n        for(int[] edge: edges){\\n            int u=edge[0];\\n            int v=edge[1];\\n            int c=edge[2];\\n            adjList.get(u).add(new Pair(v, c));\\n        }\\n    }\\n    \\n    public void addEdge(int[] edge) {\\n        int u=edge[0];\\n        int v=edge[1];\\n        int c=edge[2];\\n        adjList.get(u).add(new Pair(v, c));\\n    }\\n    \\n    public int shortestPath(int node1, int node2) {\\n        Queue<Pair> q=new PriorityQueue<>();\\n        int [] dist=new int [adjList.size()];\\n        Arrays.fill(dist, Integer.MAX_VALUE);\\n        dist[node1]=0;\\n        q.add(new Pair(node1,0));\\n        while(!q.isEmpty()){\\n            Pair pair=q.poll();\\n            int curr=pair.node;\\n            for(Pair adj: adjList.get(curr)){\\n                int adjNode=adj.node;\\n                int wt=adj.wt;\\n                if(dist[adjNode]>dist[curr]+wt){\\n                    dist[adjNode]=dist[curr]+wt;\\n                    q.add(new Pair(adjNode, dist[adjNode]));\\n                }\\n            }\\n        }\\n        return dist[node2]==Integer.MAX_VALUE ? -1 : dist[node2];\\n\\n    }\\n}\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph obj = new Graph(n, edges);\\n * obj.addEdge(edge);\\n * int param_2 = obj.shortestPath(node1,node2);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Pair implements Comparable<Pair> {\\n    int node;\\n    int wt;\\n    public Pair(int node, int wt){\\n        this.node=node;\\n        this.wt=wt;\\n    }\\n    @Override\\n    public int compareTo(Pair p){\\n        return this.wt==p.wt?(this.node-p.node):(this.wt-p.wt);\\n    }\\n}\\n\\nclass Graph {\\n    \\n    List<List<Pair>> adjList=new ArrayList<>();\\n    \\n    public Graph(int n, int[][] edges) {\\n        for(int i=0; i<n; i++) adjList.add(new ArrayList<Pair>());\\n        for(int[] edge: edges){\\n            int u=edge[0];\\n            int v=edge[1];\\n            int c=edge[2];\\n            adjList.get(u).add(new Pair(v, c));\\n        }\\n    }\\n    \\n    public void addEdge(int[] edge) {\\n        int u=edge[0];\\n        int v=edge[1];\\n        int c=edge[2];\\n        adjList.get(u).add(new Pair(v, c));\\n    }\\n    \\n    public int shortestPath(int node1, int node2) {\\n        Queue<Pair> q=new PriorityQueue<>();\\n        int [] dist=new int [adjList.size()];\\n        Arrays.fill(dist, Integer.MAX_VALUE);\\n        dist[node1]=0;\\n        q.add(new Pair(node1,0));\\n        while(!q.isEmpty()){\\n            Pair pair=q.poll();\\n            int curr=pair.node;\\n            for(Pair adj: adjList.get(curr)){\\n                int adjNode=adj.node;\\n                int wt=adj.wt;\\n                if(dist[adjNode]>dist[curr]+wt){\\n                    dist[adjNode]=dist[curr]+wt;\\n                    q.add(new Pair(adjNode, dist[adjNode]));\\n                }\\n            }\\n        }\\n        return dist[node2]==Integer.MAX_VALUE ? -1 : dist[node2];\\n\\n    }\\n}\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph obj = new Graph(n, edges);\\n * obj.addEdge(edge);\\n * int param_2 = obj.shortestPath(node1,node2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420381,
                "title": "dijkstra-s-shortest-path-algorithm-simple-code",
                "content": "\\n\\n# Code\\n```\\nclass Graph {\\npublic:\\n    typedef long long ll;\\n    vector<pair<int,int>>adj[110];\\n    \\n    Graph(int n, vector<vector<int>>& edges) {\\n        // adj.erase();\\n        for(auto it : edges){\\n            adj[it[0]].push_back(make_pair(it[1],it[2]));\\n        }\\n    }\\n    \\n    void addEdge(vector<int> edge) {\\n        adj[edge[0]].push_back({edge[1],edge[2]});\\n    }\\n    \\n    int shortestPath(int node1, int node2) {\\n        if(node1 == node2) return 0;\\n        int ans  = -1;\\n        \\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pq;\\n        \\n        vector<ll>vis(110,INT_MAX);\\n        \\n        for(auto it : adj[node1]){\\n            pq.push({it.second,it.first});\\n        }\\n\\n        while(!pq.empty()){\\n            auto temp = pq.top();\\n            ll val = temp.first;\\n            ll num = temp.second;\\n\\n            pq.pop();\\n            \\n            if(num == node2) return val;\\n            \\n            if(vis[num] > val){\\n                vis[num] = val;\\n                for(auto it : adj[num]){\\n                    pq.push({it.second+val,it.first});\\n                }\\n            }\\n            \\n            \\n        }\\n        return -1;\\n    }\\n};\\n\\n\\n```\\n# upvote if it\\'s help you HAPPY CODING :)",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Graph {\\npublic:\\n    typedef long long ll;\\n    vector<pair<int,int>>adj[110];\\n    \\n    Graph(int n, vector<vector<int>>& edges) {\\n        // adj.erase();\\n        for(auto it : edges){\\n            adj[it[0]].push_back(make_pair(it[1],it[2]));\\n        }\\n    }\\n    \\n    void addEdge(vector<int> edge) {\\n        adj[edge[0]].push_back({edge[1],edge[2]});\\n    }\\n    \\n    int shortestPath(int node1, int node2) {\\n        if(node1 == node2) return 0;\\n        int ans  = -1;\\n        \\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pq;\\n        \\n        vector<ll>vis(110,INT_MAX);\\n        \\n        for(auto it : adj[node1]){\\n            pq.push({it.second,it.first});\\n        }\\n\\n        while(!pq.empty()){\\n            auto temp = pq.top();\\n            ll val = temp.first;\\n            ll num = temp.second;\\n\\n            pq.pop();\\n            \\n            if(num == node2) return val;\\n            \\n            if(vis[num] > val){\\n                vis[num] = val;\\n                for(auto it : adj[num]){\\n                    pq.push({it.second+val,it.first});\\n                }\\n            }\\n            \\n            \\n        }\\n        return -1;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420377,
                "title": "c-dijkstra-s-algorithm",
                "content": "\\n\\n\\t\\tclass Graph {\\n\\t\\tpublic:\\n\\t\\t\\tvector<vector<pair<int,int>>>adj;\\n\\t\\t\\tGraph(int n, vector<vector<int>>& edges) {\\n\\t\\t\\t\\tadj.resize(n+1);\\n\\t\\t\\t\\tfor(int i=0;i<edges.size();i++){\\n\\t\\t\\t\\t\\tadj[edges[i][0]].push_back({edges[i][1],edges[i][2]});\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tvoid addEdge(vector<int> edge) {\\n\\t\\t\\t\\tadj[edge[0]].push_back({edge[1],edge[2]});\\n\\t\\t\\t}\\n\\n\\t\\t\\tint shortestPath(int node1, int node2) {\\n\\t\\t\\t\\tpriority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>>pq;\\n\\t\\t\\t\\tpq.push({0,node1});\\n\\t\\t\\t\\tint n=adj.size();\\n\\t\\t\\t\\tvector<int> dist(n+1, 1e9);\\n\\t\\t\\t\\tdist[node1]=0;\\n\\t\\t\\t\\twhile(!pq.empty()){\\n\\t\\t\\t\\t\\tint u=pq.top().second;\\n\\t\\t\\t\\t\\tpq.pop();\\n\\t\\t\\t\\t\\tfor(auto it:adj[u]){\\n\\t\\t\\t\\t\\t\\tint v=it.first;\\n\\t\\t\\t\\t\\t\\tint w=it.second;\\n\\t\\t\\t\\t\\t\\tif (dist[v] > dist[u] + w) {\\n\\t\\t\\t\\t\\t\\t\\tdist[v] = dist[u] + w;\\n\\t\\t\\t\\t\\t\\t\\tpq.push({dist[v], v});\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(dist[node2]!=1e9){\\n\\t\\t\\t\\t\\treturn dist[node2];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn -1;\\n\\t\\t\\t}\\n\\t\\t};",
                "solutionTags": [],
                "code": "\\n\\n\\t\\tclass Graph {\\n\\t\\tpublic:\\n\\t\\t\\tvector<vector<pair<int,int>>>adj;\\n\\t\\t\\tGraph(int n, vector<vector<int>>& edges) {\\n\\t\\t\\t\\tadj.resize(n+1);\\n\\t\\t\\t\\tfor(int i=0;i<edges.size();i++){\\n\\t\\t\\t\\t\\tadj[edges[i][0]].push_back({edges[i][1],edges[i][2]});\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tvoid addEdge(vector<int> edge) {\\n\\t\\t\\t\\tadj[edge[0]].push_back({edge[1],edge[2]});\\n\\t\\t\\t}\\n\\n\\t\\t\\tint shortestPath(int node1, int node2) {\\n\\t\\t\\t\\tpriority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>>pq;\\n\\t\\t\\t\\tpq.push({0,node1});\\n\\t\\t\\t\\tint n=adj.size();\\n\\t\\t\\t\\tvector<int> dist(n+1, 1e9);\\n\\t\\t\\t\\tdist[node1]=0;\\n\\t\\t\\t\\twhile(!pq.empty()){\\n\\t\\t\\t\\t\\tint u=pq.top().second;\\n\\t\\t\\t\\t\\tpq.pop();\\n\\t\\t\\t\\t\\tfor(auto it:adj[u]){\\n\\t\\t\\t\\t\\t\\tint v=it.first;\\n\\t\\t\\t\\t\\t\\tint w=it.second;\\n\\t\\t\\t\\t\\t\\tif (dist[v] > dist[u] + w) {\\n\\t\\t\\t\\t\\t\\t\\tdist[v] = dist[u] + w;\\n\\t\\t\\t\\t\\t\\t\\tpq.push({dist[v], v});\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(dist[node2]!=1e9){\\n\\t\\t\\t\\t\\treturn dist[node2];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn -1;\\n\\t\\t\\t}\\n\\t\\t};",
                "codeTag": "Java"
            },
            {
                "id": 3420374,
                "title": "c-solution",
                "content": "# Code\\n```\\npublic class Graph\\n{\\n    private readonly List<List<int[]>> _g;\\n\\n    public Graph(int n, int[][] edges)\\n    {\\n        _g = new List<List<int[]>>();\\n\\n        for (var i = 0; i < n; i++)\\n            _g.Add(new List<int[]>());\\n\\n        foreach (var e in edges)\\n            _g[e[0]].Add(new[] { e[1], e[2] });\\n    }\\n\\n    public void AddEdge(int[] e)\\n    {\\n        _g[e[0]].Add(new[] { e[1], e[2] });\\n    }\\n\\n    public int ShortestPath(int node1, int node2)\\n    {\\n        var pq = new PriorityQueue<int[], int[]>(Comparer<int[]>.Create((a, b) => b[0].CompareTo(a[0])));\\n        var cost = new int[_g.Count];\\n\\n        for (var i = 0; i < _g.Count; i++)\\n            cost[i] = int.MaxValue;\\n\\n        cost[node1] = 0;\\n        pq.Enqueue(new[] { 0, node1 }, new[] { 0, node1 });\\n\\n        while (pq.Count > 0 && pq.Peek()[1] != node2)\\n        {\\n            var cur = pq.Dequeue();\\n            var nc = cur[0];\\n            var i = cur[1];\\n\\n            foreach (var next in _g[i])\\n            {\\n                var j = next[0];\\n                var c = next[1];\\n\\n                if (-nc + c >= cost[j])\\n                    continue;\\n\\n                cost[j] = -nc + c;\\n                pq.Enqueue(new[] { nc - c, j }, new[] { nc - c, j });\\n            }\\n        }\\n\\n        return cost[node2] == int.MaxValue ? -1 : cost[node2];\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Graph\\n{\\n    private readonly List<List<int[]>> _g;\\n\\n    public Graph(int n, int[][] edges)\\n    {\\n        _g = new List<List<int[]>>();\\n\\n        for (var i = 0; i < n; i++)\\n            _g.Add(new List<int[]>());\\n\\n        foreach (var e in edges)\\n            _g[e[0]].Add(new[] { e[1], e[2] });\\n    }\\n\\n    public void AddEdge(int[] e)\\n    {\\n        _g[e[0]].Add(new[] { e[1], e[2] });\\n    }\\n\\n    public int ShortestPath(int node1, int node2)\\n    {\\n        var pq = new PriorityQueue<int[], int[]>(Comparer<int[]>.Create((a, b) => b[0].CompareTo(a[0])));\\n        var cost = new int[_g.Count];\\n\\n        for (var i = 0; i < _g.Count; i++)\\n            cost[i] = int.MaxValue;\\n\\n        cost[node1] = 0;\\n        pq.Enqueue(new[] { 0, node1 }, new[] { 0, node1 });\\n\\n        while (pq.Count > 0 && pq.Peek()[1] != node2)\\n        {\\n            var cur = pq.Dequeue();\\n            var nc = cur[0];\\n            var i = cur[1];\\n\\n            foreach (var next in _g[i])\\n            {\\n                var j = next[0];\\n                var c = next[1];\\n\\n                if (-nc + c >= cost[j])\\n                    continue;\\n\\n                cost[j] = -nc + c;\\n                pq.Enqueue(new[] { nc - c, j }, new[] { nc - c, j });\\n            }\\n        }\\n\\n        return cost[node2] == int.MaxValue ? -1 : cost[node2];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420315,
                "title": "dijkstra-s",
                "content": "```\\nclass Graph {\\npublic:\\n    int v;\\n    vector<vector<pair<int,int>>>adj;\\n    Graph(int n, vector<vector<int>>& edges) {\\n        v = n;\\n        adj.resize(v);\\n        for(auto it:edges)\\n        {\\n            adj[it[0]].push_back({it[1], it[2]});\\n        }\\n    }\\n    void addEdge(vector<int> edge) {\\n        adj[edge[0]].push_back({edge[1], edge[2]});\\n    }\\n    \\n    int shortestPath(int node1, int node2) {\\n        priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>>pq;\\n        pq.push({0, node1});\\n        vector<int>dist(v, 1e9);\\n        dist[node1] = 0;\\n        while(pq.size())\\n        {\\n            int node = pq.top().second, wt = pq.top().first;\\n            pq.pop();\\n            for(auto it:adj[node])\\n            {\\n                int adjNode = it.first, edgewt = it.second;\\n                if(dist[adjNode] > wt+edgewt) {\\n                    dist[adjNode] = wt+edgewt;\\n                    pq.push({dist[adjNode], adjNode});\\n                }\\n            }\\n        }\\n        return dist[node2] == 1e9?-1:dist[node2];\\n        // return 0;\\n    }\\n};\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph* obj = new Graph(n, edges);\\n * obj->addEdge(edge);\\n * int param_2 = obj->shortestPath(node1,node2);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass Graph {\\npublic:\\n    int v;\\n    vector<vector<pair<int,int>>>adj;\\n    Graph(int n, vector<vector<int>>& edges) {\\n        v = n;\\n        adj.resize(v);\\n        for(auto it:edges)\\n        {\\n            adj[it[0]].push_back({it[1], it[2]});\\n        }\\n    }\\n    void addEdge(vector<int> edge) {\\n        adj[edge[0]].push_back({edge[1], edge[2]});\\n    }\\n    \\n    int shortestPath(int node1, int node2) {\\n        priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>>pq;\\n        pq.push({0, node1});\\n        vector<int>dist(v, 1e9);\\n        dist[node1] = 0;\\n        while(pq.size())\\n        {\\n            int node = pq.top().second, wt = pq.top().first;\\n            pq.pop();\\n            for(auto it:adj[node])\\n            {\\n                int adjNode = it.first, edgewt = it.second;\\n                if(dist[adjNode] > wt+edgewt) {\\n                    dist[adjNode] = wt+edgewt;\\n                    pq.push({dist[adjNode], adjNode});\\n                }\\n            }\\n        }\\n        return dist[node2] == 1e9?-1:dist[node2];\\n        // return 0;\\n    }\\n};\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph* obj = new Graph(n, edges);\\n * obj->addEdge(edge);\\n * int param_2 = obj->shortestPath(node1,node2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420295,
                "title": "simple-dijkstra-python",
                "content": "# Approach\\nGiven the constraints (n <= 100), we can just use dijkstra\\'s algorithm to solve it.\\n\\n# Complexity\\n- Time complexity: O(n log n) for each shortestPath(), O(1) for each addEdge()\\n\\n# Code\\n```\\nclass Graph:\\n\\n    def __init__(self, n: int, edges: List[List[int]]):\\n        self.n = n\\n        self.adj = [[] for _ in range(n)]\\n        for u, v, weight in edges:\\n            self.adj[u].append((v, weight))\\n        \\n    def addEdge(self, edge: List[int]) -> None:\\n        u, v, weight = edge\\n        self.adj[u].append((v, weight))\\n        \\n    def shortestPath(self, node1: int, node2: int) -> int:\\n        inf = float(\\'inf\\')\\n        dist = [inf] * self.n\\n        dist[node1] = 0\\n        h = [(0, node1)]\\n        while len(h):\\n            cost, vertex = heapq.heappop(h)\\n            dist[vertex] = cost\\n            if vertex == node2:\\n                return cost\\n            for nei, weight in self.adj[vertex]:\\n                if dist[nei] > dist[vertex] + weight:\\n                    dist[nei] = dist[vertex] + weight\\n                    heapq.heappush(h, (dist[vertex] + weight, nei))\\n        return -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Graph:\\n\\n    def __init__(self, n: int, edges: List[List[int]]):\\n        self.n = n\\n        self.adj = [[] for _ in range(n)]\\n        for u, v, weight in edges:\\n            self.adj[u].append((v, weight))\\n        \\n    def addEdge(self, edge: List[int]) -> None:\\n        u, v, weight = edge\\n        self.adj[u].append((v, weight))\\n        \\n    def shortestPath(self, node1: int, node2: int) -> int:\\n        inf = float(\\'inf\\')\\n        dist = [inf] * self.n\\n        dist[node1] = 0\\n        h = [(0, node1)]\\n        while len(h):\\n            cost, vertex = heapq.heappop(h)\\n            dist[vertex] = cost\\n            if vertex == node2:\\n                return cost\\n            for nei, weight in self.adj[vertex]:\\n                if dist[nei] > dist[vertex] + weight:\\n                    dist[nei] = dist[vertex] + weight\\n                    heapq.heappush(h, (dist[vertex] + weight, nei))\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420218,
                "title": "dijkstra-algorithm-straightforward-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor calculating shortest path apply dijkstra algorithm\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1- Create a adjaceny vector of vector to store edges\\n2- Create a distance array to keep the shortest distance of node from source\\n3- resize the adj and dis vector\\n4- in addEdge function store the edge in adj\\n5- in the shortestPath function apply dijkstra from node1 as source node\\n# Code\\n```\\nclass Graph {\\npublic:\\n vector<vector<pair<int,int>>>adj;\\n    vector<int>d;\\n    Graph(int n, vector<vector<int>>& edges) \\n    {\\n        d.resize(n);\\n        adj.resize(n);\\n        for(auto it:edges)\\n        {\\n            adj[it[0]].push_back({it[1],it[2]});  \\n        }\\n    }\\n    \\n    void addEdge(vector<int> edge) \\n    {\\n        adj[edge[0]].push_back({edge[1],edge[2]});\\n    }\\n    \\n    int shortestPath(int node1, int node2) \\n    {\\n        for(int i=0;i<d.size();i++)\\n        {\\n            d[i]=INT_MAX;\\n        }\\n        d[node1]=0;\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pq;\\n        pq.push({0,node1});\\n        while(!pq.empty())\\n        {\\n            int node=pq.top().second;\\n            int dis=pq.top().first;\\n            pq.pop();\\n            if(node==node2)\\n                return d[node];\\n            if(dis>d[node])\\n                continue;\\n            for(auto it:adj[node])\\n            {\\n                int e1=it.first;\\n                int w1=it.second;\\n                if(d[node]+w1<d[e1])\\n                {\\n                    d[e1]=d[node]+w1;\\n                    pq.push({d[e1],e1});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph* obj = new Graph(n, edges);\\n * obj->addEdge(edge);\\n * int param_2 = obj->shortestPath(node1,node2);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Graph {\\npublic:\\n vector<vector<pair<int,int>>>adj;\\n    vector<int>d;\\n    Graph(int n, vector<vector<int>>& edges) \\n    {\\n        d.resize(n);\\n        adj.resize(n);\\n        for(auto it:edges)\\n        {\\n            adj[it[0]].push_back({it[1],it[2]});  \\n        }\\n    }\\n    \\n    void addEdge(vector<int> edge) \\n    {\\n        adj[edge[0]].push_back({edge[1],edge[2]});\\n    }\\n    \\n    int shortestPath(int node1, int node2) \\n    {\\n        for(int i=0;i<d.size();i++)\\n        {\\n            d[i]=INT_MAX;\\n        }\\n        d[node1]=0;\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pq;\\n        pq.push({0,node1});\\n        while(!pq.empty())\\n        {\\n            int node=pq.top().second;\\n            int dis=pq.top().first;\\n            pq.pop();\\n            if(node==node2)\\n                return d[node];\\n            if(dis>d[node])\\n                continue;\\n            for(auto it:adj[node])\\n            {\\n                int e1=it.first;\\n                int w1=it.second;\\n                if(d[node]+w1<d[e1])\\n                {\\n                    d[e1]=d[node]+w1;\\n                    pq.push({d[e1],e1});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph* obj = new Graph(n, edges);\\n * obj->addEdge(edge);\\n * int param_2 = obj->shortestPath(node1,node2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420215,
                "title": "c-bfs",
                "content": "# Intuition\\nUse BFS algorithm for the 3rd method\\n```\\npublic int ShortestPath(int node1, int node2)\\n```\\n\\n# Approach\\nAdd the the class and initialize in the constructor an extra array with all edges:\\n```\\nprivate List<int[]>[] arr;\\n```\\n```\\nfor (int i = 0; i < edges.Length; i++)\\n{\\n    arr[edges[i][0]].Add(new[] { edges[i][1], edges[i][2] });\\n}\\n```\\nIn the AddEdge just add new edge:\\n```\\narr[edge[0]].Add(new[] { edge[1], edge[2] });\\n```\\nIn the `ShortestPath(int node1, int node2)` method just use BFS algorithm to calculate results for all nodes.\\nRecalculate the result for the certain node if the new result is better (i.e. less), then the previous one:\\n```\\nif (lengths[nextNode] > arr[item][i][1] + lengths[item])\\n{\\n    lengths[nextNode] = arr[item][i][1] + lengths[item];\\n    ...\\n}\\n```\\nAt the end return lengths[node2] or -1, if there is no path.\\n\\n# Complexity\\n- Time complexity:\\n$$O(len(edges))$$ -->\\n\\n- Space complexity:\\n$$O(len(edges))$$\\n\\n# Code\\n```\\npublic class Graph {\\n    private List<int[]>[] arr;\\n    public Graph(int n, int[][] edges) {\\n        arr = new List<int[]>[n];\\n        for (int i = 0; i < n; i++)\\n        {\\n            arr[i] = new List<int[]>();\\n        }\\n        for (int i = 0; i < edges.Length; i++)\\n        {\\n            arr[edges[i][0]].Add(new[] { edges[i][1], edges[i][2] });\\n        }\\n    }\\n    \\n    public void AddEdge(int[] edge) {\\n        arr[edge[0]].Add(new[] { edge[1], edge[2] });\\n    }\\n    \\n    public int ShortestPath(int node1, int node2) {\\n        var set = new HashSet<int> { node1 };\\n        var lengths = new int[arr.Length];\\n        for (int i = 0; i < lengths.Length; i++)\\n        {\\n            lengths[i] = int.MaxValue;\\n        }\\n        lengths[node1] = 0;\\n        while (set.Count > 0)\\n        {\\n            var set2 = new HashSet<int> ();\\n            foreach (var item in set)\\n            {\\n                for (int i = 0; i < arr[item].Count; i++)\\n                {\\n                    var nextNode = arr[item][i][0];\\n                    if (lengths[nextNode] > arr[item][i][1] + lengths[item])\\n                    {\\n                        lengths[nextNode] = arr[item][i][1] + lengths[item];\\n                        set2.Add(nextNode);\\n                    }\\n                }\\n            }\\n            set = set2;\\n        }\\n        return lengths[node2] != int.MaxValue ? lengths[node2] : -1;\\n    }\\n}\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph obj = new Graph(n, edges);\\n * obj.AddEdge(edge);\\n * int param_2 = obj.ShortestPath(node1,node2);\\n */\\n```",
                "solutionTags": [
                    "C#",
                    "Breadth-First Search"
                ],
                "code": "```\\npublic int ShortestPath(int node1, int node2)\\n```\n```\\nprivate List<int[]>[] arr;\\n```\n```\\nfor (int i = 0; i < edges.Length; i++)\\n{\\n    arr[edges[i][0]].Add(new[] { edges[i][1], edges[i][2] });\\n}\\n```\n```\\narr[edge[0]].Add(new[] { edge[1], edge[2] });\\n```\n```\\nif (lengths[nextNode] > arr[item][i][1] + lengths[item])\\n{\\n    lengths[nextNode] = arr[item][i][1] + lengths[item];\\n    ...\\n}\\n```\n```\\npublic class Graph {\\n    private List<int[]>[] arr;\\n    public Graph(int n, int[][] edges) {\\n        arr = new List<int[]>[n];\\n        for (int i = 0; i < n; i++)\\n        {\\n            arr[i] = new List<int[]>();\\n        }\\n        for (int i = 0; i < edges.Length; i++)\\n        {\\n            arr[edges[i][0]].Add(new[] { edges[i][1], edges[i][2] });\\n        }\\n    }\\n    \\n    public void AddEdge(int[] edge) {\\n        arr[edge[0]].Add(new[] { edge[1], edge[2] });\\n    }\\n    \\n    public int ShortestPath(int node1, int node2) {\\n        var set = new HashSet<int> { node1 };\\n        var lengths = new int[arr.Length];\\n        for (int i = 0; i < lengths.Length; i++)\\n        {\\n            lengths[i] = int.MaxValue;\\n        }\\n        lengths[node1] = 0;\\n        while (set.Count > 0)\\n        {\\n            var set2 = new HashSet<int> ();\\n            foreach (var item in set)\\n            {\\n                for (int i = 0; i < arr[item].Count; i++)\\n                {\\n                    var nextNode = arr[item][i][0];\\n                    if (lengths[nextNode] > arr[item][i][1] + lengths[item])\\n                    {\\n                        lengths[nextNode] = arr[item][i][1] + lengths[item];\\n                        set2.Add(nextNode);\\n                    }\\n                }\\n            }\\n            set = set2;\\n        }\\n        return lengths[node2] != int.MaxValue ? lengths[node2] : -1;\\n    }\\n}\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph obj = new Graph(n, edges);\\n * obj.AddEdge(edge);\\n * int param_2 = obj.ShortestPath(node1,node2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420208,
                "title": "implemented-easily",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Graph {\\npublic:\\n    vector<vector<pair<int,int>>>adj;\\n    \\n    Graph(int n, vector<vector<int>>& edges) {\\n        adj.resize(n);\\n        for(auto& edge:edges){\\n            adj[edge[0]].push_back({edge[1],edge[2]});\\n        }\\n        \\n    }\\n    \\n    void addEdge(vector<int> edge) {\\n        if(edge.size()==2){\\n            edge.push_back(0);\\n        }\\n        adj[edge[0]].push_back({edge[1],edge[2]});\\n    }\\n    \\n    int shortestPath(int src, int dest) {\\n    int n = adj.size(); // Number of nodes in the graph\\n    vector<int> dist(n, INT_MAX); // Initialize distances to all nodes as infinity\\n    dist[src] = 0; // Distance from source to itself is 0\\n\\n    // Priority queue to store nodes to be processed, ordered by distance\\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\\n    pq.push({0, src});\\n\\n    while (!pq.empty()) {\\n        int u = pq.top().second; // Extract the node with minimum distance\\n        pq.pop();\\n\\n        // Iterate over all adjacent nodes of u\\n        for (auto& edge : adj[u]) {\\n            int v = edge.first; // Adjacent node\\n            int weight = edge.second; // Weight of the edge from u to v\\n\\n            // If a shorter path is found from src to v passing through u\\n            if (dist[u] + weight < dist[v]) {\\n                dist[v] = dist[u] + weight; // Update the distance\\n                pq.push({dist[v], v}); // Push v into the priority queue for further processing\\n            }\\n        }\\n    }\\n\\n    if(dist[dest]==INT_MAX) return -1;\\n        else return dist[dest]; \\n    }\\n};\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph* obj = new Graph(n, edges);\\n * obj->addEdge(edge);\\n * int param_2 = obj->shortestPath(node1,node2);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Graph {\\npublic:\\n    vector<vector<pair<int,int>>>adj;\\n    \\n    Graph(int n, vector<vector<int>>& edges) {\\n        adj.resize(n);\\n        for(auto& edge:edges){\\n            adj[edge[0]].push_back({edge[1],edge[2]});\\n        }\\n        \\n    }\\n    \\n    void addEdge(vector<int> edge) {\\n        if(edge.size()==2){\\n            edge.push_back(0);\\n        }\\n        adj[edge[0]].push_back({edge[1],edge[2]});\\n    }\\n    \\n    int shortestPath(int src, int dest) {\\n    int n = adj.size(); // Number of nodes in the graph\\n    vector<int> dist(n, INT_MAX); // Initialize distances to all nodes as infinity\\n    dist[src] = 0; // Distance from source to itself is 0\\n\\n    // Priority queue to store nodes to be processed, ordered by distance\\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\\n    pq.push({0, src});\\n\\n    while (!pq.empty()) {\\n        int u = pq.top().second; // Extract the node with minimum distance\\n        pq.pop();\\n\\n        // Iterate over all adjacent nodes of u\\n        for (auto& edge : adj[u]) {\\n            int v = edge.first; // Adjacent node\\n            int weight = edge.second; // Weight of the edge from u to v\\n\\n            // If a shorter path is found from src to v passing through u\\n            if (dist[u] + weight < dist[v]) {\\n                dist[v] = dist[u] + weight; // Update the distance\\n                pq.push({dist[v], v}); // Push v into the priority queue for further processing\\n            }\\n        }\\n    }\\n\\n    if(dist[dest]==INT_MAX) return -1;\\n        else return dist[dest]; \\n    }\\n};\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph* obj = new Graph(n, edges);\\n * obj->addEdge(edge);\\n * int param_2 = obj->shortestPath(node1,node2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420201,
                "title": "java-bfs",
                "content": "\\n\\n# Code\\n```\\nclass Graph {\\n    \\n    List<MyPath>[] allPaths;\\n    int level;\\n\\n    public Graph(int n, int[][] edges) {\\n        allPaths = new ArrayList[n];\\n        level = n;\\n        for(int[] edge : edges){\\n            int from = edge[0];\\n            if(allPaths[from] == null)\\n                allPaths[from] = new ArrayList<>();\\n            allPaths[from].add(new MyPath(edge[1], edge[2]));\\n        }\\n    }\\n    \\n    public void addEdge(int[] edge) {\\n        int from = edge[0];\\n        if(allPaths[from] == null)\\n            allPaths[from] = new ArrayList<>();\\n        allPaths[from].add(new MyPath(edge[1], edge[2]));\\n    }\\n    \\n    public int shortestPath(int node1, int node2) {\\n\\n        Queue<MyPath> q = new LinkedList<>();\\n        int[] distance = new int[level];\\n        \\n        q.add(new MyPath(node1, 0));\\n        int res = Integer.MAX_VALUE;\\n        \\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            for(int i = 0; i < size; i++){\\n                MyPath node = q.poll();\\n                if(node.getDst() == node2){\\n                    res = Math.min(res, node.getCost());\\n                    continue;\\n                }\\n                int cur = node.getDst();\\n                if(allPaths[cur] != null){\\n                    for(MyPath neighbor : allPaths[cur]){\\n                      if(distance[neighbor.getDst()] != 0 && neighbor.getCost() + node.getCost() > distance[neighbor.getDst()])\\n                            continue;\\n                        distance[neighbor.getDst()] = neighbor.getCost() + node.getCost();\\n                        q.add(new MyPath(neighbor.getDst(), neighbor.getCost() + node.getCost()));\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return res == Integer.MAX_VALUE ? -1 : res;\\n    }\\n}\\n\\nclass MyPath{\\n    int dst;\\n    int cost;\\n    \\n    MyPath(final int dst, final int cost){\\n        this.dst = dst;\\n        this.cost = cost;\\n    }\\n    \\n    public int getDst(){\\n        return this.dst;\\n    }\\n    \\n    public int getCost(){\\n        return this.cost;\\n    }\\n}\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph obj = new Graph(n, edges);\\n * obj.addEdge(edge);\\n * int param_2 = obj.shortestPath(node1,node2);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Graph {\\n    \\n    List<MyPath>[] allPaths;\\n    int level;\\n\\n    public Graph(int n, int[][] edges) {\\n        allPaths = new ArrayList[n];\\n        level = n;\\n        for(int[] edge : edges){\\n            int from = edge[0];\\n            if(allPaths[from] == null)\\n                allPaths[from] = new ArrayList<>();\\n            allPaths[from].add(new MyPath(edge[1], edge[2]));\\n        }\\n    }\\n    \\n    public void addEdge(int[] edge) {\\n        int from = edge[0];\\n        if(allPaths[from] == null)\\n            allPaths[from] = new ArrayList<>();\\n        allPaths[from].add(new MyPath(edge[1], edge[2]));\\n    }\\n    \\n    public int shortestPath(int node1, int node2) {\\n\\n        Queue<MyPath> q = new LinkedList<>();\\n        int[] distance = new int[level];\\n        \\n        q.add(new MyPath(node1, 0));\\n        int res = Integer.MAX_VALUE;\\n        \\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            for(int i = 0; i < size; i++){\\n                MyPath node = q.poll();\\n                if(node.getDst() == node2){\\n                    res = Math.min(res, node.getCost());\\n                    continue;\\n                }\\n                int cur = node.getDst();\\n                if(allPaths[cur] != null){\\n                    for(MyPath neighbor : allPaths[cur]){\\n                      if(distance[neighbor.getDst()] != 0 && neighbor.getCost() + node.getCost() > distance[neighbor.getDst()])\\n                            continue;\\n                        distance[neighbor.getDst()] = neighbor.getCost() + node.getCost();\\n                        q.add(new MyPath(neighbor.getDst(), neighbor.getCost() + node.getCost()));\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return res == Integer.MAX_VALUE ? -1 : res;\\n    }\\n}\\n\\nclass MyPath{\\n    int dst;\\n    int cost;\\n    \\n    MyPath(final int dst, final int cost){\\n        this.dst = dst;\\n        this.cost = cost;\\n    }\\n    \\n    public int getDst(){\\n        return this.dst;\\n    }\\n    \\n    public int getCost(){\\n        return this.cost;\\n    }\\n}\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph obj = new Graph(n, edges);\\n * obj.addEdge(edge);\\n * int param_2 = obj.shortestPath(node1,node2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420186,
                "title": "can-we-use-floyd-warshall-algorithm-to-solve-this-problem",
                "content": "When adding the edge (u, v), I would find all vertices a and b such that a path between (a,u) exists and one between (v, b) exists. Then I would try to set distance[a][b] = min(distance[a][b], distance[a][u]+edge_cost+distance[v][b]).\\n\\nTo find the shortest path between u and v, I would simply return distancec[u][v] if it is not infinite.\\n\\nThis logic makes sense to me but it looks like some distances may not be updated. My code is currently not running for certain testcases.\\n\\n\\tclass Graph:\\n\\n    def __init__(self, n: int, edges: List[List[int]]):\\n        self.n = n\\n        self.distances = [[float(\\'inf\\') for j in range(n)] for i in range(n)]\\n                \\n        for i in range(n):\\n            self.distances[i][i] = 0\\n            \\n        for e in edges:\\n            self.distances[e[0]][e[1]] = e[2]\\n            \\n        for i in range(n):\\n            for j in range(n):\\n                self.compute(i, j)\\n                \\n        #print(\\'distances is\\', self.distances)\\n\\n    def compute(self, u, v):\\n        for k in range(self.n):\\n            if self.distances[u][k] != float(\\'inf\\') and self.distances[k][v] != float(\\'inf\\'):\\n                self.distances[u][v] = min(self.distances[u][v], self.distances[u][k]+self.distances[k][v])\\n        return\\n        \\n    def find_connected_to(self, u):\\n        connected = []\\n        for i in range(self.n):\\n            if self.distances[i][u] != float(\\'inf\\'):\\n                connected.append(i)\\n        return connected\\n    \\n    def find_connected_from(self, v):\\n        connected = []\\n        for i in range(self.n):\\n            if self.distances[v][i] != float(\\'inf\\'):\\n                connected.append(i)\\n        return connected\\n            \\n    def addEdge(self, edge: List[int]) -> None:\\n        u, v, cost = edge[0], edge[1], edge[2]\\n        #print(\\'adding edge\\', u, v, cost)\\n        \\n        self.distances[u][v] = cost # edge does not exist prior to this\\n\\n        connected_u = self.find_connected_to(u)\\n        connected_v = self.find_connected_from(v)\\n        #print(\\'cu cv\\', connected_u, connected_v, self.distances)\\n    \\n        for a in connected_u:\\n            for b in connected_v:\\n                #print(a, b, self.distances[a][b], self.distances[a][u], self.distances[v][b], cost)\\n                if self.distances[a][b] > self.distances[a][u]+cost+self.distances[v][b]:\\n                    #print(\\'hit\\')\\n                    self.distances[a][b] = self.distances[a][u]+cost+self.distances[v][b]\\n        return\\n\\n    def shortestPath(self, node1: int, node2: int) -> int:\\n        #print(\\'shortest path\\', node1, node2, self.distances[node1][node2])\\n        self.compute(node1, node2)\\n        if self.distances[node1][node2] == float(\\'inf\\'):\\n            return -1\\n        return self.distances[node1][node2]",
                "solutionTags": [],
                "code": "When adding the edge (u, v), I would find all vertices a and b such that a path between (a,u) exists and one between (v, b) exists. Then I would try to set distance[a][b] = min(distance[a][b], distance[a][u]+edge_cost+distance[v][b]).\\n\\nTo find the shortest path between u and v, I would simply return distancec[u][v] if it is not infinite.\\n\\nThis logic makes sense to me but it looks like some distances may not be updated. My code is currently not running for certain testcases.\\n\\n\\tclass Graph:\\n\\n    def __init__(self, n: int, edges: List[List[int]]):\\n        self.n = n\\n        self.distances = [[float(\\'inf\\') for j in range(n)] for i in range(n)]\\n                \\n        for i in range(n):\\n            self.distances[i][i] = 0\\n            \\n        for e in edges:\\n            self.distances[e[0]][e[1]] = e[2]\\n            \\n        for i in range(n):\\n            for j in range(n):\\n                self.compute(i, j)\\n                \\n        #print(\\'distances is\\', self.distances)\\n\\n    def compute(self, u, v):\\n        for k in range(self.n):\\n            if self.distances[u][k] != float(\\'inf\\') and self.distances[k][v] != float(\\'inf\\'):\\n                self.distances[u][v] = min(self.distances[u][v], self.distances[u][k]+self.distances[k][v])\\n        return\\n        \\n    def find_connected_to(self, u):\\n        connected = []\\n        for i in range(self.n):\\n            if self.distances[i][u] != float(\\'inf\\'):\\n                connected.append(i)\\n        return connected\\n    \\n    def find_connected_from(self, v):\\n        connected = []\\n        for i in range(self.n):\\n            if self.distances[v][i] != float(\\'inf\\'):\\n                connected.append(i)\\n        return connected\\n            \\n    def addEdge(self, edge: List[int]) -> None:\\n        u, v, cost = edge[0], edge[1], edge[2]\\n        #print(\\'adding edge\\', u, v, cost)\\n        \\n        self.distances[u][v] = cost # edge does not exist prior to this\\n\\n        connected_u = self.find_connected_to(u)\\n        connected_v = self.find_connected_from(v)\\n        #print(\\'cu cv\\', connected_u, connected_v, self.distances)\\n    \\n        for a in connected_u:\\n            for b in connected_v:\\n                #print(a, b, self.distances[a][b], self.distances[a][u], self.distances[v][b], cost)\\n                if self.distances[a][b] > self.distances[a][u]+cost+self.distances[v][b]:\\n                    #print(\\'hit\\')\\n                    self.distances[a][b] = self.distances[a][u]+cost+self.distances[v][b]\\n        return\\n\\n    def shortestPath(self, node1: int, node2: int) -> int:\\n        #print(\\'shortest path\\', node1, node2, self.distances[node1][node2])\\n        self.compute(node1, node2)\\n        if self.distances[node1][node2] == float(\\'inf\\'):\\n            return -1\\n        return self.distances[node1][node2]",
                "codeTag": "Java"
            },
            {
                "id": 3420184,
                "title": "c-easy-understanding-dijkstra-solution",
                "content": "\\n\\n# Approach\\nSimple Dijkstra algorithm \\n\\n\\n\\n\\n\\n# Code\\n```\\nclass Graph {\\npublic:\\n    vector<vector<pair<int,int>>>adj;\\n    Graph(int n, vector<vector<int>>& edges) {\\n        adj.resize(n);\\n        \\n        for( auto i: edges){\\n            adj[i[0]].push_back({i[1],i[2]});\\n        }\\n    }\\n    \\n    void addEdge(vector<int> edge) {\\n        adj[edge[0]].push_back({edge[1],edge[2]});\\n    }\\n    \\n    int shortestPath(int n1, int n2) {\\n        \\n        int n= adj.size();\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pq;\\n        \\n        \\n        vector<int>dis(n,INT_MAX);\\n        dis[n1]=0;\\n        pq.push({n1,0});\\n        \\n        while(!pq.empty()){\\n            int x= pq.top().first;\\n            int d= pq.top().second;\\n            \\n            pq.pop();\\n            \\n            for(auto i: adj[x]){\\n                int w= i.second;\\n                int j= i.first;\\n                if(dis[x]+w<dis[j]){\\n                    pq.push({j,dis[x]+w});\\n                    dis[j]=dis[x]+w;\\n                }\\n            }\\n        }\\n        \\n        if(dis[n2]!=INT_MAX){\\n            return dis[n2];\\n        }\\n        return -1;\\n        \\n        \\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Graph {\\npublic:\\n    vector<vector<pair<int,int>>>adj;\\n    Graph(int n, vector<vector<int>>& edges) {\\n        adj.resize(n);\\n        \\n        for( auto i: edges){\\n            adj[i[0]].push_back({i[1],i[2]});\\n        }\\n    }\\n    \\n    void addEdge(vector<int> edge) {\\n        adj[edge[0]].push_back({edge[1],edge[2]});\\n    }\\n    \\n    int shortestPath(int n1, int n2) {\\n        \\n        int n= adj.size();\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pq;\\n        \\n        \\n        vector<int>dis(n,INT_MAX);\\n        dis[n1]=0;\\n        pq.push({n1,0});\\n        \\n        while(!pq.empty()){\\n            int x= pq.top().first;\\n            int d= pq.top().second;\\n            \\n            pq.pop();\\n            \\n            for(auto i: adj[x]){\\n                int w= i.second;\\n                int j= i.first;\\n                if(dis[x]+w<dis[j]){\\n                    pq.push({j,dis[x]+w});\\n                    dis[j]=dis[x]+w;\\n                }\\n            }\\n        }\\n        \\n        if(dis[n2]!=INT_MAX){\\n            return dis[n2];\\n        }\\n        return -1;\\n        \\n        \\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420164,
                "title": "c-simple-dijkstra",
                "content": "\\nOnly one thing we need to keep in mind:\\n1)After dequeing an element we need to check if after queueing this element we had found a shorter distance;\\notherwise it is just a plain bfs.\\n```\\nclass Graph {\\npublic:\\n    vector<vector<pair<int,int>>> graph;\\n    Graph(int n, vector<vector<int>>& edges) {\\n        graph.resize(n,vector<pair<int,int>>());\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            graph[edges[i][0]].push_back({edges[i][1],edges[i][2]});\\n        }\\n    }\\n    \\n    void addEdge(vector<int> edge) {\\n        graph[edge[0]].push_back({edge[1],edge[2]});\\n    }\\n    \\n    int shortestPath(int node1, int node2) {\\n        vector<int> distance(graph.size(),INT_MAX);\\n        distance[node1]=0;\\n        queue<pair<int,int>> q;\\n        q.push({node1,0});\\n        while(q.size()!=0)\\n        {\\n            pair<int,int> temp=q.front();\\n            q.pop();\\n            if(distance[temp.first]<temp.second)continue;\\n            for(int i=0;i<graph[temp.first].size();i++)\\n            {\\n                int new_distance=distance[temp.first]+graph[temp.first][i].second;\\n                if(new_distance>=distance[graph[temp.first][i].first])continue;\\n                distance[graph[temp.first][i].first]=new_distance;\\n                q.push({graph[temp.first][i].first,new_distance});\\n            }\\n        }\\n        return  distance[node2]==INT_MAX?-1:distance[node2];\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Graph {\\npublic:\\n    vector<vector<pair<int,int>>> graph;\\n    Graph(int n, vector<vector<int>>& edges) {\\n        graph.resize(n,vector<pair<int,int>>());\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            graph[edges[i][0]].push_back({edges[i][1],edges[i][2]});\\n        }\\n    }\\n    \\n    void addEdge(vector<int> edge) {\\n        graph[edge[0]].push_back({edge[1],edge[2]});\\n    }\\n    \\n    int shortestPath(int node1, int node2) {\\n        vector<int> distance(graph.size(),INT_MAX);\\n        distance[node1]=0;\\n        queue<pair<int,int>> q;\\n        q.push({node1,0});\\n        while(q.size()!=0)\\n        {\\n            pair<int,int> temp=q.front();\\n            q.pop();\\n            if(distance[temp.first]<temp.second)continue;\\n            for(int i=0;i<graph[temp.first].size();i++)\\n            {\\n                int new_distance=distance[temp.first]+graph[temp.first][i].second;\\n                if(new_distance>=distance[graph[temp.first][i].first])continue;\\n                distance[graph[temp.first][i].first]=new_distance;\\n                q.push({graph[temp.first][i].first,new_distance});\\n            }\\n        }\\n        return  distance[node2]==INT_MAX?-1:distance[node2];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420157,
                "title": "djikstra",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nthis is a shortest path problem, so, djikstra algorithm will work here\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nsimple djikstra\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Graph {\\npublic:\\n    vector<vector<pair<int, int>>>adj;\\n    int n;\\n    Graph(int n, vector<vector<int>>& edges) {\\n        adj.resize(n, vector<pair<int, int>>());\\n        for(auto &it: edges){\\n            adj[it[0]].push_back({it[1], it[2]}); //node, cost\\n        }\\n        this->n=n;\\n    }\\n    \\n    void addEdge(vector<int> edge) {\\n        adj[edge[0]].push_back({edge[1], edge[2]});\\n    }\\n    \\n    int shortestPath(int node1, int node2) {\\n        vector<int>dis(n, INT_MAX);\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>>q; //dis, node\\n        q.push({0, node1});\\n        dis[node1]=0;\\n        while(!q.empty()){\\n            int dist=q.top().first;\\n            int node=q.top().second;\\n            q.pop();\\n            if(dis[node]!=dist)continue;\\n            for(auto &it: adj[node]){\\n                if(dist+it.second < dis[it.first]){\\n                    dis[it.first]=dist+it.second;\\n                    q.push({dis[it.first], it.first});\\n                }\\n            }\\n        }\\n        if(dis[node2]==INT_MAX)return -1;\\n        return dis[node2];\\n    }\\n};\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph* obj = new Graph(n, edges);\\n * obj->addEdge(edge);\\n * int param_2 = obj->shortestPath(node1,node2);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Graph {\\npublic:\\n    vector<vector<pair<int, int>>>adj;\\n    int n;\\n    Graph(int n, vector<vector<int>>& edges) {\\n        adj.resize(n, vector<pair<int, int>>());\\n        for(auto &it: edges){\\n            adj[it[0]].push_back({it[1], it[2]}); //node, cost\\n        }\\n        this->n=n;\\n    }\\n    \\n    void addEdge(vector<int> edge) {\\n        adj[edge[0]].push_back({edge[1], edge[2]});\\n    }\\n    \\n    int shortestPath(int node1, int node2) {\\n        vector<int>dis(n, INT_MAX);\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>>q; //dis, node\\n        q.push({0, node1});\\n        dis[node1]=0;\\n        while(!q.empty()){\\n            int dist=q.top().first;\\n            int node=q.top().second;\\n            q.pop();\\n            if(dis[node]!=dist)continue;\\n            for(auto &it: adj[node]){\\n                if(dist+it.second < dis[it.first]){\\n                    dis[it.first]=dist+it.second;\\n                    q.push({dis[it.first], it.first});\\n                }\\n            }\\n        }\\n        if(dis[node2]==INT_MAX)return -1;\\n        return dis[node2];\\n    }\\n};\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph* obj = new Graph(n, edges);\\n * obj->addEdge(edge);\\n * int param_2 = obj->shortestPath(node1,node2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420150,
                "title": "python-simple-dijkstra-using-heap-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- build graph\\n- using dist array to save min cost of each node to reach it\\n- if i hit target node save cost and contniue as it may be reached from another place with low cost \\n- if dist[target] is flaot(\"inf) return -1 \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom collections import defaultdict\\nfrom heapq import heappush , heappop\\nclass Graph(object):\\n\\n    def __init__(self, n, edges):\\n        \"\"\"\\n        :type n: int\\n        :type edges: List[List[int]]\\n        \"\"\"\\n        self.graph = defaultdict(list)\\n        self.n=n\\n        for u,v,c in edges:\\n            self.graph[u].append((v,c))\\n\\n    def addEdge(self, edge):\\n        \"\"\"\\n        :type edge: List[int]\\n        :rtype: None\\n        \"\"\"\\n        self.graph[edge[0]].append((edge[1] , edge[2]))\\n        \\n\\n    def shortestPath(self, node1, node2):\\n        \"\"\"\\n        :type node1: int\\n        :type node2: int\\n        :rtype: int\\n        \"\"\"\\n        dist = [float(\"inf\")]*self.n\\n        dist[node1]=0\\n        heap = [[node1,0]]\\n        res=float(\"inf\")\\n        while heap:\\n            node , cost = heappop(heap)\\n            if node ==node2:\\n                res = min(res , cost)\\n            if cost > dist[node]:\\n                continue\\n            for neigh , edge_cost in self.graph[node]:\\n                new_cost=edge_cost + cost\\n                if new_cost < dist[neigh]:\\n                    heappush(heap , (neigh , new_cost))\\n                    dist[neigh] = new_cost\\n        return res if dist[node2]!=float(\"inf\") else -1\\n                    \\n        \\n\\n\\n# Your Graph object will be instantiated and called as such:\\n# obj = Graph(n, edges)\\n# obj.addEdge(edge)\\n# param_2 = obj.shortestPath(node1,node2)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Graph"
                ],
                "code": "```\\nfrom collections import defaultdict\\nfrom heapq import heappush , heappop\\nclass Graph(object):\\n\\n    def __init__(self, n, edges):\\n        \"\"\"\\n        :type n: int\\n        :type edges: List[List[int]]\\n        \"\"\"\\n        self.graph = defaultdict(list)\\n        self.n=n\\n        for u,v,c in edges:\\n            self.graph[u].append((v,c))\\n\\n    def addEdge(self, edge):\\n        \"\"\"\\n        :type edge: List[int]\\n        :rtype: None\\n        \"\"\"\\n        self.graph[edge[0]].append((edge[1] , edge[2]))\\n        \\n\\n    def shortestPath(self, node1, node2):\\n        \"\"\"\\n        :type node1: int\\n        :type node2: int\\n        :rtype: int\\n        \"\"\"\\n        dist = [float(\"inf\")]*self.n\\n        dist[node1]=0\\n        heap = [[node1,0]]\\n        res=float(\"inf\")\\n        while heap:\\n            node , cost = heappop(heap)\\n            if node ==node2:\\n                res = min(res , cost)\\n            if cost > dist[node]:\\n                continue\\n            for neigh , edge_cost in self.graph[node]:\\n                new_cost=edge_cost + cost\\n                if new_cost < dist[neigh]:\\n                    heappush(heap , (neigh , new_cost))\\n                    dist[neigh] = new_cost\\n        return res if dist[node2]!=float(\"inf\") else -1\\n                    \\n        \\n\\n\\n# Your Graph object will be instantiated and called as such:\\n# obj = Graph(n, edges)\\n# obj.addEdge(edge)\\n# param_2 = obj.shortestPath(node1,node2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420149,
                "title": "dijkstra-algorithm",
                "content": "\\n\\n# Code\\n```\\nclass Graph {\\npublic:\\n    vector<vector<pair<int,int>>> adj;\\n    int k;\\n    Graph(int n, vector<vector<int>>& edges) {\\n        int m = edges.size();\\n        k=n;\\n        adj.resize(n);\\n        for(int i=0;i<m;i++){\\n            adj[edges[i][0]].push_back({edges[i][1],edges[i][2]});\\n        }\\n    }\\n    \\n    void addEdge(vector<int> edge) {\\n        adj[edge[0]].push_back({edge[1],edge[2]});\\n    }\\n    \\n    int shortestPath(int node1, int node2) {\\n\\t// Dijkstra\\'s algorithm begins from here\\n\\tpriority_queue<pair<int,int>,vector<pair<int,int> >,greater<pair<int,int>>> pq;\\n\\tvector<int> distTo(k,INT_MAX);\\n\\tdistTo[node1] = 0;\\n\\tpq.push(make_pair(0,node1));\\t// (dist,source)\\n\\twhile( !pq.empty() ){\\n\\t\\tint dist = pq.top().first;\\n\\t\\tint prev = pq.top().second;\\n\\t\\tpq.pop();\\n\\t\\tvector<pair<int,int> >::iterator it;\\n\\t\\tfor( it = adj[prev].begin() ; it != adj[prev].end() ; it++){\\n\\t\\t\\tint next = it->first;\\n\\t\\t\\tint nextDist = it->second;\\n\\t\\t\\tif( distTo[next] > distTo[prev] + nextDist){\\n\\t\\t\\t\\tdistTo[next] = distTo[prev] + nextDist;\\n\\t\\t\\t\\tpq.push(make_pair(distTo[next], next));\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n    int p = distTo[node2];\\n    if(p==INT_MAX){\\n        return -1;\\n    }\\n\\treturn p;\\n    }\\n};\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph* obj = new Graph(n, edges);\\n * obj->addEdge(edge);\\n * int param_2 = obj->shortestPath(node1,node2);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Graph {\\npublic:\\n    vector<vector<pair<int,int>>> adj;\\n    int k;\\n    Graph(int n, vector<vector<int>>& edges) {\\n        int m = edges.size();\\n        k=n;\\n        adj.resize(n);\\n        for(int i=0;i<m;i++){\\n            adj[edges[i][0]].push_back({edges[i][1],edges[i][2]});\\n        }\\n    }\\n    \\n    void addEdge(vector<int> edge) {\\n        adj[edge[0]].push_back({edge[1],edge[2]});\\n    }\\n    \\n    int shortestPath(int node1, int node2) {\\n\\t// Dijkstra\\'s algorithm begins from here\\n\\tpriority_queue<pair<int,int>,vector<pair<int,int> >,greater<pair<int,int>>> pq;\\n\\tvector<int> distTo(k,INT_MAX);\\n\\tdistTo[node1] = 0;\\n\\tpq.push(make_pair(0,node1));\\t// (dist,source)\\n\\twhile( !pq.empty() ){\\n\\t\\tint dist = pq.top().first;\\n\\t\\tint prev = pq.top().second;\\n\\t\\tpq.pop();\\n\\t\\tvector<pair<int,int> >::iterator it;\\n\\t\\tfor( it = adj[prev].begin() ; it != adj[prev].end() ; it++){\\n\\t\\t\\tint next = it->first;\\n\\t\\t\\tint nextDist = it->second;\\n\\t\\t\\tif( distTo[next] > distTo[prev] + nextDist){\\n\\t\\t\\t\\tdistTo[next] = distTo[prev] + nextDist;\\n\\t\\t\\t\\tpq.push(make_pair(distTo[next], next));\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n    int p = distTo[node2];\\n    if(p==INT_MAX){\\n        return -1;\\n    }\\n\\treturn p;\\n    }\\n};\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph* obj = new Graph(n, edges);\\n * obj->addEdge(edge);\\n * int param_2 = obj->shortestPath(node1,node2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420126,
                "title": "easy-java-solution-djikstra-s-algorithm",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBasic djikstra\\'s algorithm to find shortest path\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(ElogV)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Graph {\\n\\n    public class Edge{\\n        int src;\\n        int dest;\\n        int weight;\\n        Edge(int src,int dest, int weight){\\n            this.src = src;\\n            this.dest = dest;\\n            this.weight = weight;\\n        }\\n    }\\n    int len;\\n    ArrayList<Edge>[] al;\\n    public Graph(int n, int[][] edges) {\\n        al = new ArrayList[n];\\n        len = n;\\n        for(int i=0;i<n;i++){\\n            al[i] = new ArrayList<Edge>();\\n        }\\n        for(int[] edge : edges){\\n            al[edge[0]].add(new Edge(edge[0],edge[1],edge[2]));\\n        }\\n    }\\n    \\n    public void addEdge(int[] edge) {\\n        al[edge[0]].add(new Edge(edge[0],edge[1],edge[2]));\\n    }\\n    \\n    public int shortestPath(int node1, int node2) {\\n        PriorityQueue<Edge> pq = new PriorityQueue<>((Edge a,Edge b)->{\\n            return a.weight-b.weight;\\n        });\\n        int[] dist = new int[len];\\n        Arrays.fill(dist, Integer.MAX_VALUE);\\n        dist[node1] = 0;\\n        pq.offer(new Edge(node1, node1, 0));\\n        while (!pq.isEmpty()) {\\n            Edge node = pq.poll();\\n            int u = node.dest;\\n            if (dist[u] < node.weight) continue;\\n            for (Edge neighbor : al[u]) {\\n                int v = neighbor.dest;\\n                int wei = neighbor.weight;\\n                if (dist[v] > dist[u] + wei) {\\n                    dist[v] = dist[u] + wei;\\n                    pq.offer(new Edge(node1, v, dist[v]));\\n                }\\n            }\\n        }\\n        return dist[node2] == Integer.MAX_VALUE ? -1 : dist[node2];\\n    }\\n\\n}",
                "solutionTags": [
                    "Java",
                    "Graph",
                    "Heap (Priority Queue)"
                ],
                "code": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBasic djikstra\\'s algorithm to find shortest path\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(ElogV)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Graph {\\n\\n    public class Edge{\\n        int src;\\n        int dest;\\n        int weight;\\n        Edge(int src,int dest, int weight){\\n            this.src = src;\\n            this.dest = dest;\\n            this.weight = weight;\\n        }\\n    }\\n    int len;\\n    ArrayList<Edge>[] al;\\n    public Graph(int n, int[][] edges) {\\n        al = new ArrayList[n];\\n        len = n;\\n        for(int i=0;i<n;i++){\\n            al[i] = new ArrayList<Edge>();\\n        }\\n        for(int[] edge : edges){\\n            al[edge[0]].add(new Edge(edge[0],edge[1],edge[2]));\\n        }\\n    }\\n    \\n    public void addEdge(int[] edge) {\\n        al[edge[0]].add(new Edge(edge[0],edge[1],edge[2]));\\n    }\\n    \\n    public int shortestPath(int node1, int node2) {\\n        PriorityQueue<Edge> pq = new PriorityQueue<>((Edge a,Edge b)->{\\n            return a.weight-b.weight;\\n        });\\n        int[] dist = new int[len];\\n        Arrays.fill(dist, Integer.MAX_VALUE);\\n        dist[node1] = 0;\\n        pq.offer(new Edge(node1, node1, 0));\\n        while (!pq.isEmpty()) {\\n            Edge node = pq.poll();\\n            int u = node.dest;\\n            if (dist[u] < node.weight) continue;\\n            for (Edge neighbor : al[u]) {\\n                int v = neighbor.dest;\\n                int wei = neighbor.weight;\\n                if (dist[v] > dist[u] + wei) {\\n                    dist[v] = dist[u] + wei;\\n                    pq.offer(new Edge(node1, v, dist[v]));\\n                }\\n            }\\n        }\\n        return dist[node2] == Integer.MAX_VALUE ? -1 : dist[node2];\\n    }\\n\\n}",
                "codeTag": "Java"
            },
            {
                "id": 3420125,
                "title": "c-solution-easy-peasy-lemon-squeezy",
                "content": "```\\n\\nclass Graph {\\npublic:\\n    Graph(int n, vector<vector<int>>& edges) {\\n        adj.resize(n);\\n        for (auto& e : edges) {\\n            adj[e[0]].push_back({e[1], e[2]});\\n        }\\n    }\\n    \\n    void addEdge(vector<int> edge) {\\n        adj[edge[0]].push_back({edge[1], edge[2]});\\n    }\\n    \\n    int shortestPath(int node1, int node2) {\\n        vector<int> dist(adj.size(), numeric_limits<int>::max());\\n        dist[node1] = 0;\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\\n        pq.push({0, node1});\\n        while (!pq.empty()) {\\n            int u = pq.top().second;\\n            pq.pop();\\n            for (auto& v : adj[u]) {\\n                int alt = dist[u] + v.second;\\n                if (alt < dist[v.first]) {\\n                    dist[v.first] = alt;\\n                    pq.push({alt, v.first});\\n                }\\n            }\\n            if (u == node2) {\\n                break;\\n            }\\n        }\\n        return dist[node2] == numeric_limits<int>::max() ? -1 : dist[node2];\\n    }\\n    \\nprivate:\\n    vector<vector<pair<int, int>>> adj;\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Graph"
                ],
                "code": "```\\n\\nclass Graph {\\npublic:\\n    Graph(int n, vector<vector<int>>& edges) {\\n        adj.resize(n);\\n        for (auto& e : edges) {\\n            adj[e[0]].push_back({e[1], e[2]});\\n        }\\n    }\\n    \\n    void addEdge(vector<int> edge) {\\n        adj[edge[0]].push_back({edge[1], edge[2]});\\n    }\\n    \\n    int shortestPath(int node1, int node2) {\\n        vector<int> dist(adj.size(), numeric_limits<int>::max());\\n        dist[node1] = 0;\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\\n        pq.push({0, node1});\\n        while (!pq.empty()) {\\n            int u = pq.top().second;\\n            pq.pop();\\n            for (auto& v : adj[u]) {\\n                int alt = dist[u] + v.second;\\n                if (alt < dist[v.first]) {\\n                    dist[v.first] = alt;\\n                    pq.push({alt, v.first});\\n                }\\n            }\\n            if (u == node2) {\\n                break;\\n            }\\n        }\\n        return dist[node2] == numeric_limits<int>::max() ? -1 : dist[node2];\\n    }\\n    \\nprivate:\\n    vector<vector<pair<int, int>>> adj;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420123,
                "title": "python-easy-to-understand-solution-dijsktra-explained",
                "content": "# Approach\\nThe problem is very simple, we only need to calculate the shortest path each time using Dijsktra. I used an Adjacency List to keep track of the edges.\\n\\n\\n# Code\\n```\\nclass Graph:\\n\\n    def __init__(self, n: int, edges: List[List[int]]):\\n        self.__n = n\\n        self.__adjL = [ list() for _ in range(n) ]\\n        \\n        for edge in edges:\\n            self.__adjL[edge[0]].append([edge[1],edge[2]])\\n\\n    def addEdge(self, edge: List[int]) -> None:\\n        self.__adjL[edge[0]].append([edge[1],edge[2]])\\n\\n    def shortestPath(self, node1: int, node2: int) -> int:\\n        adjL = self.__adjL\\n        \\n        visited = [ False for _ in range(self.__n) ]\\n        \\n        heap = []\\n        heap.append([0, node1])\\n        \\n        while heap:\\n            dist, cur = heapq.heappop(heap)\\n            \\n            if visited[cur]:\\n                continue\\n            \\n            visited[cur] = True\\n            \\n            if cur == node2:\\n                return dist\\n            \\n            for nextNode, weight in adjL[cur]:\\n                if not visited[nextNode]:\\n                    heapq.heappush(heap, [weight+dist, nextNode])\\n        \\n        return -1\\n\\n\\n# Your Graph object will be instantiated and called as such:\\n# obj = Graph(n, edges)\\n# obj.addEdge(edge)\\n# param_2 = obj.shortestPath(node1,node2)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Graph:\\n\\n    def __init__(self, n: int, edges: List[List[int]]):\\n        self.__n = n\\n        self.__adjL = [ list() for _ in range(n) ]\\n        \\n        for edge in edges:\\n            self.__adjL[edge[0]].append([edge[1],edge[2]])\\n\\n    def addEdge(self, edge: List[int]) -> None:\\n        self.__adjL[edge[0]].append([edge[1],edge[2]])\\n\\n    def shortestPath(self, node1: int, node2: int) -> int:\\n        adjL = self.__adjL\\n        \\n        visited = [ False for _ in range(self.__n) ]\\n        \\n        heap = []\\n        heap.append([0, node1])\\n        \\n        while heap:\\n            dist, cur = heapq.heappop(heap)\\n            \\n            if visited[cur]:\\n                continue\\n            \\n            visited[cur] = True\\n            \\n            if cur == node2:\\n                return dist\\n            \\n            for nextNode, weight in adjL[cur]:\\n                if not visited[nextNode]:\\n                    heapq.heappush(heap, [weight+dist, nextNode])\\n        \\n        return -1\\n\\n\\n# Your Graph object will be instantiated and called as such:\\n# obj = Graph(n, edges)\\n# obj.addEdge(edge)\\n# param_2 = obj.shortestPath(node1,node2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420084,
                "title": "dijkstra-c-easy-simple",
                "content": "```\\nclass Graph {\\npublic:\\n   \\n    int dijkstra(int start,int dst,vector<pair<int,int>> adj[],int n){\\n        set<pair<int,int>> st;\\n        st.insert({0,start});\\n    vector<int> dis(n,INT_MAX);\\n        dis[start]=0;\\n        while(st.size()>0){\\n            auto temp=*(st.begin());\\n            if(temp.second==dst) return dis[dst];\\n            st.erase(temp);\\n            for(auto it:adj[temp.second]){\\n                if(dis[temp.second]+it.second<dis[it.first]){\\n                    if(dis[it.first]!=INT_MAX){\\n                        st.erase({dis[it.first],it.first});\\n                    }\\n                    dis[it.first]=dis[temp.second]+it.second;\\n                    st.insert({dis[temp.second]+it.second,it.first});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n    int num;\\n    vector<pair<int,int>> adj[101];\\n    Graph(int n, vector<vector<int>>& edges) {\\n        num=n;\\n        vector<pair<int,int>> adj1[101];\\n        for(auto it:edges){\\n            adj1[it[0]].push_back({it[1],it[2]});\\n        }\\n        for(int i=0;i<101;i++){\\n            adj[i]=adj1[i];\\n        }\\n    }\\n    \\n    void addEdge(vector<int> edge) {\\n        adj[edge[0]].push_back({edge[1],edge[2]});\\n    }\\n    \\n    int shortestPath(int node1, int node2) {\\n        return dijkstra(node1,node2,adj,num);\\n    }\\n};\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph* obj = new Graph(n, edges);\\n * obj->addEdge(edge);\\n * int param_2 = obj->shortestPath(node1,node2);\\n */\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Graph {\\npublic:\\n   \\n    int dijkstra(int start,int dst,vector<pair<int,int>> adj[],int n){\\n        set<pair<int,int>> st;\\n        st.insert({0,start});\\n    vector<int> dis(n,INT_MAX);\\n        dis[start]=0;\\n        while(st.size()>0){\\n            auto temp=*(st.begin());\\n            if(temp.second==dst) return dis[dst];\\n            st.erase(temp);\\n            for(auto it:adj[temp.second]){\\n                if(dis[temp.second]+it.second<dis[it.first]){\\n                    if(dis[it.first]!=INT_MAX){\\n                        st.erase({dis[it.first],it.first});\\n                    }\\n                    dis[it.first]=dis[temp.second]+it.second;\\n                    st.insert({dis[temp.second]+it.second,it.first});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n    int num;\\n    vector<pair<int,int>> adj[101];\\n    Graph(int n, vector<vector<int>>& edges) {\\n        num=n;\\n        vector<pair<int,int>> adj1[101];\\n        for(auto it:edges){\\n            adj1[it[0]].push_back({it[1],it[2]});\\n        }\\n        for(int i=0;i<101;i++){\\n            adj[i]=adj1[i];\\n        }\\n    }\\n    \\n    void addEdge(vector<int> edge) {\\n        adj[edge[0]].push_back({edge[1],edge[2]});\\n    }\\n    \\n    int shortestPath(int node1, int node2) {\\n        return dijkstra(node1,node2,adj,num);\\n    }\\n};\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph* obj = new Graph(n, edges);\\n * obj->addEdge(edge);\\n * int param_2 = obj->shortestPath(node1,node2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420083,
                "title": "java-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Graph {\\n\\n    //int[] -> child, cost\\n    HashMap<Integer, List<int[]>> g = new HashMap<>();\\n    \\n    public Graph(int n, int[][] edges) {\\n        for(int i=0; i<n; i++){\\n            g.put(i, new ArrayList<int[]>());\\n        }\\n        \\n        for(int[] edge : edges){\\n            addEdge(edge);\\n        }\\n    }\\n    \\n    //from, to, edgecost\\n    public void addEdge(int[] edge) {\\n        //to, edgecost\\n        g.get(edge[0]).add(new int[]{edge[1], edge[2]});\\n    }\\n    \\n    public int shortestPath(int node1, int node2) {\\n        int[] dst = new int[g.size()];\\n        boolean[] visited = new boolean[g.size()];\\n        \\n        Arrays.fill(dst, Integer.MAX_VALUE);\\n        \\n        if(node1 == node2) return 0;\\n        \\n        Queue<Integer> q = new ArrayDeque();\\n        q.offer(node1);\\n        dst[node1] = 0;\\n        visited[node1] = true;\\n        \\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            for(int i=0; i<size; i++){\\n                \\n                //parent\\n                int par = q.poll();\\n                \\n                //child: to, edgecost\\n                for(int[] child : g.get(par)){\\n                    int to = child[0];\\n                    int cost = child[1];\\n                    \\n                    int prevdst = dst[to];\\n                    //dst at child\\n                    dst[to] = Math.min(dst[to], dst[par] + cost);\\n                    \\n                    if(prevdst != dst[to]){\\n                        //visited[to] = true;\\n                        q.offer(to);\\n                    }\\n                }\\n                \\n            }\\n        }\\n        \\n        return dst[node2] == Integer.MAX_VALUE ? -1 : dst[node2];\\n    }\\n}\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph obj = new Graph(n, edges);\\n * obj.addEdge(edge);\\n * int param_2 = obj.shortestPath(node1,node2);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Topological Sort"
                ],
                "code": "```\\nclass Graph {\\n\\n    //int[] -> child, cost\\n    HashMap<Integer, List<int[]>> g = new HashMap<>();\\n    \\n    public Graph(int n, int[][] edges) {\\n        for(int i=0; i<n; i++){\\n            g.put(i, new ArrayList<int[]>());\\n        }\\n        \\n        for(int[] edge : edges){\\n            addEdge(edge);\\n        }\\n    }\\n    \\n    //from, to, edgecost\\n    public void addEdge(int[] edge) {\\n        //to, edgecost\\n        g.get(edge[0]).add(new int[]{edge[1], edge[2]});\\n    }\\n    \\n    public int shortestPath(int node1, int node2) {\\n        int[] dst = new int[g.size()];\\n        boolean[] visited = new boolean[g.size()];\\n        \\n        Arrays.fill(dst, Integer.MAX_VALUE);\\n        \\n        if(node1 == node2) return 0;\\n        \\n        Queue<Integer> q = new ArrayDeque();\\n        q.offer(node1);\\n        dst[node1] = 0;\\n        visited[node1] = true;\\n        \\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            for(int i=0; i<size; i++){\\n                \\n                //parent\\n                int par = q.poll();\\n                \\n                //child: to, edgecost\\n                for(int[] child : g.get(par)){\\n                    int to = child[0];\\n                    int cost = child[1];\\n                    \\n                    int prevdst = dst[to];\\n                    //dst at child\\n                    dst[to] = Math.min(dst[to], dst[par] + cost);\\n                    \\n                    if(prevdst != dst[to]){\\n                        //visited[to] = true;\\n                        q.offer(to);\\n                    }\\n                }\\n                \\n            }\\n        }\\n        \\n        return dst[node2] == Integer.MAX_VALUE ? -1 : dst[node2];\\n    }\\n}\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph obj = new Graph(n, edges);\\n * obj.addEdge(edge);\\n * int param_2 = obj.shortestPath(node1,node2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420052,
                "title": "c-simple-dijkstra-s-algorithm-o-v-2-queries",
                "content": "## Explanation\\nNotice the Graph and addEdge function is simple and the shortestPath could be simply found by Dijkstra\\'s Algorithm. \\n\\n### Reminder\\nNeed to add the case when Node1 == Node2!!\\n\\n# Code\\n```\\nclass Graph {\\npublic:\\n    unordered_map<int, vector<pair<int, int>>> graph;\\n    Graph(int n, vector<vector<int>>& edges) {\\n        for (auto &e: edges){\\n            graph[e[0]].push_back({e[2], e[1]});\\n        }\\n    }\\n    \\n    void addEdge(vector<int> edge) {\\n        graph[edge[0]].push_back({edge[2], edge[1]});\\n    }\\n    \\n    int shortestPath(int node1, int node2) {\\n        if (node1 == node2) return 0;\\n        unordered_map<int, int> searched;\\n        searched.insert({node1, 0});\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>> > pq;\\n        for (auto &a: graph[node1]) pq.push({a.first, a.second});\\n        while (!pq.empty()){\\n            auto top = pq.top();\\n            if (top.second == node2) return top.first;\\n            pq.pop();\\n            if (searched.find(top.second) == searched.end()){\\n                searched[top.second] = top.first;\\n                for (auto it = graph[top.second].begin(); it != graph[top.second].end(); it++) \\n                    pq.push({top.first + it->first, it->second});\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph* obj = new Graph(n, edges);\\n * obj->addEdge(edge);\\n * int param_2 = obj->shortestPath(node1,node2);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Graph"
                ],
                "code": "```\\nclass Graph {\\npublic:\\n    unordered_map<int, vector<pair<int, int>>> graph;\\n    Graph(int n, vector<vector<int>>& edges) {\\n        for (auto &e: edges){\\n            graph[e[0]].push_back({e[2], e[1]});\\n        }\\n    }\\n    \\n    void addEdge(vector<int> edge) {\\n        graph[edge[0]].push_back({edge[2], edge[1]});\\n    }\\n    \\n    int shortestPath(int node1, int node2) {\\n        if (node1 == node2) return 0;\\n        unordered_map<int, int> searched;\\n        searched.insert({node1, 0});\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>> > pq;\\n        for (auto &a: graph[node1]) pq.push({a.first, a.second});\\n        while (!pq.empty()){\\n            auto top = pq.top();\\n            if (top.second == node2) return top.first;\\n            pq.pop();\\n            if (searched.find(top.second) == searched.end()){\\n                searched[top.second] = top.first;\\n                for (auto it = graph[top.second].begin(); it != graph[top.second].end(); it++) \\n                    pq.push({top.first + it->first, it->second});\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph* obj = new Graph(n, edges);\\n * obj->addEdge(edge);\\n * int param_2 = obj->shortestPath(node1,node2);\\n */\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1864287,
                "content": [
                    {
                        "username": "15o1",
                        "content": "Just one word solution for this \"HARD\" question\\n\\n\"Dijkstra\""
                    },
                    {
                        "username": "ranjithreddy-31",
                        "content": "This seems simple if you know Dijkstra\\'s algorithm. Has to be medium."
                    },
                    {
                        "username": "The_Laughing_Storm",
                        "content": "Wait so why is it that if the given graph for example doesnt have the node (2) in it then the distance from (2,2) is 0 instead of -1. Like if the node doesnt exist in the graph then shouldn't the ans be -1"
                    },
                    {
                        "username": "Ouskit",
                        "content": "Can this question be done with floyd-warshall ? "
                    },
                    {
                        "username": "Arshy_2807",
                        "content": "I think floyd-warshall will give you a TLE."
                    },
                    {
                        "username": "Ouskit",
                        "content": "I got wrong answer in below code with floyd-warshall, why?\\n```cpp\\nclass Graph {\\npublic:\\n    vector<vector<int>> distAll;\\n    int edgeNum;\\n    Graph(int n, vector<vector<int>>& edges) {\\n        edgeNum = n;\\n        vector<vector<int>> dist(n,vector<int>(n,INT_MAX));\\n        \\n        // floyd warshall\\n        for(int i=0;i<n;i++)\\n            dist[i][i]=0;\\n        \\n        for(int i=0;i<edges.size();i++){\\n            \\n            int src=edges[i][0];\\n            int dst=edges[i][1];\\n            int wt=edges[i][2];\\n            \\n            dist[src][dst]=wt;\\n        }\\n        \\n        for(int k=0;k<n;k++){\\n            for(int i=0;i<n;i++){\\n                for(int j=0;j<n;j++){\\n                    if(dist[i][k] != INT_MAX && dist[k][j] != INT_MAX)\\n                        dist[i][j]=min(dist[i][j],(dist[i][k]+dist[k][j]));\\n                }\\n            }\\n        }\\n        \\n        distAll = dist;\\n    }\\n    \\n    void addEdge(vector<int> edge) {\\n        if(edge[2] > distAll[edge[0]][edge[1]]) return;\\n        distAll[edge[0]][edge[1]] = edge[2];\\n        \\n        for(int i=0;i< edgeNum;i++){\\n            for(int j=0;j < edgeNum;j++){\\n                    if(distAll[i][edge[0]] != INT_MAX && distAll[edge[0]][j] != INT_MAX){\\n                        distAll[i][j]=min(distAll[i][j],(distAll[i][edge[0]]+distAll[edge[0]][j]));    \\n                    }\\n                    \\n                    if(distAll[i][edge[1]] != INT_MAX && distAll[edge[1]][j] != INT_MAX)\\n                        distAll[i][j]=min(distAll[i][j],(distAll[i][edge[1]]+distAll[edge[1]][j]));\\n                }\\n        }\\n    }\\n    \\n    int shortestPath(int node1, int node2) {\\n        return distAll[node1][node2] == INT_MAX ? -1 : distAll[node1][node2];\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 2034464,
                "content": [
                    {
                        "username": "15o1",
                        "content": "Just one word solution for this \"HARD\" question\\n\\n\"Dijkstra\""
                    },
                    {
                        "username": "ranjithreddy-31",
                        "content": "This seems simple if you know Dijkstra\\'s algorithm. Has to be medium."
                    },
                    {
                        "username": "The_Laughing_Storm",
                        "content": "Wait so why is it that if the given graph for example doesnt have the node (2) in it then the distance from (2,2) is 0 instead of -1. Like if the node doesnt exist in the graph then shouldn't the ans be -1"
                    },
                    {
                        "username": "Ouskit",
                        "content": "Can this question be done with floyd-warshall ? "
                    },
                    {
                        "username": "Arshy_2807",
                        "content": "I think floyd-warshall will give you a TLE."
                    },
                    {
                        "username": "Ouskit",
                        "content": "I got wrong answer in below code with floyd-warshall, why?\\n```cpp\\nclass Graph {\\npublic:\\n    vector<vector<int>> distAll;\\n    int edgeNum;\\n    Graph(int n, vector<vector<int>>& edges) {\\n        edgeNum = n;\\n        vector<vector<int>> dist(n,vector<int>(n,INT_MAX));\\n        \\n        // floyd warshall\\n        for(int i=0;i<n;i++)\\n            dist[i][i]=0;\\n        \\n        for(int i=0;i<edges.size();i++){\\n            \\n            int src=edges[i][0];\\n            int dst=edges[i][1];\\n            int wt=edges[i][2];\\n            \\n            dist[src][dst]=wt;\\n        }\\n        \\n        for(int k=0;k<n;k++){\\n            for(int i=0;i<n;i++){\\n                for(int j=0;j<n;j++){\\n                    if(dist[i][k] != INT_MAX && dist[k][j] != INT_MAX)\\n                        dist[i][j]=min(dist[i][j],(dist[i][k]+dist[k][j]));\\n                }\\n            }\\n        }\\n        \\n        distAll = dist;\\n    }\\n    \\n    void addEdge(vector<int> edge) {\\n        if(edge[2] > distAll[edge[0]][edge[1]]) return;\\n        distAll[edge[0]][edge[1]] = edge[2];\\n        \\n        for(int i=0;i< edgeNum;i++){\\n            for(int j=0;j < edgeNum;j++){\\n                    if(distAll[i][edge[0]] != INT_MAX && distAll[edge[0]][j] != INT_MAX){\\n                        distAll[i][j]=min(distAll[i][j],(distAll[i][edge[0]]+distAll[edge[0]][j]));    \\n                    }\\n                    \\n                    if(distAll[i][edge[1]] != INT_MAX && distAll[edge[1]][j] != INT_MAX)\\n                        distAll[i][j]=min(distAll[i][j],(distAll[i][edge[1]]+distAll[edge[1]][j]));\\n                }\\n        }\\n    }\\n    \\n    int shortestPath(int node1, int node2) {\\n        return distAll[node1][node2] == INT_MAX ? -1 : distAll[node1][node2];\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1926540,
                "content": [
                    {
                        "username": "15o1",
                        "content": "Just one word solution for this \"HARD\" question\\n\\n\"Dijkstra\""
                    },
                    {
                        "username": "ranjithreddy-31",
                        "content": "This seems simple if you know Dijkstra\\'s algorithm. Has to be medium."
                    },
                    {
                        "username": "The_Laughing_Storm",
                        "content": "Wait so why is it that if the given graph for example doesnt have the node (2) in it then the distance from (2,2) is 0 instead of -1. Like if the node doesnt exist in the graph then shouldn't the ans be -1"
                    },
                    {
                        "username": "Ouskit",
                        "content": "Can this question be done with floyd-warshall ? "
                    },
                    {
                        "username": "Arshy_2807",
                        "content": "I think floyd-warshall will give you a TLE."
                    },
                    {
                        "username": "Ouskit",
                        "content": "I got wrong answer in below code with floyd-warshall, why?\\n```cpp\\nclass Graph {\\npublic:\\n    vector<vector<int>> distAll;\\n    int edgeNum;\\n    Graph(int n, vector<vector<int>>& edges) {\\n        edgeNum = n;\\n        vector<vector<int>> dist(n,vector<int>(n,INT_MAX));\\n        \\n        // floyd warshall\\n        for(int i=0;i<n;i++)\\n            dist[i][i]=0;\\n        \\n        for(int i=0;i<edges.size();i++){\\n            \\n            int src=edges[i][0];\\n            int dst=edges[i][1];\\n            int wt=edges[i][2];\\n            \\n            dist[src][dst]=wt;\\n        }\\n        \\n        for(int k=0;k<n;k++){\\n            for(int i=0;i<n;i++){\\n                for(int j=0;j<n;j++){\\n                    if(dist[i][k] != INT_MAX && dist[k][j] != INT_MAX)\\n                        dist[i][j]=min(dist[i][j],(dist[i][k]+dist[k][j]));\\n                }\\n            }\\n        }\\n        \\n        distAll = dist;\\n    }\\n    \\n    void addEdge(vector<int> edge) {\\n        if(edge[2] > distAll[edge[0]][edge[1]]) return;\\n        distAll[edge[0]][edge[1]] = edge[2];\\n        \\n        for(int i=0;i< edgeNum;i++){\\n            for(int j=0;j < edgeNum;j++){\\n                    if(distAll[i][edge[0]] != INT_MAX && distAll[edge[0]][j] != INT_MAX){\\n                        distAll[i][j]=min(distAll[i][j],(distAll[i][edge[0]]+distAll[edge[0]][j]));    \\n                    }\\n                    \\n                    if(distAll[i][edge[1]] != INT_MAX && distAll[edge[1]][j] != INT_MAX)\\n                        distAll[i][j]=min(distAll[i][j],(distAll[i][edge[1]]+distAll[edge[1]][j]));\\n                }\\n        }\\n    }\\n    \\n    int shortestPath(int node1, int node2) {\\n        return distAll[node1][node2] == INT_MAX ? -1 : distAll[node1][node2];\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1864218,
                "content": [
                    {
                        "username": "15o1",
                        "content": "Just one word solution for this \"HARD\" question\\n\\n\"Dijkstra\""
                    },
                    {
                        "username": "ranjithreddy-31",
                        "content": "This seems simple if you know Dijkstra\\'s algorithm. Has to be medium."
                    },
                    {
                        "username": "The_Laughing_Storm",
                        "content": "Wait so why is it that if the given graph for example doesnt have the node (2) in it then the distance from (2,2) is 0 instead of -1. Like if the node doesnt exist in the graph then shouldn't the ans be -1"
                    },
                    {
                        "username": "Ouskit",
                        "content": "Can this question be done with floyd-warshall ? "
                    },
                    {
                        "username": "Arshy_2807",
                        "content": "I think floyd-warshall will give you a TLE."
                    },
                    {
                        "username": "Ouskit",
                        "content": "I got wrong answer in below code with floyd-warshall, why?\\n```cpp\\nclass Graph {\\npublic:\\n    vector<vector<int>> distAll;\\n    int edgeNum;\\n    Graph(int n, vector<vector<int>>& edges) {\\n        edgeNum = n;\\n        vector<vector<int>> dist(n,vector<int>(n,INT_MAX));\\n        \\n        // floyd warshall\\n        for(int i=0;i<n;i++)\\n            dist[i][i]=0;\\n        \\n        for(int i=0;i<edges.size();i++){\\n            \\n            int src=edges[i][0];\\n            int dst=edges[i][1];\\n            int wt=edges[i][2];\\n            \\n            dist[src][dst]=wt;\\n        }\\n        \\n        for(int k=0;k<n;k++){\\n            for(int i=0;i<n;i++){\\n                for(int j=0;j<n;j++){\\n                    if(dist[i][k] != INT_MAX && dist[k][j] != INT_MAX)\\n                        dist[i][j]=min(dist[i][j],(dist[i][k]+dist[k][j]));\\n                }\\n            }\\n        }\\n        \\n        distAll = dist;\\n    }\\n    \\n    void addEdge(vector<int> edge) {\\n        if(edge[2] > distAll[edge[0]][edge[1]]) return;\\n        distAll[edge[0]][edge[1]] = edge[2];\\n        \\n        for(int i=0;i< edgeNum;i++){\\n            for(int j=0;j < edgeNum;j++){\\n                    if(distAll[i][edge[0]] != INT_MAX && distAll[edge[0]][j] != INT_MAX){\\n                        distAll[i][j]=min(distAll[i][j],(distAll[i][edge[0]]+distAll[edge[0]][j]));    \\n                    }\\n                    \\n                    if(distAll[i][edge[1]] != INT_MAX && distAll[edge[1]][j] != INT_MAX)\\n                        distAll[i][j]=min(distAll[i][j],(distAll[i][edge[1]]+distAll[edge[1]][j]));\\n                }\\n        }\\n    }\\n    \\n    int shortestPath(int node1, int node2) {\\n        return distAll[node1][node2] == INT_MAX ? -1 : distAll[node1][node2];\\n    }\\n};\\n```"
                    }
                ]
            }
        ]
    }
]