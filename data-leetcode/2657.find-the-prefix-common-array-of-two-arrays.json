[
    {
        "title": "Find the Prefix Common Array of Two Arrays",
        "question_content": "You are given two 0-indexed integer permutations A and B of length n.\nA prefix common array of A and B is an array C such that C[i] is equal to the count of numbers that are present at or before the index i in both A and B.\nReturn the prefix common array of A and B.\nA sequence of n integers is called a&nbsp;permutation if it contains all integers from 1 to n exactly once.\n&nbsp;\nExample 1:\n\nInput: A = [1,3,2,4], B = [3,1,2,4]\nOutput: [0,2,3,4]\nExplanation: At i = 0: no number is common, so C[0] = 0.\nAt i = 1: 1 and 3 are common in A and B, so C[1] = 2.\nAt i = 2: 1, 2, and 3 are common in A and B, so C[2] = 3.\nAt i = 3: 1, 2, 3, and 4 are common in A and B, so C[3] = 4.\n\nExample 2:\n\nInput: A = [2,3,1], B = [3,1,2]\nOutput: [0,1,3]\nExplanation: At i = 0: no number is common, so C[0] = 0.\nAt i = 1: only 3 is common in A and B, so C[1] = 1.\nAt i = 2: 1, 2, and 3 are common in A and B, so C[2] = 3.\n\n&nbsp;\nConstraints:\n\n\t1 <= A.length == B.length == n <= 50\n\t1 <= A[i], B[i] <= n\n\tIt is guaranteed that A and B are both a permutation of n integers.",
        "solutions": [
            {
                "id": 3466676,
                "title": "frequency-array-solution-explained-o-n-time-and-space-c",
                "content": "\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& a, vector<int>& b) {\\n        // Get the Size of an Array\\n        int n = a.size();\\n        \\n        // Create frequency array which will store the running frequency\\n        // of each integer in both the arrays together. Since, they\\n        // are permutations, the frequency of the each element will \\n        // reach 2 at max at any point during the iterations.\\n        vector<int> aux(n+1, 0);\\n        \\n        // Answer array\\n        vector<int> ans(n, 0);\\n        \\n        // cmn will store the number of elements found to be common yet.         \\n        int cmn = 0;\\n        for(int i = 0; i < n; i++){\\n            // Increment frequency of element a[i], if frequency becomes 2 then \\n            // increment the cmn counter.\\n            aux[a[i]]++;\\n            if(aux[a[i]] == 2) cmn++;\\n            // Increment frequency of element b[i], if frequency becomes 2 then\\n            // increment the cmn counter.       \\n            aux[b[i]]++;\\n            if(aux[b[i]] == 2) cmn++;\\n            \\n            // Because we are moving in one direction the common elements\\n            // will not be changed infact the count will remain same or increase\\n            // but will never get reduced and hence at index \\'i\\' the number of\\n            // common elements will be \\'cmn\\'       \\n            ans[i] = cmn;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nIf it was easy for you to understand, make sure to upvote and help others!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& a, vector<int>& b) {\\n        // Get the Size of an Array\\n        int n = a.size();\\n        \\n        // Create frequency array which will store the running frequency\\n        // of each integer in both the arrays together. Since, they\\n        // are permutations, the frequency of the each element will \\n        // reach 2 at max at any point during the iterations.\\n        vector<int> aux(n+1, 0);\\n        \\n        // Answer array\\n        vector<int> ans(n, 0);\\n        \\n        // cmn will store the number of elements found to be common yet.         \\n        int cmn = 0;\\n        for(int i = 0; i < n; i++){\\n            // Increment frequency of element a[i], if frequency becomes 2 then \\n            // increment the cmn counter.\\n            aux[a[i]]++;\\n            if(aux[a[i]] == 2) cmn++;\\n            // Increment frequency of element b[i], if frequency becomes 2 then\\n            // increment the cmn counter.       \\n            aux[b[i]]++;\\n            if(aux[b[i]] == 2) cmn++;\\n            \\n            // Because we are moving in one direction the common elements\\n            // will not be changed infact the count will remain same or increase\\n            // but will never get reduced and hence at index \\'i\\' the number of\\n            // common elements will be \\'cmn\\'       \\n            ans[i] = cmn;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466857,
                "title": "day-394-brute-optimal-one-pass-100-0ms-python-java-c-explained-approach",
                "content": "# Please Upvote as it really motivates me \\uD83C\\uDD99\\uD83C\\uDD99\\uD83C\\uDD99\\n# Intuition & Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe need to find an array C of the same length such that C[i] is the number of elements that are common to both A and B in the prefix of length i+1.\\n\\nWe can start by creating two hash maps indexStoreOfA and indexStoreOfB to store the indices of each element in A and B, respectively.\\n\\nWe then iterate over the prefix of A and count the number of elements that are common to both A and B up to that point. We do this by checking if the index of each element in A is less than or equal to i and the index of the same element in B is also less than or equal to i.\\n\\nWe store the count in an array answer and return it as the answer.\\n\\nSince we iterate over the prefix of A and perform constant time operations for each element, the time complexity of this solution is O(n^2), where n is the length of the arrays A and B.\\n\\n\\n# Code\\n```java []\\npublic int[]ThePrefixCommonArray(int[] A, int[] B) {\\n    int length = A.length;\\n    // Create two hash maps to store the indices of each element in A and B\\n    HashMap<Integer, Integer> indexStoreOfA = new HashMap<>();\\n    HashMap<Integer, Integer> indexStoreOfB = new HashMap<>();\\n    // Populate the hash maps with the indices of each element in A and B\\n    for (int i = 0; i < length; i++) {\\n        indexStoreOfA.put(A[i], i);\\n        indexStoreOfB.put(B[i], i);\\n    }\\n    // Create an array to store the prefix common array\\n    int[] answer = new int[length];\\n    // Iterate over each element in A\\n    for (int i = 0; i < length; i++) {\\n        int prefixCounter = 0;\\n        // Iterate over each element in the prefix of A up to i\\n        for (int j = 0; j <= i; j++) {\\n            // If the element at index j in A is also in B and its index in both A and B is less than or equal to i,\\n            // increment the prefix counter\\n            if (indexStoreOfA.get(A[j]) <= i && indexStoreOfB.get(A[j]) <= i) prefixCounter++;\\n        }\\n        // Store the prefix counter in the answer array\\n        answer[i] = prefixCounter;\\n    }\\n    // Return the prefix common array\\n    return answer;\\n}\\n```\\n```python []\\nclass Solution:\\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n        n = len(A)\\n        m1, m2 = {}, {}\\n        for i in range(n):\\n            m1[A[i]] = i\\n            m2[B[i]] = i\\n        c = [0] * n\\n        for i in range(n):\\n            cnt = 0\\n            for j in range(i + 1):\\n                if m1[A[j]] <= i and m2[A[j]] <= i:\\n                    cnt += 1\\n            c[i] = cnt\\n        return c\\n```\\n```c++ []\\nclass Solution {\\npublic    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        int n = A.size();\\n        unordered_map<int, int> m1, m2;\\n        for(int i = 0; i < n; i++) {\\n            m1[A[i]] = i;\\n            m2[B[i]] = i;\\n        }\\n        vector<int> c(n);\\n        for(int i = 0; i < n; i++) {\\n            int cnt = 0;\\n            for(int j = 0; j <= i; j++) {\\n                if(m1[A[j]] <= i && m2[A[j]] <= i) {\\n                    cnt++;\\n                }\\n            }\\n            c[i] = cnt;\\n        }\\n        return c;\\n    }\\n};\\n```\\n\\n\\n# Complexity\\nTC: The time complexity of the code is O(n^2), where n is the length of the input arrays A and B. This is because the code iterates over each element in A and then iterates over each element in the prefix of A up to i, resulting in a nested loop. The time complexity of the nested loop is O(n^2) because the maximum number of iterations is n(n+1)/2. Therefore, the overall time complexity of the code is O(n^2).\\nSC: The space complexity of the code is O(n), where n is the length of the input\\n\\n\\n# Please Upvote as it really motivates me \\uD83C\\uDD99\\uD83C\\uDD99\\uD83C\\uDD99\\n# Optimal approach using frequency array \\nWe are given two integer permutations A and B of length n, and we need to find the prefix common array of A and B.\\n\\nA prefix common array of A and B is an array C such that C[i] is equal to the count of numbers that are present at or before the index i in both A and B.\\n\\nTo find the prefix common array, we can iterate over both arrays A and B simultaneously and keep track of the frequency of each integer in both arrays using an array cnt.\\n\\nFor each element in A and B, we increment the corresponding element in cnt and check if its frequency becomes 2. If the frequency becomes 2, it means that the element is present in both A and B at or before the current index i.\\n\\nWe update the corresponding element in the result array res by adding 1 if the frequency of the element in A or B becomes 2, otherwise we add 0.\\n\\nFinally, we compute the prefix sum of the res array to get the prefix common array of A and B.\\n\\nThe time complexity of this approach is O(n), where n is the length of the input arrays A and B.\\n\\n```java []\\npublic int[] findThePrefixCommonArray(int[] A, int[] B) {\\n    int n = A.length, res[] = new int[n],cnt[] = new int[51];\\n    for (int i = 0; i < n; ++i) {\\n        res[i] = (++cnt[A[i]] == 2 ? 1 : 0) + (++cnt[B[i]] == 2 ? 1 : 0);\\n        if( i > 0)  res[i] += res[i - 1];\\n    }\\n    return res;\\n}\\n```\\n```c++ []\\n vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n    int n = A.size();\\n    vector<int> res(n), cnt(51);\\n    for (int i = 0; i < n; ++i) {\\n        res[i] = (++cnt[A[i]] == 2 ? 1 : 0) + (++cnt[B[i]] == 2 ? 1 : 0);\\n        if( i > 0)  res[i] += res[i - 1];\\n    }\\n    return res;\\n}\\n```\\n```python []\\ndef findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n    n = len(A)\\n    res = [0] * n\\n    cnt = [0] * 51\\n    for i in range(n):\\n        res[i] = ((cnt[A[i]] := cnt[A[i]] + 1) == 2) + ((cnt[B[i]] := cnt[B[i]] + 1) == 2)\\n        if i > 0:\\n            res[i] += res[i - 1]\\n    return res\\n```\\n# TC = o(n)\\n# SC = O(51)==>o(1)\\n\\n![BREUSELEE.webp](https://assets.leetcode.com/users/images/062630f0-ef80-4e74-abdb-302827b99235_1680054012.5054147.webp)\\n![image.png](https://assets.leetcode.com/users/images/303fa18d-281d-49f0-87ef-1a018fc9a488_1681355186.0923774.png)\\n\\n\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\uD83C\\uDD99\\uD83C\\uDD99\\uD83C\\uDD99\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D \\uD83C\\uDD99\\uD83C\\uDD99\\uD83C\\uDD99\\nhttps://leetcode.com/problems/find-the-prefix-common-array-of-two-arrays/solutions/3466857/day-394-brute-optimal-100-0ms-python-java-c-explained-approach/\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3"
                ],
                "code": "```java []\\npublic int[]ThePrefixCommonArray(int[] A, int[] B) {\\n    int length = A.length;\\n    // Create two hash maps to store the indices of each element in A and B\\n    HashMap<Integer, Integer> indexStoreOfA = new HashMap<>();\\n    HashMap<Integer, Integer> indexStoreOfB = new HashMap<>();\\n    // Populate the hash maps with the indices of each element in A and B\\n    for (int i = 0; i < length; i++) {\\n        indexStoreOfA.put(A[i], i);\\n        indexStoreOfB.put(B[i], i);\\n    }\\n    // Create an array to store the prefix common array\\n    int[] answer = new int[length];\\n    // Iterate over each element in A\\n    for (int i = 0; i < length; i++) {\\n        int prefixCounter = 0;\\n        // Iterate over each element in the prefix of A up to i\\n        for (int j = 0; j <= i; j++) {\\n            // If the element at index j in A is also in B and its index in both A and B is less than or equal to i,\\n            // increment the prefix counter\\n            if (indexStoreOfA.get(A[j]) <= i && indexStoreOfB.get(A[j]) <= i) prefixCounter++;\\n        }\\n        // Store the prefix counter in the answer array\\n        answer[i] = prefixCounter;\\n    }\\n    // Return the prefix common array\\n    return answer;\\n}\\n```\n```python []\\nclass Solution:\\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n        n = len(A)\\n        m1, m2 = {}, {}\\n        for i in range(n):\\n            m1[A[i]] = i\\n            m2[B[i]] = i\\n        c = [0] * n\\n        for i in range(n):\\n            cnt = 0\\n            for j in range(i + 1):\\n                if m1[A[j]] <= i and m2[A[j]] <= i:\\n                    cnt += 1\\n            c[i] = cnt\\n        return c\\n```\n```c++ []\\nclass Solution {\\npublic    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        int n = A.size();\\n        unordered_map<int, int> m1, m2;\\n        for(int i = 0; i < n; i++) {\\n            m1[A[i]] = i;\\n            m2[B[i]] = i;\\n        }\\n        vector<int> c(n);\\n        for(int i = 0; i < n; i++) {\\n            int cnt = 0;\\n            for(int j = 0; j <= i; j++) {\\n                if(m1[A[j]] <= i && m2[A[j]] <= i) {\\n                    cnt++;\\n                }\\n            }\\n            c[i] = cnt;\\n        }\\n        return c;\\n    }\\n};\\n```\n```java []\\npublic int[] findThePrefixCommonArray(int[] A, int[] B) {\\n    int n = A.length, res[] = new int[n],cnt[] = new int[51];\\n    for (int i = 0; i < n; ++i) {\\n        res[i] = (++cnt[A[i]] == 2 ? 1 : 0) + (++cnt[B[i]] == 2 ? 1 : 0);\\n        if( i > 0)  res[i] += res[i - 1];\\n    }\\n    return res;\\n}\\n```\n```c++ []\\n vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n    int n = A.size();\\n    vector<int> res(n), cnt(51);\\n    for (int i = 0; i < n; ++i) {\\n        res[i] = (++cnt[A[i]] == 2 ? 1 : 0) + (++cnt[B[i]] == 2 ? 1 : 0);\\n        if( i > 0)  res[i] += res[i - 1];\\n    }\\n    return res;\\n}\\n```\n```python []\\ndef findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n    n = len(A)\\n    res = [0] * n\\n    cnt = [0] * 51\\n    for i in range(n):\\n        res[i] = ((cnt[A[i]] := cnt[A[i]] + 1) == 2) + ((cnt[B[i]] := cnt[B[i]] + 1) == 2)\\n        if i > 0:\\n            res[i] += res[i - 1]\\n    return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466962,
                "title": "java-c-python-one-pass",
                "content": "# **Explanation**\\nIterate A[i] and B[i],\\nand record if we have ever seen A[i] and B[i].\\n\\nThe second time we have seen the same value,\\nwe will increment the number `cur` of current common elements.\\n\\nFinall return the result.\\n<br>\\n\\n# **Complexity**\\nTime `O(n)`\\nSpace `O(n)` for output\\n<br>\\n\\n**Java**\\n```java\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        int cur = 0, n = A.length, res[] = new int[n], seen[] = new int[n + 1];\\n        for (int i = 0; i < n; ++i) {\\n            if (++seen[A[i]] == 2) cur++;\\n            if (++seen[B[i]] == 2) cur++;\\n            res[i] = cur;\\n        }\\n        return res;\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        int cur = 0, n = A.size();\\n        vector<int> res(n), seen(n + 1);\\n        for (int i = 0; i < n; ++i) {\\n            if (++seen[A[i]] == 2) cur++;\\n            if (++seen[B[i]] == 2) cur++;\\n            res[i] = cur;\\n        }\\n        return res;\\n    }\\n```\\n\\n**Python**\\n```py\\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n        res = []\\n        seen = cur = 0\\n        for ab in zip(A, B):\\n            for a in ab:\\n                if (1 << a) & seen:\\n                    cur += 1\\n                seen |= 1 << a\\n            res.append(cur)\\n        return res\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        int cur = 0, n = A.length, res[] = new int[n], seen[] = new int[n + 1];\\n        for (int i = 0; i < n; ++i) {\\n            if (++seen[A[i]] == 2) cur++;\\n            if (++seen[B[i]] == 2) cur++;\\n            res[i] = cur;\\n        }\\n        return res;\\n    }\\n```\n```cpp\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        int cur = 0, n = A.size();\\n        vector<int> res(n), seen(n + 1);\\n        for (int i = 0; i < n; ++i) {\\n            if (++seen[A[i]] == 2) cur++;\\n            if (++seen[B[i]] == 2) cur++;\\n            res[i] = cur;\\n        }\\n        return res;\\n    }\\n```\n```py\\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n        res = []\\n        seen = cur = 0\\n        for ab in zip(A, B):\\n            for a in ab:\\n                if (1 << a) & seen:\\n                    cur += 1\\n                seen |= 1 << a\\n            res.append(cur)\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3466638,
                "title": "simple-java-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        int a[]=new int[51];\\n        int len=A.length;\\n        int res[]=new int[len];\\n        for(int i=1;i<=len;i++)\\n        {\\n            a[A[i-1]]++;\\n            a[B[i-1]]++;\\n            int count=0;\\n            for(int j=0;j<=50;j++)\\n            {\\n                if(a[j]==2)\\n                {\\n                    count++;\\n                }\\n            }\\n            res[i-1]=count;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        int a[]=new int[51];\\n        int len=A.length;\\n        int res[]=new int[len];\\n        for(int i=1;i<=len;i++)\\n        {\\n            a[A[i-1]]++;\\n            a[B[i-1]]++;\\n            int count=0;\\n            for(int j=0;j<=50;j++)\\n            {\\n                if(a[j]==2)\\n                {\\n                    count++;\\n                }\\n            }\\n            res[i-1]=count;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466695,
                "title": "explained-using-bit-set-very-simple-easy-to-understand-solution",
                "content": "\\n<b> Up vote if you like the solution</b>\\n\\n# Approach\\nLets consider the case if the constraint is, value of array is less than 32 in place of 50\\nHere we can take two flags a & b. Keep setting its bits as per the array value we see on iteration.\\n    Then taking the bit wise AND of a & b, then counting the 1\\'s will give us no. of common elements till we traversed.\\n\\nSo if you understand above case, for constraint above we can take 4 variables a1, a2, b1 & b2 to store status of seen element.\\nHere a1 will store status of 1-31 & a2 store status of 32 to 50. Same is the case for b1 & b2.\\n\\n\\n# Code\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        int a1 = 0, b1 = 0, a2 = 0, b2 = 0;\\n        vector<int> ans;\\n        for(int i = 0; i < A.size(); ++i){\\n            if(A[i] < 32) a1 = (a1 | (1 << A[i]));\\n            else a2 = (a2 | (1 << (A[i] - 31)));\\n            if(B[i] < 32) b1 = (b1 | (1 << B[i]));\\n            else b2 = (b2 | (1 << (B[i] - 31)));\\n            ans.push_back(__builtin_popcount((a1 & b1))  + __builtin_popcount((a2 & b2)));\\n        }\\n        return ans;\\n    }\\n};\\n```\\n<b>Here is an article of my last interview experience - A Journey to FAANG Company, I recomand you to go through this to know which all resources I have used & how I cracked interview at Amazon:\\nhttps://leetcode.com/discuss/interview-experience/3171859/Journey-to-a-FAANG-Company-Amazon-or-SDE2-(L5)-or-Bangalore-or-Oct-2022-Accepted\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        int a1 = 0, b1 = 0, a2 = 0, b2 = 0;\\n        vector<int> ans;\\n        for(int i = 0; i < A.size(); ++i){\\n            if(A[i] < 32) a1 = (a1 | (1 << A[i]));\\n            else a2 = (a2 | (1 << (A[i] - 31)));\\n            if(B[i] < 32) b1 = (b1 | (1 << B[i]));\\n            else b2 = (b2 | (1 << (B[i] - 31)));\\n            ans.push_back(__builtin_popcount((a1 & b1))  + __builtin_popcount((a2 & b2)));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466640,
                "title": "counter",
                "content": "\\nWe go left-to-right and count the elements in both arrays.\\n\\nThe element `n` appears in both arrays when `cnt[n] == 2`.\\n\\n```cpp\\nvector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n    vector<int> res, cnt(51);\\n    for (int i = 0; i < A.size(); ++i)\\n        res.push_back((++cnt[A[i]] == 2) + (++cnt[B[i]] == 2));\\n    partial_sum(begin(res), end(res), begin(res));\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nvector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n    vector<int> res, cnt(51);\\n    for (int i = 0; i < A.size(); ++i)\\n        res.push_back((++cnt[A[i]] == 2) + (++cnt[B[i]] == 2));\\n    partial_sum(begin(res), end(res), begin(res));\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3467191,
                "title": "c-python-o-n-solution-using-set",
                "content": "\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# C++\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        unordered_set<int> a, b;\\n        vector<int> ans;\\n        int count = 0;\\n        for(int i = 0; i < A.size(); i++) {\\n            a.insert(A[i]);\\n            b.insert(B[i]);\\n            if(A[i] == B[i]) {\\n                count++;\\n                ans.push_back(count);\\n                continue;\\n            }\\n            if(b.find(A[i]) != b.end()) count++;\\n            if(a.find(B[i]) != a.end()) count++;\\n            ans.push_back(count);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n# Python / Python3\\n```\\nclass Solution:\\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n        a = set()\\n        b = set()\\n        ans = []\\n        count = 0\\n        for i in range(0, len(A)):\\n            a.add(A[i])\\n            b.add(B[i])\\n            if A[i] == B[i]:\\n                count += 1\\n                ans.append(count)\\n                continue\\n            if A[i] in b:\\n                count += 1\\n            if B[i] in a:\\n                count += 1\\n            ans.append(count)\\n        return ans\\n```",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        unordered_set<int> a, b;\\n        vector<int> ans;\\n        int count = 0;\\n        for(int i = 0; i < A.size(); i++) {\\n            a.insert(A[i]);\\n            b.insert(B[i]);\\n            if(A[i] == B[i]) {\\n                count++;\\n                ans.push_back(count);\\n                continue;\\n            }\\n            if(b.find(A[i]) != b.end()) count++;\\n            if(a.find(B[i]) != a.end()) count++;\\n            ans.push_back(count);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n        a = set()\\n        b = set()\\n        ans = []\\n        count = 0\\n        for i in range(0, len(A)):\\n            a.add(A[i])\\n            b.add(B[i])\\n            if A[i] == B[i]:\\n                count += 1\\n                ans.append(count)\\n                continue\\n            if A[i] in b:\\n                count += 1\\n            if B[i] in a:\\n                count += 1\\n            ans.append(count)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466802,
                "title": "c-best-solution-one-time-traversal-o-n-easy-to-understand",
                "content": "\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(3n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& a, vector<int>& b) {\\n        vector<int> temp;\\n        set<int> st;\\n        map<int, bool> m1, m2;\\n        \\n        for(int i=0; i<a.size(); i++)   {\\n            m1[a[i]] = m2[b[i]] = true; // make the both element true in their map\\n            if(m1.find(b[i]) != m1.end())  st.insert(b[i]);     // if the b[i] is present before in the array a then push it in set\\n            if(m2.find(a[i]) != m2.end())  st.insert(a[i]);     // if the a[i] is present before in the array b then push it in set\\n            temp.push_back(st.size());      // set => size indecates the number of element common \\n        }\\n        return temp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Map",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& a, vector<int>& b) {\\n        vector<int> temp;\\n        set<int> st;\\n        map<int, bool> m1, m2;\\n        \\n        for(int i=0; i<a.size(); i++)   {\\n            m1[a[i]] = m2[b[i]] = true; // make the both element true in their map\\n            if(m1.find(b[i]) != m1.end())  st.insert(b[i]);     // if the b[i] is present before in the array a then push it in set\\n            if(m2.find(a[i]) != m2.end())  st.insert(a[i]);     // if the a[i] is present before in the array b then push it in set\\n            temp.push_back(st.size());      // set => size indecates the number of element common \\n        }\\n        return temp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3469401,
                "title": "java-find-the-prefix-common-array-of-two-arrays",
                "content": "\\n```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n                int []com = new int[A.length];\\n        HashSet<Integer> setA = new HashSet<>();\\n        HashSet<Integer> setB = new HashSet<>();\\n        for (int i = 0; i < A.length; i++)\\n        {\\n            setA.add(A[i]);\\n            setB.add(B[i]);\\n            HashSet<Integer> tmp = new HashSet<>(setA);\\n            tmp.retainAll(setB);\\n            com[i] = tmp.size();\\n        }\\n        return com;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n                int []com = new int[A.length];\\n        HashSet<Integer> setA = new HashSet<>();\\n        HashSet<Integer> setB = new HashSet<>();\\n        for (int i = 0; i < A.length; i++)\\n        {\\n            setA.add(A[i]);\\n            setB.add(B[i]);\\n            HashSet<Integer> tmp = new HashSet<>(setA);\\n            tmp.retainAll(setB);\\n            com[i] = tmp.size();\\n        }\\n        return com;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467846,
                "title": "python-3-8-lines-w-example-t-m-132-ms-16-mb",
                "content": "```\\nclass Solution:\\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n\\n        ans, cur, d = [], 0, defaultdict(int)   #  Example: A = [1,3,2,4], B = [3,1,2,4]\\n\\n        for a,b in zip(A,B):                    #  zip(A,B) = [(1,3), (3,1), (2,2), (4,4)]\\n\\n            if a == b: ans.append(cur:=cur+1)   #    (A,B)      d       cur    ans\\n                                                #    \\u2013\\u2013\\u2013\\u2013\\u2013  \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013  \\u2013\\u2013\\u2013\\u2013   \\u2013\\u2013\\u2013\\u2013\\n            else:                               #    (1,3)  {1:1, 3:1}    0    [0]\\n                d[a] += 1                       #    (3,1)  {1:2, 3:2}    2    [0,2]\\n                d[b] += 1                       #    (2,2)  {1:2, 3:2}    3    [0,2,3]\\n                                                #    (4,4)  {1:2, 3:2}    4    [0,2,3,4]\\n\\n                ans.append(cur:= cur+ (d[a] == 2) + (d[b] == 2))\\n\\n            print((a,b), d, cur, ans)\\n        return ans\\n```\\n[https://leetcode.com/problems/find-the-prefix-common-array-of-two-arrays/submissions/941774522/](http://)\\nI could be wrong, but I think that time complexity is *O*(*N*) and space complexity is *O*(*N*).\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n\\n        ans, cur, d = [], 0, defaultdict(int)   #  Example: A = [1,3,2,4], B = [3,1,2,4]\\n\\n        for a,b in zip(A,B):                    #  zip(A,B) = [(1,3), (3,1), (2,2), (4,4)]\\n\\n            if a == b: ans.append(cur:=cur+1)   #    (A,B)      d       cur    ans\\n                                                #    \\u2013\\u2013\\u2013\\u2013\\u2013  \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013  \\u2013\\u2013\\u2013\\u2013   \\u2013\\u2013\\u2013\\u2013\\n            else:                               #    (1,3)  {1:1, 3:1}    0    [0]\\n                d[a] += 1                       #    (3,1)  {1:2, 3:2}    2    [0,2]\\n                d[b] += 1                       #    (2,2)  {1:2, 3:2}    3    [0,2,3]\\n                                                #    (4,4)  {1:2, 3:2}    4    [0,2,3,4]\\n\\n                ans.append(cur:= cur+ (d[a] == 2) + (d[b] == 2))\\n\\n            print((a,b), d, cur, ans)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3497523,
                "title": "c-solution-using-set-one-pass-solution",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Check if the values are equal, then count the value as common one\\n- Else check if any of the value is present in the set or not, if present, the increase the count, else insert it into the set\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        unordered_set<int> mp;\\n        vector<int> res;\\n        int count=0;\\n        for(int i=0;i<A.size();i++) {\\n            if(A[i]==B[i]) {\\n                count++;\\n            }else{\\n                if(mp.find(A[i])!=mp.end()) count++;\\n                else mp.insert(A[i]);\\n\\n                if(mp.find(B[i])!=mp.end()) count++;\\n                else mp.insert(B[i]);\\n            }\\n            res.push_back(count);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        unordered_set<int> mp;\\n        vector<int> res;\\n        int count=0;\\n        for(int i=0;i<A.size();i++) {\\n            if(A[i]==B[i]) {\\n                count++;\\n            }else{\\n                if(mp.find(A[i])!=mp.end()) count++;\\n                else mp.insert(A[i]);\\n\\n                if(mp.find(B[i])!=mp.end()) count++;\\n                else mp.insert(B[i]);\\n            }\\n            res.push_back(count);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3492154,
                "title": "c-maintain-a-count-array-easy-to-understand",
                "content": "# Intuition\\nSTORE COUNT OF ELEMENT OF ARRAT\\n\\n# Approach\\nMAINTAIN COUNT OF ELEMENT\\'S OF ARRAY\\nFOR 1st ARRAY INCREMENT COUNT FOR 2nd ARRAY DECREMENT COUNT OF ELEMENT\\n1st ARRAY: BEFORE INCREMENT COUNT CHECK ELEMENT COUNT < 0  OR NOTE\\n2nd ARRAY: BEFRE DECREMENT COUNT CHECK ELEMENT PREVIOSLY EXISTS OF NOT\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        int n = A.size(),k=0;\\n        vector<int> ans(n),dp(n+1,0);//DP ARRAY FOR STORE COUNT OF ALL ELEMENTS\\n        for(int i = 0; i < n; i++){\\n            if(dp[A[i]]<0)k++;\\n            dp[A[i]]++;\\n            if(dp[B[i]]>0)k++;\\n            dp[B[i]]--;\\n            ans[i] = k;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        int n = A.size(),k=0;\\n        vector<int> ans(n),dp(n+1,0);//DP ARRAY FOR STORE COUNT OF ALL ELEMENTS\\n        for(int i = 0; i < n; i++){\\n            if(dp[A[i]]<0)k++;\\n            dp[A[i]]++;\\n            if(dp[B[i]]>0)k++;\\n            dp[B[i]]--;\\n            ans[i] = k;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467605,
                "title": "python3-one-line",
                "content": "Loop over the intersection of arrays, increasing the length of the window, moving the index to the right at each iteration. An array composed of the length of the intersection of the arrays at each step will be the answer.\\n\\nFor example: (current step, set(A[:i + 1]), set(B[:i + 1]), length of intersection)\\ni = 0: {1}, {3} -> 0\\ni = 1: {1, 3}, {1, 3} -> 2\\ni = 2: {1, 2, 3}, {1, 2, 3} -> 3\\ni = 3: {1, 2, 3, 4}, {1, 2, 3, 4} -> 4\\n\\n```\\nclass Solution:\\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n        return [len(set(A[:i + 1]) & set(B[:i + 1])) for i in range(len(A))]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n        return [len(set(A[:i + 1]) & set(B[:i + 1])) for i in range(len(A))]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466741,
                "title": "easy-to-understand-map-simple-code",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) \\n    {\\n        int n = A.size();\\n        unordered_map<int, int>mp;\\n        vector<int>ans(n, 0);\\n        for (int i = 0; i < n; i++)\\n        {\\n            mp[B[i]]++;\\n            //====================================\\n            int common = 0;\\n            for (int j = 0; j <= i; j++)\\n            {\\n                if (mp.count(A[j])) common++;\\n            }\\n            //======================================\\n            ans[i] = common;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) \\n    {\\n        int n = A.size();\\n        unordered_map<int, int>mp;\\n        vector<int>ans(n, 0);\\n        for (int i = 0; i < n; i++)\\n        {\\n            mp[B[i]]++;\\n            //====================================\\n            int common = 0;\\n            for (int j = 0; j <= i; j++)\\n            {\\n                if (mp.count(A[j])) common++;\\n            }\\n            //======================================\\n            ans[i] = common;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466729,
                "title": "simple-clean-java-solution",
                "content": "\\n```java []\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        int[] res = new int[A.length];\\n        Set<Integer> setA = new HashSet<>();\\n        Set<Integer> setB = new HashSet<>();\\n        for(int i=0; i<A.length; i++){\\n            setA.add(A[i]);\\n            setB.add(B[i]);\\n            Set<Integer> set = new HashSet(setA);\\n            set.retainAll(setB);\\n            res[i] = set.size();\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java []\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        int[] res = new int[A.length];\\n        Set<Integer> setA = new HashSet<>();\\n        Set<Integer> setB = new HashSet<>();\\n        for(int i=0; i<A.length; i++){\\n            setA.add(A[i]);\\n            setB.add(B[i]);\\n            Set<Integer> set = new HashSet(setA);\\n            set.retainAll(setB);\\n            res[i] = set.size();\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3816661,
                "title": "python-3-two-set-solution",
                "content": "```python3 []\\nclass Solution:\\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n        res, s1, s2 = [], set(), set()\\n        for a, b in zip(A, B):\\n            s1.add(a)\\n            s2.add(b)\\n            res.append(len(s1 & s2))\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python3 []\\nclass Solution:\\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n        res, s1, s2 = [], set(), set()\\n        for a, b in zip(A, B):\\n            s1.add(a)\\n            s2.add(b)\\n            res.append(len(s1 & s2))\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3481901,
                "title": "easy-c-solution-single-loop-set",
                "content": "# Intuition\\nWe start filling elements in the set\\nset oonly has unique elements\\nAs we fill elements in set the size should increase by 2 every time but due to duplicacy it does not\\nso we just see how many should be there - how many there are. \\n\\n# Approach\\n2*(i+1)-st.size()\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        unordered_set<int> st;\\n        vector<int> ans;\\n        for(int i=0;i<A.size();i++){\\n            st.insert(A[i]);st.insert(B[i]);\\n            ans.push_back(2*(i+1)-st.size());\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        unordered_set<int> st;\\n        vector<int> ans;\\n        for(int i=0;i<A.size();i++){\\n            st.insert(A[i]);st.insert(B[i]);\\n            ans.push_back(2*(i+1)-st.size());\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467133,
                "title": "c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        int n = A.size();\\n        vector<int> vis(n + 1), ans;\\n        for(int i = 0; i < n; i++) {\\n            vis[A[i]]++;\\n            vis[B[i]]++;\\n            int cnt = 0;\\n            for(int j = 1; j <= n; j++) if(vis[j] == 2) cnt++;\\n            ans.push_back(cnt);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        int n = A.size();\\n        vector<int> vis(n + 1), ans;\\n        for(int i = 0; i < n; i++) {\\n            vis[A[i]]++;\\n            vis[B[i]]++;\\n            int cnt = 0;\\n            for(int j = 1; j <= n; j++) if(vis[j] == 2) cnt++;\\n            ans.push_back(cnt);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466858,
                "title": "c-easy-time-o-n-space-o-n-most-optimized",
                "content": "````\\n\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        vector<int> ans;\\n        vector<int> v(51,0);\\n        int x = 0;\\n        for(int i = 0; i < A.size(); i++){\\n            if(v[A[i]]<0)\\n                x++;\\n            v[A[i]]++;\\n            if(v[B[i]]>0)\\n                x++;\\n            v[B[i]]--;\\n            ans.push_back(x);\\n        }\\n        return ans;\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "````\\n\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        vector<int> ans;\\n        vector<int> v(51,0);\\n        int x = 0;\\n        for(int i = 0; i < A.size(); i++){\\n            if(v[A[i]]<0)\\n                x++;\\n            v[A[i]]++;\\n            if(v[B[i]]>0)\\n                x++;\\n            v[B[i]]--;\\n            ans.push_back(x);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466822,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n        count = defaultdict(int)\\n        n = len(A)\\n        ans = [0] * n\\n        s = 0\\n        for i in range(n):\\n            count[A[i]] += 1\\n            if count[A[i]] == 2:\\n                s += 1\\n            count[B[i]] += 1\\n            if count[B[i]] == 2:\\n                s += 1\\n            ans[i] = s\\n        return ans\\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n        count = defaultdict(int)\\n        n = len(A)\\n        ans = [0] * n\\n        s = 0\\n        for i in range(n):\\n            count[A[i]] += 1\\n            if count[A[i]] == 2:\\n                s += 1\\n            count[B[i]] += 1\\n            if count[B[i]] == 2:\\n                s += 1\\n            ans[i] = s\\n        return ans\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466722,
                "title": "c-solution-using-set",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        vector<int>arr(A.size());\\n        int index=0;\\n        \\n        for(int i=0;i<A.size();i++){\\n            int count = 0;\\n            set<int>set;\\n            for(int j=0; j<=i;j++){\\n                set.insert(A[j]);\\n            }\\n            for(int k=0;k<=i;k++){\\n                if(!set.insert(B[k]).second ){\\n                    count++;\\n                }    \\n            }\\n            arr[index++] = count;\\n        }\\n        return arr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        vector<int>arr(A.size());\\n        int index=0;\\n        \\n        for(int i=0;i<A.size();i++){\\n            int count = 0;\\n            set<int>set;\\n            for(int j=0; j<=i;j++){\\n                set.insert(A[j]);\\n            }\\n            for(int k=0;k<=i;k++){\\n                if(!set.insert(B[k]).second ){\\n                    count++;\\n                }    \\n            }\\n            arr[index++] = count;\\n        }\\n        return arr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466708,
                "title": "set-counting-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        unordered_set<int> s1, s2;\\n        int n = A.size();\\n        vector<int> ans;\\n        for(int i=0; i<n; i++) {\\n            s1.insert(A[i]);\\n            s2.insert(B[i]);\\n            \\n            int cnt = 0;\\n            for(int i=1; i<=n; i++) {\\n                if(s1.find(i) != s1.end() && s2.find(i) != s1.end()) cnt++;\\n            }\\n            ans.push_back(cnt);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        unordered_set<int> s1, s2;\\n        int n = A.size();\\n        vector<int> ans;\\n        for(int i=0; i<n; i++) {\\n            s1.insert(A[i]);\\n            s2.insert(B[i]);\\n            \\n            int cnt = 0;\\n            for(int i=1; i<=n; i++) {\\n                if(s1.find(i) != s1.end() && s2.find(i) != s1.end()) cnt++;\\n            }\\n            ans.push_back(cnt);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466635,
                "title": "c-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        unordered_map<int,int> mp;\\n        vector<int> val;\\n        int ans=0;\\n        for(int i=0;i<A.size();i++){\\n            mp[A[i]]++;\\n            if(mp[A[i]] == 2)\\n                ans++;\\n            mp[B[i]]++;\\n            if(mp[B[i]] == 2)\\n                ans++;\\n            val.push_back(ans);\\n        }\\n        return val;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        unordered_map<int,int> mp;\\n        vector<int> val;\\n        int ans=0;\\n        for(int i=0;i<A.size();i++){\\n            mp[A[i]]++;\\n            if(mp[A[i]] == 2)\\n                ans++;\\n            mp[B[i]]++;\\n            if(mp[B[i]] == 2)\\n                ans++;\\n            val.push_back(ans);\\n        }\\n        return val;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3950768,
                "title": "easy-c-solution-maps-beats-99",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n      map<int,int> mp;\\n      int count=0;\\n      vector<int> v;\\n      for(int i=0;i<A.size();i++)\\n      {\\n          mp[A[i]]++;\\n          if(mp[A[i]]==2)\\n          {\\n              count++;\\n          }\\n          mp[B[i]]++;\\n          if(mp[B[i]]==2)\\n          {\\n              count++;\\n          }\\n          v.push_back(count);\\n      }  \\n    return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n      map<int,int> mp;\\n      int count=0;\\n      vector<int> v;\\n      for(int i=0;i<A.size();i++)\\n      {\\n          mp[A[i]]++;\\n          if(mp[A[i]]==2)\\n          {\\n              count++;\\n          }\\n          mp[B[i]]++;\\n          if(mp[B[i]]==2)\\n          {\\n              count++;\\n          }\\n          v.push_back(count);\\n      }  \\n    return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3765411,
                "title": "java-hashset-easy-to-understand-o-n",
                "content": "# Intuition\\nBasically the problem statement says we need to check how many duplicate elements we got upto every index from both arrays A and B.\\n\\n# Approach\\nAs soon as the word duplicate strikes your mind.. you should think of HashSets. Maintain a HashSet to store unique elements and create array C denoting how many duplicates we have found upto that index in both arrays A and B.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\no(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        HashSet<Integer> unique = new HashSet<>();\\n        int[] C = new int[A.length];\\n        for(int i=0; i<C.length; i++){\\n            unique.add(A[i]);\\n            unique.add(B[i]);\\n            C[i] = (2*(i+1)) - unique.size();\\n        }\\n        return C;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        HashSet<Integer> unique = new HashSet<>();\\n        int[] C = new int[A.length];\\n        for(int i=0; i<C.length; i++){\\n            unique.add(A[i]);\\n            unique.add(B[i]);\\n            C[i] = (2*(i+1)) - unique.size();\\n        }\\n        return C;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3603166,
                "title": "frequency-array-solution-o-n-time-and-space-faster-than-100-online-java-solution",
                "content": "class Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        int freq[] = new int[A.length+1];\\n        int c[] = new int[A.length];\\n        int count = 0;\\n        for(int i=0;i<A.length;i++){\\n            freq[A[i]]++;\\n            if(freq[A[i]]==2)count++;\\n            freq[B[i]]++;\\n            if(freq[B[i]]==2)count++;\\n            c[i]=count;\\n        }\\n        return c;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        int freq[] = new int[A.length+1];\\n        int c[] = new int[A.length];\\n        int count = 0;\\n        for(int i=0;i<A.length;i++){\\n            freq[A[i]]++;\\n            if(freq[A[i]]==2)count++;\\n            freq[B[i]]++;\\n            if(freq[B[i]]==2)count++;\\n            c[i]=count;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3467151,
                "title": "simple-easy-solution-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        vector<int>ans;\\n        unordered_map<int, int>mp;\\n        for(int i=0; i<A.size(); i++) {\\n            mp[A[i]]++;\\n            mp[B[i]]++;\\n            int t= 2*(i+1)- mp.size();\\n            ans.push_back(t);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        vector<int>ans;\\n        unordered_map<int, int>mp;\\n        for(int i=0; i<A.size(); i++) {\\n            mp[A[i]]++;\\n            mp[B[i]]++;\\n            int t= 2*(i+1)- mp.size();\\n            ans.push_back(t);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467075,
                "title": "java-simple-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem requires finding the number of common elements between the two given integer arrays for each prefix of the arrays.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Create two ArrayList objects, al and bl, to store the elements of the input arrays a and b, respectively.\\n\\n1. Initialize the size of the input arrays to n and create an integer array ans of size n to store the number of common elements between a and b for each prefix of the arrays.\\n\\n1. Initialize a counter variable cnt to 0.\\n\\n1. Loop through each prefix of the input arrays using a for loop that iterates over the indices i from 0 to n-1.\\n\\n1. In each iteration, add the ith element of a and b to their respective ArrayLists.\\n\\n1. If the ith elements of a and b are equal, increment the counter variable cnt by 1.\\n\\n1. If the ith elements of a and b are not equal, check if bl (the ArrayList for b) contains the ith element of a. If true, increment the counter variable cnt by 1.\\n\\n1. Similarly, check if al (the ArrayList for a) contains the ith element of b. If true, increment the counter variable cnt by 1.\\n\\n1. Store the count of common elements cnt in the ith index of the ans array.\\n\\n1. After looping through all prefixes, return the ans array.\\n\\n**The overall approach of the code is to use two ArrayList objects to keep track of the elements of the input arrays and then iterate over each prefix of the arrays to count the number of common elements between them.**\\n\\n# Complexity\\n- Time complexity:  O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] a, int[] b) {\\n        List<Integer> al = new ArrayList<>();\\n        List<Integer> bl = new ArrayList<>();\\n        int n = a.length;\\n        int[] ans = new int[n];\\n        int cnt=0;\\n        for(int i=0;i<n;i++){\\n            \\n            al.add(a[i]);\\n            bl.add(b[i]);\\n            if(a[i]==b[i]){\\n                cnt++;\\n            }\\n            else{\\n                if(bl.contains(a[i])){\\n                    cnt++;\\n                }\\n                if(al.contains(b[i])){\\n                    cnt++;\\n                }\\n            }\\n            ans[i] = cnt;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] a, int[] b) {\\n        List<Integer> al = new ArrayList<>();\\n        List<Integer> bl = new ArrayList<>();\\n        int n = a.length;\\n        int[] ans = new int[n];\\n        int cnt=0;\\n        for(int i=0;i<n;i++){\\n            \\n            al.add(a[i]);\\n            bl.add(b[i]);\\n            if(a[i]==b[i]){\\n                cnt++;\\n            }\\n            else{\\n                if(bl.contains(a[i])){\\n                    cnt++;\\n                }\\n                if(al.contains(b[i])){\\n                    cnt++;\\n                }\\n            }\\n            ans[i] = cnt;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466861,
                "title": "java-simplest-solution-ever",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        \\n \\n    int n = A.length;\\n        int m = B.length;\\n        int[] C = new int[n];\\n        Set<Integer> setA = new HashSet<>();\\n        Set<Integer> setB = new HashSet<>();\\n        for (int i = 0; i < n; i++) {\\n            setA.add(A[i]);\\n            setB.add(B[i]);\\n            int commonCount = 0;\\n            for (int num : setA) {\\n                if (setB.contains(num)) {\\n                    commonCount++;\\n                }\\n            }\\n            C[i] = commonCount;\\n        }\\n        return C;\\n    }\\n}\\n\\n\\n\\n\\n    \\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        \\n \\n    int n = A.length;\\n        int m = B.length;\\n        int[] C = new int[n];\\n        Set<Integer> setA = new HashSet<>();\\n        Set<Integer> setB = new HashSet<>();\\n        for (int i = 0; i < n; i++) {\\n            setA.add(A[i]);\\n            setB.add(B[i]);\\n            int commonCount = 0;\\n            for (int num : setA) {\\n                if (setB.contains(num)) {\\n                    commonCount++;\\n                }\\n            }\\n            C[i] = commonCount;\\n        }\\n        return C;\\n    }\\n}\\n\\n\\n\\n\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466801,
                "title": "brute-c-solution",
                "content": "\\n# Approach\\nFor each index check in both arrays for the common elements.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& q, vector<int>& w) {\\n        int n=q.size();\\n        vector<int>v;\\n        for(int i=0;i<n;i++){\\n            int cnt=0;\\n            for(int k=0;k<=i;k++){\\n                for(int p=0;p<=i;p++){\\n                    if(q[k]==w[p]){\\n                        cnt++;\\n                    }\\n                }\\n            }\\n            v.push_back(cnt);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& q, vector<int>& w) {\\n        int n=q.size();\\n        vector<int>v;\\n        for(int i=0;i<n;i++){\\n            int cnt=0;\\n            for(int k=0;k<=i;k++){\\n                for(int p=0;p<=i;p++){\\n                    if(q[k]==w[p]){\\n                        cnt++;\\n                    }\\n                }\\n            }\\n            v.push_back(cnt);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3987843,
                "title": "c-o-n-hashmap-o-n-time",
                "content": "# Intuition\\nBecause there are guaranteed to be the same permutation of n elements, if we can have the indices of each element from {1..n} available in O(1) time, we can quickly check in an iterative fashion if we want to add to the prefix or not.\\n\\n# Approach\\nCreate two index-maps for the two arrays. If the elements are the same, then we add 1 to our answer till before. Else, we may encounter an element in `A` which was present in `B` before, or the vice-versa. Hence, we need to add 1 based on both checks.\\n\\n# Complexity\\n- Time complexity:\\nO(n) : 3 loops.\\n\\n- Space complexity:\\nO(n) : 2 Hashmaps + 1 solution array.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        unordered_map<int, int> A_idx;\\n        unordered_map<int, int> B_idx;\\n        for(int i = 0 ; i < A.size(); i++) A_idx[A[i]] = i;\\n        for(int i = 0 ; i < A.size(); i++) B_idx[B[i]] = i;\\n        vector<int> soln_c(A.size(), 0);\\n        soln_c[0] = A[0] == B[0];\\n        for(int i = 1 ; i < A.size(); i++) {\\n            soln_c[i] = soln_c[i-1];\\n            if(A[i] == B[i])\\n                soln_c[i] += 1;\\n            else\\n                soln_c[i] += (B_idx[A[i]] <= i) + (A_idx[B[i]] <= i);\\n        }\\n        return soln_c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        unordered_map<int, int> A_idx;\\n        unordered_map<int, int> B_idx;\\n        for(int i = 0 ; i < A.size(); i++) A_idx[A[i]] = i;\\n        for(int i = 0 ; i < A.size(); i++) B_idx[B[i]] = i;\\n        vector<int> soln_c(A.size(), 0);\\n        soln_c[0] = A[0] == B[0];\\n        for(int i = 1 ; i < A.size(); i++) {\\n            soln_c[i] = soln_c[i-1];\\n            if(A[i] == B[i])\\n                soln_c[i] += 1;\\n            else\\n                soln_c[i] += (B_idx[A[i]] <= i) + (A_idx[B[i]] <= i);\\n        }\\n        return soln_c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3937672,
                "title": "2657-find-the-prefix-common-array-of-two-arrays-java",
                "content": "```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        // Initialize an array to store the common prefix lengths\\n        int ans[] = new int[A.length];\\n        // Initialize a counter to keep track of common prefix length\\n        int cnt = 0;\\n\\n        // Initialize hash maps to track element frequencies in arrays A and B\\n        HashMap<Integer, Integer> H1 = new HashMap<Integer, Integer>();\\n        HashMap<Integer, Integer> H2 = new HashMap<Integer, Integer>();\\n\\n        // Check if the first elements of A and B are equal\\n        if (A[0] == B[0]) {\\n            cnt++;          // Increment the counter\\n            ans[0] = cnt;   // Store the counter value for the first index\\n        } else {\\n            H1.put(A[0], 1); // Add the first element of A to H1 with frequency 1\\n            H2.put(B[0], 1); // Add the first element of B to H2 with frequency 1\\n        }\\n\\n        // Iterate through the arrays starting from the second index\\n        for (int i = 1; i < A.length; i++) {\\n            // If elements at the same index in A and B are equal, increment the counter\\n            if (A[i] == B[i])\\n                cnt++;\\n            \\n            // If the current element of A has occurred previously in B, increment the counter\\n            if (H2.containsKey(A[i]))\\n                cnt++;\\n            \\n            // If the current element of B has occurred previously in A, increment the counter\\n            if (H1.containsKey(B[i]))\\n                cnt++;\\n            \\n            // Store the current counter value in the ans array\\n            ans[i] = cnt;\\n            \\n            // Update frequency counts in the hash maps\\n            H1.put(A[i], H1.getOrDefault(A[i], 0) + 1);\\n            H2.put(B[i], H2.getOrDefault(B[i], 0) + 1);\\n        }\\n\\n        // Return the array containing common prefix lengths for each index\\n        return ans;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        // Initialize an array to store the common prefix lengths\\n        int ans[] = new int[A.length];\\n        // Initialize a counter to keep track of common prefix length\\n        int cnt = 0;\\n\\n        // Initialize hash maps to track element frequencies in arrays A and B\\n        HashMap<Integer, Integer> H1 = new HashMap<Integer, Integer>();\\n        HashMap<Integer, Integer> H2 = new HashMap<Integer, Integer>();\\n\\n        // Check if the first elements of A and B are equal\\n        if (A[0] == B[0]) {\\n            cnt++;          // Increment the counter\\n            ans[0] = cnt;   // Store the counter value for the first index\\n        } else {\\n            H1.put(A[0], 1); // Add the first element of A to H1 with frequency 1\\n            H2.put(B[0], 1); // Add the first element of B to H2 with frequency 1\\n        }\\n\\n        // Iterate through the arrays starting from the second index\\n        for (int i = 1; i < A.length; i++) {\\n            // If elements at the same index in A and B are equal, increment the counter\\n            if (A[i] == B[i])\\n                cnt++;\\n            \\n            // If the current element of A has occurred previously in B, increment the counter\\n            if (H2.containsKey(A[i]))\\n                cnt++;\\n            \\n            // If the current element of B has occurred previously in A, increment the counter\\n            if (H1.containsKey(B[i]))\\n                cnt++;\\n            \\n            // Store the current counter value in the ans array\\n            ans[i] = cnt;\\n            \\n            // Update frequency counts in the hash maps\\n            H1.put(A[i], H1.getOrDefault(A[i], 0) + 1);\\n            H2.put(B[i], H2.getOrDefault(B[i], 0) + 1);\\n        }\\n\\n        // Return the array containing common prefix lengths for each index\\n        return ans;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3721347,
                "title": "easy-solution-using-hashset-o-n-java",
                "content": "```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        \\n        HashSet<Integer> set1=new HashSet<>();\\n        HashSet<Integer> set2=new HashSet<>();\\n        \\n        int [] arr=new int[A.length];\\n        for(int i=0;i<A.length;i++)\\n        {\\n            set1.add(A[i]);\\n            set2.add(B[i]);\\n            \\n            HashSet<Integer> res=new HashSet<>(set1);\\n            res.retainAll(set2);\\n            arr[i]=res.size();   \\n        }\\n        return arr;  // upvote my solution\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        \\n        HashSet<Integer> set1=new HashSet<>();\\n        HashSet<Integer> set2=new HashSet<>();\\n        \\n        int [] arr=new int[A.length];\\n        for(int i=0;i<A.length;i++)\\n        {\\n            set1.add(A[i]);\\n            set2.add(B[i]);\\n            \\n            HashSet<Integer> res=new HashSet<>(set1);\\n            res.retainAll(set2);\\n            arr[i]=res.size();   \\n        }\\n        return arr;  // upvote my solution\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3718097,
                "title": "c-easiest-possible-solution-o-n-2",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        unordered_map<int, int> map1; // Create an unordered map to store the frequency of elements from both A and B\\n        vector<int> ans(A.size(), 0); // Create a result vector initialized with 0s, to store the prefix common array\\n\\n        for (int i = 0; i < A.size(); i++) {\\n            map1[A[i]]++; // Increment the frequency of element A[i] in the map\\n            map1[B[i]]++; // Increment the frequency of element B[i] in the map\\n\\n            int count = 0; // Initialize a count variable to store the number of elements with frequency >= 2\\n\\n            for (auto it : map1) // Iterate through the elements of the unordered map\\n                if (it.second >= 2) // If the frequency is greater than or equal to 2, it means it\\'s common in both A and B\\n                    count += it.second; // Increment the count based on the frequency of the common element\\n\\n            ans[i] += count / 2; // Store half of the count in the result array for each index i\\n        }\\n\\n        return ans; // Return the result vector containing the prefix common array\\n    }\\n};\\n```\\n\\n**Time Complexity:**\\n\\nThe outer loop runs for A.size() iterations, and the inner loop iterates over the elements of the unordered map, which has a maximum size of 2 * A.size() (as it stores elements from both A and B). Therefore, the time complexity of the inner loop is O(A.size()).\\nSince the inner loop runs inside the outer loop, the overall time complexity of the function is O(A.size() * A.size()).\\n\\n**Space Complexity:**\\n\\nThe unordered map map1 can store up to 2 * A.size() elements, each containing a unique element from A and B. Therefore, the space complexity of the unordered map is O(A.size()).\\nThe ans vector has the same size as vector A, so its space complexity is also O(A.size()).\\nOverall, the space complexity of the function is O(A.size()).",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        unordered_map<int, int> map1; // Create an unordered map to store the frequency of elements from both A and B\\n        vector<int> ans(A.size(), 0); // Create a result vector initialized with 0s, to store the prefix common array\\n\\n        for (int i = 0; i < A.size(); i++) {\\n            map1[A[i]]++; // Increment the frequency of element A[i] in the map\\n            map1[B[i]]++; // Increment the frequency of element B[i] in the map\\n\\n            int count = 0; // Initialize a count variable to store the number of elements with frequency >= 2\\n\\n            for (auto it : map1) // Iterate through the elements of the unordered map\\n                if (it.second >= 2) // If the frequency is greater than or equal to 2, it means it\\'s common in both A and B\\n                    count += it.second; // Increment the count based on the frequency of the common element\\n\\n            ans[i] += count / 2; // Store half of the count in the result array for each index i\\n        }\\n\\n        return ans; // Return the result vector containing the prefix common array\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3710294,
                "title": "intuative-solution-beats-98-79-in-rn-98-42-in-m",
                "content": "# Intuition\\nlet,\\n\\ni = current number of elements being checked in the lists\\nn = length of list\\nk = number of common elements\\nd = Length of dictionary\\n\\nIf we store the all unique elements in a dictionary upto the **i**th length and let\\'s assume that no element is common between the two list, then the length of the dictionary will be i*2. However, now let us assume there are k number of common elements, then the length of the dictionary is:\\n$$d = i*2 - k$$\\n\\nor\\n\\n$$k = i*2 - d$$\\n\\nfor example:\\n    A = [1,3]\\n    B = [3,1]\\n    n = 2\\n    \\n    when i = 1\\n    d = 2 #dictionary = [1,3]\\n    k = 1 * 2 - 2 = 0\\n\\n    when i = 2\\n    d = 2 #dictionary = [1,3]\\n    k = 2 * 2 - 2 = 2\\n\\n# Complexity\\n- Time complexity:\\n    $$O(n)$$\\n\\n- Space complexity:\\n    worst case, 2n from dictionary (tmp) and n from list (C):\\n    3n\\n    $$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n        C = []\\n        tmp = {}\\n        if A[0] == B[0]:\\n            C.append(1)\\n        else:\\n            C.append(0)\\n        tmp[A[0]] = 1\\n        tmp[B[0]] = 1\\n        for i in range(1,len(A)):\\n            tmp[A[i]] = 1\\n            tmp[B[i]] = 1\\n            C.append((i+1)*2 - len(tmp)) \\n        return C\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n        C = []\\n        tmp = {}\\n        if A[0] == B[0]:\\n            C.append(1)\\n        else:\\n            C.append(0)\\n        tmp[A[0]] = 1\\n        tmp[B[0]] = 1\\n        for i in range(1,len(A)):\\n            tmp[A[i]] = 1\\n            tmp[B[i]] = 1\\n            C.append((i+1)*2 - len(tmp)) \\n        return C\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3690673,
                "title": "swift-hash-table-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAt first, I wanted to solve through dictionaries, because I did not understand the task at all. Because a friend explained that whenever we iterate over an array we count everything to count all the same numbers. From 0 to i. This turned out to be very important!\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI realized that a dictionary is not needed. We can use a set. Each time we insert numbers into a set, we know the difference in the number. Thus, we can understand how many identical numbers are already in the set.\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    func findThePrefixCommonArray(_ A: [Int], _ B: [Int]) -> [Int] {\\n        var set: Set<Int> = []\\n        var result: [Int] = []\\n        for i in 1...A.count {\\n            set.insert(A[i - 1])\\n            set.insert(B[i - 1])\\n            result.append(i * 2 - set.count)\\n        }\\n        return result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    func findThePrefixCommonArray(_ A: [Int], _ B: [Int]) -> [Int] {\\n        var set: Set<Int> = []\\n        var result: [Int] = []\\n        for i in 1...A.count {\\n            set.insert(A[i - 1])\\n            set.insert(B[i - 1])\\n            result.append(i * 2 - set.count)\\n        }\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3688343,
                "title": "easy-lvl-problem",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        int n = A.size();\\n        vector<int> f(n+1);\\n        vector<int> res(n);\\n\\n        for (int i=0; i<n; i++) {\\n            if (++f[A[i]] == 2) res[i]++;\\n            if (++f[B[i]] == 2) res[i]++;\\n\\n            if (i>0) res[i] += res[i-1];\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        int n = A.size();\\n        vector<int> f(n+1);\\n        vector<int> res(n);\\n\\n        for (int i=0; i<n; i++) {\\n            if (++f[A[i]] == 2) res[i]++;\\n            if (++f[B[i]] == 2) res[i]++;\\n\\n            if (i>0) res[i] += res[i-1];\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3670342,
                "title": "simple-javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSince each integer can only appear once in each array, if the integer is already in the set seen, then increment by one. Otherwise, add to the set. No concerns of duplicate counting due to distinct integers.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n) due to iteratring through entire array.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n) due to seen set that will contain every element.\\n# Code\\n```\\n/**\\n * @param {number[]} A\\n * @param {number[]} B\\n * @return {number[]}\\n */\\nvar findThePrefixCommonArray = function(A, B) {\\n    let seen = new Set();\\n    let prefixCommonArr = [];\\n    let currentCount = 0;\\n\\n    for (let i = 0; i < A.length; i++) {\\n        if (seen.has(A[i])) {\\n            currentCount += 1;\\n        }\\n        seen.add(A[i]);\\n\\n        if (seen.has(B[i])) {\\n            currentCount +=1 ;\\n        }\\n        seen.add(B[i]);\\n        \\n        prefixCommonArr[i] = currentCount;\\n    }\\n\\n    return prefixCommonArr;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} A\\n * @param {number[]} B\\n * @return {number[]}\\n */\\nvar findThePrefixCommonArray = function(A, B) {\\n    let seen = new Set();\\n    let prefixCommonArr = [];\\n    let currentCount = 0;\\n\\n    for (let i = 0; i < A.length; i++) {\\n        if (seen.has(A[i])) {\\n            currentCount += 1;\\n        }\\n        seen.add(A[i]);\\n\\n        if (seen.has(B[i])) {\\n            currentCount +=1 ;\\n        }\\n        seen.add(B[i]);\\n        \\n        prefixCommonArr[i] = currentCount;\\n    }\\n\\n    return prefixCommonArr;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3668005,
                "title": "beats-100-optimal-o-n-hashing",
                "content": "# Approach\\nThe main logic of the code involves keeping track of the frequency of elements in both arrays using the `freq` array. By checking if an element has a frequency of 2, we can determine if it is common in both prefix arrays. The cumulative count `cumcount` is incremented whenever a new common element is found. Finally, the count array is populated with the cumulative `count` up to each index.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$, for storing `count[]`\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        int[] count = new int[A.length];\\n        int n = A.length;\\n        int[] freq = new int[51];\\n\\n        int cumcount = 0;\\n        for(int i=0; i<n; i++) {\\n            freq[A[i]]++;\\n            // if freq[x] ==2 that mean it was already common in both the prefix arrays\\n            if(freq[A[i]] == 2) \\n                cumcount++;\\n            \\n            // similarly for element B[i]\\n            freq[B[i]]++;\\n            if(freq[B[i]] == 2)\\n                cumcount++;\\n            \\n            count[i] = cumcount;\\n        }\\n        return count;\\n    }\\n}\\n```\\n\\n### Please do upvote!! \\uD83D\\uDE4F",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        int[] count = new int[A.length];\\n        int n = A.length;\\n        int[] freq = new int[51];\\n\\n        int cumcount = 0;\\n        for(int i=0; i<n; i++) {\\n            freq[A[i]]++;\\n            // if freq[x] ==2 that mean it was already common in both the prefix arrays\\n            if(freq[A[i]] == 2) \\n                cumcount++;\\n            \\n            // similarly for element B[i]\\n            freq[B[i]]++;\\n            if(freq[B[i]] == 2)\\n                cumcount++;\\n            \\n            count[i] = cumcount;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3656547,
                "title": "extremely-easy-beginner-friendly-method-brute-force",
                "content": "\\n# Approach\\n                           Brute force method\\nTo solve the problem, we can iterate through the arrays A and B simultaneously and create a counter vector to store the elements encountered at each index. For each iteration, we sort the counter vector and count the number of duplicates. The count represents the number of common elements between the prefixes A[0:i+1] and B[0:i+1]. We store this count in the solution vector.\\n\\n# Complexity\\n- Time complexity: O(n^2 log(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- Space complexity: O(min(n,m))\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) \\n    {\\n        vector<int> solution;\\n        vector<int> counter;\\n        int count = 0;\\n        for(int i = 0; i<A.size();i++)\\n        {\\n            count = 0;\\n            counter.push_back(A[i]);\\n            counter.push_back(B[i]);\\n\\n            sort(counter.begin(), counter.end());\\n            for(int j = 1 ; j< counter.size();j++)\\n            {\\n                if(counter[j]==counter[j-1])count++;\\n            }\\n\\n            solution.push_back(count);\\n        }       \\n\\n        return solution;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) \\n    {\\n        vector<int> solution;\\n        vector<int> counter;\\n        int count = 0;\\n        for(int i = 0; i<A.size();i++)\\n        {\\n            count = 0;\\n            counter.push_back(A[i]);\\n            counter.push_back(B[i]);\\n\\n            sort(counter.begin(), counter.end());\\n            for(int j = 1 ; j< counter.size();j++)\\n            {\\n                if(counter[j]==counter[j-1])count++;\\n            }\\n\\n            solution.push_back(count);\\n        }       \\n\\n        return solution;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3553756,
                "title": "solution-using-set-identities",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThere are probably easier solutions, but here is a mathematical one that shows the power of set identities.\\n\\nWhat you want is to maintain the intersection between the sets of numbers in either array that you\\'ve already seen so far. The size of this intersection at each $$i$$ is equal to $$C[i]$$.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nLet $$sA$$ and $$sB$$ be sets containing elements from $$A$$ and $$B$$ respectively as we traverse the arrays. Let $$sA_i$$ and $$sB_i$$ be the two sets after iteration $$i$$. Then, in iteration $$i+1$$, the elements $$A[i+1]$$ and $$B[i+1]$$ come along. \\n\\nWe want $$C[i+1] = |sA_{i+1} \\\\cap sB_{i+1}| = |(sA_i \\\\cup \\\\{A[i]\\\\}) \\\\cap (sB_i \\\\cup \\\\{B[i]\\\\})|$$.\\n\\nNow, recall the following set identity: $$A \\\\cap (B \\\\cup C) = (A \\\\cap B) \\\\cup (A \\\\cap C)$$. Using this identity, $$C[i+1]$$ can be written as:\\n\\n$$C[i+1] = (sA_i \\\\cap sB_i) \\\\cup (\\\\{A[i]\\\\} \\\\cap sB_i) \\\\cup (\\\\{B[i]\\\\} \\\\cap sA_i) \\\\cup (\\\\{A[i]\\\\} \\\\cap \\\\{B[i]\\\\})$$.\\n\\nBut $$sA_i \\\\cap sB_i = C[i]$$ which we have from the previous iteration, and the other three terms in the union above can be obtained by simply query-ing $$sA$$ and $$sB$$ for the elements. One can do this using a set or a hashmap.\\n\\n# Complexity\\n- Time complexity: $$O(n\\\\log n)$$ improvable to $$O(n)$$ with hashmap.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        set<int> setA, setB;\\n        vector<int> C;\\n        C.assign(A.size(), 0);\\n        for (int i = 0; i < A.size(); i++)\\n        {\\n            C[i] = ((i > 0) ? C[i-1] : 0) + \\n                   (setB.find(A[i]) != setB.end()) + \\n                   (setA.find(B[i]) != setA.end())\\n                   + (A[i] == B[i]);\\n\\n            setA.insert(A[i]);\\n            setB.insert(B[i]);\\n        }\\n\\n        return C;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        set<int> setA, setB;\\n        vector<int> C;\\n        C.assign(A.size(), 0);\\n        for (int i = 0; i < A.size(); i++)\\n        {\\n            C[i] = ((i > 0) ? C[i-1] : 0) + \\n                   (setB.find(A[i]) != setB.end()) + \\n                   (setA.find(B[i]) != setA.end())\\n                   + (A[i] == B[i]);\\n\\n            setA.insert(A[i]);\\n            setB.insert(B[i]);\\n        }\\n\\n        return C;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3531758,
                "title": "brute-force",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& a, vector<int>& b) {\\n        \\n        int n = a.size();\\n        unordered_map<int, int> mp;\\n        int ans = 0;\\n        vector<int> res(n,0);\\n        for(int i=0;i<n;i++)\\n        {   \\n            mp[a[i]]++ ;\\n            \\n            for(int j=0;j<=i;j++)\\n            {\\n                if(mp.count(b[j]))\\n                {\\n                    res[i]++;\\n                }\\n            }\\n        }\\n        \\n       \\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& a, vector<int>& b) {\\n        \\n        int n = a.size();\\n        unordered_map<int, int> mp;\\n        int ans = 0;\\n        vector<int> res(n,0);\\n        for(int i=0;i<n;i++)\\n        {   \\n            mp[a[i]]++ ;\\n            \\n            for(int j=0;j<=i;j++)\\n            {\\n                if(mp.count(b[j]))\\n                {\\n                    res[i]++;\\n                }\\n            }\\n        }\\n        \\n       \\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3525437,
                "title": "two-solutions-to-find-the-prefix-common-array-of-two-arrays-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# 1. Approach\\n<!-- Describe your approach to solving the problem. -->\\n*BRUTE FORCE APPROACH*\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^3)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        int i, j, k, count=0;\\n        vector<int> ans;\\n        for(i=0 ; i<A.size() ; i++)\\n        {\\n            count=0;\\n            for(j=0 ; j<=i ; j++)\\n            {\\n                for(k=0 ; k<=i ; k++)\\n                {\\n                    if(A[j]==B[k])\\n                    {\\n                        count++;\\n                    }\\n                }\\n            }\\n            ans.push_back(count);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# 2. Approach\\n<!-- Describe your approach to solving the problem. -->\\n*OPTIMIZED APPROACH*\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2logn)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        int i, j, k, count=0;\\n        vector<int> temp1;\\n        vector<int> temp2;\\n        vector<int> ans;\\n        for(i=0 ; i<A.size() ; i++)\\n        {\\n            count=0;\\n            j=0, k=0;\\n            copy(A.begin(), A.begin()+i+1, back_inserter(temp1));\\n            copy(B.begin(), B.begin()+i+1, back_inserter(temp2));\\n            sort(temp1.begin(), temp1.end());\\n            sort(temp2.begin(), temp2.end());\\n            while(j<=i && k<=i)\\n            {\\n                if(temp1[j]==temp2[k])\\n                {\\n                    count++;\\n                    j++;\\n                    k++;\\n                }\\n                else if(temp1[j]<temp2[k])\\n                {\\n                    j++;\\n                }\\n                else if(temp1[j]>temp2[k])\\n                {\\n                    k++;\\n                }\\n            }\\n            temp1.clear();\\n            temp2.clear();\\n            ans.push_back(count);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/4edc6144-1286-417b-a06b-f2c829b9d98e_1684120230.4192863.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        int i, j, k, count=0;\\n        vector<int> ans;\\n        for(i=0 ; i<A.size() ; i++)\\n        {\\n            count=0;\\n            for(j=0 ; j<=i ; j++)\\n            {\\n                for(k=0 ; k<=i ; k++)\\n                {\\n                    if(A[j]==B[k])\\n                    {\\n                        count++;\\n                    }\\n                }\\n            }\\n            ans.push_back(count);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        int i, j, k, count=0;\\n        vector<int> temp1;\\n        vector<int> temp2;\\n        vector<int> ans;\\n        for(i=0 ; i<A.size() ; i++)\\n        {\\n            count=0;\\n            j=0, k=0;\\n            copy(A.begin(), A.begin()+i+1, back_inserter(temp1));\\n            copy(B.begin(), B.begin()+i+1, back_inserter(temp2));\\n            sort(temp1.begin(), temp1.end());\\n            sort(temp2.begin(), temp2.end());\\n            while(j<=i && k<=i)\\n            {\\n                if(temp1[j]==temp2[k])\\n                {\\n                    count++;\\n                    j++;\\n                    k++;\\n                }\\n                else if(temp1[j]<temp2[k])\\n                {\\n                    j++;\\n                }\\n                else if(temp1[j]>temp2[k])\\n                {\\n                    k++;\\n                }\\n            }\\n            temp1.clear();\\n            temp2.clear();\\n            ans.push_back(count);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522472,
                "title": "java-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        int n=A.length;\\n        int ans[]=new int[n];\\n        int index=0;\\n        Set<Integer> s1=new HashSet<>();\\n        Set<Integer> s2=new HashSet<>();\\n         if(A[0]==B[0]){\\n                ans[index++]=1;\\n            }else if(A[0]!=B[0]){\\n                ans[index++]=0;\\n            }\\n            s1.add(A[0]);\\n            s2.add(B[0]);\\n        for(int i=1;i<n;i++)\\n        {\\n            s1.add(A[i]);\\n            s2.add(B[i]);\\n            int c=0;\\n            for(int j:s1){\\n                if(s2.contains(j))c++;\\n            }\\n            ans[index++]=c;\\n        }\\n        return ans;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        int n=A.length;\\n        int ans[]=new int[n];\\n        int index=0;\\n        Set<Integer> s1=new HashSet<>();\\n        Set<Integer> s2=new HashSet<>();\\n         if(A[0]==B[0]){\\n                ans[index++]=1;\\n            }else if(A[0]!=B[0]){\\n                ans[index++]=0;\\n            }\\n            s1.add(A[0]);\\n            s2.add(B[0]);\\n        for(int i=1;i<n;i++)\\n        {\\n            s1.add(A[i]);\\n            s2.add(B[i]);\\n            int c=0;\\n            for(int j:s1){\\n                if(s2.contains(j))c++;\\n            }\\n            ans[index++]=c;\\n        }\\n        return ans;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3519710,
                "title": "c-easy-solution-with-o-n-time-complexity",
                "content": "# Intuition\\nusing ordered map\\n\\n# Approach\\nusing map to count the common values so far.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        vector<int>v;\\n        map<int,int>mp;\\n        int c=0;\\n//traversing through out the vector finding wether vectors have coommon eleemnts in it using map.(if repeated then frequency will be 2)\\n        for(int i=0;i<A.size();i++){\\n            mp[A[i]]++;\\n            if(mp[A[i]]==2){\\n                c++;\\n            }\\n            mp[B[i]]++;\\n             if(mp[B[i]]==2){\\n                c++;\\n            }\\n            v.push_back(c);\\n        }\\n        return v;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        vector<int>v;\\n        map<int,int>mp;\\n        int c=0;\\n//traversing through out the vector finding wether vectors have coommon eleemnts in it using map.(if repeated then frequency will be 2)\\n        for(int i=0;i<A.size();i++){\\n            mp[A[i]]++;\\n            if(mp[A[i]]==2){\\n                c++;\\n            }\\n            mp[B[i]]++;\\n             if(mp[B[i]]==2){\\n                c++;\\n            }\\n            v.push_back(c);\\n        }\\n        return v;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3507561,
                "title": "single-pass-easy-simple-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe need to just need to count the seen element\\'s.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe use a unordered_set to store the count of distinct elements.\\nIf we know that how many elements are new then we can easily calculate the no.of same elsement\\'s.\\n\\nFirst run a loop from i=0 to i<n(size of array) Then we start inserting the each element of both the array\\'s in unordered_set.\\nif any of the element\\'s are same the it not pushed in unordered_set so in this way we can easily know the no. of diffrent element\\'s so far.\\nand then we If all the visited numbers are distinct the the size of unordered_set is  equal to (i+1)*2.\\nAnd by comparing the these two we can easily know the no. of same element\\'s.\\nand that is push_back to the Our answer array(C).\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nAs we run a loop i=0 to i<n \\nTime complexity:$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nAs we use an unordered_set.\\nSpace complexity:$$O(n)$$\\n\\n# Code\\n`If you like the solution then please give an UP-VOTE`\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        unordered_set<int>us;\\n        vector<int>C;\\n        for(int i=0;i<A.size();i++){\\n            us.insert(A[i]);\\n            us.insert(B[i]);\\n            C.push_back((i+1)*2-us.size());\\n        }\\n        return C;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        unordered_set<int>us;\\n        vector<int>C;\\n        for(int i=0;i<A.size();i++){\\n            us.insert(A[i]);\\n            us.insert(B[i]);\\n            C.push_back((i+1)*2-us.size());\\n        }\\n        return C;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3504846,
                "title": "c-simplest-using-only-one-set-only",
                "content": "##### Algorithm \\n* Check if A\\'s index is already present , cnt+1 if yes\\n* Insert A[i] to check with B\\n* Check B\\'s index is already present , cnt+1 if yes\\n* Insert B[i] for \\n\\nWe don\\'t need extra map for 2nd array as we are counting comman indexs from both arrays\\n\\n\\n\\n#####  C++ Code\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        unordered_set<int>s;\\n        int n=A.size();\\n        \\n        vector<int>ans(n);\\n        int cnt=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(s.find(A[i])!=s.end()) cnt++;\\n            s.insert(A[i]);\\n            if(s.find(B[i])!=s.end()) cnt++;\\n            s.insert(B[i]);\\n            \\n            ans[i]=cnt;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n##### Complexity \\n* TC : O(n)\\n* SC : O(2n) : set + ans vector\\n\\n##### *Upvote if it helped you :)*\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        unordered_set<int>s;\\n        int n=A.size();\\n        \\n        vector<int>ans(n);\\n        int cnt=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(s.find(A[i])!=s.end()) cnt++;\\n            s.insert(A[i]);\\n            if(s.find(B[i])!=s.end()) cnt++;\\n            s.insert(B[i]);\\n            \\n            ans[i]=cnt;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3488004,
                "title": "easy-c-solution-using-set",
                "content": "# Complexity\\n- Time complexity: $$O(nlogn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        set<int> st;\\n        int cnt=0;\\n        int n= A.size();\\n        vector<int> ans;\\n        for (int i=0; i<n; i++){\\n            if (st.find(A[i])!=st.end()){\\n                cnt++;\\n            }\\n            else st.insert(A[i]);\\n            if (st.find(B[i])!=st.end()){\\n                cnt++;\\n            }\\n            else st.insert(B[i]);\\n            ans.push_back(cnt);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Counting",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        set<int> st;\\n        int cnt=0;\\n        int n= A.size();\\n        vector<int> ans;\\n        for (int i=0; i<n; i++){\\n            if (st.find(A[i])!=st.end()){\\n                cnt++;\\n            }\\n            else st.insert(A[i]);\\n            if (st.find(B[i])!=st.end()){\\n                cnt++;\\n            }\\n            else st.insert(B[i]);\\n            ans.push_back(cnt);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3481183,
                "title": "c-brute-force-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:$$O(n*logn)$$\\n\\n- Space complexity:$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        map<int, int>m1, m2;\\n        vector<int>ans;\\n        int cnt=0;\\n        for(int i=0; i<A.size(); i++){\\n            m1[A[i]]++;\\n            m2[B[i]]++;\\n            if(m1.find(B[i])!=m1.end()){cnt++;}\\n            if(m2.find(A[i])!=m2.end()){cnt++;}\\n            if(A[i]==B[i]){cnt--;}\\n            ans.push_back(cnt);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        map<int, int>m1, m2;\\n        vector<int>ans;\\n        int cnt=0;\\n        for(int i=0; i<A.size(); i++){\\n            m1[A[i]]++;\\n            m2[B[i]]++;\\n            if(m1.find(B[i])!=m1.end()){cnt++;}\\n            if(m2.find(A[i])!=m2.end()){cnt++;}\\n            if(A[i]==B[i]){cnt--;}\\n            ans.push_back(cnt);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3475896,
                "title": "easy-understanding-o-n-time-complexity",
                "content": "\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n        s = {}\\n        result = []\\n        n = len(A)\\n        count = 0\\n\\n        for i in range(n):\\n            if A[i] in s:\\n                s[A[i]] += 1\\n                count += 1\\n            else:\\n                s[A[i]] = 1\\n\\n            \\n            if B[i] in s:\\n                s[B[i]] += 1\\n                count += 1\\n            else:\\n                s[B[i]] = 1\\n            result.append(count)\\n        return result\\n\\n\\n            \\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n        s = {}\\n        result = []\\n        n = len(A)\\n        count = 0\\n\\n        for i in range(n):\\n            if A[i] in s:\\n                s[A[i]] += 1\\n                count += 1\\n            else:\\n                s[A[i]] = 1\\n\\n            \\n            if B[i] in s:\\n                s[B[i]] += 1\\n                count += 1\\n            else:\\n                s[B[i]] = 1\\n            result.append(count)\\n        return result\\n\\n\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3474066,
                "title": "easy-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& arr1, vector<int>& arr2) \\n\\t{\\n\\t\\tvector<int>ans;\\n\\t\\tvector<int>v;\\n\\t\\tint maxele = *max_element(arr1.begin(),arr1.end());\\n\\t\\tv.resize(maxele+1,0);\\n\\t\\tint count = 0;\\n\\t\\tint idx = 0;\\n\\t\\twhile(idx < arr1.size())\\n\\t\\t{\\n\\t\\t    v[arr1[idx]]++;\\n\\t\\t    v[arr2[idx]]++;\\n\\t\\t    int count = 0;\\n\\t\\t    for(int i=0;i<v.size();i++)\\n\\t\\t    {\\n\\t\\t    \\tif(v[i] == 2)\\n\\t\\t    \\t{\\n\\t\\t    \\t\\tcount++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tans.push_back(count);\\n\\t\\t\\tidx++;\\n\\t\\t}\\n\\t\\treturn ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& arr1, vector<int>& arr2) \\n\\t{\\n\\t\\tvector<int>ans;\\n\\t\\tvector<int>v;\\n\\t\\tint maxele = *max_element(arr1.begin(),arr1.end());\\n\\t\\tv.resize(maxele+1,0);\\n\\t\\tint count = 0;\\n\\t\\tint idx = 0;\\n\\t\\twhile(idx < arr1.size())\\n\\t\\t{\\n\\t\\t    v[arr1[idx]]++;\\n\\t\\t    v[arr2[idx]]++;\\n\\t\\t    int count = 0;\\n\\t\\t    for(int i=0;i<v.size();i++)\\n\\t\\t    {\\n\\t\\t    \\tif(v[i] == 2)\\n\\t\\t    \\t{\\n\\t\\t    \\t\\tcount++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tans.push_back(count);\\n\\t\\t\\tidx++;\\n\\t\\t}\\n\\t\\treturn ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3469415,
                "title": "find-the-prefix-common-array-of-two-arrays-c-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        int n=A.size();\\n        vector<int> ans(n);\\n        ans[0]=0;\\n        ans[n-1]=n;\\n        vector<int> a(n+1,0);\\n        vector<int> b(n+1,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            a[A[i]]=1;\\n            b[B[i]]=1;\\n            int count=0;\\n            for(int j=1;j<=n;j++)\\n            {\\n                if(a[j]==1&&b[j]==1)\\n                {\\n                    count++;\\n                }\\n            }\\n            ans[i]=count;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        int n=A.size();\\n        vector<int> ans(n);\\n        ans[0]=0;\\n        ans[n-1]=n;\\n        vector<int> a(n+1,0);\\n        vector<int> b(n+1,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            a[A[i]]=1;\\n            b[B[i]]=1;\\n            int count=0;\\n            for(int j=1;j<=n;j++)\\n            {\\n                if(a[j]==1&&b[j]==1)\\n                {\\n                    count++;\\n                }\\n            }\\n            ans[i]=count;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3469162,
                "title": "c-solution",
                "content": "```\\nint* findThePrefixCommonArray(int* A, int ASize, int* B, int BSize, int* returnSize){\\n    int* c = (int*)calloc(ASize, sizeof(int));\\n    int* count = (int*)calloc(ASize+1, sizeof(int));\\n    int commonCnt = 0;\\n    for(int i = 0; i < ASize; i++){\\n        count[A[i]]++;\\n        count[B[i]]++;\\n        if(count[A[i]] == 2) commonCnt++;\\n        if(count[B[i]] == 2 && A[i] != B[i]) commonCnt++;\\n        c[i] = commonCnt;\\n    }\\n    *returnSize = ASize;\\n    return c;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint* findThePrefixCommonArray(int* A, int ASize, int* B, int BSize, int* returnSize){\\n    int* c = (int*)calloc(ASize, sizeof(int));\\n    int* count = (int*)calloc(ASize+1, sizeof(int));\\n    int commonCnt = 0;\\n    for(int i = 0; i < ASize; i++){\\n        count[A[i]]++;\\n        count[B[i]]++;\\n        if(count[A[i]] == 2) commonCnt++;\\n        if(count[B[i]] == 2 && A[i] != B[i]) commonCnt++;\\n        c[i] = commonCnt;\\n    }\\n    *returnSize = ASize;\\n    return c;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3468672,
                "title": "hash-table-java-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        int n = A.length;\\n        HashMap<Integer,Integer> mp1 = new HashMap<>();\\n        HashMap<Integer,Integer> mp2 = new HashMap<>();\\n        int[] C = new int[n];\\n        for(int i=0;i<n;i++){\\n            mp1.put(A[i],mp1.getOrDefault(A[i],0)+1);\\n            mp2.put(B[i],mp2.getOrDefault(B[i],0)+1);\\n            for(int x:mp1.keySet()){\\n                if(mp2.containsKey(x)){\\n                    C[i] += Math.min(mp1.get(x),mp2.get(x));\\n                }\\n            }\\n        }\\n        return C;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        int n = A.length;\\n        HashMap<Integer,Integer> mp1 = new HashMap<>();\\n        HashMap<Integer,Integer> mp2 = new HashMap<>();\\n        int[] C = new int[n];\\n        for(int i=0;i<n;i++){\\n            mp1.put(A[i],mp1.getOrDefault(A[i],0)+1);\\n            mp2.put(B[i],mp2.getOrDefault(B[i],0)+1);\\n            for(int x:mp1.keySet()){\\n                if(mp2.containsKey(x)){\\n                    C[i] += Math.min(mp1.get(x),mp2.get(x));\\n                }\\n            }\\n        }\\n        return C;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468175,
                "title": "c",
                "content": "![image](https://assets.leetcode.com/users/images/b5f5c2fb-9367-4e2c-b6eb-593965b340d3_1682824695.380845.png)\\n```\\nint* findThePrefixCommonArray(int* A, int ASize, int* B, int BSize, int* returnSize) {\\n    int arr[51] = {0};\\n    *returnSize = ASize;\\n    int* C = (int*) calloc(ASize, sizeof(int));\\n    arr[A[0]]++;\\n    arr[B[0]]++;\\n    if (A[0] == B[0]) C[0]++;\\n    C[ASize-1] = ASize;\\n    for (int i = 1 ; i < ASize - 1; i++) {\\n        if (arr[A[i]] != 0) {\\n            C[i]++;\\n        } else {\\n            arr[A[i]]++;\\n        }\\n        if (arr[B[i]] != 0) {\\n            C[i]++;\\n        } else {\\n            arr[B[i]]++;\\n        }\\n        C[i] += C[i-1];\\n    }\\n    return C;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint* findThePrefixCommonArray(int* A, int ASize, int* B, int BSize, int* returnSize) {\\n    int arr[51] = {0};\\n    *returnSize = ASize;\\n    int* C = (int*) calloc(ASize, sizeof(int));\\n    arr[A[0]]++;\\n    arr[B[0]]++;\\n    if (A[0] == B[0]) C[0]++;\\n    C[ASize-1] = ASize;\\n    for (int i = 1 ; i < ASize - 1; i++) {\\n        if (arr[A[i]] != 0) {\\n            C[i]++;\\n        } else {\\n            arr[A[i]]++;\\n        }\\n        if (arr[B[i]] != 0) {\\n            C[i]++;\\n        } else {\\n            arr[B[i]]++;\\n        }\\n        C[i] += C[i-1];\\n    }\\n    return C;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3467669,
                "title": "c-code-using-vector",
                "content": "# Complexity\\n- Time complexity:\\n   O(N)\\n\\n- Space complexity:\\n O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        int n=A.size();\\n        vector<int>fr(n+1);\\n        vector<int>ans(n,0);\\n        int ct=0;\\n\\n        for(int i=0;i<n;i++){\\n            if(++fr[A[i]]==2)ct++;\\n            if(++fr[B[i]]==2)ct++;\\n            ans[i]=ct;\\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        int n=A.size();\\n        vector<int>fr(n+1);\\n        vector<int>ans(n,0);\\n        int ct=0;\\n\\n        for(int i=0;i<n;i++){\\n            if(++fr[A[i]]==2)ct++;\\n            if(++fr[B[i]]==2)ct++;\\n            ans[i]=ct;\\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467653,
                "title": "simple-python-solution-using-intersection-between-the-sets",
                "content": "# Approach:\\nPerform intersection of both the sets after adding each new element in both the sets A and B\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n        setA,setB,n,res=set(),set(),len(A),list()\\n        for i in range(n):\\n            setA.add(A[i])\\n            setB.add(B[i])\\n            res.append(len(setA.intersection(setB)))\\n        return res       \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n        setA,setB,n,res=set(),set(),len(A),list()\\n        for i in range(n):\\n            setA.add(A[i])\\n            setB.add(B[i])\\n            res.append(len(setA.intersection(setB)))\\n        return res       \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467279,
                "title": "easy-solution-with-the-explaination",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\ngo to the index and check the previous elements\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n-go to each and every element \\n-and check the prior elements if they match then increment the count variable initialised with zero\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) \\n    {\\n        vector<int>ans;\\n        int count=0;\\n        for(int i=0;i<A.size();i++)\\n        {\\n            for(int j=0;j<=i;j++)\\n            {\\n                for(int k=0;k<=i;k++)\\n                {\\n                    if( A[j]==B[k])\\n                        count++;\\n                }\\n            }\\n            ans.push_back(count);\\n            count=0;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# upvote me for the solution comment if any doubts\\n![images.jpeg](https://assets.leetcode.com/users/images/08f7a485-5bb3-4a9b-a6d6-5a4b513d8d6d_1682789008.721314.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "String Matching"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) \\n    {\\n        vector<int>ans;\\n        int count=0;\\n        for(int i=0;i<A.size();i++)\\n        {\\n            for(int j=0;j<=i;j++)\\n            {\\n                for(int k=0;k<=i;k++)\\n                {\\n                    if( A[j]==B[k])\\n                        count++;\\n                }\\n            }\\n            ans.push_back(count);\\n            count=0;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467278,
                "title": "easy-solution-with-the-explaination",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\ngo to the index and check the previous elements\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n-go to each and every element \\n-and check the prior elements if they match then increment the count variable initialised with zero\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) \\n    {\\n        vector<int>ans;\\n        int count=0;\\n        for(int i=0;i<A.size();i++)\\n        {\\n            for(int j=0;j<=i;j++)\\n            {\\n                for(int k=0;k<=i;k++)\\n                {\\n                    if( A[j]==B[k])\\n                        count++;\\n                }\\n            }\\n            ans.push_back(count);\\n            count=0;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# upvote me for the solution comment if any doubts\\n![images.jpeg](https://assets.leetcode.com/users/images/08f7a485-5bb3-4a9b-a6d6-5a4b513d8d6d_1682789008.721314.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "String Matching"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) \\n    {\\n        vector<int>ans;\\n        int count=0;\\n        for(int i=0;i<A.size();i++)\\n        {\\n            for(int j=0;j<=i;j++)\\n            {\\n                for(int k=0;k<=i;k++)\\n                {\\n                    if( A[j]==B[k])\\n                        count++;\\n                }\\n            }\\n            ans.push_back(count);\\n            count=0;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467189,
                "title": "using-set-damn-easy-and-short-code",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        // vector<int> ans;\\n        int n=A.size();\\n        vector<int> ans(n,0);\\n        set<int> st;\\n        for(int i=0;i<n;i++){\\n            int cnt=0;\\n            st.insert(A[i]);\\n            for(int j=i;j>=0;j--){\\n                if(st.find(B[j])!=st.end())cnt++;\\n            }\\n            ans[i]=cnt;\\n        }\\n        return ans;\\n    }\\n};```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        // vector<int> ans;\\n        int n=A.size();\\n        vector<int> ans(n,0);\\n        set<int> st;\\n        for(int i=0;i<n;i++){\\n            int cnt=0;\\n            st.insert(A[i]);\\n            for(int j=i;j>=0;j--){\\n                if(st.find(B[j])!=st.end())cnt++;\\n            }\\n            ans[i]=cnt;\\n        }\\n        return ans;\\n    }\\n};```",
                "codeTag": "Java"
            },
            {
                "id": 3467150,
                "title": "simplest-solution-o-n-hashset-java",
                "content": "# Code\\n```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        HashSet<Integer> hs=new HashSet<>();\\n        int []out=new int[A.length];\\n        for(int i=0;i<A.length;i++){\\n            hs.add(A[i]);\\n            hs.add(B[i]);\\n            out[i]=2*(i+1)-hs.size();\\n        }\\n\\n        return out;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        HashSet<Integer> hs=new HashSet<>();\\n        int []out=new int[A.length];\\n        for(int i=0;i<A.length;i++){\\n            hs.add(A[i]);\\n            hs.add(B[i]);\\n            out[i]=2*(i+1)-hs.size();\\n        }\\n\\n        return out;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467148,
                "title": "c-easy-approach-using-set",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        int n=A.size();\\n        set<int> st1;\\n        set<int> st2;\\n        vector<int> ans(n,0);\\n        if(A[0]==B[0])\\n            ans[0]=1;\\n        st1.insert(A[0]);\\n        st2.insert(B[0]);\\n        for(int i=1;i<n;i++)\\n        {\\n            st1.insert(A[i]);\\n            st2.insert(B[i]);\\n            int cnt=0;\\n            for(int x:st1)\\n            {\\n                if(st2.find(x)!=st2.end())\\n                    cnt++;\\n            }\\n            ans[i]=cnt;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        int n=A.size();\\n        set<int> st1;\\n        set<int> st2;\\n        vector<int> ans(n,0);\\n        if(A[0]==B[0])\\n            ans[0]=1;\\n        st1.insert(A[0]);\\n        st2.insert(B[0]);\\n        for(int i=1;i<n;i++)\\n        {\\n            st1.insert(A[i]);\\n            st2.insert(B[i]);\\n            int cnt=0;\\n            for(int x:st1)\\n            {\\n                if(st2.find(x)!=st2.end())\\n                    cnt++;\\n            }\\n            ans[i]=cnt;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467105,
                "title": "simple-easy-8-line-of-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        vector<int>ans;\\n        unordered_set<int>st;\\n        for(int i=0; i<A.size(); i++) {\\n            st.insert(A[i]);\\n            st.insert(B[i]);\\n            int t= 2*(i+1)- st.size();\\n            ans.push_back(t);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        vector<int>ans;\\n        unordered_set<int>st;\\n        for(int i=0; i<A.size(); i++) {\\n            st.insert(A[i]);\\n            st.insert(B[i]);\\n            int t= 2*(i+1)- st.size();\\n            ans.push_back(t);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466989,
                "title": "java-solution-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        int[] arr = new int[A.length];\\n        int index = 0;\\n        \\n        for(int i = 0; i < A.length; i++) {\\n            int count = 0;\\n            Set<Integer> set = new HashSet<>();\\n            \\n            for(int j = 0; j <= i; j++) {\\n                set.add(A[j]);\\n            }\\n            \\n            for(int k = 0; k <= i; k++) {\\n                if(!set.add(B[k])) {\\n                    count++;\\n                }\\n            }\\n            \\n            arr[index++] = count;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        int[] arr = new int[A.length];\\n        int index = 0;\\n        \\n        for(int i = 0; i < A.length; i++) {\\n            int count = 0;\\n            Set<Integer> set = new HashSet<>();\\n            \\n            for(int j = 0; j <= i; j++) {\\n                set.add(A[j]);\\n            }\\n            \\n            for(int k = 0; k <= i; k++) {\\n                if(!set.add(B[k])) {\\n                    count++;\\n                }\\n            }\\n            \\n            arr[index++] = count;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466930,
                "title": "c-easy-to-understand-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSo we know that we have to get common elements till i, while iterating in array.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nNow if we have 1 at position 0 in vector 1 and position 2 in vector 2, then 1 won\\'t be common till positon 2. \\n\\nSo we get choose maximum of indices for this number and store it in common array.\\n\\nNow we have a ans vector, to store the total new answers we have for a particular indice in the array.\\n\\nNow for our answer, we know from above example at positon 2 we will have this pair as answer. But all of the pairs behind are also the answer.\\n\\nSo to add those we run the last loop.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n  O(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n  O(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        int n = A.size();\\n        \\n        vector<int> common(n+1,0);\\n        \\n        for (int i=0;i<n;i++) {\\n            common[A[i]] = max(common[A[i]],i);\\n            common[B[i]] = max(common[B[i]],i);\\n        } \\n        \\n        vector<int> ans(n,0);\\n\\n        for (int i=0;i<n;i++) {\\n            ans[common[i+1]]++;\\n        }\\n        \\n        \\n        for (int i=1;i<n;i++) {\\n            ans[i] += ans[i-1];\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        int n = A.size();\\n        \\n        vector<int> common(n+1,0);\\n        \\n        for (int i=0;i<n;i++) {\\n            common[A[i]] = max(common[A[i]],i);\\n            common[B[i]] = max(common[B[i]],i);\\n        } \\n        \\n        vector<int> ans(n,0);\\n\\n        for (int i=0;i<n;i++) {\\n            ans[common[i+1]]++;\\n        }\\n        \\n        \\n        for (int i=1;i<n;i++) {\\n            ans[i] += ans[i-1];\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466894,
                "title": "java-contest-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        HashMap<Integer,Integer> m1 = new HashMap<>();\\n        HashMap<Integer,Integer> m2 = new HashMap<>();\\n        int[] ans = new int[A.length];\\n        int a=0;\\n        for(int i=0;i<A.length;i++){\\n            m1.put(A[i],1);\\n            m2.put(B[i],1);\\n            int e = 0;\\n            for(int j=0;j<=i;j++){\\n                if(m1.containsKey(B[j])){\\n                    for(j=0;j<=i;j++){\\n                        if( m2.containsKey(A[j])){\\n                            ans[i]=a+1;\\n                    a++;\\n                 e=ans[i];\\n                        }\\n                    }\\n                \\n              }\\n                \\n            }\\n            a=0;\\n            \\n           ans[i]=e;\\n            \\n            \\n\\n        }\\n        return ans;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        HashMap<Integer,Integer> m1 = new HashMap<>();\\n        HashMap<Integer,Integer> m2 = new HashMap<>();\\n        int[] ans = new int[A.length];\\n        int a=0;\\n        for(int i=0;i<A.length;i++){\\n            m1.put(A[i],1);\\n            m2.put(B[i],1);\\n            int e = 0;\\n            for(int j=0;j<=i;j++){\\n                if(m1.containsKey(B[j])){\\n                    for(j=0;j<=i;j++){\\n                        if( m2.containsKey(A[j])){\\n                            ans[i]=a+1;\\n                    a++;\\n                 e=ans[i];\\n                        }\\n                    }\\n                \\n              }\\n                \\n            }\\n            a=0;\\n            \\n           ans[i]=e;\\n            \\n            \\n\\n        }\\n        return ans;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466867,
                "title": "easy-java-solution-sets-o-n-approach",
                "content": "\\n# Approach\\nTake a Set and start putting values inside it one by one. Make a expected Size which would represent the exptected size of the set if all the elements are unique.\\n\\nNow, if there are unique elements, then set wouldn\\'t add those elements, and therefore subtracting exptectedSize with the set size would result to our answer\\n\\n- Time complexity:\\nSince we traverse the array, therefore complexity would be O(N)\\n# Code\\n```\\nclass Solution {\\n    public static int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        Set<Integer> set = new HashSet<>();\\n        int[] ans = new int[A.length];\\n        int expectedSize = 2;\\n        for(int i = 0; i< A.length; i++){\\n            set.add(A[i]);\\n            set.add(B[i]);\\n\\n            ans[i] = expectedSize-set.size();\\n            expectedSize+=2;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public static int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        Set<Integer> set = new HashSet<>();\\n        int[] ans = new int[A.length];\\n        int expectedSize = 2;\\n        for(int i = 0; i< A.length; i++){\\n            set.add(A[i]);\\n            set.add(B[i]);\\n\\n            ans[i] = expectedSize-set.size();\\n            expectedSize+=2;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466793,
                "title": "simple-code-using-mapping",
                "content": "# Code\\n```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        boolean t[] = new boolean[51];\\n        int len = A.length;\\n        int C[] = new int[len];\\n        int count = 0;\\n        for(int i=0; i<len; i++){\\n            \\n            if(t[A[i]] && t[B[i]]){\\n                count+=2;\\n                C[i] = count;\\n            }  \\n\\n            else if(t[A[i]] || t[B[i]] || A[i] == B[i] ) C[i] = ++count;\\n\\n            else C[i] = count;\\n            \\n            t[A[i]] = true;\\n            t[B[i]] = true;\\n        }\\n        return C;\\n    }   \\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        boolean t[] = new boolean[51];\\n        int len = A.length;\\n        int C[] = new int[len];\\n        int count = 0;\\n        for(int i=0; i<len; i++){\\n            \\n            if(t[A[i]] && t[B[i]]){\\n                count+=2;\\n                C[i] = count;\\n            }  \\n\\n            else if(t[A[i]] || t[B[i]] || A[i] == B[i] ) C[i] = ++count;\\n\\n            else C[i] = count;\\n            \\n            t[A[i]] = true;\\n            t[B[i]] = true;\\n        }\\n        return C;\\n    }   \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466783,
                "title": "only-map-tc-o-n-easy-understsnding-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        int n=A.size();\\n        vector<int> c(n);\\n        unordered_map<int , int> mp;\\n        int prevsum=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(mp[A[i]] || mp[B[i]] || (A[i]==B[i]))\\n            {\\n                if(A[i]==B[i])\\n                {\\n                   c[i]=prevsum+mp[A[i]]+mp[B[i]]+1; \\n                }\\n                else\\n                {\\n                    c[i]=prevsum+mp[A[i]]+mp[B[i]];\\n                }\\n                \\n            }\\n            else\\n            {\\n                c[i]=0+prevsum;\\n            }\\n            prevsum=c[i];\\n            mp[A[i]]=1;\\n            mp[B[i]]=1;\\n            \\n        }\\n        return c;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        int n=A.size();\\n        vector<int> c(n);\\n        unordered_map<int , int> mp;\\n        int prevsum=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(mp[A[i]] || mp[B[i]] || (A[i]==B[i]))\\n            {\\n                if(A[i]==B[i])\\n                {\\n                   c[i]=prevsum+mp[A[i]]+mp[B[i]]+1; \\n                }\\n                else\\n                {\\n                    c[i]=prevsum+mp[A[i]]+mp[B[i]];\\n                }\\n                \\n            }\\n            else\\n            {\\n                c[i]=0+prevsum;\\n            }\\n            prevsum=c[i];\\n            mp[A[i]]=1;\\n            mp[B[i]]=1;\\n            \\n        }\\n        return c;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466761,
                "title": "dart-solution-using-hashmaps",
                "content": "\\n# Code\\n```\\nclass Solution {\\n  List<int> findThePrefixCommonArray(List<int> A, List<int> B) {\\n    List<int> result = [];\\n    for (int i = 1; i <= A.length; i++) {\\n      result.add(countCommonNumbers(A.sublist(0, i), B.sublist(0, i)));\\n    }\\n    return result;\\n  }\\n\\n  int countCommonNumbers(List<int> A, List<int> B) {\\n    Map<int, int> freq1 = {};\\n    Map<int, int> freq2 = {};\\n\\n    int result = 0;\\n\\n    for (int i = 0; i < A.length; i++) {\\n      if (!freq1.containsKey(A[i])) {\\n        freq1[A[i]] = 1;\\n      } else {\\n        freq1[A[i]] = freq1[A[i]]! + 1;\\n      }\\n    }\\n\\n    for (int i = 0; i < B.length; i++) {\\n      if (!freq2.containsKey(B[i])) {\\n        freq2[B[i]] = 1;\\n      } else {\\n        freq2[B[i]] = freq2[B[i]]! + 1;\\n      }\\n    }\\n\\n    for (var x in freq1.entries) {\\n      int countsInA = x.value;\\n      int countsInB = 0;\\n      if (freq2.containsKey(x.key)) {\\n        countsInB = freq2[x.key]!;\\n      }\\n      result += countsInA < countsInB ? countsInA : countsInB;\\n    }\\n    return result;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  List<int> findThePrefixCommonArray(List<int> A, List<int> B) {\\n    List<int> result = [];\\n    for (int i = 1; i <= A.length; i++) {\\n      result.add(countCommonNumbers(A.sublist(0, i), B.sublist(0, i)));\\n    }\\n    return result;\\n  }\\n\\n  int countCommonNumbers(List<int> A, List<int> B) {\\n    Map<int, int> freq1 = {};\\n    Map<int, int> freq2 = {};\\n\\n    int result = 0;\\n\\n    for (int i = 0; i < A.length; i++) {\\n      if (!freq1.containsKey(A[i])) {\\n        freq1[A[i]] = 1;\\n      } else {\\n        freq1[A[i]] = freq1[A[i]]! + 1;\\n      }\\n    }\\n\\n    for (int i = 0; i < B.length; i++) {\\n      if (!freq2.containsKey(B[i])) {\\n        freq2[B[i]] = 1;\\n      } else {\\n        freq2[B[i]] = freq2[B[i]]! + 1;\\n      }\\n    }\\n\\n    for (var x in freq1.entries) {\\n      int countsInA = x.value;\\n      int countsInB = 0;\\n      if (freq2.containsKey(x.key)) {\\n        countsInB = freq2[x.key]!;\\n      }\\n      result += countsInA < countsInB ? countsInA : countsInB;\\n    }\\n    return result;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466734,
                "title": "python-set-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n        seen_of_A = set()\\n        seen_of_B = set()\\n        c=[0]*len(A)\\n        common=0\\n        for i in range(len(A)):\\n            if A[i]==B[i]:\\n                common +=1\\n            if A[i] in seen_of_B:\\n                common +=1\\n            if B[i] in seen_of_A:\\n                common +=1\\n            c[i] = common\\n            seen_of_A.add(A[i])\\n            seen_of_B.add(B[i])\\n        return c\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n        seen_of_A = set()\\n        seen_of_B = set()\\n        c=[0]*len(A)\\n        common=0\\n        for i in range(len(A)):\\n            if A[i]==B[i]:\\n                common +=1\\n            if A[i] in seen_of_B:\\n                common +=1\\n            if B[i] in seen_of_A:\\n                common +=1\\n            c[i] = common\\n            seen_of_A.add(A[i])\\n            seen_of_B.add(B[i])\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466686,
                "title": "python-1-line",
                "content": "```python\\nclass Solution:\\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n        return [len(set(A[:i+1]) & set(B[:i+1])) for i in range(len(A))]\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n        return [len(set(A[:i+1]) & set(B[:i+1])) for i in range(len(A))]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466669,
                "title": "c-map",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        unordered_map<int,int> mp1,mp2;\\n        int cnt=0;\\n        vector<int> ans;\\n        for(int i=0;i<A.size();i++){\\n            mp1[A[i]]++;\\n            mp2[B[i]]++;\\n            \\n            if(mp1.find(B[i])!=mp1.end()){\\n                cnt+=1;\\n            }\\n            if(mp2.find(A[i])!=mp2.end() && A[i]!=B[i]){\\n                cnt+=1;\\n            }\\n            ans.push_back(cnt);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        unordered_map<int,int> mp1,mp2;\\n        int cnt=0;\\n        vector<int> ans;\\n        for(int i=0;i<A.size();i++){\\n            mp1[A[i]]++;\\n            mp2[B[i]]++;\\n            \\n            if(mp1.find(B[i])!=mp1.end()){\\n                cnt+=1;\\n            }\\n            if(mp2.find(A[i])!=mp2.end() && A[i]!=B[i]){\\n                cnt+=1;\\n            }\\n            ans.push_back(cnt);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466650,
                "title": "beginner-friendly-java-one-loop",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        int[] ans = new int[A.length];\\n        int[] arr=new int[A.length+1];\\n        int idx=0;\\n        int x=0;\\n        while(idx<A.length)\\n        {\\n            arr[A[idx]]++;\\n            arr[B[idx]]++;\\n            if(arr[A[idx]]==2)x++;\\n            if(arr[B[idx]]==2)x++;\\n            \\n            if(A[idx]==B[idx])x--;\\n            ans[idx]=x;\\n            idx++;\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        int[] ans = new int[A.length];\\n        int[] arr=new int[A.length+1];\\n        int idx=0;\\n        int x=0;\\n        while(idx<A.length)\\n        {\\n            arr[A[idx]]++;\\n            arr[B[idx]]++;\\n            if(arr[A[idx]]==2)x++;\\n            if(arr[B[idx]]==2)x++;\\n            \\n            if(A[idx]==B[idx])x--;\\n            ans[idx]=x;\\n            idx++;\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4097211,
                "title": "best-solution-using-hash-map-in-c",
                "content": "\\n# C++\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        vector <int> v1;\\n        map <int , int> mp;\\n        for(int i = 0; i < A.size(); i++) {\\n            mp[A[i]] = i;\\n            int count = 0;\\n            for(int j = 0; j < mp.size(); j++) {\\n                if(mp.find(B[j]) != mp.end()) {\\n                    count++;\\n                }\\n            }\\n            v1.push_back(count);\\n        }\\n        return v1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        vector <int> v1;\\n        map <int , int> mp;\\n        for(int i = 0; i < A.size(); i++) {\\n            mp[A[i]] = i;\\n            int count = 0;\\n            for(int j = 0; j < mp.size(); j++) {\\n                if(mp.find(B[j]) != mp.end()) {\\n                    count++;\\n                }\\n            }\\n            v1.push_back(count);\\n        }\\n        return v1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4097156,
                "title": "best-solution-using-brute-force-in-c",
                "content": "\\n# C++\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        vector <int> v1;\\n        for(int i = 0; i < A.size(); i++) {\\n            int count = 0;\\n            for(int j = 0; j < i+1; j++) {\\n                for(int k = 0; k < i+1; k++) {\\n                    if(B[k] == A[j]) {\\n                        count++;\\n                    }\\n                }\\n            }\\n            v1.push_back(count);\\n        }\\n        return v1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        vector <int> v1;\\n        for(int i = 0; i < A.size(); i++) {\\n            int count = 0;\\n            for(int j = 0; j < i+1; j++) {\\n                for(int k = 0; k < i+1; k++) {\\n                    if(B[k] == A[j]) {\\n                        count++;\\n                    }\\n                }\\n            }\\n            v1.push_back(count);\\n        }\\n        return v1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4095762,
                "title": "using-simple-map-c-o-n-beats-others",
                "content": "\\n\\nTIME COMPLEXITY IS O(N)\\nAFTER READING SOLUTION STILL FACE ANY DOUBTS-\\n1> COMMENT BELOW , I M ACTIVE ON LC \\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n   \\'\\'\\'     // FIRST STEP IS TO CHECK \\n        // PHLA ELEMENT DONO array ka same h ya alag h \\n        vector<int>v;\\n        int count=0;\\n        if(A[0]==B[0])\\n        {\\n            count++; // same number mila to count 0->1\\n            v.push_back(count); // store kra lo count ko 0 index par\\n        }\\n        else\\n        {\\n            //remain count be 0 bcz dono element alg h \\n            v.push_back(0);\\n        }\\n        // now bcz we have visited 0 index elements of a and b \\n        // now we will store them in map\\n        \\n        unordered_map<int,int>mp;  //key,frequency\\n        mp[A[0]]++;\\n        mp[B[0]]++;\\n        \\n        //now we must traverse for index 1 to n-1\\n        \\n        for(int i=1;i<A.size();i++)\\n        {\\n            //check if they are same \\n            if(A[i]==B[i])\\n            {\\n                count++;  //  for eg a[0],b[0] = 1,3 and a[1]b[1]= 1,1 toh 1 -> comes 3 times ..so common pair for both array will be only 1,1 so count+=1;\\n                \\n                v.push_back(count);\\n            }\\n            else\\n            {\\n                //agr same ni different ho tbh \\n                //check kro vo map mh h ya nhi , if exist in map then we can count them as repeated \\n                if(mp.find(A[i])!=mp.end())   \\n                {   count++; }\\n                if(mp.find(B[i])!=mp.end())\\n                {\\n                    count++;\\n                }\\n                  v.push_back(count);\\n                // add all visited elemnts in map \\n                mp[A[i]]++;\\n                mp[B[i]]++;\\n            }\\n        }\\n        \\n      return v;\\n        \\'\\'\\'\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n   \\'\\'\\'     // FIRST STEP IS TO CHECK \\n        // PHLA ELEMENT DONO array ka same h ya alag h \\n        vector<int>v;\\n        int count=0;\\n        if(A[0]==B[0])\\n        {\\n            count++; // same number mila to count 0->1\\n            v.push_back(count); // store kra lo count ko 0 index par\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 4090389,
                "title": "o-n-solution-one-set-easely-can-be-rewriten-for-any-language",
                "content": "# Intuition\\nThere were too many overcomplicated solutions so I decided to try to use only one Set \\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        int[] res = new int[A.length];\\n        \\n        HashSet<Integer> mem = new HashSet<>();\\n        mem.add(A[0]); \\n        res[0] = mem.add(B[0]) ? 0 : 1; // if first value eq second value then it\\'s common prefix \\n\\n        for (int i = 1; i < res.length; i++) {\\n            int c = mem.add(A[i]) ? 0 : 1;\\n            c += mem.add(B[i]) ? 0 : 1;\\n            res[i] = c + res[i - 1]; // number of common prefixes can\\'t decrease, so we can reuse calculated on previous iteration value\\n        }\\n\\n        return res;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        int[] res = new int[A.length];\\n        \\n        HashSet<Integer> mem = new HashSet<>();\\n        mem.add(A[0]); \\n        res[0] = mem.add(B[0]) ? 0 : 1; // if first value eq second value then it\\'s common prefix \\n\\n        for (int i = 1; i < res.length; i++) {\\n            int c = mem.add(A[i]) ? 0 : 1;\\n            c += mem.add(B[i]) ? 0 : 1;\\n            res[i] = c + res[i - 1]; // number of common prefixes can\\'t decrease, so we can reuse calculated on previous iteration value\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4079189,
                "title": "solve-using-stack-o-n-complexity",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def findThePrefixCommonArray(self, a: List[int], b: List[int]) -> List[int]:\\n        stack = []\\n        i = 0\\n        n = len(a)\\n        count = 0\\n        ans = [0]*n\\n        while i<n:\\n            #if num in stack, increase count else add in stack\\n            if a[i] in stack: count +=1\\n            if a[i] not in stack:\\n                stack.append(a[i])\\n            #if num in stack, increase count else add in stack\\n            if b[i] in stack: count +=1\\n            if b[i] not in stack:\\n                stack.append(b[i])\\n            ans[i] = count\\n            i+=1\\n        return ans\\n            \\n```",
                "solutionTags": [
                    "Python3",
                    "Stack",
                    "Counting"
                ],
                "code": "```\\nclass Solution:\\n    def findThePrefixCommonArray(self, a: List[int], b: List[int]) -> List[int]:\\n        stack = []\\n        i = 0\\n        n = len(a)\\n        count = 0\\n        ans = [0]*n\\n        while i<n:\\n            #if num in stack, increase count else add in stack\\n            if a[i] in stack: count +=1\\n            if a[i] not in stack:\\n                stack.append(a[i])\\n            #if num in stack, increase count else add in stack\\n            if b[i] in stack: count +=1\\n            if b[i] not in stack:\\n                stack.append(b[i])\\n            ans[i] = count\\n            i+=1\\n        return ans\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4073550,
                "title": "easy-to-understand-python3-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n        ans = [0] * len(A)\\n\\n        for i in range(len(A)):\\n            common_A = Counter(A[:i+1])\\n            common_B = Counter(B[:i+1])\\n            common = common_A & common_B\\n            ans[i] = len(common)\\n\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n        ans = [0] * len(A)\\n\\n        for i in range(len(A)):\\n            common_A = Counter(A[:i+1])\\n            common_B = Counter(B[:i+1])\\n            common = common_A & common_B\\n            ans[i] = len(common)\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4071263,
                "title": "a-simple-solution-with-two-sets-beats-94",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n        seen_a, seen_b = set(), set()\\n        counter, counts = 0, []\\n        for a, b in zip(A,B):\\n            seen_a.add(a)\\n            seen_b.add(b)\\n            counter += (a in seen_b) + (b in seen_a) - (a == b)\\n            counts.append(counter)\\n\\n        return counts\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n        seen_a, seen_b = set(), set()\\n        counter, counts = 0, []\\n        for a, b in zip(A,B):\\n            seen_a.add(a)\\n            seen_b.add(b)\\n            counter += (a in seen_b) + (b in seen_a) - (a == b)\\n            counts.append(counter)\\n\\n        return counts\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4065710,
                "title": "super-easy-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n\\n        int cnt=0;\\n        vector<int>v;\\n        unordered_map<int,int>mp1;\\n        for(int i=0;i<A.size();i++)\\n        {\\n            if(A[i]==B[i])\\n            {\\n                cnt++;\\n            }\\n            if(mp1.find(A[i])!=mp1.end())\\n            {\\n                cnt++;\\n            }\\n            if(mp1.find(B[i])!=mp1.end())\\n            {\\n                cnt++;\\n            }\\n            mp1[A[i]]++;\\n            mp1[B[i]]++;\\n            v.push_back(cnt);\\n        }\\n        return v;\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n\\n        int cnt=0;\\n        vector<int>v;\\n        unordered_map<int,int>mp1;\\n        for(int i=0;i<A.size();i++)\\n        {\\n            if(A[i]==B[i])\\n            {\\n                cnt++;\\n            }\\n            if(mp1.find(A[i])!=mp1.end())\\n            {\\n                cnt++;\\n            }\\n            if(mp1.find(B[i])!=mp1.end())\\n            {\\n                cnt++;\\n            }\\n            mp1[A[i]]++;\\n            mp1[B[i]]++;\\n            v.push_back(cnt);\\n        }\\n        return v;\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4058591,
                "title": "java-simple-set",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        int C[]=new int[A.length];\\n        Set<Integer> set = new HashSet();\\n        set.add(A[0]);\\n        set.add(B[0]);\\n        C[0]=A[0]==B[0]?1:0;\\n   \\n   \\n     \\n        for(int i=1;i<A.length;i++){\\n               \\n               if(A[i]!=B[i]){\\n               C[i]=C[i-1]+(set.contains(B[i])?1:0);\\n               C[i]+=set.contains(A[i])?1:0;\\n               }\\n               else{\\n            C[i]=C[i-1]+1;\\n               }\\n            \\n set.add(A[i]);\\n        set.add(B[i]);\\n        }\\nreturn C;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        int C[]=new int[A.length];\\n        Set<Integer> set = new HashSet();\\n        set.add(A[0]);\\n        set.add(B[0]);\\n        C[0]=A[0]==B[0]?1:0;\\n   \\n   \\n     \\n        for(int i=1;i<A.length;i++){\\n               \\n               if(A[i]!=B[i]){\\n               C[i]=C[i-1]+(set.contains(B[i])?1:0);\\n               C[i]+=set.contains(A[i])?1:0;\\n               }\\n               else{\\n            C[i]=C[i-1]+1;\\n               }\\n            \\n set.add(A[i]);\\n        set.add(B[i]);\\n        }\\nreturn C;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4053192,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport java.util.HashMap;\\n\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        int[] result = new int[A.length];\\n        HashMap<Integer, Integer> mapA = new HashMap<>();\\n        HashMap<Integer, Integer> mapB = new HashMap<>();\\n        for(int i=0; i<A.length; i++) {\\n            mapA.put(A[i], mapA.getOrDefault(A[i], 0)+1);\\n            mapB.put(B[i], mapB.getOrDefault(B[i], 0)+1);\\n            for(int a: mapA.keySet()) {\\n                if(mapB.containsKey(a)) {\\n                    result[i] += mapA.get(a);\\n                }\\n            }\\n        }\\n        for(int i=0; i<result.length; i++) {\\n            System.out.println(result[i]);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nimport java.util.HashMap;\\n\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        int[] result = new int[A.length];\\n        HashMap<Integer, Integer> mapA = new HashMap<>();\\n        HashMap<Integer, Integer> mapB = new HashMap<>();\\n        for(int i=0; i<A.length; i++) {\\n            mapA.put(A[i], mapA.getOrDefault(A[i], 0)+1);\\n            mapB.put(B[i], mapB.getOrDefault(B[i], 0)+1);\\n            for(int a: mapA.keySet()) {\\n                if(mapB.containsKey(a)) {\\n                    result[i] += mapA.get(a);\\n                }\\n            }\\n        }\\n        for(int i=0; i<result.length; i++) {\\n            System.out.println(result[i]);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4046828,
                "title": "very-easy-c-code-beginner-friendly",
                "content": "# Intuition\\nThe intution is to use 2 hash maps to keep check of what integers we\\'ve encountered so far in both vectors A and B. As we pass through an integer we\\'ll add that number and it\\'s freq(1) in the maps.\\nthen in second loop we\\'ll iterate through maps. As it is given that size of both arrays will be equal, that means size of hashMaps will also be equal, till integers traversed. \\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        vector<int>ans;\\n         int count=0;\\n         unordered_map<int,int>mp1;\\n         unordered_map<int,int>mp2;\\n         \\n         for(int i=0;i<A.size();i++)\\n            count=0;\\n             int j=0;\\n            mp1[A[i]]=1;\\n            mp2[B[i]]=1;\\n            for(auto x:mp1)\\n           {\\n              if(mp2.find(x.first)!=mp2.end() && x.second==mp2[B[j]] )\\n              \\n              {\\n                  count++;\\n              }\\n              \\n              j++;\\n           }\\n           ans.push_back(count);\\n         }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        vector<int>ans;\\n         int count=0;\\n         unordered_map<int,int>mp1;\\n         unordered_map<int,int>mp2;\\n         \\n         for(int i=0;i<A.size();i++)\\n            count=0;\\n             int j=0;\\n            mp1[A[i]]=1;\\n            mp2[B[i]]=1;\\n            for(auto x:mp1)\\n           {\\n              if(mp2.find(x.first)!=mp2.end() && x.second==mp2[B[j]] )\\n              \\n              {\\n                  count++;\\n              }\\n              \\n              j++;\\n           }\\n           ans.push_back(count);\\n         }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4045163,
                "title": "1ms-100-java-no-map",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBasically whenever a number has occured two times, that is in both arrays, we increment count.So, count keeps track of all the COMMON elements that have occured yet in both arrays. So in each iteration we put value of count in our ans array\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        int[]frq  = new int[A.length+1];\\n        int[]ans  = new int[A.length];\\n        int count=0;\\n\\n        for(int i=0; i<ans.length; i++){\\n            frq[A[i]]++;\\n            if(frq[A[i]] == 2) count++;\\n            frq[B[i]]++;\\n            if(frq[B[i]] == 2) count++;\\n\\n            ans[i] = count;\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        int[]frq  = new int[A.length+1];\\n        int[]ans  = new int[A.length];\\n        int count=0;\\n\\n        for(int i=0; i<ans.length; i++){\\n            frq[A[i]]++;\\n            if(frq[A[i]] == 2) count++;\\n            frq[B[i]]++;\\n            if(frq[B[i]] == 2) count++;\\n\\n            ans[i] = count;\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4043985,
                "title": "short-one",
                "content": "# Code\\n```\\nclass Solution {\\n    fun findThePrefixCommonArray(a: IntArray, b: IntArray) = IntArray(a.size) { i ->\\n        a.sliceArray(0..i).intersect(b.sliceArray(0..i).toSet()).size\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun findThePrefixCommonArray(a: IntArray, b: IntArray) = IntArray(a.size) { i ->\\n        a.sliceArray(0..i).intersect(b.sliceArray(0..i).toSet()).size\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4040536,
                "title": "hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        int n = A.size();\\n        vector<int>res, vis(n);\\n        int cnt=0;\\n        unordered_map<int, int>mp;\\n        for(int i=0; i<n; i++){\\n            vis[A[i]-1]++;\\n            vis[B[i]-1]++;\\n            for(int j=0; j<n; j++)\\n            {\\n                if(vis[j]==2){\\n                    mp[i]++;\\n                }\\n            }\\n            cnt=mp[i];\\n            res.push_back(cnt);\\n        }\\n        for(auto i: vis){\\n            cout<<i<<\" \";\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        int n = A.size();\\n        vector<int>res, vis(n);\\n        int cnt=0;\\n        unordered_map<int, int>mp;\\n        for(int i=0; i<n; i++){\\n            vis[A[i]-1]++;\\n            vis[B[i]-1]++;\\n            for(int j=0; j<n; j++)\\n            {\\n                if(vis[j]==2){\\n                    mp[i]++;\\n                }\\n            }\\n            cnt=mp[i];\\n            res.push_back(cnt);\\n        }\\n        for(auto i: vis){\\n            cout<<i<<\" \";\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4039869,
                "title": "easy-python-solution-using-dict",
                "content": "# Approach\\nInitialize a dict to keep the counter. Loop through A and B if the element is there in the dict then increment the counter else add the key to the dict. Finally add the counter to the `output`.\\n\\n# Complexity\\n- Time complexity:\\nO(N^2)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```py\\nclass Solution:\\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n        charDict = {}\\n        output, counter = [], 0 \\n        for i in range(len(A)) : \\n            if A[i] not in charDict.keys() : \\n                charDict[A[i]] = 1 \\n            else : \\n                charDict[A[i]] += 1 \\n                counter += 1 \\n\\n            if B[i] not in charDict.keys() : \\n                charDict[B[i]] = 1 \\n            else :\\n                charDict[B[i]] += 1\\n                counter += 1 \\n\\n            output.append(counter)\\n\\n        return output \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Hash Table"
                ],
                "code": "```py\\nclass Solution:\\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n        charDict = {}\\n        output, counter = [], 0 \\n        for i in range(len(A)) : \\n            if A[i] not in charDict.keys() : \\n                charDict[A[i]] = 1 \\n            else : \\n                charDict[A[i]] += 1 \\n                counter += 1 \\n\\n            if B[i] not in charDict.keys() : \\n                charDict[B[i]] = 1 \\n            else :\\n                charDict[B[i]] += 1\\n                counter += 1 \\n\\n            output.append(counter)\\n\\n        return output \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4038273,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        vector<int> answer;\\n\\n        for(int i=0;i<A.size();i++){\\n            int count=0;\\n            for(int m=0;m<=i;m++){\\n            for(int j=0;j<=i;j++){\\n                if(A[m]==B[j]){\\n                count++;\\n                }\\n            }\\n        }\\n        answer.push_back(count);\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        vector<int> answer;\\n\\n        for(int i=0;i<A.size();i++){\\n            int count=0;\\n            for(int m=0;m<=i;m++){\\n            for(int j=0;j<=i;j++){\\n                if(A[m]==B[j]){\\n                count++;\\n                }\\n            }\\n        }\\n        answer.push_back(count);\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4023323,
                "title": "java-solution-using-hashmap-o-n-tc-beats-75",
                "content": "# Code\\n```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        int[] ans = new int[A.length];\\n        HashMap<Integer, Integer> hm = new HashMap<>();\\n        int temp = 0;\\n        for(int i = 0; i < A.length; i++){\\n            if(A[i]==B[i]){\\n                temp++;\\n                ans[i] = temp;\\n            }\\n            else if(hm.containsKey(A[i])){\\n                temp++;\\n            }\\n            else{\\n                hm.put(A[i], 1);\\n            }\\n            if(hm.containsKey(B[i])){\\n                temp++;\\n            }\\n            else{\\n                hm.put(B[i], 1);\\n            }\\n            ans[i] = temp;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        int[] ans = new int[A.length];\\n        HashMap<Integer, Integer> hm = new HashMap<>();\\n        int temp = 0;\\n        for(int i = 0; i < A.length; i++){\\n            if(A[i]==B[i]){\\n                temp++;\\n                ans[i] = temp;\\n            }\\n            else if(hm.containsKey(A[i])){\\n                temp++;\\n            }\\n            else{\\n                hm.put(A[i], 1);\\n            }\\n            if(hm.containsKey(B[i])){\\n                temp++;\\n            }\\n            else{\\n                hm.put(B[i], 1);\\n            }\\n            ans[i] = temp;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4022377,
                "title": "map-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n\\n      vector<int> ans;\\n     \\n     unordered_map<int,int> mymap;\\n     int count=0;\\n     for(int i=0;i<A.size();i++)\\n      {\\n        mymap[A[i]]++;\\n        mymap[B[i]]++;\\n        if(A[i]!=B[i]){\\n            if(mymap[A[i]] >= 2) count++;\\n            if(mymap[B[i]] >= 2) count++;\\n        }\\n        else{\\n            count++;\\n        }\\n          ans.push_back(count);\\n         \\n      } \\n\\n      return ans;\\n\\n       \\n\\n       \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n\\n      vector<int> ans;\\n     \\n     unordered_map<int,int> mymap;\\n     int count=0;\\n     for(int i=0;i<A.size();i++)\\n      {\\n        mymap[A[i]]++;\\n        mymap[B[i]]++;\\n        if(A[i]!=B[i]){\\n            if(mymap[A[i]] >= 2) count++;\\n            if(mymap[B[i]] >= 2) count++;\\n        }\\n        else{\\n            count++;\\n        }\\n          ans.push_back(count);\\n         \\n      } \\n\\n      return ans;\\n\\n       \\n\\n       \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4022366,
                "title": "simple-solution-using-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n\\n      vector<int> ans;\\n      int count=0;\\n      if(A[0]!=B[0]){\\n          ans.push_back(0);\\n\\n      }else{\\n          count++; \\n          ans.push_back(1);\\n      }\\n     map<int,int> mymap;\\n\\n     mymap[A[0]]++;\\n     mymap[B[0]]++;\\n\\n\\n      for(int i=1;i<A.size();i++)\\n      {\\n        mymap[A[i]]++;\\n        mymap[B[i]]++;\\n        if(A[i]!=B[i]){\\n            if(mymap[A[i]] >= 2) count++;\\n            if(mymap[B[i]] >= 2) count++;\\n        }\\n        else{\\n            count++;\\n        }\\n          ans.push_back(count);\\n         \\n      } \\n\\n      return ans;\\n\\n       \\n\\n       \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n\\n      vector<int> ans;\\n      int count=0;\\n      if(A[0]!=B[0]){\\n          ans.push_back(0);\\n\\n      }else{\\n          count++; \\n          ans.push_back(1);\\n      }\\n     map<int,int> mymap;\\n\\n     mymap[A[0]]++;\\n     mymap[B[0]]++;\\n\\n\\n      for(int i=1;i<A.size();i++)\\n      {\\n        mymap[A[i]]++;\\n        mymap[B[i]]++;\\n        if(A[i]!=B[i]){\\n            if(mymap[A[i]] >= 2) count++;\\n            if(mymap[B[i]] >= 2) count++;\\n        }\\n        else{\\n            count++;\\n        }\\n          ans.push_back(count);\\n         \\n      } \\n\\n      return ans;\\n\\n       \\n\\n       \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4017925,
                "title": "very-simple-approach-using-map-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        unordered_map<int,int>mp1;\\n        unordered_map<int,int>mp2;\\n        int count=0;\\n        vector<int>ans;\\n        for(int i=0;i<A.size();i++)\\n        {\\n           mp1[A[i]]++;\\n           mp2[B[i]]++;\\n           count=0;\\n           for(int j=0;j<=i;j++)\\n           {   \\n           if(mp2.find(A[j])!=mp1.end())\\n           {\\n               count++;\\n           }\\n           }\\n           ans.push_back(count);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        unordered_map<int,int>mp1;\\n        unordered_map<int,int>mp2;\\n        int count=0;\\n        vector<int>ans;\\n        for(int i=0;i<A.size();i++)\\n        {\\n           mp1[A[i]]++;\\n           mp2[B[i]]++;\\n           count=0;\\n           for(int j=0;j<=i;j++)\\n           {   \\n           if(mp2.find(A[j])!=mp1.end())\\n           {\\n               count++;\\n           }\\n           }\\n           ans.push_back(count);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4015110,
                "title": "95",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        int n=A.size();\\n        vector<int>ans(n);int count=0;\\n        vector<int>seen(n+1);\\n        for(int i=0;i<n;i++){\\n            if(++seen[A[i]]==2)count++;\\n            if(++seen[B[i]]==2)count++;\\n            ans[i]=count;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        int n=A.size();\\n        vector<int>ans(n);int count=0;\\n        vector<int>seen(n+1);\\n        for(int i=0;i<n;i++){\\n            if(++seen[A[i]]==2)count++;\\n            if(++seen[B[i]]==2)count++;\\n            ans[i]=count;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4012750,
                "title": "using-hash-set-and-indexing",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) \\n    {\\n       vector<int> v;\\n       set<int> s;\\n       for(int i=0;i<A.size();i++)\\n       {\\n           s.insert(A[i]);\\n           s.insert(B[i]);\\n           if(s.size() >= 2*(i+1))\\n           {\\n               \\n              \\n              v.push_back(s.size()-2*(i+1));\\n           }\\n           else\\n           {\\n               \\n             \\n                v.push_back(2*(i+1)-s.size());\\n           }\\n       }\\n       return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) \\n    {\\n       vector<int> v;\\n       set<int> s;\\n       for(int i=0;i<A.size();i++)\\n       {\\n           s.insert(A[i]);\\n           s.insert(B[i]);\\n           if(s.size() >= 2*(i+1))\\n           {\\n               \\n              \\n              v.push_back(s.size()-2*(i+1));\\n           }\\n           else\\n           {\\n               \\n             \\n                v.push_back(2*(i+1)-s.size());\\n           }\\n       }\\n       return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4010121,
                "title": "very-simple-javascript-typescript-solution-set-array",
                "content": "\\n# Set\\n```\\nconst findThePrefixCommonArray = (A, B) => {\\n    const set = new Set();\\n    const result = [];\\n    let cnt = 0;\\n\\n    for (let i = 0; i < A.length; i++) {\\n        if (set.has(A[i])) {\\n            cnt++;\\n        } else {\\n           set.add(A[i]);\\n        }\\n\\n        if (set.has(B[i])) {\\n            cnt++;\\n        } else {\\n           set.add(B[i])\\n        }\\n\\n        result[i] = cnt;\\n    }\\n\\n    return result;\\n};\\n```\\n\\n\\n\\n# Array\\n```\\nconst findThePrefixCommonArray = (A, B) => {\\n    const arr = [];\\n    const result = [];\\n    let cnt = 0;\\n\\n    for (let i = 0; i < A.length; i++) {\\n        if (arr[A[i]]) {\\n            cnt++;\\n        } else {\\n           arr[A[i]] = 1; \\n        }\\n\\n        if (arr[B[i]]) {\\n            cnt++;\\n        } else {\\n           arr[B[i]] = 1; \\n        }\\n\\n        result[i] = cnt;\\n    }\\n\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Array",
                    "Ordered Set"
                ],
                "code": "```\\nconst findThePrefixCommonArray = (A, B) => {\\n    const set = new Set();\\n    const result = [];\\n    let cnt = 0;\\n\\n    for (let i = 0; i < A.length; i++) {\\n        if (set.has(A[i])) {\\n            cnt++;\\n        } else {\\n           set.add(A[i]);\\n        }\\n\\n        if (set.has(B[i])) {\\n            cnt++;\\n        } else {\\n           set.add(B[i])\\n        }\\n\\n        result[i] = cnt;\\n    }\\n\\n    return result;\\n};\\n```\n```\\nconst findThePrefixCommonArray = (A, B) => {\\n    const arr = [];\\n    const result = [];\\n    let cnt = 0;\\n\\n    for (let i = 0; i < A.length; i++) {\\n        if (arr[A[i]]) {\\n            cnt++;\\n        } else {\\n           arr[A[i]] = 1; \\n        }\\n\\n        if (arr[B[i]]) {\\n            cnt++;\\n        } else {\\n           arr[B[i]] = 1; \\n        }\\n\\n        result[i] = cnt;\\n    }\\n\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4005931,
                "title": "my-solution-is-very-simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& a, vector<int>& b) {\\n    unordered_map<int,int>mp;\\n    int ans =0;\\n    vector<int>v;\\n    int c =0;\\n\\n    for(int i =0; i<a.size(); i++){\\n        mp[a[i]]++;\\n         for(int j =0; j<=i; j++){\\n\\n           if(mp.find(b[j])!=mp.end()){\\n               c++;\\n           }\\n            \\n       }\\n       v.push_back(c);\\n       c=0;\\n    }\\n    \\n   return v;\\n    }\\n};\\n\\n/*\\n1,2,3,4\\n1,2,3,4\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n*/\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& a, vector<int>& b) {\\n    unordered_map<int,int>mp;\\n    int ans =0;\\n    vector<int>v;\\n    int c =0;\\n\\n    for(int i =0; i<a.size(); i++){\\n        mp[a[i]]++;\\n         for(int j =0; j<=i; j++){\\n\\n           if(mp.find(b[j])!=mp.end()){\\n               c++;\\n           }\\n            \\n       }\\n       v.push_back(c);\\n       c=0;\\n    }\\n    \\n   return v;\\n    }\\n};\\n\\n/*\\n1,2,3,4\\n1,2,3,4\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4004417,
                "title": "95-faster-and-i-think-smarter-one-too",
                "content": "# Intuition\\niterate from end to start. as every list in the end will have n number of matches i.e., len of list.\\n\\n# Approach\\nat the end there will be n no. of matches for sure. use a set and have the unique values in it. which will help in determining the number of matches.\\nEX:\\nA = [1,2,3,4] len of A = 4\\nB = [1,3,2,4]\\n\\nas said above last value of result will be 4. iterate from back. \\n\\n=> insert ***len(A)-len(uniqueset)*** to the start of the list to each iteration.\\nExplanation:\\n\\n:i=3 uniqueset = () result=[4] \\n    :i=2 uniqueset = (4) result = ( [len(A)-len(uniqueset),4] => [4-1,4] ) = [3,4]\\n    :i=1 uniqueset = (2,3,4) => result = [1,3,4]\\n    :i=0 uniqueset = (1,2,3,4) => result = [0,1,3,4]\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution:\\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n        unique = set()\\n        _len = len(A)\\n        result = [_len]\\n        for i in range(_len-2,-1,-1):\\n            unique.add(A[i+1])\\n            unique.add(B[i+1])\\n            result.insert(0,_len-len(unique))\\n        return result\\n\\n```\\n\\nThak you :)",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n        unique = set()\\n        _len = len(A)\\n        result = [_len]\\n        for i in range(_len-2,-1,-1):\\n            unique.add(A[i+1])\\n            unique.add(B[i+1])\\n            result.insert(0,_len-len(unique))\\n        return result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3997181,
                "title": "ruby-one-liner-250ms",
                "content": "# Intuition\\nCan be solved simply by counting the matches of one array slice with another array slice, although there may be a way of taking advantage of the consecutive integers in each permutation\\n\\n# Approach\\n`map` the `b.size` array using `count`, `include?` and front-inclusive slices `[..i]`\\n\\n# Code\\n```\\ndef find_the_prefix_common_array(a, b)\\n  (0...b.size).map{|i| a[..i].count{|a| b[..i].include?(a)}}\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef find_the_prefix_common_array(a, b)\\n  (0...b.size).map{|i| a[..i].count{|a| b[..i].include?(a)}}\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3992166,
                "title": "direct-approach-using-java",
                "content": "\\n\\n# Java Code\\n```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        int arr[] = new int[A.length];\\n        for(int i =0;i<A.length;i++){\\n            int count = 0;\\n            for(int j = 0;j<=i;j++){\\n                for(int k = 0;k<=i;k++)\\n                    if(A[j]==B[k])\\n                        count++;                    \\n            }\\n            arr[i] = count;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        int arr[] = new int[A.length];\\n        for(int i =0;i<A.length;i++){\\n            int count = 0;\\n            for(int j = 0;j<=i;j++){\\n                for(int k = 0;k<=i;k++)\\n                    if(A[j]==B[k])\\n                        count++;                    \\n            }\\n            arr[i] = count;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3991127,
                "title": "o-n-time-complexity-o-1-space-complexity-solution",
                "content": "# Intuition\\ncreate a map to keep track of integers seen till now. \\n# Approach\\ncreate a map to keep track of integers seen till now. Since the number is till 50  and array of bool is enough to keep track to keep time complexity to minimum.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n- Space complexity:\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        bool prefixSet[51]={false};\\n        int idx=0;\\n        int commonCnt=0;\\n        vector<int > result;\\n        \\n        while (idx< A.size())\\n        {\\n            if (prefixSet[A[idx]])\\n            {\\n                commonCnt++;   \\n            }\\n            else\\n            {\\n                prefixSet[A[idx]] = true;\\n            }\\n\\n            if (prefixSet[B[idx]])\\n            {\\n                commonCnt++;   \\n            }\\n            else\\n            {\\n                prefixSet[B[idx]] = true;\\n            }\\n\\n            result.push_back(commonCnt);\\n\\n            idx++;\\n        }\\n\\n        return result;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        bool prefixSet[51]={false};\\n        int idx=0;\\n        int commonCnt=0;\\n        vector<int > result;\\n        \\n        while (idx< A.size())\\n        {\\n            if (prefixSet[A[idx]])\\n            {\\n                commonCnt++;   \\n            }\\n            else\\n            {\\n                prefixSet[A[idx]] = true;\\n            }\\n\\n            if (prefixSet[B[idx]])\\n            {\\n                commonCnt++;   \\n            }\\n            else\\n            {\\n                prefixSet[B[idx]] = true;\\n            }\\n\\n            result.push_back(commonCnt);\\n\\n            idx++;\\n        }\\n\\n        return result;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3988258,
                "title": "essay-c-solution-using-multiset-for-beginner",
                "content": "\\n\\nHere\\'s a simplified explanation of the code:\\n\\n**Intuition**:\\nThe code aims to find the number of common elements between two vectors while considering their positions.\\n\\n**Approach**:\\n1. Initialize two multisets, `m1` and `m2`, to store the elements from vectors `A` and `B`, respectively. Multisets are used because they allow duplicate elements and automatically sort them.\\n\\n2. Find the sizes of vectors `A` and `B` and store them in `n` and `m`, respectively.\\n\\n3. Determine the maximum length between `n` and `m` and store it in the variable `len`. This is used for iterating through both vectors.\\n\\n4. Create an empty vector `ans` to store the results.\\n\\n5. Iterate from `i` equals 0 to `len - 1`:\\n   - Insert the element at position `i` in vector `A` into `m1`.\\n   - Insert the element at position `i` in vector `B` into `m2`.\\n\\n6. Initialize a variable `count` to 0 to keep track of the number of common elements at each position.\\n\\n7. Iterate through the elements in `m1`:\\n   - For each element, check if it exists in `m2` by using `m2.find(ele)`. If it does, increment the `count` variable.\\n\\n8. After counting the common elements for the current position, push the `count` value into the `ans` vector.\\n\\n9. Continue this process for all positions in the vectors.\\n\\n10. Finally, return the `ans` vector containing the counts of common elements at each position.\\n\\n**Complexity**:\\n\\n- Time complexity: The code has a nested loop that iterates through both vectors, so the time complexity is O(max(n, m)), where n and m are the sizes of vectors A and B, respectively.\\n\\n- Space complexity: The code uses two multisets, `m1` and `m2`, to store the elements from vectors A and B. The space complexity is O(n + m), where n and m are the sizes of vectors A and B, respectively, because the multisets store the unique elements from each vector.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n\\n        multiset<int> m1;\\n        multiset<int> m2;\\n        int n= A.size();\\n        int m= B.size();\\n        int len= max(n,m);\\n        vector<int> ans;\\n        for(int i =0; i<len; i++){\\n            \\n          m1.insert(A[i]);\\n          m2.insert(B[i]);\\n         int count =0;\\n         for( auto ele : m1){\\n            \\n            if( m2.find(ele)!= m2.end()){\\n                count++;\\n            }\\n         }\\n         ans.push_back(count);\\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n\\n        multiset<int> m1;\\n        multiset<int> m2;\\n        int n= A.size();\\n        int m= B.size();\\n        int len= max(n,m);\\n        vector<int> ans;\\n        for(int i =0; i<len; i++){\\n            \\n          m1.insert(A[i]);\\n          m2.insert(B[i]);\\n         int count =0;\\n         for( auto ele : m1){\\n            \\n            if( m2.find(ele)!= m2.end()){\\n                count++;\\n            }\\n         }\\n         ans.push_back(count);\\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3988058,
                "title": "two-sets",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n     unordered_set<int>h1;\\n     unordered_set<int>h2;\\n     int ans=0;\\n     vector<int>v(A.size(),0);\\n     for(int i=0;i<A.size();i++){\\n         if(A[i]==B[i]){\\n             h1.insert(A[i]);\\n             h2.insert(A[i]);\\n             v[i]=++ans;\\n             continue;\\n         }\\n         v[i]=ans;\\n         if(h1.find(B[i])!=h1.end()){\\n             v[i]=++ans;\\n         }\\n         h2.insert(B[i]);\\n         if(h2.find(A[i])!=h2.end()){\\n             v[i]=++ans;\\n         }\\n         h1.insert(A[i]);\\n     }\\n     return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n     unordered_set<int>h1;\\n     unordered_set<int>h2;\\n     int ans=0;\\n     vector<int>v(A.size(),0);\\n     for(int i=0;i<A.size();i++){\\n         if(A[i]==B[i]){\\n             h1.insert(A[i]);\\n             h2.insert(A[i]);\\n             v[i]=++ans;\\n             continue;\\n         }\\n         v[i]=ans;\\n         if(h1.find(B[i])!=h1.end()){\\n             v[i]=++ans;\\n         }\\n         h2.insert(B[i]);\\n         if(h2.find(A[i])!=h2.end()){\\n             v[i]=++ans;\\n         }\\n         h1.insert(A[i]);\\n     }\\n     return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3982412,
                "title": "java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        int[] res = new int[A.length];\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int i=0; i<res.length; i++) {\\n            map.put(A[i], map.getOrDefault(A[i], 0) +1 );\\n            map.put(B[i], map.getOrDefault(B[i], 0) +1 );\\n            res[i] = (int) map.values()\\n                                .stream()\\n                                .filter(v -> v==2)\\n                                .count();\\n        }\\n        return res;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        int[] res = new int[A.length];\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int i=0; i<res.length; i++) {\\n            map.put(A[i], map.getOrDefault(A[i], 0) +1 );\\n            map.put(B[i], map.getOrDefault(B[i], 0) +1 );\\n            res[i] = (int) map.values()\\n                                .stream()\\n                                .filter(v -> v==2)\\n                                .count();\\n        }\\n        return res;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3975706,
                "title": "java-one-pass",
                "content": "\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        Set<Integer> one = new HashSet<>()  ,two = new HashSet<>();\\n        int res = 0;\\n        int[] resarr = new int[A.length];\\n        for(int i = 0 ; i<A.length ;i++){\\n            int a = A[i] , b = B[i];\\n            one.add(a);two.add(b);\\n            if(two.contains(a)) res++;\\n            if( a!= b && one.contains(b)) res++;\\n            resarr[i] = res;\\n        }\\n        return resarr;\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        Set<Integer> one = new HashSet<>()  ,two = new HashSet<>();\\n        int res = 0;\\n        int[] resarr = new int[A.length];\\n        for(int i = 0 ; i<A.length ;i++){\\n            int a = A[i] , b = B[i];\\n            one.add(a);two.add(b);\\n            if(two.contains(a)) res++;\\n            if( a!= b && one.contains(b)) res++;\\n            resarr[i] = res;\\n        }\\n        return resarr;\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3974183,
                "title": "elixir-simple-solution-using-mapset",
                "content": "```\\ndefmodule Solution do\\n  @spec find_the_prefix_common_array(a :: [integer], b :: [integer]) :: [integer]\\n  def find_the_prefix_common_array(a, b) do\\n    Enum.zip(a, b)\\n    |> Enum.reduce({[], 0, %MapSet{}, %MapSet{}}, fn {a, b}, {ans, ct, sa, sb} ->\\n      ct =\\n        cond do\\n          a == b -> ct + 1\\n          MapSet.member?(sa, b) && MapSet.member?(sb, a) -> ct + 2\\n          MapSet.member?(sa, b) || MapSet.member?(sb, a) -> ct + 1\\n          true -> ct\\n        end\\n\\n      {[ct | ans], ct, MapSet.put(sa, a), MapSet.put(sb, b)}\\n    end)\\n    |> elem(0)\\n    |> Enum.reverse()\\n  end\\nend\\n\\n```",
                "solutionTags": [
                    "Elixir"
                ],
                "code": "```\\ndefmodule Solution do\\n  @spec find_the_prefix_common_array(a :: [integer], b :: [integer]) :: [integer]\\n  def find_the_prefix_common_array(a, b) do\\n    Enum.zip(a, b)\\n    |> Enum.reduce({[], 0, %MapSet{}, %MapSet{}}, fn {a, b}, {ans, ct, sa, sb} ->\\n      ct =\\n        cond do\\n          a == b -> ct + 1\\n          MapSet.member?(sa, b) && MapSet.member?(sb, a) -> ct + 2\\n          MapSet.member?(sa, b) || MapSet.member?(sb, a) -> ct + 1\\n          true -> ct\\n        end\\n\\n      {[ct | ans], ct, MapSet.put(sa, a), MapSet.put(sb, b)}\\n    end)\\n    |> elem(0)\\n    |> Enum.reverse()\\n  end\\nend\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3973931,
                "title": "java-beginner-friendly-approach-using-arrays-and-count",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCount the occurances and carry forwarding the current count and saving space by modifying exisiting input Array.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n       int[] result = new int[51];\\n       int counter =0;\\n       for(int i=0;i<A.length;i++)\\n       {\\n           result[A[i]]++;\\n           if(result[A[i]]==2)\\n           counter++;\\n           result[B[i]]++;\\n           if(result[B[i]]==2)\\n           counter++;\\n           A[i]=counter;\\n       } \\n       return A;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n       int[] result = new int[51];\\n       int counter =0;\\n       for(int i=0;i<A.length;i++)\\n       {\\n           result[A[i]]++;\\n           if(result[A[i]]==2)\\n           counter++;\\n           result[B[i]]++;\\n           if(result[B[i]]==2)\\n           counter++;\\n           A[i]=counter;\\n       } \\n       return A;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3971811,
                "title": "easy-soln-for-beginners-using-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        vector<int>ans;\\n        unordered_map<int,int>map;\\n        for(int i=0;i<B.size();i++){\\n            map[B[i]]++;\\n            int count=0;\\n            for(int j=0;j<=i;j++){\\n                if(map.find(A[j])!=map.end()){\\n                    count++;\\n                }\\n            }\\n            ans.push_back(count);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        vector<int>ans;\\n        unordered_map<int,int>map;\\n        for(int i=0;i<B.size();i++){\\n            map[B[i]]++;\\n            int count=0;\\n            for(int j=0;j<=i;j++){\\n                if(map.find(A[j])!=map.end()){\\n                    count++;\\n                }\\n            }\\n            ans.push_back(count);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3969337,
                "title": "beats-99",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n\\n        int count[] = new int[A.length];\\n        int result[] = new int[A.length];\\n        int temp = 0;\\n        for(int i = 0; i<A.length; i++){\\n            count[A[i]-1]++;\\n            count[B[i]-1]++;\\n\\n            if(count[A[i]-1]==2) temp++;\\n            if(count[B[i]-1]==2 && A[i]!=B[i]) temp++;\\n            result[i] = temp;\\n            }\\n\\n            return result;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n\\n        int count[] = new int[A.length];\\n        int result[] = new int[A.length];\\n        int temp = 0;\\n        for(int i = 0; i<A.length; i++){\\n            count[A[i]-1]++;\\n            count[B[i]-1]++;\\n\\n            if(count[A[i]-1]==2) temp++;\\n            if(count[B[i]-1]==2 && A[i]!=B[i]) temp++;\\n            result[i] = temp;\\n            }\\n\\n            return result;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3958656,
                "title": "java-observation-hashset-solution-se",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        Set<Integer> set = new HashSet<>();\\n        int res[] = new int[A.length];\\n        int ind = 0;\\n        for(int i = 0;i<A.length;i++){\\n            set.add(A[i]);\\n            set.add(B[i]);\\n            res[ind++] = 2*(i+1) - set.size();\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        Set<Integer> set = new HashSet<>();\\n        int res[] = new int[A.length];\\n        int ind = 0;\\n        for(int i = 0;i<A.length;i++){\\n            set.add(A[i]);\\n            set.add(B[i]);\\n            res[ind++] = 2*(i+1) - set.size();\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3958071,
                "title": "c-unordered-map-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        int n=A.size();\\n        vector<int> ans(n,0);\\n        unordered_map<int,int> mp;\\n        \\n        for(int i=0;i<n;i++){\\n            mp[A[i]]++;\\n            mp[B[i]]++;\\n            int cnt=0;\\n            for(auto it: mp){\\n                if(it.second>=2){\\n                    cnt++;\\n                }\\n            }\\n            ans[i]=cnt;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        int n=A.size();\\n        vector<int> ans(n,0);\\n        unordered_map<int,int> mp;\\n        \\n        for(int i=0;i<n;i++){\\n            mp[A[i]]++;\\n            mp[B[i]]++;\\n            int cnt=0;\\n            for(auto it: mp){\\n                if(it.second>=2){\\n                    cnt++;\\n                }\\n            }\\n            ans[i]=cnt;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3955548,
                "title": "easy-solution-in-c",
                "content": "# Intuition\\n\\n\\n# Approach\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        vector<int>c;\\n        unordered_map<int,int>m;\\n        for(int i=0;i<A.size();i++){\\n            int ans=0;\\n            m[A[i]]++;\\n            m[B[i]]++;\\n            for(auto const &p:m){\\n                 if(p.second==2)\\n                    ans++;\\n            }\\n            c.push_back(ans);\\n        }\\n        return c;\\n\\n\\n        }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        vector<int>c;\\n        unordered_map<int,int>m;\\n        for(int i=0;i<A.size();i++){\\n            int ans=0;\\n            m[A[i]]++;\\n            m[B[i]]++;\\n            for(auto const &p:m){\\n                 if(p.second==2)\\n                    ans++;\\n            }\\n            c.push_back(ans);\\n        }\\n        return c;\\n\\n\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3946368,
                "title": "java-solution-using-2-hashmaps",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        HashMap<Integer,Integer> map1=new HashMap<>();\\n        HashMap<Integer,Integer> map2=new HashMap<>();\\n        for(int i=0;i<A.length;i++)\\n        {\\n            map1.put(i,A[i]);\\n            map2.put(B[i],i);\\n        }\\n\\n        int result[]=new int[A.length];\\n        for(int j=0;j<result.length;j++)\\n        {\\n            int cnt=0;\\n            for(int x=j;x>=0;x--)\\n            {\\n                if(map2.containsKey(map1.get(x)))\\n                {\\n                    if(map2.get(map1.get(x))<=j)\\n                    {\\n                        cnt++;\\n                    }\\n                }\\n            }\\n            result[j]=cnt;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        HashMap<Integer,Integer> map1=new HashMap<>();\\n        HashMap<Integer,Integer> map2=new HashMap<>();\\n        for(int i=0;i<A.length;i++)\\n        {\\n            map1.put(i,A[i]);\\n            map2.put(B[i],i);\\n        }\\n\\n        int result[]=new int[A.length];\\n        for(int j=0;j<result.length;j++)\\n        {\\n            int cnt=0;\\n            for(int x=j;x>=0;x--)\\n            {\\n                if(map2.containsKey(map1.get(x)))\\n                {\\n                    if(map2.get(map1.get(x))<=j)\\n                    {\\n                        cnt++;\\n                    }\\n                }\\n            }\\n            result[j]=cnt;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3942129,
                "title": "easy-c-solution-o-n-approach-beats-94",
                "content": "# Intuition\\nUse a hashmap to store the frequency of each element.\\n\\n# Approach\\n- If A[i] and B[i] have frequency as 2 and both of them are equal then add only 1 to count.\\n- If both of them are not equal then separately check whether their frequency is 2 or not.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        vector<int> ans;\\n        unordered_map<int, int> freq;\\n        int n = A.size();\\n        int cnt = 0;\\n\\n        for(int i = 0; i < n; i++) {\\n            freq[A[i]]++;\\n            freq[B[i]]++;\\n            if(A[i] == B[i] && freq[A[i]] == 2)\\n                cnt++;\\n            else {\\n                if(freq[A[i]] == 2)\\n                    cnt++;\\n                if(freq[B[i]] == 2)\\n                    cnt++;\\n            }\\n\\n            ans.push_back(cnt);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        vector<int> ans;\\n        unordered_map<int, int> freq;\\n        int n = A.size();\\n        int cnt = 0;\\n\\n        for(int i = 0; i < n; i++) {\\n            freq[A[i]]++;\\n            freq[B[i]]++;\\n            if(A[i] == B[i] && freq[A[i]] == 2)\\n                cnt++;\\n            else {\\n                if(freq[A[i]] == 2)\\n                    cnt++;\\n                if(freq[B[i]] == 2)\\n                    cnt++;\\n            }\\n\\n            ans.push_back(cnt);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3941030,
                "title": "o-n-time-o-n-space-c-solution",
                "content": "# Intuition\\nFew observations:\\n1. All 3 vectors (A, B, Resulting) must be of the same size.\\n2. On each iteration we need to determine how much common elements A and B have.\\n3. Thus this common number may only grow or stay the same.\\n4. If it grows it only can grow by 1 or 2.\\n\\n# Approach\\nWe traverse both arrays at the same time comparing its values.\\nWe use hash to store the \"not yet matching\" elements encountered in it.\\nIf elements match we increase common counter by 1.\\nIf they dont - we check if the elements are already in the hash, increasing common counter by 1 with each match, or adding \"not yet matched\" element to the hash.\\nOn each iteration set the resulting value for this position in the array to current common counter.\\n\\n \\n# Complexity\\n- Time complexity:\\nO(N) since we traverse all sets exactly 1 time and hash usage is limited to add\\\\search methods which both are O(1).\\n\\n- Space complexity:\\nO(N) - in the worst case we will end up having a hash with all the values from A and from B in it.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    /*\\n    test cases:\\n    [1 3 2 4] [3 1 2 4] - [0 2 3 4] - +\\n    [2 3 1] [3 1 2] - [0 1 3] - +\\n    [1 2 3 4 5 6 7] [1 2 3 4 5 6 7] - [1 2 3 4 5 6 7] - +\\n    [1 2 3 4 5] [6 7 8 9 10] - [0 0 0 0 0] - +\\n    [0 1 2 3 4] [4 3 2 1 0] - [0 0 1 4 5] - +\\n    [2 4 5 3 1] [3 5 4 1 0] - [0 0 2 3 4] - +\\n    */\\n\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) \\n    {\\n        if(A.size() != B.size())\\n            return vector<int>();\\n        \\n        unordered_set<int> set_unc;\\n        vector<int> res(A.size(), 0);\\n\\n        int common = 0;\\n\\n        for(int i = 0; i < A.size(); i++)\\n        {\\n            int a = A[i], b = B[i];\\n            if(a == b)\\n                common++;\\n            else\\n            {\\n                if(set_unc.contains(a))\\n                    common++;\\n                else\\n                    set_unc.insert(a);\\n\\n                if(set_unc.contains(b))\\n                    common++;\\n                else\\n                    set_unc.insert(b);\\n            }\\n            res[i] = common;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    /*\\n    test cases:\\n    [1 3 2 4] [3 1 2 4] - [0 2 3 4] - +\\n    [2 3 1] [3 1 2] - [0 1 3] - +\\n    [1 2 3 4 5 6 7] [1 2 3 4 5 6 7] - [1 2 3 4 5 6 7] - +\\n    [1 2 3 4 5] [6 7 8 9 10] - [0 0 0 0 0] - +\\n    [0 1 2 3 4] [4 3 2 1 0] - [0 0 1 4 5] - +\\n    [2 4 5 3 1] [3 5 4 1 0] - [0 0 2 3 4] - +\\n    */\\n\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) \\n    {\\n        if(A.size() != B.size())\\n            return vector<int>();\\n        \\n        unordered_set<int> set_unc;\\n        vector<int> res(A.size(), 0);\\n\\n        int common = 0;\\n\\n        for(int i = 0; i < A.size(); i++)\\n        {\\n            int a = A[i], b = B[i];\\n            if(a == b)\\n                common++;\\n            else\\n            {\\n                if(set_unc.contains(a))\\n                    common++;\\n                else\\n                    set_unc.insert(a);\\n\\n                if(set_unc.contains(b))\\n                    common++;\\n                else\\n                    set_unc.insert(b);\\n            }\\n            res[i] = common;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3940890,
                "title": "jai-shree-ram-optimised-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n\\n        int n=A.size();\\n        vector<int>ans(n,0);\\n        unordered_set<int>s;\\n        int cnt=0;\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            s.insert(A[i]);\\n            for(int j=0;j<=i;j++)\\n            {\\n                if(s.count(B[j])!=0)\\n                {\\n                    ans[i]++;\\n                }\\n            }\\n            //ans[i]=cnt;\\n        }\\n        return ans;\\n        \\n\\n\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n\\n        int n=A.size();\\n        vector<int>ans(n,0);\\n        unordered_set<int>s;\\n        int cnt=0;\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            s.insert(A[i]);\\n            for(int j=0;j<=i;j++)\\n            {\\n                if(s.count(B[j])!=0)\\n                {\\n                    ans[i]++;\\n                }\\n            }\\n            //ans[i]=cnt;\\n        }\\n        return ans;\\n        \\n\\n\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3926209,
                "title": "c-easy-time-o-n-space-o-n-most-optimized",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        int n = A.size();\\n        unordered_map<int, int> m;\\n        vector<int> v;\\n        \\n        for(int i = 0; i < n; i++){\\n            m[A[i]]++;\\n            m[B[i]]++;\\n\\n            int c = 0;\\n\\n            for(auto it : m)if(it.second == 2)c++;\\n\\n            v.push_back(c);\\n        }\\n\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        int n = A.size();\\n        unordered_map<int, int> m;\\n        vector<int> v;\\n        \\n        for(int i = 0; i < n; i++){\\n            m[A[i]]++;\\n            m[B[i]]++;\\n\\n            int c = 0;\\n\\n            for(auto it : m)if(it.second == 2)c++;\\n\\n            v.push_back(c);\\n        }\\n\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3920725,
                "title": "java-simple-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        int count = 0;\\n        int[] freq = new int[51];\\n        int[] res = new int[A.length];\\n        for(int i = 0; i < A.length; i++) {\\n            for(int j = 0; j <= i; j++) {\\n                freq[A[j]]++;\\n                freq[B[j]]++;\\n            }\\n            count = 0;\\n            for(int j = 0; j < freq.length; j++) {\\n                if(freq[j] == 2)\\n                    count += 1;\\n                freq[j] = 0;\\n            }\\n            res[i] = count;\\n        }        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        int count = 0;\\n        int[] freq = new int[51];\\n        int[] res = new int[A.length];\\n        for(int i = 0; i < A.length; i++) {\\n            for(int j = 0; j <= i; j++) {\\n                freq[A[j]]++;\\n                freq[B[j]]++;\\n            }\\n            count = 0;\\n            for(int j = 0; j < freq.length; j++) {\\n                if(freq[j] == 2)\\n                    count += 1;\\n                freq[j] = 0;\\n            }\\n            res[i] = count;\\n        }        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3920463,
                "title": "easy-solution-using-vector-unordered-map-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        unordered_map<int, int> perm;\\n        vector<int> prefix;\\n        int common = 0;\\n        for(int i=0; i < A.size(); i++){\\n            if(++perm[A[i]-1] > 1) common++;\\n            if(++perm[B[i]-1] > 1) common++;\\n            prefix.push_back(common);\\n        }\\n        return prefix;\\n    }\\n};\\n```\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        vector<int> perm(50,0), prefix;\\n        int common = 0;\\n        for(int i=0; i < A.size(); i++){\\n            if(++perm[A[i]-1] > 1) common++;\\n            if(++perm[B[i]-1] > 1) common++;\\n            prefix.push_back(common);\\n        }\\n        return prefix;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        unordered_map<int, int> perm;\\n        vector<int> prefix;\\n        int common = 0;\\n        for(int i=0; i < A.size(); i++){\\n            if(++perm[A[i]-1] > 1) common++;\\n            if(++perm[B[i]-1] > 1) common++;\\n            prefix.push_back(common);\\n        }\\n        return prefix;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        vector<int> perm(50,0), prefix;\\n        int common = 0;\\n        for(int i=0; i < A.size(); i++){\\n            if(++perm[A[i]-1] > 1) common++;\\n            if(++perm[B[i]-1] > 1) common++;\\n            prefix.push_back(common);\\n        }\\n        return prefix;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3913127,
                "title": "simple-python-solution-using-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Inialize two hashmap\\n2. Traverse each element\\n3. If Both elements are same then increement as 1\\n4. other wise verify the elements in hasmaps\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom collections import defaultdict\\nclass Solution:\\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n        x = defaultdict(lambda:0)\\n        y = defaultdict(lambda:0)\\n        c=[]\\n        common=0\\n        for i in range(len(A)):\\n            if A[i]==B[i]:\\n                common+=1\\n            else:\\n                if x[B[i]]>0:\\n                    common+=1\\n                if y[A[i]]>0:\\n                    common+=1\\n                x[A[i]]+=1\\n                y[B[i]]+=1\\n            c.append(common)\\n        return c\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n        x = defaultdict(lambda:0)\\n        y = defaultdict(lambda:0)\\n        c=[]\\n        common=0\\n        for i in range(len(A)):\\n            if A[i]==B[i]:\\n                common+=1\\n            else:\\n                if x[B[i]]>0:\\n                    common+=1\\n                if y[A[i]]>0:\\n                    common+=1\\n                x[A[i]]+=1\\n                y[B[i]]+=1\\n            c.append(common)\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3911665,
                "title": "easy-readable-solution-12-lines-o-n-time-o-n-space",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n        ans, c, s1, s2 = [], 0, set(), set()\\n        for i in range(len(A)):\\n            if A[i] not in s1 and A[i] in s2:\\n                c += 1\\n            if B[i] not in s2 and B[i] in s1:\\n                c += 1\\n            if A[i] == B[i] and A[i] not in s1 and B[i] not in s2:\\n                c += 1\\n            s1.add(A[i])\\n            s2.add(B[i])\\n            ans.append(c)\\n        return ans\\n```\\n\\nPlease let me know if any improvements can be made.\\n\\nThanks",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n        ans, c, s1, s2 = [], 0, set(), set()\\n        for i in range(len(A)):\\n            if A[i] not in s1 and A[i] in s2:\\n                c += 1\\n            if B[i] not in s2 and B[i] in s1:\\n                c += 1\\n            if A[i] == B[i] and A[i] not in s1 and B[i] not in s2:\\n                c += 1\\n            s1.add(A[i])\\n            s2.add(B[i])\\n            ans.append(c)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3911071,
                "title": "c-time-o-n-space-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Have a map to store if the number appeared in both array\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n# Code\\n```\\npublic class Solution {\\n    public int[] FindThePrefixCommonArray(int[] A, int[] B) {\\n        int[] map = new int[A.Length + 1];\\n        int[] ret = new int[A.Length];\\n        int prev = 0;\\n\\n        for(int i = 0; i < A.Length; i++)\\n        {\\n            map[A[i]]++;\\n            map[B[i]]++;\\n            \\n            ret[i] = prev;\\n\\n            if (map[A[i]] == 2)\\n                ret[i]++;\\n\\n            if (A[i] != B[i] && map[B[i]] == 2)\\n                ret[i]++;\\n\\n            prev = ret[i];\\n        }\\n\\n        return ret;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] FindThePrefixCommonArray(int[] A, int[] B) {\\n        int[] map = new int[A.Length + 1];\\n        int[] ret = new int[A.Length];\\n        int prev = 0;\\n\\n        for(int i = 0; i < A.Length; i++)\\n        {\\n            map[A[i]]++;\\n            map[B[i]]++;\\n            \\n            ret[i] = prev;\\n\\n            if (map[A[i]] == 2)\\n                ret[i]++;\\n\\n            if (A[i] != B[i] && map[B[i]] == 2)\\n                ret[i]++;\\n\\n            prev = ret[i];\\n        }\\n\\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3910580,
                "title": "beats-100-faster-c-easy-code",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& a, vector<int>& b) {\\n\\n        vector<int>ans;\\n        set<int>s;\\n        for(int i=0;i<a.size();i++){\\n            s.insert(a[i]);\\n            s.insert(b[i]);\\n            int t=(i+1)*2,n=s.size();\\n            (n==t) ? ans.push_back(0) : ans.push_back(t-n);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& a, vector<int>& b) {\\n\\n        vector<int>ans;\\n        set<int>s;\\n        for(int i=0;i<a.size();i++){\\n            s.insert(a[i]);\\n            s.insert(b[i]);\\n            int t=(i+1)*2,n=s.size();\\n            (n==t) ? ans.push_back(0) : ans.push_back(t-n);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3908607,
                "title": "c-solution-using-set",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        set<int> s1;\\n        vector<int> v;\\n        for(int i=0; i<A.size(); i++){\\n            s1.insert(A[i]);\\n            int cnt=0;\\n            for(int j=0; j<=i; j++){\\n                if(s1.find(B[j])!=s1.end()){\\n                    cnt++;\\n                }\\n            }\\n             v.push_back(cnt);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        set<int> s1;\\n        vector<int> v;\\n        for(int i=0; i<A.size(); i++){\\n            s1.insert(A[i]);\\n            int cnt=0;\\n            for(int j=0; j<=i; j++){\\n                if(s1.find(B[j])!=s1.end()){\\n                    cnt++;\\n                }\\n            }\\n             v.push_back(cnt);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3900971,
                "title": "c-easy-solution-with-unordered-maps",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        unordered_map<int, int> map1;\\n        unordered_map<int, int> map2;\\n\\n        vector<int> res;\\n        int count = 0;\\n        for (int i = 0; i < (int) A.size(); i++) {\\n            map1[A[i]]++;\\n            map2[B[i]]++;\\n            if (map2[A[i]] > 0) {\\n                count++;\\n                map2[A[i]]--;\\n                map1[A[i]]--;\\n            }\\n            if (map1[B[i]] > 0) {\\n                count++;\\n                map1[B[i]]--;\\n                map2[B[i]]--;\\n            }\\n\\n            res.push_back(count);\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        unordered_map<int, int> map1;\\n        unordered_map<int, int> map2;\\n\\n        vector<int> res;\\n        int count = 0;\\n        for (int i = 0; i < (int) A.size(); i++) {\\n            map1[A[i]]++;\\n            map2[B[i]]++;\\n            if (map2[A[i]] > 0) {\\n                count++;\\n                map2[A[i]]--;\\n                map1[A[i]]--;\\n            }\\n            if (map1[B[i]] > 0) {\\n                count++;\\n                map1[B[i]]--;\\n                map2[B[i]]--;\\n            }\\n\\n            res.push_back(count);\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3898891,
                "title": "python-simple-python-solution-prefix-sum",
                "content": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 134 ms, faster than 85.57% of Python3 online submissions for Find the Prefix Common Array of Two Arrays.\\n# Memory Usage: 16.4 MB, less than 44.65% of Python3 online submissions for Find the Prefix Common Array of Two Arrays.\\n\\n\\tclass Solution:\\n\\t\\tdef findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n\\n\\t\\t\\tresult = [0 for _ in range(len(A))]\\n\\n\\t\\t\\tif A[0] == B[0]:\\n\\t\\t\\t\\tresult[0] = 1\\n\\n\\t\\t\\tfor index in range(1 , len(A)):\\n\\n\\t\\t\\t\\tcheck = False\\n\\n\\t\\t\\t\\tif A[index] == B[index]:\\n\\t\\t\\t\\t\\tresult[index] = result[index - 1] + 1\\n\\t\\t\\t\\telse:\\n\\n\\t\\t\\t\\t\\tif A[index] in B[:index + 1]:\\n\\t\\t\\t\\t\\t\\tresult[index] = result[index - 1] + 1\\n\\t\\t\\t\\t\\t\\tcheck = True\\n\\n\\t\\t\\t\\t\\tif B[index] in A[:index + 1]:\\n\\n\\t\\t\\t\\t\\t\\tif check == False:\\n\\t\\t\\t\\t\\t\\t\\tresult[index] = result[index - 1] + 1\\n\\t\\t\\t\\t\\t\\t\\tcheck = True\\n\\t\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\t\\tresult[index] = result[index] + 1\\n\\n\\t\\t\\t\\t\\tif check == False:\\n\\t\\t\\t\\t\\t\\tresult[index] = result[index - 1]\\n\\n\\t\\t\\treturn result\\n\\t\\t\\t\\n\\tTime Complexity : O(n)\\n\\tSpace Complexity : O(n)\\n\\t\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Prefix Sum"
                ],
                "code": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 134 ms, faster than 85.57% of Python3 online submissions for Find the Prefix Common Array of Two Arrays.\\n# Memory Usage: 16.4 MB, less than 44.65% of Python3 online submissions for Find the Prefix Common Array of Two Arrays.\\n\\n\\tclass Solution:\\n\\t\\tdef findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n\\n\\t\\t\\tresult = [0 for _ in range(len(A))]\\n\\n\\t\\t\\tif A[0] == B[0]:\\n\\t\\t\\t\\tresult[0] = 1\\n\\n\\t\\t\\tfor index in range(1 , len(A)):\\n\\n\\t\\t\\t\\tcheck = False\\n\\n\\t\\t\\t\\tif A[index] == B[index]:\\n\\t\\t\\t\\t\\tresult[index] = result[index - 1] + 1\\n\\t\\t\\t\\telse:\\n\\n\\t\\t\\t\\t\\tif A[index] in B[:index + 1]:\\n\\t\\t\\t\\t\\t\\tresult[index] = result[index - 1] + 1\\n\\t\\t\\t\\t\\t\\tcheck = True\\n\\n\\t\\t\\t\\t\\tif B[index] in A[:index + 1]:\\n\\n\\t\\t\\t\\t\\t\\tif check == False:\\n\\t\\t\\t\\t\\t\\t\\tresult[index] = result[index - 1] + 1\\n\\t\\t\\t\\t\\t\\t\\tcheck = True\\n\\t\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\t\\tresult[index] = result[index] + 1\\n\\n\\t\\t\\t\\t\\tif check == False:\\n\\t\\t\\t\\t\\t\\tresult[index] = result[index - 1]\\n\\n\\t\\t\\treturn result\\n\\t\\t\\t\\n\\tTime Complexity : O(n)\\n\\tSpace Complexity : O(n)\\n\\t\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "codeTag": "Java"
            },
            {
                "id": 3896199,
                "title": "beats-100-cpp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& a, vector<int>& b) \\n    {\\n        int n=a.size();\\n        vector<int>ans;\\n        vector<int>ma(n+2,0);\\n        vector<int>mb(n+2,0);\\n        ma[a[0]]++;mb[b[0]]++;\\n        if(a[0]==b[0]) ans.push_back(1);\\n        else ans.push_back(0);\\n        for(int i=1;i<a.size();i++)\\n        {\\n            ma[a[i]]++;\\n            mb[b[i]]++;\\n            if(a[i]==b[i]) ans.push_back(ans.back()+1);\\n            else ans.push_back(ans.back()+ma[b[i]]+mb[a[i]]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& a, vector<int>& b) \\n    {\\n        int n=a.size();\\n        vector<int>ans;\\n        vector<int>ma(n+2,0);\\n        vector<int>mb(n+2,0);\\n        ma[a[0]]++;mb[b[0]]++;\\n        if(a[0]==b[0]) ans.push_back(1);\\n        else ans.push_back(0);\\n        for(int i=1;i<a.size();i++)\\n        {\\n            ma[a[i]]++;\\n            mb[b[i]]++;\\n            if(a[i]==b[i]) ans.push_back(ans.back()+1);\\n            else ans.push_back(ans.back()+ma[b[i]]+mb[a[i]]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3892907,
                "title": "o-n-solution-using-single-for-loop",
                "content": "# Intuition\\n1. We know that the possible numbers are between 1,n.\\n2. We know that each number can only occur once in each array.\\n\\n# Approach\\nWe setup a hashtable to keep track if a number has occured before in either array. \\n\\nStep 1:\\nIterate through both arrays simoltaneously. If the number at the current index is the same in both arrays increment the counter.\\n\\nStep 2:\\nIf the numbers at the current index are not the same, we check our hashtable to see if the number occured before.\\n\\nStep 3:\\nIf the number occured previously, we increment the counter.\\nIf it did not occur previously, we update the hashtable.\\n\\nStep 4:\\nAppend the current state of the counter to our results array at the end of each itteration. \\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n- Space complexity:\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        unordered_map <int,bool> map;\\n        vector<int> C;\\n        int common = 0;\\n        \\n        for(int i = 0; i<A.size();i++){\\n            if (A[i]==B[i])\\n            {\\n                common++;\\n            }\\n            else {\\n                if(map[A[i]]==1){\\n                    common++;\\n                }else{\\n                    map[A[i]]=1;\\n                }\\n                if (map[B[i]]==1){\\n                    common++;\\n                }else{\\n                    map[B[i]]=1;\\n                }\\n            }\\n            C.push_back(common);\\n        }\\n        return C;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        unordered_map <int,bool> map;\\n        vector<int> C;\\n        int common = 0;\\n        \\n        for(int i = 0; i<A.size();i++){\\n            if (A[i]==B[i])\\n            {\\n                common++;\\n            }\\n            else {\\n                if(map[A[i]]==1){\\n                    common++;\\n                }else{\\n                    map[A[i]]=1;\\n                }\\n                if (map[B[i]]==1){\\n                    common++;\\n                }else{\\n                    map[B[i]]=1;\\n                }\\n            }\\n            C.push_back(common);\\n        }\\n        return C;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3890396,
                "title": "easiest-python-solution-using-dictionary",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n        ans=[]\\n        i=0\\n        l=len(A)\\n        dicts={}\\n        last=0\\n        while i<l:\\n            if A[i] in dicts:\\n                last+=1\\n            else:dicts[A[i]]=1\\n            if B[i] in dicts:\\n                last+=1\\n            else:dicts[B[i]]=1\\n            ans.append(last)\\n            i+=1\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n        ans=[]\\n        i=0\\n        l=len(A)\\n        dicts={}\\n        last=0\\n        while i<l:\\n            if A[i] in dicts:\\n                last+=1\\n            else:dicts[A[i]]=1\\n            if B[i] in dicts:\\n                last+=1\\n            else:dicts[B[i]]=1\\n            ans.append(last)\\n            i+=1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3884494,
                "title": "easy-to-understand-solution-time-o-n",
                "content": "# Code\\n```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        Set<Integer> set = new HashSet<>();\\n        int ans[] = new int[A.length];\\n\\n        int count=0;\\n        for(int i=0;i<A.length;i++){\\n                if(A[i]==B[i]){\\n                    count++;\\n                }else{\\n                count = getCount(A[i],count,set);\\n                count = getCount(B[i],count,set);\\n                }\\n            ans[i]=count;        \\n            }\\n      return   ans;\\n    }\\n\\n    int getCount(int num,int count,Set<Integer> set){\\n            if(set.contains(num)){\\n                count++;\\n            }else{\\n                set.add(num);\\n            }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        Set<Integer> set = new HashSet<>();\\n        int ans[] = new int[A.length];\\n\\n        int count=0;\\n        for(int i=0;i<A.length;i++){\\n                if(A[i]==B[i]){\\n                    count++;\\n                }else{\\n                count = getCount(A[i],count,set);\\n                count = getCount(B[i],count,set);\\n                }\\n            ans[i]=count;        \\n            }\\n      return   ans;\\n    }\\n\\n    int getCount(int num,int count,Set<Integer> set){\\n            if(set.contains(num)){\\n                count++;\\n            }else{\\n                set.add(num);\\n            }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3878964,
                "title": "python-one-pass-set-solution",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n        seen = set()\\n        res = [0] * len(A)\\n        for i in range(len(A)):\\n            presented = 0\\n            if A[i] in seen:\\n                presented += 1\\n            seen.add(A[i])\\n            if B[i] in seen:\\n                presented += 1\\n            seen.add(B[i])\\n            res[i] = presented if i == 0 else presented + res[i - 1]\\n        return res \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n        seen = set()\\n        res = [0] * len(A)\\n        for i in range(len(A)):\\n            presented = 0\\n            if A[i] in seen:\\n                presented += 1\\n            seen.add(A[i])\\n            if B[i] in seen:\\n                presented += 1\\n            seen.add(B[i])\\n            res[i] = presented if i == 0 else presented + res[i - 1]\\n        return res \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3873944,
                "title": "systumm",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B)\\n    {\\n        vector<int> ans(B.size(),0);\\n        unordered_map<int,bool> map;\\n        for(int i=0;i<A.size();i++)\\n        {\\n            if(find(B.begin(),B.begin()+i+1,A[i])!=B.begin()+i+1)\\n                ans[i]++;\\n            ans[i]+=map[B[i]];\\n            map[A[i]]=true;\\n            if(i>0)\\n            ans[i]+=ans[i-1];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B)\\n    {\\n        vector<int> ans(B.size(),0);\\n        unordered_map<int,bool> map;\\n        for(int i=0;i<A.size();i++)\\n        {\\n            if(find(B.begin(),B.begin()+i+1,A[i])!=B.begin()+i+1)\\n                ans[i]++;\\n            ans[i]+=map[B[i]];\\n            map[A[i]]=true;\\n            if(i>0)\\n            ans[i]+=ans[i-1];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3873414,
                "title": "beats-98-24-of-users-with-c-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        \\n        int n = A.size();\\n        unordered_map<int,int>mp;\\n        vector<int>ans(n,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            int count = 0;\\n            //if(A[i]==B[i]) count++;\\n            if(mp[A[i]]>0) count++;\\n            else mp[A[i]]++;\\n            if(mp[B[i]]>0) count++;\\n            else mp[B[i]]++;\\n            if(i==0) ans[0]=count;\\n            else ans[i]=ans[i-1]+count;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        \\n        int n = A.size();\\n        unordered_map<int,int>mp;\\n        vector<int>ans(n,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            int count = 0;\\n            //if(A[i]==B[i]) count++;\\n            if(mp[A[i]]>0) count++;\\n            else mp[A[i]]++;\\n            if(mp[B[i]]>0) count++;\\n            else mp[B[i]]++;\\n            if(i==0) ans[0]=count;\\n            else ans[i]=ans[i-1]+count;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3859960,
                "title": "beginner-friendly-easy-hashtable-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        //int count = 0;\\n        vector<int> ans;\\n        map<int,int> mp;\\n        for(int i =0;i<A.size();i++){\\n            mp[A[i]]++;\\n            mp[B[i]]++;\\n            int count = 0;\\n            for(auto it: mp){\\n                if(it.second == 2){\\n                    count++;\\n                }\\n            }\\n            ans.push_back(count);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        //int count = 0;\\n        vector<int> ans;\\n        map<int,int> mp;\\n        for(int i =0;i<A.size();i++){\\n            mp[A[i]]++;\\n            mp[B[i]]++;\\n            int count = 0;\\n            for(auto it: mp){\\n                if(it.second == 2){\\n                    count++;\\n                }\\n            }\\n            ans.push_back(count);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3859005,
                "title": "c-easy-solution-using-both-map-and-set",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        // Unordered - Set\\n        \\n        vector<int> ans;\\n        unordered_set<int> st;\\n\\n        for(int i=0 ;i<A.size() ;i++){\\n            st.insert(A[i]);\\n            st.insert(B[i]);\\n\\n            ans.push_back(2*(i+1) - st.size());\\n        }\\n        return ans;\\n        \\n        // Unordered - Map\\n\\n        // unordered_map<int, int> mpa, mpb;\\n        // int common = 0;\\n        // vector<int> ans;\\n\\n        // for(int i=0 ;i<A.size() ;i++){\\n        //     mpa[A[i]]=1;\\n        //     if(mpb[A[i]])\\n        //     common++;\\n        //     else\\n        //     mpb[A[i]] = 1;\\n        //     if(mpa[B[i]])\\n        //     common++;\\n        //     else\\n        //     mpb[B[i]] = 1;\\n\\n        //     ans.push_back(common);\\n        // }\\n        // return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        // Unordered - Set\\n        \\n        vector<int> ans;\\n        unordered_set<int> st;\\n\\n        for(int i=0 ;i<A.size() ;i++){\\n            st.insert(A[i]);\\n            st.insert(B[i]);\\n\\n            ans.push_back(2*(i+1) - st.size());\\n        }\\n        return ans;\\n        \\n        // Unordered - Map\\n\\n        // unordered_map<int, int> mpa, mpb;\\n        // int common = 0;\\n        // vector<int> ans;\\n\\n        // for(int i=0 ;i<A.size() ;i++){\\n        //     mpa[A[i]]=1;\\n        //     if(mpb[A[i]])\\n        //     common++;\\n        //     else\\n        //     mpb[A[i]] = 1;\\n        //     if(mpa[B[i]])\\n        //     common++;\\n        //     else\\n        //     mpb[B[i]] = 1;\\n\\n        //     ans.push_back(common);\\n        // }\\n        // return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3854667,
                "title": "c-hash-table-time-o-n-space-o-n",
                "content": "# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        \\n        vector<int> ans(A.size());\\n        unordered_map<int, int> um;\\n        for(int i = 0; i < A.size(); ++i){\\n            //Add frequency of the current values\\n            um[A[i]]++;\\n            um[B[i]]++;\\n\\n            //Copy the previous answer, this is important since we dont need to find the numbers that we have already found, instead we will just increment if we found one again\\n            if(i > 0) ans[i] = ans[i-1];\\n\\n            //If the same value is in the same index, only add once\\n            if(A[i] == B[i]){\\n                ans[i]++;\\n                continue;\\n            }\\n\\n            //Else, if the count is 2 (meaning the other number has been found), add one to the answer\\n            if(um[A[i]] == 2) ans[i]++;\\n            if(um[B[i]] == 2) ans[i]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        \\n        vector<int> ans(A.size());\\n        unordered_map<int, int> um;\\n        for(int i = 0; i < A.size(); ++i){\\n            //Add frequency of the current values\\n            um[A[i]]++;\\n            um[B[i]]++;\\n\\n            //Copy the previous answer, this is important since we dont need to find the numbers that we have already found, instead we will just increment if we found one again\\n            if(i > 0) ans[i] = ans[i-1];\\n\\n            //If the same value is in the same index, only add once\\n            if(A[i] == B[i]){\\n                ans[i]++;\\n                continue;\\n            }\\n\\n            //Else, if the count is 2 (meaning the other number has been found), add one to the answer\\n            if(um[A[i]] == 2) ans[i]++;\\n            if(um[B[i]] == 2) ans[i]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3853201,
                "title": "easy-solution-using-set",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n \\n        c=[]\\n        \\n        for i in range(0,len(A)):\\n            if len(set(A[:i+1]) & set(B[:i+1]))>0:\\n                c.append(len(set(A[:i+1]) & set(B[:i+1])))\\n            else:\\n                c.append(0)\\n        return c\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n \\n        c=[]\\n        \\n        for i in range(0,len(A)):\\n            if len(set(A[:i+1]) & set(B[:i+1]))>0:\\n                c.append(len(set(A[:i+1]) & set(B[:i+1])))\\n            else:\\n                c.append(0)\\n        return c\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3850395,
                "title": "c-beats-100-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) \\n    {\\n        int size = A.size();\\n        vector<int> aux(size, -1);\\n\\n        for(int i = 0; i < size; i++)\\n        {\\n            if(aux[A[i] - 1] < i)\\n                aux[A[i] - 1] = i;\\n\\n            if(aux[B[i] - 1] < i)\\n                aux[B[i] - 1] = i;\\n        }\\n\\n        vector<int> C(size, 0);\\n\\n        for(int i = 0; i < size; i++)\\n        {\\n            ++C[aux[i]];\\n        }\\n\\n        for(int i = 1; i < size; i++)\\n        {\\n            C[i] += C[i - 1];\\n        }\\n\\n        return C;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) \\n    {\\n        int size = A.size();\\n        vector<int> aux(size, -1);\\n\\n        for(int i = 0; i < size; i++)\\n        {\\n            if(aux[A[i] - 1] < i)\\n                aux[A[i] - 1] = i;\\n\\n            if(aux[B[i] - 1] < i)\\n                aux[B[i] - 1] = i;\\n        }\\n\\n        vector<int> C(size, 0);\\n\\n        for(int i = 0; i < size; i++)\\n        {\\n            ++C[aux[i]];\\n        }\\n\\n        for(int i = 1; i < size; i++)\\n        {\\n            C[i] += C[i - 1];\\n        }\\n\\n        return C;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3848110,
                "title": "worst-complexities-but-simple-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>&a , vector<int>&b){\\n        vector<int>ans;\\n        for(int i=0; i<a.size(); i++){\\n            int c=0;\\n            unordered_set<int>st1,st2;\\n            for(int j=0; j<=i; j++){\\n                st1.insert(a[j]);\\n                st2.insert(b[j]);\\n            }\\n            for(auto i:st2){\\n                if(st1.find(i)!=st1.end()){\\n                    c++;\\n                }\\n            }\\n            ans.push_back(c);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>&a , vector<int>&b){\\n        vector<int>ans;\\n        for(int i=0; i<a.size(); i++){\\n            int c=0;\\n            unordered_set<int>st1,st2;\\n            for(int j=0; j<=i; j++){\\n                st1.insert(a[j]);\\n                st2.insert(b[j]);\\n            }\\n            for(auto i:st2){\\n                if(st1.find(i)!=st1.end()){\\n                    c++;\\n                }\\n            }\\n            ans.push_back(c);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3845955,
                "title": "c-solution-hashset-o-n-2",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$ O(n) $$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int[] FindThePrefixCommonArray(int[] A, int[] B) {\\n        int[] res = new int[A.Length];\\n        HashSet<int> hashSet = new();\\n\\n        for(int i=0; i<A.Length; i++){\\n            hashSet.Add(A[i]);\\n            int count = 0;\\n\\n            for(int j=0; j<=i; j++){\\n                if(hashSet.Contains(B[j])){\\n                    count++;\\n                }\\n            }\\n\\n            res[i] = count;\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] FindThePrefixCommonArray(int[] A, int[] B) {\\n        int[] res = new int[A.Length];\\n        HashSet<int> hashSet = new();\\n\\n        for(int i=0; i<A.Length; i++){\\n            hashSet.Add(A[i]);\\n            int count = 0;\\n\\n            for(int j=0; j<=i; j++){\\n                if(hashSet.Contains(B[j])){\\n                    count++;\\n                }\\n            }\\n\\n            res[i] = count;\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3845401,
                "title": "simple-implementation-using-dictionary",
                "content": "# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\npublic class Solution {\\n    public int[] FindThePrefixCommonArray(int[] A, int[] B) {\\n        int n = A.Length, prev = 0;\\n        int[] result = new int[n];\\n        Dictionary<int, int> lookup = new Dictionary<int,int>();\\n\\n        for(int i = 0; i < n; i++){\\n            int aNum = A[i];\\n            int bNum = B[i];\\n\\n            if(!lookup.ContainsKey(aNum))\\n                lookup.Add(aNum, 1);\\n            else\\n                lookup[aNum] += 1;\\n\\n            \\n            if(!lookup.ContainsKey(bNum))\\n                lookup.Add(bNum, 1);\\n            else\\n                lookup[bNum] += 1;\\n            \\n            if(lookup[aNum] == 2)\\n                result[i] += 1;\\n            \\n            if(lookup[bNum] == 2 && aNum != bNum)\\n                result[i] += 1;\\n\\n            result[i] += prev;\\n            prev = result[i];\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] FindThePrefixCommonArray(int[] A, int[] B) {\\n        int n = A.Length, prev = 0;\\n        int[] result = new int[n];\\n        Dictionary<int, int> lookup = new Dictionary<int,int>();\\n\\n        for(int i = 0; i < n; i++){\\n            int aNum = A[i];\\n            int bNum = B[i];\\n\\n            if(!lookup.ContainsKey(aNum))\\n                lookup.Add(aNum, 1);\\n            else\\n                lookup[aNum] += 1;\\n\\n            \\n            if(!lookup.ContainsKey(bNum))\\n                lookup.Add(bNum, 1);\\n            else\\n                lookup[bNum] += 1;\\n            \\n            if(lookup[aNum] == 2)\\n                result[i] += 1;\\n            \\n            if(lookup[bNum] == 2 && aNum != bNum)\\n                result[i] += 1;\\n\\n            result[i] += prev;\\n            prev = result[i];\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3843482,
                "title": "simple-c-solution-using-set",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        set<int> st;\\n        int n = A.size();\\n        vector<int> ans(n,0);\\n        ans[n-1] = n;\\n        int i;\\n        for(int i=0;i<n-1;i++){\\n            st.insert(A[i]);\\n            st.insert(B[i]);\\n            ans[i] = (i+1)*2 - st.size();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        set<int> st;\\n        int n = A.size();\\n        vector<int> ans(n,0);\\n        ans[n-1] = n;\\n        int i;\\n        for(int i=0;i<n-1;i++){\\n            st.insert(A[i]);\\n            st.insert(B[i]);\\n            ans[i] = (i+1)*2 - st.size();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3841827,
                "title": "100-beating-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        int[] arr=new int[A.length];\\n        int []set1=new int[A.length+1];\\n        int []set2=new int[A.length+1];\\n        int cnt=0;\\n        for(int i=0;i<A.length;i++){\\n           set1[A[i]]=1;\\n           set2[B[i]]=1;\\n            if(A[i]==B[i])cnt++;\\n            else{\\n            if(set1[B[i]]==1)cnt++;\\n            if(set2[A[i]]==1)cnt++;}\\n            arr[i]=cnt;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        int[] arr=new int[A.length];\\n        int []set1=new int[A.length+1];\\n        int []set2=new int[A.length+1];\\n        int cnt=0;\\n        for(int i=0;i<A.length;i++){\\n           set1[A[i]]=1;\\n           set2[B[i]]=1;\\n            if(A[i]==B[i])cnt++;\\n            else{\\n            if(set1[B[i]]==1)cnt++;\\n            if(set2[A[i]]==1)cnt++;}\\n            arr[i]=cnt;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3841773,
                "title": "c-beats-95-easy-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        int n=A.size();\\n        vector<int>ans(n);\\n        map<int,int>mp;\\n        int c=0;\\n        for(int i=0;i<n;i++){\\n            mp[A[i]]++;\\n            if(mp[A[i]]==2)\\n            c++;\\n            mp[B[i]]++;\\n            if(mp[B[i]]==2)\\n            c++;\\n            ans[i]=c;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        int n=A.size();\\n        vector<int>ans(n);\\n        map<int,int>mp;\\n        int c=0;\\n        for(int i=0;i<n;i++){\\n            mp[A[i]]++;\\n            if(mp[A[i]]==2)\\n            c++;\\n            mp[B[i]]++;\\n            if(mp[B[i]]==2)\\n            c++;\\n            ans[i]=c;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3840438,
                "title": "python-linear-in-time-and-space-simply-use-two-sets",
                "content": "# Intuition\\nUse Python\\'s set\\n\\n# Approach\\nIterate from the beginning. At each step add element from A to one set and element B to another set. The result at this point is size of the intersection of the sets.\\n\\n# Complexity\\n- Time complexity: O(N) : each set operation is constant time\\n\\n- Space complexity: O(N) : sets store every number once\\n\\n# Code\\n```\\nclass Solution:\\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n        sa, sb = set(), set()\\n        res = []\\n        for i in range(len(A)):\\n            sa.add(A[i])\\n            sb.add(B[i])\\n            res.append(len(sa & sb))\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n        sa, sb = set(), set()\\n        res = []\\n        for i in range(len(A)):\\n            sa.add(A[i])\\n            sb.add(B[i])\\n            res.append(len(sa & sb))\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3832737,
                "title": "easy-to-understand-c-solution-using-set-using-map-beats-97-50",
                "content": "\\n\\n# Code\\n```\\n\\n//Using set :- Beats 97.50% in Runtime of c++ user\\n//             Beats 46.50% in Memory of c++ user\\n\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        vector<int> ans;\\n        unordered_set<int> mp;\\n        for(int i=0;i<A.size();i++){\\n            int cnt=0;\\n            mp.insert(A[i]);\\n            for(int j=0;j<=i;j++){\\n                    if(mp.find(B[j]) != mp.end()) cnt++;\\n            }\\n            ans.push_back(cnt);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n# Code\\n\\n```\\n//Using Map :- Beats 95.90% Runtime of c++ user\\n//             Beats 68.17% in Memory of c++ user\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        int n = A.size();\\n        vector<int> ans(n,0);\\n        unordered_map<int,int> mp;\\n        int cnt=0;\\n        \\n        if(A[0] == B[0]){\\n            cnt++; \\n            ans[0] = cnt;\\n        }\\n        \\n        mp[A[0]]++;\\n        mp[B[0]]++;\\n        \\n        for(int i=1;i<n;i++){\\n           if(A[i] == B[i]) cnt++;\\n            else{\\n                if(mp.find(A[i]) != mp.end()) cnt++;\\n                if(mp.find(B[i]) != mp.end()) cnt++;\\n            }\\n            ans[i] = cnt;\\n            mp[A[i]]++;\\n            mp[B[i]]++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Ordered Map",
                    "Ordered Set"
                ],
                "code": "```\\n\\n//Using set :- Beats 97.50% in Runtime of c++ user\\n//             Beats 46.50% in Memory of c++ user\\n\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        vector<int> ans;\\n        unordered_set<int> mp;\\n        for(int i=0;i<A.size();i++){\\n            int cnt=0;\\n            mp.insert(A[i]);\\n            for(int j=0;j<=i;j++){\\n                    if(mp.find(B[j]) != mp.end()) cnt++;\\n            }\\n            ans.push_back(cnt);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\n//Using Map :- Beats 95.90% Runtime of c++ user\\n//             Beats 68.17% in Memory of c++ user\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        int n = A.size();\\n        vector<int> ans(n,0);\\n        unordered_map<int,int> mp;\\n        int cnt=0;\\n        \\n        if(A[0] == B[0]){\\n            cnt++; \\n            ans[0] = cnt;\\n        }\\n        \\n        mp[A[0]]++;\\n        mp[B[0]]++;\\n        \\n        for(int i=1;i<n;i++){\\n           if(A[i] == B[i]) cnt++;\\n            else{\\n                if(mp.find(A[i]) != mp.end()) cnt++;\\n                if(mp.find(B[i]) != mp.end()) cnt++;\\n            }\\n            ans[i] = cnt;\\n            mp[A[i]]++;\\n            mp[B[i]]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3829437,
                "title": "easy-kotlin-solution-with-just-one-set",
                "content": "# Code\\n```\\nclass Solution {\\n    fun findThePrefixCommonArray(A: IntArray, B: IntArray): IntArray {\\n        val result = IntArray(A.size)\\n        val set = mutableSetOf<Int>()\\n        var i = 0\\n        var commonPrefixCounter = 0\\n\\n        while (i < A.size) {\\n            if (!set.add(A[i]))\\n                commonPrefixCounter++\\n                \\n            if (!set.add(B[i]))\\n                commonPrefixCounter++\\n\\n            result[i] = commonPrefixCounter\\n            i++\\n        }\\n\\n        return result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    fun findThePrefixCommonArray(A: IntArray, B: IntArray): IntArray {\\n        val result = IntArray(A.size)\\n        val set = mutableSetOf<Int>()\\n        var i = 0\\n        var commonPrefixCounter = 0\\n\\n        while (i < A.size) {\\n            if (!set.add(A[i]))\\n                commonPrefixCounter++\\n                \\n            if (!set.add(B[i]))\\n                commonPrefixCounter++\\n\\n            result[i] = commonPrefixCounter\\n            i++\\n        }\\n\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3827242,
                "title": "simple-code-one-pass-using-set-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        HashSet<Integer> set = new HashSet<>();\\n        int n = A.length; \\n        int[] ans = new int[n];\\n        int count = 0;\\n\\n        for(int i = 0; i<n; i++){\\n            if(set.contains(A[i])){\\n                count++;\\n            }\\n            set.add(A[i]);\\n\\n            if(set.contains(B[i])){\\n                count++;\\n            }\\n            set.add(B[i]);\\n\\n            ans[i] = count;\\n\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        HashSet<Integer> set = new HashSet<>();\\n        int n = A.length; \\n        int[] ans = new int[n];\\n        int count = 0;\\n\\n        for(int i = 0; i<n; i++){\\n            if(set.contains(A[i])){\\n                count++;\\n            }\\n            set.add(A[i]);\\n\\n            if(set.contains(B[i])){\\n                count++;\\n            }\\n            set.add(B[i]);\\n\\n            ans[i] = count;\\n\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3826923,
                "title": "2657-find-the-prefix-common-array-of-two-arrays",
                "content": "# Intuition\\n<!-- using Hashset we can determine the common elements of both the arrays a and b at specified index -->\\n\\n# Approach\\n<!-- using Hashset and two for loops -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- )(n^2)-->\\n\\n- Space complexity:\\n<!-- O(n) -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] a, int[] b) {\\n        int[] c=new int[a.length];\\n\\t  HashSet<Integer> set=new HashSet<>();\\n\\t\\n\\t   for(int i=0;i<a.length;i++){\\n\\t       set.add(a[i]);\\n\\t       int co=0;\\n\\t     for(int j=0;j<=i;j++){\\n\\t         if(set.contains(b[j])) co++;\\n\\t     }\\n\\t     c[i]=co;\\n\\t       \\n\\t   }\\n\\t\\t return c;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] a, int[] b) {\\n        int[] c=new int[a.length];\\n\\t  HashSet<Integer> set=new HashSet<>();\\n\\t\\n\\t   for(int i=0;i<a.length;i++){\\n\\t       set.add(a[i]);\\n\\t       int co=0;\\n\\t     for(int j=0;j<=i;j++){\\n\\t         if(set.contains(b[j])) co++;\\n\\t     }\\n\\t     c[i]=co;\\n\\t       \\n\\t   }\\n\\t\\t return c;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1877149,
                "content": [
                    {
                        "username": "karan_cpp_py",
                        "content": "It must be tagged as easy"
                    },
                    {
                        "username": "pritul2020",
                        "content": "explain it bro ,i not understand it"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Just go for the brute force solution, n<=50 only :)"
                    },
                    {
                        "username": "bhargav1811",
                        "content": "Why is this testcase invalid?\\nA = [3,1,1,2,4]\\nB = [1,3,1,2,4]\\n\\nIs there any metion regarding this invalidness in question? Plz point me that !!\\nLeetcode gives this error for this testcase\\n`\\nexpected variables A[0]:1 and A[2]:1 to have different values\\n`\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement mentions that both A and B are permutations of n integers, where n is the length of A and B. \\n\\nA sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once. This is a fundamental property of a permutation.\\n\\nIn the case of A = [3,1,1,2,4], it\\'s not a valid permutation of the integers from 1 to 5 because it contains the number 1 twice and the number 5 is missing. So, this test case is indeed invalid because it violates the stated conditions of the problem. \\n\\nThus, the error message you see from Leetcode is correct and indicates that all elements in the permutation should be unique. In the problematic test case, the elements A[0] and A[2] are both 1, which is not allowed in a permutation."
                    },
                    {
                        "username": "botan",
                        "content": "\"You are given two 0-indexed integer permutations A and B of length n.\"\\n\"A sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once.\"\\n\\nYou\\'d have to fish for this information though, so your point is totally valid.\\nPerhaps a point should be added to the constraints about values of A and B being distinct."
                    },
                    {
                        "username": "botan",
                        "content": "I have the JS solution that beats 100% submissions by using 2 bitmasks.\nhttps://leetcode.com/problems/find-the-prefix-common-array-of-two-arrays/solutions/3477139/top-100-javascript-o-n-time-o-1-space-bitmask/"
                    },
                    {
                        "username": "Abhinav_Shaw",
                        "content": "what if the size of the arrays are not same?"
                    },
                    {
                        "username": "bparanj",
                        "content": "In the problem statement, it\\'s explicitly mentioned that the size of both arrays A and B is equal to n. \\n\\nIf the sizes of the two arrays are not the same, then it will violate the problem constraints, thus rendering the situation invalid for this problem. \\n\\nThe problem is designed to compare corresponding elements in the two arrays. If the arrays are of different sizes, this comparison would not be possible for all elements. Thus, the problem assumes and requires that both arrays are of the same size."
                    },
                    {
                        "username": "botan",
                        "content": "Then the longer array will just get a tail with the same value at each position.\\n\\nE.g. A = [1, 2, 3], B = [1, 2, 3, 4, 5, 6, 7], result = [1, 2, 3, 3, 3, 3, 3]"
                    },
                    {
                        "username": "aquaman55",
                        "content": "1 <= A.length == B.length == n <= 50 \\n\\nRead the constraint"
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "did it using a stack \\n"
                    },
                    {
                        "username": "sanchitdeshmukh23",
                        "content": "using hashmap was much more easier.\\n"
                    }
                ]
            },
            {
                "id": 1880977,
                "content": [
                    {
                        "username": "karan_cpp_py",
                        "content": "It must be tagged as easy"
                    },
                    {
                        "username": "pritul2020",
                        "content": "explain it bro ,i not understand it"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Just go for the brute force solution, n<=50 only :)"
                    },
                    {
                        "username": "bhargav1811",
                        "content": "Why is this testcase invalid?\\nA = [3,1,1,2,4]\\nB = [1,3,1,2,4]\\n\\nIs there any metion regarding this invalidness in question? Plz point me that !!\\nLeetcode gives this error for this testcase\\n`\\nexpected variables A[0]:1 and A[2]:1 to have different values\\n`\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement mentions that both A and B are permutations of n integers, where n is the length of A and B. \\n\\nA sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once. This is a fundamental property of a permutation.\\n\\nIn the case of A = [3,1,1,2,4], it\\'s not a valid permutation of the integers from 1 to 5 because it contains the number 1 twice and the number 5 is missing. So, this test case is indeed invalid because it violates the stated conditions of the problem. \\n\\nThus, the error message you see from Leetcode is correct and indicates that all elements in the permutation should be unique. In the problematic test case, the elements A[0] and A[2] are both 1, which is not allowed in a permutation."
                    },
                    {
                        "username": "botan",
                        "content": "\"You are given two 0-indexed integer permutations A and B of length n.\"\\n\"A sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once.\"\\n\\nYou\\'d have to fish for this information though, so your point is totally valid.\\nPerhaps a point should be added to the constraints about values of A and B being distinct."
                    },
                    {
                        "username": "botan",
                        "content": "I have the JS solution that beats 100% submissions by using 2 bitmasks.\nhttps://leetcode.com/problems/find-the-prefix-common-array-of-two-arrays/solutions/3477139/top-100-javascript-o-n-time-o-1-space-bitmask/"
                    },
                    {
                        "username": "Abhinav_Shaw",
                        "content": "what if the size of the arrays are not same?"
                    },
                    {
                        "username": "bparanj",
                        "content": "In the problem statement, it\\'s explicitly mentioned that the size of both arrays A and B is equal to n. \\n\\nIf the sizes of the two arrays are not the same, then it will violate the problem constraints, thus rendering the situation invalid for this problem. \\n\\nThe problem is designed to compare corresponding elements in the two arrays. If the arrays are of different sizes, this comparison would not be possible for all elements. Thus, the problem assumes and requires that both arrays are of the same size."
                    },
                    {
                        "username": "botan",
                        "content": "Then the longer array will just get a tail with the same value at each position.\\n\\nE.g. A = [1, 2, 3], B = [1, 2, 3, 4, 5, 6, 7], result = [1, 2, 3, 3, 3, 3, 3]"
                    },
                    {
                        "username": "aquaman55",
                        "content": "1 <= A.length == B.length == n <= 50 \\n\\nRead the constraint"
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "did it using a stack \\n"
                    },
                    {
                        "username": "sanchitdeshmukh23",
                        "content": "using hashmap was much more easier.\\n"
                    }
                ]
            },
            {
                "id": 1880320,
                "content": [
                    {
                        "username": "karan_cpp_py",
                        "content": "It must be tagged as easy"
                    },
                    {
                        "username": "pritul2020",
                        "content": "explain it bro ,i not understand it"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Just go for the brute force solution, n<=50 only :)"
                    },
                    {
                        "username": "bhargav1811",
                        "content": "Why is this testcase invalid?\\nA = [3,1,1,2,4]\\nB = [1,3,1,2,4]\\n\\nIs there any metion regarding this invalidness in question? Plz point me that !!\\nLeetcode gives this error for this testcase\\n`\\nexpected variables A[0]:1 and A[2]:1 to have different values\\n`\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement mentions that both A and B are permutations of n integers, where n is the length of A and B. \\n\\nA sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once. This is a fundamental property of a permutation.\\n\\nIn the case of A = [3,1,1,2,4], it\\'s not a valid permutation of the integers from 1 to 5 because it contains the number 1 twice and the number 5 is missing. So, this test case is indeed invalid because it violates the stated conditions of the problem. \\n\\nThus, the error message you see from Leetcode is correct and indicates that all elements in the permutation should be unique. In the problematic test case, the elements A[0] and A[2] are both 1, which is not allowed in a permutation."
                    },
                    {
                        "username": "botan",
                        "content": "\"You are given two 0-indexed integer permutations A and B of length n.\"\\n\"A sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once.\"\\n\\nYou\\'d have to fish for this information though, so your point is totally valid.\\nPerhaps a point should be added to the constraints about values of A and B being distinct."
                    },
                    {
                        "username": "botan",
                        "content": "I have the JS solution that beats 100% submissions by using 2 bitmasks.\nhttps://leetcode.com/problems/find-the-prefix-common-array-of-two-arrays/solutions/3477139/top-100-javascript-o-n-time-o-1-space-bitmask/"
                    },
                    {
                        "username": "Abhinav_Shaw",
                        "content": "what if the size of the arrays are not same?"
                    },
                    {
                        "username": "bparanj",
                        "content": "In the problem statement, it\\'s explicitly mentioned that the size of both arrays A and B is equal to n. \\n\\nIf the sizes of the two arrays are not the same, then it will violate the problem constraints, thus rendering the situation invalid for this problem. \\n\\nThe problem is designed to compare corresponding elements in the two arrays. If the arrays are of different sizes, this comparison would not be possible for all elements. Thus, the problem assumes and requires that both arrays are of the same size."
                    },
                    {
                        "username": "botan",
                        "content": "Then the longer array will just get a tail with the same value at each position.\\n\\nE.g. A = [1, 2, 3], B = [1, 2, 3, 4, 5, 6, 7], result = [1, 2, 3, 3, 3, 3, 3]"
                    },
                    {
                        "username": "aquaman55",
                        "content": "1 <= A.length == B.length == n <= 50 \\n\\nRead the constraint"
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "did it using a stack \\n"
                    },
                    {
                        "username": "sanchitdeshmukh23",
                        "content": "using hashmap was much more easier.\\n"
                    }
                ]
            },
            {
                "id": 1880083,
                "content": [
                    {
                        "username": "karan_cpp_py",
                        "content": "It must be tagged as easy"
                    },
                    {
                        "username": "pritul2020",
                        "content": "explain it bro ,i not understand it"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Just go for the brute force solution, n<=50 only :)"
                    },
                    {
                        "username": "bhargav1811",
                        "content": "Why is this testcase invalid?\\nA = [3,1,1,2,4]\\nB = [1,3,1,2,4]\\n\\nIs there any metion regarding this invalidness in question? Plz point me that !!\\nLeetcode gives this error for this testcase\\n`\\nexpected variables A[0]:1 and A[2]:1 to have different values\\n`\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement mentions that both A and B are permutations of n integers, where n is the length of A and B. \\n\\nA sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once. This is a fundamental property of a permutation.\\n\\nIn the case of A = [3,1,1,2,4], it\\'s not a valid permutation of the integers from 1 to 5 because it contains the number 1 twice and the number 5 is missing. So, this test case is indeed invalid because it violates the stated conditions of the problem. \\n\\nThus, the error message you see from Leetcode is correct and indicates that all elements in the permutation should be unique. In the problematic test case, the elements A[0] and A[2] are both 1, which is not allowed in a permutation."
                    },
                    {
                        "username": "botan",
                        "content": "\"You are given two 0-indexed integer permutations A and B of length n.\"\\n\"A sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once.\"\\n\\nYou\\'d have to fish for this information though, so your point is totally valid.\\nPerhaps a point should be added to the constraints about values of A and B being distinct."
                    },
                    {
                        "username": "botan",
                        "content": "I have the JS solution that beats 100% submissions by using 2 bitmasks.\nhttps://leetcode.com/problems/find-the-prefix-common-array-of-two-arrays/solutions/3477139/top-100-javascript-o-n-time-o-1-space-bitmask/"
                    },
                    {
                        "username": "Abhinav_Shaw",
                        "content": "what if the size of the arrays are not same?"
                    },
                    {
                        "username": "bparanj",
                        "content": "In the problem statement, it\\'s explicitly mentioned that the size of both arrays A and B is equal to n. \\n\\nIf the sizes of the two arrays are not the same, then it will violate the problem constraints, thus rendering the situation invalid for this problem. \\n\\nThe problem is designed to compare corresponding elements in the two arrays. If the arrays are of different sizes, this comparison would not be possible for all elements. Thus, the problem assumes and requires that both arrays are of the same size."
                    },
                    {
                        "username": "botan",
                        "content": "Then the longer array will just get a tail with the same value at each position.\\n\\nE.g. A = [1, 2, 3], B = [1, 2, 3, 4, 5, 6, 7], result = [1, 2, 3, 3, 3, 3, 3]"
                    },
                    {
                        "username": "aquaman55",
                        "content": "1 <= A.length == B.length == n <= 50 \\n\\nRead the constraint"
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "did it using a stack \\n"
                    },
                    {
                        "username": "sanchitdeshmukh23",
                        "content": "using hashmap was much more easier.\\n"
                    }
                ]
            },
            {
                "id": 1877672,
                "content": [
                    {
                        "username": "karan_cpp_py",
                        "content": "It must be tagged as easy"
                    },
                    {
                        "username": "pritul2020",
                        "content": "explain it bro ,i not understand it"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Just go for the brute force solution, n<=50 only :)"
                    },
                    {
                        "username": "bhargav1811",
                        "content": "Why is this testcase invalid?\\nA = [3,1,1,2,4]\\nB = [1,3,1,2,4]\\n\\nIs there any metion regarding this invalidness in question? Plz point me that !!\\nLeetcode gives this error for this testcase\\n`\\nexpected variables A[0]:1 and A[2]:1 to have different values\\n`\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement mentions that both A and B are permutations of n integers, where n is the length of A and B. \\n\\nA sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once. This is a fundamental property of a permutation.\\n\\nIn the case of A = [3,1,1,2,4], it\\'s not a valid permutation of the integers from 1 to 5 because it contains the number 1 twice and the number 5 is missing. So, this test case is indeed invalid because it violates the stated conditions of the problem. \\n\\nThus, the error message you see from Leetcode is correct and indicates that all elements in the permutation should be unique. In the problematic test case, the elements A[0] and A[2] are both 1, which is not allowed in a permutation."
                    },
                    {
                        "username": "botan",
                        "content": "\"You are given two 0-indexed integer permutations A and B of length n.\"\\n\"A sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once.\"\\n\\nYou\\'d have to fish for this information though, so your point is totally valid.\\nPerhaps a point should be added to the constraints about values of A and B being distinct."
                    },
                    {
                        "username": "botan",
                        "content": "I have the JS solution that beats 100% submissions by using 2 bitmasks.\nhttps://leetcode.com/problems/find-the-prefix-common-array-of-two-arrays/solutions/3477139/top-100-javascript-o-n-time-o-1-space-bitmask/"
                    },
                    {
                        "username": "Abhinav_Shaw",
                        "content": "what if the size of the arrays are not same?"
                    },
                    {
                        "username": "bparanj",
                        "content": "In the problem statement, it\\'s explicitly mentioned that the size of both arrays A and B is equal to n. \\n\\nIf the sizes of the two arrays are not the same, then it will violate the problem constraints, thus rendering the situation invalid for this problem. \\n\\nThe problem is designed to compare corresponding elements in the two arrays. If the arrays are of different sizes, this comparison would not be possible for all elements. Thus, the problem assumes and requires that both arrays are of the same size."
                    },
                    {
                        "username": "botan",
                        "content": "Then the longer array will just get a tail with the same value at each position.\\n\\nE.g. A = [1, 2, 3], B = [1, 2, 3, 4, 5, 6, 7], result = [1, 2, 3, 3, 3, 3, 3]"
                    },
                    {
                        "username": "aquaman55",
                        "content": "1 <= A.length == B.length == n <= 50 \\n\\nRead the constraint"
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "did it using a stack \\n"
                    },
                    {
                        "username": "sanchitdeshmukh23",
                        "content": "using hashmap was much more easier.\\n"
                    }
                ]
            },
            {
                "id": 1876990,
                "content": [
                    {
                        "username": "karan_cpp_py",
                        "content": "It must be tagged as easy"
                    },
                    {
                        "username": "pritul2020",
                        "content": "explain it bro ,i not understand it"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Just go for the brute force solution, n<=50 only :)"
                    },
                    {
                        "username": "bhargav1811",
                        "content": "Why is this testcase invalid?\\nA = [3,1,1,2,4]\\nB = [1,3,1,2,4]\\n\\nIs there any metion regarding this invalidness in question? Plz point me that !!\\nLeetcode gives this error for this testcase\\n`\\nexpected variables A[0]:1 and A[2]:1 to have different values\\n`\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement mentions that both A and B are permutations of n integers, where n is the length of A and B. \\n\\nA sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once. This is a fundamental property of a permutation.\\n\\nIn the case of A = [3,1,1,2,4], it\\'s not a valid permutation of the integers from 1 to 5 because it contains the number 1 twice and the number 5 is missing. So, this test case is indeed invalid because it violates the stated conditions of the problem. \\n\\nThus, the error message you see from Leetcode is correct and indicates that all elements in the permutation should be unique. In the problematic test case, the elements A[0] and A[2] are both 1, which is not allowed in a permutation."
                    },
                    {
                        "username": "botan",
                        "content": "\"You are given two 0-indexed integer permutations A and B of length n.\"\\n\"A sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once.\"\\n\\nYou\\'d have to fish for this information though, so your point is totally valid.\\nPerhaps a point should be added to the constraints about values of A and B being distinct."
                    },
                    {
                        "username": "botan",
                        "content": "I have the JS solution that beats 100% submissions by using 2 bitmasks.\nhttps://leetcode.com/problems/find-the-prefix-common-array-of-two-arrays/solutions/3477139/top-100-javascript-o-n-time-o-1-space-bitmask/"
                    },
                    {
                        "username": "Abhinav_Shaw",
                        "content": "what if the size of the arrays are not same?"
                    },
                    {
                        "username": "bparanj",
                        "content": "In the problem statement, it\\'s explicitly mentioned that the size of both arrays A and B is equal to n. \\n\\nIf the sizes of the two arrays are not the same, then it will violate the problem constraints, thus rendering the situation invalid for this problem. \\n\\nThe problem is designed to compare corresponding elements in the two arrays. If the arrays are of different sizes, this comparison would not be possible for all elements. Thus, the problem assumes and requires that both arrays are of the same size."
                    },
                    {
                        "username": "botan",
                        "content": "Then the longer array will just get a tail with the same value at each position.\\n\\nE.g. A = [1, 2, 3], B = [1, 2, 3, 4, 5, 6, 7], result = [1, 2, 3, 3, 3, 3, 3]"
                    },
                    {
                        "username": "aquaman55",
                        "content": "1 <= A.length == B.length == n <= 50 \\n\\nRead the constraint"
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "did it using a stack \\n"
                    },
                    {
                        "username": "sanchitdeshmukh23",
                        "content": "using hashmap was much more easier.\\n"
                    }
                ]
            }
        ]
    }
]